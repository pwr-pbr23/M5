/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive serde2 typeinfo
import java lang reflect field
import java lang reflect genericarraytype
import java lang reflect method
import java lang reflect parameterizedtype
import java lang reflect type
import java util arraylist
import java util hashmap
import java util linkedlist
import java util list
import java util map
import java util concurrent concurrenthashmap
import org apache commons lang stringutils
import org apache hadoop hive common type hivevarchar
import org apache hadoop hive serde serdeconstants
import org apache hadoop hive serde2 objectinspector listobjectinspector
import org apache hadoop hive serde2 objectinspector mapobjectinspector
import org apache hadoop hive serde2 objectinspector objectinspector
import org apache hadoop hive serde2 objectinspector objectinspector category
import org apache hadoop hive serde2 objectinspector objectinspectorfactory
import org apache hadoop hive serde2 objectinspector objectinspectorutils
import org apache hadoop hive serde2 objectinspector primitiveobjectinspector
import org apache hadoop hive serde2 objectinspector primitiveobjectinspector primitivecategory
import org apache hadoop hive serde2 objectinspector structfield
import org apache hadoop hive serde2 objectinspector structobjectinspector
import org apache hadoop hive serde2 objectinspector unionobjectinspector
import org apache hadoop hive serde2 objectinspector primitive primitiveobjectinspectorfactory
import org apache hadoop hive serde2 objectinspector primitive primitiveobjectinspectorutils
import org apache hadoop hive serde2 objectinspector primitive primitiveobjectinspectorutils primitivetypeentry
/**
* typeinfoutils.
*
*/
public final class typeinfoutils
private typeinfoutils
// prevent instantiation
/**
* return the extended typeinfo from a java type. by extended typeinfo, we
* allow unknowntype for java.lang.object.
*
* @param t
*          the java type.
* @param m
*          the method, only used for generating error messages.
*/
private static typeinfo getextendedtypeinfofromjavatype type t  method m
if  t    object class
return typeinfofactory unknowntypeinfo
if  t instanceof parameterizedtype
parameterizedtype pt    parameterizedtype  t
// list?
if  list class     class<?>  pt getrawtype
arraylist class     class<?>  pt getrawtype
return typeinfofactory getlisttypeinfo getextendedtypeinfofromjavatype
pt getactualtypearguments    m
// map?
if  map class     class<?>  pt getrawtype
hashmap class     class<?>  pt getrawtype
return typeinfofactory getmaptypeinfo getextendedtypeinfofromjavatype
pt getactualtypearguments    m
getextendedtypeinfofromjavatype pt getactualtypearguments    m
// otherwise convert t to rawtype so we will fall into the following if
// block.
t   pt getrawtype
// must be a class.
if    t instanceof class
throw new runtimeexception     t
m
class<?> c    class<?>  t
// java primitive type?
if  primitiveobjectinspectorutils isprimitivejavatype c
return typeinfoutils
gettypeinfofromobjectinspector primitiveobjectinspectorfactory
getprimitivejavaobjectinspector primitiveobjectinspectorutils
gettypeentryfromprimitivejavatype c  primitivecategory
// java primitive class?
if  primitiveobjectinspectorutils isprimitivejavaclass c
return typeinfoutils
gettypeinfofromobjectinspector primitiveobjectinspectorfactory
getprimitivejavaobjectinspector primitiveobjectinspectorutils
gettypeentryfromprimitivejavaclass c  primitivecategory
// primitive writable class?
if  primitiveobjectinspectorutils isprimitivewritableclass c
return typeinfoutils
gettypeinfofromobjectinspector primitiveobjectinspectorfactory
getprimitivewritableobjectinspector primitiveobjectinspectorutils
gettypeentryfromprimitivewritableclass c  primitivecategory
// must be a struct
field fields   objectinspectorutils getdeclarednonstaticfields c
arraylist<string> fieldnames   new arraylist<string> fields length
arraylist<typeinfo> fieldtypeinfos   new arraylist<typeinfo> fields length
for  field field   fields
fieldnames add field getname
fieldtypeinfos add getextendedtypeinfofromjavatype
field getgenerictype    m
return typeinfofactory getstructtypeinfo fieldnames  fieldtypeinfos
/**
* returns the array element type, if the type is an array (object[]), or
* genericarraytype (map<string,string>[]). otherwise return null.
*/
public static type getarrayelementtype type t
if  t instanceof class      class<?>  t  isarray
class<?> arrayclass    class<?>  t
return arrayclass getcomponenttype
else if  t instanceof genericarraytype
genericarraytype arraytype    genericarraytype  t
return arraytype getgenericcomponenttype
return null
/**
* get the parameter typeinfo for a method.
*
* @param size
*          in case the last parameter of method is an array, we will try to
*          return a list<typeinfo> with the specified size by repeating the
*          element of the array at the end. in case the size is smaller than
*          the minimum possible number of arguments for the method, null will
*          be returned.
*/
public static list<typeinfo> getparametertypeinfos method m  int size
type methodparametertypes   m getgenericparametertypes
// whether the method takes variable-length arguments
// whether the method takes an array like object[],
// or string[] etc in the last argument.
type lastparaelementtype   typeinfoutils
getarrayelementtype methodparametertypes length    0 ? null
methodparametertypes
boolean isvariablelengthargument    lastparaelementtype    null
list<typeinfo> typeinfos   null
if   isvariablelengthargument
// normal case, no variable-length arguments
if  size    methodparametertypes length
return null
typeinfos   new arraylist<typeinfo> methodparametertypes length
for  type methodparametertype   methodparametertypes
typeinfos add getextendedtypeinfofromjavatype methodparametertype  m
else
// variable-length arguments
if  size < methodparametertypes length   1
return null
typeinfos   new arraylist<typeinfo> size
for  int i   0  i < methodparametertypes length   1  i
typeinfos add getextendedtypeinfofromjavatype methodparametertypes
m
for  int i   methodparametertypes length   1  i < size  i
typeinfos add getextendedtypeinfofromjavatype lastparaelementtype  m
return typeinfos
public static boolean hasparameters string typename
int idx   typename indexof
if  idx     1
return false
else
return true
public static string getbasename string typename
int idx   typename indexof
if  idx     1
return typename
else
return typename substring 0  idx
/**
* returns true if both typeinfos are of primitive type, and the primitive category matches.
* @param ti1
* @param ti2
* @return
*/
public static boolean doprimitivecategoriesmatch typeinfo ti1  typeinfo ti2
if  ti1 getcategory      category primitive    ti2 getcategory      category primitive
if    primitivetypeinfo ti1  getprimitivecategory
primitivetypeinfo ti2  getprimitivecategory
return true
return false
/**
* parse a recursive typeinfo list string. for example, the following inputs
* are valid inputs:
* "int,string,map<string,int>,list<map<int,list<string>>>,list<struct<a:int,b:string>>"
* the separators between typeinfos can be ",", ":", or ";".
*
* in order to use this class: typeinfoparser parser = new
* typeinfoparser("int,string"); arraylist<typeinfo> typeinfos =
* parser.parsetypeinfos();
*/
private static class typeinfoparser
private static class token
public int position
public string text
public boolean istype
@override
public string tostring
return     position       text
private static boolean istypechar char c
return character isletterordigit c     c         c
/**
* tokenize the typeinfostring. the rule is simple: all consecutive
* alphadigits and '_', '.' are in one token, and all other characters are
* one character per token.
*
* tokenize("map<int,string>") should return
* ["map","<","int",",","string",">"]
*/
private static arraylist<token> tokenize string typeinfostring
arraylist<token> tokens   new arraylist<token> 0
int begin   0
int end   1
while  end <  typeinfostring length
// last character ends a token?
if  end    typeinfostring length
istypechar typeinfostring charat end   1
istypechar typeinfostring charat end
token t   new token
t position   begin
t text   typeinfostring substring begin  end
t istype   istypechar typeinfostring charat begin
tokens add t
begin   end
end
return tokens
public typeinfoparser string typeinfostring
this typeinfostring   typeinfostring
typeinfotokens   tokenize typeinfostring
private final string typeinfostring
private final arraylist<token> typeinfotokens
private arraylist<typeinfo> typeinfos
private int itoken
public arraylist<typeinfo> parsetypeinfos
typeinfos   new arraylist<typeinfo>
itoken   0
while  itoken < typeinfotokens size
typeinfos add parsetype
if  itoken < typeinfotokens size
token separator   typeinfotokens get itoken
if    equals separator text       equals separator text
equals separator text
itoken
else
throw new illegalargumentexception
separator position       typeinfostring
typeinfotokens
return typeinfos
private token peek
if  itoken < typeinfotokens size
return typeinfotokens get itoken
else
return null
private token expect string item
return expect item  null
private token expect string item  string alternative
if  itoken >  typeinfotokens size
throw new illegalargumentexception     item
typeinfostring
token t   typeinfotokens get itoken
if  item equals
if   serdeconstants list_type_name equals t text
serdeconstants map_type_name equals t text
serdeconstants struct_type_name equals t text
serdeconstants union_type_name equals t text
null    primitiveobjectinspectorutils
gettypeentryfromtypename t text
t text equals alternative
throw new illegalargumentexception     item
t position
typeinfostring       t text
else if  item equals
if   t istype     t text equals alternative
throw new illegalargumentexception     item
t position
typeinfostring       t text
else
if   item equals t text      t text equals alternative
throw new illegalargumentexception     item
t position
typeinfostring       t text
itoken
return t
private string parseparams
list<string> params   new linkedlist<string>
token t   peek
if  t    null    t text equals
expect
// checking for null in the for-loop condition prevents null-ptr exception
// and allows us to fail more gracefully with a parsing error.
for t   peek     t    null      t text equals     t   expect
params add expect    text
if  params size      0
throw new illegalargumentexception
typeinfostring
return params toarray new string
private typeinfo parsetype
token t   expect
// is this a primitive type?
primitivetypeentry primitivetype   primitiveobjectinspectorutils
gettypeentryfromtypename t text
if  primitivetype    null
primitivetype primitivecategory equals primitivecategory unknown
if  primitivetype isparameterized
primitivetype   primitivetype addparameters parseparams
// if type has qualifiers, the typeinfo needs them in its type string
return typeinfofactory getprimitivetypeinfo primitivetype tostring
// is this a list type?
if  serdeconstants list_type_name equals t text
expect
typeinfo listelementtype   parsetype
expect
return typeinfofactory getlisttypeinfo listelementtype
// is this a map type?
if  serdeconstants map_type_name equals t text
expect
typeinfo mapkeytype   parsetype
expect
typeinfo mapvaluetype   parsetype
expect
return typeinfofactory getmaptypeinfo mapkeytype  mapvaluetype
// is this a struct type?
if  serdeconstants struct_type_name equals t text
arraylist<string> fieldnames   new arraylist<string>
arraylist<typeinfo> fieldtypeinfos   new arraylist<typeinfo>
boolean first   true
do
if  first
expect
first   false
else
token separator   expect
if  separator text equals
// end of struct
break
token name   expect
fieldnames add name text
expect
fieldtypeinfos add parsetype
while  true
return typeinfofactory getstructtypeinfo fieldnames  fieldtypeinfos
// is this a union type?
if  serdeconstants union_type_name equals t text
list<typeinfo> objecttypeinfos   new arraylist<typeinfo>
boolean first   true
do
if  first
expect
first   false
else
token separator   expect
if  separator text equals
// end of union
break
objecttypeinfos add parsetype
while  true
return typeinfofactory getuniontypeinfo objecttypeinfos
throw new runtimeexception
t position       typeinfostring
public primitiveparts parseprimitiveparts
primitiveparts parts   new primitiveparts
token t   expect
parts typename   t text
parts typeparams   parseparams
return parts
public static class primitiveparts
public string  typename
public string typeparams
/**
* make some of the typeinfo parsing available as a utility.
*/
public static primitiveparts parseprimitiveparts string typeinfostring
typeinfoparser parser   new typeinfoparser typeinfostring
return parser parseprimitiveparts
static map<typeinfo  objectinspector> cachedstandardobjectinspector
new concurrenthashmap<typeinfo  objectinspector>
/**
* returns the standard object inspector that can be used to translate an
* object of that typeinfo to a standard object type.
*/
public static objectinspector getstandardwritableobjectinspectorfromtypeinfo
typeinfo typeinfo
objectinspector result   cachedstandardobjectinspector get typeinfo
if  result    null
switch  typeinfo getcategory
case primitive
result   primitiveobjectinspectorfactory getprimitivewritableobjectinspector
primitivetypeinfo  typeinfo
break
case list
objectinspector elementobjectinspector
getstandardwritableobjectinspectorfromtypeinfo   listtypeinfo  typeinfo
getlistelementtypeinfo
result   objectinspectorfactory
getstandardlistobjectinspector elementobjectinspector
break
case map
maptypeinfo maptypeinfo    maptypeinfo  typeinfo
objectinspector keyobjectinspector
getstandardwritableobjectinspectorfromtypeinfo maptypeinfo getmapkeytypeinfo
objectinspector valueobjectinspector
getstandardwritableobjectinspectorfromtypeinfo maptypeinfo getmapvaluetypeinfo
result   objectinspectorfactory getstandardmapobjectinspector
keyobjectinspector  valueobjectinspector
break
case struct
structtypeinfo structtypeinfo    structtypeinfo  typeinfo
list<string> fieldnames   structtypeinfo getallstructfieldnames
list<typeinfo> fieldtypeinfos   structtypeinfo
getallstructfieldtypeinfos
list<objectinspector> fieldobjectinspectors   new arraylist<objectinspector>
fieldtypeinfos size
for  int i   0  i < fieldtypeinfos size    i
fieldobjectinspectors
add getstandardwritableobjectinspectorfromtypeinfo fieldtypeinfos
get i
result   objectinspectorfactory getstandardstructobjectinspector
fieldnames  fieldobjectinspectors
break
case union
uniontypeinfo uniontypeinfo    uniontypeinfo  typeinfo
list<typeinfo> objecttypeinfos   uniontypeinfo
getallunionobjecttypeinfos
list<objectinspector> fieldobjectinspectors
new arraylist<objectinspector> objecttypeinfos size
for  int i   0  i < objecttypeinfos size    i
fieldobjectinspectors
add getstandardwritableobjectinspectorfromtypeinfo objecttypeinfos
get i
result   objectinspectorfactory getstandardunionobjectinspector
fieldobjectinspectors
break
default
result   null
cachedstandardobjectinspector put typeinfo  result
return result
static map<typeinfo  objectinspector> cachedstandardjavaobjectinspector
new concurrenthashmap<typeinfo  objectinspector>
/**
* returns the standard object inspector that can be used to translate an
* object of that typeinfo to a standard object type.
*/
public static objectinspector getstandardjavaobjectinspectorfromtypeinfo
typeinfo typeinfo
objectinspector result   cachedstandardjavaobjectinspector get typeinfo
if  result    null
switch  typeinfo getcategory
case primitive
// note: we use javaprimitiveobjectinspector instead of
// standardprimitiveobjectinspector
result   primitiveobjectinspectorfactory
getprimitivejavaobjectinspector  primitivetypeinfo  typeinfo
break
case list
objectinspector elementobjectinspector
getstandardjavaobjectinspectorfromtypeinfo   listtypeinfo  typeinfo
getlistelementtypeinfo
result   objectinspectorfactory
getstandardlistobjectinspector elementobjectinspector
break
case map
maptypeinfo maptypeinfo    maptypeinfo  typeinfo
objectinspector keyobjectinspector   getstandardjavaobjectinspectorfromtypeinfo maptypeinfo
getmapkeytypeinfo
objectinspector valueobjectinspector
getstandardjavaobjectinspectorfromtypeinfo maptypeinfo getmapvaluetypeinfo
result   objectinspectorfactory getstandardmapobjectinspector
keyobjectinspector  valueobjectinspector
break
case struct
structtypeinfo structypeinfo    structtypeinfo  typeinfo
list<string> fieldnames   structypeinfo getallstructfieldnames
list<typeinfo> fieldtypeinfos   structypeinfo
getallstructfieldtypeinfos
list<objectinspector> fieldobjectinspectors   new arraylist<objectinspector>
fieldtypeinfos size
for  int i   0  i < fieldtypeinfos size    i
fieldobjectinspectors
add getstandardjavaobjectinspectorfromtypeinfo fieldtypeinfos
get i
result   objectinspectorfactory getstandardstructobjectinspector
fieldnames  fieldobjectinspectors
break
case union
uniontypeinfo uniontypeinfo    uniontypeinfo  typeinfo
list<typeinfo> objecttypeinfos   uniontypeinfo
getallunionobjecttypeinfos
list<objectinspector> fieldobjectinspectors
new arraylist<objectinspector> objecttypeinfos size
for  int i   0  i < objecttypeinfos size    i
fieldobjectinspectors
add getstandardjavaobjectinspectorfromtypeinfo objecttypeinfos
get i
result   objectinspectorfactory getstandardunionobjectinspector
fieldobjectinspectors
break
default
result   null
cachedstandardjavaobjectinspector put typeinfo  result
return result
/**
* get the typeinfo object from the objectinspector object by recursively
* going into the objectinspector structure.
*/
public static typeinfo gettypeinfofromobjectinspector objectinspector oi
// optimization for later.
// if (oi instanceof typeinfobasedobjectinspector) {
// typeinfobasedobjectinspector typeinfobasedobjectinspector =
// (objectinspector)oi;
// return typeinfobasedobjectinspector.gettypeinfo();
// }
if  oi    null
return null
// recursively going into objectinspector structure
typeinfo result   null
switch  oi getcategory
case primitive
primitiveobjectinspector poi    primitiveobjectinspector  oi
result   typeinfofactory getprimitivetypeinfo poi gettypename
break
case list
listobjectinspector loi    listobjectinspector  oi
result   typeinfofactory
getlisttypeinfo gettypeinfofromobjectinspector loi
getlistelementobjectinspector
break
case map
mapobjectinspector moi    mapobjectinspector  oi
result   typeinfofactory getmaptypeinfo
gettypeinfofromobjectinspector moi getmapkeyobjectinspector
gettypeinfofromobjectinspector moi getmapvalueobjectinspector
break
case struct
structobjectinspector soi    structobjectinspector  oi
list<? extends structfield> fields   soi getallstructfieldrefs
list<string> fieldnames   new arraylist<string> fields size
list<typeinfo> fieldtypeinfos   new arraylist<typeinfo> fields size
for  structfield f   fields
fieldnames add f getfieldname
fieldtypeinfos add gettypeinfofromobjectinspector f
getfieldobjectinspector
result   typeinfofactory getstructtypeinfo fieldnames  fieldtypeinfos
break
case union
unionobjectinspector uoi    unionobjectinspector  oi
list<typeinfo> objecttypeinfos   new arraylist<typeinfo>
for  objectinspector eoi   uoi getobjectinspectors
objecttypeinfos add gettypeinfofromobjectinspector eoi
result   typeinfofactory getuniontypeinfo objecttypeinfos
break
default
throw new runtimeexception
return result
public static arraylist<typeinfo> gettypeinfosfromtypestring string typestring
typeinfoparser parser   new typeinfoparser typestring
return parser parsetypeinfos
public static typeinfo gettypeinfofromtypestring string typestring
typeinfoparser parser   new typeinfoparser typestring
return parser parsetypeinfos   get 0
/**
* given two types, determine whether conversion needs to occur to compare the two types.
* this is needed for cases like varchar, where the typeinfo for varchar(10) != varchar(5),
* but there would be no need to have to convert to compare these values.
* @param typea
* @param typeb
* @return
*/
public static boolean isconversionrequiredforcomparison typeinfo typea  typeinfo typeb
if  typea    typeb
return false
if  typeinfoutils doprimitivecategoriesmatch typea   typeb
return false
return true
/**
* return the character length of the type
* @param typeinfo
* @return
*/
public static int getcharacterlengthfortype primitivetypeinfo typeinfo
switch  typeinfo getprimitivecategory
case string
return hivevarchar max_varchar_length
case varchar
varchartypeparams varcharparams    varchartypeparams  typeinfo gettypeparams
if  varcharparams    null
throw new runtimeexception
return varcharparams getlength
default
return 0