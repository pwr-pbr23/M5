/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive metastore
import static org apache commons lang stringutils join
import static org apache hadoop hive metastore metastoreutils default_database_comment
import static org apache hadoop hive metastore metastoreutils default_database_name
import static org apache hadoop hive metastore metastoreutils validatename
import java io ioexception
import java util abstractmap
import java util arraylist
import java util arrays
import java util collections
import java util formatter
import java util hashmap
import java util hashset
import java util iterator
import java util linkedhashmap
import java util list
import java util map
import java util map entry
import java util properties
import java util set
import java util timer
import java util regex pattern
import org apache commons cli optionbuilder
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop fs path
import org apache hadoop hive common logutils
import org apache hadoop hive common logutils loginitializationexception
import org apache hadoop hive common classification interfaceaudience
import org apache hadoop hive common classification interfacestability
import org apache hadoop hive common cli commonclioptions
import org apache hadoop hive common metrics metrics
import org apache hadoop hive conf hiveconf
import org apache hadoop hive conf hiveconf confvars
import org apache hadoop hive metastore api alreadyexistsexception
import org apache hadoop hive metastore api columnstatistics
import org apache hadoop hive metastore api columnstatisticsdesc
import org apache hadoop hive metastore api columnstatisticsobj
import org apache hadoop hive metastore api configvalsecurityexception
import org apache hadoop hive metastore api database
import org apache hadoop hive metastore api environmentcontext
import org apache hadoop hive metastore api fieldschema
import org apache hadoop hive metastore api hiveobjectprivilege
import org apache hadoop hive metastore api hiveobjectref
import org apache hadoop hive metastore api hiveobjecttype
import org apache hadoop hive metastore api index
import org apache hadoop hive metastore api indexalreadyexistsexception
import org apache hadoop hive metastore api invalidinputexception
import org apache hadoop hive metastore api invalidobjectexception
import org apache hadoop hive metastore api invalidoperationexception
import org apache hadoop hive metastore api invalidpartitionexception
import org apache hadoop hive metastore api metaexception
import org apache hadoop hive metastore api nosuchobjectexception
import org apache hadoop hive metastore api partition
import org apache hadoop hive metastore api partitioneventtype
import org apache hadoop hive metastore api principalprivilegeset
import org apache hadoop hive metastore api principaltype
import org apache hadoop hive metastore api privilegebag
import org apache hadoop hive metastore api privilegegrantinfo
import org apache hadoop hive metastore api role
import org apache hadoop hive metastore api skewedinfo
import org apache hadoop hive metastore api table
import org apache hadoop hive metastore api thrifthivemetastore
import org apache hadoop hive metastore api type
import org apache hadoop hive metastore api unknowndbexception
import org apache hadoop hive metastore api unknownpartitionexception
import org apache hadoop hive metastore api unknowntableexception
import org apache hadoop hive metastore api hive_metastoreconstants
import org apache hadoop hive metastore events addpartitionevent
import org apache hadoop hive metastore events alterpartitionevent
import org apache hadoop hive metastore events altertableevent
import org apache hadoop hive metastore events createdatabaseevent
import org apache hadoop hive metastore events createtableevent
import org apache hadoop hive metastore events dropdatabaseevent
import org apache hadoop hive metastore events droppartitionevent
import org apache hadoop hive metastore events droptableevent
import org apache hadoop hive metastore events eventcleanertask
import org apache hadoop hive metastore events loadpartitiondoneevent
import org apache hadoop hive metastore events preaddpartitionevent
import org apache hadoop hive metastore events prealterpartitionevent
import org apache hadoop hive metastore events prealtertableevent
import org apache hadoop hive metastore events precreatedatabaseevent
import org apache hadoop hive metastore events precreatetableevent
import org apache hadoop hive metastore events predropdatabaseevent
import org apache hadoop hive metastore events predroppartitionevent
import org apache hadoop hive metastore events predroptableevent
import org apache hadoop hive metastore events preeventcontext
import org apache hadoop hive metastore events preloadpartitiondoneevent
import org apache hadoop hive metastore model mdbprivilege
import org apache hadoop hive metastore model mglobalprivilege
import org apache hadoop hive metastore model mpartitioncolumnprivilege
import org apache hadoop hive metastore model mpartitionprivilege
import org apache hadoop hive metastore model mrole
import org apache hadoop hive metastore model mrolemap
import org apache hadoop hive metastore model mtablecolumnprivilege
import org apache hadoop hive metastore model mtableprivilege
import org apache hadoop hive serde2 deserializer
import org apache hadoop hive serde2 serdeexception
import org apache hadoop hive serde2 serdeutils
import org apache hadoop hive shims shimloader
import org apache hadoop hive thrift hadoopthriftauthbridge
import org apache hadoop hive thrift tugicontainingtransport
import org apache hadoop security usergroupinformation
import org apache hadoop util reflectionutils
import org apache hadoop util stringutils
import org apache thrift texception
import org apache thrift tprocessor
import org apache thrift protocol tbinaryprotocol
import org apache thrift server tserver
import org apache thrift server tthreadpoolserver
import org apache thrift transport tframedtransport
import org apache thrift transport tserversocket
import org apache thrift transport tservertransport
import org apache thrift transport ttransport
import org apache thrift transport ttransportfactory
import com facebook fb303 facebookbase
import com facebook fb303 fb_status
/**
* todo:pc remove application logic to a separate interface.
*/
public class hivemetastore extends thrifthivemetastore
public static final log log   logfactory getlog
hivemetastore class
/**
* default port on which to start the hive server
*/
private static final int default_hive_metastore_port   9083
private static hadoopthriftauthbridge server saslserver
private static boolean usesasl
private static final class chainedttransportfactory extends ttransportfactory
private final ttransportfactory parenttransfactory
private final ttransportfactory childtransfactory
private chainedttransportfactory
ttransportfactory parenttransfactory
ttransportfactory childtransfactory
this parenttransfactory   parenttransfactory
this childtransfactory   childtransfactory
@override
public ttransport gettransport ttransport trans
return childtransfactory gettransport parenttransfactory gettransport trans
public static class hmshandler extends facebookbase implements
ihmshandler
public static final log log   hivemetastore log
private static boolean createdefaultdb   false
private string rawstoreclassname
private final hiveconf hiveconf     stores datastore  jpox  properties
// right now they come from jpox.properties
private warehouse wh     hdfs warehouse
private final threadlocal<rawstore> threadlocalms
new threadlocal<rawstore>
@override
protected synchronized rawstore initialvalue
return null
// thread local configuration is needed as many threads could make changes
// to the conf using the connection hook
private final threadlocal<configuration> threadlocalconf
new threadlocal<configuration>
@override
protected synchronized configuration initialvalue
return null
public static final string audit_format
ugi
remote ip
command
public static final log auditlog   logfactory getlog
hivemetastore class getname
private static final threadlocal<formatter> auditformatter
new threadlocal<formatter>
@override
protected formatter initialvalue
return new formatter new stringbuilder audit_format length     4
private final void logauditevent string cmd
if  cmd    null
return
usergroupinformation ugi
try
ugi   shimloader gethadoopshims   getugiforconf getconf
catch  exception ex
throw new runtimeexception ex
final formatter fmt   auditformatter get
stringbuilder  fmt out    setlength 0
string address
if  usesasl
address   saslserver getremoteaddress   tostring
else
address   getipaddress
if  address    null
address
auditlog info fmt format audit_format  ugi getusername
address  cmd  tostring
// the next serial number to be assigned
private boolean checkfordefaultdb
private static int nextserialnum   0
private static threadlocal<integer> threadlocalid   new threadlocal<integer>
@override
protected synchronized integer initialvalue
return new integer nextserialnum
// this will only be set if the metastore is being accessed from a metastore thrift server,
// not if it is from the cli. also, only if the ttransport being used to connect is an
// instance of tsocket.
private static threadlocal<string> threadlocalipaddress   new threadlocal<string>
@override
protected synchronized string initialvalue
return null
public static void setipaddress string ipaddress
threadlocalipaddress set ipaddress
// this will return null if the metastore is not being accessed from a metastore thrift server,
// or if the ttransport being used to connect is not an instance of tsocket.
public static string getipaddress
return threadlocalipaddress get
public static integer get
return threadlocalid get
public hmshandler string name  throws metaexception
super name
hiveconf   new hiveconf this getclass
init
public hmshandler string name  hiveconf conf  throws metaexception
super name
hiveconf   conf
init
public hiveconf gethiveconf
return hiveconf
private classloader classloader
private alterhandler alterhandler
private list<metastorepreeventlistener> prelisteners
private list<metastoreeventlistener> listeners
private list<metastoreendfunctionlistener> endfunctionlisteners
private list<metastoreinitlistener> initlisteners
private pattern partitionvalidationpattern
classloader   thread currentthread   getcontextclassloader
if  classloader    null
classloader   configuration class getclassloader
private boolean init   throws metaexception
rawstoreclassname   hiveconf getvar hiveconf confvars metastore_raw_store_impl
checkfordefaultdb   hiveconf getboolean
true
initlisteners   metastoreutils getmetastorelisteners
metastoreinitlistener class  hiveconf
hiveconf getvar hiveconf confvars metastore_init_hooks
for  metastoreinitlistener singleinitlistener  initlisteners
metastoreinitcontext context   new metastoreinitcontext
singleinitlistener oninit context
string alterhandlername   hiveconf get
hivealterhandler class getname
alterhandler    alterhandler  reflectionutils newinstance metastoreutils getclass
alterhandlername   hiveconf
wh   new warehouse hiveconf
createdefaultdb
if  hiveconf getboolean    false
try
metrics init
catch  exception e
// log exception, but ignore inability to start
log error     e getclass   getname
e getmessage
metastoreutils printstacktrace e
prelisteners   metastoreutils getmetastorelisteners metastorepreeventlistener class
hiveconf
hiveconf getvar hiveconf confvars metastore_pre_event_listeners
listeners   metastoreutils getmetastorelisteners metastoreeventlistener class  hiveconf
hiveconf getvar hiveconf confvars metastore_event_listeners
endfunctionlisteners   metastoreutils getmetastorelisteners
metastoreendfunctionlistener class  hiveconf
hiveconf getvar hiveconf confvars metastore_end_function_listeners
string partitionvalidationregex
hiveconf getvar hiveconf confvars metastore_partition_name_whitelist_pattern
if  partitionvalidationregex    null    partitionvalidationregex
partitionvalidationpattern   pattern compile partitionvalidationregex
else
partitionvalidationpattern   null
long cleanfreq   hiveconf getlongvar confvars metastore_event_clean_freq    1000l
if  cleanfreq > 0
// in default config, there is no timer.
timer cleaner   new timer    true
cleaner schedule new eventcleanertask this   cleanfreq  cleanfreq
return true
private string addprefix string s
return threadlocalid get         s
public void setconf configuration conf
threadlocalconf set conf
rawstore ms   threadlocalms get
if  ms    null
ms setconf conf
private configuration getconf
configuration conf   threadlocalconf get
if  conf    null
conf   new configuration hiveconf
threadlocalconf set conf
return conf
public warehouse getwh
return wh
/**
* get a cached rawstore.
*
* @return the cached rawstore
* @throws metaexception
*/
@interfaceaudience limitedprivate
@interfacestability evolving
public rawstore getms   throws metaexception
rawstore ms   threadlocalms get
if  ms    null
ms   newrawstore
ms verifyschema
threadlocalms set ms
ms   threadlocalms get
return ms
private rawstore newrawstore   throws metaexception
log info addprefix
rawstoreclassname
configuration conf   getconf
return retryingrawstore getproxy hiveconf  conf  rawstoreclassname  threadlocalid get
private void createdefaultdb_core rawstore ms  throws metaexception  invalidobjectexception
try
ms getdatabase default_database_name
catch  nosuchobjectexception e
ms createdatabase
new database default_database_name  default_database_comment
wh getdefaultdatabasepath default_database_name  tostring    null
hmshandler createdefaultdb   true
/**
* create default database if it doesn't exist
*
* @throws metaexception
*/
private void createdefaultdb   throws metaexception
synchronized  hmshandler class
if  hmshandler createdefaultdb     checkfordefaultdb
return
try
createdefaultdb_core getms
catch  invalidobjectexception e
throw new metaexception e getmessage
catch  metaexception e
throw e
catch  exception e
assert  e instanceof runtimeexception
throw  runtimeexception  e
private void loginfo string m
log info threadlocalid get   tostring         m
logauditevent m
public string startfunction string function  string extraloginfo
incrementcounter function
loginfo  getipaddress      null ?         getipaddress
function   extraloginfo
try
metrics startscope function
catch  ioexception e
log debug
e getclass   getname         e getmessage
metastoreutils printstacktrace e
return function
public string startfunction string function
return startfunction function
public string starttablefunction string function  string db  string tbl
return startfunction function      db       tbl
public string startmultitablefunction string function  string db  list<string> tbls
string tablenames   join tbls
return startfunction function      db       tablenames
public string startpartitionfunction string function  string db  string tbl
list<string> partvals
return startfunction function      db       tbl
join partvals
public string startpartitionfunction string function  string db  string tbl
map<string  string> partname
return startfunction function      db       tbl       partname
private void endfunction string function  boolean successful  exception e
endfunction function  successful  e  null
public void endfunction string function  boolean successful  exception e
string inputtablename
endfunction function  new metastoreendfunctioncontext successful  e  inputtablename
public void endfunction string function  metastoreendfunctioncontext context
try
metrics endscope function
catch  ioexception e
log debug     e
for  metastoreendfunctionlistener listener   endfunctionlisteners
listener onendfunction function  context
@override
public fb_status getstatus
return fb_status alive
@override
public void shutdown
loginfo
rawstore ms   threadlocalms get
if  ms    null
ms shutdown
threadlocalms remove
loginfo
@override
public abstractmap<string  long> getcounters
abstractmap<string  long> counters   super getcounters
// allow endfunctionlisteners to add any counters they have collected
if  endfunctionlisteners    null
for  metastoreendfunctionlistener listener   endfunctionlisteners
listener exportcounters counters
return counters
private void create_database_core rawstore ms  final database db
throws alreadyexistsexception  invalidobjectexception  metaexception
if   validatename db getname
throw new invalidobjectexception db getname
if  null    db getlocationuri
db setlocationuri wh getdefaultdatabasepath db getname    tostring
else
db setlocationuri wh getdnspath new path db getlocationuri     tostring
path dbpath   new path db getlocationuri
boolean success   false
boolean madedir   false
try
firepreevent new precreatedatabaseevent db  this
if   wh isdir dbpath
if   wh mkdirs dbpath
throw new metaexception     dbpath
db getname
madedir   true
ms opentransaction
ms createdatabase db
success   ms committransaction
finally
if   success
ms rollbacktransaction
if  madedir
wh deletedir dbpath  true
for  metastoreeventlistener listener   listeners
listener oncreatedatabase new createdatabaseevent db  success  this
public void create_database final database db
throws alreadyexistsexception  invalidobjectexception  metaexception
startfunction        db tostring
boolean success   false
exception ex   null
try
try
if  null    get_database db getname
throw new alreadyexistsexception     db getname
catch  nosuchobjectexception e
// expected
create_database_core getms    db
success   true
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidobjectexception
throw  invalidobjectexception  e
else if  e instanceof alreadyexistsexception
throw  alreadyexistsexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex
public database get_database final string name  throws nosuchobjectexception
metaexception
startfunction        name
database db   null
exception ex   null
try
db   getms   getdatabase name
catch  metaexception e
ex   e
throw e
catch  nosuchobjectexception e
ex   e
throw e
catch  exception e
ex   e
assert  e instanceof runtimeexception
throw  runtimeexception  e
finally
endfunction    db    null  ex
return db
public void alter_database final string dbname  final database db
throws nosuchobjectexception  texception  metaexception
startfunction     dbname
boolean success   false
exception ex   null
try
getms   alterdatabase dbname  db
success   true
catch  exception e
ex   e
rethrowexception e
finally
endfunction    success  ex
private void drop_database_core rawstore ms
final string name  final boolean deletedata  final boolean cascade
throws nosuchobjectexception  invalidoperationexception  metaexception
ioexception  invalidobjectexception  invalidinputexception
boolean success   false
database db   null
list<path> tablepaths   new arraylist<path>
list<path> partitionpaths   new arraylist<path>
try
ms opentransaction
db   ms getdatabase name
firepreevent new predropdatabaseevent db  this
list<string> alltables   get_all_tables db getname
if   cascade     alltables isempty
throw new invalidoperationexception     db getname
path path   new path db getlocationuri    getparent
if   wh iswritable path
throw new metaexception
path
hiveconf getuser
path databasepath   wh getdnspath wh getdatabasepath db
// first drop tables
int tablebatchsize   hiveconf getintvar hiveconf
confvars metastore_batch_retrieve_max
int startindex   0
int endindex    1
// retrieve the tables from the metastore in batches to alleviate memory constraints
while  endindex < alltables size     1
startindex   endindex   1
endindex   endindex   tablebatchsize
if  endindex >  alltables size
endindex   alltables size     1
list<table> tables   null
try
tables   ms gettableobjectsbyname name  alltables sublist startindex  endindex
catch  unknowndbexception e
throw new metaexception e getmessage
if  tables    null     tables isempty
for  table table   tables
// if the table is not external and it might not be in a subdirectory of the database
// add it's locations to the list of paths to delete
path tablepath   null
if  table getsd   getlocation      null     isexternal table
tablepath   wh getdnspath new path table getsd   getlocation
if   wh iswritable tablepath getparent
throw new metaexception
table gettablename         tablepath getparent
hiveconf getuser
if   issubdirectory databasepath  tablepath
tablepaths add tablepath
// for each partition in each table, drop the partitions and get a list of
// partitions' locations which might need to be deleted
partitionpaths   droppartitionsandgetlocations ms  name  table gettablename
tablepath  table getpartitionkeys    deletedata     isexternal table
// drop the table but not its data
drop_table name  table gettablename    false
if  ms dropdatabase name
success   ms committransaction
finally
if   success
ms rollbacktransaction
else if  deletedata
// delete the data in the partitions which have other locations
deletepartitiondata partitionpaths
// delete the data in the tables which have other locations
for  path tablepath   tablepaths
deletetabledata tablepath
// delete the data in the database
try
wh deletedir new path db getlocationuri     true
catch  exception e
log error     db getlocationuri
e getmessage
// it is not a terrible thing even if the data is not deleted
for  metastoreeventlistener listener   listeners
listener ondropdatabase new dropdatabaseevent db  success  this
/**
* returns a best guess as to whether or not other is a subdirectory of parent. it does not
* take into account any intricacies of the underlying file system, which is assumed to be
* hdfs. this should not return any false positives, but may return false negatives.
*
* @param parent
* @param other
* @return
*/
private boolean issubdirectory path parent  path other
return other tostring   startswith parent tostring   endswith path separator  ?
parent tostring     parent tostring     path separator
public void drop_database final string dbname  final boolean deletedata  final boolean cascade
throws nosuchobjectexception  invalidoperationexception  metaexception
startfunction        dbname
if  default_database_name equalsignorecase dbname
endfunction    false  null
throw new metaexception
boolean success   false
exception ex   null
try
drop_database_core getms    dbname  deletedata  cascade
success   true
catch  ioexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidoperationexception
throw  invalidoperationexception  e
else if  e instanceof nosuchobjectexception
throw  nosuchobjectexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex
public list<string> get_databases final string pattern  throws metaexception
startfunction        pattern
list<string> ret   null
exception ex   null
try
ret   getms   getdatabases pattern
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex
return ret
public list<string> get_all_databases   throws metaexception
startfunction
list<string> ret   null
exception ex   null
try
ret   getms   getalldatabases
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex
return ret
private void create_type_core final rawstore ms  final type type
throws alreadyexistsexception  metaexception  invalidobjectexception
if   metastoreutils validatename type getname
throw new invalidobjectexception
boolean success   false
try
ms opentransaction
if  is_type_exists ms  type getname
throw new alreadyexistsexception     type getname
ms createtype type
success   ms committransaction
finally
if   success
ms rollbacktransaction
public boolean create_type final type type  throws alreadyexistsexception
metaexception  invalidobjectexception
startfunction        type tostring
boolean success   false
exception ex   null
try
create_type_core getms    type
success   true
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidobjectexception
throw  invalidobjectexception  e
else if  e instanceof alreadyexistsexception
throw  alreadyexistsexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex
return success
public type get_type final string name  throws metaexception  nosuchobjectexception
startfunction        name
type ret   null
exception ex   null
try
ret   getms   gettype name
if  null    ret
throw new nosuchobjectexception
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof nosuchobjectexception
throw  nosuchobjectexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex
return ret
private boolean is_type_exists rawstore ms  string typename
throws metaexception
return  ms gettype typename     null
private void drop_type_core final rawstore ms  string typename
throws nosuchobjectexception  metaexception
boolean success   false
try
ms opentransaction
// drop any partitions
if   is_type_exists ms  typename
throw new nosuchobjectexception typename
if   ms droptype typename
throw new metaexception     typename
success   ms committransaction
finally
if   success
ms rollbacktransaction
public boolean drop_type final string name  throws metaexception  nosuchobjectexception
startfunction        name
boolean success   false
exception ex   null
try
// todo:pc validate that there are no types that refer to this
success   getms   droptype name
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof nosuchobjectexception
throw  nosuchobjectexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex
return success
public map<string  type> get_type_all string name  throws metaexception
// todo auto-generated method stub
startfunction        name
endfunction    false  null
throw new metaexception
private void create_table_core final rawstore ms  final table tbl
final environmentcontext envcontext
throws alreadyexistsexception  metaexception
invalidobjectexception  nosuchobjectexception
if   metastoreutils validatename tbl gettablename
throw new invalidobjectexception tbl gettablename
string validate   metastoreutils validatetblcolumns tbl getsd   getcols
if  validate    null
throw new invalidobjectexception     validate
if  tbl getpartitionkeys      null
validate   metastoreutils validatetblcolumns tbl getpartitionkeys
if  validate    null
throw new invalidobjectexception     validate
skewedinfo skew   tbl getsd   getskewedinfo
if  skew    null
validate   metastoreutils validateskewedcolnames skew getskewedcolnames
if  validate    null
throw new invalidobjectexception     validate
validate   metastoreutils validateskewedcolnamessubsetcol
skew getskewedcolnames    tbl getsd   getcols
if  validate    null
throw new invalidobjectexception     validate
path tblpath   null
boolean success   false  madedir   false
try
firepreevent new precreatetableevent tbl  this
ms opentransaction
if  ms getdatabase tbl getdbname       null
throw new nosuchobjectexception     tbl getdbname
// get_table checks whether database exists, it should be moved here
if  is_table_exists ms  tbl getdbname    tbl gettablename
throw new alreadyexistsexception     tbl gettablename
if   tabletype virtual_view tostring   equals tbl gettabletype
if  tbl getsd   getlocation      null
tbl getsd   getlocation   isempty
tblpath   wh gettablepath
ms getdatabase tbl getdbname     tbl gettablename
else
if   isexternal tbl      metastoreutils isnonnativetable tbl
log warn     tbl getsd   getlocation
tbl gettablename
tblpath   wh getdnspath new path tbl getsd   getlocation
tbl getsd   setlocation tblpath tostring
if  tblpath    null
if   wh isdir tblpath
if   wh mkdirs tblpath
throw new metaexception tblpath
madedir   true
// set create time
long time   system currenttimemillis     1000
tbl setcreatetime  int  time
if  tbl getparameters      null
tbl getparameters   get hive_metastoreconstants ddl_time     null
tbl puttoparameters hive_metastoreconstants ddl_time  long tostring time
ms createtable tbl
success   ms committransaction
finally
if   success
ms rollbacktransaction
if  madedir
wh deletedir tblpath  true
for  metastoreeventlistener listener   listeners
createtableevent createtableevent
new createtableevent tbl  success  this
createtableevent setenvironmentcontext envcontext
listener oncreatetable createtableevent
@override
public void create_table final table tbl  throws alreadyexistsexception
metaexception  invalidobjectexception
create_table_with_environment_context tbl  null
@override
public void create_table_with_environment_context final table tbl
final environmentcontext envcontext
throws alreadyexistsexception  metaexception  invalidobjectexception
startfunction        tbl tostring
boolean success   false
exception ex   null
try
create_table_core getms    tbl  envcontext
success   true
catch  nosuchobjectexception e
ex   e
throw new invalidobjectexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidobjectexception
throw  invalidobjectexception  e
else if  e instanceof alreadyexistsexception
throw  alreadyexistsexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex  tbl gettablename
private boolean is_table_exists rawstore ms  string dbname  string name
throws metaexception
return  ms gettable dbname  name     null
private void drop_table_core final rawstore ms  final string dbname  final string name
final boolean deletedata  final environmentcontext envcontext
throws nosuchobjectexception  metaexception  ioexception
invalidobjectexception  invalidinputexception
boolean success   false
boolean isexternal   false
path tblpath   null
list<path> partpaths   null
table tbl   null
isexternal   false
boolean isindextable   false
try
ms opentransaction
// drop any partitions
tbl   get_table dbname  name
if  tbl    null
throw new nosuchobjectexception name
if  tbl getsd      null
throw new metaexception
firepreevent new predroptableevent tbl  deletedata  this
isindextable   isindextable tbl
if  isindextable
throw new runtimeexception
name
if   isindextable
try
list<index> indexes   ms getindexes dbname  name  short max_value
while  indexes    null    indexes size   > 0
for  index idx   indexes
this drop_index_by_name dbname  name  idx getindexname    true
indexes   ms getindexes dbname  name  short max_value
catch  texception e
throw new metaexception e getmessage
isexternal   isexternal tbl
if  tbl getsd   getlocation      null
tblpath   new path tbl getsd   getlocation
if   wh iswritable tblpath getparent
throw new metaexception
tblpath getparent
hiveconf getuser
// drop the partitions and get a list of locations which need to be deleted
partpaths   droppartitionsandgetlocations ms  dbname  name  tblpath
tbl getpartitionkeys    deletedata     isexternal
if   ms droptable dbname  name
throw new metaexception
success   ms committransaction
finally
if   success
ms rollbacktransaction
else if  deletedata     isexternal
// delete the data in the partitions which have other locations
deletepartitiondata partpaths
// delete the data in the table
deletetabledata tblpath
// ok even if the data is not deleted
for  metastoreeventlistener listener   listeners
droptableevent droptableevent   new droptableevent tbl  success  deletedata  this
droptableevent setenvironmentcontext envcontext
listener ondroptable droptableevent
/**
* deletes the data in a table's location, if it fails logs an error
*
* @param tablepath
*/
private void deletetabledata path tablepath
if  tablepath    null
try
wh deletedir tablepath  true
catch  exception e
log error     tablepath
e getmessage
/**
* give a list of partitions' locations, tries to delete each one
* and for each that fails logs an error.
*
* @param partpaths
*/
private void deletepartitiondata list<path> partpaths
if  partpaths    null     partpaths isempty
for  path partpath   partpaths
try
wh deletedir partpath  true
catch  exception e
log error     partpath
e getmessage
/**
* retrieves the partitions specified by partitionkeys. if checklocation, for locations of
* partitions which may not be subdirectories of tablepath checks to make the locations are
* writable.
*
* drops the metadata for each partition.
*
* provides a list of locations of partitions which may not be subdirectories of tablepath.
*
* @param ms
* @param dbname
* @param tablename
* @param tablepath
* @param partitionkeys
* @param checklocation
* @return
* @throws metaexception
* @throws ioexception
* @throws invalidinputexception
* @throws invalidobjectexception
* @throws nosuchobjectexception
*/
private list<path> droppartitionsandgetlocations rawstore ms  string dbname
string tablename  path tablepath  list<fieldschema> partitionkeys  boolean checklocation
throws metaexception  ioexception  nosuchobjectexception  invalidobjectexception
invalidinputexception
int partitionbatchsize   hiveconf getintvar hiveconf
confvars metastore_batch_retrieve_max
path tablednspath   null
if  tablepath    null
tablednspath   wh getdnspath tablepath
list<path> partpaths   new arraylist<path>
// call droppartition on each of the table's partitions to follow the
// procedure for cleanly dropping partitions.
while  true
list<partition> partstodelete   ms getpartitions dbname  tablename  partitionbatchsize
if  partstodelete    null    partstodelete isempty
break
for  partition part   partstodelete
if  checklocation    part getsd      null
part getsd   getlocation      null
path partpath   wh getdnspath new path part getsd   getlocation
if  tablednspath    null
partpath    null     issubdirectory tablednspath  partpath
if   wh iswritable partpath getparent
throw new metaexception
warehouse makepartname partitionkeys  part getvalues
partpath getparent
hiveconf getuser
partpaths add partpath
ms droppartition dbname  tablename  part getvalues
return partpaths
@override
public void drop_table final string dbname  final string name  final boolean deletedata
throws nosuchobjectexception  metaexception
drop_table_with_environment_context dbname  name  deletedata  null
@override
public void drop_table_with_environment_context final string dbname  final string name
final boolean deletedata  final environmentcontext envcontext
throws nosuchobjectexception  metaexception
starttablefunction    dbname  name
boolean success   false
exception ex   null
try
drop_table_core getms    dbname  name  deletedata  envcontext
success   true
catch  ioexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof nosuchobjectexception
throw  nosuchobjectexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex  name
/**
* is this an external table?
*
* @param table
*          check if this table is external.
* @return true if the table is external, otherwise false.
*/
private boolean isexternal table table
return metastoreutils isexternaltable table
private boolean isindextable table table
return metastoreutils isindextable table
public table get_table final string dbname  final string name  throws metaexception
nosuchobjectexception
table t   null
starttablefunction    dbname  name
exception ex   null
try
t   getms   gettable dbname  name
if  t    null
throw new nosuchobjectexception dbname       name
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof nosuchobjectexception
throw  nosuchobjectexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    t    null  ex  name
return t
/**
* gets multiple tables from the hive metastore.
*
* @param dbname
*          the name of the database in which the tables reside
* @param names
*          the names of the tables to get.
*
* @return a list of tables whose names are in the the list "names" and
*         are retrievable from the database specified by "dbnames."
*         there is no guarantee of the order of the returned tables.
*         if there are duplicate names, only one instance of the table will be returned.
* @throws metaexception
* @throws invalidoperationexception
* @throws unknowndbexception
*/
public list<table> get_table_objects_by_name final string dbname  final list<string> names
throws metaexception  invalidoperationexception  unknowndbexception
list<table> tables   null
startmultitablefunction    dbname  names
exception ex   null
try
if  dbname    null    dbname isempty
throw new unknowndbexception
if  names    null
throw new invalidoperationexception dbname
tables   getms   gettableobjectsbyname dbname  names
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidoperationexception
throw  invalidoperationexception  e
else if  e instanceof unknowndbexception
throw  unknowndbexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    tables    null  ex  join names
return tables
@override
public list<string> get_table_names_by_filter
final string dbname  final string filter  final short maxtables
throws metaexception  invalidoperationexception  unknowndbexception
list<string> tables   null
startfunction        dbname       filter
exception ex   null
try
if  dbname    null    dbname isempty
throw new unknowndbexception
if  filter    null
throw new invalidoperationexception filter
tables   getms   listtablenamesbyfilter dbname  filter  maxtables
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidoperationexception
throw  invalidoperationexception  e
else if  e instanceof unknowndbexception
throw  unknowndbexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    tables    null  ex  join tables
return tables
public boolean set_table_parameters string dbname  string name
map<string  string> params  throws nosuchobjectexception  metaexception
endfunction starttablefunction    dbname  name   false  null  name
// todo auto-generated method stub
return false
private partition append_partition_common rawstore ms  string dbname  string tablename
list<string> part_vals  environmentcontext envcontext  throws invalidobjectexception
alreadyexistsexception  metaexception
partition part   new partition
boolean success   false  madedir   false
path partlocation   null
table tbl   null
try
ms opentransaction
part setdbname dbname
part settablename tablename
part setvalues part_vals
preaddpartitionevent event   new preaddpartitionevent part  this
firepreevent event
metastoreutils validatepartitionnamecharacters part_vals  partitionvalidationpattern
tbl   ms gettable part getdbname    part gettablename
if  tbl    null
throw new invalidobjectexception
if  tbl getsd   getlocation      null
throw new metaexception
part setsd tbl getsd
partlocation   new path tbl getsd   getlocation    warehouse
makepartname tbl getpartitionkeys    part_vals
part getsd   setlocation partlocation tostring
partition old_part   null
try
old_part   ms getpartition part getdbname    part
gettablename    part getvalues
catch  nosuchobjectexception e
// this means there is no existing partition
old_part   null
if  old_part    null
throw new alreadyexistsexception     part
if   wh isdir partlocation
if   wh mkdirs partlocation
throw new metaexception partlocation
madedir   true
// set create time
long time   system currenttimemillis     1000
part setcreatetime  int  time
part puttoparameters hive_metastoreconstants ddl_time  long tostring time
success   ms addpartition part
if  success
success   ms committransaction
finally
if   success
ms rollbacktransaction
if  madedir
wh deletedir partlocation  true
for  metastoreeventlistener listener   listeners
addpartitionevent addpartitionevent
new addpartitionevent tbl  part  success  this
addpartitionevent setenvironmentcontext envcontext
listener onaddpartition addpartitionevent
return part
private void firepreevent preeventcontext event  throws metaexception
for  metastorepreeventlistener listener   prelisteners
try
listener onevent event
catch  nosuchobjectexception e
throw new metaexception e getmessage
catch  invalidoperationexception e
throw new metaexception e getmessage
@override
public partition append_partition final string dbname  final string tablename
final list<string> part_vals  throws invalidobjectexception
alreadyexistsexception  metaexception
return append_partition_with_environment_context dbname  tablename  part_vals  null
@override
public partition append_partition_with_environment_context final string dbname
final string tablename  final list<string> part_vals  final environmentcontext envcontext
throws invalidobjectexception  alreadyexistsexception  metaexception
startpartitionfunction    dbname  tablename  part_vals
if  log isdebugenabled
for  string part   part_vals
log debug part
partition ret   null
exception ex   null
try
ret   append_partition_common getms    dbname  tablename  part_vals  envcontext
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidobjectexception
throw  invalidobjectexception  e
else if  e instanceof alreadyexistsexception
throw  alreadyexistsexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex  tablename
return ret
private int add_partitions_core final rawstore ms  final list<partition> parts
throws metaexception  invalidobjectexception  alreadyexistsexception
string db   parts get 0  getdbname
string tblname   parts get 0  gettablename
loginfo     db       tblname
boolean success   false
map<partition  boolean> addedpartitions   new hashmap<partition  boolean>
try
ms opentransaction
for  partition part   parts
// no environment context is passed.
entry<partition  boolean> e   add_partition_core_notxn ms  part  null
addedpartitions put e getkey    e getvalue
success   ms committransaction
finally
if   success
ms rollbacktransaction
for  entry<partition  boolean> e   addedpartitions entryset
if  e getvalue
wh deletedir new path e getkey   getsd   getlocation     true
// we just created this directory - it's not a case of pre-creation, so we nuke
for  partition part   parts
firemetastoreaddpartitionevent ms  part  null  success
return parts size
public int add_partitions final list<partition> parts  throws metaexception
invalidobjectexception  alreadyexistsexception
startfunction
if  parts size      0
return 0
integer ret   null
exception ex   null
try
ret   add_partitions_core getms    parts
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidobjectexception
throw  invalidobjectexception  e
else if  e instanceof alreadyexistsexception
throw  alreadyexistsexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
string tablename   parts get 0  gettablename
endfunction    ret    null  ex  tablename
return ret
/**
* an implementation of add_partition_core that does not commit
* transaction or rollback transaction as part of its operation
* - it is assumed that will be tended to from outside this call
*
* @param ms
* @param part
* @param envcontext
*          parameters passed by the client
* @return
* @throws invalidobjectexception
* @throws alreadyexistsexception
* @throws metaexception
*/
private entry<partition  boolean> add_partition_core_notxn
final rawstore ms  final partition part
final environmentcontext envcontext
throws invalidobjectexception  alreadyexistsexception  metaexception
boolean success   false  madedir   false
path partlocation   null
table tbl   null
try
firepreevent new preaddpartitionevent part  this
metastoreutils validatepartitionnamecharacters part getvalues
partitionvalidationpattern
partition old_part   null
try
old_part   ms getpartition part getdbname    part
gettablename    part getvalues
catch  nosuchobjectexception e
// this means there is no existing partition
old_part   null
if  old_part    null
throw new alreadyexistsexception     part
tbl   ms gettable part getdbname    part gettablename
if  tbl    null
throw new invalidobjectexception
string partlocationstr   null
if  part getsd      null
partlocationstr   part getsd   getlocation
if  partlocationstr    null    partlocationstr isempty
// set default location if not specified and this is
// a physical table partition (not a view)
if  tbl getsd   getlocation      null
partlocation   new path tbl getsd   getlocation    warehouse
makepartname tbl getpartitionkeys    part getvalues
else
if  tbl getsd   getlocation      null
throw new metaexception
partlocation   wh getdnspath new path partlocationstr
if  partlocation    null
part getsd   setlocation partlocation tostring
// check to see if the directory already exists before calling
// mkdirs() because if the file system is read-only, mkdirs will
// throw an exception even if the directory already exists.
if   wh isdir partlocation
if   wh mkdirs partlocation
throw new metaexception partlocation
madedir   true
// set create time
long time   system currenttimemillis     1000
part setcreatetime  int  time
if  part getparameters      null
part getparameters   get hive_metastoreconstants ddl_time     null
part puttoparameters hive_metastoreconstants ddl_time  long tostring time
// inherit table properties into partition properties.
map<string  string> tblparams   tbl getparameters
string inheritprops   hiveconf getvar confvars metastore_part_inherit_tbl_props  trim
// default value is empty string in which case no properties will be inherited.
// * implies all properties needs to be inherited
set<string> inheritkeys   new hashset<string> arrays aslist inheritprops split
if  inheritkeys contains
inheritkeys   tblparams keyset
for  string key   inheritkeys
string paramval   tblparams get key
if  null    paramval       add the property only if it exists in table properties
part puttoparameters key  paramval
success   ms addpartition part
finally
if   success
if  madedir
wh deletedir partlocation  true
map<partition  boolean> returnval   new hashmap<partition  boolean>
returnval put part  madedir
return returnval entryset   iterator   next
private partition add_partition_core final rawstore ms
final partition part  final environmentcontext envcontext
throws invalidobjectexception  alreadyexistsexception  metaexception
boolean success   false
partition retptn   null
try
ms opentransaction
retptn   add_partition_core_notxn ms  part  envcontext  getkey
// we proceed only if we'd actually succeeded anyway, otherwise,
// we'd have thrown an exception
success   ms committransaction
finally
if   success
ms rollbacktransaction
firemetastoreaddpartitionevent ms  part  envcontext  success
return retptn
private void firemetastoreaddpartitionevent final rawstore ms
final partition part  final environmentcontext envcontext  boolean success
throws metaexception
final table tbl   ms gettable part getdbname    part gettablename
for  metastoreeventlistener listener   listeners
addpartitionevent addpartitionevent
new addpartitionevent tbl  part  success  this
addpartitionevent setenvironmentcontext envcontext
listener onaddpartition addpartitionevent
@override
public partition add_partition final partition part
throws invalidobjectexception  alreadyexistsexception  metaexception
return add_partition_with_environment_context part  null
@override
public partition add_partition_with_environment_context
final partition part  environmentcontext envcontext
throws invalidobjectexception  alreadyexistsexception
metaexception
starttablefunction
part getdbname    part gettablename
partition ret   null
exception ex   null
try
ret   add_partition_core getms    part  envcontext
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidobjectexception
throw  invalidobjectexception  e
else if  e instanceof alreadyexistsexception
throw  alreadyexistsexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex  part    null ?  part gettablename    null
return ret
@override
public partition exchange_partition map<string  string> partitionspecs
string sourcedbname  string sourcetablename  string destdbname
string desttablename  throws metaexception  nosuchobjectexception
invalidobjectexception  invalidinputexception  texception
boolean success   false
boolean pathcreated   false
rawstore ms   getms
ms opentransaction
table destinationtable   ms gettable destdbname  desttablename
table sourcetable   ms gettable sourcedbname  sourcetablename
list<string> partvals   metastoreutils getpvals sourcetable getpartitionkeys
partitionspecs
list<string> partvalspresent   new arraylist<string>
list<fieldschema> partitionkeyspresent   new arraylist<fieldschema>
int i   0
for  fieldschema fs  sourcetable getpartitionkeys
string partval   partvals get i
if  partval    null     partval equals
partvalspresent add partval
partitionkeyspresent add fs
i
list<partition> partitionstoexchange   get_partitions_ps sourcedbname  sourcetablename
partvals   short  1
boolean samecolumns   metastoreutils comparefieldcolumns
sourcetable getsd   getcols    destinationtable getsd   getcols
boolean samepartitions   metastoreutils comparefieldcolumns
sourcetable getpartitionkeys    destinationtable getpartitionkeys
if   samecolumns     samepartitions
throw new metaexception
path sourcepath   new path sourcetable getsd   getlocation
warehouse makepartname partitionkeyspresent  partvalspresent
path destpath   new path destinationtable getsd   getlocation
warehouse makepartname partitionkeyspresent  partvalspresent
try
for  partition partition  partitionstoexchange
partition destpartition   new partition partition
destpartition setdbname destdbname
destpartition settablename destinationtable gettablename
path destpartitionpath   new path destinationtable getsd   getlocation
warehouse makepartname destinationtable getpartitionkeys    partition getvalues
destpartition getsd   setlocation destpartitionpath tostring
ms addpartition destpartition
ms droppartition partition getdbname    sourcetable gettablename
partition getvalues
/**
* todo: use the hard link feature of hdfs
* once https://issues.apache.org/jira/browse/hdfs-3370 is done
*/
pathcreated   wh renamedir sourcepath  destpath
success   ms committransaction
finally
if   success
ms rollbacktransaction
if  pathcreated
wh renamedir destpath  sourcepath
return new partition
private boolean drop_partition_common rawstore ms  string db_name  string tbl_name
list<string> part_vals  final boolean deletedata  final environmentcontext envcontext
throws metaexception  nosuchobjectexception  ioexception  invalidobjectexception
invalidinputexception
boolean success   false
path partpath   null
table tbl   null
partition part   null
boolean isarchived   false
path archiveparentdir   null
try
ms opentransaction
part   ms getpartition db_name  tbl_name  part_vals
tbl   get_table db_name  tbl_name
firepreevent new predroppartitionevent tbl  part  deletedata  this
if  part    null
throw new nosuchobjectexception
part_vals
isarchived   metastoreutils isarchived part
if  isarchived
archiveparentdir   metastoreutils getoriginallocation part
if   wh iswritable archiveparentdir getparent
throw new metaexception
archiveparentdir getparent
hiveconf getuser
if   ms droppartition db_name  tbl_name  part_vals
throw new metaexception
success   ms committransaction
if   part getsd      null      part getsd   getlocation      null
partpath   new path part getsd   getlocation
if   wh iswritable partpath getparent
throw new metaexception
partpath getparent
hiveconf getuser
finally
if   success
ms rollbacktransaction
else if  deletedata      partpath    null      archiveparentdir    null
if  tbl    null     isexternal tbl
// archived partitions have har:/to_har_file as their location.
// the original directory was saved in params
if  isarchived
assert  archiveparentdir    null
wh deletedir archiveparentdir  true
else
assert  partpath    null
wh deletedir partpath  true
// ok even if the data is not deleted
for  metastoreeventlistener listener   listeners
droppartitionevent droppartitionevent
new droppartitionevent tbl  part  success  deletedata  this
droppartitionevent setenvironmentcontext envcontext
listener ondroppartition droppartitionevent
return true
@override
public boolean drop_partition final string db_name  final string tbl_name
final list<string> part_vals  final boolean deletedata
throws nosuchobjectexception  metaexception  texception
return drop_partition_with_environment_context db_name  tbl_name  part_vals  deletedata

@override
public boolean drop_partition_with_environment_context final string db_name
final string tbl_name  final list<string> part_vals  final boolean deletedata
final environmentcontext envcontext
throws nosuchobjectexception  metaexception  texception
startpartitionfunction    db_name  tbl_name  part_vals
log info     part_vals
boolean ret   false
exception ex   null
try
ret   drop_partition_common getms    db_name  tbl_name  part_vals  deletedata  envcontext
catch  ioexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret  ex  tbl_name
return ret
public partition get_partition final string db_name  final string tbl_name
final list<string> part_vals  throws metaexception  nosuchobjectexception
startpartitionfunction    db_name  tbl_name  part_vals
partition ret   null
exception ex   null
try
ret   getms   getpartition db_name  tbl_name  part_vals
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof nosuchobjectexception
throw  nosuchobjectexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex  tbl_name
return ret
@override
public partition get_partition_with_auth final string db_name
final string tbl_name  final list<string> part_vals
final string user_name  final list<string> group_names
throws metaexception  nosuchobjectexception  texception
startpartitionfunction    db_name  tbl_name
part_vals
partition ret   null
exception ex   null
try
ret   getms   getpartitionwithauth db_name  tbl_name  part_vals
user_name  group_names
catch  invalidobjectexception e
ex   e
throw new nosuchobjectexception e getmessage
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tbl_name
return ret
public list<partition> get_partitions final string db_name  final string tbl_name
final short max_parts  throws nosuchobjectexception  metaexception
starttablefunction    db_name  tbl_name
list<partition> ret   null
exception ex   null
try
ret   getms   getpartitions db_name  tbl_name  max_parts
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof nosuchobjectexception
throw  nosuchobjectexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex  tbl_name
return ret
@override
public list<partition> get_partitions_with_auth final string dbname
final string tblname  final short maxparts  final string username
final list<string> groupnames  throws nosuchobjectexception
metaexception  texception
starttablefunction    dbname  tblname
list<partition> ret   null
exception ex   null
try
ret   getms   getpartitionswithauth dbname  tblname  maxparts
username  groupnames
catch  invalidobjectexception e
ex   e
throw new nosuchobjectexception e getmessage
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tblname
return ret
public list<string> get_partition_names final string db_name  final string tbl_name
final short max_parts  throws metaexception
starttablefunction    db_name  tbl_name
list<string> ret   null
exception ex   null
try
ret   getms   listpartitionnames db_name  tbl_name  max_parts
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex  tbl_name
return ret
@override
public void alter_partition final string db_name  final string tbl_name
final partition new_part
throws invalidoperationexception  metaexception
texception
rename_partition db_name  tbl_name  null  new_part
@override
public void alter_partition_with_environment_context final string dbname
final string tablename  final partition newpartition
final environmentcontext envcontext
throws invalidoperationexception  metaexception  texception
rename_partition dbname  tablename  null
newpartition  envcontext
@override
public void rename_partition final string db_name  final string tbl_name
final list<string> part_vals  final partition new_part
throws invalidoperationexception  metaexception  texception
// call rename_partition without an environment context.
rename_partition db_name  tbl_name  part_vals  new_part  null
private void rename_partition final string db_name  final string tbl_name
final list<string> part_vals  final partition new_part
final environmentcontext envcontext
throws invalidoperationexception  metaexception
texception
starttablefunction    db_name  tbl_name
if  log isinfoenabled
log info     new_part getvalues
if  part_vals    null    part_vals size   > 0
log info     part_vals
partition oldpart   null
exception ex   null
try
firepreevent new prealterpartitionevent db_name  tbl_name  part_vals  new_part  this
if  part_vals    null     part_vals isempty
metastoreutils validatepartitionnamecharacters new_part getvalues
partitionvalidationpattern
oldpart   alterhandler alterpartition getms    wh  db_name  tbl_name  part_vals  new_part
for  metastoreeventlistener listener   listeners
alterpartitionevent alterpartitionevent
new alterpartitionevent oldpart  new_part  true  this
alterpartitionevent setenvironmentcontext envcontext
listener onalterpartition alterpartitionevent
catch  invalidobjectexception e
ex   e
throw new invalidoperationexception e getmessage
catch  alreadyexistsexception e
ex   e
throw new invalidoperationexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidoperationexception
throw  invalidoperationexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    oldpart    null  ex  tbl_name
return
@override
public void alter_partitions final string db_name  final string tbl_name
final list<partition> new_parts
throws invalidoperationexception  metaexception
texception
starttablefunction    db_name  tbl_name
if  log isinfoenabled
for  partition tmppart   new_parts
log info     tmppart getvalues
// all partitions are altered atomically
// all prehooks are fired together followed by all post hooks
list<partition> oldparts   null
exception ex   null
try
for  partition tmppart   new_parts
try
for  metastorepreeventlistener listener   prelisteners
listener onevent
new prealterpartitionevent db_name  tbl_name  null  tmppart  this
catch  nosuchobjectexception e
throw new metaexception e getmessage
oldparts   alterhandler alterpartitions getms    wh  db_name  tbl_name  new_parts
iterator<partition> olditr   oldparts iterator
for  partition tmppart   new_parts
partition oldtmppart   null
if  olditr hasnext
oldtmppart    partition  olditr next
else
throw new invalidoperationexception
for  metastoreeventlistener listener   listeners
alterpartitionevent alterpartitionevent
new alterpartitionevent oldtmppart  tmppart  true  this
listener onalterpartition alterpartitionevent
catch  invalidobjectexception e
ex   e
throw new invalidoperationexception e getmessage
catch  alreadyexistsexception e
ex   e
throw new invalidoperationexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidoperationexception
throw  invalidoperationexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    oldparts    null  ex  tbl_name
return
public boolean create_index index index_def
throws indexalreadyexistsexception  metaexception
endfunction startfunction     false  null
// todo auto-generated method stub
throw new metaexception
public void alter_index final string dbname  final string base_table_name
final string index_name  final index newindex
throws invalidoperationexception  metaexception
startfunction        dbname       base_table_name
index_name       newindex getindexname
newindex puttoparameters hive_metastoreconstants ddl_time  long tostring system
currenttimemillis     1000
boolean success   false
exception ex   null
try
getms   alterindex dbname  base_table_name  index_name  newindex
success   true
catch  invalidobjectexception e
ex   e
throw new invalidoperationexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidoperationexception
throw  invalidoperationexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex  base_table_name
return
public string getversion   throws texception
endfunction startfunction     true  null
return
@override
public void alter_table final string dbname  final string name
final table newtable
throws invalidoperationexception  metaexception
// do not set an environment context.
alter_table_with_environment_context dbname  name  newtable  null
@override
public void alter_table_with_environment_context final string dbname
final string name  final table newtable
final environmentcontext envcontext
throws invalidoperationexception  metaexception
startfunction        dbname       name
newtable gettablename
// update the time if it hasn't been specified.
if  newtable getparameters      null
newtable getparameters   get hive_metastoreconstants ddl_time     null
newtable puttoparameters hive_metastoreconstants ddl_time  long tostring system
currenttimemillis     1000
boolean success   false
exception ex   null
try
table oldt   get_table dbname  name
firepreevent new prealtertableevent oldt  newtable  this
alterhandler altertable getms    wh  dbname  name  newtable
success   true
for  metastoreeventlistener listener   listeners
altertableevent altertableevent
new altertableevent oldt  newtable  success  this
altertableevent setenvironmentcontext envcontext
listener onaltertable altertableevent
catch  nosuchobjectexception e
// thrown when the table to be altered does not exist
ex   e
throw new invalidoperationexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof invalidoperationexception
throw  invalidoperationexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex  name
public list<string> get_tables final string dbname  final string pattern
throws metaexception
startfunction        dbname       pattern
list<string> ret   null
exception ex   null
try
ret   getms   gettables dbname  pattern
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex
return ret
public list<string> get_all_tables final string dbname  throws metaexception
startfunction        dbname
list<string> ret   null
exception ex   null
try
ret   getms   getalltables dbname
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex
return ret
public list<fieldschema> get_fields string db  string tablename
throws metaexception  unknowntableexception  unknowndbexception
startfunction        db       tablename
string names   tablename split
string base_table_name   names
table tbl
list<fieldschema> ret   null
exception ex   null
try
try
tbl   get_table db  base_table_name
catch  nosuchobjectexception e
throw new unknowntableexception e getmessage
boolean getcolsfromserde   serdeutils shouldgetcolsfromserde
tbl getsd   getserdeinfo   getserializationlib
if   getcolsfromserde
ret   tbl getsd   getcols
else
try
deserializer s   metastoreutils getdeserializer hiveconf  tbl
ret   metastoreutils getfieldsfromdeserializer tablename  s
catch  serdeexception e
stringutils stringifyexception e
throw new metaexception e getmessage
catch  exception e
ex   e
if  e instanceof unknowndbexception
throw  unknowndbexception  e
else if  e instanceof unknowntableexception
throw  unknowntableexception  e
else if  e instanceof metaexception
throw  metaexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex  tablename
return ret
/**
* return the schema of the table. this function includes partition columns
* in addition to the regular columns.
*
* @param db
*          name of the database
* @param tablename
*          name of the table
* @return list of columns, each column is a fieldschema structure
* @throws metaexception
* @throws unknowntableexception
* @throws unknowndbexception
*/
public list<fieldschema> get_schema string db  string tablename
throws metaexception  unknowntableexception  unknowndbexception
startfunction        db       tablename
boolean success   false
exception ex   null
try
string names   tablename split
string base_table_name   names
table tbl
try
tbl   get_table db  base_table_name
catch  nosuchobjectexception e
throw new unknowntableexception e getmessage
list<fieldschema> fieldschemas   get_fields db  base_table_name
if  tbl    null    fieldschemas    null
throw new unknowntableexception tablename
if  tbl getpartitionkeys      null
// combine the column field schemas and the partition keys to create the
// whole schema
fieldschemas addall tbl getpartitionkeys
success   true
return fieldschemas
catch  exception e
ex   e
if  e instanceof unknowndbexception
throw  unknowndbexception  e
else if  e instanceof unknowntableexception
throw  unknowntableexception  e
else if  e instanceof metaexception
throw  metaexception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex  tablename
public string getcpuprofile int profiledurationinsec  throws texception
return
/**
* returns the value of the given configuration variable name. if the
* configuration variable with the given name doesn't exist, or if there
* were an exception thrown while retrieving the variable, or if name is
* null, defaultvalue is returned.
*/
public string get_config_value string name  string defaultvalue
throws texception  configvalsecurityexception
startfunction        name
defaultvalue
boolean success   false
exception ex   null
try
if  name    null
success   true
return defaultvalue
// allow only keys that start with hive.*, hdfs.*, mapred.* for security
// i.e. don't allow access to db password
if   pattern matches    name
throw new configvalsecurityexception
name
string toreturn   defaultvalue
try
toreturn   hiveconf get name  defaultvalue
catch  runtimeexception e
log error threadlocalid get   tostring
e getmessage         e getcause
success   true
return toreturn
catch  exception e
ex   e
if  e instanceof configvalsecurityexception
throw  configvalsecurityexception  e
else if  e instanceof texception
throw  texception  e
else
texception te   new texception e tostring
te initcause e
throw te
finally
endfunction    success  ex
private list<string> getpartvalsfromname rawstore ms  string dbname  string tblname
string partname  throws metaexception  invalidobjectexception
// unescape the partition name
linkedhashmap<string  string> hm   warehouse makespecfromname partname
// getpartition expects partition values in a list. use info from the
// table to put the partition column values in order
table t   ms gettable dbname  tblname
if  t    null
throw new invalidobjectexception dbname       tblname
list<string> partvals   new arraylist<string>
for  fieldschema field   t getpartitionkeys
string key   field getname
string val   hm get key
if  val    null
throw new invalidobjectexception     key
partvals add val
return partvals
private partition get_partition_by_name_core final rawstore ms  final string db_name
final string tbl_name  final string part_name
throws metaexception  nosuchobjectexception  texception
list<string> partvals   null
try
partvals   getpartvalsfromname ms  db_name  tbl_name  part_name
catch  invalidobjectexception e
throw new nosuchobjectexception e getmessage
partition p   ms getpartition db_name  tbl_name  partvals
if  p    null
throw new nosuchobjectexception db_name       tbl_name
part_name
return p
public partition get_partition_by_name final string db_name  final string tbl_name
final string part_name  throws metaexception  nosuchobjectexception  texception
startfunction        db_name
tbl_name       part_name
partition ret   null
exception ex   null
try
ret   get_partition_by_name_core getms    db_name  tbl_name  part_name
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tbl_name
return ret
@override
public partition append_partition_by_name final string db_name  final string tbl_name
final string part_name  throws invalidobjectexception
alreadyexistsexception  metaexception  texception
return append_partition_by_name_with_environment_context db_name  tbl_name  part_name  null
@override
public partition append_partition_by_name_with_environment_context final string db_name
final string tbl_name  final string part_name  final environmentcontext env_context
throws invalidobjectexception  alreadyexistsexception  metaexception  texception
startfunction        db_name
tbl_name       part_name
partition ret   null
exception ex   null
try
rawstore ms   getms
list<string> partvals   getpartvalsfromname ms  db_name  tbl_name  part_name
ret   append_partition_common ms  db_name  tbl_name  partvals  env_context
catch  exception e
ex   e
if  e instanceof invalidobjectexception
throw  invalidobjectexception  e
else if  e instanceof alreadyexistsexception
throw  alreadyexistsexception  e
else if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex  tbl_name
return ret
private boolean drop_partition_by_name_core final rawstore ms  final string db_name
final string tbl_name  final string part_name  final boolean deletedata
final environmentcontext envcontext  throws nosuchobjectexception  metaexception
texception  ioexception  invalidobjectexception  invalidinputexception
list<string> partvals   null
try
partvals   getpartvalsfromname ms  db_name  tbl_name  part_name
catch  invalidobjectexception e
throw new nosuchobjectexception e getmessage
return drop_partition_common ms  db_name  tbl_name  partvals  deletedata  envcontext
@override
public boolean drop_partition_by_name final string db_name  final string tbl_name
final string part_name  final boolean deletedata  throws nosuchobjectexception
metaexception  texception
return drop_partition_by_name_with_environment_context db_name  tbl_name  part_name
deletedata  null
@override
public boolean drop_partition_by_name_with_environment_context final string db_name
final string tbl_name  final string part_name  final boolean deletedata
final environmentcontext envcontext  throws nosuchobjectexception
metaexception  texception
startfunction        db_name
tbl_name       part_name
boolean ret   false
exception ex   null
try
ret   drop_partition_by_name_core getms    db_name  tbl_name
part_name  deletedata  envcontext
catch  ioexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret  ex  tbl_name
return ret
@override
public list<partition> get_partitions_ps final string db_name
final string tbl_name  final list<string> part_vals
final short max_parts  throws metaexception  texception  nosuchobjectexception
startpartitionfunction    db_name  tbl_name  part_vals
list<partition> ret   null
exception ex   null
try
ret   get_partitions_ps_with_auth db_name  tbl_name  part_vals
max_parts  null  null
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tbl_name
return ret
@override
public list<partition> get_partitions_ps_with_auth final string db_name
final string tbl_name  final list<string> part_vals
final short max_parts  final string username
final list<string> groupnames  throws metaexception  texception  nosuchobjectexception
startpartitionfunction    db_name  tbl_name
part_vals
list<partition> ret   null
exception ex   null
try
ret   getms   listpartitionspswithauth db_name  tbl_name  part_vals  max_parts
username  groupnames
catch  invalidobjectexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tbl_name
return ret
@override
public list<string> get_partition_names_ps final string db_name
final string tbl_name  final list<string> part_vals  final short max_parts
throws metaexception  texception  nosuchobjectexception
startpartitionfunction    db_name  tbl_name  part_vals
list<string> ret   null
exception ex   null
try
ret   getms   listpartitionnamesps db_name  tbl_name  part_vals  max_parts
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tbl_name
return ret
@override
public list<string> partition_name_to_vals string part_name
throws metaexception  texception
if  part_name length      0
return new arraylist<string>
linkedhashmap<string  string> map   warehouse makespecfromname part_name
list<string> part_vals   new arraylist<string>
part_vals addall map values
return part_vals
@override
public map<string  string> partition_name_to_spec string part_name  throws metaexception
texception
if  part_name length      0
return new hashmap<string  string>
return warehouse makespecfromname part_name
@override
public index add_index final index newindex  final table indextable
throws invalidobjectexception  alreadyexistsexception  metaexception  texception
startfunction        newindex tostring         indextable tostring
index ret   null
exception ex   null
try
ret   add_index_core getms    newindex  indextable
catch  exception e
ex   e
if  e instanceof invalidobjectexception
throw  invalidobjectexception  e
else if  e instanceof alreadyexistsexception
throw  alreadyexistsexception  e
else if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
string tablename   indextable    null ? indextable gettablename     null
endfunction    ret    null  ex  tablename
return ret
private index add_index_core final rawstore ms  final index index  final table indextable
throws invalidobjectexception  alreadyexistsexception  metaexception
boolean success   false  indextablecreated   false
try
ms opentransaction
index old_index   null
try
old_index   get_index_by_name index getdbname    index
getorigtablename    index getindexname
catch  exception e
if  old_index    null
throw new alreadyexistsexception     index
table origtbl   ms gettable index getdbname    index getorigtablename
if  origtbl    null
throw new invalidobjectexception
// set create time
long time   system currenttimemillis     1000
table indextbl   indextable
if  indextbl    null
try
indextbl   ms gettable index getdbname    index getindextablename
catch  exception e
if  indextbl    null
throw new invalidobjectexception
this create_table indextable
indextablecreated   true
index setcreatetime  int  time
index puttoparameters hive_metastoreconstants ddl_time  long tostring time
ms addindex index
success   ms committransaction
return index
finally
if   success
if  indextablecreated
try
this drop_table index getdbname    index getindextablename    false
catch  exception e
ms rollbacktransaction
@override
public boolean drop_index_by_name final string dbname  final string tblname
final string indexname  final boolean deletedata  throws nosuchobjectexception
metaexception  texception
startfunction        dbname
tblname       indexname
boolean ret   false
exception ex   null
try
ret   drop_index_by_name_core getms    dbname  tblname
indexname  deletedata
catch  ioexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret  ex  tblname
return ret
private boolean drop_index_by_name_core final rawstore ms
final string dbname  final string tblname
final string indexname  final boolean deletedata  throws nosuchobjectexception
metaexception  texception  ioexception  invalidobjectexception  invalidinputexception
boolean success   false
path tblpath   null
list<path> partpaths   null
try
ms opentransaction
// drop the underlying index table
index index   get_index_by_name dbname  tblname  indexname
if  index    null
throw new nosuchobjectexception indexname
ms dropindex dbname  tblname  indexname
string idxtblname   index getindextablename
if  idxtblname    null
table tbl   null
tbl   this get_table dbname  idxtblname
if  tbl getsd      null
throw new metaexception
if  tbl getsd   getlocation      null
tblpath   new path tbl getsd   getlocation
if   wh iswritable tblpath getparent
throw new metaexception
tblpath getparent
hiveconf getuser
// drop the partitions and get a list of partition locations which need to be deleted
partpaths   droppartitionsandgetlocations ms  dbname  idxtblname  tblpath
tbl getpartitionkeys    deletedata
if   ms droptable dbname  idxtblname
throw new metaexception
idxtblname       idxtblname
success   ms committransaction
finally
if   success
ms rollbacktransaction
return false
else if  deletedata    tblpath    null
deletepartitiondata partpaths
deletetabledata tblpath
// ok even if the data is not deleted
return true
@override
public index get_index_by_name final string dbname  final string tblname
final string indexname  throws metaexception  nosuchobjectexception
texception
startfunction        dbname
tblname       indexname
index ret   null
exception ex   null
try
ret   get_index_by_name_core getms    dbname  tblname  indexname
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tblname
return ret
private index get_index_by_name_core final rawstore ms  final string db_name
final string tbl_name  final string index_name
throws metaexception  nosuchobjectexception  texception
index index   ms getindex db_name  tbl_name  index_name
if  index    null
throw new nosuchobjectexception db_name       tbl_name
index_name
return index
@override
public list<string> get_index_names final string dbname  final string tblname
final short maxindexes  throws metaexception  texception
starttablefunction    dbname  tblname
list<string> ret   null
exception ex   null
try
ret   getms   listindexnames dbname  tblname  maxindexes
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex  tblname
return ret
@override
public list<index> get_indexes final string dbname  final string tblname
final short maxindexes  throws nosuchobjectexception  metaexception
texception
starttablefunction    dbname  tblname
list<index> ret   null
exception ex   null
try
ret   getms   getindexes dbname  tblname  maxindexes
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tblname
return ret
private string lowercaseconvertpartname string partname  throws metaexception
boolean isfirst   true
map<string  string> partspec   warehouse makeescspecfromname partname
string convertedpartname   new string
for  map entry<string  string> entry   partspec entryset
string partcolname   entry getkey
string partcolval   entry getvalue
if   isfirst
convertedpartname
else
isfirst   false
convertedpartname    partcolname tolowercase         partcolval
return convertedpartname
public columnstatistics get_table_column_statistics string dbname  string tablename
string colname  throws nosuchobjectexception  metaexception  texception
invalidinputexception  invalidobjectexception
dbname   dbname tolowercase
tablename   tablename tolowercase
colname   colname tolowercase
startfunction     dbname       tablename
colname
columnstatistics statsobj   null
try
statsobj   getms   gettablecolumnstatistics dbname  tablename  colname
finally
endfunction    statsobj    null  null  tablename
return statsobj
public columnstatistics get_partition_column_statistics string dbname  string tablename
string partname  string colname  throws nosuchobjectexception  metaexception
invalidinputexception  texception invalidobjectexception
dbname   dbname tolowercase
tablename   tablename tolowercase
colname   colname tolowercase
string convertedpartname   lowercaseconvertpartname partname
startfunction     dbname       tablename
convertedpartname       colname
columnstatistics statsobj   null
try
list<string> partvals   getpartvalsfromname getms    dbname  tablename  partname
statsobj   getms   getpartitioncolumnstatistics dbname  tablename  convertedpartname
partvals  colname
finally
endfunction    statsobj    null  null  tablename
return statsobj
public boolean update_table_column_statistics columnstatistics colstats
throws nosuchobjectexception invalidobjectexception metaexception texception
invalidinputexception
string dbname   null
string tablename   null
string colname   null
columnstatisticsdesc statsdesc   colstats getstatsdesc
dbname   statsdesc getdbname   tolowercase
tablename   statsdesc gettablename   tolowercase
statsdesc setdbname dbname
statsdesc settablename tablename
long time   system currenttimemillis     1000
statsdesc setlastanalyzed time
list<columnstatisticsobj> statsobjs    colstats getstatsobj
for  columnstatisticsobj statsobj statsobjs
colname   statsobj getcolname   tolowercase
statsobj setcolname colname
startfunction     dbname       tablename
colname
colstats setstatsdesc statsdesc
colstats setstatsobj statsobjs
boolean ret   false
try
ret   getms   updatetablecolumnstatistics colstats
return ret
finally
endfunction    ret    false  null  tablename
public boolean update_partition_column_statistics columnstatistics colstats
throws nosuchobjectexception invalidobjectexception metaexception texception
invalidinputexception
string dbname   null
string tablename   null
string partname   null
string colname   null
columnstatisticsdesc statsdesc   colstats getstatsdesc
dbname   statsdesc getdbname   tolowercase
tablename   statsdesc gettablename   tolowercase
partname   lowercaseconvertpartname statsdesc getpartname
statsdesc setdbname dbname
statsdesc settablename tablename
statsdesc setpartname partname
long time   system currenttimemillis     1000
statsdesc setlastanalyzed time
list<columnstatisticsobj> statsobjs    colstats getstatsobj
for  columnstatisticsobj statsobj statsobjs
colname   statsobj getcolname   tolowercase
statsobj setcolname colname
startfunction     dbname       tablename
partname       colname
colstats setstatsdesc statsdesc
colstats setstatsobj statsobjs
boolean ret   false
try
list<string> partvals   getpartvalsfromname getms    dbname
tablename  partname
ret   getms   updatepartitioncolumnstatistics colstats  partvals
return ret
finally
endfunction    ret    false  null  tablename
public boolean delete_partition_column_statistics string dbname  string tablename
string partname  string colname  throws nosuchobjectexception  metaexception
invalidobjectexception  texception  invalidinputexception
dbname   dbname tolowercase
tablename   tablename tolowercase
if  colname    null
colname   colname tolowercase
string convertedpartname   lowercaseconvertpartname partname
startfunction     dbname       tablename
convertedpartname       colname
boolean ret   false
try
list<string> partvals   getpartvalsfromname getms    dbname  tablename  convertedpartname
ret   getms   deletepartitioncolumnstatistics dbname  tablename
convertedpartname  partvals  colname
finally
endfunction    ret    false  null  tablename
return ret
public boolean delete_table_column_statistics string dbname  string tablename  string colname
throws nosuchobjectexception  metaexception  invalidobjectexception  texception
invalidinputexception
dbname   dbname tolowercase
tablename   tablename tolowercase
if  colname    null
colname   colname tolowercase
startfunction     dbname       tablename
colname
boolean ret   false
try
ret   getms   deletetablecolumnstatistics dbname  tablename  colname
finally
endfunction    ret    false  null  tablename
return ret
@override
public list<partition> get_partitions_by_filter final string dbname
final string tblname  final string filter  final short maxparts
throws metaexception  nosuchobjectexception  texception
starttablefunction    dbname  tblname
list<partition> ret   null
exception ex   null
try
ret   getms   getpartitionsbyfilter dbname  tblname  filter  maxparts
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tblname
return ret
private void rethrowexception exception e
throws metaexception  nosuchobjectexception  texception
// todo: both of these are texception, why do we need these separate clauses?
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof nosuchobjectexception
throw  nosuchobjectexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
@override
public list<partition> get_partitions_by_names final string dbname
final string tblname  final list<string> partnames
throws metaexception  nosuchobjectexception  texception
starttablefunction    dbname  tblname
list<partition> ret   null
exception ex   null
try
ret   getms   getpartitionsbynames dbname  tblname  partnames
catch  exception e
ex   e
rethrowexception e
finally
endfunction    ret    null  ex  tblname
return ret
@override
public principalprivilegeset get_privilege_set hiveobjectref hiveobject
string username  list<string> groupnames  throws metaexception
texception
if  hiveobject getobjecttype      hiveobjecttype column
string partname   getpartname hiveobject
return this get_column_privilege_set hiveobject getdbname    hiveobject
getobjectname    partname  hiveobject getcolumnname    username
groupnames
else if  hiveobject getobjecttype      hiveobjecttype partition
string partname   getpartname hiveobject
return this get_partition_privilege_set hiveobject getdbname
hiveobject getobjectname    partname  username  groupnames
else if  hiveobject getobjecttype      hiveobjecttype database
return this get_db_privilege_set hiveobject getdbname    username
groupnames
else if  hiveobject getobjecttype      hiveobjecttype table
return this get_table_privilege_set hiveobject getdbname    hiveobject
getobjectname    username  groupnames
else if  hiveobject getobjecttype      hiveobjecttype global
return this get_user_privilege_set username  groupnames
return null
private string getpartname hiveobjectref hiveobject  throws metaexception
string partname   null
list<string> partvalue   hiveobject getpartvalues
if  partvalue    null    partvalue size   > 0
try
table table   get_table hiveobject getdbname    hiveobject
getobjectname
partname   warehouse
makepartname table getpartitionkeys    partvalue
catch  nosuchobjectexception e
throw new metaexception e getmessage
return partname
public principalprivilegeset get_column_privilege_set final string dbname
final string tablename  final string partname  final string columnname
final string username  final list<string> groupnames  throws metaexception
texception
incrementcounter
principalprivilegeset ret   null
try
ret   getms   getcolumnprivilegeset
dbname  tablename  partname  columnname  username  groupnames
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
public principalprivilegeset get_db_privilege_set final string dbname
final string username  final list<string> groupnames  throws metaexception
texception
incrementcounter
principalprivilegeset ret   null
try
ret   getms   getdbprivilegeset dbname  username  groupnames
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
public principalprivilegeset get_partition_privilege_set
final string dbname  final string tablename  final string partname
final string username  final list<string> groupnames
throws metaexception  texception
incrementcounter
principalprivilegeset ret   null
try
ret   getms   getpartitionprivilegeset dbname  tablename  partname
username  groupnames
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
public principalprivilegeset get_table_privilege_set final string dbname
final string tablename  final string username
final list<string> groupnames  throws metaexception  texception
incrementcounter
principalprivilegeset ret   null
try
ret   getms   gettableprivilegeset dbname  tablename  username
groupnames
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
@override
public boolean grant_role final string rolename
final string username  final principaltype principaltype
final string grantor  final principaltype grantortype  final boolean grantoption
throws metaexception  texception
incrementcounter
boolean ret   null
try
rawstore ms   getms
role role   ms getrole rolename
ret   ms grantrole role  username  principaltype  grantor  grantortype  grantoption
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
public list<role> list_roles final string principalname
final principaltype principaltype  throws metaexception  texception
incrementcounter
list<role> ret   null
try
list<role> result   new arraylist<role>
list<mrolemap> rolemap   getms   listroles principalname  principaltype
if  rolemap    null
for  mrolemap role   rolemap
mrole r   role getrole
result add new role r getrolename    r
getcreatetime    r getownername
ret   result
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
@override
public boolean create_role final role role
throws metaexception  texception
incrementcounter
boolean ret   null
try
ret   getms   addrole role getrolename    role getownername
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
@override
public boolean drop_role final string rolename
throws metaexception  texception
incrementcounter
boolean ret   null
try
ret   getms   removerole rolename
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
@override
public list<string> get_role_names   throws metaexception  texception
incrementcounter
list<string> ret   null
try
ret   getms   listrolenames
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
@override
public boolean grant_privileges final privilegebag privileges  throws metaexception
texception
incrementcounter
boolean ret   null
try
ret   getms   grantprivileges privileges
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
@override
public boolean revoke_role final string rolename  final string username
final principaltype principaltype  throws metaexception  texception
incrementcounter
boolean ret   null
try
rawstore ms   getms
role mrole   ms getrole rolename
ret   ms revokerole mrole  username  principaltype
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
@override
public boolean revoke_privileges final privilegebag privileges
throws metaexception  texception
incrementcounter
boolean ret   null
try
ret   getms   revokeprivileges privileges
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
public principalprivilegeset get_user_privilege_set final string username
final list<string> groupnames  throws metaexception  texception
incrementcounter
principalprivilegeset ret   null
try
ret   getms   getuserprivilegeset username  groupnames
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
public principaltype getprincipaltype string principaltype
return principaltype valueof principaltype
@override
public list<hiveobjectprivilege> list_privileges string principalname
principaltype principaltype  hiveobjectref hiveobject
throws metaexception  texception
if  hiveobject getobjecttype      hiveobjecttype global
return this list_global_privileges principalname  principaltype
else if  hiveobject getobjecttype      hiveobjecttype database
return this list_db_privileges principalname  principaltype  hiveobject
getdbname
else if  hiveobject getobjecttype      hiveobjecttype table
return this list_table_privileges principalname  principaltype
hiveobject getdbname    hiveobject getobjectname
else if  hiveobject getobjecttype      hiveobjecttype partition
return this list_partition_privileges principalname  principaltype
hiveobject getdbname    hiveobject getobjectname    hiveobject
getpartvalues
else if  hiveobject getobjecttype      hiveobjecttype column
return this list_column_privileges principalname  principaltype
hiveobject getdbname    hiveobject getobjectname    hiveobject
getpartvalues    hiveobject getcolumnname
return null
public list<hiveobjectprivilege> list_column_privileges
final string principalname  final principaltype principaltype
final string dbname  final string tablename  final list<string> partvalues
final string columnname  throws metaexception  texception
incrementcounter
list<hiveobjectprivilege> ret   null
try
rawstore ms   getms
string partname   null
if  partvalues    null    partvalues size   > 0
table tbl   get_table dbname  tablename
partname   warehouse makepartname tbl getpartitionkeys    partvalues
list<hiveobjectprivilege> result   collections <hiveobjectprivilege> emptylist
if  partname    null
partition part   null
part   get_partition_by_name dbname  tablename  partname
list<mpartitioncolumnprivilege> mpartitioncols   ms listprincipalpartitioncolumngrants
principalname
principaltype  dbname  tablename  partname  columnname
if  mpartitioncols size   > 0
result   new arraylist<hiveobjectprivilege>
for  int i   0  i < mpartitioncols size    i
mpartitioncolumnprivilege scol   mpartitioncols get i
hiveobjectref objectref   new hiveobjectref
hiveobjecttype column  dbname  tablename
part    null ? null   part getvalues    scol
getcolumnname
hiveobjectprivilege secobj   new hiveobjectprivilege objectref
scol getprincipalname    principaltype
new privilegegrantinfo scol getprivilege    scol
getcreatetime    scol getgrantor    principaltype
valueof scol getgrantortype     scol getgrantoption
result add secobj
else
list<mtablecolumnprivilege> mtablecols   ms
listprincipaltablecolumngrants principalname  principaltype
dbname  tablename  columnname
if  mtablecols size   > 0
result   new arraylist<hiveobjectprivilege>
for  int i   0  i < mtablecols size    i
mtablecolumnprivilege scol   mtablecols get i
hiveobjectref objectref   new hiveobjectref
hiveobjecttype column  dbname  tablename  null  scol
getcolumnname
hiveobjectprivilege secobj   new hiveobjectprivilege
objectref  scol getprincipalname    principaltype
new privilegegrantinfo scol getprivilege    scol
getcreatetime    scol getgrantor    principaltype
valueof scol getgrantortype     scol
getgrantoption
result add secobj
ret   result
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
return ret
public list<hiveobjectprivilege> list_db_privileges final string principalname
final principaltype principaltype  final string dbname
throws metaexception  texception
incrementcounter
try
rawstore ms   getms
list<mdbprivilege> mdbs   ms listprincipaldbgrants
principalname  principaltype  dbname
if  mdbs size   > 0
list<hiveobjectprivilege> result   new arraylist<hiveobjectprivilege>
for  int i   0  i < mdbs size    i
mdbprivilege sdb   mdbs get i
hiveobjectref objectref   new hiveobjectref
hiveobjecttype database  dbname  null  null  null
hiveobjectprivilege secobj   new hiveobjectprivilege objectref
sdb getprincipalname    principaltype
new privilegegrantinfo sdb getprivilege    sdb
getcreatetime    sdb getgrantor    principaltype
valueof sdb getgrantortype     sdb getgrantoption
result add secobj
return result
return collections <hiveobjectprivilege> emptylist
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
public list<hiveobjectprivilege> list_partition_privileges
final string principalname  final principaltype principaltype
final string dbname  final string tablename  final list<string> partvalues
throws metaexception  texception
incrementcounter
try
rawstore ms   getms
table tbl   get_table dbname  tablename
string partname   warehouse makepartname tbl getpartitionkeys    partvalues
list<mpartitionprivilege> mparts   ms listprincipalpartitiongrants
principalname  principaltype  dbname  tablename  partname
if  mparts size   > 0
list<hiveobjectprivilege> result   new arraylist<hiveobjectprivilege>
for  int i   0  i < mparts size    i
mpartitionprivilege spart   mparts get i
hiveobjectref objectref   new hiveobjectref
hiveobjecttype partition  dbname  tablename  partvalues

hiveobjectprivilege secobj   new hiveobjectprivilege objectref
spart getprincipalname    principaltype
new privilegegrantinfo spart getprivilege    spart
getcreatetime    spart getgrantor    principaltype
valueof spart getgrantortype     spart
getgrantoption
result add secobj
return result
return collections <hiveobjectprivilege> emptylist
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
public list<hiveobjectprivilege> list_table_privileges
final string principalname  final principaltype principaltype
final string dbname  final string tablename  throws metaexception
texception
incrementcounter
try
list<mtableprivilege> mtbls   getms
listalltablegrants principalname  principaltype  dbname  tablename
if  mtbls size   > 0
list<hiveobjectprivilege> result   new arraylist<hiveobjectprivilege>
for  int i   0  i < mtbls size    i
mtableprivilege stbl   mtbls get i
hiveobjectref objectref   new hiveobjectref
hiveobjecttype table  dbname  tablename  null  null
hiveobjectprivilege secobj   new hiveobjectprivilege objectref
stbl getprincipalname    principaltype
new privilegegrantinfo stbl getprivilege    stbl getcreatetime    stbl
getgrantor    principaltype valueof stbl
getgrantortype     stbl getgrantoption
result add secobj
return result
return collections <hiveobjectprivilege> emptylist
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
public list<hiveobjectprivilege> list_global_privileges
final string principalname  final principaltype principaltype
throws metaexception  texception
incrementcounter
try
list<mglobalprivilege> musers   getms   listprincipalglobalgrants
principalname  principaltype
if  musers size   > 0
list<hiveobjectprivilege> result   new arraylist<hiveobjectprivilege>
for  int i   0  i < musers size    i
mglobalprivilege susr   musers get i
hiveobjectref objectref   new hiveobjectref
hiveobjecttype global  null  null  null  null
hiveobjectprivilege secuser   new hiveobjectprivilege
objectref  susr getprincipalname    principaltype
new privilegegrantinfo susr getprivilege    susr
getcreatetime    susr getgrantor    principaltype
valueof susr getgrantortype     susr getgrantoption
result add secuser
return result
return collections <hiveobjectprivilege> emptylist
catch  metaexception e
throw e
catch  exception e
throw new runtimeexception e
@override
public void cancel_delegation_token string token_str_form
throws metaexception  texception
startfunction
boolean success   false
exception ex   null
try
hivemetastore canceldelegationtoken token_str_form
success   true
catch  ioexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    success  ex
@override
public long renew_delegation_token string token_str_form
throws metaexception  texception
startfunction
long ret   null
exception ex   null
try
ret   hivemetastore renewdelegationtoken token_str_form
catch  ioexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex
return ret
@override
public string get_delegation_token string token_owner
string renewer_kerberos_principal_name
throws metaexception  texception
startfunction
string ret   null
exception ex   null
try
ret
hivemetastore getdelegationtoken token_owner
renewer_kerberos_principal_name
catch  ioexception e
ex   e
throw new metaexception e getmessage
catch  interruptedexception e
ex   e
throw new metaexception e getmessage
catch  exception e
ex   e
if  e instanceof metaexception
throw  metaexception  e
else if  e instanceof texception
throw  texception  e
else
metaexception me   new metaexception e tostring
me initcause e
throw me
finally
endfunction    ret    null  ex
return ret
@override
public void markpartitionforevent final string db_name  final string tbl_name
final map<string  string> partname  final partitioneventtype evttype  throws
metaexception  texception  nosuchobjectexception  unknowndbexception
unknowntableexception
invalidpartitionexception  unknownpartitionexception
table tbl   null
exception ex   null
try
startpartitionfunction    db_name  tbl_name  partname
firepreevent new preloadpartitiondoneevent db_name  tbl_name  partname  this
tbl   getms   markpartitionforevent db_name  tbl_name  partname  evttype
if  null    tbl
throw new unknowntableexception     tbl_name
else
for  metastoreeventlistener listener   listeners
listener onloadpartitiondone new loadpartitiondoneevent true  tbl  partname  this
catch  exception original
ex   original
log error original
if  original instanceof nosuchobjectexception
throw  nosuchobjectexception  original
else if  original instanceof unknowntableexception
throw  unknowntableexception  original
else if  original instanceof unknowndbexception
throw  unknowndbexception  original
else if  original instanceof unknownpartitionexception
throw  unknownpartitionexception  original
else if  original instanceof invalidpartitionexception
throw  invalidpartitionexception  original
else if  original instanceof metaexception
throw  metaexception  original
else
metaexception me   new metaexception original tostring
me initcause original
throw me
finally
endfunction    tbl    null  ex  tbl_name
@override
public boolean ispartitionmarkedforevent final string db_name  final string tbl_name
final map<string  string> partname  final partitioneventtype evttype  throws
metaexception  nosuchobjectexception  unknowndbexception  unknowntableexception
texception  unknownpartitionexception  invalidpartitionexception
startpartitionfunction    db_name  tbl_name  partname
boolean ret   null
exception ex   null
try
ret   getms   ispartitionmarkedforevent db_name  tbl_name  partname  evttype
catch  exception original
log error original
ex   original
if  original instanceof nosuchobjectexception
throw  nosuchobjectexception  original
else if  original instanceof unknowntableexception
throw  unknowntableexception  original
else if  original instanceof unknowndbexception
throw  unknowndbexception  original
else if  original instanceof unknownpartitionexception
throw  unknownpartitionexception  original
else if  original instanceof invalidpartitionexception
throw  invalidpartitionexception  original
else if  original instanceof metaexception
throw  metaexception  original
else
metaexception me   new metaexception original tostring
me initcause original
throw me
finally
endfunction    ret    null  ex  tbl_name
return ret
@override
public list<string> set_ugi string username  list<string> groupnames  throws metaexception
texception
collections addall groupnames  username
return groupnames
@override
public boolean partition_name_has_valid_characters list<string> part_vals
boolean throw_exception  throws texception  metaexception
startfunction
boolean ret   false
exception ex   null
try
if  throw_exception
metastoreutils validatepartitionnamecharacters part_vals  partitionvalidationpattern
ret   true
else
ret   metastoreutils partitionnamehasvalidcharacters part_vals
partitionvalidationpattern
catch  exception e
if  e instanceof metaexception
throw  metaexception e
else
ex   e
metaexception me   new metaexception
me initcause e
throw me
endfunction    true  null
return ret
public static ihmshandler newhmshandler string name  hiveconf hiveconf  throws metaexception
return retryinghmshandler getproxy hiveconf  name
/**
* discard a current delegation token.
*
* @param tokenstrform
*          the token in string form
*/
public static void canceldelegationtoken string tokenstrform
throws ioexception
saslserver canceldelegationtoken tokenstrform
/**
* get a new delegation token.
*
* @param renewer
*          the designated renewer
*/
public static string getdelegationtoken string owner  string renewer
throws ioexception  interruptedexception
return saslserver getdelegationtoken owner  renewer
/**
* renew a delegation token to extend its lifetime.
*
* @param tokenstrform
*          the token in string form
*/
public static long renewdelegationtoken string tokenstrform
throws ioexception
return saslserver renewdelegationtoken tokenstrform
/**
* hivemetastore specific cli
*
*/
static public class hivemetastorecli extends commonclioptions
int port   default_hive_metastore_port
@suppresswarnings
public hivemetastorecli
super    true
// -p port
options addoption optionbuilder
hasarg
withargname
withdescription
default_hive_metastore_port
create
@override
public void parse string args
super parse args
// support the old syntax "hivemetastore [port]" but complain
args   commandline getargs
if  args length > 0
// complain about the deprecated syntax -- but still run
system err println
port   new integer args
// notice that command line options take precedence over the
// deprecated (old style) naked args...
if  commandline hasoption
port   integer parseint commandline getoptionvalue
else
// legacy handling
string metastoreport   system getenv
if  metastoreport    null
port   integer parseint metastoreport
/**
* @param args
*/
public static void main string args  throws throwable
hivemetastorecli cli   new hivemetastorecli
cli parse args
final boolean iscliverbose   cli isverbose
// note: it is critical to do this prior to initializing log4j, otherwise
// any log specific settings via hiveconf will be ignored
properties hiveconf   cli addhiveconftosystemproperties
// if the log4j.configuration property hasn't already been explicitly set,
// use hive's default log4j configuration
if  system getproperty       null
// note: it is critical to do this here so that log4j is reinitialized
// before any of the other core hive classes are loaded
try
logutils inithivelog4j
catch  loginitializationexception e
hmshandler log warn e getmessage
try
string msg       cli port
hmshandler log info msg
if  cli isverbose
system err println msg
hiveconf conf   new hiveconf hmshandler class
// set all properties specified on the command line
for  map entry<object  object> item   hiveconf entryset
conf set  string  item getkey     string  item getvalue
// add shutdown hook.
runtime getruntime   addshutdownhook new thread
@override
public void run
string shutdownmsg
hmshandler log info shutdownmsg
if  iscliverbose
system err println shutdownmsg
startmetastore cli port  shimloader gethadoopthriftauthbridge    conf
catch  throwable t
// catch the exception, log it and rethrow it.
hmshandler log
error    t
throw t
/**
* start metastore based on a passed {@link hadoopthriftauthbridge}
*
* @param port
* @param bridge
* @throws throwable
*/
public static void startmetastore int port  hadoopthriftauthbridge bridge
throws throwable
startmetastore port  bridge  new hiveconf hmshandler class
/**
* start metastore based on a passed {@link hadoopthriftauthbridge}
*
* @param port
* @param bridge
* @param conf
*          configuration overrides
* @throws throwable
*/
public static void startmetastore int port  hadoopthriftauthbridge bridge
hiveconf conf  throws throwable
try
// server will create new threads up to max as necessary. after an idle
// period, it will destory threads to keep the number of threads in the
// pool to min.
int minworkerthreads   conf getintvar hiveconf confvars metastoreserverminthreads
int maxworkerthreads   conf getintvar hiveconf confvars metastoreservermaxthreads
boolean tcpkeepalive   conf getboolvar hiveconf confvars metastore_tcp_keep_alive
boolean useframedtransport   conf getboolvar confvars metastore_use_thrift_framed_transport
usesasl   conf getboolvar hiveconf confvars metastore_use_thrift_sasl
tservertransport servertransport   tcpkeepalive ?
new tserversocketkeepalive port    new tserversocket port
tprocessor processor
ttransportfactory transfactory
if  usesasl
// we are in secure mode.
if  useframedtransport
throw new hivemetaexception
saslserver   bridge createserver
conf getvar hiveconf confvars metastore_kerberos_keytab_file
conf getvar hiveconf confvars metastore_kerberos_principal
// start delegation token manager
hmshandler hmshandler   new hmshandler    conf
saslserver startdelegationtokensecretmanager conf  hmshandler
transfactory   saslserver createtransportfactory
metastoreutils getmetastoresaslproperties conf
processor   saslserver wrapprocessor
new thrifthivemetastore processor<hmshandler> hmshandler
log info
else
// we are in unsecure mode.
ihmshandler handler   newhmshandler    conf
if  conf getboolvar confvars metastore_execute_set_ugi
transfactory   useframedtransport ?
new chainedttransportfactory new tframedtransport factory
new tugicontainingtransport factory
new tugicontainingtransport factory
processor   new tugibasedprocessor<ihmshandler> handler
log info
else
transfactory   useframedtransport ?
new tframedtransport factory     new ttransportfactory
processor   new tsetipaddressprocessor<ihmshandler> handler
log info
tthreadpoolserver args args   new tthreadpoolserver args servertransport
processor processor
transportfactory transfactory
protocolfactory new tbinaryprotocol factory
minworkerthreads minworkerthreads
maxworkerthreads maxworkerthreads
tserver tserver   new tthreadpoolserver args
hmshandler log info     port
hmshandler log info
minworkerthreads
hmshandler log info
maxworkerthreads
hmshandler log info     tcpkeepalive
tserver serve
catch  throwable x
x printstacktrace
hmshandler log error stringutils stringifyexception x
throw x