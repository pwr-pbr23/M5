/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql udf generic
import java util arraylist
import java util list
import java util arrays
import java util collections
import java util random
import org apache hadoop hive serde2 io doublewritable
/**
* a generic, re-usable histogram class that supports partial aggregations.
* the algorithm is a heuristic adapted from the following paper:
* yael ben-haim and elad tom-tov, "a streaming parallel decision tree algorithm",
* j. machine learning research 11 (2010), pp. 849--872. although there are no approximation
* guarantees, it appears to work well with adequate data and a large (e.g., 20-80) number
* of histogram bins.
*/
public class numerichistogram
/**
* the coord class defines a histogram bin, which is just an (x,y) pair.
*/
static class coord implements comparable
double x
double y
public int compareto object other
coord o    coord  other
if x < o x
return  1
if x > o x
return 1
return 0
// class variables
private int nbins
private int nusedbins
private arraylist<coord> bins
private random prng
/**
* creates a new histogram object. note that the allocate() or merge()
* method must be called before the histogram can be used.
*/
public numerichistogram
nbins   0
nusedbins   0
bins   null
// init the rng for breaking ties in histogram merging. a fixed seed is specified here
// to aid testing, but can be eliminated to use a time-based seed (which would
// make the algorithm non-deterministic).
prng   new random 31183
/**
* resets a histogram object to its initial state. allocate() or merge() must be
* called again before use.
*/
public void reset
bins   null
nbins   nusedbins   0
/**
* returns the number of bins currently being used by the histogram.
*/
public int getusedbins
return nusedbins
/**
* returns true if this histogram object has been initialized by calling merge()
* or allocate().
*/
public boolean isready
return nbins    0
/**
* returns a particular histogram bin.
*/
public coord getbin int b
return bins get b
/**
* sets the number of histogram bins to use for approximating data.
*
* @param num_bins number of non-uniform-width histogram bins to use
*/
public void allocate int num_bins
nbins   num_bins
bins   new arraylist<coord>
nusedbins   0
/**
* takes a serialized histogram created by the serialize() method and merges
* it with the current histogram object.
*
* @param other a serialized histogram created by the serialize() method
* @see #merge
*/
public void merge list<doublewritable> other
if other    null
return
if nbins    0    nusedbins    0
// our aggregation buffer has nothing in it, so just copy over 'other'
// by deserializing the arraylist of (x,y) pairs into an array of coord objects
nbins    int  other get 0  get
nusedbins    other size   1  2
bins   new arraylist<coord> nusedbins
for  int i   1  i < other size    i  2
coord bin   new coord
bin x   other get i  get
bin y   other get i 1  get
bins add bin
else
// the aggregation buffer already contains a partial histogram. therefore, we need
// to merge histograms using algorithm #2 from the ben-haim and tom-tov paper.
arraylist<coord> tmp_bins   new arraylist<coord> nusedbins    other size   1  2
// copy all the histogram bins from us and 'other' into an overstuffed histogram
for  int i   0  i < nusedbins  i
coord bin   new coord
bin x   bins get i  x
bin y   bins get i  y
tmp_bins add bin
for  int j   1  j < other size    j    2
coord bin   new coord
bin x   other get j  get
bin y   other get j 1  get
tmp_bins add bin
collections sort tmp_bins
// now trim the overstuffed histogram down to the correct number of bins
bins   tmp_bins
nusedbins     other size   1  2
trim
/**
* adds a new data point to the histogram approximation. make sure you have
* called either allocate() or merge() first. this method implements algorithm #1
* from ben-haim and tom-tov, "a streaming parallel decision tree algorithm", jmlr 2010.
*
* @param v the data point to add to the histogram approximation.
*/
public void add double v
// binary search to find the closest bucket that v should go into.
// 'bin' should be interpreted as the bin to shift right in order to accomodate
// v. as a result, bin is in the range [0,n], where n means that the value v is
// greater than all the n bins currently in the histogram. it is also possible that
// a bucket centered at 'v' already exists, so this must be checked in the next step.
int bin   0
for int l 0  r nusedbins  l < r
bin    l r  2
if  bins get bin  x > v
r   bin
else
if  bins get bin  x < v
l     bin
else
break     break loop on equal comparator
// if we found an exact bin match for value v, then just increment that bin's count.
// otherwise, we need to insert a new bin and trim the resulting histogram back to size.
// a possible optimization here might be to set some threshold under which 'v' is just
// assumed to be equal to the closest bin -- if fabs(v-bins[bin].x) < threshold, then
// just increment 'bin'. this is not done now because we don't want to make any
// assumptions about the range of numeric data being analyzed.
if  bin < nusedbins    bins get bin  x    v
bins get bin  y
else
coord newbin   new coord
newbin x   v
newbin y   1
bins add bin  newbin
// trim the bins down to the correct number of bins.
if    nusedbins > nbins
trim
/**
* trims a histogram down to 'nbins' bins by iteratively merging the closest bins.
* if two pairs of bins are equally close to each other, decide uniformly at random which
* pair to merge, based on a prng.
*/
private void trim
while nusedbins > nbins
// find the closest pair of bins in terms of x coordinates. break ties randomly.
double smallestdiff   bins get 1  x   bins get 0  x
int smallestdiffloc   0  smallestdiffcount   1
for int i   1  i < nusedbins 1  i
double diff   bins get i 1  x   bins get i  x
if diff < smallestdiff
smallestdiff   diff
smallestdiffloc   i
smallestdiffcount   1
else
if diff    smallestdiff    prng nextdouble   <   1 0   smallestdiffcount
smallestdiffloc   i
// merge the two closest bins into their average x location, weighted by their heights.
// the height of the new bin is the sum of the heights of the old bins.
// double d = bins[smallestdiffloc].y + bins[smallestdiffloc+1].y;
// bins[smallestdiffloc].x *= bins[smallestdiffloc].y / d;
// bins[smallestdiffloc].x += bins[smallestdiffloc+1].x / d *
//   bins[smallestdiffloc+1].y;
// bins[smallestdiffloc].y = d;
double d   bins get smallestdiffloc  y   bins get smallestdiffloc 1  y
coord smallestdiffbin   bins get smallestdiffloc
smallestdiffbin x    smallestdiffbin y   d
smallestdiffbin x    bins get smallestdiffloc 1  x   d   bins get smallestdiffloc 1  y
smallestdiffbin y   d
// shift the remaining bins left one position
bins remove smallestdiffloc 1
nusedbins
/**
* gets an approximate quantile value from the current histogram. some popular
* quantiles are 0.5 (median), 0.95, and 0.98.
*
* @param q the requested quantile, must be strictly within the range (0,1).
* @return the quantile value.
*/
public double quantile double q
assert bins    null    nusedbins > 0    nbins > 0
double sum   0  csum   0
int b
for b   0  b < nusedbins  b
sum    bins get b  y
for b   0  b < nusedbins  b
csum    bins get b  y
if csum   sum >  q
if b    0
return bins get b  x
csum    bins get b  y
double r   bins get b 1  x
q sum   csum     bins get b  x   bins get b 1  x   bins get b  y
return r
return  1     for xlint  code will never reach here
/**
* in preparation for a hive merge() call, serializes the current histogram object into an
* arraylist of doublewritable objects. this list is deserialized and merged by the
* merge method.
*
* @return an arraylist of hadoop doublewritable objects that represents the current
* histogram.
* @see #merge
*/
public arraylist<doublewritable> serialize
arraylist<doublewritable> result   new arraylist<doublewritable>
// return a single arraylist where the first element is the number of bins bins,
// and subsequent elements represent bins (x,y) pairs.
result add new doublewritable nbins
if bins    null
for int i   0  i < nusedbins  i
result add new doublewritable bins get i  x
result add new doublewritable bins get i  y
return result
public int getnumbins
return bins    null ? 0   bins size