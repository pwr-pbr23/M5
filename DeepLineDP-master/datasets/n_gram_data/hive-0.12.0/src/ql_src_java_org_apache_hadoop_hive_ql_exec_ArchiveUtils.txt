/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql exec
import java net uri
import java net urisyntaxexception
import java util arraylist
import java util hashmap
import java util iterator
import java util linkedhashmap
import java util linkedlist
import java util list
import java util map
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop fs path
import org apache hadoop hive conf hiveconf
import org apache hadoop hive metastore warehouse
import org apache hadoop hive metastore api fieldschema
import org apache hadoop hive metastore api metaexception
import org apache hadoop hive ql metadata hive
import org apache hadoop hive ql metadata hiveexception
import org apache hadoop hive ql metadata partition
import org apache hadoop hive ql metadata table
import org apache hadoop hive shims hadoopshims
/**
* archiveutils.
*
*/
@suppresswarnings
public final class archiveutils
private static final log log   logfactory getlog archiveutils class getname
public static string archiving_level
/**
* partspecinfo keeps fields and values extracted from partial partition info
* which is prefix of the full info.
*/
public static class partspecinfo
public list<fieldschema> fields
public list<string> values
private partspecinfo list<fieldschema> fields  list<string> values
this fields   fields
this values   values
/**
* extract partial prefix specification from table and key-value map
*
* @param tbl table in which partition is
* @param partspec specification of partition
* @return extracted specification
*/
static public partspecinfo create table tbl  map<string  string> partspec
throws hiveexception
// we have to check if we receive prefix of partition keys so in table
// scheme like table/ds=2011-01-02/hr=13/
// archive partition (ds='2011-01-02') will work and
// archive partition(hr='13') won't
list<fieldschema> prefixfields   new arraylist<fieldschema>
list<string> prefixvalues   new arraylist<string>
list<fieldschema> partcols   tbl getpartcols
iterator<string> itrpskeys   partspec keyset   iterator
for  fieldschema fs   partcols
if   itrpskeys hasnext
break
if   itrpskeys next   tolowercase   equals
fs getname   tolowercase
throw new hiveexception
partspec
prefixfields add fs
prefixvalues add partspec get fs getname
return new partspecinfo prefixfields  prefixvalues
/**
* creates path where partitions matching prefix should lie in filesystem
* @param tbl table in which partition is
* @return expected location of partitions matching prefix in filesystem
*/
public path createpath table tbl  throws hiveexception
string prefixsubdir
try
prefixsubdir   warehouse makepartname fields  values
catch  metaexception e
throw new hiveexception    e
uri tabledir   tbl getdatalocation
if tabledir    null
throw new hiveexception
return new path tabledir tostring    prefixsubdir
/**
* generates name for prefix partial partition specification.
*/
public string getname   throws hiveexception
try
return warehouse makepartname fields  values
catch  metaexception e
throw new hiveexception    e
/**
* harpathhelper helps to create har:/ uris for locations inside of archive.
*/
public static class harpathhelper
private final uri base  originalbase
/**
* creates helper for archive.
* @param archive absolute location of archive in underlying filesystem
* @param originalbase directory for which hadoop archive was created
*/
public harpathhelper hiveconf hconf  uri archive  uri originalbase  throws hiveexception
this originalbase   addslash originalbase
string parenthost   archive gethost
string harhost   null
if  parenthost    null
harhost   archive getscheme
else
harhost   archive getscheme         parenthost
// have to make sure there's slash after .har, otherwise resolve doesn't work
string path   addslash archive getpath
if  path endswith
throw new hiveexception
// haruri is used to access the partition's files, which are in the archive
// the format of the ri is something like:
// har://underlyingfsscheme-host:port/archivepath
try
base   new uri    archive getuserinfo    harhost  archive getport
path  archive getquery    archive getfragment
catch  urisyntaxexception e
throw new hiveexception    e
public uri getharuri uri original  hadoopshims shim  throws hiveexception
uri haruri   null
try
haruri   shim getharuri original  base  originalbase
catch  urisyntaxexception e
throw new hiveexception    e
return haruri
public static string addslash string s
return s endswith    ? s   s
/**
* makes sure, that uri points to directory by adding slash to it.
* useful in relativizing uris.
*/
public static uri addslash uri u  throws hiveexception
if u getpath   endswith
return u
else
try
return new uri u getscheme    u getauthority    u getpath        u getquery    u getfragment
catch  urisyntaxexception e
throw new hiveexception    e
/**
* determines whether a partition has been archived
*
* @param p
* @return is it archived?
*/
public static boolean isarchived partition p
map<string  string> params   p getparameters
if    equalsignorecase params get
org apache hadoop hive metastore api hive_metastoreconstants is_archived
return true
else
return false
/**
* returns archiving level, which is how many fields were set in partial
* specification archive was run for
*/
public static int getarchivinglevel partition p  throws hiveexception
if  isarchived p
throw new hiveexception
map<string  string> params   p getparameters
string lv   params get archiveutils archiving_level
if lv    null
return integer parseint lv
else       partitions archived before introducing multiple archiving
return p getvalues   size
/**
* get a prefix of the given parition's string representation. the sencond
* argument, level, is used for the prefix length. for example, partition
* (ds='2010-01-01', hr='00', min='00'), level 1 will reture 'ds=2010-01-01',
* and level 2 will return 'ds=2010-01-01/hr=00'.
*
* @param p
*          partition object
* @param level
*          level for prefix depth
* @return prefix of partition's string representation
* @throws hiveexception
*/
public static string getpartialname partition p  int level  throws hiveexception
list<fieldschema> ffields   p gettable   getpartcols
list<fieldschema> fields   new arraylist<fieldschema> level
list<string> fvalues   p getvalues
list<string> values   new arraylist<string> level
for int i  0 i<level i
fieldschema fs   ffields get i
string s   fvalues get i
fields add fs
values add s
try
return warehouse makepartname fields  values
catch  metaexception e
throw new hiveexception
/**
* determines if one can insert into partition(s), or there's a conflict with
* archive. it can be because partition is itself archived or it is to be
* created inside existing archive. the second case is when partition doesn't
* exist yet, but it would be inside of an archive if it existed. this one is
* quite tricky to check, we need to find at least one partition inside of
* the parent directory. if it is archived and archiving level tells that
* the archival was done of directory partition is in it means we cannot
* insert; otherwise we can.
* this method works both for full specifications and partial ones - in second
* case it checks if any partition that could possibly match such
* specification is inside archive.
*
* @param db - hive object
* @param tbl - table where partition is
* @param partspec - partition specification with possible nulls in case of
* dynamic partiton inserts
* @return null if partition can be inserted, string with colliding archive
* name when it can't
* @throws hiveexception
*/
public static string conflictingarchivenameornull hive db  table tbl
linkedhashmap<string  string> partspec
throws hiveexception
list<fieldschema> partkeys   tbl getpartitionkeys
int partspeclevel   0
for  fieldschema partkey   partkeys
if   partspec containskey partkey getname
break
partspeclevel
if partspeclevel    partspec size
throw new hiveexception     partspec
tbl gettablename
map<string  string> spec   new hashmap<string  string> partspec
list<string> reversedkeys   new linkedlist<string>
for  fieldschema fs   tbl getpartcols
if  spec containskey fs getname
reversedkeys add 0  fs getname
for  string rk   reversedkeys
list<partition> parts   db getpartitions tbl  spec   short  1
if  parts size      0
partition p   parts get 0
if   isarchived p
// if archiving was done at this or at upper level, every matched
// partition would be archived, so it not being archived means
// no archiving was done neither at this nor at upper level
return null
else if  getarchivinglevel p  > spec size
// if archiving was done at this or at upper level its level
// would be lesser or equal to specification size
// it is not, which means no archiving at this or upper level
return null
else
return getpartialname p  getarchivinglevel p
spec remove rk
return null