/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql udf generic
import java nio bytebuffer
import java util hashmap
import java util hashset
import java util map
import java util set
import org apache hadoop hive ql exec description
import org apache hadoop hive ql exec udfargumentexception
import org apache hadoop hive ql exec udfargumentlengthexception
import org apache hadoop hive ql exec udfargumenttypeexception
import org apache hadoop hive ql metadata hiveexception
import org apache hadoop hive ql udf udftype
import org apache hadoop hive serde2 objectinspector objectinspector
import org apache hadoop hive serde2 objectinspector objectinspector category
import org apache hadoop hive serde2 objectinspector objectinspectorconverters
import org apache hadoop hive serde2 objectinspector primitiveobjectinspector
import org apache hadoop hive serde2 objectinspector primitiveobjectinspector primitivecategory
import org apache hadoop hive serde2 objectinspector primitive primitiveobjectinspectorfactory
import org apache hadoop io text
/**
* translate(string input, string from, string to) is an equivalent function to translate in
* postgressql. see explain extended annotation below to read more about how this udf works
*
*/
@udftype deterministic   true
//@formatter:off
@description
name
value
extended
//@formatter:on
public class genericudftranslate extends genericudf
// for all practical purposes a code point is a fancy name for character. a java char data type
// can store characters that require 16 bits or less. however, the unicode specification has
// changed to allow for characters whose representation requires more than 16 bits. therefore we
// need to represent each character (called a code point from hereon) as int. more details at
// http://docs.oracle.com/javase/7/docs/api/java/lang/character.html
/**
* if a code point needs to be replaced with another code point, this map with store the mapping.
*/
private final map<integer  integer> replacementmap   new hashmap<integer  integer>
/**
* this set stores all the code points which needed to be deleted from the input string. the
* objects in deletionset and keys in replacementmap are mutually exclusive
*/
private final set<integer> deletionset   new hashset<integer>
/**
* a placeholder for result.
*/
private final text result   new text
/**
* the values of from parameter from the previous evaluate() call.
*/
private text lastfrom   null
/**
* the values of to parameter from the previous evaluate() call.
*/
private text lastto   null
/**
* converters for retrieving the arguments to the udf.
*/
private transient objectinspectorconverters converter converters
@override
public objectinspector initialize objectinspector arguments  throws udfargumentexception
if  arguments length    3
throw new udfargumentlengthexception
for  int i   0  i < arguments length  i
if  arguments getcategory      category primitive
throw new udfargumenttypeexception i
arguments gettypename
// now that we have made sure that the argument is of primitive type, we can get the primitive
// category
primitivecategory primitivecategory     primitiveobjectinspector  arguments
getprimitivecategory
if  primitivecategory    primitivecategory string
primitivecategory    primitivecategory void
throw new udfargumenttypeexception i
arguments gettypename
converters   new objectinspectorconverters converter
for  int i   0  i < arguments length  i
converters   objectinspectorconverters getconverter arguments
primitiveobjectinspectorfactory writablestringobjectinspector
// we will be returning a text object
return primitiveobjectinspectorfactory writablestringobjectinspector
@override
public object evaluate deferredobject arguments  throws hiveexception
assert  arguments length    3
if  arguments get      null    arguments get      null    arguments get      null
return null
text input    text  converters convert arguments get
text from    text  converters convert arguments get
text to    text  converters convert arguments get
populatemappingsifnecessary from  to
string resultstring   processinput input
result set resultstring
return result
/**
* pre-processes the from and to strings by calling {@link #populatemappings(text, text)} if
* necessary.
*
* @param from
*          from string to be used for translation
* @param to
*          to string to be used for translation
*/
private void populatemappingsifnecessary text from  text to
// if the from and to strings haven't changed, we don't need to preprocess again to regenerate
// the mappings of code points that need to replaced or deleted
if   lastfrom    null      lastto    null      from equals lastfrom      to equals lastto
populatemappings from  to
// these are null when evaluate() is called for the first time
if  lastfrom    null
lastfrom   new text
if  lastto    null
lastto   new text
// need to deep copy here since doing something like lastfrom = from instead, will make
// lastfrom point to the same text object which would make from.equals(lastfrom) always true
lastfrom set from
lastto set to
/**
* pre-process the from and to strings populate {@link #replacementmap} and {@link #deletionset}.
*
* @param from
*          from string to be used for translation
* @param to
*          to string to be used for translation
*/
private void populatemappings text from  text to
replacementmap clear
deletionset clear
bytebuffer frombytes   bytebuffer wrap from getbytes    0  from getlength
bytebuffer tobytes   bytebuffer wrap to getbytes    0  to getlength
// traverse through the from string, one code point at a time
while  frombytes hasremaining
// this will also move the iterator ahead by one code point
int fromcodepoint   text bytestocodepoint frombytes
// if the to string has more code points, make sure to traverse it too
if  tobytes hasremaining
int tocodepoint   text bytestocodepoint tobytes
// if the code point from from string already has a replacement or is to be deleted, we
// don't need to do anything, just move on to the next code point
if  replacementmap containskey fromcodepoint     deletionset contains fromcodepoint
continue
replacementmap put fromcodepoint  tocodepoint
else
// if the code point from from string already has a replacement or is to be deleted, we
// don't need to do anything, just move on to the next code point
if  replacementmap containskey fromcodepoint     deletionset contains fromcodepoint
continue
deletionset add fromcodepoint
/**
* translates the input string based on {@link #replacementmap} and {@link #deletionset} and
* returns the translated string.
*
* @param input
*          input string to perform the translation on
* @return translated string
*/
private string processinput text input
stringbuilder resultbuilder   new stringbuilder
// obtain the byte buffer from the input string so we can traverse it code point by code point
bytebuffer inputbytes   bytebuffer wrap input getbytes    0  input getlength
// traverse the byte buffer containing the input string one code point at a time
while  inputbytes hasremaining
int inputcodepoint   text bytestocodepoint inputbytes
// if the code point exists in deletion set, no need to emit out anything for this code point.
// continue on to the next code point
if  deletionset contains inputcodepoint
continue
integer replacementcodepoint   replacementmap get inputcodepoint
// if a replacement exists for this code point, emit out the replacement and append it to the
// output string. if no such replacement exists, emit out the original input code point
char chararray   character tochars  replacementcodepoint    null  ? replacementcodepoint
inputcodepoint
resultbuilder append chararray
string resultstring   resultbuilder tostring
return resultstring
@override
public string getdisplaystring string children
assert  children length    3
return     children       children       children