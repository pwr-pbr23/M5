/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing,
* software distributed under the license is distributed on an
* "as is" basis, without warranties or conditions of any
* kind, either express or implied.  see the license for the
* specific language governing permissions and limitations
* under the license.
*/
package org apache hive hcatalog data
import java io bytearrayinputstream
import java io ioexception
import java util arraylist
import java util arrays
import java util collections
import java util linkedhashmap
import java util list
import java util map
import java util properties
import java util regex matcher
import java util regex pattern
import org apache hadoop conf configuration
import org apache hadoop hive conf hiveconf
import org apache hadoop hive serde serdeconstants
import org apache hadoop hive serde2 serde
import org apache hadoop hive serde2 serdeexception
import org apache hadoop hive serde2 serdestats
import org apache hadoop hive serde2 serdeutils
import org apache hadoop hive serde2 objectinspector listobjectinspector
import org apache hadoop hive serde2 objectinspector mapobjectinspector
import org apache hadoop hive serde2 objectinspector objectinspector
import org apache hadoop hive serde2 objectinspector primitiveobjectinspector
import org apache hadoop hive serde2 objectinspector structfield
import org apache hadoop hive serde2 objectinspector structobjectinspector
import org apache hadoop hive serde2 objectinspector unionobjectinspector
import org apache hadoop hive serde2 objectinspector primitive booleanobjectinspector
import org apache hadoop hive serde2 objectinspector primitive byteobjectinspector
import org apache hadoop hive serde2 objectinspector primitive doubleobjectinspector
import org apache hadoop hive serde2 objectinspector primitive floatobjectinspector
import org apache hadoop hive serde2 objectinspector primitive intobjectinspector
import org apache hadoop hive serde2 objectinspector primitive longobjectinspector
import org apache hadoop hive serde2 objectinspector primitive shortobjectinspector
import org apache hadoop hive serde2 objectinspector primitive stringobjectinspector
import org apache hadoop hive serde2 objectinspector primitive timestampobjectinspector
import org apache hadoop hive serde2 typeinfo structtypeinfo
import org apache hadoop hive serde2 typeinfo typeinfo
import org apache hadoop hive serde2 typeinfo typeinfofactory
import org apache hadoop hive serde2 typeinfo typeinfoutils
import org apache hadoop io text
import org apache hadoop io writable
import org apache hive hcatalog common hcatexception
import org apache hive hcatalog data schema hcatfieldschema
import org apache hive hcatalog data schema hcatfieldschema type
import org apache hive hcatalog data schema hcatschema
import org apache hive hcatalog data schema hcatschemautils
import org codehaus jackson jsonfactory
import org codehaus jackson jsonparseexception
import org codehaus jackson jsonparser
import org codehaus jackson jsontoken
import org slf4j logger
import org slf4j loggerfactory
public class jsonserde implements serde
private static final logger log   loggerfactory getlogger jsonserde class
private list<string> columnnames
private list<typeinfo> columntypes
private structtypeinfo rowtypeinfo
private hcatschema schema
private jsonfactory jsonfactory   null
private hcatrecordobjectinspector cachedobjectinspector
@override
public void initialize configuration conf  properties tbl
throws serdeexception
log debug
log debug    tbl entryset
// get column names and types
string columnnameproperty   tbl getproperty serdeconstants list_columns
string columntypeproperty   tbl getproperty serdeconstants list_column_types
// all table column names
if  columnnameproperty length      0
columnnames   new arraylist<string>
else
columnnames   arrays aslist columnnameproperty split
// all column types
if  columntypeproperty length      0
columntypes   new arraylist<typeinfo>
else
columntypes   typeinfoutils gettypeinfosfromtypestring columntypeproperty
log debug    columnnameproperty  columnnames
log debug    columntypeproperty  columntypes
assert  columnnames size      columntypes size
rowtypeinfo    structtypeinfo  typeinfofactory getstructtypeinfo columnnames  columntypes
cachedobjectinspector   hcatrecordobjectinspectorfactory gethcatrecordobjectinspector rowtypeinfo
try
schema   hcatschemautils gethcatschema rowtypeinfo  get 0  getstructsubschema
log debug    schema
log debug    schema getfieldnames
catch  hcatexception e
throw new serdeexception e
jsonfactory   new jsonfactory
/**
* takes json string in text form, and has to return an object representation above
* it that's readable by the corresponding object inspector.
*
* for this implementation, since we're using the jackson parser, we can construct
* our own object implementation, and we use hcatrecord for it
*/
@override
public object deserialize writable blob  throws serdeexception
text t    text  blob
jsonparser p
list<object> r   new arraylist<object> collections ncopies columnnames size    null
try
p   jsonfactory createjsonparser new bytearrayinputstream  t getbytes
if  p nexttoken      jsontoken start_object
throw new ioexception
jsontoken token
while    token   p nexttoken       jsontoken end_object      token    null
// iterate through each token, and create appropriate object here.
populaterecord r  token  p  schema
catch  jsonparseexception e
log warn    e  t
log debug null  e
throw new serdeexception e
catch  ioexception e
log warn    e  t
log debug null  e
throw new serdeexception e
return new defaulthcatrecord r
private void populaterecord list<object> r  jsontoken token  jsonparser p  hcatschema s  throws ioexception
if  token    jsontoken field_name
throw new ioexception
string fieldname   p gettext
int fpos
try
fpos   s getposition fieldname
catch  nullpointerexception npe
fpos   getpositionfromhiveinternalcolumnname fieldname
log debug    fieldname  s
if   fieldname equalsignorecase gethiveinternalcolumnname fpos
log error
fieldname  fpos
throw npe
if  fpos     1
return     unknown field  we return
hcatfieldschema hcatfieldschema   s getfields   get fpos
object currfield   extractcurrentfield p  null  hcatfieldschema  false
r set fpos  currfield
public string gethiveinternalcolumnname int fpos
return hiveconf getcolumninternalname fpos
public int getpositionfromhiveinternalcolumnname string internalname
//    return hiveconf.getpositionfrominternalname(fieldname);
// the above line should have been all the implementation that
// we need, but due to a bug in that impl which recognizes
// only single-digit columns, we need another impl here.
pattern internalpattern   pattern compile
matcher m   internalpattern matcher internalname
if   m matches
return  1
else
return integer parseint m group 1
/**
* utility method to extract current expected field from given jsonparser
*
* to get the field, we need either a type or a hcatfieldschema(necessary for complex types)
* it is possible that one of them can be null, and so, if so, the other is instantiated
* from the other
*
* istokencurrent is a boolean variable also passed in, which determines
* if the jsonparser is already at the token we expect to read next, or
* needs advancing to the next before we read.
*/
private object extractcurrentfield jsonparser p  type t
hcatfieldschema hcatfieldschema  boolean istokencurrent  throws ioexception  jsonparseexception
hcatexception
object val   null
jsontoken valuetoken
if  istokencurrent
valuetoken   p getcurrenttoken
else
valuetoken   p nexttoken
if  hcatfieldschema    null
t   hcatfieldschema gettype
switch  t
case int
val    valuetoken    jsontoken value_null  ? null   p getintvalue
break
case tinyint
val    valuetoken    jsontoken value_null  ? null   p getbytevalue
break
case smallint
val    valuetoken    jsontoken value_null  ? null   p getshortvalue
break
case bigint
val    valuetoken    jsontoken value_null  ? null   p getlongvalue
break
case boolean
string bval    valuetoken    jsontoken value_null  ? null   p gettext
if  bval    null
val   boolean valueof bval
else
val   null
break
case float
val    valuetoken    jsontoken value_null  ? null   p getfloatvalue
break
case double
val    valuetoken    jsontoken value_null  ? null   p getdoublevalue
break
case string
val    valuetoken    jsontoken value_null  ? null   p gettext
break
case binary
throw new ioexception
case array
if  valuetoken    jsontoken value_null
val   null
break
if  valuetoken    jsontoken start_array
throw new ioexception
list<object> arr   new arraylist<object>
while   valuetoken   p nexttoken       jsontoken end_array
arr add extractcurrentfield p  null  hcatfieldschema getarrayelementschema   get 0   true
val   arr
break
case map
if  valuetoken    jsontoken value_null
val   null
break
if  valuetoken    jsontoken start_object
throw new ioexception
map<object  object> map   new linkedhashmap<object  object>
type keytype   hcatfieldschema getmapkeytype
hcatfieldschema valueschema   hcatfieldschema getmapvalueschema   get 0
while   valuetoken   p nexttoken       jsontoken end_object
object k   getobjectofcorrespondingprimitivetype p getcurrentname    keytype
object v
if  valueschema gettype      hcatfieldschema type struct
v   extractcurrentfield p  null  valueschema  false
else
v   extractcurrentfield p  null  valueschema  true
map put k  v
val   map
break
case struct
if  valuetoken    jsontoken value_null
val   null
break
if  valuetoken    jsontoken start_object
throw new ioexception
hcatschema subschema   hcatfieldschema getstructsubschema
int sz   subschema getfieldnames   size
list<object> struct   new arraylist<object> collections ncopies sz  null
while   valuetoken   p nexttoken       jsontoken end_object
populaterecord struct  valuetoken  p  subschema
val   struct
break
return val
private object getobjectofcorrespondingprimitivetype string s  type t  throws ioexception
switch  t
case int
return integer valueof s
case tinyint
return byte valueof s
case smallint
return short valueof s
case bigint
return long valueof s
case boolean
return  s equalsignorecase
case float
return float valueof s
case double
return double valueof s
case string
return s
case binary
throw new ioexception
throw new ioexception     t
/**
* given an object and object inspector pair, traverse the object
* and generate a text representation of the object.
*/
@override
public writable serialize object obj  objectinspector objinspector
throws serdeexception
stringbuilder sb   new stringbuilder
try
structobjectinspector soi    structobjectinspector  objinspector
list<? extends structfield> structfields   soi getallstructfieldrefs
assert  columnnames size      structfields size
if  obj    null
sb append
else
sb append serdeutils lbrace
for  int i   0  i < structfields size    i
if  i > 0
sb append serdeutils comma
sb append serdeutils quote
sb append columnnames get i
sb append serdeutils quote
sb append serdeutils colon
buildjsonstring sb  soi getstructfielddata obj  structfields get i
structfields get i  getfieldobjectinspector
sb append serdeutils rbrace
catch  ioexception e
log warn    e
throw new serdeexception e
return new text sb tostring
// todo : code section copied over from serdeutils because of non-standard json production there
// should use quotes for all field names. we should fix this there, and then remove this copy.
// see http://jackson.codehaus.org/1.7.3/javadoc/org/codehaus/jackson/jsonparser.feature.html#allow_unquoted_field_names
// for details - trying to enable jackson to ignore that doesn't seem to work(compilation failure
// when attempting to use that feature, so having to change the production itself.
// also, throws ioexception when binary is detected.
private static void buildjsonstring stringbuilder sb  object o  objectinspector oi  throws ioexception
switch  oi getcategory
case primitive
primitiveobjectinspector poi    primitiveobjectinspector  oi
if  o    null
sb append
else
switch  poi getprimitivecategory
case boolean
boolean b     booleanobjectinspector  poi  get o
sb append b ?
break
case byte
sb append   byteobjectinspector  poi  get o
break
case short
sb append   shortobjectinspector  poi  get o
break
case int
sb append   intobjectinspector  poi  get o
break
case long
sb append   longobjectinspector  poi  get o
break
case float
sb append   floatobjectinspector  poi  get o
break
case double
sb append   doubleobjectinspector  poi  get o
break
case string
sb append
sb append serdeutils escapestring   stringobjectinspector  poi
getprimitivejavaobject o
sb append
break
case timestamp
sb append
sb append   timestampobjectinspector  poi
getprimitivewritableobject o
sb append
break
case binary
throw new ioexception
default
throw new runtimeexception
poi getprimitivecategory
break
case list
listobjectinspector loi    listobjectinspector  oi
objectinspector listelementobjectinspector   loi
getlistelementobjectinspector
list<?> olist   loi getlist o
if  olist    null
sb append
else
sb append serdeutils lbracket
for  int i   0  i < olist size    i
if  i > 0
sb append serdeutils comma
buildjsonstring sb  olist get i   listelementobjectinspector
sb append serdeutils rbracket
break
case map
mapobjectinspector moi    mapobjectinspector  oi
objectinspector mapkeyobjectinspector   moi getmapkeyobjectinspector
objectinspector mapvalueobjectinspector   moi
getmapvalueobjectinspector
map<?  ?> omap   moi getmap o
if  omap    null
sb append
else
sb append serdeutils lbrace
boolean first   true
for  object entry   omap entryset
if  first
first   false
else
sb append serdeutils comma
map entry<?  ?> e    map entry<?  ?>  entry
stringbuilder keybuilder   new stringbuilder
buildjsonstring keybuilder  e getkey    mapkeyobjectinspector
string keystring   keybuilder tostring   trim
boolean doquoting     keystring isempty        keystring charat 0     serdeutils quote
if  doquoting
sb append serdeutils quote
sb append keystring
if  doquoting
sb append serdeutils quote
sb append serdeutils colon
buildjsonstring sb  e getvalue    mapvalueobjectinspector
sb append serdeutils rbrace
break
case struct
structobjectinspector soi    structobjectinspector  oi
list<? extends structfield> structfields   soi getallstructfieldrefs
if  o    null
sb append
else
sb append serdeutils lbrace
for  int i   0  i < structfields size    i
if  i > 0
sb append serdeutils comma
sb append serdeutils quote
sb append structfields get i  getfieldname
sb append serdeutils quote
sb append serdeutils colon
buildjsonstring sb  soi getstructfielddata o  structfields get i
structfields get i  getfieldobjectinspector
sb append serdeutils rbrace
break
case union
unionobjectinspector uoi    unionobjectinspector  oi
if  o    null
sb append
else
sb append serdeutils lbrace
sb append uoi gettag o
sb append serdeutils colon
buildjsonstring sb  uoi getfield o
uoi getobjectinspectors   get uoi gettag o
sb append serdeutils rbrace
break
default
throw new runtimeexception
/**
*  returns an object inspector for the specified schema that
*  is capable of reading in the object representation of the json string
*/
@override
public objectinspector getobjectinspector   throws serdeexception
return cachedobjectinspector
@override
public class<? extends writable> getserializedclass
return text class
@override
public serdestats getserdestats
// no support for statistics yet
return null