/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql io orc
import java io eofexception
import java io ioexception
import java nio bytebuffer
import java sql date
import java sql timestamp
import java util arraylist
import java util hashmap
import java util list
import java util map
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop fs fsdatainputstream
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hive common type hivedecimal
import org apache hadoop hive ql io orc runlengthintegerwriterv2 encodingtype
import org apache hadoop hive ql io sarg predicateleaf
import org apache hadoop hive ql io sarg searchargument
import org apache hadoop hive ql io sarg searchargument truthvalue
import org apache hadoop hive serde2 io bytewritable
import org apache hadoop hive serde2 io datewritable
import org apache hadoop hive serde2 io doublewritable
import org apache hadoop hive serde2 io hivevarcharwritable
import org apache hadoop hive serde2 io shortwritable
import org apache hadoop io booleanwritable
import org apache hadoop io byteswritable
import org apache hadoop io floatwritable
import org apache hadoop io intwritable
import org apache hadoop io longwritable
import org apache hadoop io text
class recordreaderimpl implements recordreader
private static final log log   logfactory getlog recordreaderimpl class
private final fsdatainputstream file
private final long firstrow
private final list<stripeinformation> stripes
new arraylist<stripeinformation>
private orcproto stripefooter stripefooter
private final long totalrowcount
private final compressioncodec codec
private final list<orcproto type> types
private final int buffersize
private final boolean included
private final long rowindexstride
private long rowinstripe   0
private int currentstripe    1
private long rowbaseinstripe   0
private long rowcountinstripe   0
private final map<streamname  instream> streams
new hashmap<streamname  instream>
private final treereader reader
private final orcproto rowindex indexes
private final searchargument sarg
// the leaf predicates for the sarg
private final list<predicateleaf> sargleaves
// an array the same length as the sargleaves that map them to column ids
private final int filtercolumns
// an array about which row groups aren't skipped
private boolean includedrowgroups   null
recordreaderimpl iterable<stripeinformation> stripes
filesystem filesystem
path path
long offset  long length
list<orcproto type> types
compressioncodec codec
int buffersize
boolean included
long striderate
searchargument sarg
string columnnames
throws ioexception
this file   filesystem open path
this codec   codec
this types   types
this buffersize   buffersize
this included   included
this sarg   sarg
if  sarg    null
sargleaves   sarg getleaves
filtercolumns   new int
for int i 0  i < filtercolumns length    i
string colname   sargleaves get i  getcolumnname
filtercolumns   findcolumns columnnames  colname
else
sargleaves   null
filtercolumns   null
long rows   0
long skippedrows   0
for stripeinformation stripe  stripes
long stripestart   stripe getoffset
if  offset > stripestart
skippedrows    stripe getnumberofrows
else if  stripestart < offset   length
this stripes add stripe
rows    stripe getnumberofrows
firstrow   skippedrows
totalrowcount   rows
reader   createtreereader path  0  types  included
indexes   new orcproto rowindex
rowindexstride   striderate
advancetonextrow 0l
private static int findcolumns string columnnames
string columnname
for int i 0  i < columnnames length    i
if  columnname equals columnnames
return i
return  1
private static final class positionproviderimpl implements positionprovider
private final orcproto rowindexentry entry
private int index   0
positionproviderimpl orcproto rowindexentry entry
this entry   entry
@override
public long getnext
return entry getpositions index
private abstract static class treereader
protected final path path
protected final int columnid
private bitfieldreader present   null
protected boolean valuepresent   false
treereader path path  int columnid
this path   path
this columnid   columnid
void checkencoding orcproto columnencoding encoding  throws ioexception
if  encoding getkind      orcproto columnencoding kind direct
throw new ioexception     encoding
columnid       path
integerreader createintegerreader orcproto columnencoding kind kind
instream in
boolean signed  throws ioexception
switch  kind
case direct_v2
case dictionary_v2
return new runlengthintegerreaderv2 in  signed
case direct
case dictionary
return new runlengthintegerreader in  signed
default
throw new illegalargumentexception     kind
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encoding
throws ioexception
checkencoding encoding get columnid
instream in   streams get new streamname columnid
orcproto stream kind present
if  in    null
present   null
valuepresent   true
else
present   new bitfieldreader in  1
/**
* seek to the given position.
* @param index the indexes loaded from the file
* @throws ioexception
*/
void seek positionprovider index  throws ioexception
if  present    null
present seek index
protected long countnonnulls long rows  throws ioexception
if  present    null
long result   0
for long c 0  c < rows    c
if  present next      1
result    1
return result
else
return rows
abstract void skiprows long rows  throws ioexception
object next object previous  throws ioexception
if  present    null
valuepresent   present next      1
return previous
private static class booleantreereader extends treereader
private bitfieldreader reader   null
booleantreereader path path  int columnid
super path  columnid
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
reader   new bitfieldreader streams get new streamname columnid
orcproto stream kind data    1
@override
void seek positionprovider index  throws ioexception
super seek index
reader seek index
@override
void skiprows long items  throws ioexception
reader skip countnonnulls items
@override
object next object previous  throws ioexception
super next previous
booleanwritable result   null
if  valuepresent
if  previous    null
result   new booleanwritable
else
result    booleanwritable  previous
result set reader next      1
return result
private static class bytetreereader extends treereader
private runlengthbytereader reader   null
bytetreereader path path  int columnid
super path  columnid
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
reader   new runlengthbytereader streams get new streamname columnid
orcproto stream kind data
@override
void seek positionprovider index  throws ioexception
super seek index
reader seek index
@override
object next object previous  throws ioexception
super next previous
bytewritable result   null
if  valuepresent
if  previous    null
result   new bytewritable
else
result    bytewritable  previous
result set reader next
return result
@override
void skiprows long items  throws ioexception
reader skip countnonnulls items
private static class shorttreereader extends treereader
private integerreader reader   null
shorttreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
streamname name   new streamname columnid
orcproto stream kind data
reader   createintegerreader encodings get columnid  getkind    streams get name   true
@override
void seek positionprovider index  throws ioexception
super seek index
reader seek index
@override
object next object previous  throws ioexception
super next previous
shortwritable result   null
if  valuepresent
if  previous    null
result   new shortwritable
else
result    shortwritable  previous
result set  short  reader next
return result
@override
void skiprows long items  throws ioexception
reader skip countnonnulls items
private static class inttreereader extends treereader
private integerreader reader   null
inttreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
streamname name   new streamname columnid
orcproto stream kind data
reader   createintegerreader encodings get columnid  getkind    streams get name   true
@override
void seek positionprovider index  throws ioexception
super seek index
reader seek index
@override
object next object previous  throws ioexception
super next previous
intwritable result   null
if  valuepresent
if  previous    null
result   new intwritable
else
result    intwritable  previous
result set  int  reader next
return result
@override
void skiprows long items  throws ioexception
reader skip countnonnulls items
private static class longtreereader extends treereader
private integerreader reader   null
longtreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
streamname name   new streamname columnid
orcproto stream kind data
reader   createintegerreader encodings get columnid  getkind    streams get name   true
@override
void seek positionprovider index  throws ioexception
super seek index
reader seek index
@override
object next object previous  throws ioexception
super next previous
longwritable result   null
if  valuepresent
if  previous    null
result   new longwritable
else
result    longwritable  previous
result set reader next
return result
@override
void skiprows long items  throws ioexception
reader skip countnonnulls items
private static class floattreereader extends treereader
private instream stream
floattreereader path path  int columnid
super path  columnid
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
streamname name   new streamname columnid
orcproto stream kind data
stream   streams get name
@override
void seek positionprovider index  throws ioexception
super seek index
stream seek index
@override
object next object previous  throws ioexception
super next previous
floatwritable result   null
if  valuepresent
if  previous    null
result   new floatwritable
else
result    floatwritable  previous
result set serializationutils readfloat stream
return result
@override
void skiprows long items  throws ioexception
items   countnonnulls items
for int i 0  i < items    i
serializationutils readfloat stream
private static class doubletreereader extends treereader
private instream stream
doubletreereader path path  int columnid
super path  columnid
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
streamname name
new streamname columnid
orcproto stream kind data
stream   streams get name
@override
void seek positionprovider index  throws ioexception
super seek index
stream seek index
@override
object next object previous  throws ioexception
super next previous
doublewritable result   null
if  valuepresent
if  previous    null
result   new doublewritable
else
result    doublewritable  previous
result set serializationutils readdouble stream
return result
@override
void skiprows long items  throws ioexception
items   countnonnulls items
stream skip items   8
private static class binarytreereader extends treereader
private instream stream
private integerreader lengths   null
binarytreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
streamname name   new streamname columnid
orcproto stream kind data
stream   streams get name
lengths   createintegerreader encodings get columnid  getkind    streams get new
streamname columnid  orcproto stream kind length    false
@override
void seek positionprovider index  throws ioexception
super seek index
stream seek index
lengths seek index
@override
object next object previous  throws ioexception
super next previous
byteswritable result   null
if  valuepresent
if  previous    null
result   new byteswritable
else
result    byteswritable  previous
int len    int  lengths next
result setsize len
int offset   0
while  len > 0
int written   stream read result getbytes    offset  len
if  written < 0
throw new eofexception     stream
len    written
offset    written
return result
@override
void skiprows long items  throws ioexception
items   countnonnulls items
long lengthtoskip   0
for int i 0  i < items    i
lengthtoskip    lengths next
stream skip lengthtoskip
private static class timestamptreereader extends treereader
private integerreader data   null
private integerreader nanos   null
timestamptreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
data   createintegerreader encodings get columnid  getkind
streams get new streamname columnid
orcproto stream kind data    true
nanos   createintegerreader encodings get columnid  getkind
streams get new streamname columnid
orcproto stream kind secondary    false
@override
void seek positionprovider index  throws ioexception
super seek index
data seek index
nanos seek index
@override
object next object previous  throws ioexception
super next previous
timestamp result   null
if  valuepresent
if  previous    null
result   new timestamp 0
else
result    timestamp  previous
long millis    data next     writerimpl base_timestamp
writerimpl millis_per_second
int newnanos   parsenanos nanos next
// fix the rounding when we divided by 1000.
if  millis >  0
millis    newnanos   1000000
else
millis    newnanos   1000000
result settime millis
result setnanos newnanos
return result
private static int parsenanos long serialized
int zeros   7    int  serialized
int result    int  serialized >>> 3
if  zeros    0
for int i  0  i <  zeros    i
result    10
return result
@override
void skiprows long items  throws ioexception
items   countnonnulls items
data skip items
nanos skip items
private static class datetreereader extends treereader
private integerreader reader   null
datetreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
streamname name   new streamname columnid
orcproto stream kind data
reader   createintegerreader encodings get columnid  getkind    streams get name   true
@override
void seek positionprovider index  throws ioexception
super seek index
reader seek index
@override
object next object previous  throws ioexception
super next previous
date result   null
if  valuepresent
if  previous    null
result   new date 0
else
result    date  previous
result settime datewritable daystomillis  int  reader next
return result
@override
void skiprows long items  throws ioexception
reader skip countnonnulls items
private static class decimaltreereader extends treereader
private instream valuestream
private integerreader scalestream   null
decimaltreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
valuestream   streams get new streamname columnid
orcproto stream kind data
scalestream   createintegerreader encodings get columnid  getkind    streams get
new streamname columnid  orcproto stream kind secondary    true
@override
void seek positionprovider index  throws ioexception
super seek index
valuestream seek index
scalestream seek index
@override
object next object previous  throws ioexception
super next previous
if  valuepresent
return new hivedecimal serializationutils readbiginteger valuestream
int  scalestream next
return null
@override
void skiprows long items  throws ioexception
items   countnonnulls items
for int i 0  i < items  i
serializationutils readbiginteger valuestream
scalestream skip items
/**
* a tree reader that will read string columns. at the start of the
* stripe, it creates an internal reader based on whether a direct or
* dictionary encoding was used.
*/
private static class stringtreereader extends treereader
private treereader reader
stringtreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
reader checkencoding encoding
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
// for each stripe, checks the encoding and initializes the appropriate
// reader
switch  encodings get columnid  getkind
case direct
case direct_v2
reader   new stringdirecttreereader path  columnid
break
case dictionary
case dictionary_v2
reader   new stringdictionarytreereader path  columnid
break
default
throw new illegalargumentexception
encodings get columnid  getkind
reader startstripe streams  encodings
@override
void seek positionprovider index  throws ioexception
reader seek index
@override
object next object previous  throws ioexception
return reader next previous
@override
void skiprows long items  throws ioexception
reader skiprows items
/**
* a reader for string columns that are direct encoded in the current
* stripe.
*/
private static class stringdirecttreereader extends treereader
private instream stream
private integerreader lengths
stringdirecttreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if  encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
streamname name   new streamname columnid
orcproto stream kind data
stream   streams get name
lengths   createintegerreader encodings get columnid  getkind
streams get new streamname columnid  orcproto stream kind length
false
@override
void seek positionprovider index  throws ioexception
super seek index
stream seek index
lengths seek index
@override
object next object previous  throws ioexception
super next previous
text result   null
if  valuepresent
if  previous    null
result   new text
else
result    text  previous
int len    int  lengths next
int offset   0
byte bytes   new byte
while  len > 0
int written   stream read bytes  offset  len
if  written < 0
throw new eofexception     stream
len    written
offset    written
result set bytes
return result
@override
void skiprows long items  throws ioexception
items   countnonnulls items
long lengthtoskip   0
for int i 0  i < items    i
lengthtoskip    lengths next
stream skip lengthtoskip
/**
* a reader for string columns that are dictionary encoded in the current
* stripe.
*/
private static class stringdictionarytreereader extends treereader
private dynamicbytearray dictionarybuffer
private int dictionaryoffsets
private integerreader reader
stringdictionarytreereader path path  int columnid
super path  columnid
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if  encoding getkind      orcproto columnencoding kind dictionary
encoding getkind      orcproto columnencoding kind dictionary_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
// read the dictionary blob
int dictionarysize   encodings get columnid  getdictionarysize
streamname name   new streamname columnid
orcproto stream kind dictionary_data
instream in   streams get name
if  in available   > 0
dictionarybuffer   new dynamicbytearray 64  in available
dictionarybuffer readall in
else
dictionarybuffer   null
in close
// read the lengths
name   new streamname columnid  orcproto stream kind length
in   streams get name
integerreader lenreader   createintegerreader encodings get columnid
getkind    in  false
int offset   0
if  dictionaryoffsets    null
dictionaryoffsets length < dictionarysize   1
dictionaryoffsets   new int
for int i 0  i < dictionarysize    i
dictionaryoffsets   offset
offset     int  lenreader next
dictionaryoffsets   offset
in close
// set up the row reader
name   new streamname columnid  orcproto stream kind data
reader   createintegerreader encodings get columnid  getkind
streams get name   false
@override
void seek positionprovider index  throws ioexception
super seek index
reader seek index
@override
object next object previous  throws ioexception
super next previous
text result   null
if  valuepresent
int entry    int  reader next
if  previous    null
result   new text
else
result    text  previous
int offset   dictionaryoffsets
int length
// if it isn't the last entry, subtract the offsets otherwise use
// the buffer length.
if  entry < dictionaryoffsets length   1
length   dictionaryoffsets   offset
else
length   dictionarybuffer size     offset
// if the column is just empty strings, the size will be zero,
// so the buffer will be null, in that case just return result
// as it will default to empty
if  dictionarybuffer    null
dictionarybuffer settext result  offset  length
else
result clear
return result
@override
void skiprows long items  throws ioexception
reader skip countnonnulls items
private static class varchartreereader extends stringtreereader
int maxlength
varchartreereader path path  int columnid  int maxlength
super path  columnid
this maxlength   maxlength
@override
object next object previous  throws ioexception
hivevarcharwritable result   null
if  previous    null
result   new hivevarcharwritable
else
result    hivevarcharwritable  previous
// use the string reader implementation to populate the internal text value
object textval   super next result gettextvalue
if  textval    null
return null
// result should now hold the value that was read in.
// enforce varchar length
result enforcemaxlength maxlength
return result
private static class structtreereader extends treereader
private final treereader fields
private final string fieldnames
structtreereader path path  int columnid
list<orcproto type> types
boolean included  throws ioexception
super path  columnid
orcproto type type   types get columnid
int fieldcount   type getfieldnamescount
this fields   new treereader
this fieldnames   new string
for int i 0  i < fieldcount    i
int subtype   type getsubtypes i
if  included    null    included
this fields   createtreereader path  subtype  types  included
this fieldnames   type getfieldnames i
@override
void seek positionprovider index  throws ioexception
super seek index
for treereader kid  fields
if  kid    null
kid seek index
@override
object next object previous  throws ioexception
super next previous
orcstruct result   null
if  valuepresent
if  previous    null
result   new orcstruct fields length
else
result    orcstruct  previous
// if the input format was initialized with a file with a
// different number of fields, the number of fields needs to
// be updated to the correct number
if  result getnumfields      fields length
result setnumfields fields length
for int i 0  i < fields length    i
if  fields    null
result setfieldvalue i  fields next result getfieldvalue i
return result
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
for treereader field  fields
if  field    null
field startstripe streams  encodings
@override
void skiprows long items  throws ioexception
items   countnonnulls items
for treereader field  fields
if  field    null
field skiprows items
private static class uniontreereader extends treereader
private final treereader fields
private runlengthbytereader tags
uniontreereader path path  int columnid
list<orcproto type> types
boolean included  throws ioexception
super path  columnid
orcproto type type   types get columnid
int fieldcount   type getsubtypescount
this fields   new treereader
for int i 0  i < fieldcount    i
int subtype   type getsubtypes i
if  included    null    included
this fields   createtreereader path  subtype  types  included
@override
void seek positionprovider index  throws ioexception
super seek index
tags seek index
for treereader kid  fields
kid seek index
@override
object next object previous  throws ioexception
super next previous
orcunion result   null
if  valuepresent
if  previous    null
result   new orcunion
else
result    orcunion  previous
byte tag   tags next
object previousval   result getobject
result set tag  fields next tag    result gettag   ?
previousval   null
return result
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
tags   new runlengthbytereader streams get new streamname columnid
orcproto stream kind data
for treereader field  fields
if  field    null
field startstripe streams  encodings
@override
void skiprows long items  throws ioexception
items   countnonnulls items
long counts   new long
for int i 0  i < items    i
counts    1
for int i 0  i < counts length    i
fields skiprows counts
private static class listtreereader extends treereader
private final treereader elementreader
private integerreader lengths   null
listtreereader path path  int columnid
list<orcproto type> types
boolean included  throws ioexception
super path  columnid
orcproto type type   types get columnid
elementreader   createtreereader path  type getsubtypes 0   types
included
@override
void seek positionprovider index  throws ioexception
super seek index
lengths seek index
elementreader seek index
@override
@suppresswarnings
object next object previous  throws ioexception
super next previous
list<object> result   null
if  valuepresent
if  previous    null
result   new arraylist<object>
else
result    arraylist<object>  previous
int prevlength   result size
int length    int  lengths next
// extend the list to the new length
for int i prevlength  i < length    i
result add null
// read the new elements into the array
for int i 0  i< length  i
result set i  elementreader next i < prevlength ?
result get i    null
// remove any extra elements
for int i prevlength   1  i >  length    i
result remove i
return result
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
lengths   createintegerreader encodings get columnid  getkind
streams get new streamname columnid
orcproto stream kind length    false
if  elementreader    null
elementreader startstripe streams  encodings
@override
void skiprows long items  throws ioexception
items   countnonnulls items
long childskip   0
for long i 0  i < items    i
childskip    lengths next
elementreader skiprows childskip
private static class maptreereader extends treereader
private final treereader keyreader
private final treereader valuereader
private integerreader lengths   null
maptreereader path path
int columnid
list<orcproto type> types
boolean included  throws ioexception
super path  columnid
orcproto type type   types get columnid
int keycolumn   type getsubtypes 0
int valuecolumn   type getsubtypes 1
if  included    null    included
keyreader   createtreereader path  keycolumn  types  included
else
keyreader   null
if  included    null    included
valuereader   createtreereader path  valuecolumn  types  included
else
valuereader   null
@override
void seek positionprovider index  throws ioexception
super seek index
lengths seek index
keyreader seek index
valuereader seek index
@override
@suppresswarnings
object next object previous  throws ioexception
super next previous
map<object  object> result   null
if  valuepresent
if  previous    null
result   new hashmap<object  object>
else
result    hashmap<object  object>  previous
// for now just clear and create new objects
result clear
int length    int  lengths next
// read the new elements into the array
for int i 0  i< length  i
result put keyreader next null   valuereader next null
return result
@override
void checkencoding orcproto columnencoding encoding  throws ioexception
if   encoding getkind      orcproto columnencoding kind direct
encoding getkind      orcproto columnencoding kind direct_v2
throw new ioexception     encoding
columnid       path
@override
void startstripe map<streamname  instream> streams
list<orcproto columnencoding> encodings
throws ioexception
super startstripe streams  encodings
lengths   createintegerreader encodings get columnid  getkind
streams get new streamname columnid
orcproto stream kind length    false
if  keyreader    null
keyreader startstripe streams  encodings
if  valuereader    null
valuereader startstripe streams  encodings
@override
void skiprows long items  throws ioexception
items   countnonnulls items
long childskip   0
for long i 0  i < items    i
childskip    lengths next
keyreader skiprows childskip
valuereader skiprows childskip
private static treereader createtreereader path path
int columnid
list<orcproto type> types
boolean included
throws ioexception
orcproto type type   types get columnid
switch  type getkind
case boolean
return new booleantreereader path  columnid
case byte
return new bytetreereader path  columnid
case double
return new doubletreereader path  columnid
case float
return new floattreereader path  columnid
case short
return new shorttreereader path  columnid
case int
return new inttreereader path  columnid
case long
return new longtreereader path  columnid
case string
return new stringtreereader path  columnid
case varchar
if   type hasmaximumlength
throw new illegalargumentexception
return new varchartreereader path  columnid  type getmaximumlength
case binary
return new binarytreereader path  columnid
case timestamp
return new timestamptreereader path  columnid
case date
return new datetreereader path  columnid
case decimal
return new decimaltreereader path  columnid
case struct
return new structtreereader path  columnid  types  included
case list
return new listtreereader path  columnid  types  included
case map
return new maptreereader path  columnid  types  included
case union
return new uniontreereader path  columnid  types  included
default
throw new illegalargumentexception
type getkind
orcproto stripefooter readstripefooter stripeinformation stripe
throws ioexception
long offset   stripe getoffset     stripe getindexlength
stripe getdatalength
int taillength    int  stripe getfooterlength
// read the footer
bytebuffer tailbuf   bytebuffer allocate taillength
file seek offset
file readfully tailbuf array    tailbuf arrayoffset    taillength
return orcproto stripefooter parsefrom instream create
new bytebuffer tailbuf   new long 0   taillength  codec
buffersize
static enum location
before  min  middle  max  after
/**
* given a point and min and max, determine if the point is before, at the
* min, in the middle, at the max, or after the range.
* @param point the point to test
* @param min the minimum point
* @param max the maximum point
* @param <t> the type of the comparision
* @return the location of the point
*/
static <t> location comparetorange comparable<t> point  t min  t max
int mincompare   point compareto min
if  mincompare < 0
return location before
else if  mincompare    0
return location min
int maxcompare   point compareto max
if  maxcompare > 0
return location after
else if  maxcompare    0
return location max
return location middle
/**
* get the minimum value out of an index entry.
* @param index the index entry
* @return the object for the minimum value or null if there isn't one
*/
static object getmin orcproto columnstatistics index
if  index hasintstatistics
orcproto integerstatistics stat   index getintstatistics
if  stat hasminimum
return stat getminimum
if  index hasstringstatistics
orcproto stringstatistics stat   index getstringstatistics
if  stat hasminimum
return stat getminimum
if  index hasdoublestatistics
orcproto doublestatistics stat   index getdoublestatistics
if  stat hasminimum
return stat getminimum
return null
/**
* get the maximum value out of an index entry.
* @param index the index entry
* @return the object for the maximum value or null if there isn't one
*/
static object getmax orcproto columnstatistics index
if  index hasintstatistics
orcproto integerstatistics stat   index getintstatistics
if  stat hasmaximum
return stat getmaximum
if  index hasstringstatistics
orcproto stringstatistics stat   index getstringstatistics
if  stat hasmaximum
return stat getmaximum
if  index hasdoublestatistics
orcproto doublestatistics stat   index getdoublestatistics
if  stat hasmaximum
return stat getmaximum
return null
/**
* evaluate a predicate with respect to the statistics from the column
* that is referenced in the predicate.
* @param index the statistics for the column mentioned in the predicate
* @param predicate the leaf predicate we need to evaluation
* @return the set of truth values that may be returned for the given
*   predicate.
*/
static truthvalue evaluatepredicate orcproto columnstatistics index
predicateleaf predicate
object minvalue   getmin index
// if we didn't have any values, everything must have been null
if  minvalue    null
if  predicate getoperator      predicateleaf operator is_null
return truthvalue yes
else
return truthvalue null
object maxvalue   getmax index
location loc
switch  predicate getoperator
case null_safe_equals
loc   comparetorange  comparable  predicate getliteral
minvalue  maxvalue
if  loc    location before    loc    location after
return truthvalue no
else
return truthvalue yes_no
case equals
loc   comparetorange  comparable  predicate getliteral
minvalue  maxvalue
if  minvalue equals maxvalue     loc    location min
return truthvalue yes_null
else if  loc    location before    loc    location after
return truthvalue no_null
else
return truthvalue yes_no_null
case less_than
loc   comparetorange  comparable  predicate getliteral
minvalue  maxvalue
if  loc    location after
return truthvalue yes_null
else if  loc    location before    loc    location min
return truthvalue no_null
else
return truthvalue yes_no_null
case less_than_equals
loc   comparetorange  comparable  predicate getliteral
minvalue  maxvalue
if  loc    location after    loc    location max
return truthvalue yes_null
else if  loc    location before
return truthvalue no_null
else
return truthvalue yes_no_null
case in
if  minvalue equals maxvalue
// for a single value, look through to see if that value is in the
// set
for object arg  predicate getliterallist
loc   comparetorange  comparable  arg  minvalue  maxvalue
if  loc    location min
return truthvalue yes_null
return truthvalue no_null
else
// are all of the values outside of the range?
for object arg  predicate getliterallist
loc   comparetorange  comparable  arg  minvalue  maxvalue
if  loc    location min    loc    location middle
loc    location max
return truthvalue yes_no_null
return truthvalue no_null
case between
list<object> args   predicate getliterallist
loc   comparetorange  comparable  args get 0   minvalue  maxvalue
if  loc    location before    loc    location min
location loc2   comparetorange  comparable  args get 1   minvalue
maxvalue
if  loc2    location after    loc2    location max
return truthvalue yes_null
else if  loc2    location before
return truthvalue no_null
else
return truthvalue yes_no_null
else if  loc    location after
return truthvalue no_null
else
return truthvalue yes_no_null
case is_null
return truthvalue yes_no
default
return truthvalue yes_no_null
/**
* pick the row groups that we need to load from the current stripe.
* @return an array with a boolean for each row group or null if all of the
*    row groups must be read.
* @throws ioexception
*/
private boolean pickrowgroups   throws ioexception
// if we don't have a sarg or indexes, we read everything
if  sarg    null    rowindexstride    0
return null
readrowindex
long rowsinstripe   stripes get currentstripe  getnumberofrows
int groupsinstripe    int    rowsinstripe   rowindexstride   1
rowindexstride
boolean result   new boolean
truthvalue leafvalues   new truthvalue
for int rowgroup 0  rowgroup < result length    rowgroup
for int pred 0  pred < leafvalues length    pred
if  filtercolumns     1
orcproto columnstatistics stats
indexes] getentry rowgroup  getstatistics
leafvalues   evaluatepredicate stats  sargleaves get pred
if  log isdebugenabled
log debug     stats
log debug     sargleaves get pred
leafvalues
else
// the column is a virtual column
leafvalues   truthvalue yes_no_null
result   sarg evaluate leafvalues  isnotneeded
if  log isdebugenabled
log debug      rowindexstride   rowgroup
rowindexstride    rowgroup 1    1
result ?
// if we found something to skip, use the array. otherwise, return null.
for boolean b  result
if   b
return result
return null
/**
* read the current stripe into memory.
* @throws ioexception
*/
private void readstripe   throws ioexception
stripeinformation stripe   stripes get currentstripe
stripefooter   readstripefooter stripe
streams clear
// setup the position in the stripe
rowcountinstripe   stripe getnumberofrows
rowinstripe   0
rowbaseinstripe   0
for int i 0  i < currentstripe    i
rowbaseinstripe    stripes get i  getnumberofrows
// reset all of the indexes
for int i 0  i < indexes length    i
indexes   null
includedrowgroups   pickrowgroups
// move forward to the first unskipped row
if  includedrowgroups    null
while  rowinstripe < rowcountinstripe
includedrowgroups
rowinstripe   math min rowcountinstripe  rowinstripe   rowindexstride
// if we haven't skipped the whole stripe, read the data
if  rowinstripe < rowcountinstripe
// if we aren't projecting columns or filtering rows, just read it all
if  included    null    includedrowgroups    null
readalldatastreams stripe
else
readpartialdatastreams stripe
reader startstripe streams  stripefooter getcolumnslist
// if we skipped the first row group, move the pointers forward
if  rowinstripe    0
seektorowentry  int   rowinstripe   rowindexstride
private void readalldatastreams stripeinformation stripe
throws ioexception
byte buffer
new byte
file seek stripe getoffset     stripe getindexlength
file readfully buffer  0  buffer length
int sectionoffset   0
for orcproto stream section  stripefooter getstreamslist
if  streamname getarea section getkind       streamname area data
int sectionlength    int  section getlength
bytebuffer sectionbuffer   bytebuffer wrap buffer  sectionoffset
sectionlength
streamname name   new streamname section getcolumn
section getkind
streams put name
instream create name tostring    new bytebuffer sectionbuffer
new long 0   sectionlength  codec  buffersize
sectionoffset    sectionlength
/**
* the secionts of stripe that we need to read.
*/
static class diskrange
/** the first address we need to read. */
long offset
/** the first address afterwards. */
long end
diskrange long offset  long end
this offset   offset
this end   end
if  end < offset
throw new illegalargumentexception     this
@override
public boolean equals object other
if  other    null    other getclass      getclass
return false
diskrange otherr    diskrange  other
return otherr offset    offset    otherr end    end
@override
public string tostring
return     offset       end
private static final int byte_stream_positions   1
private static final int run_length_byte_positions
byte_stream_positions   1
private static final int bitfield_positions   run_length_byte_positions   1
private static final int run_length_int_positions
byte_stream_positions   1
/**
* get the offset in the index positions for the column that the given
* stream starts.
* @param encoding the encoding of the column
* @param type the type of the column
* @param stream the kind of the stream
* @param iscompressed is the file compressed
* @param hasnulls does the column have a present stream?
* @return the number of positions that will be used for that stream
*/
static int getindexposition orcproto columnencoding kind encoding
orcproto type kind type
orcproto stream kind stream
boolean iscompressed
boolean hasnulls
if  stream    orcproto stream kind present
return 0
int compressionvalue   iscompressed ? 1   0
int base   hasnulls ?  bitfield_positions   compressionvalue    0
switch  type
case boolean
case byte
case short
case int
case long
case float
case double
case struct
case map
case list
case union
return base
case string
if  encoding    orcproto columnencoding kind dictionary
encoding    orcproto columnencoding kind dictionary_v2
return base
else
if  stream    orcproto stream kind data
return base
else
return base   byte_stream_positions   compressionvalue
case binary
if  stream    orcproto stream kind data
return base
return base   byte_stream_positions   compressionvalue
case decimal
if  stream    orcproto stream kind data
return base
return base   byte_stream_positions   compressionvalue
case timestamp
if  stream    orcproto stream kind data
return base
return base   run_length_int_positions   compressionvalue
default
throw new illegalargumentexception     type
// for uncompressed streams, what is the most overlap with the following set
// of rows (long vint literal group).
static final int worst_uncompressed_slop   2   8   512
/**
* is this stream part of a dictionary?
* @return is this part of a dictionary?
*/
static boolean isdictionary orcproto stream kind kind
orcproto columnencoding encoding
orcproto columnencoding kind encodingkind   encoding getkind
return kind    orcproto stream kind dictionary_data
kind    orcproto stream kind length
encodingkind    orcproto columnencoding kind dictionary
encodingkind    orcproto columnencoding kind dictionary_v2
/**
* plan the ranges of the file that we need to read given the list of
* columns and row groups.
* @param streamlist the list of streams avaiable
* @param indexes the indexes that have been loaded
* @param includedcolumns which columns are needed
* @param includedrowgroups which row groups are needed
* @param iscompressed does the file have generic compression
* @param encodings the encodings for each column
* @param types the types of the columns
* @param compressionsize the compression block size
* @return the list of disk ranges that will be loaded
*/
static list<diskrange> planreadpartialdatastreams
list<orcproto stream> streamlist
orcproto rowindex indexes
boolean includedcolumns
boolean includedrowgroups
boolean iscompressed
list<orcproto columnencoding> encodings
list<orcproto type> types
int compressionsize
list<diskrange> result   new arraylist<diskrange>
long offset   0
// figure out which columns have a present stream
boolean hasnull   new boolean
for orcproto stream stream  streamlist
if  stream getkind      orcproto stream kind present
hasnull   true
for orcproto stream stream  streamlist
long length   stream getlength
int column   stream getcolumn
orcproto stream kind streamkind   stream getkind
if  streamname getarea streamkind     streamname area data
includedcolumns
// if we aren't filtering or it is a dictionary, load it.
if  includedrowgroups    null
isdictionary streamkind  encodings get column
result add new diskrange offset  offset   length
else
for int group 0  group < includedrowgroups length    group
if  includedrowgroups
int posn   getindexposition encodings get column  getkind
types get column  getkind    stream getkind    iscompressed
hasnull
long start   indexes getentry group  getpositions posn
// figure out the worst case last location
long end    group    includedrowgroups length   1  ?
length   math min length
indexes getentry group   1
getpositions posn
iscompressed ?
outstream header_size
compressionsize
worst_uncompressed_slop
result add new diskrange offset   start  offset   end
offset    length
return result
/**
* update the disk ranges to collapse adjacent or overlapping ranges. it
* assumes that the ranges are sorted.
* @param ranges the list of disk ranges to merge
*/
static void mergediskranges list<diskrange> ranges
diskrange prev   null
for int i 0  i < ranges size      i
diskrange current   ranges get i
if  prev    null    overlap prev offset  prev end
current offset  current end
prev offset   math min prev offset  current offset
prev end   math max prev end  current end
ranges remove i
i    1
else
prev   current
/**
* read the list of ranges from the file.
* @param file the file to read
* @param base the base of the stripe
* @param ranges the disk ranges within the stripe to read
* @return the bytes read for each disk range, which is the same length as
*    ranges
* @throws ioexception
*/
static byte readdiskranges fsdatainputstream file
long base
list<diskrange> ranges  throws ioexception
byte result   new byte
int i   0
for diskrange range  ranges
int len    int   range end   range offset
result   new byte
file seek base   range offset
file readfully result
i    1
return result
/**
* does region a overlap region b? the end points are inclusive on both sides.
* @param lefta a's left point
* @param righta a's right point
* @param leftb b's left point
* @param rightb b's right point
* @return does region a overlap region b?
*/
static boolean overlap long lefta  long righta  long leftb  long rightb
if  lefta <  leftb
return righta >  leftb
return rightb >  lefta
/**
* build a string representation of a list of disk ranges.
* @param ranges ranges to stringify
* @return the resulting string
*/
static string stringifydiskranges list<diskrange> ranges
stringbuilder buffer   new stringbuilder
buffer append
for int i 0  i < ranges size      i
if  i    0
buffer append
buffer append ranges get i  tostring
buffer append
return buffer tostring
static void createstreams list<orcproto stream> streamdescriptions
list<diskrange> ranges
byte bytes
boolean includecolumn
compressioncodec codec
int buffersize
map<streamname  instream> streams
throws ioexception
long offset   0
for orcproto stream streamdesc  streamdescriptions
int column   streamdesc getcolumn
if  includecolumn
streamname getarea streamdesc getkind       streamname area data
long length   streamdesc getlength
int first    1
int last    2
for int i 0  i < bytes length    i
diskrange range   ranges get i
if  overlap offset  offset length  range offset  range end
if  first     1
first   i
last   i
bytebuffer buffers   new bytebuffer
long offsets   new long
for int i 0  i < buffers length    i
diskrange range   ranges get i   first
long start   math max range offset  offset
long end   math min range end  offset length
buffers   bytebuffer wrap bytes
math max 0   int   offset   range offset     int   end   start
offsets   math max 0  range offset   offset
streamname name   new streamname column  streamdesc getkind
streams put name  instream create name tostring    buffers  offsets
length  codec  buffersize
offset    streamdesc getlength
private void readpartialdatastreams stripeinformation stripe
throws ioexception
list<orcproto stream> streamlist   stripefooter getstreamslist
list<diskrange> chunks
planreadpartialdatastreams streamlist
indexes  included  includedrowgroups  codec    null
stripefooter getcolumnslist    types  buffersize
if  log isdebugenabled
log debug     stringifydiskranges chunks
mergediskranges chunks
if  log isdebugenabled
log debug     stringifydiskranges chunks
byte bytes   readdiskranges file  stripe getoffset    chunks
createstreams streamlist  chunks  bytes  included  codec  buffersize
streams
@override
public boolean hasnext   throws ioexception
return rowinstripe < rowcountinstripe
/**
* read the next stripe until we find a row that we don't skip.
* @throws ioexception
*/
private void advancestripe   throws ioexception
rowinstripe   rowcountinstripe
while  rowinstripe >  rowcountinstripe
currentstripe < stripes size     1
currentstripe    1
readstripe
/**
* skip over rows that we aren't selecting, so that the next row is
* one that we will read.
* @param nextrow the row we want to go to
* @throws ioexception
*/
private void advancetonextrow long nextrow  throws ioexception
long nextrowinstripe   nextrow   rowbaseinstripe
// check for row skipping
if  rowindexstride    0
includedrowgroups    null
nextrowinstripe < rowcountinstripe
int rowgroup    int   nextrowinstripe   rowindexstride
if   includedrowgroups
while  rowgroup < includedrowgroups length
includedrowgroups
rowgroup    1
// if we are off the end of the stripe, just move stripes
if  rowgroup >  includedrowgroups length
advancestripe
return
nextrowinstripe   math min rowcountinstripe  rowgroup   rowindexstride
if  nextrowinstripe < rowcountinstripe
if  nextrowinstripe    rowinstripe
if  rowindexstride    0
int rowgroup    int   nextrowinstripe   rowindexstride
seektorowentry rowgroup
reader skiprows nextrowinstripe   rowgroup   rowindexstride
else
reader skiprows nextrowinstripe   rowinstripe
rowinstripe   nextrowinstripe
else
advancestripe
@override
public object next object previous  throws ioexception
object result   reader next previous
// find the next row
rowinstripe    1
advancetonextrow rowinstripe   rowbaseinstripe
return result
@override
public void close   throws ioexception
file close
@override
public long getrownumber
return rowinstripe   rowbaseinstripe   firstrow
/**
* return the fraction of rows that have been read from the selected.
* section of the file
* @return fraction between 0.0 and 1.0 of rows consumed
*/
@override
public float getprogress
return   float  rowbaseinstripe   rowinstripe    totalrowcount
private int findstripe long rownumber
for int i 0  i < stripes size    i
stripeinformation stripe   stripes get i
if  stripe getnumberofrows   > rownumber
return i
rownumber    stripe getnumberofrows
throw new illegalargumentexception
private void readrowindex   throws ioexception
long offset   stripes get currentstripe  getoffset
for orcproto stream stream  stripefooter getstreamslist
if  stream getkind      orcproto stream kind row_index
int col   stream getcolumn
if   included    null    included     indexes    null
byte buffer   new byte
file seek offset
file readfully buffer
indexes   orcproto rowindex parsefrom instream create
new bytebuffer  bytebuffer wrap buffer    new long 0
stream getlength    codec  buffersize
offset    stream getlength
private void seektorowentry int rowentry  throws ioexception
positionprovider index   new positionprovider
for int i 0  i < indexes length    i
if  indexes    null
index
new positionproviderimpl indexes getentry rowentry
reader seek index
@override
public void seektorow long rownumber  throws ioexception
if  rownumber < 0
throw new illegalargumentexception
rownumber
else if  rownumber < firstrow
throw new illegalargumentexception
rownumber
// convert to our internal form (rows from the beginning of slice)
rownumber    firstrow
// move to the right stripe
int rightstripe   findstripe rownumber
if  rightstripe    currentstripe
currentstripe   rightstripe
readstripe
readrowindex
// if we aren't to the right row yet, advanance in the stripe.
advancetonextrow rownumber