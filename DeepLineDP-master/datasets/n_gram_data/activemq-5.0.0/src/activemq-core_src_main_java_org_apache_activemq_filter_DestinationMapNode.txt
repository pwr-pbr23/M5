/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq filter
import java util arraylist
import java util collection
import java util hashmap
import java util hashset
import java util iterator
import java util list
import java util map
import java util set
/**
* an implementation class used to implement {@link destinationmap}
*
* @version $revision: 1.2 $
*/
public class destinationmapnode implements destinationnode
protected static final string any_child   destinationmap any_child
protected static final string any_descendent   destinationmap any_descendent
// we synchornize at the destinationmap level
private destinationmapnode parent
private list values   new arraylist
private map childnodes   new hashmap
private string path
// private destinationmapnode anychild;
private int pathlength
public destinationmapnode destinationmapnode parent
this parent   parent
if  parent    null
pathlength   0
else
pathlength   parent pathlength   1
/**
* returns the child node for the given named path or null if it does not
* exist
*/
public destinationmapnode getchild string path
return  destinationmapnode childnodes get path
/**
* returns the child nodes
*/
public collection getchildren
return childnodes values
public int getchildcount
return childnodes size
/**
* returns the child node for the given named path, lazily creating one if
* it does not yet exist
*/
public destinationmapnode getchildorcreate string path
destinationmapnode answer    destinationmapnode childnodes get path
if  answer    null
answer   createchildnode
answer path   path
childnodes put path  answer
return answer
/**
* returns the node which represents all children (i.e. the * node)
*/
// public destinationmapnode getanychildnode() {
// if (anychild == null) {
// anychild = createchildnode();
// }
// return anychild;
// }
/**
* returns a mutable list of the values available at this node in the tree
*/
public list getvalues
return values
/**
* returns a mutable list of the values available at this node in the tree
*/
public list removevalues
arraylist v   new arraylist values
// parent.getanychildnode().getvalues().removeall(v);
values clear
pruneifempty
return v
public set removedesendentvalues
set answer   new hashset
removedesendentvalues answer
return answer
protected void removedesendentvalues set answer
// if (anychild != null) {
// anychild.removedesendentvalues(answer);
// }
answer addall removevalues
/**
* returns a list of all the values from this node down the tree
*/
public set getdesendentvalues
set answer   new hashset
appenddescendantvalues answer
return answer
public void add string paths  int idx  object value
if  idx >  paths length
values add value
else
// if (idx == paths.length - 1) {
// getanychildnode().getvalues().add(value);
// }
// else {
// getanychildnode().add(paths, idx + 1, value);
// }
getchildorcreate paths  add paths  idx   1  value
public void remove string paths  int idx  object value
if  idx >  paths length
values remove value
pruneifempty
else
// if (idx == paths.length - 1) {
// getanychildnode().getvalues().remove(value);
// }
// else {
// getanychildnode().remove(paths, idx + 1, value);
// }
getchildorcreate paths  remove paths    idx  value
public void removeall set answer  string paths  int startindex
destinationnode node   this
int size   paths length
for  int i   startindex  i < size    node    null  i
string path   paths
if  path equals any_descendent
answer addall node removedesendentvalues
break
node appendmatchingwildcards answer  paths  i
if  path equals any_child
// node = node.getanychildnode();
node   new anychilddestinationnode node
else
node   node getchild path
if  node    null
answer addall node removevalues
public void appenddescendantvalues set answer
answer addall values
// lets add all the children too
iterator iter   childnodes values   iterator
while  iter hasnext
destinationnode child    destinationnode iter next
child appenddescendantvalues answer
// todo???
// if (anychild != null) {
// anychild.appenddescendantvalues(answer);
// }
/**
* factory method to create a child node
*/
protected destinationmapnode createchildnode
return new destinationmapnode this
/**
* matches any entries in the map containing wildcards
*/
public void appendmatchingwildcards set answer  string paths  int idx
if  idx   1 > pathlength
return
destinationmapnode wildcardnode   getchild any_child
if  wildcardnode    null
wildcardnode appendmatchingvalues answer  paths  idx   1
wildcardnode   getchild any_descendent
if  wildcardnode    null
answer addall wildcardnode getdesendentvalues
public void appendmatchingvalues set answer  string paths  int startindex
destinationnode node   this
boolean couldmatchany   true
int size   paths length
for  int i   startindex  i < size    node    null  i
string path   paths
if  path equals any_descendent
answer addall node getdesendentvalues
couldmatchany   false
break
node appendmatchingwildcards answer  paths  i
if  path equals any_child
node   new anychilddestinationnode node
else
node   node getchild path
if  node    null
answer addall node getvalues
if  couldmatchany
// lets allow foo.bar to match the foo.bar.> entry in the map
destinationnode child   node getchild any_descendent
if  child    null
answer addall child getvalues
public string getpath
return path
protected void pruneifempty
if  parent    null    childnodes isempty      values isempty
parent removechild this
protected void removechild destinationmapnode node
childnodes remove node getpath
pruneifempty