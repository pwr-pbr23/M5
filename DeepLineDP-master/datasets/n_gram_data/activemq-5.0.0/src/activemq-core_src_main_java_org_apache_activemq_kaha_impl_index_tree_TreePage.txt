/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq kaha impl index tree
import java io datainput
import java io dataoutput
import java io ioexception
import java util arraylist
import java util hashset
import java util list
import java util set
import org apache activemq kaha marshaller
import org apache commons logging log
import org apache commons logging logfactory
/**
* page in a btree
*
* @version $revision: 1.1.1.1 $
*/
class treepage
static final int page_header_size   18
private static final transient log log   logfactory getlog treepage class
static enum flavour
less  more
private treeindex tree
private int maximumentries
private long id
private long parentid   treeentry not_set
private boolean leaf   true
private list<treeentry> treeentries
/*
* for persistence only
*/
private long nextfreepageid   treeentry not_set
private boolean active   true
/**
* constructor
*
* @param tree
* @param id
* @param parentid
* @param maximumentries
*/
treepage treeindex tree  long id  long parentid  int maximumentries
this maximumentries
this tree   tree
this id   id
this parentid   parentid
/**
* constructor
*
* @param maximumentries
*/
public treepage int maximumentries
this maximumentries   maximumentries
this treeentries   new arraylist<treeentry> maximumentries
public string tostring
return     getid         getparentid
public boolean equals object o
boolean result   false
if  o instanceof treepage
treepage other    treepage o
result   other id    id
return result
public int hashcode
return  int id
boolean isactive
return this active
void setactive boolean active
this active   active
long getnextfreepageid
return this nextfreepageid
void setnextfreepageid long nextpageid
this nextfreepageid   nextpageid
long getid
return id
void setid long id
this id   id
void write marshaller keymarshaller  dataoutput dataout  throws ioexception
writeheader dataout
dataout writeint treeentries size
for  treeentry entry   treeentries
entry write keymarshaller  dataout
void read marshaller keymarshaller  datainput datain  throws ioexception
readheader datain
int size   datain readint
treeentries clear
for  int i   0  i < size  i
treeentry entry   new treeentry
entry read keymarshaller  datain
treeentries add entry
void readheader datainput datain  throws ioexception
active   datain readboolean
leaf   datain readboolean
setparentid datain readlong
nextfreepageid   datain readlong
void writeheader dataoutput dataout  throws ioexception
dataout writeboolean isactive
dataout writeboolean isleaf
dataout writelong getparentid
dataout writelong nextfreepageid
boolean isempty
return treeentries isempty
boolean isfull
return treeentries size   >  maximumentries
boolean isroot
return getparentid   < 0
boolean isleaf
if  treeentries isempty
leaf   true
return leaf
boolean isunderflowed
return treeentries size   <  maximumentries   2
boolean isoverflowed
return treeentries size   > maximumentries
void setleaf boolean newvalue
this leaf   newvalue
treepage getparent   throws ioexception
return tree lookuppage parentid
long getparentid
return parentid
void setparentid long newid  throws ioexception
if  newid    this id
throw new illegalstateexception     this
newid
this parentid   newid
tree writepage this
list<treeentry> getentries
return treeentries
void setentries list<treeentry> newentries
this treeentries   newentries
int getmaximumentries
return this maximumentries
void setmaximumentries int maximumentries
this maximumentries   maximumentries
int size
return treeentries size
treeindex gettree
return this tree
void settree treeindex tree
this tree   tree
void reset   throws ioexception
treeentries clear
setparentid treeentry not_set
setnextfreepageid treeentry not_set
setleaf true
public treeentry find treeentry key  throws ioexception
int low   0
int high   size     1
long pageid    1
while  low <  high
int mid    low   high  >> 1
treeentry te   gettreeentry mid
int cmp   te compareto key
if  cmp    0
return te
else if  cmp < 0
low   mid   1
pageid   te getnextpageid
else
high   mid   1
pageid   te getprevpageid
treepage page   tree lookuppage pageid
if  page    null
return page find key
return null
treeentry put treeentry newentry  throws ioexception
treeentry result   null
if  isroot
if  isempty
inserttreeentry 0  newentry
else
result   doinsert null  newentry
else
throw new illegalstateexception     this
return result
treeentry remove treeentry entry  throws ioexception
treeentry result   null
if  isroot
if   isempty
result   doremove entry
else
throw new illegalstateexception
return result
private treeentry doinsert flavour flavour  treeentry newentry  throws ioexception
treeentry result   null
treepageentry closest   findclosestentry newentry
if  closest    null
treeentry closestentry   closest gettreeentry
treepage closestpage   closest gettreepage
int cmp   closestentry compareto newentry
if  cmp    0
// we actually just need to pass back the value
long oldvalue   closestentry getindexoffset
closestentry setindexoffset newentry getindexoffset
newentry setindexoffset oldvalue
result   newentry
save
else if  closestpage    null
result   closestpage doinsert closest getflavour    newentry
else
if   isfull
inserttreeentry closest getindex    newentry
save
else
dooverflow flavour  newentry
else
if   isfull
doinsertentry newentry
save
else
// need to insert the new entry and propogate up the hightest
// value
dooverflow flavour  newentry
return result
private treepage dooverflow flavour flavour  treeentry newentry  throws ioexception
treepage result   this
treeentry theentry   newentry
if   isfull
doinsertentry newentry
save
else
if   isroot      flavour    null
// we aren't the root, but to ensure the correct distribution we
// need to
// insert the new entry and take a node of the end of the page
// and pass that up the tree to find a home
doinsertentry newentry
if  flavour    flavour less
theentry   removetreeentry 0
theentry reset
theentry setnextpageid getid
else
theentry   removetreeentry size     1
theentry reset
theentry setprevpageid getid
save
result   getparent   dooverflow flavour  theentry
if   theentry equals newentry
// the newentry stayed here
result   this
else
// so we are the root and need to split
doinsertentry newentry
int midindex   size     2
treeentry midentry   removetreeentry midindex
list<treeentry> sublist   getsublist midindex  size
removealltreeentries sublist
treepage newroot   tree createroot
newroot setleaf false
this setparentid newroot getid
save       we are no longer root   need to save   we maybe
// looked up v. soon!
treepage rightpage   tree createpage newroot getid
rightpage setentries sublist
rightpage checkleaf
resetparentid rightpage getid    rightpage getentries
midentry setnextpageid rightpage getid
midentry setprevpageid this getid
newroot inserttreeentry 0  midentry
resetparentid newroot getid    newroot getentries
save
rightpage save
newroot save
return result
private treeentry doremove treeentry entry  throws ioexception
treeentry result   null
treepageentry closest   findclosestentry entry
if  closest    null
treeentry closestentry   closest gettreeentry
if  closestentry    null
treepage closestpage   closest gettreepage
int cmp   closestentry compareto entry
if  cmp    0
result   closest gettreeentry
int index   closest getindex
removetreeentry index
save
// ensure we don't loose children
dounderflow result  index
else if  closestpage    null
closestpage doremove entry
return result
/**
* @return true if the page is removed
* @throws ioexception
*/
private boolean dounderflow   throws ioexception
boolean result   false
boolean working   true
while  working    isunderflowed       isempty       isleaf
int lastindex   size     1
treeentry entry   gettreeentry lastindex
working   dounderflow entry  lastindex
if  isunderflowed      isleaf
result   dounderflowleaf
return result
private boolean dounderflow treeentry entry  int index  throws ioexception
boolean result   false
// pull an entry up from a leaf to fill the empty space
if  entry getnextpageid      treeentry not_set
treepage page   tree lookuppage entry getnextpageid
if  page    null     page isempty
treeentry replacement   page removetreeentry 0
treeentry copy   replacement copy
checkparentidforremovedpageentry copy  page getid    getid
if   page isempty
copy setnextpageid page getid
page setparentid this id
else
page setleaf true
int replacementindex   doinsertentry copy
if  page dounderflow
// page removed so update our replacement
resetpagereference replacementindex  copy getnextpageid
copy setnextpageid treeentry not_set
else
page save
save
result   true
// ensure we don't loose previous bit of the tree
if  entry getprevpageid      treeentry not_set
treeentry preventry    index > 0  ? gettreeentry index   1    null
if  preventry    null    preventry getnextpageid      entry getprevpageid
treepage page   tree lookuppage entry getprevpageid
if  page    null     page isempty
treeentry replacement   page removetreeentry page getentries   size     1
treeentry copy   replacement copy
// check children pages of the replacement point to the
// correct place
checkparentidforremovedpageentry copy  page getid    getid
if   page isempty
copy setprevpageid page getid
else
page setleaf true
inserttreeentry index  copy
// if we overflow - the page the replacement ends up on
treepage landed   null
treeentry removed   null
if  isoverflowed
treepage parent   getparent
if  parent    null
removed   gettreeentry 0
flavour flavour   getflavour parent  removed
if  flavour    flavour less
removed   removetreeentry 0
landed   parent dooverflow flavour  removed
else
removed   removetreeentry size     1
landed   parent dooverflow flavour more  removed
if  page dounderflow
if  landed    null    landed equals this
landed   this
resetpagereference copy getnextpageid
landed resetpagereference copy getnextpageid
copy setprevpageid treeentry not_set
landed save
else
page save
save
result   true
// now we need to check we haven't overflowed this page
if   result
save
// now see if we need to save this page
result    dounderflowleaf
save
return result
private boolean dounderflowleaf   throws ioexception
boolean result   false
// if we have unerflowed - and we are a leaf - push entries further up
// the tree
// and delete ourselves
if  isunderflowed      isleaf
list<treeentry> list   new arraylist<treeentry> treeentries
treeentries clear
for  treeentry entry   list
// need to check for each iteration - we might get promoted to
// root
treepage parent   getparent
if  parent    null
flavour flavour   getflavour parent  entry
treepage landedon   parent dooverflow flavour  entry
checkparentidforremovedpageentry entry  getid    landedon getid
treepage parent   getparent
if  parent    null
parent checkleaf
parent removepageid getid
parent dounderflow
parent save
tree releasepage this
result   true
return result
private flavour getflavour treepage page  treeentry entry
flavour result   null
if  page    null     page getentries   isempty
treeentry last   page getentries   get page getentries   size     1
if  last compareto entry  > 0
result   flavour more
else
result   flavour less
return result
private void checkleaf
boolean result   false
for  treeentry entry   treeentries
if  entry haschildpagesreferences
result   true
break
setleaf  result
private void checkparentidforremovedpageentry treeentry entry  long oldpageid  long newpageid
throws ioexception
treepage page   tree lookuppage entry getprevpageid
if  page    null    page getparentid      oldpageid
page setparentid newpageid
page save
page   tree lookuppage entry getnextpageid
if  page    null    page getparentid      oldpageid
page setparentid newpageid
page save
private void removepageid long pageid
for  treeentry entry   treeentries
if  entry getnextpageid      pageid
entry setnextpageid treeentry not_set
if  entry getprevpageid      pageid
entry setprevpageid treeentry not_set
private treepageentry findclosestentry treeentry key  throws ioexception
treepageentry result   null
treeentry treeentry   null
flavour flavour   null
long pageid    1
int low   0
int high   size     1
int mid   low
while  low <  high
mid    low   high  >> 1
treeentry   gettreeentry mid
int cmp   treeentry compareto key
if  cmp < 0
low   mid   1
pageid   treeentry getnextpageid
flavour   flavour less
else if  cmp > 0
high   mid   1
pageid   treeentry getprevpageid
flavour   flavour more
else
// got exact match
low   mid
break
if  treeentry    null
treepage treepage   tree lookuppage pageid
result   new treepageentry treeentry  treepage  flavour  low
return result
private int doinsertentry treeentry newentry  throws ioexception
int low   0
int high   size     1
while  low <  high
int mid    low   high  >> 1
treeentry midval   gettreeentry mid
int cmp   midval compareto newentry
if  cmp < 0
low   mid   1
else if  cmp > 0
high   mid   1
inserttreeentry low  newentry
return low
private void inserttreeentry int index  treeentry entry  throws ioexception
int p   index   1
int n   index
treeentry preventry    p >  0    p < treeentries size    ? treeentries get p    null
treeentry nextentry    n >  0    n < treeentries size    ? treeentries get n    null
if  preventry    null
if  preventry getnextpageid      entry getnextpageid
preventry setnextpageid treeentry not_set
if  entry getprevpageid      treeentry not_set
entry setprevpageid preventry getnextpageid
if  nextentry    null
if  nextentry getprevpageid      entry getprevpageid
nextentry setprevpageid treeentry not_set
if  entry getnextpageid      treeentry not_set
entry setnextpageid nextentry getprevpageid
addtreeentry index  entry
private void resetpagereference int index  long pageid
int p   index   1
int n   index
treeentry preventry    p >  0    p < treeentries size    ? treeentries get p    null
treeentry nextentry    n >  0    n < treeentries size    ? treeentries get n    null
if  preventry    null
if  preventry getnextpageid      pageid
preventry setnextpageid treeentry not_set
if  nextentry    null
if  nextentry getprevpageid      pageid
nextentry setprevpageid treeentry not_set
private boolean resetpagereference long pageid
boolean updated   false
for  treeentry entry   treeentries
if  entry getprevpageid      pageid
entry setprevpageid treeentry not_set
updated   true
if  entry getnextpageid      pageid
entry setnextpageid treeentry not_set
updated   true
return updated
private void resetparentid long newparentid  list<treeentry> entries  throws ioexception
set<long> set   new hashset<long>
for  treeentry entry   entries
if  entry    null
set add entry getprevpageid
set add entry getnextpageid
for  long pageid   set
treepage page   tree lookuppage pageid
if  page    null
page setparentid newparentid
private void addtreeentry int index  treeentry entry  throws ioexception
treeentries add index  entry
private treeentry removetreeentry int index  throws ioexception
treeentry result   treeentries remove index
return result
private void removealltreeentries list<treeentry> c
treeentries removeall c
private list<treeentry> getsublist int from  int to
return new arraylist<treeentry> treeentries sublist from  to
private treeentry gettreeentry int index
treeentry result   treeentries get index
return result
void saveheader   throws ioexception
tree writepage this
void save   throws ioexception
tree writefullpage this
protected void dump   throws ioexception
log info this
set<long> set   new hashset<long>
for  treeentry entry   treeentries
if  entry    null
log info entry
set add entry getprevpageid
set add entry getnextpageid
for  long pageid   set
treepage page   tree lookuppage pageid
if  page    null
page dump