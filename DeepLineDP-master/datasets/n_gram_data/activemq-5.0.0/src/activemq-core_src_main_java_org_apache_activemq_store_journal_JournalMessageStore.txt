/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store journal
import java io ioexception
import java util arraylist
import java util collections
import java util hashset
import java util iterator
import java util linkedhashmap
import java util list
import java util map
import java util set
import org apache activeio journal recordlocation
import org apache activemq broker connectioncontext
import org apache activemq command activemqdestination
import org apache activemq command journalqueueack
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messageid
import org apache activemq store messagerecoverylistener
import org apache activemq store messagestore
import org apache activemq store persistenceadapter
import org apache activemq transaction synchronization
import org apache activemq usage memoryusage
import org apache activemq usage systemusage
import org apache activemq util callback
import org apache activemq util transactiontemplate
import org apache commons logging log
import org apache commons logging logfactory
/**
* a messagestore that uses a journal to store it's messages.
*
* @version $revision: 1.14 $
*/
public class journalmessagestore implements messagestore
private static final log log   logfactory getlog journalmessagestore class
protected final journalpersistenceadapter peristenceadapter
protected final journaltransactionstore transactionstore
protected final messagestore longtermstore
protected final activemqdestination destination
protected final transactiontemplate transactiontemplate
protected recordlocation lastlocation
protected set<recordlocation> inflighttxlocations   new hashset<recordlocation>
private map<messageid  message> messages   new linkedhashmap<messageid  message>
private list<messageack> messageacks   new arraylist<messageack>
/** a messagestore that we can use to retrieve messages quickly. */
private map<messageid  message> cpaddedmessageids
private memoryusage memoryusage
public journalmessagestore journalpersistenceadapter adapter  messagestore checkpointstore  activemqdestination destination
this peristenceadapter   adapter
this transactionstore   adapter gettransactionstore
this longtermstore   checkpointstore
this destination   destination
this transactiontemplate   new transactiontemplate adapter  new connectioncontext
public void setmemoryusage memoryusage memoryusage
this memoryusage memoryusage
longtermstore setmemoryusage memoryusage
/**
* not synchronized since the journal has better throughput if you increase
* the number of concurrent writes that it is doing.
*/
public void addmessage connectioncontext context  final message message  throws ioexception
final messageid id   message getmessageid
final boolean debug   log isdebugenabled
message incrementreferencecount
final recordlocation location   peristenceadapter writecommand message  message isresponserequired
if   context isintransaction
if  debug
log debug     id       location
addmessage message  location
else
if  debug
log debug     id       location
synchronized  this
inflighttxlocations add location
transactionstore addmessage this  message  location
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
if  debug
log debug     id       location
synchronized  journalmessagestore this
inflighttxlocations remove location
addmessage message  location
public void afterrollback   throws exception
if  debug
log debug     id       location
synchronized  journalmessagestore this
inflighttxlocations remove location
message decrementreferencecount
void addmessage final message message  final recordlocation location
synchronized  this
lastlocation   location
messageid id   message getmessageid
messages put id  message
public void replayaddmessage connectioncontext context  message message
try
// only add the message if it has not already been added.
message t   longtermstore getmessage message getmessageid
if  t    null
longtermstore addmessage context  message
catch  throwable e
log warn     message getmessageid         e
/**
*/
public void removemessage connectioncontext context  final messageack ack  throws ioexception
final boolean debug   log isdebugenabled
journalqueueack remove   new journalqueueack
remove setdestination destination
remove setmessageack ack
final recordlocation location   peristenceadapter writecommand remove  ack isresponserequired
if   context isintransaction
if  debug
log debug     ack getlastmessageid         location
removemessage ack  location
else
if  debug
log debug     ack getlastmessageid         location
synchronized  this
inflighttxlocations add location
transactionstore removemessage this  ack  location
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
if  debug
log debug     ack getlastmessageid         location
synchronized  journalmessagestore this
inflighttxlocations remove location
removemessage ack  location
public void afterrollback   throws exception
if  debug
log debug     ack getlastmessageid         location
synchronized  journalmessagestore this
inflighttxlocations remove location
final void removemessage final messageack ack  final recordlocation location
synchronized  this
lastlocation   location
messageid id   ack getlastmessageid
message message   messages remove id
if  message    null
messageacks add ack
else
message decrementreferencecount
public void replayremovemessage connectioncontext context  messageack messageack
try
// only remove the message if it has not already been removed.
message t   longtermstore getmessage messageack getlastmessageid
if  t    null
longtermstore removemessage context  messageack
catch  throwable e
log warn     messageack getlastmessageid         e
/**
* @return
* @throws ioexception
*/
public recordlocation checkpoint   throws ioexception
return checkpoint null
/**
* @return
* @throws ioexception
*/
@suppresswarnings
public recordlocation checkpoint final callback postcheckpointtest  throws ioexception
final list<messageack> cpremovedmessagelocations
final list<recordlocation> cpactivejournallocations
final int maxcheckpointmessageaddsize   peristenceadapter getmaxcheckpointmessageaddsize
// swap out the message hash maps..
synchronized  this
cpaddedmessageids   this messages
cpremovedmessagelocations   this messageacks
cpactivejournallocations   new arraylist<recordlocation> inflighttxlocations
this messages   new linkedhashmap<messageid  message>
this messageacks   new arraylist<messageack>
transactiontemplate run new callback
public void execute   throws exception
int size   0
persistenceadapter persitanceadapter   transactiontemplate getpersistenceadapter
connectioncontext context   transactiontemplate getcontext
// checkpoint the added messages.
synchronized  journalmessagestore this
iterator<message> iterator   cpaddedmessageids values   iterator
while  iterator hasnext
message message   iterator next
try
longtermstore addmessage context  message
catch  throwable e
log warn     e getmessage    e
size    message getsize
message decrementreferencecount
// commit the batch if it's getting too big
if  size >  maxcheckpointmessageaddsize
persitanceadapter committransaction context
persitanceadapter begintransaction context
size   0
persitanceadapter committransaction context
persitanceadapter begintransaction context
// checkpoint the removed messages.
iterator<messageack> iterator   cpremovedmessagelocations iterator
while  iterator hasnext
try
messageack ack   iterator next
longtermstore removemessage transactiontemplate getcontext    ack
catch  throwable e
log debug     e getmessage    e
if  postcheckpointtest    null
postcheckpointtest execute
synchronized  this
cpaddedmessageids   null
if  cpactivejournallocations size   > 0
collections sort cpactivejournallocations
return cpactivejournallocations get 0
synchronized  this
return lastlocation
/**
*
*/
public message getmessage messageid identity  throws ioexception
message answer   null
synchronized  this
// do we have a still have it in the journal?
answer   messages get identity
if  answer    null    cpaddedmessageids    null
answer   cpaddedmessageids get identity
if  answer    null
return answer
// if all else fails try the long term message store.
return longtermstore getmessage identity
/**
* replays the checkpointstore first as those messages are the oldest ones,
* then messages are replayed from the transaction log and then the cache is
* updated.
*
* @param listener
* @throws exception
*/
public void recover final messagerecoverylistener listener  throws exception
peristenceadapter checkpoint true  true
longtermstore recover listener
public void start   throws exception
if  this memoryusage    null
this memoryusage addusagelistener peristenceadapter
longtermstore start
public void stop   throws exception
longtermstore stop
if  this memoryusage    null
this memoryusage removeusagelistener peristenceadapter
/**
* @return returns the longtermstore.
*/
public messagestore getlongtermmessagestore
return longtermstore
/**
* @see org.apache.activemq.store.messagestore#removeallmessages(connectioncontext)
*/
public void removeallmessages connectioncontext context  throws ioexception
peristenceadapter checkpoint true  true
longtermstore removeallmessages context
public activemqdestination getdestination
return destination
public void addmessagereference connectioncontext context  messageid messageid  long expirationtime  string messageref  throws ioexception
throw new ioexception
public string getmessagereference messageid identity  throws ioexception
throw new ioexception
/**
* @return
* @throws ioexception
* @see org.apache.activemq.store.messagestore#getmessagecount()
*/
public int getmessagecount   throws ioexception
peristenceadapter checkpoint true  true
return longtermstore getmessagecount
public void recovernextmessages int maxreturned  messagerecoverylistener listener  throws exception
peristenceadapter checkpoint true  true
longtermstore recovernextmessages maxreturned  listener
public void resetbatching
longtermstore resetbatching