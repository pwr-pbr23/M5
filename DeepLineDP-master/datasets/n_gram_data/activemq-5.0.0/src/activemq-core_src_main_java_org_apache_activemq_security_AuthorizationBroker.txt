/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq security
import java util set
import org apache activemq broker broker
import org apache activemq broker brokerfilter
import org apache activemq broker connectioncontext
import org apache activemq broker producerbrokerexchange
import org apache activemq broker region destination
import org apache activemq broker region subscription
import org apache activemq command activemqdestination
import org apache activemq command activemqqueue
import org apache activemq command activemqtopic
import org apache activemq command consumerinfo
import org apache activemq command message
import org apache activemq command producerinfo
/**
* verifies if a authenticated user can do an operation against the broker using
* an authorization map.
*
* @version $revision$
*/
public class authorizationbroker extends brokerfilter implements securityadminmbean
private final authorizationmap authorizationmap
public authorizationbroker broker next  authorizationmap authorizationmap
super next
this authorizationmap   authorizationmap
public destination adddestination connectioncontext context  activemqdestination destination  throws exception
final securitycontext securitycontext    securitycontext context getsecuritycontext
if  securitycontext    null
throw new securityexception
// if(!((activemqtempdestination)destination).getconnectionid().equals(context.getconnectionid().getvalue())
// ) {
if   securitycontext isbrokercontext
set<?> allowedacls   null
if   destination istemporary
allowedacls   authorizationmap getadminacls destination
else
allowedacls   authorizationmap gettempdestinationadminacls
if  allowedacls    null     securitycontext isinoneof allowedacls
throw new securityexception     securitycontext getusername         destination
// }
return super adddestination context  destination
public void removedestination connectioncontext context  activemqdestination destination  long timeout  throws exception
final securitycontext securitycontext    securitycontext context getsecuritycontext
if  securitycontext    null
throw new securityexception
set<?> allowedacls   null
if   destination istemporary
allowedacls   authorizationmap getadminacls destination
else
allowedacls   authorizationmap gettempdestinationadminacls
if  allowedacls    null     securitycontext isinoneof allowedacls
throw new securityexception     securitycontext getusername         destination
super removedestination context  destination  timeout
public subscription addconsumer connectioncontext context  consumerinfo info  throws exception
final securitycontext subject    securitycontext context getsecuritycontext
if  subject    null
throw new securityexception
set<?> allowedacls   null
if   info getdestination   istemporary
allowedacls   authorizationmap getreadacls info getdestination
else
allowedacls   authorizationmap gettempdestinationreadacls
if  allowedacls    null     subject isinoneof allowedacls
throw new securityexception     subject getusername         info getdestination
subject getauthorizedreaddests   put info getdestination    info getdestination
/*
* need to think about this a little more. we could do per message
* security checking to implement finer grained security checking. for
* example a user can only see messages with price>1000 . perhaps this
* should just be another additional broker filter that installs this
* type of feature. if we did want to do that, then we would install a
* predicate. we should be careful since there may be an existing
* predicate already assigned and the consumer info may be sent to a
* remote broker, so it also needs to support being marshaled.
* info.setadditionalpredicate(new booleanexpression() { public boolean
* matches(messageevaluationcontext message) throws jmsexception { if(
* !subject.getauthorizedreaddests().contains(message.getdestination()) ) {
* set allowedacls =
* authorizationmap.getreadacls(message.getdestination());
* if(allowedacls!=null && !subject.isinoneof(allowedacls)) return
* false; subject.getauthorizedreaddests().put(message.getdestination(),
* message.getdestination()); } return true; } public object
* evaluate(messageevaluationcontext message) throws jmsexception {
* return matches(message) ? boolean.true : boolean.false; } });
*/
return super addconsumer context  info
public void addproducer connectioncontext context  producerinfo info  throws exception
securitycontext subject    securitycontext context getsecuritycontext
if  subject    null
throw new securityexception
if  info getdestination      null
set<?> allowedacls   null
if   info getdestination   istemporary
allowedacls   authorizationmap getwriteacls info getdestination
else
allowedacls   authorizationmap gettempdestinationwriteacls
if  allowedacls    null     subject isinoneof allowedacls
throw new securityexception     subject getusername         info getdestination
subject getauthorizedwritedests   put info getdestination    info getdestination
super addproducer context  info
public void send producerbrokerexchange producerexchange  message messagesend  throws exception
securitycontext subject    securitycontext producerexchange getconnectioncontext   getsecuritycontext
if  subject    null
throw new securityexception
if   subject getauthorizedwritedests   contains messagesend getdestination
set<?> allowedacls   null
if   messagesend getdestination   istemporary
allowedacls   authorizationmap getwriteacls messagesend getdestination
else
allowedacls   authorizationmap gettempdestinationwriteacls
if  allowedacls    null     subject isinoneof allowedacls
throw new securityexception     subject getusername         messagesend getdestination
subject getauthorizedwritedests   put messagesend getdestination    messagesend getdestination
super send producerexchange  messagesend
// securityadminmbean interface
// -------------------------------------------------------------------------
public void addqueuerole string queue  string operation  string role
adddestinationrole new activemqqueue queue   operation  role
public void addtopicrole string topic  string operation  string role
adddestinationrole new activemqtopic topic   operation  role
public void removequeuerole string queue  string operation  string role
removedestinationrole new activemqqueue queue   operation  role
public void removetopicrole string topic  string operation  string role
removedestinationrole new activemqtopic topic   operation  role
public void adddestinationrole javax jms destination destination  string operation  string role
public void removedestinationrole javax jms destination destination  string operation  string role
public void addrole string role
public void adduserrole string user  string role
public void removerole string role
public void removeuserrole string user  string role