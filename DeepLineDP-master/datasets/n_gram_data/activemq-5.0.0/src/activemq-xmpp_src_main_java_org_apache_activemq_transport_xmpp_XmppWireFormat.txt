/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport xmpp
import java io datainput
import java io datainputstream
import java io dataoutput
import java io dataoutputstream
import java io ioexception
import org apache activemq util bytearrayinputstream
import org apache activemq util bytearrayoutputstream
import org apache activemq util bytesequence
import org apache activemq wireformat wireformat
import org apache commons logging log
import org apache commons logging logfactory
/**
* a wire format which uses xmpp format of messages
*
* @version $revision$
*/
public class xmppwireformat implements wireformat
private int version   1
public wireformat copy
return new xmppwireformat
}
/*
public packet readpacket(datainput in) throws ioexception {
return null;
}
public packet readpacket(int firstbyte, datainput in) throws ioexception {
return null;
}
public packet writepacket(packet packet, dataoutput out) throws ioexception, jmsexception {
switch (packet.getpackettype()) {
case packet.activemq_message:
writemessage((activemqmessage) packet, "", out);
break;
case packet.activemq_text_message:
writetextmessage((activemqtextmessage) packet, out);
break;
case packet.activemq_bytes_message:
writebytesmessage((activemqbytesmessage) packet, out);
break;
case packet.activemq_object_message:
writeobjectmessage((activemqobjectmessage) packet, out);
break;
case packet.activemq_map_message:
case packet.activemq_stream_message:
case packet.activemq_broker_info:
case packet.activemq_connection_info:
case packet.activemq_msg_ack:
case packet.consumer_info:
case packet.durable_unsubscribe:
case packet.int_response_receipt_info:
case packet.producer_info:
case packet.receipt_info:
case packet.response_receipt_info:
case packet.session_info:
case packet.transaction_info:
case packet.xa_transaction_info:
default:
log.warn("ignoring message type: " + packet.getpackettype() + " packet: " + packet);
}
return null;
}
*/
//    /**
//     * can this wireformat process packets of this version
//     * @param version the version number to test
//     * @return true if can accept the version
//     */
//    public boolean canprocesswireformatversion(int version){
//        return true;
//    }
//
//    /**
//     * @return the current version of this wire format
//     */
//    public int getcurrentwireformatversion(){
//        return 1;
//    }
//
//    // implementation methods
//    //-------------------------------------------------------------------------
//    protected void writeobjectmessage(activemqobjectmessage message, dataoutput out) throws jmsexception, ioexception {
//        serializable object = message.getobject();
//        string text = (object != null) ? object.tostring() : "";
//        writemessage(message, text, out);
//    }
//
//    protected void writetextmessage(activemqtextmessage message, dataoutput out) throws jmsexception, ioexception {
//        writemessage(message, message.gettext(), out);
//    }
//
//    protected void writebytesmessage(activemqbytesmessage message, dataoutput out) throws ioexception {
//        bytearray data = message.getbodyasbytes();
//        string text = encodebinary(data.getbuf(),data.getoffset(),data.getlength());
//        writemessage(message, text, out);
//    }
//
//    protected void writemessage(activemqmessage message, string body, dataoutput out) throws ioexception {
//        string type = getxmpptype(message);
//
//        stringbuffer buffer = new stringbuffer("<");
//        buffer.append(type);
//        buffer.append(" to='");
//        buffer.append(message.getjmsdestination().tostring());
//        buffer.append("' from='");
//        buffer.append(message.getjmsreplyto().tostring());
//        string messageid = message.getjmsmessageid();
//        if (messageid != null) {
//            buffer.append("' id='");
//            buffer.append(messageid);
//        }
//
//        hashmap properties = message.getproperties();
//        if (properties != null) {
//            for (iterator iter = properties.entryset().iterator(); iter.hasnext();) {
//                map.entry entry = (map.entry) iter.next();
//                object key = entry.getkey();
//                object value = entry.getvalue();
//                if (value != null) {
//                    buffer.append("' ");
//                    buffer.append(key.tostring());
//                    buffer.append("='");
//                    buffer.append(value.tostring());
//                }
//            }
//        }
//
//        buffer.append("'>");
//
//        string id = message.getjmscorrelationid();
//        if (id != null) {
//            buffer.append("<thread>");
//            buffer.append(id);
//            buffer.append("</thread>");
//        }
//        buffer.append(body);
//        buffer.append("</");
//        buffer.append(type);
//        buffer.append(">");
//
//        out.write(buffer.tostring().getbytes());
//    }
//
//    protected string encodebinary(byte[] data,int offset,int length) {
//        // todo
//        throw new runtimeexception("not implemented yet!");
//    }
//
//    protected string getxmpptype(activemqmessage message) {
//        string type = message.getjmstype();
//        if (type == null) {
//            type = "message";
//        }
//        return type;
//    }
public bytesequence marshal object command  throws ioexception
bytearrayoutputstream baos   new bytearrayoutputstream
dataoutputstream dos   new dataoutputstream baos
marshal command  dos
dos close
return baos tobytesequence
}
public object unmarshal bytesequence packet  throws ioexception
bytearrayinputstream stream   new bytearrayinputstream packet
datainputstream dis   new datainputstream stream
return unmarshal dis
}
public void marshal object object  dataoutput dataoutput  throws ioexception
/** todo */
}
public object unmarshal datainput datainput  throws ioexception
return null       todo
}
public int getversion
return version
}
public void setversion int version
this version   version
}
}