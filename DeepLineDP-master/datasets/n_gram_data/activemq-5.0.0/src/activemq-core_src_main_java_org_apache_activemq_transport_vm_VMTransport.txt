/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport vm
import java io ioexception
import java io interruptedioexception
import java net uri
import java util concurrent linkedblockingqueue
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomiclong
import org apache activemq command command
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq thread valve
import org apache activemq transport futureresponse
import org apache activemq transport responsecallback
import org apache activemq transport transport
import org apache activemq transport transportdisposedioexception
import org apache activemq transport transportlistener
import org apache activemq util ioexceptionsupport
/**
* a transport implementation that uses direct method invocations.
*
* @version $revision$
*/
public class vmtransport implements transport  task
private static final object disconnect   new object
private static final atomiclong next_id   new atomiclong 0
private static final taskrunnerfactory task_runner_factory   new taskrunnerfactory    thread norm_priority  true  1000
protected vmtransport peer
protected transportlistener transportlistener
protected boolean disposed
protected boolean marshal
protected boolean network
protected boolean async   true
protected int asyncqueuedepth   2000
protected linkedblockingqueue<object> messagequeue
protected boolean started
protected final uri location
protected final long id
private taskrunner taskrunner
private final object lazyinitmutext   new object
private final valve enqueuevalve   new valve true
private final atomicboolean stopping   new atomicboolean
public vmtransport uri location
this location   location
this id   next_id getandincrement
public void setpeer vmtransport peer
this peer   peer
public void oneway object command  throws ioexception
if  disposed
throw new transportdisposedioexception
if  peer    null
throw new ioexception
try
// disable the peer from changing his state while we try to enqueue onto him.
peer enqueuevalve increment
if  peer disposed    peer stopping get
throw new transportdisposedioexception     peer tostring
if  peer started
if  peer async
peer getmessagequeue   put command
peer wakeup
else
if  command    disconnect
peer transportlistener onexception new transportdisposedioexception     peer tostring
else
peer transportlistener oncommand command
enqueuevalve decrement
else
peer getmessagequeue   put command
catch  interruptedexception e
throw ioexceptionsupport create e
finally
// allow the peer to change state again...
peer enqueuevalve decrement
public void start   throws exception
if  transportlistener    null
throw new ioexception
try
enqueuevalve turnoff
if  messagequeue    null     async
object command
while   command   messagequeue poll       null     stopping get
transportlistener oncommand command
started   true
wakeup
finally
enqueuevalve turnon
// if we get stopped while starting up, then do the actual stop now
// that the enqueuevalve is back on.
if  stopping get
stop
public void stop   throws exception
stopping set true
// if stop() is called while being start()ed.. then we can't stop until we return to the start() method.
if  enqueuevalve ison
// let the peer know that we are disconnecting..
try
oneway disconnect
catch  exception ignore
taskrunner tr   null
try
enqueuevalve turnoff
if   disposed
started   false
disposed   true
if  taskrunner    null
tr   taskrunner
taskrunner   null
finally
stopping set false
enqueuevalve turnon
if  tr    null
tr shutdown 1000
/**
* @see org.apache.activemq.thread.task#iterate()
*/
public boolean iterate
final transportlistener tl
try
// disable changing the state variables while we are running...
enqueuevalve increment
tl   transportlistener
if   started    disposed    tl    null    stopping get
if  stopping get
// drain the queue it since folks could be blocked putting on to
// it and that would not allow the stop() method for finishing up.
getmessagequeue   clear
return false
catch  interruptedexception e
return false
finally
enqueuevalve decrement
linkedblockingqueue<object> mq   getmessagequeue
object command   mq poll
if  command    null
if  command    disconnect
tl onexception new transportdisposedioexception     peer tostring
else
tl oncommand command
return  mq isempty
else
return false
public void settransportlistener transportlistener commandlistener
try
try
enqueuevalve turnoff
this transportlistener   commandlistener
wakeup
finally
enqueuevalve turnon
catch  interruptedexception e
throw new runtimeexception e
private linkedblockingqueue<object> getmessagequeue
synchronized  lazyinitmutext
if  messagequeue    null
messagequeue   new linkedblockingqueue<object> this asyncqueuedepth
return messagequeue
public futureresponse asyncrequest object command  responsecallback responsecallback  throws ioexception
throw new assertionerror
public object request object command  throws ioexception
throw new assertionerror
public object request object command  int timeout  throws ioexception
throw new assertionerror
public transportlistener gettransportlistener
return transportlistener
public <t> t narrow class<t> target
if  target isassignablefrom getclass
return target cast this
return null
public boolean ismarshal
return marshal
public void setmarshal boolean marshal
this marshal   marshal
public boolean isnetwork
return network
public void setnetwork boolean network
this network   network
public string tostring
return location       id
public string getremoteaddress
if  peer    null
return peer tostring
return null
/**
* @return the async
*/
public boolean isasync
return async
/**
* @param async the async to set
*/
public void setasync boolean async
this async   async
/**
* @return the asyncqueuedepth
*/
public int getasyncqueuedepth
return asyncqueuedepth
/**
* @param asyncqueuedepth the asyncqueuedepth to set
*/
public void setasyncqueuedepth int asyncqueuedepth
this asyncqueuedepth   asyncqueuedepth
protected void wakeup
if  async
synchronized  lazyinitmutext
if  taskrunner    null
taskrunner   task_runner_factory createtaskrunner this      tostring
try
taskrunner wakeup
catch  interruptedexception e
thread currentthread   interrupt
public boolean isfaulttolerant
return false