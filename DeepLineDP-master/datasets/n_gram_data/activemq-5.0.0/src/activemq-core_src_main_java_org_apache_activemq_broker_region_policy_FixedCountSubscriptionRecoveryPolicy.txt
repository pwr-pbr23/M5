/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region policy
import java util arraylist
import java util list
import org apache activemq broker connectioncontext
import org apache activemq broker region messagereference
import org apache activemq broker region subscriptionrecovery
import org apache activemq broker region topic
import org apache activemq command activemqdestination
import org apache activemq command message
import org apache activemq filter destinationfilter
/**
* this implementation of {@link subscriptionrecoverypolicy} will keep a fixed
* count of last messages.
*
* @org.apache.xbean.xbean
* @version $revision$
*/
public class fixedcountsubscriptionrecoverypolicy implements subscriptionrecoverypolicy
private volatile messagereference messages
private int maximumsize   100
private int tail
public subscriptionrecoverypolicy copy
fixedcountsubscriptionrecoverypolicy rc   new fixedcountsubscriptionrecoverypolicy
rc setmaximumsize maximumsize
return rc
public synchronized boolean add connectioncontext context  messagereference node  throws exception
messages   node
if  tail >  messages length
tail   0
return true
public synchronized void recover connectioncontext context  topic topic  subscriptionrecovery sub  throws exception
// re-dispatch the last message seen.
int t   tail
// the buffer may not have rolled over yet..., start from the front
if  messages    null
t   0
// well the buffer is really empty then.
if  messages    null
return
// keep dispatching until t hit's tail again.
do
messagereference node   messages
sub addrecoveredmessage context  node
t
if  t >  messages length
t   0
while  t    tail
public void start   throws exception
messages   new messagereference
public void stop   throws exception
messages   null
public int getmaximumsize
return maximumsize
/**
* sets the maximum number of messages that this destination will hold
* around in ram
*/
public void setmaximumsize int maximumsize
this maximumsize   maximumsize
public synchronized message browse activemqdestination destination  throws exception
list<message> result   new arraylist<message>
destinationfilter filter   destinationfilter parsefilter destination
int t   tail
if  messages    null
t   0
if  messages    null
do
messagereference ref   messages
message message   ref getmessage
if  filter matches message getdestination
result add message
t
if  t >  messages length
t   0
while  t    tail
return result toarray new message