/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store amq
import java io ioexception
import java util iterator
import java util linkedhashmap
import java util map
import org apache activemq command journaltopicack
import org apache activemq command journaltransaction
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command transactionid
import org apache activemq command xatransactionid
import org apache activemq kaha impl async location
import org apache activemq store transactionrecoverylistener
import org apache activemq store transactionstore
/**
*/
public class amqtransactionstore implements transactionstore
map<transactionid  amqtx> inflighttransactions   new linkedhashmap<transactionid  amqtx>
map<transactionid  amqtx> preparedtransactions   new linkedhashmap<transactionid  amqtx>
private final amqpersistenceadapter peristenceadapter
private boolean doingrecover
public amqtransactionstore amqpersistenceadapter adapter
this peristenceadapter   adapter
/**
* @throws ioexception
* @see org.apache.activemq.store.transactionstore#prepare(transactionid)
*/
public void prepare transactionid txid  throws ioexception
amqtx tx   null
synchronized  inflighttransactions
tx   inflighttransactions remove txid
if  tx    null
return
peristenceadapter writecommand new journaltransaction journaltransaction xa_prepare  txid  false   true
synchronized  preparedtransactions
preparedtransactions put txid  tx
/**
* @throws ioexception
* @see org.apache.activemq.store.transactionstore#prepare(transactionid)
*/
public void replayprepare transactionid txid  throws ioexception
amqtx tx   null
synchronized  inflighttransactions
tx   inflighttransactions remove txid
if  tx    null
return
synchronized  preparedtransactions
preparedtransactions put txid  tx
public amqtx gettx transactionid txid  location location
amqtx tx   null
synchronized  inflighttransactions
tx   inflighttransactions get txid
if  tx    null
tx   new amqtx location
inflighttransactions put txid  tx
return tx
/**
* @throws xaexception
* @see org.apache.activemq.store.transactionstore#commit(org.apache.activemq.service.transaction)
*/
public void commit transactionid txid  boolean wasprepared  throws ioexception
amqtx tx
if  wasprepared
synchronized  preparedtransactions
tx   preparedtransactions remove txid
else
synchronized  inflighttransactions
tx   inflighttransactions remove txid
if  tx    null
return
if  txid isxatransaction
peristenceadapter writecommand new journaltransaction journaltransaction xa_commit  txid  wasprepared   true
else
peristenceadapter writecommand new journaltransaction journaltransaction local_commit  txid  wasprepared   true
/**
* @throws xaexception
* @see org.apache.activemq.store.transactionstore#commit(org.apache.activemq.service.transaction)
*/
public amqtx replaycommit transactionid txid  boolean wasprepared  throws ioexception
if  wasprepared
synchronized  preparedtransactions
return preparedtransactions remove txid
else
synchronized  inflighttransactions
return inflighttransactions remove txid
/**
* @throws ioexception
* @see org.apache.activemq.store.transactionstore#rollback(transactionid)
*/
public void rollback transactionid txid  throws ioexception
amqtx tx   null
synchronized  inflighttransactions
tx   inflighttransactions remove txid
if  tx    null
synchronized  preparedtransactions
tx   preparedtransactions remove txid
if  tx    null
if  txid isxatransaction
peristenceadapter writecommand new journaltransaction journaltransaction xa_rollback  txid  false   true
else
peristenceadapter writecommand new journaltransaction journaltransaction local_rollback  txid  false   true
/**
* @throws ioexception
* @see org.apache.activemq.store.transactionstore#rollback(transactionid)
*/
public void replayrollback transactionid txid  throws ioexception
boolean inflight   false
synchronized  inflighttransactions
inflight   inflighttransactions remove txid     null
if  inflight
synchronized  preparedtransactions
preparedtransactions remove txid
public void start   throws exception
public void stop   throws exception
public synchronized void recover transactionrecoverylistener listener  throws ioexception
// all the in-flight transactions get rolled back..
synchronized  inflighttransactions
inflighttransactions clear
this doingrecover   true
try
map<transactionid  amqtx> txs   null
synchronized  preparedtransactions
txs   new linkedhashmap<transactionid  amqtx> preparedtransactions
for  iterator<transactionid> iter   txs keyset   iterator    iter hasnext
object txid   iter next
amqtx tx   txs get txid
listener recover  xatransactionid txid  tx getmessages    tx getacks
finally
this doingrecover   false
/**
* @param message
* @throws ioexception
*/
void addmessage amqmessagestore store  message message  location location  throws ioexception
amqtx tx   gettx message gettransactionid    location
tx add store  message  location
/**
* @param ack
* @throws ioexception
*/
public void removemessage amqmessagestore store  messageack ack  location location  throws ioexception
amqtx tx   gettx ack gettransactionid    location
tx add store  ack
public void acknowledge amqtopicmessagestore store  journaltopicack ack  location location
amqtx tx   gettx ack gettransactionid    location
tx add store  ack
public location checkpoint   throws ioexception
// nothing really to checkpoint.. since, we don't
// checkpoint tx operations in to long term store until they are
// committed.
// but we keep track of the first location of an operation
// that was associated with an active tx. the journal can not
// roll over active tx records.
location rc   null
synchronized  inflighttransactions
for  iterator<amqtx> iter   inflighttransactions values   iterator    iter hasnext
amqtx tx   iter next
location location   tx getlocation
if  rc    null    rc compareto location  < 0
rc   location
synchronized  preparedtransactions
for  iterator<amqtx> iter   preparedtransactions values   iterator    iter hasnext
amqtx tx   iter next
location location   tx getlocation
if  rc    null    rc compareto location  < 0
rc   location
return rc
public boolean isdoingrecover
return doingrecover
/**
* @return the preparedtransactions
*/
public map<transactionid  amqtx> getpreparedtransactions
return this preparedtransactions
/**
* @param preparedtransactions the preparedtransactions to set
*/
public void setpreparedtransactions map<transactionid  amqtx> preparedtransactions
if  preparedtransactions    null
this preparedtransactions clear
this preparedtransactions putall preparedtransactions