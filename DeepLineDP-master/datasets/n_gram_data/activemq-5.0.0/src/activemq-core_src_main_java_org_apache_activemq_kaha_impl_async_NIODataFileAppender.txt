/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq kaha impl async
import java io ioexception
import java io randomaccessfile
import java nio bytebuffer
import java nio channels filechannel
/**
* an asyncdatafileappender that uses nio bytebuffers and file chanels to more
* efficently copy data to files.
*
* @version $revision: 1.1.1.1 $
*/
class niodatafileappender extends datafileappender
public niodatafileappender asyncdatamanager filemanager
super filemanager
/**
* the async processing loop that writes to the data files and does the
* force calls.
*
* since the file sync() call is the slowest of all the operations, this
* algorithm tries to 'batch' or group together several file sync() requests
* into a single file sync() call. the batching is accomplished attaching
* the same countdownlatch instance to every force request in a group.
*
*/
protected void processqueue
datafile datafile   null
randomaccessfile file   null
filechannel channel   null
try
bytebuffer header   bytebuffer allocatedirect asyncdatamanager item_head_space
bytebuffer footer   bytebuffer allocatedirect asyncdatamanager item_foot_space
bytebuffer buffer   bytebuffer allocatedirect maxwritebatchsize
// populate the static parts of the headers and footers..
header putint 0      size
header put  byte 0      type
header put reserved_space      reserved
header put asyncdatamanager item_head_sor
footer put asyncdatamanager item_head_eor
while  true
object o   null
// block till we get a command.
synchronized  enqueuemutex
while  true
if  shutdown
o   shutdown_command
break
if  nextwritebatch    null
o   nextwritebatch
nextwritebatch   null
break
enqueuemutex wait
enqueuemutex notify
if  o    shutdown_command
break
writebatch wb    writebatch o
if  datafile    wb datafile
if  file    null
datafile closerandomaccessfile file
datafile   wb datafile
file   datafile openrandomaccessfile true
channel   file getchannel
writecommand write   wb first
// write all the data.
// only need to seek to first location.. all others
// are in sequence.
file seek write location getoffset
//
// is it just 1 big write?
if  wb size    write location getsize
header clear
header putint write location getsize
header put write location gettype
header clear
transfer header  channel
bytebuffer source   bytebuffer wrap write data getdata    write data getoffset
write data getlength
transfer source  channel
footer clear
transfer footer  channel
else
// combine the smaller writes into 1 big buffer
while  write    null
header clear
header putint write location getsize
header put write location gettype
header clear
copy header  buffer
assert  header hasremaining
bytebuffer source   bytebuffer wrap write data getdata    write data getoffset
write data getlength
copy source  buffer
assert  source hasremaining
footer clear
copy footer  buffer
assert  footer hasremaining
write    writecommand write getnext
// fully write out the buffer..
buffer flip
transfer buffer  channel
buffer clear
file getchannel   force false
writecommand lastwrite    writecommand wb first gettailnode
datamanager setlastappendlocation lastwrite location
// signal any waiting threads that the write is on disk.
if  wb latch    null
wb latch countdown
// now that the data is on disk, remove the writes from the in
// flight
// cache.
write   wb first
while  write    null
if   write sync
inflightwrites remove new writekey write location
write    writecommand write getnext
catch  ioexception e
synchronized  enqueuemutex
firstasyncexception   e
catch  interruptedexception e
finally
try
if  file    null
datafile closerandomaccessfile file
catch  ioexception e
shutdowndone countdown
/**
* copy the bytes in header to the channel.
*
* @param header - source of data
* @param channel - destination where the data will be written.
* @throws ioexception
*/
private void transfer bytebuffer header  filechannel channel  throws ioexception
while  header hasremaining
channel write header
private int copy bytebuffer src  bytebuffer dest
int rc   math min dest remaining    src remaining
if  rc > 0
// adjust our limit so that we don't overflow the dest buffer.
int limit   src limit
src limit src position     rc
dest put src
// restore the limit.
src limit limit
return rc