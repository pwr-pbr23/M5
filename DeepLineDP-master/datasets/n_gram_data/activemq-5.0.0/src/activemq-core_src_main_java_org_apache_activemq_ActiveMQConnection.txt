/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq
import java io ioexception
import java io inputstream
import java io outputstream
import java net uri
import java net urisyntaxexception
import java util hashmap
import java util iterator
import java util map
import java util concurrent concurrenthashmap
import java util concurrent copyonwritearraylist
import java util concurrent countdownlatch
import java util concurrent linkedblockingqueue
import java util concurrent threadfactory
import java util concurrent threadpoolexecutor
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomicinteger
import javax jms connection
import javax jms connectionconsumer
import javax jms connectionmetadata
import javax jms deliverymode
import javax jms destination
import javax jms exceptionlistener
import javax jms illegalstateexception
import javax jms jmsexception
import javax jms queue
import javax jms queueconnection
import javax jms queuesession
import javax jms serversessionpool
import javax jms session
import javax jms topic
import javax jms topicconnection
import javax jms topicsession
import javax jms xaconnection
import org apache activemq blob blobtransferpolicy
import org apache activemq command activemqdestination
import org apache activemq command activemqmessage
import org apache activemq command activemqtempdestination
import org apache activemq command activemqtempqueue
import org apache activemq command activemqtemptopic
import org apache activemq command brokerinfo
import org apache activemq command command
import org apache activemq command commandtypes
import org apache activemq command connectioncontrol
import org apache activemq command connectionerror
import org apache activemq command connectionid
import org apache activemq command connectioninfo
import org apache activemq command consumercontrol
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command controlcommand
import org apache activemq command destinationinfo
import org apache activemq command exceptionresponse
import org apache activemq command message
import org apache activemq command messagedispatch
import org apache activemq command messageid
import org apache activemq command producerack
import org apache activemq command producerid
import org apache activemq command removesubscriptioninfo
import org apache activemq command response
import org apache activemq command sessionid
import org apache activemq command shutdowninfo
import org apache activemq command wireformatinfo
import org apache activemq management jmsconnectionstatsimpl
import org apache activemq management jmsstatsimpl
import org apache activemq management statscapable
import org apache activemq management statsimpl
import org apache activemq state commandvisitoradapter
import org apache activemq thread taskrunnerfactory
import org apache activemq transport transport
import org apache activemq transport transportlistener
import org apache activemq util idgenerator
import org apache activemq util introspectionsupport
import org apache activemq util jmsexceptionsupport
import org apache activemq util longsequencegenerator
import org apache activemq util servicesupport
import org apache commons logging log
import org apache commons logging logfactory
public class activemqconnection implements connection  topicconnection  queueconnection  statscapable  closeable  streamconnection  transportlistener
public static final string default_user   activemqconnectionfactory default_user
public static final string default_password   activemqconnectionfactory default_password
public static final string default_broker_url   activemqconnectionfactory default_broker_url
private static final log log   logfactory getlog activemqconnection class
private static final idgenerator connection_id_generator   new idgenerator
public final concurrenthashmap<activemqtempdestination  activemqtempdestination> activetempdestinations   new concurrenthashmap<activemqtempdestination  activemqtempdestination>
protected boolean dispatchasync
protected boolean alwayssessionasync   true
private taskrunnerfactory sessiontaskrunner   new taskrunnerfactory    threadpriorities inbound_client_session  false  1000
private final threadpoolexecutor asyncconnectionthread
// connection state variables
private final connectioninfo info
private exceptionlistener exceptionlistener
private boolean clientidset
private boolean isconnectioninfosenttobroker
private boolean userspecifiedclientid
// configuration options variables
private activemqprefetchpolicy prefetchpolicy   new activemqprefetchpolicy
private blobtransferpolicy blobtransferpolicy
private redeliverypolicy redeliverypolicy
private messagetransformer transformer
private boolean disabletimestampsbydefault
private boolean optimizedmessagedispatch   true
private boolean copymessageonsend   true
private boolean usecompression
private boolean objectmessageserializationdefered
private boolean useasyncsend
private boolean optimizeacknowledge
private boolean nestedmapandlistenabled   true
private boolean useretroactiveconsumer
private boolean exclusiveconsumer
private boolean alwayssyncsend
private int closetimeout   15000
private boolean watchtopicadvisories   true
private long warnaboutunstartedconnectiontimeout   500l
private final transport transport
private final idgenerator clientidgenerator
private final jmsstatsimpl factorystats
private final jmsconnectionstatsimpl stats
private final atomicboolean started   new atomicboolean false
private final atomicboolean closing   new atomicboolean false
private final atomicboolean closed   new atomicboolean false
private final atomicboolean transportfailed   new atomicboolean false
private final copyonwritearraylist<activemqsession> sessions   new copyonwritearraylist<activemqsession>
private final copyonwritearraylist<activemqconnectionconsumer> connectionconsumers   new copyonwritearraylist<activemqconnectionconsumer>
private final copyonwritearraylist<activemqinputstream> inputstreams   new copyonwritearraylist<activemqinputstream>
private final copyonwritearraylist<activemqoutputstream> outputstreams   new copyonwritearraylist<activemqoutputstream>
private final copyonwritearraylist<transportlistener> transportlisteners   new copyonwritearraylist<transportlistener>
// maps consumerids to activemqconsumer objects
private final concurrenthashmap<consumerid  activemqdispatcher> dispatchers   new concurrenthashmap<consumerid  activemqdispatcher>
private final concurrenthashmap<producerid  activemqmessageproducer> producers   new concurrenthashmap<producerid  activemqmessageproducer>
private final longsequencegenerator sessionidgenerator   new longsequencegenerator
private final sessionid connectionsessionid
private final longsequencegenerator consumeridgenerator   new longsequencegenerator
private final longsequencegenerator produceridgenerator   new longsequencegenerator
private final longsequencegenerator tempdestinationidgenerator   new longsequencegenerator
private final longsequencegenerator localtransactionidgenerator   new longsequencegenerator
private advisoryconsumer advisoryconsumer
private final countdownlatch brokerinforeceived   new countdownlatch 1
private brokerinfo brokerinfo
private ioexception firstfailureerror
private int producerwindowsize   activemqconnectionfactory default_producer_window_size
// assume that protocol is the latest. change to the actual protocol
// version when a wireformatinfo is received.
private atomicinteger protocolversion   new atomicinteger commandtypes protocol_version
private long timecreated
private connectionaudit connectionaudit   new connectionaudit
/**
* construct an <code>activemqconnection</code>
*
* @param transport
* @param factorystats
* @throws exception
*/
protected activemqconnection final transport transport  idgenerator clientidgenerator  jmsstatsimpl factorystats  throws exception
this transport   transport
this clientidgenerator   clientidgenerator
this factorystats   factorystats
// configure a single threaded executor who's core thread can timeout if
// idle
asyncconnectionthread   new threadpoolexecutor 1  1  5  timeunit seconds  new linkedblockingqueue<runnable>    new threadfactory
public thread newthread runnable r
thread thread   new thread r      transport
thread setdaemon true
return thread
// asyncconnectionthread.allowcorethreadtimeout(true);
this info   new connectioninfo new connectionid connection_id_generator generateid
this info setmanageable true
this connectionsessionid   new sessionid info getconnectionid     1
this transport settransportlistener this
this stats   new jmsconnectionstatsimpl sessions  this instanceof xaconnection
this factorystats addconnection this
this timecreated   system currenttimemillis
this connectionaudit setcheckforduplicates transport isfaulttolerant
protected void setusername string username
this info setusername username
protected void setpassword string password
this info setpassword password
/**
* a static helper method to create a new connection
*
* @return an activemqconnection
* @throws jmsexception
*/
public static activemqconnection makeconnection   throws jmsexception
activemqconnectionfactory factory   new activemqconnectionfactory
return  activemqconnection factory createconnection
/**
* a static helper method to create a new connection
*
* @param uri
* @return and activemqconnection
* @throws jmsexception
*/
public static activemqconnection makeconnection string uri  throws jmsexception  urisyntaxexception
activemqconnectionfactory factory   new activemqconnectionfactory uri
return  activemqconnection factory createconnection
/**
* a static helper method to create a new connection
*
* @param user
* @param password
* @param uri
* @return an activemqconnection
* @throws jmsexception
*/
public static activemqconnection makeconnection string user  string password  string uri  throws jmsexception  urisyntaxexception
activemqconnectionfactory factory   new activemqconnectionfactory user  password  new uri uri
return  activemqconnection factory createconnection
/**
* @return a number unique for this connection
*/
public jmsconnectionstatsimpl getconnectionstats
return stats
/**
* creates a <code>session</code> object.
*
* @param transacted indicates whether the session is transacted
* @param acknowledgemode indicates whether the consumer or the client will
*                acknowledge any messages it receives; ignored if the
*                session is transacted. legal values are
*                <code>session.auto_acknowledge</code>,
*                <code>session.client_acknowledge</code>, and
*                <code>session.dups_ok_acknowledge</code>.
* @return a newly created session
* @throws jmsexception if the <code>connection</code> object fails to
*                 create a session due to some internal error or lack of
*                 support for the specific transaction and acknowledgement
*                 mode.
* @see session#auto_acknowledge
* @see session#client_acknowledge
* @see session#dups_ok_acknowledge
* @since 1.1
*/
public session createsession boolean transacted  int acknowledgemode  throws jmsexception
checkclosedorfailed
ensureconnectioninfosent
return new activemqsession this  getnextsessionid    transacted ? session session_transacted    acknowledgemode    session session_transacted
? session auto_acknowledge   acknowledgemode   dispatchasync  alwayssessionasync
/**
* @return sessionid
*/
protected sessionid getnextsessionid
return new sessionid info getconnectionid    sessionidgenerator getnextsequenceid
/**
* gets the client identifier for this connection.
* <p>
* this value is specific to the jms provider. it is either preconfigured by
* an administrator in a <code> connectionfactory</code> object or assigned
* dynamically by the application by calling the <code>setclientid</code>
* method.
*
* @return the unique client identifier
* @throws jmsexception if the jms provider fails to return the client id
*                 for this connection due to some internal error.
*/
public string getclientid   throws jmsexception
checkclosedorfailed
return this info getclientid
/**
* sets the client identifier for this connection.
* <p>
* the preferred way to assign a jms client's client identifier is for it to
* be configured in a client-specific <code>connectionfactory</code>
* object and transparently assigned to the <code>connection</code> object
* it creates.
* <p>
* alternatively, a client can set a connection's client identifier using a
* provider-specific value. the facility to set a connection's client
* identifier explicitly is not a mechanism for overriding the identifier
* that has been administratively configured. it is provided for the case
* where no administratively specified identifier exists. if one does exist,
* an attempt to change it by setting it must throw an
* <code>illegalstateexception</code>. if a client sets the client
* identifier explicitly, it must do so immediately after it creates the
* connection and before any other action on the connection is taken. after
* this point, setting the client identifier is a programming error that
* should throw an <code>illegalstateexception</code>.
* <p>
* the purpose of the client identifier is to associate a connection and its
* objects with a state maintained on behalf of the client by a provider.
* the only such state identified by the jms api is that required to support
* durable subscriptions.
* <p>
* if another connection with the same <code>clientid</code> is already
* running when this method is called, the jms provider should detect the
* duplicate id and throw an <code>invalidclientidexception</code>.
*
* @param newclientid the unique client identifier
* @throws jmsexception if the jms provider fails to set the client id for
*                 this connection due to some internal error.
* @throws javax.jms.invalidclientidexception if the jms client specifies an
*                 invalid or duplicate client id.
* @throws javax.jms.illegalstateexception if the jms client attempts to set
*                 a connection's client id at the wrong time or when it has
*                 been administratively configured.
*/
public void setclientid string newclientid  throws jmsexception
checkclosedorfailed
if  this clientidset
throw new illegalstateexception
if  this isconnectioninfosenttobroker
throw new illegalstateexception
this info setclientid newclientid
this userspecifiedclientid   true
ensureconnectioninfosent
/**
* sets the default client id that the connection will use if explicitly not
* set with the setclientid() call.
*/
public void setdefaultclientid string clientid  throws jmsexception
this info setclientid clientid
this userspecifiedclientid   true
/**
* gets the metadata for this connection.
*
* @return the connection metadata
* @throws jmsexception if the jms provider fails to get the connection
*                 metadata for this connection.
* @see javax.jms.connectionmetadata
*/
public connectionmetadata getmetadata   throws jmsexception
checkclosedorfailed
return activemqconnectionmetadata instance
/**
* gets the <code>exceptionlistener</code> object for this connection. not
* every <code>connection</code> has an <code>exceptionlistener</code>
* associated with it.
*
* @return the <code>exceptionlistener</code> for this connection, or
*         null. if no <code>exceptionlistener</code> is associated with
*         this connection.
* @throws jmsexception if the jms provider fails to get the
*                 <code>exceptionlistener</code> for this connection.
* @see javax.jms.connection#setexceptionlistener(exceptionlistener)
*/
public exceptionlistener getexceptionlistener   throws jmsexception
checkclosedorfailed
return this exceptionlistener
/**
* sets an exception listener for this connection.
* <p>
* if a jms provider detects a serious problem with a connection, it informs
* the connection's <code> exceptionlistener</code>, if one has been
* registered. it does this by calling the listener's <code>onexception
* </code>
* method, passing it a <code>jmsexception</code> object describing the
* problem.
* <p>
* an exception listener allows a client to be notified of a problem
* asynchronously. some connections only consume messages, so they would
* have no other way to learn their connection has failed.
* <p>
* a connection serializes execution of its <code>exceptionlistener</code>.
* <p>
* a jms provider should attempt to resolve connection problems itself
* before it notifies the client of them.
*
* @param listener the exception listener
* @throws jmsexception if the jms provider fails to set the exception
*                 listener for this connection.
*/
public void setexceptionlistener exceptionlistener listener  throws jmsexception
checkclosedorfailed
this exceptionlistener   listener
/**
* starts (or restarts) a connection's delivery of incoming messages. a call
* to <code>start</code> on a connection that has already been started is
* ignored.
*
* @throws jmsexception if the jms provider fails to start message delivery
*                 due to some internal error.
* @see javax.jms.connection#stop()
*/
public void start   throws jmsexception
checkclosedorfailed
ensureconnectioninfosent
if  started compareandset false  true
for  iterator<activemqsession> i   sessions iterator    i hasnext
activemqsession session   i next
session start
/**
* temporarily stops a connection's delivery of incoming messages. delivery
* can be restarted using the connection's <code>start</code> method. when
* the connection is stopped, delivery to all the connection's message
* consumers is inhibited: synchronous receives block, and messages are not
* delivered to message listeners.
* <p>
* this call blocks until receives and/or message listeners in progress have
* completed.
* <p>
* stopping a connection has no effect on its ability to send messages. a
* call to <code>stop</code> on a connection that has already been stopped
* is ignored.
* <p>
* a call to <code>stop</code> must not return until delivery of messages
* has paused. this means that a client can rely on the fact that none of
* its message listeners will be called and that all threads of control
* waiting for <code>receive</code> calls to return will not return with a
* message until the connection is restarted. the receive timers for a
* stopped connection continue to advance, so receives may time out while
* the connection is stopped.
* <p>
* if message listeners are running when <code>stop</code> is invoked, the
* <code>stop</code> call must wait until all of them have returned before
* it may return. while these message listeners are completing, they must
* have the full services of the connection available to them.
*
* @throws jmsexception if the jms provider fails to stop message delivery
*                 due to some internal error.
* @see javax.jms.connection#start()
*/
public void stop   throws jmsexception
checkclosedorfailed
if  started compareandset true  false
for  iterator<activemqsession> i   sessions iterator    i hasnext
activemqsession s   i next
s stop
/**
* closes the connection.
* <p>
* since a provider typically allocates significant resources outside the
* jvm on behalf of a connection, clients should close these resources when
* they are not needed. relying on garbage collection to eventually reclaim
* these resources may not be timely enough.
* <p>
* there is no need to close the sessions, producers, and consumers of a
* closed connection.
* <p>
* closing a connection causes all temporary destinations to be deleted.
* <p>
* when this method is invoked, it should not return until message
* processing has been shut down in an orderly fashion. this means that all
* message listeners that may have been running have returned, and that all
* pending receives have returned. a close terminates all pending message
* receives on the connection's sessions' consumers. the receives may return
* with a message or with null, depending on whether there was a message
* available at the time of the close. if one or more of the connection's
* sessions' message listeners is processing a message at the time when
* connection <code>close</code> is invoked, all the facilities of the
* connection and its sessions must remain available to those listeners
* until they return control to the jms provider.
* <p>
* closing a connection causes any of its sessions' transactions in progress
* to be rolled back. in the case where a session's work is coordinated by
* an external transaction manager, a session's <code>commit</code> and
* <code> rollback</code> methods are not used and the result of a closed
* session's work is determined later by the transaction manager. closing a
* connection does not force an acknowledgment of client-acknowledged
* sessions.
* <p>
* invoking the <code>acknowledge</code> method of a received message from
* a closed connection's session must throw an
* <code>illegalstateexception</code>. closing a closed connection must
* not throw an exception.
*
* @throws jmsexception if the jms provider fails to close the connection
*                 due to some internal error. for example, a failure to
*                 release resources or to close a socket connection can
*                 cause this exception to be thrown.
*/
public void close   throws jmsexception
checkclosed
try
// if we were running, lets stop first.
stop
synchronized  this
if   closed get
closing set true
if  advisoryconsumer    null
advisoryconsumer dispose
advisoryconsumer   null
for  iterator<activemqsession> i   this sessions iterator    i hasnext
activemqsession s   i next
s dispose
for  iterator<activemqconnectionconsumer> i   this connectionconsumers iterator    i hasnext
activemqconnectionconsumer c   i next
c dispose
for  iterator<activemqinputstream> i   this inputstreams iterator    i hasnext
activemqinputstream c   i next
c dispose
for  iterator<activemqoutputstream> i   this outputstreams iterator    i hasnext
activemqoutputstream c   i next
c dispose
if  isconnectioninfosenttobroker
// if we announced ourselfs to the broker.. try to let
// the broker
// know that the connection is being shutdown.
syncsendpacket info createremovecommand    closetimeout
asyncsendpacket new shutdowninfo
servicesupport dispose this transport
started set false
// todo if we move the taskrunnerfactory to the connection
// factory
// then we may need to call
// factory.onconnectionclose(this);
sessiontaskrunner shutdown
if  asyncconnectionthread    null
asyncconnectionthread shutdown
closed set true
closing set false
finally
factorystats removeconnection this
/**
* tells the broker to terminate its vm. this can be used to cleanly
* terminate a broker running in a standalone java process. server must have
* property enable.vm.shutdown=true defined to allow this to work.
*/
// todo : org.apache.activemq.message.brokeradmincommand not yet
// implemented.
/*
* public void terminatebrokervm() throws jmsexception { brokeradmincommand
* command = new brokeradmincommand();
* command.setcommand(brokeradmincommand.shutdown_server_vm);
* asyncsendpacket(command); }
*/
/**
* create a durable connection consumer for this connection (optional
* operation). this is an expert facility not used by regular jms clients.
*
* @param topic topic to access
* @param subscriptionname durable subscription name
* @param messageselector only messages with properties matching the message
*                selector expression are delivered. a value of null or an
*                empty string indicates that there is no message selector
*                for the message consumer.
* @param sessionpool the server session pool to associate with this durable
*                connection consumer
* @param maxmessages the maximum number of messages that can be assigned to
*                a server session at one time
* @return the durable connection consumer
* @throws jmsexception if the <code>connection</code> object fails to
*                 create a connection consumer due to some internal error
*                 or invalid arguments for <code>sessionpool</code> and
*                 <code>messageselector</code>.
* @throws javax.jms.invaliddestinationexception if an invalid destination
*                 is specified.
* @throws javax.jms.invalidselectorexception if the message selector is
*                 invalid.
* @see javax.jms.connectionconsumer
* @since 1.1
*/
public connectionconsumer createdurableconnectionconsumer topic topic  string subscriptionname  string messageselector  serversessionpool sessionpool  int maxmessages
throws jmsexception
return this createdurableconnectionconsumer topic  subscriptionname  messageselector  sessionpool  maxmessages  false
/**
* create a durable connection consumer for this connection (optional
* operation). this is an expert facility not used by regular jms clients.
*
* @param topic topic to access
* @param subscriptionname durable subscription name
* @param messageselector only messages with properties matching the message
*                selector expression are delivered. a value of null or an
*                empty string indicates that there is no message selector
*                for the message consumer.
* @param sessionpool the server session pool to associate with this durable
*                connection consumer
* @param maxmessages the maximum number of messages that can be assigned to
*                a server session at one time
* @param nolocal set true if you want to filter out messages published
*                locally
* @return the durable connection consumer
* @throws jmsexception if the <code>connection</code> object fails to
*                 create a connection consumer due to some internal error
*                 or invalid arguments for <code>sessionpool</code> and
*                 <code>messageselector</code>.
* @throws javax.jms.invaliddestinationexception if an invalid destination
*                 is specified.
* @throws javax.jms.invalidselectorexception if the message selector is
*                 invalid.
* @see javax.jms.connectionconsumer
* @since 1.1
*/
public connectionconsumer createdurableconnectionconsumer topic topic  string subscriptionname  string messageselector  serversessionpool sessionpool  int maxmessages
boolean nolocal  throws jmsexception
checkclosedorfailed
ensureconnectioninfosent
sessionid sessionid   new sessionid info getconnectionid     1
consumerinfo info   new consumerinfo new consumerid sessionid  consumeridgenerator getnextsequenceid
info setdestination activemqmessagetransformation transformdestination topic
info setsubscriptionname subscriptionname
info setselector messageselector
info setprefetchsize maxmessages
info setdispatchasync dispatchasync
// allows the options on the destination to configure the consumerinfo
if  info getdestination   getoptions      null
map<string  string> options   new hashmap<string  string> info getdestination   getoptions
introspectionsupport setproperties this info  options
return new activemqconnectionconsumer this  sessionpool  info
// properties
// -------------------------------------------------------------------------
/**
* returns true if this connection has been started
*
* @return true if this connection is started
*/
public boolean isstarted
return started get
/**
* returns true if the connection is closed
*/
public boolean isclosed
return closed get
/**
* returns true if the connection is in the process of being closed
*/
public boolean isclosing
return closing get
/**
* returns true if the underlying transport has failed
*/
public boolean istransportfailed
return transportfailed get
/**
* @return returns the prefetchpolicy.
*/
public activemqprefetchpolicy getprefetchpolicy
return prefetchpolicy
/**
* sets the <a
* href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
* policy</a> for consumers created by this connection.
*/
public void setprefetchpolicy activemqprefetchpolicy prefetchpolicy
this prefetchpolicy   prefetchpolicy
/**
*/
public transport gettransportchannel
return transport
/**
* @return returns the clientid of the connection, forcing one to be
*         generated if one has not yet been configured.
*/
public string getinitializedclientid   throws jmsexception
ensureconnectioninfosent
return info getclientid
/**
* @return returns the timestampsdisablebydefault.
*/
public boolean isdisabletimestampsbydefault
return disabletimestampsbydefault
/**
* sets whether or not timestamps on messages should be disabled or not. if
* you disable them it adds a small performance boost.
*/
public void setdisabletimestampsbydefault boolean timestampsdisablebydefault
this disabletimestampsbydefault   timestampsdisablebydefault
/**
* @return returns the dispatchoptimizedmessage.
*/
public boolean isoptimizedmessagedispatch
return optimizedmessagedispatch
/**
* if this flag is set then an larger prefetch limit is used - only
* applicable for durable topic subscribers.
*/
public void setoptimizedmessagedispatch boolean dispatchoptimizedmessage
this optimizedmessagedispatch   dispatchoptimizedmessage
/**
* @return returns the closetimeout.
*/
public int getclosetimeout
return closetimeout
/**
* sets the timeout before a close is considered complete. normally a
* close() on a connection waits for confirmation from the broker; this
* allows that operation to timeout to save the client hanging if there is
* no broker
*/
public void setclosetimeout int closetimeout
this closetimeout   closetimeout
/**
* @return connectioninfo
*/
public connectioninfo getconnectioninfo
return this info
public boolean isuseretroactiveconsumer
return useretroactiveconsumer
/**
* sets whether or not retroactive consumers are enabled. retroactive
* consumers allow non-durable topic subscribers to receive old messages
* that were published before the non-durable subscriber started.
*/
public void setuseretroactiveconsumer boolean useretroactiveconsumer
this useretroactiveconsumer   useretroactiveconsumer
public boolean isnestedmapandlistenabled
return nestedmapandlistenabled
/**
* enables/disables whether or not message properties and mapmessage entries
* support <a
* href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">nested
* structures</a> of map and list objects
*/
public void setnestedmapandlistenabled boolean structuredmapsenabled
this nestedmapandlistenabled   structuredmapsenabled
public boolean isexclusiveconsumer
return exclusiveconsumer
/**
* enables or disables whether or not queue consumers should be exclusive or
* not for example to preserve ordering when not using <a
* href="http://activemq.apache.org/message-groups.html">message groups</a>
*
* @param exclusiveconsumer
*/
public void setexclusiveconsumer boolean exclusiveconsumer
this exclusiveconsumer   exclusiveconsumer
/**
* adds a transport listener so that a client can be notified of events in
* the underlying transport
*/
public void addtransportlistener transportlistener transportlistener
transportlisteners add transportlistener
public void removetransportlistener transportlistener transportlistener
transportlisteners remove transportlistener
public taskrunnerfactory getsessiontaskrunner
return sessiontaskrunner
public void setsessiontaskrunner taskrunnerfactory sessiontaskrunner
this sessiontaskrunner   sessiontaskrunner
public messagetransformer gettransformer
return transformer
/**
* sets the transformer used to transform messages before they are sent on
* to the jms bus or when they are received from the bus but before they are
* delivered to the jms client
*/
public void settransformer messagetransformer transformer
this transformer   transformer
/**
* @return the statsenabled
*/
public boolean isstatsenabled
return this stats isenabled
/**
* @param statsenabled the statsenabled to set
*/
public void setstatsenabled boolean statsenabled
this stats setenabled statsenabled
// implementation methods
// -------------------------------------------------------------------------
/**
* used internally for adding sessions to the connection
*
* @param session
* @throws jmsexception
* @throws jmsexception
*/
protected void addsession activemqsession session  throws jmsexception
this sessions add session
if  sessions size   > 1    session istransacted
optimizedmessagedispatch   false
/**
* used interanlly for removing sessions from a connection
*
* @param session
*/
protected void removesession activemqsession session
this sessions remove session
this removedispatcher session
/**
* add a connectionconsumer
*
* @param connectionconsumer
* @throws jmsexception
*/
protected void addconnectionconsumer activemqconnectionconsumer connectionconsumer  throws jmsexception
this connectionconsumers add connectionconsumer
/**
* remove a connectionconsumer
*
* @param connectionconsumer
*/
protected void removeconnectionconsumer activemqconnectionconsumer connectionconsumer
this connectionconsumers remove connectionconsumer
this removedispatcher connectionconsumer
/**
* creates a <code>topicsession</code> object.
*
* @param transacted indicates whether the session is transacted
* @param acknowledgemode indicates whether the consumer or the client will
*                acknowledge any messages it receives; ignored if the
*                session is transacted. legal values are
*                <code>session.auto_acknowledge</code>,
*                <code>session.client_acknowledge</code>, and
*                <code>session.dups_ok_acknowledge</code>.
* @return a newly created topic session
* @throws jmsexception if the <code>topicconnection</code> object fails
*                 to create a session due to some internal error or lack of
*                 support for the specific transaction and acknowledgement
*                 mode.
* @see session#auto_acknowledge
* @see session#client_acknowledge
* @see session#dups_ok_acknowledge
*/
public topicsession createtopicsession boolean transacted  int acknowledgemode  throws jmsexception
return new activemqtopicsession  activemqsession createsession transacted  acknowledgemode
/**
* creates a connection consumer for this connection (optional operation).
* this is an expert facility not used by regular jms clients.
*
* @param topic the topic to access
* @param messageselector only messages with properties matching the message
*                selector expression are delivered. a value of null or an
*                empty string indicates that there is no message selector
*                for the message consumer.
* @param sessionpool the server session pool to associate with this
*                connection consumer
* @param maxmessages the maximum number of messages that can be assigned to
*                a server session at one time
* @return the connection consumer
* @throws jmsexception if the <code>topicconnection</code> object fails
*                 to create a connection consumer due to some internal
*                 error or invalid arguments for <code>sessionpool</code>
*                 and <code>messageselector</code>.
* @throws javax.jms.invaliddestinationexception if an invalid topic is
*                 specified.
* @throws javax.jms.invalidselectorexception if the message selector is
*                 invalid.
* @see javax.jms.connectionconsumer
*/
public connectionconsumer createconnectionconsumer topic topic  string messageselector  serversessionpool sessionpool  int maxmessages  throws jmsexception
return createconnectionconsumer topic  messageselector  sessionpool  maxmessages  false
/**
* creates a connection consumer for this connection (optional operation).
* this is an expert facility not used by regular jms clients.
*
* @param queue the queue to access
* @param messageselector only messages with properties matching the message
*                selector expression are delivered. a value of null or an
*                empty string indicates that there is no message selector
*                for the message consumer.
* @param sessionpool the server session pool to associate with this
*                connection consumer
* @param maxmessages the maximum number of messages that can be assigned to
*                a server session at one time
* @return the connection consumer
* @throws jmsexception if the <code>queueconnection</code> object fails
*                 to create a connection consumer due to some internal
*                 error or invalid arguments for <code>sessionpool</code>
*                 and <code>messageselector</code>.
* @throws javax.jms.invaliddestinationexception if an invalid queue is
*                 specified.
* @throws javax.jms.invalidselectorexception if the message selector is
*                 invalid.
* @see javax.jms.connectionconsumer
*/
public connectionconsumer createconnectionconsumer queue queue  string messageselector  serversessionpool sessionpool  int maxmessages  throws jmsexception
return createconnectionconsumer queue  messageselector  sessionpool  maxmessages  false
/**
* creates a connection consumer for this connection (optional operation).
* this is an expert facility not used by regular jms clients.
*
* @param destination the destination to access
* @param messageselector only messages with properties matching the message
*                selector expression are delivered. a value of null or an
*                empty string indicates that there is no message selector
*                for the message consumer.
* @param sessionpool the server session pool to associate with this
*                connection consumer
* @param maxmessages the maximum number of messages that can be assigned to
*                a server session at one time
* @return the connection consumer
* @throws jmsexception if the <code>connection</code> object fails to
*                 create a connection consumer due to some internal error
*                 or invalid arguments for <code>sessionpool</code> and
*                 <code>messageselector</code>.
* @throws javax.jms.invaliddestinationexception if an invalid destination
*                 is specified.
* @throws javax.jms.invalidselectorexception if the message selector is
*                 invalid.
* @see javax.jms.connectionconsumer
* @since 1.1
*/
public connectionconsumer createconnectionconsumer destination destination  string messageselector  serversessionpool sessionpool  int maxmessages  throws jmsexception
return createconnectionconsumer destination  messageselector  sessionpool  maxmessages  false
public connectionconsumer createconnectionconsumer destination destination  string messageselector  serversessionpool sessionpool  int maxmessages  boolean nolocal
throws jmsexception
checkclosedorfailed
ensureconnectioninfosent
consumerid consumerid   createconsumerid
consumerinfo info   new consumerinfo consumerid
info setdestination activemqmessagetransformation transformdestination destination
info setselector messageselector
info setprefetchsize maxmessages
info setnolocal nolocal
info setdispatchasync dispatchasync
// allows the options on the destination to configure the consumerinfo
if  info getdestination   getoptions      null
map<string  string> options   new hashmap<string  string> info getdestination   getoptions
introspectionsupport setproperties info  options
return new activemqconnectionconsumer this  sessionpool  info
/**
* @return
*/
private consumerid createconsumerid
return new consumerid connectionsessionid  consumeridgenerator getnextsequenceid
/**
* @return
*/
private producerid createproducerid
return new producerid connectionsessionid  produceridgenerator getnextsequenceid
/**
* creates a <code>queuesession</code> object.
*
* @param transacted indicates whether the session is transacted
* @param acknowledgemode indicates whether the consumer or the client will
*                acknowledge any messages it receives; ignored if the
*                session is transacted. legal values are
*                <code>session.auto_acknowledge</code>,
*                <code>session.client_acknowledge</code>, and
*                <code>session.dups_ok_acknowledge</code>.
* @return a newly created queue session
* @throws jmsexception if the <code>queueconnection</code> object fails
*                 to create a session due to some internal error or lack of
*                 support for the specific transaction and acknowledgement
*                 mode.
* @see session#auto_acknowledge
* @see session#client_acknowledge
* @see session#dups_ok_acknowledge
*/
public queuesession createqueuesession boolean transacted  int acknowledgemode  throws jmsexception
return new activemqqueuesession  activemqsession createsession transacted  acknowledgemode
/**
* ensures that the clientid was manually specified and not auto-generated.
* if the clientid was not specified this method will throw an exception.
* this method is used to ensure that the clientid + durablesubscriber name
* are used correctly.
*
* @throws jmsexception
*/
public void checkclientidwasmanuallyspecified   throws jmsexception
if   userspecifiedclientid
throw new jmsexception
/**
* send a packet through the connection - for internal use only
*
* @param command
* @throws jmsexception
*/
public void asyncsendpacket command command  throws jmsexception
if  isclosed
throw new connectionclosedexception
else
try
this transport oneway command
catch  ioexception e
throw jmsexceptionsupport create e
/**
* send a packet through a connection - for internal use only
*
* @param command
* @return
* @throws jmsexception
*/
public response syncsendpacket command command  throws jmsexception
if  isclosed
throw new connectionclosedexception
else
try
response response    response this transport request command
if  response isexception
exceptionresponse er    exceptionresponse response
if  er getexception   instanceof jmsexception
throw  jmsexception er getexception
else
throw jmsexceptionsupport create er getexception
return response
catch  ioexception e
throw jmsexceptionsupport create e
/**
* send a packet through a connection - for internal use only
*
* @param command
* @return
* @throws jmsexception
*/
public response syncsendpacket command command  int timeout  throws jmsexception
if  isclosed
throw new connectionclosedexception
else
try
response response    response this transport request command  timeout
if  response    null    response isexception
exceptionresponse er    exceptionresponse response
if  er getexception   instanceof jmsexception
throw  jmsexception er getexception
else
throw jmsexceptionsupport create er getexception
return response
catch  ioexception e
throw jmsexceptionsupport create e
/**
* @return statistics for this connection
*/
public statsimpl getstats
return stats
/**
* simply throws an exception if the connection is already closed or the
* transport has failed
*
* @throws jmsexception
*/
protected synchronized void checkclosedorfailed   throws jmsexception
checkclosed
if  transportfailed get
throw new connectionfailedexception firstfailureerror
/**
* simply throws an exception if the connection is already closed
*
* @throws jmsexception
*/
protected synchronized void checkclosed   throws jmsexception
if  closed get
throw new connectionclosedexception
/**
* send the connectioninfo to the broker
*
* @throws jmsexception
*/
protected synchronized void ensureconnectioninfosent   throws jmsexception
// can we skip sending the connectioninfo packet??
if  isconnectioninfosenttobroker    closed get
return
if  info getclientid      null    info getclientid   trim   length      0
info setclientid clientidgenerator generateid
syncsendpacket info
this isconnectioninfosenttobroker   true
// add a temp destination advisory consumer so that
// we know what the valid temporary destinations are on the
// broker without having to do an rpc to the broker.
consumerid consumerid   new consumerid new sessionid info getconnectionid     1   consumeridgenerator getnextsequenceid
if  watchtopicadvisories
advisoryconsumer   new advisoryconsumer this  consumerid
public synchronized boolean iswatchtopicadvisories
return watchtopicadvisories
public synchronized void setwatchtopicadvisories boolean watchtopicadvisories
this watchtopicadvisories   watchtopicadvisories
/**
* @return returns the useasyncsend.
*/
public boolean isuseasyncsend
return useasyncsend
/**
* forces the use of <a
* href="http://activemq.apache.org/async-sends.html">async sends</a> which
* adds a massive performance boost; but means that the send() method will
* return immediately whether the message has been sent or not which could
* lead to message loss.
*/
public void setuseasyncsend boolean useasyncsend
this useasyncsend   useasyncsend
/**
* @return true if always sync send messages
*/
public boolean isalwayssyncsend
return this alwayssyncsend
/**
* set true if always require messages to be sync sent
*
* @param alwayssyncsend
*/
public void setalwayssyncsend boolean alwayssyncsend
this alwayssyncsend   alwayssyncsend
/**
* cleans up this connection so that it's state is as if the connection was
* just created. this allows the resource adapter to clean up a connection
* so that it can be reused without having to close and recreate the
* connection.
*/
public void cleanup   throws jmsexception
if  advisoryconsumer    null
advisoryconsumer dispose
advisoryconsumer   null
for  iterator<activemqsession> i   this sessions iterator    i hasnext
activemqsession s   i next
s dispose
for  iterator<activemqconnectionconsumer> i   this connectionconsumers iterator    i hasnext
activemqconnectionconsumer c   i next
c dispose
for  iterator<activemqinputstream> i   this inputstreams iterator    i hasnext
activemqinputstream c   i next
c dispose
for  iterator<activemqoutputstream> i   this outputstreams iterator    i hasnext
activemqoutputstream c   i next
c dispose
if  isconnectioninfosenttobroker
if   transportfailed get       closing get
asyncsendpacket info createremovecommand
isconnectioninfosenttobroker   false
if  userspecifiedclientid
info setclientid null
userspecifiedclientid   false
clientidset   false
started set false
/**
* changes the associated username/password that is associated with this
* connection. if the connection has been used, you must called cleanup()
* before calling this method.
*
* @throws illegalstateexception if the connection is in used.
*/
public void changeuserinfo string username  string password  throws jmsexception
if  isconnectioninfosenttobroker
throw new illegalstateexception
this info setusername username
this info setpassword password
/**
* @return returns the resourcemanagerid.
* @throws jmsexception
*/
public string getresourcemanagerid   throws jmsexception
waitforbrokerinfo
if  brokerinfo    null
throw new jmsexception
return brokerinfo getbrokerid   getvalue
/**
* returns the broker name if one is available or null if one is not
* available yet.
*/
public string getbrokername
try
brokerinforeceived await 5  timeunit seconds
if  brokerinfo    null
return null
return brokerinfo getbrokername
catch  interruptedexception e
thread currentthread   interrupt
return null
/**
* returns the broker information if it is available or null if it is not
* available yet.
*/
public brokerinfo getbrokerinfo
return brokerinfo
/**
* @return returns the redeliverypolicy.
* @throws jmsexception
*/
public redeliverypolicy getredeliverypolicy   throws jmsexception
return redeliverypolicy
/**
* sets the redelivery policy to be used when messages are rolled back
*/
public void setredeliverypolicy redeliverypolicy redeliverypolicy
this redeliverypolicy   redeliverypolicy
public blobtransferpolicy getblobtransferpolicy
if  blobtransferpolicy    null
blobtransferpolicy   createblobtransferpolicy
return blobtransferpolicy
/**
* sets the policy used to describe how out-of-band blobs (binary large
* objects) are transferred from producers to brokers to consumers
*/
public void setblobtransferpolicy blobtransferpolicy blobtransferpolicy
this blobtransferpolicy   blobtransferpolicy
/**
* @return returns the alwayssessionasync.
*/
public boolean isalwayssessionasync
return alwayssessionasync
/**
* if this flag is set then a separate thread is not used for dispatching
* messages for each session in the connection. however, a separate thread
* is always used if there is more than one session, or the session isn't in
* auto acknowledge or duplicates ok mode
*/
public void setalwayssessionasync boolean alwayssessionasync
this alwayssessionasync   alwayssessionasync
/**
* @return returns the optimizeacknowledge.
*/
public boolean isoptimizeacknowledge
return optimizeacknowledge
/**
* enables an optimised acknowledgement mode where messages are acknowledged
* in batches rather than individually
*
* @param optimizeacknowledge the optimizeacknowledge to set.
*/
public void setoptimizeacknowledge boolean optimizeacknowledge
this optimizeacknowledge   optimizeacknowledge
public long getwarnaboutunstartedconnectiontimeout
return warnaboutunstartedconnectiontimeout
/**
* enables the timeout from a connection creation to when a warning is
* generated if the connection is not properly started via {@link #start()}
* and a message is received by a consumer. it is a very common gotcha to
* forget to <a
* href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
* the connection</a> so this option makes the default case to create a
* warning if the user forgets. to disable the warning just set the value to <
* 0 (say -1).
*/
public void setwarnaboutunstartedconnectiontimeout long warnaboutunstartedconnectiontimeout
this warnaboutunstartedconnectiontimeout   warnaboutunstartedconnectiontimeout
/**
* returns the time this connection was created
*/
public long gettimecreated
return timecreated
private void waitforbrokerinfo   throws jmsexception
try
brokerinforeceived await
catch  interruptedexception e
thread currentthread   interrupt
throw jmsexceptionsupport create e
// package protected so that it can be used in unit tests
transport gettransport
return transport
public void addproducer producerid producerid  activemqmessageproducer producer
producers put producerid  producer
public void removeproducer producerid producerid
producers remove producerid
public void adddispatcher consumerid consumerid  activemqdispatcher dispatcher
dispatchers put consumerid  dispatcher
public void removedispatcher consumerid consumerid
dispatchers remove consumerid
/**
* @param o - the command to consume
*/
public void oncommand final object o
final command command    command o
if   closed get      command    null
try
command visit new commandvisitoradapter
@override
public response processmessagedispatch messagedispatch md  throws exception
activemqdispatcher dispatcher   dispatchers get md getconsumerid
if  dispatcher    null
// copy in case a embedded broker is dispatching via
// vm://
// md.getmessage() == null to signal end of queue
// browse.
message msg   md getmessage
if  msg    null
msg   msg copy
msg setreadonlybody true
msg setreadonlyproperties true
msg setredeliverycounter md getredeliverycounter
msg setconnection activemqconnection this
md setmessage msg
dispatcher dispatch md
return null
@override
public response processproducerack producerack pa  throws exception
if  pa    null    pa getproducerid      null
activemqmessageproducer producer   producers get pa getproducerid
if  producer    null
producer onproducerack pa
return null
@override
public response processbrokerinfo brokerinfo info  throws exception
brokerinfo   info
brokerinforeceived countdown
optimizeacknowledge     brokerinfo isfaulttolerantconfiguration
getblobtransferpolicy   setbrokeruploadurl info getbrokeruploadurl
return null
@override
public response processconnectionerror final connectionerror error  throws exception
asyncconnectionthread execute new runnable
public void run
onasyncexception error getexception
return null
@override
public response processcontrolcommand controlcommand command  throws exception
oncontrolcommand command
return null
@override
public response processconnectioncontrol connectioncontrol control  throws exception
onconnectioncontrol  connectioncontrol command
return null
@override
public response processconsumercontrol consumercontrol control  throws exception
onconsumercontrol  consumercontrol command
return null
@override
public response processwireformat wireformatinfo info  throws exception
onwireformatinfo  wireformatinfo command
return null
catch  exception e
onasyncexception e
for  iterator<transportlistener> iter   transportlisteners iterator    iter hasnext
transportlistener listener   iter next
listener oncommand command
protected void onwireformatinfo wireformatinfo info
protocolversion set info getversion
/**
* used for handling async exceptions
*
* @param error
*/
public void onasyncexception throwable error
if   closed get       closing get
if  this exceptionlistener    null
if    error instanceof jmsexception
error   jmsexceptionsupport create error
final jmsexception e    jmsexception error
asyncconnectionthread execute new runnable
public void run
activemqconnection this exceptionlistener onexception e
else
log warn     error  error
public void onexception final ioexception error
onasyncexception error
if   closing get       closed get
asyncconnectionthread execute new runnable
public void run
transportfailed error
servicesupport dispose activemqconnection this transport
brokerinforeceived countdown
for  iterator<transportlistener> iter   transportlisteners
iterator    iter hasnext
transportlistener listener   iter next
listener onexception error
public void transportinterupted
for  iterator<activemqsession> i   this sessions iterator    i hasnext
activemqsession s   i next
s clearmessagesinprogress
for  iterator<transportlistener> iter   transportlisteners iterator    iter hasnext
transportlistener listener   iter next
listener transportinterupted
public void transportresumed
for  iterator<transportlistener> iter   transportlisteners iterator    iter hasnext
transportlistener listener   iter next
listener transportresumed
for  iterator<activemqsession> i   this sessions iterator    i hasnext
activemqsession s   i next
s deliveracks
/**
* create the destinationinfo object for the temporary destination.
*
* @param topic - if its true topic, else queue.
* @return destinationinfo
* @throws jmsexception
*/
protected activemqtempdestination createtempdestination boolean topic  throws jmsexception
// check if destination info is of temporary type.
activemqtempdestination dest
if  topic
dest   new activemqtemptopic info getconnectionid    tempdestinationidgenerator getnextsequenceid
else
dest   new activemqtempqueue info getconnectionid    tempdestinationidgenerator getnextsequenceid
destinationinfo info   new destinationinfo
info setconnectionid this info getconnectionid
info setoperationtype destinationinfo add_operation_type
info setdestination dest
syncsendpacket info
dest setconnection this
activetempdestinations put dest  dest
return dest
/**
* @param destination
* @throws jmsexception
*/
public void deletetempdestination activemqtempdestination destination  throws jmsexception
checkclosedorfailed
for  iterator<activemqsession> i   this sessions iterator    i hasnext
activemqsession s   i next
if  s isinuse destination
throw new jmsexception
activetempdestinations remove destination
destinationinfo info   new destinationinfo
info setconnectionid this info getconnectionid
info setoperationtype destinationinfo remove_operation_type
info setdestination destination
info settimeout 0
syncsendpacket info
public boolean isdeleted activemqdestination dest
// if we are not watching the advisories.. then
// we will assume that the temp destination does exist.
if  advisoryconsumer    null
return false
return  activetempdestinations contains dest
public boolean iscopymessageonsend
return copymessageonsend
public longsequencegenerator getlocaltransactionidgenerator
return localtransactionidgenerator
public boolean isusecompression
return usecompression
/**
* enables the use of compression of the message bodies
*/
public void setusecompression boolean usecompression
this usecompression   usecompression
public void destroydestination activemqdestination destination  throws jmsexception
checkclosedorfailed
ensureconnectioninfosent
destinationinfo info   new destinationinfo
info setconnectionid this info getconnectionid
info setoperationtype destinationinfo remove_operation_type
info setdestination destination
info settimeout 0
syncsendpacket info
public boolean isdispatchasync
return dispatchasync
/**
* enables or disables the default setting of whether or not consumers have
* their messages <a
* href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
* synchronously or asynchronously by the broker</a>. for non-durable
* topics for example we typically dispatch synchronously by default to
* minimize context switches which boost performance. however sometimes its
* better to go slower to ensure that a single blocked consumer socket does
* not block delivery to other consumers.
*
* @param asyncdispatch if true then consumers created on this connection
*                will default to having their messages dispatched
*                asynchronously. the default value is false.
*/
public void setdispatchasync boolean asyncdispatch
this dispatchasync   asyncdispatch
public boolean isobjectmessageserializationdefered
return objectmessageserializationdefered
/**
* when an object is set on an objectmessage, the jms spec requires the
* object to be serialized by that set method. enabling this flag causes the
* object to not get serialized. the object may subsequently get serialized
* if the message needs to be sent over a socket or stored to disk.
*/
public void setobjectmessageserializationdefered boolean objectmessageserializationdefered
this objectmessageserializationdefered   objectmessageserializationdefered
public inputstream createinputstream destination dest  throws jmsexception
return createinputstream dest  null
public inputstream createinputstream destination dest  string messageselector  throws jmsexception
return createinputstream dest  messageselector  false
public inputstream createinputstream destination dest  string messageselector  boolean nolocal  throws jmsexception
return docreateinputstream dest  messageselector  nolocal  null
public inputstream createdurableinputstream topic dest  string name  throws jmsexception
return createinputstream dest  null  false
public inputstream createdurableinputstream topic dest  string name  string messageselector  throws jmsexception
return createdurableinputstream dest  name  messageselector  false
public inputstream createdurableinputstream topic dest  string name  string messageselector  boolean nolocal  throws jmsexception
return docreateinputstream dest  messageselector  nolocal  name
private inputstream docreateinputstream destination dest  string messageselector  boolean nolocal  string subname  throws jmsexception
checkclosedorfailed
ensureconnectioninfosent
return new activemqinputstream this  createconsumerid    activemqdestination transform dest   messageselector  nolocal  subname  prefetchpolicy getinputstreamprefetch
/**
* creates a persistent output stream; individual messages will be written
* to disk/database by the broker
*/
public outputstream createoutputstream destination dest  throws jmsexception
return createoutputstream dest  null  activemqmessage default_delivery_mode  activemqmessage default_priority  activemqmessage default_time_to_live
/**
* creates a non persistent output stream; messages will not be written to
* disk
*/
public outputstream createnonpersistentoutputstream destination dest  throws jmsexception
return createoutputstream dest  null  deliverymode non_persistent  activemqmessage default_priority  activemqmessage default_time_to_live
/**
* creates an output stream allowing full control over the delivery mode,
* the priority and time to live of the messages and the properties added to
* messages on the stream.
*
* @param streamproperties defines a map of key-value pairs where the keys
*                are strings and the values are primitive values (numbers
*                and strings) which are appended to the messages similarly
*                to using the
*                {@link javax.jms.message#setobjectproperty(string, object)}
*                method
*/
public outputstream createoutputstream destination dest  map<string  object> streamproperties  int deliverymode  int priority  long timetolive  throws jmsexception
checkclosedorfailed
ensureconnectioninfosent
return new activemqoutputstream this  createproducerid    activemqdestination transform dest   streamproperties  deliverymode  priority  timetolive
/**
* unsubscribes a durable subscription that has been created by a client.
* <p>
* this method deletes the state being maintained on behalf of the
* subscriber by its provider.
* <p>
* it is erroneous for a client to delete a durable subscription while there
* is an active <code>messageconsumer </code> or
* <code>topicsubscriber</code> for the subscription, or while a consumed
* message is part of a pending transaction or has not been acknowledged in
* the session.
*
* @param name the name used to identify this subscription
* @throws jmsexception if the session fails to unsubscribe to the durable
*                 subscription due to some internal error.
* @throws invaliddestinationexception if an invalid subscription name is
*                 specified.
* @since 1.1
*/
public void unsubscribe string name  throws jmsexception
checkclosedorfailed
removesubscriptioninfo rsi   new removesubscriptioninfo
rsi setconnectionid getconnectioninfo   getconnectionid
rsi setsubscriptionname name
rsi setclientid getconnectioninfo   getclientid
syncsendpacket rsi
/**
* internal send method optimized: - it does not copy the message - it can
* only handle activemq messages. - you can specify if the send is async or
* sync - does not allow you to send /w a transaction.
*/
void send activemqdestination destination  activemqmessage msg  messageid messageid  int deliverymode  int priority  long timetolive  boolean async  throws jmsexception
checkclosedorfailed
if  destination istemporary      isdeleted destination
throw new jmsexception     destination
msg setjmsdestination destination
msg setjmsdeliverymode deliverymode
long expiration   0l
if   isdisabletimestampsbydefault
long timestamp   system currenttimemillis
msg setjmstimestamp timestamp
if  timetolive > 0
expiration   timetolive   timestamp
msg setjmsexpiration expiration
msg setjmspriority priority
msg setjmsredelivered false
msg setmessageid messageid
msg onsend
msg setproducerid msg getmessageid   getproducerid
if  log isdebugenabled
log debug     msg
if  async
asyncsendpacket msg
else
syncsendpacket msg
public void addoutputstream activemqoutputstream stream
outputstreams add stream
public void removeoutputstream activemqoutputstream stream
outputstreams remove stream
public void addinputstream activemqinputstream stream
inputstreams add stream
public void removeinputstream activemqinputstream stream
inputstreams remove stream
protected void oncontrolcommand controlcommand command
string text   command getcommand
if  text    null
if  text equals
log info
system exit 0
protected void onconnectioncontrol connectioncontrol command
if  command isfaulttolerant
this optimizeacknowledge   false
for  iterator<activemqsession> i   this sessions iterator    i hasnext
activemqsession s   i next
s setoptimizeacknowledge false
protected void onconsumercontrol consumercontrol command
if  command isclose
for  iterator<activemqsession> i   this sessions iterator    i hasnext
activemqsession s   i next
s close command getconsumerid
else
for  iterator<activemqsession> i   this sessions iterator    i hasnext
activemqsession s   i next
s setprefetchsize command getconsumerid    command getprefetch
protected void transportfailed ioexception error
transportfailed set true
if  firstfailureerror    null
firstfailureerror   error
if   closed get       closing get
try
cleanup
catch  jmsexception e
log warn    e
/**
* should a jms message be copied to a new jms message object as part of the
* send() method in jms. this is enabled by default to be compliant with the
* jms specification. you can disable it if you do not mutate jms messages
* after they are sent for a performance boost
*/
public void setcopymessageonsend boolean copymessageonsend
this copymessageonsend   copymessageonsend
public string tostring
return     info getconnectionid         info getclientid         started get
protected blobtransferpolicy createblobtransferpolicy
return new blobtransferpolicy
public int getprotocolversion
return protocolversion get
public int getproducerwindowsize
return producerwindowsize
public void setproducerwindowsize int producerwindowsize
this producerwindowsize   producerwindowsize
protected void removedispatcher activemqdispatcher dispatcher
connectionaudit removedispatcher dispatcher
protected boolean isduplicate activemqdispatcher dispatcher  message message
return connectionaudit isduplicate dispatcher  message
protected void rollbackduplicate activemqdispatcher dispatcher  message message
connectionaudit rollbackduplicate dispatcher  message