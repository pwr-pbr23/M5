/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport reliable
import java io ioexception
import java util sortedset
import java util treeset
import org apache activemq command command
import org apache activemq command replaycommand
import org apache activemq command response
import org apache activemq openwire commandidcomparator
import org apache activemq transport futureresponse
import org apache activemq transport responsecorrelator
import org apache activemq transport transport
import org apache activemq transport udp udptransport
import org apache commons logging log
import org apache commons logging logfactory
/**
* this interceptor deals with out of order commands together with being able to
* handle dropped commands and the re-requesting dropped commands.
*
* @version $revision$
*/
public class reliabletransport extends responsecorrelator
private static final log log   logfactory getlog reliabletransport class
private replaystrategy replaystrategy
private sortedset<command> commands   new treeset<command> new commandidcomparator
private int expectedcounter   1
private int replaybuffercommandcount   50
private int requesttimeout   2000
private replaybuffer replaybuffer
private replayer replayer
private udptransport udptransport
public reliabletransport transport next  replaystrategy replaystrategy
super next
this replaystrategy   replaystrategy
public reliabletransport transport next  udptransport udptransport  throws ioexception
super next  udptransport getsequencegenerator
this udptransport   udptransport
this replayer   udptransport createreplayer
/**
* requests that a range of commands be replayed
*/
public void requestreplay int fromcommandid  int tocommandid
replaycommand replay   new replaycommand
replay setfirstnaknumber fromcommandid
replay setlastnaknumber tocommandid
try
oneway replay
catch  ioexception e
gettransportlistener   onexception e
public object request object o  throws ioexception
final command command    command o
futureresponse response   asyncrequest command  null
while  true
response result   response getresult requesttimeout
if  result    null
return result
onmissingresponse command  response
public object request object o  int timeout  throws ioexception
final command command    command o
futureresponse response   asyncrequest command  null
while  timeout > 0
int time   timeout
if  timeout > requesttimeout
time   requesttimeout
response result   response getresult time
if  result    null
return result
onmissingresponse command  response
timeout    time
return response getresult 0
public void oncommand object o
command command    command o
// lets pass wireformat through
if  command iswireformatinfo
super oncommand command
return
else if  command getdatastructuretype      replaycommand data_structure_type
replaycommands  replaycommand command
return
int actualcounter   command getcommandid
boolean valid   expectedcounter    actualcounter
if   valid
synchronized  commands
int nextcounter   actualcounter
boolean empty   commands isempty
if   empty
command nextavailable   commands first
nextcounter   nextavailable getcommandid
try
boolean keep   replaystrategy ondroppedpackets this  expectedcounter  actualcounter  nextcounter
if  keep
// lets add it to the list for later on
if  log isdebugenabled
log debug     command
commands add command
catch  ioexception e
onexception e
if   empty
// lets see if the first item in the set is the next
// expected
command   commands first
valid   expectedcounter    command getcommandid
if  valid
commands remove command
while  valid
// we've got a valid header so increment counter
replaystrategy onreceivedpacket this  expectedcounter
expectedcounter
super oncommand command
synchronized  commands
// we could have more commands left
valid    commands isempty
if  valid
// lets see if the first item in the set is the next
// expected
command   commands first
valid   expectedcounter    command getcommandid
if  valid
commands remove command
public int getbufferedcommandcount
synchronized  commands
return commands size
public int getexpectedcounter
return expectedcounter
/**
* this property should never really be set - but is mutable primarily for
* test cases
*/
public void setexpectedcounter int expectedcounter
this expectedcounter   expectedcounter
public int getrequesttimeout
return requesttimeout
/**
* sets the default timeout of requests before starting to request commands
* are replayed
*/
public void setrequesttimeout int requesttimeout
this requesttimeout   requesttimeout
public replaystrategy getreplaystrategy
return replaystrategy
public replaybuffer getreplaybuffer
if  replaybuffer    null
replaybuffer   createreplaybuffer
return replaybuffer
public void setreplaybuffer replaybuffer replaybuffer
this replaybuffer   replaybuffer
public int getreplaybuffercommandcount
return replaybuffercommandcount
/**
* sets the default number of commands which are buffered
*/
public void setreplaybuffercommandcount int replaybuffersize
this replaybuffercommandcount   replaybuffersize
public void setreplaystrategy replaystrategy replaystrategy
this replaystrategy   replaystrategy
public replayer getreplayer
return replayer
public void setreplayer replayer replayer
this replayer   replayer
public string tostring
return next tostring
public void start   throws exception
if  udptransport    null
udptransport setreplaybuffer getreplaybuffer
if  replaystrategy    null
throw new illegalargumentexception
super start
/**
* lets attempt to replay the request as a command may have disappeared
*/
protected void onmissingresponse command command  futureresponse response
log debug     this       command
int commandid   command getcommandid
requestreplay commandid  commandid
protected replaybuffer createreplaybuffer
return new defaultreplaybuffer getreplaybuffercommandcount
protected void replaycommands replaycommand command
try
if  replayer    null
onexception new ioexception
if  log isdebugenabled
log debug     command
getreplaybuffer   replaymessages command getfirstnaknumber    command getlastnaknumber    replayer
// todo we could proactively remove ack'd stuff from the replay
// buffer
// if we only have a single client talking to us
catch  ioexception e
onexception e