/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq kaha impl async
import java io file
import java io ioexception
import java io randomaccessfile
import java nio channels filelock
import org apache activemq util bytesequence
/**
* use to reliably store fixed sized state data. it stores the state in record
* that is versioned and repeated twice in the file so that a failure in the
* middle of the write of the first or second record do not not result in an
* unknown state.
*
* @version $revision: 1.1 $
*/
public final class controlfile
private static final boolean disable_file_lock     equals system getproperty
private final file file
/** the file that holds the control data. */
private final randomaccessfile randomaccessfile
private final int maxrecordsize
private final int firstrecordstart
private final int secondrecordstart
private final int firstrecordend
private final int secondrecordend
private long version
private filelock lock
private boolean disposed
public controlfile file file  int recordsize  throws ioexception
this file   file
this maxrecordsize   recordsize   4
// calculate where the records start and end.
this firstrecordstart   8
this secondrecordstart   8   maxrecordsize   8   8
this firstrecordend   firstrecordstart maxrecordsize
this secondrecordend   secondrecordstart maxrecordsize
randomaccessfile   new randomaccessfile file
/**
* locks the control file.
*
* @throws ioexception
*/
public void lock   throws ioexception
if  disable_file_lock
return
if  lock    null
lock   randomaccessfile getchannel   trylock
if  lock    null
throw new ioexception     file
/**
* un locks the control file.
*
* @throws ioexception
*/
public void unlock   throws ioexception
if  disable_file_lock
return
if  lock    null
lock release
lock   null
public void dispose
if  disposed
return
disposed   true
try
unlock
catch  ioexception ignore
try
randomaccessfile close
catch  ioexception ignore
public synchronized bytesequence load   throws ioexception
long l   randomaccessfile length
if  l < maxrecordsize
return null
randomaccessfile seek firstrecordstart 8
long v1   randomaccessfile readlong
randomaccessfile seek firstrecordend
long v1check   randomaccessfile readlong
randomaccessfile seek secondrecordstart   8
long v2   randomaccessfile readlong
randomaccessfile seek secondrecordend
long v2check   randomaccessfile readlong
byte data   null
if  v2    v2check
version   v2
randomaccessfile seek secondrecordstart
int size   randomaccessfile readint
data   new byte
randomaccessfile readfully data
else if  v1    v1check
version   v1
randomaccessfile seek firstrecordstart
int size   randomaccessfile readint
data   new byte
randomaccessfile readfully data
else
// bummer.. both checks are screwed. we don't know
// if any of the two buffer are ok. this should
// only happen is data got corrupted.
throw new ioexception
return new bytesequence data  0  data length
public void store bytesequence data  boolean sync  throws ioexception
version
randomaccessfile setlength  maxrecordsize   2    32
randomaccessfile seek 0
// write the first copy of the control data.
randomaccessfile writelong version
randomaccessfile writeint data getlength
randomaccessfile write data getdata
randomaccessfile seek firstrecordend
randomaccessfile writelong version
// write the second copy of the control data.
randomaccessfile writelong version
randomaccessfile writeint data getlength
randomaccessfile write data getdata
randomaccessfile seek secondrecordend
randomaccessfile writelong version
if  sync
randomaccessfile getfd   sync