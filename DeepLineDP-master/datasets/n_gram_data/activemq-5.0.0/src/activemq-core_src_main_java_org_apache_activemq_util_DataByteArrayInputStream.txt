/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq util
import java io datainput
import java io ioexception
import java io inputstream
import java io utfdataformatexception
/**
* optimized bytearrayinputstream that can be used more than once
*
* @version $revision: 1.1.1.1 $
*/
public final class databytearrayinputstream extends inputstream implements datainput
private byte buf
private int pos
private int offset
/**
* creates a <code>storebytearrayinputstream</code>.
*
* @param buf the input buffer.
*/
public databytearrayinputstream byte buf
this buf   buf
this pos   0
this offset   0
/**
* creates a <code>storebytearrayinputstream</code>.
*
* @param sequence the input buffer.
*/
public databytearrayinputstream bytesequence sequence
this buf   sequence getdata
this offset   sequence getoffset
this pos    this offset
/**
* creates <code>wirebytearrayinputstream</code> with a minmalist byte
* array
*/
public databytearrayinputstream
this new byte
/**
* @return the size
*/
public int size
return pos   offset
/**
* @return the underlying data array
*/
public byte getrawdata
return buf
/**
* reset the <code>storebytearrayinputstream</code> to use an new byte
* array
*
* @param newbuff
*/
public void restart byte newbuff
buf   newbuff
pos   0
/**
* reset the <code>storebytearrayinputstream</code> to use an new
* bytesequence
*
* @param sequence
*/
public void restart bytesequence sequence
this buf   sequence getdata
this pos   sequence getoffset
/**
* re-start the input stream - reusing the current buffer
*
* @param size
*/
public void restart int size
if  buf    null    buf length < size
buf   new byte
restart buf
/**
* reads the next byte of data from this input stream. the value byte is
* returned as an <code>int</code> in the range <code>0</code> to
* <code>255</code>. if no byte is available because the end of the
* stream has been reached, the value <code>-1</code> is returned.
* <p>
* this <code>read</code> method cannot block.
*
* @return the next byte of data, or <code>-1</code> if the end of the
*         stream has been reached.
*/
public int read
return  pos < buf length  ?  buf   0xff     1
/**
* reads up to <code>len</code> bytes of data into an array of bytes from
* this input stream.
*
* @param b the buffer into which the data is read.
* @param off the start offset of the data.
* @param len the maximum number of bytes read.
* @return the total number of bytes read into the buffer, or
*         <code>-1</code> if there is no more data because the end of the
*         stream has been reached.
*/
public int read byte b  int off  int len
if  b    null
throw new nullpointerexception
if  pos >  buf length
return  1
if  pos   len > buf length
len   buf length   pos
if  len <  0
return 0
system arraycopy buf  pos  b  off  len
pos    len
return len
/**
* @return the number of bytes that can be read from the input stream
*         without blocking.
*/
public int available
return buf length   pos
public void readfully byte b
read b  0  b length
public void readfully byte b  int off  int len
read b  off  len
public int skipbytes int n
if  pos   n > buf length
n   buf length   pos
if  n < 0
return 0
pos    n
return n
public boolean readboolean
return read      0
public byte readbyte
return  byte read
public int readunsignedbyte
return read
public short readshort
int ch1   read
int ch2   read
return  short   ch1 << 8     ch2 << 0
public int readunsignedshort
int ch1   read
int ch2   read
return  ch1 << 8     ch2 << 0
public char readchar
int ch1   read
int ch2   read
return  char   ch1 << 8     ch2 << 0
public int readint
int ch1   read
int ch2   read
int ch3   read
int ch4   read
return  ch1 << 24     ch2 << 16     ch3 << 8     ch4 << 0
public long readlong
long rc     long buf << 56      long  buf   255  << 48      long  buf   255  << 40      long  buf   255  << 32
return rc     long  buf   255  << 24      buf   255  << 16      buf   255  << 8      buf   255  << 0
public float readfloat   throws ioexception
return float intbitstofloat readint
public double readdouble   throws ioexception
return double longbitstodouble readlong
public string readline
int start   pos
while  pos < buf length
int c   read
if  c
break
if  c
c   read
if  c         c     1
pos
break
return new string buf  start  pos
public string readutf   throws ioexception
int length   readunsignedshort
char characters   new char
int c
int c2
int c3
int count   0
int total   pos   length
while  pos < total
c    int buf   0xff
if  c > 127
break
pos
characters    char c
while  pos < total
c    int buf   0xff
switch  c >> 4
case 0
case 1
case 2
case 3
case 4
case 5
case 6
case 7
pos
characters    char c
break
case 12
case 13
pos    2
if  pos > length
throw new utfdataformatexception
c2    int buf
if   c2   0xc0     0x80
throw new utfdataformatexception
characters    char    c   0x1f  << 6     c2   0x3f
break
case 14
pos    3
if  pos > length
throw new utfdataformatexception
c2    int buf
c3    int buf
if    c2   0xc0     0x80       c3   0xc0     0x80
throw new utfdataformatexception
characters    char    c   0x0f  << 12      c2   0x3f  << 6      c3   0x3f  << 0
break
default
throw new utfdataformatexception
return new string characters  0  count