/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store
import java io ioexception
import javax jms jmsexception
import org apache activemq broker connectioncontext
import org apache activemq command messageid
import org apache activemq command subscriptioninfo
/**
* a messagestore for durable topic subscriptions
*
* @version $revision: 1.4 $
*/
public interface topicmessagestore extends messagestore
/**
* stores the last acknowledged messgeid for the given subscription so that
* we can recover and commence dispatching messages from the last checkpoint
*
* @param context
* @param clientid
* @param subscriptionname
* @param messageid
* @param subscriptionpersistentid
* @throws ioexception
*/
void acknowledge connectioncontext context  string clientid  string subscriptionname  messageid messageid  throws ioexception
/**
* @param clientid
* @param subscriptionname
* @param sub
* @throws ioexception
* @throws jmsexception
*/
void deletesubscription string clientid  string subscriptionname  throws ioexception
/**
* for the new subscription find the last acknowledged message id and then
* find any new messages since then and dispatch them to the subscription.
* <p/> e.g. if we dispatched some messages to a new durable topic
* subscriber, then went down before acknowledging any messages, we need to
* know the correct point from which to recover from.
*
* @param clientid
* @param subscriptionname
* @param listener
* @param subscription
* @throws exception
*/
void recoversubscription string clientid  string subscriptionname  messagerecoverylistener listener  throws exception
/**
* for an active subscription - retrieve messages from the store for the
* subscriber after the lastmessageid messageid <p/>
*
* @param clientid
* @param subscriptionname
* @param maxreturned
* @param listener
* @throws exception
*/
void recovernextmessages string clientid  string subscriptionname  int maxreturned  messagerecoverylistener listener  throws exception
/**
* a hint to the store to reset any batching state for a durable subsriber
*
* @param clientid
* @param subscriptionname
*/
void resetbatching string clientid  string subscriptionname
/**
* get the number of messages ready to deliver from the store to a durable
* subscriber
*
* @param clientid
* @param subscribername
* @return the outstanding message count
* @throws ioexception
*/
int getmessagecount string clientid  string subscribername  throws ioexception
/**
* finds the subscriber entry for the given consumer info
*
* @param clientid
* @param subscriptionname
* @return the subscriptioninfo
* @throws ioexception
*/
subscriptioninfo lookupsubscription string clientid  string subscriptionname  throws ioexception
/**
* lists all the durable subscriptions for a given destination.
*
* @return an array subscriptioninfos
* @throws ioexception
*/
subscriptioninfo getallsubscriptions   throws ioexception
/**
* inserts the subscriber info due to a subscription change <p/> if this is
* a new subscription and the retroactive is false, then the last message
* sent to the topic should be set as the last message acknowledged by they
* new subscription. otherwise, if retroactive is true, then create the
* subscription without it having an acknowledged message so that on
* recovery, all message recorded for the topic get replayed.
*
* @param clientid
* @param subscriptionname
* @param selector
* @param retroactive
* @throws ioexception
*/
void addsubsciption subscriptioninfo subscriptioninfo  boolean retroactive  throws ioexception