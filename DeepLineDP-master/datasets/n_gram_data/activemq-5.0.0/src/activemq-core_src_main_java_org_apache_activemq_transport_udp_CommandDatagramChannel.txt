/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport udp
import java io datainputstream
import java io dataoutputstream
import java io ioexception
import java net socketaddress
import java nio bytebuffer
import java nio channels datagramchannel
import org apache activemq command command
import org apache activemq command endpoint
import org apache activemq command lastpartialcommand
import org apache activemq command partialcommand
import org apache activemq openwire booleanstream
import org apache activemq openwire openwireformat
import org apache activemq transport reliable replaybuffer
import org apache activemq util bytearrayinputstream
import org apache activemq util bytearrayoutputstream
import org apache commons logging log
import org apache commons logging logfactory
/**
* a strategy for reading datagrams and de-fragmenting them together.
*
* @version $revision$
*/
public class commanddatagramchannel extends commandchannelsupport
private static final log log   logfactory getlog commanddatagramchannel class
private datagramchannel channel
private bytebufferpool bufferpool
// reading
private object readlock   new object
private bytebuffer readbuffer
// writing
private object writelock   new object
private int defaultmarshalbuffersize   64   1024
public commanddatagramchannel udptransport transport  openwireformat wireformat  int datagramsize  socketaddress targetaddress  datagramheadermarshaller headermarshaller
datagramchannel channel  bytebufferpool bufferpool
super transport  wireformat  datagramsize  targetaddress  headermarshaller
this channel   channel
this bufferpool   bufferpool
public void start   throws exception
bufferpool setdefaultsize datagramsize
bufferpool start
readbuffer   bufferpool borrowbuffer
public void stop   throws exception
bufferpool stop
public command read   throws ioexception
command answer   null
endpoint from   null
synchronized  readlock
while  true
readbuffer clear
socketaddress address   channel receive readbuffer
readbuffer flip
if  readbuffer limit      0
continue
from   headermarshaller createendpoint readbuffer  address
int remaining   readbuffer remaining
byte data   new byte
readbuffer get data
// todo could use a datainput implementation that talks direct
// to
// the bytebuffer to avoid object allocation and unnecessary
// buffering?
datainputstream datain   new datainputstream new bytearrayinputstream data
answer    command wireformat unmarshal datain
break
if  answer    null
answer setfrom from
if  log isdebugenabled
log debug     name       from       answer
return answer
public void write command command  socketaddress address  throws ioexception
synchronized  writelock
bytearrayoutputstream largebuffer   new bytearrayoutputstream defaultmarshalbuffersize
wireformat marshal command  new dataoutputstream largebuffer
byte data   largebuffer tobytearray
int size   data length
bytebuffer writebuffer   bufferpool borrowbuffer
writebuffer clear
headermarshaller writeheader command  writebuffer
if  size > writebuffer remaining
// lets split the command up into chunks
int offset   0
boolean lastfragment   false
int length   data length
for  int fragment   0   lastfragment  fragment
// write the header
if  fragment > 0
writebuffer   bufferpool borrowbuffer
writebuffer clear
headermarshaller writeheader command  writebuffer
int chunksize   writebuffer remaining
// we need to remove the amount of overhead to write the
// partial command
// lets write the flags in there
booleanstream bs   null
if  wireformat istightencodingenabled
bs   new booleanstream
bs writeboolean true      the partial data byte is
// never null
// lets remove the header of the partial command
// which is the byte for the type and an int for the size of
// the byte[]
// data type + the command id + size of the partial data
chunksize    1   4   4
// the boolean flags
if  bs    null
chunksize    bs marshalledsize
else
chunksize    1
if   wireformat issizeprefixdisabled
// lets write the size of the command buffer
writebuffer putint chunksize
chunksize    4
lastfragment   offset   chunksize >  length
if  chunksize   offset > length
chunksize   length   offset
if  lastfragment
writebuffer put lastpartialcommand data_structure_type
else
writebuffer put partialcommand data_structure_type
if  bs    null
bs marshal writebuffer
int commandid   command getcommandid
if  fragment > 0
commandid   sequencegenerator getnextsequenceid
writebuffer putint commandid
if  bs    null
writebuffer put  byte 1
// size of byte array
writebuffer putint chunksize
// now the data
writebuffer put data  offset  chunksize
offset    chunksize
sendwritebuffer commandid  address  writebuffer  false
else
writebuffer put data
sendwritebuffer command getcommandid    address  writebuffer  false
// properties
// -------------------------------------------------------------------------
public bytebufferpool getbufferpool
return bufferpool
/**
* sets the implementation of the byte buffer pool to use
*/
public void setbufferpool bytebufferpool bufferpool
this bufferpool   bufferpool
// implementation methods
// -------------------------------------------------------------------------
protected void sendwritebuffer int commandid  socketaddress address  bytebuffer writebuffer  boolean redelivery  throws ioexception
// lets put the datagram into the replay buffer first to prevent timing
// issues
replaybuffer buffercache   getreplaybuffer
if  buffercache    null     redelivery
buffercache addbuffer commandid  writebuffer
writebuffer flip
if  log isdebugenabled
string text   redelivery ?
log debug     name       text       commandid       address
channel send writebuffer  address
public void sendbuffer int commandid  object buffer  throws ioexception
if  buffer    null
bytebuffer writebuffer    bytebuffer buffer
sendwritebuffer commandid  getreplayaddress    writebuffer  true
else
if  log iswarnenabled
log warn     commandid