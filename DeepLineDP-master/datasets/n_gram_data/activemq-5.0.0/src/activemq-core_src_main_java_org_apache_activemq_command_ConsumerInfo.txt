/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq command
import org apache activemq filter booleanexpression
import org apache activemq state commandvisitor
/**
* @openwire:marshaller code="5"
* @version $revision: 1.20 $
*/
public class consumerinfo extends basecommand
public static final byte data_structure_type   commandtypes consumer_info
public static final byte high_priority   10
public static final byte normal_priority   0
public static final byte network_consumer_priority    5
public static final byte low_priority    10
protected consumerid consumerid
protected activemqdestination destination
protected int prefetchsize
protected int maximumpendingmessagelimit
protected boolean browser
protected boolean dispatchasync
protected string selector
protected string subscriptionname
protected boolean nolocal
protected boolean exclusive
protected boolean retroactive
protected byte priority
protected brokerid brokerpath
protected boolean optimizedacknowledge
// used by the broker
protected transient int currentprefetchsize
// if true, the consumer will not send range
protected boolean norangeacks
// acks.
protected booleanexpression additionalpredicate
protected transient boolean networksubscription     this subscription
// originated from a
// network connection
public consumerinfo
public consumerinfo consumerid consumerid
this consumerid   consumerid
public consumerinfo sessioninfo sessioninfo  long consumerid
this consumerid   new consumerid sessioninfo getsessionid    consumerid
public consumerinfo copy
consumerinfo info   new consumerinfo
copy info
return info
public void copy consumerinfo info
super copy info
info consumerid   consumerid
info destination   destination
info prefetchsize   prefetchsize
info maximumpendingmessagelimit   maximumpendingmessagelimit
info browser   browser
info dispatchasync   dispatchasync
info selector   selector
info subscriptionname   subscriptionname
info nolocal   nolocal
info exclusive   exclusive
info retroactive   retroactive
info priority   priority
info brokerpath   brokerpath
public boolean isdurable
return subscriptionname    null
public byte getdatastructuretype
return data_structure_type
/**
* is used to uniquely identify the consumer to the broker.
*
* @openwire:property version=1 cache=true
*/
public consumerid getconsumerid
return consumerid
public void setconsumerid consumerid consumerid
this consumerid   consumerid
/**
* is this consumer a queue browser?
*
* @openwire:property version=1
*/
public boolean isbrowser
return browser
public void setbrowser boolean browser
this browser   browser
/**
* the destination that the consumer is interested in receiving messages
* from. this destination could be a composite destination.
*
* @openwire:property version=1 cache=true
*/
public activemqdestination getdestination
return destination
public void setdestination activemqdestination destination
this destination   destination
/**
* how many messages a broker will send to the client without receiving an
* ack before he stops dispatching messages to the client.
*
* @openwire:property version=1
*/
public int getprefetchsize
return prefetchsize
public void setprefetchsize int prefetchsize
this prefetchsize   prefetchsize
this currentprefetchsize   prefetchsize
/**
* how many messages a broker will keep around, above the prefetch limit,
* for non-durable topics before starting to discard older messages.
*
* @openwire:property version=1
*/
public int getmaximumpendingmessagelimit
return maximumpendingmessagelimit
public void setmaximumpendingmessagelimit int maximumpendingmessagelimit
this maximumpendingmessagelimit   maximumpendingmessagelimit
/**
* should the broker dispatch a message to the consumer async? if he does it
* async, then he uses a more seda style of processing while if it is not
* done async, then he broker use a stp style of processing. stp is more
* appropriate in high bandwidth situations or when being used by and in vm
* transport.
*
* @openwire:property version=1
*/
public boolean isdispatchasync
return dispatchasync
public void setdispatchasync boolean dispatchasync
this dispatchasync   dispatchasync
/**
* the jms selector used to filter out messages that this consumer is
* interested in.
*
* @openwire:property version=1
*/
public string getselector
return selector
public void setselector string selector
this selector   selector
/**
* used to identify the name of a durable subscription.
*
* @openwire:property version=1
*/
public string getsubscriptionname
return subscriptionname
public void setsubscriptionname string durablesubscriptionid
this subscriptionname   durablesubscriptionid
/**
* @deprecated
* @return
* @see getsubscriptionname
*/
public string getsubcriptionname
return subscriptionname
/**
* @deprecated
* @see setsubscriptionname
* @param durablesubscriptionid
*/
public void setsubcriptionname string durablesubscriptionid
this subscriptionname   durablesubscriptionid
/**
* set nolocal to true to avoid receiving messages that were published
* locally on the same connection.
*
* @openwire:property version=1
*/
public boolean isnolocal
return nolocal
public void setnolocal boolean nolocal
this nolocal   nolocal
/**
* an exclusive consumer locks out other consumers from being able to
* receive messages from the destination. if there are multiple exclusive
* consumers for a destination, the first one created will be the exclusive
* consumer of the destination.
*
* @openwire:property version=1
*/
public boolean isexclusive
return exclusive
public void setexclusive boolean exclusive
this exclusive   exclusive
/**
* a retroactive consumer only has meaning for topics. it allows a consumer
* to retroactively see messages sent prior to the consumer being created.
* if the consumer is not durable, it will be delivered the last message
* published to the topic. if the consumer is durable then it will receive
* all persistent messages that are still stored in persistent storage for
* that topic.
*
* @openwire:property version=1
*/
public boolean isretroactive
return retroactive
public void setretroactive boolean retroactive
this retroactive   retroactive
public removeinfo createremovecommand
removeinfo command   new removeinfo getconsumerid
command setresponserequired isresponserequired
return command
/**
* the broker will avoid dispatching to a lower priority consumer if there
* are other higher priority consumers available to dispatch to. this allows
* letting the broker to have an affinity to higher priority consumers.
* default priority is 0.
*
* @openwire:property version=1
*/
public byte getpriority
return priority
public void setpriority byte priority
this priority   priority
/**
* the route of brokers the command has moved through.
*
* @openwire:property version=1 cache=true
*/
public brokerid getbrokerpath
return brokerpath
public void setbrokerpath brokerid brokerpath
this brokerpath   brokerpath
/**
* a transient additional predicate that can be used it inject additional
* predicates into the selector on the fly. handy if if say a security
* broker interceptor wants to filter out messages based on security level
* of the consumer.
*
* @openwire:property version=1
*/
public booleanexpression getadditionalpredicate
return additionalpredicate
public void setadditionalpredicate booleanexpression additionalpredicate
this additionalpredicate   additionalpredicate
public response visit commandvisitor visitor  throws exception
return visitor processaddconsumer this
/**
* @openwire:property version=1
* @return returns the networksubscription.
*/
public boolean isnetworksubscription
return networksubscription
/**
* @param networksubscription the networksubscription to set.
*/
public void setnetworksubscription boolean networksubscription
this networksubscription   networksubscription
/**
* @openwire:property version=1
* @return returns the optimizedacknowledge.
*/
public boolean isoptimizedacknowledge
return optimizedacknowledge
/**
* @param optimizedacknowledge the optimizedacknowledge to set.
*/
public void setoptimizedacknowledge boolean optimizedacknowledge
this optimizedacknowledge   optimizedacknowledge
/**
* @return returns the currentprefetchsize.
*/
public int getcurrentprefetchsize
return currentprefetchsize
/**
* @param currentprefetchsize the currentprefetchsize to set.
*/
public void setcurrentprefetchsize int currentprefetchsize
this currentprefetchsize   currentprefetchsize
/**
* the broker may be able to optimize it's processing or provides better qos
* if it knows the consumer will not be sending ranged acks.
*
* @return true if the consumer will not send range acks.
* @openwire:property version=1
*/
public boolean isnorangeacks
return norangeacks
public void setnorangeacks boolean norangeacks
this norangeacks   norangeacks