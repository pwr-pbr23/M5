/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq filter
import java util arraylist
import java util collection
import java util hashmap
import java util iterator
import java util list
import java util map
import javax jms jmsexception
/**
* a multiexpressionevaluator is used to evaluate multiple expressions in single
* method call. <p/> multiple expression/expressionlistener pairs can be added
* to a multiexpressionevaluator object. when the multiexpressionevaluator
* object is evaluated, all the registed expressions are evaluated and then the
* associated expressionlistener is invoked to inform it of the evaluation
* result. <p/> by evaluating multiple expressions at one time, some
* optimizations can be made to reduce the number of computations normally
* required to evaluate all the expressions. <p/> when this class adds an
* expression it wrapps each node in the expression's ast with a cacheexpression
* object. then each cacheexpression object (one for each node) is placed in the
* cachedexpressions map. the cachedexpressions map allows us to find the sub
* expressions that are common across two different expressions. when adding an
* expression in, if a sub expression of the expression is allready in the
* cachedexpressions map, then instead of wrapping the sub expression in a new
* cacheexpression object, we reuse the cacheexpression allready int the map.
* <p/> to help illustrate what going on, lets try to give an exmample: if we
* denote the ast of a expression as follows:
* [ast-node-type,left-node,right-node], then a expression like: "3*5+6" would
* result in "[*,3,[+,5,6]]" <p/> if the [*,3,[+,5,6]] expression is added to
* the multiexpressionevaluator, it would really be converted to:
* [c0,[*,3,[c1,[+,5,6]]]] where c0 and c1 represent the cacheexpression
* expression objects that cache the results of the * and the + operation.
* constants and property nodes are not cached. <p/> if later on we add the
* following expression [=,11,[+,5,6]] ("11=5+6") to the
* multiexpressionevaluator it would be converted to: [c2,[=,11,[c1,[+,5,6]]]],
* where c2 is a new cacheexpression object but c1 is the same cacheexpression
* used in the previous expression. <p/> when the expressions are evaluated, the
* c1 cacheexpression object will only evaluate the [+,5,6] expression once and
* cache the resulting value. hence evauating the second expression costs less
* because that [+,5,6] is not done 2 times. <p/> problems: - cacheing the
* values introduces overhead. it may be possible to be smarter about which
* nodes in the ast are cached and which are not. - current implementation is
* not thread safe. this is because you need a way to invalidate all the cached
* values so that the next evaluation re-evaluates the nodes. by going single
* threaded, chache invalidation is done quickly by incrementing a 'view'
* counter. when a cacheexpressionnotices it's last cached value was generated
* in an old 'view', it invalidates its cached value.
*
* @version $revision: 1.2 $ $date: 2005/08/27 03:52:36 $
*/
public class multiexpressionevaluator
map<string  expressionlistenerset> rootexpressions   new hashmap<string  expressionlistenerset>
map<expression  cacheexpression> cachedexpressions   new hashmap<expression  cacheexpression>
int view
/**
* a unaryexpression that caches the result of the nested expression. the
* cached value is valid if the
* cacheexpression.cview==multiexpressionevaluator.view
*/
public class cacheexpression extends unaryexpression
short refcount
int cview   view   1
object cachedvalue
int cachedhashcode
public cacheexpression expression realexpression
super realexpression
cachedhashcode   realexpression hashcode
/**
* @see org.apache.activemq.filter.expression#evaluate(messageevaluationcontext)
*/
public object evaluate messageevaluationcontext message  throws jmsexception
if  view    cview
return cachedvalue
cachedvalue   right evaluate message
cview   view
return cachedvalue
public int hashcode
return cachedhashcode
public boolean equals object o
if  o    null
return false
return   cacheexpression o  right equals right
public string getexpressionsymbol
return null
public string tostring
return right tostring
/**
* multiple listeners my be interested in the results of a single
* expression.
*/
static class expressionlistenerset
expression expression
list<expressionlistener> listeners   new arraylist<expressionlistener>
/**
* objects that are interested in the results of an expression should
* implement this interface.
*/
static interface expressionlistener
void evaluateresultevent expression selector  messageevaluationcontext message  object result
/**
* adds an expressionlistener to a given expression. when evaluate is
* called, the expressionlistener will be provided the results of the
* expression applied to the evaluated message.
*/
public void addexpressionlistner expression selector  expressionlistener c
expressionlistenerset data   rootexpressions get selector tostring
if  data    null
data   new expressionlistenerset
data expression   addtocache selector
rootexpressions put selector tostring    data
data listeners add c
/**
* removes an expressionlistener from receiving the results of a given
* evaluation.
*/
public boolean removeeventlistner string selector  expressionlistener c
string expkey   selector
expressionlistenerset d   rootexpressions get expkey
// that selector had not been added.
if  d    null
return false
// that selector did not have that listeners..
if   d listeners remove c
return false
// if there are no more listeners for this expression....
if  d listeners size      0
// un-cache it...
removefromcache  cacheexpression d expression
rootexpressions remove expkey
return true
/**
* finds the cacheexpression that has been associated with an expression. if
* it is the first time the expression is being added to the cache, a new
* cacheexpression is created and associated with the expression. <p/> this
* method updates the reference counters on the cacheexpression to know when
* it is no longer needed.
*/
private cacheexpression addtocache expression expr
cacheexpression n   cachedexpressions get expr
if  n    null
n   new cacheexpression expr
cachedexpressions put expr  n
if  expr instanceof unaryexpression
// cache the sub expressions too
unaryexpression un    unaryexpression expr
un setright addtocache un getright
else if  expr instanceof binaryexpression
// cache the sub expressions too.
binaryexpression bn    binaryexpression expr
bn setright addtocache bn getright
bn setleft addtocache bn getleft
n refcount
return n
/**
* removes an expression from the cache. updates the reference counters on
* the cacheexpression object. when the refernce counter goes to zero, the
* entry int the expression to cacheexpression map is removed.
*
* @param cn
*/
private void removefromcache cacheexpression cn
cn refcount
expression realexpr   cn getright
if  cn refcount    0
cachedexpressions remove realexpr
if  realexpr instanceof unaryexpression
unaryexpression un    unaryexpression realexpr
removefromcache  cacheexpression un getright
if  realexpr instanceof binaryexpression
binaryexpression bn    binaryexpression realexpr
removefromcache  cacheexpression bn getright
/**
* evaluates the message against all the expressions added to this object.
* the added expressionlisteners are notified of the result of the
* evaluation.
*
* @param message
*/
public void evaluate messageevaluationcontext message
collection<expressionlistenerset> expressionlisteners   rootexpressions values
for  iterator<expressionlistenerset> iter   expressionlisteners iterator    iter hasnext
expressionlistenerset els   iter next
try
object result   els expression evaluate message
for  iterator<expressionlistener> iterator   els listeners iterator    iterator hasnext
expressionlistener l   iterator next
l evaluateresultevent els expression  message  result
catch  throwable e
e printstacktrace