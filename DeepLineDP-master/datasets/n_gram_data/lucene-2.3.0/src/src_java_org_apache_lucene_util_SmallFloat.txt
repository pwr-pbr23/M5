package org apache lucene util
/**
* copyright 2005 the apache software foundation
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
/** floating point numbers smaller than 32 bits.
*
* @author yonik
* @version $id$
*/
public class smallfloat
/** converts a 32 bit float to an 8 bit float.
* <br>values less than zero are all mapped to zero.
* <br>values are truncated (rounded down) to the nearest 8 bit value.
* <br>values between zero and the smallest representable value
*  are rounded up.
*
* @param f the 32 bit float to be converted to an 8 bit float (byte)
* @param nummantissabits the number of mantissa bits to use in the byte, with the remainder to be used in the exponent
* @param zeroexp the zero-point in the range of exponent values
* @return the 8 bit float representation
*/
public static byte floattobyte float f  int nummantissabits  int zeroexp
// adjustment from a float zero exponent to our zero exponent,
// shifted over to our exponent position.
int fzero    63 zeroexp <<nummantissabits
int bits   float floattorawintbits f
int smallfloat   bits >>  24 nummantissabits
if  smallfloat < fzero
return  bits< 0  ?
byte 0      negative numbers and zero both map to 0 byte
byte 1      underflow is mapped to smallest non zero number
else if  smallfloat >  fzero   0x100
return  1      overflow maps to largest number
else
return  byte  smallfloat   fzero
/** converts an 8 bit float to a 32 bit float. */
public static float bytetofloat byte b  int nummantissabits  int zeroexp
// on java1.5 & 1.6 jvms, prebuilding a decoding array and doing a lookup
// is only a little bit faster (anywhere from 0% to 7%)
if  b    0  return 0 0f
int bits    b 0xff  <<  24 nummantissabits
bits     63 zeroexp  << 24
return float intbitstofloat bits
//
// some specializations of the generic functions follow.
// the generic functions are just as fast with current (1.5)
// -server jvms, but still slower with client jvms.
//
/** floattobyte(b, mantissabits=3, zeroexponent=15)
* <br>smallest non-zero value = 5.820766e-10
* <br>largest value = 7.5161928e9
* <br>epsilon = 0.125
*/
public static byte floattobyte315 float f
int bits   float floattorawintbits f
int smallfloat   bits >>  24 3
if  smallfloat <  63 15 <<3
return  bits< 0  ?  byte 0    byte 1
if  smallfloat >    63 15 <<3    0x100
return  1
return  byte  smallfloat     63 15 <<3
/** bytetofloat(b, mantissabits=3, zeroexponent=15) */
public static float byte315tofloat byte b
// on java1.5 & 1.6 jvms, prebuilding a decoding array and doing a lookup
// is only a little bit faster (anywhere from 0% to 7%)
if  b    0  return 0 0f
int bits    b 0xff  <<  24 3
bits     63 15  << 24
return float intbitstofloat bits
/** floattobyte(b, mantissabits=5, zeroexponent=2)
* <br>smallest nonzero value = 0.033203125
* <br>largest value = 1984.0
* <br>epsilon = 0.03125
*/
public static byte floattobyte52 float f
int bits   float floattorawintbits f
int smallfloat   bits >>  24 5
if  smallfloat <  63 2 <<5
return  bits< 0  ?  byte 0    byte 1
if  smallfloat >    63 2 <<5    0x100
return  1
return  byte  smallfloat     63 2 <<5
/** bytetofloat(b, mantissabits=5, zeroexponent=2) */
public static float byte52tofloat byte b
// on java1.5 & 1.6 jvms, prebuilding a decoding array and doing a lookup
// is only a little bit faster (anywhere from 0% to 7%)
if  b    0  return 0 0f
int bits    b 0xff  <<  24 5
bits     63 2  << 24
return float intbitstofloat bits