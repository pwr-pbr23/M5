package org apache lucene store
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
/** abstract base class for input from a file in a {@link directory}.  a
* random-access input stream.  used for all lucene index input operations.
* @see directory
*/
public abstract class indexinput implements cloneable
private char chars                               used by readstring
/** reads and returns a single byte.
* @see indexoutput#writebyte(byte)
*/
public abstract byte readbyte   throws ioexception
/** reads a specified number of bytes into an array at the specified offset.
* @param b the array to read bytes into
* @param offset the offset in the array to start storing bytes
* @param len the number of bytes to read
* @see indexoutput#writebytes(byte[],int)
*/
public abstract void readbytes byte b  int offset  int len
throws ioexception
/** reads a specified number of bytes into an array at the
* specified offset with control over whether the read
* should be buffered (callers who have their own buffer
* should pass in "false" for usebuffer).  currently only
* {@link bufferedindexinput} respects this parameter.
* @param b the array to read bytes into
* @param offset the offset in the array to start storing bytes
* @param len the number of bytes to read
* @param usebuffer set to false if the caller will handle
* buffering.
* @see indexoutput#writebytes(byte[],int)
*/
public void readbytes byte b  int offset  int len  boolean usebuffer
throws ioexception
// default to ignoring usebuffer entirely
readbytes b  offset  len
/** reads four bytes and returns an int.
* @see indexoutput#writeint(int)
*/
public int readint   throws ioexception
return   readbyte     0xff  << 24      readbyte     0xff  << 16
readbyte     0xff  <<  8      readbyte     0xff
/** reads an int stored in variable-length format.  reads between one and
* five bytes.  smaller values take fewer bytes.  negative numbers are not
* supported.
* @see indexoutput#writevint(int)
*/
public int readvint   throws ioexception
byte b   readbyte
int i   b   0x7f
for  int shift   7   b   0x80     0  shift    7
b   readbyte
i     b   0x7f  << shift
return i
/** reads eight bytes and returns a long.
* @see indexoutput#writelong(long)
*/
public long readlong   throws ioexception
return    long readint    << 32     readint     0xffffffffl
/** reads a long stored in variable-length format.  reads between one and
* nine bytes.  smaller values take fewer bytes.  negative numbers are not
* supported. */
public long readvlong   throws ioexception
byte b   readbyte
long i   b   0x7f
for  int shift   7   b   0x80     0  shift    7
b   readbyte
i     b   0x7fl  << shift
return i
/** reads a string.
* @see indexoutput#writestring(string)
*/
public string readstring   throws ioexception
int length   readvint
if  chars    null    length > chars length
chars   new char
readchars chars  0  length
return new string chars  0  length
/** reads utf-8 encoded characters into an array.
* @param buffer the array to read characters into
* @param start the offset in the array to start storing characters
* @param length the number of characters to read
* @see indexoutput#writechars(string,int,int)
*/
public void readchars char buffer  int start  int length
throws ioexception
final int end   start   length
for  int i   start  i < end  i
byte b   readbyte
if   b   0x80     0
buffer    char  b   0x7f
else if   b   0xe0     0xe0
buffer    char    b   0x1f  << 6
readbyte     0x3f
else
buffer    char    b   0x0f  << 12
readbyte     0x3f  << 6
readbyte     0x3f
/**
* expert
*
* similar to {@link #readchars(char[], int, int)} but does not do any conversion operations on the bytes it is reading in.  it still
* has to invoke {@link #readbyte()} just as {@link #readchars(char[], int, int)} does, but it does not need a buffer to store anything
* and it does not have to do any of the bitwise operations, since we don't actually care what is in the byte except to determine
* how many more bytes to read
* @param length the number of chars to read
*/
public void skipchars int length  throws ioexception
for  int i   0  i < length  i
byte b   readbyte
if   b   0x80     0
//do nothing, we only need one byte
else if   b   0xe0     0xe0
readbyte     read an additional byte
else
//read two additional bytes.
readbyte
readbyte
/** closes the stream to futher operations. */
public abstract void close   throws ioexception
/** returns the current position in this file, where the next read will
* occur.
* @see #seek(long)
*/
public abstract long getfilepointer
/** sets current position in this file, where the next read will occur.
* @see #getfilepointer()
*/
public abstract void seek long pos  throws ioexception
/** the number of bytes in the file. */
public abstract long length
/** returns a clone of this stream.
*
* <p>clones of a stream access the same data, and are positioned at the same
* point as the stream they were cloned from.
*
* <p>expert: subclasses must ensure that clones may be positioned at
* different points in the input from each other and from the stream they
* were cloned from.
*/
public object clone
indexinput clone   null
try
clone    indexinput super clone
catch  clonenotsupportedexception e
clone chars   null
return clone