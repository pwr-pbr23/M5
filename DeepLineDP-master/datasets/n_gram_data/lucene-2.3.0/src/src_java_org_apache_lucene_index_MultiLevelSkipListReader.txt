package org apache lucene index
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util arrays
import org apache lucene store bufferedindexinput
import org apache lucene store indexinput
/**
* this abstract class reads skip lists with multiple levels.
*
* see {@link multilevelskiplistwriter} for the information about the encoding
* of the multi level skip lists.
*
* subclasses must implement the abstract method {@link #readskipdata(int, indexinput)}
* which defines the actual format of the skip data.
*/
abstract class multilevelskiplistreader
// the maximum number of skip levels possible for this index
private int maxnumberofskiplevels
// number of levels in this skip list
private int numberofskiplevels
// expert: defines the number of top skip levels to buffer in memory.
// reducing this number results in less memory usage, but possibly
// slower performance due to more random i/os.
// please notice that the space each level occupies is limited by
// the skipinterval. the top level can not contain more than
// skiplevel entries, the second top level can not contain more
// than skiplevel^2 entries and so forth.
private int numberoflevelstobuffer   1
private int doccount
private boolean haveskipped
private indexinput skipstream        skipstream for each level
private long skippointer             the start pointer of each skip level
private int skipinterval             skipinterval of each level
private int numskipped               number of docs skipped per level
private int skipdoc                  doc id of current skip entry per level
private int lastdoc                    doc id of last read skip entry with docid <  target
private long childpointer            child pointer of current skip entry per level
private long lastchildpointer          childpointer of last read skip entry with docid <  target
private boolean inputisbuffered
public multilevelskiplistreader indexinput skipstream  int maxskiplevels  int skipinterval
this skipstream   new indexinput
this skippointer   new long
this childpointer   new long
this numskipped   new int
this maxnumberofskiplevels   maxskiplevels
this skipinterval   new int
this skipstream   skipstream
this inputisbuffered    skipstream instanceof bufferedindexinput
this skipinterval   skipinterval
for  int i   1  i < maxskiplevels  i
// cache skip intervals
this skipinterval   this skipinterval   skipinterval
skipdoc   new int
/** returns the id of the doc to which the last call of {@link #skipto(int)}
*  has skipped.  */
int getdoc
return lastdoc
/** skips entries to the first beyond the current whose document number is
*  greater than or equal to <i>target</i>. returns the current doc count.
*/
int skipto int target  throws ioexception
if   haveskipped
// first time, load skip levels
loadskiplevels
haveskipped   true
// walk up the levels until highest level is found that has a skip
// for this target
int level   0
while  level < numberofskiplevels   1    target > skipdoc
level
while  level >  0
if  target > skipdoc
if   loadnextskip level
continue
else
// no more skips on this level, go down one level
if  level > 0    lastchildpointer > skipstream getfilepointer
seekchild level   1
level
return numskipped   skipinterval   1
private boolean loadnextskip int level  throws ioexception
// we have to skip, the target document is greater than the current
// skip list entry
setlastskipdata level
numskipped    skipinterval
if  numskipped > doccount
// this skip list is exhausted
skipdoc   integer max_value
if  numberofskiplevels > level  numberofskiplevels   level
return false
// read next skip entry
skipdoc    readskipdata level  skipstream
if  level    0
// read the child pointer if we are not on the leaf level
childpointer   skipstream readvlong     skippointer
return true
/** seeks the skip entry on the given level */
protected void seekchild int level  throws ioexception
skipstream seek lastchildpointer
numskipped   numskipped   skipinterval
skipdoc   lastdoc
if  level > 0
childpointer   skipstream readvlong     skippointer
void close   throws ioexception
for  int i   1  i < skipstream length  i
if  skipstream    null
skipstream close
/** initializes the reader */
void init long skippointer  int df
this skippointer   skippointer
this doccount   df
arrays fill skipdoc  0
arrays fill numskipped  0
arrays fill childpointer  0
haveskipped   false
for  int i   1  i < numberofskiplevels  i
skipstream   null
/** loads the skip levels  */
private void loadskiplevels   throws ioexception
numberofskiplevels   doccount    0 ? 0    int  math floor math log doccount    math log skipinterval
if  numberofskiplevels > maxnumberofskiplevels
numberofskiplevels   maxnumberofskiplevels
skipstream seek skippointer
int tobuffer   numberoflevelstobuffer
for  int i   numberofskiplevels   1  i > 0  i
// the length of the current level
long length   skipstream readvlong
// the start pointer of the current level
skippointer   skipstream getfilepointer
if  tobuffer > 0
// buffer this level
skipstream   new skipbuffer skipstream   int  length
tobuffer
else
// clone this stream, it is already at the start of the current level
skipstream    indexinput  skipstream clone
if  inputisbuffered    length < bufferedindexinput buffer_size
bufferedindexinput  skipstream  setbuffersize  int  length
// move base stream beyond the current level
skipstream seek skipstream getfilepointer     length
// use base stream for the lowest level
skippointer   skipstream getfilepointer
/**
* subclasses must implement the actual skip data encoding in this method.
*
* @param level the level skip data shall be read from
* @param skipstream the skip stream to read from
*/
protected abstract int readskipdata int level  indexinput skipstream  throws ioexception
/** copies the values of the last read skip entry on this level */
protected void setlastskipdata int level
lastdoc   skipdoc
lastchildpointer   childpointer
/** used to buffer the top skip levels */
private final static class skipbuffer extends indexinput
private byte data
private long pointer
private int pos
skipbuffer indexinput input  int length  throws ioexception
data   new byte
pointer   input getfilepointer
input readbytes data  0  length
public void close   throws ioexception
data   null
public long getfilepointer
return pointer   pos
public long length
return data length
public byte readbyte   throws ioexception
return data
public void readbytes byte b  int offset  int len  throws ioexception
system arraycopy data  pos  b  offset  len
pos    len
public void seek long pos  throws ioexception
this pos     int   pos   pointer