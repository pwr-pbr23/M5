package org apache lucene index
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene store indexinput
import java io ioexception
final class segmenttermpositions
extends segmenttermdocs implements termpositions
private indexinput proxstream
private int proxcount
private int position
// the current payload length
private int payloadlength
// indicates whether the payload of the currend position has
// been read from the proxstream yet
private boolean needtoloadpayload
// these variables are being used to remember information
// for a lazy skip
private long lazyskippointer    1
private int lazyskipproxcount   0
segmenttermpositions segmentreader p
super p
this proxstream   null      the proxstream will be cloned lazily when nextposition   is called for the first time
final void seek terminfo ti  term term  throws ioexception
super seek ti  term
if  ti    null
lazyskippointer   ti proxpointer
lazyskipproxcount   0
proxcount   0
payloadlength   0
needtoloadpayload   false
public final void close   throws ioexception
super close
if  proxstream    null  proxstream close
public final int nextposition   throws ioexception
// perform lazy skips if neccessary
lazyskip
proxcount
return position    readdeltaposition
private final int readdeltaposition   throws ioexception
int delta   proxstream readvint
if  currentfieldstorespayloads
// if the current field stores payloads then
// the position delta is shifted one bit to the left.
// if the lsb is set, then we have to read the current
// payload length
if   delta   1     0
payloadlength   proxstream readvint
delta >>>  1
needtoloadpayload   true
return delta
protected final void skippingdoc   throws ioexception
// we remember to skip a document lazily
lazyskipproxcount    freq
public final boolean next   throws ioexception
// we remember to skip the remaining positions of the current
// document lazily
lazyskipproxcount    proxcount
if  super next                       run super
proxcount   freq                   note frequency
position   0                   reset position
return true
return false
public final int read final int docs  final int freqs
throw new unsupportedoperationexception
/** called by super.skipto(). */
protected void skipprox long proxpointer  int payloadlength  throws ioexception
// we save the pointer, we might have to skip there lazily
lazyskippointer   proxpointer
lazyskipproxcount   0
proxcount   0
this payloadlength   payloadlength
needtoloadpayload   false
private void skippositions int n  throws ioexception
for  int f   n  f > 0  f                skip unread positions
readdeltaposition
skippayload
private void skippayload   throws ioexception
if  needtoloadpayload    payloadlength > 0
proxstream seek proxstream getfilepointer     payloadlength
needtoloadpayload   false
// it is not always neccessary to move the prox pointer
// to a new document after the freq pointer has been moved.
// consider for example a phrase query with two terms:
// the freq pointer for term 1 has to move to document x
// to answer the question if the term occurs in that document. but
// only if term 2 also matches document x, the positions have to be
// read to figure out if term 1 and term 2 appear next
// to each other in document x and thus satisfy the query.
// so we move the prox pointer lazily to the document
// as soon as positions are requested.
private void lazyskip   throws ioexception
if  proxstream    null
// clone lazily
proxstream    indexinput parent proxstream clone
// we might have to skip the current payload
// if it was not read yet
skippayload
if  lazyskippointer     1
proxstream seek lazyskippointer
lazyskippointer    1
if  lazyskipproxcount    0
skippositions lazyskipproxcount
lazyskipproxcount   0
public int getpayloadlength
return payloadlength
public byte getpayload byte data  int offset  throws ioexception
if   needtoloadpayload
throw new ioexception
// read payloads lazily
byte retarray
int retoffset
if  data    null    data length   offset < payloadlength
// the array is too small to store the payload data,
// so we allocate a new one
retarray   new byte
retoffset   0
else
retarray   data
retoffset   offset
proxstream readbytes retarray  retoffset  payloadlength
needtoloadpayload   false
return retarray
public boolean ispayloadavailable
return needtoloadpayload    payloadlength > 0