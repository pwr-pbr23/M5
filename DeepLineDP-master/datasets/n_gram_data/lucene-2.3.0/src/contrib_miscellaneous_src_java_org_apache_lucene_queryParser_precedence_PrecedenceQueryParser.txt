/* generated by:javacc: do not edit this line. precedencequeryparser.java */
package org apache lucene queryparser precedence
import java util vector
import java io
import java text
import java util
import org apache lucene index term
import org apache lucene analysis
import org apache lucene document
import org apache lucene search
import org apache lucene util parameter
/**
* experimental query parser variant designed to handle operator precedence
* in a more sensible fashion than queryparser.  there are still some
* open issues with this parser. the following tests are currently failing
* in testprecedencequeryparser and are disabled to make this test pass:
* <ul>
* <li> testsimple
* <li> testwildcard
* <li> testprecedence
* </ul>
*
* this class is generated by javacc.  the only method that clients should need
* to call is {@link #parse(string)}.
*
* the syntax for query strings is as follows:
* a query is a series of clauses.
* a clause may be prefixed by:
* <ul>
* <li> a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating
* that the clause is required or prohibited respectively; or
* <li> a term followed by a colon, indicating the field to be searched.
* this enables one to construct queries which search multiple fields.
* </ul>
*
* a clause may be either:
* <ul>
* <li> a term, indicating all the documents that contain this term; or
* <li> a nested query, enclosed in parentheses.  note that this may be used
* with a <code>+</code>/<code>-</code> prefix to require any of a set of
* terms.
* </ul>
*
* thus, in bnf, the query grammar is:
* <pre>
*   query  ::= ( clause )*
*   clause ::= ["+", "-"] [&lt;term&gt; ":"] ( &lt;term&gt; | "(" query ")" )
* </pre>
*
* <p>
* examples of appropriately formatted queries can be found in the <a
* href="http://jakarta.apache.org/lucene/docs/queryparsersyntax.html">query syntax
* documentation</a>.
* </p>
*
* @author brian goetz
* @author peter halacsy
* @author tatu saloranta
*/
public class precedencequeryparser implements precedencequeryparserconstants
private static final int conj_none     0
private static final int conj_and      1
private static final int conj_or       2
private static final int mod_none      0
private static final int mod_not       10
private static final int mod_req       11
// make it possible to call setdefaultoperator() without accessing
// the nested class:
public static final operator and_operator   operator and
public static final operator or_operator   operator or
/** the actual operator that parser uses to combine query terms */
private operator operator   or_operator
boolean lowercaseexpandedterms   true
analyzer analyzer
string field
int phraseslop   0
float fuzzyminsim   fuzzyquery defaultminsimilarity
int fuzzyprefixlength   fuzzyquery defaultprefixlength
locale locale   locale getdefault
static final class operator extends parameter
private operator string name
super name
static final operator or   new operator
static final operator and   new operator
/** constructs a query parser.
*  @param f  the default field for query terms.
*  @param a   used to find terms in the query text.
*/
public precedencequeryparser string f  analyzer a
this new fastcharstream new stringreader
analyzer   a
field   f
/** parses a query string, returning a {@link org.apache.lucene.search.query}.
*  @param expression  the query string to be parsed.
*  @throws parseexception if the parsing fails
*/
public query parse string expression  throws parseexception
// optimize empty query to be empty booleanquery
if  expression    null    expression trim   length      0
return new booleanquery
reinit new fastcharstream new stringreader expression
try
query query   query field
return  query    null  ? query   new booleanquery
catch  tokenmgrerror tme
throw new parseexception tme getmessage
catch  booleanquery toomanyclauses tmc
throw new parseexception
/**
* @return returns the analyzer.
*/
public analyzer getanalyzer
return analyzer
/**
* @return returns the field.
*/
public string getfield
return field
/**
* get the minimal similarity for fuzzy queries.
*/
public float getfuzzyminsim
return fuzzyminsim
/**
* set the minimum similarity for fuzzy queries.
* default is 0.5f.
*/
public void setfuzzyminsim float fuzzyminsim
this fuzzyminsim   fuzzyminsim
/**
* get the prefix length for fuzzy queries.
* @return returns the fuzzyprefixlength.
*/
public int getfuzzyprefixlength
return fuzzyprefixlength
/**
* set the prefix length for fuzzy queries. default is 0.
* @param fuzzyprefixlength the fuzzyprefixlength to set.
*/
public void setfuzzyprefixlength int fuzzyprefixlength
this fuzzyprefixlength   fuzzyprefixlength
/**
* sets the default slop for phrases.  if zero, then exact phrase matches
* are required.  default value is zero.
*/
public void setphraseslop int phraseslop
this phraseslop   phraseslop
/**
* gets the default slop for phrases.
*/
public int getphraseslop
return phraseslop
/**
* sets the boolean operator of the queryparser.
* in default mode (<code>or_operator</code>) terms without any modifiers
* are considered optional: for example <code>capital of hungary</code> is equal to
* <code>capital or of or hungary</code>.<br/>
* in <code>and_operator</code> mode terms are considered to be in conjuction: the
* above mentioned query is parsed as <code>capital and of and hungary</code>
*/
public void setdefaultoperator operator op
this operator   op
/**
* gets implicit operator setting, which will be either and_operator
* or or_operator.
*/
public operator getdefaultoperator
return operator
/**
* whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
* lower-cased or not.  default is <code>true</code>.
*/
public void setlowercaseexpandedterms boolean lowercaseexpandedterms
this lowercaseexpandedterms   lowercaseexpandedterms
/**
* @see #setlowercaseexpandedterms(boolean)
*/
public boolean getlowercaseexpandedterms
return lowercaseexpandedterms
/**
* set locale used by date range parsing.
*/
public void setlocale locale locale
this locale   locale
/**
* returns current locale, allowing access by subclasses.
*/
public locale getlocale
return locale
protected void addclause vector clauses  int conj  int modifier  query q
boolean required  prohibited
// if this term is introduced by and, make the preceding term required,
// unless it's already prohibited
if  clauses size   > 0    conj    conj_and
booleanclause c    booleanclause  clauses elementat clauses size   1
if   c isprohibited
c setoccur booleanclause occur must
if  clauses size   > 0    operator    and_operator    conj    conj_or
// if this term is introduced by or, make the preceding term optional,
// unless it's prohibited (that means we leave -a or b but +a or b-->a or b)
// notice if the input is a or b, first term is parsed as required; without
// this modification a or b would parsed as +a or b
booleanclause c    booleanclause  clauses elementat clauses size   1
if   c isprohibited
c setoccur booleanclause occur should
// we might have been passed a null query; the term might have been
// filtered away by the analyzer.
if  q    null
return
if  operator    or_operator
// we set required if we're introduced by and or +; prohibited if
// introduced by not or -; make sure not to set both.
prohibited    modifier    mod_not
required    modifier    mod_req
if  conj    conj_and     prohibited
required   true
else
// we set prohibited if we're introduced by not or -; we set required
// if not prohibited and not introduced by or
prohibited    modifier    mod_not
required       prohibited    conj    conj_or
if  required     prohibited
clauses addelement new booleanclause q  booleanclause occur must
else if   required     prohibited
clauses addelement new booleanclause q  booleanclause occur should
else if   required    prohibited
clauses addelement new booleanclause q  booleanclause occur must_not
else
throw new runtimeexception
/**
* @exception parseexception throw in overridden method to disallow
*/
protected query getfieldquery string field  string querytext   throws parseexception
// use the analyzer to get all the tokens, and then build a termquery,
// phrasequery, or nothing based on the term count
tokenstream source   analyzer tokenstream field  new stringreader querytext
vector v   new vector
org apache lucene analysis token t
int positioncount   0
boolean severaltokensatsameposition   false
while  true
try
t   source next
catch  ioexception e
t   null
if  t    null
break
v addelement t
if  t getpositionincrement      1
positioncount
else
severaltokensatsameposition   true
try
source close
catch  ioexception e
// ignore
if  v size      0
return null
else if  v size      1
t    org apache lucene analysis token  v elementat 0
return new termquery new term field  t termtext
else
if  severaltokensatsameposition
if  positioncount    1
// no phrase query:
booleanquery q   new booleanquery
for  int i   0  i < v size    i
t    org apache lucene analysis token  v elementat i
termquery currentquery   new termquery
new term field  t termtext
q add currentquery  booleanclause occur should
return q
else
// phrase query:
multiphrasequery mpq   new multiphrasequery
list multiterms   new arraylist
for  int i   0  i < v size    i
t    org apache lucene analysis token  v elementat i
if  t getpositionincrement      1    multiterms size   > 0
mpq add  term multiterms toarray new term
multiterms clear
multiterms add new term field  t termtext
mpq add  term multiterms toarray new term
return mpq
else
phrasequery q   new phrasequery
q setslop phraseslop
for  int i   0  i < v size    i
q add new term field    org apache lucene analysis token
v elementat i   termtext
return q
/**
* base implementation delegates to {@link #getfieldquery(string,string)}.
* this method may be overridden, for example, to return
* a spannearquery instead of a phrasequery.
*
* @exception parseexception throw in overridden method to disallow
*/
protected query getfieldquery string field  string querytext  int slop
throws parseexception
query query   getfieldquery field  querytext
if  query instanceof phrasequery
phrasequery  query  setslop slop
if  query instanceof multiphrasequery
multiphrasequery  query  setslop slop
return query
/**
* @exception parseexception throw in overridden method to disallow
*/
protected query getrangequery string field
string part1
string part2
boolean inclusive  throws parseexception
if  lowercaseexpandedterms
part1   part1 tolowercase
part2   part2 tolowercase
try
dateformat df   dateformat getdateinstance dateformat short  locale
df setlenient true
date d1   df parse part1
date d2   df parse part2
part1   datetools datetostring d1  datetools resolution day
part2   datetools datetostring d2  datetools resolution day
catch  exception e
return new rangequery new term field  part1
new term field  part2
inclusive
/**
* factory method for generating query, given a set of clauses.
* by default creates a boolean query composed of clauses passed in.
*
* can be overridden by extending classes, to modify query being
* returned.
*
* @param clauses vector that contains {@link booleanclause} instances
*    to join.
*
* @return resulting {@link query} object.
* @exception parseexception throw in overridden method to disallow
*/
protected query getbooleanquery vector clauses  throws parseexception
return getbooleanquery clauses  false
/**
* factory method for generating query, given a set of clauses.
* by default creates a boolean query composed of clauses passed in.
*
* can be overridden by extending classes, to modify query being
* returned.
*
* @param clauses vector that contains {@link booleanclause} instances
*    to join.
* @param disablecoord true if coord scoring should be disabled.
*
* @return resulting {@link query} object.
* @exception parseexception throw in overridden method to disallow
*/
protected query getbooleanquery vector clauses  boolean disablecoord
throws parseexception
if  clauses    null    clauses size      0
return null
booleanquery query   new booleanquery disablecoord
for  int i   0  i < clauses size    i
query add  booleanclause clauses elementat i
return query
/**
* factory method for generating a query. called when parser
* parses an input term token that contains one or more wildcard
* characters (? and *), but is not a prefix term token (one
* that has just a single * character at the end)
*<p>
* depending on settings, prefix term may be lower-cased
* automatically. it will not go through the default analyzer,
* however, since normal analyzers are unlikely to work properly
* with wildcard templates.
*<p>
* can be overridden by extending classes, to provide custom handling for
* wildcard queries, which may be necessary due to missing analyzer calls.
*
* @param field name of the field query will use.
* @param termstr term token that contains one or more wild card
*   characters (? or *), but is not simple prefix term
*
* @return resulting {@link query} built for the term
* @exception parseexception throw in overridden method to disallow
*/
protected query getwildcardquery string field  string termstr  throws parseexception
if  lowercaseexpandedterms
termstr   termstr tolowercase
term t   new term field  termstr
return new wildcardquery t
/**
* factory method for generating a query (similar to
* {@link #getwildcardquery}). called when parser parses an input term
* token that uses prefix notation; that is, contains a single '*' wildcard
* character as its last character. since this is a special case
* of generic wildcard term, and such a query can be optimized easily,
* this usually results in a different query object.
*<p>
* depending on settings, a prefix term may be lower-cased
* automatically. it will not go through the default analyzer,
* however, since normal analyzers are unlikely to work properly
* with wildcard templates.
*<p>
* can be overridden by extending classes, to provide custom handling for
* wild card queries, which may be necessary due to missing analyzer calls.
*
* @param field name of the field query will use.
* @param termstr term token to use for building term for the query
*    (<b>without</b> trailing '*' character!)
*
* @return resulting {@link query} built for the term
* @exception parseexception throw in overridden method to disallow
*/
protected query getprefixquery string field  string termstr  throws parseexception
if  lowercaseexpandedterms
termstr   termstr tolowercase
term t   new term field  termstr
return new prefixquery t
/**
* factory method for generating a query (similar to
* {@link #getwildcardquery}). called when parser parses
* an input term token that has the fuzzy suffix (~) appended.
*
* @param field name of the field query will use.
* @param termstr term token to use for building term for the query
*
* @return resulting {@link query} built for the term
* @exception parseexception throw in overridden method to disallow
*/
protected query getfuzzyquery string field  string termstr  float minsimilarity  throws parseexception
if  lowercaseexpandedterms
termstr   termstr tolowercase
term t   new term field  termstr
return new fuzzyquery t  minsimilarity  fuzzyprefixlength
/**
* returns a string where the escape char has been
* removed, or kept only once if there was a double escape.
*/
private string discardescapechar string input
char casource   input tochararray
char cadest   new char
int j   0
for  int i   0  i < casource length  i
if   casource           i > 0    casource
cadest casource
return new string cadest  0  j
/**
* returns a string where those characters that queryparser
* expects to be escaped are escaped by a preceding <code>\</code>.
*/
public static string escape string s
stringbuffer sb   new stringbuffer
for  int i   0  i < s length    i
char c   s charat i
// note: keep this in sync with _escaped_char below!
if  c         c         c         c         c         c         c
c         c         c         c         c         c         c
c         c
sb append
sb append c
return sb tostring
/**
* command line tool to test queryparser, using {@link org.apache.lucene.analysis.simpleanalyzer}.
* usage:<br>
* <code>java org.apache.lucene.queryparser.queryparser &lt;input&gt;</code>
*/
public static void main string args  throws exception
if  args length    0
system out println
system exit 0
precedencequeryparser qp   new precedencequeryparser
new org apache lucene analysis simpleanalyzer
query q   qp parse args
system out println q tostring
// *   query  ::= ( clause )*
// *   clause ::= ["+", "-"] [<term> ":"] ( <term> | "(" query ")" )
final public int conjunction   throws parseexception
int ret   conj_none
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case and
case or
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case and
jj_consume_token and
ret   conj_and
break
case or
jj_consume_token or
ret   conj_or
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
break
default
jj_la1   jj_gen
if  true  return ret
throw new error
final public int modifier   throws parseexception
int ret   mod_none
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case not
case plus
case minus
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case plus
jj_consume_token plus
ret   mod_req
break
case minus
jj_consume_token minus
ret   mod_not
break
case not
jj_consume_token not
ret   mod_not
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
break
default
jj_la1   jj_gen
if  true  return ret
throw new error
final public query query string field  throws parseexception
vector clauses   new vector
query q  firstquery null
boolean orpresent   false
int modifier
modifier   modifier
q   andexpression field
addclause clauses  conj_none  modifier  q
if  modifier    mod_none
firstquery   q
label_1
while  true
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case or
case not
case plus
case minus
case lparen
case quoted
case term
case prefixterm
case wildterm
case rangein_start
case rangeex_start
case number
break
default
jj_la1   jj_gen
break label_1
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case or
jj_consume_token or
orpresent true
break
default
jj_la1   jj_gen
modifier   modifier
q   andexpression field
addclause clauses  orpresent ? conj_or   conj_none  modifier  q
if  clauses size      1    firstquery    null
if  true  return firstquery
else
if  true  return getbooleanquery clauses
throw new error
final public query andexpression string field  throws parseexception
vector clauses   new vector
query q  firstquery null
int modifier
q   clause field
addclause clauses  conj_none  mod_none  q
firstquery   q
label_2
while  true
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case and
break
default
jj_la1   jj_gen
break label_2
jj_consume_token and
modifier   modifier
q   clause field
addclause clauses  conj_and  modifier  q
if  clauses size      1    firstquery    null
if  true  return firstquery
else
if  true  return getbooleanquery clauses
throw new error
final public query clause string field  throws parseexception
query q
token fieldtoken null  boost null
if  jj_2_1 2
fieldtoken   jj_consume_token term
jj_consume_token colon
field discardescapechar fieldtoken image
else
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case quoted
case term
case prefixterm
case wildterm
case rangein_start
case rangeex_start
case number
q   term field
break
case lparen
jj_consume_token lparen
q   query field
jj_consume_token rparen
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case carat
jj_consume_token carat
boost   jj_consume_token number
break
default
jj_la1   jj_gen
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
if  boost    null
float f    float 1 0
try
f   float valueof boost image  floatvalue
q setboost f
catch  exception ignored
if  true  return q
throw new error
final public query term string field  throws parseexception
token term  boost null  fuzzyslop null  goop1  goop2
boolean prefix   false
boolean wildcard   false
boolean fuzzy   false
query q
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case term
case prefixterm
case wildterm
case number
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case term
term   jj_consume_token term
break
case prefixterm
term   jj_consume_token prefixterm
prefix true
break
case wildterm
term   jj_consume_token wildterm
wildcard true
break
case number
term   jj_consume_token number
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case fuzzy_slop
fuzzyslop   jj_consume_token fuzzy_slop
fuzzy true
break
default
jj_la1   jj_gen
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case carat
jj_consume_token carat
boost   jj_consume_token number
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case fuzzy_slop
fuzzyslop   jj_consume_token fuzzy_slop
fuzzy true
break
default
jj_la1   jj_gen
break
default
jj_la1   jj_gen
string termimage discardescapechar term image
if  wildcard
q   getwildcardquery field  termimage
else if  prefix
q   getprefixquery field
discardescapechar term image substring
0  term image length   1
else if  fuzzy
float fms   fuzzyminsim
try
fms   float valueof fuzzyslop image substring 1   floatvalue
catch  exception ignored
if fms < 0 0f    fms > 1 0f
if  true  throw new parseexception
q   getfuzzyquery field  termimage  fms
else
q   getfieldquery field  termimage
break
case rangein_start
jj_consume_token rangein_start
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case rangein_goop
goop1   jj_consume_token rangein_goop
break
case rangein_quoted
goop1   jj_consume_token rangein_quoted
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case rangein_to
jj_consume_token rangein_to
break
default
jj_la1   jj_gen
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case rangein_goop
goop2   jj_consume_token rangein_goop
break
case rangein_quoted
goop2   jj_consume_token rangein_quoted
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
jj_consume_token rangein_end
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case carat
jj_consume_token carat
boost   jj_consume_token number
break
default
jj_la1   jj_gen
if  goop1 kind    rangein_quoted
goop1 image   goop1 image substring 1  goop1 image length   1
else
goop1 image   discardescapechar goop1 image
if  goop2 kind    rangein_quoted
goop2 image   goop2 image substring 1  goop2 image length   1
else
goop2 image   discardescapechar goop2 image
q   getrangequery field  goop1 image  goop2 image  true
break
case rangeex_start
jj_consume_token rangeex_start
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case rangeex_goop
goop1   jj_consume_token rangeex_goop
break
case rangeex_quoted
goop1   jj_consume_token rangeex_quoted
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case rangeex_to
jj_consume_token rangeex_to
break
default
jj_la1   jj_gen
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case rangeex_goop
goop2   jj_consume_token rangeex_goop
break
case rangeex_quoted
goop2   jj_consume_token rangeex_quoted
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
jj_consume_token rangeex_end
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case carat
jj_consume_token carat
boost   jj_consume_token number
break
default
jj_la1   jj_gen
if  goop1 kind    rangeex_quoted
goop1 image   goop1 image substring 1  goop1 image length   1
else
goop1 image   discardescapechar goop1 image
if  goop2 kind    rangeex_quoted
goop2 image   goop2 image substring 1  goop2 image length   1
else
goop2 image   discardescapechar goop2 image
q   getrangequery field  goop1 image  goop2 image  false
break
case quoted
term   jj_consume_token quoted
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case fuzzy_slop
fuzzyslop   jj_consume_token fuzzy_slop
break
default
jj_la1   jj_gen
switch   jj_ntk   1 ?jj_ntk   jj_ntk
case carat
jj_consume_token carat
boost   jj_consume_token number
break
default
jj_la1   jj_gen
int s   phraseslop
if  fuzzyslop    null
try
s   float valueof fuzzyslop image substring 1   intvalue
catch  exception ignored
q   getfieldquery field  term image substring 1  term image length   1   s
break
default
jj_la1   jj_gen
jj_consume_token  1
throw new parseexception
if  boost    null
float f    float  1 0
try
f   float valueof boost image  floatvalue
catch  exception ignored
/* should this be handled somehow? (defaults to "no boost", if
* boost number is invalid)
*/
// avoid boosting null queries, such as those caused by stop words
if  q    null
q setboost f
if  true  return q
throw new error
final private boolean jj_2_1 int xla
jj_la   xla  jj_lastpos   jj_scanpos   token
try   return  jj_3_1
catch lookaheadsuccess ls    return true
finally   jj_save 0  xla
final private boolean jj_3_1
if  jj_scan_token term   return true
if  jj_scan_token colon   return true
return false
public precedencequeryparsertokenmanager token_source
public token token  jj_nt
private int jj_ntk
private token jj_scanpos  jj_lastpos
private int jj_la
public boolean lookingahead   false
private boolean jj_semla
private int jj_gen
final private int jj_la1   new int
static private int jj_la1_0
static
jj_la1_0
private static void jj_la1_0
jj_la1_0   new int  0x180 0x180 0xe00 0xe00 0xfb1f00 0x100 0x80 0x8000 0xfb1000 0x9a0000 0x40000 0x40000 0x8000 0xc000000 0x1000000 0xc000000 0x8000 0xc0000000 0x10000000 0xc0000000 0x8000 0x40000 0x8000 0xfb0000
final private jjcalls jj_2_rtns   new jjcalls
private boolean jj_rescan   false
private int jj_gc   0
public precedencequeryparser charstream stream
token_source   new precedencequeryparsertokenmanager stream
token   new token
jj_ntk    1
jj_gen   0
for  int i   0  i < 24  i    jj_la1    1
for  int i   0  i < jj_2_rtns length  i    jj_2_rtns   new jjcalls
public void reinit charstream stream
token_source reinit stream
token   new token
jj_ntk    1
jj_gen   0
for  int i   0  i < 24  i    jj_la1    1
for  int i   0  i < jj_2_rtns length  i    jj_2_rtns   new jjcalls
public precedencequeryparser precedencequeryparsertokenmanager tm
token_source   tm
token   new token
jj_ntk    1
jj_gen   0
for  int i   0  i < 24  i    jj_la1    1
for  int i   0  i < jj_2_rtns length  i    jj_2_rtns   new jjcalls
public void reinit precedencequeryparsertokenmanager tm
token_source   tm
token   new token
jj_ntk    1
jj_gen   0
for  int i   0  i < 24  i    jj_la1    1
for  int i   0  i < jj_2_rtns length  i    jj_2_rtns   new jjcalls
final private token jj_consume_token int kind  throws parseexception
token oldtoken
if   oldtoken   token  next    null  token   token next
else token   token next   token_source getnexttoken
jj_ntk    1
if  token kind    kind
jj_gen
if    jj_gc > 100
jj_gc   0
for  int i   0  i < jj_2_rtns length  i
jjcalls c   jj_2_rtns
while  c    null
if  c gen < jj_gen  c first   null
c   c next
return token
token   oldtoken
jj_kind   kind
throw generateparseexception
static private final class lookaheadsuccess extends java lang error
final private lookaheadsuccess jj_ls   new lookaheadsuccess
final private boolean jj_scan_token int kind
if  jj_scanpos    jj_lastpos
jj_la
if  jj_scanpos next    null
jj_lastpos   jj_scanpos   jj_scanpos next   token_source getnexttoken
else
jj_lastpos   jj_scanpos   jj_scanpos next
else
jj_scanpos   jj_scanpos next
if  jj_rescan
int i   0  token tok   token
while  tok    null    tok    jj_scanpos    i    tok   tok next
if  tok    null  jj_add_error_token kind  i
if  jj_scanpos kind    kind  return true
if  jj_la    0    jj_scanpos    jj_lastpos  throw jj_ls
return false
final public token getnexttoken
if  token next    null  token   token next
else token   token next   token_source getnexttoken
jj_ntk    1
jj_gen
return token
final public token gettoken int index
token t   lookingahead ? jj_scanpos   token
for  int i   0  i < index  i
if  t next    null  t   t next
else t   t next   token_source getnexttoken
return t
final private int jj_ntk
if   jj_nt token next     null
return  jj_ntk    token next token_source getnexttoken    kind
else
return  jj_ntk   jj_nt kind
private java util vector jj_expentries   new java util vector
private int jj_expentry
private int jj_kind    1
private int jj_lasttokens   new int
private int jj_endpos
private void jj_add_error_token int kind  int pos
if  pos >  100  return
if  pos    jj_endpos   1
jj_lasttokens   kind
else if  jj_endpos    0
jj_expentry   new int
for  int i   0  i < jj_endpos  i
jj_expentry   jj_lasttokens
boolean exists   false
for  java util enumeration e   jj_expentries elements    e hasmoreelements
int oldentry    int  e nextelement
if  oldentry length    jj_expentry length
exists   true
for  int i   0  i < jj_expentry length  i
if  oldentry    jj_expentry
exists   false
break
if  exists  break
if   exists  jj_expentries addelement jj_expentry
if  pos    0  jj_lasttokens   kind
public parseexception generateparseexception
jj_expentries removeallelements
boolean la1tokens   new boolean
for  int i   0  i < 32  i
la1tokens   false
if  jj_kind >  0
la1tokens   true
jj_kind    1
for  int i   0  i < 24  i
if  jj_la1    jj_gen
for  int j   0  j < 32  j
if   jj_la1_0    1<<j      0
la1tokens   true
for  int i   0  i < 32  i
if  la1tokens
jj_expentry   new int
jj_expentry   i
jj_expentries addelement jj_expentry
jj_endpos   0
jj_rescan_token
jj_add_error_token 0  0
int exptokseq   new int
for  int i   0  i < jj_expentries size    i
exptokseq    int jj_expentries elementat i
return new parseexception token  exptokseq  tokenimage
final public void enable_tracing
final public void disable_tracing
final private void jj_rescan_token
jj_rescan   true
for  int i   0  i < 1  i
jjcalls p   jj_2_rtns
do
if  p gen > jj_gen
jj_la   p arg  jj_lastpos   jj_scanpos   p first
switch  i
case 0  jj_3_1    break
p   p next
while  p    null
jj_rescan   false
final private void jj_save int index  int xla
jjcalls p   jj_2_rtns
while  p gen > jj_gen
if  p next    null    p   p next   new jjcalls    break
p   p next
p gen   jj_gen   xla   jj_la  p first   token  p arg   xla
static final class jjcalls
int gen
token first
int arg
jjcalls next