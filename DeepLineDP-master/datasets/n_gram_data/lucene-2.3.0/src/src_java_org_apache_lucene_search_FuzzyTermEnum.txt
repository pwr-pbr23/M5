package org apache lucene search
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene index indexreader
import org apache lucene index term
import java io ioexception
/** subclass of filteredtermenum for enumerating all terms that are similiar
* to the specified filter term.
*
* <p>term enumerations are always ordered by term.compareto().  each term in
* the enumeration is greater than all that precede it.
*/
public final class fuzzytermenum extends filteredtermenum
/* this should be somewhere around the average long word.
* if it is longer, we waste time and space. if it is shorter, we waste a
* little bit of time growing the array as we encounter longer words.
*/
private static final int typical_longest_word_in_index   19
/* allows us save time required to create a new array
* everytime similarity is called.
*/
private int d
private float similarity
private boolean endenum   false
private term searchterm   null
private final string field
private final string text
private final string prefix
private final float minimumsimilarity
private final float scale_factor
private final int maxdistances   new int
/**
* creates a fuzzytermenum with an empty prefix and a minsimilarity of 0.5f.
* <p>
* after calling the constructor the enumeration is already pointing to the first
* valid term if such a term exists.
*
* @param reader
* @param term
* @throws ioexception
* @see #fuzzytermenum(indexreader, term, float, int)
*/
public fuzzytermenum indexreader reader  term term  throws ioexception
this reader  term  fuzzyquery defaultminsimilarity  fuzzyquery defaultprefixlength
/**
* creates a fuzzytermenum with an empty prefix.
* <p>
* after calling the constructor the enumeration is already pointing to the first
* valid term if such a term exists.
*
* @param reader
* @param term
* @param minsimilarity
* @throws ioexception
* @see #fuzzytermenum(indexreader, term, float, int)
*/
public fuzzytermenum indexreader reader  term term  float minsimilarity  throws ioexception
this reader  term  minsimilarity  fuzzyquery defaultprefixlength
/**
* constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of
* length <code>prefixlength</code> with <code>term</code> and which have a fuzzy similarity &gt;
* <code>minsimilarity</code>.
* <p>
* after calling the constructor the enumeration is already pointing to the first
* valid term if such a term exists.
*
* @param reader delivers terms.
* @param term pattern term.
* @param minsimilarity minimum required similarity for terms from the reader. default value is 0.5f.
* @param prefixlength length of required common prefix. default value is 0.
* @throws ioexception
*/
public fuzzytermenum indexreader reader  term term  final float minsimilarity  final int prefixlength  throws ioexception
super
if  minsimilarity >  1 0f
throw new illegalargumentexception
else if  minsimilarity < 0 0f
throw new illegalargumentexception
if prefixlength < 0
throw new illegalargumentexception
this minimumsimilarity   minsimilarity
this scale_factor   1 0f    1 0f   minimumsimilarity
this searchterm   term
this field   searchterm field
//the prefix could be longer than the word.
//it's kind of silly though.  it means we must match the entire word.
final int fullsearchtermlength   searchterm text   length
final int realprefixlength   prefixlength > fullsearchtermlength ? fullsearchtermlength   prefixlength
this text   searchterm text   substring realprefixlength
this prefix   searchterm text   substring 0  realprefixlength
initializemaxdistances
this d   initdistancearray
setenum reader terms new term searchterm field    prefix
/**
* the termcompare method in fuzzytermenum uses levenshtein distance to
* calculate the distance between the given term and the comparing term.
*/
protected final boolean termcompare term term
if  field    term field      term text   startswith prefix
final string target   term text   substring prefix length
this similarity   similarity target
return  similarity > minimumsimilarity
endenum   true
return false
public final float difference
return  float   similarity   minimumsimilarity    scale_factor
public final boolean endenum
return endenum
/******************************
* compute levenshtein distance
******************************/
/**
* finds and returns the smallest of three integers
*/
private static final int min int a  int b  int c
final int t    a < b  ? a   b
return  t < c  ? t   c
private final int initdistancearray
return new int
/**
* <p>similarity returns a number that is 1.0f or less (including negative numbers)
* based on how similar the term is compared to a target term.  it returns
* exactly 0.0f when
* <pre>
*    editdistance &lt; maximumeditdistance</pre>
* otherwise it returns:
* <pre>
*    1 - (editdistance / length)</pre>
* where length is the length of the shortest term (text or target) including a
* prefix that are identical and editdistance is the levenshtein distance for
* the two words.</p>
*
* <p>embedded within this algorithm is a fail-fast levenshtein distance
* algorithm.  the fail-fast algorithm differs from the standard levenshtein
* distance algorithm in that it is aborted if it is discovered that the
* mimimum distance between the words is greater than some threshold.
*
* <p>to calculate the maximum distance threshold we use the following formula:
* <pre>
*     (1 - minimumsimilarity) * length</pre>
* where length is the shortest term including any prefix that is not part of the
* similarity comparision.  this formula was derived by solving for what maximum value
* of distance returns false for the following statements:
* <pre>
*   similarity = 1 - ((float)distance / (float) (prefixlength + math.min(textlen, targetlen)));
*   return (similarity > minimumsimilarity);</pre>
* where distance is the levenshtein distance for the two words.
* </p>
* <p>levenshtein distance (also known as edit distance) is a measure of similiarity
* between two strings where the distance is measured as the number of character
* deletions, insertions or substitutions required to transform one string to
* the other string.
* @param target the target word or phrase
* @return the similarity,  0.0 or less indicates that it matches less than the required
* threshold and 1.0 indicates that the text and target are identical
*/
private synchronized final float similarity final string target
final int m   target length
final int n   text length
if  n    0
//we don't have anything to compare.  that means if we just add
//the letters for m we get the new word
return prefix length      0 ? 0 0f   1 0f     float  m   prefix length
if  m    0
return prefix length      0 ? 0 0f   1 0f     float  n   prefix length
final int maxdistance   getmaxdistance m
if  maxdistance < math abs m n
//just adding the characters of m to n or vice-versa results in
//too many edits
//for example "pre" length is 3 and "prefixes" length is 8.  we can see that
//given this optimal circumstance, the edit distance cannot be less than 5.
//which is 8-3 or more precisesly math.abs(3-8).
//if our maximum edit distance is 4, then we can discard this word
//without looking at it.
return 0 0f
//let's make sure we have enough room in our array to do the distance calculations.
if  d length <  m
growdistancearray m
// init matrix d
for  int i   0  i <  n  i    d   i
for  int j   0  j <  m  j    d   j
// start computing edit distance
for  int i   1  i <  n  i
int bestpossibleeditdistance   m
final char s_i   text charat i   1
for  int j   1  j <  m  j
if  s_i    target charat j 1
d   min d  d  d  1
else
d   min d 1  d 1  d
bestpossibleeditdistance   math min bestpossibleeditdistance  d
//after calculating row i, the best possible edit distance
//can be found by found by finding the smallest value in a given column.
//if the bestpossibleeditdistance is greater than the max distance, abort.
if  i > maxdistance    bestpossibleeditdistance > maxdistance       equal is okay  but not greater
//the closest the target can be to the text is just too far away.
//this target is leaving the party early.
return 0 0f
// this will return less than 0.0 when the edit distance is
// greater than the number of characters in the shorter word.
// but this was the formula that was previously used in fuzzytermenum,
// so it has not been changed (even though minimumsimilarity must be
// greater than 0.0)
return 1 0f     float d    float   prefix length     math min n  m
/**
* grow the second dimension of the array, so that we can calculate the
* levenshtein difference.
*/
private void growdistancearray int m
for  int i   0  i < d length  i
d   new int
/**
* the max distance is the maximum levenshtein distance for the text
* compared to some other value that results in score that is
* better than the minimum similarity.
* @param m the length of the "other value"
* @return the maximum levenshtein distance that we care about
*/
private final int getmaxdistance int m
return  m < maxdistances length  ? maxdistances   calculatemaxdistance m
private void initializemaxdistances
for  int i   0  i < maxdistances length  i
maxdistances   calculatemaxdistance i
private int calculatemaxdistance int m
return  int    1 minimumsimilarity     math min text length    m    prefix length
public void close   throws ioexception
super close       call super close   and let the garbage collector do its work