package org apache lucene index
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene store directory
import org apache lucene store indexoutput
import org apache lucene store indexinput
import java util linkedlist
import java util hashset
import java util iterator
import java io ioexception
/**
* combines multiple files into a single compound file.
* the file format:<br>
* <ul>
*     <li>vint filecount</li>
*     <li>{directory}
*         filecount entries with the following structure:</li>
*         <ul>
*             <li>long dataoffset</li>
*             <li>string filename</li>
*         </ul>
*     <li>{file data}
*         filecount entries with the raw data of the corresponding file</li>
* </ul>
*
* the filecount integer indicates how many files are contained in this compound
* file. the {directory} that follows has that many entries. each directory entry
* contains a long pointer to the start of this file's data section, and a string
* with that file's name.
*
*
* @version $id$
*/
final class compoundfilewriter
private static final class fileentry
/** source file */
string file
/** temporary holder for the start of directory entry for this file */
long directoryoffset
/** temporary holder for the start of this file's data section */
long dataoffset
private directory directory
private string filename
private hashset ids
private linkedlist entries
private boolean merged   false
private segmentmerger checkabort checkabort
/** create the compound stream in the specified file. the file name is the
*  entire name (no extensions are added).
*  @throws nullpointerexception if <code>dir</code> or <code>name</code> is null
*/
public compoundfilewriter directory dir  string name
this dir  name  null
compoundfilewriter directory dir  string name  segmentmerger checkabort checkabort
if  dir    null
throw new nullpointerexception
if  name    null
throw new nullpointerexception
this checkabort   checkabort
directory   dir
filename   name
ids   new hashset
entries   new linkedlist
/** returns the directory of the compound file. */
public directory getdirectory
return directory
/** returns the name of the compound file. */
public string getname
return filename
/** add a source stream. <code>file</code> is the string by which the
*  sub-stream will be known in the compound stream.
*
*  @throws illegalstateexception if this writer is closed
*  @throws nullpointerexception if <code>file</code> is null
*  @throws illegalargumentexception if a file with the same name
*   has been added already
*/
public void addfile string file
if  merged
throw new illegalstateexception
if  file    null
throw new nullpointerexception
if    ids add file
throw new illegalargumentexception
file
fileentry entry   new fileentry
entry file   file
entries add entry
/** merge files with the extensions added up to now.
*  all files with these extensions are combined sequentially into the
*  compound stream. after successful merge, the source files
*  are deleted.
*  @throws illegalstateexception if close() had been called before or
*   if no file has been added to this object
*/
public void close   throws ioexception
if  merged
throw new illegalstateexception
if  entries isempty
throw new illegalstateexception
merged   true
// open the compound stream
indexoutput os   null
try
os   directory createoutput filename
// write the number of entries
os writevint entries size
// write the directory with all offsets at 0.
// remember the positions of directory entries so that we can
// adjust the offsets later
iterator it   entries iterator
while it hasnext
fileentry fe    fileentry  it next
fe directoryoffset   os getfilepointer
os writelong 0         for now
os writestring fe file
// open the files and copy their data into the stream.
// remember the locations of each file's data section.
byte buffer   new byte
it   entries iterator
while it hasnext
fileentry fe    fileentry  it next
fe dataoffset   os getfilepointer
copyfile fe  os  buffer
// write the data offsets into the directory of the compound stream
it   entries iterator
while it hasnext
fileentry fe    fileentry  it next
os seek fe directoryoffset
os writelong fe dataoffset
// close the output stream. set the os to null before trying to
// close so that if an exception occurs during the close, the
// finally clause below will not attempt to close the stream
// the second time.
indexoutput tmp   os
os   null
tmp close
finally
if  os    null  try   os close      catch  ioexception e
/** copy the contents of the file with specified extension into the
*  provided output stream. use the provided buffer for moving data
*  to reduce memory allocation.
*/
private void copyfile fileentry source  indexoutput os  byte buffer
throws ioexception
indexinput is   null
try
long startptr   os getfilepointer
is   directory openinput source file
long length   is length
long remainder   length
int chunk   buffer length
while remainder > 0
int len    int  math min chunk  remainder
is readbytes buffer  0  len
os writebytes buffer  len
remainder    len
if  checkabort    null
// roughly every 2 mb we will check if
// it's time to abort
checkabort work 80
// verify that remainder is 0
if  remainder    0
throw new ioexception
remainder
source file       length
chunk
// verify that the output length diff is equal to original file
long endptr   os getfilepointer
long diff   endptr   startptr
if  diff    length
throw new ioexception
diff
length
finally
if  is    null  is close