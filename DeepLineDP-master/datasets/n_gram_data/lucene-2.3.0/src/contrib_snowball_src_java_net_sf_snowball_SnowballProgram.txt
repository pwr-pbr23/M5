package net sf snowball
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java lang reflect invocationtargetexception
public class snowballprogram
protected snowballprogram
current   new stringbuffer
setcurrent
}
/**
* set the current string.
*/
public void setcurrent string value
current replace 0  current length    value
cursor   0
limit   current length
limit_backward   0
bra   cursor
ket   limit
}
/**
* get the current string.
*/
public string getcurrent
return current tostring
}
// current string
protected stringbuffer current
protected int cursor
protected int limit
protected int limit_backward
protected int bra
protected int ket
protected void copy_from snowballprogram other
current            other current
cursor             other cursor
limit              other limit
limit_backward     other limit_backward
bra                other bra
ket                other ket
}
protected boolean in_grouping char  s  int min  int max
if  cursor >  limit  return false
char ch   current charat cursor
if  ch > max    ch < min  return false
ch    min
if   s    0x1 <<  ch   0x7       0  return false
cursor
return true
}
protected boolean in_grouping_b char  s  int min  int max
if  cursor <  limit_backward  return false
char ch   current charat cursor   1
if  ch > max    ch < min  return false
ch    min
if   s    0x1 <<  ch   0x7       0  return false
cursor
return true
}
protected boolean out_grouping char  s  int min  int max
if  cursor >  limit  return false
char ch   current charat cursor
if  ch > max    ch < min
cursor
return true
}
ch    min
if   s    0x1 <<  ch   0x7       0
cursor
return true
}
return false
}
protected boolean out_grouping_b char  s  int min  int max
if  cursor <  limit_backward  return false
char ch   current charat cursor   1
if  ch > max    ch < min
cursor
return true
}
ch    min
if   s    0x1 <<  ch   0x7       0
cursor
return true
}
return false
}
protected boolean in_range int min  int max
if  cursor >  limit  return false
char ch   current charat cursor
if  ch > max    ch < min  return false
cursor
return true
}
protected boolean in_range_b int min  int max
if  cursor <  limit_backward  return false
char ch   current charat cursor   1
if  ch > max    ch < min  return false
cursor
return true
}
protected boolean out_range int min  int max
if  cursor >  limit  return false
char ch   current charat cursor
if    ch > max    ch < min   return false
cursor
return true
}
protected boolean out_range_b int min  int max
if  cursor <  limit_backward  return false
char ch   current charat cursor   1
if   ch > max    ch < min   return false
cursor
return true
}
protected boolean eq_s int s_size  string s
if  limit   cursor < s_size  return false
int i
for  i   0  i    s_size  i
if  current charat cursor   i     s charat i   return false
}
cursor    s_size
return true
}
protected boolean eq_s_b int s_size  string s
if  cursor   limit_backward < s_size  return false
int i
for  i   0  i    s_size  i
if  current charat cursor   s_size   i     s charat i   return false
}
cursor    s_size
return true
}
protected boolean eq_v stringbuffer s
return eq_s s length    s tostring
}
protected boolean eq_v_b stringbuffer s
return eq_s_b s length    s tostring
}
protected int find_among among v  int v_size
int i   0
int j   v_size
int c   cursor
int l   limit
int common_i   0
int common_j   0
boolean first_key_inspected   false
while true
int k   i     j   i  >> 1
int diff   0
int common   common_i < common_j ? common_i   common_j     smaller
among w   v
int i2
for  i2   common  i2 < w s_size  i2
if  c   common    l
diff    1
break
}
diff   current charat c   common    w s charat i2
if  diff    0  break
common
}
if  diff < 0
j   k
common_j   common
else
i   k
common_i   common
}
if  j   i <  1
if  i > 0  break     v >s has been inspected
if  j    i  break     only one item in v
// - but now we need to go round once more to get
// v->s inspected. this looks messy, but is actually
// the optimal approach.
if  first_key_inspected  break
first_key_inspected   true
}
}
while true
among w   v
if  common_i >  w s_size
cursor   c   w s_size
if  w method    null  return w result
boolean res
try
object resobj   w method invoke w methodobject
new object
res   resobj tostring   equals
catch  invocationtargetexception e
res   false
// fixme - debug message
catch  illegalaccessexception e
res   false
// fixme - debug message
}
cursor   c   w s_size
if  res  return w result
}
i   w substring_i
if  i < 0  return 0
}
}
// find_among_b is for backwards processing. same comments apply
protected int find_among_b among v  int v_size
int i   0
int j   v_size
int c   cursor
int lb   limit_backward
int common_i   0
int common_j   0
boolean first_key_inspected   false
while true
int k   i     j   i  >> 1
int diff   0
int common   common_i < common_j ? common_i   common_j
among w   v
int i2
for  i2   w s_size   1   common  i2 >  0  i2
if  c   common    lb
diff    1
break
}
diff   current charat c   1   common    w s charat i2
if  diff    0  break
common
}
if  diff < 0
j   k
common_j   common
else
i   k
common_i   common
}
if  j   i <  1
if  i > 0  break
if  j    i  break
if  first_key_inspected  break
first_key_inspected   true
}
}
while true
among w   v
if  common_i >  w s_size
cursor   c   w s_size
if  w method    null  return w result
boolean res
try
object resobj   w method invoke w methodobject
new object
res   resobj tostring   equals
catch  invocationtargetexception e
res   false
// fixme - debug message
catch  illegalaccessexception e
res   false
// fixme - debug message
}
cursor   c   w s_size
if  res  return w result
}
i   w substring_i
if  i < 0  return 0
}
}
/* to replace chars between c_bra and c_ket in current by the
* chars in s.
*/
protected int replace_s int c_bra  int c_ket  string s
int adjustment   s length      c_ket   c_bra
current replace bra  ket  s
limit    adjustment
if  cursor >  c_ket  cursor    adjustment
else if  cursor > c_bra  cursor   c_bra
return adjustment
}
protected void slice_check
if  bra < 0
bra > ket
ket > limit
limit > current length         this line could be removed
system err println
// fixme: report error somehow.
/*
fprintf(stderr, "faulty slice operation:\n");
debug(z, -1, 0);
exit(1);
*/
}
}
protected void slice_from string s
slice_check
replace_s bra  ket  s
}
protected void slice_from stringbuffer s
slice_from s tostring
}
protected void slice_del
slice_from
}
protected void insert int c_bra  int c_ket  string s
int adjustment   replace_s c_bra  c_ket  s
if  c_bra <  bra  bra    adjustment
if  c_bra <  ket  ket    adjustment
}
protected void insert int c_bra  int c_ket  stringbuffer s
insert c_bra  c_ket  s tostring
}
/* copy the slice into the supplied stringbuffer */
protected stringbuffer slice_to stringbuffer s
slice_check
int len   ket   bra
s replace 0  s length    current substring bra  ket
return s
}
protected stringbuffer assign_to stringbuffer s
s replace 0  s length    current substring 0  limit
return s
}
/*
extern void debug(struct sn_env * z, int number, int line_count)
{   int i;
int limit = size(z->p);
//if (number >= 0) printf("%3d (line %4d): '", number, line_count);
if (number >= 0) printf("%3d (line %4d): [%d]'", number, line_count,limit);
for (i = 0; i <= limit; i++)
{   if (z->lb == i) printf("{");
if (z->bra == i) printf("[");
if (z->c == i) printf("|");
if (z->ket == i) printf("]");
if (z->l == i) printf("}");
if (i < limit)
{   int ch = z->p[i];
if (ch == 0) ch = '#';
printf("%c", ch);
}
}
printf("'\n");
}
*/