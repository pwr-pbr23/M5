package org apache lucene benchmark standard
import org apache lucene analysis analyzer
import org apache lucene analysis standard standardanalyzer
import org apache lucene benchmark abstractbenchmarker
import org apache lucene benchmark benchmarkoptions
import org apache lucene benchmark benchmarker
import org apache lucene benchmark stats querydata
import org apache lucene benchmark stats testdata
import org apache lucene benchmark stats testrundata
import org apache lucene benchmark stats timedata
import org apache lucene document datetools
import org apache lucene document document
import org apache lucene document field
import org apache lucene index indexreader
import org apache lucene index indexwriter
import org apache lucene queryparser queryparser
import org apache lucene search hits
import org apache lucene search indexsearcher
import org apache lucene search query
import org apache lucene store fsdirectory
import java io
import java text dateformat
import java text simpledateformat
import java util
/**
* copyright 2005 the apache software foundation
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
/**
*  reads in the reuters collection, downloaded from http://www.daviddlewis.com/resources/testcollections/reuters21578/reuters21578.tar.gz
* in the workingdir/reuters and indexes them using the {@link org.apache.lucene.analysis.standard.standardanalyzer}
*<p/>
* runs a standard set of documents through an indexer and then runs a standard set of queries against the index.
*
* @see org.apache.lucene.benchmark.standard.standardbenchmarker#benchmark(java.io.file, org.apache.lucene.benchmark.benchmarkoptions)
*
* @deprecated use the bytask code instead. see http://lucene.zones.apache.org:8080/hudson/job/lucene-nightly/javadoc/org/apache/lucene/benchmark/bytask/package-summary.html .
**/
public class standardbenchmarker extends abstractbenchmarker implements benchmarker
public static final string source_dir
public static final string index_dir
//30-mar-1987 14:22:36.87
private static dateformat format   new simpledateformat   locale us
//dateformat.getdatetimeinstance(dateformat.medium, dateformat.short);
static
format setlenient true
public standardbenchmarker
public testdata  benchmark file workingdir  benchmarkoptions opts  throws exception
standardoptions options    standardoptions  opts
workingdir mkdirs
file sourcedir   getsourcedirectory workingdir
sourcedir mkdirs
file indexdir   new file workingdir  index_dir
indexdir mkdirs
analyzer a   new standardanalyzer
list querylist   new arraylist 20
querylist addall arrays aslist reutersqueries standard_queries
querylist addall arrays aslist reutersqueries getprebuiltqueries
query qs   createqueries querylist  a
// here you can limit the set of query benchmarks
querydata qds   querydata getall qs
// here you can narrow down the set of test parameters
testdata params   testdata gettestdataminmaxmergeandmaxbuffered new file sourcedir    jumbodir     new analyzer a     testdata getall new file sourcedir  jumbodir   new analyzer a
system out println     params length
for  int i   0  i < params length  i
try
reset indexdir
params setdirectory fsdirectory getdirectory indexdir
params setqueries qds
system out println params
runbenchmark params  options
// here you can collect and output the rundata for further processing.
system out println params showrundata params getid
//bench.runsearchbenchmark(queries, dir);
params getdirectory   close
system runfinalization
system gc
catch  exception e
e printstacktrace
system out println     e getmessage
//break;
return params
protected file getsourcedirectory file workingdir
return new file workingdir  source_dir
/**
* run benchmark using supplied parameters.
*
* @param params benchmark parameters
* @throws exception
*/
protected void runbenchmark testdata params  standardoptions options  throws exception
system out println     new date
int runcount   options getruncount
for  int i   0  i < runcount  i
testrundata trd   new testrundata
trd startrun
trd setid string valueof i
indexwriter iw   new indexwriter params getdirectory    params getanalyzer    true
iw setmergefactor params getmergefactor
iw setmaxbuffereddocs params getmaxbuffereddocs
iw setusecompoundfile params iscompound
makeindex trd  params getsource    iw  true  true  false  options
if  params isoptimize
timedata td   new timedata
trd adddata td
td start
iw optimize
td stop
trd adddata td
iw close
querydata queries   params getqueries
if  queries    null
indexreader ir   null
indexsearcher searcher   null
for  int k   0  k < queries length  k
querydata qd   queries
if  ir    null    qd reopen
searcher close
ir close
ir   null
searcher   null
if  ir    null
ir   indexreader open params getdirectory
searcher   new indexsearcher ir
document doc   null
if  qd warmup
timedata td   new timedata qd id
for  int m   0  m < ir maxdoc    m
td start
if  ir isdeleted m
td stop
continue
doc   ir document m
td stop
trd adddata td
timedata td   new timedata qd id
td start
hits h   searcher search qd q
//system.out.println("hits size: " + h.length() + " query: " + qd.q);
td stop
trd adddata td
td   new timedata qd id
if  h    null    h length   > 0
for  int m   0  m < h length    m
td start
int id   h id m
if  qd retrieve
doc   ir document id
td stop
trd adddata td
try
if  searcher    null
searcher close
catch  exception e
try
if  ir    null
ir close
catch  exception e
trd endrun
params getrundata   add trd
//system.out.println(params[i].showrundata(params[i].getid()));
//params.showrundata(params.getid());
system out println     new date
/**
* parse the reuters sgml and index:
* date, title, dateline, body
*
*
*
* @param in        input file
* @return lucene document
*/
protected document makedocument file in  string tags  boolean stored  boolean tokenized  boolean tfv
throws exception
document doc   new document
// tag this document
if  tags    null
for  int i   0  i < tags length  i
doc add new field     i  tags  stored    true ? field store yes   field store no
tokenized    true ? field index tokenized   field index un_tokenized  tfv    true ? field termvector yes   field termvector no
doc add new field    in getcanonicalpath    stored    true ? field store yes   field store no
tokenized    true ? field index tokenized   field index un_tokenized  tfv    true ? field termvector yes   field termvector no
bufferedreader reader   new bufferedreader new filereader in
string line   null
//first line is the date, 3rd is the title, rest is body
string datestr   reader readline
reader readline     skip an empty line
string title   reader readline
reader readline     skip an empty line
stringbuffer body   new stringbuffer 1024
while   line   reader readline       null
body append line  append
reader close
date date   format parse datestr trim
doc add new field    datetools datetostring date  datetools resolution second   field store yes  field index un_tokenized
if  title    null
doc add new field    title  stored    true ? field store yes   field store no
tokenized    true ? field index tokenized   field index un_tokenized  tfv    true ? field termvector yes   field termvector no
if  body length   > 0
doc add new field    body tostring    stored    true ? field store yes   field store no
tokenized    true ? field index tokenized   field index un_tokenized  tfv    true ? field termvector yes   field termvector no
return doc
/**
* make index, and collect time data.
*
* @param trd       run data to populate
* @param srcdir    directory with source files
* @param iw        index writer, already open
* @param stored    store values of fields
* @param tokenized tokenize fields
* @param tfv       store term vectors
* @throws exception
*/
protected void makeindex testrundata trd  file srcdir  indexwriter iw  boolean stored  boolean tokenized
boolean tfv  standardoptions options  throws exception
//file[] groups = srcdir.listfiles();
list files   new arraylist
getallfiles srcdir  null  files
document doc   null
long cnt   0l
timedata td   new timedata
td name
int scaleup   options getscaleup
int logstep   options getlogstep
int max   math min files size    options getmaximumdocumentstoindex
for  int s   0  s < scaleup  s
string tags   new string srcdir getname         s
int i   0
for  iterator iterator   files iterator    iterator hasnext      i < max  i
file file    file  iterator next
doc   makedocument file  tags  stored  tokenized  tfv
td start
iw adddocument doc
td stop
cnt
if  cnt % logstep    0
system err println     cnt       trd getid
trd adddata td
td reset
trd adddata td
public static void getallfiles file srcdir  filefilter filter  list allfiles
file  files   srcdir listfiles filter
for  int i   0  i < files length  i
file file   files
if  file isdirectory
getallfiles file  filter  allfiles
else
allfiles add file
/**
* parse the strings containing lucene queries.
*
* @param qs array of strings containing query expressions
* @param a  analyzer to use when parsing queries
* @return array of lucene queries
*/
public static query createqueries list qs  analyzer a
queryparser qp   new queryparser    a
list queries   new arraylist
for  int i   0  i < qs size    i
try
object query   qs get i
query q   null
if  query instanceof string
q   qp parse  string  query
else if  query instanceof query
q    query  query
else
system err println     query
if  q    null
queries add q
catch  exception e
e printstacktrace
return  query  queries toarray new query
/**
* remove existing index.
*
* @throws exception
*/
protected void reset file indexdir  throws exception
if  indexdir exists
fullydelete indexdir
indexdir mkdirs
/**
* save a stream to a file.
*
* @param is         input stream
* @param out        output file
* @param closeinput if true, close the input stream when done.
* @throws exception
*/
protected void savestream inputstream is  file out  boolean closeinput  throws exception
byte buf   new byte
fileoutputstream fos   new fileoutputstream out
int len   0
long total   0l
long time   system currenttimemillis
long delta   time
while   len   is read buf   > 0
fos write buf  0  len
total    len
time   system currenttimemillis
if  time   delta > 5000
system err println     total   1024
delta   time
fos flush
fos close
if  closeinput
is close