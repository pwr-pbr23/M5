package org apache lucene index
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene document document
import org apache lucene document fieldselector
import org apache lucene search similarity
import org apache lucene store
import java io file
import java io fileoutputstream
import java io ioexception
import java util arrays
import java util collection
/** indexreader is an abstract class, providing an interface for accessing an
index.  search of an index is done entirely through this abstract interface,
so that any subclass which implements it is searchable.
<p> concrete subclasses of indexreader are usually constructed with a call to
one of the static <code>open()</code> methods, e.g. {@link #open(string)}.
<p> for efficiency, in this api documents are often referred to via
<i>document numbers</i>, non-negative integers which each name a unique
document in the index.  these document numbers are ephemeral--they may change
as documents are added to and deleted from an index.  clients should thus not
rely on a given document having the same number between sessions.
<p> an indexreader can be opened on a directory for which an indexwriter is
opened already, but it cannot be used to delete documents from the index then.
<p>
note: for backwards api compatibility, several methods are not listed
as abstract, but have no useful implementations in this base class and
instead always throw unsupportedoperationexception.  subclasses are
strongly encouraged to override these methods, but in many cases may not
need to.
</p>
@version $id$
*/
public abstract class indexreader
/**
* constants describing field properties, for example used for
* {@link indexreader#getfieldnames(fieldoption)}.
*/
public static final class fieldoption
private string option
private fieldoption
private fieldoption string option
this option   option
public string tostring
return this option
/** all fields */
public static final fieldoption all   new fieldoption
/** all indexed fields */
public static final fieldoption indexed   new fieldoption
/** all fields that store payloads */
public static final fieldoption stores_payloads   new fieldoption
/** all fields which are not indexed */
public static final fieldoption unindexed   new fieldoption
/** all fields which are indexed with termvectors enabled */
public static final fieldoption indexed_with_termvector   new fieldoption
/** all fields which are indexed but don't have termvectors enabled */
public static final fieldoption indexed_no_termvector   new fieldoption
/** all fields with termvectors enabled. please note that only standard termvector fields are returned */
public static final fieldoption termvector   new fieldoption
/** all fields with termvectors with position values enabled */
public static final fieldoption termvector_with_position   new fieldoption
/** all fields with termvectors with offset values enabled */
public static final fieldoption termvector_with_offset   new fieldoption
/** all fields with termvectors with offset values and position values enabled */
public static final fieldoption termvector_with_position_offset   new fieldoption
private boolean closed
protected boolean haschanges
private volatile int refcount
// for testing
synchronized int getrefcount
return refcount
/**
* increments the refcount of this indexreader instance. refcounts are used to determine
* when a reader can be closed safely, i. e. as soon as no other indexreader is referencing
* it anymore.
*/
protected synchronized void incref
assert refcount > 0
refcount
/**
* decreases the refcount of this indexreader instance. if the refcount drops
* to 0, then pending changes are committed to the index and this reader is closed.
*
* @throws ioexception in case an ioexception occurs in commit() or doclose()
*/
protected synchronized void decref   throws ioexception
assert refcount > 0
if  refcount    1
commit
doclose
refcount
/**
* @deprecated will be deleted when indexreader(directory) is deleted
* @see #directory()
*/
private directory directory
/**
* legacy constructor for backwards compatibility.
*
* <p>
* this constructor should not be used, it exists for backwards
* compatibility only to support legacy subclasses that did not "own"
* a specific directory, but needed to specify something to be returned
* by the directory() method.  future subclasses should delegate to the
* no arg constructor and implement the directory() method as appropriate.
*
* @param directory directory to be returned by the directory() method
* @see #directory()
* @deprecated - use indexreader()
*/
protected indexreader directory directory
this
this directory   directory
protected indexreader
refcount   1
/**
* @throws alreadyclosedexception if this indexreader is closed
*/
protected final void ensureopen   throws alreadyclosedexception
if  refcount <  0
throw new alreadyclosedexception
/** returns an indexreader reading the index in an fsdirectory in the named
path.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
* @param path the path to the index directory */
public static indexreader open string path  throws corruptindexexception  ioexception
return open fsdirectory getdirectory path   true  null
/** returns an indexreader reading the index in an fsdirectory in the named
* path.
* @param path the path to the index directory
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static indexreader open file path  throws corruptindexexception  ioexception
return open fsdirectory getdirectory path   true  null
/** returns an indexreader reading the index in the given directory.
* @param directory the index directory
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static indexreader open final directory directory  throws corruptindexexception  ioexception
return open directory  false  null
/** expert: returns an indexreader reading the index in the given
* directory, with a custom {@link indexdeletionpolicy}.
* @param directory the index directory
* @param deletionpolicy a custom deletion policy (only used
*  if you use this reader to perform deletes or to set
*  norms); see {@link indexwriter} for details.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static indexreader open final directory directory  indexdeletionpolicy deletionpolicy  throws corruptindexexception  ioexception
return open directory  false  deletionpolicy
private static indexreader open final directory directory  final boolean closedirectory  final indexdeletionpolicy deletionpolicy  throws corruptindexexception  ioexception
return directoryindexreader open directory  closedirectory  deletionpolicy
/**
* refreshes an indexreader if the index has changed since this instance
* was (re)opened.
* <p>
* opening an indexreader is an expensive operation. this method can be used
* to refresh an existing indexreader to reduce these costs. this method
* tries to only load segments that have changed or were created after the
* indexreader was (re)opened.
* <p>
* if the index has not changed since this instance was (re)opened, then this
* call is a noop and returns this instance. otherwise, a new instance is
* returned. the old instance is <b>not</b> closed and remains usable.<br>
* <b>note:</b> the re-opened reader instance and the old instance might share
* the same resources. for this reason no index modification operations
* (e. g. {@link #deletedocument(int)}, {@link #setnorm(int, string, byte)})
* should be performed using one of the readers until the old reader instance
* is closed. <b>otherwise, the behavior of the readers is undefined.</b>
* <p>
* you can determine whether a reader was actually reopened by comparing the
* old instance with the instance returned by this method:
* <pre>
* indexreader reader = ...
* ...
* indexreader new = r.reopen();
* if (new != reader) {
*   ...     // reader was reopened
*   reader.close();
* }
* reader = new;
* ...
* </pre>
*
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public synchronized indexreader reopen   throws corruptindexexception  ioexception
throw new unsupportedoperationexception
/**
* returns the directory associated with this index.  the default
* implementation returns the directory specified by subclasses when
* delegating to the indexreader(directory) constructor, or throws an
* unsupportedoperationexception if one was not specified.
* @throws unsupportedoperationexception if no directory
*/
public directory directory
ensureopen
if  null    directory
return directory
else
throw new unsupportedoperationexception
/**
* returns the time the index in the named directory was last modified.
* do not use this to check whether the reader is still up-to-date, use
* {@link #iscurrent()} instead.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static long lastmodified string directory  throws corruptindexexception  ioexception
return lastmodified new file directory
/**
* returns the time the index in the named directory was last modified.
* do not use this to check whether the reader is still up-to-date, use
* {@link #iscurrent()} instead.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static long lastmodified file filedirectory  throws corruptindexexception  ioexception
return   long  new segmentinfos findsegmentsfile filedirectory
public object dobody string segmentfilename
return new long fsdirectory filemodified filedirectory  segmentfilename
run    longvalue
/**
* returns the time the index in the named directory was last modified.
* do not use this to check whether the reader is still up-to-date, use
* {@link #iscurrent()} instead.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static long lastmodified final directory directory2  throws corruptindexexception  ioexception
return   long  new segmentinfos findsegmentsfile directory2
public object dobody string segmentfilename  throws ioexception
return new long directory2 filemodified segmentfilename
run    longvalue
/**
* reads version number from segments files. the version number is
* initialized with a timestamp and then increased by one for each change of
* the index.
*
* @param directory where the index resides.
* @return version number.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static long getcurrentversion string directory  throws corruptindexexception  ioexception
return getcurrentversion new file directory
/**
* reads version number from segments files. the version number is
* initialized with a timestamp and then increased by one for each change of
* the index.
*
* @param directory where the index resides.
* @return version number.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static long getcurrentversion file directory  throws corruptindexexception  ioexception
directory dir   fsdirectory getdirectory directory
long version   getcurrentversion dir
dir close
return version
/**
* reads version number from segments files. the version number is
* initialized with a timestamp and then increased by one for each change of
* the index.
*
* @param directory where the index resides.
* @return version number.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public static long getcurrentversion directory directory  throws corruptindexexception  ioexception
return segmentinfos readcurrentversion directory
/**
* version number when this indexreader was opened. not implemented in the indexreader base class.
* @throws unsupportedoperationexception unless overridden in subclass
*/
public long getversion
throw new unsupportedoperationexception
/**<p>for indexreader implementations that use
* terminfosreader to read terms, this sets the
* indexdivisor to subsample the number of indexed terms
* loaded into memory.  this has the same effect as {@link
* indexwriter#settermindexinterval} except that setting
* must be done at indexing time while this setting can be
* set per reader.  when set to n, then one in every
* n*termindexinterval terms in the index is loaded into
* memory.  by setting this to a value > 1 you can reduce
* memory usage, at the expense of higher latency when
* loading a terminfo.  the default value is 1.</p>
*
* <b>note:</b> you must call this before the term
* index is loaded.  if the index is already loaded,
* an illegalstateexception is thrown.
* @throws illegalstateexception if the term index has already been loaded into memory
*/
public void setterminfosindexdivisor int indexdivisor  throws illegalstateexception
throw new unsupportedoperationexception
/** <p>for indexreader implementations that use
*  terminfosreader to read terms, this returns the
*  current indexdivisor.
*  @see #setterminfosindexdivisor */
public int getterminfosindexdivisor
throw new unsupportedoperationexception
/**
* check whether this indexreader is still using the
* current (i.e., most recently committed) version of the
* index.  if a writer has committed any changes to the
* index since this reader was opened, this will return
* <code>false</code>, in which case you must open a new
* indexreader in order to see the changes.  see the
* description of the <a href="indexwriter.html#autocommit"><code>autocommit</code></a>
* flag which controls when the {@link indexwriter}
* actually commits changes to the index.
*
* <p>
* not implemented in the indexreader base class.
* </p>
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
* @throws unsupportedoperationexception unless overridden in subclass
*/
public boolean iscurrent   throws corruptindexexception  ioexception
throw new unsupportedoperationexception
/**
* checks is the index is optimized (if it has a single segment and
* no deletions).  not implemented in the indexreader base class.
* @return <code>true</code> if the index is optimized; <code>false</code> otherwise
* @throws unsupportedoperationexception unless overridden in subclass
*/
public boolean isoptimized
throw new unsupportedoperationexception
/**
*  return an array of term frequency vectors for the specified document.
*  the array contains a vector for each vectorized field in the document.
*  each vector contains terms and frequencies for all terms in a given vectorized field.
*  if no such fields existed, the method returns null. the term vectors that are
* returned my either be of type termfreqvector or of type termpositionsvector if
* positions or offsets have been stored.
*
* @param docnumber document for which term frequency vectors are returned
* @return array of term frequency vectors. may be null if no term vectors have been
*  stored for the specified document.
* @throws ioexception if index cannot be accessed
* @see org.apache.lucene.document.field.termvector
*/
abstract public termfreqvector gettermfreqvectors int docnumber
throws ioexception
/**
*  return a term frequency vector for the specified document and field. the
*  returned vector contains terms and frequencies for the terms in
*  the specified field of this document, if the field had the storetermvector
*  flag set. if termvectors had been stored with positions or offsets, a
*  termpositionsvector is returned.
*
* @param docnumber document for which the term frequency vector is returned
* @param field field for which the term frequency vector is returned.
* @return term frequency vector may be null if field does not exist in the specified
* document or term vector was not stored.
* @throws ioexception if index cannot be accessed
* @see org.apache.lucene.document.field.termvector
*/
abstract public termfreqvector gettermfreqvector int docnumber  string field
throws ioexception
/**
* load the term vector into a user-defined data structure instead of relying on the parallel arrays of
* the {@link termfreqvector}.
* @param docnumber the number of the document to load the vector for
* @param field the name of the field to load
* @param mapper the {@link termvectormapper} to process the vector.  must not be null
* @throws ioexception if term vectors cannot be accessed or if they do not exist on the field and doc. specified.
*
*/
abstract public void gettermfreqvector int docnumber  string field  termvectormapper mapper  throws ioexception
/**
* map all the term vectors for all fields in a document
* @param docnumber the number of the document to load the vector for
* @param mapper the {@link termvectormapper} to process the vector.  must not be null
* @throws ioexception if term vectors cannot be accessed or if they do not exist on the field and doc. specified.
*/
abstract public void gettermfreqvector int docnumber  termvectormapper mapper  throws ioexception
/**
* returns <code>true</code> if an index exists at the specified directory.
* if the directory does not exist or if there is no index in it.
* <code>false</code> is returned.
* @param  directory the directory to check for an index
* @return <code>true</code> if an index exists; <code>false</code> otherwise
*/
public static boolean indexexists string directory
return indexexists new file directory
/**
* returns <code>true</code> if an index exists at the specified directory.
* if the directory does not exist or if there is no index in it.
* @param  directory the directory to check for an index
* @return <code>true</code> if an index exists; <code>false</code> otherwise
*/
public static boolean indexexists file directory
return segmentinfos getcurrentsegmentgeneration directory list        1
/**
* returns <code>true</code> if an index exists at the specified directory.
* if the directory does not exist or if there is no index in it.
* @param  directory the directory to check for an index
* @return <code>true</code> if an index exists; <code>false</code> otherwise
* @throws ioexception if there is a problem with accessing the index
*/
public static boolean indexexists directory directory  throws ioexception
return segmentinfos getcurrentsegmentgeneration directory      1
/** returns the number of documents in this index. */
public abstract int numdocs
/** returns one greater than the largest possible document number.
* this may be used to, e.g., determine how big to allocate an array which
* will have an element for every document number in an index.
*/
public abstract int maxdoc
/** returns the stored fields of the <code>n</code><sup>th</sup>
<code>document</code> in this index.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public document document int n  throws corruptindexexception  ioexception
ensureopen
return document n  null
/**
* get the {@link org.apache.lucene.document.document} at the <code>n</code><sup>th</sup> position. the {@link org.apache.lucene.document.fieldselector}
* may be used to determine what {@link org.apache.lucene.document.field}s to load and how they should be loaded.
*
* <b>note:</b> if this reader (more specifically, the underlying <code>fieldsreader</code>) is closed before the lazy {@link org.apache.lucene.document.field} is
* loaded an exception may be thrown.  if you want the value of a lazy {@link org.apache.lucene.document.field} to be available after closing you must
* explicitly load it or fetch the document again with a new loader.
*
*
* @param n get the document at the <code>n</code><sup>th</sup> position
* @param fieldselector the {@link org.apache.lucene.document.fieldselector} to use to determine what fields should be loaded on the document.  may be null, in which case all fields will be loaded.
* @return the stored fields of the {@link org.apache.lucene.document.document} at the nth position
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*
* @see org.apache.lucene.document.fieldable
* @see org.apache.lucene.document.fieldselector
* @see org.apache.lucene.document.setbasedfieldselector
* @see org.apache.lucene.document.loadfirstfieldselector
*/
//when we convert to jdk 1.5 make this set<string>
public abstract document document int n  fieldselector fieldselector  throws corruptindexexception  ioexception
/** returns true if document <i>n</i> has been deleted */
public abstract boolean isdeleted int n
/** returns true if any documents have been deleted */
public abstract boolean hasdeletions
/** returns true if there are norms stored for this field. */
public boolean hasnorms string field  throws ioexception
// backward compatible implementation.
// segmentreader has an efficient implementation.
ensureopen
return norms field     null
/** returns the byte-encoded normalization factor for the named field of
* every document.  this is used by the search code to score documents.
*
* @see org.apache.lucene.document.field#setboost(float)
*/
public abstract byte norms string field  throws ioexception
/** reads the byte-encoded normalization factor for the named field of every
*  document.  this is used by the search code to score documents.
*
* @see org.apache.lucene.document.field#setboost(float)
*/
public abstract void norms string field  byte bytes  int offset
throws ioexception
/** expert: resets the normalization factor for the named field of the named
* document.  the norm represents the product of the field's {@link
* org.apache.lucene.document.fieldable#setboost(float) boost} and its {@link similarity#lengthnorm(string,
* int) length normalization}.  thus, to preserve the length normalization
* values when resetting this, one should base the new value upon the old.
*
* @see #norms(string)
* @see similarity#decodenorm(byte)
* @throws stalereaderexception if the index has changed
*  since this reader was opened
* @throws corruptindexexception if the index is corrupt
* @throws lockobtainfailedexception if another writer
*  has this index open (<code>write.lock</code> could not
*  be obtained)
* @throws ioexception if there is a low-level io error
*/
public final synchronized  void setnorm int doc  string field  byte value
throws stalereaderexception  corruptindexexception  lockobtainfailedexception  ioexception
ensureopen
acquirewritelock
haschanges   true
dosetnorm doc  field  value
/** implements setnorm in subclass.*/
protected abstract void dosetnorm int doc  string field  byte value
throws corruptindexexception  ioexception
/** expert: resets the normalization factor for the named field of the named
* document.
*
* @see #norms(string)
* @see similarity#decodenorm(byte)
*
* @throws stalereaderexception if the index has changed
*  since this reader was opened
* @throws corruptindexexception if the index is corrupt
* @throws lockobtainfailedexception if another writer
*  has this index open (<code>write.lock</code> could not
*  be obtained)
* @throws ioexception if there is a low-level io error
*/
public void setnorm int doc  string field  float value
throws stalereaderexception  corruptindexexception  lockobtainfailedexception  ioexception
ensureopen
setnorm doc  field  similarity encodenorm value
/** returns an enumeration of all the terms in the index. the
* enumeration is ordered by term.compareto(). each term is greater
* than all that precede it in the enumeration. note that after
* calling terms(), {@link termenum#next()} must be called
* on the resulting enumeration before calling other methods such as
* {@link termenum#term()}.
* @throws ioexception if there is a low-level io error
*/
public abstract termenum terms   throws ioexception
/** returns an enumeration of all terms starting at a given term. if
* the given term does not exist, the enumeration is positioned at the
* first term greater than the supplied therm. the enumeration is
* ordered by term.compareto(). each term is greater than all that
* precede it in the enumeration.
* @throws ioexception if there is a low-level io error
*/
public abstract termenum terms term t  throws ioexception
/** returns the number of documents containing the term <code>t</code>.
* @throws ioexception if there is a low-level io error
*/
public abstract int docfreq term t  throws ioexception
/** returns an enumeration of all the documents which contain
* <code>term</code>. for each document, the document number, the frequency of
* the term in that document is also provided, for use in search scoring.
* thus, this method implements the mapping:
* <p><ul>
* term &nbsp;&nbsp; =&gt; &nbsp;&nbsp; &lt;docnum, freq&gt;<sup>*</sup>
* </ul>
* <p>the enumeration is ordered by document number.  each document number
* is greater than all that precede it in the enumeration.
* @throws ioexception if there is a low-level io error
*/
public termdocs termdocs term term  throws ioexception
ensureopen
termdocs termdocs   termdocs
termdocs seek term
return termdocs
/** returns an unpositioned {@link termdocs} enumerator.
* @throws ioexception if there is a low-level io error
*/
public abstract termdocs termdocs   throws ioexception
/** returns an enumeration of all the documents which contain
* <code>term</code>.  for each document, in addition to the document number
* and frequency of the term in that document, a list of all of the ordinal
* positions of the term in the document is available.  thus, this method
* implements the mapping:
*
* <p><ul>
* term &nbsp;&nbsp; =&gt; &nbsp;&nbsp; &lt;docnum, freq,
* &lt;pos<sub>1</sub>, pos<sub>2</sub>, ...
* pos<sub>freq-1</sub>&gt;
* &gt;<sup>*</sup>
* </ul>
* <p> this positional information facilitates phrase and proximity searching.
* <p>the enumeration is ordered by document number.  each document number is
* greater than all that precede it in the enumeration.
* @throws ioexception if there is a low-level io error
*/
public termpositions termpositions term term  throws ioexception
ensureopen
termpositions termpositions   termpositions
termpositions seek term
return termpositions
/** returns an unpositioned {@link termpositions} enumerator.
* @throws ioexception if there is a low-level io error
*/
public abstract termpositions termpositions   throws ioexception
/** deletes the document numbered <code>docnum</code>.  once a document is
* deleted it will not appear in termdocs or termpostitions enumerations.
* attempts to read its field with the {@link #document}
* method will result in an error.  the presence of this document may still be
* reflected in the {@link #docfreq} statistic, though
* this will be corrected eventually as the index is further modified.
*
* @throws stalereaderexception if the index has changed
* since this reader was opened
* @throws corruptindexexception if the index is corrupt
* @throws lockobtainfailedexception if another writer
*  has this index open (<code>write.lock</code> could not
*  be obtained)
* @throws ioexception if there is a low-level io error
*/
public final synchronized void deletedocument int docnum  throws stalereaderexception  corruptindexexception  lockobtainfailedexception  ioexception
ensureopen
acquirewritelock
haschanges   true
dodelete docnum
/** implements deletion of the document numbered <code>docnum</code>.
* applications should call {@link #deletedocument(int)} or {@link #deletedocuments(term)}.
*/
protected abstract void dodelete int docnum  throws corruptindexexception  ioexception
/** deletes all documents that have a given <code>term</code> indexed.
* this is useful if one uses a document field to hold a unique id string for
* the document.  then to delete such a document, one merely constructs a
* term with the appropriate field and the unique id string as its text and
* passes it to this method.
* see {@link #deletedocument(int)} for information about when this deletion will
* become effective.
*
* @return the number of documents deleted
* @throws stalereaderexception if the index has changed
*  since this reader was opened
* @throws corruptindexexception if the index is corrupt
* @throws lockobtainfailedexception if another writer
*  has this index open (<code>write.lock</code> could not
*  be obtained)
* @throws ioexception if there is a low-level io error
*/
public final int deletedocuments term term  throws stalereaderexception  corruptindexexception  lockobtainfailedexception  ioexception
ensureopen
termdocs docs   termdocs term
if  docs    null  return 0
int n   0
try
while  docs next
deletedocument docs doc
n
finally
docs close
return n
/** undeletes all documents currently marked as deleted in this index.
*
* @throws stalereaderexception if the index has changed
*  since this reader was opened
* @throws lockobtainfailedexception if another writer
*  has this index open (<code>write.lock</code> could not
*  be obtained)
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public final synchronized void undeleteall   throws stalereaderexception  corruptindexexception  lockobtainfailedexception  ioexception
ensureopen
acquirewritelock
haschanges   true
doundeleteall
/** implements actual undeleteall() in subclass. */
protected abstract void doundeleteall   throws corruptindexexception  ioexception
/** does nothing by default. subclasses that require a write lock for
*  index modifications must implement this method. */
protected synchronized void acquirewritelock   throws ioexception
/* noop */
/**
*
* @throws ioexception
*/
public final synchronized void flush   throws ioexception
ensureopen
commit
/**
* commit changes resulting from delete, undeleteall, or
* setnorm operations
*
* if an exception is hit, then either no changes or all
* changes will have been committed to the index
* (transactional semantics).
* @throws ioexception if there is a low-level io error
*/
protected final synchronized void commit   throws ioexception
if haschanges
docommit
haschanges   false
/** implements commit. */
protected abstract void docommit   throws ioexception
/**
* closes files associated with this index.
* also saves any new deletions to disk.
* no other methods should be called after this has been called.
* @throws ioexception if there is a low-level io error
*/
public final synchronized void close   throws ioexception
if   closed
decref
closed   true
/** implements close. */
protected abstract void doclose   throws ioexception
/**
* get a list of unique field names that exist in this index and have the specified
* field option information.
* @param fldoption specifies which field option should be available for the returned fields
* @return collection of strings indicating the names of the fields.
* @see indexreader.fieldoption
*/
public abstract collection getfieldnames fieldoption fldoption
/**
* returns <code>true</code> iff the index in the named directory is
* currently locked.
* @param directory the directory to check for a lock
* @throws ioexception if there is a low-level io error
*/
public static boolean islocked directory directory  throws ioexception
return
directory makelock indexwriter write_lock_name  islocked
/**
* returns <code>true</code> iff the index in the named directory is
* currently locked.
* @param directory the directory to check for a lock
* @throws ioexception if there is a low-level io error
*/
public static boolean islocked string directory  throws ioexception
directory dir   fsdirectory getdirectory directory
boolean result   islocked dir
dir close
return result
/**
* forcibly unlocks the index in the named directory.
* <p>
* caution: this should only be used by failure recovery code,
* when it is known that no other process nor thread is in fact
* currently accessing this index.
*/
public static void unlock directory directory  throws ioexception
directory makelock indexwriter write_lock_name  release
/**
* prints the filename and size of each file within a given compound file.
* add the -extract flag to extract files to the current working directory.
* in order to make the extracted version of the index work, you have to copy
* the segments file from the compound index into the directory where the extracted files are stored.
* @param args usage: org.apache.lucene.index.indexreader [-extract] &lt;cfsfile&gt;
*/
public static void main string  args
string filename   null
boolean extract   false
for  int i   0  i < args length    i
if  args equals
extract   true
else if  filename    null
filename   args
if  filename    null
system out println
return
directory dir   null
compoundfilereader cfr   null
try
file file   new file filename
string dirname   file getabsolutefile   getparent
filename   file getname
dir   fsdirectory getdirectory dirname
cfr   new compoundfilereader dir  filename
string  files   cfr list
arrays sort files        sort the array of filename so that the output is more readable
for  int i   0  i < files length    i
long len   cfr filelength files
if  extract
system out println     files       len
indexinput ii   cfr openinput files
fileoutputstream f   new fileoutputstream files
// read and write with a small buffer, which is more effectiv than reading byte by byte
byte buffer   new byte
int chunk   buffer length
while len > 0
final int buflen    int  math min chunk  len
ii readbytes buffer  0  buflen
f write buffer  0  buflen
len    buflen
f close
ii close
else
system out println files       len
catch  ioexception ioe
ioe printstacktrace
finally
try
if  dir    null
dir close
if  cfr    null
cfr close
catch  ioexception ioe
ioe printstacktrace