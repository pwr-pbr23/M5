package org apache lucene index
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import org apache lucene store directory
import org apache lucene store lock
import org apache lucene store lockobtainfailedexception
/**
* indexreader implementation that has access to a directory.
* instances that have a segmentinfos object (i. e. segmentinfos != null)
* "own" the directory, which means that they try to acquire a write lock
* whenever index modifications are performed.
*/
abstract class directoryindexreader extends indexreader
protected directory directory
protected boolean closedirectory
private indexdeletionpolicy deletionpolicy
private segmentinfos segmentinfos
private lock writelock
private boolean stale
/** used by commit() to record pre-commit state in case
* rollback is necessary */
private boolean rollbackhaschanges
private segmentinfos rollbacksegmentinfos
void init directory directory  segmentinfos segmentinfos  boolean closedirectory
this directory   directory
this segmentinfos   segmentinfos
this closedirectory   closedirectory
protected directoryindexreader
directoryindexreader directory directory  segmentinfos segmentinfos
boolean closedirectory
super
init directory  segmentinfos  closedirectory
static directoryindexreader open final directory directory  final boolean closedirectory  final indexdeletionpolicy deletionpolicy  throws corruptindexexception  ioexception
return  directoryindexreader  new segmentinfos findsegmentsfile directory
protected object dobody string segmentfilename  throws corruptindexexception  ioexception
segmentinfos infos   new segmentinfos
infos read directory  segmentfilename
directoryindexreader reader
if  infos size      1                index is optimized
reader   segmentreader get infos  infos info 0   closedirectory
else
reader   new multisegmentreader directory  infos  closedirectory
reader setdeletionpolicy deletionpolicy
return reader
run
public final synchronized indexreader reopen   throws corruptindexexception  ioexception
ensureopen
if  this haschanges    this iscurrent
// the index hasn't changed - nothing to do here
return this
return  directoryindexreader  new segmentinfos findsegmentsfile directory
protected object dobody string segmentfilename  throws corruptindexexception  ioexception
segmentinfos infos   new segmentinfos
infos read directory  segmentfilename
directoryindexreader newreader   doreopen infos
if  directoryindexreader this    newreader
newreader init directory  infos  closedirectory
newreader deletionpolicy   deletionpolicy
return newreader
run
/**
* re-opens the index using the passed-in segmentinfos
*/
protected abstract directoryindexreader doreopen segmentinfos infos  throws corruptindexexception  ioexception
public void setdeletionpolicy indexdeletionpolicy deletionpolicy
this deletionpolicy   deletionpolicy
/** returns the directory this index resides in.
*/
public directory directory
ensureopen
return directory
/**
* version number when this indexreader was opened.
*/
public long getversion
ensureopen
return segmentinfos getversion
/**
* check whether this indexreader is still using the
* current (i.e., most recently committed) version of the
* index.  if a writer has committed any changes to the
* index since this reader was opened, this will return
* <code>false</code>, in which case you must open a new
* indexreader in order to see the changes.  see the
* description of the <a href="indexwriter.html#autocommit"><code>autocommit</code></a>
* flag which controls when the {@link indexwriter}
* actually commits changes to the index.
*
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public boolean iscurrent   throws corruptindexexception  ioexception
ensureopen
return segmentinfos readcurrentversion directory     segmentinfos getversion
/**
* checks is the index is optimized (if it has a single segment and no deletions)
* @return <code>true</code> if the index is optimized; <code>false</code> otherwise
*/
public boolean isoptimized
ensureopen
return segmentinfos size      1    hasdeletions      false
protected void doclose   throws ioexception
if closedirectory
directory close
/**
* commit changes resulting from delete, undeleteall, or
* setnorm operations
*
* if an exception is hit, then either no changes or all
* changes will have been committed to the index
* (transactional semantics).
* @throws ioexception if there is a low-level io error
*/
protected void docommit   throws ioexception
if haschanges
if  segmentinfos    null
// default deleter (for backwards compatibility) is
// keeponlylastcommitdeleter:
indexfiledeleter deleter    new indexfiledeleter directory
deletionpolicy    null ? new keeponlylastcommitdeletionpolicy     deletionpolicy
segmentinfos  null  null
// checkpoint the state we are about to change, in
// case we have to roll back:
startcommit
boolean success   false
try
commitchanges
segmentinfos write directory
success   true
finally
if   success
// rollback changes that were made to
// segmentinfos but failed to get [fully]
// committed.  this way this reader instance
// remains consistent (matched to what's
// actually in the index):
rollbackcommit
// recompute deletable files & remove them (so
// partially written .del files, etc, are
// removed):
deleter refresh
// have the deleter remove any now unreferenced
// files due to this commit:
deleter checkpoint segmentinfos  true
if  writelock    null
writelock release        release write lock
writelock   null
else
commitchanges
haschanges   false
protected abstract void commitchanges   throws ioexception
/**
* tries to acquire the writelock on this directory.
* this method is only valid if this indexreader is directory owner.
*
* @throws stalereaderexception if the index has changed
* since this reader was opened
* @throws corruptindexexception if the index is corrupt
* @throws lockobtainfailedexception if another writer
*  has this index open (<code>write.lock</code> could not
*  be obtained)
* @throws ioexception if there is a low-level io error
*/
protected void acquirewritelock   throws stalereaderexception  corruptindexexception  lockobtainfailedexception  ioexception
if  segmentinfos    null
ensureopen
if  stale
throw new stalereaderexception
if  writelock    null
lock writelock   directory makelock indexwriter write_lock_name
if   writelock obtain indexwriter write_lock_timeout      obtain write lock
throw new lockobtainfailedexception     writelock
this writelock   writelock
// we have to check whether index has changed since this reader was opened.
// if so, this reader is no longer valid for deletion
if  segmentinfos readcurrentversion directory  > segmentinfos getversion
stale   true
this writelock release
this writelock   null
throw new stalereaderexception
/**
* should internally checkpoint state that will change
* during commit so that we can rollback if necessary.
*/
void startcommit
if  segmentinfos    null
rollbacksegmentinfos    segmentinfos  segmentinfos clone
rollbackhaschanges   haschanges
/**
* rolls back state to just before the commit (this is
* called by commit() if there is some exception while
* committing).
*/
void rollbackcommit
if  segmentinfos    null
for int i 0 i<segmentinfos size   i
// rollback each segmentinfo.  because the
// segmentreader holds a reference to the
// segmentinfo we can't [easily] just replace
// segmentinfos, so we reset it in place instead:
segmentinfos info i  reset rollbacksegmentinfos info i
rollbacksegmentinfos   null
haschanges   rollbackhaschanges
/** release the write lock, if needed. */
protected void finalize   throws throwable
try
if  writelock    null
writelock release                              release write lock
writelock   null
finally
super finalize