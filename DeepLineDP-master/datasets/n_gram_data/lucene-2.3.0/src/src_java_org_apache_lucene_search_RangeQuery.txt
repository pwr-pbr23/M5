package org apache lucene search
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import org apache lucene index term
import org apache lucene index termenum
import org apache lucene index indexreader
import org apache lucene util tostringutils
/**
* a query that matches documents within an exclusive range. a rangequery
* is built by queryparser for input like <code>[010 to 120]</code> but only if the queryparser has
* the useoldrangequery property set to true. the queryparser default behaviour is to use
* the newer constantscorerangequery class. this is generally preferable because:
* <ul>
* 	<li>it is faster than rangequery</li>
* 	<li>unlike rangequery, it does not cause a booleanquery.toomanyclauses exception if the range of values is large</li>
* 	<li>unlike rangequery it does not influence scoring based on the scarcity of individual terms that may match</li>
* </ul>
*
*
* @see constantscorerangequery
*
*
* @version $id$
*/
public class rangequery extends query
private term lowerterm
private term upperterm
private boolean inclusive
/** constructs a query selecting all terms greater than
* <code>lowerterm</code> but less than <code>upperterm</code>.
* there must be at least one term and either term may be null,
* in which case there is no bound on that side, but if there are
* two terms, both terms <b>must</b> be for the same field.
*/
public rangequery term lowerterm  term upperterm  boolean inclusive
if  lowerterm    null    upperterm    null
throw new illegalargumentexception
if  lowerterm    null    upperterm    null    lowerterm field      upperterm field
throw new illegalargumentexception
// if we have a lowerterm, start there. otherwise, start at beginning
if  lowerterm    null
this lowerterm   lowerterm
else
this lowerterm   new term upperterm field
this upperterm   upperterm
this inclusive   inclusive
public query rewrite indexreader reader  throws ioexception
booleanquery query   new booleanquery true
termenum enumerator   reader terms lowerterm
try
boolean checklower   false
if   inclusive     make adjustments to set to exclusive
checklower   true
string testfield   getfield
do
term term   enumerator term
if  term    null    term field      testfield       interned comparison
if   checklower    term text   compareto lowerterm text    > 0
checklower   false
if  upperterm    null
int compare   upperterm text   compareto term text
/* if beyond the upper term, or is exclusive and
* this is equal to the upper term, break out */
if   compare < 0       inclusive    compare    0
break
termquery tq   new termquery term      found a match
tq setboost getboost        set the boost
query add tq  booleanclause occur should      add to query
else
break
while  enumerator next
finally
enumerator close
return query
/** returns the field name for this query */
public string getfield
return  lowerterm    null ? lowerterm field     upperterm field
/** returns the lower term of this range query */
public term getlowerterm     return lowerterm
/** returns the upper term of this range query */
public term getupperterm     return upperterm
/** returns <code>true</code> if the range query is inclusive */
public boolean isinclusive     return inclusive
/** prints a user-readable version of this query. */
public string tostring string field
stringbuffer buffer   new stringbuffer
if   getfield   equals field
buffer append getfield
buffer append
buffer append inclusive ?
buffer append lowerterm    null ? lowerterm text
buffer append
buffer append upperterm    null ? upperterm text
buffer append inclusive ?
buffer append tostringutils boost getboost
return buffer tostring
/** returns true iff <code>o</code> is equal to this. */
public boolean equals object o
if  this    o  return true
if    o instanceof rangequery   return false
final rangequery other    rangequery  o
if  this getboost      other getboost    return false
if  this inclusive    other inclusive  return false
// one of lowerterm and upperterm can be null
if  this lowerterm    null ?  this lowerterm equals other lowerterm    other lowerterm    null  return false
if  this upperterm    null ?  this upperterm equals other upperterm    other upperterm    null  return false
return true
/** returns a hash code value for this object.*/
public int hashcode
int h   float floattointbits getboost
h ^  lowerterm    null ? lowerterm hashcode     0
// reversible mix to make lower and upper position dependent and
// to prevent them from cancelling out.
h ^   h << 25     h >>> 8
h ^  upperterm    null ? upperterm hashcode     0
h ^  this inclusive ? 0x2742e74a   0
return h