package org apache lucene queryparser
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene analysis analyzer
import org apache lucene search booleanclause
import org apache lucene search booleanquery
import org apache lucene search multiphrasequery
import org apache lucene search phrasequery
import org apache lucene search query
import java util vector
import java util map
/**
* a queryparser which constructs queries to search multiple fields.
*
*
* @version $revision$
*/
public class multifieldqueryparser extends queryparser
protected string fields
protected map      boosts
/**
* creates a multifieldqueryparser.
* allows passing of a map with term to boost, and the boost to apply to each term.
*
* <p>it will, when parse(string query)
* is called, construct a query like this (assuming the query consists of
* two terms and you specify the two fields <code>title</code> and <code>body</code>):</p>
*
* <code>
* (title:term1 body:term1) (title:term2 body:term2)
* </code>
*
* <p>when setdefaultoperator(and_operator) is set, the result will be:</p>
*
* <code>
* +(title:term1 body:term1) +(title:term2 body:term2)
* </code>
*
* <p>when you pass a boost (title=>5 body=>10) you can get </p>
*
* <code>
* +(title:term1^5.0 body:term1^10.0) +(title:term2^5.0 body:term2^10.0)
* </code>
*
* <p>in other words, all the query's terms must appear, but it doesn't matter in
* what fields they appear.</p>
*/
public multifieldqueryparser string fields  analyzer analyzer  map boosts
this fields analyzer
this boosts   boosts
/**
* creates a multifieldqueryparser.
*
* <p>it will, when parse(string query)
* is called, construct a query like this (assuming the query consists of
* two terms and you specify the two fields <code>title</code> and <code>body</code>):</p>
*
* <code>
* (title:term1 body:term1) (title:term2 body:term2)
* </code>
*
* <p>when setdefaultoperator(and_operator) is set, the result will be:</p>
*
* <code>
* +(title:term1 body:term1) +(title:term2 body:term2)
* </code>
*
* <p>in other words, all the query's terms must appear, but it doesn't matter in
* what fields they appear.</p>
*/
public multifieldqueryparser string fields  analyzer analyzer
super null  analyzer
this fields   fields
protected query getfieldquery string field  string querytext  int slop  throws parseexception
if  field    null
vector clauses   new vector
for  int i   0  i < fields length  i
query q   getfieldquery fields  querytext
if  q    null
//if the user passes a map of boosts
if  boosts    null
//get the boost from the map and apply them
float boost    float boosts get fields
if  boost    null
q setboost boost floatvalue
if  q instanceof phrasequery
phrasequery  q  setslop slop
if  q instanceof multiphrasequery
multiphrasequery  q  setslop slop
clauses add new booleanclause q  booleanclause occur should
if  clauses size      0      happens for stopwords
return null
return getbooleanquery clauses  true
return super getfieldquery field  querytext
protected query getfieldquery string field  string querytext  throws parseexception
return getfieldquery field  querytext  0
protected query getfuzzyquery string field  string termstr  float minsimilarity  throws parseexception
if  field    null
vector clauses   new vector
for  int i   0  i < fields length  i
clauses add new booleanclause getfuzzyquery fields  termstr  minsimilarity
booleanclause occur should
return getbooleanquery clauses  true
return super getfuzzyquery field  termstr  minsimilarity
protected query getprefixquery string field  string termstr  throws parseexception
if  field    null
vector clauses   new vector
for  int i   0  i < fields length  i
clauses add new booleanclause getprefixquery fields  termstr
booleanclause occur should
return getbooleanquery clauses  true
return super getprefixquery field  termstr
protected query getwildcardquery string field  string termstr  throws parseexception
if  field    null
vector clauses   new vector
for  int i   0  i < fields length  i
clauses add new booleanclause getwildcardquery fields  termstr
booleanclause occur should
return getbooleanquery clauses  true
return super getwildcardquery field  termstr
protected query getrangequery string field  string part1  string part2  boolean inclusive  throws parseexception
if  field    null
vector clauses   new vector
for  int i   0  i < fields length  i
clauses add new booleanclause getrangequery fields  part1  part2  inclusive
booleanclause occur should
return getbooleanquery clauses  true
return super getrangequery field  part1  part2  inclusive
/**
* parses a query which searches on the fields specified.
* <p>
* if x fields are specified, this effectively constructs:
* <pre>
* <code>
* (field1:query1) (field2:query2) (field3:query3)...(fieldx:queryx)
* </code>
* </pre>
* @param queries queries strings to parse
* @param fields fields to search on
* @param analyzer analyzer to use
* @throws parseexception if query parsing fails
* @throws illegalargumentexception if the length of the queries array differs
*  from the length of the fields array
*/
public static query parse string queries  string fields
analyzer analyzer  throws parseexception
if  queries length    fields length
throw new illegalargumentexception
booleanquery bquery   new booleanquery
for  int i   0  i < fields length  i
queryparser qp   new queryparser fields  analyzer
query q   qp parse queries
if  q  null       q never null  just being defensive
q instanceof booleanquery       booleanquery q  getclauses   length>0
bquery add q  booleanclause occur should
return bquery
/**
* parses a query, searching on the fields specified.
* use this if you need to specify certain fields as required,
* and others as prohibited.
* <p><pre>
* usage:
* <code>
* string[] fields = {"filename", "contents", "description"};
* booleanclause.occur[] flags = {booleanclause.occur.should,
*                booleanclause.occur.must,
*                booleanclause.occur.must_not};
* multifieldqueryparser.parse("query", fields, flags, analyzer);
* </code>
* </pre>
*<p>
* the code above would construct a query:
* <pre>
* <code>
* (filename:query) +(contents:query) -(description:query)
* </code>
* </pre>
*
* @param query query string to parse
* @param fields fields to search on
* @param flags flags describing the fields
* @param analyzer analyzer to use
* @throws parseexception if query parsing fails
* @throws illegalargumentexception if the length of the fields array differs
*  from the length of the flags array
*/
public static query parse string query  string fields
booleanclause occur flags  analyzer analyzer  throws parseexception
if  fields length    flags length
throw new illegalargumentexception
booleanquery bquery   new booleanquery
for  int i   0  i < fields length  i
queryparser qp   new queryparser fields  analyzer
query q   qp parse query
if  q  null       q never null  just being defensive
q instanceof booleanquery       booleanquery q  getclauses   length>0
bquery add q  flags
return bquery
/**
* parses a query, searching on the fields specified.
* use this if you need to specify certain fields as required,
* and others as prohibited.
* <p><pre>
* usage:
* <code>
* string[] query = {"query1", "query2", "query3"};
* string[] fields = {"filename", "contents", "description"};
* booleanclause.occur[] flags = {booleanclause.occur.should,
*                booleanclause.occur.must,
*                booleanclause.occur.must_not};
* multifieldqueryparser.parse(query, fields, flags, analyzer);
* </code>
* </pre>
*<p>
* the code above would construct a query:
* <pre>
* <code>
* (filename:query1) +(contents:query2) -(description:query3)
* </code>
* </pre>
*
* @param queries queries string to parse
* @param fields fields to search on
* @param flags flags describing the fields
* @param analyzer analyzer to use
* @throws parseexception if query parsing fails
* @throws illegalargumentexception if the length of the queries, fields,
*  and flags array differ
*/
public static query parse string queries  string fields  booleanclause occur flags
analyzer analyzer  throws parseexception
if    queries length    fields length    queries length    flags length
throw new illegalargumentexception
booleanquery bquery   new booleanquery
for  int i   0  i < fields length  i
queryparser qp   new queryparser fields  analyzer
query q   qp parse queries
if  q  null       q never null  just being defensive
q instanceof booleanquery       booleanquery q  getclauses   length>0
bquery add q  flags
return bquery