package org apache lucene store
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
/** base implementation class for buffered {@link indexinput}. */
public abstract class bufferedindexinput extends indexinput
/** default buffer size */
public static final int buffer_size   1024
private int buffersize   buffer_size
private byte buffer
private long bufferstart   0 			     position in file of buffer
private int bufferlength   0 			     end of valid bytes
private int bufferposition   0 		     next byte to read
public byte readbyte   throws ioexception
if  bufferposition >  bufferlength
refill
return buffer
public bufferedindexinput
/** inits bufferedindexinput with a specific buffersize */
public bufferedindexinput int buffersize
checkbuffersize buffersize
this buffersize   buffersize
/** change the buffer size used by this indexinput */
public void setbuffersize int newsize
assert buffer    null    buffersize    buffer length
if  newsize    buffersize
checkbuffersize newsize
buffersize   newsize
if  buffer    null
// resize the existing buffer and carefully save as
// many bytes as possible starting from the current
// bufferposition
byte newbuffer   new byte
final int leftinbuffer   bufferlength bufferposition
final int numtocopy
if  leftinbuffer > newsize
numtocopy   newsize
else
numtocopy   leftinbuffer
system arraycopy buffer  bufferposition  newbuffer  0  numtocopy
bufferstart    bufferposition
bufferposition   0
bufferlength   numtocopy
buffer   newbuffer
/** returns buffer size.  @see #setbuffersize */
public int getbuffersize
return buffersize
private void checkbuffersize int buffersize
if  buffersize <  0
throw new illegalargumentexception     buffersize
public void readbytes byte b  int offset  int len  throws ioexception
readbytes b  offset  len  true
public void readbytes byte b  int offset  int len  boolean usebuffer  throws ioexception
if len <   bufferlength bufferposition
// the buffer contains enough data to satisfy this request
if len>0     to allow b to be null if len is 0
system arraycopy buffer  bufferposition  b  offset  len
bufferposition  len
else
// the buffer does not have enough data. first serve all we've got.
int available   bufferlength   bufferposition
if available > 0
system arraycopy buffer  bufferposition  b  offset  available
offset    available
len    available
bufferposition    available
// and now, read the remaining 'len' bytes:
if  usebuffer    len<buffersize
// if the amount left to read is small enough, and
// we are allowed to use our buffer, do it in the usual
// buffered way: fill the buffer and copy from it:
refill
if bufferlength<len
// throw an exception when refill() could not read len bytes:
system arraycopy buffer  0  b  offset  bufferlength
throw new ioexception
else
system arraycopy buffer  0  b  offset  len
bufferposition len
else
// the amount left to read is larger than the buffer
// or we've been asked to not use our buffer -
// there's no performance reason not to read it all
// at once. note that unlike the previous code of
// this function, there is no need to do a seek
// here, because there's no need to reread what we
// had in the buffer.
long after   bufferstart bufferposition len
if after > length
throw new ioexception
readinternal b  offset  len
bufferstart   after
bufferposition   0
bufferlength   0                        trigger refill   on read
private void refill   throws ioexception
long start   bufferstart   bufferposition
long end   start   buffersize
if  end > length   				     don't read past eof
end   length
bufferlength    int  end   start
if  bufferlength <  0
throw new ioexception
if  buffer    null
buffer   new byte 		     allocate buffer lazily
seekinternal bufferstart
readinternal buffer  0  bufferlength
bufferstart   start
bufferposition   0
/** expert: implements buffer refill.  reads bytes from the current position
* in the input.
* @param b the array to read bytes into
* @param offset the offset in the array to start storing bytes
* @param length the number of bytes to read
*/
protected abstract void readinternal byte b  int offset  int length
throws ioexception
public long getfilepointer     return bufferstart   bufferposition
public void seek long pos  throws ioexception
if  pos >  bufferstart    pos <  bufferstart   bufferlength
bufferposition    int  pos   bufferstart       seek within buffer
else
bufferstart   pos
bufferposition   0
bufferlength   0 				     trigger refill   on read
seekinternal pos
/** expert: implements seek.  sets current position in this file, where the
* next {@link #readinternal(byte[],int,int)} will occur.
* @see #readinternal(byte[],int,int)
*/
protected abstract void seekinternal long pos  throws ioexception
public object clone
bufferedindexinput clone    bufferedindexinput super clone
clone buffer   null
clone bufferlength   0
clone bufferposition   0
clone bufferstart   getfilepointer
return clone