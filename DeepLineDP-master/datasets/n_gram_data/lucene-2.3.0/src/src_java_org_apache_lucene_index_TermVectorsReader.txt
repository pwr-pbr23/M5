package org apache lucene index
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene store bufferedindexinput
import org apache lucene store directory
import org apache lucene store indexinput
import java io ioexception
/**
* @version $id$
*/
class termvectorsreader implements cloneable
static final int format_version   2
//the size in bytes that the format_version will take up at the beginning of each file
static final int format_size   4
static final byte store_positions_with_termvector   0x1
static final byte store_offset_with_termvector   0x2
private fieldinfos fieldinfos
private indexinput tvx
private indexinput tvd
private indexinput tvf
private int size
// the docid offset where our docs begin in the index
// file.  this will be 0 if we have our own private file.
private int docstoreoffset
private int tvdformat
private int tvfformat
termvectorsreader directory d  string segment  fieldinfos fieldinfos
throws corruptindexexception  ioexception
this d  segment  fieldinfos  bufferedindexinput buffer_size
termvectorsreader directory d  string segment  fieldinfos fieldinfos  int readbuffersize
throws corruptindexexception  ioexception
this d  segment  fieldinfos  bufferedindexinput buffer_size   1  0
termvectorsreader directory d  string segment  fieldinfos fieldinfos  int readbuffersize  int docstoreoffset  int size
throws corruptindexexception  ioexception
boolean success   false
try
if  d fileexists segment       indexfilenames vectors_index_extension
tvx   d openinput segment       indexfilenames vectors_index_extension  readbuffersize
checkvalidformat tvx
tvd   d openinput segment       indexfilenames vectors_documents_extension  readbuffersize
tvdformat   checkvalidformat tvd
tvf   d openinput segment       indexfilenames vectors_fields_extension  readbuffersize
tvfformat   checkvalidformat tvf
if   1    docstoreoffset
this docstoreoffset   0
this size    int   tvx length   >> 3
else
this docstoreoffset   docstoreoffset
this size   size
// verify the file is long enough to hold all of our
// docs
assert   int   tvx length     8   >  size   docstoreoffset
this fieldinfos   fieldinfos
success   true
finally
// with lock-less commits, it's entirely possible (and
// fine) to hit a filenotfound exception above. in
// this case, we want to explicitly close any subset
// of things that were opened so that we don't have to
// wait for a gc to do so.
if   success
close
private int checkvalidformat indexinput in  throws corruptindexexception  ioexception
int format   in readint
if  format > format_version
throw new corruptindexexception     format
format_version
return format
void close   throws ioexception
// make all effort to close up. keep the first exception
// and throw it as a new one.
ioexception keep   null
if  tvx    null  try   tvx close      catch  ioexception e    if  keep    null  keep   e
if  tvd    null  try   tvd close      catch  ioexception e    if  keep    null  keep   e
if  tvf     null  try    tvf close      catch  ioexception e    if  keep    null  keep   e
if  keep    null  throw  ioexception  keep fillinstacktrace
/**
*
* @return the number of documents in the reader
*/
int size
return size
public void get int docnum  string field  termvectormapper mapper  throws ioexception
if  tvx    null
int fieldnumber   fieldinfos fieldnumber field
//we need to account for the format_size at when seeking in the tvx
//we don't need to do this in other seeks because we already have the
// file pointer
//that was written in another file
tvx seek   docnum   docstoreoffset    8l    format_size
//system.out.println("tvx pointer: " + tvx.getfilepointer());
long position   tvx readlong
tvd seek position
int fieldcount   tvd readvint
//system.out.println("num fields: " + fieldcount);
// there are only a few fields per document. we opt for a full scan
// rather then requiring that they be ordered. we need to read through
// all of the fields anyway to get to the tvf pointers.
int number   0
int found    1
for  int i   0  i < fieldcount  i
if tvdformat    format_version
number   tvd readvint
else
number    tvd readvint
if  number    fieldnumber
found   i
// this field, although valid in the segment, was not found in this
// document
if  found     1
// compute position in the tvf file
position   0
for  int i   0  i <  found  i
position    tvd readvlong
mapper setdocumentnumber docnum
readtermvector field  position  mapper
else
//system.out.println("fieldable not found");
else
//system.out.println("no tvx file");
/**
* retrieve the term vector for the given document and field
* @param docnum the document number to retrieve the vector for
* @param field the field within the document to retrieve
* @return the termfreqvector for the document and field or null if there is no termvector for this field.
* @throws ioexception if there is an error reading the term vector files
*/
termfreqvector get int docnum  string field  throws ioexception
// check if no term vectors are available for this segment at all
parallelarraytermvectormapper mapper   new parallelarraytermvectormapper
get docnum  field  mapper
return mapper materializevector
/**
* return all term vectors stored for this document or null if the could not be read in.
*
* @param docnum the document number to retrieve the vector for
* @return all term frequency vectors
* @throws ioexception if there is an error reading the term vector files
*/
termfreqvector get int docnum  throws ioexception
termfreqvector result   null
if  tvx    null
//we need to offset by
tvx seek   docnum   docstoreoffset    8l    format_size
long position   tvx readlong
tvd seek position
int fieldcount   tvd readvint
// no fields are vectorized for this document
if  fieldcount    0
int number   0
string fields   new string
for  int i   0  i < fieldcount  i
if tvdformat    format_version
number   tvd readvint
else
number    tvd readvint
fields   fieldinfos fieldname number
// compute position in the tvf file
position   0
long tvfpointers   new long
for  int i   0  i < fieldcount  i
position    tvd readvlong
tvfpointers   position
result   readtermvectors docnum  fields  tvfpointers
else
//system.out.println("no tvx file");
return result
public void get int docnumber  termvectormapper mapper  throws ioexception
// check if no term vectors are available for this segment at all
if  tvx    null
//we need to offset by
tvx seek  docnumber   8l    format_size
long position   tvx readlong
tvd seek position
int fieldcount   tvd readvint
// no fields are vectorized for this document
if  fieldcount    0
int number   0
string fields   new string
for  int i   0  i < fieldcount  i
if tvdformat    format_version
number   tvd readvint
else
number    tvd readvint
fields   fieldinfos fieldname number
// compute position in the tvf file
position   0
long tvfpointers   new long
for  int i   0  i < fieldcount  i
position    tvd readvlong
tvfpointers   position
mapper setdocumentnumber docnumber
readtermvectors fields  tvfpointers  mapper
else
//system.out.println("no tvx file");
private segmenttermvector readtermvectors int docnum  string fields  long tvfpointers
throws ioexception
segmenttermvector res   new segmenttermvector
for  int i   0  i < fields length  i
parallelarraytermvectormapper mapper   new parallelarraytermvectormapper
mapper setdocumentnumber docnum
readtermvector fields  tvfpointers  mapper
res    segmenttermvector  mapper materializevector
return res
private void readtermvectors string fields  long tvfpointers  termvectormapper mapper
throws ioexception
for  int i   0  i < fields length  i
readtermvector fields  tvfpointers  mapper
/**
*
* @param field the field to read in
* @param tvfpointer the pointer within the tvf file where we should start reading
* @param mapper the mapper used to map the termvector
* @return the termvector located at that position
* @throws ioexception
*/
private void readtermvector string field  long tvfpointer  termvectormapper mapper
throws ioexception
// now read the data from specified position
//we don't need to offset by the format here since the pointer already includes the offset
tvf seek tvfpointer
int numterms   tvf readvint
//system.out.println("num terms: " + numterms);
// if no terms - return a constant empty termvector. however, this should never occur!
if  numterms    0
return
boolean storepositions
boolean storeoffsets
if tvfformat    format_version
byte bits   tvf readbyte
storepositions    bits   store_positions_with_termvector     0
storeoffsets    bits   store_offset_with_termvector     0
else
tvf readvint
storepositions   false
storeoffsets   false
mapper setexpectations field  numterms  storeoffsets  storepositions
int start   0
int deltalength   0
int totallength   0
char  buffer   new char        init the buffer with a length of 10 character
char previousbuffer
for  int i   0  i < numterms  i
start   tvf readvint
deltalength   tvf readvint
totallength   start   deltalength
if  buffer length < totallength        increase buffer
buffer   null        give a hint to garbage collector
buffer   new char
if  start > 0      just copy if necessary
system arraycopy previousbuffer  0  buffer  0  start
tvf readchars buffer  start  deltalength
string term   new string buffer  0  totallength
previousbuffer   buffer
int freq   tvf readvint
int  positions   null
if  storepositions      read in the positions
//does the mapper even care about positions?
if  mapper isignoringpositions      false
positions   new int
int prevposition   0
for  int j   0  j < freq  j
positions   prevposition   tvf readvint
prevposition   positions
else
//we need to skip over the positions.  since these are vints, i don't believe there is anyway to know for sure how far to skip
//
for  int j   0  j < freq  j
tvf readvint
termvectoroffsetinfo offsets   null
if  storeoffsets
//does the mapper even care about offsets?
if  mapper isignoringoffsets      false
offsets   new termvectoroffsetinfo
int prevoffset   0
for  int j   0  j < freq  j
int startoffset   prevoffset   tvf readvint
int endoffset   startoffset   tvf readvint
offsets   new termvectoroffsetinfo startoffset  endoffset
prevoffset   endoffset
else
for  int j   0  j < freq  j
tvf readvint
tvf readvint
mapper map term  freq  offsets  positions
protected object clone
if  tvx    null    tvd    null    tvf    null
return null
termvectorsreader clone   null
try
clone    termvectorsreader  super clone
catch  clonenotsupportedexception e
clone tvx    indexinput  tvx clone
clone tvd    indexinput  tvd clone
clone tvf    indexinput  tvf clone
return clone
/**
* models the existing parallel array structure
*/
class parallelarraytermvectormapper extends termvectormapper
private string terms
private int termfreqs
private int positions
private termvectoroffsetinfo offsets
private int currentposition
private boolean storingoffsets
private boolean storingpositions
private string field
public void setexpectations string field  int numterms  boolean storeoffsets  boolean storepositions
this field   field
terms   new string
termfreqs   new int
this storingoffsets   storeoffsets
this storingpositions   storepositions
if storepositions
this positions   new int
if storeoffsets
this offsets   new termvectoroffsetinfo
public void map string term  int frequency  termvectoroffsetinfo offsets  int positions
terms   term
termfreqs   frequency
if  storingoffsets
this offsets   offsets
if  storingpositions
this positions   positions
currentposition
/**
* construct the vector
* @return the {@link termfreqvector} based on the mappings.
*/
public termfreqvector materializevector
segmenttermvector tv   null
if  field    null    terms    null
if  storingpositions    storingoffsets
tv   new segmenttermpositionvector field  terms  termfreqs  positions  offsets
else
tv   new segmenttermvector field  terms  termfreqs
return tv