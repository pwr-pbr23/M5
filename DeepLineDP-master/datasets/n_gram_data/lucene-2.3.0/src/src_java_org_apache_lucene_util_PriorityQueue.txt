package org apache lucene util
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
/** a priorityqueue maintains a partial ordering of its elements such that the
least element can always be found in constant time.  put()'s and pop()'s
require log(size) time. */
public abstract class priorityqueue
private int size
private int maxsize
protected object heap
/** determines the ordering of objects in this priority queue.  subclasses
must define this one method. */
protected abstract boolean lessthan object a  object b
/** subclass constructors must call this. */
protected final void initialize int maxsize
size   0
int heapsize
if  0    maxsize
// we allocate 1 extra to avoid if statement in top()
heapsize   2
else
heapsize   maxsize   1
heap   new object
this maxsize   maxsize
/**
* adds an object to a priorityqueue in log(size) time.
* if one tries to add more objects than maxsize from initialize
* a runtimeexception (arrayindexoutofbound) is thrown.
*/
public final void put object element
size
heap   element
upheap
/**
* adds element to the priorityqueue in log(size) time if either
* the priorityqueue is not full, or not lessthan(element, top()).
* @param element
* @return true if element is added, false otherwise.
*/
public boolean insert object element
return insertwithoverflow element     element
/**
* insertwithoverflow() is the same as insert() except its
* return value: it returns the object (if any) that was
* dropped off the heap because it was full. this can be
* the given parameter (in case it is smaller than the
* full heap's minimum, and couldn't be added), or another
* object that was previously the smallest value in the
* heap and now has been replaced by a larger one, or null
* if the queue wasn't yet full with maxsize elements.
*/
public object insertwithoverflow object element
if  size < maxsize
put element
return null
else if  size > 0     lessthan element  heap
object ret   heap
heap   element
adjusttop
return ret
else
return element
/** returns the least element of the priorityqueue in constant time. */
public final object top
// we don't need to check size here: if maxsize is 0,
// then heap is length 2 array with both entries null.
// if size is 0 then heap[1] is already null.
return heap
/** removes and returns the least element of the priorityqueue in log(size)
time. */
public final object pop
if  size > 0
object result   heap 			     save first value
heap   heap 			     move last to first
heap   null 			     permit gc of objects
size
downheap   				     adjust heap
return result
else
return null
/** should be called when the object at top changes values.  still log(n)
* worst case, but it's at least twice as fast to <pre>
*  { pq.top().change(); pq.adjusttop(); }
* </pre> instead of <pre>
*  { o = pq.pop(); o.change(); pq.push(o); }
* </pre>
*/
public final void adjusttop
downheap
/** returns the number of elements currently stored in the priorityqueue. */
public final int size
return size
/** removes all entries from the priorityqueue. */
public final void clear
for  int i   0  i <  size  i
heap   null
size   0
private final void upheap
int i   size
object node   heap 			     save bottom node
int j   i >>> 1
while  j > 0    lessthan node  heap
heap   heap 			     shift parents down
i   j
j   j >>> 1
heap   node 				     install saved node
private final void downheap
int i   1
object node   heap 			     save top node
int j   i << 1 				     find smaller child
int k   j   1
if  k <  size    lessthan heap  heap
j   k
while  j <  size    lessthan heap  node
heap   heap 			     shift up child
i   j
j   i << 1
k   j   1
if  k <  size    lessthan heap  heap
j   k
heap   node 				     install saved node