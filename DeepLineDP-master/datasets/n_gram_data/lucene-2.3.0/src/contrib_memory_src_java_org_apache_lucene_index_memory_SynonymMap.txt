package org apache lucene index memory
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java io inputstream
import java nio bytebuffer
import java nio charset charset
import java util arraylist
import java util arrays
import java util hashmap
import java util iterator
import java util map
import java util treemap
import java util treeset
/**
* loads the <a target="_blank"
* href="http://www.cogsci.princeton.edu/~wn/">wordnet </a> prolog file <a
* href="http://www.cogsci.princeton.edu/2.0/wnprolog-2.0.tar.gz">wn_s.pl </a>
* into a thread-safe main-memory hash map that can be used for fast
* high-frequency lookups of synonyms for any given (lowercase) word string.
* <p>
* there holds: if b is a synonym for a (a -> b) then a is also a synonym for b (b -> a).
* there does not necessarily hold: a -> b, b -> c then a -> c.
* <p>
* loading typically takes some 1.5 secs, so should be done only once per
* (server) program execution, using a singleton pattern. once loaded, a
* synonym lookup via {@link #getsynonyms(string)}takes constant time o(1).
* a loaded default synonym map consumes about 10 mb main memory.
* an instance is immutable, hence thread-safe.
* <p>
* this implementation borrows some ideas from the lucene syns2index demo that
* dave spencer originally contributed to lucene. dave's approach
* involved a persistent lucene index which is suitable for occasional
* lookups or very large synonym tables, but considered unsuitable for
* high-frequency lookups of medium size synonym tables.
* <p>
* example usage:
* <pre>
* string[] words = new string[] { "hard", "woods", "forest", "wolfish", "xxxx"};
* synonymmap map = new synonymmap(new fileinputstream("samples/fulltext/wn_s.pl"));
* for (int i = 0; i &lt; words.length; i++) {
*     string[] synonyms = map.getsynonyms(words[i]);
*     system.out.println(words[i] + ":" + java.util.arrays.aslist(synonyms).tostring());
* }
*
* example output:
* hard:[arduous, backbreaking, difficult, fermented, firmly, grueling, gruelling, heavily, heavy, intemperately, knockout, laborious, punishing, severe, severely, strong, toilsome, tough]
* woods:[forest, wood]
* forest:[afforest, timber, timberland, wood, woodland, woods]
* wolfish:[edacious, esurient, rapacious, ravening, ravenous, voracious, wolflike]
* xxxx:[]
* </pre>
*
* @author whoschek.at.lbl.dot.gov
* @see <a target="_blank"
*      href="http://www.cogsci.princeton.edu/~wn/man/prologdb.5wn.html">prologdb
*      man page </a>
* @see <a target="_blank" href="http://www.hostmon.com/rfc/advanced.jsp">dave's synonym demo site</a>
*/
public class synonymmap
/** the index data; map<string word, string[] synonyms> */
private final hashmap table
private static final string empty   new string
private static final boolean debug   false
/**
* constructs an instance, loading wordnet synonym data from the given input
* stream. finally closes the stream. the words in the stream must be in
* utf-8 or a compatible subset (for example ascii, macroman, etc.).
*
* @param input
*            the stream to read from (null indicates an empty synonym map)
* @throws ioexception
*             if an error occured while reading the stream.
*/
public synonymmap inputstream input  throws ioexception
this table   input    null ? new hashmap 0    read tobytearray input
/**
* returns the synonym set for the given word, sorted ascending.
*
* @param word
*            the word to lookup (must be in lowercase).
* @return the synonyms; a set of zero or more words, sorted ascending, each
*         word containing lowercase characters that satisfy
*         <code>character.isletter()</code>.
*/
public string getsynonyms string word
object syns   table get word
if  syns    null  return empty
if  syns instanceof string  return new string   string  syns
string synonyms    string  syns
string copy   new string     copy for guaranteed immutability
system arraycopy synonyms  0  copy  0  synonyms length
return copy
/**
* returns a string representation of the index data for debugging purposes.
*
* @return a string representation
*/
public string tostring
stringbuffer buf   new stringbuffer
iterator iter   new treemap table  keyset   iterator
int count   0
int f0   0
int f1   0
int f2   0
int f3   0
while  iter hasnext
string word    string  iter next
buf append word
string synonyms   getsynonyms word
buf append arrays aslist synonyms
buf append
count    synonyms length
if  synonyms length    0  f0
if  synonyms length    1  f1
if  synonyms length    2  f2
if  synonyms length    3  f3
buf append     table size         count       f0      f1       f2       f3
return buf tostring
/**
* analyzes/transforms the given word on input stream loading. this default implementation simply
* lowercases the word. override this method with a custom stemming
* algorithm or similar, if desired.
*
* @param word
*            the word to analyze
* @return the same word, or a different word (or null to indicate that the
*         word should be ignored)
*/
protected string analyze string word
return word tolowercase
private static boolean isvalid string str
for  int i str length      i >  0
if   character isletter str charat i    return false
return true
private hashmap read byte data
int words     int   76401   0 7      presizing
int groups    int   88022   0 7      presizing
hashmap word2groups   new hashmap words       map<string word  int groups>
hashmap group2words   new hashmap groups      map<int group  string words>
hashmap internedwords   new hashmap words     map<string word  string word>
charset charset   charset forname
int lastnum    1
integer lastgroup   null
int len   data length
int i 0
while  i < len       until eof
/* part a: parse a line */
// scan to beginning of group
while  i < len    data       i
if  i >  len  break     eof
i
// parse group
int num   0
while  i < len    data
num   10 num    data   48
i
i
//      if (debug) system.err.println("num="+ num);
// scan to beginning of word
while  i < len    data       i
i
// scan to end of word
int start   i
do
while  i < len    data       i
i
while  i < len    data           word must end with
if  i >  len  break     eof
string word   charset decode bytebuffer wrap data  start  i start 1   tostring
//      string word = new string(data, 0, start, i-start-1); // ascii
/*
* part b: ignore phrases (with spaces and hyphens) and
* non-alphabetic words, and let user customize word (e.g. do some
* stemming)
*/
if   isvalid word   continue     ignore
word   analyze word
if  word    null    word length      0  continue     ignore
/* part c: add (group,word) to tables */
// ensure compact string representation, minimizing memory overhead
string w    string  internedwords get word
if  w    null
word   new string word      ensure compact string
internedwords put word  word
else
word   w
integer group   lastgroup
if  num    lastnum
group   new integer num
lastgroup   group
lastnum   num
// add word --> group
arraylist groups    arraylist  word2groups get word
if  groups    null
groups   new arraylist 1
word2groups put word  groups
groups add group
// add group --> word
arraylist words    arraylist  group2words get group
if  words    null
words   new arraylist 1
group2words put group  words
words add word
/* part d: compute index data structure */
hashmap word2syns   createindex word2groups  group2words
/* part e: minimize memory consumption by a factor 3 (or so) */
//    if (true) return word2syns;
word2groups   null     help gc
group2words   null     help gc
return optimize word2syns  internedwords
private hashmap createindex map word2groups  map group2words
hashmap word2syns   new hashmap
iterator iter   word2groups entryset   iterator
while  iter hasnext         for each word
map entry entry    map entry  iter next
arraylist group    arraylist  entry getvalue
string word    string  entry getkey
//      hashset synonyms = new hashset();
treeset synonyms   new treeset
for  int i group size      i >  0         for each groupid of word
arraylist words    arraylist  group2words get group get i
for  int j words size      j >  0         add all words
object synonym   words get j      note that w and word are interned
if  synonym    word       a word is implicitly it's own synonym
synonyms add synonym
int size   synonyms size
if  size > 0
string syns   new string
if  size    1
syns    string  synonyms first
else
synonyms toarray syns
//        if (syns.length > 1) arrays.sort(syns);
//        if (debug) system.err.println("word=" + word + ":" + arrays.aslist(syns));
word2syns put word  syns
return word2syns
private hashmap optimize hashmap word2syns  hashmap internedwords
if  debug
system err println
for  int i 0  i < 10  i    system gc
system err println
// collect entries
int len   0
int size   word2syns size
string allsynonyms   new string
string words   new string
iterator iter   word2syns entryset   iterator
for  int j 0  j < size  j
map entry entry    map entry  iter next
allsynonyms    string  entry getvalue
words    string  entry getkey
len    words length
// assemble large string containing all words
stringbuffer buf   new stringbuffer len
for  int j 0  j < size  j    buf append words
string allwords   new string buf tostring        ensure compact string across jdk versions
buf   null
// intern words at app level via memory-overlaid substrings
for  int p 0  j 0  j < size  j
string word   words
internedwords put word  allwords substring p  p   word length
p    word length
// replace words with interned words
for  int j 0  j < size  j
string syns   allsynonyms
for  int k syns length    k >  0
syns    string  internedwords get syns
object replacement   syns
if  syns length    1  replacement   syns     minimize memory consumption some more
word2syns remove words
word2syns put internedwords get words   replacement
if  debug
words   null
allsynonyms   null
internedwords   null
allwords   null
system err println
for  int i 0  i < 10  i    system gc
system err println
return word2syns
// the following utility methods below are copied from apache style nux library - see http://dsd.lbl.gov/nux
private static byte tobytearray inputstream input  throws ioexception
try
// safe and fast even if input.available() behaves weird or buggy
int len   math max 256  input available
byte buffer   new byte
byte output   new byte
len   0
int n
while   n   input read buffer   >  0
if  len   n > output length       grow capacity
byte tmp   new byte
system arraycopy output  0  tmp  0  len
system arraycopy buffer  0  tmp  len  n
buffer   output     use larger buffer for future larger bulk reads
output   tmp
else
system arraycopy buffer  0  output  len  n
len    n
if  len    output length  return output
buffer   null     help gc
buffer   new byte
system arraycopy output  0  buffer  0  len
return buffer
finally
if  input    null  input close