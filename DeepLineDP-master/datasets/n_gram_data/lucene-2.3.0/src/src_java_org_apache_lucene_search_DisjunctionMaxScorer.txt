package org apache lucene search
/**
* copyright 2004 the apache software foundation
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util arraylist
/**
* the scorer for disjunctionmaxquery's.  the union of all documents generated by the the subquery scorers
* is generated in document number order.  the score for each document is the maximum of the scores computed
* by the subquery scorers that generate that document, plus tiebreakermultiplier times the sum of the scores
* for the other subqueries that generate the document.
* @author chuck williams
*/
class disjunctionmaxscorer extends scorer
/* the scorers for subqueries that have remaining docs, kept as a min heap by number of next doc. */
private arraylist subscorers   new arraylist
/* multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result. */
private float tiebreakermultiplier
private boolean more   false              true iff there is a next document
private boolean firsttime   true          true iff next   has not yet been called
/** creates a new instance of disjunctionmaxscorer
* @param tiebreakermultiplier multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result.
* @param similarity -- not used since our definition involves neither coord nor terms directly */
public disjunctionmaxscorer float tiebreakermultiplier  similarity similarity
super similarity
this tiebreakermultiplier   tiebreakermultiplier
/** add the scorer for a subquery
* @param scorer the scorer of a subquery of our associated disjunctionmaxquery
*/
public void add scorer scorer  throws ioexception
if  scorer next               initialize and retain only if it produces docs
subscorers add scorer
more   true
/** generate the next document matching our associated disjunctionmaxquery.
* @return true iff there is a next document
*/
public boolean next   throws ioexception
if   more  return false
if  firsttime
heapify
firsttime   false
return true       more would have been false if no subscorers had any docs
// increment all generators that generated the last doc and adjust the heap.
int lastdoc     scorer  subscorers get 0   doc
do
if    scorer  subscorers get 0   next
heapadjust 0
else
heapremoveroot
if  subscorers isempty    return  more   false
while     scorer  subscorers get 0   doc    lastdoc
return true
/** determine the current document number.  initially invalid, until {@link #next()} is called the first time.
* @return the document number of the currently generated document
*/
public int doc
return   scorer  subscorers get 0   doc
/** determine the current document score.  initially invalid, until {@link #next()} is called the first time.
* @return the score of the current generated document
*/
public float score   throws ioexception
int doc     scorer  subscorers get 0   doc
float sum      scorer  subscorers get 0   score     max    sum
int size   subscorers size
scoreall 1  size  doc  sum  max
scoreall 2  size  doc  sum  max
return max    sum   max  tiebreakermultiplier
// recursively iterate all subscorers that generated last doc computing sum and max
private void scoreall int root  int size  int doc  float sum  float max  throws ioexception
if  root<size      scorer  subscorers get root   doc      doc
float sub     scorer  subscorers get root   score
sum    sub
max   math max max  sub
scoreall  root<<1  1  size  doc  sum  max
scoreall  root<<1  2  size  doc  sum  max
/** advance to the first document beyond the current whose number is greater than or equal to target.
* @param target the minimum number of the next desired document
* @return true iff there is a document to be generated whose number is at least target
*/
public boolean skipto int target  throws ioexception
if  firsttime
if   more  return false
heapify
firsttime   false
while  subscorers size  >0      scorer subscorers get 0   doc  <target
if    scorer subscorers get 0   skipto target
heapadjust 0
else
heapremoveroot
if   subscorers size    0
return  more   false
return true
/** explain a score that we computed.  unsupported -- see explanation capability in disjunctionmaxquery.
* @param doc the number of a document we scored
* @return the explanation for our score
*/
public explanation explain int doc  throws ioexception
throw new unsupportedoperationexception
// organize subscorers into a min heap with scorers generating the earlest document on top.
private void heapify
int size   subscorers size
for  int i  size>>1  1  i> 0  i
heapadjust i
/* the subtree of subscorers at root is a min heap except possibly for its root element.
* bubble the root down as required to make the subtree a heap.
*/
private void heapadjust int root
scorer scorer  scorer subscorers get root
int doc scorer doc
int i root  size subscorers size
while  i<  size>>1  1
int lchild  i<<1  1
scorer lscorer  scorer subscorers get lchild
int ldoc lscorer doc
int rdoc integer max_value  rchild  i<<1  2
scorer rscorer null
if  rchild<size
rscorer  scorer subscorers get rchild
rdoc rscorer doc
if  ldoc<doc
if  rdoc<ldoc
subscorers set i  rscorer
subscorers set rchild  scorer
i rchild
else
subscorers set i  lscorer
subscorers set lchild  scorer
i lchild
else if  rdoc<doc
subscorers set i  rscorer
subscorers set rchild  scorer
i rchild
else return
// remove the root scorer from subscorers and re-establish it as a heap
private void heapremoveroot
int size subscorers size
if  size  1
subscorers remove 0
else
subscorers set 0  subscorers get size 1
subscorers remove size 1
heapadjust 0