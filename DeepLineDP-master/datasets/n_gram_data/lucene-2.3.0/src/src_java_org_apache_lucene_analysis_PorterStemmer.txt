package org apache lucene analysis
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
/*
porter stemmer in java. the original paper is in
porter, 1980, an algorithm for suffix stripping, program, vol. 14,
no. 3, pp 130-137,
see also http://www.tartarus.org/~martin/porterstemmer/index.html
bug 1 (reported by gonzalo parra 16/10/99) fixed as marked below.
tthe words 'aed', 'eed', 'oed' leave k at 'a' for step 3, and b[k-1]
is then out outside the bounds of b.
similarly,
bug 2 (reported by steve dyrdahl 22/2/00) fixed as marked below.
'ion' by itself leaves j = -1 in the test for 'ion' in step 5, and
b[j] is then outside the bounds of b.
release 3.
[ this version is derived from release 3, modified by brian goetz to
optimize for fewer object creations.  ]
*/
import java io
/**
*
* stemmer, implementing the porter stemming algorithm
*
* the stemmer class transforms a word into its root form.  the input
* word can be provided a character at time (by calling add()), or at once
* by calling one of the various stem(something) methods.
*/
class porterstemmer
private char b
private int i        offset into b
j  k  k0
private boolean dirty   false
private static final int inc   50     unit of size whereby b is increased
private static final int extra   1
public porterstemmer
b   new char
i   0
/**
* reset() resets the stemmer so it can stem another word.  if you invoke
* the stemmer by calling add(char) and then stem(), you must call reset()
* before starting another word.
*/
public void reset     i   0  dirty   false
/**
* add a character to the word being stemmed.  when you are finished
* adding characters, you can call stem(void) to process the word.
*/
public void add char ch
if  b length <  i   extra
char new_b   new char
system arraycopy b  0  new_b  0  b length
b   new_b
b   ch
/**
* after a word has been stemmed, it can be retrieved by tostring(),
* or a reference to the internal buffer can be retrieved by getresultbuffer
* and getresultlength (which is generally more efficient.)
*/
public string tostring     return new string b 0 i
/**
* returns the length of the word resulting from the stemming process.
*/
public int getresultlength     return i
/**
* returns a reference to a character buffer containing the results of
* the stemming process.  you also need to consult getresultlength()
* to determine the length of the result.
*/
public char getresultbuffer     return b
/* cons(i) is true <=> b[i] is a consonant. */
private final boolean cons int i
switch  b
case    case    case    case    case
return false
case
return  i  k0  ? true    cons i 1
default
return true
/* m() measures the number of consonant sequences between k0 and j. if c is
a consonant sequence and v a vowel sequence, and <..> indicates arbitrary
presence,
<c><v>       gives 0
<c>vc<v>     gives 1
<c>vcvc<v>   gives 2
<c>vcvcvc<v> gives 3
....
*/
private final int m
int n   0
int i   k0
while true
if  i > j
return n
if    cons i
break
i
i
while true
while true
if  i > j
return n
if  cons i
break
i
i
n
while true
if  i > j
return n
if    cons i
break
i
i
/* vowelinstem() is true <=> k0,...j contains a vowel */
private final boolean vowelinstem
int i
for  i   k0  i <  j  i
if    cons i
return true
return false
/* doublec(j) is true <=> j,(j-1) contain a double consonant. */
private final boolean doublec int j
if  j < k0 1
return false
if  b    b
return false
return cons j
/* cvc(i) is true <=> i-2,i-1,i has the form consonant - vowel - consonant
and also if the second c is not w,x or y. this is used when trying to
restore an e at the end of a short word. e.g.
cav(e), lov(e), hop(e), crim(e), but
snow, box, tray.
*/
private final boolean cvc int i
if  i < k0 2     cons i     cons i 1      cons i 2
return false
else
int ch   b
if  ch         ch         ch       return false
return true
private final boolean ends string s
int l   s length
int o   k l 1
if  o < k0
return false
for  int i   0  i < l  i
if  b    s charat i
return false
j   k l
return true
/* setto(s) sets (j+1),...k to the characters in the string s, readjusting
k. */
void setto string s
int l   s length
int o   j 1
for  int i   0  i < l  i
b   s charat i
k   j l
dirty   true
/* r(s) is used further down. */
void r string s    if  m   > 0  setto s
/* step1() gets rid of plurals and -ed or -ing. e.g.
caresses  ->  caress
ponies    ->  poni
ties      ->  ti
caress    ->  caress
cats      ->  cat
feed      ->  feed
agreed    ->  agree
disabled  ->  disable
matting   ->  mat
mating    ->  mate
meeting   ->  meet
milling   ->  mill
messing   ->  mess
meetings  ->  meet
*/
private final void step1
if  b
if  ends     k    2
else if  ends     setto
else if  b       k
if  ends
if  m   > 0
k
else if   ends       ends        vowelinstem
k   j
if  ends     setto
else if  ends     setto
else if  ends     setto
else if  doublec k
int ch   b
if  ch         ch         ch
k
else if  m      1    cvc k
setto
/* step2() turns terminal y to i when there is another vowel in the stem. */
private final void step2
if  ends       vowelinstem
b
dirty   true
/* step3() maps double suffices to single ones. so -ization ( = -ize plus
-ation) maps to -ize etc. note that the string before the suffix must give
m() > 0. */
private final void step3
if  k    k0  return     for bug 1
switch  b
case
if  ends       r     break
if  ends       r     break
break
case
if  ends       r     break
if  ends       r     break
break
case
if  ends       r     break
break
case
if  ends       r     break
if  ends       r     break
if  ends       r     break
if  ends       r     break
if  ends       r     break
break
case
if  ends       r     break
if  ends       r     break
if  ends       r     break
break
case
if  ends       r     break
if  ends       r     break
if  ends       r     break
if  ends       r     break
break
case
if  ends       r     break
if  ends       r     break
if  ends       r     break
break
case
if  ends       r     break
/* step4() deals with -ic-, -full, -ness etc. similar strategy to step3. */
private final void step4
switch  b
case
if  ends       r     break
if  ends       r     break
if  ends       r     break
break
case
if  ends       r     break
break
case
if  ends       r     break
if  ends       r     break
break
case
if  ends       r     break
break
/* step5() takes off -ant, -ence etc., in context <c>vcvc<v>. */
private final void step5
if  k    k0  return     for bug 1
switch  b
case
if  ends     break
return
case
if  ends     break
if  ends     break
return
case
if  ends     break  return
case
if  ends     break  return
case
if  ends     break
if  ends     break  return
case
if  ends     break
if  ends     break
if  ends     break
/* element etc. not stripped before the m */
if  ends     break
return
case
if  ends       j >  0     b         b        break
/* j >= 0 fixes bug 2 */
if  ends     break
return
/* takes care of -ous */
case
if  ends     break
return
case
if  ends     break
if  ends     break
return
case
if  ends     break
return
case
if  ends     break
return
case
if  ends     break
return
default
return
if  m   > 1
k   j
/* step6() removes a final -e if m() > 1. */
private final void step6
j   k
if  b
int a   m
if  a > 1    a    1     cvc k 1
k
if  b         doublec k     m   > 1
k
/**
* stem a word provided as a string.  returns the result as a string.
*/
public string stem string s
if  stem s tochararray    s length
return tostring
else
return s
/** stem a word contained in a char[].  returns true if the stemming process
* resulted in a word different from the input.  you can retrieve the
* result with getresultlength()/getresultbuffer() or tostring().
*/
public boolean stem char word
return stem word  word length
/** stem a word contained in a portion of a char[] array.  returns
* true if the stemming process resulted in a word different from
* the input.  you can retrieve the result with
* getresultlength()/getresultbuffer() or tostring().
*/
public boolean stem char wordbuffer  int offset  int wordlen
reset
if  b length < wordlen
char new_b   new char
b   new_b
system arraycopy wordbuffer  offset  b  0  wordlen
i   wordlen
return stem 0
/** stem a word contained in a leading portion of a char[] array.
* returns true if the stemming process resulted in a word different
* from the input.  you can retrieve the result with
* getresultlength()/getresultbuffer() or tostring().
*/
public boolean stem char word  int wordlen
return stem word  0  wordlen
/** stem the word placed into the stemmer buffer through calls to add().
* returns true if the stemming process resulted in a word different
* from the input.  you can retrieve the result with
* getresultlength()/getresultbuffer() or tostring().
*/
public boolean stem
return stem 0
public boolean stem int i0
k   i   1
k0   i0
if  k > k0 1
step1    step2    step3    step4    step5    step6
// also, a word is considered dirty if we lopped off letters
// thanks to ifigenia vairelles for pointing this out.
if  i    k 1
dirty   true
i   k 1
return dirty
/** test program for demonstrating the stemmer.  it reads a file and
* stems each word, writing the result to standard out.
* usage: stemmer file-name
*/
public static void main string args
porterstemmer s   new porterstemmer
for  int i   0  i < args length  i
try
inputstream in   new fileinputstream args
byte buffer   new byte
int bufferlen  offset  ch
bufferlen   in read buffer
offset   0
s reset
while true
if  offset < bufferlen
ch   buffer
else
bufferlen   in read buffer
offset   0
if  bufferlen < 0
ch    1
else
ch   buffer
if  character isletter  char  ch
s add character tolowercase  char  ch
else
s stem
system out print s tostring
s reset
if  ch < 0
break
else
system out print  char  ch
in close
catch  ioexception e
system out println     args