package org apache lucene store
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java nio channels filechannel
import java nio channels filelock
import java io file
import java io randomaccessfile
import java io ioexception
import java util hashset
import java util random
/**
* <p>implements {@link lockfactory} using native os file
* locks.  note that because this lockfactory relies on
* java.nio.* apis for locking, any problems with those apis
* will cause locking to fail.  specifically, on certain nfs
* environments the java.nio.* locks will fail (the lock can
* incorrectly be double acquired) whereas {@link
* simplefslockfactory} worked perfectly in those same
* environments.  for nfs based access to an index, it's
* recommended that you try {@link simplefslockfactory}
* first and work around the one limitation that a lock file
* could be left when the jvm exits abnormally.</p>
*
* <p>the primary benefit of {@link nativefslockfactory} is
* that lock files will be properly removed (by the os) if
* the jvm has an abnormal exit.</p>
*
* <p>note that, unlike {@link simplefslockfactory}, the existence of
* leftover lock files in the filesystem on exiting the jvm
* is fine because the os will free the locks held against
* these files even though the files still remain.</p>
*
* <p>if you suspect that this or any other lockfactory is
* not working properly in your environment, you can easily
* test it by using {@link verifyinglockfactory}, {@link
* lockverifyserver} and {@link lockstresstest}.</p>
*
* @see lockfactory
*/
public class nativefslockfactory extends lockfactory
/**
* directory specified by <code>org.apache.lucene.lockdir</code>
* system property.  if that is not set, then <code>java.io.tmpdir</code>
* system property is used.
*/
private file lockdir
// simple test to verify locking system is "working".  on
// nfs, if it's misconfigured, you can hit long (35
// second) timeouts which cause lock.obtain to take far
// too long (it assumes the obtain() call takes zero
// time).  since it's a configuration problem, we test up
// front once on creating the lockfactory:
private void acquiretestlock   throws ioexception
string randomlockname       long tostring new random   nextint    character max_radix
lock l   makelock randomlockname
try
l obtain
catch  ioexception e
ioexception e2   new ioexception     lockdir
e2 initcause e
throw e2
l release
/**
* create a nativefslockfactory instance, with null (unset)
* lock directory.  this is package-private and is only
* used by fsdirectory when creating this lockfactory via
* the system property
* org.apache.lucene.store.fsdirectorylockfactoryclass.
*/
nativefslockfactory   throws ioexception
this  file  null
/**
* create a nativefslockfactory instance, storing lock
* files into the specified lockdirname:
*
* @param lockdirname where lock files are created.
*/
public nativefslockfactory string lockdirname  throws ioexception
this new file lockdirname
/**
* create a nativefslockfactory instance, storing lock
* files into the specified lockdir:
*
* @param lockdir where lock files are created.
*/
public nativefslockfactory file lockdir  throws ioexception
setlockdir lockdir
/**
* set the lock directory.  this is package-private and is
* only used externally by fsdirectory when creating this
* lockfactory via the system property
* org.apache.lucene.store.fsdirectorylockfactoryclass.
*/
void setlockdir file lockdir  throws ioexception
this lockdir   lockdir
if  lockdir    null
// ensure that lockdir exists and is a directory.
if   lockdir exists
if   lockdir mkdirs
throw new ioexception
lockdir getabsolutepath
else if   lockdir isdirectory
throw new ioexception
lockdir getabsolutepath
acquiretestlock
public synchronized lock makelock string lockname
if  lockprefix    null
lockname   lockprefix       lockname
return new nativefslock lockdir  lockname
public void clearlock string lockname  throws ioexception
// note that this isn't strictly required anymore
// because the existence of these files does not mean
// they are locked, but, still do this in case people
// really want to see the files go away:
if  lockdir exists
if  lockprefix    null
lockname   lockprefix       lockname
file lockfile   new file lockdir  lockname
if  lockfile exists       lockfile delete
throw new ioexception     lockfile
class nativefslock extends lock
private randomaccessfile f
private filechannel channel
private filelock lock
private file path
private file lockdir
/*
* the javadocs for filechannel state that you should have
* a single instance of a filechannel (per jvm) for all
* locking against a given file.  to ensure this, we have
* a single (static) hashset that contains the file paths
* of all currently locked locks.  this protects against
* possible cases where different directory instances in
* one jvm (each with their own nativefslockfactory
* instance) have set the same lock dir and lock prefix.
*/
private static hashset lock_held   new hashset
public nativefslock file lockdir  string lockfilename
this lockdir   lockdir
path   new file lockdir  lockfilename
public synchronized boolean obtain   throws ioexception
if  islocked
// our instance is already locked:
return false
// ensure that lockdir exists and is a directory.
if   lockdir exists
if   lockdir mkdirs
throw new ioexception
lockdir getabsolutepath
else if   lockdir isdirectory
throw new ioexception
lockdir getabsolutepath
string canonicalpath   path getcanonicalpath
boolean markedheld   false
try
// make sure nobody else in-process has this lock held
// already, and, mark it held if not:
synchronized lock_held
if  lock_held contains canonicalpath
// someone else in this jvm already has the lock:
return false
else
// this "reserves" the fact that we are the one
// thread trying to obtain this lock, so we own
// the only instance of a channel against this
// file:
lock_held add canonicalpath
markedheld   true
try
f   new randomaccessfile path
catch  ioexception e
// on windows, we can get intermittant "access
// denied" here.  so, we treat this as failure to
// acquire the lock, but, store the reason in case
// there is in fact a real error case.
failurereason   e
f   null
if  f    null
try
channel   f getchannel
try
lock   channel trylock
catch  ioexception e
// at least on os x, we will sometimes get an
// intermittant "permission denied" ioexception,
// which seems to simply mean "you failed to get
// the lock".  but other ioexceptions could be
// "permanent" (eg, locking is not supported via
// the filesystem).  so, we record the failure
// reason here; the timeout obtain (usually the
// one calling us) will use this as "root cause"
// if it fails to get the lock.
failurereason   e
finally
if  lock    null
try
channel close
finally
channel   null
finally
if  channel    null
try
f close
finally
f   null
finally
if  markedheld     islocked
synchronized lock_held
if  lock_held contains canonicalpath
lock_held remove canonicalpath
return islocked
public synchronized void release   throws ioexception
if  islocked
try
lock release
finally
lock   null
try
channel close
finally
channel   null
try
f close
finally
f   null
synchronized lock_held
lock_held remove path getcanonicalpath
if   path delete
throw new lockreleasefailedexception     path
public synchronized boolean islocked
return lock    null
public string tostring
return     path
public void finalize   throws throwable
try
if  islocked
release
finally
super finalize