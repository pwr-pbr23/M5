package org apache lucene search
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene index termpositions
import java io ioexception
import java util arrays
import java util comparator
import java util hashmap
final class sloppyphrasescorer extends phrasescorer
private int slop
private phrasepositions repeats
private boolean checkedrepeats
sloppyphrasescorer weight weight  termpositions tps  int offsets  similarity similarity
int slop  byte norms
super weight  tps  offsets  similarity  norms
this slop   slop
/**
* score a candidate doc for all slop-valid position-combinations (matches)
* encountered while traversing/hopping the phrasepositions.
* <br> the score contribution of a match depends on the distance:
* <br> - highest score for distance=0 (exact match).
* <br> - score gets lower as distance gets higher.
* <br>example: for query "a b"~2, a document "x a b a y" can be scored twice:
* once for "a b" (distance=0), and once for "b a" (distance=2).
* <br>pssibly not all valid combinations are encountered, because for efficiency
* we always propagate the least phraseposition. this allows to base on
* priorityqueue and move forward faster.
* as result, for example, document "a b c b a"
* would score differently for queries "a b c"~4 and "c b a"~4, although
* they really are equivalent.
* similarly, for doc "a b c b a f g", query "c b"~2
* would get same score as "g f"~2, although "c b"~2 could be matched twice.
* we may want to fix this in the future (currently not, for performance reasons).
*/
protected final float phrasefreq   throws ioexception
int end   initphrasepositions
float freq   0 0f
boolean done    end<0
while   done
phrasepositions pp    phrasepositions  pq pop
int start   pp position
int next     phrasepositions  pq top    position
boolean tpsdiffer   true
for  int pos   start  pos <  next     tpsdiffer  pos   pp position
if  pos< next    tpsdiffer
start   pos 				     advance pp to min window
if   pp nextposition
done   true              ran out of a term    done
break
tpsdiffer    pp repeats    termpositionsdiffer pp
int matchlength   end   start
if  matchlength <  slop
freq    getsimilarity   sloppyfreq matchlength      score match
if  pp position > end
end   pp position
pq put pp  				     restore pq
return freq
/**
* init phrasepositions in place.
* there is a one time initializatin for this scorer:
* <br>- put in repeats[] each pp that has another pp with same position in the doc.
* <br>- also mark each such pp by pp.repeats = true.
* <br>later can consult with repeats[] in termpositionsdiffer(pp), making that check efficient.
* in particular, this allows to score queries with no repetiotions with no overhead due to this computation.
* <br>- example 1 - query with no repetitions: "ho my"~2
* <br>- example 2 - query with repetitions: "ho my my"~2
* <br>- example 3 - query with repetitions: "my ho my"~2
* <br>init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.
* @return end (max position), or -1 if any term ran out (i.e. done)
* @throws ioexception
*/
private int initphrasepositions   throws ioexception
int end   0
// no repeats at all (most common case is also the simplest one)
if  checkedrepeats    repeats  null
// build queue from list
pq clear
for  phrasepositions pp   first  pp    null  pp   pp next
pp firstposition
if  pp position > end
end   pp position
pq put pp              build pq from list
return end
// position the pp's
for  phrasepositions pp   first  pp    null  pp   pp next
pp firstposition
// one time initializatin for this scorer
if   checkedrepeats
checkedrepeats   true
// check for repeats
hashmap m   null
for  phrasepositions pp   first  pp    null  pp   pp next
int tppos   pp position   pp offset
for  phrasepositions pp2   pp next  pp2    null  pp2   pp2 next
int tppos2   pp2 position   pp2 offset
if  tppos2    tppos
if  m    null
m   new hashmap
pp repeats   true
pp2 repeats   true
m put pp null
m put pp2 null
if  m  null
repeats    phrasepositions  m keyset   toarray new phrasepositions
// with repeats must advance some repeating pp's so they all start with differing tp's
if  repeats  null
// must propagate higher offsets first (otherwise might miss matches).
arrays sort repeats   new comparator
public int compare object x  object y
return   phrasepositions  y  offset     phrasepositions  x  offset
// now advance them
for  int i   0  i < repeats length  i
phrasepositions pp   repeats
while   termpositionsdiffer pp
if   pp nextposition
return  1        ran out of a term    done
// build queue from list
pq clear
for  phrasepositions pp   first  pp    null  pp   pp next
if  pp position > end
end   pp position
pq put pp              build pq from list
return end
// disalow two pp's to have the same tp position, so that same word twice
// in query would go elswhere in the matched doc
private boolean termpositionsdiffer phrasepositions pp
// efficiency note: a more efficient implemention could keep a map between repeating
// pp's, so that if pp1a, pp1b, pp1c are repeats term1, and pp2a, pp2b are repeats
// of term2, pp2a would only be checked against pp2b but not against pp1a, pp1b, pp1c.
// however this would complicate code, for a rather rare case, so choice is to compromise here.
int tppos   pp position   pp offset
for  int i   0  i < repeats length  i
phrasepositions pp2   repeats
if  pp2    pp
continue
int tppos2   pp2 position   pp2 offset
if  tppos2    tppos
return false
return true