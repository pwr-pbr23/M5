package org apache lucene search spans
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util arrays
import java util comparator
import org apache lucene index indexreader
/** a spans that is formed from the ordered subspans of a spannearquery
* where the subspans do not overlap and have a maximum slop between them.
* <p>
* the formed spans only contains minimum slop matches.<br>
* the matching slop is computed from the distance(s) between
* the non overlapping matching spans.<br>
* successive matches are always formed from the successive spans
* of the spannearquery.
* <p>
* the formed spans may contain overlaps when the slop is at least 1.
* for example, when querying using
* <pre>t1 t2 t3</pre>
* with slop at least 1, the fragment:
* <pre>t1 t2 t1 t3 t2 t3</pre>
* matches twice:
* <pre>t1 t2 .. t3      </pre>
* <pre>      t1 .. t2 t3</pre>
*/
class nearspansordered implements spans
private final int allowedslop
private boolean firsttime   true
private boolean more   false
/** the spans in the same order as the spannearquery */
private final spans subspans
/** indicates that all subspans have same doc() */
private boolean insamedoc   false
private int matchdoc    1
private int matchstart    1
private int matchend    1
private final spans subspansbydoc
private final comparator spandoccomparator   new comparator
public int compare object o1  object o2
return   spans o1  doc       spans o2  doc
private spannearquery query
public nearspansordered spannearquery spannearquery  indexreader reader
throws ioexception
if  spannearquery getclauses   length < 2
throw new illegalargumentexception
spannearquery
allowedslop   spannearquery getslop
spanquery clauses   spannearquery getclauses
subspans   new spans
subspansbydoc   new spans
for  int i   0  i < clauses length  i
subspans   clauses getspans reader
subspansbydoc   subspans     used in tosamedoc
query   spannearquery     kept for tostring   only
// inherit javadocs
public int doc     return matchdoc
// inherit javadocs
public int start     return matchstart
// inherit javadocs
public int end     return matchend
// inherit javadocs
public boolean next   throws ioexception
if  firsttime
firsttime   false
for  int i   0  i < subspans length  i
if    subspans next
more   false
return false
more   true
return advanceafterordered
// inherit javadocs
public boolean skipto int target  throws ioexception
if  firsttime
firsttime   false
for  int i   0  i < subspans length  i
if    subspans skipto target
more   false
return false
more   true
else if  more     subspans doc   < target
if  subspans skipto target
insamedoc   false
else
more   false
return false
return advanceafterordered
/** advances the subspans to just after an ordered match with a minimum slop
* that is smaller than the slop allowed by the spannearquery.
* @return true iff there is such a match.
*/
private boolean advanceafterordered   throws ioexception
while  more     insamedoc    tosamedoc
if  stretchtoorder      shrinktoaftershortestmatch
return true
return false     no more matches
/** advance the subspans to the same document */
private boolean tosamedoc   throws ioexception
arrays sort subspansbydoc  spandoccomparator
int firstindex   0
int maxdoc   subspansbydoc doc
while  subspansbydoc doc      maxdoc
if    subspansbydoc skipto maxdoc
more   false
insamedoc   false
return false
maxdoc   subspansbydoc doc
if    firstindex    subspansbydoc length
firstindex   0
for  int i   0  i < subspansbydoc length  i
assert  subspansbydoc doc      maxdoc
subspansbydoc
subspansbydoc doc
maxdoc
insamedoc   true
return true
/** check whether two spans in the same document are ordered.
* @param spans1
* @param spans2
* @return true iff spans1 starts before spans2
*              or the spans start at the same position,
*              and spans1 ends before spans2.
*/
static final boolean docspansordered spans spans1  spans spans2
assert spans1 doc      spans2 doc         spans1 doc         spans2 doc
int start1   spans1 start
int start2   spans2 start
/* do not call docspansordered(int,int,int,int) to avoid invoking .end() : */
return  start1    start2  ?  spans1 end   < spans2 end       start1 < start2
/** like {@link #docspansordered(spans,spans)}, but use the spans
* starts and ends as parameters.
*/
private static final boolean docspansordered int start1  int end1  int start2  int end2
return  start1    start2  ?  end1 < end2     start1 < start2
/** order the subspans within the same document by advancing all later spans
* after the previous one.
*/
private boolean stretchtoorder   throws ioexception
matchdoc   subspans doc
for  int i   1  insamedoc     i < subspans length   i
while    docspansordered subspans  subspans
if    subspans next
insamedoc   false
more   false
break
else if  matchdoc    subspans doc
insamedoc   false
break
return insamedoc
/** the subspans are ordered in the same doc, so there is a possible match.
* compute the slop while making the match as short as possible by advancing
* all subspans except the last one in reverse order.
*/
private boolean shrinktoaftershortestmatch   throws ioexception
matchstart   subspans start
matchend   subspans end
int matchslop   0
int laststart   matchstart
int lastend   matchend
for  int i   subspans length   2  i >  0  i
spans prevspans   subspans
int prevstart   prevspans start
int prevend   prevspans end
while  true       advance prevspans until after  laststart  lastend
if    prevspans next
insamedoc   false
more   false
break     check remaining subspans for final match
else if  matchdoc    prevspans doc
insamedoc   false     the last subspans is not advanced here
break     check remaining subspans for last match in this document
else
int ppstart   prevspans start
int ppend   prevspans end       cannot avoid invoking  end
if    docspansordered ppstart  ppend  laststart  lastend
break     check remaining subspans
else      prevspans still before  laststart  lastend
prevstart   ppstart
prevend   ppend
assert prevstart <  matchstart
if  matchstart > prevend       only non overlapping spans add to slop
matchslop     matchstart   prevend
/* do not break on (matchslop > allowedslop) here to make sure
* that subspans[0] is advanced after the match, if any.
*/
matchstart   prevstart
laststart   prevstart
lastend   prevend
return matchslop <  allowedslop     ordered and allowed slop
public string tostring
return getclass   getname       query tostring
firsttime?   more? doc     start     end