package org apache lucene index
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import org apache lucene store directory
import org apache lucene store bufferedindexinput
/** this stores a monotonically increasing set of <term, terminfo> pairs in a
* directory.  pairs are accessed either by term or by ordinal position the
* set.  */
final class terminfosreader
private directory directory
private string segment
private fieldinfos fieldinfos
private threadlocal enumerators   new threadlocal
private segmenttermenum origenum
private long size
private term indexterms   null
private terminfo indexinfos
private long indexpointers
private segmenttermenum indexenum
private int indexdivisor   1
private int totalindexinterval
terminfosreader directory dir  string seg  fieldinfos fis
throws corruptindexexception  ioexception
this dir  seg  fis  bufferedindexinput buffer_size
terminfosreader directory dir  string seg  fieldinfos fis  int readbuffersize
throws corruptindexexception  ioexception
boolean success   false
try
directory   dir
segment   seg
fieldinfos   fis
origenum   new segmenttermenum directory openinput segment
readbuffersize   fieldinfos  false
size   origenum size
totalindexinterval   origenum indexinterval
indexenum   new segmenttermenum directory openinput segment
readbuffersize   fieldinfos  true
success   true
finally
// with lock-less commits, it's entirely possible (and
// fine) to hit a filenotfound exception above. in
// this case, we want to explicitly close any subset
// of things that were opened so that we don't have to
// wait for a gc to do so.
if   success
close
public int getskipinterval
return origenum skipinterval
public int getmaxskiplevels
return origenum maxskiplevels
/**
* <p>sets the indexdivisor, which subsamples the number
* of indexed terms loaded into memory.  this has a
* similar effect as {@link
* indexwriter#settermindexinterval} except that setting
* must be done at indexing time while this setting can be
* set per reader.  when set to n, then one in every
* n*termindexinterval terms in the index is loaded into
* memory.  by setting this to a value > 1 you can reduce
* memory usage, at the expense of higher latency when
* loading a terminfo.  the default value is 1.</p>
*
* <b>note:</b> you must call this before the term
* index is loaded.  if the index is already loaded,
* an illegalstateexception is thrown.
*
+ @throws illegalstateexception if the term index has
* already been loaded into memory.
*/
public void setindexdivisor int indexdivisor  throws illegalstateexception
if  indexdivisor < 1
throw new illegalargumentexception     indexdivisor
if  indexterms    null
throw new illegalstateexception
this indexdivisor   indexdivisor
totalindexinterval   origenum indexinterval   indexdivisor
/** returns the indexdivisor.
* @see #setindexdivisor
*/
public int getindexdivisor
return indexdivisor
final void close   throws ioexception
if  origenum    null
origenum close
if  indexenum    null
indexenum close
enumerators set null
/** returns the number of term/value pairs in the set. */
final long size
return size
private segmenttermenum getenum
segmenttermenum termenum    segmenttermenum enumerators get
if  termenum    null
termenum   terms
enumerators set termenum
return termenum
private synchronized void ensureindexisread   throws ioexception
if  indexterms    null                                        index already read
return                                                      do nothing
try
int indexsize   1   int indexenum size 1  indexdivisor      otherwise read index
indexterms   new term
indexinfos   new terminfo
indexpointers   new long
for  int i   0  indexenum next    i
indexterms   indexenum term
indexinfos   indexenum terminfo
indexpointers   indexenum indexpointer
for  int j   1  j < indexdivisor  j
if   indexenum next
break
finally
indexenum close
indexenum   null
/** returns the offset of the greatest index entry which is less than or equal to term.*/
private final int getindexoffset term term
int lo   0 					     binary search indexterms
int hi   indexterms length   1
while  hi >  lo
int mid    lo   hi  >> 1
int delta   term compareto indexterms
if  delta < 0
hi   mid   1
else if  delta > 0
lo   mid   1
else
return mid
return hi
private final void seekenum int indexoffset  throws ioexception
getenum   seek indexpointers
indexoffset   totalindexinterval    1
indexterms  indexinfos
/** returns the terminfo for a term in the set, or null. */
terminfo get term term  throws ioexception
if  size    0  return null
ensureindexisread
// optimize sequential access: first try scanning cached enum w/o seeking
segmenttermenum enumerator   getenum
if  enumerator term      null                    term is at or past current
enumerator prev      null    term compareto enumerator prev   > 0
term compareto enumerator term    >  0
int enumoffset    int  enumerator position totalindexinterval  1
if  indexterms length    enumoffset	     but before end of block
term compareto indexterms  < 0
return scanenum term  			     no need to seek
// random-access: must seek
seekenum getindexoffset term
return scanenum term
/** scans within block for matching term. */
private final terminfo scanenum term term  throws ioexception
segmenttermenum enumerator   getenum
enumerator scanto term
if  enumerator term      null    term compareto enumerator term       0
return enumerator terminfo
else
return null
/** returns the nth term in the set. */
final term get int position  throws ioexception
if  size    0  return null
segmenttermenum enumerator   getenum
if  enumerator    null    enumerator term      null
position >  enumerator position
position <  enumerator position   totalindexinterval
return scanenum position  		     can avoid seek
seekenum position totalindexinterval      must seek
return scanenum position
private final term scanenum int position  throws ioexception
segmenttermenum enumerator   getenum
while enumerator position < position
if   enumerator next
return null
return enumerator term
/** returns the position of a term in the set or -1. */
final long getposition term term  throws ioexception
if  size    0  return  1
ensureindexisread
int indexoffset   getindexoffset term
seekenum indexoffset
segmenttermenum enumerator   getenum
while term compareto enumerator term    > 0    enumerator next
if  term compareto enumerator term       0
return enumerator position
else
return  1
/** returns an enumeration of all the terms and terminfos in the set. */
public segmenttermenum terms
return  segmenttermenum origenum clone
/** returns an enumeration of terms starting at or after the named term. */
public segmenttermenum terms term term  throws ioexception
get term
return  segmenttermenum getenum   clone