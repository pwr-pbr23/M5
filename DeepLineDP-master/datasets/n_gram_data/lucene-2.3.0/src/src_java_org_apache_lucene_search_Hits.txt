package org apache lucene search
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util concurrentmodificationexception
import java util vector
import java util iterator
import org apache lucene document document
import org apache lucene index corruptindexexception
/** a ranked list of documents, used to hold search results.
* <p>
* <b>caution:</b> iterate only over the hits needed.  iterating over all
* hits is generally not desirable and may be the source of
* performance issues. if you need to iterate over many or all hits, consider
* using the search method that takes a {@link hitcollector}.
* </p>
* <p><b>note:</b> deleting matching documents concurrently with traversing
* the hits, might, when deleting hits that were not yet retrieved, decrease
* {@link #length()}. in such case,
* {@link java.util.concurrentmodificationexception concurrentmodificationexception}
* is thrown when accessing hit <code>n</code> &ge; current_{@link #length()}
* (but <code>n</code> &lt; {@link #length()}_at_start).
*/
public final class hits
private weight weight
private searcher searcher
private filter filter   null
private sort sort   null
private int length 				     the total number of hits
private vector hitdocs   new vector   	     cache of hits retrieved
private hitdoc first             head of lru cache
private hitdoc last              tail of lru cache
private int numdocs   0          number cached
private int maxdocs   200        max to cache
private int ndeletions           # deleted docs in the index
private int lengthatstart        this is the number apps usually count on  although deletions can bring it down
private int ndeletedhits   0     # of already collected hits that were meanwhile deleted
boolean debugcheckedfordeletions   false     for test purposes
hits searcher s  query q  filter f  throws ioexception
weight   q weight s
searcher   s
filter   f
ndeletions   countdeletions s
getmoredocs 50      retrieve 100 initially
lengthatstart   length
hits searcher s  query q  filter f  sort o  throws ioexception
weight   q weight s
searcher   s
filter   f
sort   o
ndeletions   countdeletions s
getmoredocs 50      retrieve 100 initially
lengthatstart   length
// count # deletions, return -1 if unknown.
private int countdeletions searcher s  throws ioexception
int cnt    1
if  s instanceof indexsearcher
cnt   s maxdoc       indexsearcher  s  getindexreader   numdocs
return cnt
/**
* tries to add new documents to hitdocs.
* ensures that the hit numbered <code>min</code> has been retrieved.
*/
private final void getmoredocs int min  throws ioexception
if  hitdocs size   > min
min   hitdocs size
int n   min   2 	   double # retrieved
topdocs topdocs    sort    null  ? searcher search weight  filter  n    searcher search weight  filter  n  sort
length   topdocs totalhits
scoredoc scoredocs   topdocs scoredocs
float scorenorm   1 0f
if  length > 0    topdocs getmaxscore   > 1 0f
scorenorm   1 0f   topdocs getmaxscore
int start   hitdocs size     ndeletedhits
// any new deletions?
int ndels2   countdeletions searcher
debugcheckedfordeletions   false
if  ndeletions < 0    ndels2 > ndeletions
// either we cannot count deletions, or some "previously valid hits" might have been deleted, so find exact start point
ndeletedhits   0
debugcheckedfordeletions   true
int i2   0
for  int i1 0  i1<hitdocs size      i2<scoredocs length  i1
int id1     hitdoc hitdocs get i1   id
int id2   scoredocs doc
if  id1    id2
i2
else
ndeletedhits
start   i2
int end   scoredocs length < length ? scoredocs length   length
length    ndeletedhits
for  int i   start  i < end  i
hitdocs addelement new hitdoc scoredocs score   scorenorm
scoredocs doc
ndeletions   ndels2
/** returns the total number of hits available in this set. */
public final int length
return length
/** returns the stored fields of the n<sup>th</sup> document in this set.
* <p>documents are cached, so that repeated requests for the same element may
* return the same document object.
* @throws corruptindexexception if the index is corrupt
* @throws ioexception if there is a low-level io error
*/
public final document doc int n  throws corruptindexexception  ioexception
hitdoc hitdoc   hitdoc n
// update lru cache of documents
remove hitdoc                    remove from list  if there
addtofront hitdoc                add to front of list
if  numdocs > maxdocs            if cache is full
hitdoc oldlast   last
remove last                  flush last
oldlast doc   null           let doc get gc'd
if  hitdoc doc    null
hitdoc doc   searcher doc hitdoc id       cache miss  read document
return hitdoc doc
/** returns the score for the n<sup>th</sup> document in this set. */
public final float score int n  throws ioexception
return hitdoc n  score
/** returns the id for the n<sup>th</sup> document in this set.
* note that ids may change when the index changes, so you cannot
* rely on the id to be stable.
*/
public final int id int n  throws ioexception
return hitdoc n  id
/**
* returns a {@link hititerator} to navigate the hits.  each item returned
* from {@link iterator#next()} is a {@link hit}.
* <p>
* <b>caution:</b> iterate only over the hits needed.  iterating over all
* hits is generally not desirable and may be the source of
* performance issues. if you need to iterate over many or all hits, consider
* using a search method that takes a {@link hitcollector}.
* </p>
*/
public iterator iterator
return new hititerator this
private final hitdoc hitdoc int n  throws ioexception
if  n >  lengthatstart
throw new indexoutofboundsexception     n
if  n >  hitdocs size
getmoredocs n
if  n >  length
throw new concurrentmodificationexception     n
return  hitdoc  hitdocs elementat n
private final void addtofront hitdoc hitdoc        insert at front of cache
if  first    null
last   hitdoc
else
first prev   hitdoc
hitdoc next   first
first   hitdoc
hitdoc prev   null
numdocs
private final void remove hitdoc hitdoc   	     remove from cache
if  hitdoc doc    null           it's not in the list
return 					     abort
if  hitdoc next    null
last   hitdoc prev
else
hitdoc next prev   hitdoc prev
if  hitdoc prev    null
first   hitdoc next
else
hitdoc prev next   hitdoc next
numdocs
final class hitdoc
float score
int id
document doc   null
hitdoc next      in doubly linked cache
hitdoc prev      in doubly linked cache
hitdoc float s  int i
score   s
id   i