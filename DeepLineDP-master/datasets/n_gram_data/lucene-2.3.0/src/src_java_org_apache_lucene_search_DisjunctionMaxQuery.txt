package org apache lucene search
/**
* copyright 2004 the apache software foundation
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene index indexreader
import java io ioexception
import java util arraylist
import java util iterator
import java util collection
import java util set
/**
* a query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
* score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
* this is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
* combined equivalently into a single search field).  we want the primary score to be the one associated with the highest boost,
* not the sum of the field scores (as booleanquery would give).
* if the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
* another gets a higher score than "albino" matching both fields.
* to get this result, use both booleanquery and disjunctionmaxquery:  for each term a disjunctionmaxquery searches for it in
* each field, while the set of these disjunctionmaxquery's is combined into a booleanquery.
* the tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
* include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
* in the multiple fields.
* @author chuck williams
*/
public class disjunctionmaxquery extends query
/* the subqueries */
private arraylist disjuncts   new arraylist
/* multiple of the non-max disjunct scores added into our final score.  non-zero values support tie-breaking. */
private float tiebreakermultiplier   0 0f
/** creates a new empty disjunctionmaxquery.  use add() to add the subqueries.
* @param tiebreakermultiplier this score of each non-maximum disjunct for a document is multiplied by this weight
*        and added into the final score.  if non-zero, the value should be small, on the order of 0.1, which says that
*        10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
*        word in the lower scored field (i.e., one that is not in any higher scored field.
*/
public disjunctionmaxquery float tiebreakermultiplier
this tiebreakermultiplier   tiebreakermultiplier
/**
* creates a new disjunctionmaxquery
* @param disjuncts a collection<query> of all the disjuncts to add
* @param tiebreakermultiplier   the weight to give to each matching non-maximum disjunct
*/
public disjunctionmaxquery collection disjuncts  float tiebreakermultiplier
this tiebreakermultiplier   tiebreakermultiplier
add disjuncts
/** add a subquery to this disjunction
* @param query the disjunct added
*/
public void add query query
disjuncts add query
/** add a collection of disjuncts to this disjunction
* via iterable<query>
*/
public void add collection disjuncts
this disjuncts addall disjuncts
/** an iterator<query> over the disjuncts */
public iterator iterator
return disjuncts iterator
/* the weight for disjunctionmaxquery's, used to normalize, score and explain these queries */
private class disjunctionmaxweight implements weight
private similarity similarity       the similarity which we are associated
private arraylist weights   new arraylist        the weight's for our subqueries  in 1 1 correspondence with disjuncts
/* construct the weight for this query searched by searcher.  recursively construct subquery weights. */
public disjunctionmaxweight searcher searcher  throws ioexception
this similarity   searcher getsimilarity
for  int i   0  i < disjuncts size    i
weights add   query  disjuncts get i   createweight searcher
/* return our associated disjunctionmaxquery */
public query getquery     return disjunctionmaxquery this
/* return our boost */
public float getvalue     return getboost
/* compute the sub of squared weights of us applied to our subqueries.  used for normalization. */
public float sumofsquaredweights   throws ioexception
float max   0 0f  sum   0 0f
for  int i   0  i < weights size    i
float sub     weight  weights get i   sumofsquaredweights
sum    sub
max   math max max  sub
return    sum   max    tiebreakermultiplier   tiebreakermultiplier    max    getboost     getboost
/* apply the computed normalization factor to our subqueries */
public void normalize float norm
norm    getboost        incorporate our boost
for  int i   0   i < weights size    i
weight  weights get i   normalize norm
/* create the scorer used to score our associated disjunctionmaxquery */
public scorer scorer indexreader reader  throws ioexception
disjunctionmaxscorer result   new disjunctionmaxscorer tiebreakermultiplier  similarity
for  int i   0   i < weights size    i
weight w    weight  weights get i
scorer subscorer   w scorer reader
if  subscorer    null  return null
result add subscorer
return result
/* explain the score we computed for doc */
public explanation explain indexreader reader  int doc  throws ioexception
if   disjuncts size      1  return   weight  weights get 0   explain reader doc
complexexplanation result   new complexexplanation
float max   0 0f  sum   0 0f
result setdescription tiebreakermultiplier    0 0f ?         tiebreakermultiplier
for  int i   0   i < weights size    i
explanation e     weight  weights get i   explain reader  doc
if  e ismatch
result setmatch boolean true
result adddetail e
sum    e getvalue
max   math max max  e getvalue
result setvalue max    sum   max  tiebreakermultiplier
return result
end of disjunctionmaxweight inner class
/* create the weight used to score us */
protected weight createweight searcher searcher  throws ioexception
return new disjunctionmaxweight searcher
/** optimize our representation and our subqueries representations
* @param reader the indexreader we query
* @return an optimized copy of us (which may not be a copy if there is nothing to optimize) */
public query rewrite indexreader reader  throws ioexception
if  disjuncts size      1
query singleton    query  disjuncts get 0
query result   singleton rewrite reader
if  getboost      1 0f
if  result    singleton  result    query result clone
result setboost getboost     result getboost
return result
disjunctionmaxquery clone   null
for  int i   0   i < disjuncts size    i
query clause    query  disjuncts get i
query rewrite   clause rewrite reader
if  rewrite    clause
if  clone    null  clone    disjunctionmaxquery this clone
clone disjuncts set i  rewrite
if  clone    null  return clone
else return this
/** create a shallow copy of us -- used in rewriting if necessary
* @return a copy of us (but reuse, don't copy, our subqueries) */
public object clone
disjunctionmaxquery clone    disjunctionmaxquery super clone
clone disjuncts    arraylist this disjuncts clone
return clone
// inherit javadoc
public void extractterms set terms
for  int i   0  i < disjuncts size    i
query disjuncts get i   extractterms terms
/** prettyprint us.
* @param field the field to which we are applied
* @return a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost"
*/
public string tostring string field
stringbuffer buffer   new stringbuffer
buffer append
for  int i   0   i < disjuncts size    i
query subquery    query  disjuncts get i
if  subquery instanceof booleanquery         wrap sub bools in parens
buffer append
buffer append subquery tostring field
buffer append
else buffer append subquery tostring field
if  i    disjuncts size   1  buffer append
buffer append
if  tiebreakermultiplier    0 0f
buffer append
buffer append tiebreakermultiplier
if  getboost      1 0
buffer append
buffer append getboost
return buffer tostring
/** return true iff we represent the same query as o
* @param o another object
* @return true iff o is a disjunctionmaxquery with the same boost and the same subqueries, in the same order, as us
*/
public boolean equals object o
if     o instanceof disjunctionmaxquery    return false
disjunctionmaxquery other    disjunctionmaxquery o
return this getboost      other getboost
this tiebreakermultiplier    other tiebreakermultiplier
this disjuncts equals other disjuncts
/** compute a hash code for hashing us
* @return the hash code
*/
public int hashcode
return float floattointbits getboost
float floattointbits tiebreakermultiplier
disjuncts hashcode