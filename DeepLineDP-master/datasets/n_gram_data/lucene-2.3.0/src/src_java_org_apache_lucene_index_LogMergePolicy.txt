package org apache lucene index
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util set
import org apache lucene store directory
/** <p>this class implements a {@link mergepolicy} that tries
*  to merge segments into levels of exponentially
*  increasing size, where each level has < mergefactor
*  segments in it.  whenever a given levle has mergefactor
*  segments or more in it, they will be merged.</p>
*
* <p>this class is abstract and requires a subclass to
* define the {@link #size} method which specifies how a
* segment's size is determined.  {@link logdocmergepolicy}
* is one subclass that measures size by document count in
* the segment.  {@link logbytesizemergepolicy} is another
* subclass that measures size as the total byte size of the
* file(s) for the segment.</p>
*/
public abstract class logmergepolicy extends mergepolicy
/** defines the allowed range of log(size) for each
*  level.  a level is computed by taking the max segment
*  log size, minuse level_log_span, and finding all
*  segments falling within that range. */
public static final double level_log_span   0 75
/** default merge factor, which is how many segments are
*  merged at a time */
public static final int default_merge_factor   10
/** default maximum segment size.  a segment of this size
*  or larger will never be merged.  @see setmaxmergedocs */
public static final int default_max_merge_docs   integer max_value
private int mergefactor   default_merge_factor
long minmergesize
long maxmergesize
int maxmergedocs   default_max_merge_docs
private boolean usecompoundfile   true
private boolean usecompounddocstore   true
private indexwriter writer
private void message string message
if  writer    null
writer message     message
/** <p>returns the number of segments that are merged at
* once and also controls the total number of segments
* allowed to accumulate in the index.</p> */
public int getmergefactor
return mergefactor
/** determines how often segment indices are merged by
* adddocument().  with smaller values, less ram is used
* while indexing, and searches on unoptimized indices are
* faster, but indexing speed is slower.  with larger
* values, more ram is used during indexing, and while
* searches on unoptimized indices are slower, indexing is
* faster.  thus larger values (> 10) are best for batch
* index creation, and smaller values (< 10) for indices
* that are interactively maintained. */
public void setmergefactor int mergefactor
if  mergefactor < 2
throw new illegalargumentexception
this mergefactor   mergefactor
// javadoc inherited
public boolean usecompoundfile segmentinfos infos  segmentinfo info
return usecompoundfile
/** sets whether compound file format should be used for
*  newly flushed and newly merged segments. */
public void setusecompoundfile boolean usecompoundfile
this usecompoundfile   usecompoundfile
/** returns true if newly flushed and newly merge segments
*  are written in compound file format. @see
*  #setusecompoundfile */
public boolean getusecompoundfile
return usecompoundfile
// javadoc inherited
public boolean usecompounddocstore segmentinfos infos
return usecompounddocstore
/** sets whether compound file format should be used for
*  newly flushed and newly merged doc store
*  segment files (term vectors and stored fields). */
public void setusecompounddocstore boolean usecompounddocstore
this usecompounddocstore   usecompounddocstore
/** returns true if newly flushed and newly merge doc
*  store segment files (term vectors and stored fields)
*  are written in compound file format. @see
*  #setusecompounddocstore */
public boolean getusecompounddocstore
return usecompounddocstore
public void close
abstract protected long size segmentinfo info  throws ioexception
private boolean isoptimized segmentinfos infos  indexwriter writer  int maxnumsegments  set segmentstooptimize  throws ioexception
final int numsegments   infos size
int numtooptimize   0
segmentinfo optimizeinfo   null
for int i 0 i<numsegments    numtooptimize <  maxnumsegments i
final segmentinfo info   infos info i
if  segmentstooptimize contains info
numtooptimize
optimizeinfo   info
return numtooptimize <  maxnumsegments
numtooptimize    1    isoptimized writer  optimizeinfo
/** returns true if this single nfo is optimized (has no
*  pending norms or deletes, is in the same dir as the
*  writer, and matches the current compound file setting */
private boolean isoptimized indexwriter writer  segmentinfo info
throws ioexception
return  info hasdeletions
info hasseparatenorms
info dir    writer getdirectory
info getusecompoundfile      usecompoundfile
/** returns the merges necessary to optimize the index.
*  this merge policy defines "optimized" to mean only one
*  segment in the index, where that segment has no
*  deletions pending nor separate norms, and it is in
*  compound file format if the current usecompoundfile
*  setting is true.  this method returns multiple merges
*  (mergefactor at a time) so the {@link mergescheduler}
*  in use may make use of concurrency. */
public mergespecification findmergesforoptimize segmentinfos infos  indexwriter writer  int maxnumsegments  set segmentstooptimize  throws ioexception
mergespecification spec
assert maxnumsegments > 0
if   isoptimized infos  writer  maxnumsegments  segmentstooptimize
// find the newest (rightmost) segment that needs to
// be optimized (other segments may have been flushed
// since optimize started):
int last   infos size
while last > 0
final segmentinfo info   infos info   last
if  segmentstooptimize contains info
last
break
if  last > 0
spec   new mergespecification
// first, enroll all "full" merges (size
// mergefactor) to potentially be run concurrently:
while  last   maxnumsegments   1 >  mergefactor
spec add new onemerge infos range last mergefactor  last   usecompoundfile
last    mergefactor
// only if there are no full merges pending do we
// add a final partial (< mergefactor segments) merge:
if  0    spec merges size
if  maxnumsegments    1
// since we must optimize down to 1 segment, the
// choice is simple:
if  last > 1     isoptimized writer  infos info 0
spec add new onemerge infos range 0  last   usecompoundfile
else if  last > maxnumsegments
// take care to pick a partial merge that is
// least cost, but does not make the index too
// lopsided.  if we always just picked the
// partial tail then we could produce a highly
// lopsided index over time:
// we must merge this many segments to leave
// maxnumsegments in the index (from when
// optimize was first kicked off):
final int finalmergesize   last   maxnumsegments   1
// consider all possible starting points:
long bestsize   0
int beststart   0
for int i 0 i<last finalmergesize 1 i
long sumsize   0
for int j 0 j<finalmergesize j
sumsize    size infos info j i
if  i    0     sumsize < 2 size infos info i 1      sumsize < bestsize
beststart   i
bestsize   sumsize
spec add new onemerge infos range beststart  beststart finalmergesize   usecompoundfile
else
spec   null
else
spec   null
return spec
/** checks if any merges are now necessary and returns a
*  {@link mergepolicy.mergespecification} if so.  a merge
*  is necessary when there are more than {@link
*  #setmergefactor} segments at a given level.  when
*  multiple levels have too many segments, this method
*  will return multiple merges, allowing the {@link
*  mergescheduler} to use concurrency. */
public mergespecification findmerges segmentinfos infos  indexwriter writer  throws ioexception
final int numsegments   infos size
this writer   writer
message     numsegments
// compute levels, which is just log (base mergefactor)
// of the size of each segment
float levels   new float
final float norm    float  math log mergefactor
final directory directory   writer getdirectory
for int i 0 i<numsegments i
final segmentinfo info   infos info i
long size   size info
// refuse to import a segment that's too large
if  info doccount > maxmergedocs    info dir    directory
throw new illegalargumentexception     info doccount       maxmergedocs
if  size >  maxmergesize    info dir    directory
throw new illegalargumentexception     size       maxmergesize
// floor tiny segments
if  size < 1
size   1
levels    float  math log size  norm
final float levelfloor
if  minmergesize <  0
levelfloor    float  0 0
else
levelfloor    float   math log minmergesize  norm
// now, we quantize the log values into levels.  the
// first level is any segment whose log size is within
// level_log_span of the max size, or, who has such as
// segment "to the right".  then, we find the max of all
// other segments and use that to define the next level
// segment, etc.
mergespecification spec   null
int start   0
while start < numsegments
// find max level of all segments not already
// quantized.
float maxlevel   levels
for int i 1 start i<numsegments i
final float level   levels
if  level > maxlevel
maxlevel   level
// now search backwards for the rightmost segment that
// falls into this level:
float levelbottom
if  maxlevel < levelfloor
// all remaining segments fall into the min level
levelbottom    1 0f
else
levelbottom    float   maxlevel   level_log_span
// force a boundary at the level floor
if  levelbottom < levelfloor    maxlevel >  levelfloor
levelbottom   levelfloor
int upto   numsegments 1
while upto >  start
if  levels >  levelbottom
break
upto
message     levelbottom       maxlevel        1 upto start
// finally, record all merges that are viable at this level:
int end   start   mergefactor
while end <  1 upto
boolean anytoolarge   false
for int i start i<end i
final segmentinfo info   infos info i
anytoolarge     size info  >  maxmergesize    info doccount >  maxmergedocs
if   anytoolarge
if  spec    null
spec   new mergespecification
message     start       end
spec add new onemerge infos range start  end   usecompoundfile
else
message     start       end
start   end
end   start   mergefactor
start   1 upto
return spec
/** <p>determines the largest segment (measured by
* document count) that may be merged with other segments.
* small values (e.g., less than 10,000) are best for
* interactive indexing, as this limits the length of
* pauses while indexing to a few seconds.  larger values
* are best for batched indexing and speedier
* searches.</p>
*
* <p>the default value is {@link integer#max_value}.</p>
*
* <p>the default merge policy ({@link
* logbytesizemergepolicy}) also allows you to set this
* limit by net size (in mb) of the segment, using {@link
* logbytesizemergepolicy#setmaxmergemb}.</p>
*/
public void setmaxmergedocs int maxmergedocs
this maxmergedocs   maxmergedocs
/** returns the largest segment (measured by document
*  count) that may be merged with other segments.
*  @see #setmaxmergedocs */
public int getmaxmergedocs
return maxmergedocs