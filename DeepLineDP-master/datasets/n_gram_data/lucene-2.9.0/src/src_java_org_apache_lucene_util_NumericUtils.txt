package org apache lucene util
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import org apache lucene analysis numerictokenstream     for javadocs
import org apache lucene document numericfield     for javadocs
import org apache lucene search numericrangequery     for javadocs
import org apache lucene search numericrangefilter     for javadocs
/**
* this is a helper class to generate prefix-encoded representations for numerical values
* and supplies converters to represent float/double values as sortable integers/longs.
*
* <p>to quickly execute range queries in apache lucene, a range is divided recursively
* into multiple intervals for searching: the center of the range is searched only with
* the lowest possible precision in the trie, while the boundaries are matched
* more exactly. this reduces the number of terms dramatically.
*
* <p>this class generates terms to achieve this: first the numerical integer values need to
* be converted to strings. for that integer values (32 bit or 64 bit) are made unsigned
* and the bits are converted to ascii chars with each 7 bit. the resulting string is
* sortable like the original integer value. each value is also prefixed
* (in the first char) by the <code>shift</code> value (number of bits removed) used
* during encoding.
*
* <p>to also index floating point numbers, this class supplies two methods to convert them
* to integer values by changing their bit layout: {@link #doubletosortablelong},
* {@link #floattosortableint}. you will have no precision loss by
* converting floating point numbers to integers and back (only that the integer form
* is not usable). other data types like dates can easily converted to longs or ints (e.g.
* date to long: {@link java.util.date#gettime}).
*
* <p>for easy usage, the trie algorithm is implemented for indexing inside
* {@link numerictokenstream} that can index <code>int</code>, <code>long</code>,
* <code>float</code>, and <code>double</code>. for querying,
* {@link numericrangequery} and {@link numericrangefilter} implement the query part
* for the same data types.
*
* <p>this class can also be used, to generate lexicographically sortable (according
* {@link string#compareto(string)}) representations of numeric data types for other
* usages (e.g. sorting).
*
* <p><font color="red"><b>note:</b> this api is experimental and
* might change in incompatible ways in the next release.</font>
*
* @since 2.9
*/
public final class numericutils
private numericutils         no instance
/**
* the default precision step used by {@link numericfield}, {@link numerictokenstream},
* {@link numericrangequery}, and {@link numericrangefilter} as default
*/
public static final int precision_step_default   4
/**
* expert: longs are stored at lower precision by shifting off lower bits. the shift count is
* stored as <code>shift_start_long+shift</code> in the first character
*/
public static final char shift_start_long    char 0x20
/**
* expert: the maximum term length (used for <code>char[]</code> buffer size)
* for encoding <code>long</code> values.
* @see #longtoprefixcoded(long,int,char[])
*/
public static final int buf_size_long   63 7   2
/**
* expert: integers are stored at lower precision by shifting off lower bits. the shift count is
* stored as <code>shift_start_int+shift</code> in the first character
*/
public static final char shift_start_int     char 0x60
/**
* expert: the maximum term length (used for <code>char[]</code> buffer size)
* for encoding <code>int</code> values.
* @see #inttoprefixcoded(int,int,char[])
*/
public static final int buf_size_int   31 7   2
/**
* expert: returns prefix coded bits after reducing the precision by <code>shift</code> bits.
* this is method is used by {@link numerictokenstream}.
* @param val the numeric value
* @param shift how many bits to strip from the right
* @param buffer that will contain the encoded chars, must be at least of {@link #buf_size_long}
* length
* @return number of chars written to buffer
*/
public static int longtoprefixcoded final long val  final int shift  final char buffer
if  shift>63    shift<0
throw new illegalargumentexception
int nchars    63 shift  7   1  len   nchars 1
buffer    char  shift_start_long   shift
long sortablebits   val ^ 0x8000000000000000l
sortablebits >>>  shift
while  nchars> 1
// store 7 bits per character for good efficiency when utf-8 encoding.
// the whole number is right-justified so that lucene can prefix-encode
// the terms more efficiently.
buffer    char  sortablebits   0x7f
sortablebits >>>  7
return len
/**
* expert: returns prefix coded bits after reducing the precision by <code>shift</code> bits.
* this is method is used by {@link longrangebuilder}.
* @param val the numeric value
* @param shift how many bits to strip from the right
*/
public static string longtoprefixcoded final long val  final int shift
final char buffer   new char
final int len   longtoprefixcoded val  shift  buffer
return new string buffer  0  len
/**
* this is a convenience method, that returns prefix coded bits of a long without
* reducing the precision. it can be used to store the full precision value as a
* stored field in index.
* <p>to decode, use {@link #prefixcodedtolong}.
*/
public static string longtoprefixcoded final long val
return longtoprefixcoded val  0
/**
* expert: returns prefix coded bits after reducing the precision by <code>shift</code> bits.
* this is method is used by {@link numerictokenstream}.
* @param val the numeric value
* @param shift how many bits to strip from the right
* @param buffer that will contain the encoded chars, must be at least of {@link #buf_size_int}
* length
* @return number of chars written to buffer
*/
public static int inttoprefixcoded final int val  final int shift  final char buffer
if  shift>31    shift<0
throw new illegalargumentexception
int nchars    31 shift  7   1  len   nchars 1
buffer    char  shift_start_int   shift
int sortablebits   val ^ 0x80000000
sortablebits >>>  shift
while  nchars> 1
// store 7 bits per character for good efficiency when utf-8 encoding.
// the whole number is right-justified so that lucene can prefix-encode
// the terms more efficiently.
buffer    char  sortablebits   0x7f
sortablebits >>>  7
return len
/**
* expert: returns prefix coded bits after reducing the precision by <code>shift</code> bits.
* this is method is used by {@link intrangebuilder}.
* @param val the numeric value
* @param shift how many bits to strip from the right
*/
public static string inttoprefixcoded final int val  final int shift
final char buffer   new char
final int len   inttoprefixcoded val  shift  buffer
return new string buffer  0  len
/**
* this is a convenience method, that returns prefix coded bits of an int without
* reducing the precision. it can be used to store the full precision value as a
* stored field in index.
* <p>to decode, use {@link #prefixcodedtoint}.
*/
public static string inttoprefixcoded final int val
return inttoprefixcoded val  0
/**
* returns a long from prefixcoded characters.
* rightmost bits will be zero for lower precision codes.
* this method can be used to decode e.g. a stored field.
* @throws numberformatexception if the supplied string is
* not correctly prefix encoded.
* @see #longtoprefixcoded(long)
*/
public static long prefixcodedtolong final string prefixcoded
final int shift   prefixcoded charat 0  shift_start_long
if  shift>63    shift<0
throw new numberformatexception
long sortablebits   0l
for  int i 1  len prefixcoded length    i<len  i
sortablebits <<  7
final char ch   prefixcoded charat i
if  ch>0x7f
throw new numberformatexception
integer tohexstring  int ch    i
sortablebits     long ch
return  sortablebits << shift  ^ 0x8000000000000000l
/**
* returns an int from prefixcoded characters.
* rightmost bits will be zero for lower precision codes.
* this method can be used to decode e.g. a stored field.
* @throws numberformatexception if the supplied string is
* not correctly prefix encoded.
* @see #inttoprefixcoded(int)
*/
public static int prefixcodedtoint final string prefixcoded
final int shift   prefixcoded charat 0  shift_start_int
if  shift>31    shift<0
throw new numberformatexception
int sortablebits   0
for  int i 1  len prefixcoded length    i<len  i
sortablebits <<  7
final char ch   prefixcoded charat i
if  ch>0x7f
throw new numberformatexception
integer tohexstring  int ch    i
sortablebits     int ch
return  sortablebits << shift  ^ 0x80000000
/**
* converts a <code>double</code> value to a sortable signed <code>long</code>.
* the value is converted by getting their ieee 754 floating-point &quot;double format&quot;
* bit layout and then some bits are swapped, to be able to compare the result as long.
* by this the precision is not reduced, but the value can easily used as a long.
* @see #sortablelongtodouble
*/
public static long doubletosortablelong double val
long f   double doubletorawlongbits val
if  f<0  f ^  0x7fffffffffffffffl
return f
/**
* convenience method: this just returns:
*   longtoprefixcoded(doubletosortablelong(val))
*/
public static string doubletoprefixcoded double val
return longtoprefixcoded doubletosortablelong val
/**
* converts a sortable <code>long</code> back to a <code>double</code>.
* @see #doubletosortablelong
*/
public static double sortablelongtodouble long val
if  val<0  val ^  0x7fffffffffffffffl
return double longbitstodouble val
/**
* convenience method: this just returns:
*    sortablelongtodouble(prefixcodedtolong(val))
*/
public static double prefixcodedtodouble string val
return sortablelongtodouble prefixcodedtolong val
/**
* converts a <code>float</code> value to a sortable signed <code>int</code>.
* the value is converted by getting their ieee 754 floating-point &quot;float format&quot;
* bit layout and then some bits are swapped, to be able to compare the result as int.
* by this the precision is not reduced, but the value can easily used as an int.
* @see #sortableinttofloat
*/
public static int floattosortableint float val
int f   float floattorawintbits val
if  f<0  f ^  0x7fffffff
return f
/**
* convenience method: this just returns:
*   inttoprefixcoded(floattosortableint(val))
*/
public static string floattoprefixcoded float val
return inttoprefixcoded floattosortableint val
/**
* converts a sortable <code>int</code> back to a <code>float</code>.
* @see #floattosortableint
*/
public static float sortableinttofloat int val
if  val<0  val ^  0x7fffffff
return float intbitstofloat val
/**
* convenience method: this just returns:
*    sortableinttofloat(prefixcodedtoint(val))
*/
public static float prefixcodedtofloat string val
return sortableinttofloat prefixcodedtoint val
/**
* expert: splits a long range recursively.
* you may implement a builder that adds clauses to a
* {@link org.apache.lucene.search.booleanquery} for each call to its
* {@link longrangebuilder#addrange(string,string)}
* method.
* <p>this method is used by {@link numericrangequery}.
*/
public static void splitlongrange final longrangebuilder builder
final int precisionstep   final long minbound  final long maxbound
splitrange builder  64  precisionstep  minbound  maxbound
/**
* expert: splits an int range recursively.
* you may implement a builder that adds clauses to a
* {@link org.apache.lucene.search.booleanquery} for each call to its
* {@link intrangebuilder#addrange(string,string)}
* method.
* <p>this method is used by {@link numericrangequery}.
*/
public static void splitintrange final intrangebuilder builder
final int precisionstep   final int minbound  final int maxbound
splitrange builder  32  precisionstep   long minbound   long maxbound
/** this helper does the splitting for both 32 and 64 bit. */
private static void splitrange
final object builder  final int valsize
final int precisionstep  long minbound  long maxbound
if  precisionstep < 1
throw new illegalargumentexception
if  minbound > maxbound  return
for  int shift 0    shift    precisionstep
// calculate new bounds for inner precision
final long diff   1l <<  shift precisionstep
mask     1l<<precisionstep    1l  << shift
final boolean
haslower    minbound   mask     0l
hasupper    maxbound   mask     mask
final long
nextminbound    haslower ?  minbound   diff    minbound    ~mask
nextmaxbound    hasupper ?  maxbound   diff    maxbound    ~mask
if  shift precisionstep> valsize    nextminbound>nextmaxbound
// we are in the lowest precision or the next precision is not available.
addrange builder  valsize  minbound  maxbound  shift
// exit the split recursion loop
break
if  haslower
addrange builder  valsize  minbound  minbound   mask  shift
if  hasupper
addrange builder  valsize  maxbound   ~mask  maxbound  shift
// recurse to next precision
minbound   nextminbound
maxbound   nextmaxbound
/** helper that delegates to correct range builder */
private static void addrange
final object builder  final int valsize
long minbound  long maxbound
final int shift
// for the max bound set all lower bits (that were shifted away):
// this is important for testing or other usages of the splitted range
// (e.g. to reconstruct the full range). the prefixencoding will remove
// the bits anyway, so they do not hurt!
maxbound     1l << shift    1l
// delegate to correct range builder
switch valsize
case 64
longrangebuilder builder  addrange minbound  maxbound  shift
break
case 32
intrangebuilder builder  addrange  int minbound   int maxbound  shift
break
default
// should not happen!
throw new illegalargumentexception
/**
* expert: callback for {@link #splitlongrange}.
* you need to overwrite only one of the methods.
* <p><font color="red"><b>note:</b> this is a very low-level interface,
* the method signatures may change in later versions.</font>
*/
public static abstract class longrangebuilder
/**
* overwrite this method, if you like to receive the already prefix encoded range bounds.
* you can directly build classical (inclusive) range queries from them.
*/
public void addrange string minprefixcoded  string maxprefixcoded
throw new unsupportedoperationexception
/**
* overwrite this method, if you like to receive the raw long range bounds.
* you can use this for e.g. debugging purposes (print out range bounds).
*/
public void addrange final long min  final long max  final int shift
addrange longtoprefixcoded min  shift   longtoprefixcoded max  shift
/**
* expert: callback for {@link #splitintrange}.
* you need to overwrite only one of the methods.
* <p><font color="red"><b>note:</b> this is a very low-level interface,
* the method signatures may change in later versions.</font>
*/
public static abstract class intrangebuilder
/**
* overwrite this method, if you like to receive the already prefix encoded range bounds.
* you can directly build classical range (inclusive) queries from them.
*/
public void addrange string minprefixcoded  string maxprefixcoded
throw new unsupportedoperationexception
/**
* overwrite this method, if you like to receive the raw int range bounds.
* you can use this for e.g. debugging purposes (print out range bounds).
*/
public void addrange final int min  final int max  final int shift
addrange inttoprefixcoded min  shift   inttoprefixcoded max  shift