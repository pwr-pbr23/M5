package org apache lucene search
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import org apache lucene index indexreader
/**
* the {@link timelimitingcollector} is used to timeout search requests that
* take longer than the maximum allowed search time limit. after this time is
* exceeded, the search thread is stopped by throwing a
* {@link timeexceededexception}.
*/
public class timelimitingcollector extends collector
/**
* default timer resolution.
* @see #setresolution(long)
*/
public static final int default_resolution   20
/**
* default for {@link #isgreedy()}.
* @see #isgreedy()
*/
public boolean default_greedy   false
private static long resolution   default_resolution
private boolean greedy   default_greedy
private static final class timerthread extends thread
// note: we can avoid explicit synchronization here for several reasons:
// * updates to volatile long variables are atomic
// * only single thread modifies this value
// * use of volatile keyword ensures that it does not reside in
//   a register, but in main memory (so that changes are visible to
//   other threads).
// * visibility of changes does not need to be instantaneous, we can
//   afford losing a tick or two.
//
// see section 17 of the java language specification for details.
private volatile long time   0
/**
* timerthread provides a pseudo-clock service to all searching
* threads, so that they can count elapsed time with less overhead
* than repeatedly calling system.currenttimemillis.  a single
* thread should be created to be used for all searches.
*/
private timerthread
super
this setdaemon  true
public void run
while  true
// todo: use system.nanotime() when lucene moves to java se 5.
time    resolution
try
thread sleep  resolution
catch  interruptedexception ie
thread currentthread   interrupt
throw new runtimeexception ie
/**
* get the timer value in milliseconds.
*/
public long getmilliseconds
return time
/** thrown when elapsed search time exceeds allowed search time. */
public static class timeexceededexception extends runtimeexception
private long timeallowed
private long timeelapsed
private int lastdoccollected
private timeexceededexception long timeallowed  long timeelapsed  int lastdoccollected
super     timeelapsed       timeallowed
this timeallowed   timeallowed
this timeelapsed   timeelapsed
this lastdoccollected   lastdoccollected
/** returns allowed time (milliseconds). */
public long gettimeallowed
return timeallowed
/** returns elapsed time (milliseconds). */
public long gettimeelapsed
return timeelapsed
/** returns last doc that was collected when the search time exceeded. */
public int getlastdoccollected
return lastdoccollected
// declare and initialize a single static timer thread to be used by
// all timelimitedcollector instances.  the jvm assures that
// this only happens once.
private final static timerthread timer_thread   new timerthread
static
timer_thread start
private final long t0
private final long timeout
private final collector collector
/**
* create a timelimitedcollector wrapper over another {@link collector} with a specified timeout.
* @param collector the wrapped {@link collector}
* @param timeallowed max time allowed for collecting hits after which {@link timeexceededexception} is thrown
*/
public timelimitingcollector final collector collector  final long timeallowed
this collector   collector
t0   timer_thread getmilliseconds
this timeout   t0   timeallowed
/**
* return the timer resolution.
* @see #setresolution(long)
*/
public static long getresolution
return resolution
/**
* set the timer resolution.
* the default timer resolution is 20 milliseconds.
* this means that a search required to take no longer than
* 800 milliseconds may be stopped after 780 to 820 milliseconds.
* <br>note that:
* <ul>
* <li>finer (smaller) resolution is more accurate but less efficient.</li>
* <li>setting resolution to less than 5 milliseconds will be silently modified to 5 milliseconds.</li>
* <li>setting resolution smaller than current resolution might take effect only after current
* resolution. (assume current resolution of 20 milliseconds is modified to 5 milliseconds,
* then it can take up to 20 milliseconds for the change to have effect.</li>
* </ul>
*/
public static void setresolution long newresolution
resolution   math max newresolution 5      5 milliseconds is about the minimum reasonable time for a object wait long  call
/**
* checks if this time limited collector is greedy in collecting the last hit.
* a non greedy collector, upon a timeout, would throw a {@link timeexceededexception}
* without allowing the wrapped collector to collect current doc. a greedy one would
* first allow the wrapped hit collector to collect current doc and only then
* throw a {@link timeexceededexception}.
* @see #setgreedy(boolean)
*/
public boolean isgreedy
return greedy
/**
* sets whether this time limited collector is greedy.
* @param greedy true to make this time limited greedy
* @see #isgreedy()
*/
public void setgreedy boolean greedy
this greedy   greedy
/**
* calls {@link collector#collect(int)} on the decorated {@link collector}
* unless the allowed time has passed, in which case it throws an exception.
*
* @throws timeexceededexception
*           if the time allowed has exceeded.
*/
public void collect final int doc  throws ioexception
long time   timer_thread getmilliseconds
if  timeout < time
if  greedy
//system.out.println(this+"  greedy: before failing, collecting doc: "+doc+"  "+(time-t0));
collector collect doc
//system.out.println(this+"  failing on:  "+doc+"  "+(time-t0));
throw new timeexceededexception  timeout t0  time t0  doc
//system.out.println(this+"  collecting: "+doc+"  "+(time-t0));
collector collect doc
public void setnextreader indexreader reader  int base  throws ioexception
collector setnextreader reader  base
public void setscorer scorer scorer  throws ioexception
collector setscorer scorer
public boolean acceptsdocsoutoforder
return collector acceptsdocsoutoforder