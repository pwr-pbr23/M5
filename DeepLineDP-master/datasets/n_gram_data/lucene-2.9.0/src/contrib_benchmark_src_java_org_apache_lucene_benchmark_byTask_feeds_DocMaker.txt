package org apache lucene benchmark bytask feeds
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java io unsupportedencodingexception
import java util hashmap
import java util iterator
import java util map
import java util properties
import java util map entry
import java util random
import org apache lucene benchmark bytask utils config
import org apache lucene benchmark bytask utils format
import org apache lucene document document
import org apache lucene document field
import org apache lucene document field index
import org apache lucene document field store
import org apache lucene document field termvector
/**
* creates {@link document} objects. uses a {@link contentsource} to generate
* {@link docdata} objects. supports the following parameters:
* <ul>
* <li><b>content.source</b> - specifies the {@link contentsource} class to use
* (default <b>singledocsource</b>).
* <li><b>doc.stored</b> - specifies whether fields should be stored (default
* <b>false</b>).
* <li><b>doc.tokenized</b> - specifies whether fields should be tokenized
* (default <b>true</b>).
* <li><b>doc.tokenized.norms</b> - specifies whether norms should be stored in
* the index or not. (default <b>false</b>).
* <li><b>doc.body.tokenized.norms</b> - specifies whether norms should be
* stored in the index for the body field. this can be set to true, while
* <code>doc.tokenized.norms</code> is set to false, to allow norms storing just
* for the body field. (default <b>true</b>).
* <li><b>doc.term.vector</b> - specifies whether term vectors should be stored
* for fields (default <b>false</b>).
* <li><b>doc.term.vector.positions</b> - specifies whether term vectors should
* be stored with positions (default <b>false</b>).
* <li><b>doc.term.vector.offsets</b> - specifies whether term vectors should be
* stored with offsets (default <b>false</b>).
* <li><b>doc.store.body.bytes</b> - specifies whether to store the raw bytes of
* the document's content in the document (default <b>false</b>).
* <li><b>doc.reuse.fields</b> - specifies whether field and document objects
* should be reused (default <b>true</b>).
* <li><b>doc.index.props</b> - specifies whether the properties returned by
* <li><b>doc.random.id.limit</b> - if specified, docs will be assigned random
* ids from 0 to this limit.  this is useful with updatedoc
* for testing performance of indexwriter.updatedocument.
* {@link docdata#getprops()} will be indexed. (default <b>false</b>).
* </ul>
*/
public class docmaker
private static class leftover
private docdata docdata
private int cnt
private random r
private int updatedocidlimit
static class docstate
private final map fields
private final boolean reusefields
final document doc
docdata docdata   new docdata
public docstate boolean reusefields  store store  index index  index bodyindex  termvector termvector
this reusefields   reusefields
if  reusefields
fields    new hashmap
// initialize the map with the default fields.
fields put body_field  new field body_field     store  bodyindex  termvector
fields put title_field  new field title_field     store  index  termvector
fields put date_field  new field date_field     store  index  termvector
fields put id_field  new field id_field     field store yes  field index not_analyzed_no_norms
fields put name_field  new field name_field     store  index  termvector
doc   new document
else
fields   null
doc   null
/**
* returns a field corresponding to the field name. if
* <code>reusefields</code> was set to true, then it attempts to reuse a
* field instance. if such a field does not exist, it creates a new one.
*/
field getfield string name  store store  index index  termvector termvector
if   reusefields
return new field name     store  index  termvector
field f    field  fields get name
if  f    null
f   new field name     store  index  termvector
fields put name  f
return f
private int numdocscreated   0
private boolean storebytes   false
// leftovers are thread local, because it is unsafe to share residues between threads
private threadlocal leftovr   new threadlocal
private threadlocal docstate   new threadlocal
public static final string body_field
public static final string title_field
public static final string date_field
public static final string id_field
public static final string bytes_field
public static final string name_field
protected config config
protected store storeval   store no
protected index indexval   index analyzed_no_norms
protected index bodyindexval   index analyzed
protected termvector termvecval   termvector no
protected contentsource source
protected boolean reusefields
protected docstate localdocstate
protected boolean indexproperties
private int lastprintednumuniquetexts   0
private long lastprintednumuniquebytes   0
private int printnum   0
// create a doc
// use only part of the body, modify it to keep the rest (or use all if size==0).
// reset the docdata properties so they are not added more than once.
private document createdocument docdata docdata  int size  int cnt  throws unsupportedencodingexception
final docstate ds   reusefields ? getdocstate     localdocstate
final document doc   reusefields ? ds doc   new document
doc getfields   clear
// set id_field
field idfield   ds getfield id_field  storeval  index not_analyzed_no_norms  termvecval
idfield setvalue      r    null ? r nextint updatedocidlimit    incrnumdocscreated
doc add idfield
// set name_field
string name   docdata getname
if  name    null  name
name   cnt < 0 ? name   name       cnt
field namefield   ds getfield name_field  storeval  indexval  termvecval
namefield setvalue name
doc add namefield
// set date_field
string date   docdata getdate
if  date    null
date
field datefield   ds getfield date_field  storeval  indexval  termvecval
datefield setvalue date
doc add datefield
// set title_field
string title   docdata gettitle
field titlefield   ds getfield title_field  storeval  indexval  termvecval
titlefield setvalue title    null ?     title
doc add titlefield
string body   docdata getbody
if  body    null    body length   > 0
string bdy
if  size <  0    size >  body length
bdy   body     use all
docdata setbody        nothing left
else
// attempt not to break words - if whitespace found within next 20 chars...
for  int n   size   1  n < size   20    n < body length    n
if  character iswhitespace body charat n
size   n
break
bdy   body substring 0  size      use part
docdata setbody body substring size       some left
field bodyfield   ds getfield body_field  storeval  bodyindexval  termvecval
bodyfield setvalue bdy
doc add bodyfield
if  storebytes
field bytesfield   ds getfield bytes_field  store yes  index not_analyzed_no_norms  termvector no
bytesfield setvalue bdy getbytes
doc add bytesfield
if  indexproperties
properties props   docdata getprops
if  props    null
for  iterator iterator   props entryset   iterator    iterator hasnext
entry entry    entry  iterator next
field f   ds getfield  string  entry getkey    storeval  indexval  termvecval
f setvalue  string  entry getvalue
doc add f
docdata setprops null
//system.out.println("============== created doc "+numdocscreated+" :\n"+doc+"\n==========");
return doc
private void resetleftovers
leftovr set null
protected docstate getdocstate
docstate ds    docstate  docstate get
if  ds    null
ds   new docstate true  storeval  indexval  bodyindexval  termvecval
docstate set ds
return ds
protected synchronized int incrnumdocscreated
return numdocscreated
/**
* closes the {@link docmaker}. the base implementation closes the
* {@link contentsource}, and it can be overridden to do more work (but make
* sure to call super.close()).
*/
public void close   throws ioexception
source close
/**
* returns the number of bytes generated by the content source since last
* reset.
*/
public synchronized long getbytescount
return source getbytescount
/**
* returns the total number of bytes that were generated by the content source
* defined to that doc maker.
*/
public long gettotalbytescount
return source gettotalbytescount
/**
* creates a {@link document} object ready for indexing. this method uses the
* {@link contentsource} to get the next document from the source, and creates
* a {@link document} object from the returned fields. if
* <code>reusefields</code> was set to true, it will reuse {@link document}
* and {@link field} instances.
*/
public document makedocument   throws exception
resetleftovers
docdata docdata   source getnextdocdata reusefields ? getdocstate   docdata   localdocstate docdata
document doc   createdocument docdata  0   1
return doc
/**
* same as {@link #makedocument()}, only this method creates a document of the
* given size input by <code>size</code>.
*/
public document makedocument int size  throws exception
leftover lvr    leftover  leftovr get
if  lvr    null    lvr docdata    null    lvr docdata getbody      null
lvr docdata getbody   length      0
resetleftovers
docdata docdata   reusefields ? getdocstate   docdata   localdocstate docdata
docdata dd    lvr    null ? source getnextdocdata docdata    lvr docdata
int cnt    lvr    null ? 0   lvr cnt
while  dd getbody      null    dd getbody   length   < size
docdata dd2   dd
dd   source getnextdocdata new docdata
cnt   0
dd setbody dd2 getbody     dd getbody
document doc   createdocument dd  size  cnt
if  dd getbody      null    dd getbody   length      0
resetleftovers
else
if  lvr    null
lvr   new leftover
leftovr set lvr
lvr docdata   dd
lvr cnt     cnt
return doc
public void printdocstatistics
boolean print   false
string col
stringbuffer sb   new stringbuffer
string newline   system getproperty
sb append    append format simplename getclass     append    append printnum  append    append newline
int nut   source gettotaldocscount
if  nut > lastprintednumuniquetexts
print   true
sb append    append format format 0 nut col   append newline
lastprintednumuniquetexts   nut
long nub   gettotalbytescount
if  nub > lastprintednumuniquebytes
print   true
sb append    append format format 0 nub col   append newline
lastprintednumuniquebytes   nub
if  source getdocscount   > 0
print   true
sb append    append format format 0 source getdocscount   col   append newline
sb append    append format format 0 getbytescount   col   append newline
if  print
system out println sb append newline  tostring
printnum
/** reset inputs so that the test run would behave, input wise, as if it just started. */
public synchronized void resetinputs   throws ioexception
printdocstatistics
// re-initiate since properties by round may have changed.
setconfig config
source resetinputs
numdocscreated   0
resetleftovers
/** set the configuration parameters of this doc maker. */
public void setconfig config config
this config   config
try
string sourceclass   config get
source    contentsource  class forname sourceclass  newinstance
source setconfig config
catch  exception e
// should not get here. throw runtime exception.
throw new runtimeexception e
boolean stored   config get    false
boolean tokenized   config get    true
boolean norms   config get    false
boolean bodynorms   config get    true
boolean termvec   config get    false
storeval    stored ? field store yes   field store no
if  tokenized
indexval   norms ? index analyzed   index analyzed_no_norms
bodyindexval   bodynorms ? index analyzed   index analyzed_no_norms
else
indexval   norms ? index not_analyzed   index not_analyzed_no_norms
bodyindexval   bodynorms ? index not_analyzed   index not_analyzed_no_norms
boolean termvecpositions   config get    false
boolean termvecoffsets   config get    false
if  termvecpositions    termvecoffsets
termvecval   termvector with_positions_offsets
else if  termvecpositions
termvecval   termvector with_positions
else if  termvecoffsets
termvecval   termvector with_offsets
else if  termvec
termvecval   termvector yes
else
termvecval   termvector no
storebytes   config get    false
reusefields   config get    true
if   reusefields
localdocstate   new docstate false  storeval  indexval  bodyindexval  termvecval
else
// in a multi-rounds run, it is important to reset docstate since settings
// of fields may change between rounds, and this is the only way to reset
// the cache of all threads.
docstate   new threadlocal
indexproperties   config get    false
updatedocidlimit   config get     1
if  updatedocidlimit     1
r   new random 179