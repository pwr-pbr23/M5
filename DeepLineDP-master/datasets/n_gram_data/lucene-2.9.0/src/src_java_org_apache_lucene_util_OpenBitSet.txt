/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache lucene util
import java util arrays
import java io serializable
import org apache lucene search docidset
import org apache lucene search docidsetiterator
/** an "open" bitset implementation that allows direct access to the array of words
* storing the bits.
* <p/>
* unlike java.util.bitset, the fact that bits are packed into an array of longs
* is part of the interface.  this allows efficient implementation of other algorithms
* by someone other than the author.  it also allows one to efficiently implement
* alternate serialization or interchange formats.
* <p/>
* <code>openbitset</code> is faster than <code>java.util.bitset</code> in most operations
* and *much* faster at calculating cardinality of sets and results of set operations.
* it can also handle sets of larger cardinality (up to 64 * 2**32-1)
* <p/>
* the goals of <code>openbitset</code> are the fastest implementation possible, and
* maximum code reuse.  extra safety and encapsulation
* may always be built on top, but if that's built in, the cost can never be removed (and
* hence people re-implement their own version in order to get better performance).
* if you want a "safe", totally encapsulated (and slower and limited) bitset
* class, use <code>java.util.bitset</code>.
* <p/>
* <h3>performance results</h3>
*
test system: pentium 4, sun java 1.5_06 -server -xbatch -xmx64m
<br/>bitset size = 1,000,000
<br/>results are java.util.bitset time divided by openbitset time.
<table border="1">
<tr>
<th></th> <th>cardinality</th> <th>intersect_count</th> <th>union</th> <th>nextsetbit</th> <th>get</th> <th>iterator</th>
</tr>
<tr>
<th>50% full</th> <td>3.36</td> <td>3.96</td> <td>1.44</td> <td>1.46</td> <td>1.99</td> <td>1.58</td>
</tr>
<tr>
<th>1% full</th> <td>3.31</td> <td>3.90</td> <td>&nbsp;</td> <td>1.04</td> <td>&nbsp;</td> <td>0.99</td>
</tr>
</table>
<br/>
test system: amd opteron, 64 bit linux, sun java 1.5_06 -server -xbatch -xmx64m
<br/>bitset size = 1,000,000
<br/>results are java.util.bitset time divided by openbitset time.
<table border="1">
<tr>
<th></th> <th>cardinality</th> <th>intersect_count</th> <th>union</th> <th>nextsetbit</th> <th>get</th> <th>iterator</th>
</tr>
<tr>
<th>50% full</th> <td>2.50</td> <td>3.50</td> <td>1.00</td> <td>1.03</td> <td>1.12</td> <td>1.25</td>
</tr>
<tr>
<th>1% full</th> <td>2.51</td> <td>3.49</td> <td>&nbsp;</td> <td>1.00</td> <td>&nbsp;</td> <td>1.02</td>
</tr>
</table>
* @version $id$
*/
public class openbitset extends docidset implements cloneable  serializable
protected long bits
protected int wlen       number of words  elements  used in the array
/** constructs an openbitset large enough to hold numbits.
*
* @param numbits
*/
public openbitset long numbits
bits   new long
wlen   bits length
}
public openbitset
this 64
}
/** constructs an openbitset from an existing long[].
* <br/>
* the first 64 bits are in long[0],
* with bit index 0 at the least significant bit, and bit index 63 at the most significant.
* given a bit index,
* the word containing it is long[index/64], and it is at bit number index%64 within that word.
* <p>
* numwords are the number of elements in the array that contain
* set bits (non-zero longs).
* numwords should be &lt= bits.length, and
* any existing words in the array at position &gt= numwords should be zero.
*
*/
public openbitset long bits  int numwords
this bits   bits
this wlen   numwords
}
public docidsetiterator iterator
return new openbitsetiterator bits  wlen
}
/** this docidset implementation is cacheable. */
public boolean iscacheable
return true
}
/** returns the current capacity in bits (1 greater than the index of the last bit) */
public long capacity     return bits length << 6
/**
* returns the current capacity of this set.  included for
* compatibility.  this is *not* equal to {@link #cardinality}
*/
public long size
return capacity
}
/** returns true if there are no set bits */
public boolean isempty     return cardinality    0
/** expert: returns the long[] storing the bits */
public long getbits     return bits
/** expert: sets a new long[] to use as the bit storage */
public void setbits long bits    this bits   bits
/** expert: gets the number of longs in the array that are in use */
public int getnumwords     return wlen
/** expert: sets the number of longs in the array that are in use */
public void setnumwords int nwords    this wlen nwords
/** returns true or false for the specified bit index. */
public boolean get int index
int i   index >> 6                   div 64
// signed shift will keep a negative index and force an
// array-index-out-of-bounds-exception, removing the need for an explicit check.
if  i> bits length  return false
int bit   index   0x3f               mod 64
long bitmask   1l << bit
return  bits   bitmask     0
}
/** returns true or false for the specified bit index.
* the index should be less than the openbitset size
*/
public boolean fastget int index
int i   index >> 6                   div 64
// signed shift will keep a negative index and force an
// array-index-out-of-bounds-exception, removing the need for an explicit check.
int bit   index   0x3f               mod 64
long bitmask   1l << bit
return  bits   bitmask     0
}
/** returns true or false for the specified bit index
*/
public boolean get long index
int i    int  index >> 6                  div 64
if  i> bits length  return false
int bit    int index   0x3f               mod 64
long bitmask   1l << bit
return  bits   bitmask     0
}
/** returns true or false for the specified bit index.
* the index should be less than the openbitset size.
*/
public boolean fastget long index
int i    int  index >> 6                    div 64
int bit    int index   0x3f               mod 64
long bitmask   1l << bit
return  bits   bitmask     0
}
/*
// alternate implementation of get()
public boolean get1(int index) {
int i = index >> 6;                // div 64
int bit = index & 0x3f;            // mod 64
return ((bits[i]>>>bit) & 0x01) != 0;
// this does a long shift and a bittest (on x86) vs
// a long shift, and a long and, (the test for zero is prob a no-op)
// testing on a p4 indicates this is slower than (bits[i] & bitmask) != 0;
}
*/
/** returns 1 if the bit is set, 0 if not.
* the index should be less than the openbitset size
*/
public int getbit int index
int i = index >> 6;                // div 64
int bit = index & 0x3f;            // mod 64
return   int  bits>>>bit     0x01
}
/*
public boolean get2(int index) {
int word = index >> 6;            // div 64
int bit = index & 0x0000003f;     // mod 64
return (bits[word] << bit) < 0;   // hmmm, this would work if bit order were reversed
// we could right shift and check for parity bit, if it was available to us.
}
*/
/** sets a bit, expanding the set size if necessary */
public void set long index
int wordnum   expandingwordnum index
int bit    int index   0x3f
long bitmask   1l << bit
bits    bitmask
}
/** sets the bit at the specified index.
* the index should be less than the openbitset size.
*/
public void fastset int index
int wordnum   index >> 6          div 64
int bit   index   0x3f         mod 64
long bitmask   1l << bit
bits    bitmask
}
/** sets the bit at the specified index.
* the index should be less than the openbitset size.
*/
public void fastset long index
int wordnum    int  index >> 6
int bit    int index   0x3f
long bitmask   1l << bit
bits    bitmask
}
/** sets a range of bits, expanding the set size if necessary
*
* @param startindex lower index
* @param endindex one-past the last bit to set
*/
public void set long startindex  long endindex
if  endindex <  startindex  return
int startword    int  startindex>>6
// since endindex is one past the end, this is index of the last
// word to be changed.
int endword     expandingwordnum endindex 1
long startmask    1l << startindex
long endmask    1l >>>  endindex      64  endindex 0x3f  is the same as  endindex due to wrap
if  startword    endword
bits     startmask   endmask
return
}
bits    startmask
arrays fill bits  startword 1  endword   1l
bits    endmask
}
protected int expandingwordnum long index
int wordnum    int  index >> 6
if  wordnum> wlen
ensurecapacity index 1
wlen   wordnum 1
}
return wordnum
}
/** clears a bit.
* the index should be less than the openbitset size.
*/
public void fastclear int index
int wordnum   index >> 6
int bit   index   0x03f
long bitmask   1l << bit
bits    ~bitmask
// hmmm, it takes one more instruction to clear than it does to set... any
// way to work around this?  if there were only 63 bits per word, we could
// use a right shift of 10111111...111 in binary to position the 0 in the
// correct place (using sign extension).
// could also use long.rotateright() or rotateleft() *if* they were converted
// by the jvm into a native instruction.
// bits[word] &= long.rotateleft(0xfffffffe,bit);
}
/** clears a bit.
* the index should be less than the openbitset size.
*/
public void fastclear long index
int wordnum    int  index >> 6      div 64
int bit    int index   0x3f         mod 64
long bitmask   1l << bit
bits    ~bitmask
}
/** clears a bit, allowing access beyond the current set size without changing the size.*/
public void clear long index
int wordnum    int  index >> 6      div 64
if  wordnum> wlen  return
int bit    int index   0x3f         mod 64
long bitmask   1l << bit
bits    ~bitmask
}
/** clears a range of bits.  clearing past the end does not change the size of the set.
*
* @param startindex lower index
* @param endindex one-past the last bit to clear
*/
public void clear int startindex  int endindex
if  endindex <  startindex  return
int startword    startindex>>6
if  startword >  wlen  return
// since endindex is one past the end, this is index of the last
// word to be changed.
int endword       endindex 1 >>6
long startmask    1l << startindex
long endmask    1l >>>  endindex      64  endindex 0x3f  is the same as  endindex due to wrap
// invert masks since we are clearing
startmask   ~startmask
endmask   ~endmask
if  startword    endword
bits     startmask   endmask
return
}
bits    startmask
int middle   math min wlen  endword
arrays fill bits  startword 1  middle  0l
if  endword < wlen
bits    endmask
}
}
/** clears a range of bits.  clearing past the end does not change the size of the set.
*
* @param startindex lower index
* @param endindex one-past the last bit to clear
*/
public void clear long startindex  long endindex
if  endindex <  startindex  return
int startword    int  startindex>>6
if  startword >  wlen  return
// since endindex is one past the end, this is index of the last
// word to be changed.
int endword      int   endindex 1 >>6
long startmask    1l << startindex
long endmask    1l >>>  endindex      64  endindex 0x3f  is the same as  endindex due to wrap
// invert masks since we are clearing
startmask   ~startmask
endmask   ~endmask
if  startword    endword
bits     startmask   endmask
return
}
bits    startmask
int middle   math min wlen  endword
arrays fill bits  startword 1  middle  0l
if  endword < wlen
bits    endmask
}
}
/** sets a bit and returns the previous value.
* the index should be less than the openbitset size.
*/
public boolean getandset int index
int wordnum   index >> 6          div 64
int bit   index   0x3f         mod 64
long bitmask   1l << bit
boolean val    bits   bitmask     0
bits    bitmask
return val
}
/** sets a bit and returns the previous value.
* the index should be less than the openbitset size.
*/
public boolean getandset long index
int wordnum    int  index >> 6           div 64
int bit    int index   0x3f         mod 64
long bitmask   1l << bit
boolean val    bits   bitmask     0
bits    bitmask
return val
}
/** flips a bit.
* the index should be less than the openbitset size.
*/
public void fastflip int index
int wordnum   index >> 6          div 64
int bit   index   0x3f         mod 64
long bitmask   1l << bit
bits ^  bitmask
}
/** flips a bit.
* the index should be less than the openbitset size.
*/
public void fastflip long index
int wordnum    int  index >> 6        div 64
int bit    int index   0x3f           mod 64
long bitmask   1l << bit
bits ^  bitmask
}
/** flips a bit, expanding the set size if necessary */
public void flip long index
int wordnum   expandingwordnum index
int bit    int index   0x3f           mod 64
long bitmask   1l << bit
bits ^  bitmask
}
/** flips a bit and returns the resulting bit value.
* the index should be less than the openbitset size.
*/
public boolean flipandget int index
int wordnum   index >> 6          div 64
int bit   index   0x3f         mod 64
long bitmask   1l << bit
bits ^  bitmask
return  bits   bitmask     0
}
/** flips a bit and returns the resulting bit value.
* the index should be less than the openbitset size.
*/
public boolean flipandget long index
int wordnum    int  index >> 6        div 64
int bit    int index   0x3f           mod 64
long bitmask   1l << bit
bits ^  bitmask
return  bits   bitmask     0
}
/** flips a range of bits, expanding the set size if necessary
*
* @param startindex lower index
* @param endindex one-past the last bit to flip
*/
public void flip long startindex  long endindex
if  endindex <  startindex  return
int startword    int  startindex>>6
// since endindex is one past the end, this is index of the last
// word to be changed.
int endword     expandingwordnum endindex 1
/*** grrr, java shifting wraps around so -1l>>>64 == -1
* for that reason, make sure not to use endmask if the bits to flip will
* be zero in the last word (redefine endword to be the last changed...)
long startmask = -1l << (startindex & 0x3f);     // example: 11111...111000
long endmask = -1l >>> (64-(endindex & 0x3f));   // example: 00111...111111
***/
long startmask    1l << startindex
long endmask    1l >>>  endindex      64  endindex 0x3f  is the same as  endindex due to wrap
if  startword    endword
bits ^   startmask   endmask
return
}
bits ^  startmask
for  int i startword 1  i<endword  i
bits   ~bits
}
bits ^  endmask
}
/*
public static int pop(long v0, long v1, long v2, long v3) {
// derived from pop_array by setting last four elems to 0.
// exchanges one pop() call for 10 elementary operations
// saving about 7 instructions... is there a better way?
long twosa=v0 & v1;
long ones=v0^v1;
long u2=ones^v2;
long twosb =(ones&v2)|(u2&v3);
ones=u2^v3;
long fours=(twosa&twosb);
long twos=twosa^twosb;
return (pop(fours)<<2)
+ (pop(twos)<<1)
+ pop(ones);
}
*/
/** @return the number of set bits */
public long cardinality
return bitutil pop_array bits 0 wlen
}
/** returns the popcount or cardinality of the intersection of the two sets.
* neither set is modified.
*/
public static long intersectioncount openbitset a  openbitset b
return bitutil pop_intersect a bits  b bits  0  math min a wlen  b wlen
}
/** returns the popcount or cardinality of the union of the two sets.
* neither set is modified.
*/
public static long unioncount openbitset a  openbitset b
long tot   bitutil pop_union a bits  b bits  0  math min a wlen  b wlen
if  a wlen < b wlen
tot    bitutil pop_array b bits  a wlen  b wlen a wlen
else if  a wlen > b wlen
tot    bitutil pop_array a bits  b wlen  a wlen b wlen
}
return tot
}
/** returns the popcount or cardinality of "a and not b"
* or "intersection(a, not(b))".
* neither set is modified.
*/
public static long andnotcount openbitset a  openbitset b
long tot   bitutil pop_andnot a bits  b bits  0  math min a wlen  b wlen
if  a wlen > b wlen
tot    bitutil pop_array a bits  b wlen  a wlen b wlen
}
return tot
}
/** returns the popcount or cardinality of the exclusive-or of the two sets.
* neither set is modified.
*/
public static long xorcount openbitset a  openbitset b
long tot   bitutil pop_xor a bits  b bits  0  math min a wlen  b wlen
if  a wlen < b wlen
tot    bitutil pop_array b bits  a wlen  b wlen a wlen
else if  a wlen > b wlen
tot    bitutil pop_array a bits  b wlen  a wlen b wlen
}
return tot
}
/** returns the index of the first set bit starting at the index specified.
*  -1 is returned if there are no more set bits.
*/
public int nextsetbit int index
int i   index>>6
if  i> wlen  return  1
int subindex   index   0x3f          index within the word
long word   bits >> subindex      skip all the bits to the right of index
if  word  0
return  i<<6    subindex   bitutil ntz word
}
while   i < wlen
word   bits
if  word  0  return  i<<6    bitutil ntz word
}
return  1
}
/** returns the index of the first set bit starting at the index specified.
*  -1 is returned if there are no more set bits.
*/
public long nextsetbit long index
int i    int  index>>>6
if  i> wlen  return  1
int subindex    int index   0x3f     index within the word
long word   bits >>> subindex      skip all the bits to the right of index
if  word  0
return    long i <<6     subindex   bitutil ntz word
}
while   i < wlen
word   bits
if  word  0  return    long i <<6    bitutil ntz word
}
return  1
}
public object clone
try
openbitset obs    openbitset super clone
obs bits    long  obs bits clone        hopefully an array clone is as fast er  than arraycopy
return obs
catch  clonenotsupportedexception e
throw new runtimeexception e
}
}
/** this = this and other */
public void intersect openbitset other
int newlen  math min this wlen other wlen
long thisarr   this bits
long otherarr   other bits
// testing against zero can be more efficient
int pos newlen
while   pos> 0
thisarr    otherarr
}
if  this wlen > newlen
// fill zeros from the new shorter length to the old length
arrays fill bits newlen this wlen 0
}
this wlen   newlen
}
/** this = this or other */
public void union openbitset other
int newlen   math max wlen other wlen
ensurecapacitywords newlen
long thisarr   this bits
long otherarr   other bits
int pos math min wlen other wlen
while   pos> 0
thisarr    otherarr
}
if  this wlen < newlen
system arraycopy otherarr  this wlen  thisarr  this wlen  newlen this wlen
}
this wlen   newlen
}
/** remove all elements set in other. this = this and_not other */
public void remove openbitset other
int idx   math min wlen other wlen
long thisarr   this bits
long otherarr   other bits
while   idx> 0
thisarr    ~otherarr
}
}
/** this = this xor other */
public void xor openbitset other
int newlen   math max wlen other wlen
ensurecapacitywords newlen
long thisarr   this bits
long otherarr   other bits
int pos math min wlen other wlen
while   pos> 0
thisarr ^  otherarr
}
if  this wlen < newlen
system arraycopy otherarr  this wlen  thisarr  this wlen  newlen this wlen
}
this wlen   newlen
}
// some bitset compatability methods
//** see {@link intersect} */
public void and openbitset other
intersect other
}
//** see {@link union} */
public void or openbitset other
union other
}
//** see {@link andnot} */
public void andnot openbitset other
remove other
}
/** returns true if the sets have any elements in common */
public boolean intersects openbitset other
int pos   math min this wlen  other wlen
long thisarr   this bits
long otherarr   other bits
while    pos> 0
if   thisarr   otherarr   0  return true
}
return false
}
/** expand the long[] with the size given as a number of words (64 bit longs).
* getnumwords() is unchanged by this call.
*/
public void ensurecapacitywords int numwords
if  bits length < numwords
bits   arrayutil grow bits  numwords
}
}
/** ensure that the long[] is big enough to hold numbits, expanding it if necessary.
* getnumwords() is unchanged by this call.
*/
public void ensurecapacity long numbits
ensurecapacitywords bits2words numbits
}
/** lowers numwords, the number of words in use,
* by checking for trailing zero words.
*/
public void trimtrailingzeros
int idx   wlen 1
while  idx> 0    bits  0  idx
wlen   idx 1
}
/** returns the number of 64 bit words it would take to hold numbits */
public static int bits2words long numbits
return  int    numbits 1 >>>6  1
}
/** returns true if both sets have the same bits set */
public boolean equals object o
if  this    o  return true
if    o instanceof openbitset   return false
openbitset a
openbitset b    openbitset o
// make a the larger set.
if  b wlen > this wlen
a   b  b this
else
a this
}
// check for any set bits out of the range of b
for  int i a wlen 1  i> b wlen  i
if  a bits  0  return false
}
for  int i b wlen 1  i> 0  i
if  a bits    b bits  return false
}
return true
}
public int hashcode
long h   0x98761234      something non zero for length  0
for  int i   bits length    i> 0
h ^  bits
h    h << 1     h >>> 63      rotate left
}
return  int   h>>32  ^ h       fold leftmost bits into right
}
}