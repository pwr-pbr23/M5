package org apache lucene queryparser complexphrase
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util arraylist
import java util iterator
import java util list
import org apache lucene analysis analyzer
import org apache lucene index indexreader
import org apache lucene index term
import org apache lucene queryparser parseexception
import org apache lucene queryparser queryparser
import org apache lucene search booleanclause
import org apache lucene search booleanquery
import org apache lucene search multitermquery
import org apache lucene search query
import org apache lucene search termquery
import org apache lucene search termrangequery
import org apache lucene search spans spannearquery
import org apache lucene search spans spannotquery
import org apache lucene search spans spanorquery
import org apache lucene search spans spanquery
import org apache lucene search spans spantermquery
/**
* queryparser which permits complex phrase query syntax eg "(john jon
* jonathan~) peters*".
* <p>
* performs potentially multiple passes over query text to parse any nested
* logic in phrasequeries. - first pass takes any phrasequery content between
* quotes and stores for subsequent pass. all other query content is parsed as
* normal - second pass parses any stored phrasequery content, checking all
* embedded clauses are referring to the same field and therefore can be
* rewritten as span queries. all phrasequery clauses are expressed as
* complexphrasequery objects
* </p>
* <p>
* this could arguably be done in one pass using a new queryparser but here i am
* working within the constraints of the existing parser as a base class. this
* currently simply feeds all phrase content through an analyzer to select
* phrase terms - any "special" syntax such as * ~ * etc are not given special
* status
* </p>
*
*/
public class complexphrasequeryparser extends queryparser
private arraylist  <complexphrasequery>  complexphrases   null
private boolean ispass2resolvingphrases
private complexphrasequery currentphrasequery   null
public complexphrasequeryparser string f  analyzer a
super f  a
protected query getfieldquery string field  string querytext  int slop
complexphrasequery cpq   new complexphrasequery field  querytext  slop
complexphrases add cpq      add to list of phrases to be parsed once
// we
// are through with this pass
return cpq
public query parse string query  throws parseexception
if  ispass2resolvingphrases
multitermquery rewritemethod oldmethod   getmultitermrewritemethod
try
// temporarily force booleanquery rewrite so that parser will
// generate visible
// collection of terms which we can convert into spanqueries.
// constantscorerewrite mode produces an
// opaque constantscorequery object which cannot be interrogated for
// terms in the same way a booleanquery can.
// queryparser is not guaranteed threadsafe anyway so this temporary
// state change should not
// present an issue
setmultitermrewritemethod multitermquery scoring_boolean_query_rewrite
return super parse query
finally
setmultitermrewritemethod oldmethod
// first pass - parse the top-level query recording any phrasequerys
// which will need to be resolved
complexphrases   new arraylist  <complexphrasequery>
query q   super parse query
// perform second pass, using this queryparser to parse any nested
// phrasequeries with different
// set of syntax restrictions (i.e. all fields must be same)
ispass2resolvingphrases   true
try
for  iterator iterator   complexphrases iterator    iterator hasnext
currentphrasequery    complexphrasequery  iterator next
// in each phrase, now parse the contents between quotes as a
// separate parse operation
currentphrasequery parsephraseelements this
finally
ispass2resolvingphrases   false
return q
// there is no "gettermquery throws parseexception" method to override so
// unfortunately need
// to throw a runtime exception here if a term for another field is embedded
// in phrase query
protected query newtermquery term term
if  ispass2resolvingphrases
try
checkphraseclauseisforsamefield term field
catch  parseexception pe
throw new runtimeexception    pe
return super newtermquery term
// helper method used to report on any clauses that appear in query syntax
private void checkphraseclauseisforsamefield string field
throws parseexception
if   field equals currentphrasequery field
throw new parseexception  "   field
nested in phrase   for field      currentphrasequery field
"
protected query getwildcardquery string field  string termstr
throws parseexception
if  ispass2resolvingphrases
checkphraseclauseisforsamefield field
return super getwildcardquery field  termstr
protected query getrangequery string field  string part1  string part2
boolean inclusive  throws parseexception
if  ispass2resolvingphrases
checkphraseclauseisforsamefield field
return super getrangequery field  part1  part2  inclusive
protected query newrangequery string field  string part1  string part2
boolean inclusive
if  ispass2resolvingphrases
// must use old-style rangequery in order to produce a booleanquery
// that can be turned into spanor clause
termrangequery rangequery   new termrangequery field  part1  part2  inclusive  inclusive
getrangecollator
rangequery setrewritemethod multitermquery scoring_boolean_query_rewrite
return rangequery
return super newrangequery field  part1  part2  inclusive
protected query getfuzzyquery string field  string termstr
float minsimilarity  throws parseexception
if  ispass2resolvingphrases
checkphraseclauseisforsamefield field
return super getfuzzyquery field  termstr  minsimilarity
/*
* used to handle the query content in between quotes and produced span-based
* interpretations of the clauses.
*/
static class complexphrasequery extends query
string field
string phrasedquerystringcontents
int slopfactor
private query contents
public complexphrasequery string field  string phrasedquerystringcontents
int slopfactor
super
this field   field
this phrasedquerystringcontents   phrasedquerystringcontents
this slopfactor   slopfactor
// called by complexphrasequeryparser for each phrase after the main
// parse
// thread is through
protected void parsephraseelements queryparser qp  throws parseexception
// todo ensure that field-sensitivity is preserved ie the query
// string below is parsed as
// field+":("+phrasedquerystringcontents+")"
// but this will need code in rewrite to unwrap the first layer of
// boolean query
contents   qp parse phrasedquerystringcontents
public query rewrite indexreader reader  throws ioexception
// arraylist spanclauses = new arraylist();
if  contents instanceof termquery
return contents
// build a sequence of span clauses arranged in a spannear - child
// clauses can be complex
// booleans e.g. nots and ors etc
int numnegatives   0
if    contents instanceof booleanquery
throw new illegalargumentexception  "
contents getclass   getname
found in phrase query string      phrasedquerystringcontents
"
booleanquery bq    booleanquery  contents
booleanclause bclauses   bq getclauses
spanquery allspanclauses   new spanquery
// for all clauses e.g. one* two~
for  int i   0  i < bclauses length  i
// hashset bclauseterms=new hashset();
query qc   bclauses getquery
// rewrite this clause e.g one* becomes (one or onerous)
qc   qc rewrite reader
if  bclauses getoccur   equals booleanclause occur must_not
numnegatives
if  qc instanceof booleanquery
arraylist sc   new arraylist
addcomplexphraseclause sc   booleanquery  qc
if  sc size   > 0
allspanclauses    spanquery  sc get 0
else
// insert fake term e.g. phrase query was for "fred smithe*" and
// there were no "smithe*" terms - need to
// prevent match on just "fred".
allspanclauses   new spantermquery new term field
else
if  qc instanceof termquery
termquery tq    termquery  qc
allspanclauses   new spantermquery tq getterm
else
throw new illegalargumentexception  "
qc getclass   getname
found in phrase query string
phrasedquerystringcontents    "
if  numnegatives    0
// the simple case - no negative elements in phrase
return new spannearquery allspanclauses  slopfactor  true
// complex case - we have mixed positives and negatives in the
// sequence.
// need to return a spannotquery
arraylist positiveclauses   new arraylist
for  int j   0  j < allspanclauses length  j
if   bclauses getoccur   equals booleanclause occur must_not
positiveclauses add allspanclauses
spanquery includeclauses    spanquery  positiveclauses
toarray new spanquery
spanquery include   null
if  includeclauses length    1
include   includeclauses     only one positive clause
else
// need to increase slop factor based on gaps introduced by
// negatives
include   new spannearquery includeclauses  slopfactor   numnegatives
true
// use sequence of positive and negative values as the exclude.
spannearquery exclude   new spannearquery allspanclauses  slopfactor
true
spannotquery snot   new spannotquery include  exclude
return snot
private void addcomplexphraseclause list spanclauses  booleanquery qc
arraylist ors   new arraylist
arraylist nots   new arraylist
booleanclause bclauses   qc getclauses
// for all clauses e.g. one* two~
for  int i   0  i < bclauses length  i
query childquery   bclauses getquery
// select the list to which we will add these options
arraylist chosenlist   ors
if  bclauses getoccur      booleanclause occur must_not
chosenlist   nots
if  childquery instanceof termquery
termquery tq    termquery  childquery
spantermquery stq   new spantermquery tq getterm
stq setboost tq getboost
chosenlist add stq
else if  childquery instanceof booleanquery
booleanquery cbq    booleanquery  childquery
addcomplexphraseclause chosenlist  cbq
else
// todo alternatively could call extract terms here?
throw new illegalargumentexception
childquery getclass   getname
if  ors size      0
return
spanorquery soq   new spanorquery  spanquery  ors
toarray new spanquery
if  nots size      0
spanclauses add soq
else
spanorquery snqs   new spanorquery  spanquery  nots
toarray new spanquery
spannotquery snq   new spannotquery soq  snqs
spanclauses add snq
public string tostring string field
return
public int hashcode
final int prime   31
int result   1
result   prime   result     field    null  ? 0   field hashcode
result   prime
result
phrasedquerystringcontents    null  ? 0
phrasedquerystringcontents hashcode
result   prime   result   slopfactor
return result
public boolean equals object obj
if  this    obj
return true
if  obj    null
return false
if  getclass      obj getclass
return false
complexphrasequery other    complexphrasequery  obj
if  field    null
if  other field    null
return false
else if   field equals other field
return false
if  phrasedquerystringcontents    null
if  other phrasedquerystringcontents    null
return false
else if   phrasedquerystringcontents
equals other phrasedquerystringcontents
return false
if  slopfactor    other slopfactor
return false
return true