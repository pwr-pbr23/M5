package org apache lucene analysis cjk
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java io reader
import org apache lucene analysis tokenizer
import org apache lucene analysis tokenattributes offsetattribute
import org apache lucene analysis tokenattributes termattribute
import org apache lucene analysis tokenattributes typeattribute
import org apache lucene util attributesource
import org apache lucene util attributesource attributefactory
/**
* cjktokenizer is designed for chinese, japanese, and korean languages.
* <p>
* the tokens returned are every two adjacent characters with overlap match.
* </p>
* <p>
* example: "java c1c2c3c4" will be segmented to: "java" "c1c2" "c2c3" "c3c4".
* </p>
* additionally, the following is applied to latin text (such as english):
* <ul>
* <li>text is converted to lowercase.
* <li>numeric digits, '+', '#', and '_' are tokenized as letters.
* <li>full-width forms are converted to half-width forms.
* </ul>
* for more info on asian language (chinese, japanese, and korean) text segmentation:
* please search  <a
* href="http://www.google.com/search?q=word+chinese+segment">google</a>
*
*/
public final class cjktokenizer extends tokenizer
//~ static fields/initializers ---------------------------------------------
/** word token type */
static final int word_type   0
/** single byte token type */
static final int single_token_type   1
/** double byte token type */
static final int double_token_type   2
/** names for token types */
static final string token_type_names
/** max word length */
private static final int max_word_len   255
/** buffer size: */
private static final int io_buffer_size   256
//~ instance fields --------------------------------------------------------
/** word offset, used to imply which character(in ) is parsed */
private int offset   0
/** the index used only for iobuffer */
private int bufferindex   0
/** data length */
private int datalen   0
/**
* character buffer, store the characters which are used to compose <br>
* the returned token
*/
private final char buffer   new char
/**
* i/o buffer, used to store the content of the input(one of the <br>
* members of tokenizer)
*/
private final char iobuffer   new char
/** word type: single=>ascii  double=>non-ascii word=>default */
private int tokentype   word_type
/**
* tag: previous character is a cached double-byte character  "c1c2c3c4"
* ----(set the c1 istokened) c1c2 "c2c3c4" ----(set the c2 istokened)
* c1c2 c2c3 "c3c4" ----(set the c3 istokened) "c1c2 c2c3 c3c4"
*/
private boolean preistokened   false
private termattribute termatt
private offsetattribute offsetatt
private typeattribute typeatt
//~ constructors -----------------------------------------------------------
/**
* construct a token stream processing the given input.
*
* @param in i/o reader
*/
public cjktokenizer reader in
super in
init
public cjktokenizer attributesource source  reader in
super source  in
init
public cjktokenizer attributefactory factory  reader in
super factory  in
init
private void init
termatt    termattribute  addattribute termattribute class
offsetatt    offsetattribute  addattribute offsetattribute class
typeatt    typeattribute  addattribute typeattribute class
//~ methods ----------------------------------------------------------------
/**
* returns true for the next token in the stream, or false at eos.
* see http://java.sun.com/j2se/1.3/docs/api/java/lang/character.unicodeblock.html
* for detail.
*
* @return false for end of stream, true otherwise
*
* @throws java.io.ioexception - throw ioexception when read error <br>
*         happened in the inputstream
*
*/
public boolean incrementtoken   throws ioexception
clearattributes
/** how many character(s) has been stored in buffer */
while true       loop until we find a non empty token
int length   0
/** the position used to create token */
int start   offset
while  true       loop until we've found a full token
/** current character */
char c
/** unicode block of current character for detail */
character unicodeblock ub
offset
if  bufferindex >  datalen
datalen   input read iobuffer
bufferindex   0
if  datalen     1
if  length > 0
if  preistokened    true
length   0
preistokened   false
break
else
return false
else
//get current character
c   iobuffer
//get the unicodeblock of the current character
ub   character unicodeblock of c
//if the current character is ascii or extend ascii
if   ub    character unicodeblock basic_latin
ub    character unicodeblock halfwidth_and_fullwidth_forms
if  ub    character unicodeblock halfwidth_and_fullwidth_forms
int i    int  c
if  i >  65281    i <  65374
// convert certain halfwidth_and_fullwidth_forms to basic_latin
i   i   65248
c    char  i
// if the current character is a letter or "_" "+" "#"
if  character isletterordigit c
c           c           c
if  length    0
// "javac1c2c3c4linux" <br>
//      ^--: the current character begin to token the ascii
// letter
start   offset   1
else if  tokentype    double_token_type
// "javac1c2c3c4linux" <br>
//              ^--: the previous non-ascii
// : the current character
offset
bufferindex
if  preistokened    true
// there is only one non-ascii has been stored
length   0
preistokened   false
break
else
break
// store the lowercase(c) in the buffer
buffer   character tolowercase c
tokentype   single_token_type
// break the procedure if buffer overflowed!
if  length    max_word_len
break
else if  length > 0
if  preistokened    true
length   0
preistokened   false
else
break
else
// non-ascii letter, e.g."c1c2c3c4"
if  character isletter c
if  length    0
start   offset   1
buffer   c
tokentype   double_token_type
else
if  tokentype    single_token_type
offset
bufferindex
//return the previous ascii characters
break
else
buffer   c
tokentype   double_token_type
if  length    2
offset
bufferindex
preistokened   true
break
else if  length > 0
if  preistokened    true
// empty the buffer
length   0
preistokened   false
else
break
if  length > 0
termatt settermbuffer buffer  0  length
offsetatt setoffset correctoffset start   correctoffset start length
typeatt settype token_type_names
return true
else if  datalen     1
return false
// cycle back and try for the next token (don't
// return an empty string)
public final void end
// set final offset
final int finaloffset   offset
this offsetatt setoffset finaloffset  finaloffset
public void reset   throws ioexception
super reset
offset   bufferindex   datalen   0
preistokened   false
tokentype   word_type
public void reset reader reader  throws ioexception
super reset reader
reset