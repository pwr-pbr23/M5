/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2004-2006 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby runtime
import java lang ref referencequeue
import java lang ref weakreference
import java util arraylist
import java util hashmap
import java util iterator
import java util list
import java util map
import java util concurrent atomic atomiclong
import org jruby rubymodule
import org jruby runtime builtin irubyobject
import org jruby util weakidentityhashmap
/**
* fixme: this version is faster than the previous, but both suffer from a
* crucial flaw: it is impossible to create an objectspace with an iterator
* that doesn't either: a. hold on to objects that might otherwise be collected
* or b. have no way to guarantee that a call to hasnext() will be correct or
* that a subsequent call to next() will produce an object. for our purposes,
* for now, this may be acceptable.
*/
public class objectspace
private referencequeue deadreferences   new referencequeue
private weakreferencelistnode top
private referencequeue deadidentityreferences   new referencequeue
private final map identities   new hashmap
private final map identitiesbyobject   new weakidentityhashmap
private static final atomiclong maxid   new atomiclong 1000
public long idof irubyobject rubyobject
synchronized  identities
long longid    long  identitiesbyobject get rubyobject
if  longid    null
longid   createid rubyobject
return longid longvalue
public static long calculateobjectid object object
// fixnums get all the odd ids, so we use identityhashcode * 2
return maxid getandincrement     2
private long createid irubyobject object
cleanidentities
long id   calculateobjectid object
identities put id  new idreference object  id  deadidentityreferences
identitiesbyobject put object  id
return id
public irubyobject id2ref long id
synchronized  identities
cleanidentities
idreference reference    idreference  identities get long valueof id
if  reference    null
return null
return  irubyobject  reference get
private void cleanidentities
idreference ref
while   ref    idreference  deadidentityreferences poll       null
identities remove long valueof ref id
public void addfinalizer irubyobject object  irubyobject proc
object addfinalizer proc
public void removefinalizers long id
irubyobject object   id2ref id
if  object    null
object removefinalizers
public synchronized void add irubyobject object
cleanup
top   new weakreferencelistnode object  deadreferences  top
public synchronized iterator iterator rubymodule rubyclass
final list objlist   new arraylist
weakreferencelistnode current   top
while  current    null
irubyobject obj    irubyobject current get
if  obj    null    rubyclass isinstance obj
objlist add current
current   current nextnode
return new iterator
private iterator iter   objlist iterator
public boolean hasnext
throw new unsupportedoperationexception
public object next
object obj   null
while  iter hasnext
weakreferencelistnode node    weakreferencelistnode iter next
obj   node get
if  obj    null  break
return obj
public void remove
throw new unsupportedoperationexception
private synchronized void cleanup
weakreferencelistnode reference
while   reference    weakreferencelistnode deadreferences poll       null
reference remove
private class weakreferencelistnode extends weakreference
private weakreferencelistnode prevnode
private weakreferencelistnode nextnode
public weakreferencelistnode object ref  referencequeue queue  weakreferencelistnode next
super ref  queue
this nextnode   next
if  next    null
next prevnode   this
public void remove
synchronized  objectspace this
if  prevnode    null
prevnode nextnode   nextnode
else
top   nextnode
if  nextnode    null
nextnode prevnode   prevnode
private static class idreference extends weakreference
private final long id
public idreference irubyobject object  long id  referencequeue queue
super object  queue
this id   id
public long id
return id