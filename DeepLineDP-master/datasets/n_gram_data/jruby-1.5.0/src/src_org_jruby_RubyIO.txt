/*
**** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2001-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2006 thomas e enebo <enebo@acm.org>
* copyright (c) 2004-2006 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 evan buswell <ebuswell@gmail.com>
* copyright (c) 2007 miguel covarrubias <mlcovarrubias@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby
import com kenai constantine platform fcntl
import java io eofexception
import java io filedescriptor
import java io ioexception
import java io filenotfoundexception
import java io inputstream
import java io outputstream
import java nio channels cancelledkeyexception
import java nio channels channel
import java nio channels channels
import java nio channels filechannel
import java nio channels pipe
import java nio channels selectablechannel
import java nio channels selectionkey
import java nio channels selector
import java util arraylist
import java util hashmap
import java util hashset
import java util iterator
import java util list
import java util map
import java util set
import java util concurrent atomic atomicinteger
import org jcodings encoding
import org jruby anno framefield
import org jruby anno jrubymethod
import org jruby anno jrubyclass
import org jruby common irubywarnings id
import org jruby exceptions raiseexception
import org jruby libraries fcntllibrary
import org jruby platform platform
import org jruby runtime block
import org jruby runtime classindex
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
import org jruby util bytelist
import org jruby util io stream
import org jruby util io modeflags
import org jruby util safepropertyaccessor
import org jruby util shelllauncher
import org jruby util typeconverter
import org jruby util io baddescriptorexception
import org jruby util io channelstream
import org jruby util io invalidvalueexception
import org jruby util io pipeexception
import org jruby util io fileexistsexception
import org jruby util io directoryasfileexception
import org jruby util io stdio
import org jruby util io openfile
import org jruby util io channeldescriptor
import static org jruby compatversion
import static org jruby rubyenumerator enumeratorize
/**
*
* @author jpetersen
*/
@jrubyclass name    include
public class rubyio extends rubyobject
protected openfile openfile
protected list<rubythread> blockingthreads
protected irubyobject externalencoding
protected irubyobject internalencoding
public void registerdescriptor channeldescriptor descriptor  boolean isretained
getruntime   registerdescriptor descriptor isretained
}
public void registerdescriptor channeldescriptor descriptor
registerdescriptor descriptor false      default  don't retain
}
public void unregisterdescriptor int afileno
getruntime   unregisterdescriptor afileno
}
public channeldescriptor getdescriptorbyfileno int afileno
return getruntime   getdescriptorbyfileno afileno
}
// fixme can't use static; would interfere with other runtimes in the same jvm
protected static atomicinteger filenoindex   new atomicinteger 2
public static int getnewfileno
return filenoindex incrementandget
}
// this should only be called by this and rubyfile.
// it allows this object to be created without a iohandler.
public rubyio ruby runtime  rubyclass type
super runtime  type
openfile   new openfile
}
public rubyio ruby runtime  outputstream outputstream
super runtime  runtime getio
// we only want io objects with valid streams (better to error now).
if  outputstream    null
throw runtime newruntimeerror
}
openfile   new openfile
try
openfile setmainstream channelstream open runtime  new channeldescriptor channels newchannel outputstream   getnewfileno    new filedescriptor
catch  invalidvalueexception e
throw getruntime   newerrnoeinvalerror
}
openfile setmode openfile writable   openfile append
registerdescriptor openfile getmainstream   getdescriptor
}
public rubyio ruby runtime  inputstream inputstream
super runtime  runtime getio
if  inputstream    null
throw runtime newruntimeerror
}
openfile   new openfile
try
openfile setmainstream channelstream open runtime  new channeldescriptor channels newchannel inputstream   getnewfileno    new filedescriptor
catch  invalidvalueexception e
throw getruntime   newerrnoeinvalerror
}
openfile setmode openfile readable
registerdescriptor openfile getmainstream   getdescriptor
}
public rubyio ruby runtime  channel channel
super runtime  runtime getio
// we only want io objects with valid streams (better to error now).
if  channel    null
throw runtime newruntimeerror
}
openfile   new openfile
try
openfile setmainstream channelstream open runtime  new channeldescriptor channel  getnewfileno    new filedescriptor
catch  invalidvalueexception e
throw getruntime   newerrnoeinvalerror
}
openfile setmode openfile getmainstream   getmodes   getopenfileflags
registerdescriptor openfile getmainstream   getdescriptor
}
public rubyio ruby runtime  shelllauncher popenprocess process  modeflags modes
super runtime  runtime getio
openfile   new openfile
openfile setmode modes getopenfileflags     openfile sync
openfile setprocess process
try
if  openfile isreadable
channel inchannel
if  process getinput      null
// nio-based
inchannel   process getinput
} else {
// stream-based
inchannel   channels newchannel process getinputstream
}
channeldescriptor main   new channeldescriptor
inchannel
getnewfileno
new filedescriptor
main setcanbeseekable false
openfile setmainstream channelstream open getruntime    main
registerdescriptor main
}
if  openfile iswritable      process hasoutput
channel outchannel
if  process getoutput      null
// nio-based
outchannel   process getoutput
} else {
outchannel   channels newchannel process getoutputstream
}
channeldescriptor pipe   new channeldescriptor
outchannel
getnewfileno
new filedescriptor
pipe setcanbeseekable false
if  openfile getmainstream      null
openfile setpipestream channelstream open getruntime    pipe
} else {
openfile setmainstream channelstream open getruntime    pipe
}
registerdescriptor pipe
}
catch  invalidvalueexception e
throw getruntime   newerrnoeinvalerror
}
}
public rubyio ruby runtime  stdio stdio
super runtime  runtime getio
openfile   new openfile
try
switch  stdio
case in
openfile setmainstream
channelstream open
runtime
// special constructor that accepts stream, not channel
new channeldescriptor runtime getin    0  new modeflags modeflags rdonly   filedescriptor in
break
case out
openfile setmainstream
channelstream open
runtime
new channeldescriptor channels newchannel runtime getout     1  new modeflags modeflags wronly   modeflags append   filedescriptor out
openfile getmainstream   setsync true
break
case err
openfile setmainstream
channelstream open
runtime
new channeldescriptor channels newchannel runtime geterr     2  new modeflags modeflags wronly   modeflags append   filedescriptor err
openfile getmainstream   setsync true
break
}
catch  invalidvalueexception ex
throw getruntime   newerrnoeinvalerror
}
openfile setmode openfile getmainstream   getmodes   getopenfileflags
registerdescriptor openfile getmainstream   getdescriptor
}
public static rubyio newio ruby runtime  channel channel
return new rubyio runtime  channel
}
public openfile getopenfile
return openfile
}
protected openfile getopenfilechecked
openfile checkclosed getruntime
return openfile
}
private static objectallocator io_allocator   new objectallocator
public irubyobject allocate ruby runtime  rubyclass klass
return new rubyio runtime  klass
}
/*
* we use file versus io to match t_file in mri.
*/
@override
public int getnativetypeindex
return classindex file
}
public static rubyclass createioclass ruby runtime
rubyclass ioclass   runtime defineclass    runtime getobject    io_allocator
ioclass index   classindex io
ioclass setreifiedclass rubyio class
ioclass kindof   new rubymodule kindof
@override
public boolean iskindof irubyobject obj  rubymodule type
return obj instanceof rubyio
}
ioclass includemodule runtime getenumerable
// todo: implement tty? and isatty.  we have no real capability to
// determine this from java, but if we could set tty status, then
// we could invoke jruby differently to allow stdin to return true
// on this.  this would allow things like cgi.rb to work properly.
ioclass defineannotatedmethods rubyio class
// constants for seek
ioclass fastsetconstant    runtime newfixnum stream seek_set
ioclass fastsetconstant    runtime newfixnum stream seek_cur
ioclass fastsetconstant    runtime newfixnum stream seek_end
if  runtime is1_9
ioclass definemoduleunder
ioclass definemoduleunder
}
return ioclass
}
public outputstream getoutstream
return gethandler   newoutputstream
}
public inputstream getinstream
return gethandler   newinputstream
}
public channel getchannel
return gethandler   getchannel
}
public stream gethandler
return getopenfilechecked   getmainstream
}
@jrubymethod name      required   1  optional   1
public irubyobject reopen threadcontext context  irubyobject args
ruby runtime   context getruntime
if  args length < 1
throw runtime newargumenterror
}
irubyobject tmp   typeconverter converttotypewithcheck args  runtime getio
if   tmp isnil
try
rubyio ios    rubyio  tmp
if  ios openfile    this openfile
return this
}
openfile originalfile   ios getopenfilechecked
openfile selffile   getopenfilechecked
long pos   0
if  originalfile isreadable
pos   originalfile getmainstream   fgetpos
}
if  originalfile getpipestream      null
originalfile getpipestream   fflush
else if  originalfile iswritable
originalfile getmainstream   fflush
}
if  selffile iswritable
selffile getwritestream   fflush
}
selffile setmode originalfile getmode
selffile setprocess originalfile getprocess
selffile setlinenumber originalfile getlinenumber
selffile setpath originalfile getpath
selffile setfinalizer originalfile getfinalizer
channeldescriptor selfdescriptor   selffile getmainstream   getdescriptor
channeldescriptor originaldescriptor   originalfile getmainstream   getdescriptor
// confirm we're not reopening self's channel
if  selfdescriptor getchannel      originaldescriptor getchannel
// check if we're a stdio io, and ensure we're not badly mutilated
if  selfdescriptor getfileno   > 0    selfdescriptor getfileno   <  2
selffile getmainstream   clearerr
// dup2 new fd into self to preserve fileno and references to it
originaldescriptor dup2into selfdescriptor
// re-register, since fileno points at something new now
registerdescriptor selfdescriptor
} else {
stream pipefile   selffile getpipestream
int mode   selffile getmode
selffile getmainstream   fclose
selffile setpipestream null
// todo: turn off readable? am i reading this right?
// this only seems to be used while duping below, since modes gets
// reset to actual modes afterward
//fptr->mode &= (m & fmode_readable) ? ~fmode_readable : ~fmode_writable;
if  pipefile    null
selffile setmainstream channelstream fdopen runtime  originaldescriptor  new modeflags
selffile setpipestream pipefile
} else {
selffile setmainstream
channelstream open
runtime
originaldescriptor dup2 selfdescriptor getfileno
// re-register the descriptor
registerdescriptor selffile getmainstream   getdescriptor
// since we're not actually duping the incoming channel into our handler, we need to
// copy the original sync behavior from the other handler
selffile getmainstream   setsync selffile getmainstream   issync
}
selffile setmode mode
}
// todo: anything threads attached to original fd are notified of the close...
// see rb_thread_fd_close
if  originalfile isreadable      pos >  0
selffile seek pos  stream seek_set
originalfile seek pos  stream seek_set
}
}
if  selffile getpipestream      null    selfdescriptor getfileno      selffile getpipestream   getdescriptor   getfileno
int fd   selffile getpipestream   getdescriptor   getfileno
if  originalfile getpipestream      null
selffile getpipestream   fclose
selffile setpipestream null
else if  fd    originalfile getpipestream   getdescriptor   getfileno
selffile getpipestream   fclose
channeldescriptor newfd2   originalfile getpipestream   getdescriptor   dup2 fd
selffile setpipestream channelstream fdopen runtime  newfd2  getiomodes runtime
// re-register, since fileno points at something new now
registerdescriptor newfd2
}
}
// todo: restore binary mode
//            if (fptr->mode & fmode_binmode) {
//                rb_io_binmode(io);
//            }
// todo: set our metaclass to target's class (i.e. scary!)
catch  ioexception ex       todo  better error handling
throw runtime newioerror     ex getmessage
catch  baddescriptorexception ex
throw runtime newioerror     ex getmessage
catch  pipeexception ex
throw runtime newioerror     ex getmessage
catch  invalidvalueexception ive
throw runtime newerrnoeinvalerror
}
} else {
irubyobject pathstring   args converttostring
// todo: check safe, taint on incoming string
if  openfile    null
openfile   new openfile
}
try
modeflags modes
if  args length > 1
irubyobject modestring   args converttostring
modes   getiomodes runtime  modestring tostring
openfile setmode modes getopenfileflags
} else {
modes   getiomodes runtime
}
string path   pathstring tostring
// ruby code frequently uses a platform check to choose "nul:" on windows
// but since that check doesn't work well on jruby, we help it out
openfile setpath path
if (openfile.getmainstream() == null) {
try
openfile setmainstream channelstream fopen runtime  path  modes
catch  fileexistsexception fee
throw runtime newerrnoeexisterror path
}
registerdescriptor openfile getmainstream   getdescriptor
if (openfile.getpipestream() != null) {
openfile getpipestream   fclose
unregisterdescriptor openfile getpipestream   getdescriptor   getfileno
openfile setpipestream null
}
return this
} else {
// todo: this is an freopen in mri, this is close, but not quite the same
openfile getmainstream   freopen runtime  path  getiomodes runtime  openfile getmodeasstring runtime
// re-register
registerdescriptor openfile getmainstream   getdescriptor
if (openfile.getpipestream() != null) {
// todo: pipe handler to be reopened with path and "w" mode
}
}
catch  pipeexception pe
throw runtime newerrnoepipeerror
catch  ioexception ex
throw runtime newioerrorfromexception ex
catch  baddescriptorexception ex
throw runtime newerrnoebadferror
catch  invalidvalueexception e
throw runtime newerrnoeinvalerror
}
}
// a potentially previously close io is being 'reopened'.
return this
}
public static modeflags getiomodes ruby runtime  string modesstring  throws invalidvalueexception
return new modeflags getiomodesintfromstring runtime  modesstring
}
public static int getiomodesintfromstring ruby runtime  string modesstring
int modes   0
int length   modesstring length
if  length    0
throw runtime newargumenterror
}
switch  modesstring charat 0
case
modes    modeflags rdonly
break
case
modes    modeflags append   modeflags wronly   modeflags creat
break
case
modes    modeflags wronly   modeflags trunc   modeflags creat
break
default
throw runtime newargumenterror     modes
}
modifierloop  for  int n   1  n < length  n
switch  modesstring charat n
case
modes    modeflags binary
break
case
modes    modes   ~modeflags accmode    modeflags rdwr
break
case
// fixme: add text mode to mode flags
break
case
break modifierloop
default
throw runtime newargumenterror     modes
}
}
return modes
}
/*
* ensure that separator is valid otherwise give it the default paragraph separator.
*/
private static bytelist separator ruby runtime
return separator runtime getrecordseparatorvar   get
}
private static bytelist separator irubyobject separatorvalue
bytelist separator   separatorvalue isnil   ? null
separatorvalue converttostring   getbytelist
if  separator    null    separator getrealsize      0  separator   stream paragraph_delimeter
return separator
}
private static bytelist getseparatorfromargs ruby runtime  irubyobject args  int idx
return separator args length > idx ? args   runtime getrecordseparatorvar   get
}
private bytelist getseparatorforgets ruby runtime  irubyobject args
return getseparatorfromargs runtime  args  0
}
public irubyobject getline ruby runtime  bytelist separator  bytelistcache cache
return getline runtime  separator   1  cache
}
public irubyobject getline ruby runtime  bytelist separator
return getline runtime  separator   1  null
}
/**
* getline using logic of gets.  if limit is -1 then read unlimited amount.
*
*/
public irubyobject getline ruby runtime  bytelist separator  long limit
return getline runtime  separator  limit  null
}
/**
* getline using logic of gets.  if limit is -1 then read unlimited amount.
*
*/
public irubyobject getline ruby runtime  bytelist separator  long limit  bytelistcache cache
try
openfile myopenfile   getopenfilechecked
myopenfile checkreadable runtime
myopenfile setreadbuffered
boolean isparagraph   separator    stream paragraph_delimeter
separator   isparagraph ? stream paragraph_separator   separator
if  isparagraph  swallow
if  separator    null    limit < 0
irubyobject str   readall null
if    rubystring str  getbytelist   length      0
return runtime.getnil();
}
incrementlineno runtime  myopenfile
return str
else if  limit    0
return rubystring newemptystring runtime
else if  separator length      1    limit < 0
return getlinefast runtime  separator get 0    0xff  cache
} else {
stream readstream   myopenfile getmainstream
int c    1
int n    1
int newline   separator get separator length     1    0xff
bytelist buf   cache    null ? cache allocate 0    new bytelist 0
try
boolean update   false
boolean limitreached   false
while  true
do
readcheck readstream
readstream clearerr
try
if  limit     1
n   readstream getline buf   byte  newline
} else {
n   readstream getline buf   byte  newline  limit
limit    n
if  limit <  0
update   limitreached   true
break
}
}
c   buf length   > 0 ? buf get buf length     1    0xff    1
catch  eofexception e
n    1
}
if  n     1
if   readstream isblocking       readstream instanceof channelstream
checkdescriptor runtime    channelstream  readstream  getdescriptor
continue
} else {
break
}
}
update   true
while  c    newline      loop until we see the nth separator char
// if we hit eof or reached limit then we're done
if  n     1    limitreached  break
// if we've found the last char of the separator,
// and we've found at least as many characters as separator length,
// and the last n characters of our buffer match the separator, we're done
if  c    newline    buf length   >  separator length
0    bytelist memcmp buf getunsafebytes    buf getbegin     buf getrealsize     separator length    separator getunsafebytes    separator getbegin    separator getrealsize
break
}
}
if  isparagraph    c     1  swallow
if   update
return runtime.getnil();
} else {
incrementlineno runtime  myopenfile
rubystring str   rubystring newstring runtime  cache    null ? new bytelist buf    buf
str settaint true
return str
}
}
finally
if cache    null
cache release buf
}
}
}
catch  pipeexception ex
throw runtime newerrnoepipeerror
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
catch  eofexception e
return runtime.getnil();
catch  baddescriptorexception e
throw runtime newerrnoebadferror
catch  ioexception e
throw runtime newioerror e getmessage
}
}
private void incrementlineno ruby runtime  openfile myopenfile
int lineno   myopenfile getlinenumber     1
myopenfile setlinenumber lineno
runtime setcurrentline lineno
rubyargsfile setcurrentlinenumber runtime getargsfile    lineno
}
protected boolean swallow int term  throws ioexception  baddescriptorexception
stream readstream   openfile getmainstream
int c
do
readcheck readstream
try
c   readstream fgetc
catch  eofexception e
c    1
}
if  c    term
readstream ungetc c
return true
}
while  c     1
return false
}
private static string vendor
static   string v   safepropertyaccessor getproperty      vendor    v    null  ?     v
private static string msgeintr
public static boolean restartsystemcall exception e
return vendor startswith       e getmessage   equals msgeintr
}
public irubyobject getlinefast ruby runtime  int delim  bytelistcache cache  throws ioexception  baddescriptorexception
stream readstream   openfile getmainstream
int c    1
bytelist buf   cache    null ? cache allocate 0    new bytelist 0
try
boolean update   false
do
readcheck readstream
readstream clearerr
int n
try
n   readstream getline buf   byte  delim
c   buf length   > 0 ? buf get buf length     1    0xff    1
catch  eofexception e
n    1
}
if  n     1
if   readstream isblocking       readstream instanceof channelstream
checkdescriptor runtime    channelstream readstream  getdescriptor
continue
} else {
break
}
}
update   true
while  c    delim
if   update
return runtime.getnil();
} else {
incrementlineno runtime  openfile
rubystring str   rubystring newstring runtime  cache    null ? new bytelist buf    buf
str settaint true
return str
}
}
finally
if cache    null
cache release buf
}
}
}
// io class methods.
@jrubymethod name           rest   true  frame   true  meta   true
public static irubyobject newinstance threadcontext context  irubyobject recv  irubyobject args  block block
rubyclass klass    rubyclass recv
if  block isgiven
string classname   klass getname
context getruntime   getwarnings   warn
id block_not_accepted
classname       classname
classname
}
return klass newinstance context  args  block
}
private irubyobject initializecommon19 int fileno  modeflags modes
try
channeldescriptor descriptor   getdescriptorbyfileno fileno
if  descriptor    null  throw getruntime   newerrnoebadferror
descriptor checkopen
if  modes    null  modes   descriptor getoriginalmodes
if  openfile isopen
// jruby-4650: make sure we clean up the old data,
// if it's present.
openfile cleanup getruntime    false
}
openfile setmode modes getopenfileflags
openfile setmainstream fdopen descriptor  modes
catch  baddescriptorexception ex
throw getruntime   newerrnoebadferror
catch  invalidvalueexception ive
throw getruntime   newerrnoeinvalerror
}
return this
}
@jrubymethod name      frame   true  visibility   visibility private  compat   compatversion ruby1_9
public irubyobject initialize19 threadcontext context  irubyobject filenumber  block unusedblock
return initializecommon19 rubynumeric fix2int filenumber   null
}
@jrubymethod name      frame   true  visibility   visibility private  compat   compatversion ruby1_9
public irubyobject initialize19 threadcontext context  irubyobject filenumber  irubyobject second  block unusedblock
int fileno   rubynumeric fix2int filenumber
modeflags modes
if  second instanceof rubyhash
modes   parseoptions context  second  null
} else {
modes   parsemodes19 context  second
}
return initializecommon19 fileno  modes
}
@jrubymethod name      frame   true  visibility   visibility private  compat   compatversion ruby1_9
public irubyobject initialize19 threadcontext context  irubyobject filenumber  irubyobject modevalue  irubyobject options  block unusedblock
int fileno   rubynumeric fix2int filenumber
modeflags modes   parsemodes19 context  modevalue
modes   parseoptions context  options  modes
return initializecommon19 fileno  modes
}
protected modeflags parsemodes irubyobject arg
try
if  arg instanceof rubyfixnum  return new modeflags rubyfixnum fix2long arg
return getiomodes getruntime    arg converttostring   tostring
catch  invalidvalueexception e
throw getruntime   newerrnoeinvalerror
}
}
protected modeflags parsemodes19 threadcontext context  irubyobject arg
modeflags modes   parsemodes arg
if  arg instanceof rubystring
parseencodingfromstring context  arg  1
}
return modes
}
private void parseencodingfromstring threadcontext context  irubyobject arg  int initialposition
rubystring modes19   arg converttostring
if  modes19 tostring   contains
irubyobject fullencoding   modes19 split context  rubystring newstring context getruntime        tojavaarray
irubyobject externalencodingoption   fullencoding
irubyobject internalencodingoption   null
if  fullencoding length >  initialposition   1
internalencodingoption   fullencoding
set_encoding context  externalencodingoption  internalencodingoption
} else {
set_encoding context  externalencodingoption
}
}
}
@jrubymethod name      required   1  optional   1  frame   true  visibility   visibility private  compat   compatversion ruby1_8
public irubyobject initialize irubyobject args  block unusedblock
int argcount   args length
modeflags modes
int fileno   rubynumeric fix2int args
try
channeldescriptor descriptor   getdescriptorbyfileno fileno
if  descriptor    null
throw getruntime   newerrnoebadferror
}
descriptor checkopen
if  argcount    2
if  args instanceof rubyfixnum
modes   new modeflags rubyfixnum fix2long args
} else {
modes   getiomodes getruntime    args converttostring   tostring
}
} else {
// use original modes
modes   descriptor getoriginalmodes
}
if  openfile isopen
// jruby-4650: make sure we clean up the old data,
// if it's present.
openfile cleanup getruntime    false
}
openfile setmode modes getopenfileflags
openfile setmainstream fdopen descriptor  modes
catch  baddescriptorexception ex
throw getruntime   newerrnoebadferror
catch  invalidvalueexception ive
throw getruntime   newerrnoeinvalerror
}
return this
}
protected stream fdopen channeldescriptor existingdescriptor  modeflags modes  throws invalidvalueexception
// see if we already have this descriptor open.
// if so then we can mostly share the handler (keep open
// file, but possibly change the mode).
if  existingdescriptor    null
// redundant, done above as well
// this seems unlikely to happen unless it's a totally bogus fileno
// ...so do we even need to bother trying to create one?
// in fact, we should probably raise an error, yes?
throw getruntime   newerrnoebadferror
//            if (mode == null) {
//                mode = "r";
//            }
//
//            try {
//                openfile.setmainstream(streamforfileno(getruntime(), fileno));
//            } catch (baddescriptorexception e) {
//                throw getruntime().newerrnoebadferror();
//            } catch (ioexception e) {
//                throw getruntime().newerrnoebadferror();
//            }
//            //modes = new iomodes(getruntime(), mode);
//
//            registerstream(openfile.getmainstream());
} else {
// we are creating a new io object that shares the same
// iohandler (and fileno).
return channelstream fdopen getruntime    existingdescriptor  modes
}
}
@jrubymethod compat   compatversion ruby1_9
public irubyobject external_encoding threadcontext context
return externalencoding    null ? externalencoding   rubyencoding getdefaultexternal context getruntime
}
@jrubymethod compat   compatversion ruby1_9
public irubyobject internal_encoding threadcontext context
return internalencoding    null ? internalencoding   context getruntime   getnil
}
@jrubymethod compat compatversion ruby1_9
public irubyobject set_encoding threadcontext context  irubyobject encodingstring
setexternalencoding context  encodingstring
return context getruntime   getnil
}
@jrubymethod compat compatversion ruby1_9
public irubyobject set_encoding threadcontext context  irubyobject encodingstring  irubyobject internalencoding
setexternalencoding context  encodingstring
setinternalencoding context  internalencoding
return context getruntime   getnil
}
@jrubymethod compat   compatversion ruby1_9
public irubyobject set_encoding threadcontext context  irubyobject encodingstring  irubyobject internalencoding  irubyobject options
setexternalencoding context  encodingstring
setinternalencoding context  internalencoding
return context getruntime   getnil
}
private void setexternalencoding threadcontext context  irubyobject encoding
externalencoding   getencodingcommon context  encoding
}
private void setinternalencoding threadcontext context  irubyobject encoding
irubyobject internalencodingoption   getencodingcommon context  encoding
if  internalencodingoption tostring   equals external_encoding context  tostring
context getruntime   getwarnings   warn     encoding
external_encoding context
} else {
internalencoding   internalencodingoption
}
}
private irubyobject getencodingcommon threadcontext context  irubyobject encoding
irubyobject rubyencoding   null
if  encoding instanceof rubyencoding
rubyencoding   encoding
} else {
encoding encodingobj   rubyencoding getencodingfromobject context getruntime    encoding
rubyencoding   rubyencoding convertencodingtorubyencoding context getruntime    encodingobj
}
return rubyencoding
}
@jrubymethod name      required   1  optional   2  frame   true  meta   true
public static irubyobject open threadcontext context  irubyobject recv  irubyobject args  block block
ruby runtime   context getruntime
rubyclass klass    rubyclass recv
rubyio io    rubyio klass newinstance context  args  block
if  block isgiven
try
return block yield context  io
finally
try
io getmetaclass   finvoke context  io     irubyobject null_array  block null_block
catch  raiseexception re
rubyexception rubyex   re getexception
if  rubyex kind_of_p context  runtime getstandarderror    istrue
// mri behavior: swallow standarderorrs
} else {
throw re
}
}
}
}
return io
}
@jrubymethod name      required   1  optional   2  frame   true  meta   true
public static irubyobject sysopen irubyobject recv  irubyobject args  block block
ruby runtime   recv getruntime
irubyobject pathstring   args converttostring
runtime checksafestring pathstring
string path   pathstring tostring
modeflags modes   null
int perms    1      1    don't set permissions
try
if  args length > 1
irubyobject modestring   args converttostring
modes   getiomodes runtime  modestring tostring
} else {
modes   getiomodes runtime
}
if  args length > 2
rubyinteger permsint
args length >  3 ? args converttointeger     null
perms   rubynumeric fix2int permsint
}
catch  invalidvalueexception e
throw runtime newerrnoeinvalerror
}
int fileno    1
try
channeldescriptor descriptor
channeldescriptor open runtime getcurrentdirectory
path  modes  perms  runtime getposix
runtime registerdescriptor descriptor true      isretained true
fileno   descriptor getfileno
}
catch  filenotfoundexception fnfe
throw runtime newerrnoenoenterror path
catch  directoryasfileexception dafe
throw runtime newerrnoeisdirerror path
catch  fileexistsexception fee
throw runtime newerrnoeexisterror path
catch  ioexception ioe
throw runtime newioerrorfromexception ioe
}
return runtime newfixnum fileno
}
@jrubymethod name
public irubyobject binmode
if  isclosed
throw getruntime   newioerror
}
openfile setbinmode
return this
}
@jrubymethod name      compat   compatversion ruby1_9
public irubyobject op_binmode threadcontext context
return rubyboolean newboolean context getruntime    openfile isbinmode
}
/** @deprecated will be removed in 1.2 */
protected void checkinitialized
if  openfile    null
throw getruntime   newioerror
}
}
/** @deprecated will be removed in 1.2 */
protected void checkclosed
if  openfile getmainstream      null    openfile getpipestream      null
throw getruntime   newioerror
}
}
@jrubymethod name      required   1
public irubyobject syswrite threadcontext context  irubyobject obj
ruby runtime   context getruntime
try
rubystring string   obj asstring
openfile myopenfile   getopenfilechecked
myopenfile checkwritable runtime
stream writestream   myopenfile getwritestream
if  myopenfile iswritebuffered
runtime getwarnings   warn id syswrite_buffered_io
}
if   writestream getdescriptor   iswritable
myopenfile checkclosed runtime
}
int read   writestream getdescriptor   write string getbytelist
if  read     1
// todo? i think this ends up propagating from normal java exceptions
// sys_fail(openfile.getpath())
}
return runtime newfixnum read
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
catch  pipeexception ex
throw runtime newerrnoepipeerror
catch  baddescriptorexception e
throw runtime newerrnoebadferror
catch  ioexception e
throw runtime newsystemcallerror e getmessage
}
}
@jrubymethod name      required   1
public irubyobject write_nonblock threadcontext context  irubyobject obj
// mri behavior: always check whether the file is writable
// or not, even if we are to write 0 bytes.
openfile myopenfile   getopenfilechecked
try
myopenfile checkwritable context getruntime
rubystring str   obj asstring
if  str getbytelist   length      0
return context getruntime   newfixnum 0
}
if  myopenfile iswritebuffered
context getruntime   getwarnings   warn id syswrite_buffered_io
}
int written   myopenfile getwritestream   getdescriptor   write str getbytelist
return context getruntime   newfixnum written
catch  ioexception ex
throw context getruntime   newioerrorfromexception ex
catch  baddescriptorexception ex
throw context getruntime   newerrnoebadferror
catch  invalidvalueexception ex
throw context getruntime   newerrnoeinvalerror
catch  pipeexception ex
throw context getruntime   newerrnoepipeerror
}
}
/** io_write
*
*/
@jrubymethod name      required   1
public irubyobject write threadcontext context  irubyobject obj
ruby runtime   context getruntime
runtime secure 4
rubystring str   obj asstring
// todo: ruby reuses this logic for other "write" behavior by checking if it's an io and calling write again
if  str getbytelist   length      0
return runtime newfixnum 0
}
try
openfile myopenfile   getopenfilechecked
myopenfile checkwritable runtime
int written   fwrite str getbytelist
if  written     1
// todo: sys fail
}
// if not sync, we switch to write buffered mode
if   myopenfile issync
myopenfile setwritebuffered
}
return runtime newfixnum written
catch  ioexception ex
throw runtime newioerrorfromexception ex
catch  baddescriptorexception ex
throw runtime newerrnoebadferror
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
catch  pipeexception ex
throw runtime newerrnoepipeerror
}
}
protected boolean waitwritable channeldescriptor descriptor  throws ioexception
channel channel   descriptor getchannel
if  channel    null      channel instanceof selectablechannel
return false
}
selectablechannel selectable    selectablechannel channel
selector selector   null
synchronized  selectable blockinglock
boolean oldblocking   selectable isblocking
try
selector   selector open
selectable configureblocking false
int real_ops   selectable validops     selectionkey op_write
selectionkey key   selectable keyfor selector
if  key    null
selectable register selector  real_ops  descriptor
} else {
key interestops key interestops   real_ops
}
while selector select      0
for  iterator i   selector selectedkeys   iterator    i hasnext
selectionkey skey    selectionkey  i next
if   skey interestops     skey readyops      selectionkey op_write      0
if skey attachment      descriptor
return true
}
}
}
return false
finally
if  selector    null
try
selector close
catch  exception e
}
}
selectable configureblocking oldblocking
}
}
}
/*
* throw bad file descriptor is we can not read on supplied descriptor.
*/
private void checkdescriptor ruby runtime  channeldescriptor descriptor  throws ioexception
if    waitreadable descriptor    throw runtime newioerror     openfile getpath
}
protected boolean waitreadable channeldescriptor descriptor  throws ioexception
channel channel   descriptor getchannel
if  channel    null      channel instanceof selectablechannel
return false
}
selectablechannel selectable    selectablechannel channel
selector selector   null
synchronized  selectable blockinglock
boolean oldblocking   selectable isblocking
try
selector   selector open
selectable configureblocking false
int real_ops   selectable validops      selectionkey op_read   selectionkey op_accept
selectionkey key   selectable keyfor selector
if  key    null
selectable register selector  real_ops  descriptor
} else {
key interestops key interestops   real_ops
}
while selector select      0
for  iterator i   selector selectedkeys   iterator    i hasnext
selectionkey skey    selectionkey  i next
if   skey interestops     skey readyops      selectionkey op_read   selectionkey op_accept      0
if skey attachment      descriptor
return true
}
}
}
return false
finally
if  selector    null
try
selector close
catch  exception e
}
}
selectable configureblocking oldblocking
}
}
}
protected int fwrite bytelist buffer
int n  r  l  offset   0
boolean eagain   false
stream writestream   openfile getwritestream
int len   buffer length
if   n   len  <  0  return n
try
if  openfile issync
openfile fflush writestream
// todo: why is this guarded?
//            if (!rb_thread_fd_writable(fileno(f))) {
//                rb_io_check_closed(fptr);
//            }
while offset<len
l   n
// todo: something about pipe buffer length here
r   writestream getdescriptor   write buffer offset l
if r    len
return len    everything written
}
if  0 <  r
offset    r
n    r
eagain   true
}
if eagain    waitwritable writestream getdescriptor
openfile checkclosed getruntime
if offset >  buffer length
return  1
}
eagain   false
} else {
return  1
}
}
// todo: all this stuff...some pipe logic, some async thread stuff
//          retry:
//            l = n;
//            if (pipe_buf < l &&
//                !rb_thread_critical &&
//                !rb_thread_alone() &&
//                wsplit_p(fptr)) {
//                l = pipe_buf;
//            }
//            trap_beg;
//            r = write(fileno(f), rstring(str)->ptr+offset, l);
//            trap_end;
//            if (r == n) return len;
//            if (0 <= r) {
//                offset += r;
//                n -= r;
//                errno = eagain;
//            }
//            if (rb_io_wait_writable(fileno(f))) {
//                rb_io_check_closed(fptr);
//                if (offset < rstring(str)->len)
//                    goto retry;
//            }
//            return -1l;
}
// todo: handle errors in buffered write by retrying until finished or file is closed
return writestream fwrite buffer
//        while (errno = 0, offset += (r = fwrite(rstring(str)->ptr+offset, 1, n, f)), (n -= r) > 0) {
//            if (ferror(f)
//            ) {
//                if (rb_io_wait_writable(fileno(f))) {
//                    rb_io_check_closed(fptr);
//                    clearerr(f);
//                    if (offset < rstring(str)->len)
//                        continue;
//                }
//                return -1l;
//            }
//        }
//            return len - n;
catch  ioexception ex
throw getruntime   newioerrorfromexception ex
catch  baddescriptorexception ex
throw getruntime   newerrnoebadferror
}
}
/** rb_io_addstr
*
*/
@jrubymethod name      required   1
public irubyobject op_append threadcontext context  irubyobject anobject
// claims conversion is done via 'to_s' in docs.
callmethod context     anobject
return this
}
@jrubymethod name      alias
public rubyfixnum fileno threadcontext context
return context getruntime   newfixnum getopenfilechecked   getmainstream   getdescriptor   getfileno
}
/** returns the current line number.
*
* @return the current line number.
*/
@jrubymethod name
public rubyfixnum lineno threadcontext context
return context getruntime   newfixnum getopenfilechecked   getlinenumber
}
/** sets the current line number.
*
* @param newlinenumber the new line number.
*/
@jrubymethod name      required   1
public rubyfixnum lineno_set threadcontext context  irubyobject newlinenumber
getopenfilechecked   setlinenumber rubynumeric fix2int newlinenumber
return context getruntime   newfixnum getopenfilechecked   getlinenumber
}
/** returns the current sync mode.
*
* @return the current sync mode.
*/
@jrubymethod name
public rubyboolean sync threadcontext context
return context getruntime   newboolean getopenfilechecked   getmainstream   issync
}
/**
* <p>return the process id (pid) of the process this io object
* spawned.  if no process exists (popen was not called), then
* nil is returned.  this is not how it appears to be defined
* but ruby 1.8 works this way.</p>
*
* @return the pid or nil
*/
@jrubymethod name
public irubyobject pid threadcontext context
openfile myopenfile   getopenfilechecked
if  myopenfile getprocess      null
return context getruntime   getnil
}
// of course this isn't particularly useful.
long pid   myopenfile getpid
return context getruntime   newfixnum pid
}
/**
* @deprecated
* @return
*/
public boolean writedatabuffered
return openfile getmainstream   writedatabuffered
}
@jrubymethod name
public rubyfixnum pos threadcontext context
try
return context getruntime   newfixnum getopenfilechecked   getmainstream   fgetpos
catch  invalidvalueexception ex
throw context getruntime   newerrnoeinvalerror
catch  baddescriptorexception bde
throw context getruntime   newerrnoebadferror
catch  pipeexception e
throw context getruntime   newerrnoespipeerror
catch  ioexception e
throw context getruntime   newioerror e getmessage
}
}
@jrubymethod name      required   1
public rubyfixnum pos_set threadcontext context  irubyobject newposition
long offset   rubynumeric num2long newposition
if  offset < 0
throw context getruntime   newsystemcallerror
}
openfile myopenfile   getopenfilechecked
try
myopenfile getmainstream   lseek offset  stream seek_set
catch  baddescriptorexception e
throw context getruntime   newerrnoebadferror
catch  invalidvalueexception e
throw context getruntime   newerrnoeinvalerror
catch  pipeexception e
throw context getruntime   newerrnoespipeerror
catch  ioexception e
throw context getruntime   newioerror e getmessage
}
myopenfile getmainstream   clearerr
return context getruntime   newfixnum offset
}
/** print some objects to the stream.
*
*/
@jrubymethod name      rest   true  reads   framefield lastline
public irubyobject print threadcontext context  irubyobject args
return print context  this  args
}
/** print some objects to the stream.
*
*/
public static irubyobject print threadcontext context  irubyobject maybeio  irubyobject args
if  args length    0
args   new irubyobject   context getcurrentscope   getlastline context getruntime
}
ruby runtime   context getruntime
irubyobject fs   runtime getglobalvariables   get
irubyobject rs   runtime getglobalvariables   get
for  int i   0  i < args length  i
if  i > 0     fs isnil
maybeio callmethod context     fs
}
if  args isnil
maybeio callmethod context     runtime newstring
} else {
maybeio callmethod context     args
}
}
if   rs isnil
maybeio callmethod context     rs
}
return runtime.getnil();
}
@jrubymethod name      required   1  rest   true
public irubyobject printf threadcontext context  irubyobject args
callmethod context     rubykernel sprintf context  this  args
return context getruntime   getnil
}
@jrubymethod name      required   1  backtrace   true
public irubyobject putc threadcontext context  irubyobject object
return putc context  this  object
}
public static irubyobject putc threadcontext context  irubyobject maybeio  irubyobject object
int c   rubynumeric num2chr object
if  maybeio instanceof rubyio
// fixme we should probably still be dyncalling 'write' here
rubyio io    rubyio maybeio
try
openfile myopenfile   io getopenfilechecked
myopenfile checkwritable context getruntime
stream writestream   myopenfile getwritestream
writestream fputc c
if  myopenfile issync    myopenfile fflush writestream
catch  ioexception ex
throw context getruntime   newioerrorfromexception ex
catch  baddescriptorexception e
throw context getruntime   newerrnoebadferror
catch  invalidvalueexception ex
throw context getruntime   newerrnoeinvalerror
catch  pipeexception ex
throw context getruntime   newerrnoepipeerror
}
} else {
maybeio callmethod context
rubystring newstringnocopy context getruntime    new byte   byte c
}
return object
}
public rubyfixnum seek threadcontext context  irubyobject args
long offset   rubynumeric num2long args
int whence   stream seek_set
if  args length > 1
whence   rubynumeric fix2int args converttointeger
}
return doseek context  offset  whence
}
@jrubymethod name
public rubyfixnum seek threadcontext context  irubyobject arg0
long offset   rubynumeric num2long arg0
int whence   stream seek_set
return doseek context  offset  whence
}
@jrubymethod name
public rubyfixnum seek threadcontext context  irubyobject arg0  irubyobject arg1
long offset   rubynumeric num2long arg0
int whence   rubynumeric fix2int arg1 converttointeger
return doseek context  offset  whence
}
private rubyfixnum doseek threadcontext context  long offset  int whence
openfile myopenfile   getopenfilechecked
try
myopenfile seek offset  whence
catch  baddescriptorexception ex
throw context getruntime   newerrnoebadferror
catch  invalidvalueexception e
throw context getruntime   newerrnoeinvalerror
catch  pipeexception e
throw context getruntime   newerrnoespipeerror
catch  ioexception e
throw context getruntime   newioerror e getmessage
}
myopenfile getmainstream   clearerr
return rubyfixnum zero context getruntime
}
// this was a getopt with one mandatory arg, but it did not work
// so i am parsing it for now.
@jrubymethod name      required   1  optional   1
public rubyfixnum sysseek threadcontext context  irubyobject args
long offset   rubynumeric num2long args
long pos
int whence   stream seek_set
if  args length > 1
whence   rubynumeric fix2int args converttointeger
}
openfile myopenfile   getopenfilechecked
try
if  myopenfile isreadable      myopenfile isreadbuffered
throw context getruntime   newioerror
}
if  myopenfile iswritable      myopenfile iswritebuffered
context getruntime   getwarnings   warn id sysseek_buffered_io
}
pos   myopenfile getmainstream   getdescriptor   lseek offset  whence
catch  baddescriptorexception ex
throw context getruntime   newerrnoebadferror
catch  invalidvalueexception e
throw context getruntime   newerrnoeinvalerror
catch  pipeexception e
throw context getruntime   newerrnoespipeerror
catch  ioexception e
throw context getruntime   newioerror e getmessage
}
myopenfile getmainstream   clearerr
return context getruntime   newfixnum pos
}
@jrubymethod name
public rubyfixnum rewind threadcontext context
openfile myopenfile   getopenfilechecked
try
myopenfile getmainstream   lseek 0l  stream seek_set
myopenfile getmainstream   clearerr
// todo: this is some goofy global file value from mri..what to do?
//            if (io == current_file) {
//                gets_lineno -= fptr->lineno;
//            }
catch  baddescriptorexception e
throw context getruntime   newerrnoebadferror
catch  invalidvalueexception e
throw context getruntime   newerrnoeinvalerror
catch  pipeexception e
throw context getruntime   newerrnoespipeerror
catch  ioexception e
throw context getruntime   newioerror e getmessage
}
// must be back on first line on rewind.
myopenfile setlinenumber 0
return rubyfixnum zero context getruntime
}
@jrubymethod name
public rubyfixnum fsync threadcontext context
ruby runtime   context getruntime
try
openfile myopenfile   getopenfilechecked
myopenfile checkwritable runtime
myopenfile getwritestream   sync
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
catch  pipeexception ex
throw runtime newerrnoepipeerror
catch  ioexception e
throw runtime newioerror e getmessage
catch  baddescriptorexception e
throw runtime newerrnoebadferror
}
return rubyfixnum zero runtime
}
/** sets the current sync mode.
*
* @param newsync the new sync mode.
*/
@jrubymethod name      required   1
public irubyobject sync_set irubyobject newsync
getopenfilechecked   setsync newsync istrue
getopenfilechecked   getmainstream   setsync newsync istrue
return this
}
@jrubymethod name
public rubyboolean eof_p threadcontext context
ruby runtime   context getruntime
try
openfile myopenfile   getopenfilechecked
myopenfile checkreadable runtime
myopenfile setreadbuffered
if  myopenfile getmainstream   feof
return runtime gettrue
}
if  myopenfile getmainstream   readdatabuffered
return runtime getfalse
}
readcheck myopenfile getmainstream
myopenfile getmainstream   clearerr
int c   myopenfile getmainstream   fgetc
if  c     1
myopenfile getmainstream   ungetc c
return runtime getfalse
}
myopenfile checkclosed runtime
myopenfile getmainstream   clearerr
return runtime gettrue
catch  pipeexception ex
throw runtime newerrnoepipeerror
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
catch  baddescriptorexception e
throw runtime newerrnoebadferror
catch  ioexception e
throw runtime newioerror e getmessage
}
}
@jrubymethod name
public rubyboolean tty_p threadcontext context
return context getruntime   newboolean context getruntime   getposix   isatty getopenfilechecked   getmainstream   getdescriptor   getfiledescriptor
}
@jrubymethod name      required   1
@override
public irubyobject initialize_copy irubyobject original
ruby runtime   getruntime
if  this    original  return this
rubyio originalio    rubyio  typeconverter converttotypewithcheck original  runtime getio
openfile originalfile   originalio getopenfilechecked
openfile newfile   openfile
try
if  originalfile getpipestream      null
originalfile getpipestream   fflush
originalfile getmainstream   lseek 0  stream seek_cur
else if  originalfile iswritable
originalfile getmainstream   fflush
} else {
originalfile getmainstream   lseek 0  stream seek_cur
}
newfile setmode originalfile getmode
newfile setprocess originalfile getprocess
newfile setlinenumber originalfile getlinenumber
newfile setpath originalfile getpath
newfile setfinalizer originalfile getfinalizer
modeflags modes
if  newfile isreadable
if  newfile iswritable
if  newfile getpipestream      null
modes   new modeflags modeflags rdonly
} else {
modes   new modeflags modeflags rdwr
}
} else {
modes   new modeflags modeflags rdonly
}
} else {
if  newfile iswritable
modes   new modeflags modeflags wronly
} else {
modes   originalfile getmainstream   getmodes
}
}
channeldescriptor descriptor   originalfile getmainstream   getdescriptor   dup
newfile setmainstream channelstream fdopen runtime  descriptor  modes
newfile getmainstream   setsync originalfile getmainstream   issync
// todo: the rest of this...seeking to same position is unnecessary since we share a channel
// but some of this may be needed?
//    fseeko(fptr->f, ftello(orig->f), seek_set);
//    if (orig->f2) {
//	if (fileno(orig->f) != fileno(orig->f2)) {
//	    fd = ruby_dup(fileno(orig->f2));
//	}
//	fptr->f2 = rb_fdopen(fd, "w");
//	fseeko(fptr->f2, ftello(orig->f2), seek_set);
//    }
//    if (fptr->mode & fmode_binmode) {
//	rb_io_binmode(dest);
//    }
// register the new descriptor
registerdescriptor newfile getmainstream   getdescriptor
catch  ioexception ex
throw runtime newioerror     ex
catch  baddescriptorexception ex
throw runtime newioerror     ex
catch  pipeexception ex
throw runtime newioerror     ex
catch  invalidvalueexception ex
throw runtime newioerror     ex
}
return this
}
@jrubymethod name
public rubyboolean closed_p threadcontext context
return context getruntime   newboolean isclosed
}
/**
* is this io closed
*
* @return true if closed
*/
public boolean isclosed
return openfile getmainstream      null    openfile getpipestream      null
}
/**
* <p>closes all open resources for the io.  it also removes
* it from our magical all open file descriptor pool.</p>
*
* @return the io.
*/
@jrubymethod name
public irubyobject close
ruby runtime   getruntime
if  runtime getsafelevel   >  4    istaint
throw runtime newsecurityerror
}
openfile checkclosed runtime
return close2 runtime
}
protected irubyobject close2 ruby runtime
if  openfile    null  return runtime getnil
interruptblockingthreads
/* fixme: why did we go to this trouble and not use these descriptors?
channeldescriptor main, pipe;
if (openfile.getpipestream() != null) {
pipe = openfile.getpipestream().getdescriptor();
} else {
if (openfile.getmainstream() == null) {
return runtime.getnil();
}
pipe = null;
}
main = openfile.getmainstream().getdescriptor(); */
// cleanup, raising errors if any
openfile cleanup runtime  true
// todo: notify threads waiting on descriptors/io? probably not...
if  openfile getprocess      null
obliterateprocess openfile getprocess
irubyobject processresult   rubyprocess rubystatus newprocessstatus runtime  openfile getprocess   exitvalue
runtime getglobalvariables   set    processresult
}
return runtime.getnil();
}
@jrubymethod name
public irubyobject close_write threadcontext context
try
if  context getruntime   getsafelevel   >  4    istaint
throw context getruntime   newsecurityerror
}
openfile myopenfile   getopenfilechecked
if  myopenfile getpipestream      null    myopenfile isreadable
throw context getruntime   newioerror
}
if  myopenfile getpipestream      null
close
else
myopenfile getpipestream   fclose
myopenfile setpipestream null
myopenfile setmode myopenfile getmode     ~openfile writable
// todo
// n is result of fclose; but perhaps having a syserror below is enough?
// if (n != 0) rb_sys_fail(fptr->path);
}
catch  baddescriptorexception bde
throw context getruntime   newerrnoebadferror
catch  ioexception ioe
// hmmmm
}
return this
}
@jrubymethod name
public irubyobject close_read threadcontext context
ruby runtime   context getruntime
try
if  runtime getsafelevel   >  4    istaint
throw runtime newsecurityerror
}
openfile myopenfile   getopenfilechecked
if  myopenfile getpipestream      null    myopenfile iswritable
throw runtime newioerror
}
if  myopenfile getpipestream      null
close
else
myopenfile getmainstream   fclose
myopenfile setmode myopenfile getmode     ~openfile readable
myopenfile setmainstream myopenfile getpipestream
myopenfile setpipestream null
// todo
// n is result of fclose; but perhaps having a syserror below is enough?
// if (n != 0) rb_sys_fail(fptr->path);
}
catch  baddescriptorexception bde
throw runtime newerrnoebadferror
catch  ioexception ioe
// i believe ruby bails out with a "bug" if closing fails
throw runtime newioerrorfromexception ioe
}
return this
}
/** flushes the io output stream.
*
* @return the io.
*/
@jrubymethod name
public rubyio flush
try
getopenfilechecked   getwritestream   fflush
catch  baddescriptorexception e
throw getruntime   newerrnoebadferror
catch  ioexception e
throw getruntime   newioerror e getmessage
}
return this
}
@deprecated
public irubyobject gets threadcontext context  irubyobject args
return args length    0 ? gets context    gets context  args
}
/** read a line.
*
*/
@jrubymethod name      writes   framefield lastline  compat   ruby1_8
public irubyobject gets threadcontext context
ruby runtime   context getruntime
irubyobject result   getline runtime  separator runtime getrecordseparatorvar   get
if   result isnil    context getcurrentscope   setlastline result
return result
}
@jrubymethod name      writes   framefield lastline  compat   ruby1_8
public irubyobject gets threadcontext context  irubyobject separatorarg
irubyobject result   getline context getruntime    separator separatorarg
if   result isnil    context getcurrentscope   setlastline result
return result
}
@jrubymethod name      writes   framefield lastline  compat   ruby1_9
public irubyobject gets19 threadcontext context
ruby runtime   context getruntime
irubyobject result   getline runtime  separator runtime
if   result isnil    context getcurrentscope   setlastline result
return result
}
@jrubymethod name      writes   framefield lastline  compat   ruby1_9
public irubyobject gets19 threadcontext context  irubyobject arg
bytelist separator
long limit    1
if  arg instanceof rubyinteger
limit   rubyinteger fix2long arg
separator   separator context getruntime
} else {
separator   separator arg
}
irubyobject result   getline context getruntime    separator  limit
if   result isnil    context getcurrentscope   setlastline result
return result
}
@jrubymethod name      writes   framefield lastline  compat   ruby1_9
public irubyobject gets19 threadcontext context  irubyobject separator  irubyobject limit_arg
long limit   limit_arg isnil   ?  1   rubynumeric fix2long limit_arg
irubyobject result   getline context getruntime    separator separator   limit
if   result isnil    context getcurrentscope   setlastline result
return result
}
public boolean getblocking
return   channelstream  openfile getmainstream    isblocking
}
@jrubymethod name
public irubyobject fcntl threadcontext context  irubyobject cmd
// todo: this version differs from ioctl by checking whether fcntl exists
// and raising notimplemented if it doesn't; perhaps no difference for us?
return ctl context getruntime    cmd  null
}
@jrubymethod name
public irubyobject fcntl threadcontext context  irubyobject cmd  irubyobject arg
// todo: this version differs from ioctl by checking whether fcntl exists
// and raising notimplemented if it doesn't; perhaps no difference for us?
return ctl context getruntime    cmd  arg
}
@jrubymethod name      required   1  optional   1
public irubyobject ioctl threadcontext context  irubyobject args
irubyobject cmd   args
irubyobject arg
if  args length    2
arg   args
} else {
arg   context getruntime   getnil
}
return ctl context getruntime    cmd  arg
}
public irubyobject ctl ruby runtime  irubyobject cmd  irubyobject arg
long realcmd   cmd converttointeger   getlongvalue
long narg   0
// fixme: arg may also be true, false, and nil and still be valid.  strangely enough,
// protocol conversion is not happening in ruby on this arg?
if  arg    null    arg isnil      arg    runtime getfalse
narg   0
else if  arg instanceof rubyfixnum
narg   rubyfixnum fix2long arg
else if  arg    runtime gettrue
narg   1
} else {
throw runtime newnotimplementederror
}
openfile myopenfile   getopenfilechecked
// fixme: only f_setfl and f_getfl is current supported
// fixme: only nonblock flag is supported
// fixme: f_setfl and f_setfd are treated as the same thing here.  for the case of dup(fd) we
//   should actually have f_setfl only affect one (it is unclear how well we do, but this todo
//   is here to at least document that we might need to do more work here.  mostly setfl is
//   for mode changes which should persist across fork() boundaries.  since jvm has no fork
//   this is not a problem for us.
if  realcmd    fcntllibrary fd_cloexec
// do nothing.  fd_cloexec has no meaning in jvm since we cannot really exec.
// and why the hell does webrick pass this in as a first argument!!!!!
else if  realcmd    fcntl f_setfl value      realcmd    fcntl f_setfd value
if   narg   fcntllibrary fd_cloexec     fcntllibrary fd_cloexec
// do nothing.  fd_cloexec has no meaning in jvm since we cannot really exec.
} else {
try
boolean block    narg   modeflags nonblock     modeflags nonblock
myopenfile getmainstream   setblocking block
catch  ioexception e
throw runtime newioerror e getmessage
}
}
else if  realcmd    fcntl f_getfl value
return myopenfile getmainstream   isblocking   ? rubyfixnum zero runtime    rubyfixnum newfixnum runtime  modeflags nonblock
} else {
throw runtime newnotimplementederror
}
return runtime newfixnum 0
}
private static final bytelist nil_bytelist   bytelist create
private static final bytelist recursive_bytelist   bytelist create
@jrubymethod name      rest   true
public irubyobject puts threadcontext context  irubyobject args
return puts context  this  args
}
public static irubyobject puts threadcontext context  irubyobject maybeio  irubyobject args
if  args length    0
return writeseparator context  maybeio
}
return putsarray context  maybeio  args
}
private static irubyobject writeseparator threadcontext context  irubyobject maybeio
ruby runtime   context getruntime
assert runtime getglobalvariables   getdefaultseparator   instanceof rubystring
rubystring separator    rubystring  runtime getglobalvariables   getdefaultseparator
write context  maybeio  separator getbytelist
return runtime.getnil();
}
private static irubyobject putsarray threadcontext context  irubyobject maybeio  irubyobject args
ruby runtime   context getruntime
assert runtime getglobalvariables   getdefaultseparator   instanceof rubystring
rubystring separator    rubystring  runtime getglobalvariables   getdefaultseparator
for  int i   0  i < args length  i
bytelist line
if  args isnil
line   nil_bytelist
else if  runtime isinspecting args
line   recursive_bytelist
else if  args instanceof rubyarray
inspectputs context  maybeio   rubyarray  args
continue
} else {
line   args asstring   getbytelist
}
write context  maybeio  line
if  line length      0     line endswith separator getbytelist
write context  maybeio  separator getbytelist
}
}
return runtime.getnil();
}
protected void write threadcontext context  bytelist bytelist
callmethod context     rubystring newstringshared context getruntime    bytelist
}
protected static void write threadcontext context  irubyobject maybeio  bytelist bytelist
maybeio callmethod context     rubystring newstringshared context getruntime    bytelist
}
private static irubyobject inspectputs threadcontext context  irubyobject maybeio  rubyarray array
try
context getruntime   registerinspecting array
return putsarray context  maybeio  array tojavaarray
finally
context getruntime   unregisterinspecting array
}
}
@deprecated
public irubyobject readline threadcontext context  irubyobject args
return args length    0 ? readline context    readline context  args
}
/** read a line.
*
*/
@jrubymethod name      writes   framefield lastline
public irubyobject readline threadcontext context
irubyobject line   gets context
if  line isnil    throw context getruntime   neweoferror
return line
}
@jrubymethod name      writes   framefield lastline
public irubyobject readline threadcontext context  irubyobject separator
irubyobject line   gets context  separator
if  line isnil    throw context getruntime   neweoferror
return line
}
/** read a byte. on eof returns nil.
*
*/
@jrubymethod name
public irubyobject getc
try
openfile myopenfile   getopenfilechecked
myopenfile checkreadable getruntime
myopenfile setreadbuffered
stream stream   myopenfile getmainstream
readcheck stream
stream clearerr
int c   myopenfile getmainstream   fgetc
if  c     1
// todo: check for ferror, clear it, and try once more up above readcheck
//                if (ferror(f)) {
//                    clearerr(f);
//                    if (!rb_io_wait_readable(fileno(f)))
//                        rb_sys_fail(fptr->path);
//                    goto retry;
//                }
return getruntime   getnil
}
return getruntime   newfixnum c
catch  pipeexception ex
throw getruntime   newerrnoepipeerror
catch  invalidvalueexception ex
throw getruntime   newerrnoeinvalerror
catch  baddescriptorexception e
throw getruntime   newerrnoebadferror
catch  eofexception e
throw getruntime   neweoferror
catch  ioexception e
throw getruntime   newioerror e getmessage
}
}
private void readcheck stream stream
if   stream readdatabuffered
openfile checkclosed getruntime
}
}
/**
* <p>pushes char represented by int back onto ios.</p>
*
* @param number to push back
*/
@jrubymethod name      required   1
public irubyobject ungetc irubyobject number
int ch   rubynumeric fix2int number
openfile myopenfile   getopenfilechecked
if   myopenfile isreadbuffered
throw getruntime   newioerror
}
try
myopenfile checkreadable getruntime
myopenfile setreadbuffered
if  myopenfile getmainstream   ungetc ch      1    ch     1
throw getruntime   newioerror
}
catch  pipeexception ex
throw getruntime   newerrnoepipeerror
catch  invalidvalueexception ex
throw getruntime   newerrnoeinvalerror
catch  baddescriptorexception e
throw getruntime   newerrnoebadferror
catch  eofexception e
throw getruntime   neweoferror
catch  ioexception e
throw getruntime   newioerror e getmessage
}
return getruntime   getnil
}
@jrubymethod name      required   1  optional   1  backtrace   true
public irubyobject read_nonblock threadcontext context  irubyobject args
irubyobject value   getpartial context  args  true
if  value isnil    throw context getruntime   neweoferror
if  value instanceof rubystring
rubystring str    rubystring  value
if  str isempty
ruby ruby   context getruntime
raiseexception eagain   ruby newerrnoeagainerror
// fixme: *oif* 1.9 actually does this
if  ruby is1_9
eagain getexception   extend new irubyobject  ruby getio   getconstant
}
throw eagain
}
}
return value
}
@jrubymethod name      required   1  optional   1
public irubyobject readpartial threadcontext context  irubyobject args
irubyobject value   getpartial context  args  false
if  value isnil    throw context getruntime   neweoferror
return value
}
private irubyobject getpartial threadcontext context  irubyobject args  boolean isnonblocking
ruby runtime   context getruntime
// length to read
int length   rubynumeric fix2int args
if  length < 0  throw runtime newargumenterror     length
// string/buffer to read it into
irubyobject stringarg   args length > 1 ? args   rubystring newemptystring runtime
rubystring string   stringarg isnil   ? rubystring newemptystring runtime    stringarg converttostring
openfile checkclosed runtime
if    openfile getmainstream   instanceof channelstream        cryptic for the uninitiated
throw runtime newnotimplementederror
}
try
channelstream stream    channelstream  openfile getmainstream
bytelist buf   isnonblocking ? stream readnonblock length    stream readpartial length
boolean empty   buf    null    buf length      0
string view empty ? bytelist empty_bytelist   buf
if  stream feof      empty  return runtime getnil
return string
catch  baddescriptorexception e
throw runtime newerrnoebadferror
catch  eofexception e
throw runtime neweoferror e getmessage
catch  ioexception e
throw runtime newioerror e getmessage
}
}
@jrubymethod name      required   1  optional   1
public irubyobject sysread threadcontext context  irubyobject args
int len    int rubynumeric num2long args
if  len < 0  throw getruntime   newargumenterror
try
rubystring str
bytelist buffer
if  args length    1    args isnil
if  len    0
return rubystring newemptystring getruntime
}
buffer   new bytelist len
str   rubystring newstring getruntime    buffer
} else {
str   args converttostring
str modify len
if  len    0
return str
}
buffer   str getbytelist
buffer length 0
}
openfile myopenfile   getopenfilechecked
myopenfile checkreadable getruntime
if  myopenfile getmainstream   readdatabuffered
throw getruntime   newioerror
}
// todo: ruby locks the string here
myopenfile checkclosed getruntime
// todo: ruby re-checks that the buffer string hasn't been modified
// select until read is ready
context getthread   beforeblockingcall
context getthread   select this  selectionkey op_read
int bytesread   myopenfile getmainstream   getdescriptor   read len  str getbytelist
// todo: ruby unlocks the string here
// todo: ruby truncates string to specific size here, but our bytelist should handle this already?
if  bytesread     1     bytesread    0    len > 0
throw getruntime   neweoferror
}
str settaint true
return str
catch  baddescriptorexception e
throw getruntime   newerrnoebadferror
catch  invalidvalueexception e
throw getruntime   newerrnoeinvalerror
catch  pipeexception e
throw getruntime   newerrnoepipeerror
catch  eofexception e
throw getruntime   neweoferror
catch  ioexception e
synthesizesystemcallerror e
return null
finally
context getthread   afterblockingcall
}
}
/**
* java does not give us enough information for specific error conditions
* so we are reduced to divining them through string matches...
*/
// todo: should econnaborted get thrown earlier in the descriptor itself or is it ok to handle this late?
// todo: should we include this into errno code somewhere do we can use this from other places as well?
private void synthesizesystemcallerror ioexception e
string errormessage   e getmessage
// all errors to sysread should be systemcallerrors, but on a closed stream
// ruby returns an ioerror.  java throws same exception for all errors so
// we resort to this hack...
if    equals errormessage
throw getruntime   newioerror e getmessage
else if    equals errormessage
throw getruntime   newerrnoeconnabortederror
}
throw getruntime   newsystemcallerror e getmessage
}
public irubyobject read irubyobject args
threadcontext context   getruntime   getcurrentcontext
switch  args length
case 0  return read context
case 1  return read context  args
case 2  return read context  args  args
default  throw getruntime   newargumenterror args length  2
}
}
@jrubymethod name
public irubyobject read threadcontext context
ruby runtime   context getruntime
openfile myopenfile   getopenfilechecked
try
myopenfile checkreadable runtime
myopenfile setreadbuffered
return readall context getruntime   getnil
catch  pipeexception ex
throw getruntime   newerrnoepipeerror
catch  invalidvalueexception ex
throw getruntime   newerrnoeinvalerror
catch  eofexception ex
throw getruntime   neweoferror
catch  ioexception ex
throw getruntime   newioerrorfromexception ex
catch  baddescriptorexception ex
throw getruntime   newerrnoebadferror
}
}
@jrubymethod name
public irubyobject read threadcontext context  irubyobject arg0
if  arg0 isnil
return read context
}
openfile myopenfile   getopenfilechecked
int length   rubynumeric num2int arg0
if  length < 0
throw getruntime   newargumenterror     length
}
rubystring str   null
return readnotall context  myopenfile  length  str
}
@jrubymethod name
public irubyobject read threadcontext context  irubyobject arg0  irubyobject arg1
openfile myopenfile   getopenfilechecked
if  arg0 isnil
try
myopenfile checkreadable getruntime
myopenfile setreadbuffered
return readall arg1
catch  pipeexception ex
throw getruntime   newerrnoepipeerror
catch  invalidvalueexception ex
throw getruntime   newerrnoeinvalerror
catch  eofexception ex
throw getruntime   neweoferror
catch  ioexception ex
throw getruntime   newioerrorfromexception ex
catch  baddescriptorexception ex
throw getruntime   newerrnoebadferror
}
}
int length   rubynumeric num2int arg0
if  length < 0
throw getruntime   newargumenterror     length
}
rubystring str   null
//        bytelist buffer = null;
if  arg1 isnil
//            buffer = new bytelist(length);
//            str = rubystring.newstring(getruntime(), buffer);
} else {
str   arg1 converttostring
str modify length
if  length    0
return str
}
//            buffer = str.getbytelist();
}
return readnotall context  myopenfile  length  str
}
private irubyobject readnotall threadcontext context  openfile myopenfile  int length  rubystring str
ruby runtime   context getruntime
try
myopenfile checkreadable runtime
myopenfile setreadbuffered
if  myopenfile getmainstream   feof
return runtime.getnil();
}
// todo: ruby locks the string here
// read_check from mri io.c
readcheck myopenfile getmainstream
// todo: check buffer length again?
//        if (rstring(str)->len != len) {
//            rb_raise(rb_eruntimeerror, "buffer string modified");
//        }
// todo: read into buffer using all the fread logic
//        int read = openfile.getmainstream().fread(buffer);
bytelist newbuffer   myopenfile getmainstream   fread length
// todo: ruby unlocks the string here
// todo: change this to check number read into buffer once that's working
//        if (read == 0) {
if  newbuffer    null    newbuffer length      0
if  myopenfile getmainstream      null
return runtime.getnil();
}
if  myopenfile getmainstream   feof
// truncate buffer string to zero, if provided
if  str    null
str setvalue bytelist empty_bytelist dup
}
return runtime.getnil();
}
// removed while working on jruby-2386, since fixes for that
// modified eof logic such that this check is not really valid.
// we expect that an eofexception will be thrown now in eof
// cases.
//                if (length > 0) {
//                    // i think this is only partly correct; sys fail based on errno in ruby
//                    throw getruntime().neweoferror();
//                }
}
// todo: ruby truncates string to specific size here, but our bytelist should handle this already?
// fixme: i don't like the null checks here
if  str    null
if  newbuffer    null
str   rubystring newemptystring runtime
} else {
str   rubystring newstring runtime  newbuffer
}
} else {
if  newbuffer    null
str empty
} else {
str setvalue newbuffer
}
}
str settaint true
return str
catch  eofexception ex
throw runtime neweoferror
catch  pipeexception ex
throw runtime newerrnoepipeerror
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
catch  ioexception ex
throw runtime newioerrorfromexception ex
catch  baddescriptorexception ex
throw runtime newerrnoebadferror
}
}
protected irubyobject readall irubyobject buffer  throws baddescriptorexception  eofexception  ioexception
ruby runtime   getruntime
// todo: handle writing into original buffer better
rubystring str   null
if  buffer instanceof rubystring
str    rubystring buffer
}
// todo: ruby locks the string here
// read_check from mri io.c
if  openfile getmainstream   readdatabuffered
openfile checkclosed runtime
}
bytelist newbuffer   openfile getmainstream   readall
// todo same zero-length checks as file above
if  str    null
if  newbuffer    null
str   rubystring newemptystring runtime
} else {
str   rubystring newstring runtime  newbuffer
}
} else {
if  newbuffer    null
str empty
} else {
str setvalue newbuffer
}
}
str taint runtime getcurrentcontext
return str
//        long bytes = 0;
//        long n;
//
//        if (siz == 0) siz = bufsiz;
//        if (nil_p(str)) {
//            str = rb_str_new(0, siz);
//        }
//        else {
//            rb_str_resize(str, siz);
//        }
//        for (;;) {
//            rb_str_locktmp(str);
//            read_check(fptr->f);
//            n = io_fread(rstring(str)->ptr+bytes, siz-bytes, fptr);
//            rb_str_unlocktmp(str);
//            if (n == 0 && bytes == 0) {
//                if (!fptr->f) break;
//                if (feof(fptr->f)) break;
//                if (!ferror(fptr->f)) break;
//                rb_sys_fail(fptr->path);
//            }
//            bytes += n;
//            if (bytes < siz) break;
//            siz += bufsiz;
//            rb_str_resize(str, siz);
//        }
//        if (bytes != siz) rb_str_resize(str, bytes);
//        obj_taint(str);
//
//        return str;
}
// todo: there's a lot of complexity here due to error handling and
// nonblocking io; much of this goes away, but for now i'm just
// having read call channelstream.fread directly.
//    protected int fread(int len, bytelist buffer) {
//        long n = len;
//        int c;
//        int saved_errno;
//
//        while (n > 0) {
//            c = read_buffered_data(ptr, n, fptr->f);
//            if (c < 0) goto eof;
//            if (c > 0) {
//                ptr += c;
//                if ((n -= c) <= 0) break;
//            }
//            rb_thread_wait_fd(fileno(fptr->f));
//            rb_io_check_closed(fptr);
//            clearerr(fptr->f);
//            trap_beg;
//            c = getc(fptr->f);
//            trap_end;
//            if (c == eof) {
//              eof:
//                if (ferror(fptr->f)) {
//                    switch (errno) {
//                      case eintr:
//    #if defined(erestart)
//                      case erestart:
//    #endif
//                        clearerr(fptr->f);
//                        continue;
//                      case eagain:
//    #if defined(ewouldblock) && ewouldblock != eagain
//                      case ewouldblock:
//    #endif
//                        if (len > n) {
//                            clearerr(fptr->f);
//                        }
//                        saved_errno = errno;
//                        rb_warning("nonblocking io#read is obsolete; use io#readpartial or io#sysread");
//                        errno = saved_errno;
//                    }
//                    if (len == n) return 0;
//                }
//                break;
//            }
//            *ptr++ = c;
//            n--;
//        }
//        return len - n;
//
//    }
/** read a byte. on eof throw eoferror.
*
*/
@jrubymethod name
public irubyobject readchar
irubyobject c   getc
if  c isnil    throw getruntime   neweoferror
return c
}
@jrubymethod
public irubyobject stat threadcontext context
openfile checkclosed context getruntime
return context getruntime   newfilestat getopenfilechecked   getmainstream   getdescriptor   getfiledescriptor
}
/**
* <p>invoke a block for each byte.</p>
*/
public irubyobject each_byte threadcontext context  block block
ruby runtime   context getruntime
try
openfile myopenfile   getopenfilechecked
while  true
myopenfile checkreadable runtime
myopenfile setreadbuffered
// todo: read_check from mri
int c   myopenfile getmainstream   fgetc
if  c     1
// todo: check for error, clear it, and wait until readable before trying once more
//                    if (ferror(f)) {
//                        clearerr(f);
//                        if (!rb_io_wait_readable(fileno(f)))
//                            rb_sys_fail(fptr->path);
//                        continue;
//                    }
break
}
assert c < 256
block yield context  getruntime   newfixnum c
}
// todo: one more check for error
//            if (ferror(f)) rb_sys_fail(fptr->path);
return this
catch  pipeexception ex
throw runtime newerrnoepipeerror
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
catch  baddescriptorexception e
throw runtime newerrnoebadferror
catch  eofexception e
return runtime.getnil();
catch  ioexception e
throw runtime newioerror e getmessage
}
}
@jrubymethod name      frame   true
public irubyobject each_byte19 final threadcontext context  final block block
return block isgiven   ? each_byte context  block    enumeratorize context getruntime    this
}
@jrubymethod name
public irubyobject bytes final threadcontext context
return enumeratorize context getruntime    this
}
@jrubymethod name
public irubyobject lines final threadcontext context
return enumeratorize context getruntime    this
}
public irubyobject each_char final threadcontext context  final block block
ruby runtime   context getruntime
irubyobject ch
while   ch   getc    isnil
byte c    byte rubynumeric fix2int ch
int n   runtime getkcode   getencoding   length c
rubystring str   runtime newstring
str settaint true
str cat c
while   n > 0
if  ch   getc    isnil
block yield context  str
return this
}
c    byte rubynumeric fix2int ch
str cat c
}
block yield context  str
}
return this
}
@jrubymethod name      frame   true
public irubyobject each_char19 final threadcontext context  final block block
return block isgiven   ? each_char context  block    enumeratorize context getruntime    this
}
@jrubymethod name      frame   true
public irubyobject chars19 final threadcontext context  final block block
return block isgiven   ? each_char context  block    enumeratorize context getruntime    this
}
/**
* <p>invoke a block for each line.</p>
*/
public rubyio each_line threadcontext context  irubyobject args  block block
ruby runtime   context getruntime
bytelist separator   getseparatorforgets runtime  args
bytelistcache cache   new bytelistcache
for  irubyobject line   getline runtime  separator    line isnil
line   getline runtime  separator  cache
block yield context  line
}
return this
}
@jrubymethod name      optional   1  frame   true
public irubyobject each19 final threadcontext context  irubyobjectargs  final block block
return block isgiven   ? each_line context  args  block    enumeratorize context getruntime    this     args
}
@jrubymethod name      optional   1  frame   true
public irubyobject each_line19 final threadcontext context  irubyobjectargs  final block block
return block isgiven   ? each_line context  args  block    enumeratorize context getruntime    this     args
}
@jrubymethod name      optional   1
public rubyarray readlines threadcontext context  irubyobject args
ruby runtime   context getruntime
irubyobject separatorargs   args length > 0 ? new irubyobject   args     irubyobject null_array
bytelist separator   getseparatorforgets runtime  separatorargs
rubyarray result   runtime newarray
irubyobject line
while     line   getline runtime  separator   isnil
result append line
}
return result
}
@jrubymethod name
public rubyio to_io
return this
}
@override
public string tostring
return     openfile getmode         openfile getmainstream   getdescriptor   getfileno
}
/* class methods for io */
/** rb_io_s_foreach
*
*/
public static irubyobject foreach threadcontext context  irubyobject recv  irubyobject args  block block
ruby runtime   context getruntime
int count   args length
irubyobject filename   args converttostring
runtime checksafestring filename
bytelist separator   getseparatorfromargs runtime  args  1
rubyio io    rubyio rubyfile open context  runtime getfile    new irubyobject   filename    block null_block
bytelistcache cache   new bytelistcache
if   io isnil
try
irubyobject str   io getline runtime  separator  cache
while   str isnil
block yield context  str
str   io getline runtime  separator  cache
}
finally
io close
}
}
return runtime.getnil();
}
@jrubymethod name      required   1  optional   1  frame   true  meta   true
public static irubyobject foreach19 final threadcontext context  irubyobject recv  irubyobject args  final block block
return block isgiven   ? foreach context  recv  args  block    enumeratorize context getruntime    recv     args
}
private static rubyio converttoio threadcontext context  irubyobject obj
return  rubyio typeconverter converttotype obj  context getruntime   getio
}
private static boolean registerselect threadcontext context  selector selector  irubyobject obj  rubyio ioobj  int ops  throws ioexception
channel channel   ioobj getchannel
if  channel    null      channel instanceof selectablechannel
return false
}
selectablechannel  channel  configureblocking false
int real_ops     selectablechannel  channel  validops     ops
selectionkey key     selectablechannel  channel  keyfor selector
if  key    null
selectablechannel  channel  register selector  real_ops  obj
} else {
key interestops key interestops   real_ops
}
return true
}
@jrubymethod name      required   1  optional   3  meta   true
public static irubyobject select threadcontext context  irubyobject recv  irubyobject args
return select_static context  context getruntime    args
}
private static void checkarraytype ruby runtime  irubyobject obj
if    obj instanceof rubyarray
throw runtime newtypeerror
obj getmetaclass   getname
}
}
public static irubyobject select_static threadcontext context  ruby runtime  irubyobject args
selector selector   null
try
set pending   new hashset
set unselectable_reads   new hashset
set unselectable_writes   new hashset
map<rubyio  boolean> blocking   new hashmap
selector   selector open
if   args isnil
// read
checkarraytype runtime  args
for  iterator i     rubyarray args  getlist   iterator    i hasnext
irubyobject obj    irubyobject i next
rubyio ioobj   converttoio context  obj
// save blocking state
if  ioobj getchannel   instanceof selectablechannel  blocking put ioobj    selectablechannel ioobj getchannel    isblocking
if  registerselect context  selector  obj  ioobj  selectionkey op_read   selectionkey op_accept
if  ioobj writedatabuffered
pending add obj
}
} else {
if   ioobj openfile getmode     openfile readable     0
unselectable_reads add obj
}
}
}
}
if  args length > 1     args isnil
// write
checkarraytype runtime  args
for  iterator i     rubyarray args  getlist   iterator    i hasnext
irubyobject obj    irubyobject i next
rubyio ioobj   converttoio context  obj
// save blocking state
if   blocking containskey ioobj     ioobj getchannel   instanceof selectablechannel  blocking put ioobj    selectablechannel ioobj getchannel    isblocking
if   registerselect context  selector  obj  ioobj  selectionkey op_write
if   ioobj openfile getmode     openfile writable     0
unselectable_writes add obj
}
}
}
}
if  args length > 2     args isnil
checkarraytype runtime  args
// java's select doesn't do anything about this, so we leave it be.
}
final boolean has_timeout    args length > 3     args isnil
long timeout   0
if  has_timeout
irubyobject timearg   args
if  timearg instanceof rubyfloat
timeout   math round   rubyfloat timearg  getdoublevalue     1000
else if  timearg instanceof rubyfixnum
timeout   math round   rubyfixnum timearg  getdoublevalue     1000
else      todo  mri also can hadle bignum here
throw runtime newtypeerror     timearg getmetaclass   getname
}
if  timeout < 0
throw runtime newargumenterror
}
}
if  pending isempty      unselectable_reads isempty      unselectable_writes isempty
if  has_timeout
if  timeout    0
selector selectnow
} else {
selector select timeout
}
} else {
selector select
}
} else {
selector selectnow
}
list r   new arraylist
list w   new arraylist
list e   new arraylist
for  iterator i   selector selectedkeys   iterator    i hasnext
selectionkey key    selectionkey i next
try
int interestandready   key interestops     key readyops
if   interestandready    selectionkey op_read   selectionkey op_accept   selectionkey op_connect      0
r add key attachment
pending remove key attachment
}
if   interestandready    selectionkey op_write      0
w add key attachment
}
catch  cancelledkeyexception cke
// todo: is this the right thing to do?
pending remove key attachment
e add key attachment
}
}
r addall pending
r addall unselectable_reads
w addall unselectable_writes
// make all sockets blocking as configured again
selector close       close unregisters all channels  so we can safely reset blocking modes
for  map entry blockingentry   blocking entryset
selectablechannel channel    selectablechannel   rubyio blockingentry getkey    getchannel
synchronized  channel blockinglock
channel configureblocking  boolean blockingentry getvalue
}
}
if  r size      0    w size      0    e size      0
return runtime.getnil();
}
list ret   new arraylist
ret add rubyarray newarray runtime  r
ret add rubyarray newarray runtime  w
ret add rubyarray newarray runtime  e
return rubyarray newarray runtime  ret
catch  ioexception e
throw runtime newioerror e getmessage
finally
if  selector    null
try
selector close
catch  exception e
}
}
}
}
public static irubyobject read threadcontext context  irubyobject recv  irubyobject args
switch  args length
case 0  throw context getruntime   newargumenterror 0  1
case 1  return read context  recv  args  block null_block
case 2  return read context  recv  args  args
case 3  return read context  recv  args  args  args
default  throw context getruntime   newargumenterror args length  3
}
}
private static rubyio newfile threadcontext context  irubyobject recv  irubyobject    args
return  rubyio  rubykernel open context  recv  args  block null_block
}
@jrubymethod name      meta   true  compat   compatversion ruby1_8
public static irubyobject read threadcontext context  irubyobject recv  irubyobject path  block unusedblock
rubyio file   newfile context  recv  path
try
return file read context
finally
file close
}
}
@jrubymethod name      meta   true  compat   compatversion ruby1_8
public static irubyobject read threadcontext context  irubyobject recv  irubyobject path  irubyobject length
rubyio file   newfile context  recv  path
try
return  length isnil   ? file read context  length    file read context
finally
file close
}
}
@jrubymethod name      meta   true  compat   compatversion ruby1_8
public static irubyobject read threadcontext context  irubyobject recv  irubyobject path  irubyobject length  irubyobject offset
rubyio file   newfile context  recv  path
try
if   offset isnil    file seek context  offset
return  length isnil   ? file read context  length    file read context
finally
file close
}
}
/**
*  options is a hash which can contain:
*    encoding: string or encoding
*    mode: string
*    open_args: array of string
*/
private static irubyobject read19 threadcontext context  irubyobject recv  irubyobject path  irubyobject length  irubyobject offset  rubyhash options
// fixme: process options
rubyio file   newfile context  recv  path
try
if   offset isnil    file seek context  offset
return  length isnil   ? file read context  length    file read context
finally
file close
}
}
// enebo: annotation processing forced me to do pangea method here...
@jrubymethod name      meta   true  required   1  optional   3  compat   compatversion ruby1_9
public static irubyobject read19 threadcontext context  irubyobject recv  irubyobject args  block unusedblock
irubyobject nil   context getruntime   getnil
irubyobject path   args
irubyobject length   nil
irubyobject offset   nil
rubyhash options   null
if  args length > 3
if    args instanceof rubyhash   throw context getruntime   newtypeerror
options    rubyhash  args
offset   args
length   args
else if  args length > 2
if  args instanceof rubyhash
options    rubyhash  args
} else {
offset   args
}
length   args
else if  args length > 1
if  args instanceof rubyhash
options    rubyhash  args
} else {
length   args
}
}
return read19 context  recv  path  length  offset   rubyhash  options
}
@jrubymethod name      required   1  optional   1  meta   true
public static rubyarray readlines threadcontext context  irubyobject recv  irubyobject args  block unusedblock
int count   args length
irubyobject filearguments   new irubyobject  args converttostring
irubyobject separatorarguments   count >  2 ? new irubyobject args    irubyobject null_array
rubyio file    rubyio  rubykernel open context  recv  filearguments  block null_block
try
return file readlines context  separatorarguments
finally
file close
}
}
@jrubymethod name      required   1  optional   1  meta   true
public static irubyobject popen threadcontext context  irubyobject recv  irubyobject args  block block
ruby runtime   context getruntime
int mode
irubyobject cmdobj   null
if  platform is_windows
string tokens   args converttostring   tostring   split    2
if  tokens length > 1
cmdobj   new rubystring runtime   rubyclass  recv
tokens replace             tokens
}
else
cmdobj   new rubystring runtime   rubyclass  recv
tokens replace
}
}
else
cmdobj   args converttostring
}
runtime checksafestring cmdobj
if    equals cmdobj tostring
throw runtime newnotimplementederror
}
try
if  args length    1
mode   modeflags rdonly
else if  args instanceof rubyfixnum
mode   rubyfixnum num2int args
} else {
mode   getiomodesintfromstring runtime  args converttostring   tostring
}
modeflags modes   new modeflags mode
shelllauncher popenprocess process   shelllauncher popen runtime  cmdobj  modes
// yes, this is gross. java.lang.process does not appear to be guaranteed
// "ready" when we get it back from runtime#exec, so we try to give it a
// chance by waiting for 10ms before we proceed. only doing this on 1.5
// since hotspot 1.6+ does not seem to exhibit the problem.
if  system getproperty       equals
synchronized  process
try
process wait 100
catch  interruptedexception ie
}
}
rubyio io   new rubyio runtime  process  modes
if  block isgiven
try
return block yield context  io
finally
if  io openfile isopen
io close
}
runtime getglobalvariables   set    rubyprocess rubystatus newprocessstatus runtime   process waitfor
}
}
return io
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
catch  ioexception e
throw runtime newioerrorfromexception e
catch  interruptedexception e
throw runtime newthreaderror
}
}
@jrubymethod required   1  rest   true  frame   true  meta   true
public static irubyobject popen3 threadcontext context  irubyobject recv  irubyobject args  block block
ruby runtime   context getruntime
try
popentuple tuple   popenspecial context  args
rubyarray yieldargs   rubyarray newarraylight runtime
tuple output
tuple input
tuple error
if  block isgiven
try
return block yield context  yieldargs
finally
cleanuppopen tuple
runtime getglobalvariables   set    rubyprocess rubystatus newprocessstatus runtime   tuple process waitfor     256
}
}
return yieldargs
catch  interruptedexception e
throw runtime newthreaderror
}
}
@jrubymethod required   1  rest   true  frame   true  meta   true
public static irubyobject popen4 threadcontext context  irubyobject recv  irubyobject args  block block
ruby runtime   context getruntime
try
popentuple tuple   popenspecial context  args
rubyarray yieldargs   rubyarray newarraylight runtime
runtime newfixnum shelllauncher getpidfromprocess tuple process
tuple output
tuple input
tuple error
if  block isgiven
try
return block yield context  yieldargs
finally
cleanuppopen tuple
runtime getglobalvariables   set    rubyprocess rubystatus newprocessstatus runtime   tuple process waitfor     256
}
}
return yieldargs
catch  interruptedexception e
throw runtime newthreaderror
}
}
private static void cleanuppopen popentuple tuple
if  tuple input openfile isopen
tuple input close
}
if  tuple output openfile isopen
tuple output close
}
if  tuple error openfile isopen
tuple error close
}
}
private static class popentuple
public popentuple rubyio i  rubyio o  rubyio e  process p
input   i  output   o  error   e  process   p
}
public final rubyio input
public final rubyio output
public final rubyio error
public final process process
}
public static popentuple popenspecial threadcontext context  irubyobject args
ruby runtime   context getruntime
try
shelllauncher popenprocess process   shelllauncher popen3 runtime  args
rubyio input   process getinput      null ?
new rubyio runtime  process getinput
new rubyio runtime  process getinputstream
rubyio output   process getoutput      null ?
new rubyio runtime  process getoutput
new rubyio runtime  process getoutputstream
rubyio error   process geterror      null ?
new rubyio runtime  process geterror
new rubyio runtime  process geterrorstream
input getopenfile   getmainstream   getdescriptor
setcanbeseekable false
output getopenfile   getmainstream   getdescriptor
setcanbeseekable false
error getopenfile   getmainstream   getdescriptor
setcanbeseekable false
return new popentuple input  output  error  process
catch  ioexception e
throw runtime newioerrorfromexception e
}
}
// nio based pipe
@jrubymethod name      meta   true
public static irubyobject pipe threadcontext context  irubyobject recv
// todo: this isn't an exact port of mri's pipe behavior, so revisit
ruby runtime   context getruntime
try
pipe pipe   pipe open
rubyio source   new rubyio runtime  pipe source
rubyio sink   new rubyio runtime  pipe sink
sink openfile getmainstream   setsync true
return runtime newarraynocopy new irubyobject   source  sink
catch  ioexception ioe
throw runtime newioerrorfromexception ioe
}
}
@jrubymethod name      meta   true  compat   ruby1_9
public static irubyobject copy_stream threadcontext context  irubyobject recv
irubyobject arg1  irubyobject arg2
ruby runtime   context getruntime
rubyio io1   null
boolean close_io1   false
rubyio io2   null
boolean close_io2   false
try
if  arg1 instanceof rubystring
io1    rubyio  rubyfile open context  runtime getfile    new irubyobject  arg1   block null_block
close_io1   true
else if  arg1 instanceof rubyio
io1    rubyio  arg1
} else {
throw runtime newtypeerror
}
if  arg2 instanceof rubystring
io2    rubyio  rubyfile open context  runtime getfile    new irubyobject  arg2  runtime newstring      block null_block
else if  arg2 instanceof rubyio
io2    rubyio  arg2
close_io2   true
} else {
throw runtime newtypeerror
}
channeldescriptor d1   io1 openfile getmainstream   getdescriptor
if   d1 isseekable
throw context getruntime   newtypeerror
}
channeldescriptor d2   io2 openfile getmainstream   getdescriptor
if   d2 isseekable
throw context getruntime   newtypeerror
}
filechannel f1    filechannel d1 getchannel
filechannel f2    filechannel d2 getchannel
try
long size   f1 size
f1 transferto f2 position    size  f2
return context getruntime   newfixnum size
catch  ioexception ioe
throw runtime newioerrorfromexception ioe
}
finally
try
if  io1    null
io1 close
}
finally
if  io2    null
io2 close
}
}
}
}
@jrubymethod name      meta   true  backtrace   true  compat   compatversion ruby1_9
public static irubyobject tryconvert threadcontext context  irubyobject recv  irubyobject arg
return arg respondsto    ? converttoio context  arg    context getruntime   getnil
}
/**
* add a thread to the list of blocking threads for this io.
*
* @param thread a thread blocking on this io
*/
public synchronized void addblockingthread rubythread thread
if  blockingthreads    null
blockingthreads   new arraylist<rubythread> 1
}
blockingthreads add thread
}
/**
* remove a thread from the list of blocking threads for this io.
*
* @param thread a thread blocking on this io
*/
public synchronized void removeblockingthread rubythread thread
if  blockingthreads    null
return
}
for  int i   0  i < blockingthreads size    i
if  blockingthreads get i     thread
// not using remove(object) here to avoid the equals() call
blockingthreads remove i
}
}
}
/**
* fire an ioerror in all threads blocking on this io object
*/
protected synchronized void interruptblockingthreads
if  blockingthreads    null
return
}
for  int i   0  i < blockingthreads size    i
rubythread thread   blockingthreads get i
// raise will also wake the thread from selection
thread raise new irubyobject  getruntime   newioerror    getexception     block null_block
}
}
/**
* caching reference to allocated byte-lists, allowing for internal byte[] to be
* reused, rather than reallocated.
*
* predominately used on {@link rubyio#getline(ruby, bytelist)} and variants.
*
* @author realjenius
*/
private static class bytelistcache
private byte buffer   new byte
public void release bytelist l
buffer   l getunsafebytes
}
public bytelist allocate int size
bytelist l   new bytelist buffer  0  size  false
return l
}
}
/**
*
*  ==== options
*  <code>opt</code> can have the following keys
*  :mode ::
*    same as <code>mode</code> parameter
*  :external_encoding ::
*    external encoding for the io. "-" is a
*    synonym for the default external encoding.
*  :internal_encoding ::
*    internal encoding for the io.
*    "-" is a synonym for the default internal encoding.
*    if the value is nil no conversion occurs.
*  :encoding ::
*    specifies external and internal encodings as "extern:intern".
*  :textmode ::
*    if the value is truth value, same as "b" in argument <code>mode</code>.
*  :binmode ::
*    if the value is truth value, same as "t" in argument <code>mode</code>.
*
*  also <code>opt</code> can have same keys in <code>string#encode</code> for
*  controlling conversion between the external encoding and the internal encoding.
*
*/
protected modeflags parseoptions threadcontext context  irubyobject options  modeflags modes
ruby runtime   context getruntime
rubyhash rubyoptions    rubyhash  options
irubyobject internalencodingoption   rubyoptions fastaref runtime newsymbol
irubyobject externalencodingoption   rubyoptions fastaref runtime newsymbol
rubystring dash   runtime newstring
if  externalencodingoption    null     externalencodingoption isnil
if  dash eql externalencodingoption
externalencodingoption   rubyencoding getdefaultexternal runtime
}
setexternalencoding context  externalencodingoption
}
if  internalencodingoption    null     internalencodingoption isnil
if  dash eql internalencodingoption
internalencodingoption   rubyencoding getdefaultinternal runtime
}
setinternalencoding context  internalencodingoption
}
irubyobject encoding   rubyoptions fastaref runtime newsymbol
if  encoding    null     encoding isnil
if  externalencodingoption    null     externalencodingoption isnil
context getruntime   getwarnings   warn    encoding
else if  internalencodingoption    null     internalencodingoption isnil
context getruntime   getwarnings   warn    encoding
} else {
parseencodingfromstring context  encoding  0
}
}
if  rubyoptions containskey runtime newsymbol
modes   parsemodes19 context  rubyoptions fastaref runtime newsymbol     asstring
}
//      fixme: check how ruby 1.9 handles this
//        if (rubyoptions.containskey(runtime.newsymbol("textmode")) &&
//                rubyoptions.fastaref(runtime.newsymbol("textmode")).istrue()) {
//            try {
//                modes = getiomodes(runtime, "t");
//            } catch (invalidvalueexception e) {
//                throw getruntime().newerrnoeinvalerror();
//            }
//        }
//
//        if (rubyoptions.containskey(runtime.newsymbol("binmode")) &&
//                rubyoptions.fastaref(runtime.newsymbol("binmode")).istrue()) {
//            try {
//                modes = getiomodes(runtime, "b");
//            } catch (invalidvalueexception e) {
//                throw getruntime().newerrnoeinvalerror();
//            }
//        }
return modes
}
/**
* try for around 1s to destroy the child process. this is to work around
* issues on some jvms where if you try to destroy the process too quickly
* it may not be ready and may ignore the destroy. a subsequent waitfor
* will then hang. this version tries to destroy and call exitvalue
* repeatedly for up to 1000 calls with 1ms delay between iterations, with
* the intent that the target process ought to be "ready to die" fairly
* quickly and we don't get stuck in a blocking waitfor call.
*
* @param runtime the ruby runtime, for raising an error
* @param process the process to obliterate
*/
public static void obliterateprocess process process
int i   0
object waitlock   new object
while  true
// only try 1000 times with a 1ms sleep between, so we don't hang
// forever on processes that ignore sigterm
if  i >  1000
throw new runtimeexception     process
}
// attempt to destroy (sigterm on unix, terminateprocess on windows)
process destroy
try
// get the exit value; succeeds if it has terminated, throws
// illegalthreadstateexception if not.
process exitvalue
catch  illegalthreadstateexception itse
// increment count and try again after a 1ms sleep
i    1
synchronized  waitlock
try  waitlock wait 1    catch  interruptedexception ie
}
continue
}
// success!
break
}
}
}