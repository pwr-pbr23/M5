/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007-2010 jruby team <team@jruby.org>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util
import java io file
import java io fileinputstream
import java io fileoutputstream
import java io bufferedinputstream
import java io filteroutputstream
import java io ioexception
import java io inputstream
import java io outputstream
import java io pipedinputstream
import java io pipedoutputstream
import java io printstream
import java lang reflect field
import static java lang system
import java nio bytebuffer
import java nio channels filechannel
import java util arrays
import java util hashmap
import java util iterator
import java util map
import java util regex pattern
import java util regex matcher
import org jruby main
import org jruby ruby
import org jruby rubyarray
import org jruby rubyhash
import org jruby rubyio
import org jruby rubyinstanceconfig
import org jruby rubymodule
import org jruby ext posix posix
import org jruby ext posix util fieldaccess
import org jruby ext posix util platform
import org jruby javasupport util runtimehelpers
import org jruby libraries rbconfiglibrary
import org jruby runtime threadcontext
import org jruby runtime builtin irubyobject
import org jruby util io modeflags
/**
* this mess of a class is what happens when all java gives you is
* runtime.getruntime().exec(). thanks dude, that really helped.
* @author nicksieger
*/
public class shelllauncher
private static final boolean debug   false
private static final string path_env
private static final string home_env
// from mri -- note the unixy file separators
private static final string default_path
private static final string windows_exe_suffixes
the order is important
private static final string windows_internal_cmds
// todo: better check is needed, with quoting/escaping
private static final pattern shell_metacharacter_pattern
pattern compile    n]"
private static final pattern win_envvar_pattern   pattern compile
private static class scriptthreadprocess extends process implements runnable
private final string argarray
private final string env
private final file pwd
private final boolean pipedstreams
private final pipedinputstream processoutput
private final pipedinputstream processerror
private final pipedoutputstream processinput
private rubyinstanceconfig config
private thread processthread
private int result
private ruby parentruntime
public scriptthreadprocess ruby parentruntime  final string argarray  final string env  final file dir
this parentruntime  argarray  env  dir  true
public scriptthreadprocess ruby parentruntime  final string argarray  final string env  final file dir  final boolean pipedstreams
this parentruntime   parentruntime
this argarray   argarray
this env   env
this pwd   dir
this pipedstreams   pipedstreams
if  pipedstreams
processoutput   new pipedinputstream
processerror   new pipedinputstream
processinput   new pipedoutputstream
else
processoutput   processerror   null
processinput   null
public void run
try
this result    new main config  run argarray   getstatus
catch  throwable throwable
throwable printstacktrace this config geterror
this result    1
finally
this config getoutput   close
this config geterror   close
try  this config getinput   close     catch  ioexception ioe
private map<string  string> environmentmap string env
map<string  string> m   new hashmap<string  string>
for  int i   0  i < env length  i
string kv   env split    2
m put kv  kv
return m
public void start   throws ioexception
config   new rubyinstanceconfig parentruntime getinstanceconfig
setenvironment environmentmap env
setcurrentdirectory pwd tostring
if  pipedstreams
config setinput new pipedinputstream processinput
config setoutput new printstream new pipedoutputstream processoutput
config seterror new printstream new pipedoutputstream processerror
string procname
if  argarray length > 0
procname   argarray
processthread   new thread this      procname
processthread setdaemon true
processthread start
public outputstream getoutputstream
return processinput
public inputstream getinputstream
return processoutput
public inputstream geterrorstream
return processerror
public int waitfor   throws interruptedexception
processthread join
return result
public int exitvalue
return result
public void destroy
if  pipedstreams
closestreams
processthread interrupt
private void closestreams
try   processinput close      catch  ioexception io
try   processoutput close      catch  ioexception io
try   processerror close      catch  ioexception io
private static string getcurrentenv ruby runtime
rubyhash hash    rubyhash runtime getobject   fastgetconstant
string ret   new string
int i 0
for iterator iter   hash directentryset   iterator   iter hasnext   i
map entry e    map entry iter next
ret   e getkey   tostring         e getvalue   tostring
return ret
private static boolean filenameispathsearchable string fname  boolean forexec
boolean issearchable   true
if  fname startswith
fname startswith
fname startswith
forexec     fname indexof        1
issearchable   false
if  platform is_windows
if  fname startswith
fname startswith
fname startswith
fname length   > 2     fname startswith   1
forexec     fname indexof        1
issearchable   false
return issearchable
private static file tryfile ruby runtime  string fdir  string fname
file pathfile
if  fdir    null
pathfile   new file fname
else
pathfile   new file fdir  fname
if   pathfile isabsolute
pathfile   new file runtime getcurrentdirectory    pathfile getpath
log runtime      pathfile
if  pathfile exists
return pathfile
else
return null
private static boolean withexesuffix string fname
string lowercasefname   fname tolowercase
for  string suffix   windows_exe_suffixes
if  lowercasefname endswith suffix
return true
return false
private static file isvalidfile ruby runtime  string fdir  string fname  boolean isexec
file validfile   null
if  isexec    platform is_windows
if  withexesuffix fname
validfile   tryfile runtime  fdir  fname
else
for  string suffix  windows_exe_suffixes
validfile   tryfile runtime  fdir  fname   suffix
if  validfile    null
// found a valid file, no need to search further
break
else
file pathfile   tryfile runtime  fdir  fname
if  pathfile    null
if  isexec
if   pathfile isdirectory
string pathfilestr   pathfile getabsolutepath
posix posix   runtime getposix
if  posix stat pathfilestr  isexecutable
validfile   pathfile
else
validfile   pathfile
return validfile
private static file isvalidfile ruby runtime  string fname  boolean isexec
string fdir   null
return isvalidfile runtime  fdir  fname  isexec
private static file findpathfile ruby runtime  string fname  string path  boolean isexec
file pathfile   null
boolean dopathsearch   filenameispathsearchable fname  isexec
if  dopathsearch
// todo: not used
string pathseparator   system getproperty
for  string fdir  path
// note: jruby's handling of tildes is more complete than
//       mri's, which can't handle user names after the tilde
//       when searching the executable path
pathfile   isvalidfile runtime  fdir  fname  isexec
if  pathfile    null
break
else
pathfile   isvalidfile runtime  fname  isexec
return pathfile
private static file findpathexecutable ruby runtime  string fname
string path   system getenv path_env
string pathnodes   null
if  path    null
pathnodes   default_path     assume  not modified by callee
else
string pathseparator   system getproperty
if  platform is_windows
// windows-specific behavior
path       pathseparator   path
pathnodes   path split pathseparator
return findpathfile runtime  fname  pathnodes  true
public static int runandwait ruby runtime  irubyobject rawargs
return runandwait runtime  rawargs  runtime getoutputstream
public static long runwithoutwait ruby runtime  irubyobject rawargs
return runwithoutwait runtime  rawargs  runtime getoutputstream
public static int execandwait ruby runtime  irubyobject rawargs
file pwd   new file runtime getcurrentdirectory
launchconfig cfg   new launchconfig runtime  rawargs  true
if  cfg shouldruninprocess
log runtime
try
// exec needs to behave differently in-process, because it's technically
// supposed to replace the calling process. so if we're supposed to run
// in-process, we allow it to use the default streams and not use
// pumpers at all. see jruby-2156 and jruby-2154.
scriptthreadprocess ipscript   new scriptthreadprocess
runtime  cfg getexecargs    getcurrentenv runtime   pwd  false
ipscript start
return ipscript waitfor
catch  ioexception e
throw runtime newioerrorfromexception e
catch  interruptedexception e
throw runtime newthreaderror
else
return runandwait runtime  rawargs
public static int runandwait ruby runtime  irubyobject rawargs  outputstream output
return runandwait runtime  rawargs  output  true
public static int runandwait ruby runtime  irubyobject rawargs  outputstream output  boolean doexecutablesearch
outputstream error   runtime geterrorstream
inputstream input   runtime getinputstream
try
process aprocess   run runtime  rawargs  doexecutablesearch
handlestreams runtime  aprocess  input  output  error
return aprocess waitfor
catch  ioexception e
throw runtime newioerrorfromexception e
catch  interruptedexception e
throw runtime newthreaderror
public static long runwithoutwait ruby runtime  irubyobject rawargs  outputstream output
try
popenprocess aprocess   new popenprocess popenshared runtime  rawargs
return getpidfromprocess aprocess
catch  ioexception e
throw runtime newioerrorfromexception e
public static long getpidfromprocess process process
if  process instanceof scriptthreadprocess
return process hashcode
else if  process instanceof popenprocess
return reflectpidfromprocess   popenprocess process  getchild
else
return reflectpidfromprocess process
private static final class unixprocess
private static final field unixprocess_pid
private static final class processimpl
private static final field processimpl_handle
private interface pidgetter   public long getpid process process
private static final pidgetter pid_getter
static
// default pidgetter
pidgetter pg   new pidgetter
public long getpid process process
return process hashcode
class up   null
field pid   null
try
up   class forname
pid   up getdeclaredfield
pid setaccessible true
catch  exception e
// ignore and try windows version
unixprocess   up
unixprocess_pid   pid
class pi   null
field handle   null
try
pi   class forname
handle   pi getdeclaredfield
handle setaccessible true
catch  exception e
// ignore and use hashcode
processimpl   pi
processimpl_handle   handle
if  unixprocess_pid    null
if  processimpl_handle    null
// try both
pg   new pidgetter
public long getpid process process
try
if  unixprocess isinstance process
return  integer unixprocess_pid get process
else if  processimpl isinstance process
return  long processimpl_handle get process
catch  exception e
// ignore and use hashcode
return process hashcode
else
// just unix
pg   new pidgetter
public long getpid process process
try
if  unixprocess isinstance process
return  integer unixprocess_pid get process
catch  exception e
// ignore and use hashcode
return process hashcode
else if  processimpl_handle    null
// just windows
pg   new pidgetter
public long getpid process process
try
if  processimpl isinstance process
return  long processimpl_handle get process
catch  exception e
// ignore and use hashcode
return process hashcode
else
// neither
pg   new pidgetter
public long getpid process process
return process hashcode
pid_getter   pg
public static long reflectpidfromprocess process process
return pid_getter getpid process
public static process run ruby runtime  irubyobject string  throws ioexception
return run runtime  new irubyobject  string   false
public static popenprocess popen ruby runtime  irubyobject string  modeflags modes  throws ioexception
return new popenprocess popenshared runtime  new irubyobject  string    runtime  modes
public static popenprocess popen3 ruby runtime  irubyobject strings  throws ioexception
return new popenprocess popenshared runtime  strings
private static process popenshared ruby runtime  irubyobject strings  throws ioexception
string shell   getshell runtime
process childprocess   null
file pwd   new file runtime getcurrentdirectory
try
// con: popen is a case where i think we should just always shell out.
if  strings length    1
// single string command, pass to sh to expand wildcards
string argarray   new string
argarray   shell
argarray   shell endswith    ?
argarray   strings asjavastring
childprocess   runtime getruntime   exec argarray  getcurrentenv runtime   pwd
else
// direct invocation of the command
string args   parsecommandline runtime getcurrentcontext    runtime  strings
childprocess   runtime getruntime   exec args  getcurrentenv runtime   pwd
catch  securityexception se
throw runtime newsecurityerror se getlocalizedmessage
return childprocess
/**
* unwrap all filtering streams between the given stream and its actual
* unfiltered stream. this is primarily to unwrap streams that have
* buffers that would interfere with interactivity.
*
* @param filteredstream the stream to unwrap
* @return an unwrapped stream, presumably unbuffered
*/
public static outputstream unwrapbufferedstream outputstream filteredstream
if  rubyinstanceconfig no_unwrap_process_streams  return filteredstream
while  filteredstream instanceof filteroutputstream
try
filteredstream    outputstream
fieldaccess getprotectedfieldvalue filteroutputstream class
filteredstream
catch  exception e
break     break out if we've dug as deep as we can
return filteredstream
/**
* unwrap all filtering streams between the given stream and its actual
* unfiltered stream. this is primarily to unwrap streams that have
* buffers that would interfere with interactivity.
*
* @param filteredstream the stream to unwrap
* @return an unwrapped stream, presumably unbuffered
*/
public static inputstream unwrapbufferedstream inputstream filteredstream
if  rubyinstanceconfig no_unwrap_process_streams  return filteredstream
while  filteredstream instanceof bufferedinputstream
try
filteredstream    inputstream
fieldaccess getprotectedfieldvalue bufferedinputstream class
filteredstream
catch  exception e
break     break out if we've dug as deep as we can
return filteredstream
public static class popenprocess extends process
private final process child
// real stream references, to keep them from being gced prematurely
private inputstream realinput
private outputstream realoutput
private inputstream realinerr
private inputstream input
private outputstream output
private inputstream inerr
private filechannel inputchannel
private filechannel outputchannel
private filechannel inerrchannel
private pumper inputpumper
private pumper inerrpumper
private pumper outputpumper
public popenprocess process child  ruby runtime  modeflags modes
this child   child
if  modes iswritable
prepareoutput child
else
// close process output
// see jruby-3405; hooking up to parent process stdin caused
// problems for irb etc using stdin.
try  child getoutputstream   close     catch  ioexception ioe
if  modes isreadable
prepareinput child
else
pumpinput child  runtime
pumpinerr child  runtime
public popenprocess process child
this child   child
prepareoutput child
prepareinput child
prepareinerr child
@override
public outputstream getoutputstream
return output
@override
public inputstream getinputstream
return input
@override
public inputstream geterrorstream
return inerr
public filechannel getinput
return inputchannel
public filechannel getoutput
return outputchannel
public filechannel geterror
return inerrchannel
public boolean hasoutput
return output    null    outputchannel    null
public process getchild
return child
@override
public int waitfor   throws interruptedexception
if  outputpumper    null
try
if  output    null  output close
catch  ioexception ioe
// ignore, we're on the way out
else
outputpumper quit
int result   child waitfor
return result
@override
public int exitvalue
return child exitvalue
@override
public void destroy
try
if  input    null  input close
if  inerr    null  inerr close
if  output    null  output close
if  inputchannel    null  inputchannel close
if  inerrchannel    null  inerrchannel close
if  outputchannel    null  outputchannel close
// processes seem to have some peculiar locking sequences, so we
// need to ensure nobody is trying to close/destroy while we are
synchronized  this
rubyio obliterateprocess child
if  inputpumper    null  synchronized inputpumper   inputpumper quit
if  inerrpumper    null  synchronized inerrpumper   inerrpumper quit
if  outputpumper    null  synchronized outputpumper   outputpumper quit
catch  ioexception ioe
throw new runtimeexception ioe
private void prepareinput process child
// popen callers wants to be able to read, provide subprocess in directly
realinput   child getinputstream
input   unwrapbufferedstream realinput
if  input instanceof fileinputstream
inputchannel     fileinputstream  input  getchannel
else
inputchannel   null
inputpumper   null
private void prepareinerr process child
// popen callers wants to be able to read, provide subprocess in directly
realinerr   child geterrorstream
inerr   unwrapbufferedstream realinerr
if  inerr instanceof fileinputstream
inerrchannel     fileinputstream  inerr  getchannel
else
inerrchannel   null
inerrpumper   null
private void prepareoutput process child
// popen caller wants to be able to write, provide subprocess out directly
realoutput   child getoutputstream
output   unwrapbufferedstream realoutput
if  output instanceof fileoutputstream
outputchannel     fileoutputstream  output  getchannel
else
outputchannel   null
outputpumper   null
private void pumpinput process child  ruby runtime
// no read requested, hook up read to parents output
inputstream childin   unwrapbufferedstream child getinputstream
filechannel childinchannel   null
if  childin instanceof fileinputstream
childinchannel     fileinputstream  childin  getchannel
outputstream parentout   unwrapbufferedstream runtime getout
filechannel parentoutchannel   null
if  parentout instanceof fileoutputstream
parentoutchannel     fileoutputstream  parentout  getchannel
if  childinchannel    null    parentoutchannel    null
inputpumper   new channelpumper runtime  childinchannel  parentoutchannel  pumper slave in  this
else
inputpumper   new streampumper runtime  childin  parentout  false  pumper slave in  this
inputpumper start
input   null
inputchannel   null
private void pumpinerr process child  ruby runtime
// no read requested, hook up read to parents output
inputstream childin   unwrapbufferedstream child geterrorstream
filechannel childinchannel   null
if  childin instanceof fileinputstream
childinchannel     fileinputstream  childin  getchannel
outputstream parentout   unwrapbufferedstream runtime getout
filechannel parentoutchannel   null
if  parentout instanceof fileoutputstream
parentoutchannel     fileoutputstream  parentout  getchannel
if  childinchannel    null    parentoutchannel    null
inerrpumper   new channelpumper runtime  childinchannel  parentoutchannel  pumper slave in  this
else
inerrpumper   new streampumper runtime  childin  parentout  false  pumper slave in  this
inerrpumper start
inerr   null
inerrchannel   null
private static class launchconfig
launchconfig ruby runtime  irubyobject rawargs  boolean doexecutablesearch
this runtime   runtime
this rawargs   rawargs
this doexecutablesearch   doexecutablesearch
shell   getshell runtime
args   parsecommandline runtime getcurrentcontext    runtime  rawargs
/**
* only run an in-process script if the script name has "ruby", ".rb",
* or "irb" in the name.
*/
private boolean shouldruninprocess
if   runtime getinstanceconfig   isrunrubyinprocess
return false
// check for special shell characters [<>|] at the beginning
// and end of each command word and don't run in process if we find them.
for  int i   0  i < args length  i
string c   args
if  c trim   length      0
continue
char firstlast   new char  c charat 0   c charat c length   1
for  int j   0  j < firstlast length  j
switch  firstlast
case    case    case    case
case    case    case    case
case    case    case    case
case    case    case    case
case    case    case    case
return false
case
if c length   > 1    c charat 1
return false
string command   args
if  platform is_windows
command   command tolowercase
// handle both slash types, \ and /.
string slashdelimitedtokens   command split
string finaltoken   slashdelimitedtokens
boolean inproc    finaltoken endswith
platform is_windows    finaltoken endswith
finaltoken endswith
finaltoken endswith
if   inproc
return false
else
// snip off ruby or jruby command from list of arguments
// leave alone if the command is the name of a script
int startindex   command endswith    ? 0   1
if  command trim   endswith
startindex   0
args   runtime getjrubyhome     file separator       file separator
execargs   new string
system arraycopy args  startindex  execargs  0  execargs length
return true
/**
* this hack is to work around a problem with cmd.exe on windows where it can't
* interpret a filename with spaces in the first argument position as a command.
* in that case it's better to try passing the bare arguments to runtime.exec.
* on all other platforms we'll always run the command in the shell.
*/
private boolean shouldruninshell
if  rawargs length    1
// this is the case when exact executable and its parameters passed,
// in such cases mri just executes it, without any shell.
return false
// in one-arg form, we always use shell, except for windows
if   platform is_windows  return true
// now, deal with windows
if  shell    null  return false
// todo: better name for the method
// essentially, we just check for shell meta characters.
// todo: we use args here and rawargs in upper method.
for  string arg   args
if   shouldverifypathexecutable arg trim
return true
// ok, so no shell meta-chars, now check that the command does exist
executable   args trim
executablefile   findpathexecutable runtime  executable
// if the executable exists, start it directly with no shell
if  executablefile    null
log runtime      executablefile
// todo: special processing for bat/cmd files needed at all?
// if (isbatch(executablefile)) {
//    log(runtime, "this is a bat/cmd file, will start in shell");
//    return true;
// }
return false
else
log runtime      executable
if  iscmdbuiltin executable
cmdbuiltin   true
return true
// todo: maybe true here?
return false
private void verifyexecutableforshell
string cmdline   rawargs tostring   trim
if  doexecutablesearch    shouldverifypathexecutable cmdline      cmdbuiltin
verifyexecutable
// now, prepare the exec args
execargs   new string
execargs   shell
execargs   shell endswith    ?
if  platform is_windows
// that's how mri does it too
execargs
else
execargs   cmdline
private void verifyexecutablefordirect
verifyexecutable
execargs   args
try
execargs   executablefile getcanonicalpath
catch  ioexception ioe
// can't get the canonical path, will use as-is
private void verifyexecutable
if  executablefile    null
if  executable    null
executable   args trim
executablefile   findpathexecutable runtime  executable
if  executablefile    null
throw runtime newerrnoenoenterror executable
private string getexecargs
return execargs
private static boolean isbatch file f
string path   f getpath
return  path endswith       path endswith
private boolean iscmdbuiltin string cmd
if   shell endswith          assume cmd exe
int idx   arrays binarysearch windows_internal_cmds  cmd tolowercase
if  idx >  0
log runtime      cmd
// windows shell internal command, launch in shell then
return true
return false
/**
* checks a command string to determine if it has i/o redirection
* characters that require it to be executed by a command interpreter.
*/
private static boolean hasredirection string cmdline
if  platform is_windows
// scan the string, looking for redirection characters (< or >), pipe
// character (|) or newline (\n) that are not in a quoted string
char quote
for  int idx   0  idx < cmdline length
char ptr   cmdline charat idx
switch  ptr
case
case
if  quote
quote   ptr
else if  quote    ptr
quote
idx
break
case
case
case
case
if  quote
return true
idx
break
case
// detect windows environment variables: %abc%
matcher envvarmatcher   win_envvar_pattern matcher cmdline substring idx
if  envvarmatcher find
return true
else
idx
break
case
// slash serves as escape character
idx
default
idx
break
return false
else
// todo: better check here needed, with quoting/escaping
matcher metamatcher   shell_metacharacter_pattern matcher cmdline
return metamatcher find
// should we try to verify the path executable, or just punt to the shell?
private static boolean shouldverifypathexecutable string cmdline
boolean verifypathexecutable   true
if  hasredirection cmdline
return false
return verifypathexecutable
private ruby runtime
private boolean doexecutablesearch
private irubyobject rawargs
private string shell
private string args
private string execargs
private boolean cmdbuiltin   false
private string executable
private file executablefile
public static process run ruby runtime  irubyobject rawargs  boolean doexecutablesearch  throws ioexception
process aprocess   null
file pwd   new file runtime getcurrentdirectory
launchconfig cfg   new launchconfig runtime  rawargs  doexecutablesearch
try
if  cfg shouldruninprocess
log runtime
scriptthreadprocess ipscript   new scriptthreadprocess
runtime  cfg getexecargs    getcurrentenv runtime   pwd
ipscript start
return ipscript
else if  cfg shouldruninshell
log runtime
// execute command with sh -c
// this does shell expansion of wildcards
cfg verifyexecutableforshell
aprocess   runtime getruntime   exec cfg getexecargs    getcurrentenv runtime   pwd
else
log runtime
cfg verifyexecutablefordirect
aprocess   runtime getruntime   exec cfg getexecargs    getcurrentenv runtime   pwd
catch  securityexception se
throw runtime newsecurityerror se getlocalizedmessage
return aprocess
private interface pumper extends runnable
public enum slave   in  out
public void start
public void quit
private static class streampumper extends thread implements pumper
private final inputstream in
private final outputstream out
private final boolean onlyifavailable
private final object waitlock   new object
private final object sync
private final slave slave
private volatile boolean quit
private final ruby runtime
streampumper ruby runtime  inputstream in  outputstream out  boolean avail  slave slave  object sync
this in   unwrapbufferedstream in
this out   unwrapbufferedstream out
this onlyifavailable   avail
this slave   slave
this sync   sync
this runtime   runtime
setdaemon true
@override
public void run
runtime getcurrentcontext   seteventhooksenabled false
byte buf   new byte
int numread
boolean hasreadsomething   false
try
while   quit
// the problem we trying to solve below: stdin in java
// is blocked and non-interruptible, so if we invoke read
// on it, we might never be able to interrupt such thread.
// so, we use in.available() to see if there is any input
// ready, and only then read it. but this approach can't
// tell whether the end of stream reached or not, so we
// might end up looping right at the end of the stream.
// well, at least, we can improve the situation by checking
// if some input was ever available, and if so, not
// checking for available anymore, and just go to read.
if  onlyifavailable     hasreadsomething
if  in available      0
synchronized  waitlock
waitlock wait 10
continue
else
hasreadsomething   true
if   numread   in read buf       1
break
out write buf  0  numread
catch  exception e
finally
if  onlyifavailable
synchronized  sync
// we need to close the out, since some
// processes would just wait for the stream
// to be closed before they process its content,
// and produce the output. e.g.: "cat".
if  slave    slave out
// we only close out if it's the slave stream, to avoid
// closing a directly-mapped stream from parent process
try   out close      catch  ioexception ioe
public void quit
this quit   true
synchronized  waitlock
waitlock notify
private static class channelpumper extends thread implements pumper
private final filechannel inchannel
private final filechannel outchannel
private final slave slave
private final object sync
private volatile boolean quit
private final ruby runtime
channelpumper ruby runtime  filechannel inchannel  filechannel outchannel  slave slave  object sync
if  debug  out println
this inchannel   inchannel
this outchannel   outchannel
this slave   slave
this sync   sync
this runtime   runtime
setdaemon true
@override
public void run
runtime getcurrentcontext   seteventhooksenabled false
bytebuffer buf   bytebuffer allocatedirect 1024
buf clear
try
while   quit    inchannel isopen      outchannel isopen
int read   inchannel read buf
if  read     1  break
buf flip
outchannel write buf
buf clear
catch  exception e
finally
// processes seem to have some peculiar locking sequences, so we
// need to ensure nobody is trying to close/destroy while we are
synchronized  sync
switch  slave
case out
try   outchannel close      catch  ioexception ioe
break
case in
try   inchannel close      catch  ioexception ioe
public void quit
interrupt
this quit   true
private static void handlestreams ruby runtime  process p  inputstream in  outputstream out  outputstream err  throws ioexception
inputstream pout   p getinputstream
inputstream perr   p geterrorstream
outputstream pin   p getoutputstream
streampumper t1   new streampumper runtime  pout  out  false  pumper slave in  p
streampumper t2   new streampumper runtime  perr  err  false  pumper slave in  p
// the assumption here is that the 'in' stream provides
// proper available() support. if available() always
// returns 0, we'll hang!
streampumper t3   new streampumper runtime  in  pin  true  pumper slave out  p
t1 start
t2 start
t3 start
try   t1 join      catch  interruptedexception ie
try   t2 join      catch  interruptedexception ie
t3 quit
try   err flush      catch  ioexception io
try   out flush      catch  ioexception io
try   pin close      catch  ioexception io
try   pout close      catch  ioexception io
try   perr close      catch  ioexception io
// force t3 to quit, just in case if it's stuck.
// note: on some platforms, even interrupt might not
// have an effect if the thread is io blocked.
try   t3 interrupt      catch  securityexception se
// todo: move inside the launchconfig
private static string parsecommandline threadcontext context  ruby runtime  irubyobject rawargs
string args
if  rawargs length    1
synchronized  runtime getloadservice
runtime getloadservice   require
rubymodule pathhelper   runtime getclassfrompath
rubyarray parts    rubyarray  runtimehelpers invoke
context  pathhelper     rawargs
args   new string
for  int i   0  i < parts getlength    i
args   parts entry i  tostring
else
args   new string
for  int i   0  i < rawargs length  i
args   rawargs tostring
return args
private static string getshell ruby runtime
return rbconfiglibrary jrubyshell
static void log ruby runtime  string msg
if  rubyinstanceconfig debug_launching
runtime geterr   println     msg