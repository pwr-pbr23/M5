package org jruby util
import java math biginteger
import java util arrays
import org jruby ruby
import org jruby rubybignum
import org jruby rubyinteger
import org jruby rubystring
import org jruby runtime builtin irubyobject
public class convertbytes
private final ruby runtime
private final bytelist _str
private int str
private int end
private byte data
private int base
private final boolean badcheck
private final boolean is19
public convertbytes ruby runtime  bytelist _str  int base  boolean badcheck
this runtime  _str  base  badcheck  false
public convertbytes ruby runtime  bytelist _str  int base  boolean badcheck  boolean is19
this runtime   runtime
this _str   _str
this str   _str getbegin
this data   _str getunsafebytes
this end   str   _str getrealsize
this badcheck   badcheck
this base   base
this is19   is19
public static final byte inttobinarybytes int i
return bytelist plain integer tobinarystring i
public static final byte inttooctalbytes int i
return bytelist plain integer tooctalstring i
public static final byte inttohexbytes int i
return bytelist plain integer tohexstring i  tolowercase
public static final byte inttohexbytes int i  boolean upper
string s   integer tohexstring i
s   upper ? s touppercase     s tolowercase
return bytelist plain s
public static final bytelist inttobinarybytelist int i
return new bytelist inttobinarybytes i
public static final bytelist inttooctalbytelist int i
return new bytelist inttooctalbytes i
public static final bytelist inttohexbytelist int i
return new bytelist inttohexbytes i
public static final bytelist inttohexbytelist int i  boolean upper
return new bytelist inttohexbytes i  upper
public static final byte inttobytearray int i  int radix  boolean upper
string s   integer tostring i  radix
s   upper ? s touppercase     s tolowercase
return bytelist plain s
public static final byte inttocharbytes int i
return bytelist plain integer tostring i
public static final byte longtobinarybytes long i
return bytelist plain long tobinarystring i
public static final byte longtooctalbytes long i
return bytelist plain long tooctalstring i
public static final byte longtohexbytes long i
return bytelist plain long tohexstring i  tolowercase
public static final byte longtohexbytes long i  boolean upper
string s   long tohexstring i
s   upper ? s touppercase     s tolowercase
return bytelist plain s
public static final bytelist longtobinarybytelist long i
return new bytelist longtobinarybytes i
public static final bytelist longtooctalbytelist long i
return new bytelist longtooctalbytes i
public static final bytelist longtohexbytelist long i
return new bytelist longtohexbytes i
public static final bytelist longtohexbytelist long i  boolean upper
return new bytelist longtohexbytes i  upper
public static final byte longtobytearray long i  int radix  boolean upper
string s   long tostring i  radix
s   upper ? s touppercase     s tolowercase
return bytelist plain s
public static final byte longtocharbytes long i
return bytelist plain long tostring i
public static final bytelist longtobytelist long i
return new bytelist bytelist plain long tostring i    false
public static final bytelist longtobytelist long i  int radix
return new bytelist bytelist plain long tostring i  radix    false
public static final byte twoscomplementtobinarybytes byte in
return twoscomplementtounsignedbytes in  1  false
public static final byte twoscomplementtooctalbytes byte in
return twoscomplementtounsignedbytes in  3  false
public static final byte twoscomplementtohexbytes byte in  boolean upper
return twoscomplementtounsignedbytes in  4  upper
private static final byte lower_digits
private static final byte upper_digits
public static final byte twoscomplementtounsignedbytes byte in  int shift  boolean upper
if  shift < 1    shift > 4
throw new illegalargumentexception
int ilen   in length
int olen    ilen   8   shift   1     shift
byte out   new byte
int mask    1 << shift    1
byte digits   upper ? upper_digits   lower_digits
int bitbuf   0
int bitcnt   0
for int i   ilen  o   olen    o >  0
if bitcnt < shift
bitbuf      int in    int 0xff  << bitcnt
bitcnt    8
out   digits
bitbuf >>  shift
bitcnt    shift
return out
/** rb_cstr_to_inum
*
*/
public static rubyinteger bytelisttoinum ruby runtime  bytelist str  int base  boolean badcheck
return new convertbytes runtime  str  base  badcheck  bytelisttoinum
public static rubyinteger bytelisttoinum19 ruby runtime  bytelist str  int base  boolean badcheck
return new convertbytes runtime  str  base  badcheck  true  bytelisttoinum
private final static byte conv_digit   new byte
private final static boolean digit   new boolean
private final static boolean space   new boolean
private final static boolean spaceorunderscore   new boolean
static
arrays fill conv_digit   byte  1
arrays fill digit  false
for char c      c <     c
conv_digit    byte  c
digit   true
for char c      c <     c
conv_digit    byte  c       10
for char c      c <     c
conv_digit    byte  c       10
arrays fill space  false
space   true
space   true
space   true      v
space   true
space   true
space   true
arrays fill spaceorunderscore  false
spaceorunderscore   true
spaceorunderscore   true
spaceorunderscore   true      v
spaceorunderscore   true
spaceorunderscore   true
spaceorunderscore   true
spaceorunderscore   true
/** conv_digit
*
*/
private byte convertdigit byte c
if c < 0
return  1
return conv_digit
/** isspace
*
*/
private boolean isspace int str
byte c
if str    end     c   data  < 0
return false
return space
/** isdigit
*
*/
private boolean isdigit byte buf  int str
byte c
if str    buf length     c   buf  < 0
return false
return digit
/** isspace || *str == '_'
*
*/
private boolean isspaceorunderscore int str
byte c
if str    end     c   data  < 0
return false
return spaceorunderscore
private boolean getsign
//system.err.println("getsign()");
boolean sign   true
if str < end
if data
str
else if data
str
sign   false
//system.err.println(" getsign/" + sign);
return sign
private void ignoreleadingwhitespace
if badcheck    is19
while isspace str
str
else
while isspaceorunderscore str
str
private void figureoutbase
//system.err.println("figureoutbase()/base=" + base);
if base <  0
if str < end    data
if str   1 < end
switch data
case
case
base   16
break
case
case
base   2
break
case
case
base   8
break
case
case
base   10
break
default
base   8
else
base   8
else if base <  1
base    base
else
base   10
//system.err.println(" figureoutbase/base=" + base);
private int calculatelength
int len   0
byte second     str 1 < end     data       ? data    byte 0
//system.err.println("calculatelength()/str=" + str);
switch base
case 2
len   1
if second         second
str  2
break
case 3
len   2
break
case 8
if second         second
str  2
case 4  case 5  case 6  case 7
len   3
break
case 10
if second         second
str  2
case 9  case 11  case 12
case 13  case 14  case 15
len   4
break
case 16
len   4
if second         second
str  2
break
default
if base < 2    36 < base
throw runtime newargumenterror     base
if base <  32
len   5
else
len   6
break
//system.err.println(" calculatelength()/str=" + str);
return len
private void squeezezeroes
byte c
if str < end    data
str
int us   0
while  str < end       c   data          c
if c
if   us >  2
break
else
us    0
str
if str    end    isspace str
str
private long stringtolong int nptr  int endptr  int base
//system.err.println("stringtolong(" + nptr + ", " + base + ")");
if base < 0    base    1    base > 36
return 0
int save   nptr
int s   nptr
boolean overflow   false
while isspace s
s
if s    end
boolean negative   false
if data
negative   true
s
else if data
negative   false
s
save   s
byte c
long i   0
final long cutoff   long max_value    long base
final long cutlim   long max_value %  long base
while s < end
//system.err.println(" stringtolong/reading c=" + data[s]);
c   convertdigit data
//system.err.println(" stringtolong/converted c=" + c);
if c     1    c >  base
break
s
if i > cutoff     i    cutoff    c > cutlim
overflow   true
else
i    base
i    c
if s    save
if endptr    null
endptr   s
if overflow
throw new erange negative ? erange kind underflow   erange kind overflow
if negative
return  i
else
return i
if endptr    null
if save   nptr >  2     data         data          data
endptr   save 1
else
endptr   nptr
return 0
public rubyinteger bytelisttoinum
if _str    null
if badcheck
invalidstring
return runtime newfixnum 0
ignoreleadingwhitespace
boolean sign   getsign
if str < end
if data         data
if badcheck
invalidstring
return runtime newfixnum 0
figureoutbase
int len   calculatelength
squeezezeroes
byte c   0
if str < end
c   data
c   convertdigit c
if c < 0    c >  base
if badcheck
invalidstring
return runtime newfixnum 0
len     end str
//system.err.println(" main/len=" + len);
if len < long size 1
int endplace   new int str
long val   stringtolong str  endplace  base
//system.err.println(" stringtolong=" + val);
if endplace < end    data]
return bigparse len  sign
if badcheck
if endplace    str
invalidstring        no number
while isspace endplace
endplace
if endplace < end
invalidstring        trailing garbage
if sign
return runtime newfixnum val
else
return runtime newfixnum  val
return bigparse len  sign
private rubyinteger bigparse int len  boolean sign
if badcheck    str < end    data
invalidstring
char result   new char
int resultindex   0
byte nondigit    1
while str < end
byte c   data
byte cx   c
if c
if nondigit     1
if badcheck
invalidstring
break
nondigit   c
continue
else if  c   convertdigit c   < 0
break
if c >  base
break
nondigit    1
//system.err.println("adding char: " + (char)cx + " with number: " + cx);
result    char cx
biginteger z
if resultindex    0
z   biginteger zero
else
z   new biginteger new string result  0  resultindex   base
if  sign
z   z negate
if badcheck
if _str getbegin     1 < str    data
invalidstring
while str < end    isspace str
str
if str < end
invalidstring
return new rubybignum runtime  z
public static class erange extends runtimeexception
public static enum kind  overflow  underflow
private kind kind
public erange
super
public erange kind kind
super
this kind   kind
public kind getkind
return kind
/** rb_invalid_str
*
*/
private void invalidstring string type
irubyobject s   rubystring newstring runtime  _str  inspect
throw runtime newargumenterror     type       s