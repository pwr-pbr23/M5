/*
* to change this template, choose tools | templates
* and open the template in the editor.
*/
package org jruby java codegen
import java io fileoutputstream
import java io ioexception
import java lang reflect method
import java util arraylist
import java util hashmap
import java util hashset
import java util list
import java util map
import java util set
import org jruby ruby
import org jruby rubybasicobject
import org jruby rubyclass
import org jruby rubymodule
import org jruby ast executable runtimecache
import org jruby compiler impl skinnymethodadapter
import org jruby compiler util basicobjectstubgenerator
import org jruby internal runtime methods dynamicmethod
import org jruby internal runtime methods undefinedmethod
import org jruby javasupport javautil
import org jruby runtime block
import org jruby runtime threadcontext
import org jruby runtime builtin irubyobject
import org jruby runtime callsite cacheentry
import static org jruby util codegenutils
import org objectweb asm classwriter
import org objectweb asm type
import static org objectweb asm opcodes
/**
*
* @author headius
*/
public class realclassgenerator
private static final boolean debug   false
private static map<string  list<method>> buildsimpletoallmap class interfaces  string supertypenames  throws securityexception
map<string  list<method>> simpletoall   new hashmap<string  list<method>>
for  int i   0  i < interfaces length  i
supertypenames   p interfaces
for  method method   interfaces getmethods
list<method> methods   simpletoall get method getname
if  methods    null
simpletoall put method getname    methods   new arraylist<method>
methods add method
return simpletoall
public static class createoldstyleimplclass class supertypes  rubyclass rubyclass  ruby ruby  string name
string supertypenames   new string
map<string  list<method>> simpletoall   buildsimpletoallmap supertypes  supertypenames
class newclass   defineoldstyleimplclass ruby  name  supertypenames  simpletoall
return newclass
public static class createrealimplclass class superclass  class interfaces  rubyclass rubyclass  ruby ruby  string name
string supertypenames   new string
map<string  list<method>> simpletoall   buildsimpletoallmap interfaces  supertypenames
class newclass   definerealimplclass ruby  name  superclass  supertypenames  simpletoall
return newclass
/**
* this variation on defineimplclass uses all the classic type coercion logic
* for passing args and returning results.
*
* @param ruby
* @param name
* @param supertypenames
* @param simpletoall
* @return
*/
public static class defineoldstyleimplclass ruby ruby  string name  string supertypenames  map<string  list<method>> simpletoall
classwriter cw   new classwriter classwriter compute_maxs
string pathname   name replace
// construct the class, implementing all supertypes
cw visit v1_5  acc_public   acc_super  pathname  null  p object class   supertypenames
cw visitsource pathname      null
// fields needed for dispatch and such
cw visitfield acc_static   acc_final   acc_private     ci runtimecache class   null  null  visitend
cw visitfield acc_private   acc_final     ci irubyobject class   null  null  visitend
// create static init
skinnymethodadapter clinitmethod   new skinnymethodadapter cw visitmethod acc_public   acc_static     sig void class   null  null
// create constructor
skinnymethodadapter initmethod   new skinnymethodadapter cw visitmethod acc_public     sig void class  irubyobject class   null  null
initmethod aload 0
initmethod invokespecial p object class      sig void class
// store the wrapper
initmethod aload 0
initmethod aload 1
initmethod putfield pathname     ci irubyobject class
// end constructor
initmethod voidreturn
initmethod end
int cachesize   0
// for each simple method name, implement the complex methods, calling the simple version
for  map entry<string  list<method>> entry   simpletoall entryset
string simplename   entry getkey
set<string> nameset   javautil getrubynamesforjavaname simplename  entry getvalue
set<string> implementednames   new hashset<string>
for  method method   entry getvalue
class paramtypes   method getparametertypes
class returntype   method getreturntype
string fullname   simplename   prettyparams paramtypes
if  implementednames contains fullname   continue
implementednames add fullname
// indices for temp values
int baseindex   1
for  class paramtype   paramtypes
if  paramtype    double class    paramtype    long class
baseindex    2
else
baseindex    1
int selfindex   baseindex
int rubyindex   selfindex   1
skinnymethodadapter mv   new skinnymethodadapter
cw visitmethod acc_public  simplename  sig returntype  paramtypes   null  null
mv start
mv line 1
// todo: this code should really check if a ruby equals method is implemented or not.
if simplename equals       paramtypes length    1    paramtypes    object class    returntype    boolean type
mv line 2
mv aload 0
mv aload 1
mv invokespecial p object class      sig boolean type  params object class
mv ireturn
else if simplename equals       paramtypes length    0    returntype    integer type
mv line 3
mv aload 0
mv invokespecial p object class      sig integer type
mv ireturn
else if simplename equals       paramtypes length    0    returntype    string class
mv line 4
mv aload 0
mv invokespecial p object class      sig string class
mv areturn
else if  simplename equals       paramtypes length    0    returntype    irubyobject class
mv aload 0
mv getfield pathname     ci irubyobject class
mv areturn
else
mv line 5
int cacheindex   cachesize
// prepare temp locals
mv aload 0
mv getfield pathname     ci irubyobject class
mv astore selfindex
mv aload selfindex
mv invokeinterface p irubyobject class      sig ruby class
mv astore rubyindex
// get method from cache
mv getstatic pathname     ci runtimecache class
mv aload selfindex
mv ldc cacheindex
for  string eachname   nameset
mv ldc eachname
mv invokevirtual p runtimecache class
sig dynamicmethod class  params irubyobject class  int class  string class  nameset size
// get current context
mv aload rubyindex
mv invokevirtual p ruby class      sig threadcontext class
// load self, class, and name
mv aloadmany selfindex  selfindex
mv invokeinterface p irubyobject class      sig rubyclass class
mv ldc simplename
// coerce arguments
coerceargumentstoruby mv  paramtypes  rubyindex
// load null block
mv getstatic p block class      ci block class
// invoke method
mv line 13
mv invokevirtual p dynamicmethod class      sig irubyobject class  threadcontext class  irubyobject class  rubymodule class  string class  irubyobject class  block class
coerceresultandreturn mv  returntype
mv end
// end setup method
clinitmethod newobj p runtimecache class
clinitmethod dup
clinitmethod invokespecial p runtimecache class      sig void class
clinitmethod dup
clinitmethod ldc cachesize
clinitmethod invokevirtual p runtimecache class      sig void class  int class
clinitmethod putstatic pathname     ci runtimecache class
clinitmethod voidreturn
clinitmethod end
// end class
cw visitend
// create the class
byte bytes   cw tobytearray
class newclass
synchronized  ruby getjrubyclassloader
// try to load the specified name; only if that fails, try to define the class
try
newclass   ruby getjrubyclassloader   loadclass name
catch  classnotfoundexception cnfe
newclass   ruby getjrubyclassloader   defineclass name  cw tobytearray
if  debug
fileoutputstream fos   null
try
fos   new fileoutputstream name
fos write bytes
catch  ioexception ioe
ioe printstacktrace
finally
try  fos close     catch  exception e
return newclass
/**
* this variation on defineimplclass uses all the classic type coercion logic
* for passing args and returning results.
*
* @param ruby
* @param name
* @param supertypenames
* @param simpletoall
* @return
*/
public static class definerealimplclass ruby ruby  string name  class superclass  string supertypenames  map<string  list<method>> simpletoall
classwriter cw   new classwriter classwriter compute_maxs
string pathname   name replace
boolean isrubyhierarchy   rubybasicobject class isassignablefrom superclass
// construct the class, implementing all supertypes
if  isrubyhierarchy
// ruby hierarchy...just extend it
cw visit v1_5  acc_public   acc_super  pathname  null  p superclass   supertypenames
else
// non-ruby hierarchy; add irubyobject
string plusirubyobject   new string
plusirubyobject   p irubyobject class
system arraycopy supertypenames  0  plusirubyobject  1  supertypenames length
cw visit v1_5  acc_public   acc_super  pathname  null  p superclass   plusirubyobject
cw visitsource pathname      null
// fields needed for dispatch and such
cw visitfield acc_static   acc_final   acc_private     ci runtimecache class   null  null  visitend
// create static init
skinnymethodadapter clinitmethod   new skinnymethodadapter cw visitmethod acc_public   acc_static     sig void class   null  null
// create constructor
skinnymethodadapter initmethod   new skinnymethodadapter cw visitmethod acc_public     sig void class  ruby class  rubyclass class   null  null
if  isrubyhierarchy
// superclass is in the ruby object hierarchy; invoke typical ruby superclass constructor
initmethod aloadmany 0  1  2
initmethod invokespecial p superclass      sig void class  ruby class  rubyclass class
else
// superclass is not in ruby hierarchy; store objects and call no-arg super constructor
cw visitfield acc_final   acc_private     ci ruby class   null  null  visitend
cw visitfield acc_final   acc_private     ci rubyclass class   null  null  visitend
initmethod aloadmany 0  1
initmethod putfield pathname     ci ruby class
initmethod aloadmany 0  2
initmethod putfield pathname     ci rubyclass class
// only no-arg super constructor supported right now
initmethod aload 0
initmethod invokespecial p superclass      sig void class
initmethod voidreturn
initmethod end
if  isrubyhierarchy
// override tojava
skinnymethodadapter tojavamethod   new skinnymethodadapter cw visitmethod acc_public     sig object class  class class   null  null
tojavamethod aload 0
tojavamethod areturn
tojavamethod end
else
// decorate with stubbed irubyobject methods
basicobjectstubgenerator addbasicobjectstubstoclass cw
// add getruntime and getmetaclass impls based on captured fields
skinnymethodadapter getruntimemethod   new skinnymethodadapter cw visitmethod acc_public     sig ruby class   null  null
getruntimemethod aload 0
getruntimemethod getfield pathname     ci ruby class
getruntimemethod areturn
getruntimemethod end
skinnymethodadapter getmetaclassmethod   new skinnymethodadapter cw visitmethod acc_public     sig rubyclass class   null  null
getmetaclassmethod aload 0
getmetaclassmethod getfield pathname     ci rubyclass class
getmetaclassmethod areturn
getmetaclassmethod end
int cachesize   0
// for each simple method name, implement the complex methods, calling the simple version
for  map entry<string  list<method>> entry   simpletoall entryset
string simplename   entry getkey
set<string> nameset   javautil getrubynamesforjavaname simplename  entry getvalue
set<string> implementednames   new hashset<string>
for  method method   entry getvalue
class paramtypes   method getparametertypes
class returntype   method getreturntype
string fullname   simplename   prettyparams paramtypes
if  implementednames contains fullname   continue
implementednames add fullname
// indices for temp values
int baseindex   1
for  class paramtype   paramtypes
if  paramtype    double class    paramtype    long class
baseindex    2
else
baseindex    1
int rubyindex   baseindex   1
skinnymethodadapter mv   new skinnymethodadapter
cw visitmethod acc_public  simplename  sig returntype  paramtypes   null  null
mv start
mv line 1
// todo: this code should really check if a ruby equals method is implemented or not.
if simplename equals       paramtypes length    1    paramtypes    object class    returntype    boolean type
mv line 2
mv aload 0
mv aload 1
mv invokespecial p object class      sig boolean type  params object class
mv ireturn
else if simplename equals       paramtypes length    0    returntype    integer type
mv line 3
mv aload 0
mv invokespecial p object class      sig integer type
mv ireturn
else if simplename equals       paramtypes length    0    returntype    string class
mv line 4
mv aload 0
mv invokespecial p object class      sig string class
mv areturn
else
mv line 5
int cacheindex   cachesize
// prepare temp locals
mv aload 0
mv invokeinterface p irubyobject class      sig ruby class
mv astore rubyindex
// get method from cache
mv getstatic pathname     ci runtimecache class
mv aload 0
mv ldc cacheindex
for  string eachname   nameset
mv ldc eachname
mv invokevirtual p runtimecache class
sig dynamicmethod class  params irubyobject class  int class  string class  nameset size
// get current context
mv aload rubyindex
mv invokevirtual p ruby class      sig threadcontext class
// load self, class, and name
mv aloadmany 0  0
mv invokeinterface p irubyobject class      sig rubyclass class
mv ldc simplename
// coerce arguments
coerceargumentstoruby mv  paramtypes  rubyindex
// load null block
mv getstatic p block class      ci block class
// invoke method
mv line 13
mv invokevirtual p dynamicmethod class      sig irubyobject class  threadcontext class  irubyobject class  rubymodule class  string class  irubyobject class  block class
coerceresultandreturn mv  returntype
mv end
// end setup method
clinitmethod newobj p runtimecache class
clinitmethod dup
clinitmethod invokespecial p runtimecache class      sig void class
clinitmethod dup
clinitmethod ldc cachesize
clinitmethod invokevirtual p runtimecache class      sig void class  int class
clinitmethod putstatic pathname     ci runtimecache class
clinitmethod voidreturn
clinitmethod end
// end class
cw visitend
// create the class
byte bytes   cw tobytearray
class newclass
synchronized  ruby getjrubyclassloader
// try to load the specified name; only if that fails, try to define the class
try
newclass   ruby getjrubyclassloader   loadclass name
catch  classnotfoundexception cnfe
newclass   ruby getjrubyclassloader   defineclass name  cw tobytearray
if  debug
fileoutputstream fos   null
try
fos   new fileoutputstream name
fos write bytes
catch  ioexception ioe
ioe printstacktrace
finally
try  fos close     catch  exception e
return newclass
public static void coerceargumentstoruby skinnymethodadapter mv  class paramtypes  int rubyindex
// load arguments into irubyobject[] for dispatch
if  paramtypes length    0
mv pushint paramtypes length
mv anewarray p irubyobject class
// todo: make this do specific-arity calling
for  int i   0  argindex   1  i < paramtypes length  i
class paramtype   paramtypes
mv dup
mv pushint i
// convert to irubyobject
mv aload rubyindex
if  paramtypes isprimitive
if  paramtype    byte class    paramtype    short class    paramtype    char class    paramtype    int class
mv iload argindex
mv invokestatic p javautil class      sig irubyobject class  ruby class  int class
else if  paramtype    long class
mv lload argindex
argindex    2     up two slots  for long's two halves
mv invokestatic p javautil class      sig irubyobject class  ruby class  long class
else if  paramtype    float class
mv fload argindex
mv invokestatic p javautil class      sig irubyobject class  ruby class  float class
else if  paramtype    double class
mv dload argindex
argindex    2     up two slots  for long's two halves
mv invokestatic p javautil class      sig irubyobject class  ruby class  double class
else if  paramtype    boolean class
mv iload argindex
mv invokestatic p javautil class      sig irubyobject class  ruby class  boolean class
else
mv aload argindex
mv invokestatic p javautil class      sig irubyobject class  ruby class  object class
mv aastore
else
mv getstatic p irubyobject class      ci irubyobject class
public static void coerceresultandreturn skinnymethodadapter mv  class returntype
// if we expect a return value, unwrap it
if  returntype    void class
// todo: move the bulk of this logic to utility methods
if  returntype isprimitive
if  returntype    boolean class
mv getstatic p boolean class      ci class class
mv invokeinterface p irubyobject class      sig object class  class class
mv checkcast p boolean class
mv invokevirtual p boolean class      sig boolean class
mv ireturn
else
mv getstatic p getboxtype returntype       ci class class
mv invokeinterface p irubyobject class      sig object class  class class
if  returntype    byte class
mv checkcast p number class
mv invokevirtual p number class      sig byte class
mv ireturn
else if  returntype    short class
mv checkcast p number class
mv invokevirtual p number class      sig short class
mv ireturn
else if  returntype    char class
mv checkcast p character class
mv invokevirtual p character class      sig char class
mv ireturn
else if  returntype    int class
mv checkcast p number class
mv invokevirtual p number class      sig int class
mv ireturn
else if  returntype    long class
mv checkcast p number class
mv invokevirtual p number class      sig long class
mv lreturn
else if  returntype    float class
mv checkcast p number class
mv invokevirtual p number class      sig float class
mv freturn
else if  returntype    double class
mv checkcast p number class
mv invokevirtual p number class      sig double class
mv dreturn
else
mv ldc type gettype returntype
mv invokeinterface p irubyobject class      sig object class  class class
mv checkcast p returntype
mv areturn
else
mv voidreturn
public static boolean iscacheok cacheentry entry  irubyobject self
return cacheentry typeok entry  self getmetaclass       entry method    undefinedmethod instance