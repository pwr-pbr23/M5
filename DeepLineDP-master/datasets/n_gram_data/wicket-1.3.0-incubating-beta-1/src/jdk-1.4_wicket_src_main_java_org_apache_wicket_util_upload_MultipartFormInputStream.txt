/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket util upload
import java io bytearrayoutputstream
import java io ioexception
import java io inputstream
import java io outputstream
import java io unsupportedencodingexception
/**
* <p>
* low level api for processing file uploads.
*
* <p>
* this class can be used to process data streams conforming to mime 'multipart'
* format as defined in <a href="http://www.ietf.org/rfc/rfc1867.txt">rfc 1867</a>.
* arbitrarily large amounts of data in the stream can be processed under
* constant memory usage.
*
* <p>
* the format of the stream is defined in the following way:<br>
*
* <code>
*   multipart-body := preamble 1*encapsulation close-delimiter epilogue<br>
*   encapsulation := delimiter body crlf<br>
*   delimiter := "--" boundary crlf<br>
*   close-delimiter := "--" boudary "--"<br>
*   preamble := &lt;ignore&gt;<br>
*   epilogue := &lt;ignore&gt;<br>
*   body := header-part crlf body-part<br>
*   header-part := 1*header crlf<br>
*   header := header-name ":" header-value<br>
*   header-name := &lt;printable ascii characters except ":"&gt;<br>
*   header-value := &lt;any ascii characters except cr & lf&gt;<br>
*   body-data := &lt;arbitrary data&gt;<br>
* </code>
*
* <p>
* note that body-data can contain another mulipart entity. there is limited
* support for single pass processing of such nested streams. the nested stream
* is <strong>required</strong> to have a boundary token of the same length as
* the parent stream (see {@link #setboundary(byte[])}).
*
* <p>
* here is an exaple of usage of this class.<br>
*
* <pre>
*      try {
*          multipartstream multipartstream = new multipartstream(input,
*                                                                boundary);
*          boolean nextpart = malitpartstream.skippreamble();
*          outputstream output;
*          while(nextpart) {
*              header = chunks.readheader();
*              // process headers
*              // create some output stream
*              multipartstream.readbodypart(output);
*              nextpart = multipartstream.readboundary();
*          }
*      } catch(multipartstream.malformedstreamexception e) {
*            // the stream failed to follow required syntax
*      } catch(ioexception) {
*            // a read or write error occurred
*      }
*
* </pre>
*
* @author <a href="mailto:rafal.krzewski@e-point.pl">rafal krzewski</a>
* @author <a href="mailto:martinc@apache.org">martin cooper</a>
* @author sean c. sullivan
*
* @version $id: multipartforminputstream.java,v 1.2 2006/02/05 18:41:32
*          jonathanlocke exp $
*/
public class multipartforminputstream
// ----------------------------------------------------- manifest constants
/**
* the carriage return ascii character value.
*/
public static final byte cr   0x0d
/**
* the line feed ascii character value.
*/
public static final byte lf   0x0a
/**
* the dash (-) ascii character value.
*/
public static final byte dash   0x2d
/**
* the maximum length of <code>header-part</code> that will be processed
* (10 kilobytes = 10240 bytes.).
*/
public static final int header_part_size_max   10240
/**
* the default length of the buffer used for processing a request.
*/
protected static final int default_bufsize   4096
/**
* a byte sequence that marks the end of <code>header-part</code> (<code>crlfcrlf</code>).
*/
protected static final byte header_separator     cr  lf  cr  lf
/**
* a byte sequence that that follows a delimiter that will be followed by an
* encapsulation (<code>crlf</code>).
*/
protected static final byte field_separator     cr  lf
/**
* a byte sequence that that follows a delimiter of the last encapsulation
* in the stream (<code>--</code>).
*/
protected static final byte stream_terminator     dash  dash
// ----------------------------------------------------------- data members
/**
* the input stream from which data is read.
*/
private inputstream input
/**
* the length of the boundary token plus the leading <code>crlf--</code>.
*/
private int boundarylength
/**
* the amount of data, in bytes, that must be kept in the buffer in order to
* detect delimiters reliably.
*/
private int keepregion
/**
* the byte sequence that partitions the stream.
*/
private byte boundary
/**
* the length of the buffer used for processing the request.
*/
private int bufsize
/**
* the buffer used for processing the request.
*/
private byte buffer
/**
* the index of first valid character in the buffer. <br>
* 0 <= head < bufsize
*/
private int head
/**
* the index of last valid characer in the buffer + 1. <br>
* 0 <= tail <= bufsize
*/
private int tail
/**
* the content encoding to use when reading headers.
*/
private string headerencoding
// ----------------------------------------------------------- constructors
/**
* default constructor.
*
* @see #multipartforminputstream(inputstream, byte[], int)
* @see #multipartforminputstream(inputstream, byte[])
*
*/
public multipartforminputstream
/**
* <p>
* constructs a <code>multipartstream</code> with a custom size buffer.
*
* <p>
* note that the buffer must be at least big enough to contain the boundary
* string, plus 4 characters for cr/lf and double dash, plus at least one
* byte of data. too small a buffer size setting will degrade performance.
*
* @param input
*            the <code>inputstream</code> to serve as a data source.
* @param boundary
*            the token used for dividing the stream into
*            <code>encapsulations</code>.
* @param bufsize
*            the size of the buffer to be used, in bytes.
*
*
* @see #multipartforminputstream()
* @see #multipartforminputstream(inputstream, byte[])
*
*/
public multipartforminputstream inputstream input  byte boundary  int bufsize
this input   input
this bufsize   bufsize
this buffer   new byte
// we prepend cr/lf to the boundary to chop trailng cr/lf from
// body-data tokens.
this boundary   new byte
this boundarylength   boundary length   4
this keepregion   boundary length   3
this boundary   cr
this boundary   lf
this boundary   dash
this boundary   dash
system arraycopy boundary  0  this boundary  4  boundary length
head   0
tail   0
/**
* <p>
* constructs a <code>multipartstream</code> with a default size buffer.
*
* @param input
*            the <code>inputstream</code> to serve as a data source.
* @param boundary
*            the token used for dividing the stream into
*            <code>encapsulations</code>.
*
* @see #multipartforminputstream()
* @see #multipartforminputstream(inputstream, byte[], int)
*
*/
public multipartforminputstream inputstream input  byte boundary
this input  boundary  default_bufsize
// --------------------------------------------------------- public methods
/**
* retrieves the character encoding used when reading the headers of an
* individual part. when not specified, or <code>null</code>, the
* platform default encoding is used.
*
*
* @return the encoding used to read part headers.
*/
public string getheaderencoding
return headerencoding
/**
* specifies the character encoding to be used when reading the headers of
* individual parts. when not specified, or <code>null</code>, the
* platform default encoding is used.
*
* @param encoding
*            the encoding used to read part headers.
*/
public void setheaderencoding string encoding
headerencoding   encoding
/**
* reads a byte from the <code>buffer</code>, and refills it as
* necessary.
*
* @return the next byte from the input stream.
*
* @exception ioexception
*                if there is no more data available.
*/
public byte readbyte   throws ioexception
// buffer depleted ?
if  head    tail
head   0
// refill.
tail   input read buffer  head  bufsize
if  tail     1
// no more data available.
throw new ioexception
return buffer
/**
* skips a <code>boundary</code> token, and checks whether more
* <code>encapsulations</code> are contained in the stream.
*
* @return <code>true</code> if there are more encapsulations in this
*         stream; <code>false</code> otherwise.
*
* @exception malformedstreamexception
*                if the stream ends unexpecetedly or fails to follow
*                required syntax.
*/
public boolean readboundary   throws malformedstreamexception
byte marker   new byte
boolean nextchunk   false
head    boundarylength
try
marker   readbyte
if  marker    lf
// work around ie5 mac bug with input type=image.
// because the boundary delimiter, not including the trailing
// crlf, must not appear within any file (rfc 2046, section
// 5.1.1), we know the missing cr is due to a buggy browser
// rather than a file containing something similar to a
// boundary.
return true
marker   readbyte
if  arrayequals marker  stream_terminator  2
nextchunk   false
else if  arrayequals marker  field_separator  2
nextchunk   true
else
throw new malformedstreamexception
catch  ioexception e
throw new malformedstreamexception
return nextchunk
/**
* <p>
* changes the boundary token used for partitioning the stream.
*
* <p>
* this method allows single pass processing of nested multipart streams.
*
* <p>
* the boundary token of the nested stream is <code>required</code> to be
* of the same length as the boundary token in parent stream.
*
* <p>
* restoring the parent stream boundary token after processing of a nested
* stream is left to the application.
*
* @param boundary
*            the boundary to be used for parsing of the nested stream.
*
* @exception illegalboundaryexception
*                if the <code>boundary</code> has a different length than
*                the one being currently parsed.
*/
public void setboundary byte boundary  throws illegalboundaryexception
if  boundary length    boundarylength   4
throw new illegalboundaryexception
system arraycopy boundary  0  this boundary  4  boundary length
/**
* <p>
* reads the <code>header-part</code> of the current
* <code>encapsulation</code>.
* <p>
* headers are returned verbatim to the input stream, including the trailing
* <code>crlf</code> marker. parsing is left to the application.
*
* @param maxsize
*            the maximum amount to read before giving up
*
* @return the <code>header-part</code> of the current encapsulation.
*
* @exception malformedstreamexception
*                if the stream ends unexpecetedly.
*/
public string readheaders final int maxsize  throws malformedstreamexception
int i   0
byte b   new byte
// to support multi-byte characters
bytearrayoutputstream baos   new bytearrayoutputstream
int sizemax   header_part_size_max
int size   0
while  i < 4
try
b   readbyte
catch  ioexception e
throw new malformedstreamexception
size
if  size > maxsize
throw new malformedstreamexception     maxsize
if  b    header_separator
i
else
i   0
if  size <  sizemax
baos write b
string headers   null
if  headerencoding    null
try
headers   baos tostring headerencoding
catch  unsupportedencodingexception e
// fall back to platform default if specified encoding is not
// supported.
headers   baos tostring
else
headers   baos tostring
return headers
/**
* <p>
* reads <code>body-data</code> from the current
* <code>encapsulation</code> and writes its contents into the output
* <code>stream</code>.
*
* <p>
* arbitrary large amounts of data can be processed by this method using a
* constant size buffer. (see {@link
* #multipartforminputstream(inputstream,byte[],int) constructor}).
*
* @param output
*            the <code>stream</code> to write data into.
*
* @return the amount of data written.
*
* @exception malformedstreamexception
*                if the stream ends unexpectedly.
* @exception ioexception
*                if an i/o error occurs.
*/
public int readbodydata outputstream output  throws malformedstreamexception  ioexception
boolean done   false
int pad
int pos
int bytesread
int total   0
while   done
// is boundary token present somewere in the buffer?
pos   findseparator
if  pos     1
// write the rest of the data before the boundary.
output write buffer  head  pos   head
total    pos   head
head   pos
done   true
else
// determine how much data should be kept in the
// buffer.
if  tail   head > keepregion
pad   keepregion
else
pad   tail   head
// write out the data belonging to the body-data.
output write buffer  head  tail   head   pad
// move the data to the beginning of the buffer.
total    tail   head   pad
system arraycopy buffer  tail   pad  buffer  0  pad
// refill buffer with new data.
head   0
bytesread   input read buffer  pad  bufsize   pad
// [pprrrrrrr]
if  bytesread     1
tail   pad   bytesread
else
// the last pad amount is left in the buffer.
// boundary can't be in there so write out the
// data you have and signal an error condition.
output write buffer  0  pad
output flush
total    pad
throw new malformedstreamexception
output flush
return total
/**
* <p>
* reads <code>body-data</code> from the current
* <code>encapsulation</code> and discards it.
*
* <p>
* use this method to skip encapsulations you don't need or don't
* understand.
*
* @return the amount of data discarded.
*
* @exception malformedstreamexception
*                if the stream ends unexpectedly.
* @exception ioexception
*                if an i/o error occurs.
*/
public int discardbodydata   throws malformedstreamexception  ioexception
boolean done   false
int pad
int pos
int bytesread
int total   0
while   done
// is boundary token present somewere in the buffer?
pos   findseparator
if  pos     1
// write the rest of the data before the boundary.
total    pos   head
head   pos
done   true
else
// determine how much data should be kept in the
// buffer.
if  tail   head > keepregion
pad   keepregion
else
pad   tail   head
total    tail   head   pad
// move the data to the beginning of the buffer.
system arraycopy buffer  tail   pad  buffer  0  pad
// refill buffer with new data.
head   0
bytesread   input read buffer  pad  bufsize   pad
// [pprrrrrrr]
if  bytesread     1
tail   pad   bytesread
else
// the last pad amount is left in the buffer.
// boundary can't be in there so signal an error
// condition.
total    pad
throw new malformedstreamexception
return total
/**
* finds the beginning of the first <code>encapsulation</code>.
*
* @return <code>true</code> if an <code>encapsulation</code> was found
*         in the stream.
*
* @exception ioexception
*                if an i/o error occurs.
*/
public boolean skippreamble   throws ioexception
// first delimiter may be not preceeded with a crlf.
system arraycopy boundary  2  boundary  0  boundary length   2
boundarylength   boundary length   2
try
// discard all data up to the delimiter.
discardbodydata
// read boundary - if succeded, the stream contains an
// encapsulation.
return readboundary
catch  malformedstreamexception e
return false
finally
// restore delimiter.
system arraycopy boundary  0  boundary  2  boundary length   2
boundarylength   boundary length
boundary   cr
boundary   lf
/**
* compares <code>count</code> first bytes in the arrays <code>a</code>
* and <code>b</code>.
*
* @param a
*            the first array to compare.
* @param b
*            the second array to compare.
* @param count
*            how many bytes should be compared.
*
* @return <code>true</code> if <code>count</code> first bytes in arrays
*         <code>a</code> and <code>b</code> are equal.
*/
public static boolean arrayequals byte a  byte b  int count
for  int i   0  i < count  i
if  a    b
return false
return true
/**
* searches for a byte of specified value in the <code>buffer</code>,
* starting at the specified <code>position</code>.
*
* @param value
*            the value to find.
* @param pos
*            the starting position for searching.
*
* @return the position of byte found, counting from beginning of the
*         <code>buffer</code>, or <code>-1</code> if not found.
*/
protected int findbyte byte value  int pos
for  int i   pos  i < tail  i
if  buffer    value
return i
return  1
/**
* searches for the <code>boundary</code> in the <code>buffer</code>
* region delimited by <code>head</code> and <code>tail</code>.
*
* @return the position of the boundary found, counting from the beginning
*         of the <code>buffer</code>, or <code>-1</code> if not found.
*/
protected int findseparator
int first
int match   0
int maxpos   tail   boundarylength
for  first   head   first <  maxpos      match    boundarylength   first
first   findbyte boundary  first
if  first     1     first > maxpos
return  1
for  match   1  match < boundarylength  match
if  buffer    boundary
break
if  match    boundarylength
return first   1
return  1
/**
* returns a string representation of this object.
*
* @return the string representation of this object.
*/
public string tostring
stringbuffer sbtemp   new stringbuffer
sbtemp append
sbtemp append string valueof boundary
sbtemp append
sbtemp append bufsize
return sbtemp tostring
/**
* thrown to indicate that the input stream fails to follow the required
* syntax.
*/
public class malformedstreamexception extends ioexception
private static final long serialversionuid   1l
/**
* constructs a <code>malformedstreamexception</code> with no detail
* message.
*/
public malformedstreamexception
super
/**
* constructs an <code>malformedstreamexception</code> with the
* specified detail message.
*
* @param message
*            the detail message.
*/
public malformedstreamexception string message
super message
/**
* thrown upon attempt of setting an invalid boundary token.
*/
public class illegalboundaryexception extends ioexception
private static final long serialversionuid   1l
/**
* constructs an <code>illegalboundaryexception</code> with no detail
* message.
*/
public illegalboundaryexception
super
/**
* constructs an <code>illegalboundaryexception</code> with the
* specified detail message.
*
* @param message
*            the detail message.
*/
public illegalboundaryexception string message
super message
// ------------------------------------------------------ debugging methods
// these are the methods that were used to debug this stuff.
/*
* // dump data. protected void dump() { system.out.println("01234567890");
* byte[] temp = new byte[buffer.length]; for(int i=0; i<buffer.length;
* i++) { if (buffer[i] == 0x0d || buffer[i] == 0x0a) { temp[i] = 0x21; }
* else { temp[i] = buffer[i]; } } system.out.println(new string(temp)); int
* i; for (i=0; i<head; i++) system.out.print(" ");
* system.out.println("h"); for (i=0; i<tail; i++) system.out.print(" ");
* system.out.println("t"); system.out.flush(); } // main routine, for
* testing purposes only. // // @param args a string[] with the command line
* arguments. // @exception exception, a generic exception. public static
* void main( string[] args ) throws exception { file boundaryfile = new
* file("boundary.dat"); int boundarysize = (int)boundaryfile.length();
* byte[] boundary = new byte[boundarysize]; fileinputstream input = new
* fileinputstream(boundaryfile); input.read(boundary,0,boundarysize);
*
* input = new fileinputstream("multipart.dat"); multipartstream chunks =
* new multipartstream(input, boundary);
*
* int i = 0; string header; outputstream output; boolean nextchunk =
* chunks.skippreamble(); while (nextchunk) { header = chunks.readheaders();
* system.out.println("!"+header+"!"); system.out.println("wrote
* part"+i+".dat"); output = new fileoutputstream("part"+(i++)+".dat");
* chunks.readbodydata(output); nextchunk = chunks.readboundary(); } }
*
*/