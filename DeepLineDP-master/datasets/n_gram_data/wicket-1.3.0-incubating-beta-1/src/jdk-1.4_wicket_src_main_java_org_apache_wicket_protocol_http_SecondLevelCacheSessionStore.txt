/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket protocol http
import java io ioexception
import org apache wicket application
import org apache wicket component
import org apache wicket ipagemap
import org apache wicket page
import org apache wicket pagemap
import org apache wicket request
import org apache wicket session pagemap ipagemapentry
import org apache wicket version ipageversionmanager
import org apache wicket version undo change
/**
* fixme document me!
*
* @author jcompagner
*/
public class secondlevelcachesessionstore extends httpsessionstore
/**
* this interface is used by the secondlevelcachesessionstore so that pages
* can be stored to a persistent layer. implemenation should store the page
* that it gets under the id and versionnumber. so that every page version
* can be reconstructed when asked for.
*
* @see filepagestore as default implementation.
*/
public static interface ipagestore
/**
*
*/
void destroy
/**
* restores a page version from the persistent layer
*
* @param sessionid
* @param pagemap
* @param id
* @param versionnumber
* @param ajaxversionnumber
* @return the page
*/
page getpage string sessionid  string pagemap  int id  int versionnumber
int ajaxversionnumber
/**
* this method is called when the page is accessed. a ipagestore
* implemenation can block until a save of that page version is done. so
* that a specifiek page version is always restoreable.
*
* @param sessionid
* @param page
*/
void pageaccessed string sessionid  page page
/**
* removes a page from the persistent layer.
*
* @param sessionid
* @param page
*/
void removepage string sessionid  page page
/**
* stores the page to a persistent layer. the page should be stored
* under the id and the version number.
*
* @param sessionid
* @param page
*/
void storepage string sessionid  page page
/**
* the pagestore should cleanup all the pages for that sessionid.
*
* @param sessionid
*/
void unbind string sessionid
private static final class secondlevelcachepagemap extends pagemap
private static final long serialversionuid   1l
private page lastpage   null
/**
* construct.
*
* @param name
*/
private secondlevelcachepagemap string name
super name
public page get int id  int versionnumber
string sessionid   getsession   getid
if  lastpage    null    lastpage getnumericid      id
page page   lastpage getversion versionnumber
if  page    null
// ask the page store if it is ready saving the page.
getstore   pageaccessed sessionid  page
return page
if  sessionid    null
// this is really a page request for a default page. (so without
// an ajax version)
return getstore   getpage sessionid  getname    id  versionnumber  0
return null
public void put page page
if   page ispagestateless
string sessionid   getsession   getid
if  sessionid    null
if  lastpage    page    page getcurrentversionnumber      0
// we have to save a new page directly to the file store
// so that this version is also recoverable.
getstore   storepage sessionid  page
lastpage   page
dirty
public void removeentry ipagemapentry entry
string sessionid   getsession   getid
if  sessionid    null
getstore   removepage sessionid  entry getpage
private ipagestore getstore
return   secondlevelcachesessionstore application get   getsessionstore    getstore
private static final class secondlevelcachepageversionmanager implements ipageversionmanager
private static final long serialversionuid   1l
private short currentversionnumber
private short currentajaxversionnumber
private short lastajaxversionnumber
private page page
private transient boolean versionstarted
/**
* construct.
*
* @param page
*/
public secondlevelcachepageversionmanager page page
this page   page
/**
* @see org.apache.wicket.version.ipageversionmanager#beginversion(boolean)
*/
public void beginversion boolean mergeversion
// this is an hack.. when object is read in. it must ignore the
// first version bump.
if  versionstarted
return
versionstarted   true
if   mergeversion
currentversionnumber
lastajaxversionnumber   currentajaxversionnumber
currentajaxversionnumber   0
else
currentajaxversionnumber
/**
* @see org.apache.wicket.version.ipageversionmanager#componentadded(org.apache.wicket.component)
*/
public void componentadded component component
/**
* @see org.apache.wicket.version.ipageversionmanager#componentmodelchanging(org.apache.wicket.component)
*/
public void componentmodelchanging component component
/**
* @see org.apache.wicket.version.ipageversionmanager#componentremoved(org.apache.wicket.component)
*/
public void componentremoved component component
/**
* @see org.apache.wicket.version.ipageversionmanager#componentstatechanging(org.apache.wicket.version.undo.change)
*/
public void componentstatechanging change change
/**
* @see org.apache.wicket.version.ipageversionmanager#endversion(boolean)
*/
public void endversion boolean mergeversion
versionstarted   false
string sessionid   page getsession   getid
if  sessionid    null
ipagestore store     secondlevelcachesessionstore application get
getsessionstore    getstore
store storepage sessionid  page
/**
* @see org.apache.wicket.version.ipageversionmanager#expireoldestversion()
*/
public void expireoldestversion
/**
* @see org.apache.wicket.version.ipageversionmanager#getajaxversionnumber()
*/
public int getajaxversionnumber
return currentajaxversionnumber
/**
* @see org.apache.wicket.version.ipageversionmanager#getcurrentversionnumber()
*/
public int getcurrentversionnumber
return currentversionnumber
/**
* @see org.apache.wicket.version.ipageversionmanager#getversion(int)
*/
public page getversion int versionnumber
if  currentversionnumber    versionnumber
return page
return null
/**
* @see org.apache.wicket.version.ipageversionmanager#getversions()
*/
public int getversions
return 0
/**
* @see org.apache.wicket.version.ipageversionmanager#ignoreversionmerge()
*/
public void ignoreversionmerge
currentversionnumber
lastajaxversionnumber   currentajaxversionnumber
currentajaxversionnumber   0
/**
* @see org.apache.wicket.version.ipageversionmanager#rollbackpage(int)
*/
public page rollbackpage int numberofversions
string sessionid   page getsession   getid
if  sessionid    null
int versionnumber   currentversionnumber
int ajaxnumber   currentajaxversionnumber
if  versionstarted
versionnumber
ajaxnumber
ipagestore store     secondlevelcachesessionstore application get
getsessionstore    getstore
// if the number of versions to rollback can be done inside the
// current page version.
if  ajaxnumber >  numberofversions
return store getpage sessionid  page getpagemap   getname    page
getnumericid    versionnumber  ajaxnumber   numberofversions
else
// else go one page version down.
versionnumber
// then calculate the previous ajax version by looking at
// the last ajax number of the previous version.
ajaxnumber   lastajaxversionnumber    numberofversions   ajaxnumber
if  ajaxnumber < 0
// currently it is not supported to jump over 2
// pages....
log
error
return null
return store getpage sessionid  page getpagemap   getname    page
getnumericid    versionnumber  ajaxnumber
return null
private void readobject java io objectinputstream s  throws ioexception
classnotfoundexception
s defaultreadobject
// this is an hack.. when object is read in. it must ignore the
// first version bump.
// (matej_k) for now, i'm commenting it out. it causes serious
// trouble with back
// button, where new versions are not created as they should be
// johan promised to look at it soon
// versionstarted = true;
private ipagestore pagestore
/**
* construct.
*
* @param application
*            the application for this store
*
* @param pagestore
*            page store for keeping page versions
*/
public secondlevelcachesessionstore application application  final ipagestore pagestore
super application
this pagestore   pagestore
// turn automatic multiwindow support off by default, as we don't really
// need to be afraid to run out of history with this implementation.
// note that the session store is created before application#init is
// called, so if users set this setting explicitly, it'll be overriden
// (and that's exactly what we want: provide a better default, but not
// forcing people to do away with this feature).
application get   getpagesettings   setautomaticmultiwindowsupport false
/**
* @see org.apache.wicket.protocol.http.httpsessionstore#createpagemap(java.lang.string,
*      org.apache.wicket.session)
*/
public ipagemap createpagemap string name
return new secondlevelcachepagemap name
/**
* @see org.apache.wicket.protocol.http.abstracthttpsessionstore#destroy()
*/
public void destroy
super destroy
getstore   destroy
/**
* @return the store to use
*/
public ipagestore getstore
return pagestore
/**
* @see org.apache.wicket.protocol.http.httpsessionstore#newversionmanager(org.apache.wicket.page)
*/
public ipageversionmanager newversionmanager page page
return new secondlevelcachepageversionmanager page
/**
* @see org.apache.wicket.session.isessionstore#setattribute(org.apache.wicket.request,
*      java.lang.string, java.lang.object)
*/
public void setattribute request request  string name  object value
// ignore all pages, they are stored through the pagemap
if    value instanceof page
super setattribute request  name  value
/**
* @see org.apache.wicket.protocol.http.abstracthttpsessionstore#onunbind(java.lang.string)
*/
protected void onunbind string sessionid
getstore   unbind sessionid