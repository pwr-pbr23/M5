/*
file: copyonwritearraylist.java
written by doug lea. adapted and released, under explicit
permission, from jdk1.2 arraylist.java
which carries the following copyright:
* copyright 1997 by sun microsystems, inc.,
* 901 san antonio road, palo alto, california, 94303, u.s.a.
* all rights reserved.
*
* this software is the confidential and proprietary information
* of sun microsystems, inc. ("confidential information").  you
* shall not disclose such confidential information and shall use
* it only in accordance with the terms of the license agreement
* you entered into with sun.
history:
date       who                what
21jun1998  dl               create public version
9oct1999  dl               faster equals
29jun2001  dl               serialization methods now private
*/
package org apache wicket util concurrent
import java util abstractlist
import java util collection
import java util concurrentmodificationexception
import java util iterator
import java util list
import java util listiterator
import java util nosuchelementexception
/**
* this class implements a variant of java.util.arraylist in which all mutative
* operations (add, set, and so on) are implemented by making a fresh copy of
* the underlying array.
* <p>
* this is ordinarily too costly, but it becomes attractive when traversal
* operations vastly overwhelm mutations, and, especially, when you cannot or
* don't want to synchronize traversals, yet need to preclude interference among
* concurrent threads. the iterator method uses a reference to the state of the
* array at the point that the iterator was created. this array never changes
* during the lifetime of the iterator, so interference is impossible. (the
* iterator will not traverse elements added or changed since the iterator was
* created, but usually this is a desirable feature.)
* <p>
* as much code and documentation as possible was shamelessly copied from
* java.util.arraylist (thanks, josh!), with the intent of preserving all
* semantics of arraylist except for the copy-on-write property. (the java.util
* collection code could not be subclassed here since all of the existing
* collection classes assume elementwise mutability.)
* <p>
* because of the copy-on-write policy, some one-by-one mutative operations in
* the java.util.arrays and java.util.collections classes are so time/space
* intensive as to never be worth calling (except perhaps as benchmarks for
* garbage collectors :-).
* <p>
* three methods are supported in addition to those described in list and
* arraylist. the addifabsent and addallabsent methods provide set semantics for
* add, and are used in copyonwritearrayset. however, they can also be used
* directly from this list version. the copyin method (and a constructor that
* invokes it) allow you to copy in an initial array to use. this method can be
* useful when you first want to perform many operations on a plain array, and
* then make a copy available for use through the collection api.
* <p>
* due to their strict read-only nature, element-changing operations on
* iterators (remove, set, and add) are not supported. these are the only
* methods throwing unsupportedoperationexception.
* <p>
* <p>[<a
* href="http://gee.cs.oswego.edu/dl/classes/edu/oswego/cs/dl/util/concurrent/intro.html">
* introduction to this package. </a>]
*
* @see copyonwritearrayset
*/
public class copyonwritearraylist implements list  cloneable  java io serializable
private static final long serialversionuid   1l
/**
* the held array. directly access only within synchronized methods
*/
protected transient object array_
/**
* accessor to the array intended to be called from within unsynchronized
* read-only methods
*
* @return the internal array
*/
protected synchronized object array
return array_
/**
* constructs an empty list
*
*/
public copyonwritearraylist
array_   new object
/**
* constructs an list containing the elements of the specified collection,
* in the order they are returned by the collection's iterator.
*
* @param c the collection to get the objects from.
*/
public copyonwritearraylist collection c
array_   new object
iterator i   c iterator
int size   0
while  i hasnext
array_   i next
/**
* create a new copyonwritearraylist holding a copy of given array
*
* @param tocopyin
*            the array. a copy of this array is used as the internal array.
*/
public copyonwritearraylist object tocopyin
copyin tocopyin  0  tocopyin length
/**
* replace the held array with a copy of the <code>n</code> elements of
* the provided array, starting at position <code>first</code>. to copy
* an entire array, call with arguments (array, 0, array.length).
*
* @param tocopyin
*            the array. a copy of the indicated elements of this array is
*            used as the internal array.
* @param first
*            the index of first position of the array to start copying
*            from.
* @param n
*            the number of elements to copy. this will be the new size of
*            the list.
*/
public synchronized void copyin object tocopyin  int first  int n
array_   new object
system arraycopy tocopyin  first  array_  0  n
/**
* returns the number of components in this list.
*
* @return the number of components in this list.
*/
public int size
return array   length
/**
* tests if this list has no components.
*
* @return <code>true</code> if this list has no components;
*         <code>false</code> otherwise.
*/
public boolean isempty
return size      0
/**
* returns true if this list contains the specified element.
*
* @param o
*            element whose presence in this list is to be tested.
*/
public boolean contains object elem
object elementdata   array
int len   elementdata length
return indexof elem  elementdata  len  >  0
/**
* searches for the first occurence of the given argument, testing for
* equality using the <code>equals</code> method.
*
* @param elem
*            an object.
* @return the index of the first occurrence of the argument in this list;
*         returns <code>-1</code> if the object is not found.
* @see object#equals(object)
*/
public int indexof object elem
object elementdata   array
int len   elementdata length
return indexof elem  elementdata  len
/**
* static version allows repeated call without needed to grab lock for array
* each time
* @param elem
* @param elementdata
* @param len
* @return the index that is found. -1 if not found
*/
protected static int indexof object elem  object elementdata  int len
if  elem    null
for  int i   0  i < len  i
if  elementdata    null
return i
else
for  int i   0  i < len  i
if  elem equals elementdata
return i
return  1
/**
* searches for the first occurence of the given argument, beginning the
* search at <code>index</code>, and testing for equality using the
* <code>equals</code> method.
*
* @param elem
*            an object.
* @param index
*            the index to start searching from.
* @return the index of the first occurrence of the object argument in this
*         list at position <code>index</code> or later in the list;
*         returns <code>-1</code> if the object is not found.
* @see object#equals(object)
*/
// needed in order to compile on 1.2b3
public int indexof object elem  int index
object elementdata   array
int elementcount   elementdata length
if  elem    null
for  int i   index  i < elementcount  i
if  elementdata    null
return i
else
for  int i   index  i < elementcount  i
if  elem equals elementdata
return i
return  1
/**
* returns the index of the last occurrence of the specified object in this
* list.
*
* @param elem
*            the desired component.
* @return the index of the last occurrence of the specified object in this
*         list; returns -1 if the object is not found.
*/
public int lastindexof object elem
object elementdata   array
int len   elementdata length
return lastindexof elem  elementdata  len
protected static int lastindexof object elem  object elementdata  int len
if  elem    null
for  int i   len   1  i >  0  i
if  elementdata    null
return i
else
for  int i   len   1  i >  0  i
if  elem equals elementdata
return i
return  1
/**
* searches backwards for the specified object, starting from the specified
* index, and returns an index to it.
*
* @param elem
*            the desired component.
* @param index
*            the index to start searching from.
* @return the index of the last occurrence of the specified object in this
*         list at position less than index in the list; -1 if the object is
*         not found.
*/
public int lastindexof object elem  int index
// needed in order to compile on 1.2b3
object elementdata   array
if  elem    null
for  int i   index  i >  0  i
if  elementdata    null
return i
else
for  int i   index  i >  0  i
if  elem equals elementdata
return i
return  1
/**
* returns a shallow copy of this list. (the elements themselves are not
* copied.)
*
* @return a clone of this list.
*/
public object clone
try
object elementdata   array
copyonwritearraylist v    copyonwritearraylist super clone
v array_   new object
system arraycopy elementdata  0  v array_  0  elementdata length
return v
catch  clonenotsupportedexception e
// this shouldn't happen, since we are cloneable
throw new internalerror
/**
* returns an array containing all of the elements in this list in the
* correct order.
*/
public object toarray
object elementdata   array
object result   new object
system arraycopy elementdata  0  result  0  elementdata length
return result
/**
* returns an array containing all of the elements in this list in the
* correct order. the runtime type of the returned array is that of the
* specified array. if the list fits in the specified array, it is returned
* therein. otherwise, a new array is allocated with the runtime type of the
* specified array and the size of this list.
* <p>
* if the list fits in the specified array with room to spare (i.e., the
* array has more elements than the list), the element in the array
* immediately following the end of the collection is set to null. this is
* useful in determining the length of the list <em>only</em> if the
* caller knows that the list does not contain any null elements.
*
* @param a
*            the array into which the elements of the list are to be
*            stored, if it is big enough; otherwise, a new array of the
*            same runtime type is allocated for this purpose.
* @return an array containing the elements of the list.
* @exception arraystoreexception
*                the runtime type of a is not a supertype of the runtime
*                type of every element in this list.
*/
public object toarray object a
object elementdata   array
if  a length < elementdata length
a    object java lang reflect array newinstance a getclass   getcomponenttype
elementdata length
system arraycopy elementdata  0  a  0  elementdata length
if  a length > elementdata length
a   null
return a
// positional access operations
/**
* returns the element at the specified position in this list.
*
* @param index
*            index of element to return.
* @exception indexoutofboundsexception
*                index is out of range (index &lt; 0 || index &gt;=
*                size()).
*/
public object get int index
object elementdata   array
rangecheck index  elementdata length
return elementdata
/**
* replaces the element at the specified position in this list with the
* specified element.
*
* @param index
*            index of element to replace.
* @param element
*            element to be stored at the specified position.
* @return the element previously at the specified position.
* @exception indexoutofboundsexception
*                index out of range (index &lt; 0 || index &gt;= size()).
*/
public synchronized object set int index  object element
int len   array_ length
rangecheck index  len
object oldvalue   array_
boolean same    oldvalue    element     element    null    element equals oldvalue
if   same
object newarray   new object
system arraycopy array_  0  newarray  0  len
newarray   element
array_   newarray
return oldvalue
/**
* appends the specified element to the end of this list.
*
* @param element
*            element to be appended to this list.
* @return true (as per the general contract of collection.add).
*/
public synchronized boolean add object element
int len   array_ length
object newarray   new object
system arraycopy array_  0  newarray  0  len
newarray   element
array_   newarray
return true
/**
* inserts the specified element at the specified position in this list.
* shifts the element currently at that position (if any) and any subsequent
* elements to the right (adds one to their indices).
*
* @param index
*            index at which the specified element is to be inserted.
* @param element
*            element to be inserted.
* @exception indexoutofboundsexception
*                index is out of range (index &lt; 0 || index &gt; size()).
*/
public synchronized void add int index  object element
int len   array_ length
if  index > len    index < 0
throw new indexoutofboundsexception     index       len
object newarray   new object
system arraycopy array_  0  newarray  0  index
newarray   element
system arraycopy array_  index  newarray  index   1  len   index
array_   newarray
/**
* removes the element at the specified position in this list. shifts any
* subsequent elements to the left (subtracts one from their indices).
* returns the element that was removed from the list.
*
* @param index
*            the index of the element to removed.
* @exception indexoutofboundsexception
*                index out of range (index &lt; 0 || index &gt;= size()).
*/
public synchronized object remove int index
int len   array_ length
rangecheck index  len
object oldvalue   array_
object newarray   new object
system arraycopy array_  0  newarray  0  index
int nummoved   len   index   1
if  nummoved > 0
system arraycopy array_  index   1  newarray  index  nummoved
array_   newarray
return oldvalue
/**
* removes a single instance of the specified element from this collection,
* if it is present (optional operation). more formally, removes an element
* <code>e</code> such that <code>(o==null ? e==null :
* o.equals(e))</code>,
* if the collection contains one or more such elements. returns true if the
* collection contained the specified element (or equivalently, if the
* collection changed as a result of the call).
*
* @param element
*            element to be removed from this collection, if present.
* @return true if the collection changed as a result of the call.
*/
public synchronized boolean remove object element
int len   array_ length
if  len    0
return false
// copy while searching for element to remove
// this wins in the normal case of element being present
int newlen   len   1
object newarray   new object
for  int i   0  i < newlen    i
if  element    array_     element    null    element equals array_
// found one; copy remaining and exit
for  int k   i   1  k < len    k
newarray   array_
array_   newarray
return true
else
newarray   array_
// special handling for last cell
if  element    array_     element    null    element equals array_
array_   newarray
return true
else
return false     throw away copy
/**
* removes from this list all of the elements whose index is between
* fromindex, inclusive and toindex, exclusive. shifts any succeeding
* elements to the left (reduces their index). this call shortens the list
* by (toindex - fromindex) elements. (if toindex==fromindex, this operation
* has no effect.)
*
* @param fromindex
*            index of first element to be removed.
* @param toindex
*            index after last element to be removed.
* @exception indexoutofboundsexception
*                fromindex or toindex out of range (fromindex &lt; 0 ||
*                fromindex &gt;= size() || toindex &gt; size() || toindex
*                &lt; fromindex).
*/
public synchronized void removerange int fromindex  int toindex
int len   array_ length
if  fromindex < 0    fromindex >  len    toindex > len    toindex < fromindex
throw new indexoutofboundsexception
int nummoved   len   toindex
int newlen   len    toindex   fromindex
object newarray   new object
system arraycopy array_  0  newarray  0  fromindex
system arraycopy array_  toindex  newarray  fromindex  nummoved
array_   newarray
/**
* append the element if not present. this operation can be used to obtain
* set semantics for lists.
*
* @param element
*            element to be added to this collection, if absent.
* @return true if added
*/
public synchronized boolean addifabsent object element
// copy while checking if already present.
// this wins in the most common case where it is not present
int len   array_ length
object newarray   new object
for  int i   0  i < len    i
if  element    array_     element    null    element equals array_
return false     exit  throwing away copy
else
newarray   array_
newarray   element
array_   newarray
return true
/**
* returns true if this collection contains all of the elements in the
* specified collection.
* <p>
* this implementation iterates over the specified collection, checking each
* element returned by the iterator in turn to see if it's contained in this
* collection. if all elements are so contained true is returned, otherwise
* false.
*
*/
public boolean containsall collection c
object elementdata   array
int len   elementdata length
iterator e   c iterator
while  e hasnext
if  indexof e next    elementdata  len  < 0
return false
return true
/**
* removes from this collection all of its elements that are contained in
* the specified collection. this is a particularly expensive operation in
* this class because of the need for an internal temporary array.
* <p>
*
* @return true if this collection changed as a result of the call.
*/
public synchronized boolean removeall collection c
object elementdata   array_
int len   elementdata length
if  len    0
return false
// temp array holds those elements we know we want to keep
object temp   new object
int newlen   0
for  int i   0  i < len    i
object element   elementdata
if   c contains element
temp   element
if  newlen    len
return false
// copy temp as new array
object newarray   new object
system arraycopy temp  0  newarray  0  newlen
array_   newarray
return true
/**
* retains only the elements in this collection that are contained in the
* specified collection (optional operation). in other words, removes from
* this collection all of its elements that are not contained in the
* specified collection.
*
* @return true if this collection changed as a result of the call.
*/
public synchronized boolean retainall collection c
object elementdata   array_
int len   elementdata length
if  len    0
return false
object temp   new object
int newlen   0
for  int i   0  i < len    i
object element   elementdata
if  c contains element
temp   element
if  newlen    len
return false
object newarray   new object
system arraycopy temp  0  newarray  0  newlen
array_   newarray
return true
/**
* appends all of the elements in the specified collection that are not
* already contained in this list, to the end of this list, in the order
* that they are returned by the specified collection's iterator.
*
* @param c
*            elements to be added into this list.
* @return the number of elements added
*/
public synchronized int addallabsent collection c
int numnew   c size
if  numnew    0
return 0
object elementdata   array_
int len   elementdata length
object temp   new object
int added   0
iterator e   c iterator
while  e hasnext
object element   e next
if  indexof element  elementdata  len  < 0
if  indexof element  temp  added  < 0
temp   element
if  added    0
return 0
object newarray   new object
system arraycopy elementdata  0  newarray  0  len
system arraycopy temp  0  newarray  len  added
array_   newarray
return added
/**
* removes all of the elements from this list.
*
*/
public synchronized void clear
array_   new object
/**
* appends all of the elements in the specified collection to the end of
* this list, in the order that they are returned by the specified
* collection's iterator.
*
* @param c
*            elements to be inserted into this list.
*/
public synchronized boolean addall collection c
int numnew   c size
if  numnew    0
return false
int len   array_ length
object newarray   new object
system arraycopy array_  0  newarray  0  len
iterator e   c iterator
for  int i   0  i < numnew  i
newarray   e next
array_   newarray
return true
/**
* inserts all of the elements in the specified collection into this list,
* starting at the specified position. shifts the element currently at that
* position (if any) and any subsequent elements to the right (increases
* their indices). the new elements will appear in the list in the order
* that they are returned by the specified collection's iterator.
*
* @param index
*            index at which to insert first element from the specified
*            collection.
* @param c
*            elements to be inserted into this list.
* @exception indexoutofboundsexception
*                index out of range (index &lt; 0 || index &gt; size()).
*/
public synchronized boolean addall int index  collection c
int len   array_ length
if  index > len    index < 0
throw new indexoutofboundsexception     index       len
int numnew   c size
if  numnew    0
return false
object newarray   new object
system arraycopy array_  0  newarray  0  len
int nummoved   len   index
if  nummoved > 0
system arraycopy array_  index  newarray  index   numnew  nummoved
iterator e   c iterator
for  int i   0  i < numnew  i
newarray   e next
array_   newarray
return true
/**
* check if the given index is in range. if not, throw an appropriate
* runtime exception.
* @param index
* @param length
*/
protected void rangecheck int index  int length
if  index >  length    index < 0
throw new indexoutofboundsexception     index       length
/**
* save the state of the list to a stream (i.e., serialize it).
* @param s
* @throws java.io.ioexception
*
* @serialdata the length of the array backing the list is emitted (int),
*             followed by all of its elements (each an object) in the
*             proper order.
*/
private void writeobject java io objectoutputstream s  throws java io ioexception
// write out element count, and any hidden stuff
s defaultwriteobject
object elementdata   array
// write out array length
s writeint elementdata length
// write out all elements in the proper order.
for  int i   0  i < elementdata length  i
s writeobject elementdata
/**
* reconstitute the list from a stream (i.e., deserialize it).
* @param s
* @throws java.io.ioexception
* @throws classnotfoundexception
*/
private synchronized void readobject java io objectinputstream s  throws java io ioexception
classnotfoundexception
// read in size, and any hidden stuff
s defaultreadobject
// read in array length and allocate array
int arraylength   s readint
object elementdata   new object
// read in all elements in the proper order.
for  int i   0  i < elementdata length  i
elementdata   s readobject
array_   elementdata
/**
* returns a string representation of this collection, containing the string
* representation of each element.
*/
public string tostring
stringbuffer buf   new stringbuffer
iterator e   iterator
buf append
int maxindex   size     1
for  int i   0  i <  maxindex  i
buf append string valueof e next
if  i < maxindex
buf append
buf append
return buf tostring
/**
* compares the specified object with this list for equality. returns true
* if and only if the specified object is also a list, both lists have the
* same size, and all corresponding pairs of elements in the two lists are
* <em>equal</em>. (two elements <code>e1</code> and <code>e2</code>
* are <em>equal</em> if
* <code>(e1==null ? e2==null : e1.equals(e2))</code>.) in other words,
* two lists are defined to be equal if they contain the same elements in
* the same order.
* <p>
* this implementation first checks if the specified object is this list. if
* so, it returns true; if not, it checks if the specified object is a list.
* if not, it returns false; if so, it iterates over both lists, comparing
* corresponding pairs of elements. if any comparison returns false, this
* method returns false. if either iterator runs out of elements before
* before the other it returns false (as the lists are of unequal length);
* otherwise it returns true when the iterations complete.
*
* @param o
*            the object to be compared for equality with this list.
* @return true if the specified object is equal to this list.
*/
public boolean equals object o
if  o    this
return true
if    o instanceof list
return false
list l2    list  o
if  size      l2 size
return false
listiterator e1   listiterator
listiterator e2   l2 listiterator
while  e1 hasnext
object o1   e1 next
object o2   e2 next
if    o1    null ? o2    null   o1 equals o2
return false
return true
/**
* returns the hash code value for this list.
* <p>
* this implementation uses exactly the code that is used to define the list
* hash function in the documentation for list.hashcode.
*/
public int hashcode
int hashcode   1
iterator i   iterator
while  i hasnext
object obj   i next
hashcode   31   hashcode    obj    null ? 0   obj hashcode
return hashcode
/**
* returns an iterator over the elements contained in this collection. the
* iterator provides a snapshot of the state of the list when the iterator
* was constructed. no synchronization is needed while traversing the
* iterator. the iterator does <em>not</em> support the
* <code>remove</code> method.
*/
public iterator iterator
return new cowiterator array    0
/**
* returns an iterator of the elements in this list (in proper sequence).
* the iterator provides a snapshot of the state of the list when the
* iterator was constructed. no synchronization is needed while traversing
* the iterator. the iterator does <em>not</em> support the
* <code>remove</code>, <code>set</code>, or <code>add</code>
* methods.
*
*/
public listiterator listiterator
return new cowiterator array    0
/**
* returns a listiterator of the elements in this list (in proper sequence),
* starting at the specified position in the list. the specified index
* indicates the first element that would be returned by an initial call to
* nextelement. an initial call to previouselement would return the element
* with the specified index minus one. the listiterator returned by this
* implementation will throw an unsupportedoperationexception in its remove,
* set and add methods.
*
* @param index
*            index of first element to be returned from the listiterator
*            (by a call to getnext).
* @exception indexoutofboundsexception
*                index is out of range (index &lt; 0 || index &gt; size()).
*/
public listiterator listiterator final int index
object elementdata   array
int len   elementdata length
if  index < 0    index > len
throw new indexoutofboundsexception     index
return new cowiterator array    index
protected static class cowiterator implements listiterator
/** snapshot of the array * */
protected final object array
/**
* index of element to be returned by subsequent call to next.
*/
protected int cursor
protected cowiterator object elementarray  int initialcursor
array   elementarray
cursor   initialcursor
public boolean hasnext
return cursor < array length
public boolean hasprevious
return cursor > 0
public object next
try
return array
catch  indexoutofboundsexception ex
throw new nosuchelementexception
public object previous
try
return array
catch  indexoutofboundsexception e
throw new nosuchelementexception
public int nextindex
return cursor
public int previousindex
return cursor   1
/**
* not supported. always throws unsupportedoperationexception.
*
* @exception unsupportedoperationexception
*                remove is not supported by this iterator.
*/
public void remove
throw new unsupportedoperationexception
/**
* not supported. always throws unsupportedoperationexception.
*
* @exception unsupportedoperationexception
*                set is not supported by this iterator.
*/
public void set object o
throw new unsupportedoperationexception
/**
* not supported. always throws unsupportedoperationexception.
*
* @exception unsupportedoperationexception
*                add is not supported by this iterator.
*/
public void add object o
throw new unsupportedoperationexception
/**
* returns a view of the portion of this list between fromindex, inclusive,
* and toindex, exclusive. the returned list is backed by this list, so
* changes in the returned list are reflected in this list, and vice-versa.
* while mutative operations are supported, they are probably not very
* useful for copyonwritearrays.
* </p>
* the semantics of the list returned by this method become undefined if the
* backing list (i.e., this list) is <i>structurally modified</i> in any
* way other than via the returned list. (structural modifications are those
* that change the size of the list, or otherwise perturb it in such a
* fashion that iterations in progress may yield incorrect results.)
*
* @param fromindex
*            low endpoint (inclusive) of the sublist.
* @param tokey
*            high endpoint (exclusive) of the sublist.
* @return a view of the specified range within this list.
* @exception indexoutofboundsexception
*                illegal endpoint index value (fromindex &lt; 0 || toindex
*                &gt; size || fromindex &gt; toindex).
*/
public synchronized list sublist int fromindex  int toindex
// synchronized since sublist ctor depends on it.
int len   array_ length
if  fromindex < 0    toindex > len    fromindex > toindex
throw new indexoutofboundsexception
return new cowsublist this  fromindex  toindex
protected static class cowsublist extends abstractlist
/*
* this is currently a bit sleazy. the class extends abstractlist merely
* for convenience, to avoid having to define addall, etc. this doesn't
* hurt, but is stupid and wasteful. this class does not need or use
* modcount mechanics in abstractlist, but does need to check for
* concurrent modification using similar mechanics. on each operation,
* the array that we expect the backing list to use is checked and
* updated. since we do this for all of the base operations invoked by
* those defined in abstractlist, all is well.
*
* it's not clear whether this is worth cleaning up. the kinds of list
* operations inherited from abstractlist are are already so slow on cow
* sublists that adding a bit more space/time doesn't seem even
* noticeable.
*/
protected final copyonwritearraylist l
protected final int offset
protected int size
protected object expectedarray
protected cowsublist copyonwritearraylist list  int fromindex  int toindex
l   list
expectedarray   l array
offset   fromindex
size   toindex   fromindex
// only call this holding l's lock
protected void checkforcomodification
if  l array_    expectedarray
throw new concurrentmodificationexception
// only call this holding l's lock
protected void rangecheck int index
if  index < 0    index >  size
throw new indexoutofboundsexception     index       size
public object set int index  object element
synchronized  l
rangecheck index
checkforcomodification
object x   l set index   offset  element
expectedarray   l array_
return x
public object get int index
synchronized  l
rangecheck index
checkforcomodification
return l get index   offset
public int size
synchronized  l
checkforcomodification
return size
public void add int index  object element
synchronized  l
checkforcomodification
if  index < 0    index > size
throw new indexoutofboundsexception
l add index   offset  element
expectedarray   l array_
size
public object remove int index
synchronized  l
rangecheck index
checkforcomodification
object result   l remove index   offset
expectedarray   l array_
size
return result
public iterator iterator
synchronized  l
checkforcomodification
return new cowsublistiterator 0
public listiterator listiterator final int index
synchronized  l
checkforcomodification
if  index < 0    index > size
throw new indexoutofboundsexception     index       size
return new cowsublistiterator index
protected class cowsublistiterator implements listiterator
protected final listiterator i
protected final int index
protected cowsublistiterator int index
this index   index
i   l listiterator index   offset
public boolean hasnext
return nextindex   < size
public object next
if  hasnext
return i next
else
throw new nosuchelementexception
public boolean hasprevious
return previousindex   >  0
public object previous
if  hasprevious
return i previous
else
throw new nosuchelementexception
public int nextindex
return i nextindex     offset
public int previousindex
return i previousindex     offset
public void remove
throw new unsupportedoperationexception
public void set object o
throw new unsupportedoperationexception
public void add object o
throw new unsupportedoperationexception
public list sublist int fromindex  int toindex
synchronized  l
checkforcomodification
if  fromindex < 0    toindex > size
throw new indexoutofboundsexception
return new cowsublist l  fromindex   offset  toindex   offset