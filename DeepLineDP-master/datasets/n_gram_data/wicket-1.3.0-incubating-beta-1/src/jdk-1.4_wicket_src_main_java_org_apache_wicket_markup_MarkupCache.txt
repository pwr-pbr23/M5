/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket markup
import java io ioexception
import java util map
import org apache commons logging log
import org apache commons logging logfactory
import org apache wicket application
import org apache wicket markupcontainer
import org apache wicket wicketruntimeexception
import org apache wicket util concurrent concurrenthashmap
import org apache wicket util listener ichangelistener
import org apache wicket util resource iresourcestream
import org apache wicket util resource resourcestreamnotfoundexception
import org apache wicket util watch modificationwatcher
import org apache wicket util watch watcher
/**
* load markup and cache it for fast retrieval. if markup file changes, it'll be
* removed and subsequently reloaded when needed.
*
* @author jonathan locke
* @author juergen donnerstag
*/
public class markupcache
/** log for reporting. */
private static final log log   logfactory getlog markupcache class
/** map of markup tags by class (exactly what is in the file). */
private final map markupcache   new concurrenthashmap
/**
* markup inheritance requires that merged markup gets re-merged either
* after the base markup or the derived markup has been reloaded.
*/
private final watcher afterloadlisteners   new watcher
/** the wicket application */
private final application application
/**
* constructor.
*
* @param application
*/
public markupcache final application application
this application   application
/**
* clear markup cache and force reload of all markup data
*/
public void clear
this afterloadlisteners clear
this markupcache clear
/**
* gets a fresh markup stream that contains the (immutable) markup resource
* for this class.
*
* @param container
*            the container the markup should be associated with
* @return a stream of markupelement elements
*/
public final markupstream getmarkupstream final markupcontainer container
return getmarkupstream container  true
/**
* gets a fresh markup stream that contains the (immutable) markup resource
* for this class.
*
* @param container
*            the container the markup should be associated with
* @param throwexception
*            if true, throw an exception, if markup could not be found
* @return a stream of markupelement elements
*/
public final markupstream getmarkupstream final markupcontainer container
final boolean throwexception
if  container    null
throw new illegalargumentexception
// look for associated markup
final markup markup   getmarkup container  container getclass
// if we found markup for this container
if  markup    markup no_markup
return new markupstream markup
if  throwexception    true
// throw exception since there is no associated markup
throw new markupnotfoundexception
container getclass   getname
return null
/**
* check if container has associated markup
*
* @param container
*            the container the markup should be associated with
* @return true if this markup container has associated markup
*/
public final boolean hasassociatedmarkup final markupcontainer container
return getmarkup container  container getclass       markup no_markup
/**
* @return the number of elements currently in the cache.
*/
public int size
return markupcache size
/**
* the markup has just been loaded and now we check if markup inheritance
* applies, which is if <wicket:extend> is found in the markup. if yes, than
* load the base markups and merge the markup elements to create an updated
* (merged) list of markup elements.
*
* @param container
*            the original requesting markup container
* @param markup
*            the markup to checked for inheritance
* @return a markup object with the the base markup elements resolved.
*/
private markup checkformarkupinheritance final markupcontainer container  final markup markup
// check if markup contains <wicket:extend> which tells us that
// we need to read the inherited markup as well.
int extendindex   requiresbasemarkup markup
if  extendindex     1
// return a markupstream for the markup
return markup
// get the base markup
final markup basemarkup   getmarkup container  markup getresource   getmarkupclass
getsuperclass
if  basemarkup    markup no_markup
throw new markupnotfoundexception
markup getresource   getcontainerinfo   getcontainerclass   getname
final charsequence key   markup getresource   getcachekey
if  key    null
// register an after-load listener for base markup. the listener
// implementation will remove the derived markup which must be
// merged
// with the base markup
afterloadlisteners add basemarkup getresource    new ichangelistener
/**
* make sure there is only one listener per derived markup
*
* @see java.lang.object#equals(java.lang.object)
*/
public boolean equals object obj
return true
/**
* make sure there is only one listener per derived markup
*
* @see java.lang.object#hashcode()
*/
public int hashcode
return key hashcode
public void onchange
if  log isdebugenabled
log debug     markup getresource
removemarkup markup getresource
// merge base and derived markup
markup mergedmarkup   new mergedmarkup markup  basemarkup  extendindex
return mergedmarkup
/**
* gets any (immutable) markup resource for the container or any of its
* parent classes (markup inheritance)
*
* @param container
*            the original requesting markup container
* @param clazz
*            the class to get the associated markup for. if null, the
*            container's class is used, but it can be a parent class of the
*            container as well (markup inheritance)
* @return markup resource
*/
private final markup getmarkup final markupcontainer container  final class clazz
class containerclass   clazz
if  clazz    null
containerclass   container getclass
else
if   clazz isassignablefrom container getclass
throw new wicketruntimeexception
// get the cache key to be associated with the markup resource stream
final imarkupcachekeyprovider markupcachekeyprovider   getmarkupcachekeyprovider container
final charsequence cachekey   markupcachekeyprovider getcachekey container  clazz
// markup already in the cache? if cachekey == null, than don't cache
// the markup resource stream
markup markup   null
if  cachekey    null
markup    markup markupcache get cachekey
// must markup be loaded?
if  markup    null
synchronized  markupcache
if  cachekey    null
markup    markup markupcache get cachekey
// must markup be loaded?
if  markup    null
// who is going to provide the markup resource stream?
final imarkupresourcestreamprovider markupresourcestreamprovider   getmarkupresourcestreamprovider container
// ask the provider to locate the markup resource stream
final iresourcestream resourcestream   markupresourcestreamprovider
getmarkupresourcestream container  containerclass
// found markup?
if  resourcestream    null
final markupresourcestream markupresourcestream
if  resourcestream instanceof markupresourcestream
markupresourcestream    markupresourcestream resourcestream
else
markupresourcestream   new markupresourcestream resourcestream
new containerinfo container   containerclass
markupresourcestream setcachekey cachekey
// load the markup and watch for changes
markup   loadmarkupandwatchforchanges container  markupresourcestream
else
// flag markup as non-existent (as opposed to null,
// which might mean that it's simply not loaded into
// the cache)
markup   markup no_markup
// save any markup list (or absence of one) for next
// time
if  cachekey    null
markupcache put cachekey  markup
return markup
/**
* loads markup from a resource stream.
*
* @param container
*            the original requesting markup container
* @param markupresourcestream
*            the markup resource stream to load
* @return the markup
*/
private final markup loadmarkup final markupcontainer container
final markupresourcestream markupresourcestream
charsequence cachekey   markupresourcestream getcachekey
try
// read and parse the markup
markup markup   application getmarkupsettings   getmarkupparserfactory
newmarkupparser   readandparse markupresourcestream
// check for markup inheritance. if it contains <wicket:extend>
// the two markups get merged.
markup   checkformarkupinheritance container  markup
// add the markup to the cache
if  cachekey    null
markupcache put cachekey  markup
// trigger all listeners registered on the markup just loaded
afterloadlisteners notifylisteners markupresourcestream
return markup
catch  resourcestreamnotfoundexception e
log error     markupresourcestream  e
catch  ioexception e
log error     markupresourcestream  e
// in case of an error, remove the cache entry
synchronized  markupcache
if  cachekey    null
markupcache remove cachekey
afterloadlisteners remove markupresourcestream
return markup no_markup
/**
* load markup from an iresourcestream and add an {@link ichangelistener}to
* the {@link modificationwatcher} so that if the resource changes, we can
* remove it from the cache automatically and subsequently reload when
* needed.
*
* @param container
*            the original requesting markup container
* @param markupresourcestream
*            the markup stream to load and begin to watch
* @return the markup in the stream
*/
private final markup loadmarkupandwatchforchanges final markupcontainer container
final markupresourcestream markupresourcestream
if  markupresourcestream getcachekey      null
// watch file in the future
final modificationwatcher watcher   application getresourcesettings
getresourcewatcher true
if  watcher    null
watcher add markupresourcestream  new ichangelistener
public void onchange
if  log isdebugenabled
log debug     markupresourcestream
// remove the markup from the cache. it will be reloaded
// next time it the markup is requested.
removemarkup markupresourcestream
watcher remove markupresourcestream
if  log isdebugenabled
log debug     markupresourcestream
return loadmarkup container  markupresourcestream
/**
* remove the markup from the cache and trigger all associated listeners
*
* @param markupresourcestream
*            the resource stream
*/
private void removemarkup final markupresourcestream markupresourcestream
charsequence cachekey   markupresourcestream getcachekey
if  cachekey    null
markupcache remove cachekey
// trigger all listeners registered on the markup that is removed
afterloadlisteners notifylisteners markupresourcestream
afterloadlisteners remove markupresourcestream
/**
* check if markup contains &lt;wicket:extend&gt; which tells us that we
* need to read the inherited markup as well. &lt;wicket:extend&gt; must be
* the first wicket tag in the markup. skip raw markup
*
* @param markup
* @return == 0, if no wicket:extend was found
*/
private int requiresbasemarkup final markup markup
for  int i   0  i < markup size    i
markupelement elem    markupelement markup get i
if  elem instanceof wickettag
wickettag wtag    wickettag elem
if  wtag isextendtag
// ok, inheritance is on and we must get the
// inherited markup as well.
return i
return  1
/**
* determine the markup cache key provider to be used
*
* @param container
*            the markupcontainer requesting the markup resource stream
* @return imarkupresourcestreamprovider
*/
protected imarkupcachekeyprovider getmarkupcachekeyprovider final markupcontainer container
if  container instanceof imarkupcachekeyprovider
return  imarkupcachekeyprovider container
return new defaultmarkupcachekeyprovider
/**
* determine the markup resource stream provider to be used
*
* @param container
*            the markupcontainer requesting the markup resource stream
* @return imarkupresourcestreamprovider
*/
protected imarkupresourcestreamprovider getmarkupresourcestreamprovider
final markupcontainer container
if  container instanceof imarkupresourcestreamprovider
return  imarkupresourcestreamprovider container
return new defaultmarkupresourcestreamprovider