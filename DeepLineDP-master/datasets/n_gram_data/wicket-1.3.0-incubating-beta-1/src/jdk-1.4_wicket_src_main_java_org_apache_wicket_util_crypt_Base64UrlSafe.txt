/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket util crypt
/**
* provides base64 encoding and decoding with url and filename safe alphabet
* as defined by rfc 3548, section 4.
* <p/>
* this base64 encoder is modified to meet url requirements. the changes are:
* '+' => '*',
* '/' => '-',
* and no padding.
* <p/>
* this class is taken from the apache commons-codec, and adjusted to fit the
* wicket framework's needs, especially external dependencies have been removed.
* </p>
* <p/>
* this class implements section <cite>4. base 64 encoding with url and filename safe alphabet</cite>
* from rfc 3548 <cite>the base16, base32, and base64 data encodings</cite> by simon josefsson.</p>
*
* @author apache software foundation
* @author juergen donnerstag
*
* @since 1.2
*/
public class base64urlsafe
/**
* the base length.
*/
static final int baselength   255
/**
* lookup length.
*/
static final int lookuplength   64
/**
* used to calculate the number of bits in a byte.
*/
static final int eightbit   8
/**
* used when encoding something which has fewer than 24 bits.
*/
static final int sixteenbit   16
/**
* used to determine how many bits data contains.
*/
static final int twentyfourbitgroup   24
/**
* used to get the number of quadruples.
*/
static final int fourbyte   4
/**
* used to test the sign of a byte.
*/
static final int sign    128
/**
* contains the base64 values <code>0</code> through <code>63</code> accessed by using character encodings as
* indices.
* <p/>
* for example, <code>base64alphabet['+']</code> returns <code>62</code>.
* </p>
* <p/>
* the value of undefined encodings is <code>-1</code>.
* </p>
*/
private static byte base64alphabet   new byte
/**
* <p/>
* contains the base64 encodings <code>a</code> through <code>z</code>, followed by <code>a</code> through
* <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and
* <code>/</code>.
* </p>
* <p/>
* this array is accessed by using character values as indices.
* </p>
* <p/>
* for example, <code>lookupbase64alphabet[62] </code> returns <code>'+'</code>.
* </p>
*/
private static byte lookupbase64alphabet   new byte
// populating the lookup and character arrays
static
for  int i   0  i < baselength  i
base64alphabet    byte   1
for  int i      i >     i
base64alphabet    byte   i
for  int i      i >     i
base64alphabet    byte   i       26
for  int i      i >     i
base64alphabet    byte   i       52
base64alphabet   62
base64alphabet   63
for  int i   0  i <  25  i
lookupbase64alphabet    byte       i
for  int i   26  j   0  i <  51  i    j
lookupbase64alphabet    byte       j
for  int i   52  j   0  i <  61  i    j
lookupbase64alphabet    byte       j
lookupbase64alphabet    byte
lookupbase64alphabet    byte
/**
* returns whether or not the <code>octect</code> is in the base 64 alphabet.
*
* @param octect the value to test
* @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
*/
private static boolean isbase64 byte octect
if  octect < 0    base64alphabet     1
return false
else
return true
/**
* tests a given byte array to see if it contains
* only valid characters within the base64 alphabet.
*
* @param arrayoctect byte array to test
* @return <code>true</code> if all bytes are valid characters in the base64
*         alphabet or if the byte array is empty; false, otherwise
*/
public static boolean isarraybytebase64 byte arrayoctect
arrayoctect   discardwhitespace arrayoctect
int length   arrayoctect length
if  length    0
// shouldn't a 0 length array be valid base64 data?
// return false;
return true
for  int i   0  i < length  i
if   isbase64 arrayoctect
return false
return true
/**
* decodes an object using the base64 algorithm.  this method
* is provided in order to satisfy the requirements of the
* decoder interface, and will throw a decoderexception if the
* supplied object is not of type byte[].
*
* @param pobject object to decode
* @return an object (of type byte[]) containing the
*         binary data which corresponds to the byte[] supplied.
* @throws illegalargumentexception if the parameter supplied is not
*                                  of type byte[]
*/
public object decode object pobject
if    pobject instanceof byte
throw new illegalargumentexception
return decode  byte  pobject
/**
* decodes a byte[] containing containing
* characters in the base64 alphabet.
*
* @param parray a byte array containing base64 character data
* @return a byte array containing binary data
*/
public byte decode byte parray
return decodebase64 parray
/**
* encodes binary data using the base64 algorithm.
*
* @param binarydata array containing binary data to encode.
* @return base64-encoded data.
*/
public static byte encodebase64 byte binarydata
int lengthdatabits   binarydata length   eightbit
int fewerthan24bits   lengthdatabits % twentyfourbitgroup
int numbertriplets   lengthdatabits   twentyfourbitgroup
byte encodeddata   null
int encodeddatalength   0
if  fewerthan24bits    0
//data not divisible by 24 bit
encodeddatalength    numbertriplets   1    4
else
// 16 or 8 bit
encodeddatalength   numbertriplets   4
if  fewerthan24bits    eightbit
encodeddatalength    2
else if  fewerthan24bits    sixteenbit
encodeddatalength    1
encodeddata   new byte
byte k   0  l   0  b1   0  b2   0  b3   0
int encodedindex   0
int dataindex   0
int i   0
//log.debug("number of triplets = " + numbertriplets);
for  i   0  i < numbertriplets  i
dataindex   i   3
b1   binarydata
b2   binarydata
b3   binarydata
//log.debug("b1= " + b1 +", b2= " + b2 + ", b3= " + b3);
l    byte   b2   0x0f
k    byte   b1   0x03
byte val1
b1   sign     0  ?  byte   b1 >> 2     byte    b1  >> 2 ^ 0xc0
byte val2
b2   sign     0  ?  byte   b2 >> 4     byte    b2  >> 4 ^ 0xf0
byte val3
b3   sign     0  ?  byte   b3 >> 6     byte    b3  >> 6 ^ 0xfc
encodeddata   lookupbase64alphabet
//log.debug( "val2 = " + val2 );
//log.debug( "k4   = " + (k<<4) );
//log.debug(  "vak  = " + (val2 | (k<<4)) );
encodeddata
lookupbase64alphabet
encodeddata
lookupbase64alphabet
encodeddata   lookupbase64alphabet
encodedindex    4
// form integral number of 6-bit groups
dataindex   i   3
if  fewerthan24bits    eightbit
b1   binarydata
k    byte   b1   0x03
//log.debug("b1=" + b1);
//log.debug("b1<<2 = " + (b1>>2) );
byte val1
b1   sign     0  ?  byte   b1 >> 2     byte    b1  >> 2 ^ 0xc0
encodeddata   lookupbase64alphabet
encodeddata   lookupbase64alphabet
else if  fewerthan24bits    sixteenbit
b1   binarydata
b2   binarydata
l    byte   b2   0x0f
k    byte   b1   0x03
byte val1
b1   sign     0  ?  byte   b1 >> 2     byte    b1  >> 2 ^ 0xc0
byte val2
b2   sign     0  ?  byte   b2 >> 4     byte    b2  >> 4 ^ 0xf0
encodeddata   lookupbase64alphabet
encodeddata
lookupbase64alphabet
encodeddata   lookupbase64alphabet
return encodeddata
/**
* decodes base64 data into octects
*
* @param base64data byte array containing base64 data
* @return array containing decoded data.
*/
public static byte decodebase64 byte base64data
// rfc 2045 requires that we discard all non-base64 characters
base64data   discardnonbase64 base64data
// handle the edge case, so we don't have to worry about it later
if  base64data length    0
return new byte
int numberquadruple    base64data length   3    fourbyte
byte decodeddata   new byte
byte b1   0  b2   0  b3   0  b4   0  marker0   0  marker1   0
// throw away anything not in base64data
int encodedindex   0
int dataindex   0
for  int i   0  i < numberquadruple  i
dataindex   i   4
b1   base64alphabet]
b2   base64alphabet]
if   dataindex   3  < base64data length
//no pad e.g 3cql
b3   base64alphabet]
b4   base64alphabet]
decodeddata    byte   b1 << 2   b2 >> 4
decodeddata
byte     b2   0xf  << 4      b3 >> 2    0xf
decodeddata    byte   b3 << 6   b4
else if   dataindex   2  < base64data length
//one pad e.g. 3cq[pad]
b3   base64alphabet]
decodeddata    byte   b1 << 2   b2 >> 4
decodeddata
byte     b2   0xf  << 4      b3 >> 2    0xf
else if   dataindex   1  < base64data length
//two pad e.g. 3c[pad][pad]
decodeddata    byte   b1 << 2   b2 >> 4
encodedindex    3
return decodeddata
/**
* discards any whitespace from a base-64 encoded block.
*
* @param data the base-64 encoded data to discard the whitespace
*             from.
* @return the data, less whitespace (see rfc 2045).
*/
static byte discardwhitespace byte data
byte groomeddata   new byte
int bytescopied   0
for  int i   0  i < data length  i
switch  data
case  byte
case  byte
case  byte
case  byte
break
default
groomeddata   data
byte packeddata   new byte
system arraycopy groomeddata  0  packeddata  0  bytescopied
return packeddata
/**
* discards any characters outside of the base64 alphabet, per
* the requirements on page 25 of rfc 2045 - "any characters
* outside of the base64 alphabet are to be ignored in base64
* encoded data."
*
* @param data the base-64 encoded data to groom
* @return the data, less non-base64 characters (see rfc 2045).
*/
static byte discardnonbase64 byte data
byte groomeddata   new byte
int bytescopied   0
for  int i   0  i < data length  i
if  isbase64 data
groomeddata   data
byte packeddata   new byte
system arraycopy groomeddata  0  packeddata  0  bytescopied
return packeddata
// implementation of the encoder interface
/**
* encodes an object using the base64 algorithm.  this method
* is provided in order to satisfy the requirements of the
* encoder interface, and will throw an encoderexception if the
* supplied object is not of type byte[].
*
* @param pobject object to encode
* @return an object (of type byte[]) containing the
*         base64 encoded data which corresponds to the byte[] supplied.
* @throws illegalargumentexception if the parameter supplied is not
*                                  of type byte[]
*/
public object encode object pobject
if    pobject instanceof byte
throw new illegalargumentexception
return encode  byte  pobject
/**
* encodes a byte[] containing binary data, into a byte[] containing
* characters in the base64 alphabet.
*
* @param parray a byte array containing binary data
* @return a byte array containing only base64 character data
*/
public byte encode byte parray
return encodebase64 parray