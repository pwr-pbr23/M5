/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket
import java util iterator
import org apache commons logging log
import org apache commons logging logfactory
import org apache wicket session pagemap ipagemapentry
import org apache wicket util collections arrayliststack
/**
* a container for pages held in the session. ipagemap is a parameter to several
* methods in the wicket api. you can get a ipagemap by name from a session with
* session.getpagemap(string pagemapname) or more conveniently with
* pagemap.forname(string pagemapname). but you should not hold onto a reference
* to the pagemap (just as you should not hold onto a reference to your session
* but should get it each time you need it instead). instead, create a strongly
* typed accessor method like this:
*
* <pre>
* public ipagemap getmypagemap()
* {
* 	return ipagemap.forname(&quot;mypagemapname&quot;);
* }
* </pre>
*
* if the page map with the given name is not found, one will be automatically
* created.
*
* @author jonathan locke
*/
public class accessstackpagemap extends pagemap implements iclusterable
private static final long serialversionuid   1l
/** log. */
private static final log log   logfactory getlog accessstackpagemap class
/** stack of entry accesses by id */
private final arrayliststack accessstack   new arrayliststack 8
/**
* holds information about a pagemap access
*
* @author jonathan
*/
public static class access implements iclusterable
private static final long serialversionuid   1l
int id
int version
/**
* @see java.lang.object#equals(java.lang.object)
*/
public boolean equals object obj
if  obj instanceof access
access tmp    access obj
return tmp id    id    tmp version    version
return false
/**
* gets id.
*
* @return id
*/
public final int getid
return id
/**
* gets version.
*
* @return version
*/
public final int getversion
return version
/**
* @see java.lang.object#hashcode()
*/
public int hashcode
return id    version << 16
/**
* @see java.lang.object#tostring()
*/
public string tostring
return     id       version
/**
* constructor
*
* @param name
*            the name of this page map
*/
public accessstackpagemap final string name
super name
/**
* removes all pages from this map
*/
public final void clear
super clear
// clear access stack
accessstack clear
dirty
// todo post 1.2: we should encode the page id of the current page into the
// url for truly stateless pages so we can adjust the stack correctly
/**
* returns a stack of pagemap.access entries pushed in the order that the
* pages and versions were accessed.
*
* @return stack containing ids of entries in access order.
*/
public final arrayliststack getaccessstack
return accessstack
/**
* @return number of page versions stored in this page map
*/
public final int getversions
return accessstack size
/**
* gets the most recently accessed page map entry off the top of the entry
* access stack. this is guaranteed to be the most recently accessed entry
* if and only if the user just came from a stateful page. if the user could
* get to the current page from a stateless page, this method may not work
* if the user uses the back button. for a detailed explanation of this
* issue, see getaccessstack().
*
* @see pagemap#getaccessstack()
*
* @return previous pagemap entry in terms of access
*/
public final ipagemapentry lastaccessedentry
return getentry peekaccess   getid
/**
* @param entry
*            the entry to remove
*/
public final void removeentry final ipagemapentry entry
if entry    null
// todo this shouldn't happen but to many people are still getting this now and then/
// so first this "fix"
log warn
return
// remove entry from session
session session   getsession
synchronized  session
session removeattribute attributeforid entry getnumericid
// remove page from acccess stack
final iterator stack   accessstack iterator
while  stack hasnext
final access access    access stack next
if  access id    entry getnumericid
stack remove
// let the session know we changed the pagemap
dirty
/**
* retrieves page with given id.
*
* @param id
*            the page identifier
* @param versionnumber
*            the version to get
* @return any page having the given id
*/
public final page get final int id  int versionnumber
final ipagemapentry entry    ipagemapentry getsession   getattribute attributeforid id
if  entry    null
// get page as dirty
page page   entry getpage
// todo performance: is this really the case is a page always dirty
// even if we just render it again? possible answer: the page could
// mark itself as clean to prevent replication, but the reverse is
// probably not desirable (pages marking themselves dirty manually)
// we ought to think about this a bit and consider whether this
// could be tied in with version management. it's only when a page's
// version changes that it should be considered dirty, because then
// some kind of state changed. right? - jonathan
page dirty
// entry has been accessed
access entry  versionnumber
// get the version of the page requested from the page
final page version   page getversion versionnumber
// is the requested version available?
if  version    null
// need to update session with new page?
if  version    page
// this is our new page
page   version
// replaces old page entry
page getpagemap   put page
else
if  log isinfoenabled
log info     versionnumber       page
return null
return page
return null
/**
* @param page
*            the page to put into this map
*/
public final void put final page page
// page only goes into session if it is stateless
if   page ispagestateless
session session   getsession
// get page map entry from page
final ipagemapentry entry   page getpagemapentry
// entry has been accessed
pushaccess entry
// store entry in session
final string attribute   attributeforid entry getnumericid
if  session getattribute attribute     null
// set attribute if it is a new page, so that it will exists
// already for other threads that can come on the same time.
session setattribute attribute  entry
else
// else don't set it directly but add to the dirty map
session dirtypage page
// evict any page(s) as need be
session getapplication   getsessionsettings   getpagemapevictionstrategy   evict this
/**
* @param entry
*            add entry to access list
* @param version
*            version number being accessed
*/
private final void access final ipagemapentry entry  final int version
// see if the version being accessed is already in the stack
boolean add   true
int id   entry getnumericid
for  int i   accessstack size     1  i >  0  i
final access access    access accessstack get i
// if we found id and version in access stack
if  access id    id    access version    version
// no need to add since id and version are already in stack
add   false
// pop entries to reveal that version at top of stack
// because the user used the back button
while  i < accessstack size     1
// pop unreachable access off top of stack
final access topaccess   popaccess
// get entry for access
final ipagemapentry top   getentry topaccess getid
// if it's a page we can remove version info
if  top instanceof page
// if there's more than one version
page toppage    page top
if  toppage getversions   > 1
// remove version the top access version (-1)
toppage getversion topaccess getversion     1
else
// remove whole page
remove toppage
else if top    null
// remove entry
removeentry top
break
// if the user did not use the back button
if  add
pushaccess entry
/**
* @return access entry on top of the access stack
*/
private final access peekaccess
return  access accessstack peek
/**
* removes access entry on top of stack
*
* @return access entry on top of the access stack
*/
private final access popaccess
dirty
return  access accessstack pop
/**
* @param entry
*            entry that was accessed
*/
private final void pushaccess ipagemapentry entry
// create new access entry
final access access   new access
access id   entry getnumericid
access version   versionof entry
if  accessstack size   > 0
if  peekaccess   equals access
return
int index   accessstack indexof access
if  index >  0
accessstack remove index
accessstack push access
dirty
/**
* @param entry
*            page map entry
* @return version of entry
*/
private final int versionof final ipagemapentry entry
if  entry instanceof page
return   page entry  getcurrentversionnumber
// if entry is not a page, it cannot have versions because the page
// is constructed on the fly.
return 0