/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket extensions markup html tree
import java util enumeration
import java util hashtable
import java util nosuchelementexception
import javax swing event treemodelevent
import javax swing event treemodellistener
import javax swing tree defaultmutabletreenode
import javax swing tree mutabletreenode
import javax swing tree rowmapper
import javax swing tree treemodel
import javax swing tree treepath
import javax swing tree treeselectionmodel
import org apache wicket iclusterable
import org apache wicket util collections arrayliststack
/**
* holder and handler for tree state.
*
* this class is largely based on
* {@link javax.swing.tree.fixedheightlayoutcache}from jdk 1.5_01. using that
* class or {@link javax.swing.tree.variableheightlayoutcache}gave problems
* when working in clustered environments. hence, for this class most of the
* useful workings of fixedheightlayoutcache were copied, while everything that
* is swing/paint specific was removed.
*
* @author eelco hillenius
* @author scott violet (sun, fixedheightlayoutcache)
*/
public final class treestate implements iclusterable  treemodellistener  rowmapper
private static final long serialversionuid   1l
/** currently selected path. */
private treepath selectedpath
/** model providing information. */
private treemodel treemodel
/** selection model. */
private treeselectionmodel treeselectionmodel
/**
* true if the root node is displayed, false if its children are the highest
* visible nodes.
*/
private boolean rootvisible
/** root node. */
private treestatenode root
/** number of rows currently visible. */
private int rowcount
/**
* maps from treepath to a treestatenode.
*/
private hashtable treepathmapping
/**
* used for getting path/row information.
*/
private searchinfo info
private arrayliststack tempstacks
/**
* construct.
*/
public treestate
tempstacks   new arrayliststack
treepathmapping   new hashtable
info   new searchinfo
/**
* expands the selected path and set selection to currently selected path.
*
* @param selection
*			  the new selection.
*/
public void setselectedpath treepath selection
setexpandedstate selection  true
this selectedpath   selection
// if we have a multiple selection model
if  treeselectionmodel    null
if  treeselectionmodel ispathselected selection
treeselectionmodel removeselectionpath selection
else
treeselectionmodel addselectionpath selection
/**
* gets the currently selected path.
* @return the currently selected path
*/
public treepath getselectedpath
if   selectedpath    null     isrootvisible
selectedpath   new treepath getmodel   getroot
return selectedpath
/**
* returns the <code>treemodel</code> that is providing the data.
*
* @return the <code>treemodel</code> that is providing the data
*/
public treemodel getmodel
return treemodel
/**
* returns true if the root node of the tree is displayed.
*
* @return true if the root node of the tree is displayed
*/
public boolean isrootvisible
return rootvisible
/**
* sets the <code>treeselectionmodel</code> used to manage the selection
* to new lsm.
*
* @param selectionmodel
*			  the new <code>treeselectionmodel</code>
*/
public void setselectionmodel treeselectionmodel selectionmodel
if  this treeselectionmodel    null
this treeselectionmodel setrowmapper null
if  selectionmodel    null
selectionmodel setrowmapper this
this treeselectionmodel   selectionmodel
/**
* returns the model used to maintain the selection.
*
* @return the <code>treeselectionmodel</code>
*/
public treeselectionmodel getselectionmodel
return treeselectionmodel
//
// rowmapper
//
/**
* returns the rows that the <code>treepath</code> instances in
* <code>path</code> are being displayed at. this method should return an
* array of the same length as that passed in, and if one of the
* <code>treepaths</code> in <code>path</code> is not valid its entry in
* the array should be set to -1.
*
* @param paths
*			  the array of <code>treepath</code> s being queried
* @return an array of the same length that is passed in containing the rows
*		   that each corresponding where each <code>treepath</code> is
*		   displayed; if <code>paths</code> is <code>null</code>,
*		   <code>null</code> is returned
*/
public int getrowsforpaths treepath paths
if  paths    null
return null
int numpaths   paths length
int rows   new int
for  int counter   0  counter < numpaths  counter
rows   getrowforpath paths
return rows
/**
* sets the treemodel that will provide the data.
*
* @param newmodel
*			  the treemodel that is to provide the data
*/
public void setmodel treemodel newmodel
this treemodel   newmodel
rebuild false
/**
* determines whether or not the root node from the treemodel is visible.
*
* @param rootvisible
*			  true if the root node of the tree is to be displayed
*/
public void setrootvisible boolean rootvisible
if  isrootvisible      rootvisible
this rootvisible   rootvisible
if  root    null
if  rootvisible
rowcount
root adjustrowby 1
else
rowcount
root adjustrowby  1
visiblenodeschanged
/**
* returns the number of visible rows.
*
* @return the number of visible rows
*/
public int getrowcount
return rowcount
/**
* returns true if the value identified by row is currently expanded.
*
* @param path
*			  the row
* @return true if the value identified by row is currently expanded
*/
public boolean isexpanded treepath path
if  path    null
treestatenode lastnode   getnodeforpath path  true  false
return  lastnode    null    lastnode isexpanded
return false
/**
* returns the path for passed in row. if row is not visible null is
* returned.
*
* @param row
*			  the row
* @return the path for passed in row
*/
public treepath getpathforrow int row
if  row >  0    row < getrowcount
if  root getpathforrow row  getrowcount    info
return info getpath
return null
/**
* returns the row that the last item identified in path is visible at. will
* return -1 if any of the elements in path are not currently visible.
*
* @param path
*			  the path
* @return the row that the last item identified in path is visible at
*/
public int getrowforpath treepath path
if  path    null    root    null
return  1
treestatenode node   getnodeforpath path  true  false
if  node    null
return node getrow
treepath parentpath   path getparentpath
node   getnodeforpath parentpath  true  false
if  node    null    node isexpanded
return node getrowtomodelindex treemodel getindexofchild parentpath
getlastpathcomponent    path getlastpathcomponent
return  1
/**
* returns the number of visible children for row.
*
* @param path
*			  the path
* @return the number of visible children for row
*/
public int getvisiblechildcount treepath path
treestatenode node   getnodeforpath path  true  false
if  node    null
return 0
return node gettotalchildcount
/**
* returns an enumerator that increments over the visible paths starting at
* the passed in location. the ordering of the enumeration is based on how
* the paths are displayed.
*
* @param path
*			  the path
* @return an enumerator that increments over the visible paths
*/
public enumeration getvisiblepathsfrom treepath path
if  path    null
return null
treestatenode node   getnodeforpath path  true  false
if  node    null
return new visibletreestatenodeenumeration node
treepath parentpath   path getparentpath
node   getnodeforpath parentpath  true  false
if  node    null    node isexpanded
return new visibletreestatenodeenumeration node  treemodel getindexofchild
parentpath getlastpathcomponent    path getlastpathcomponent
return null
/**
* marks the path <code>path</code> expanded state to
* <code>isexpanded</code>.
*
* @param path
*			  the path
* @param isexpanded
*			  whether the path is expanded
*/
public void setexpandedstate treepath path  boolean isexpanded
if  isexpanded
ensurepathisexpanded path  true
else if  path    null
treepath parentpath   path getparentpath
// yeck! make the parent expanded.
if  parentpath    null
treestatenode parentnode   getnodeforpath parentpath  false  true
if  parentnode    null
parentnode makevisible
// and collapse the child.
treestatenode childnode   getnodeforpath path  true  false
if  childnode    null
childnode collapse true
/**
* returns true if the path is expanded, and visible.
*
* @param path
*			  the path
* @return true if the path is expanded, and visible
*/
public boolean getexpandedstate treepath path
treestatenode node   getnodeforpath path  true  false
return  node    null  ?  node isvisible      node isexpanded      false
//
// treemodellistener methods
//
/**
* <p>
* invoked after a node (or a set of siblings) has changed in some way. the
* node(s) have not changed locations in the tree or altered their children
* arrays, but other attributes have changed and may affect presentation.
* example: the name of a file has changed, but it is in the same location
* in the file system.
* </p>
* <p>
* e.path() returns the path the parent of the changed node(s).
* </p>
* <p>
* e.childindices() returns the index(es) of the changed node(s).
* </p>
*
* @param e
*			  the tree model event
*/
public void treenodeschanged treemodelevent e
if  e    null
int changedindexs
treestatenode changedparent   getnodeforpath e gettreepath    false  false
int maxcounter
changedindexs   e getchildindices
/*
* only need to update the children if the node has been expanded
* once.
*/
// pending(scott): make sure childindexs is sorted!
if  changedparent    null
if  changedindexs    null     maxcounter   changedindexs length  > 0
object parentvalue   changedparent getuserobject
for  int counter   0  counter < maxcounter  counter
treestatenode child   changedparent
getchildatmodelindex changedindexs
if  child    null
child setuserobject treemodel getchild parentvalue
changedindexs
if  changedparent isvisible      changedparent isexpanded
visiblenodeschanged
// null for root indicates it changed.
else if  changedparent    root
changedparent isvisible      changedparent isexpanded
visiblenodeschanged
/**
* <p>
* invoked after nodes have been inserted into the tree.
* </p>
* <p>
* e.path() returns the parent of the new nodes
* <p>
* e.childindices() returns the indices of the new nodes in ascending order.
*
* @param e
*			  the tree model event
*/
public void treenodesinserted treemodelevent e
if  e    null
int changedindexs
treestatenode changedparent   getnodeforpath e gettreepath    false  false
int maxcounter
changedindexs   e getchildindices
/*
* only need to update the children if the node has been expanded
* once.
*/
// pending(scott): make sure childindexs is sorted!
if  changedparent    null
changedindexs    null     maxcounter   changedindexs length  > 0
boolean isvisible    changedparent isvisible      changedparent
isexpanded
for  int counter   0  counter < maxcounter  counter
changedparent childinsertedatmodelindex changedindexs
isvisible
if  isvisible    treeselectionmodel    null
treeselectionmodel resetrowselection
if  changedparent isvisible
this visiblenodeschanged
/**
* <p>
* invoked after nodes have been removed from the tree. note that if a
* subtree is removed from the tree, this method may only be invoked once
* for the root of the removed subtree, not once for each individual set of
* siblings removed.
* </p>
* <p>
* e.path() returns the former parent of the deleted nodes.
* </p>
* <p>
* e.childindices() returns the indices the nodes had before they were
* deleted in ascending order.
* </p>
*
* @param e
*			  the tree model event
*/
public void treenodesremoved treemodelevent e
if  e    null
int changedindexs
int maxcounter
treepath parentpath   e gettreepath
treestatenode changedparentnode   getnodeforpath parentpath  false  false
changedindexs   e getchildindices
// pending(scott): make sure that changedindexs are sorted in
// ascending order.
if  changedparentnode    null
changedindexs    null     maxcounter   changedindexs length  > 0
boolean isvisible    changedparentnode isvisible      changedparentnode
isexpanded
for  int counter   maxcounter   1  counter >  0  counter
changedparentnode removechildatmodelindex changedindexs
isvisible
if  isvisible
if  treeselectionmodel    null
treeselectionmodel resetrowselection
if  treemodel getchildcount changedparentnode getuserobject       0
changedparentnode isleaf
// node has become a leaf, collapse it.
changedparentnode collapse false
visiblenodeschanged
else if  changedparentnode isvisible
visiblenodeschanged
/**
* <p>
* invoked after the tree has drastically changed structure from a given
* node down. if the path returned by e.getpath() is of length one and the
* first element does not identify the current root node the first element
* should become the new root of the tree.
* <p>
* <p>
* e.path() holds the path to the node.
* </p>
* <p>
* e.childindices() returns null.
* </p>
*
* @param e
*			  the tree model event
*/
public void treestructurechanged treemodelevent e
if  e    null
treepath changedpath   e gettreepath
treestatenode changednode   getnodeforpath changedpath  false  false
// check if root has changed, either to a null root, or
// to an entirely new root.
if  changednode    root
changednode    null      changedpath    null    treemodel    null    treemodel
getroot      null      changedpath    null    changedpath
getpathcount   <  1
rebuild true
else if  changednode    null
boolean wasexpanded  wasvisible
treestatenode parent    treestatenode  changednode getparent
wasexpanded   changednode isexpanded
wasvisible   changednode isvisible
int index   parent getindex changednode
changednode collapse false
parent remove index
if  wasvisible    wasexpanded
int row   changednode getrow
parent resetchildrenrowsfrom row  index  changednode getchildindex
changednode   getnodeforpath changedpath  false  true
changednode expand
if  treeselectionmodel    null    wasvisible    wasexpanded
treeselectionmodel resetrowselection
if  wasvisible
this visiblenodeschanged
//
// local methods
//
/**
* called when the visibility of nodes changed.
*/
private void visiblenodeschanged
/**
* adjust the large row count.
*
* @param change
*			  the change for the row count
*/
private void adjustrowcountby int change
rowcount    change
/**
* adds a mapping for node.
*
* @param node
*			  the node to map
*/
private void addmapping treestatenode node
treepathmapping put node gettreepath    node
/**
* removes the mapping for a previously added node.
*
* @param node
*			  the node to remove the mapping for
*/
private void removemapping treestatenode node
treepathmapping remove node gettreepath
/**
* returns the node previously added for <code>path</code>. this may
* return null, if you to create a node use getnodeforpath.
*
* @param path
*			  the path
* @return the state node
*/
private treestatenode getmapping treepath path
return  treestatenode  treepathmapping get path
/**
* sent to completely rebuild the visible tree. all nodes are collapsed.
*
* @param clearselection
*			  whether to clear the selection
*/
private void rebuild boolean clearselection
object rootuo
treepathmapping clear
if  treemodel    null     rootuo   treemodel getroot       null
root   createnodeforvalue rootuo  0
root path   new treepath rootuo
addmapping root
if  isrootvisible
rowcount   1
root row   0
else
rowcount   0
root row    1
root expand
else
root   null
rowcount   0
if  clearselection    treeselectionmodel    null
treeselectionmodel clearselection
this visiblenodeschanged
/**
* ensures that all the path components in path are expanded, accept for the
* last component which will only be expanded if expandlast is true. returns
* true if succesful in finding the path.
*
* @param apath
*			  the path
* @param expandlast
*			  whether to expand the last element
* @return true if succesful in finding the path
*/
private boolean ensurepathisexpanded treepath apath  boolean expandlast
if  apath    null
// make sure the last entry isn't a leaf.
if  treemodel isleaf apath getlastpathcomponent
apath   apath getparentpath
expandlast   true
if  apath    null
treestatenode lastnode   getnodeforpath apath  false  true
if  lastnode    null
lastnode makevisible
if  expandlast
lastnode expand
return true
return false
/**
* creates and returns an instance of treestatenode.
*
* @param userobject
*			  the user object
* @param childindex
*			  the index relative to the parent
* @return the tree state node
*/
private treestatenode createnodeforvalue object userobject  int childindex
return new treestatenode userobject  childindex   1
/**
* messages gettreenodeforpage(path, onlyifvisible, shouldcreate,
* path.length) as long as path is non-null and the length is > 0. otherwise
* returns null.
*
* @param path
*			  the path
* @param onlyifvisible
* @param shouldcreate
* @return the tree state node
*/
private treestatenode getnodeforpath treepath path  boolean onlyifvisible
boolean shouldcreate
if  path    null
treestatenode node
node   getmapping path
if  node    null
if  onlyifvisible     node isvisible
return null
return node
if  onlyifvisible
return null
// check all the parent paths, until a match is found.
arrayliststack paths
if  tempstacks size      0
paths   new arrayliststack
else
paths    arrayliststack tempstacks pop
try
paths push path
path   path getparentpath
while  path    null
node   getmapping path
if  node    null
// found a match, create entries for all paths in
// paths.
while  node    null    paths size   > 0
path    treepath  paths pop
node   node createchildfor path getlastpathcomponent
return node
paths push path
path   path getparentpath
finally
paths clear
tempstacks push paths
// if we get here it means they share a different root!
return null
return null
/**
* treestatenode is used to track what has been expanded.
*/
private final class treestatenode extends defaultmutabletreenode
private static final long serialversionuid   1l
/** whether this node is expanded */
private boolean isexpanded
/** index of this node from the model. */
private int childindex
/** child count of the receiver. */
private int childcount
/**
* row of the receiver. this is only valid if the row is expanded.
*/
private int row
/** path of this node. */
private treepath path
/**
* construct.
*
* @param userobject
* @param childindex
* @param row
*/
public treestatenode object userobject  int childindex  int row
super userobject
this childindex   childindex
this row   row
//
// overriden defaultmutabletreenode methods
//
/**
* messaged when this node is added somewhere, resets the path and adds
* a mapping from path to this node.
*
* @param parent
*			  the parent
*/
public void setparent mutabletreenode parent
super setparent parent
if  parent    null
path     treestatenode  parent  gettreepath   pathbyaddingchild
getuserobject
addmapping this
/**
* messaged when this node is removed from its parent, this messages
* <code>removedfrommapping</code> to remove all the children.
*
* @param childindex
*			  the index of this node relative to its parent
*/
public void remove int childindex
treestatenode node    treestatenode  getchildat childindex
node removefrommapping
super remove childindex
/**
* messaged to set the user object. this resets the path.
*
* @param o
*			  the user object
*/
public void setuserobject object o
super setuserobject o
if  path    null
treestatenode parent    treestatenode  getparent
if  parent    null
resetchildrenpaths parent gettreepath
else
resetchildrenpaths null
//
//
/**
* returns the index of the receiver in the model.
*
* @return the index of this node relative to its parent
*/
public int getchildindex
return childindex
/**
* returns the <code>treepath</code> of the receiver.
*
* @return the tree path
*/
public treepath gettreepath
return path
/**
* returns the child for the passed in model index, this will return
* <code>null</code> if the child for <code>index</code> has not yet
* been created (expanded).
*
* @param index
*			  the childs index
* @return the tree state node
*/
public treestatenode getchildatmodelindex int index
// pending: make this a binary search!
for  int counter   getchildcount     1  counter >  0  counter
if    treestatenode  getchildat counter   childindex    index
return  treestatenode  getchildat counter
return null
/**
* returns true if this node is visible. this is determined by asking
* all the parents if they are expanded.
*
* @return true if this node is visible
*/
public boolean isvisible
treestatenode parent    treestatenode  getparent
if  parent    null
return true
return  parent isexpanded      parent isvisible
/**
* returns the row of the receiver.
*
* @return the row of the receiver
*/
public int getrow
return row
/**
* returns the row of the child with a model index of <code>index</code>.
*
* @param index
*			  the model index
* @return the row of the child with a model index of <code>index</code>
*/
public int getrowtomodelindex int index
treestatenode child
// this too could be a binary search!
for  int counter   0  maxcounter   getchildcount    counter < maxcounter  counter
child    treestatenode  getchildat counter
if  child childindex >  index
if  child childindex    index
return child row
if  counter    0
return getrow     1   index
return child row    child childindex   index
// yeck!
return getrow     1   gettotalchildcount      childcount   index
/**
* returns the number of children in the receiver by descending all
* expanded nodes and messaging them with gettotalchildcount.
*
* @return the number of children in the receiver by descending all
*		   expanded nodes and messaging them with gettotalchildcount
*/
public int gettotalchildcount
if  isexpanded
treestatenode parent    treestatenode  getparent
int pindex
if  parent    null
pindex   parent getindex this     1 < parent getchildcount
// this node has a created sibling, to calc total
// child count directly from that!
treestatenode nextsibling    treestatenode  parent
getchildat pindex   1
return nextsibling row   row    nextsibling childindex   childindex
else
int retcount   childcount
for  int counter   getchildcount     1  counter >  0  counter
retcount      treestatenode  getchildat counter
gettotalchildcount
return retcount
return 0
/**
* returns true if this node is expanded.
*
* @return true if this node is expanded
*/
public boolean isexpanded
return isexpanded
/**
* the highest visible nodes have a depth of 0.
*
* @return the level of visibility
*/
public int getvisiblelevel
if  isrootvisible
return getlevel
else
return getlevel     1
/**
* recreates the receivers path, and all its childrens paths.
*
* @param parentpath
*			  the parent of the path to recreate
*/
private void resetchildrenpaths treepath parentpath
removemapping this
if  parentpath    null
path   new treepath getuserobject
else
path   parentpath pathbyaddingchild getuserobject
addmapping this
for  int counter   getchildcount     1  counter >  0  counter
treestatenode  getchildat counter   resetchildrenpaths path
/**
* removes the receiver, and all its children, from the mapping table.
*/
private void removefrommapping
if  path    null
removemapping this
for  int counter   getchildcount     1  counter >  0  counter
treestatenode  getchildat counter   removefrommapping
/**
* creates a new node to represent <code>userobject</code>. this does
* not check to ensure there isn't already a child node to manage
* <code>userobject</code>.
*
* @param userobject
*			  the user object of the new node
* @return the new node
*/
private treestatenode createchildfor object userobject
int newchildindex   treemodel getindexofchild getuserobject    userobject
if  newchildindex < 0
return null
treestatenode anode
treestatenode child   createnodeforvalue userobject  newchildindex
int childrow
if  isvisible
childrow   getrowtomodelindex newchildindex
else
childrow    1
child row   childrow
for  int counter   0  maxcounter   getchildcount    counter < maxcounter  counter
anode    treestatenode  getchildat counter
if  anode childindex > newchildindex
insert child  counter
return child
add child
return child
/**
* adjusts the receiver, and all its children rows by
* <code>adjust</code>.
*
* @param adjust
*			  adjustement
*/
private void adjustrowby int adjust
row    adjust
if  isexpanded
for  int counter   getchildcount     1  counter >  0  counter
treestatenode  getchildat counter   adjustrowby adjust
/**
* adjusts this node, its child, and its parent starting at an index of
* <code>startindex</code> index is the index of the child to start
* adjusting from, which is not necessarily the model index.
*
* @param adjust
* @param startindex
*/
private void adjustrowby int adjust  int startindex
// could check isvisible, but probably isn't worth it.
if  isexpanded
// children following startindex.
for  int counter   getchildcount     1  counter >  startindex  counter
treestatenode  getchildat counter   adjustrowby adjust
// parent
treestatenode parent    treestatenode  getparent
if  parent    null
parent adjustrowby adjust  parent getindex this    1
/**
* messaged when the node has expanded. this updates all of the
* receivers children rows, as well as the total row count.
*/
private void didexpand
int nextrow   setrowandchildren row
treestatenode parent    treestatenode  getparent
int childrowcount   nextrow   row   1
if  parent    null
parent adjustrowby childrowcount  parent getindex this    1
adjustrowcountby childrowcount
/**
* sets the receivers row to <code>nextrow</code> and recursively
* updates all the children of the receivers rows. the index the next
* row is to be placed as is returned.
*
* @param nextrow
* @return the index the next row is to be placed
*/
private int setrowandchildren int nextrow
row   nextrow
if   isexpanded
return row   1
int lastrow   row   1
int lastmodelindex   0
treestatenode child
int maxcounter   getchildcount
for  int counter   0  counter < maxcounter  counter
child    treestatenode  getchildat counter
lastrow     child childindex   lastmodelindex
lastmodelindex   child childindex   1
if  child isexpanded
lastrow   child setrowandchildren lastrow
else
child row   lastrow
return lastrow   childcount   lastmodelindex
/**
* resets the receivers childrens rows. starting with the child at
* <code>childindex</code> (and <code>modelindex</code>) to
* <code>newrow</code>. this uses <code>setrowandchildren</code> to
* recursively descend children, and uses <code>resetrowselection</code>
* to ascend parents.
*
* @param newrow
* @param childindex
* @param modelindex
*/
// this can be rather expensive, but is needed for the collapse
// case this is resulting from a remove (although i could fix
// that by having instances of treestatenode hold a ref to
// the number of children). i prefer this though, making determing
// the row of a particular node fast is very nice!
private void resetchildrenrowsfrom int newrow  int childindex  int modelindex
int lastrow   newrow
int lastmodelindex   modelindex
treestatenode node
int maxcounter   getchildcount
for  int counter   childindex  counter < maxcounter  counter
node    treestatenode  getchildat counter
lastrow     node childindex   lastmodelindex
lastmodelindex   node childindex   1
if  node isexpanded
lastrow   node setrowandchildren lastrow
else
node row   lastrow
lastrow    childcount   lastmodelindex
node    treestatenode  getparent
if  node    null
node resetchildrenrowsfrom lastrow  node getindex this    1
this childindex   1
else
this is the root  reset total rowcount
rowcount   lastrow
/**
* makes the receiver visible, but invoking
* <code>expandparentandreceiver</code> on the superclass.
*/
private void makevisible
treestatenode parent    treestatenode  getparent
if  parent    null
parent expandparentandreceiver
/**
* invokes <code>expandparentandreceiver</code> on the parent, and
* expands the receiver.
*/
private void expandparentandreceiver
treestatenode parent    treestatenode  getparent
if  parent    null
parent expandparentandreceiver
expand
/**
* expands the receiver.
*/
private void expand
if   isexpanded     isleaf
boolean visible   isvisible
isexpanded   true
childcount   treemodel getchildcount getuserobject
if  visible
didexpand
// update the selection model.
if  visible    treeselectionmodel    null
treeselectionmodel resetrowselection
/**
* collapses the receiver. if <code>adjustrows</code> is true, the
* rows of nodes after the receiver are adjusted.
*
* @param adjustrows
*			  whether to adjust the rows of the receiver
*/
private void collapse boolean adjustrows
if  isexpanded
if  isvisible      adjustrows
int childcount   gettotalchildcount
isexpanded   false
adjustrowcountby  childcount
// we can do this because adjustrowby won't descend
// the children.
adjustrowby  childcount  0
else
isexpanded   false
if  adjustrows    isvisible      treeselectionmodel    null
treeselectionmodel resetrowselection
/**
* returns true if the receiver is a leaf.
*
* @return true if the receiver is a leaf
*/
public boolean isleaf
treemodel model   getmodel
return  model    null  ? model isleaf this getuserobject      true
/**
* adds newchild to this nodes children at the appropriate location. the
* location is determined from the childindex of newchild.
*
* @param newchild
*			  the node to add
*/
//		private void addnode(treestatenode newchild)
//		{
//			boolean added = false;
//			int childindex = newchild.getchildindex();
//
//			for (int counter = 0, maxcounter = getchildcount(); counter < maxcounter; counter++)
//			{
//				if (((treestatenode) getchildat(counter)).getchildindex() > childindex)
//				{
//					added = true;
//					insert(newchild, counter);
//					counter = maxcounter;
//				}
//			}
//			if (!added)
//				add(newchild);
//		}
/**
* removes the child at <code>modelindex</code>.
* <code>ischildvisible</code> should be true if the receiver is
* visible and expanded.
*
* @param modelindex
* @param ischildvisible
*/
private void removechildatmodelindex int modelindex  boolean ischildvisible
treestatenode childnode   getchildatmodelindex modelindex
if  childnode    null
int row   childnode getrow
int index   getindex childnode
childnode collapse false
remove index
adjustchildindexs index   1
childcount
if  ischildvisible
// adjust the rows.
resetchildrenrowsfrom row  index  modelindex
else
int maxcounter   getchildcount
treestatenode achild
for  int counter   0  counter < maxcounter  counter
achild    treestatenode  getchildat counter
if  achild childindex >  modelindex
if  ischildvisible
adjustrowby  1  counter
adjustrowcountby  1
// since matched and children are always sorted by
// index, no need to continue testing with the
// above.
for    counter < maxcounter  counter
treestatenode  getchildat counter   childindex
childcount
return
// no children to adjust, but it was a child, so we still need
// to adjust nodes after this one.
if  ischildvisible
adjustrowby  1  maxcounter
adjustrowcountby  1
childcount
/**
* adjusts the child indexs of the receivers children by
* <code>adjust</code>, starting at <code>index</code>.
*
* @param index
* @param adjust
*/
private void adjustchildindexs int index  int adjust
for  int counter   index  maxcounter   getchildcount    counter < maxcounter  counter
treestatenode  getchildat counter   childindex    adjust
/**
* messaged when a child has been inserted at index. for all the
* children that have a childindex >= index their index is incremented
* by one.
*
* @param index
*			  the insertion index
* @param isexpandedandvisible
*/
private void childinsertedatmodelindex int index  boolean isexpandedandvisible
treestatenode achild
int maxcounter   getchildcount
for  int counter   0  counter < maxcounter  counter
achild    treestatenode  getchildat counter
if  achild childindex >  index
if  isexpandedandvisible
adjustrowby 1  counter
adjustrowcountby 1
/*
* since matched and children are always sorted by index, no
* need to continue testing with the above.
*/
for    counter < maxcounter  counter
treestatenode  getchildat counter   childindex
childcount
return
// no children to adjust, but it was a child, so we still need
// to adjust nodes after this one.
if  isexpandedandvisible
adjustrowby 1  maxcounter
adjustrowcountby 1
childcount
/**
* returns true if there is a row for <code>row</code>.
* <code>nextrow</code> gives the bounds of the receiver. information
* about the found row is returned in <code>info</code>. this should
* be invoked on root with <code>nextrow</code> set to
* <code>getrowcount</code> ().
*
* @param row
* @param nextrow
* @param info
*			  search info object
* @return true if there is a row for <code>row</code>
*/
private boolean getpathforrow int row  int nextrow  searchinfo info
if  this row    row
info node   this
info isnodeparentnode   false
info childindex   childindex
return true
treestatenode child
treestatenode lastchild   null
for  int counter   0  maxcounter   getchildcount    counter < maxcounter  counter
child    treestatenode  getchildat counter
if  child row > row
if  counter    0
// no node exists for it, and is first.
info node   this
info isnodeparentnode   true
info childindex   row   this row   1
return true
else
// may have been in last childs bounds.
int lastchildendrow   1
child row    child childindex   lastchild childindex
if  row < lastchildendrow
return lastchild getpathforrow row  lastchildendrow  info
// between last child and child, but not in last child
info node   this
info isnodeparentnode   true
info childindex   row
lastchildendrow   lastchild childindex   1
return true
lastchild   child
// not in children, but we should have it, offset from
// nextrow.
if  lastchild    null
int lastchildendrow   nextrow    childcount   lastchild childindex    1
if  row < lastchildendrow
return lastchild getpathforrow row  lastchildendrow  info
// between last child and child, but not in last child
info node   this
info isnodeparentnode   true
info childindex   row   lastchildendrow   lastchild childindex   1
return true
else
// no children.
int retchildindex   row   this row   1
if  retchildindex >  childcount
return false
info node   this
info isnodeparentnode   true
info childindex   retchildindex
return true
/**
* asks all the children of the receiver for their totalchildcount and
* returns this value (plus stopindex).
*
* @param stopindex
*			  index to stop on
* @return childcount of all children of the receiver
*/
//		private int getcountto(int stopindex)
//		{
//			treestatenode achild;
//			int retcount = stopindex + 1;
//
//			for (int counter = 0, maxcounter = getchildcount(); counter < maxcounter; counter++)
//			{
//				achild = (treestatenode) getchildat(counter);
//				if (achild.childindex >= stopindex)
//					counter = maxcounter;
//				else
//					retcount += achild.gettotalchildcount();
//			}
//			if (parent != null)
//				return retcount + ((treestatenode) getparent()).getcountto(childindex);
//			if (!isrootvisible())
//				return (retcount - 1);
//			return retcount;
//		}
/**
* returns the number of children that are expanded to
* <code>stopindex</code>. this does not include the number of
* children that the child at <code>stopindex</code> might have.
*
* @param stopindex
*			  index to stop on
* @return the number of children that are expanded to
*		   <code>stopindex</code>
*/
//		private int getnumexpandedchildrento(int stopindex)
//		{
//			treestatenode achild;
//			int retcount = stopindex;
//
//			for (int counter = 0, maxcounter = getchildcount(); counter < maxcounter; counter++)
//			{
//				achild = (treestatenode) getchildat(counter);
//				if (achild.childindex >= stopindex)
//					return retcount;
//				else
//				{
//					retcount += achild.gettotalchildcount();
//				}
//			}
//			return retcount;
//		}
/**
* messaged when this node either expands or collapses.
*/
//		private void didadjusttree()
//		{
//		}
/**
* used as a placeholder when getting the path in fhtreestatenodes.
*/
private final class searchinfo implements iclusterable
private static final long serialversionuid   1l
private treestatenode node
private boolean isnodeparentnode
private int childindex
private treepath getpath
if  node    null
return null
if  isnodeparentnode
return node gettreepath   pathbyaddingchild
treemodel getchild node getuserobject    childindex
return node path
/**
* an enumerator to iterate through visible nodes.
*/
private final class visibletreestatenodeenumeration implements enumeration
/** parent thats children are being enumerated. */
private treestatenode parent
/**
* index of next child. an index of -1 signifies parent should be
* visibled next.
*/
private int nextindex
/** number of children in parent. */
private int childcount
private visibletreestatenodeenumeration treestatenode node
this node   1
private visibletreestatenodeenumeration treestatenode parent  int startindex
this parent   parent
this nextindex   startindex
this childcount   treemodel getchildcount this parent getuserobject
/**
* @return true if more visible nodes.
*/
public boolean hasmoreelements
return  parent    null
/**
* @return next visible treepath.
*/
public object nextelement
if   hasmoreelements
throw new nosuchelementexception
treepath retobject
if  nextindex     1
retobject   parent gettreepath
else
treestatenode node   parent getchildatmodelindex nextindex
if  node    null
retobject   parent gettreepath   pathbyaddingchild
treemodel getchild parent getuserobject    nextindex
else
retobject   node gettreepath
updatenextobject
return retobject
/**
* determines the next object by invoking <code>updatenextindex</code>
* and if not succesful <code>findnextvalidparent</code>.
*/
private void updatenextobject
if   updatenextindex
findnextvalidparent
/**
* finds the next valid parent, this should be called when nextindex is
* beyond the number of children of the current parent.
*
* @return whether there is a next valid parent
*/
private boolean findnextvalidparent
if  parent    root
// mark as invalid!
parent   null
return false
while  parent    null
treestatenode newparent    treestatenode  parent getparent
if  newparent    null
nextindex   parent childindex
parent   newparent
childcount   treemodel getchildcount parent getuserobject
if  updatenextindex
return true
else
parent   null
return false
/**
* updates <code>nextindex</code> returning false if it is beyond the
* number of children of parent.
*
* @return false if it is beyond the number of children of parent
*/
private boolean updatenextindex
// nextindex == -1 identifies receiver, make sure is expanded
// before descend.
if  nextindex     1     parent isexpanded
return false
// check that it can have kids
if  childcount    0
return false
// make sure next index not beyond child count.
else if    nextindex >  childcount
return false
treestatenode child   parent getchildatmodelindex nextindex
if  child    null    child isexpanded
parent   child
nextindex    1
childcount   treemodel getchildcount child getuserobject
return true