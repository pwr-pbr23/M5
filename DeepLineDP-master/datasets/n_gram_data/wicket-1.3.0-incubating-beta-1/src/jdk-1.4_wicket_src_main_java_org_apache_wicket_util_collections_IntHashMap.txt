/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket util collections
import java io ioexception
import java io serializable
import java util abstractcollection
import java util abstractset
import java util collection
import java util concurrentmodificationexception
import java util iterator
import java util map
import java util nosuchelementexception
import java util set
/**
* this is a int hashmap that has the exact same features and interface as a
* normal map except that the key is directly an integer. so no hash is
* calculated or key object is stored.
*
* @author jcompagner
*/
public class inthashmap implements cloneable  serializable
transient volatile set keyset   null
transient volatile collection values   null
/**
* the default initial capacity - must be a power of two.
*/
static final int default_initial_capacity   16
/**
* the maximum capacity, used if a higher value is implicitly specified by
* either of the constructors with arguments. must be a power of two <= 1<<30.
*/
static final int maximum_capacity   1 << 30
/**
* the load factor used when none specified in constructor.
*/
static final float default_load_factor   0 75f
/**
* the table, resized as necessary. length must always be a power of two.
*/
transient entry table
/**
* the number of key-value mappings contained in this identity hash map.
*/
transient int size
/**
* the next size value at which to resize (capacity * load factor).
*
* @serial
*/
int threshold
/**
* the load factor for the hash table.
*
* @serial
*/
final float loadfactor
/**
* the number of times this hashmap has been structurally modified
* structural modifications are those that change the number of mappings in
* the hashmap or otherwise modify its internal structure (e.g., rehash).
* this field is used to make iterators on collection-views of the hashmap
* fail-fast. (see concurrentmodificationexception).
*/
transient volatile int modcount
/**
* constructs an empty <tt>hashmap</tt> with the specified initial
* capacity and load factor.
*
* @param initialcapacity
*            the initial capacity.
* @param loadfactor
*            the load factor.
* @throws illegalargumentexception
*             if the initial capacity is negative or the load factor is
*             nonpositive.
*/
public inthashmap int initialcapacity  float loadfactor
if  initialcapacity < 0
throw new illegalargumentexception       $non nls 1$
initialcapacity
if  initialcapacity > maximum_capacity
initialcapacity   maximum_capacity
if  loadfactor <  0    float isnan loadfactor
throw new illegalargumentexception       $non nls 1$
loadfactor
// find a power of 2 >= initialcapacity
int capacity   1
while  capacity < initialcapacity
capacity <<  1
this loadfactor   loadfactor
threshold    int  capacity   loadfactor
table   new entry
init
/**
* constructs an empty <tt>hashmap</tt> with the specified initial
* capacity and the default load factor (0.75).
*
* @param initialcapacity
*            the initial capacity.
* @throws illegalargumentexception
*             if the initial capacity is negative.
*/
public inthashmap int initialcapacity
this initialcapacity  default_load_factor
/**
* constructs an empty <tt>hashmap</tt> with the default initial capacity
* (16) and the default load factor (0.75).
*/
public inthashmap
this loadfactor   default_load_factor
threshold    int  default_initial_capacity   default_load_factor
table   new entry
init
// internal utilities
/**
* initialization hook for subclasses. this method is called in all
* constructors and pseudo-constructors (clone, readobject) after hashmap
* has been initialized but before any entries have been inserted. (in the
* absence of this method, readobject would require explicit knowledge of
* subclasses.)
*/
void init
/**
* returns index for hash code h.
*
* @param h
* @param length
* @return the index for the hash integer for the given length
*/
static int indexfor int h  int length
return h    length   1
/**
* returns the number of key-value mappings in this map.
*
* @return the number of key-value mappings in this map.
*/
public int size
return size
/**
* returns <tt>true</tt> if this map contains no key-value mappings.
*
* @return <tt>true</tt> if this map contains no key-value mappings.
*/
public boolean isempty
return size    0
/**
* returns the value to which the specified key is mapped in this identity
* hash map, or <tt>null</tt> if the map contains no mapping for this key.
* a return value of <tt>null</tt> does not <i>necessarily</i> indicate
* that the map contains no mapping for the key; it is also possible that
* the map explicitly maps the key to <tt>null</tt>. the
* <tt>containskey</tt> method may be used to distinguish these two cases.
*
* @param key
*            the key whose associated value is to be returned.
* @return the value to which this map maps the specified key, or
*         <tt>null</tt> if the map contains no mapping for this key.
* @see #put(int, object)
*/
public object get int key
int i   indexfor key  table length
entry e   table
while  true
if  e    null
return e
if  key    e key
return e value
e   e next
/**
* returns <tt>true</tt> if this map contains a mapping for the specified
* key.
*
* @param key
*            the key whose presence in this map is to be tested
* @return <tt>true</tt> if this map contains a mapping for the specified
*         key.
*/
public boolean containskey int key
int i   indexfor key  table length
entry e   table
while  e    null
if  key    e key
return true
e   e next
return false
/**
* returns the entry associated with the specified key in the hashmap.
* returns null if the hashmap contains no mapping for this key.
*
* @param key
* @return the entry object for the given hash key
*/
entry getentry int key
int i   indexfor key  table length
entry e   table
while  e    null      key    e key
e   e next
return e
/**
* associates the specified value with the specified key in this map. if the
* map previously contained a mapping for this key, the old value is
* replaced.
*
* @param key
*            key with which the specified value is to be associated.
* @param value
*            value to be associated with the specified key.
* @return previous value associated with specified key, or <tt>null</tt>
*         if there was no mapping for key. a <tt>null</tt> return can
*         also indicate that the hashmap previously associated
*         <tt>null</tt> with the specified key.
*/
public object put int key  object value
int i   indexfor key  table length
for  entry e   table  e    null  e   e next
if  key    e key
object oldvalue   e value
e value   value
return oldvalue
modcount
addentry key  value  i
return null
/**
* this method is used instead of put by constructors and pseudoconstructors
* (clone, readobject). it does not resize the table, check for
* comodification, etc. it calls createentry rather than addentry.
*
* @param key
* @param value
*/
private void putforcreate int key  object value
int i   indexfor key  table length
/**
* look for preexisting entry for key. this will never happen for clone
* or deserialize. it will only happen for construction if the input map
* is a sorted map whose ordering is inconsistent w/ equals.
*/
for  entry e   table  e    null  e   e next
if  key    e key
e value   value
return
createentry key  value  i
void putallforcreate inthashmap m
for  iterator i   m entryset   iterator    i hasnext
entry e    entry i next
putforcreate e getkey    e getvalue
/**
* rehashes the contents of this map into a new array with a larger
* capacity. this method is called automatically when the number of keys in
* this map reaches its threshold.
*
* if current capacity is maximum_capacity, this method does not resize the
* map, but but sets threshold to integer.max_value. this has the effect of
* preventing future calls.
*
* @param newcapacity
*            the new capacity, must be a power of two; must be greater than
*            current capacity unless current capacity is maximum_capacity
*            (in which case value is irrelevant).
*/
void resize int newcapacity
entry oldtable   table
int oldcapacity   oldtable length
if  oldcapacity    maximum_capacity
threshold   integer max_value
return
entry newtable   new entry
transfer newtable
table   newtable
threshold    int  newcapacity   loadfactor
/**
* transfer all entries from current table to newtable.
*
* @param newtable
*/
void transfer entry newtable
entry src   table
int newcapacity   newtable length
for  int j   0  j < src length  j
entry e   src
if  e    null
src   null
do
entry next   e next
int i   indexfor e key  newcapacity
e next   newtable
newtable   e
e   next
while  e    null
/**
* copies all of the mappings from the specified map to this map these
* mappings will replace any mappings that this map had for any of the keys
* currently in the specified map.
*
* @param m
*            mappings to be stored in this map.
* @throws nullpointerexception
*             if the specified map is null.
*/
public void putall inthashmap m
int numkeystobeadded   m size
if  numkeystobeadded    0
return
/*
* expand the map if the map if the number of mappings to be added is
* greater than or equal to threshold. this is conservative; the obvious
* condition is (m.size() + size) >= threshold, but this condition could
* result in a map with twice the appropriate capacity, if the keys to
* be added overlap with the keys already in this map. by using the
* conservative calculation, we subject ourself to at most one extra
* resize.
*/
if  numkeystobeadded > threshold
int targetcapacity    int  numkeystobeadded   loadfactor   1
if  targetcapacity > maximum_capacity
targetcapacity   maximum_capacity
int newcapacity   table length
while  newcapacity < targetcapacity
newcapacity <<  1
if  newcapacity > table length
resize newcapacity
for  iterator i   m entryset   iterator    i hasnext
entry e    entry i next
put e getkey    e getvalue
/**
* removes the mapping for this key from this map if present.
*
* @param key
*            key whose mapping is to be removed from the map.
* @return previous value associated with specified key, or <tt>null</tt>
*         if there was no mapping for key. a <tt>null</tt> return can
*         also indicate that the map previously associated <tt>null</tt>
*         with the specified key.
*/
public object remove int key
entry e   removeentryforkey key
return  e    null ? e   e value
/**
* removes and returns the entry associated with the specified key in the
* hashmap. returns null if the hashmap contains no mapping for this key.
*
* @param key
* @return the entry object that was removed
*/
entry removeentryforkey int key
int i   indexfor key  table length
entry prev   table
entry e   prev
while  e    null
entry next   e next
if  key    e key
modcount
size
if  prev    e
table   next
else
prev next   next
return e
prev   e
e   next
return e
/**
* special version of remove for entryset.
*
* @param o
* @return the entry that was removed
*/
entry removemapping object o
if    o instanceof entry
return null
entry entry    entry o
int key   entry getkey
int i   indexfor key  table length
entry prev   table
entry e   prev
while  e    null
entry next   e next
if  e key    key    e equals entry
modcount
size
if  prev    e
table   next
else
prev next   next
return e
prev   e
e   next
return e
/**
* removes all mappings from this map.
*/
public void clear
modcount
entry tab   table
for  int i   0  i < tab length  i
tab   null
size   0
/**
* returns <tt>true</tt> if this map maps one or more keys to the
* specified value.
*
* @param value
*            value whose presence in this map is to be tested.
* @return <tt>true</tt> if this map maps one or more keys to the
*         specified value.
*/
public boolean containsvalue object value
if  value    null
return containsnullvalue
entry tab   table
for  int i   0  i < tab length  i
for  entry e   tab  e    null  e   e next
if  value equals e value
return true
return false
/**
* special-case code for containsvalue with null argument
*
* @return boolean true if there is a null value in this map
*/
private boolean containsnullvalue
entry tab   table
for  int i   0  i < tab length  i
for  entry e   tab  e    null  e   e next
if  e value    null
return true
return false
/**
* returns a shallow copy of this <tt>hashmap</tt> instance: the keys and
* values themselves are not cloned.
*
* @return a shallow copy of this map.
*/
public object clone   throws clonenotsupportedexception
inthashmap result   null
try
result    inthashmap super clone
result table   new entry
result entryset   null
result modcount   0
result size   0
result init
result putallforcreate this
catch  clonenotsupportedexception e
// assert false;
return result
/**
* @author jcompagner
*/
public static class entry
final int key
object value
entry next
/**
* create new entry.
*
* @param k
* @param v
* @param n
*/
entry int k  object v  entry n
value   v
next   n
key   k
/**
* @return the int key of this entry
*/
public int getkey
return key
/**
* @return gets the value object of this entry
*/
public object getvalue
return value
/**
* @param newvalue
* @return the previous value
*/
public object setvalue object newvalue
object oldvalue   value
value   newvalue
return oldvalue
/**
* @see java.lang.object#equals(java.lang.object)
*/
public boolean equals object o
if    o instanceof entry
return false
entry e    entry o
int k1   getkey
int k2   e getkey
if  k1    k2
object v1   getvalue
object v2   e getvalue
if  v1    v2     v1    null    v1 equals v2
return true
return false
/**
* @see java.lang.object#hashcode()
*/
public int hashcode
return key ^  value    null ? 0   value hashcode
/**
* @see java.lang.object#tostring()
*/
public string tostring
return getkey         getvalue      $non nls 1$
/**
* add a new entry with the specified key, value and hash code to the
* specified bucket. it is the responsibility of this method to resize the
* table if appropriate.
*
* subclass overrides this to alter the behavior of put method.
*
* @param key
* @param value
* @param bucketindex
*/
void addentry int key  object value  int bucketindex
table   new entry key  value  table
if  size   >  threshold
resize 2   table length
/**
* like addentry except that this version is used when creating entries as
* part of map construction or "pseudo-construction" (cloning,
* deserialization). this version needn't worry about resizing the table.
*
* subclass overrides this to alter the behavior of hashmap(map), clone, and
* readobject.
*
* @param key
* @param value
* @param bucketindex
*/
void createentry int key  object value  int bucketindex
table   new entry key  value  table
size
private abstract class hashiterator implements iterator
entry next     next entry to return
int expectedmodcount     for fast fail
int index     current slot
entry current     current entry
hashiterator
expectedmodcount   modcount
entry t   table
int i   t length
entry n   null
if  size    0
advance to first entry
while  i > 0     n   t     null
noop
next   n
index   i
/**
* @see java.util.iterator#hasnext()
*/
public boolean hasnext
return next    null
entry nextentry
if  modcount    expectedmodcount
throw new concurrentmodificationexception
entry e   next
if  e    null
throw new nosuchelementexception
entry n   e next
entry t   table
int i   index
while  n    null    i > 0
n   t
index   i
next   n
return current   e
/**
* @see java.util.iterator#remove()
*/
public void remove
if  current    null
throw new illegalstateexception
if  modcount    expectedmodcount
throw new concurrentmodificationexception
int k   current key
current   null
inthashmap this removeentryforkey k
expectedmodcount   modcount
private class valueiterator extends hashiterator
/**
* @see java.util.iterator#next()
*/
public object next
return nextentry   value
private class keyiterator extends hashiterator
/**
* @see java.util.iterator#next()
*/
public object next
return new integer nextentry   getkey
private class entryiterator extends hashiterator
/**
* @see java.util.iterator#next()
*/
public object next
return nextentry
// subclass overrides these to alter behavior of views' iterator() method
iterator newkeyiterator
return new keyiterator
iterator newvalueiterator
return new valueiterator
iterator newentryiterator
return new entryiterator
// views
private transient set entryset   null
/**
* returns a set view of the keys contained in this map. the set is backed
* by the map, so changes to the map are reflected in the set, and
* vice-versa. the set supports element removal, which removes the
* corresponding mapping from this map, via the <tt>iterator.remove</tt>,
* <tt>set.remove</tt>, <tt>removeall</tt>, <tt>retainall</tt>, and
* <tt>clear</tt> operations. it does not support the <tt>add</tt> or
* <tt>addall</tt> operations.
*
* @return a set view of the keys contained in this map.
*/
public set keyset
set ks   keyset
return  ks    null ? ks    keyset   new keyset
private class keyset extends abstractset
/**
* @see java.util.abstractcollection#iterator()
*/
public iterator iterator
return newkeyiterator
/**
* @see java.util.abstractcollection#size()
*/
public int size
return size
/**
* @see java.util.abstractcollection#contains(java.lang.object)
*/
public boolean contains object o
if  o instanceof number
return containskey   number o  intvalue
return false
/**
* @see java.util.abstractcollection#remove(java.lang.object)
*/
public boolean remove object o
if  o instanceof number
return inthashmap this removeentryforkey   number o  intvalue       null
return false
/**
* @see java.util.abstractcollection#clear()
*/
public void clear
inthashmap this clear
/**
* returns a collection view of the values contained in this map. the
* collection is backed by the map, so changes to the map are reflected in
* the collection, and vice-versa. the collection supports element removal,
* which removes the corresponding mapping from this map, via the
* <tt>iterator.remove</tt>, <tt>collection.remove</tt>,
* <tt>removeall</tt>, <tt>retainall</tt>, and <tt>clear</tt>
* operations. it does not support the <tt>add</tt> or <tt>addall</tt>
* operations.
*
* @return a collection view of the values contained in this map.
*/
public collection values
collection vs   values
return  vs    null ? vs    values   new values
private class values extends abstractcollection
/**
* @see java.util.abstractcollection#iterator()
*/
public iterator iterator
return newvalueiterator
/**
* @see java.util.abstractcollection#size()
*/
public int size
return size
/**
* @see java.util.abstractcollection#contains(java.lang.object)
*/
public boolean contains object o
return containsvalue o
/**
* @see java.util.abstractcollection#clear()
*/
public void clear
inthashmap this clear
/**
* returns a collection view of the mappings contained in this map. each
* element in the returned collection is a <tt>map.entry</tt>. the
* collection is backed by the map, so changes to the map are reflected in
* the collection, and vice-versa. the collection supports element removal,
* which removes the corresponding mapping from the map, via the
* <tt>iterator.remove</tt>, <tt>collection.remove</tt>,
* <tt>removeall</tt>, <tt>retainall</tt>, and <tt>clear</tt>
* operations. it does not support the <tt>add</tt> or <tt>addall</tt>
* operations.
*
* @return a collection view of the mappings contained in this map.
* @see map.entry
*/
public set entryset
set es   entryset
return  es    null ? es    entryset   new entryset
private class entryset extends abstractset
/**
* @see java.util.abstractcollection#iterator()
*/
public iterator iterator
return newentryiterator
/**
* @see java.util.abstractcollection#contains(java.lang.object)
*/
public boolean contains object o
if    o instanceof entry
return false
entry e    entry o
entry candidate   getentry e getkey
return candidate    null    candidate equals e
/**
* @see java.util.abstractcollection#remove(java.lang.object)
*/
public boolean remove object o
return removemapping o     null
/**
* @see java.util.abstractcollection#size()
*/
public int size
return size
/**
* @see java.util.abstractcollection#clear()
*/
public void clear
inthashmap this clear
/**
* save the state of the <tt>hashmap</tt> instance to a stream (i.e.,
* serialize it).
*
* @param s
*            the objectoutputstream
* @throws ioexception
*
* @serialdata the <i>capacity</i> of the hashmap (the length of the bucket
*             array) is emitted (int), followed by the <i>size</i> of the
*             hashmap (the number of key-value mappings), followed by the
*             key (object) and value (object) for each key-value mapping
*             represented by the hashmap the key-value mappings are emitted
*             in the order that they are returned by
*             <tt>entryset().iterator()</tt>.
*
*/
private void writeobject java io objectoutputstream s  throws ioexception
// write out the threshold, loadfactor, and any hidden stuff
s defaultwriteobject
// write out number of buckets
s writeint table length
// write out size (number of mappings)
s writeint size
// write out keys and values (alternating)
for  iterator i   entryset   iterator    i hasnext
entry e    entry i next
s writeint e getkey
s writeobject e getvalue
private static final long serialversionuid   362498820763181265l
/**
* reconstitute the <tt>hashmap</tt> instance from a stream (i.e.,
* deserialize it).
*
* @param s
* @throws ioexception
* @throws classnotfoundexception
*/
private void readobject java io objectinputstream s  throws ioexception  classnotfoundexception
// read in the threshold, loadfactor, and any hidden stuff
s defaultreadobject
// read in number of buckets and allocate the bucket array;
int numbuckets   s readint
table   new entry
init       give subclass a chance to do its thing
// read in size (number of mappings)
int size   s readint
// read the keys and values, and put the mappings in the hashmap
for  int i   0  i < size  i
int key   s readint
object value   s readobject
putforcreate key  value
// these methods are used when serializing hashsets
int capacity
return table length
float loadfactor
return loadfactor