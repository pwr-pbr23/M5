/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket markup parser
import java io bufferedinputstream
import java io bytearrayinputstream
import java io ioexception
import java io inputstream
import java text parseexception
import org apache wicket markup markupelement
import org apache wicket util io fullybufferedreader
import org apache wicket util io xmlreader
import org apache wicket util parse metapattern parsers tagnameparser
import org apache wicket util parse metapattern parsers variableassignmentparser
import org apache wicket util resource resourcestreamnotfoundexception
/**
* a fairly shallow markup pull parser which parses a markup string of a given
* type of markup (for example, html, xml, vxml or wml) into componenttag and
* rawmarkup tokens.
*
* @author jonathan locke
* @author juergen donnerstag
*/
public final class xmlpullparser extends abstractmarkupfilter implements ixmlpullparser
/** next() must be called at least once for the type to be valid */
public static final int not_initialized   0
/** <name ...> */
public static final int tag   1
/** tag body in between two tags */
public static final int body   2
/** <!-- ... --> */
public static final int comment   3
/** <![cdata[ .. ]]> */
public static final int cdata   4
/** <?...> */
public static final int processing_instruction   5
/** all other tags which look like <!.. > */
public static final int special_tag   6
/**
* reads the xml data from an input stream and converts the chars according
* to its encoding (<?xml ... encoding="..." ?>)
*/
private xmlreader xmlreader
/**
* a xml independent reader which loads the whole source data into memory
* and which provides convinience methods to access the data.
*/
private fullybufferedreader input
/** temporary variable which will hold the name of the closing tag. */
private string skipuntiltext
/** the last substring selected from the input */
private charsequence lasttext
/** the type of what is in lasttext */
private int lasttype   not_initialized
/** if lasttype == tag, than ... */
private xmltag lasttag
/**
* construct.
*/
public xmlpullparser
/**
*
* @see org.apache.wicket.markup.parser.ixmlpullparser#getencoding()
*/
public string getencoding
return this xmlreader getencoding
/**
*
* @see org.apache.wicket.markup.parser.ixmlpullparser#getxmldeclaration()
*/
public string getxmldeclaration
return this xmlreader getxmldeclaration
/**
*
* @see org.apache.wicket.markup.parser.ixmlpullparser#getinputfrompositionmarker(int)
*/
public final charsequence getinputfrompositionmarker final int topos
return this input getsubstring topos
/**
*
* @see org.apache.wicket.markup.parser.ixmlpullparser#getinput(int, int)
*/
public final charsequence getinput final int frompos  final int topos
return this input getsubstring frompos  topos
/**
* whatever will be in between the current index and the closing tag, will
* be ignored (and thus treated as raw markup (text). this is useful for
* tags like 'script'.
*
* @throws parseexception
*/
private final void skipuntil   throws parseexception
// this is a tag with non-xhtml text as body - skip this until the
// skipuntiltext is found.
final int startindex   this input getposition
final int tagnamelen   this skipuntiltext length
int pos   this input getposition     1
string endtagtext   null
int lastpos   0
while   skipuntiltext equalsignorecase endtagtext
pos   this input find    pos   1
if   pos     1       pos    tagnamelen   2   >  this input size
throw new parseexception skipuntiltext
this input getlinenumber         this input getcolumnnumber
startindex
lastpos   pos   2
endtagtext   this input getsubstring lastpos  lastpos   tagnamelen  tostring
this input setposition pos
this lasttext   this input getsubstring startindex  pos
this lasttype   body
// check that the tag is properly closed
lastpos   this input find    lastpos   tagnamelen
if  lastpos     1
throw new parseexception     this input getlinenumber
this input getcolumnnumber        startindex
// reset the state variable
this skipuntiltext   null
/**
* gets the next tag from the input string.
*
* @return the extracted tag (will always be of type xmltag).
* @throws parseexception
*/
public final boolean next   throws parseexception
// reached end of markup file?
if  this input getposition   >  this input size
return false
if  this skipuntiltext    null
skipuntil
return true
// any more tags in the markup?
final int openbracketindex   this input find
// tag or body?
if  this input charat this input getposition
if  openbracketindex     1
// there is no next matching tag.
this lasttext   this input getsubstring  1
this input setposition this input size
this lasttype   body
return true
this lasttext   this input getsubstring openbracketindex
this input setposition openbracketindex
this lasttype   body
return true
// determine the line number
this input countlinesto openbracketindex
// get index of closing tag and advance past the tag
int closebracketindex   this input find    openbracketindex   1
if  closebracketindex     1
throw new parseexception     openbracketindex
this input getposition
// get the complete tag text
this lasttext   this input getsubstring openbracketindex  closebracketindex   1
// get the tagtext between open and close brackets
string tagtext   this lasttext subsequence 1  this lasttext length     1  tostring
if  tagtext length      0
throw new parseexception     openbracketindex
this input getposition
// handle special tags like <!-- and <![cdata ...
final char firstchar   tagtext charat 0
if   firstchar           firstchar
specialtaghandling tagtext  openbracketindex  closebracketindex
return true
// type of the tag, to be determined next
final xmltag type type
// if the tag ends in '/', it's a "simple" tag like <foo/>
if  tagtext endswith
type   xmltag open_close
tagtext   tagtext substring 0  tagtext length     1
else if  tagtext startswith
// the tag text starts with a '/', it's a simple close tag
type   xmltag close
tagtext   tagtext substring 1
else
// it must be an open tag
type   xmltag open
// if open tag and starts with "s" like "script" or "style", than
// ...
if   tagtext length   > 5
tagtext charat 0            tagtext charat 0
final string lowercase   tagtext substring 0  6  tolowercase
if  lowercase startswith
// prepare to skip everything between the open and close tag
this skipuntiltext
else if  lowercase startswith
// prepare to skip everything between the open and close tag
this skipuntiltext
// parse remaining tag text, obtaining a tag object or null
// if it's invalid
this lasttag   parsetagtext tagtext
if  this lasttag    null
// populate tag fields
this lasttag type   type
this lasttag pos   openbracketindex
this lasttag length   this lasttext length
this lasttag text   this lasttext
this lasttag linenumber   this input getlinenumber
this lasttag columnnumber   this input getcolumnnumber
// move to position after the tag
this input setposition closebracketindex   1
this lasttype   tag
return true
else
throw new parseexception     this input getlinenumber
this input getcolumnnumber        openbracketindex
/**
* handle special tags like <!-- --> or <![cdata[..]]> or <?xml>
*
* @param tagtext
* @param openbracketindex
* @param closebracketindex
* @throws parseexception
*/
private void specialtaghandling string tagtext  final int openbracketindex
int closebracketindex  throws parseexception
// handle comments
if  tagtext startswith
// normal comment section.
// skip ahead to "-->". note that you can not simply test for
// tagtext.endswith("--") as the comment might contain a '>'
// inside.
int pos   this input find    openbracketindex   1
if  pos     1
throw new parseexception
input getlinenumber         input getcolumnnumber
openbracketindex
pos    3
this lasttext   this input getsubstring openbracketindex  pos
this lasttype   comment
// conditional comment? <!--[if ...]>..<![endif]-->
if  tagtext startswith       tagtext endswith
this lasttext tostring   endswith
// actually it is no longer a comment. it is now
// up to the browser to select the section appropriate.
this input setposition closebracketindex   1
else
this input setposition pos
return
// the closing tag of a conditional comment <!--[if ie]>...<![endif]-->
if  tagtext equals
this lasttype   comment
this input setposition closebracketindex   1
return
// cdata sections might contain "<" which is not part of an xml tag.
// make sure escaped "<" are treated right
if  tagtext startswith
final string starttext    tagtext length   <  8 ? tagtext   tagtext substring 0  8
if  starttext touppercase   equals
int pos1   openbracketindex
do
// get index of closing tag and advance past the tag
closebracketindex   findchar    pos1
if  closebracketindex     1
throw new parseexception
input getlinenumber         input getcolumnnumber
this input getposition
// get the tagtext between open and close brackets
tagtext   this input getsubstring openbracketindex   1  closebracketindex
tostring
pos1   closebracketindex   1
while  tagtext endswith       false
// move to position after the tag
this input setposition closebracketindex   1
this lasttext   tagtext
this lasttype   cdata
return
if  tagtext charat 0
this lasttype   processing_instruction
// move to position after the tag
this input setposition closebracketindex   1
return
// move to position after the tag
this lasttype   special_tag
this input setposition closebracketindex   1
/**
* gets the next tag from the input string.
*
* @return the extracted tag (will always be of type xmltag).
* @throws parseexception
*/
public final markupelement nexttag   throws parseexception
while  next
switch  this lasttype
case tag
return this lasttag
case body
break
case comment
break
case cdata
break
case processing_instruction
break
case special_tag
break
return null
/**
* find the char but ignore any text within ".." and '..'
*
* @param ch
*            the character to search
* @param startindex
*            start index
* @return -1 if not found, else the index
*/
private int findchar final char ch  int startindex
char quote   0
for    startindex < this input size    startindex
final char charat   this input charat startindex
if  quote    0
if  quote    charat
quote   0
else if   charat           charat
quote   charat
else if  charat    ch
return startindex
return  1
/**
* parse the given string.
* <p>
* note: xml character encoding is not applied. it is assumed the input
* provided does have the correct encoding already.
*
* @param string
*            the input string
* @throws ioexception
*             error while reading the resource
* @throws resourcestreamnotfoundexception
*             resource not found
*/
public void parse final charsequence string  throws ioexception
resourcestreamnotfoundexception
parse new bytearrayinputstream string tostring   getbytes     null
/**
* reads and parses markup from an input stream, using utf-8 encoding by
* default when not specified in xml declaration.
*
* @param in
*            the input stream to read and parse
* @throws ioexception
* @throws resourcestreamnotfoundexception
*/
public void parse final inputstream in  throws ioexception
resourcestreamnotfoundexception
// when xml declaration does not specify encoding, it defaults to utf-8
parse in
/**
* reads and parses markup from an input stream
*
* @param inputstream
*            the input stream to read and parse
* @param encoding
*            the default character encoding of the input
* @throws ioexception
* @throws resourcestreamnotfoundexception
*/
public void parse final inputstream inputstream  final string encoding  throws ioexception
resourcestreamnotfoundexception
try
this xmlreader   new xmlreader
new bufferedinputstream inputstream  4000   encoding
this input   new fullybufferedreader this xmlreader
finally
inputstream close
if this xmlreader    null
this xmlreader close
/**
*
* @see org.apache.wicket.markup.parser.ixmlpullparser#setpositionmarker()
*/
public final void setpositionmarker
this input setpositionmarker this input getposition
/**
*
* @see org.apache.wicket.markup.parser.ixmlpullparser#setpositionmarker(int)
*/
public final void setpositionmarker final int pos
this input setpositionmarker pos
/**
*
* @see java.lang.object#tostring()
*/
public string tostring
return this input tostring
/**
* parses the text between tags. for example, "a href=foo.html".
*
* @param tagtext
*            the text between tags
* @return a new tag object or null if the tag is invalid
* @throws parseexception
*/
private xmltag parsetagtext final string tagtext  throws parseexception
// get the length of the tagtext
final int tagtextlength   tagtext length
// if we match tagname pattern
final tagnameparser tagnameparser   new tagnameparser tagtext
if  tagnameparser matcher   lookingat
final xmltag tag   new xmltag
// extract the tag from the pattern matcher
tag name   tagnameparser getname
tag namespace   tagnameparser getnamespace
// are we at the end? then there are no attributes, so we just
// return the tag
int pos   tagnameparser matcher   end 0
if  pos    tagtextlength
return tag
// extract attributes
final variableassignmentparser attributeparser   new variableassignmentparser tagtext
while  attributeparser matcher   find pos
// get key and value using attribute pattern
string value   attributeparser getvalue
// in case like <html xmlns:wicket> will the value be null
if  value    null
value
// set new position to end of attribute
pos   attributeparser matcher   end 0
// chop off double quotes or single quotes
if  value startswith    '"
value   value substring 1  value length     1
// trim trailing whitespace
value   value trim
// get key
final string key   attributeparser getkey
// put the attribute in the attributes hash
if  null    tag put key  value
throw new parseexception     key  this input
getposition
// the input has to match exactly (no left over junk after
// attributes)
if  pos    tagtextlength
return tag
return tag
return null