/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket application
import java util hashmap
import java util map
/**
* this class is an utility class that perform wilcard-patterns matching and isolation.
*
* @version $id: wildcardmatcherhelper.java 420832 2006-07-11 13:11:02z cziegeler $
*/
public class wildcardmatcherhelper
//~ static fields/initializers -----------------------------------------------------------------
/** default path separator: "/" */
public static final char esc
/** default path separator: "/" */
public static final char pathsep
/** default path separator: "/" */
public static final char star
//~ methods ------------------------------------------------------------------------------------
/**
* match a pattern agains a string and isolates wildcard replacement into a <code>map</code>.
* <br>
* here is how the matching algorithm works:
*
* <ul>
*   <li>
*     the '*' character, meaning that zero or more characters (excluding the path separator '/')
*     are to be matched.
*   </li>
*   <li>
*     the '**' sequence, meaning that zero or more characters (including the path separator '/')
*     are to be matched.
*   </li>
*   <li>
*     the '\*' sequence is honored as a litteral '*' character, not a wildcard
*   </li>
* </ul>
* <br>
* when more than two '*' characters, not separated by another character, are found their value is
* considered as '**' and immediate succeeding '*' are skipped.
* <br>
* the '**' wildcard is greedy and thus the following sample cannot match:
* <dl>
*   <dt>pattern</dt>
*   <dd>star,star,pathsep,star,pathsep,star,star (why can't i express it litterally?)</dt>
*   <dt>string</dt>
*   <dd>foo/bar/baz/bug</dt>
* </dl>
* the first '**' in the pattern will suck up until the last '/' in string and thus will not match.
* <br>
* a more advance algorithm could cerainly check whether there is an other literal later in the pattern to ev. match in string
* but i'll leave this exercise to someone else atm if one needs such.
*
* @param pat the pattern string.
* @param str the string to math agains the pattern
*
* @return a <code>map</code> containing the representation of the extracted pattern. the extracted patterns are
*         keys in the <code>map</code> from left to right beginning with "1" for te left most, "2" for the next,
*         a.s.o. the key "0" is the string itself. if the return value is null, string does not match to the
*         pattern .
*/
public static map match final string pat
final string str
final matcher map   new matcher pat  str
if map ismatch
return map getmap
return null
//~ inner classes ------------------------------------------------------------------------------
/**
* the private matcher class
*/
private static class matcher
//~ instance fields ------------------------------------------------------------------------
/** the character array of the pattern */
private final char apat
/** the length of the character array of the pattern */
private final int lpat
/** the character array of the string */
private final char astr
/** the length of the character array of the string */
private final int lstr
/** the <code>map</code> to be filled */
private map map   new hashmap
/** whether string matched to pattern */
private final boolean matched
/** map index */
private int idx   0
/** index into pattern */
private int ipat   0
/** index into string */
private int istr   0
//~ constructors ---------------------------------------------------------------------------
/**
* creates a new matcher object.
*
* @param pat the pattern
* @param str the string
*/
public matcher final string pat
final string str
apat   pat tochararray
lpat   apat length
astr   str tochararray
lstr   astr length
add str
matched   match
//~ methods --------------------------------------------------------------------------------
/**
* document me!
*
* @return document me!
*/
public map getmap
return map
/**
* has it matched?
*
* @return whether it has matched
*/
public boolean ismatch
return matched
/**
* add a extracted substring to the map
*
* @param astr the extracted substring
*/
private void add final string astr
map put string valueof idx     astr
/**
* scans the pattern and the search string from the start toward the end
*
* @return wether the pstring matches the pattern
*/
private boolean match
// scan a common literal prefix
scanliteralprefix
// if we are already at the end of both strings
// than the pattern matched
if ipat >  lpat    istr >  lstr  return true
// if hole string has matched the pattern so far and the rest of the pattern only has wildcard(s)
// we match too otherwise we clearly don't match
if ipat < lpat    istr >  lstr
while ipat < lpat    apat    star  ipat
if ipat >  lpat
add
return true
else
return false
// if hole pattern has matched the string so far but the string has more characters left
// we don't match
if ipat >  lpat    istr < lstr  return false
// if we have not stopped at a wildcard character
// a character doesn't match and thus we do not match at all
if apat    star  return false
// if it is a double (or more) wildcard pattern
if ipat < lpat   1    apat    star
// skip to first non star charater in the pattern
while   ipat < lpat    apat    star
// if we are at the end of the pattern we've matched and are finish scanning
if ipat >  lpat
add new string astr  istr  lstr   istr
return true
// now we need to scan for the end of the literal characters in the pattern
final int sipat   ipat     start position of a literal character used for substring operations
while ipat < lpat     apat    star     ipat > 0    apat    esc    ipat
// if we reached the end of the pattern just do a string compare with the corresponding part from
// the end of the string
if ipat >  lpat
return checkends sipat  false
// now we need to check whether the litteral substring of the pattern
// is contained in the string somewhere
final int l   ipat   sipat
int eistr   lstr   l
// beause the '**' wildcard need to be greedy we scan from the end of the string for a match
while istr < eistr      strncmp apat  sipat  astr  eistr  l   eistr
if istr >  eistr  return false
add new string astr  istr  eistr   istr
istr   eistr   l
else     if it is a single star pattern
// skip the star
ipat
// if we are at the beginning of the pattern we have to check there is no path_sep in string
if ipat >  lpat
final int sistr   istr
while istr < lstr     astr    pathsep   istr
if istr >  lstr
add new string astr  sistr  lstr   sistr
return true
// otherwise we do not match
return false
// now we need to search for the start of either a path sparator or another wildcard characters
// in the pattern
final int sipat   ipat
while ipat < lpat
apat    star
apat    esc    ipat < lpat   1    apat    star
apat    pathsep
ipat
// if we reached the end of the pattern just do a string compare with the corresponding part from
// the end of the string
if ipat >  lpat
return checkends sipat  true
// if we stopped at an other wildcard
// we exclude it from being compared
if apat    star
ipat
// now we need to check whether the litteral substring of the pattern
// is contained in the string somewhere
final int l   ipat  sipat   1
final int sistr   istr
while istr < lstr      strncmp apat  sipat  astr  istr  l   istr
if istr >  lstr  return false
add new string astr  sistr  istr   sistr
ipat
istr    l
return match
/**
* scan a possible common suffix
*/
private final void scanliteralprefix
// scan a common literal suffix
while ipat < lpat
istr < lstr
apat    esc    ipat < lpat   1    apat    star    apat    astr
apat    star
apat    astr
ipat
istr
/**
* compare two charater array from  individual offsets
*
* @param a1 the first character array
* @param o1 the offset into the first character array
* @param a2 the second character array
* @param o2 the offset into the second character array
* @param l the length to compare
*
* @return whether the all the mentioned characters match each other
*/
private final boolean strncmp final char a1
final int o1
final char a2
final int o2
final int l
int i   0
while i < l    o1   i < a1 length    o2   i < a2 length    a1    a2  i
return i    l
private final boolean checkends final int sipat  final boolean issinglestart
// if the remaining length of the string isn't the same as that found in the pattern
// we do not match
final int l   lpat   sipat     calculate length of comparison
final int ostr   lstr   l     calculate offset into string
if ostr >  0    strncmp apat  sipat  astr  ostr  l
if  issinglestart
// if the ends matches make sure there isn't a pathsep in the candidate string part
int i   ostr   istr
while  i > istr
if  astr    pathsep
return false     we cannot match because of a pathsep in the matched part
add new string astr  istr  ostr   istr
return true
// otherwise we do not match
return false