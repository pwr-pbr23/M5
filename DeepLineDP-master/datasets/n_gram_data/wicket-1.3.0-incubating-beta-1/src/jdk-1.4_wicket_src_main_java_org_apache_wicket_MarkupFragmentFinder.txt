/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket
import org apache wicket markup componenttag
import org apache wicket markup markupelement
import org apache wicket markup markupstream
import org apache wicket markup html border border
/**
* responding to an ajax request requires that we position the markup stream at
* the component associated with the ajax request. that is straight forward in
* most cases except for "transparent" components and for components which
* implement there own icomponentresolver.
*
* @author juergen donnerstag
*/
final class markupfragmentfinder
/**
* construct
*/
public markupfragmentfinder
/**
* get the markup stream and position it at the component
*
* @param component
* @return a markupstream which is positioned at the component
*/
final markupstream find final component component
// get the parent's associated markup stream.
markupcontainer parentwithassociatedmarkup   component findparentwithassociatedmarkup
markupstream markupstream   null
// might be that we have to walk up the component hierarchy
while  true
markupstream   parentwithassociatedmarkup getassociatedmarkupstream true
// in case the component has already been rendered, this is a
// performance short cut. but actually this was necessary because
// transparent containers and components which implement
// icomponentresolver destroy the 1:1 match between component path
// and markup path.
if  component markupindex     1
// might be that the markup has been reloaded and that the
// position has changed. make sure the component is still
// available
try
markupstream setcurrentindex component markupindex
markupelement elem   markupstream get
if  elem instanceof componenttag
componenttag tag    componenttag elem
if  tag getid   equals component getid
// ok, found it
return markupstream
catch  indexoutofboundsexception ex
// fall through. don't do anything
// make sure the markup stream is positioned at the correct element
string relativepath   getcomponentrelativepath component  parentwithassociatedmarkup
// if the component is defined in the markup
int index   markupstream findcomponentindex relativepath  component getid
if  index     1
// than position the stream at the beginning of the component
markupstream setcurrentindex index
return markupstream
// yet another exception for border in the code base.
// however if the container with the markup is a border, than
// ...
if  parentwithassociatedmarkup instanceof border
parentwithassociatedmarkup   parentwithassociatedmarkup
findparentwithassociatedmarkup
else
throw new wicketruntimeexception
component tostring
// not found, reset the stream
markupstream   null
/**
* get component path relativ to the parent container with associated markup
*
* @param component
* @param parentwithassociatedmarkup
* @return the relativ path
*/
private string getcomponentrelativepath final component component
final markupcontainer parentwithassociatedmarkup
final string componentpath   component getparent   getpagerelativepath
final string parentwithassociatedmarkuppath   parentwithassociatedmarkup
getpagerelativepath
string relativepath   componentpath substring parentwithassociatedmarkuppath length
if  relativepath startswith
relativepath   relativepath substring 1
return relativepath