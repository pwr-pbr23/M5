/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket settings
import java util list
import org apache wicket iresponsefilter
import org apache wicket requestcycle
import org apache wicket session
import org apache wicket markup html pages browserinfopage
import org apache wicket protocol http webrequestcycle
import org apache wicket settings iexceptionsettings unexpectedexceptiondisplay
import org apache wicket util lang enumeratedtype
import org apache wicket util time duration
/**
* inteface for request related settings
* <p>
* <i>bufferresponse </i> (defaults to true) - true if the application should
* buffer responses. this does require some additional memory, but helps keep
* exception displays accurate because the whole rendering process completes
* before the page is sent to the user, thus avoiding the possibility of a
* partially rendered page.
* <p>
* <i>renderstrategy </i>- sets in what way the render part of a request is
* handled. basically, there are two different options:
* <ul>
* <li>direct, applicationsettings.one_pass_render. everything is handled in
* one physical request. this is efficient, and is the best option if you want
* to do sophisticated clustering. it does not however, shield you from what is
* commonly known as the <i>double submit problem </i></li>
* <li>using a redirect. this follows the pattern <a
* href="http://www.theserverside.com/articles/article.tss?l=redirectafterpost"
* >as described at the serverside </a> and that is commonly known as redirect
* after post. wicket takes it one step further to do any rendering after a
* redirect, so that not only form submits are shielded from the double submit
* problem, but also the irequestlistener handlers (that could be e.g. a link
* that deletes a row). with this pattern, you have two options to choose from:
* <ul>
* <li>applicationsettings.redirect_to_render. this option first handles the
* 'action' part of the request, which is either page construction (bookmarkable
* pages or the home page) or calling a irequestlistener handler, such as
* link.onclick. when that part is done, a redirect is issued to the render
* part, which does all the rendering of the page and its components. <strong>be
* aware </strong> that this may mean, depending on whether you access any
* models in the action part of the request, that attachement and detachement of
* some models is done twice for a request.</li>
* <li>applicationsettings.redirect_to_buffer. this option handles both the
* action- and the render part of the request in one physical request, but
* instead of streaming the result to the browser directly, it is kept in
* memory, and a redirect is issue to get this buffered result (after which it
* is immediately removed). this option currently is the default render
* strategy, as it shields you from the double submit problem, while being more
* efficient and less error prone regarding to detachable models.</li>
* </ul>
* </li>
* </ul>
* note that this parameter sets the default behavior, but that you can manually
* set whether any redirecting is done by calling method
* requestcycle.setredirect. setting the redirect flag when the application is
* configured to use one_pass_render, will result in a redirect of type
* redirect_to_render. when the application is configured to use
* redirect_to_render or redirect_to_buffer, setting the redirect flag to false,
* will result in that request begin rendered and streamed in one pass.
* <p>
* more documentation is available about each setting in the setter method for
* the property.
*
* @author igor vaynberg (ivaynberg)
*/
public interface irequestcyclesettings
/**
* enumerated type for different ways of handling the render part of
* requests.
*/
public static class renderstrategy extends enumeratedtype
private static final long serialversionuid   1l
renderstrategy final string name
super name
/**
* all logical parts of a request (the action and render part) are handled
* within the same request. to enable a the client side redirect for a
* request, users can set the 'redirect' property of {@link requestcycle}to
* true (getrequestcycle.setredirect(true)), after which the behavior will
* be like renderstragegy 'redirect_to_render'.
* <p>
* this strategy is more efficient than the 'redirect_to_render' strategy,
* and doesn't have some of the potential problems of it, it also does not
* solve the double submit problem. it is however the best option to use
* when you want to do sophisticated (non-sticky session) clustering.
* </p>
*/
public static final irequestcyclesettings renderstrategy one_pass_render   new irequestcyclesettings renderstrategy
/**
* all logical parts of a request (the action and render part) are handled
* within the same request, but instead of streaming the render result to
* the browser directly, the result is cached on the server. a client side
* redirect command is issued to the browser specifically to render this
* request.
*/
public static final irequestcyclesettings renderstrategy redirect_to_buffer   new irequestcyclesettings renderstrategy
/**
* the render part of a request (opposed to the 'action part' which is
* either the construction of a bookmarkable page or the execution of a
* irequestlistener handler) is handled by a seperate request by issueing a
* redirect request to the browser. this is commonly known as the 'redirect
* after submit' pattern, though in our case, we use it for get and post
* requests instead of just the post requests. to cancel the client side
* redirect for a request, users can set the 'redirect' property of
* {@link requestcycle}to false (getrequestcycle.setredirect(false)).
* <p>
* this pattern solves the 'refresh' problem. while it is a common feature
* of browsers to refresh/ reload a web page, this results in problems in
* many dynamic web applications. for example, when you have a link with an
* event handler that e.g. deletes a row from a list, you usually want to
* ignore refresh requests after that link is clicked on. by using this
* strategy, the refresh request only results in the re-rendering of the
* page without executing the event handler again.
* </p>
* <p>
* though it solves the refresh problem, it introduces potential problems,
* as the request that is logically one, are actually two seperate request.
* not only is this less efficient, but this also can mean that within the
* same request attachement/ detachement of models is done twice (in case
* you use models in the bookmarkable page constructors and irequestlistener
* handlers). if you use this strategy, you should be aware of this
* possibily, and should also be aware that for one logical request,
* actually two instances of requestcycle are created and processed.
* </p>
*/
public static final irequestcyclesettings renderstrategy redirect_to_render   new irequestcyclesettings renderstrategy
/**
* adds a response filter to the list. filters are evaluated in the order
* they have been added.
*
* @param responsefilter
*            the {@link iresponsefilter} that is added
*/
void addresponsefilter iresponsefilter responsefilter
/**
* @return true if this application buffers its responses
*/
boolean getbufferresponse
/**
* gets whether wicket should try to get extensive client info by
* redirecting to
* {@link browserinfopage a page that polls for client capabilities}. this
* method is used by the default implementation of
* {@link webrequestcycle#newclientinfo()}, so if that method is overriden,
* there is no guarantee this method will be taken into account.
*
* @return whether to gather extensive client info
*/
boolean getgatherextendedbrowserinfo
/**
* gets in what way the render part of a request is handled.
*
* @return the render strategy
*/
irequestcyclesettings renderstrategy getrenderstrategy
/**
* @return an unmodifiable list of added response filters, null if none
*/
list getresponsefilters
/**
* in order to do proper form parameter decoding it is important that the
* response and the following request have the same encoding. see
* http://www.crazysquirrel.com/computing/general/form-encoding.jspx for
* additional information.
*
* @return the request and response encoding
*/
string getresponserequestencoding
/**
* gets the time that a request will by default be waiting for the previous
* request to be handled before giving up.
*
* @return the time out
*/
duration gettimeout
/**
* @see org.apache.wicket.settings.iexceptionsettings#getunexpectedexceptiondisplay()
*
* @return unexpectedexceptiondisplay
*/
unexpectedexceptiondisplay getunexpectedexceptiondisplay
/**
* @param bufferresponse
*            true if this application should buffer responses.
*/
void setbufferresponse boolean bufferresponse
/**
* sets whether wicket should try to get extensive client info by
* redirecting to
* {@link browserinfopage a page that polls for client capabilities}. this
* method is used by the default implementation of
* {@link webrequestcycle#newclientinfo()}, so if that method is overriden,
* there is no guarantee this method will be taken into account.
*
* <p>
* <strong>warning: </strong> though this facility should work transparently
* in most cases, it is recommended that you trigger the roundtrip to get
* the browser info somewhere where it hurts the least. the roundtrip will
* be triggered the first time you call {@link session#getclientinfo()} for
* a session, and after the roundtrip a new request with the same info (url,
* post parameters) is handled. so rather than calling this in the middle of
* an implementation of a form submit method, which would result in the code
* of that method before the call to {@link session#getclientinfo()} to be
* executed twice, you best call {@link session#getclientinfo()} e.g. in a
* page constructor or somewhere else where you didn't do a lot of
* processing first.
* </p>
*
* @param gatherextendedbrowserinfo
*            whether to gather extensive client info
*/
void setgatherextendedbrowserinfo boolean gatherextendedbrowserinfo
/**
* sets in what way the render part of a request is handled. basically,
* there are two different options:
* <ul>
* <li>direct, applicationsettings.one_pass_render. everything is handled
* in one physical request. this is efficient, and is the best option if you
* want to do sophisticated clustering. it does not however, shield you from
* what is commonly known as the <i>double submit problem </i></li>
* <li>using a redirect. this follows the pattern <a
* href="http://www.theserverside.com/articles/article.tss?l=redirectafterpost"
* >as described at the serverside </a> and that is commonly known as
* redirect after post. wicket takes it one step further to do any rendering
* after a redirect, so that not only form submits are shielded from the
* double submit problem, but also the irequestlistener handlers (that could
* be e.g. a link that deletes a row). with this pattern, you have two
* options to choose from:
* <ul>
* <li>applicationsettings.redirect_to_render. this option first handles
* the 'action' part of the request, which is either page construction
* (bookmarkable pages or the home page) or calling a irequestlistener
* handler, such as link.onclick. when that part is done, a redirect is
* issued to the render part, which does all the rendering of the page and
* its components. <strong>be aware </strong> that this may mean, depending
* on whether you access any models in the action part of the request, that
* attachement and detachement of some models is done twice for a request.
* </li>
* <li>applicationsettings.redirect_to_buffer. this option handles both the
* action- and the render part of the request in one physical request, but
* instead of streaming the result to the browser directly, it is kept in
* memory, and a redirect is issue to get this buffered result (after which
* it is immediately removed). this option currently is the default render
* strategy, as it shields you from the double submit problem, while being
* more efficient and less error prone regarding to detachable models.</li>
* </ul>
* note that this parameter sets the default behavior, but that you can
* manually set whether any redirecting is done by calling method
* requestcycle.setredirect. setting the redirect flag when the application
* is configured to use one_pass_render, will result in a redirect of type
* redirect_to_render. when the application is configured to use
* redirect_to_render or redirect_to_buffer, setting the redirect flag to
* false, will result in that request begin rendered and streamed in one
* pass.
*
* @param renderstrategy
*            the render strategy that should be used by default.
*/
void setrenderstrategy irequestcyclesettings renderstrategy renderstrategy
/**
* in order to do proper form parameter decoding it is important that the
* response and the following request have the same encoding. see
* http://www.crazysquirrel.com/computing/general/form-encoding.jspx for
* additional information.
*
* default encoding: utf-8
*
* @param responserequestencoding
*            the request and response encoding to be used.
*/
void setresponserequestencoding final string responserequestencoding
/**
* sets the time that a request will by default be waiting for the previous
* request to be handled before giving up.
*
* @param timeout
*/
void settimeout duration timeout
/**
* @see org.apache.wicket.settings.iexceptionsettings#setunexpectedexceptiondisplay(org.apache.wicket.settings.settings.unexpectedexceptiondisplay)
*
* @param unexpectedexceptiondisplay
*/
void setunexpectedexceptiondisplay final unexpectedexceptiondisplay unexpectedexceptiondisplay