/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket resource loader
import java util arraylist
import java util list
import java util locale
import org apache commons logging log
import org apache commons logging logfactory
import org apache wicket application
import org apache wicket component
import org apache wicket markupcontainer
import org apache wicket page
import org apache wicket markup html webcomponent
import org apache wicket markup html webmarkupcontainer
import org apache wicket markup html webpage
import org apache wicket resource properties
import org apache wicket resource propertiesfactory
import org apache wicket util resource locator resourcenameiterator
import org apache wicket util string strings
/**
* this is wicket's default string resource loader.
* <p>
* the component based string resource loader attempts to find the resource from
* a bundle that corresponds to the supplied component object or one of its
* parent containers.
* <p>
* the search order for resources is built around the containers that hold the
* component (if it is not a page). consider a page that contains a panel that
* contains a label. if we pass the label as the component then resource loading
* will first look for the resource against the page, then against the panel and
* finally against the label.
* <p>
* the above search order may seem slightly odd at first, but can be explained
* thus: team a writes a new component x and packages it as a reusable wicket
* component along with all required resources. team b then creates a new
* container component y that holds a instance of an x. however, team b wishes
* the text to be different to that which was provided with x so rather than
* needing to change x, they include override values in the resources for y.
* finally, team c makes use of component y in a page they are writing.
* initially they are happy with the text for y so they do not include any
* override values in the resources for the page. however, after demonstrating
* to the customer, the customer requests the text for y to be different. team c
* need only provide override values against their page and thus do not need to
* change y.
* <p>
* this implementation is fully aware of both locale and style values when
* trying to obtain the appropriate resources.
* <p>
* in addition to the above search order, each key will be pre-pended with the
* relative path of the current component related to the component that is being
* searched. e.g. assume a component hierarchy like page1.form1.input1 and your
* are requesting a key named 'requiredvalidator'. wicket will search the
* property in the following order:
*
* <pre>
*        page1.properties =&gt; form1.input1.requiredvalidator
*        page1.properties =&gt; requiredvalidator
*        form1.properties =&gt; input1.requiredvalidator
*        form1.properties =&gt; requiredvalidator
*        input1.properties =&gt; requiredvalidator
*        myapplication.properties =&gt; page1.form1.input1.requiredvalidator
*        myapplication.properties =&gt; requiredvalidator
* </pre>
*
* note that the latter two property files are only checked if the
* classstringresourceloader has been registered with application as well, which
* is the default.
* <p>
* in addition to the above search order, each component that is being searched
* for a resource also includes the resources from any parent classes that it
* inherits from. for example, pagea extends commonbasepage which in turn
* extends webpage. when a resource lookup is requested on pagea, the resource
* bundle for pagea is first checked. if the resource is not found in this
* bundle then the resource bundle for commonbasepage is checked. this allows
* designers of base pages and components to define default sets of string
* resources and then developers implementing subclasses to either override or
* extend these in their own resource bundle.
* <p>
* this implementation can be subclassed to implement modified behavior. the new
* implementation must be registered with the application (resourcesettings)
* though.
* <p>
* you may enable log debug messages for this class to fully understand the
* search order.
*
* @author chris turner
* @author juergen donnerstag
*/
public class componentstringresourceloader implements istringresourceloader
/** log. */
private static final log log   logfactory getlog componentstringresourceloader class
/**
* create and initialise the resource loader.
*/
public componentstringresourceloader
/**
* get the string resource for the given combination of class, key, locale
* and style. the information is obtained from a resource bundle associated
* with the provided class (or one of its super classes).
*
* @param clazz
*            the class to find resources to be loaded
* @param key
*            the key to obtain the string for
* @param locale
*            the locale identifying the resource set to select the strings
*            from
* @param style
*            the (optional) style identifying the resource set to select
*            the strings from (see {@link org.apache.wicket.session})
* @return the string resource value or null if resource not found
*/
public string loadstringresource class clazz  final string key  final locale locale
final string style
if  clazz    null
return null
while  true
// create the base path
string path   clazz getname   replace
// iterator over all the combinations
resourcenameiterator iter   new resourcenameiterator path  style  locale
while  iter hasnext
string newpath    string  iter next
// load the properties associated with the path
final properties props   propertiesfactory get   load clazz  newpath
if  props    null
// lookup the value
string value   props getstring key
if  value    null
if  log isdebugenabled
log debug     props       key
return value
// didn't find the key yet, continue searching if possible
if  isstopresourcesearch clazz
break
// move to the next superclass
clazz   clazz getsuperclass
// not found
return null
/**
* check the supplied class to see if it is one that we shouldn't bother
* further searches up the class hierarchy for properties.
*
* @param clazz
*            the class to check
* @return whether to stop the search
*/
protected boolean isstopresourcesearch final class clazz
if  clazz    null    clazz equals object class     clazz equals application class
return true
// stop at all html markup base classes
if  clazz equals webpage class     clazz equals webmarkupcontainer class
clazz equals webcomponent class
return true
// stop at all wicket base classes
return clazz equals page class     clazz equals markupcontainer class
clazz equals component class
/**
*
* @see org.apache.wicket.resource.loader.istringresourceloader#loadstringresource(org.apache.wicket.component,
*      java.lang.string)
*/
public string loadstringresource final component component  final string key
if  component    null
return null
// the return value
string string   null
locale locale   component getlocale
string style   component getstyle
// the key prefix is equal to the component path relativ to the
// current component on the top of the stack.
string prefix   strings replaceall component getpagerelativepath          tostring
// the reason why we need to create that stack is because we need to
// walk it downwards starting with page down to the component
list searchstack   getcomponentstack component
// walk the component hierarchy down from page to the component
for  int i   searchstack size     1   i >  0      string    null   i
class clazz    class searchstack get i
// first check if a property with the 'key' provided by the
// user is available.
string   loadstringresource clazz  key  locale  style
// if not, prepend the component relativ path to the key
if   string    null      prefix    null      prefix length   > 0
string   loadstringresource clazz  prefix       key  locale  style
// if still not found, adjust the component relativ path
// for the next component on the path from the page
// down.
if  string    null
prefix   strings afterfirst prefix
return string
/**
* traverse the component hierachy up to the page and add each component
* class to the list (stack) returned
*
* @param component
*            the component to evaluate
* @return the stack of classes
*/
private list getcomponentstack final component component
// build the search stack
final list searchstack   new arraylist
searchstack add component getclass
if    component instanceof page
// add all the component on the way to the page
markupcontainer container   component getparent
while  container    null
searchstack add container getclass
if  container instanceof page
break
container   container getparent
return searchstack