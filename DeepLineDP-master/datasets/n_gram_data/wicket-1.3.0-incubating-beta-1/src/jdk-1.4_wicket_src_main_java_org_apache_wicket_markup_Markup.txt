/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket markup
import java util hashmap
import java util iterator
import java util map
import java util regex matcher
import java util regex pattern
import org apache commons logging log
import org apache commons logging logfactory
/**
* holds markup as a resource (the stream that the markup came from) and a list
* of markupelements (the markup itself).
*
* @see markupelement
* @see componenttag
* @see org.apache.wicket.markup.rawmarkup
*
* @author jonathan locke
* @author juergen donnerstag
*/
public class markup
private static final log log   logfactory getlog markup class
/** placeholder that indicates no markup */
public static final markup no_markup   new markup
/** the list of markup elements */
private markupfragment markup
/** the markup's resource stream for diagnostic purposes */
private markupresourcestream resource
/** if found in the markup, the <?xml ...?> string */
private string xmldeclaration
/** the encoding as found in <?xml ... encoding="" ?>. null, else */
private string encoding
/** wicket namespace: <html xmlns:wicket="http://wicket.apache.org"> */
private string wicketnamespace
/** == wicketnamespace + ":id" */
private string wicketid
/**
* used at markup load time to maintain the current component path (not id)
* while adding markup elements to this markup instance
*/
private stringbuffer currentpath
/**
* a cache which maps (componentpath + id) to the componenttags index in the
* markup
*/
private map componentmap
/**
* constructor
*/
markup
this markup   new markupfragment this
setwicketnamespace componenttag default_wicket_namespace
/**
* initialize the index where <head> can be found.
*/
protected void initialize
// reset
this componentmap   null
if  markup    null
// html tags like <img> may not have a close tag. but because that
// can only be detected until later on in the sequential markup
// reading loop, we only can do it now.
stringbuffer componentpath   null
for  int i   0  i < this markup size    i
markupelement elem   this markup get i
if  elem instanceof componenttag
componenttag tag    componenttag elem
// set the tags components path
componentpath   setcomponentpathfortag componentpath  tag
// and add it to the local cache to be found fast if
// required
addtocache i  tag
// the variable is only needed while adding markup elements.
// initialize() is invoked after all elements have been added.
this currentpath   null
/**
* @param that
*            the markup to compare with
* @return true if the two markups are equal
*/
public boolean equalto final markup that
final markupstream thisstream   new markupstream this
final markupstream thatstream   new markupstream that
// compare the streams
return thisstream equalto thatstream
/**
* @return string representation of markup list
*/
public string tostring
if  resource    null
return resource tostring
else
return
/**
* @return string representation of markup list
*/
public string todebugstring
return this markup tostring
/**
* for wicket it would be sufficient for this method to be package
* protected. however to allow wicket-bench easy access to the
* information ...
*
* @param index
*            index into markup list
* @return markup element
*/
public markupelement get final int index
return markup get index
/**
* gets the resource that contains this markup
*
* @return the resource where this markup came from
*/
markupresourcestream getresource
return resource
/**
* for wicket it would be sufficient for this method to be package
* protected. however to allow wicket-bench easy access to the
* information ...
*
* @return number of markup elements
*/
public int size
return markup size
/**
* return the xml declaration string, in case if found in the markup.
*
* @return null, if not found.
*/
public string getxmldeclaration
return xmldeclaration
/**
* gets the markup encoding. a markup encoding may be specified in a markup
* file with an xml encoding specifier of the form &lt;?xml ...
* encoding="..." ?&gt;.
*
* @return encoding, or null if not found.
*/
public string getencoding
return encoding
/**
* get the wicket namespace valid for this specific markup
*
* @return wicket namespace
*/
public string getwicketnamespace
return this wicketnamespace
/**
* find the markup element index of the component with 'path'
*
* @param path
*            the component path expression
* @param id
*            the component's id to search for
* @return -1, if not found
*/
public int findcomponentindex final string path  final string id
if   id    null      id length      0
throw new illegalargumentexception
// todo post 1.2: a component path e.g. "panel:label" does not match 1:1
// with the markup in case of listview, where the path contains a number
// for each list item. e.g. list:0:label. what we currently do is simply
// remove the number from the path and hope that no user uses an integer
// for a component id. this is a hack only. a much better solution would
// delegate to the various components recursivly to search within there
// realm only for the components markup. listitems could then simply
// do nothing and delegate to their parents.
string completepath    path    null    path length      0 ? id   path       id
// s/:\d+//g
pattern re   pattern compile
matcher matcher   re matcher completepath
completepath   matcher replaceall
// all component tags are registered with the cache
if  this componentmap    null
// not found
return  1
final integer value    integer this componentmap get completepath
if  value    null
// not found
return  1
// return the components position in the markup stream
return value intvalue
/**
* sets encoding.
*
* @param encoding
*            encoding
*/
final void setencoding final string encoding
this encoding   encoding
/**
* sets wicketnamespace.
*
* @param wicketnamespace
*            wicketnamespace
*/
public final void setwicketnamespace final string wicketnamespace
this wicketnamespace   wicketnamespace
this wicketid   wicketnamespace
if   componenttag default_wicket_namespace equals wicketnamespace
log info     wicketnamespace
/**
* sets xmldeclaration.
*
* @param xmldeclaration
*            xmldeclaration
*/
final void setxmldeclaration final string xmldeclaration
this xmldeclaration   xmldeclaration
/**
* sets the resource stream associated with the markup. it is for diagnostic
* purposes only.
*
* @param resource
*            the markup resource stream
*/
final void setresource final markupresourcestream resource
this resource   resource
/**
* add a markupelement
*
* @param markupelement
*/
public final void addmarkupelement final markupelement markupelement
this markup addmarkupelement markupelement
/**
* add a markupelement
*
* @param pos
* @param markupelement
*/
final void addmarkupelement final int pos  final markupelement markupelement
this markup addmarkupelement pos  markupelement
/**
* add the tag to the local cache if open or open-close and if wicket:id is
* present
*
* @param index
* @param tag
*/
private void addtocache final int index  final componenttag tag
// only if the tag has wicket:id="xx" and open or open-close
if   tag isopen      tag isopenclose       tag getattributes   containskey wicketid
// add the tag to the cache
if  this componentmap    null
this componentmap   new hashmap
final string key
if  tag getpath      null
key   tag getpath         tag getid
else
key   tag getid
this componentmap put key  new integer index
/**
* set the components path within the markup and add the component tag to
* the local cache
*
* @param componentpath
* @param tag
* @return componentpath
*/
private stringbuffer setcomponentpathfortag final stringbuffer componentpath
final componenttag tag
// only if the tag has wicket:id="xx" and open or open-close
if   tag isopen      tag isopenclose       tag getattributes   containskey wicketid
// with open-close the path does not change. it can/will not have
// children. the same is true for html tags like <br> or <img>
// which might not have close tags.
if  tag isopenclose      tag hasnoclosetag
// set the components path.
if   this currentpath    null      this currentpath length   > 0
tag setpath this currentpath tostring
else
// set the components path.
if  this currentpath    null
this currentpath   new stringbuffer 100
else if  this currentpath length   > 0
tag setpath this currentpath tostring
this currentpath append
// .. and append the tags id to the component path for the
// children to come
this currentpath append tag getid
else if  tag isclose       this currentpath    null
// for example <wicket:message> does not have an id
if   tag getopentag      null
tag getopentag   getattributes   containskey wicketid
// remove the last element from the component path
int index   this currentpath lastindexof
if  index     1
this currentpath setlength index
else
this currentpath setlength 0
return this currentpath
/**
* make all tags immutable and the list of elements unmodifable.
*/
final void makeimmutable
this markup makeimmutable
// we assume all markup elements have now been added. it is
// now time to initialize all remaining variables based
// on the markup loaded, which could not be initialized
// earlier on.
initialize
/**
* reset the markup to its defaults, except for the wicket
* namespace which remains unchanged.
*/
final void reset
this markup   new markupfragment this
this resource   null
this xmldeclaration   null
this encoding   null
this currentpath   null
/**
* create an iterator for the component tags in the markup.
*
* @param startindex
*            the index to start with
* @param matchclass
*            iterate over elements matching the class
* @return componenttagiterator
*/
public iterator componenttagiterator final int startindex  final class matchclass
return this markup iterator startindex  matchclass