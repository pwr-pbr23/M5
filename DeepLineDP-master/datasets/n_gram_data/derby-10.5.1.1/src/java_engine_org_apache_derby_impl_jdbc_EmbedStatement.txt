/*
derby - class org.apache.derby.impl.jdbc.embedstatement
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl jdbc
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql activation
import org apache derby iapi sql preparedstatement
import org apache derby iapi sql resultset
import org apache derby iapi sql parametervalueset
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi error standardexception
import org apache derby iapi jdbc enginestatement
import java sql sqlexception
import java sql sqlwarning
import java.sql.statement;
import java util vector
/*
we would import these, but have name-overlap
import java.sql.statement;
import java.sql.resultset;
*/
/**
*
* embedstatement is a local jdbc statement.
*
<p><b>supports</b>
<ul>
<li> jsr169 - no subsetting for java.sql.statement
<li> jdbc 2.0
<li> jdbc 3.0 - no new dependencies on new jdbc 3.0 or jdk 1.4 classes,
new methods can safely be added into implementation.
</ul>
*/
public class embedstatement extends connectionchild
implements enginestatement
private final java sql connection applicationconnection
/**
* statement reference the application is using to execute
* this statement. normally set to this, but if this was
* created by a connection from an xaconnection then this
* will be a reference to the brokeredstatement.
*
* making it protected to allow access from embedpreparedstatement40
* to be used for statementevents
*
*/
protected enginestatement applicationstatement
int updatecount    1
embedresultset results
//for jdbc3.0 feature, where you can get a resultset of rows inserted
//for auto generated columns after an insert
private java sql resultset autogeneratedkeysresultset
private string cursorname
private final boolean formetadata
final int resultsettype
final int resultsetconcurrency
private final int resultsetholdability
final languageconnectioncontext lcc
private sqlwarning warnings
string sqltext
private int fetchsize   1
private int fetchdirection   java sql resultset fetch_forward
int maxfieldsize
/**
* query timeout in milliseconds. by default, no statements time
* out. timeout is set explicitly with setquerytimeout().
*/
long timeoutmillis
//the state of this statement, set to false when close() is called
private boolean active   true
//in case of batch update, save the individual statements in the batch in this vector
//this is only used by jdbc 2.0
vector batchstatements
// the maximum # of rows to return per result set.
// (0 means no limit.)
int maxrows
private parametervalueset pvs
// an embedstatement is not poolable by default. the constructor for
// preparedstatement overrides this.
protected boolean ispoolable   false
//
// constructor
//
public embedstatement  embedconnection connection  boolean formetadata
int resultsettype  int resultsetconcurrency  int resultsetholdability
super connection
this formetadata   formetadata
this resultsettype   resultsettype
this resultsetconcurrency   resultsetconcurrency
this resultsetholdability   resultsetholdability
lcc   getembedconnection   getlanguageconnection
applicationconnection   getembedconnection   getapplicationconnection
applicationstatement   this
//
// java.sql.statement interface
// the comments are those from the jdbc interface,
// so we know what we're supposed to to.
/**
* execute a sql statement that returns a single resultset.
*
* @param sql					typically this is a static sql select statement
* @return a resultset that contains the data produced by the
* query; never null
* @exception sqlexception thrown on failure.
*/
public java sql resultset executequery string sql
throws sqlexception
execute sql  true  false  statement no_generated_keys  null  null
if  sanitymanager debug
if  results    null
sanitymanager throwassert
return results
/**
* execute a sql insert, update or delete statement. in addition,
* sql statements that return nothing such as sql ddl statements
* can be executed.
*
* @param sql a sql insert, update or delete statement or a sql
* statement that returns nothing
* @return either the row count for insert, update or delete; or 0
* for sql statements that return nothing
* @exception sqlexception thrown on failure.
*/
public int executeupdate string sql  throws sqlexception
execute sql  false  true  statement no_generated_keys  null  null
return updatecount
/**
* jdbc 3.0
*
* execute the given sql statement and signals the driver with the given flag
* about whether the auto-generated keys produced by this statement object
* should be made available for retrieval.
*
* @param sql a sql insert, update or delete statement or a sql
* statement that returns nothing
* @param autogeneratedkeys - a flag indicating whether auto-generated keys
* should be made available for retrieval; one of the following constants:
* statement.return_generated_keys statement.no_generated_keys
* @return either the row count for insert, update or delete; or 0
* for sql statements that return nothing
* @exception sqlexception if a database access error occurs
*/
public int executeupdate string sql  int autogeneratedkeys  throws sqlexception
execute sql  false  true  autogeneratedkeys  null  null
return updatecount
/**
* jdbc 3.0
*
* executes the given sql statement and signals the driver that the
* auto-generated keys indicated in the given array should be made
* available for retrieval. the driver will ignore the array if the sql
* statement is not an insert statement
*
* @param sql a sql insert, update or delete statement or a sql
* statement that returns nothing
* @param columnindexes - an array of column indexes indicating the
* columns that should be returned from the inserted row
* @return either the row count for insert, update or delete; or 0
* for sql statements that return nothing
* @exception sqlexception if a database access error occurs
*/
public int executeupdate string sql  int columnindexes  throws sqlexception
execute sql  false  true
columnindexes    null      columnindexes length    0
? statement no_generated_keys
statement return_generated_keys
columnindexes

return updatecount
/**
* jdbc 3.0
*
* executes the given sql statement and signals the driver that the
* auto-generated keys indicated in the given array should be made
* available for retrieval. the driver will ignore the array if the sql
* statement is not an insert statement
*
* @param sql a sql insert, update or delete statement or a sql
* statement that returns nothing
* @param columnnames - an array of the names of the columns
* that should be returned from the inserted row
* @return either the row count for insert, update or delete; or 0
* for sql statements that return nothing
* @exception sqlexception if a database access error occurs
*/
public int executeupdate string sql  string columnnames  throws sqlexception
execute sql  false  true
columnnames    null      columnnames length    0
? statement no_generated_keys
statement return_generated_keys

columnnames
return updatecount
final void checkifinmiddleofbatch   throws sqlexception
/* if batchstatements is not null then we are in the middle
* of a batch. that's an invalid state. we need to finish the
* batch either by clearing the batch or executing the batch.
* executeupdate is not allowed inside the batch.
*/
if  batchstatements    null
throw newsqlexception sqlstate middle_of_batch
/**
* tell whether this statment has been closed or not.
*
* @return <code>true</code> is closed, <code>false</code> otherwise.
* @exception sqlexception if a database access error occurs.
*/
public boolean isclosed   throws sqlexception
// if active, verify state by consulting parent connection.
if  active
try
checkexecstatus
catch  sqlexception sqle
return  active
/**
* in many cases, it is desirable to immediately release a
* statements's database and jdbc resources instead of waiting for
* this to happen when it is automatically closed; the close
* method provides this immediate release.
*
* <p><b>note:</b> a statement is automatically closed when it is
* garbage collected. when a statement is closed its current
* resultset, if one exists, is also closed.
* @exception sqlexception thrown on failure.
*/
public final void close   throws sqlexception
/* the close() method is the only method
* that is allowed to be called on a closed
* statement, as per jon ellis.
*/
if   active
return
synchronized  getconnectionsynchronization
closeactions
//we first set the status
active   false
//first, clear the resutl set
clearresultsets
//next, release other resource
cursorname   null
warnings   null
sqltext   null
batchstatements   null
/**
* mark the statement and its single-use activation as unused. this method
* should be called from <code>embedpreparedstatement</code>'s finalizer as
* well, even though prepared statements reuse activations, since
* <code>getgeneratedkeys()</code> uses a single-use activation regardless
* of statement type.
* <br>
* dynamic result sets (those in dynamicresults array) need not
* be handled here as they will be handled by the statement object
* that created them. in some cases results will point to a
* resultset in dynamicresults but all that will happen is that
* the activation will get marked as unused twice.
*/
protected void finalize   throws throwable
super finalize
// we mark the activation as not being used and
// that is it.  we rely on the connection to sweep
// through the activations to find the ones that
// aren't in use, and to close them.  we cannot
// do a activation.close() here because there are
// synchronized methods under close that cannot
// be called during finalization.
if  results    null    results singleuseactivation    null
results singleuseactivation markunused
// allow sub-classes to execute additional close
// logic while holding the synchronization.
void closeactions   throws sqlexception
//----------------------------------------------------------------------
/**
* the maxfieldsize limit (in bytes) is the maximum amount of data
* returned for any column value; it only applies to binary,
* varbinary, longvarbinary, char, varchar, and longvarchar
* columns.  if the limit is exceeded, the excess data is silently
* discarded.
*
* @return the current max column size limit; zero means unlimited
* @exception sqlexception thrown on failure.
*/
public int getmaxfieldsize   throws sqlexception
checkstatus
return maxfieldsize
/**
* the maxfieldsize limit (in bytes) is set to limit the size of
* data that can be returned for any column value; it only applies
* to binary, varbinary, longvarbinary, char, varchar, and
* longvarchar fields.  if the limit is exceeded, the excess data
* is silently discarded.
*
* @param max the new max column size limit; zero means unlimited
* @exception sqlexception thrown on failure.
*/
public void setmaxfieldsize int max  throws sqlexception
checkstatus
if  max < 0
throw newsqlexception sqlstate invalid_maxfield_size  new integer max
this maxfieldsize   max
/**
* the maxrows limit is the maximum number of rows that a
* resultset can contain.  if the limit is exceeded, the excess
* rows are silently dropped.
*
* @return the current max row limit; zero means unlimited
* @exception sqlexception thrown on failure.
*/
public int getmaxrows   throws sqlexception
checkstatus
return maxrows
/**
* the maxrows limit is set to limit the number of rows that any
* resultset can contain.  if the limit is exceeded, the excess
* rows are silently dropped.
*
* @param max the new max rows limit; zero means unlimited
* @exception sqlexception thrown on failure.
*/
public void setmaxrows int max  throws sqlexception
checkstatus
if  max < 0
throw newsqlexception sqlstate invalid_max_rows_value  new integer max
this maxrows   max
/**
* if escape scanning is on (the default) the driver will do
* escape substitution before sending the sql to the database.
*
* @param enable true to enable; false to disable
* @exception sqlexception thrown on failure.
*/
public void setescapeprocessing boolean enable  throws sqlexception
checkstatus
// nothing to do in our server , just ignore it.
/**
* the querytimeout limit is the number of seconds the driver will
* wait for a statement to execute. if the limit is exceeded a
* sqlexception is thrown.
*
* @return the current query timeout limit in seconds; zero means unlimited
* @exception sqlexception thrown on failure.
*/
public final int getquerytimeout   throws sqlexception
checkstatus
return  int   timeoutmillis   1000
/**
* the querytimeout limit is the number of seconds the driver will
* wait for a statement to execute. if the limit is exceeded a
* sqlexception is thrown.
*
* @param seconds the new query timeout limit in seconds; zero means unlimited
* @exception sqlexception thrown on failure.
*/
public final void setquerytimeout int seconds  throws sqlexception
checkstatus
if  seconds < 0
throw newsqlexception sqlstate invalid_querytimeout_value
new integer seconds
timeoutmillis    long  seconds   1000
/**
* cancel can be used by one thread to cancel a statement that
* is being executed by another thread.
* @exception sqlexception thrown on failure.
*/
public void cancel   throws sqlexception
throw util notimplemented
/**
* the first warning reported by calls on this statement is
* returned.  a statment's execute methods clear its sqlwarning
* chain. subsequent statement warnings will be chained to this
* sqlwarning.
*
* <p>the warning chain is automatically cleared each time
* a statement is (re)executed.
*
* <p><b>note:</b> if you are processing a resultset then any
* warnings associated with resultset reads will be chained on the
* resultset object.
*
* @return the first sqlwarning or null
* @exception sqlexception thrown on failure.
*/
public sqlwarning getwarnings   throws sqlexception
checkstatus
return warnings
/**
* after this call getwarnings returns null until a new warning is
* reported for this statement.
* @exception sqlexception thrown on failure.
*/
public void clearwarnings   throws sqlexception
checkstatus
warnings   null
/**
* setcursorname defines the sql cursor name that will be used by
* subsequent statement execute methods. this name can then be
* used in sql positioned update/delete statements to identify the
* current row in the resultset generated by this statement.  if
* the database doesn't support positioned update/delete, this
* method is a noop.
*
* <p><b>note:</b> by definition, positioned update/delete
* execution must be done by a different statement than the one
* which generated the resultset being used for positioning. also,
* cursor names must be unique within a connection.
*
* @param name the new cursor name.
*/
public void setcursorname string name  throws sqlexception
checkstatus
cursorname   name
//----------------------- multiple results --------------------------
/**
* execute a sql statement that may return multiple results.
* under some (uncommon) situations a single sql statement may return
* multiple result sets and/or update counts.  normally you can ignore
* this, unless you're executing a stored procedure that you know may
* return multiple results, or unless you're dynamically executing an
* unknown sql string.  the "execute", "getmoreresults", "getresultset"
* and "getupdatecount" methods let you navigate through multiple results.
*
* the "execute" method executes a sql statement and indicates the
* form of the first result.  you can then use getresultset or
* getupdatecount to retrieve the result, and getmoreresults to
* move to any subsequent result(s).
*
* @param sql					any sql statement
*
* @return true if the first result is a resultset; false if it is an integer
* @see #getresultset
* @see #getupdatecount
* @see #getmoreresults
* @exception sqlexception thrown on failure
*/
public boolean execute string sql
throws sqlexception
return execute sql  false  false  statement no_generated_keys  null  null
/**
* execute a sql statement that may return multiple results.
* under some (uncommon) situations a single sql statement may return
* multiple result sets and/or update counts.  normally you can ignore
* this, unless you're executing a stored procedure that you know may
* return multiple results, or unless you're dynamically executing an
* unknown sql string.  the "execute", "getmoreresults", "getresultset"
* and "getupdatecount" methods let you navigate through multiple results.
*
* the "execute" method executes a sql statement and indicates the
* form of the first result.  you can then use getresultset or
* getupdatecount to retrieve the result, and getmoreresults to
* move to any subsequent result(s).
*
* @param sql					any sql statement
* @param executequery			caller is executequery()
* @param executeupdate			caller is executeupdate()
* @param autogeneratedkeys
* @param columnindexes
* @param columnnames
*
* @return true if the first result is a resultset; false if it is an integer
* @see #getresultset
* @see #getupdatecount
* @see #getmoreresults
* @exception sqlexception thrown on failure
*/
private boolean execute string sql  boolean executequery  boolean executeupdate
int autogeneratedkeys  int columnindexes  string columnnames  throws sqlexception
synchronized  getconnectionsynchronization
checkexecstatus
if  sql    null
throw newsqlexception sqlstate null_sql_text
checkifinmiddleofbatch
clearresultsets       release the last statement executed  if any
setupcontextstack       make sure there's context
// try to remember the sql statement in case anybody asks for it
sqltext   sql
try
activation activation
try
preparedstatement preparedstatement   lcc prepareinternalstatement
lcc getdefaultschema    sql  resultsetconcurrency
java sql resultset concur_read_only  false
activation
preparedstatement getactivation lcc  resultsettype
java sql resultset type_scroll_insensitive
checkrequirescallablestatement activation
catch  throwable t
throw handleexception t
// this is for a statement execution
activation setsingleexecution
//bug 4838 - save the auto-generated key information in activation. keeping this
//information in lcc will not work work it can be tampered by a nested trasaction
if  autogeneratedkeys    statement return_generated_keys
activation setautogeneratedkeysresultsetinfo columnindexes  columnnames
return executestatement activation  executequery  executeupdate
finally
restorecontextstack
/**
* jdbc 3.0
*
* executes the given sql statement, which may return multiple
* results, and signals the driver that any auto-generated keys
* should be made available for retrieval. the driver will ignore
* this signal if the sql statement is not an insert statement.
*
* @param sql any sql statement
* @param autogeneratedkeys - a constant indicating whether
* auto-generated keys should be made available for retrieval using
* the method getgeneratedkeys; one of the following constants:
* statement.return_generated_keys or statement.no_generated_keys
* @return rue if the first result is a resultset object; false if
* it is an update count or there are no results
* @exception sqlexception if a database access error occurs
*/
public boolean execute string sql  int autogeneratedkeys  throws sqlexception
return execute sql  false  false  autogeneratedkeys  null  null
/**
* jdbc 3.0
*
* executes the given sql statement, which may return multiple
* results, and signals the driver that the auto-generated keys
* indicated in the given array should be made available for retrieval.
* this array contains the indexes of the columns in the target table
* that contain the auto-generated keys that should be made available.
* the driver will ignore the array if the given sql statement is not an
* insert statement.
*
* @param sql any sql statement
* @param columnindexes - an array of the indexes of the columns in the
* inserted row that should be made available for retrieval by a call to
* the method getgeneratedkeys
* @return rue if the first result is a resultset object; false if
* it is an update count or there are no results
* @exception sqlexception if a database access error occurs
*/
public boolean execute string sql  int columnindexes  throws sqlexception
return execute sql  false  true
columnindexes    null      columnindexes length    0
? statement no_generated_keys
statement return_generated_keys
columnindexes

/**
* jdbc 3.0
*
* executes the given sql statement, which may return multiple
* results, and signals the driver that the auto-generated keys
* indicated in the given array should be made available for retrieval.
* this array contains the names of the columns in the target table
* that contain the auto-generated keys that should be made available.
* the driver will ignore the array if the given sql statement is not an
* insert statement.
*
* @param sql any sql statement
* @param columnnames - an array of the names of the columns in the
* inserted row that should be made available for retrieval by a call to
* the method getgeneratedkeys
* @return rue if the first result is a resultset object; false if
* it is an update count or there are no results
* @exception sqlexception if a database access error occurs
*/
public boolean execute string sql  string columnnames  throws sqlexception
return execute sql  false  true
columnnames    null      columnnames length    0
? statement no_generated_keys
statement return_generated_keys

columnnames
/**
*  getresultset returns the current result as a resultset.  it
*  should only be called once per result.
*
* @return the current result as a resultset; null if the result
* is an update count or there are no more results or the statement
* was closed.
* @see #execute
*/
public final java sql resultset getresultset   throws sqlexception
checkstatus
return results
/**
*  getupdatecount returns the current result as an update count;
*  if the result is a resultset or there are no more results -1
*  is returned.  it should only be called once per result.
*
* <p>the only way to tell for sure that the result is an update
*  count is to first test to see if it is a resultset. if it is
*  not a resultset it is either an update count or there are no
*  more results.
*
* @return the current result as an update count; -1 if it is a
* resultset or there are no more results
* @see #execute
*/
public final int getupdatecount  	throws sqlexception
checkstatus
return updatecount
/**
* getmoreresults moves to a statement's next result.  it returns true if
* this result is a resultset.  getmoreresults also implicitly
* closes any current resultset obtained with getresultset.
*
* there are no more results when (!getmoreresults() &&
* (getupdatecount() == -1)
*
* @return true if the next result is a resultset; false if it is
* an update count or there are no more results
* @see #execute
* @exception sqlexception thrown on failure.
*/
public final boolean getmoreresults   throws sqlexception
return getmoreresults statement close_all_results
/////////////////////////////////////////////////////////////////////////
//
//	jdbc 2.0 methods that are implemented here because embedpreparedstatement
//  and embedcallablestatement in local20 need access to them, and those
//	classes extend their peer classes in local, instead of embedstatement
//	in local20
//
//  we do the same of jdbc 3.0 methods.
/////////////////////////////////////////////////////////////////////////
/**
* jdbc 2.0
*
* determine the result set type.
*
* @exception sqlexception feature not implemented for now.
*/
public final int getresultsettype
throws sqlexception
checkstatus
return resultsettype
/**
* jdbc 2.0
*
* give a hint as to the direction in which the rows in a result set
* will be processed. the hint applies only to result sets created
* using this statement object.  the default value is
* resultset.fetch_forward.
*
* @param direction the initial direction for processing rows
* @exception sqlexception if a database-access error occurs or direction
* is not one of resultset.fetch_forward, resultset.fetch_reverse, or
* resultset.fetch_unknown
*/
public void setfetchdirection int direction  throws sqlexception
checkstatus
/* fetch direction is meaningless to us. we just save
* it off if it is valid  and return the current value if asked.
*/
if  direction    java sql resultset fetch_forward
direction    java sql resultset fetch_reverse
direction    java sql resultset fetch_unknown
fetchdirection   direction
else
throw newsqlexception sqlstate invalid_fetch_direction
new integer direction
/**
* jdbc 2.0
*
* determine the fetch direction.
*
* @return the default fetch direction
* @exception sqlexception if a database-access error occurs
*/
public int getfetchdirection   throws sqlexception
checkstatus
return fetchdirection
/**
* jdbc 2.0
*
* give the jdbc driver a hint as to the number of rows that should
* be fetched from the database when more rows are needed.  the number
* of rows specified only affects result sets created using this
* statement. if the value specified is zero, then the hint is ignored.
* the default value is zero.
*
* @param rows the number of rows to fetch
* @exception sqlexception if a database-access error occurs, or the
* condition 0 <= rows <= this.getmaxrows() is not satisfied.
*/
public void setfetchsize int rows  throws sqlexception
checkstatus
if  rows < 0      this getmaxrows      0
rows > this getmaxrows
throw newsqlexception sqlstate invalid_st_fetch_size  new integer rows
else if   rows > 0      ignore the call if the value is zero
fetchsize   rows
/**
* jdbc 2.0
*
* determine the default fetch size.
* @exception sqlexception if a database-access error occurs
*
*/
public int getfetchsize   throws sqlexception
checkstatus
return fetchsize
/**
* jdbc 2.0
*
* determine the result set concurrency.
*
* @exception sqlexception feature not implemented for now.
*/
public int getresultsetconcurrency   throws sqlexception
checkstatus
return resultsetconcurrency
/**
* jdbc 3.0
*
* retrieves the result set holdability for resultset objects
* generated by this statement object.
*
* @return either resultset.hold_cursors_over_commit or
* resultset.close_cursors_at_commit
* @exception sqlexception feature not implemented for now.
*/
public final int getresultsetholdability   throws sqlexception
checkstatus
return resultsetholdability
/**
* jdbc 2.0
*
* adds a sql command to the current batch of commmands for the statement.
* this method is optional.
*
* @param sql typically this is a static sql insert or update statement
* @exception sqlexception if a database-access error occurs, or the
* driver does not support batch statements
*/
public void addbatch  string sql   throws sqlexception
checkstatus
synchronized  getconnectionsynchronization
if  batchstatements    null
batchstatements   new vector
batchstatements addelement sql
/**
* jdbc 2.0
*
* make the set of commands in the current batch empty.
* this method is optional.
*
* @exception sqlexception if a database-access error occurs, or the
* driver does not support batch statements
*/
public final void clearbatch   throws sqlexception
checkstatus
synchronized  getconnectionsynchronization
batchstatements   null
/**
* jdbc 2.0
*
* submit a batch of commands to the database for execution.
* this method is optional.
*
* moving jdbc2.0 batch related code in this class because
* callablestatement in jdbc 20 needs this code too and it doesn't derive
* from prepared statement in jdbc 20 in our implementation.
* batchupdateexception is the only new class from jdbc 20 which is being
* referenced here and in order to avoid any jdk11x problems, using
* reflection code to make an instance of that class.
*
* @return an array of update counts containing one element for each
* command in the batch.  the array is ordered according
* to the order in which commands were inserted into the batch
* @exception sqlexception if a database-access error occurs, or the
* driver does not support batch statements
*/
public int executebatch   throws sqlexception
checkexecstatus
synchronized  getconnectionsynchronization
setupcontextstack
int i   0
// as per the jdbc 2.0 specs, close the statement object's current resultset
// if one is open.
// are there results?
// outside of the lower try/finally since results will
// setup and restore themselves.
clearresultsets
vector stmts   batchstatements
batchstatements   null
int size
if  stmts    null
size   0
else
size   stmts size
int returnupdatecountforbatch   new int
sqlexception sqle
try
for    i< size  i
if  executebatchelement stmts elementat i
throw newsqlexception sqlstate resultset_return_not_allowed
returnupdatecountforbatch   getupdatecount
return returnupdatecountforbatch
catch  standardexception se
sqle   handleexception se
catch  sqlexception sqle2
sqle   sqle2
finally
restorecontextstack
int successfulupdatecount   new int
for  int j 0  j<i  j
successfulupdatecount   returnupdatecountforbatch
sqlexception batch
new java sql batchupdateexception sqle getmessage    sqle getsqlstate
sqle geterrorcode    successfulupdatecount
batch setnextexception sqle
batch initcause sqle
throw batch
/**
execute a single element of the batch. overridden by embedpreparedstatement
*/
boolean executebatchelement object batchelement  throws sqlexception  standardexception
return execute  string batchelement  false  true  statement no_generated_keys  null  null
/**
* jdbc 2.0
*
* return the connection that produced the statement.
*
* @exception sqlexception exception if it cannot find the connection
* associated to this statement.
*/
public final java sql connection getconnection    throws sqlexception
checkstatus
java sql connection appconn   getembedconnection   getapplicationconnection
if   appconn    applicationconnection      appconn    null
throw util nocurrentconnection
return appconn
/**
* jdbc 3.0
*
* moves to this statement obect's next result, deals with any current resultset
* object(s) according to the instructions specified by the given flag, and
* returns true if the next result is a resultset object
*
* @param current - one of the following statement constants indicating what
* should happen to current resultset objects obtained using the method
* getresultsetclose_current_result, keep_current_result, or close_all_results
* @return true if the next result is a resultset; false if it is
* an update count or there are no more results
* @see #execute
* @exception sqlexception thrown on failure.
*/
public final boolean getmoreresults int current  throws sqlexception
checkexecstatus
synchronized  getconnectionsynchronization
if  dynamicresults    null
// we only have the one resultset, so this is
// simply a close for us.
clearresultsets
return false
int startingclose
switch  current
default
case statement close_all_results
startingclose   0
break
case statement close_current_result
// just close the current result set.
startingclose   currentdynamicresultset
break
case statement keep_current_result
// make the close loop a no-op.
startingclose   dynamicresults length
break
// close loop.
sqlexception se   null
for  int i   startingclose  i <  currentdynamicresultset    i < dynamicresults length  i
embedresultset lrs   dynamicresults
if  lrs    null
continue
try
lrs close
catch  sqlexception sqle
if  se    null
se   sqle
else
se setnextexception sqle
finally
dynamicresults   null
if  se    null
// leave positioned on the current result set (?)
throw se
updatecount    1
while    currentdynamicresultset < dynamicresults length
embedresultset lrs   dynamicresults
if  lrs    null
if  lrs isclosed
dynamicresults   null
continue
results   lrs
return true
results   null
return false
/**
* jdbc 3.0
*
* retrieves any auto-generated keys created as a result of executing this
* statement object. if this statement is a non-insert statement,
* a null resultset object is returned.
*
* @return a resultset object containing the auto-generated key(s) generated by
* the execution of this statement object
* @exception sqlexception if a database access error occurs
*/
public final java sql resultset getgeneratedkeys   throws sqlexception
checkstatus
if  autogeneratedkeysresultset    null
return null
else
execute    true  false  statement no_generated_keys  null  null
return results
/////////////////////////////////////////////////////////////////////////
//
//	implementation specific methods
//
/////////////////////////////////////////////////////////////////////////
/**
execute the current statement.
@exception sqlexception thrown on failure.
*/
boolean executestatement activation a
boolean executequery  boolean executeupdate
throws sqlexception
// we don't differentiate the update from the resultset case.
// so, there could be a result set.
// note: the statement interface will paste together
// an activation and make sure the prepared statement
// is still valid, so it is preferrable, for now,
// to creating our own activation and stuffing it in
// the prepared statement.
synchronized  getconnectionsynchronization
if  sanitymanager debug
// ensure that clearresultsets has been called
// to fulfill [jdbc4: section 15.2.5 ]
// a resultset object is implicitly closed when:
// the associated statement object is re-executed
sanitymanager assert results    null
sanitymanager assert dynamicresults    null
sanitymanager assert autogeneratedkeysresultset    null
setupcontextstack       make sure there's context
boolean retval
pvs   a getparametervalueset
try
clearwarnings
if    formetadata
commitifneeded       commit the last statement if needed
needcommit
else
if  lcc getactivationcount   > 1
// we do not want to commit here as there seems to be other
// statements/resultsets currently opened for this connection.
else
commitifneeded       we can legitimately commit
needcommit
// if this was a prepared statement, this just
// gets it for us, it won't recompile unless it is invalid.
preparedstatement ps   a getpreparedstatement
ps reprepare lcc
addwarning ps getcompiletimewarnings
/*
** warning warning
**
** any state set in the activation before execution *must* be copied
** to the new activation in genericactivationholder.execute() when
** the statement has been recompiled. state such as
** singleexecution, cursorname, holdability, maxrows.
*/
if  cursorname    null
a setcursorname cursorname
boolean executeholdable   getexecuteholdable
a setresultsetholdability executeholdable
//reset the activation to clear warnings
//and clear existing result sets in case this has been cached
a reset
a setmaxrows maxrows
resultset resultstowrap   ps execute a  timeoutmillis
addwarning a getwarnings
if  resultstowrap returnsrows
// the statement returns rows, so calling it with
// executeupdate() is not allowed.
if  executeupdate
throw standardexception newexception
sqlstate lang_invalid_call_to_execute_update
embedresultset lresults   factory newembedresultset getembedconnection    resultstowrap  formetadata  this  ps isatomic
results   lresults
// set up the finalization of the resultset to
// mark the activation as unused. it will be
// closed sometime later by the connection
// outside of finalization.
if  a issingleexecution
lresults singleuseactivation   a
updatecount    1
retval   true
else
// only applipable for an insert statement, which does not return rows.
//the auto-generated keys resultset will be null if used for non-insert statement
if  a getautogeneratedkeysresultsetmode       resultstowrap getautogeneratedkeysresultset      null
resultstowrap getautogeneratedkeysresultset   open
autogeneratedkeysresultset   factory newembedresultset getembedconnection
resultstowrap getautogeneratedkeysresultset    false  this  ps isatomic
updatecount   resultstowrap modifiedrowcount
results   null     note that we have none
int dynamicresultcount   0
if  a getdynamicresults      null
dynamicresultcount
processdynamicresults a getdynamicresults
a getmaxdynamicresults
resultstowrap close       don't need the result set any more
// executequery() is not allowed if the statement
// doesn't return exactly one resultset.
if  executequery    dynamicresultcount    1
throw standardexception newexception
sqlstate lang_invalid_call_to_execute_query
// executeupdate() is not allowed if the statement
// returns resultsets.
if  executeupdate    dynamicresultcount > 0
throw standardexception newexception
sqlstate lang_invalid_call_to_execute_update
if  dynamicresultcount    0
if  a issingleexecution
a close
if   formetadata
commitifneeded
else
if  lcc getactivationcount   > 1
// we do not want to commit here as there seems to be other
// statements/resultsets currently opened for this connection.
else
commitifneeded       we can legitimately commit
retval    dynamicresultcount > 0
catch  throwable t
if  a issingleexecution
try   a close      catch  throwable tt
throw handleexception t
finally
restorecontextstack
return retval
/**
* add a sqlwarning to this statement object.
* if the statement already has a sqlwarning then it
* is added to the end of the chain.
*
* @see #getwarnings()
*/
final void addwarning sqlwarning sw
if  sw    null
if  warnings    null
warnings   sw
else
warnings setnextexception sw
/* package */
public string getsqltext
// no need to synchronize - accessing a reference is atomic
// synchronized (getconnectionsynchronization())
return sqltext
public parametervalueset getparametervalueset
return pvs
/**
* throw an exception if this statement has been closed explictly
* or it has noticed it has been closed implicitly.
* jdbc specifications require nearly all methods throw a sqlexception
* if the statement has been closed, thus most methods call this
* method or checkexecstatus first.
*
* @exception sqlexception thrown if the statement is marked as closed.
*
* @see #checkexecstatus()
*/
final void checkstatus   throws sqlexception
if   active
//
// check the status of the connection first
//
java sql connection appconn   getembedconnection   getapplicationconnection
if  appconn    null    appconn isclosed
throw util nocurrentconnection
throw newsqlexception sqlstate already_closed
/**
a heavier weight version of checkstatus() that ensures the application's connection
object is still open. this is to stop errors or unexpected behaviour when a [prepared]statement
object is used after the application has been closed. in particular to ensure that
a statement obtained from a pooledconnection cannot be used after the application has closed
its connection (as the underlying connection is still active).
to avoid this heavier weight check on every method of [prepared]statement it is only used
on those methods that would end up using the database's connection to read or modify data.
e.g. execute*(), but not setxxx, etc.
<br>
if this statement's connection is closed an exception will
be thrown and the active field will be set to false,
completely marking the statement as closed.
<br>
if the statement is not currently connected to an active
transaction, i.e. a suspended global transaction, then
this method will throw a sqlexception but the statement
will remain open. the statement is open but unable to
process any new requests until its global transaction
is resumed.
<br>
upon return from the method, with or without a sqlexception
the field active will correctly represent the open state of
the statement.
@exception sqlexception thrown if the statement is marked as closed
or the statement's transaction is suspended.
@see #checkstatus()
*/
final void checkexecstatus   throws sqlexception
// getconnection() checks if the statement is closed
if   getconnection   isclosed
return
// now this connection is closed for all
// future use.
active   false
throw util nocurrentconnection
/**
close and clear all result sets associated with this statement
from the last execution.
*/
void clearresultsets   throws sqlexception
sqlexception sqle   null
try
// are there results?
// outside of the lower try/finally since results will
// setup and restore themselves.
if  results    null
results close
results   null
catch  sqlexception s1
sqle   s1
try
if  autogeneratedkeysresultset    null
autogeneratedkeysresultset close
autogeneratedkeysresultset   null
catch  sqlexception sauto
if  sqle    null
sqle   sauto
else
sqle setnextexception sauto
// close all the dynamic result sets.
if  dynamicresults    null
for  int i   0  i < dynamicresults length  i
embedresultset lrs   dynamicresults
if  lrs    null
continue
try
lrs close
catch  sqlexception sdynamic
if  sqle    null
sqle   sdynamic
else
sqle setnextexception sdynamic
dynamicresults   null
/*
we don't reset statement to null because preparedstatement
relies on it being there for subsequent (post-close) execution
requests.  there is no close method on database statement objects.
*/
updatecount    1     reset field
if  sqle    null
throw sqle
/**
check to see if a statement requires to be executed via a callable statement.
*/
void checkrequirescallablestatement activation activation  throws sqlexception
parametervalueset pvs   activation getparametervalueset
if  pvs    null
return
if  pvs checknodeclaredoutputparameters
try
activation close
catch  standardexception se
throw newsqlexception sqlstate requires_callable_statement  sqltext
/**
transfer my batch of statements to a newly created statement.
*/
public void transferbatch embedstatement other  throws sqlexception
synchronized  getconnectionsynchronization
other batchstatements   batchstatements
batchstatements   null
/**
* set the application statement for this statement.
*/
public final void setapplicationstatement enginestatement s
this applicationstatement   s
private embedresultset dynamicresults
private int currentdynamicresultset
/**
* go through a holder of dynamic result sets, remove those that
* should not be returned, and sort the result sets according to
* their creation.
*
* @param holder a holder of dynamic result sets
* @param maxdynamicresultsets the maximum number of result sets
* to be returned
* @return the actual number of result sets
* @exception sqlexception if an error occurs
*/
private int processdynamicresults java sql resultset holder
int maxdynamicresultsets
throws sqlexception
embedresultset sorted   new embedresultset
int actualcount   0
for  int i   0  i < holder length  i
java sql resultset param   holder
java sql resultset rs   param
// clear the jdbc dynamic resultset from the language
// resultset for the call statement. this stops the
// call statement closing the resultset when its language
// resultset is closed, which will happen just after the
// call to the processdynamicresults() method.
param   null
// ignore non-derby result sets or results sets from another connection
// and closed result sets.
embedresultset lrs   embedstatement processdynamicresult
getembedconnection    rs  this
if  lrs    null
continue
sorted   lrs
if  actualcount    0
// results are defined to be ordered according to their creation
if  actualcount    1
java util arrays sort sorted  0  actualcount
dynamicresults   sorted
if  actualcount > maxdynamicresultsets
addwarning standardexception newwarning sqlstate lang_too_many_dynamic_results_returned
for  int i   maxdynamicresultsets  i < actualcount  i
sorted close
sorted   null
actualcount   maxdynamicresultsets
updatecount    1
results   sorted
currentdynamicresultset   0
// 0100c is not returned for procedures written in java, from the sql2003 spec.
// getwarnings(standardexception.newwarning(sqlstate.lang_dynamic_results_returned));
return actualcount
/**
* process a resultset created in a java procedure as a dynamic result.
* to be a valid dynamic result the resultset must be:
* <ul>
* <li> from a derby system
* <li> from a nested connection of connection passed in
* or from the connection itself.
* <li> open
* </ul>
* any invalid resultset is ignored.
*
*
* @param conn connection resultset needs to belong to
* @param resultset resultset to be tested
* @param callstatement statement that executed the call, null if
* @return the result set cast down to embedresultset, null if not a valid
* dynamic result.
*/
static embedresultset processdynamicresult embedconnection conn
java sql resultset resultset
embedstatement callstatement
if  resultset    null
return null
// ignore non-derby result sets or results sets from another connection
if    resultset instanceof embedresultset
return null
embedresultset lrs    embedresultset  resultset
if  lrs getembedconnection   rootconnection    conn rootconnection
return null
// ignore closed result sets.
try
//following will check if the jdbc resultset or the language
//resultset is closed. if yes, then it will throw an exception.
//so, the exception indicates that the resultset is closed and
//hence we should ignore it.
lrs checkifclosed
catch  sqlexception ex
return null
lrs setdynamicresultset callstatement
return lrs
/**
callback on the statement when one of its result sets is closed.
this allows the statement to control when it completes and hence
when it commits in auto commit mode.
must have connection synchronization and setupcontextstack(), this
is required for the call to commitifneeded().
*/
void resultsetclosing embedresultset closinglrs  throws sqlexception
// if the connection is not in auto commit then this statement completion
// cannot cause a commit.
if   getembedconnection   autocommit
return
// if we have dynamic results, see if there is another result set open.
// if so, then no commit. the last result set to close will close the statement.
if  dynamicresults    null
for  int i   0  i < dynamicresults length  i
embedresultset lrs   dynamicresults
if  lrs    null
continue
if  lrs isclosed
continue
if  lrs    closinglrs
continue
// at least one still open so no commit now.
return
// new throwable("commit on " + sqltext).printstacktrace(system.out);
// beetle 5383.  force a commit in autocommit always.  before this
// change if client in autocommit opened a result set, did a commit,
// then next then close a commit would not be forced on the close.
commitifautocommit
/**
* get the execute time holdability for the statement.
* when in a global transaction holdabilty defaults to false.
* @throws sqlexception error from getresultsetholdability.
*/
private boolean getexecuteholdable   throws sqlexception
if  resultsetholdability     java sql resultset close_cursors_at_commit
return false
// simple non-xa case
if  applicationstatement    this
return true
return applicationstatement getresultsetholdability
java sql resultset hold_cursors_over_commit
/**
* returns the value of the embedstatement's poolable hint,
* indicating whether pooling is requested.
*
* @return the value of the poolable hint.
* @throws sqlexception if the statement has been closed.
*/
public boolean ispoolable   throws sqlexception
// assert the statement is still active (not closed)
checkstatus
return ispoolable
/**
* requests that an embedstatement be pooled or not.
*
* @param poolable requests that the embedstatement be pooled if true
* and not be pooled if false.
* @throws sqlexception if the embedstatement has been closed.
*/
public void setpoolable boolean poolable  throws sqlexception
// assert the statement is still active (not closed)
checkstatus
ispoolable   poolable