/*
derby - class org.apache.derby.impl.services.locks.deadlock
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services locks
import org apache derby iapi services locks virtuallocktable
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi services context contextservice
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store access transactioninfo
import java util hashtable
import java util dictionary
import java util stack
import java util list
/**
code to support deadlock detection.
*/
class deadlock
private deadlock
/**
* look for a deadlock.
* <br>
* walk through the graph of all locks and search for cycles among
* the waiting lock requests which would indicate a deadlock. a simple
* deadlock cycle is where the granted locks of waiting compatibility
* space a is blocking compatibility space b and space b holds locks causing
* space a to wait.
* <p>
* would be nice to get a better high level description of deadlock
* search.
* <p>
* mt - if the <code>locktable</code> is a <code>lockset</code> object, the
* callers must be synchronized on the <code>lockset</code> object in order
* to satisfy the syncronization requirements of
* <code>lockset.addwaiters()</code>. if it is a
* <code>concurrentlockset</code> object, the callers must not hold any of
* the <code>reentrantlock</code>s guarding the entries in the lock table,
* and the callers must make sure that only a single thread calls
* <code>look()</code> at a time.
*
*
* @param factory the locking system factory
* @param set the complete lock table. a lock table is a hash
* table keyed by a lockable and with a lockcontrol as
* the data element.
* @param control a lockcontrol contains a reference to the item being
* locked and doubly linked lists for the granted locks
* and the waiting locks. the passed in value is the
* lock that the caller was waiting on when woken up
* to do the deadlock check.
* @param startinglock represents the specific waiting lock request that
* the caller has been waiting on, before just being
* woken up to do this search.
* @param deadlockwake either constants.waiting_lock_in_wait, or
* constants.waiting_lock_deadlock.
*
* @return the identifier to be used to open the conglomerate later.
*
* @exception standardexception standard exception policy.
*/
static object look abstractpool factory  locktable set
lockcontrol control  activelock startinglock
byte deadlockwake
// step one, get a list of all waiters
dictionary waiters   deadlock getwaiters set
// this stack will track the potential deadlock chain
// the stack consists of
// start (vector element 0)
// - compatibility space of waiter a
// - stack of compatibility spaces with granted lock for waiter a
stack chain   new stack
chain push startinglock getcompatabilityspace
chain push control getgrants
outer 	for
if  chain isempty
// all done
break outer
list grants    list  chain peek
if  grants isempty
// pop this list of granted locks and back to the previous one
rollback chain
continue outer
int endstack   grants size     1
object space     lock  grants get endstack   getcompatabilityspace
// this stack of granted locks can contain multiple entries
// for a single space. we don't want to do deadlock detection
// twice so check to see if we have seen this space already.
for  int gs   0  gs < endstack  gs
if  space equals   lock  grants get gs   getcompatabilityspace
chain push space      set up as rollback   expects
rollback chain
continue outer
// find if this space is waiting on anyone
inner 		for
int index   chain indexof space
if  index     1
// we could be seeing a situation here like
// granted t1{s}, t2{s}
// waiting t1{x} - deadlock checking on this
//
// in this case it's not a deadlock, although it
// depends on the locking policy of the lockable. e.g.
// granted t1(latch)
// waiting t1(latch)
//  is a deadlock.
//
if   index     chain size     1
index     chain size     2
index     chain indexof grants    1
// potential self deadlock, but probably not!
activelock lock    activelock  waiters get space
if  lock canskip
// not a deadlock ...
chain push space      set up as rollback   expects
rollback chain
continue outer
return deadlock handle factory  chain  index  waiters  deadlockwake
chain push space
lock waitinglock    lock  waiters get space
if  waitinglock    null
// end of the road, no deadlock in this path
// pop items until the previous stack
rollback chain
continue outer
// is a lockcontrol or another activelock
object waiton   waiters get waitinglock
if  waiton instanceof lockcontrol
lockcontrol waitoncontrol    lockcontrol  waiton
// this lock control may have waiters but no
// one holding the lock. this is true if lock
// has just been released but the waiters haven't
// woken up, or they are trying to get the synchronization we hold.
if  waitoncontrol isunlocked
// end of the road, no deadlock in this path
// pop items until the previous stack
rollback chain
continue outer
chain push waitoncontrol getgrants
continue outer
else
// simply waiting on another waiter
space   waitinglock getcompatabilityspace
return null
private static void rollback stack chain
do
chain pop
if  chain isempty
return
while    chain peek   instanceof list
// remove the last element, the one we were looking at
list grants    list  chain peek
grants remove grants size     1
private static hashtable getwaiters locktable set
hashtable waiters   new hashtable
set addwaiters waiters
return waiters
private static object handle abstractpool factory  stack chain  int start
dictionary waiters  byte deadlockwake
// if start is zero then the space that started looking for the
// deadlock is activly involved in the deadlock.
object checker   chain elementat 0
int minlockcount   integer max_value
object victim   null
for  int i   start  i < chain size    i
object space   chain elementat i
if  space instanceof list
continue
// see if the checker is in the deadlock and we
// already picked as a victim
if   checker equals space       deadlockwake    constants waiting_lock_deadlock
victim   checker
break
lockspace ls    lockspace  space
int spacecount   ls deadlockcount minlockcount
if  spacecount <  minlockcount
victim   space
minlockcount   spacecount
// see if the vitim is the one doing the checking
if  checker equals victim
object data   new object
data   chain
data   waiters
return data
activelock victimlock    activelock  waiters get victim
victimlock wakeup constants waiting_lock_deadlock
return null
static standardexception buildexception abstractpool factory
object data
stack chain    stack  data
dictionary waiters    dictionary  data
languageconnectioncontext lcc    languageconnectioncontext
contextservice getcontext languageconnectioncontext context_id
tablenameinfo tabinfo   null
transactioninfo tt   null
transactioncontroller tc   null
if  lcc    null
try
tc   lcc gettransactionexecute
tabinfo   new tablenameinfo lcc  false
tt   tc getaccessmanager   gettransactioninfo
catch  standardexception se
// just don't get any table info.
stringbuffer sb   new stringbuffer 200
hashtable attributes   new hashtable 17
string victimxid   null
for  int i   0  i < chain size    i
object space   chain elementat i
if  space instanceof list
list grants    list  space
if  grants size      0
sb append
for  int j   0  j < grants size    j
if  j    0
sb append
lock gl    lock  grants get j
sb append
sb append gl getcompatabilityspace   getowner
sb append
sb append gl getqualifier
sb append
sb append
continue
// information about the lock we are waiting on
// type |tablename                     |lockname
lock lock     lock  waiters get space
// see if this lockable object wants to participate
lock getlockable   lockattributes virtuallocktable all  attributes
addinfo sb     attributes get virtuallocktable locktype
if  tabinfo    null
long conglomid    long  attributes get virtuallocktable conglomid
if  conglomid    null
long containerid    long  attributes get virtuallocktable containerid
try
conglomid   new long tc findconglomid containerid longvalue
catch  standardexception se
addinfo sb     tabinfo gettablename conglomid
addinfo sb     attributes get virtuallocktable lockname
sb append
string xid
string valueof lock getcompatabilityspace   getowner
if  i    0
victimxid   xid
addinfo sb     xid
addinfo sb     lock getqualifier
sb append
if  tt    null
for  int tti   tt length   1  tti >  0  tti
transactioninfo ti   tt
// resolve (track 2771) - not sure why
// ti.gettransactionidstring() or ti can return null.
if  ti    null
string idstring   ti gettransactionidstring
if  idstring    null    idstring equals xid
addinfo sb     ti getusernamestring
addinfo sb     ti getstatementtextstring
break
sb append
attributes clear
standardexception se   standardexception newexception sqlstate deadlock  sb tostring    victimxid
se setreport factory deadlockmonitor
return se
private static void addinfo stringbuffer sb  string desc  object data
sb append desc
if  data    null
data
sb append data