/*
derby - class org.apache.derby.impl.sql.compile.halfouterjoinnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services context contextmanager
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile optimizablepredicate
import org apache derby iapi sql compile optimizablepredicatelist
import org apache derby iapi sql compile optimizer
import org apache derby iapi sql compile costestimate
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi error standardexception
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi util jbitset
import java util properties
/**
* an halfouterjoinnode represents a left or a right outer join result set.
* right outer joins are always transformed into left outer joins during
* preprocessing for simplicity.
*
*/
public class halfouterjoinnode extends joinnode
private boolean rightouterjoin
private boolean transformed   false
/**
* initializer for a halfouterjoinnode.
*
* @param leftresult		the resultsetnode on the left side of this join
* @param rightresult		the resultsetnode on the right side of this join
* @param onclause			the on clause
* @param usingclause		the using clause
* @param rightouterjoin	whether or not this node represents a user
*							specified right outer join
* @param tableproperties	properties list associated with the table
*
* @exception standardexception		thrown on error
*/
public void init
object leftresult
object rightresult
object onclause
object usingclause
object rightouterjoin
object tableproperties
throws standardexception
super init
leftresult
rightresult
onclause
usingclause

tableproperties

this rightouterjoin     boolean  rightouterjoin  booleanvalue
/* we can only flatten an outer join
* using the null intolerant predicate xform.
* in that case, we will return an innerjoin.
*/
flattenablejoin   false
/*
*  optimizable interface
*/
/**
* @see optimizable#pushoptpredicate
*
* @exception standardexception		thrown on error
*/
public boolean pushoptpredicate optimizablepredicate optimizablepredicate
throws standardexception
/* we should never push the predicate to joinpredicates as in joinnode.  joinpredicates
* should only be predicates relating the two joining tables.  in the case of half join,
* it is biased.  if the general predicate (not join predicate) contains refernce to right
* result set, and if doesn't qualify, we shouldn't return the row for the result to be
* correct, but half join will fill right side null and return the row.  so we can only
* push predicate to the left, as we do in "pushexpression".  bug 5055
*/
fromtable		leftfromtable    fromtable  leftresultset
if  leftfromtable getreferencedtablemap   contains optimizablepredicate getreferencedmap
return leftfromtable pushoptpredicate optimizablepredicate
return false
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return 	    rightouterjoin
transformed
super tostring
else
return
/**
* put a projectrestrictnode on top of each fromtable in the fromlist.
* columnreferences must continue to point to the same resultcolumn, so
* that resultcolumn must percolate up to the new prn.  however,
* that resultcolumn will point to a new expression, a virtualcolumnnode,
* which points to the fromtable and the resultcolumn that is the source for
* the columnreference.
* (the new prn will have the original of the resultcolumnlist and
* the resultcolumns from that list.  the fromtable will get shallow copies
* of the resultcolumnlist and its resultcolumns.  resultcolumn.expression
* will remain at the fromtable, with the prn getting a new
* virtualcolumnnode for each resultcolumn.expression.)
* we then project out the non-referenced columns.  if there are no referenced
* columns, then the prn's resultcolumnlist will consist of a single resultcolumn
* whose expression is 1.
*
* @param numtables			number of tables in the dml statement
* @param gbl				the group by list, if any
* @param fromlist			the from list, if any
*
* @return the generated projectrestrictnode atop the original fromtable.
*
* @exception standardexception		thrown on error
*/
public resultsetnode preprocess int numtables
groupbylist gbl
fromlist fromlist
throws standardexception
resultsetnode newtreetop
/* transform right outer joins to the equivalent left outer join */
if  rightouterjoin
/* verify that a user specifed right outer join is transformed into
* a left outer join exactly once.
*/
if  sanitymanager debug
sanitymanager assert   transformed
resultsetnode tmp   leftresultset
leftresultset   rightresultset
rightresultset   tmp
transformed   true
newtreetop   super preprocess numtables  gbl  fromlist
return newtreetop
/**
* push expressions down to the first resultsetnode which can do expression
* evaluation and has the same referenced table map.
* resolve - this means only pushing down single table expressions to
* distinctnodes today.  once we have a better understanding of how
* the optimizer will work, we can push down join clauses.
*
* @param outerpredicatelist	the predicatelist from the outer rs.
*
* @exception standardexception		thrown on error
*/
public void pushexpressions predicatelist outerpredicatelist
throws standardexception
fromtable		leftfromtable    fromtable  leftresultset
fromtable		rightfromtable    fromtable  rightresultset
/* we only try to push single table predicates to the left.
* pushing them to the right would give incorrect semantics.
* we use the logic for pushing down single table predicates here.
*/
pushexpressionstoleft outerpredicatelist
/* push the pushable outer join predicates to the right.  this is done
* bottom up, hence at the end of this method, so that outer join
* conditions only get pushed down 1 level.
* we use the optimizer's logic for pushing down join clause here.
*/
// walk joinpredicates backwards due to possible deletes
for  int index   joinpredicates size     1  index >  0  index
predicate predicate
predicate    predicate  joinpredicates elementat index
if    predicate getpushable
continue
getrightpredicatelist   addpredicate predicate
/* remove the matching predicate from the outer list */
joinpredicates removeelementat index
/* recurse down both sides of tree */
predicatelist	nopredicates
predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
leftfromtable pushexpressions getleftpredicatelist
rightfromtable pushexpressions nopredicates
/**
* this method determines if (1) the query is a loj, and (2) if the loj is a candidate for
* reordering (i.e., linearization).  the condition for loj linearization is:
* 1. only loj in the fromlist, i.e., no inner, no full joins, no rojs
* 2. on clause must be equality join between left and right operands and in cnf (i.e., and is allowed)
*/
public boolean loj_reorderable int numtables
throws standardexception
boolean anychange   false
resultsetnode logicalleftresultset      row preserving side
resultsetnode logicalrightresultset     null producing side
// figure out which is the row-preserving side and which is
// null-producing side.
if  rightouterjoin
right outer join
logicalleftresultset    rightresultset
logicalrightresultset   leftresultset
else
logicalleftresultset    leftresultset
logicalrightresultset   rightresultset
// redundantly normalize the on predicate (it will also be called in preprocess()).
super normexpressions
// this is a very simple loj of base tables. do nothing.
if  logicalleftresultset instanceof frombasetable
logicalrightresultset instanceof frombasetable
return anychange
// recursively check if we can reordering loj, and build the table
// references. note that joins may have been reordered and therefore the
// table references need to be recomputed.
if  logicalleftresultset instanceof halfouterjoinnode
anychange  	  halfouterjoinnode logicalleftresultset  loj_reorderable numtables     anychange
else if    logicalleftresultset instanceof frombasetable
left operand must be either a base table or another loj
// in principle, we don't care about the left operand.  however, we
// need to re-bind the resultcolumns.  if the left operand is a
// view, we may have to re-bind the where clause etc...
// we ran into difficulty for the following query:
//  create view v8 (cv, bv, av) as (select c, b, a from t union select f, e, d from s);
//  select * from v8 left outer join (s left outer join r on (f = i)) on (e=v8.bv);
return anychange
if  logicalrightresultset instanceof halfouterjoinnode
anychange     halfouterjoinnode logicalrightresultset  loj_reorderable numtables     anychange
else if    logicalrightresultset instanceof frombasetable
right operand must be either a base table or another loj
return anychange
// it is much easier to do loj reordering if there is no roj.
// however, we ran into some problem downstream when we transform an roj
// into loj -- transformouterjoin() didn't expect roj to be transformed
// into loj alread.  so, we skip optimizing roj at the moment.
if  rightouterjoin     logicalrightresultset instanceof halfouterjoinnode
halfouterjoinnode logicalrightresultset  rightouterjoin
return loj_bindresultcolumns anychange
// build the data structure for testing/doing loj reordering.
// fill in the table references on row-preserving and null-producing sides.
// it may be possible that either operand is a complex view.
jbitset				npreferencedtablemap     null producing
jbitset				rpreferencedtablemap     row preserving
rpreferencedtablemap   logicalleftresultset lojgetreferencedtables numtables
npreferencedtablemap   logicalrightresultset lojgetreferencedtables numtables
if   rpreferencedtablemap    null    npreferencedtablemap    null
anychange
return loj_bindresultcolumns anychange
// check if the predicate is equality predicate in cnf (i.e., and only)
// and left/right column references must come from either operand.
// that is, we don't allow:
// 1. a=a
// 2. 1=1
// 3. b=c where both b and c are either from left or right operand.
// we probably need to make the joinclause "left-deep" so that we can
// walk it easier.
binaryrelationaloperatornode equals
valuenode leftcol
valuenode rightcol
andnode   and
valuenode left
valuenode vn   joinclause
while  vn instanceof andnode
and    andnode  vn
left   and getleftoperand
// make sure that this is an equijoin of the form "c = d" where c
// and d references tables from both left and right operands.
if  left instanceof relationaloperator
valuenode left  isbinaryequalsoperatornode
equals    binaryrelationaloperatornode  left
leftcol   equals getleftoperand
rightcol   equals getrightoperand
if     leftcol instanceof columnreference    rightcol instanceof columnreference
return loj_bindresultcolumns anychange
boolean refcheck   false
boolean leftoperandcheck   false
if  rpreferencedtablemap get   columnreference leftcol  gettablenumber
refcheck   true
leftoperandcheck   true
else if  npreferencedtablemap get   columnreference leftcol  gettablenumber
refcheck   true
if  refcheck    false
return loj_bindresultcolumns anychange
refcheck   false
if  leftoperandcheck    false    rpreferencedtablemap get   columnreference rightcol  gettablenumber
refcheck   true
else if  leftoperandcheck    true    npreferencedtablemap get   columnreference rightcol  gettablenumber
refcheck   true
if  refcheck    false
return loj_bindresultcolumns anychange
else return loj_bindresultcolumns anychange       get out of here
vn   and getrightoperand
// check if the logical right resultset is a composite inner and as such
// that this current loj can be pushed through it.
boolean       push   false
// logical right operand is another loj... so we may be able to push the
// join
if  logicalrightresultset instanceof halfouterjoinnode
// get the null-producing operand of the child
jbitset  logicalnpreftablemap     halfouterjoinnode logicalrightresultset  lojgetnpreferencedtables numtables
// does the current loj join predicate reference
// logicalnpreftablemap?  if not, we can push the current
// join.
vn   joinclause
push   true
while  vn instanceof andnode
and    andnode  vn
left   and getleftoperand
equals    binaryrelationaloperatornode  left
leftcol   equals getleftoperand
rightcol   equals getrightoperand
if  logicalnpreftablemap get   columnreference leftcol  gettablenumber
logicalnpreftablemap get   columnreference rightcol  gettablenumber
push   false
break
vn   and getrightoperand
// push the current loj into the next level
if  push
// for safety, check the joinnode data members: they should null or
// empty list before we proceed.
if  super subquerylist size      0
joinnode logicalrightresultset  subquerylist size      0
super joinpredicates size      0
joinnode logicalrightresultset  joinpredicates size      0
super usingclause    null
joinnode logicalrightresultset  usingclause    null
return loj_bindresultcolumns anychange       get out of here
anychange   true     we are reordering the lojs
resultsetnode tmp   logicalleftresultset
resultsetnode lchild  rchild
//            this loj
//            /      \
//  logicalleftrs   logicalrightrs
//                   /     \
//                lchild  rchild
// becomes
//
//               this loj
//               /      \
//     logicalrightrs   rchild
//           /     \
// logicalleftrs   lchild  <<<  we need to be careful about this order
//                              as the "logicalrightrs may be a roj
//
// handle the lower level loj node
lchild     halfouterjoinnode logicalrightresultset  leftresultset
rchild     halfouterjoinnode logicalrightresultset  rightresultset
halfouterjoinnode logicalrightresultset  rightresultset   lchild
halfouterjoinnode logicalrightresultset  leftresultset    tmp
// switch the on clause
vn   joinclause
joinclause       halfouterjoinnode logicalrightresultset  joinclause
halfouterjoinnode logicalrightresultset  joinclause   vn
// no need to switch halfouterjoinnode data members for now because
// we are handling only loj.
// boolean local_rightouterjoin = rightouterjoin;
// boolean local_transformed    = transformed;
// rightouterjoin = ((halfouterjoinnode)logicalrightresultset).rightouterjoin;
// transformed    = ((halfouterjoinnode)logicalrightresultset).transformed;
// ((halfouterjoinnode)logicalrightresultset).rightouterjoin = local_rightouterjoin;
// ((halfouterjoinnode)logicalrightresultset).transformed    = local_transformed;
fromlist localfromlist    fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
// switch loj nodes: by handling the current loj node
leftresultset    logicalrightresultset
rightresultset   rchild
// rebuild the result columns and re-bind column references
halfouterjoinnode leftresultset  resultcolumns   null
joinnode leftresultset  bindresultcolumns localfromlist      localfromlist is empty
// left operand must be another loj, try again until a fixpoint
boolean localchange     halfouterjoinnode leftresultset  loj_reorderable numtables
// rebuild the result columns and re-bind column references for 'this'
return loj_bindresultcolumns anychange
return loj_bindresultcolumns anychange
// this method re-binds the result columns which may be referenced in the on
// clause in this node.
public boolean loj_bindresultcolumns boolean anychange
throws standardexception
if  anychange
this resultcolumns   null
fromlist localfromlist    fromlist  getnodefactory   getnode c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
joinnode this  bindresultcolumns localfromlist
return anychange
/**
* transform any outer join into an inner join where applicable.
* (based on the existence of a null intolerant
* predicate on the inner table.)
*
* @param predicatetree	the predicate tree for the query block
*
* @return the new tree top (outerjoin or innerjoin).
*
* @exception standardexception		thrown on error
*/
public fromtable transformouterjoins valuenode predicatetree  int numtables
throws standardexception
resultsetnode innerrs
if  predicatetree    null
/* we can't transform this node, so tell both sides of the
* outer join that they can't get flattened into outer query block.
*/
leftresultset notflattenablejoin
rightresultset notflattenablejoin
return this
super transformouterjoins predicatetree  numtables
jbitset innermap   new jbitset numtables
if  rightouterjoin
if  sanitymanager debug
sanitymanager assert   transformed
innerrs   leftresultset
else
innerrs   rightresultset
innerrs fillinreferencedtablemap innermap
/* walk predicates looking for
* a null intolerant predicate on the inner table.
*/
valuenode vn   predicatetree
while  vn instanceof andnode
andnode and    andnode  vn
valuenode left   and getleftoperand
/* skip is null predicates as they are not null intolerant */
if  left isinstanceof c_nodetypes is_null_node
vn   and getrightoperand
continue
/* only consider predicates that are relops */
if  left instanceof relationaloperator
jbitset refmap   new jbitset numtables
/* do not consider method calls,
* conditionals, field references, etc. */
if     left categorize refmap  true
vn   and getrightoperand
continue
/* if the predicate is a null intolerant predicate
* on the right side then we can flatten to an
* inner join.  we do the xform here, flattening
* will happen later.
*/
for  int bit   0  bit < numtables  bit
if  refmap get bit     innermap get bit
// oj -> ij
joinnode ij     joinnode
getnodefactory   getnode
c_nodetypes join_node
leftresultset
rightresultset
joinclause

resultcolumns


getcontextmanager
ij settablenumber tablenumber
ij setsubquerylist subquerylist
ij setaggregatevector aggregatevector
return ij
vn   and getrightoperand
/* we can't transform this node, so tell both sides of the
* outer join that they can't get flattened into outer query block.
*/
leftresultset notflattenablejoin
rightresultset notflattenablejoin
return this
/** @see joinnode#adjustnumberofrowsreturned */
protected void adjustnumberofrowsreturned costestimate costestimate
/*
** an outer join returns at least as many rows as in the outer
** table. even if this started as a right outer join, it will
** have been transformed to a left outer join by this point.
*/
costestimate outercost   getleftresultset   getcostestimate
if  costestimate rowcount   < outercost rowcount
costestimate setcost costestimate getestimatedcost
outercost rowcount
outercost rowcount
/**
* generate the code for an inner join node.
*
* @exception standardexception		thrown on error
*/
public void generate activationclassbuilder acb
methodbuilder mb
throws standardexception
/* verify that a user specifed right outer join is transformed into
* a left outer join exactly once.
*/
if  sanitymanager debug
sanitymanager assert rightouterjoin    transformed
rightouterjoin
transformed
super generatecore acb  mb  leftouterjoin
/**
* generate	and add any arguments specifict to outer joins.
* generate	the methods (and add them as parameters) for
* returning an empty row from 1 or more sides of an outer join,
* if required.  pass whether or not this was originally a
* right outer join.
*
* @param acb		the activationclassbuilder
* @param mb the method the generate code is to go into
*
* return the args that have been added
*
* @exception standardexception		thrown on error
*/
protected int addouterjoinarguments activationclassbuilder acb
methodbuilder mb
throws standardexception
/* nulls always generated from the right */
rightresultset getresultcolumns   generatenulls acb  mb
/* was this originally a right outer join? */
mb push rightouterjoin
return 2
/**
* return the number of arguments to the join result set.
*/
protected int getnumjoinarguments
/* we add two more arguments than the superclass does */
return super getnumjoinarguments     2
protected void onerowrightside activationclassbuilder acb
methodbuilder mb
// always return false for now
mb push false
mb push false      isnotexists?
/**
* return the logical left result set for this qualified
* join node.
* (for right outer join, the left is the right
* and the right is the left and the join is the nioj).
*/
resultsetnode getlogicalleftresultset
if  rightouterjoin
return rightresultset
else
return leftresultset
/**
* return the logical right result set for this qualified
* join node.
* (for right outer join, the left is the right
* and the right is the left and the join is the nioj).
*/
resultsetnode getlogicalrightresultset
if  rightouterjoin
return leftresultset
else
return rightresultset
/**
* return true if right outer join or false if left outer join
* used to set nullability correctly in joinnode
*/
public boolean isrightouterjoin
return rightouterjoin
// return the null-producing table references
public jbitset lojgetnpreferencedtables int numtables
throws standardexception
if  rightouterjoin     transformed
return  jbitset  leftresultset lojgetreferencedtables numtables
else
return  jbitset  rightresultset lojgetreferencedtables numtables