/*
derby - class org.apache.derby.impl.drda.drdastatement
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl drda
import java io ioexception
import java io unsupportedencodingexception
import java lang reflect invocationtargetexception
import java lang reflect method
import java math biginteger
import java sql callablestatement
import java sql connection
import java sql parametermetadata
import java sql preparedstatement
import java sql resultset
import java sql sqlexception
import java sql statement
import java util arraylist
import java util hashtable
import java util stringtokenizer
import java util vector
import java lang reflect array
import org apache derby iapi jdbc brokeredconnection
import org apache derby iapi jdbc brokeredpreparedstatement
import org apache derby iapi jdbc enginepreparedstatement
import org apache derby iapi jdbc engineresultset
import org apache derby iapi reference jdbc30translation
import org apache derby iapi sql execute executioncontext
import org apache derby iapi util stringutil
import org apache derby impl jdbc util
/**
drdastatement stores information about the statement being executed
*/
class drdastatement
//note!
//
// since drdastatements are reused, all variables (except those noted in
// the comments for reset method) should be set to their default values
// in reset().
protected string typdefnam 		  typdefnam for this statement
protected int byteorder 		  deduced from typdefnam  save string comparisons
protected int ccsidsbc 			  ccsid for single byte characters
protected int ccsiddbc 			  ccsid for double byte characters
protected int ccsidmbc 			  ccsid for mixed byte characters
protected string ccsidsbcencoding 	  java encoding for ccsidsbc
protected string ccsiddbcencoding 	  java encoding for ccsiddbc
protected string ccsidmbcencoding 	  java encoding for ccsidmbc
protected database database 		   database this statement is created for
private   pkgnamcsn pkgnamcsn 		   package name section # and  consistency token
protected consistencytoken pkgcnstkn           consistency token for the first result set
protected string pkgid                  package id
protected int pkgsn 		   section number
int withholdcursor    1 	    hold cursor after commit attribute
protected int isolationlevel            jcc isolation level for statement
protected string cursorname
protected int scrolltype   resultset type_forward_only 			   sensitive or insensitive scroll attribute
protected int concurtype   resultset concur_read_only  			   concurency type
protected long rowcount 			   number of rows we have processed
protected byte  rslsetflg 		   result set flags
protected int maxrslcnt 			   maximum result set count
protected preparedstatement ps         prepared statement
protected parametermetadata stmtpmeta     param metadata
protected boolean iscall
protected string procname 			   callable statement's method name
private   int outputtypes 		   jdbc type for output parameter or not_output_param
// if not an output parameter.
private int outputprecision
private int outputscale
protected static int not_output_param    100000
protected boolean outputexpected 	   expect output from a callable statement
private statement stmt 				   sql statement
private drdaresultset currentdrdars      current resultset
private hashtable resultsettable         hashtable with resultsets
private arraylist resultsetkeylist      ordered list of hash keys
private int numresultsets   0
/** this class is used to keep track of the statement's parameters
* as they are received from the client. it uses arrays to track
* the drda type, the length in bytes and the externalness of each
* parameter. arrays of int/byte are used rather than arraylists
* of integer/byte in order to re-use the same storage each time
* the statement is executed. */
private static class drdaparamstate
// the last parameter may be streamed.
// we need to keep a record of it so we can drain it if it is not
// used.
// only the last parameter with an extdta will be streamed.
//(see drdaconnthread.readandsetallextparams()).
private extdtareaderinputstream streamedparameter   null
private int typelstend_   0
private byte typelst_   new byte
private int  lenlst_   new int
private int extlstend_   0
private int  extlst_   new int
private static object growarray object array
final int oldlen   array getlength array
object tmp
array newinstance array getclass   getcomponenttype
math max oldlen 1  2
system arraycopy array  0  tmp  0  oldlen
return tmp
/**
* <code>clear</code> resets the arrays so that new parameters
* will be added at the beginning. no initialization or
* releasing of storage takes place unless the trim argument
* is true.
*
* @param trim - if true; release excess storage
*/
protected void clear boolean trim
streamedparameter   null
typelstend_   0
extlstend_   0
if  trim    typelst_ length > 10
typelst_   new byte
lenlst_   new int
extlst_   new int
/**
* <code>adddrdaparam</code> adds a new parameter with its
* drda type and byte length. the arrays are automatically
* grown if needed.
*
* @param t a <code>byte</code> value, the drda type of the
* parameter being added
* @param s an <code>int</code> value, the length in bytes of
* the parameter being added
*/
protected void adddrdaparam byte t  int s
if  typelstend_ >  typelst_ length
typelst_    byte growarray typelst_
lenlst_    int growarray lenlst_
typelst_   t
lenlst_   s
typelstend_
/**
* <code>getdrdaparamcount</code> return the number of
* parameters added so far (since last clear).
*
* @return an <code>int</code> value, the number of parameters
*/
protected int  getdrdaparamcount     return typelstend_
/**
* <code>getdrdatype</code> returns a byte that represents the
* drda type of the ith parameter.
*
* @param i an <code>int</code> value, a parameter position
* (zero-based)
* @return a <code>byte</code> value, the drda type
*/
protected byte getdrdatype int i    return typelst_
/**
* <code>getdrdalen</code> returns the length in bytes of the
* ith parameter.
*
* @param i an <code>int</code> value, a parameter position
* (zero-based)
* @return an <code>int</code> value
*/
protected int getdrdalen int i    return lenlst_
/**
* <code>addextpos</code> marks parameter i as external. the
* array is grown as needed.
*
* @param p an <code>int</code> value, a parameter position
* (zero-based)
*/
protected void addextpos int p
if  extlstend_ >  extlst_ length
extlst_    int growarray extlst_
extlst_   p
extlstend_
/**
* <code>getextposcount</code> returns the number of
* parameters marked as external so far (since last clear).
*
* @return an <code>int</code> value, the number of external
* parameters.
*/
protected int getextposcount     return extlstend_
/**
* <code>getextpos</code> returns the actual parameter position
* of the ith external parameter.
*
* @param i an <code>int</code> value, index into the list of
* external parameters, zero-based
* @return an <code>int</code> value, the parameter position
* of the ith external parameter (zero-based)
*/
protected int getextpos int i    return extlst_
/**
* read the rest of the streamed parameter if not consumed
* by the executing statement.  derby-3085
* @throws ioexception
*/
protected void drainstreamedparameter   throws ioexception
if  streamedparameter    null
// we drain the buffer 1000 bytes at a time.
// 1000 is just a random selection that doesn't take
// too much memory. perhaps something else would be
// more efficient?
byte buffer   new byte
int i
do
i  streamedparameter read buffer 0 1000
while  i     1
public void setstreamedparameter extdtareaderinputstream eis
streamedparameter   eis
private drdaparamstate drdaparamstate_   new drdaparamstate
// query options  sent on excsqlstt
// these the default for resultsets created for this statement.
// these can be overriden by opnqry or cntqry,
protected int nbrrow 			   number of fetch or insert rows
protected int qryrowset 			   query row set
protected int blksize 				   query block size
protected int maxblkext 			   maximum number of extra blocks
protected int outovropt 			   output override option
protected boolean qryrfrtbl 		   query refresh answer set table
private int qryprctyp   codepoint qryblkctl_default       protocol type
boolean needstosendparamdata   false
boolean explicitlyprepared   false       prepared with prpsqlstt  reusable
// constructor
/**
* drdastatement constructor
*
* @param database
*
*/
drdastatement  database database
this database   database
settypdefvalues
this currentdrdars   new drdaresultset
/**
* set typdef values
*
*/
protected void settypdefvalues
// initialize statement values to current database values
this typdefnam   database typdefnam
this byteorder   database byteorder
this ccsidsbc   database ccsidsbc
this ccsiddbc   database ccsiddbc
this ccsidmbc   database ccsidmbc
this ccsidsbcencoding   database ccsidsbcencoding
this ccsiddbcencoding   database ccsiddbcencoding
this ccsidmbcencoding   database ccsidmbcencoding
/**
* set database
*
* @param database
*/
protected void setdatabase database database
this database   database
settypdefvalues
/**
* set statement
*
* @param conn	connection
* @exception sqlexception
*/
protected void setstatement connection conn
throws sqlexception
stmt   conn createstatement
//beetle 3849 -  see  preparestatement for details
if  cursorname    null
stmt setcursorname cursorname
/**
* get the statement
*
* @return statement
* @exception sqlexception
*/
protected statement getstatement
throws sqlexception
return stmt
/**set resultset defaults to match
* the statement defaults sent on excsqlstt
* this might be overridden on opnqry or cntqry
**/
protected void setrsdefaultoptions drdaresultset drs
drs nbrrow   nbrrow
drs qryrowset   qryrowset
drs blksize   blksize
drs maxblkext   maxblkext
drs outovropt   outovropt
drs rslsetflg   rslsetflg
drs scrolltype   scrolltype
drs concurtype   concurtype
drs setqryprctyp qryprctyp
drs qryrowset   qryrowset
/**
* get the extdata objects
*
*  @return arraylist with extdta
*/
protected arraylist getextdtaobjects
return currentdrdars getextdtaobjects
/**
* set the extdata objects
*/
protected void  setextdtaobjects arraylist a
currentdrdars setextdtaobjects a
public void setsplitqrydta byte data
currentdrdars setsplitqrydta data
public bytegetsplitqrydta
return currentdrdars getsplitqrydta
/**
* add extdtaobject
* @param o - object to  add
* @param jdbcindex - jdbc index for parameter
*/
protected void  addextdtaobject  object o  int jdbcindex
currentdrdars addextdtaobject o jdbcindex
/**
* clear externalized lob objects in current result set
*/
protected void  clearextdtaobjects
currentdrdars clearextdtaobjects
/*
* is lob object nullable
* @param index - offset starting with 0
* @return true if object is nullable
*/
protected boolean isextdtavaluenullable int index
return currentdrdars isextdtavaluenullable index
/**
* set query options sent on opnqry and pass options down to the
* current <code>drdaresultset</code> object.
*
* @param blksize qryblksz (query block size)
* @param qryblkctl qryprctyp (query protocol type)
* @param maxblkext maxblkext (maximum number of extra blocks)
* @param outovropt outovropt (output override option)
* @param qryrowset qryrowset (query rowset size)
* @param qryclsimpl qryclsimp (query close implicit)
* @see drdaresultset#setopnqryoptions(int, int, int, int, int, int)
*/
protected void setopnqryoptions int blksize  int qryblkctl
int maxblkext  int outovropt int qryrowset int qryclsimpl
this blksize   blksize
this qryprctyp   qryblkctl
this maxblkext   maxblkext
this outovropt   outovropt
this qryrowset   qryrowset
currentdrdars setopnqryoptions  blksize  qryblkctl  maxblkext
outovropt  qryrowset  qryclsimpl
/*
* set query options sent on cntqry
*/
protected void setqueryoptions int blksize  boolean qryrelscr
long qryrownbr
boolean qryfrtbl int nbrrow int maxblkext
int qryscrorn  boolean qryrowsns
boolean qryblkrst
boolean qryrtndta int qryrowset
int rtnextdta
currentdrdars blksize   blksize
currentdrdars qryrelscr   qryrelscr
currentdrdars qryrownbr   qryrownbr
currentdrdars qryrfrtbl   qryrfrtbl
currentdrdars nbrrow   nbrrow
currentdrdars maxblkext   maxblkext
currentdrdars qryscrorn   qryscrorn
currentdrdars qryrowsns   qryrowsns
currentdrdars qryblkrst   qryblkrst
currentdrdars qryrtndta   qryrtndta
currentdrdars qryrowset   qryrowset
currentdrdars rtnextdta   rtnextdta
protected void setqryprctyp int qryprctyp
this qryprctyp   qryprctyp
currentdrdars setqryprctyp qryprctyp
protected int  getqryprctyp
throws sqlexception
return currentdrdars getqryprctyp
protected void setqryrownbr long qryrownbr
currentdrdars qryrownbr   qryrownbr
protected long  getqryrownbr
return currentdrdars qryrownbr
protected int  getqryrowset
return currentdrdars qryrowset
protected int getblksize
return currentdrdars blksize
protected void setqryrtndta boolean qryrtndta
currentdrdars qryrtndta   qryrtndta
protected boolean  getqryrtndta
return currentdrdars qryrtndta
protected void setqryscrorn int qryscrorn
currentdrdars qryscrorn   qryscrorn
protected int  getqryscrorn
return currentdrdars qryscrorn
protected void setscrolltype int scrolltype
currentdrdars scrolltype   scrolltype
protected int  getscrolltype
return currentdrdars scrolltype
/**
* is this a scrollable cursor?
* return true if this is not a forward only cursor
*/
protected boolean isscrollable
return  getscrolltype      resultset type_forward_only
protected void setconcurtype int scrolltype
currentdrdars concurtype   scrolltype
protected int  getconcurtype
return currentdrdars concurtype
protected void 	setoutovr_drdatype int outovr_drdatype
currentdrdars outovr_drdatype   outovr_drdatype
protected int 	getoutovr_drdatype
return currentdrdars outovr_drdatype
protected boolean hasdata
return currentdrdars hasdata
protected void  sethasdata boolean hasdata
currentdrdars hasdata   hasdata
/**
* this method is used to initialize the default statement of the database
* for re-use. it is different from reset() method since default statements
* get initiliazed differently. e.g: stmt variable used in default statement
* is created only once in database.makeconnection.
* todo: need to see what exactly it means to initialize the default
* statement. (derby-1002)
*
*/
protected void initialize
settypdefvalues
protected preparedstatement explicitprepare string sqlstmt  throws sqlexception
explicitlyprepared   true
return prepare sqlstmt
protected boolean wasexplicitlyprepared
return explicitlyprepared
/**
* create a prepared statement
*
* @param sqlstmt - sql statement
*
* @exception sqlexception
*/
protected preparedstatement prepare string sqlstmt    throws sqlexception
// save current prepare iso level
int saveisolationlevel    1
boolean isolationset   false
if  pkgnamcsn   null
isolationlevel    connection transaction_none
saveisolationlevel   database getprepareisolation
database setprepareisolation isolationlevel
isolationset   true
parsepkgidtofindholdability
if  iscallablesql sqlstmt
iscall   true
ps   database getconnection   preparecall
sqlstmt  scrolltype  concurtype  withholdcursor
setupcallablestatementparams  callablestatement ps
else
ps   database getconnection   preparestatement
sqlstmt  scrolltype  concurtype  withholdcursor
// beetle 3849  -  need to change the cursor name to what
// jcc thinks it will be, since there is no way in the
// protocol to communicate the actual cursor name.  jcc keeps
// a mapping from the client cursor names to the db2 style cursor names
if  cursorname    null   cursorname not null means we are dealing with dynamic pacakges
ps setcursorname cursorname
if  isolationset
database setprepareisolation saveisolationlevel
return ps
/**
* get prepared statement
*
* @return prepared statement
*/
protected preparedstatement getpreparedstatement   throws sqlexception
return ps
/**
* executes the prepared statement and populates the resultsettable.
* access to the various resultsets is then possible by using
* setcurrentdrdaresultset(string pkgnamcsn)  to set the current
* resultset and then calling getresultset() or the other access
* methods to get resultset data.
*
* @return true if the execution has resultsets
*/
protected boolean execute   throws sqlexception
boolean hasresultset   ps execute
// derby-3085 - we need to make sure we drain the streamed parameter
// if not used by the server, for example if an update statement does not
// update any rows, the parameter won't be used.  network server will
// stream only the last parameter with an extdta. this is stored when the
// parameter is set and drained now after statement execution if needed.
try
drdaparamstate_ drainstreamedparameter
catch  ioexception e
util javaexception e
// java.sql.statement says any result sets that are opened
// when the statement is re-executed must be closed; this
// is handled by the call to "ps.execute()" above--but we
// also have to reset our 'numresultsets' counter, since
// all previously opened result sets are now invalid.
numresultsets   0
resultset rs   null
boolean iscallable    ps instanceof java sql callablestatement
if  iscallable
needstosendparamdata   true
do
rs   ps getresultset
if  rs   null
//for callable statement, get holdability of statement generating the result set
if iscallable
addresultset rs    engineresultset  rs  getholdability
else
addresultset rs withholdcursor
hasresultset   true
// for normal selects we are done, but procedures might
// have more resultsets
while  iscallable    getmoreresults statement keep_current_result
return hasresultset
/**
* clear out type data for parameters.
* unfortunately we currently overload the resultset type info
* rsdrdatypes et al with parameter info.
* resolve: need to separate this
*/
protected void finishparams
needstosendparamdata   false
/**
* set the pkgid sec num for this statement and the
* consistency token that will be used for the first resultset.
* for dyamic packages the package name is encoded as follows
* sys(s/l)(h/n)xyy
* where 's' represents small package and 'l' large
*                      (ignored by derby)
* where 'h' represents with hold, and 'n' represents no with hold.
*                      (may be overridden by sqlattr for with
*                       hold")
*
* where 'www' is the package iteration (ignored by derby)
* where 'x' is the isolation level: 0=nc, 1=ur, 2=cs, 3=rs, 4=rr
* where 'yy' is the package iteration 00 through ff
* where 'zz' is unique for each platform
* happilly, these values correspond precisely to the internal derby
* isolation levels  in executioncontext.java
* x   isolation level
* --  ---------------------
* 0   nc  (java.sql.connection.transaction_none)
* 1   ur  (java.sql.connection.tranaction_read_uncommitted)
* 2   cs  (java.sql.connection.transaction_read_committed)
* 3   rs  (java.sql.connection.transaction_repeatable_read)
* 4   rr  (java.sql.connection.transaction_serializable)
*
* static packages have preset isolation levels
* (see getstaticpackageisolation)
* @param pkgnamcsn  package id section number and token from the client
*/
protected void setpkgnamcsn pkgnamcsn pkgnamcsn
this pkgnamcsn    pkgnamcsn
// store the consistency string for the first resultset.
// this will be used to calculate consistency strings for the
// other result sets.
pkgid   pkgnamcsn getpkgid
if  isdynamicpkgid pkgid
isolationlevel   integer parseint pkgid substring 5 6
/*
*   generate db2-style cursorname
*   example value : sql_cursn200c1
*   where
*      sql_cur is db2 cursor name prefix;
*      s - small package , l -large package
*      n - normal cursor, h - hold cursor
*      200 - package id as sent by jcc
*      c - tack-on code for cursors
*      1 - section number sent by jcc
*/
// cursor name
// trim the sys off the pkgid so it wont' be in the cursor name
string shortpkgid   pkgid substring pkgid length    5   pkgid length
pkgsn   pkgnamcsn getpkgsn
this cursorname        shortpkgid       pkgsn
else    static package
isolationlevel   getstaticpackageisolation pkgid
this pkgcnstkn   pkgnamcsn getpkgcnstkn
/**
* get the isolation level for a static package.
* @param pkgid - package identifier string (e.g. sysstat)
* @return isolation
*/
private int getstaticpackageisolation string pkgid
// sysstat is used for metadata. and is the only static package used
// for jcc. other static packages will need to be supported for
// ccc. maybe a static hash table would then be in order.
if  pkgid equals
return executioncontext read_uncommitted_isolation_level
else
return executioncontext unspecified_isolation_level
/**
* get pkgnamcsn
*
* @return pkgnamcsn
*/
protected pkgnamcsn getpkgnamcsn
return pkgnamcsn
/**
* get result set
*
* @return result set
*/
protected resultset getresultset
return currentdrdars getresultset
/**
* gets the current drda resultset
*
* @return drdaresultset
*/
protected drdaresultset getcurrentdrdaresultset
return currentdrdars
/**
* set currentdrdaresultset
*
* @param rsnum   the result set number starting with 0
*
*/
protected void setcurrentdrdaresultset int rsnum
consistencytoken consisttoken   getresultsetpkgcnstkn rsnum
if  currentdrdars pkgcnstkn    consisttoken
return
currentdrdars   getdrdaresultset consisttoken
/**
* set currentdrdaresultset
*
* @param pkgnamcsn  the pkgid section number and unique resultset
*                    consistency token
*
*/
protected void setcurrentdrdaresultset pkgnamcsn pkgnamcsn
pkgid   pkgnamcsn getpkgid
pkgsn   pkgnamcsn getpkgsn
consistencytoken consisttoken   pkgnamcsn getpkgcnstkn
drdaresultset newdrdars   getdrdaresultset consisttoken
if  newdrdars    null
currentdrdars   newdrdars
/*
* get drdaresultset by consistency token
*
*/
private drdaresultset getdrdaresultset consistencytoken consisttoken
if   resultsettable      null
currentdrdars    null
currentdrdars pkgcnstkn    consisttoken
return currentdrdars
else
return  drdaresultset   resultsettable get consisttoken
/*
* get drdaresultset by result set number
*
*/
private drdaresultset getdrdaresultset int rsnum
consistencytoken consisttoken   getresultsetpkgcnstkn rsnum
return getdrdaresultset consisttoken
/** add a new resultset to this statement.
* set as the current result set if  there is not an
* existing current resultset.
* @param value - resultset to add
* @param holdvalue - holdability of the resultset
* @return    consistency token  for this resultset
*            for a single resultset that is the same as the statement's
*            for multiple resultsets just the consistency token is changed
*/
protected consistencytoken addresultset resultset value  int holdvalue  throws sqlexception
drdaresultset newdrdars   null
int rsnum   numresultsets
consistencytoken newrspkgcnstkn   calculateresultsetpkgcnstkn rsnum
if  rsnum    0
newdrdars   currentdrdars
else
newdrdars   new drdaresultset
// multiple resultsets we neeed to setup the hash table
if  resultsettable    null
// if hashtable doesn't exist, create it and store resultset 0
// before we store our new resultset.
// for just a single resultset we don't ever create the hashtable.
resultsettable   new hashtable
resultsettable put pkgcnstkn  currentdrdars
resultsetkeylist   new arraylist
resultsetkeylist add 0  pkgcnstkn
resultsettable put newrspkgcnstkn  newdrdars
resultsetkeylist add rsnum  newrspkgcnstkn
newdrdars setresultset value
newdrdars setpkgcnstkn newrspkgcnstkn
newdrdars withholdcursor   holdvalue
setrsdefaultoptions newdrdars
newdrdars suspend
numresultsets
return newrspkgcnstkn
/**
*
* @return 	number of result sets
*/
protected int getnumresultsets
return numresultsets
/**
* @param rsnum result set starting with 0
* @return  consistency token (key) for the result set
*/
protected consistencytoken getresultsetpkgcnstkn int rsnum
if  rsnum    0
return pkgcnstkn
else
return  consistencytoken  resultsetkeylist get rsnum
/**
*@return resultset drda datatypes
**/
protected int getrsdrdatypes
return currentdrdars getrsdrdatypes
/**
*  close the current resultset
*/
protected void rsclose   throws sqlexception
if  currentdrdars getresultset      null
return
currentdrdars close
needstosendparamdata   false
numresultsets
/**
* explicitly close the result set by clsqry
* needed to check for double close.
*/
protected void clsqry
currentdrdars clsqry
/*
* @return whether clsqry has been called on the
*         current result set.
*/
protected boolean wasexplicitlyclosed
return currentdrdars wasexplicitlyclosed
/**
* this method closes the jdbc objects and frees up all references held by
* this object.
*
* @throws sqlexception
*/
protected void close    throws sqlexception
if  ps    null
ps close
if  stmt    null
stmt close
currentdrdars close
resultsettable   null
resultsetkeylist   null
ps   null
stmtpmeta   null
stmt   null
rslsetflg   null
procname   null
outputtypes   null
outputprecision   null
outputscale   null
// clear parameters and release excess storage
drdaparamstate_ clear true
/**
* this method resets the state of this drdastatement object so that it can
* be re-used. this method should reset all variables of this class except
* the following:
* 1. database - this variable gets initialized in the constructor and by
* call to setdatabase.
* 2. members which get initialized in setpkgnamcsn (pkgnamcsn, pkgcnstkn,
* pkgid, pkgsn, isolationlevel, cursorname). pkgnamcsn is the key used to
* find if the drdastatement can be re-used. hence its value will not change
* when the object is re-used.
*
*/
protected void reset
settypdefvalues
withholdcursor    1
scrolltype   resultset type_forward_only
concurtype   resultset concur_read_only
rowcount   0
rslsetflg   null
maxrslcnt   0
ps   null
stmtpmeta   null
iscall   false
procname   null
outputtypes   null
outputexpected   false
stmt   null
currentdrdars reset
resultsettable   null
resultsetkeylist   null
numresultsets   0
// clear parameters without releasing storage
drdaparamstate_ clear false
nbrrow   0
qryrowset   0
blksize   0
maxblkext   0
outovropt   0
qryrfrtbl   false
qryprctyp   codepoint qryblkctl_default
needstosendparamdata   false
explicitlyprepared   false
/**
* is statement closed
* @return whether the statement is closed
*/
protected boolean rsisclosed
return currentdrdars isclosed
/**
* set state to suspended (result set is opened)
*/
protected void rssuspend
currentdrdars suspend
/**
* set resultset/out parameter precision
*
* @param index - starting with 1
* @param precision
*/
protected void setrsprecision int index  int precision
currentdrdars setrsprecision index precision
/**
* get resultset /out paramter precision
* @param index -starting with 1
* @return precision of column
*/
protected int getrsprecision int index
return currentdrdars getrsprecision index
/**
* set resultset/out parameter scale
*
* @param index - starting with 1
* @param scale
*/
protected void setrsscale int index  int scale
currentdrdars setrsscale index  scale
/**
* get resultset /out paramter scale
* @param index -starting with 1
* @return scale of column
*/
protected int  getrsscale int index
return currentdrdars getrsscale index
/**
* set result  drdatype
*
* @param index - starting with 1
* @param type
*/
protected  void setrsdrdatype int index  int type
currentdrdars setrsdrdatype index type
/** clears the parameter state (type, length and ext information)
* stored in this statement, but does not release any
* storage. this reduces the cost of re-executing the statement
* since no new storage needs to be allocated. */
protected void cleardrdaparams
drdaparamstate_ clear false
/** get the number of external parameters in this
* statement. external means parameters that are transmitted in a
* separate dss in the drda protocol.
* @return the number of external parameters
*/
protected int getextpositioncount
return drdaparamstate_ getextposcount
/** get the parameter position of the i'th external parameter
* @param i - zero-based index into list of external parameters
* @return the parameter position of the i'th external parameter
*/
protected int getextposition int i
return drdaparamstate_ getextpos i
/** mark the pos'th parameter as external
* @param pos - zero-based index into list of external parameters
*/
protected void addextposition int pos
drdaparamstate_ addextpos pos
/** get the number of parameters, internal and external, that has
* been added to this statement.
* @return the number of parameters
*/
protected int getdrdaparamcount
return drdaparamstate_ getdrdaparamcount
/** add another parameter to this statement.
* @param t - type of the parameter
* @param l - length in bytes of the parameter
*/
protected void adddrdaparam byte t  int l
drdaparamstate_ adddrdaparam t  l
protected void setstreamedparameter extdtareaderinputstream eis
drdaparamstate_ setstreamedparameter eis
/**
* get parameter drdatype
*
* @param index - starting with 1
* @return  drda type of column
*/
protected int getparamdrdatype int index
return drdaparamstate_ getdrdatype index 1
/**
* returns drda length of parameter as sent by client.
* @param index - starting with 1
* @return data length
*/
protected int getparamlen int index
return drdaparamstate_ getdrdalen index 1
/**
*  get parameter precision or db2 max (31)
*
*  @param index parameter index starting with 1
*
*  @return  precision
*/
protected int getparamprecision int index  throws sqlexception
if  ps    null    ps instanceof callablestatement
parametermetadata pmeta   getparametermetadata
return math min pmeta getprecision index
fdocaconstants numeric_max_precision
else
return  1
/**
*  get parameter scale or db2 max (31)
*
*  @param index parameter index starting with 1
*
*  @return  scale
*/
protected int getparamscale int index  throws sqlexception
if  ps    null    ps instanceof callablestatement
parametermetadata pmeta   getparametermetadata
return math min pmeta getscale index  fdocaconstants numeric_max_precision
else
return  1
/**
* get the number of result set columns for the current resultset
*
* @return number of columns
*/
protected int getnumrscols
int rsdrdatypes   getrsdrdatypes
if  rsdrdatypes    null
return rsdrdatypes length
else
return 0
/**
* get  resultset/out parameter drdatype
*
* @param index - starting with 1
* @return  drda type of column
*/
protected int getrsdrdatype int index
return currentdrdars getrsdrdatype index
/**
* get resultset/out parameter drdalen
* @param index starting with 1
*
* @return length of drda data
*/
protected int getrslen int index
return currentdrdars getrslen index
/**
* @param rsnum  - result set # starting with 0
*/
public string getresultsetcursorname int rsnum  throws sqlexception
drdaresultset drdars   getdrdaresultset rsnum
return drdars getresultsetcursorname
protected string todebugstring string indent
string s
if  ps    null
s    indent   ps
else
s    indent   pkgid   pkgsn
s        getsqltext
return s
/**  for a single result set, just echo the consistency token that the client sent us.
* for subsequent resultsets, just subtract the resultset number from
* the consistency token and that will differentiate the result sets.
* this seems to be what db2 does
* @param rsnum  - result set # starting with 0
*
* @return  consistency token for result set
*/
protected consistencytoken calculateresultsetpkgcnstkn int rsnum
consistencytoken consisttoken   pkgcnstkn
if  rsnum    0    pkgcnstkn    null
return consisttoken
else
biginteger consisttokenbi
new biginteger consisttoken getbytes
biginteger rsnumbi   biginteger valueof rsnum
consisttokenbi   consisttokenbi subtract rsnumbi
consisttoken   new consistencytoken consisttokenbi tobytearray
return consisttoken
protected boolean iscallablestatement
return iscall
private boolean iscallablesql string sql
java util stringtokenizer tokenizer   new java util stringtokenizer
sql
string firsttoken   tokenizer nexttoken
if  stringutil sqlequalsignorecase firsttoken
captures call   and ? call
return true
return false
private void setupcallablestatementparams callablestatement cs  throws sqlexception
parametermetadata pmeta   getparametermetadata
int numelems   pmeta getparametercount
for   int i   0  i < numelems  i
boolean outputflag   false
int parametermode   pmeta getparametermode i   1
int parametertype   pmeta getparametertype i   1
int parameterprecision   pmeta getprecision i   1
int parameterscale   pmeta getscale i   1
switch  parametermode
case jdbc30translation parameter_mode_in
break
case jdbc30translation parameter_mode_out
case jdbc30translation parameter_mode_in_out
outputflag   true
break
case jdbc30translation parameter_mode_unknown
// it's only unknown if array
string objecttype   pmeta getparameterclassname i 1
parametertype
getoutputparametertypefromclassname objecttype
if  parametertype     not_output_param
outputflag   true
if  outputflag
if  outputtypes    null    not initialized yet  since previously none output
outputtypes   new int
outputprecision   new int
outputscale   new int
for  int j   0  j < numelems  j
outputtypes   not_output_param     default init value
outputprecision   not_output_param
outputscale   not_output_param
// save the output type so we can register when we parse
// the sqldta
outputtypes   parametertype
outputprecision   parameterprecision
outputscale   parameterscale
/**
given an object class  name get the paramameter type if the
parameter mode is unknown.
arrays except for byte arrrays are assumed to be output parameters
tinyint output parameters are going to be broken because there
is no way to differentiate them from binary input parameters.
@param objectname class name of object being evaluated.
indicating if this an output parameter
@return type from java.sql.types
**/
protected static int getoutputparametertypefromclassname string
objectname
if  objectname endswith
// for byte[] we are going to assume it is input.
// for tinyint output params you gotta use
//  object integer[] or use a procedure
if  objectname equals
return not_output_param
//isoutparam[offset] = false;
//return java.sql.types.varbinary;
// known arrays are output parameters
// otherwise we pass it's a java_object
if  objectname equals
return java sql types tinyint
if  objectname equals
return java sql types varbinary
if  objectname equals
return java sql types varchar
if  objectname equals
objectname equals
return java sql types integer
else if  objectname equals
objectname equals
return java sql types bigint
else if  objectname equals
return java sql types numeric
else if  objectname equals
objectname equals
return java sql types bit
else if  objectname equals
return java sql types smallint
else if  objectname equals
objectname equals
return java sql types real
else if  objectname equals
objectname equals
return java sql types double
else if  objectname equals
return java sql types date
else if  objectname equals
return java sql types time
else if  objectname equals
return java sql types timestamp
// not one of the ones we know. this must be a java_object
return not_output_param
//isoutparam[offset] = false;
//return java.sql.types.java_object;
public void registeralloutparams   throws sqlexception
if  iscall     outputtypes    null
for  int i   1  i <  outputtypes length  i
registeroutparam i
public void registeroutparam int paramnum  throws sqlexception
callablestatement cs
if  isoutputparam paramnum
cs    callablestatement  ps
cs registeroutparameter paramnum  getoutputparamtype paramnum
protected boolean hasoutputparams
return  outputtypes    null
/**
* is  parameter an ouput parameter
* @param paramnum parameter number starting with 1.
* return true if this is an output parameter.
*/
boolean isoutputparam int paramnum
if  outputtypes    null
return  outputtypes    not_output_param
return false
/**
* get type for output parameter.
*
* @param paramnum - parameter number starting with 1
* @return jdbctype or not_output_param if this is not an output parameter
*/
int getoutputparamtype int paramnum
if  outputtypes    null
return  outputtypes
return not_output_param
/**
* get scale for output parameter.
*
* @param paramnum - parameter number starting with 1
* @return scale or not_output_param if this is not an output parameter
*/
int getoutputparamscale int paramnum
if  outputscale    null
return  outputscale
return not_output_param
/**
* get precision  for output parameter.
*
* @param paramnum - parameter number starting with 1
* @return precision or not_output_param if this is not an output parameter
*/
int getoutputparamprecision int paramnum
if  outputprecision    null
return  outputprecision
return not_output_param
private boolean isdynamicpkgid string pkgid
char size   pkgid charat 3
//  separate attribute used for holdability in 5.1.60
// this is just for checking that it is a dynamic package
char holdability   pkgid charat 4
return  pkgid substring 0 3  equals        size
size
holdability         holdability
private  void parsepkgidtofindholdability
if  withholdcursor     1
return
//first, check if holdability was passed as a sql attribute "with hold" for this prepare. if yes, then withholdcursor
//should not get overwritten by holdability from package name and that is why the check for -1
if  isdynamicpkgid pkgid
if pkgid charat 4
withholdcursor   resultset close_cursors_at_commit
else
withholdcursor   resultset hold_cursors_over_commit
else
withholdcursor   resultset hold_cursors_over_commit
/**
* retrieve the parametermetadata for the prepared statement.
* @return parametermetadata for the prepared statement.
* note: there is no separate brokeredparametersetmetadata.
*/
protected parametermetadata getparametermetadata   throws sqlexception
if  stmtpmeta    null
return stmtpmeta
stmtpmeta   ps getparametermetadata
return stmtpmeta
/**
* get more results using reflection.
* @param current - flag to pass to statement.getmoreresults(current)
* @return true if there are more results.
* @throws sqlexception
* @see java.sql.statement#getmoreresults
*
*/
private boolean getmoreresults int current  throws sqlexception
return getpreparedstatement   getmoreresults current
/**
* use reflection to retrieve sql text for embedpreparedstatement
* or brokeredpreparedstatement.
* @return sql text
*/
private string getsqltext
string retval   null
class emptyparam
object args   null
try
method sh   getpreparedstatement   getclass   getmethod   emptyparam
retval    string  sh invoke getpreparedstatement   args
catch  exception e
//  do nothing we will just return a null string
return retval
/**
* method to decide whether the resultset should be closed
* implicitly based on the qryclsimp value sent from the
* client. only forward-only result sets should be implicitly
* closed. some clients do not expect result sets to be closed
* implicitly if the protocol is lmtblkprc.
*
* @param lmtblkprcok <code>true</code> if the client expects
* qryclsimp to be respected for the lmtblkprc protocol
* @return implicit close boolean
* @exception sqlexception
*/
boolean isrscloseimplicit boolean lmtblkprcok  throws sqlexception
return
currentdrdars qryclsimp    codepoint qryclsimp_yes
isscrollable
lmtblkprcok
currentdrdars getqryprctyp      codepoint lmtblkprc