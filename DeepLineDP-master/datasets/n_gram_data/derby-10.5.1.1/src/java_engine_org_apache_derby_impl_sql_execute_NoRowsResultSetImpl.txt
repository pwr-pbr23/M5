/*
derby - class org.apache.derby.impl.sql.execute.norowsresultsetimpl
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import java sql timestamp
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services i18n messageservice
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi sql activation
import org apache derby iapi sql resultcolumndescriptor
import org apache derby iapi sql resultdescription
import org apache derby iapi sql resultset
import org apache derby iapi sql row
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn statementcontext
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql execute resultsetstatisticsfactory
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
/**
* abstract resultset for implementations that do not return rows.
* examples are ddl statements, call statements and dml.
* <p>
* an implementation must provide a resultset.open() method
* that performs the required action.
* <p>
* resultset.returnsrows() returns false and any method
* that fetches a row will throw an exception.
*
*/
abstract class norowsresultsetimpl implements resultset
final activation    activation
private boolean dumpedstats
noputresultset	subquerytrackingarray
private final boolean statisticstimingon
/** true if the result set has been opened, and not yet closed. */
private boolean isopen
/* run time statistics variables */
final languageconnectioncontext lcc
protected long begintime
protected long endtime
protected long beginexecutiontime
protected long endexecutiontime
private int                             firstcolumn    1        first column being stuffed  for updates  this lies in the second half of the row
private int                           generatedcolumnpositions     1 based positions of generated columns in the target row
// one cell for  each slot in generatedcolumnpositions. these are temporary
// values which hold the result of running the generation clause before we
// stuff the result into the target row.
private datavaluedescriptor  normalizedgeneratedvalues
norowsresultsetimpl activation activation
throws standardexception
this activation   activation
if  sanitymanager debug
if  activation    null
sanitymanager throwassert     getclass
lcc   activation getlanguageconnectioncontext
statisticstimingon   lcc getstatisticstiming
/* note - we can't get the current time until after setting up the
* activation, as we end up using the activation to get the
* languageconnectioncontext.
*/
begintime   getcurrenttimemillis
beginexecutiontime   begintime
statementcontext sc   lcc getstatementcontext
sc settopresultset this   noputresultset  null
// pick up any materialized subqueries
subquerytrackingarray   sc getsubquerytrackingarray
/**
* set up the result set for use. should always be called from
* <code>open()</code>.
*
* @exception standardexception thrown on error
*/
void setup   throws standardexception
isopen   true
/**
* returns false
*/
public final boolean	returnsrows     return false
/**
* returns zero.
*/
public int	modifiedrowcount     return 0
public final activation getactivation
return activation
/**
* returns the row at the absolute position from the query,
* and returns null when there is no such position.
* (negative position means from the end of the result set.)
* moving the cursor to an invalid position leaves the cursor
* positioned either before the first row (negative position)
* or after the last row (positive position).
* note: an exception will be thrown on 0.
*
* @param row	the position.
* @return	the row at the absolute position, or null if no such position.
*
* @exception standardexception		thrown on failure
* @see row
*/
public final execrow	getabsoluterow int row  throws standardexception
/*
the jdbc use of this class will never call here.
only the db api used directly can get this exception.
*/
throw standardexception newexception sqlstate lang_does_not_return_rows
/**
* returns the row at the relative position from the current
* cursor position, and returns null when there is no such position.
* (negative position means toward the beginning of the result set.)
* moving the cursor to an invalid position leaves the cursor
* positioned either before the first row (negative position)
* or after the last row (positive position).
* note: 0 is valid.
* note: an exception is thrown if the cursor is not currently
* positioned on a row.
*
* @param row	the position.
* @return	the row at the relative position, or null if no such position.
*
* @exception standardexception		thrown on failure
* @see row
*/
public final execrow	getrelativerow int row  throws standardexception
/*
the jdbc use of this class will never call here.
only the db api used directly can get this exception.
*/
throw standardexception newexception sqlstate lang_does_not_return_rows
/**
* sets the current position to before the first row and returns null
* because there is no current row.
*
* @return	null.
*
* @exception standardexception		thrown on failure
* @see row
*/
public final execrow	setbeforefirstrow
throws standardexception
/*
the jdbc use of this class will never call here.
only the db api used directly can get this exception.
*/
throw standardexception newexception sqlstate lang_does_not_return_rows
/**
* returns the first row from the query, and returns null when there
* are no rows.
*
* @return	the first row, or null if no rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public final execrow	getfirstrow
throws standardexception
/*
the jdbc use of this class will never call here.
only the db api used directly can get this exception.
*/
throw standardexception newexception sqlstate lang_does_not_return_rows
/**
* no rows to return, so throw an exception.
*
* @exception standardexception		always throws a
*									standardexception to indicate
*									that this method is not intended to
*									be used.
*/
public final execrow	getnextrow   throws standardexception
/*
the jdbc use of this class will never call here.
only the db api used directly can get this exception.
*/
throw standardexception newexception sqlstate lang_does_not_return_rows
/**
* returns the previous row from the query, and returns null when there
* are no more previous rows.
*
* @return	the previous row, or null if no more previous rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public final execrow	getpreviousrow
throws standardexception
/*
the jdbc use of this class will never call here.
only the db api used directly can get this exception.
*/
throw standardexception newexception sqlstate lang_does_not_return_rows
/**
* returns the last row from the query, and returns null when there
* are no rows.
*
* @return	the last row, or null if no rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public final execrow	getlastrow
throws standardexception
/*
the jdbc use of this class will never call here.
only the db api used directly can get this exception.
*/
throw standardexception newexception sqlstate lang_does_not_return_rows
/**
* sets the current position to after the last row and returns null
* because there is no current row.
*
* @return	null.
*
* @exception standardexception		thrown on failure
* @see row
*/
public final execrow	setafterlastrow
throws standardexception
/*
the jdbc use of this class will never call here.
only the db api used directly can get this exception.
*/
throw standardexception newexception sqlstate lang_does_not_return_rows
/**
* clear the current row. this is done after a commit on holdable
* result sets.
* this is a no-op on result set which do not provide rows.
*/
public final void clearcurrentrow
/**
* determine if the cursor is before the first row in the result
* set.
*
* @return true if before the first row, false otherwise. returns
* false when the result set contains no rows.
*/
public final boolean checkrowposition int istype
return false
/**
* returns the row number of the current row.  row
* numbers start from 1 and go to 'n'.  corresponds
* to row numbering used to position current row
* in the result set (as per jdbc).
*
* @return	the row number, or 0 if not on a row
*
*/
public final int getrownumber
return 0
/**
* dump the stat if not already done so. close all of the open subqueries.
*
* @exception standardexception thrown on error
*/
public void	close   throws standardexception
if   isopen
return
if    dumpedstats
/*
** if run time statistics tracing is turned on, then now is the
** time to dump out the information.
** note - we make a special exception for commit.  if autocommit
** is on, then the run time statistics from the autocommit is the
** only one that the user would ever see.  so, we don't overwrite
** the run time statistics object for a commit.
** derby-2353: also make an exception when the activation is
** closed. if the activation is closed, the run time statistics
** object is null and there's nothing to print. this may happen
** if a top-level result set closes the activation and close() is
** subsequently called on the child result sets. the information
** about the children is also printed by the parent, so it's safe
** to skip printing it.
*/
if  lcc getruntimestatisticsmode
doescommit       activation isclosed
endexecutiontime   getcurrenttimemillis
resultsetstatisticsfactory rssf
lcc getlanguageconnectionfactory
getexecutionfactory   getresultsetstatisticsfactory
lcc setruntimestatisticsobject
rssf getruntimestatistics activation  this  subquerytrackingarray
headerprintwriter istream   lcc getlogqueryplan   ? monitor getstream     null
if  istream    null
istream printlnwithheader languageconnectioncontext xidstr
lcc gettransactionexecute   gettransactionidstring
languageconnectioncontext lccstr
lcc getinstancenumber
lcc getruntimestatisticsobject   getstatementtext
lcc getruntimestatisticsobject   getstatementexecutionplantext
dumpedstats   true
/* this is the top resultset,
* close all of the open subqueries.
*/
int stalength    subquerytrackingarray    null  ? 0
subquerytrackingarray length
for  int index   0  index < stalength  index
if  subquerytrackingarray    null
continue
if  subquerytrackingarray isclosed
continue
subquerytrackingarray close
isopen   false
if  activation issingleexecution
activation close
/**
* find out if the <code>resultset</code> is closed.
*
* @return <code>true</code> if closed, <code>false</code> otherwise
*/
public boolean isclosed
return  isopen
public void	finish   throws standardexception
/**
* get the execution time in milliseconds.
*
* @return long		the execution time in milliseconds.
*/
public long getexecutetime
return endtime   begintime
/**
* get the timestamp for the beginning of execution.
*
* @return timestamp		the timestamp for the beginning of execution.
*/
public timestamp getbeginexecutiontimestamp
if  beginexecutiontime    0
return null
else
return new timestamp beginexecutiontime
/**
* get the timestamp for the end of execution.
*
* @return timestamp		the timestamp for the end of execution.
*/
public timestamp getendexecutiontimestamp
if  endexecutiontime    0
return null
else
return new timestamp endexecutiontime
/**
* resolve - this method will go away once it is overloaded in all subclasses.
* return the query plan as a string.
*
* @param depth	indentation level.
*
* @return string	the query plan as a string.
*/
public string getqueryplantext int depth
return messageservice gettextmessage
sqlstate lang_gqpt_not_supported
getclass   getname
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
/* resolve - this should be overloaded in all subclasses */
return 0
/**
* @see resultset#getsubquerytrackingarray
*/
public final noputresultset getsubquerytrackingarray int numsubqueries
if  subquerytrackingarray    null
subquerytrackingarray   new noputresultset
return subquerytrackingarray
/**
* @see resultset#getautogeneratedkeysresultset
*/
public resultset getautogeneratedkeysresultset
//a non-null resultset would be returned only for an insert statement
return  resultset null
/**
return the cursor name, null in this case.
@see resultset#getcursorname
*/
public string getcursorname
return null
// class implementation
/**
* return the current time in milliseconds, if debug and runtimestats is
* on, else return 0.  (only pay price of system call if need to.)
*
* @return long		current time in milliseconds.
*/
protected final long getcurrenttimemillis
if  statisticstimingon
return system currenttimemillis
else
return 0
/**
*	run a check constraint against the current row. raise an error if
* the check constraint is violated.
*
*	@param	checkgm			generated code to run the check constraint.
* @param	checkname		name of the constraint to check.
*	@param	heapconglom		number of heap conglomerate.
*	@param	activation		class in which checkgm lives.
*
* @exception standardexception thrown on error
*/
public	static	void	evaluateacheckconstraint
generatedmethod checkgm
string checkname
long heapconglom
activation activation
throws standardexception
if  checkgm    null
datavaluedescriptor checkboolean
checkboolean    datavaluedescriptor  checkgm invoke activation
/* throw exception if check constraint is violated.
* (only if check constraint evaluates to false.)
*/
if   checkboolean    null
checkboolean isnull
checkboolean getboolean
/* now we have a lot of painful work to get the
* table name for the error message.  all we have
* is the conglomerate number to work with.
*/
datadictionary dd   activation getlanguageconnectioncontext   getdatadictionary
conglomeratedescriptor cd   dd getconglomeratedescriptor  heapconglom
tabledescriptor td   dd gettabledescriptor cd gettableid
standardexception se   standardexception newexception sqlstate lang_check_constraint_violated
td getqualifiedname    checkname
throw se
/**
* compute the generation clauses on the current row in order to fill in
* computed columns.
*
* @param generationclauses    the generated method which evaluates generation clauses
* @param activation               the thread-specific instance of the generated class
* @param source                   the tuple stream driving this insert/update
* @param newrow                   the base row being stuffed
* @param isupdate                 true if this is an update. false otherwise.
*/
public	void	evaluategenerationclauses
generatedmethod generationclauses
activation activation
noputresultset    source
execrow           newrow
boolean           isupdate
throws standardexception
if  generationclauses    null
execrow oldrow    execrow  activation getcurrentrow  source resultsetnumber
//
// we may need to poke the current row into the activation so that
// it is visible to the method which evaluates the generation
// clause. this is because the generation clause may refer to other
// columns in that row.
//
try
source setcurrentrow  newrow
generationclauses invoke activation
//
// now apply not null checks and other coercions. for non-generated columns, these
// are performed in the driving resultset.
//
if   firstcolumn < 0     firstcolumn   normalizeresultset computestartcolumn  isupdate  activation getresultdescription
if   generatedcolumnpositions    null     setupgeneratedcolumns  activation   valuerow  newrow
resultdescription   resultdescription   activation getresultdescription
int                         count   generatedcolumnpositions length
for   int i   0  i < count  i
int         position   generatedcolumnpositions
datavaluedescriptor normalizedcolumn   normalizeresultset normalizecolumn
resultdescription getcolumndescriptor  position   gettype
newrow
position
normalizedgeneratedvalues
resultdescription
newrow setcolumn  position  normalizedcolumn
finally
//
// we restore the activation to its state before we ran the generation
// clause. this may not be necessary but i don't understand all of
// the paths through the insert and update result sets. this
// defensive coding seems prudent to me.
//
if   oldrow    null     source clearcurrentrow
else   source setcurrentrow  oldrow
/**
* construct support for normalizing generated columns. this figures out
* which columns in the target row have generation clauses which need to be run.
*/
private void    setupgeneratedcolumns  activation activation  valuerow newrow
throws standardexception
resultdescription   resultdescription   activation getresultdescription
int                         columncount   resultdescription getcolumncount
execrow                 emptyrow   newrow getnewnullrow
int                         generatedcolumncount   0
// first count the number of generated columns
for   int i   1  i <  columncount  i
if   i < firstcolumn     continue
resultcolumndescriptor  rcd   resultdescription getcolumndescriptor  i
if   rcd hasgenerationclause       generatedcolumncount
// now allocate and populate support structures
generatedcolumnpositions   new int
normalizedgeneratedvalues   new datavaluedescriptor
int     idx   0
for   int i   1  i <  columncount  i
if   i < firstcolumn     continue
resultcolumndescriptor  rcd   resultdescription getcolumndescriptor  i
if   rcd hasgenerationclause
generatedcolumnpositions   i
normalizedgeneratedvalues   emptyrow getcolumn  i
idx
/**
*	run check constraints against the current row. raise an error if
* a check constraint is violated.
*
*	@param	checkgm			generated code to run the check constraint.
*	@param	activation		class in which checkgm lives.
*
* @exception standardexception thrown on error
*/
public	static	void	evaluatecheckconstraints
generatedmethod checkgm
activation activation
throws standardexception
if  checkgm    null
// evaluate the expression containing the check constraints.
// this expression will throw an exception if there is a
// violation, so there is no need to check the result.
checkgm invoke activation
/**
* does this resultset cause a commit or rollback.
*
* @return whether or not this resultset cause a commit or rollback.
*/
public boolean doescommit
return false
public java sql sqlwarning getwarnings
return null