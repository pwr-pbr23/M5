/*
derby - class org.apache.derby.impl.jdbc.embeddatabasemetadata
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl jdbc
import org apache derby iapi services info productversionholder
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary spsdescriptor
import org apache derby iapi error standardexception
import org apache derby impl sql execute genericconstantactionfactory
import org apache derby impl sql execute genericexecutionfactory
import org apache derby iapi reference sqlstate
import org apache derby iapi reference limits
import java util properties
import java sql databasemetadata
import java sql connection
import java sql preparedstatement
import java sql sqlexception
import java sql resultset
import java sql types
import java io ioexception
import java io inputstream
/**
* this class provides information about the database as a whole.
*
* <p>many of the methods here return lists of information in resultsets.
* you can use the normal resultset methods such as getstring and getint
* to retrieve the data from these resultsets.  if a given form of
* metadata is not available, these methods should throw a sqlexception.
*
* <p>some of these methods take arguments that are string patterns.  these
* arguments all have names such as foopattern.  within a pattern string, "%"
* means match any substring of 0 or more characters, and "_" means match
* any one character. only metadata entries matching the search pattern
* are returned. if a search pattern argument is set to a null ref, it means
* that argument's criteria should be dropped from the search.
*
* <p>a sqlexception will be thrown if a driver does not support a meta
* data method.  in the case of methods that return a resultset,
* either a resultset (which may be empty) is returned or a
* sqlexception is thrown.
* <p>
* this implementation gets instructions from the database for how to satisfy
* most requests for information.  each instruction is either a simple string
* containing the desired information, or the text of a query that may be
* executed on the database connection to gather the information.  we get the
* instructions via an "instructionreader," which requires the database
* connection for initialization.
* <p>
* those few pieces of metadata that are related to the driver, rather than the
* database, come from a separate instructionreader.  note that in that case it
* probably doesn't make sense to allow an instruction to specify a query.
*
* @see <a href="http://java.sun.com/products/jdbc/download.html#corespec30">jdbc 3.0 specification</a>
*/
public class embeddatabasemetadata extends connectionchild
implements databasemetadata  java security privilegedaction
/*
** property and values related to using
** stored prepared statements for metatdata.
*/
private final string url
/*
** set to true if metadata is off
*/
private	genericconstantactionfactory	constantactionfactory
//////////////////////////////////////////////////////////////
//
// constructors
//
//////////////////////////////////////////////////////////////
/**
@exception sqlexception on error
*/
public embeddatabasemetadata  embedconnection connection  string url
throws sqlexception
super connection
this url   url
/** cached query descriptions from metadata.properties. */
private static properties querydescriptions
/** cached query descriptions from metadata_net.properties. */
private static properties querydescriptions_net
/**
* return all queries found in either metadata.properties or
* metadata_net.properties.
*
* @param net if <code>true</code>, read metadata_net.properties;
* otherwise, read metadata.properties.
* @return a <code>properties</code> value with the queries
*/
private properties getquerydescriptions boolean net
properties p   net ? querydescriptions_net   querydescriptions
if  p    null
return p
loadquerydescriptions
return net ? querydescriptions_net   querydescriptions
/**
* read the query descriptions from metadata.properties and
* metadata_net.properties. this method must be invoked from
* within a privileged block.
*/
private void pbloadquerydescriptions
string files
properties props   new properties
for  int i   0  i < files length    i
try
props   new properties
// security permission - ip3
inputstream is   getclass   getresourceasstream files
props load is
is close
catch  ioexception ioe
if  sanitymanager debug
sanitymanager throwassert     files  ioe
querydescriptions   props
querydescriptions_net   props
//////////////////////////////////////////////////////////////
//
// databasemetadata interface
//
//////////////////////////////////////////////////////////////
//----------------------------------------------------------------------
// first, a variety of minor information about the target database.
/**
* can all the procedures returned by getprocedures be called by the
* current user?
*
* @return true if so
*/
public boolean allproceduresarecallable
return true
/**
* can all the tables returned by gettable be selected by the
* current user?
*
* @return true if so
*/
public boolean alltablesareselectable
return true
/**
* what's the url for this database?
*
* @return the url or null if it can't be generated
*/
public final string geturl
if  url    null
return url
int attributestart   url indexof
if  attributestart     1
return url
else
return url substring 0 attributestart
/**
* what's our user name as known to the database?
*
* @return our database user name
*/
public string getusername
return  getembedconnection   gettr   getusername
/**
* is the database in read-only mode?
*
* @return true if so
*/
public boolean isreadonly
return getlanguageconnectioncontext   getdatabase   isreadonly
/**
* are null values sorted high?
*
* @return true if so
*/
public boolean nullsaresortedhigh
return true
/**
* are null values sorted low?
*
* @return true if so
*/
public boolean nullsaresortedlow
return false
/**
* are null values sorted at the start regardless of sort order?
*
* @return true if so
*/
public boolean nullsaresortedatstart
return false
/**
* are null values sorted at the end regardless of sort order?
*
* @return true if so
*/
public boolean nullsaresortedatend
return false
/**
* what's the name of this database product?
*
* @return database product name
*/
public string getdatabaseproductname
return monitor getmonitor   getengineversion   getproductname
/**
* what's the version of this database product?
*
* @return database version
*/
public string getdatabaseproductversion
productversionholder mypvh   monitor getmonitor   getengineversion
return mypvh getversionbuildstring true
/**
* what's the name of this jdbc driver?
*
* @return jdbc driver name
*/
public string getdrivername
return
/**
* what's the version of this jdbc driver?
*
* @return jdbc driver version
*/
public string getdriverversion
return getdatabaseproductversion
/**
* what's this jdbc driver's major version number?
*
* @return jdbc driver major version
*/
public int getdrivermajorversion
return getembedconnection   getlocaldriver   getmajorversion
/**
* what's this jdbc driver's minor version number?
*
* @return jdbc driver minor version number
*/
public int getdriverminorversion
return getembedconnection   getlocaldriver   getminorversion
/**
* does the database store tables in a local file?
*
* @return true if so
*/
public boolean useslocalfiles
return true
/**
* does the database use a file for each table?
*
* @return true if the database uses a local file for each table
*/
public boolean useslocalfilepertable
return true
/**
* does the database treat mixed case unquoted sql identifiers as
* case sensitive and as a result store them in mixed case?
*
* a jdbc-compliant driver will always return false.
*
* @return true if so
*/
public boolean supportsmixedcaseidentifiers
return false
/**
* does the database treat mixed case unquoted sql identifiers as
* case insensitive and store them in upper case?
*
* @return true if so
*/
public boolean storesuppercaseidentifiers
return true
/**
* does the database treat mixed case unquoted sql identifiers as
* case insensitive and store them in lower case?
*
* @return true if so
*/
public boolean storeslowercaseidentifiers
return false
/**
* does the database treat mixed case unquoted sql identifiers as
* case insensitive and store them in mixed case?
*
* @return true if so
*/
public boolean storesmixedcaseidentifiers
return false
/**
* does the database treat mixed case quoted sql identifiers as
* case sensitive and as a result store them in mixed case?
*
* a jdbc-compliant driver will always return true.
*
* @return true if so
*/
public boolean supportsmixedcasequotedidentifiers
return true
/**
* does the database treat mixed case quoted sql identifiers as
* case insensitive and store them in upper case?
*
* @return true if so
*/
public boolean storesuppercasequotedidentifiers
return false
/**
* does the database treat mixed case quoted sql identifiers as
* case insensitive and store them in lower case?
*
* @return true if so
*/
public boolean storeslowercasequotedidentifiers
return false
/**
* does the database treat mixed case quoted sql identifiers as
* case insensitive and store them in mixed case?
*
* @return true if so
*/
public boolean storesmixedcasequotedidentifiers
return true
/**
* what's the string used to quote sql identifiers?
* this returns a space " " if identifier quoting isn't supported.
*
* a jdbc-compliant driver always uses a double quote character.
*
* @return the quoting string
*/
public string getidentifierquotestring
return  "
/**
* get a comma separated list of all a database's sql keywords
* that are not also sql92 keywords.
includes reserved and non-reserved keywords.
* @return the list
*/
public string getsqlkeywords
return
/**
* get a comma separated list of jdbc escaped numeric functions.
* must be a complete or sub set of functions in appendix c.1
* of jdbc 3.0 specification (pp. 183).
* @return the list
*/
public string getnumericfunctions
return
/**
* get a comma separated list of jdbc escaped string functions.
* must be a complete or sub set of functions in appendix c.2
* of jdbc 3.0 specification (pp. 184).
* @return the list
*/
public string getstringfunctions
return
/**
* get a comma separated list of jdbc escaped system functions.
* must be a complete or sub set of functions in appendix c.4
* of jdbc 3.0 specification (pp. 185).
* @return the list
*/
public string getsystemfunctions
return
/**
* get a comma separated list of jdbc escaped time date functions.
* must be a complete or sub set of functions in appendix c.3
* of jdbc 3.0 specification.
* @return the list
*/
public string gettimedatefunctions
return
/**
* this is the string that can be used to escape '_' or '%' in
* the string pattern style catalog search parameters.
we have no default escape value, so = is the end of the next line
* <p>the '_' character represents any single character.
* <p>the '%' character represents any sequence of zero or
* more characters.
* @return the string used to escape wildcard characters
*/
public string getsearchstringescape
return
/**
* get all the "extra" characters that can be used in unquoted
* identifier names (those beyond a-z, a-z, 0-9 and _).
*
* @return the string containing the extra characters
*/
public string getextranamecharacters
return
//--------------------------------------------------------------------
// functions describing which features are supported.
/**
* is "alter table" with add column supported?
*
* @return true if so
*/
public boolean supportsaltertablewithaddcolumn
return true
/**
* is "alter table" with drop column supported?
*
* @return true if so
*/
public boolean supportsaltertablewithdropcolumn
return true
/**
* is column aliasing supported?
*
* <p>if so, the sql as clause can be used to provide names for
* computed columns or to provide alias names for columns as
* required.
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportscolumnaliasing
return true
/**
* are concatenations between null and non-null values null?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean nullplusnonnullisnull
return true
/**
* is the convert function between sql types supported?
*
* @return true if so
*/
public boolean supportsconvert
return true
/**
* is convert between the given sql types supported?
*
* @param fromtype the type to convert from
* @param totype the type to convert to
* @return true if so
* @see types
*/
public boolean supportsconvert int fromtype  int totype
/*
* at the moment we don't support convert at all, so we take the easy
* way out.  eventually we need to figure out how to handle this
* cleanly.
*/
return false
/**
* are table correlation names supported?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportstablecorrelationnames
return true
/**
* if table correlation names are supported, are they restricted
* to be different from the names of the tables?
*
* @return true if so
*/
public boolean supportsdifferenttablecorrelationnames
return true
/**
* are expressions in "order by" lists supported?
*
* @return true if so
*/
public boolean supportsexpressionsinorderby
/* derby - 2244 : derby does support order by expression (derby-134)
* thus changing the return value to true to relfect that the support
* is present
*/
return true
/**
* can an "order by" clause use columns not in the select?
*
* @return true if so
*/
public boolean supportsorderbyunrelated
return false
/**
* is some form of "group by" clause supported?
*
* @return true if so
*/
public boolean supportsgroupby
return true
/**
* can a "group by" clause use columns not in the select?
*
* @return true if so
*/
public boolean supportsgroupbyunrelated
return true
/**
* can a "group by" clause add columns not in the select
* provided it specifies all the columns in the select?
*
* @return true if so
*/
public boolean supportsgroupbybeyondselect
return true
/**
* is the escape character in "like" clauses supported?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportslikeescapeclause
return true
/**
* are multiple resultsets from a single execute supported?
*
* @return true if so
*/
public boolean supportsmultipleresultsets
return true
/**
* can we have multiple transactions open at once (on different
* connections)?
*
* @return true if so
*/
public boolean supportsmultipletransactions
return true
/**
* can columns be defined as non-nullable?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportsnonnullablecolumns
return true
/**
* is the odbc minimum sql grammar supported?
*
* all jdbc-compliant drivers must return true.
*
* @return true if so
*/
public boolean supportsminimumsqlgrammar
return true
/**
* is the odbc core sql grammar supported?
*
* @return true if so
*/
public boolean supportscoresqlgrammar
return false
/**
* is the odbc extended sql grammar supported?
*
* @return true if so
*/
public boolean supportsextendedsqlgrammar
return false
/**
* is the ansi92 entry level sql grammar supported?
*
* all jdbc-compliant drivers must return true.
*
* @return true if so
*/
public boolean supportsansi92entrylevelsql
/* derby - 2243 : derby does support ansi 92 standards,
* thus changing the return value to true to relfect that the support
* is present
*/
return true
/**
* is the ansi92 intermediate sql grammar supported?
*
* @return true if so
*
*/
public boolean supportsansi92intermediatesql
return false
/**
* is the ansi92 full sql grammar supported?
*
* @return true if so
*
*/
public boolean supportsansi92fullsql
return false
/**
* is the sql integrity enhancement facility supported?
*
* @return true if so
*
*/
public boolean supportsintegrityenhancementfacility
return false
/**
* is some form of outer join supported?
*
* @return true if so
*
*/
public boolean supportsouterjoins
return true
/**
* are full nested outer joins supported?
*
* @return true if so
*
*/
public boolean supportsfullouterjoins
return false
/**
* is there limited support for outer joins?  (this will be true
* if supportfullouterjoins is true.)
*
* @return true if so
*
*/
public boolean supportslimitedouterjoins
return true
/**
* what's the database vendor's preferred term for "schema"?
*
* @return the vendor term
*
*/
public string getschematerm
return
/**
* what's the database vendor's preferred term for "procedure"?
*
* @return the vendor term
*
*/
public string getprocedureterm
return
/**
* what's the database vendor's preferred term for "catalog"?
*
* @return the vendor term
*
*/
public string getcatalogterm
return
/**
* does a catalog appear at the start of a qualified table name?
* (otherwise it appears at the end)
*
* @return true if it appears at the start
*
*/
public boolean iscatalogatstart
return false
/**
* what's the separator between catalog and table name?
*
* @return the separator string
*
*/
public string getcatalogseparator
return
/**
* can a schema name be used in a data manipulation statement?
*
* @return true if so
*
*/
public boolean supportsschemasindatamanipulation
return true
/**
* can a schema name be used in a procedure call statement?
*
* @return true if so
*
*/
public boolean supportsschemasinprocedurecalls
return true
/**
* can a schema name be used in a table definition statement?
*
* @return true if so
*
*/
public boolean supportsschemasintabledefinitions
return true
/**
* can a schema name be used in an index definition statement?
*
* @return true if so
*/
public boolean supportsschemasinindexdefinitions
return true
/**
* can a schema name be used in a privilege definition statement?
*
* @return true if so
*
*/
public boolean supportsschemasinprivilegedefinitions
return true
/**
* can a catalog name be used in a data manipulation statement?
*
* @return true if so
*
*/
public boolean supportscatalogsindatamanipulation
return false
/**
* can a catalog name be used in a procedure call statement?
*
* @return true if so
*
*/
public boolean supportscatalogsinprocedurecalls
return false
/**
* can a catalog name be used in a table definition statement?
*
* @return true if so
*
*/
public boolean supportscatalogsintabledefinitions
return false
/**
* can a catalog name be used in an index definition statement?
*
* @return true if so
*/
public boolean supportscatalogsinindexdefinitions
return false
/**
* can a catalog name be used in a privilege definition statement?
*
* @return true if so
*/
public boolean supportscatalogsinprivilegedefinitions
return false
/**
* is positioned delete supported?
*
* @return true if so
*/
public boolean supportspositioneddelete
return true
/**
* is positioned update supported?
*
* @return true if so
*/
public boolean supportspositionedupdate
return true
/**
* is select for update supported?
*
* @return true if so
*/
public boolean supportsselectforupdate
return true
/**
* are stored procedure calls using the stored procedure escape
* syntax supported?
*
* @return true if so
*/
public boolean supportsstoredprocedures
return true
/**
* are subqueries in comparison expressions supported?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportssubqueriesincomparisons
return true
/**
* are subqueries in 'exists' expressions supported?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportssubqueriesinexists
return true
/**
* are subqueries in 'in' statements supported?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportssubqueriesinins
return true
/**
* are subqueries in quantified expressions supported?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportssubqueriesinquantifieds
return true
/**
* are correlated subqueries supported?
*
* a jdbc-compliant driver always returns true.
*
* @return true if so
*/
public boolean supportscorrelatedsubqueries
return true
/**
* is sql union supported?
*
* @return true if so
*/
public boolean supportsunion
return true
/**
* is sql union all supported?
*
* @return true if so
*/
public boolean supportsunionall
return true
/**
* can cursors remain open across commits?
*
* @return true if cursors always remain open; false if they might not remain open
*/
//returns false because derby does not support cursors that are open across commits for xa transactions.
public boolean supportsopencursorsacrosscommit
return false
/**
* can cursors remain open across rollbacks?
*
* @return true if cursors always remain open; false if they might not remain open
*/
public boolean supportsopencursorsacrossrollback
return false
/**
* can statements remain open across commits?
*
* @return true if statements always remain open; false if they might not remain open
*/
public boolean supportsopenstatementsacrosscommit
return true
/**
* can statements remain open across rollbacks?
*
* @return true if statements always remain open; false if they might not remain open
*/
public boolean supportsopenstatementsacrossrollback
return false
//----------------------------------------------------------------------
// the following group of methods exposes various limitations
// based on the target database with the current driver.
// unless otherwise specified, a result of zero means there is no
// limit, or the limit is not known.
/**
* how many hex characters can you have in an inline binary literal?
*
* @return max literal length
*/
public int getmaxbinaryliterallength
return 0
/**
* what's the max length for a character literal?
*
* @return max literal length
*/
public int getmaxcharliterallength
return 0
/**
* what's the limit on column name length?
*
* @return max literal length
*/
public int getmaxcolumnnamelength
return limits max_identifier_length
/**
* what's the maximum number of columns in a "group by" clause?
*
* @return max number of columns
*/
public int getmaxcolumnsingroupby
return 0
/**
* what's the maximum number of columns allowed in an index?
*
* @return max columns
*/
public int getmaxcolumnsinindex
return 0
/**
* what's the maximum number of columns in an "order by" clause?
*
* @return max columns
*/
public int getmaxcolumnsinorderby
return 0
/**
* what's the maximum number of columns in a "select" list?
*
* we don't have a limit...
*
* @return max columns
*/
public int getmaxcolumnsinselect
return 0
/**
* what's the maximum number of columns in a table?
*
* @return max columns
*/
public int getmaxcolumnsintable
return 0
/**
* how many active connections can we have at a time to this database?
*
* @return max connections
*/
public int getmaxconnections
return 0
/**
* what's the maximum cursor name length?
*
* @return max cursor name length in bytes
*/
public int getmaxcursornamelength
return limits max_identifier_length
/**
* what's the maximum length of an index (in bytes)?
*
* @return max index length in bytes
*/
public int getmaxindexlength
return 0
/**
* what's the maximum length allowed for a schema name?
*
* @return max name length in bytes
*/
public int getmaxschemanamelength
return limits max_identifier_length
/**
* what's the maximum length of a procedure name?
*
* @return max name length in bytes
*/
public int getmaxprocedurenamelength
return limits max_identifier_length
/**
* what's the maximum length of a catalog name?
*
* @return max name length in bytes
*/
public int getmaxcatalognamelength
return 0
/**
* what's the maximum length of a single row?
*
* @return max row size in bytes
*/
public int getmaxrowsize
return 0
/**
* did getmaxrowsize() include longvarchar and longvarbinary
* blobs?
*
* @return true if so
*/
public boolean doesmaxrowsizeincludeblobs
return true
/**
* what's the maximum length of a sql statement?
*
* @return max length in bytes
*/
public int getmaxstatementlength
return 0
/**
* how many active statements can we have open at one time to this
* database?
*
* @return the maximum
*/
public int getmaxstatements
return 0
/**
* what's the maximum length of a table name?
*
* @return max name length in bytes
*/
public int getmaxtablenamelength
return limits max_identifier_length
/**
* what's the maximum number of tables in a select?
*
* @return the maximum
*/
public int getmaxtablesinselect
return 0
/**
* what's the maximum length of a user name?
*
* @return max name length  in bytes
*/
public int getmaxusernamelength
return limits db2_max_userid_length
//----------------------------------------------------------------------
/**
* what's the database's default transaction isolation level?  the
* values are defined in java.sql.connection.
*
* @return the default isolation level
* @see connection
*/
public int getdefaulttransactionisolation
return java sql connection transaction_read_committed
/**
* are transactions supported? if not, commit is a noop and the
* isolation level is transaction_none.
*
* @return true if transactions are supported
*/
public boolean supportstransactions
return true
/**
* does the database support the given transaction isolation level?
*
* databasemetadata.supportstransactionisolation() should return false for
* isolation levels that are not supported even if a higher level can be
* substituted.
*
* @param level the values are defined in java.sql.connection
* @return true if so
* @see connection
*/
public boolean supportstransactionisolationlevel int level
// remind: this is hard-coded for the moment because it doesn't nicely
// fit within the framework we've set up for the rest of these values.
// part of the reason is that it has a parameter, so it's not just a
// simple value look-up.  some ideas for the future on how to make this
// not hard-coded:
//	  - code it as a query: "select true from <something> where ? in
//      (a,b,c)" where a,b,c are the supported isolation levels.  the
//      parameter would be set to "level".  this seems awfully awkward.
//    - somehow what you'd really like is to enable the instructions
//      file to contain the list, or set, of supported isolation
//      levels.  something like:
//          supportstr...ionlevel=serializable | repeatable_read | ...
//      that would take some more code that doesn't seem worthwhile at
//      the moment for this one case.
/*
remind: this could be moved into a query that is e.g.
values ( ? in (8,...) )
so that database could control the list of supported
isolations.  for now, it's hard coded, and just the one.
*/
return  level    connection transaction_serializable
level    connection transaction_repeatable_read
level    connection transaction_read_committed
level    connection transaction_read_uncommitted
/**
* are both data definition and data manipulation statements
* within a transaction supported?
*
* @return true if so
*/
public boolean supportsdatadefinitionanddatamanipulationtransactions
return true
/**
* are only data manipulation statements within a transaction
* supported?
*
* @return true if so
*/
public boolean supportsdatamanipulationtransactionsonly
return false
/**
* does a data definition statement within a transaction force the
* transaction to commit?
*
* @return true if so
*
*/
public boolean datadefinitioncausestransactioncommit
return false
/**
* is a data definition statement within a transaction ignored?
*
* @return true if so
*
*/
public boolean datadefinitionignoredintransactions
return false
/**
* get a description of stored procedures available in a
* catalog.
*
* <p>only procedure descriptions matching the schema and
* procedure name criteria are returned.  they are ordered by
* procedure_schem, and procedure_name.
*
* <p>each procedure description has the the following columns:
*  <ol>
*	<li><b>procedure_cat</b> string => procedure catalog (may be null)
*	<li><b>procedure_schem</b> string => procedure schema (may be null)
*	<li><b>procedure_name</b> string => procedure name
*  <li> reserved for future use
*  <li> reserved for future use
*  <li> reserved for future use
*	<li><b>remarks</b> string => explanatory comment on the procedure
*	<li><b>procedure_type</b> short => kind of procedure:
*      <ul>
*      <li> procedureresultunknown - may return a result
*      <li> procedurenoresult - does not return a result
*      <li> procedurereturnsresult - returns a result
*      </ul>
*  <li><b>specific_name</b> string => the name which uniquely
*  identifies this procedure within its schema (since jdbc 4.0)
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schemapattern a schema name pattern; "" retrieves those
* without a schema
* @param procedurenamepattern a procedure name pattern
* @return resultset - each row is a procedure description
* @see #getsearchstringescape
* @exception sqlexception thrown on failure.
*/
public resultset getprocedures string catalog  string schemapattern
string procedurenamepattern  throws sqlexception
// using the new jdbc 4.0 version of the query here. the query
// was given a new name to allow the old query to
// be used by odbcmetadatagenerator.
return dogetprocs catalog  schemapattern
procedurenamepattern
/**
* get a description of stored procedures available in a
* catalog.  same as getprocedures() above, except that
* the result set will conform to odbc specifications.
*/
public resultset getproceduresforodbc string catalog  string schemapattern
string procedurenamepattern  throws sqlexception
// for odbc we still use the transformed version of the jdbc
// 3.0 query, (may change in the future).
return dogetprocs catalog  schemapattern
procedurenamepattern
/**
* implements databasemetadata.getfunctions() for an embedded
* database. queries the database to get information about
* functions (procedures returning values). executes the
* 'getfunctions' query from metadata.properties to obtain the
* resultset to return.<p> compatibility: this is a new method in
* the api which is only available with with derby versions > 10.1 and
* jdk versions >= 1.6 <p>upgrade: since this is a new query it
* does not have an sps, and will be available as soon as any
* database, new or old, is booted with the new version of derby,
* (in <b>soft and hard</b> upgrade).
* @param catalog limit the search to functions in this catalog
* (not used)
* @param schemapattern limit the search to functions in schemas
* matching this pattern
* @param functionnamepattern limit the search to functions
* matching this pattern
* @return a resultset with metadata information
* @throws sqlexception if any of the underlying jdbc methods fail
*/
public resultset getfunctions java lang string catalog
java lang string schemapattern
java lang string functionnamepattern
throws sqlexception
return dogetprocs catalog  schemapattern
functionnamepattern
/**
* does the actual work for the getprocedures and getfunctions
* metadata calls.  see getprocedures() method above for parameter
* descriptions.
* @param queryname name of the query to execute; is used
*	to determine whether the result set should conform to
*	jdbc or odbc specifications.
*/
private resultset dogetprocs string catalog  string schemapattern
string procedurenamepattern  string queryname
throws sqlexception
preparedstatement s   getpreparedquery queryname
s setstring 1  swapnull catalog
s setstring 2  swapnull schemapattern
s setstring 3  swapnull procedurenamepattern
return s executequery
/**
* get a description of a catalog's stored procedure parameters
* and result columns.
*
* <p>only descriptions matching the schema, procedure and
* parameter name criteria are returned.  they are ordered by
* procedure_schem and procedure_name. within this, the return value,
* if any, is first. next are the parameter descriptions in call
* order. the column descriptions follow in column number order.
*
* <p>each row in the resultset is a parameter description or
* column description with the following fields:
*  <ol>
*	<li><b>procedure_cat</b> string => procedure catalog (may be null)
*	<li><b>procedure_schem</b> string => procedure schema (may be null)
*	<li><b>procedure_name</b> string => procedure name
*	<li><b>column_name</b> string => column/parameter name
*	<li><b>column_type</b> short => kind of column/parameter:
*      <ul>
*      <li> procedurecolumnunknown - nobody knows
*      <li> procedurecolumnin - in parameter
*      <li> procedurecolumninout - inout parameter
*      <li> procedurecolumnout - out parameter
*      <li> procedurecolumnreturn - procedure return value
*      <li> procedurecolumnresult - result column in resultset
*      </ul>
*  <li><b>data_type</b> int => sql type from java.sql.types
*	<li><b>type_name</b> string => sql type name
*	<li><b>precision</b> int => precision
*	<li><b>length</b> int => length in bytes of data
*	<li><b>scale</b> short => scale
*	<li><b>radix</b> short => radix
*	<li><b>nullable</b> short => can it contain null?
*      <ul>
*      <li> procedurenonulls - does not allow null values
*      <li> procedurenullable - allows null values
*      <li> procedurenullableunknown - nullability unknown
*      </ul>
*	<li><b>remarks</b> string => comment describing parameter/column
*	<li><b>column_def</b> string
*	<li><b>sql_data_type</b> int
*	<li><b>sql_datetime_sub</b> int
*	<li><b>char_octet_length</b> int
*	<li><b>ordinal_position</b> int
*	<li><b>is_nullable</b> string
*	<li><b>specific_name</b> string
*  </ol>
*
* <p><b>note:</b> some databases may not return the column
* descriptions for a procedure. additional columns beyond
* specific_name can be defined by the database.
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schemapattern a schema name pattern; "" retrieves those
* without a schema
* @param procedurenamepattern a procedure name pattern
* @param columnnamepattern a column name pattern
* @return resultset - each row is a stored procedure parameter or
*      column description
* @see #getsearchstringescape
* @exception sqlexception thrown on failure.
*/
public resultset getprocedurecolumns string catalog
string schemapattern
string procedurenamepattern
string columnnamepattern  throws sqlexception
// using the new jdbc 4.0 version of the query here. the query
// was given a new name to allow the old query to
// be used by odbcmetadatagenerator.
return dogetproccols catalog  schemapattern
procedurenamepattern  columnnamepattern
/**
* get a description of a catalog's stored procedure parameters
* and result columns.  same as getprocedurecolumns() above,
* except that the result set will conform to odbc specifications.
*/
public resultset getprocedurecolumnsforodbc string catalog
string schemapattern  string procedurenamepattern
string columnnamepattern  throws sqlexception
// for odbc we still use the transformed version of the jdbc
// 3.0 query, (may change in the future).
return dogetproccols catalog  schemapattern
procedurenamepattern  columnnamepattern
/**
* implements databasemetadata.getfunctioncolumns() for an embedded
* database. queries the database to get information about
* function parameters. executes the
* 'getfunctioncolumns' query from metadata.properties to obtain the
* resultset.<p> compatibility: this is a new method in
* the api which is only available with with derby versions > 10.1 and
* jdk versions >= 1.6 <p>upgrade: since this is a new query it
* does not have an sps, and will be available as soon as any
* database, new or old, is booted with the new version of derby,
* (in <b>soft and hard</b> upgrade).
* @param catalog limit the search to functions in this catalog
* (not used)
* @param schemapattern limit the search to functions in schemas
* matching this pattern
* @param functionnamepattern limit the search to functions
* matching this pattern
* @param parameternamepattern limit the search parameters
* matching this pattern
* @return a resultset with metadata information
* @throws sqlexception if a database error occurs
*/
public resultset getfunctioncolumns string catalog
string schemapattern
string functionnamepattern
string parameternamepattern
throws sqlexception
return dogetproccols catalog
schemapattern
functionnamepattern
parameternamepattern
/**
* does the actual work for the getprocedurecolumns metadata
* calls. see getprocedurecolumns() method above for parameter
* descriptions.
* @param queryname name of the query to execute; is used
*	to determine whether the result set should conform to
*	jdbc or odbc specifications.
*/
private resultset dogetproccols string catalog  string schemapattern
string procedurenamepattern  string columnnamepattern
string queryname  throws sqlexception
preparedstatement s   getpreparedquery queryname
//
// catalog is not part of the query
//
s setstring 1  swapnull schemapattern
s setstring 2  swapnull procedurenamepattern
s setstring 3  swapnull columnnamepattern
return s executequery
/**
* get a description of tables available in a catalog.
*
* <p>only table descriptions matching the catalog, schema, table
* name and type criteria are returned.  they are ordered by
* table_type, table_schem and table_name.
*
* <p>each table description has the following columns:
*  <ol>
*	<li><b>table_cat</b> string => table catalog (may be null)
*	<li><b>table_schem</b> string => table schema (may be null)
*	<li><b>table_name</b> string => table name
*	<li><b>table_type</b> string => table type.  typical types are "table",
*			"view",	"system table", "global temporary",
*			"local temporary", "alias", "synonym".
*	<li><b>remarks</b> string => explanatory comment on the table
*  <li><b>type_cat</b> string => the types catalog (may be
*          <code>null</code>)
*  <li><b>type_schem</b> string => the types schema (may be
*          <code>null</code>)
*  <li><b>type_name</b> string => type name (may be
*          <code>null</code>)
*  <li><b>self_referencing_col_name</b> string => name of the
*          designated "identifier" column of a typed table (may
*          be <code>null</code>)
*  <li><b>ref_generation</b> string => specifies how values in
*          self_referencing_col_name are created. values are
*          "system", "user", "derived". (may be
*          <code>null</code>)
*  </ol>
*
* <p><b>note:</b> some databases may not return information for
* all tables.
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schemapattern a schema name pattern; "" retrieves those
* without a schema
* @param tablenamepattern a table name pattern
* @param types a list of table types to include; null returns all types
* @return resultset - each row is a table description
* @see #getsearchstringescape
* @exception sqlexception thrown on failure.
*/
public resultset gettables string catalog  string schemapattern
string tablenamepattern  string types  throws sqlexception
preparedstatement s   getpreparedquery
s setstring 1  swapnull catalog
s setstring 2  swapnull schemapattern
s setstring 3  swapnull tablenamepattern
//important
//whenever a new table type is added to derby, the sql for
//gettables in metadata.properties will have to change and the
//following if else will need to be modified too.
//
//the gettables sql in metadata.properties has following clause
//tabletype in (?, ?, ?, ?)
//there are 4?s for in list because derby supports 4 tables types
//at the moment which are 't','s','v' and 'a'.
//anytime a new table type is added, an additional ? should be
//added to the above clause. in addition, the following code will
//have to change too because it will need to set value for that
//additional ?.
//
//following explains the logic for table types handling.
//if the user has asked for specific table types in gettables,
//then the "if" statement below will use those types values
//for ?s. if there are still some ?s in the in list that are left
//with unassigned values, then we will set those ? to null.
// so paramter 4 will be "t" for table, 5 will be "v" for view, 6 will be
// "a" for synonym, 7 will be "s" for system table in
//tabletype in (?, ?, ?, ?)
// if the user hasn't asked for any specific table types then all
// four values will be set.
// when a new table type is added to derby we will have to add a
// parameter to the metadata statement and handle it here.
// array for type parameters
final int numberoftabletypesinderby   4
if  types    null       null means all types
types   new string
string typeparams   new string
for  int i 0  i < numberoftabletypesinderby i
typeparams   null
for  int i   0  i<types length  i
if    equals types
typeparams
else if    equals types
typeparams
else if    equals types
typeparams
else if    equals types
equals types      keep system_table since this is how we have been testing
typeparams
// if user puts in other types we simply ignore.
// 	tabletype in (?,?,?,?) starts at parameter 4 so we add 4
// set to value passed in or null if no value was given.
for  int i 0  i < numberoftabletypesinderby  i
if  typeparams    null
s setnull i 4 types char
else
s setstring i 4 typeparams
return s executequery
/**
* get the schema names available in this database.  the results
* are ordered by schema name.
*
* <p>the schema columns are:
*  <ol>
*  <li><strong>table_schem</strong> string =&gt; schema name</li>
*  <li><strong>table_catalog</strong> string =&gt; catalog name
*  (may be <code>null</code>)</li>
*  </ol>
*
* @return resultset - each row is a schema description
* @exception sqlexception thrown on failure.
*/
public resultset getschemas   throws sqlexception
return getschemas null  null
/**
* get the catalog names available in this database.  the results
* are ordered by catalog name.
*
* <p>the catalog column is:
*  <ol>
*	<li><b>table_cat</b> string => catalog name
*  </ol>
*
* @return resultset - each row has a single string column that is a
* catalog name
* @exception sqlexception thrown on failure.
*/
public resultset getcatalogs   throws sqlexception
return getsimplequery
/**
* get the table types available in this database.  the results
* are ordered by table type.
*
* <p>the table type is:
*  <ol>
*	<li><b>table_type</b> string => table type.  typical types are "table",
*			"view",	"system table", "global temporary",
*			"local temporary", "alias", "synonym".
*  </ol>
*
* @return resultset - each row has a single string column that is a
* table type
* @exception sqlexception thrown on failure.
*/
public resultset gettabletypes   throws sqlexception
return getsimplequery
/**
* get a description of table columns available in a catalog.
*
* <p>only column descriptions matching the catalog, schema, table
* and column name criteria are returned.  they are ordered by
* table_schem, table_name and ordinal_position.
*
* <p>each column description has the following columns:
*  <ol>
*	<li><b>table_cat</b> string => table catalog (may be null)
*	<li><b>table_schem</b> string => table schema (may be null)
*	<li><b>table_name</b> string => table name
*	<li><b>column_name</b> string => column name
*	<li><b>data_type</b> int => sql type from java.sql.types
*	<li><b>type_name</b> string => data source dependent type name
*	<li><b>column_size</b> int => column size.  for char or date
*	    types this is the maximum number of characters, for numeric or
*	    decimal types this is precision.
*	<li><b>buffer_length</b> is not used.
*	<li><b>decimal_digits</b> int => the number of fractional digits
*	<li><b>num_prec_radix</b> int => radix (typically either 10 or 2)
*	<li><b>nullable</b> int => is null allowed?
*      <ul>
*      <li> columnnonulls - might not allow null values
*      <li> columnnullable - definitely allows null values
*      <li> columnnullableunknown - nullability unknown
*      </ul>
*	<li><b>remarks</b> string => comment describing column (may be null)
* 	<li><b>column_def</b> string => default value (may be null)
*	<li><b>sql_data_type</b> int => unused
*	<li><b>sql_datetime_sub</b> int => unused
*	<li><b>char_octet_length</b> int => for char types the
*       maximum number of bytes in the column
*	<li><b>ordinal_position</b> int	=> index of column in table
*      (starting at 1)
*	<li><b>is_nullable</b> string => "no" means column definitely
*      does not allow null values; "yes" means the column might
*      allow null values.  an empty string means nobody knows.
*  <li><b>scope_catlog</b> string => catalog of table that is the
*  scope of a reference attribute (<code>null</code> if data_type
*  isn't ref)
*  <li><b>scope_schema</b> string => schema of table that is the
*  scope of a reference attribute (<code>null</code> if the
*  data_type isn't ref)
*  <li><b>scope_table</b> string => table name that this the
*  scope of a reference attribure (<code>null</code> if the
*  data_type isn't ref)
*  <li><b>source_data_type</b> short => source type of a distinct
*  type or user-generated ref type, sql type from java.sql.types
*  (<code>null</code> if data_type isn't distinct or
*  user-generated ref)
*  <li><b>is_autoincrement</b> string => indicates whether this
*  column is auto incremented
*  <ul>
*  <li> yes --- if the column is auto incremented
*  <li> no --- if the column is not auto incremented
*  <li> empty string --- if it cannot be determined whether the
*       column is auto incremented parameter is unknown
*  </ul>
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schemapattern a schema name pattern; "" retrieves those
* without a schema
* @param tablenamepattern a table name pattern
* @param columnnamepattern a column name pattern
* @return resultset - each row is a column description
* @see #getsearchstringescape
* @exception sqlexception thrown on failure.
*/
public resultset getcolumns string catalog  string schemapattern
string tablenamepattern  string columnnamepattern
throws sqlexception
return dogetcols catalog  schemapattern  tablenamepattern
columnnamepattern
/**
* get a description of table columns available in a catalog.
* same as getcolumns() above, except that the result set
* will conform to odbc specifications.
*/
public resultset getcolumnsforodbc string catalog  string schemapattern
string tablenamepattern  string columnnamepattern
throws sqlexception
return dogetcols catalog  schemapattern  tablenamepattern
columnnamepattern
/**
* does the actual work for the getcolumns metadata calls.
* see getcolumns() method above for parameter descriptions.
* @param queryname name of the query to execute; is used
*	to determine whether the result set should conform to
*	jdbc or odbc specifications.
*/
private resultset dogetcols string catalog  string schemapattern
string tablenamepattern  string columnnamepattern
string queryname  throws sqlexception
preparedstatement s   getpreparedquery queryname
s setstring 1  swapnull catalog
s setstring 2  swapnull schemapattern
s setstring 3  swapnull tablenamepattern
s setstring 4  swapnull columnnamepattern
return s executequery
/**
* get a description of the access rights for a table's columns.
*
* <p>only privileges matching the column name criteria are
* returned.  they are ordered by column_name and privilege.
*
* <p>each privilige description has the following columns:
*  <ol>
*	<li><b>table_cat</b> string => table catalog (may be null)
*	<li><b>table_schem</b> string => table schema (may be null)
*	<li><b>table_name</b> string => table name
*	<li><b>column_name</b> string => column name
*	<li><b>grantor</b> => grantor of access (may be null)
*	<li><b>grantee</b> string => grantee of access
*	<li><b>privilege</b> string => name of access (select,
*      insert, update, refrences, ...)
*	<li><b>is_grantable</b> string => "yes" if grantee is permitted
*      to grant to others; "no" if not; null if unknown
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schema a schema name; "" retrieves those without a schema
* @param table a table name
* @param columnnamepattern a column name pattern
* @return resultset - each row is a column privilege description
* @see #getsearchstringescape
* @exception sqlexception thrown on failure.
*/
public resultset getcolumnprivileges string catalog  string schema
string table  string columnnamepattern  throws sqlexception
if  table    null
throw util generatecssqlexception
sqlstate table_name_cannot_be_null
preparedstatement s   getpreparedquery
s setstring 1  swapnull catalog
s setstring 2  swapnull schema
s setstring 3  table     derby 1484  must match table name as stored
s setstring 4  swapnull columnnamepattern
return s executequery
/**
* get a description of the access rights for each table available
* in a catalog. note that a table privilege applies to one or
* more columns in the table. it would be wrong to assume that
* this priviledge applies to all columns (this may be true for
* some systems but is not true for all.)
*
* <p>only privileges matching the schema and table name
* criteria are returned.  they are ordered by table_schem,
* table_name, and privilege.
*
* <p>each privilige description has the following columns:
*  <ol>
*	<li><b>table_cat</b> string => table catalog (may be null)
*	<li><b>table_schem</b> string => table schema (may be null)
*	<li><b>table_name</b> string => table name
*	<li><b>grantor</b> => grantor of access (may be null)
*	<li><b>grantee</b> string => grantee of access
*	<li><b>privilege</b> string => name of access (select,
*      insert, update, refrences, ...)
*	<li><b>is_grantable</b> string => "yes" if grantee is permitted
*      to grant to others; "no" if not; null if unknown
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schemapattern a schema name pattern; "" retrieves those
* without a schema
* @param tablenamepattern a table name pattern
* @return resultset - each row is a table privilege description
* @see #getsearchstringescape
* @exception sqlexception thrown on failure.
*/
public resultset gettableprivileges string catalog  string schemapattern
string tablenamepattern  throws sqlexception
preparedstatement s   getpreparedquery
s setstring 1  swapnull catalog
s setstring 2  swapnull schemapattern
s setstring 3  swapnull tablenamepattern
return s executequery
/**
* get a description of a table's optimal set of columns that
* uniquely identifies a row. they are ordered by scope.
*
* <p>each column description has the following columns:
*  <ol>
*	<li><b>scope</b> short => actual scope of result
*      <ul>
*      <li> bestrowtemporary - very temporary, while using row
*      <li> bestrowtransaction - valid for remainder of current transaction
*      <li> bestrowsession - valid for remainder of current session
*      </ul>
*	<li><b>column_name</b> string => column name
*	<li><b>data_type</b> int => sql data type from java.sql.types
*	<li><b>type_name</b> string => data source dependent type name
*	<li><b>column_size</b> int => precision
*	<li><b>buffer_length</b> int => not used
*	<li><b>decimal_digits</b> short	 => scale
*	<li><b>pseudo_column</b> short => is this a pseudo column
*      like an oracle rowid
*      <ul>
*      <li> bestrowunknown - may or may not be pseudo column
*      <li> bestrownotpseudo - is not a pseudo column
*      <li> bestrowpseudo - is a pseudo column
*      </ul>
*  </ol>
*
* @param catalogpattern a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schemapattern a schema name; "" retrieves those without a schema
* @param table a table name
* @param scope the scope of interest; use same values as scope
* @param nullable include columns that are nullable?
* @return resultset - each row is a column description
* @exception sqlexception thrown on failure.
*/
public resultset getbestrowidentifier
string catalogpattern
string schemapattern
string table
int scope
boolean nullable
throws sqlexception
return dogetbestrowid catalogpattern  schemapattern  table
scope  nullable
/**
* get a description of a table's optimal set of columns that
* uniquely identifies a row. they are ordered by scope.
* same as getbestrowidentifier() above, except that the result
* set will conform to odbc specifications.
*/
public resultset getbestrowidentifierforodbc string catalogpattern
string schemapattern  string table  int scope
boolean nullable  throws sqlexception
return dogetbestrowid catalogpattern  schemapattern  table
scope  nullable
/**
* does the actual work for the getbestrowidentifier metadata
* calls.  see getbestrowidentifier() method above for parameter
* descriptions.
* @param queryprefix prefix to be appended to the names of
*	the queries used in this method.  this is used
*	to determine whether the result set should conform to
*	jdbc or odbc specifications.
*/
private resultset dogetbestrowid string catalogpattern
string schemapattern  string table  int scope
boolean nullable  string queryprefix  throws sqlexception
if  table    null
throw util generatecssqlexception
sqlstate table_name_cannot_be_null
int nullableinintform   0
if  nullable
nullableinintform   1
if  catalogpattern    null
catalogpattern
if  schemapattern    null
schemapattern
preparedstatement ps
boolean done
// scope value is bad, return an empty result
if  scope < 0    scope > 2
ps   getpreparedquery
return ps executequery
// see if there is a primary key, use it.
ps   getpreparedquery
ps setstring 1 catalogpattern
ps setstring 2 schemapattern
ps setstring 3 table
resultset rs   ps executequery
done   rs next
string constraintid
if  done
constraintid   rs getstring 1
rs close
ps close
if  done
// this one's it, do the real thing and return it.
// we don't need to check catalog, schema, table name
// or scope again.
ps   getpreparedquery queryprefix
ps setstring 1 constraintid
ps setstring 2 constraintid
// note, primary key columns aren't nullable,
// so we skip the nullok parameter.
return ps executequery
// get the unique constraint with the fewest columns.
ps   getpreparedquery
ps setstring 1 catalogpattern
ps setstring 2 schemapattern
ps setstring 3 table
rs   ps executequery
done   rs next
if  done
constraintid   rs getstring 1
// remind: we need to actually check for null columns
// and toss out constraints with null columns if they aren't
// desired... recode this as a while returning at the
// first match or falling off the end.
rs close
ps close
if  done
// this one's it, do the real thing and return it.
ps   getpreparedquery queryprefix
ps setstring 1 constraintid
ps setstring 2 constraintid
ps setint 3 nullableinintform
return ps executequery
// second-to last try -- unique index with minimal # columns
// (only non null columns if so required)
ps   getpreparedquery
ps setstring 1 catalogpattern
ps setstring 2 schemapattern
ps setstring 3 table
rs   ps executequery
done   rs next
long indexnum   0
if  done
indexnum   rs getlong 1
// remind: we need to actually check for null columns
// and toss out constraints with null columns if they aren't
// desired... recode this as a while returning at the
// first match or falling off the end.
rs close
ps close
if  done
// this one's it, do the real thing and return it.
ps   getpreparedquery queryprefix
ps setlong 1 indexnum
ps setint 2 nullableinintform
return ps executequery
// last try -- just return all columns of the table
// the not null ones if that restriction is upon us.
ps   getpreparedquery queryprefix
ps setstring 1 catalogpattern
ps setstring 2 schemapattern
ps setstring 3 table
ps setint 4 scope
ps setint 5 nullableinintform
return ps executequery
/**
* get a description of a table's columns that are automatically
* updated when any value in a row is updated.  they are
* unordered.
*
* <p>each column description has the following columns:
*  <ol>
*	<li><b>scope</b> short => is not used
*	<li><b>column_name</b> string => column name
*	<li><b>data_type</b> int => sql data type from java.sql.types
*	<li><b>type_name</b> string => data source dependent type name
*	<li><b>column_size</b> int => precision
*	<li><b>buffer_length</b> int => length of column value in bytes
*	<li><b>decimal_digits</b> short	 => scale
*	<li><b>pseudo_column</b> short => is this a pseudo column
*      like an oracle rowid
*      <ul>
*      <li> versioncolumnunknown - may or may not be pseudo column
*      <li> versioncolumnnotpseudo - is not a pseudo column
*      <li> versioncolumnpseudo - is a pseudo column
*      </ul>
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schema a schema name; "" retrieves those without a schema
* @param table a table name
* @return resultset - each row is a column description
* @exception sqlexception thrown on failure.
*/
public resultset getversioncolumns string catalog  string schema
string table  throws sqlexception
return dogetversioncols catalog  schema  table
/**
* get a description of a table's columns that are automatically
* updated when any value in a row is updated.  they are
* unordered.  same as getversioncolumns() above, except that
* the result set will conform to odbc specifications.
*/
public resultset getversioncolumnsforodbc string catalog  string schema
string table  throws sqlexception
return dogetversioncols catalog  schema  table
/**
* does the actual work for the getversioncolumns metadata
* calls.  see getversioncolumns() method above for parameter
* descriptions.
* @param queryname name of the query to execute; is used
*	to determine whether the result set should conform to
*	jdbc or odbc specifications.
*/
private resultset dogetversioncols string catalog  string schema
string table  string queryname  throws sqlexception
if  table    null
throw util generatecssqlexception
sqlstate table_name_cannot_be_null
preparedstatement s   getpreparedquery queryname
s setstring 1  swapnull catalog
s setstring 2  swapnull schema
s setstring 3  table     derby 1484  must match table name as stored
return s executequery
/**
* check if the dictionary is at the same version as the engine. if not,
* then that means stored versions of the jdbc database metadata queries
* may not be compatible with this version of the software.
* this can happen if we are in soft upgrade mode. since in soft upgrade
* mode, we can't change these stored metadata queries in a backward
* incompatible way, engine needs to read the metadata sql from
* metadata.properties or metadata_net.properties file rather than
* rely on system tables.
*
* @return true if we are not in soft upgrade mode
* @throws sqlexception
*/
private boolean notinsoftupgrademode
throws sqlexception
if   getembedconnection   isclosed
throw util nocurrentconnection
boolean notinsoftupgrademode
try
notinsoftupgrademode
getlanguageconnectioncontext   getdatadictionary   checkversion
datadictionary dd_version_current null
catch  throwable t
throw handleexception t
return notinsoftupgrademode
/**
* get a description of a table's primary key columns.  they
* are ordered by column_name.
*
* <p>each primary key column description has the following columns:
*  <ol>
*	<li><b>table_cat</b> string => table catalog (may be null)
*	<li><b>table_schem</b> string => table schema (may be null)
*	<li><b>table_name</b> string => table name
*	<li><b>column_name</b> string => column name
*	<li><b>key_seq</b> short => sequence number within primary key
*	<li><b>pk_name</b> string => primary key name (may be null)
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schema a schema name pattern; "" retrieves those
* without a schema
* @param table a table name
* @return resultset - each row is a primary key column description
* @exception sqlexception thrown on failure.
*/
public resultset getprimarykeys string catalog  string schema
string table  throws sqlexception
preparedstatement s   getpreparedquery
if  table    null
throw util generatecssqlexception
sqlstate table_name_cannot_be_null
s setstring 1  swapnull catalog
s setstring 2  swapnull schema
s setstring 3  table     derby 1484  must match table name as stored
return s executequery
/**
* get a description of the primary key columns that are
* referenced by a table's foreign key columns (the primary keys
* imported by a table).  they are ordered by pktable_cat,
* pktable_schem, pktable_name, and key_seq.
*
* <p>each primary key column description has the following columns:
*  <ol>
*	<li><b>pktable_cat</b> string => primary key table catalog
*      being imported (may be null)
*	<li><b>pktable_schem</b> string => primary key table schema
*      being imported (may be null)
*	<li><b>pktable_name</b> string => primary key table name
*      being imported
*	<li><b>pkcolumn_name</b> string => primary key column name
*      being imported
*	<li><b>fktable_cat</b> string => foreign key table catalog (may be null)
*	<li><b>fktable_schem</b> string => foreign key table schema (may be null)
*	<li><b>fktable_name</b> string => foreign key table name
*	<li><b>fkcolumn_name</b> string => foreign key column name
*	<li><b>key_seq</b> short => sequence number within foreign key
*	<li><b>update_rule</b> short => what happens to
*       foreign key when primary is updated:
*      <ul>
*      <li> importednoaction - do not allow update of primary
*               key if it has been imported
*      <li> importedkeycascade - change imported key to agree
*               with primary key update
*      <li> importedkeysetnull - change imported key to null if
*               its primary key has been updated
*      <li> importedkeysetdefault - change imported key to default values
*               if its primary key has been updated
*      <li> importedkeyrestrict - same as importedkeynoaction
*                                 (for odbc 2.x compatibility)
*      </ul>
*	<li><b>delete_rule</b> short => what happens to
*      the foreign key when primary is deleted.
*      <ul>
*      <li> importedkeynoaction - do not allow delete of primary
*               key if it has been imported
*      <li> importedkeycascade - delete rows that import a deleted key
*      <li> importedkeysetnull - change imported key to null if
*               its primary key has been deleted
*      <li> importedkeyrestrict - same as importedkeynoaction
*                                 (for odbc 2.x compatibility)
*      <li> importedkeysetdefault - change imported key to default if
*               its primary key has been deleted
*      </ul>
*	<li><b>fk_name</b> string => foreign key name (may be null)
*	<li><b>pk_name</b> string => primary key name (may be null)
*	<li><b>deferrability</b> short => can the evaluation of foreign key
*      constraints be deferred until commit
*      <ul>
*      <li> importedkeyinitiallydeferred - see sql92 for definition
*      <li> importedkeyinitiallyimmediate - see sql92 for definition
*      <li> importedkeynotdeferrable - see sql92 for definition
*      </ul>
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schema a schema name pattern; "" retrieves those
* without a schema
* @param table a table name
* @return resultset - each row is a primary key column description
* @see #getexportedkeys
* @exception sqlexception thrown on failure.
*/
public resultset getimportedkeys string catalog  string schema
string table  throws sqlexception
if  table    null
throw util generatecssqlexception
sqlstate table_name_cannot_be_null
preparedstatement s   getpreparedquery
s setstring 1  swapnull catalog
s setstring 2  swapnull schema
s setstring 3  table     derby 1484  must match table name as stored
return s executequery
/**
* get a description of the foreign key columns that reference a
* table's primary key columns (the foreign keys exported by a
* table).  they are ordered by fktable_cat, fktable_schem,
* fktable_name, and key_seq.
*
* <p>each foreign key column description has the following columns:
*  <ol>
*	<li><b>pktable_cat</b> string => primary key table catalog (may be null)
*	<li><b>pktable_schem</b> string => primary key table schema (may be null)
*	<li><b>pktable_name</b> string => primary key table name
*	<li><b>pkcolumn_name</b> string => primary key column name
*	<li><b>fktable_cat</b> string => foreign key table catalog (may be null)
*      being exported (may be null)
*	<li><b>fktable_schem</b> string => foreign key table schema (may be null)
*      being exported (may be null)
*	<li><b>fktable_name</b> string => foreign key table name
*      being exported
*	<li><b>fkcolumn_name</b> string => foreign key column name
*      being exported
*	<li><b>key_seq</b> short => sequence number within foreign key
*	<li><b>update_rule</b> short => what happens to
*       foreign key when primary is updated:
*      <ul>
*      <li> importednoaction - do not allow update of primary
*               key if it has been imported
*      <li> importedkeycascade - change imported key to agree
*               with primary key update
*      <li> importedkeysetnull - change imported key to null if
*               its primary key has been updated
*      <li> importedkeysetdefault - change imported key to default values
*               if its primary key has been updated
*      <li> importedkeyrestrict - same as importedkeynoaction
*                                 (for odbc 2.x compatibility)
*      </ul>
*	<li><b>delete_rule</b> short => what happens to
*      the foreign key when primary is deleted.
*      <ul>
*      <li> importedkeynoaction - do not allow delete of primary
*               key if it has been imported
*      <li> importedkeycascade - delete rows that import a deleted key
*      <li> importedkeysetnull - change imported key to null if
*               its primary key has been deleted
*      <li> importedkeyrestrict - same as importedkeynoaction
*                                 (for odbc 2.x compatibility)
*      <li> importedkeysetdefault - change imported key to default if
*               its primary key has been deleted
*      </ul>
*	<li><b>fk_name</b> string => foreign key name (may be null)
*	<li><b>pk_name</b> string => primary key name (may be null)
*	<li><b>deferrability</b> short => can the evaluation of foreign key
*      constraints be deferred until commit
*      <ul>
*      <li> importedkeyinitiallydeferred - see sql92 for definition
*      <li> importedkeyinitiallyimmediate - see sql92 for definition
*      <li> importedkeynotdeferrable - see sql92 for definition
*      </ul>
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schema a schema name pattern; "" retrieves those
* without a schema
* @param table a table name
* @return resultset - each row is a foreign key column description
* @see #getimportedkeys
* @exception sqlexception thrown on failure.
*/
public resultset getexportedkeys string catalog  string schema
string table  throws sqlexception
if  table    null
throw util generatecssqlexception
sqlstate table_name_cannot_be_null
preparedstatement s   getpreparedquery
s setstring 1  swapnull catalog
s setstring 2  swapnull schema
s setstring 3  table     derby 1484  must match table name as stored
s setstring 4  swapnull null
s setstring 5  swapnull null
s setstring 6  swapnull null
return s executequery
/**
* get a description of the foreign key columns in the foreign key
* table that reference the primary key columns of the primary key
* table (describe how one table imports another's key.) this
* should normally return a single foreign key/primary key pair
* (most tables only import a foreign key from a table once.)  they
* are ordered by fktable_cat, fktable_schem, fktable_name, and
* key_seq.
*
* <p>each foreign key column description has the following columns:
*  <ol>
*	<li><b>pktable_cat</b> string => primary key table catalog (may be null)
*	<li><b>pktable_schem</b> string => primary key table schema (may be null)
*	<li><b>pktable_name</b> string => primary key table name
*	<li><b>pkcolumn_name</b> string => primary key column name
*	<li><b>fktable_cat</b> string => foreign key table catalog (may be null)
*      being exported (may be null)
*	<li><b>fktable_schem</b> string => foreign key table schema (may be null)
*      being exported (may be null)
*	<li><b>fktable_name</b> string => foreign key table name
*      being exported
*	<li><b>fkcolumn_name</b> string => foreign key column name
*      being exported
*	<li><b>key_seq</b> short => sequence number within foreign key
*	<li><b>update_rule</b> short => what happens to
*       foreign key when primary is updated:
*      <ul>
*      <li> importednoaction - do not allow update of primary
*               key if it has been imported
*      <li> importedkeycascade - change imported key to agree
*               with primary key update
*      <li> importedkeysetnull - change imported key to null if
*               its primary key has been updated
*      <li> importedkeysetdefault - change imported key to default values
*               if its primary key has been updated
*      <li> importedkeyrestrict - same as importedkeynoaction
*                                 (for odbc 2.x compatibility)
*      </ul>
*	<li><b>delete_rule</b> short => what happens to
*      the foreign key when primary is deleted.
*      <ul>
*      <li> importedkeynoaction - do not allow delete of primary
*               key if it has been imported
*      <li> importedkeycascade - delete rows that import a deleted key
*      <li> importedkeysetnull - change imported key to null if
*               its primary key has been deleted
*      <li> importedkeyrestrict - same as importedkeynoaction
*                                 (for odbc 2.x compatibility)
*      <li> importedkeysetdefault - change imported key to default if
*               its primary key has been deleted
*      </ul>
*	<li><b>fk_name</b> string => foreign key name (may be null)
*	<li><b>pk_name</b> string => primary key name (may be null)
*	<li><b>deferrability</b> short => can the evaluation of foreign key
*      constraints be deferred until commit
*      <ul>
*      <li> importedkeyinitiallydeferred - see sql92 for definition
*      <li> importedkeyinitiallyimmediate - see sql92 for definition
*      <li> importedkeynotdeferrable - see sql92 for definition
*      </ul>
*  </ol>
*
* @param primarycatalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param primaryschema a schema name pattern; "" retrieves those
* without a schema
* @param primarytable the table name that exports the key
* @param foreigncatalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param foreignschema a schema name pattern; "" retrieves those
* without a schema
* @param foreigntable the table name that imports the key
* @return resultset - each row is a foreign key column description
* @see #getimportedkeys
* @exception sqlexception thrown on failure.
*/
public resultset getcrossreference
string primarycatalog  string primaryschema  string primarytable
string foreigncatalog  string foreignschema  string foreigntable
throws sqlexception
if  primarytable    null    foreigntable    null
throw util generatecssqlexception
sqlstate table_name_cannot_be_null
preparedstatement s   getpreparedquery
s setstring 1  swapnull primarycatalog
s setstring 2  swapnull primaryschema
s setstring 3  primarytable     jdbc spec  must match table name as stored
s setstring 4  swapnull foreigncatalog
s setstring 5  swapnull foreignschema
s setstring 6  foreigntable     jdbc spec  must match table name as stored
return s executequery
/**
* in contrast to the jdbc version of getcrossreference, this
* method allows null values for table names.
*/
public resultset getcrossreferenceforodbc
string primarycatalog  string primaryschema  string primarytable
string foreigncatalog  string foreignschema  string foreigntable
throws sqlexception
preparedstatement s   getpreparedquery
s setstring 1  swapnull primarycatalog
s setstring 2  swapnull primaryschema
s setstring 3  swapnull primarytable
s setstring 4  swapnull foreigncatalog
s setstring 5  swapnull foreignschema
s setstring 6  swapnull foreigntable
return s executequery
/**
* get a description of all the standard sql types supported by
* this database. they are ordered by data_type and then by how
* closely the data type maps to the corresponding jdbc sql type.
*
* <p>each type description has the following columns:
*  <ol>
*	<li><b>type_name</b> string => type name
*	<li><b>data_type</b> int => sql data type from java.sql.types
*	<li><b>precision</b> int => maximum precision
*	<li><b>literal_prefix</b> string => prefix used to quote a literal
*      (may be null)
*	<li><b>literal_suffix</b> string => suffix used to quote a literal
(may be null)
*	<li><b>create_params</b> string => parameters used in creating
*      the type (may be null)
*	<li><b>nullable</b> short => can you use null for this type?
*      <ul>
*      <li> typenonulls - does not allow null values
*      <li> typenullable - allows null values
*      <li> typenullableunknown - nullability unknown
*      </ul>
*	<li><b>case_sensitive</b> boolean=> is it case sensitive?
*	<li><b>searchable</b> short => can you use "where" based on this type:
*      <ul>
*      <li> typeprednone - no support
*      <li> typepredchar - only supported with where .. like
*      <li> typepredbasic - supported except for where .. like
*      <li> typesearchable - supported for all where ..
*      </ul>
*	<li><b>unsigned_attribute</b> boolean => is it unsigned?
*	<li><b>fixed_prec_scale</b> boolean => can it be a money value?
*	<li><b>auto_increment</b> boolean => can it be used for an
*      auto-increment value?
*	<li><b>local_type_name</b> string => localized version of type name
*      (may be null)
*	<li><b>minimum_scale</b> short => minimum scale supported
*	<li><b>maximum_scale</b> short => maximum scale supported
*	<li><b>sql_data_type</b> int => unused
*	<li><b>sql_datetime_sub</b> int => unused
*	<li><b>num_prec_radix</b> int => usually 2 or 10
*  </ol>
*
* @return resultset - each row is a sql type description
* @exception sqlexception thrown on failure.
*/
public resultset gettypeinfo   throws sqlexception
return getsimplequery
/**
* get a description of all the standard sql types supported by
* this database. they are ordered by data_type and then by how
* closely the data type maps to the corresponding jdbc sql type.
* same as gettypeinfo above, except that the result set will
* conform to odbc specifications.
*/
public resultset gettypeinfoforodbc   throws sqlexception
return getsimplequery
/**
* get a description of a table's indices and statistics. they are
* ordered by non_unique, type, index_name, and ordinal_position.
*
* <p>each index column description has the following columns:
*  <ol>
*	<li><b>table_cat</b> string => table catalog (may be null)
*	<li><b>table_schem</b> string => table schema (may be null)
*	<li><b>table_name</b> string => table name
*	<li><b>non_unique</b> boolean => can index values be non-unique?
*      false when type is tableindexstatistic
*	<li><b>index_qualifier</b> string => index catalog (may be null);
*      null when type is tableindexstatistic
*	<li><b>index_name</b> string => index name; null when type is
*      tableindexstatistic
*	<li><b>type</b> short => index type:
*      <ul>
*      <li> tableindexstatistic - this identifies table statistics that are
*           returned in conjuction with a table's index descriptions
*      <li> tableindexclustered - this is a clustered index
*      <li> tableindexhashed - this is a hashed index
*      <li> tableindexother - this is some other style of index
*      </ul>
*	<li><b>ordinal_position</b> short => column sequence number
*      within index; zero when type is tableindexstatistic
*	<li><b>column_name</b> string => column name; null when type is
*      tableindexstatistic
*	<li><b>asc_or_desc</b> string => column sort sequence, "a" => ascending,
*      "d" => descending, may be null if sort sequence is not supported;
*      null when type is tableindexstatistic
*	<li><b>cardinality</b> int => when type is tableindexstatistic, then
*      this is the number of rows in the table; otherwise, it is the
*      number of unique values in the index.
*	<li><b>pages</b> int => when type is  tableindexstatisic then
*      this is the number of pages used for the table, otherwise it
*      is the number of pages used for the current index.
*	<li><b>filter_condition</b> string => filter condition, if any.
*      (may be null)
*  </ol>
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schema a schema name pattern; "" retrieves those without a schema
* @param table a table name
* @param unique when true, return only indices for unique values;
*     when false, return indices regardless of whether unique or not
* @param approximate when true, result is allowed to reflect approximate
*     or out of data values; when false, results are requested to be
*     accurate
* @return resultset - each row is an index column description
* @exception sqlexception thrown on failure.
*/
public resultset getindexinfo string catalog  string schema  string table
boolean unique  boolean approximate
throws sqlexception
return dogetindexinfo catalog  schema  table  unique  approximate
/**
* get a description of a table's indices and statistics. they are
* ordered by non_unique, type, index_name, and ordinal_position.
* same as getindexinfo above, except that the result set will
* conform to odbc specifications.
*/
public resultset getindexinfoforodbc string catalog  string schema  string table
boolean unique  boolean approximate  throws sqlexception
return dogetindexinfo catalog  schema  table  unique  approximate
/**
* does the actual work for the getindexinfo metadata
* calls.  see getindexinfo() method above for parameter
* descriptions.
* @param queryname name of the query to execute; is used
*	to determine whether the result set should conform to
*	jdbc or odbc specifications.
*/
private resultset dogetindexinfo string catalog  string schema  string table
boolean unique  boolean approximate  string queryname
throws sqlexception
if  table    null
throw util generatecssqlexception
sqlstate table_name_cannot_be_null
int approximateinint   0
if  approximate  approximateinint   1
preparedstatement s   getpreparedquery queryname
s setstring 1  swapnull catalog
s setstring 2  swapnull schema
s setstring 3  table     derby 1484  must match table name as stored
s setboolean 4  unique
s setint 5  approximateinint
return s executequery
/////////////////////////////////////////////////////////////////////////
//
//	jdbc 2.0	-	new public methods
//
/////////////////////////////////////////////////////////////////////////
/**
* jdbc 2.0
*
* does the database support the given result set type?
*
* @param type defined in java.sql.resultset
* @return true if so
* @see connection
*/
public boolean supportsresultsettype int type
if   type    resultset type_forward_only
type    resultset type_scroll_insensitive
return true
//we don't support type_scroll_sensitive yet.
return false
/**
* jdbc 2.0
*
* does the database support the concurrency type in combination
* with the given result set type?
*
* @param type defined in java.sql.resultset
* @param concurrency type defined in java.sql.resultset
* @return true if so
* @see connection
*/
public boolean supportsresultsetconcurrency int type  int concurrency
if  type    resultset type_scroll_sensitive
// (type_scroll_sensitive, *)
return false
else
// (forward_only, concur_updatable)
// (forward_only, concur_read_only)
// (type_scroll_insensitive, concur_updatable)
// (type_scroll_insensitive, read_only)
return true
/**
* jdbc 2.0
*
* determine whether a result set's updates are visible.
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if updates are visible for the result set type
*/
public boolean ownupdatesarevisible int type
if  type    resultset type_scroll_insensitive
return true
else
return false
/**
* jdbc 2.0
*
* determine whether a result set's deletes are visible.
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if deletes are visible for the result set type
*/
public boolean owndeletesarevisible int type
if  type    resultset type_scroll_insensitive
return true
else
return false
/**
* jdbc 2.0
*
* determine whether a result set's inserts are visible.
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if inserts are visible for the result set type
*/
public boolean owninsertsarevisible int type
return false
// since derby materializes a forward only resultset incrementally, it is
// possible to see changes made by others and hence following 3 metadata
// calls will return true for forward only resultsets.
/**
* jdbc 2.0
*
* determine whether updates made by others are visible.
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if updates are visible for the result set type
*/
public boolean othersupdatesarevisible int type
if  type    resultset type_forward_only
return true
return false
/**
* jdbc 2.0
*
* determine whether deletes made by others are visible.
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if deletes are visible for the result set type
*/
public boolean othersdeletesarevisible int type
if  type    resultset type_forward_only
return true
return false
/**
* jdbc 2.0
*
* determine whether inserts made by others are visible.
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if inserts are visible for the result set type
*/
public boolean othersinsertsarevisible int type
if  type    resultset type_forward_only
return true
return false
/**
* jdbc 2.0
*
* determine whether or not a visible row update can be detected by
* calling resultset.rowupdated().
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if updates are detected by the resultset type
*/
public boolean updatesaredetected int type
if  type    resultset type_scroll_insensitive
return true
else
// for forward only resultsets, we move to before the next
// row after a update and that is why updatesaredetected
// returns false.
return false
/**
* jdbc 2.0
*
* determine whether or not a visible row delete can be detected by
* calling resultset.rowdeleted().  if deletesaredetected()
* returns false, then deleted rows are removed from the result set.
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if deletes are detected by the resultset type
*/
public boolean deletesaredetected int type
if  type    resultset type_scroll_insensitive
return true
else
// for forward only resultsets, we move to before the next
// row after a delete and that is why deletesaredetected
// returns false
return false
/**
* jdbc 2.0
*
* determine whether or not a visible row insert can be detected
* by calling resultset.rowinserted().
*
* @param type result set type, i.e. resultset.type_xxx
* @return true if inserts are detected by the resultset type
*/
public boolean insertsaredetected int type
return false
/**
* jdbc 2.0
*
* return true if the driver supports batch updates, else return false.
*
*/
public boolean supportsbatchupdates
return true
/**
* jdbc 2.0
*
* get a description of the user-defined types defined in a particular
* schema.  schema specific udts may have type java_object, struct,
* or distinct.
*
* <p>only types matching the catalog, schema, type name and type
* criteria are returned.  they are ordered by data_type, type_schem
* and type_name.  the type name parameter may be a fully qualified
* name.  in this case, the catalog and schemapattern parameters are
* ignored.
*
* <p>each type description has the following columns:
*  <ol>
*	<li><b>type_cat</b> string => the type's catalog (may be null)
*	<li><b>type_schem</b> string => type's schema (may be null)
*	<li><b>type_name</b> string => type name
*  <li><b>class_name</b> string => java class name
*	<li><b>data_type</b> string => type value defined in java.sql.types.
*  one of java_object, struct, or distinct
*	<li><b>remarks</b> string => explanatory comment on the type
*  <li><b>base_type</b> short => type code of the source type of
*  a distinct type or the type that implements the user-generated
*  reference type of the self_referencing_column of a structured
*  type as defined in java.sql.types (<code>null</code> if
*  data_type is not distinct or not struct with
*  reference_generation = user_defined)
*  </ol>
*
* <p><b>note:</b> if the driver does not support udts then an empty
* result set is returned.
*
* @param catalog a catalog name; "" retrieves those without a
* catalog; null means drop catalog name from the selection criteria
* @param schemapattern a schema name pattern; "" retrieves those
* without a schema
* @param typenamepattern a type name pattern; may be a fully qualified
* name
* @param types a list of user-named types to include (java_object,
* struct, or distinct); null returns all types
* @return resultset - each row is a type description
* @exception sqlexception if a database-access error occurs.
*/
public resultset getudts string catalog  string schemapattern
string typenamepattern  int types
throws sqlexception
//we don't have support for catalog names
//we don't have java class types per schema, instead it's per database and hence
//we ignore schemapattern.
//the only type of user-named types we support are java_object
int getclasstypes   0
if  types    null      types length >  1
for  int i 0  i<types length  i
if  types    java sql types java_object
getclasstypes   1
else
getclasstypes   1
preparedstatement s   getpreparedquery
s setint 1  java sql types java_object
s setstring 2  catalog
s setstring 3  schemapattern
s setstring 4  swapnull typenamepattern
s setint 5  getclasstypes
return s executequery
/**
* jdbc 2.0
*
* return the connection that produced this metadata object.
*
*/
public connection getconnection
return getembedconnection   getapplicationconnection
/**
following methods are for the new jdbc 3.0 methods in java.sql.databasemetadata
(see the jdbc 3.0 spec). we have the jdbc 3.0 methods in local20
package, so we don't have to have a new class in local30.
the new jdbc 3.0 methods don't make use of any new jdbc3.0 classes and
so this will work fine in jdbc2.0 configuration.
*/
/////////////////////////////////////////////////////////////////////////
//
//	jdbc 3.0	-	new public methods
//
/////////////////////////////////////////////////////////////////////////
/**
* jdbc 3.0
*
* retrieves whether this database supports statement pooling.
*
* @return true if statement pooling is supported; false otherwise
*/
public boolean supportsstatementpooling
return false
/**
* jdbc 3.0
*
* retrieves whether this database supports savepoints.
*
* @return true if savepoints are supported; false otherwise
*/
public boolean supportssavepoints
return true
/**
* jdbc 3.0
*
* retrieves whether this database supports named parameters to callable statements.
*
* @return true if named parameters are supported; false otherwise
*/
public boolean supportsnamedparameters
return false
/**
* jdbc 3.0
*
* retrieves whether it is possible to have multiple resultset objects returned from a
* callablestatement object simultaneously.
*
* @return true if a callablestatement object can return multiple resultset objects
* simultaneously; false otherwise
*/
public boolean supportsmultipleopenresults
return true
/**
* jdbc 3.0
*
* retrieves whether auto-generated keys can be retrieved after a statement
* has been executed.
*
* @return true if auto-generated keys can be retrieved after a statement has
* executed; false otherwise
*/
public boolean supportsgetgeneratedkeys
/*
* currently reverting the returned value to false until there
* is more support for autogenerated keys in derby.
* (such as support for specifying the returned columns for
* the autogenerated key)
*/
return false
/**
* jdbc 3.0
*
* retrieves whether this database supports the given result set holdability.
*
* @param holdability - one of the following constants:
* resultset.hold_cursors_over_commit or resultset.close_cursors_at_commit
* @return true if so; false otherwise
* executed; false otherwise
*/
public boolean supportsresultsetholdability int holdability
return true
/**
* jdbc 3.0
*
* retrieves the default holdability of this resultset object.
*
* @return the default holdability which is resultset.hold_cursors_over_commit
*/
public int getresultsetholdability
return resultset hold_cursors_over_commit
/**
* jdbc 3.0
*
* retrieves the major version number of the underlying database.
*
* @return the underlying database's major version
*/
public int getdatabasemajorversion
productversionholder pvh   monitor getmonitor   getengineversion
if  pvh    null
return  1
return pvh getmajorversion
/**
* jdbc 3.0
*
* retrieves the minor version number of the underlying database.
*
* @return the underlying database's minor version
*/
public int getdatabaseminorversion
productversionholder pvh   monitor getmonitor   getengineversion
if  pvh    null
return  1
return pvh getminorversion
/**
* jdbc 3.0
*
* retrieves the major jdbc version number for this driver.
*
* @return jdbc version major number
*/
public int getjdbcmajorversion
return 3
/**
* jdbc 3.0
*
* retrieves the minor jdbc version number for this driver.
*
* @return jdbc version minor number
*/
public int getjdbcminorversion
return 0
/**
* jdbc 3.0
*
* indicates whether the sqlstates returned by sqlexception.getsqlstate
* is x/open (now known as open group) sql cli or sql99.
*
* @return the type of sqlstates, one of: sqlstatexopen or sqlstatesql99
*/
public int getsqlstatetype
return sqlstatesql99
/**
* jdbc 3.0
*
* indicates whether updates made to a lob are made on a copy or
* directly to the lob.
* <p>
* for the embedded driver, all updates will be made to a copy.
* hence, this call will always return <code>true</code>
*
* @return true if updates are made to a copy of the lob; false if
* updates are made directly to the lob
* @exception sqlexception feature not implemented for now.
*/
public boolean locatorsupdatecopy
throws sqlexception
return true
/**
* jdbc 3.0
*
* retrieves a description of the user-defined type (udt) hierarchies defined
* in a particular schema in this database. only the immediate super type/ sub type
* relationship is modeled.
*
* @param catalog - a catalog name; "" retrieves those without a catalog;
* null means drop catalog name from the selection criteria
* @param schemapattern - a schema name pattern; "" retrieves those without a schema
* @param typenamepattern - a udt name pattern; may be a fully-qualified name
* @return a resultset object in which a row gives information about the designated udt
* @exception sqlexception feature not implemented for now.
*/
public resultset getsupertypes string catalog  string schemapattern  string typenamepattern
throws sqlexception
return getsimplequery
/**
* jdbc 3.0
*
* retrieves a description of the table hierarchies defined in a particular
* schema in this database.
*
* @param catalog - a catalog name; "" retrieves those without a catalog;
* null means drop catalog name from the selection criteria
* @param schemapattern - a schema name pattern; "" retrieves those without a schema
* @param typenamepattern - a udt name pattern; may be a fully-qualified name
* @return a resultset object in which each row is a type description
* @exception sqlexception if a database access error occurs
*/
public resultset getsupertables string catalog  string schemapattern  string typenamepattern
throws sqlexception
return getsimplequery
/**
* jdbc 3.0
*
* retrieves a description of the given attribute of the given type for a
* user-defined type (udt) that is available in the given schema and catalog.
*
* @param catalog - a catalog name; must match the catalog name as it is
* stored in the database; "" retrieves those without a catalog; null means that
* the catalog name should not be used to narrow the search
* @param schemapattern - a schema name pattern; "" retrieves those without a schema;
* null means that the schema name should not be used to narrow the search
* @param typenamepattern - a type name pattern; must match the type name as it is
* stored in the database
* @param attributenamepattern - an attribute name pattern; must match the attribute
* name as it is declared in the database
* @return a resultset object in which each row is a type description
* @exception sqlexception if a database access error occurs.
*/
public resultset getattributes string catalog  string schemapattern
string typenamepattern  string attributenamepattern
throws sqlexception
return getsimplequery
/////////////////////////////////////////////////////////////////////////
//
//  jdbc 4.0 - new public methods
//
/////////////////////////////////////////////////////////////////////////
/**
* jdbc 4.0
*
* <p>returns a list of the client info properties supported by
* the driver. the result set contains the following columns:
*
* <p>
* <ol>
*  <li>name string=&gt; the name of the client info property.</li>
*  <li>max_len int=&gt; the maximum length of the value for the
*      property.</li>
*  <li>default_value string=&gt; the default value of the property.</li>
*  <li>description string=&gt; a description of the property.</li>
* </ol>
*
* <p>the <code>resultset</code> is sorted by the name column.
*
* @return a <code>resultset</code> object; each row is a
* supported client info property
* @exception sqlexception if an error occurs
*/
public resultset getclientinfoproperties   throws sqlexception
return getsimplequery
/**
* jdbc 4.0
*
* <p>get the schema names available in this database. the results
* are ordered by schema name.
*
* <p>the schema columns are:
*  <ol>
*  <li><strong>table_schem</strong> string =&gt; schema name</li>
*  <li><strong>table_catalog</strong> string =&gt; catalog name
*  (may be <code>null</code>)</li>
*  </ol>
*
* @param catalog catalog name used to narrow down the search; ""
* means no catalog, <code>null</code> means any catalog
* @param schemapattern schema name used to narrow down the
* search, <code>null</code> means schema name should not be used
* to narrow down search
* @return a <code>resultset</code> object in which each row is a
* schema description
* @exception sqlexception if a database error occurs
*/
public resultset getschemas string catalog  string schemapattern
throws sqlexception
preparedstatement s   getpreparedquery
s setstring 1  swapnull catalog
s setstring 2  swapnull schemapattern
return s executequery
//////////////////////////////////////////////////////////////
//
// misc
//
//////////////////////////////////////////////////////////////
/**
* get metadata that the client driver will cache. the metadata is
* fetched using sysibm.metadata (found in metadata_net.properties).
*
* @return the result set returned by sysibm.metadata
* @exception sqlexception if a database error occurs
*/
public resultset getclientcachedmetadata   throws sqlexception
return getsimplequery    true
/*
* utility helper routines:
*/
/**
* execute a query in metadata.properties (or sps in the sys
* schema) or metadata_net.properties (or sps in the sysibm
* schema).
*
* @param namekey the name of the query
* @param net if <code>true</code>, execute a query in
* metadata_net.properties; otherwise, execute a query in
* metadata.properties
* @return a <code>resultset</code> value
* @exception sqlexception if a database error occurs
*/
private resultset getsimplequery string namekey  boolean net
throws sqlexception
preparedstatement ps   getpreparedquery namekey  net
if  ps    null
return null
return ps executequery
/**
* execute a query in metadata.properties, or an sps in the sys
* schema.
*
* @param namekey the name of the query
* @return a <code>resultset</code> value
* @exception sqlexception if a database error occurs
*/
protected resultset getsimplequery string namekey  throws sqlexception
return getsimplequery namekey  false
/**
* get a stored prepared statement from the system tables.
*
* @param namekey the name of the query
* @param net if <code>true</code>, find query in sysibm schema;
* otherwise, find query in sys schema
* @return a <code>preparedstatement</code> value
* @exception sqlexception if a database error occurs
*/
private preparedstatement getpreparedqueryusingsystemtables string namekey
boolean net
throws sqlexception
synchronized  getconnectionsynchronization
setupcontextstack
preparedstatement ps   null
try
string querytext
getquerydescriptions net  getproperty namekey
if  querytext    null
throw util notimplemented namekey
ps   preparesps namekey  querytext  net
catch  throwable t
throw handleexception t
finally
restorecontextstack
return ps
/**
* either get the prepared query for the metadata call from the
* system tables, or from the metadata.properties or
* metadata_net.properties file.
* in soft upgrade mode, the queries stored in the system tables
* might not be upto date with the derby engine release because
* system tables can't be modified in backward incompatible way in
* soft upgrade mode. because of this, if the database is in
* soft upgrade mode, get the queries from metadata.properties
* file rather than from the system tables.
*
* getting queries from metadata(_net).properties might cause problems
* if system catalogs have been changed between versions either by
* addition of columns or have new catalogs. to continue
* to support soft upgrade from older versions of database, find
* query that most closely matches database dictionary version.
*
* @param queryname name of the metadata query for which we need
* a prepared statement
* @param net if <code>true</code>, use metadata_net.properties
* instead of metadata.properties
* @return preparedstatement
* @exception sqlexception if a database error occurs
*/
private preparedstatement getpreparedquery string queryname
boolean net
throws sqlexception
preparedstatement s
//we can safely goto system table since we are not in soft upgrade
//mode and hence metadata sql in system tables are uptodate
//with this derby release. we also need to be writable so
// that we can update sps statements (derby-3546)
if  notinsoftupgrademode       isreadonly
s   getpreparedqueryusingsystemtables queryname  net
else
try
//can't use stored prepared statements because we are in soft upgrade
//mode or are read only, and hence need to get metadata sql from
//metadata.properties file or metadata_net.properties
string querytext   getqueryfromdescription queryname  net
s   getembedconnection   preparemetadatastatement querytext
catch  throwable t
throw handleexception t
return s
/**
* get a prepared query from system tables or metadata.properties.
*
* @param queryname name of the query
* @return a <code>preparedstatement</code> value
* @exception sqlexception if a database error occurs
*/
protected preparedstatement getpreparedquery string queryname
throws sqlexception
return getpreparedquery queryname  false
/**
* given a queryname, find closest match in querydescriptions. this method
* should be called in soft-upgrade mode only, where current software version
* doesn't match dictionary version. for these cases, there may be
* multiple entries in querydescriptions for given queryname. find a
* version of the query that closely matches dictionary version.
*
* this method is currently coded to handle two specific queries,
* getcolumnprivileges and gettableprivileges. derby databases that are 10.1
* or earlier will not have new system tables added for 10.2 for privileges.
*
* it should be possible to automate finding closest match by generating
* all major_minor versions between software version and dictionary version
* and try each one from dictionary version to current version. since only
* needed for two queries, overhead may not be worth it yet.
*
* @param queryname name of the query
* @param net if <code>true</code>, get the query from
* metadata_net.properties instead of metadata.properties
* @return the query text
* @exception standardexception if an error occurs
*/
private string getqueryfromdescription string queryname  boolean net
throws standardexception
datadictionary dd   getlanguageconnectioncontext   getdatadictionary
// if dictionary version is below 10.2, special case
// getcolumnprivileges and gettableprivileges since new system tables
// for privileges wouldn't be present.
if   dd checkversion datadictionary dd_version_derby_10_2  null
if  queryname equals
queryname
if  queryname equals
queryname
return getquerydescriptions net  getproperty queryname
/*
** given a sps name and a query text it returns a
** java.sql.preparedstatement for the sps. if the sps
** doeesn't exist is created.
**
*/
private preparedstatement preparesps string	spsname
string	spstext
boolean net
throws standardexception  sqlexception
languageconnectioncontext lcc   getlanguageconnectioncontext
/* we now need to do this in sub transaction because we could possibly recompile sps
* later, and the recompile is in a sub transaction, and will update the sysstatements
* entry.  don't want to block.
*/
lcc beginnestedtransaction true
datadictionary dd   getlanguageconnectioncontext   getdatadictionary
spsdescriptor spsd   dd getspsdescriptor
spsname
net ? dd getsysibmschemadescriptor
dd getsystemschemadescriptor
lcc commitnestedtransaction
if  spsd    null
throw util notimplemented spsname
/* manish:
there should be a nicer way of getting a
java.sql.preparedstatement from an sps descriptor!
*/
/*
** it is unnecessarily expensive to get the
** the statement, and then send an execute
** statement, but we have no (easy) way of turning
** the statement into a java.sql.preparedstatement.
*/
string querytext
net ?
return getembedconnection   preparemetadatastatement querytext
static final protected string swapnull string s
return  s    null ?     s
/**
*	gets the constant action factory
*
*	@return	the constant action factory.
*
* @exception standardexception		thrown on failur4e
*/
private genericconstantactionfactory	getgenericconstantactionfactory
throws standardexception
if   constantactionfactory    null
genericexecutionfactory	execfactory    genericexecutionfactory
getlanguageconnectioncontext   getlanguageconnectionfactory   getexecutionfactory
constantactionfactory   execfactory getconstantactionfactory
return	constantactionfactory
/**
*	gets the languageconnectioncontext for this connection.
*
*	@return	the lcc for this connection
*
*/
private	languageconnectioncontext	getlanguageconnectioncontext
return getembedconnection   getlanguageconnection
/*
** priv block code, moved out of the old java2 version.
*/
/**
* loads the query descriptions from metadata.properties and
* metadata_net.properties into <code>querydescriptions</code> and
* <code>querydescriptions_net</code>.
*/
private void loadquerydescriptions
java security accesscontroller doprivileged this
/**
* performs a privileged action. reads the query descriptions.
*
* @return <code>null</code>
*/
public final object run
// security permission - ip3
pbloadquerydescriptions
return null