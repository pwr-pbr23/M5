/*
derby - class org.apache.derby.impl.services.locks.concurrentlockset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services locks
import org apache derby iapi services locks compatibilityspace
import org apache derby iapi services locks latch
import org apache derby iapi services locks lockable
import org apache derby iapi services locks c_lockfactory
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services diag diagnosticutil
import org apache derby iapi reference property
import org apache derby iapi reference sqlstate
import java util concurrent atomic atomicinteger
import java util concurrent locks condition
import java util concurrent locks reentrantlock
import java util concurrent concurrenthashmap
import java util arraylist
import java util hashmap
import java util enumeration
import java util map
/**
a concurrentlockset is a complete lock table which maps
<code>lockable</code>s to <code>lockcontrol</code> objects.
<p>
a lockcontrol contains information about the locks held on a lockable.
<br>
mt - mutable : all public methods of this class, except addwaiters, are
thread safe. addwaiters can only be called from the thread which performs
deadlock detection. only one thread can perform deadlock detection at a
time.
<br>
the class creates activelock and lockcontrol objects.
lockcontrol objects are never passed out of this class, all the methods of
lockcontrol are called while holding a reentrantlock associated with the
lockable controlled by the lockcontrol, thus providing the
single threading that lockcontrol required.
methods of lockables are only called by this class or lockcontrol, and
always while holding the corresponding reentrantlock, thus providing the
single threading that lockable requires.
@see lockcontrol
*/
final class concurrentlockset implements locktable
/*
** fields
*/
private final abstractpool factory
/** hash table which maps <code>lockable</code> objects to
* <code>lock</code>s. */
private final concurrenthashmap<lockable  entry> locks
/**
* list containing all entries seen by the last call to
* <code>addwaiters()</code>. makes it possible for the deadlock detection
* thread to lock all the entries it has visited until it has
* finished. this prevents false deadlocks from being reported (because all
* observed waiters must still be waiting when the deadlock detection has
* completed).
*/
private arraylist<entry> seenbydeadlockdetection
/**
timeout for deadlocks, in ms.
<br>
mt - immutable
*/
private int deadlocktimeout   property deadlock_timeout_default   1000
private int waittimeout   property wait_timeout_default   1000
//exclude-start-lockdiag-
// this varible is set and get without synchronization.
// only one thread should be setting it at one time.
private boolean deadlocktrace
//exclude-end-lockdiag-
// the number of waiters for locks
private final atomicinteger blockcount
/*
** constructor
*/
concurrentlockset abstractpool factory
this factory   factory
blockcount   new atomicinteger
locks   new concurrenthashmap<lockable  entry>
/**
* class representing an entry in the lock table.
*/
private static final class entry
/** the lock control. */
control control
/**
* mutex used to ensure single-threaded access to the lockcontrols. to
* avoid java deadlocks, no thread should ever hold the mutex of more
* than one entry. excepted from this requirement is a thread which
* performs deadlock detection. during deadlock detection, a thread
* might hold several mutexes, but it is not allowed to hold any mutex
* when entering the deadlock detection. only one thread is allowed to
* perform deadlock detection at a time.
*/
private final reentrantlock mutex   new reentrantlock
/**
* condition variable which prevents calls to <code>lock()</code> from
* locking the entry. if it is not <code>null</code>, only the thread
* performing deadlock detection may lock the entry (by calling
* <code>lockfordeadlockdetection()</code>).
*/
private condition deadlockdetection
/**
* lock the entry, ensuring exclusive access to the contained
* <code>control</code> object. the call will block until the entry can
* be locked. if the entry is unlocked and
* <code>deadlockdetection</code> is not <code>null</code>, the entry
* belongs to a thread which waits for deadlock detection to be
* initiated, and the call will block until that thread has finished
* its deadlock detection.
*/
void lock
if  sanitymanager debug
sanitymanager assert  mutex isheldbycurrentthread
mutex lock
while  deadlockdetection    null
deadlockdetection awaituninterruptibly
/**
* unlock the entry, allowing other threads to lock and access the
* contained <code>control</code> object.
*/
void unlock
mutex unlock
/**
* lock the entry while performing deadlock detection. this method will
* lock the entry even when <code>deadlockdetection</code> is not
* <code>null</code>. if <code>deadlockdetection</code> is not
* <code>null</code>, we know the entry and its <code>control</code>
* will not be accessed by others until we have finished the deadlock
* detection, so it's ok for us to access it.
*
*/
void lockfordeadlockdetection
if  sanitymanager debug
sanitymanager assert  mutex isheldbycurrentthread
mutex lock
/**
* notify that the lock request that is currently accessing the entry
* will be entering deadlock detection. unlock the entry to allow the
* current thread or other threads to lock the entry for deadlock
* detection, but set the condition variable to prevent regular locking
* of the entry.
*/
void enterdeadlockdetection
deadlockdetection   mutex newcondition
mutex unlock
/**
* notify that the deadlock detection triggered by the current thread
* has finished. re-lock the entry and notify any waiters that the
* deadlock detection has completed.
*/
void exitdeadlockdetection
if  sanitymanager debug
sanitymanager assert  mutex isheldbycurrentthread
mutex lock
deadlockdetection signalall
deadlockdetection   null
/**
* get an entry from the lock table. if no entry exists for the
* <code>lockable</code>, insert an entry. the returned entry will be
* locked and is guaranteed to still be present in the table.
*
* @param ref the <code>lockable</code> whose entry to return
* @return the entry for the <code>lockable</code>, locked for exclusive
* access
*/
private entry getentry lockable ref
entry e   locks get ref
while  true
if  e    null
e lock
if  e control    null
// entry is found and in use, return it
return e
// entry is empty, hence it was removed from the table after we
// retrieved it. try to reuse it later.
else
// no entry found, create a new one
e   new entry
e lock
// reinsert empty entry, or insert the new entry
entry current   locks putifabsent ref  e
if  current    null
// successfully (re-)inserted entry, return it
return e
// someone beat us, unlock the old entry and retry with the entry
// they inserted
e unlock
e   current
/**
* check whether there is a deadlock. make sure that only one thread enters
* deadlock detection at a time.
*
* @param entry the entry in the lock table for the lock request that
* triggered deadlock detection
* @param waitinglock the waiting lock
* @param wakeupreason the reason for waking up the waiter
* @return an object describing the deadlock
*/
private object checkdeadlock entry entry  activelock waitinglock
byte wakeupreason
lockcontrol control    lockcontrol  entry control
// make sure that the entry is not blocking other threads performing
// deadlock detection since we have to wait for them to finish
entry enterdeadlockdetection
synchronized  deadlock class
try
return deadlock look factory  this  control  waitinglock
wakeupreason
finally
// unlock all entries we visited
for  entry e   seenbydeadlockdetection
e unlock
seenbydeadlockdetection   null
// re-lock the entry
entry exitdeadlockdetection
/*
** public methods
*/
/**
*	lock an object within a specific compatibility space.
*
*	@param	compatibilityspace compatibility space.
*	@param	ref lockable reference.
*	@param	qualifier qualifier.
*	@param	timeout timeout in milli-seconds
*
*	@return	object that represents the lock.
*
*	@exception	standardexception standard derby policy.
*/
public lock lockobject compatibilityspace compatibilityspace  lockable ref
object qualifier  int timeout
throws standardexception
if  sanitymanager debug
if  sanitymanager debug_on
if  locks size   > 1000
system out println
locks size
lockcontrol control
lock lockitem
string  lockdebug   null
entry entry   getentry ref
try
control gc   entry control
if  gc    null
// object is not locked, can be granted
lock gl   new lock compatibilityspace  ref  qualifier
gl grant
entry control   gl
return gl
control   gc getlockcontrol
if  control    gc
entry control   control
if  sanitymanager debug
sanitymanager assert ref equals control getlockable
// assert item is in the list
sanitymanager assert
locks get control getlockable    control    control
lockitem   control addlock this  compatibilityspace  qualifier
if  lockitem getcount      0
return lockitem
if  abstractpool nolockwait timeout  compatibilityspace
// remove all trace of lock
control giveupwait lockitem  this
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager showtrace new throwable
// the following dumps the lock table as it
// exists at the time a timeout is about to
// cause a deadlock exception to be thrown.
lockdebug
diagnosticutil todiagstring lockitem
// we cannot hold a lock on an entry while calling
// todebugstring() since it will lock other entries in
// the lock table. holding the lock could cause a
// deadlock.
entry unlock
try
lockdebug    todebugstring
finally
// re-lock the entry so that the outer finally
// clause doesn't fail.
entry lock
return null
finally
entry unlock
boolean deadlockwait   false
int actualtimeout
if  timeout    c_lockfactory wait_forever
// always check for deadlocks as there should not be any
deadlockwait   true
if   actualtimeout   deadlocktimeout     c_lockfactory wait_forever
actualtimeout   property deadlock_timeout_default   1000
else
if  timeout    c_lockfactory timed_wait
timeout   actualtimeout   waittimeout
else
actualtimeout   timeout
// five posible cases
// i)   timeout -1, deadlock -1         ->
//          just wait forever, no deadlock check
// ii)  timeout >= 0, deadlock -1       ->
//          just wait for timeout, no deadlock check
// iii) timeout -1, deadlock >= 0       ->
//          wait for deadlock, then deadlock check,
//          then infinite timeout
// iv)  timeout >=0, deadlock < timeout ->
//          wait for deadlock, then deadlock check,
//          then wait for (timeout - deadlock)
// v)   timeout >=0, deadlock >= timeout ->
//          just wait for timeout, no deadlock check
if  deadlocktimeout >  0
if  actualtimeout < 0
// infinite wait but perform a deadlock check first
deadlockwait   true
actualtimeout   deadlocktimeout
else if  deadlocktimeout < actualtimeout
// deadlock wait followed by a timeout wait
deadlockwait   true
actualtimeout   deadlocktimeout
// leave timeout as the remaining time
timeout    deadlocktimeout
activelock waitinglock    activelock  lockitem
lockitem   null
int earlywakeupcount   0
long startwaittime   0
forever 	for
byte wakeupreason   waitinglock waitforgrant actualtimeout
activelock nextwaitinglock   null
object deadlockdata   null
try
boolean willquitwait
enumeration timeoutlocktable   null
long currenttime   0
entry lock
try
if  control isgrantable
control firstwaiter      waitinglock
compatibilityspace
qualifier
// yes, we are granted, put us on the granted queue.
control grant waitinglock
// remove from the waiting queue & get next waiter
nextwaitinglock
control getnextwaiter waitinglock  true  this
return waitinglock
// try again later
waitinglock clearpotentiallygranted
willquitwait
wakeupreason    constants waiting_lock_grant
if    wakeupreason    constants waiting_lock_in_wait
deadlockwait
wakeupreason    constants waiting_lock_deadlock
// check for a deadlock, even if we were woken up
// because we were selected as a victim we still
// check because the situation may have changed.
deadlockdata
checkdeadlock entry  waitinglock  wakeupreason
if  deadlockdata    null
// we don't have a deadlock
deadlockwait   false
actualtimeout   timeout
startwaittime   0
willquitwait   false
else
willquitwait   true
nextwaitinglock
control getnextwaiter
waitinglock  willquitwait  this
// if we were not woken by another then we have
// timed out. either deadlock out or timeout
if  sanitymanager debug
sanitymanager debug_on
willquitwait
// generate the first part of the debug message
// while holding the lock on entry, so that we have
// exclusive access to waitinglock. wait until the
// entry has been unlocked before appending the
// contents of the lock table (to avoid deadlocks).
lockdebug
diagnosticutil todiagstring waitinglock
finally
entry unlock
// need to do this outside of the synchronized block as the
// message text building (timeouts and deadlocks) may
// involve getting locks to look up table names from
// identifiers.
if  willquitwait
if  deadlocktrace     deadlockdata    null
// if ending lock request due to lock timeout
// want a copy of the locktable and the time,
// in case of deadlock deadlockdata has the
// info we need.
currenttime   system currenttimemillis
timeoutlocktable
factory makevirtuallocktable
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager showtrace new throwable
// the following dumps the lock table as it
// exists at the time a timeout is about to
// cause a deadlock exception to be thrown.
lockdebug    todebugstring
if  lockdebug    null
string type
deadlockdata    null  ?
sanitymanager debug_print
type
type
lockdebug
if  deadlockdata    null
// ending wait because of lock timeout.
if  deadlocktrace
// turn on derby.locks.deadlocktrace to build
// the locktable.
throw timeout buildexception
waitinglock  timeoutlocktable  currenttime
else
standardexception se
standardexception newexception
sqlstate lock_timeout
throw se
else
// ending wait because of lock deadlock.
throw deadlock buildexception
factory  deadlockdata
finally
if  nextwaitinglock    null
nextwaitinglock wakeup constants waiting_lock_grant
nextwaitinglock   null
if  actualtimeout    c_lockfactory wait_forever
if  wakeupreason    constants waiting_lock_in_wait
earlywakeupcount
if  earlywakeupcount > 5
long now   system currenttimemillis
if  startwaittime    0
long sleeptime   now   startwaittime
actualtimeout    sleeptime
startwaittime   now
for
/**
unlock an object, previously locked by lockobject().
if unlockcount is not zero then the lock will be unlocked
that many times, otherwise the unlock count is taken from
item.
*/
public void unlock latch item  int unlockcount
// assume lockentry is there
entry entry   locks get item getlockable
entry lock
try
unlock entry  item  unlockcount
finally
entry unlock
/**
* unlock an object, previously locked by lockobject().
*
* @param entry the entry in which the lock is contained (the current
* thread must have locked the entry)
* @param item the item to unlock
* @param unlockcount the number of times to unlock the item (if zero, take
* the unlock count from item)
*/
private void unlock entry entry  latch item  int unlockcount
if  sanitymanager debug
sanitymanager assert entry mutex isheldbycurrentthread
if  sanitymanager debug_on constants lock_trace
/*
** i don't like checking the trace flag twice, but sanitymanager
** doesn't provide a way to get to the debug trace stream
** directly.
*/
sanitymanager debug
constants lock_trace
diagnosticutil todiagstring item
boolean trygrant   false
activelock nextgrant   null
control control   entry control
if  sanitymanager debug
// only valid lock's expected
if  item getlockable      null
sanitymanager throwassert
unlockcount
diagnosticutil todiagstring item
// only valid lock's expected
if  control    null
sanitymanager throwassert
unlockcount
diagnosticutil todiagstring item
sanitymanager assert
locks get control getlockable    control    control
if   unlockcount    0      unlockcount > item getcount
sanitymanager throwassert     unlockcount
item getcount         item
trygrant   control unlock item  unlockcount
item   null
boolean maybeempty   true
if  trygrant
nextgrant   control firstwaiter
if  nextgrant    null
maybeempty   false
if   nextgrant setpotentiallygranted
nextgrant   null
if  maybeempty
if  control isempty
// no-one granted, no-one waiting, remove lock control
locks remove control getlockable
entry control   null
return
if  trygrant     nextgrant    null
nextgrant wakeup constants waiting_lock_grant
/**
* unlock an object once if it is present in the specified group. also
* remove the object from the group.
*
* @param space the compatibility space
* @param ref a reference to the locked object
* @param qualifier qualifier of the lock
* @param group a map representing the locks in a group
* @return the corresponding lock in the group map, or <code>null</code> if
* the object was not unlocked
*/
public lock unlockreference compatibilityspace space  lockable ref
object qualifier  map group
entry entry   locks get ref
if  entry    null
return null
entry lock
try
control control   entry control
if  control    null
return null
lock setlock   control getlock space  qualifier
if  setlock    null
return null
lock lockingroup    lock  group remove setlock
if  lockingroup    null
unlock entry  lockingroup  1
return lockingroup
finally
entry unlock
/**
* {@inheritdoc}
*/
public boolean zerodurationlockobject
compatibilityspace space  lockable ref  object qualifier  int timeout
throws standardexception
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
space  null  ref  qualifier  timeout
if  sanitymanager debug_on constants lock_stack_trace
// the following will print the stack trace of the lock
// request to the log.
throwable t   new throwable
java io printwriter istream
sanitymanager get_debug_stream
istream println
t printstacktrace istream
// very fast zerodurationlockobject() for unlocked objects.
// if no entry exists in the lock manager for this reference
// then it must be unlocked.
// if the object is locked then we perform a grantable
// check, skipping over any waiters.
// if the caller wants to wait and the lock cannot
// be granted then we do the slow join the queue and
// release the lock method.
entry entry   locks get ref
if  entry    null
return true
entry lock
try
control control   entry control
if  control    null
return true
// if we are grantable, ignoring waiting locks then
// we can also grant this request now, as skipping
// over the waiters won't block them as we release
// the lock rightway.
if  control isgrantable true  space  qualifier
return true
// can't be granted and are not willing to wait.
if  abstractpool nolockwait timeout  space
return false
finally
entry unlock
lock lock   lockobject space  ref  qualifier  timeout
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
space  null  ref  qualifier  timeout
// and simply unlock it once
unlock lock  1
return true
/**
* set the deadlock timeout.
*
* @param timeout deadlock timeout in milliseconds
*/
public void setdeadlocktimeout int timeout
deadlocktimeout   timeout
/**
* set the wait timeout.
*
* @param timeout wait timeout in milliseconds
*/
public void setwaittimeout int timeout
waittimeout   timeout
/*
** non public methods
*/
//exclude-start-lockdiag-
public void setdeadlocktrace boolean val
// set this without synchronization
deadlocktrace   val
//exclude-end-lockdiag-
private string todebugstring
if  sanitymanager debug
string str   new string
int i   0
for  entry entry   locks values
entry lock
try
str        i
diagnosticutil todiagstring entry control
finally
entry unlock
return str
else
return null
/**
* add all waiters in this lock table to a <code>map</code> object.
* this method can only be called by the thread that is currently
* performing deadlock detection. all entries that are visited in the lock
* table will be locked when this method returns. the entries that have
* been seen and locked will be unlocked after the deadlock detection has
* finished.
*/
public void addwaiters map waiters
seenbydeadlockdetection   new arraylist<entry> locks size
for  entry entry   locks values
seenbydeadlockdetection add entry
entry lockfordeadlockdetection
if  entry control    null
entry control addwaiters waiters
//exclude-start-lockdiag-
/**
* make a shallow clone of myself and my lock controls
*/
public map<lockable  control> shallowclone
hashmap<lockable  control> clone   new hashmap<lockable  control>
for  entry entry   locks values
entry lock
try
control control   entry control
if  control    null
clone put control getlockable    control shallowclone
finally
entry unlock
return clone
//exclude-end-lockdiag-
/**
* increase blockcount by one.
*/
public void onemorewaiter
blockcount incrementandget
/**
* decrease blockcount by one.
*/
public void onelesswaiter
blockcount decrementandget
/**
* check whether anyone is blocked.
* @return <code>true</code> if someone is blocked, <code>false</code>
* otherwise
*/
public boolean anyoneblocked
int blocked   blockcount get
if  sanitymanager debug
sanitymanager assert
blocked >  0
return blocked    0