/*
derby - class org.apache.derby.impl.sql.execute.basicsortobserver
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi store access sortobserver
import org apache derby iapi services io storable
import org apache derby iapi types cloneableobject
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql execute execrow
import org apache derby iapi types datavaluedescriptor
import java util vector
/**
* this is the most basic sort observer.  it
* handles distinct sorts and non-distinct sorts.
*
*/
public class basicsortobserver implements sortobserver
{
protected boolean 	doclone
protected boolean	distinct
private	  boolean	reusewrappers
private	  execrow	execrow
private	  vector	vector
/**
* simple constructor
*
* @param doclone if true, then rows that are retained
*		by the sorter will be cloned.  this is needed
*		if language is reusing row wrappers.
*
* @param distinct	if true, toss out duplicates.
*		otherwise, retain them.
*
* @param execrow	execrow to use as source of clone for store.
*
* @param reusewrappers	whether or not we can reuse the wrappers
*/
public basicsortobserver boolean doclone  boolean distinct  execrow	execrow  boolean reusewrappers
{
this doclone   doclone
this distinct   distinct
this execrow   execrow
this reusewrappers   reusewrappers
vector   new vector
}
/**
* called prior to inserting a distinct sort
* key.
*
* @param insertrow the current row that the sorter
* 		is on the verge of retaining
*
* @return the row to be inserted by the sorter.  if null,
*		then nothing is inserted by the sorter.  distinct
*		sorts will want to return null.
*
* @exception standardexception never thrown
*/
public datavaluedescriptor insertnonduplicatekey datavaluedescriptor insertrow
throws standardexception
{
return  doclone  ?
getclone insertrow
insertrow
}
/**
* called prior to inserting a duplicate sort
* key.
*
* @param insertrow the current row that the sorter
* 		is on the verge of retaining.  it is a duplicate
* 		of existingrow.
*
* @param existingrow the row that is already in the
* 		the sorter which is a duplicate of insertrow
*
* @exception standardexception never thrown
*/
public datavaluedescriptor insertduplicatekey datavaluedescriptor insertrow  datavaluedescriptor existingrow
throws standardexception
{
return  distinct  ?
datavaluedescriptor null
doclone  ?
getclone insertrow
insertrow
}
public void addtofreelist datavaluedescriptor objectarray  int maxfreelistsize
{
if  reusewrappers    vector size   < maxfreelistsize
{
vector addelement objectarray
}
}
public datavaluedescriptor getarrayclone
throws standardexception
{
int lastelement   vector size
if  lastelement > 0
{
datavaluedescriptor retval    datavaluedescriptor  vector elementat lastelement   1
vector removeelementat lastelement   1
return retval;
}
return execrow getrowarrayclone
}
private datavaluedescriptor getclone datavaluedescriptor origarray
{
/* if the free list is not empty, then
* get an datavaluedescriptor[] from there and swap
* objects between that datavaluedescriptor[] and
* origarray, returning the datavaluedescriptor[]
* from the free list.  that will save
* on unnecessary cloning.
*/
/* resolve - we can't enable this code
* until bug 2829 is fixed.
* (close bug 2828 when enabling the code.
if (vector.size() > 0)
{
datavaluedescriptor[] retval = getarrayclone();
for (int index = 0; index < retval.length; index++)
{
datavaluedescriptor tmp = origarray[index];
origarray[index] = retval[index];
retval[index] = tmp;
}
return retval;
}
*/
datavaluedescriptor newarray   new datavaluedescriptor
for  int i   0  i < origarray length  i
{
// the only difference between getclone and cloneobject is cloneobject does
// not objectify a stream.  we use getclone here.  beetle 4896.
newarray   origarray getclone
}
return newarray
}
}