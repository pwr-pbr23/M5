/*
derby - class simpleapp
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
import java sql connection
import java sql drivermanager
import java sql preparedstatement
import java sql resultset
import java sql sqlexception
import java sql statement
import java util arraylist
import java util properties
/**
* <p>
* this sample program is a minimal java application showing jdbc access to a
* derby database.</p>
* <p>
* instructions for how to run this program are
* given in <a href=example.html>example.html</a>, by default located in the
* same directory as this source file ($derby_home/demo/programs/simple/).</p>
* <p>
* derby applications can run against derby running in an embedded
* or a client/server framework.</p>
* <p>
* when derby runs in an embedded framework, the jdbc application and derby
* run in the same java virtual machine (jvm). the application
* starts up the derby engine.</p>
* <p>
* when derby runs in a client/server framework, the application runs in a
* different jvm from derby. the application only needs to load the client
* driver, and the connectivity framework (in this case the derby network
* server) provides network connections.</p>
*/
public class simpleapp
/* the default framework is embedded*/
private string framework
private string driver
private string protocol
/**
* <p>
* starts the demo by creating a new instance of this class and running
* the <code>go()</code> method.</p>
* <p>
* when you run this application, you may give one of the following
* arguments:
*  <ul>
<li><code>embedded</code> - default, if none specified. will use
*        derby's embedded driver. this driver is included in the derby.jar
*        file.</li>
*    <li><code>derbyclient</code> - will use the derby client driver to
*        access the derby network server. this driver is included in the
*        derbyclient.jar file.</li>
*    <li><code>jccjdbcclient</code> - will use the db2 universal jdbc
*        network client driver, also known as jcc, to access the network
*        server. this driver is not part of the derby distribution.</li>
*  </ul>
* <p>
* when you are using a client/server framework, the network server must
* already be running when trying to obtain client connections to derby.
* this demo program will will try to connect to a network server on this
* host (the localhost), see the <code>protocol</code> instance variable.
* </p>
* <p>
* when running this demo, you must include the correct driver in the
* classpath of the jvm. see <a href="example.html">example.html</a> for
* details.
* </p>
* @param args this program accepts one optional argument specifying which
*        connection framework (jdbc driver) to use (see above). the default
*        is to use the embedded jdbc driver.
*/
public static void main string args
new simpleapp   go args
system out println
/**
* <p>
* starts the actual demo activities. this includes loading the correct
* jdbc driver, creating a database by making a connection to derby,
* creating a table in the database, and inserting, updating and retreiving
* some data. some of the retreived data is then verified (compared) against
* the expected results. finally, the table is deleted and, if the embedded
* framework is used, the database is shut down.</p>
* <p>
* generally, when using a client/server framework, other clients may be
* (or want to be) connected to the database, so you should be careful about
* doing shutdown unless you know that noone else needs to access the
* database until it is rebooted. that is why this demo will not shut down
* the database unless it is running derby embedded.</p>
*
* @param args - optional argument specifying which framework or jdbc driver
*        to use to connect to derby. default is the embedded framework,
*        see the <code>main()</code> method for details.
* @see #main(string[])
*/
void go string args
/* parse the arguments to determine which framework is desired*/
parsearguments args
system out println     framework
/* load the desired jdbc driver */
loaddriver
/* we will be using statement and preparedstatement objects for
* executing sql. these objects, as well as connections and resultsets,
* are resources that should be released explicitly after use, hence
* the try-catch-finally pattern used below.
* we are storing the statement and prepared statement object references
* in an array list for convenience.
*/
connection conn   null
/* this arraylist usage may cause a warning when compiling this class
* with a compiler for j2se 5.0 or newer. we are not using generics
* because we want the source to support j2se 1.4.2 environments. */
arraylist statements   new arraylist       list of statements  preparedstatements
preparedstatement psinsert   null
preparedstatement psupdate   null
statement s   null
resultset rs   null
try
properties props   new properties       connection properties
// providing a user name and password is optional in the embedded
// and derbyclient frameworks
props put
props put
/* by default, the schema app will be used when no username is
* provided.
* otherwise, the schema name is the same as the user name (in this
* case "user1" or user1.)
*
* note that user authentication is off by default, meaning that any
* user can connect to your database using any password. to enable
* authentication, see the derby developer's guide.
*/
string dbname         the name of the database
/*
* this connection specifies create=true in the connection url to
* cause the database to be created when connecting for the first
* time. to remove the database, remove the directory derbydb (the
* same as the database name) and its contents.
*
* the directory derbydb will be created under the directory that
* the system property derby.system.home points to, or the current
* directory (user.dir) if derby.system.home is not set.
*/
conn   drivermanager getconnection protocol   dbname
props
system out println     dbname
// we want to control transactions manually. autocommit is on by
// default in jdbc.
conn setautocommit false
/* creating a statement object that we can use for running various
* sql statements commands against the database.*/
s   conn createstatement
statements add s
// we create a table...
s execute
system out println
// and add a few rows...
/* it is recommended to use preparedstatements when you are
* repeating execution of an sql statement. preparedstatements also
* allows you to parameterize variables. by using preparedstatements
* you may increase performance (because the derby engine does not
* have to recompile the sql statement each time it is executed) and
* improve security (because of java type checking).
*/
// parameter 1 is num (int), parameter 2 is addr (varchar)
psinsert   conn preparestatement
statements add psinsert
psinsert setint 1  1956
psinsert setstring 2
psinsert executeupdate
system out println
psinsert setint 1  1910
psinsert setstring 2
psinsert executeupdate
system out println
// let's update some rows as well...
// parameter 1 and 3 are num (int), parameter 2 is addr (varchar)
psupdate   conn preparestatement
statements add psupdate
psupdate setint 1  180
psupdate setstring 2
psupdate setint 3  1956
psupdate executeupdate
system out println
psupdate setint 1  300
psupdate setstring 2
psupdate setint 3  180
psupdate executeupdate
system out println
/*
we select the rows and verify the results.
*/
rs   s executequery
/* we expect the first returned column to be an integer (num),
* and second to be a string (addr). rows are sorted by street
* number (num).
*
* normally, it is best to use a pattern of
*  while(rs.next()) {
*    // do something with the result set
*  }
* to process all returned rows, but we are only expecting two rows
* this time, and want the verification code to be easy to
* comprehend, so we use a different pattern.
*/
int number     street number retreived from the database
boolean failure   false
if   rs next
failure   true
reportfailure
if   number   rs getint 1      300
failure   true
reportfailure
number
if   rs next
failure   true
reportfailure
if   number   rs getint 1      1910
failure   true
reportfailure
number
if  rs next
failure   true
reportfailure
if   failure
system out println
// delete the table
s execute
system out println
/*
we commit the transaction. any changes will be persisted to
the database now.
*/
conn commit
system out println
/*
* in embedded mode, an application should shut down the database.
* if the application fails to shut down the database,
* derby will not perform a checkpoint when the jvm shuts down.
* this means that it will take longer to boot (connect to) the
* database the next time, because derby needs to perform a recovery
* operation.
*
* it is also possible to shut down the derby system/engine, which
* automatically shuts down all booted databases.
*
* explicitly shutting down the database or the derby engine with
* the connection url is preferred. this style of shutdown will
* always throw an sqlexception.
*
* not shutting down when in a client environment, see method
* javadoc.
*/
if  framework equals
try
// the shutdown=true attribute shuts down derby
drivermanager getconnection
// to shut down a specific database only, but keeep the
// engine running (for example for connecting to other
// databases), specify a database in the connection url:
//drivermanager.getconnection("jdbc:derby:" + dbname + ";shutdown=true");
catch  sqlexception se
if     se geterrorcode      50000
equals se getsqlstate
// we got the expected exception
system out println
// note that for single database shutdown, the expected
// sql state is "08006", and the error code is 45000.
else
// if the error code or sqlstate is different, we have
// an unexpected exception (shutdown failed)
system err println
printsqlexception se
catch  sqlexception sqle
printsqlexception sqle
finally
// release all open resources to avoid unnecessary memory usage
// resultset
try
if  rs    null
rs close
rs   null
catch  sqlexception sqle
printsqlexception sqle
// statements and preparedstatements
int i   0
while   statements isempty
// preparedstatement extend statement
statement st    statement statements remove i
try
if  st    null
st close
st   null
catch  sqlexception sqle
printsqlexception sqle
//connection
try
if  conn    null
conn close
conn   null
catch  sqlexception sqle
printsqlexception sqle
/**
* loads the appropriate jdbc driver for this environment/framework. for
* example, if we are in an embedded environment, we load derby's
* embedded driver, <code>org.apache.derby.jdbc.embeddeddriver</code>.
*/
private void loaddriver
/*
*  the jdbc driver is loaded by loading its class.
*  if you are using jdbc 4.0 (java se 6) or newer, jdbc drivers may
*  be automatically loaded, making this code optional.
*
*  in an embedded environment, this will also start up the derby
*  engine (though not any databases), since it is not already
*  running. in a client environment, the derby engine is being run
*  by the network server framework.
*
*  in an embedded environment, any static derby system properties
*  must be set before loading the driver to take effect.
*/
try
class forname driver  newinstance
system out println
catch  classnotfoundexception cnfe
system err println     driver
system err println
cnfe printstacktrace system err
catch  instantiationexception ie
system err println
driver
ie printstacktrace system err
catch  illegalaccessexception iae
system err println
driver
iae printstacktrace system err
/**
* reports a data verification failure to system.err with the given message.
*
* @param message a message describing what failed.
*/
private void reportfailure string message
system err println
system err println     message
/**
* prints details of an sqlexception chain to <code>system.err</code>.
* details included are sql state, error code, exception message.
*
* @param e the sqlexception from which to print details.
*/
public static void printsqlexception sqlexception e
// unwraps the entire exception chain to unveil the real cause of the
// exception.
while  e    null
system err println
system err println     e getsqlstate
system err println     e geterrorcode
system err println     e getmessage
// for stack traces, refer to derby.log or uncomment this:
//e.printstacktrace(system.err);
e   e getnextexception
/**
* parses the arguments given and sets the values of this class' instance
* variables accordingly - that is which framework to use, the name of the
* jdbc driver class, and which connection protocol protocol to use. the
* protocol should be used as part of the jdbc url when connecting to derby.
* <p>
* if the argument is "embedded" or invalid, this method will not change
* anything, meaning that the default values will be used.</p>
* <p>
* @param args jdbc connection framework, either "embedded", "derbyclient"
*        or "jccjdbcclient". only the first argument will be considered,
*        the rest will be ignored.
*/
private void parsearguments string args
if  args length > 0
if  args equalsignorecase
framework
driver
protocol
else if  args equalsignorecase
framework
driver
protocol