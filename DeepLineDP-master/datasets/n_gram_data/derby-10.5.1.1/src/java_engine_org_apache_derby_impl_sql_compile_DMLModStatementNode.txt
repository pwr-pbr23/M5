/*
derby - class org.apache.derby.impl.sql.compile.dmlmodstatementnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import java lang reflect modifier
import java util enumeration
import java util hashtable
import java util hashset
import java util vector
import org apache derby catalog defaultinfo
import org apache derby catalog uuid
import org apache derby iapi error standardexception
import org apache derby iapi reference classname
import org apache derby iapi reference sqlstate
import org apache derby iapi services classfile vmopcode
import org apache derby iapi services compiler localfield
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services context contextmanager
import org apache derby iapi services io formatablebitset
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql statementtype
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile nodefactory
import org apache derby iapi sql compile parser
import org apache derby iapi sql conn authorizer
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql depend dependent
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary columndescriptorlist
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi sql dictionary constraintdescriptorlist
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary foreignkeyconstraintdescriptor
import org apache derby iapi sql dictionary genericdescriptorlist
import org apache derby iapi sql dictionary indexrowgenerator
import org apache derby iapi sql dictionary referencedkeyconstraintdescriptor
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary triggerdescriptor
import org apache derby iapi types datatypedescriptor
import org apache derby iapi store access transactioncontroller
import org apache derby impl sql execute fkinfo
import org apache derby impl sql execute triggerinfo
/**
* a dmlstatement for a table modification: to wit, insert
* update or delete.
*
*/
abstract class dmlmodstatementnode extends dmlstatementnode
//	protected datadictionary	datadictionary;
protected fromvti			targetvti
protected tablename			targettablename
protected resultcolumnlist	resultcolumnlist
protected int 				lockmode 		   lock mode for the target table
protected fkinfo			fkinfo 			   array of fkinfo structures
// generated during bind
protected triggerinfo		triggerinfo 	   generated during bind
public tabledescriptor		targettabledescriptor
/* the indexes that could be affected by this statement */
public	indexrowgenerator 		indicestomaintain
public	long						indexconglomeratenumbers
public	string					indexnames
protected constraintdescriptorlist relevantcdl
protected genericdescriptorlist relevanttriggers
// private
private boolean			requiresdeferredprocessing
private	int				statementtype
private boolean			bound
private valuenode		checkconstraints
/* info required to perform referential actions */
protected string fktablenames     referencing table names
protected int fkrefactions       type of referential actions
protected columndescriptorlist  fkcoldescriptors
protected long fkindexconglomnumbers    conglomerate number of the backing index
protected  boolean isdependenttable
protected int fkcolarrays
protected hashtable graphhashtable
// hash table which maitains the querytreenode graph
protected tablename synonymtablename
/**
* initializer for a dmlmodstatementnode -- delegate to dmlstatementnode
*
* @param resultset	a resultsetnode for the result set of the
*			dml statement
*/
public void init object resultset
super init resultset
statementtype   getstatementtype
/**
* initializer for a dmlmodstatementnode -- delegate to dmlstatementnode
*
* @param resultset	a resultsetnode for the result set of the
*			dml statement
* @param statementtype used by nodes that allocate a dmlmod directly
*			(rather than inheriting it).
*/
public void init object resultset  object statementtype
super init resultset
this statementtype     integer  statementtype  intvalue
void settarget querytreenode targetname
if  targetname instanceof tablename
this targettablename    tablename  targetname
else
if  sanitymanager debug
if     targetname instanceof fromvti
sanitymanager throwassert
targetname getclass   getname
this targetvti    fromvti  targetname
targetvti settarget
/**
* if the dml is on a temporary table, generate the code to mark temporary table as modified in the current uow.
* at rollback transaction (or savepoint), we will check if the temporary table was modified in that uow.
* if yes, we will remove all the data from the temporary table
*
* @param acb	the activationclassbuilder for the class being built
* @param mb	the execute() method to be built
*
* @exception standardexception		thrown on error
*/
protected void generatecodefortemporarytable activationclassbuilder acb  methodbuilder mb
throws standardexception
if  targettabledescriptor    null    targettabledescriptor gettabletype      tabledescriptor global_temporary_table_type
targettabledescriptor isonrollbackdeleterows      true
mb pushthis
mb callmethod vmopcode invokeinterface  classname activation
classname languageconnectioncontext  0
mb push targettabledescriptor getname
mb callmethod vmopcode invokeinterface  null
1
mb endstatement
/**
* verify the target table.  get the tabledescriptor
* if the target table is not a vti.
*
* @exception standardexception		thrown on error
*/
void verifytargettable
throws standardexception
datadictionary datadictionary   getdatadictionary
if  targettablename    null
/*
** get the tabledescriptor for the table we are inserting into
*/
schemadescriptor sdtc   getschemadescriptor targettablename getschemaname
targettabledescriptor   gettabledescriptor
targettablename gettablename    sdtc
if  targettabledescriptor    null
// check if the reference is for a synonym.
tablename synonymtab   resolvetabletosynonym targettablename
if  synonymtab    null
throw standardexception newexception sqlstate lang_table_not_found  targettablename
synonymtablename   targettablename
targettablename   synonymtab
sdtc   getschemadescriptor targettablename getschemaname
targettabledescriptor   gettabledescriptor synonymtab gettablename    sdtc
if  targettabledescriptor    null
throw standardexception newexception sqlstate lang_table_not_found  targettablename
switch  targettabledescriptor gettabletype
case tabledescriptor view_type
// views are currently not updatable
throw standardexception newexception sqlstate lang_view_not_updateable
targettablename
case tabledescriptor vti_type
// fall through - currently all vti tables are system tables.
case tabledescriptor system_table_type
// system tables are not updatable
throw standardexception newexception sqlstate lang_update_system_table_attempted
targettablename
default
break
/* we need to get some kind of table lock (ix here), to prevent
* another thread from adding a new index while we are binding,
* if we are a reader in ddl mode.  just a row lock on system table
* sysconglomerate is not enough: that wouldn't prevent another
* thread from adding a new entry.  part of the fix for beetle 3976.
* same lock as in exec, compatible with row lock, for concurrency.
*/
targettabledescriptor   locktableforcompilation targettabledescriptor
getcompilercontext   createdependency targettabledescriptor
else
/* vti - vtis in dml mod are version 2 vtis - they
* must implement java.sql.preparedstatement and have
* the jdbc2.0 getmetadata() and getresultsetconcurrency()
* methods and return an updatable resultset.
*/
fromlist dummyfromlist   new fromlist
targetvti    fromvti  targetvti bindnonvtitables datadictionary  dummyfromlist
targetvti    fromvti  targetvti bindvtitables dummyfromlist
/**
*
* insert/update/delete are always atomic.
*
* @return true
*/
public boolean isatomic
return true
/**
* get a schema descriptor for the given table.
* uses this.targettablename.
*
* @return schema descriptor
*
* @exception	standardexception	throws on schema name
*						that doesn't exist
*/
public schemadescriptor getschemadescriptor   throws standardexception
schemadescriptor		sd
sd   getschemadescriptor targettablename getschemaname
return sd
/**
get a map to efficiently find heap columns from a compressed set of
read columns. the returns a map such that
<pre>
map[heapcolid (0 based)] -> readcol id (0 based)
</pre>
@param column_map_length the number of columns(ints) in the map.
@param readcolsbitset a language style (1 based) bit set with bits for
read heap columns set.
resolve: replace this with a call to rowutil when the store and
the language both use 0 base or 1 base offsets for columns. today
we can't use the store function because we have a 1 based formatablebitset.
*/
public static int getreadcolmap int column_map_length formatablebitset readcolsbitset
if  readcolsbitset    null  return null
int partial_col_cnt   0
int column_map   new int
int readcolsbitsetsize   readcolsbitset size
for  int base_index   0  base_index < column_map length  base_index
if  readcolsbitsetsize > base_index    readcolsbitset get base_index 1
column_map   partial_col_cnt
else
// this column map offset entry should never be referenced.
column_map    1
return column_map
/**
* get and bind the resultcolumnlist representing the columns in the
* target table, given the table's name.
*
* @exception standardexception		thrown on error
*/
protected void getresultcolumnlist
throws standardexception
if  targetvti    null
getresultcolumnlist  resultcolumnlist  null
else
/* binding vti - just point to vti's rcl,
* which was already bound.
*/
resultcolumnlist   targetvti getresultcolumns
/**
* get and bind the resultcolumnlist representing the columns in the
* target table, given the table's name.
*
* @exception standardexception		thrown on error
*/
protected frombasetable getresultcolumnlist resultcolumnlist	inputrcl
throws standardexception
/* get a resultcolumnlist representing all the columns in the target */
frombasetable	fbt
frombasetable
getnodefactory   getnode
c_nodetypes from_base_table
targettablename



getcontextmanager
fbt bindnonvtitables
getdatadictionary
fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
getresultcolumnlist
fbt
inputrcl
return fbt
/**
* get and bind the resultcolumnlist representing the columns in the
* target table, given a fromtable for the target table.
*
* @exception standardexception		thrown on error
*/
private void getresultcolumnlist frombasetable	frombasetable
resultcolumnlist	inputrcl
throws standardexception
if  inputrcl    null
resultcolumnlist   frombasetable getallresultcolumns null
resultcolumnlist bindresultcolumnsbyposition targettabledescriptor
else
resultcolumnlist   frombasetable getresultcolumnsforlist null  inputrcl
frombasetable gettablenamefield
resultcolumnlist bindresultcolumnsbyname targettabledescriptor
dmlstatementnode  this
/**
* do not allow generation clauses to be overriden. throws an exception
* if the user attempts to override the value of a generated column.
* the only value allowed in a generated column is default. if we find
* a generated column which is being explicitly set to default in an insert, we remove
* it from the column lists--it will be added back in during the enhance
* phase. for an update, addedgeneratedcolumns will be non-null and we will
* use this list to pass through the generated columns which have already
* been added to the update list.
*
* @param targetrcl  the row in the table being inserted or updated
* @param forupdate  true if this is an update. false otherwise.
* @param addedgeneratedcolumns generated columns which the compiler added earlier on
*/
void forbidgenerationoverrides  resultcolumnlist targetrcl  boolean forupdate  columndescriptorlist addedgeneratedcolumns
throws standardexception
int  count   targetrcl size
resultcolumnlist    resultrcl   resultset getresultcolumns
for   int i   0  i < count  i
resultcolumn    rc    resultcolumn  targetrcl elementat  i
if   rc hasgenerationclause
valuenode   resultexpression     resultcolumn  resultrcl elementat  i    getexpression
if      resultexpression instanceof defaultnode
//
// for updates, we may have added the generation clause
// ourselves. here we forgive ourselves for this pro-active behavior.
//
boolean allisforgiven   false
if   forupdate
string      columnname   rc gettablecolumndescriptor   getcolumnname
int         addedcount   addedgeneratedcolumns size
for   int j   0  j < addedcount  j
string  addedcolumnname   addedgeneratedcolumns elementat  j   getcolumnname
if   columnname equals  addedcolumnname
allisforgiven   true
break
if   allisforgiven     continue
throw standardexception newexception
sqlstate lang_cant_override_generation_clause  rc getname
else
// skip this step if we're working on an update statement.
// for updates, the target list has already been enhanced.
if   forupdate     continue
// prune the generated column and its default. they will be
// added back in during the enhance phase.
targetrcl removeelementat  i
resultrcl removeelementat  i
targetrcl resetvirtualcolumnids
resultrcl resetvirtualcolumnids
// account for the dropped entries
count
i
/**
* parse and bind the generating expressions of computed columns.
*
* @param datadictionary    metadata
* @param targettabledescriptor metadata for the table that has the generated columns
* @param sourcercl  the tuple stream which drives the insert or update
* @param targetrcl  the row in the table that's being inserted or updated
* @param forupdate true if this is an update. false otherwise.
* @param updateresultset more information on the tuple stream driving the update
*/
void parseandbindgenerationclauses
datadictionary		datadictionary
tabledescriptor		targettabledescriptor
resultcolumnlist	sourcercl
resultcolumnlist	targetrcl
boolean                 forupdate
resultsetnode       updateresultset
throws standardexception
compilercontext 			compilercontext   getcompilercontext
int  count   targetrcl size
for   int i   0  i < count  i
resultcolumn    rc    resultcolumn  targetrcl elementat  i
//
// for updates, there are two copies of the column in the row: a
// before image and the actual value which will be set when we
// update the row. we only want to compile a generation clause for
// the value which will be updated.
//
if   forupdate     rc updated       continue
if   rc hasgenerationclause
columndescriptor    coldesc   rc gettablecolumndescriptor
datatypedescriptor  dtd   coldesc gettype
defaultinfo             di   coldesc getdefaultinfo
valuenode   generationclause   parsegenerationclause  di getdefaulttext    targettabledescriptor
// insert cast in case column data type is not same as the
// resolved type of the generation clause
generationclause    valuenode  getnodefactory   getnode
c_nodetypes cast_node
generationclause
dtd
getcontextmanager
//
// unqualified function references should resolve to the
// current schema at the time that the table was
// created/altered. see derby-3945.
//
schemadescriptor    originalcurrentschema   getschemadescriptor  di getoriginalcurrentschema    true
compilercontext pushcompilationschema  originalcurrentschema
try
bindrowscopedexpression  getnodefactory    getcontextmanager    targettabledescriptor  sourcercl  generationclause
finally
compilercontext popcompilationschema
resultcolumn    newrc     resultcolumn  getnodefactory   getnode
c_nodetypes result_column  generationclause gettypeservices    generationclause  getcontextmanager
// replace the result column in place
newrc setvirtualcolumnid  i   1       column ids are 1 based
newrc setcolumndescriptor  targettabledescriptor  coldesc
targetrcl setelementat  newrc  i
// if this is an update, then the result column may appear in the
// source list as well. replace it there too and perform a
// little extra binding so that check constraints will bind and
// generate correctly if they reference the generated column
if   forupdate
for   int j   0  j < sourcercl size    j
if   rc    sourcercl elementat  j
newrc setname  rc getname
newrc setresultsetnumber  updateresultset getresultsetnumber
sourcercl setelementat  newrc  j
end of loop through sourcercl
end if this is an update statement
end if this is a generated column
end of loop through targetrcl
/**
*	parse the generation clause for a column.
*
*	@param	clausetext  text of the generation clause
*
* @return	the parsed expression as a query tree.
*
* @exception standardexception		thrown on failure
*/
public	valuenode	parsegenerationclause
string				clausetext
tabledescriptor    td
throws standardexception
parser						p
valuenode					clausetree
languageconnectioncontext	lcc   getlanguageconnectioncontext
compilercontext 			compilercontext   getcompilercontext
/* get a statement to pass to the parser */
/* we're all set up to parse. we have to build a compilable sql statement
* before we can parse -  so, we goober up a values defaulttext.
*/
string select       clausetext       td getqualifiedname
/*
** get a new compiler context, so the parsing of the select statement
** doesn't mess up anything in the current context (it could clobber
** the parametervalueset, for example).
*/
compilercontext newcc   lcc pushcompilercontext
p   newcc getparser
/* finally, we can call the parser */
// since this is always nested inside another sql statement, so toplevel flag
// should be false
statementnode qt   p parsestatement select
if  sanitymanager debug
if     qt instanceof cursornode
sanitymanager throwassert
qt getclass   getname
cursornode cn    cursornode  qt
if     cn getresultsetnode   instanceof selectnode
sanitymanager throwassert
cn getresultsetnode   getclass   getname
clausetree     resultcolumn
cursornode  qt  getresultsetnode   getresultcolumns   elementat 0
getexpression
lcc popcompilercontext newcc
return	clausetree
/**
* gets and binds all the constraints for an insert/update/delete.
* first finds the constraints that are relevant to this node.
* this is done by calling getallrelevantconstriants().  if
* getallrelevantconstraints() has already been called, then
* this list is used.  then it creates appropriate
* dependencies. then binds check constraints.  it also
* generates the array of fkinfo items that are used in
* code generation.
* note: we have a new flag here to see if defer processing is enabled or
*       not, the only scenario that is disabled is when we reapply the
*		 reply message we get from the source
*
*
* @param datadictionary		the datadictionary
* @param nodefactory			where to get query tree nodes.
* @param targettabledescriptor	the tabledescriptor
* @param dependent			parent object that will depend on all the constraints
*							that we look up. if this argument is null, then we
*							use the default dependent (the statement being compiled).
* @param sourcercl				rcl of the table being changed
* @param changedcolumnids		if null, all columns being changed, otherwise array
*								of 1-based column ids for columns being changed
* @param readcolsbitset		bit set for the read scan
* @param skipcheckconstraints 	whether to skip check constraints or not
* @param includetriggers		whether triggers are included in the processing
*
* @return	the bound, anded check constraints as a query tree.
*
* @exception standardexception		thrown on failure
*/
valuenode bindconstraints
datadictionary		datadictionary
nodefactory			nodefactory
tabledescriptor		targettabledescriptor
dependent			dependent
resultcolumnlist	sourcercl
int				changedcolumnids
formatablebitset				readcolsbitset
boolean				skipcheckconstraints
boolean 			includetriggers
throws standardexception
bound   true
/* nothing to do if updatable vti */
if  targetvti    null
return null
// donot need privileges to execute constraints
getcompilercontext   pushcurrentprivtype  authorizer null_priv
try
getallrelevantconstraints datadictionary
targettabledescriptor
skipcheckconstraints
changedcolumnids
createconstraintdependencies datadictionary  relevantcdl  dependent
generatefkinfo relevantcdl  datadictionary  targettabledescriptor  readcolsbitset
getallrelevanttriggers datadictionary  targettabledescriptor
changedcolumnids  includetriggers
createtriggerdependencies relevanttriggers  dependent
generatetriggerinfo relevanttriggers  targettabledescriptor  changedcolumnids
if  skipcheckconstraints
return null
checkconstraints   generatechecktree relevantcdl
targettabledescriptor
if  checkconstraints    null
bindrowscopedexpression nodefactory  getcontextmanager
targettabledescriptor
sourcercl
checkconstraints
finally
getcompilercontext   popcurrentprivtype
return	checkconstraints
/**
* binds an already parsed expression that only involves columns in a single
* row. e.g., a check constraint or a generation clause.
*
* @param nodefactory			where to get query tree nodes.
* @param targettabledescriptor	the tabledescriptor for the constrained table.
* @param sourcercl		result columns.
* @param expression		parsed query tree for row scoped expression
*
* @exception standardexception		thrown on failure
*/
void	bindrowscopedexpression
nodefactory			nodefactory
contextmanager    contextmanager
tabledescriptor		targettabledescriptor
resultcolumnlist	sourcercl
valuenode			expression
throws standardexception
tablename	targettablename   maketablename
nodefactory  contextmanager  targettabledescriptor getschemaname    targettabledescriptor getname
/* we now have the expression as a query tree.  now, we prepare
* to bind that query tree to the source's rcl.  that way, the
* generated code for the expression will be evaluated against the
* source row to be inserted into the target table or
* against the after portion of the source row for the update
* into the target table.
*		o  goober up a new fromlist which has a single table,
*		   a goobered up frombasetable for the target table
*		   which has the source's rcl as it rcl.
*		   (this allows the columnreferences in the expression
*		   tree to be bound to the right rcs.)
*
* note that in some circumstances we may not actually verify
* the expression against the source rcl but against a temp
* row source used for deferred processing because of a trigger.
* in this case, the caller of bindconstraints (updatenode)
* has chosen to pass in the correct rcl to bind against.
*/
fromlist fakefromlist
fromlist  nodefactory getnode
c_nodetypes from_list
nodefactory dojoinorderoptimization
contextmanager
frombasetable table    frombasetable
nodefactory getnode
c_nodetypes from_base_table
targettablename

sourcercl

contextmanager
table settablenumber 0
fakefromlist addfromtable table
// now we can do the bind.
expression   expression bindexpression
fakefromlist
subquerylist  null
vector  null
/**
* determine whether or not there are check constraints on the
* specified table.
*
* @param dd	the datadictionary to use
* @param td	the tabledescriptor for the table
*
* @return whether or not there are check constraints on the specified table.
*
* @exception standardexception		thrown on failure
*/
protected boolean hascheckconstraints datadictionary dd
tabledescriptor td
throws standardexception
constraintdescriptorlist cdl   dd getconstraintdescriptors td
if  cdl    null
return false
constraintdescriptorlist cccdl   cdl getsublist datadictionary check_constraint
return  cccdl size   > 0
/**
* determine whether or not there are generated columns in the
* specified table.
*
* @param td	the tabledescriptor for the table
*
* @return whether or not there are generated columns in the specified table.
*
* @exception standardexception		thrown on failure
*/
protected boolean hasgenerationclauses tabledescriptor td
throws standardexception
columndescriptorlist list  td getgeneratedcolumns
return  list size   > 0
/**
* get the anding of all appropriate check constraints as 1 giant query tree.
*
* makes the calling object (usually a statement) dependent on all the constraints.
*
* @param cdl				the constriant descriptor list
* @param td				the tabledescriptor
*
* @return	the anding of all appropriate check constraints as a query tree.
*
* @exception standardexception		thrown on failure
*/
private	valuenode generatechecktree
constraintdescriptorlist	cdl
tabledescriptor				td
throws standardexception
constraintdescriptorlist	cccdl   cdl getsublist datadictionary check_constraint
int							cccdlsize   cccdl size
valuenode					checktree   null
// get the text of all the check constraints
for  int index   0  index < cccdlsize  index
constraintdescriptor cd   cccdl elementat index
string constrainttext   cd getconstrainttext
// get the query tree for this constraint
valuenode oneconstraint
parsecheckconstraint constrainttext  td
// put a testconstraintnode above the constraint tree
testconstraintnode tcn
testconstraintnode  getnodefactory   getnode
c_nodetypes test_constraint_node
oneconstraint
sqlstate lang_check_constraint_violated
td getqualifiedname
cd getconstraintname
getcontextmanager
// link consecutive testconstraintnodes with and nodes
if  checktree    null
checktree   tcn
else
checktree    valuenode  getnodefactory   getnode
c_nodetypes and_node
tcn
checktree
getcontextmanager
return checktree
/**
* generate the fkinfo structures used during code generation.
* for each constraint that isn't a check constraint, add another
* one of these fkinfo structures and then package them up into
* a single array.
*
* @param cdl				the constriant descriptor list
* @param dd				the datadictionary
* @param td				the tabledescriptor
* @param readcolsbitset 	columns read
*
* @exception standardexception		thrown on failure
*/
private void generatefkinfo
constraintdescriptorlist	cdl
datadictionary				dd
tabledescriptor				td
formatablebitset						readcolsbitset
throws standardexception
vector								fkvector   new vector 10
int 								type
uuid 								uuids   null
long 								conglomnumbers   null
string							fknames   null
constraintdescriptorlist			fkcdl
referencedkeyconstraintdescriptor	refcd
boolean							isselfreferencingfk
constraintdescriptorlist			activelist   dd getactiveconstraintdescriptors cdl
int								rowmap   getrowmap readcolsbitset  td
int                               rarules   null
vector                              reftablenames   new vector 1
vector                              refindexconglomnum   new vector 1
vector                              refactions   new vector 1
vector                              refcoldescriptors   new vector 1
vector                              fkcolmap   new vector 1
int activesize   activelist size
for  int index   0  index < activesize  index
constraintdescriptor cd   activelist elementat index
if  cd instanceof foreignkeyconstraintdescriptor
/*
** we are saving information for checking the
** primary/unique key that is referenced by this
** foreign key, so type is foreign key.
*/
type   fkinfo foreign_key
refcd     foreignkeyconstraintdescriptor cd  getreferencedconstraint
uuids   new uuid
conglomnumbers   new long
fknames   new string
isselfreferencingfk   new boolean
rarules   new int
fksetuparrays dd   foreignkeyconstraintdescriptor cd
0  uuids  conglomnumbers
fknames  isselfreferencingfk  rarules
// oops, get the right constraint name -- for error
// handling we want the fk name, not refcd name
fknames   cd getconstraintname
else if  cd instanceof referencedkeyconstraintdescriptor
refcd    referencedkeyconstraintdescriptor cd
/*
** we are saving information for checking the
** foreign key(s) that is dependent on this referenced
** key, so type is referenced key.
*/
type   fkinfo referenced_key
fkcdl   dd getactiveconstraintdescriptors
referencedkeyconstraintdescriptor cd  getforeignkeyconstraints constraintdescriptor enabled
int size   fkcdl size
if  size    0
continue
uuids   new uuid
fknames   new string
conglomnumbers   new long
isselfreferencingfk   new boolean
rarules   new int
foreignkeyconstraintdescriptor fkcd   null
tabledescriptor fktd
columndescriptorlist coldl
int refcolumns
columndescriptor cold
int colarray   remapreferencedcolumns cd  rowmap
for  int inner   0  inner < size  inner
fkcd    foreignkeyconstraintdescriptor  fkcdl elementat inner
fksetuparrays dd  fkcd
inner  uuids  conglomnumbers  fknames
isselfreferencingfk  rarules
if  rarules    statementtype ra_cascade
rarules   statementtype ra_setnull
//find  the referencing  table name
fktd   fkcd gettabledescriptor
reftablenames addelement fktd getschemaname         fktd getname
refactions addelement new integer rarules
//find the referencing column name required for update null.
refcolumns   fkcd getreferencedcolumns
coldl   fktd getcolumndescriptorlist
columndescriptorlist releventcoldes   new columndescriptorlist
for int i   0   i < refcolumns length  i
cold   columndescriptor coldl elementat refcolumns 1
releventcoldes add cold
refcoldescriptors addelement releventcoldes
refindexconglomnum addelement new long conglomnumbers
fkcolmap addelement colarray
else
continue
tabledescriptor	pktd   refcd gettabledescriptor
uuid pkuuid   refcd getindexid
conglomeratedescriptor pkindexconglom   pktd getconglomeratedescriptor pkuuid
tabledescriptor reftd   cd gettabledescriptor
fkvector addelement new fkinfo
fknames 							   foreign key names
reftd getname   				   table being modified
statementtype 						   insert update delete
type 								   foreign_key referenced_key
pkuuid 								   referenced backing index uuid
pkindexconglom getconglomeratenumber       referened backing index conglom
uuids 								   fk backing index uuids
conglomnumbers 						   fk backing index congloms
isselfreferencingfk 				   is self ref array of bool
remapreferencedcolumns cd  rowmap  	   column referened by key
dd getrowlocationtemplate getlanguageconnectioncontext    reftd
// row location template  for table being modified
rarules   	   referential action rules
/*
** now convert the vector into an array.
*/
int size   fkvector size
if  size > 0
fkinfo   new fkinfo
for  int i   0  i < size  i
fkinfo    fkinfo fkvector elementat i
//convert the ref action info vectors to  to arrays
size   refactions size
if  size > 0
fktablenames   new string
fkrefactions    new int
fkcoldescriptors   new columndescriptorlist
fkindexconglomnumbers   new long
fkcolarrays   new int
for  int i   0  i < size  i
fktablenames    string reftablenames elementat i
fkrefactions      integer  refactions elementat i   intvalue
fkcoldescriptors
columndescriptorlist refcoldescriptors elementat i
fkindexconglomnumbers
long refindexconglomnum elementat i   longvalue
fkcolarrays     int fkcolmap elementat i
/*
** simple little helper method
*/
private void fksetuparrays
datadictionary						dd
foreignkeyconstraintdescriptor 		fkcd
int									index
uuid								uuids
long								conglomnumbers
string							fknames
boolean							isselfreferencingfk
int                               rarules
throws standardexception
fknames   fkcd getconstraintname
uuids   fkcd getindexid
conglomnumbers   fkcd getindexconglomeratedescriptor dd  getconglomeratenumber
isselfreferencingfk   fkcd isselfreferencingfk
if statementtype    statementtype delete
rarules   fkcd getradeleterule
else if statementtype    statementtype update
rarules   fkcd getraupdaterule
/**
* generate the triggerinfo structures used during code generation.
*
* @param triggerlist				the trigger descriptor list
* @param td				the tabledescriptor
* @param changedcols		the columns that are being modified
*
* @exception standardexception		thrown on failure
*/
private void generatetriggerinfo
genericdescriptorlist		triggerlist
tabledescriptor				td
int						changedcols
throws standardexception
if   triggerlist    null      triggerlist size   > 0
triggerinfo   new triggerinfo td  changedcols  triggerlist
/**
* return the fkinfo structure.  just  a little wrapper
* to make sure we don't try to access it until after
* binding.
*
* @return the array of fkinfos
*/
public fkinfo getfkinfo
if  sanitymanager debug
sanitymanager assert bound
return fkinfo
/**
* return the triggerinfo structure.  just  a little wrapper
* to make sure we don't try to access it until after
* binding.
*
* @return the trigger info
*/
public triggerinfo gettriggerinfo
if  sanitymanager debug
sanitymanager assert bound
return triggerinfo
/**
* get the check constraints for this node
*
* @return the check constraints, may be null
*/
public valuenode getcheckconstraints
if  sanitymanager debug
sanitymanager assert bound
return checkconstraints
/**
* makes the calling object (usually a statement) dependent on all the constraints.
*
* @param tdl				the trigger descriptor list
* @param dependent			parent object that will depend on all the constraints
*							that we look up. if this argument is null, then we
*							use the default dependent (the statement being compiled).
*
* @exception standardexception		thrown on failure
*/
private void createtriggerdependencies
genericdescriptorlist 		tdl
dependent					dependent
throws standardexception
compilercontext 			compilercontext   getcompilercontext
enumeration descs   tdl elements
while  descs hasmoreelements
triggerdescriptor td    triggerdescriptor descs nextelement
/*
** the dependent now depends on this trigger.
** the default dependent is the statement
** being compiled.
*/
if  dependent    null
compilercontext createdependency td
else
compilercontext createdependency dependent  td
/**
* get all the triggers relevant to this dml operation
*
* @param dd				the data dictionary
* @param td				the tabledescriptor
* @param changedcolumnids	if null, all columns being changed, otherwise array
*							of 1-based column ids for columns being changed
* @param includetriggers	whether we allow trigger processing or not for
* 							this table
*
* @return	the constraint descriptor list
*
* @exception standardexception		thrown on failure
*/
protected genericdescriptorlist getallrelevanttriggers
datadictionary		dd
tabledescriptor		td
int				changedcolumnids
boolean 			includetriggers
throws standardexception
if   relevanttriggers     null     return relevanttriggers
relevanttriggers    new genericdescriptorlist
if  includetriggers
return relevanttriggers
td getallrelevanttriggers  statementtype  changedcolumnids  relevanttriggers
adjustdeferredflag  relevanttriggers size   > 0
return relevanttriggers
protected	void	adjustdeferredflag  boolean adjustment
if   requiresdeferredprocessing     requiresdeferredprocessing   adjustment
/**
* get all of our dependents due to a constraint.
*
* makes the calling object (usually a statement) dependent on all the constraints.
*
* @param dd				the data dictionary
* @param cdl				the constraint descriptor list
* @param dependent			parent object that will depend on all the constraints
*							that we look up. if this argument is null, then we
*							use the default dependent (the statement being compiled).
*
* @exception standardexception		thrown on failure
*/
private void createconstraintdependencies
datadictionary				dd
constraintdescriptorlist 	cdl
dependent					dependent
throws standardexception
compilercontext 			compilercontext   getcompilercontext
int cdlsize   cdl size
for  int index   0  index < cdlsize  index
constraintdescriptor cd   cdl elementat index
/*
** the dependent now depends on this constraint.
** the default dependent is the statement
** being compiled.
*/
if  dependent    null
compilercontext createdependency cd
else
compilercontext createdependency dependent  cd
/*
** we are also dependent on all referencing keys --
** if one of them is deleted, we'll have to recompile.
** also, if there is a bulk_insert on the table
** we are going to scan to validate the constraint,
** the index number will change, so we'll add a
** dependency on all tables we will scan.
*/
if  cd instanceof referencedkeyconstraintdescriptor
constraintdescriptorlist fkcdl   dd getactiveconstraintdescriptors
referencedkeyconstraintdescriptor cd  getforeignkeyconstraints constraintdescriptor enabled
int fklsize   fkcdl size
for  int inner   0  inner < fklsize  inner
constraintdescriptor fkcd   fkcdl elementat inner
if  dependent    null
compilercontext createdependency fkcd
compilercontext createdependency fkcd gettabledescriptor
else
compilercontext createdependency dependent  fkcd
compilercontext createdependency dependent  fkcd gettabledescriptor
else if  cd instanceof foreignkeyconstraintdescriptor
foreignkeyconstraintdescriptor fkcd    foreignkeyconstraintdescriptor  cd
if  dependent    null
compilercontext createdependency fkcd getreferencedconstraint   gettabledescriptor
else
compilercontext createdependency dependent
fkcd getreferencedconstraint   gettabledescriptor
/**
* get all the constraints relevant to this dml operation
*
* @param dd				the datadictionary
* @param td				the tabledescriptor
* @param skipcheckconstraints skip check constraints
* @param changedcolumnids	if null, all columns being changed, otherwise array
*							of 1-based column ids for columns being changed
*
* @return	the constraint descriptor list
*
* @exception standardexception		thrown on failure
*/
protected constraintdescriptorlist getallrelevantconstraints
datadictionary		dd
tabledescriptor		td
boolean				skipcheckconstraints
int				changedcolumnids
throws standardexception
if   relevantcdl    null     return relevantcdl
boolean	needsdeferredprocessing   new boolean
relevantcdl   new constraintdescriptorlist
needsdeferredprocessing   requiresdeferredprocessing
td getallrelevantconstraints
statementtype  skipcheckconstraints  changedcolumnids
needsdeferredprocessing  relevantcdl
adjustdeferredflag  needsdeferredprocessing
return relevantcdl
/**
* does this dml node require deferred processing?
* set to true if we have triggers or referential
* constraints that need deferred processing.
*
* @return true/false
*/
public boolean requiresdeferredprocessing
return requiresdeferredprocessing
/**
*	parse a check constraint and turn it into a query tree.
*
*	@param	checkconstrainttext	text of check constraint.
* @param	td					the tabledescriptor for the table the the constraint is on.
*
*
* @return	the parsed check constraint as a query tree.
*
* @exception standardexception		thrown on failure
*/
public	valuenode	parsecheckconstraint
string				checkconstrainttext
tabledescriptor		td
throws standardexception
parser						p
valuenode					checktree
languageconnectioncontext	lcc   getlanguageconnectioncontext
compilercontext 			compilercontext   getcompilercontext
/* get a statement to pass to the parser */
/* we're all set up to parse. we have to build a compile sql statement
* before we can parse - we just have a where clause right now.
* so, we goober up a select * from table where checkdefs.
*/
string select
td getqualifiedname
checkconstrainttext
/*
** get a new compiler context, so the parsing of the select statement
** doesn't mess up anything in the current context (it could clobber
** the parametervalueset, for example).
*/
compilercontext newcc   lcc pushcompilercontext
p   newcc getparser
/* finally, we can call the parser */
// since this is always nested inside another sql statement, so toplevel flag
// should be false
statementnode qt   p parsestatement select
if  sanitymanager debug
if     qt instanceof cursornode
sanitymanager throwassert
qt getclass   getname
cursornode cn    cursornode  qt
if     cn getresultsetnode   instanceof selectnode
sanitymanager throwassert
cn getresultsetnode   getclass   getname
checktree     selectnode    cursornode  qt  getresultsetnode    getwhereclause
lcc popcompilercontext newcc
return	checktree
/**
*	generate the code to evaluate a tree of check constraints.
*
*	@param	checkconstraints	bound query tree of anded check constraints.
*	@param	ecb					expression class builder
*
*
*
* @exception standardexception		thrown on error
*/
public	void	generatecheckconstraints
valuenode				checkconstraints
expressionclassbuilder	ecb
methodbuilder			mb
throws standardexception
// for the check constraints, we generate an exprfun
// that evaluates the expression of the clause
// against the current row of the child's result.
// if there are no check constraints, simply pass null
// to optimize for run time performance.
// generate the function and initializer:
// note: boolean lets us return nulls (boolean would not)
// private boolean exprn()
// {
//   return <<checkconstraints.generate(ps)>>;
// }
// static method exprn = method pointer to exprn;
// if there is no check constraint, we just want to pass null.
if  checkconstraints    null
mb pushnull classname generatedmethod
else
methodbuilder	userexprfun   generatecheckconstraints checkconstraints  ecb
// check constraint is used in the final result set
// as an access of the new static
// field holding a reference to this new method.
ecb pushmethodreference mb  userexprfun
/**
*	generate a method to evaluate a tree of check constraints.
*
*	@param	checkconstraints	bound query tree of anded check constraints.
*	@param	ecb					expression class builder
*
*
*
* @exception standardexception		thrown on error
*/
public	methodbuilder	generatecheckconstraints
valuenode				checkconstraints
expressionclassbuilder	ecb
throws standardexception
// this sets up the method and the static field.
// generates:
// 	java.lang.object userexprfun { }
methodbuilder userexprfun   ecb newuserexprfun
// check constraint knows it is returning its value;
/* generates:
*    return <checkexpress.generate(ecb)>;
* and adds it to userexprfun
*/
checkconstraints generateexpression ecb  userexprfun
userexprfun methodreturn
// we are done modifying userexprfun, complete it.
userexprfun complete
return userexprfun
/**
*	generate the code to evaluate all of the generation clauses. if there
*	are generation clauses, this routine builds an activation method which
*	evaluates the generation clauses and fills in the computed columns.
*
* @param rcl  describes the row of expressions to be put into the bas table
* @param resultsetnumber  index of base table into array of resultsets
* @param isupdate true if this is for an update statement
* @param ecb code generation state variable
* @param mb the method being generated
*
* @exception standardexception		thrown on error
*/
public	void	generategenerationclauses
resultcolumnlist            rcl
int                                 resultsetnumber
boolean                         isupdate
expressionclassbuilder	ecb
methodbuilder			mb
throws standardexception
resultcolumn rc
int size   rcl size
boolean hasgenerationclauses   false
for  int index   0  index < size  index
rc    resultcolumn  rcl elementat index
//
// generated columns should be populated after the base row because
// the generation clauses may refer to base columns that have to be filled
// in first.
//
if   rc hasgenerationclause
hasgenerationclauses   true
break
// we generate an exprfun
// that evaluates the generation clauses
// against the current row of the child's result.
// if there are no generation clauses, simply pass null
// to optimize for run time performance.
// generate the function and initializer:
// private integer exprn()
// {
//   ...
//   return 1 or null;
// }
// static method exprn = method pointer to exprn;
// if there are not generation clauses, we just want to pass null.
if    hasgenerationclauses
mb pushnull classname generatedmethod
else
methodbuilder	userexprfun   generategenerationclauses  rcl  resultsetnumber  isupdate  ecb
// generation clause evaluation is used in the final result set
// as an access of the new static
// field holding a reference to this new method.
ecb pushmethodreference mb  userexprfun
/**
*	generate a method to compute all of the generation clauses in a row.
*
* @param rcl  describes the row of expressions to be put into the bas table
* @param rsnumber  index of base table into array of resultsets
* @param isupdate true if this is for an update statement
* @param ecb code generation state variable
*
*/
private	methodbuilder	generategenerationclauses
resultcolumnlist            rcl
int                                 rsnumber
boolean                         isupdate
expressionclassbuilder	ecb
throws standardexception
// this sets up the method and the static field.
// generates:
// 	java.lang.object userexprfun( ) { }
methodbuilder userexprfun   ecb newuserexprfun
/* declare the field and load it with the current row */
localfield field   ecb newfielddeclaration modifier private  classname execrow
userexprfun pushthis
userexprfun push  rsnumber
userexprfun callmethod vmopcode invokevirtual  classname baseactivation     classname row  1
userexprfun putfield  field
// loop through the result columns, computing generated columns
// as we go.
int     size   rcl size
int     startcolumn   0
// for updates, we only compute the updated value for the
// column. the updated value lives in the second half of the row.
// this means we ignore the first half of the row, which holds
// the before-images of the columns.
if   isupdate
// throw away the last cell in the row, which is the row id
startcolumn   size   1
startcolumn   startcolumn   2
for   int i   startcolumn  i < size  i
resultcolumn    rc    resultcolumn  rcl elementat  i
if    rc hasgenerationclause       continue
userexprfun getfield field      instance
userexprfun push i   1      arg1
rc generateexpression ecb  userexprfun
userexprfun cast classname datavaluedescriptor
userexprfun callmethod vmopcode invokeinterface  classname row        2
/* generates:
*    return;
* and adds it to userexprfun
*/
userexprfun methodreturn
// we are done modifying userexprfun, complete it.
userexprfun complete
return userexprfun
/**
* generate an optimized querytree from a bound querytree.  actually,
* it can annotate the tree in place rather than generate a new tree,
* but this interface allows the root node of the optimized querytree
* to be different from the root node of the bound querytree.
*
* for non-optimizable statements, this method is a no-op.
*
* throws an exception if the tree is not bound, or if the binding
* is out of date.
*
*
* @exception standardexception         thrown on failure
*/
public void optimizestatement   throws standardexception
/* first optimize the query */
super optimizestatement
/* in language we always set it to row lock, it's up to store to
* upgrade it to table lock.  this makes sense for the default read
* committed isolation level and update lock.  for more detail, see
* beetle 4133.
*/
lockmode   transactioncontroller mode_record
/**
* get the list of indexes that must be updated by this dml statement.
* warning: as a side effect, it creates dependencies on those indexes.
*
* @param td	the table descriptor for the table being updated
* @param updatedcolumns	the updated column list.  if not update, null
* @param colbitset			a 1 based bit set of the columns in the list
*
* @exception standardexception		thrown on error
*/
protected void getaffectedindexes
tabledescriptor		td
resultcolumnlist	updatedcolumns
formatablebitset				colbitset
throws standardexception
vector		conglomvector   new vector
dmlmodstatementnode getxaffectedindexes td  updatedcolumns  colbitset  conglomvector
markaffectedindexes  conglomvector
/**
*	marks which indexes are affected by an update of the
*	desired shape.
*
*	is passed a list of updated columns. does the following:
*
*	1)	finds all indices which overlap the updated columns
*	2)	adds the index columns to a bitmap of affected columns
*	3)	adds the index descriptors to a list of conglomerate
*		descriptors.
*
*	@param	updatedcolumns	a list of updated columns
*	@param	colbitset		out: evolving bitmap of affected columns
*	@param	conglomvector	out: vector of affected indices
*
* @exception standardexception		thrown on error
*/
static void getxaffectedindexes
tabledescriptor		basetable
resultcolumnlist	updatedcolumns
formatablebitset				colbitset
vector				conglomvector
throws standardexception
conglomeratedescriptor	cds   basetable getconglomeratedescriptors
/* we only get distinct conglomerate numbers.  if duplicate indexes
* share one conglomerate, we only return one number.
*/
long distinctconglomnums   new long
int distinctcount   0
for  int index   0  index < cds length  index
conglomeratedescriptor cd   cds
if   cd isindex      continue
/*
** if this index doesn't contain any updated
** columns, then we can skip it.
*/
if   updatedcolumns    null
updatedcolumns updateoverlaps
cd getindexdescriptor   basecolumnpositions
continue
if   conglomvector    null
int i
for  i   0  i < distinctcount  i
if  distinctconglomnums    cd getconglomeratenumber
break
if  i    distinctcount 		   first appearence
distinctconglomnums   cd getconglomeratenumber
conglomvector addelement  cd
indexrowgenerator ixd   cd getindexdescriptor
int cols   ixd basecolumnpositions
if  colbitset    null
for  int i   0  i < cols length  i
colbitset set cols
end if
end loop through conglomerates
protected	void	markaffectedindexes
vector	affectedconglomerates
throws standardexception
conglomeratedescriptor	cd
int						indexcount   affectedconglomerates size
compilercontext			cc   getcompilercontext
indicestomaintain   new indexrowgenerator
indexconglomeratenumbers   new long
indexnames   new string
for   int ictr   0  ictr < indexcount  ictr
cd    conglomeratedescriptor  affectedconglomerates elementat  ictr
indicestomaintain   cd getindexdescriptor
indexconglomeratenumbers   cd getconglomeratenumber
indexnames
cd isconstraint    ? null   cd getconglomeratename
cc createdependency cd
public string statementtostring
return
/**
* remap referenced columns in the cd to reflect the
* passed in row map.
*
* @param cd 		constraint descriptor
* @param rowmap	1 based row map
*/
private int remapreferencedcolumns constraintdescriptor cd  int rowmap
int oldcols   cd getreferencedcolumns
if  rowmap    null
return oldcols
int newcols   new int
for  int i   0  i<oldcols length  i
newcols   rowmap]
if  sanitymanager debug
sanitymanager assert newcols    0
oldcols
return newcols
/**
* get a integer based row map from a bit set.
*
* @param bitset
* @param td
*
*/
private	int getrowmap formatablebitset bitset  tabledescriptor td
throws standardexception
if  bitset    null
return  int null
int size   td getmaxcolumnid
int iarray   new int
int j   1
for  int i   1  i <  size  i
if  bitset get i
iarray   j
return iarray
public void setrefactioninfo long fkindexconglomid
intfkcolarray
string parentresultsetid
boolean dependentscan
resultset setrefactioninfo fkindexconglomid
fkcolarray
parentresultsetid
dependentscan
/**
* normalize synonym column references to have the name of the base table.
*
* @param rcl	           the result column list of the target table
* @param targettablename  the target tablename
*
* @exception standardexception		thrown on error
*/
public void normalizesynonymcolumns
resultcolumnlist    rcl
tablename           targettablename
throws standardexception
if  synonymtablename    null
return
string syntablename   synonymtablename gettablename
int	count   rcl size
for  int i   0  i < count  i
resultcolumn    column       resultcolumn  rcl elementat i
columnreference	reference   column getreference
if   reference    null
string crtablename   reference gettablename
if   crtablename    null
if   syntablename equals  crtablename
reference settablenamenode  targettablename
else
throw standardexception newexception
sqlstate lang_table_name_mismatch
syntablename
crtablename