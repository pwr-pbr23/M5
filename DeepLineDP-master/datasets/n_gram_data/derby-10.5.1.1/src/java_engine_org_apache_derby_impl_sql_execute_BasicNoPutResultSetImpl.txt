/*
derby - class org.apache.derby.impl.sql.execute.basicnoputresultsetimpl
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import java sql sqlwarning
import java sql timestamp
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services i18n messageservice
import org apache derby iapi services io formatablebitset
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi sql row
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn statementcontext
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute executionfactory
import org apache derby iapi sql execute noputresultset
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datavaluedescriptor
/**
* abstract resultset for for operations that return rows but
* do not allow the caller to put data on output pipes. this
* basic implementation does not include support for an activiation.
* see noputresultsetimpl.java for an implementaion with support for
* an activiation.
* <p>
* this abstract class does not define the entire resultset
* interface, but leaves the 'get' half of the interface
* for subtypes to implement. it is package-visible only,
* with its methods being public for exposure by its subtypes.
* <p>
*/
abstract class basicnoputresultsetimpl
implements noputresultset
/* modified during the life of this object */
protected boolean isopen
protected boolean finished
protected execrow	  currentrow
protected boolean istopresultset
private sqlwarning	warnings
/* run time statistics variables */
public int numopens
public int rowsseen
public int rowsfiltered
protected long startexecutiontime
protected long endexecutiontime
public long begintime
public long constructortime
public long opentime
public long nexttime
public long closetime
public double optimizerestimatedrowcount
public double optimizerestimatedcost
// set on demand during execution
private statementcontext			statementcontext
public noputresultset			subquerytrackingarray
execrow compactrow
// set in the constructor and not modified
protected final activation	    activation
private final boolean				statisticstimingon
private transient transactioncontroller	tc
private int basecolumnmap
/**
*  constructor.
<br>
sets begintime for all children to use to measue constructor time.
*
*	@param	activation			the activation
*	@param	optimizerestimatedrowcount	the optimizer's estimate of the
*										total number of rows for this
*										result set
*	@param	optimizerestimatedcost		the optimizer's estimated cost for
*										this result set
*/
basicnoputresultsetimpl activation activation
double optimizerestimatedrowcount
double optimizerestimatedcost
this activation   activation
if  statisticstimingon   getlanguageconnectioncontext   getstatisticstiming
begintime   startexecutiontime   getcurrenttimemillis
this optimizerestimatedrowcount   optimizerestimatedrowcount
this optimizerestimatedcost   optimizerestimatedcost
/**
* allow sub-classes to record the total
* time spent in their constructor time.
*
*/
protected final void recordconstructortime
if  statisticstimingon
constructortime   getelapsedmillis begintime
public final activation getactivation
return activation
// noputresultset interface
/**
* this is the default implementation of reopencore().
* it simply does a close() followed by an open().  if
* there are optimizations to be made (caching, etc), this
* is a good place to do it -- this will be overridden
* by a number of resultset imlementations.  and should
* be overridden by any node that can get between a base
* table and a join.
*
* @see noputresultset#opencore
* @exception standardexception thrown if cursor finished.
*/
public void reopencore   throws standardexception
close
opencore
/**
* @see noputresultset#getnextrowcore
* @exception standardexception thrown if cursor finished.
*/
public abstract execrow	getnextrowcore   throws standardexception
/**
* @see noputresultset#getpointofattachment
*/
public int getpointofattachment
if  sanitymanager debug
sanitymanager throwassert
getclass   getname
return  1
/**
* mark the resultset as the topmost one in the resultset tree.
* useful for closing down the resultset on an error.
*/
public void markastopresultset
istopresultset   true
/**
* @see noputresultset#getscanisolationlevel
*/
public int getscanisolationlevel
if  sanitymanager debug
sanitymanager throwassert
getclass   getname
return 0
/** @see noputresultset#getestimatedrowcount */
public double getestimatedrowcount
return optimizerestimatedrowcount
/**
* @see noputresultset#requiresrelocking
*/
public boolean requiresrelocking
if  sanitymanager debug
sanitymanager throwassert
getclass   getname
return false
// resultset interface
/**
* open a scan on the table. scan parameters are evaluated
* at each open, so there is probably some way of altering
* their values...
*
* note: this method should only be called on the top resultset
* of a resultset tree to ensure that the entire resultset
* tree gets closed down on an error.  the opencore() method
* will be called for all other resultsets in the tree.
*
* @exception standardexception thrown if cursor finished.
*/
public final void	open   throws standardexception
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
finished   false
attachstatementcontext
try
opencore
catch  standardexception se
activation checkstatementvalidity
throw se
activation checkstatementvalidity
/**
* returns the row at the absolute position from the query,
* and returns null when there is no such position.
* (negative position means from the end of the result set.)
* moving the cursor to an invalid position leaves the cursor
* positioned either before the first row (negative position)
* or after the last row (positive position).
* note: an exception will be thrown on 0.
*
* @param row	the position.
* @return	the row at the absolute position, or null if no such position.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getabsoluterow int row  throws standardexception
if     isopen
throw standardexception newexception sqlstate lang_result_set_not_open  absolute
attachstatementcontext
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
sanitymanager throwassert
getclass   getname
return null
/**
* returns the row at the relative position from the current
* cursor position, and returns null when there is no such position.
* (negative position means toward the beginning of the result set.)
* moving the cursor to an invalid position leaves the cursor
* positioned either before the first row (negative position)
* or after the last row (positive position).
* note: 0 is valid.
* note: an exception is thrown if the cursor is not currently
* positioned on a row.
*
* @param row	the position.
* @return	the row at the relative position, or null if no such position.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getrelativerow int row  throws standardexception
if     isopen
throw standardexception newexception sqlstate lang_result_set_not_open  relative
attachstatementcontext
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
sanitymanager throwassert
getclass   getname
return null
/**
* sets the current position to before the first row and returns null
* because there is no current row.
*
* @return	null.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	setbeforefirstrow
throws standardexception
if     isopen
throw standardexception newexception sqlstate lang_result_set_not_open  first
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
sanitymanager throwassert
getclass   getname
return null
/**
* determine if the cursor is before the first row in the result
* set.
*
* @return true if before the first row, false otherwise. returns
* false when the result set contains no rows.
*/
public boolean checkrowposition int istype  throws standardexception
return false
/**
* returns the row number of the current row.  row
* numbers start from 1 and go to 'n'.  corresponds
* to row numbering used to position current row
* in the result set (as per jdbc).
*
* @return	the row number, or 0 if not on a row
*
*/
public int getrownumber
return 0
/**
* returns the first row from the query, and returns null when there
* are no rows.
*
* @return	the first row, or null if no rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getfirstrow
throws standardexception
if     isopen
throw standardexception newexception sqlstate lang_result_set_not_open  first
attachstatementcontext
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
sanitymanager throwassert
getclass   getname
return null
/**
* return the requested values computed
* from the next row (if any) for which
* the restriction evaluates to true.
* <p>
* restriction and projection parameters
* are evaluated for each row.
*
* note: this method should only be called on the top resultset
* of a resultset tree to ensure that the entire resultset
* tree gets closed down on an error.  the getnextrowcore() method
* will be called for all other resultsets in the tree.
*
* @exception standardexception thrown on failure.
* @exception standardexception resultsetnotopen thrown if not yet open.
*
* @return the next row in the result
*/
public final execrow	getnextrow   throws standardexception
if     isopen
throw standardexception newexception sqlstate lang_result_set_not_open  next
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
attachstatementcontext
return getnextrowcore
/**
* returns the previous row from the query, and returns null when there
* are no more previous rows.
*
* @return	the previous row, or null if no more previous rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getpreviousrow
throws standardexception
if     isopen
throw standardexception newexception sqlstate lang_result_set_not_open  previous
attachstatementcontext
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
sanitymanager throwassert
return null
/**
* returns the last row from the query, and returns null when there
* are no rows.
*
* @return	the last row, or null if no rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getlastrow
throws standardexception
if     isopen
throw standardexception newexception sqlstate lang_result_set_not_open  last
attachstatementcontext
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
sanitymanager throwassert
return null
/**
* sets the current position to after the last row and returns null
* because there is no current row.
*
* @return	null.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	setafterlastrow
throws standardexception
if     isopen
throw standardexception newexception sqlstate lang_result_set_not_open  last
if  sanitymanager debug
if   istopresultset
sanitymanager throwassert
this
sanitymanager throwassert
return null
/**
* returns true.
*/
public boolean	returnsrows     return true
public final int	modifiedrowcount     return 0
/**
* clean up on error
* @exception standardexception		thrown on failure
*
*/
public void	cleanup   throws standardexception
if  isopen
close
/**
report if closed.
*/
public boolean	isclosed
return     isopen
public void	finish   throws standardexception
finishandrts
/**
* @exception standardexception on error
*/
protected final void finishandrts   throws standardexception
if   finished
if   isclosed
close
finished   true
if  istopresultset    activation issingleexecution
activation close
/* the following methods are common to almost all sub-classes.
* they are overriden in selected cases.
*/
/**
* get the execution time in milliseconds.
*
* @return long		the execution time in milliseconds.
*/
public long getexecutetime
return gettimespent resultset entire_resultset_tree
/**
* get the timestamp for the beginning of execution.
*
* @return timestamp		the timestamp for the beginning of execution.
*/
public timestamp getbeginexecutiontimestamp
if  startexecutiontime    0
return null
else
return new timestamp startexecutiontime
/**
* get the timestamp for the end of execution.
*
* @return timestamp		the timestamp for the end of execution.
*/
public timestamp getendexecutiontimestamp
if  endexecutiontime    0
return null
else
return new timestamp endexecutiontime
/**
* @see resultset#getsubquerytrackingarray
*/
public final noputresultset getsubquerytrackingarray int numsubqueries
if  subquerytrackingarray    null
subquerytrackingarray   new noputresultset
return subquerytrackingarray
/**
* return the current time in milliseconds, if debug and runtimestats is
* on, else return 0.  (only pay price of system call if need to.)
*
* @return long		current time in milliseconds.
*/
protected final long getcurrenttimemillis
if  statisticstimingon
return system currenttimemillis
else
return 0
/**
* @see resultset#getautogeneratedkeysresultset
*/
public resultset getautogeneratedkeysresultset
//a non-null resultset would be returned only for an insert statement
return  resultset null
/**
* return the elapsed time in milliseconds, between now and the begintime, if
* debug and runtimestats is on, else return 0.
* (only pay price of system call if need to.)
*
* @return long		elapsed time in milliseconds.
*/
protected final long getelapsedmillis long begintime
if  statisticstimingon
return  system currenttimemillis     begintime
else
return 0
/**
* dump out the time information for run time stats.
*
* @return nothing.
*/
protected final string dumptimestats string indent  string subindent
return
indent
messageservice gettextmessage sqlstate lang_time_spent_this
gettimespent resultset current_resultset_only
indent
messageservice gettextmessage
sqlstate lang_time_spent_this_and_below
gettimespent noputresultset entire_resultset_tree
indent
messageservice gettextmessage
sqlstate lang_total_time_breakdown
subindent
messageservice gettextmessage sqlstate lang_constructor_time
constructortime
subindent
messageservice gettextmessage sqlstate lang_open_time
opentime
subindent
messageservice gettextmessage sqlstate lang_next_time
nexttime
subindent
messageservice gettextmessage sqlstate lang_close_time
closetime
/**
*	attach this result set to the top statement context on the stack.
*	result sets can be directly read from the jdbc layer. the jdbc layer
* will push and pop a statement context around each resultset.getnext().
* there's no guarantee that the statement context used for the last
* getnext() will be the context used for the current getnext(). the
* last statement context may have been popped off the stack and so
*	will not be available for cleanup if an error occurs. to make sure
*	that we will be cleaned up, we always attach ourselves to the top
*	context.
*
*	the fun and games occur in nested contexts: using jdbc result sets inside
* user code that is itself invoked from queries or call statements.
*
*
* @exception standardexception thrown if cursor finished.
*/
protected	void	attachstatementcontext   throws standardexception
if  istopresultset
if  statementcontext    null     statementcontext onstack
statementcontext   getlanguageconnectioncontext   getstatementcontext
statementcontext settopresultset this  subquerytrackingarray
// pick up any materialized subqueries
if  subquerytrackingarray    null
subquerytrackingarray   statementcontext getsubquerytrackingarray
statementcontext setactivation activation
/**
*	cache the language connection context. return it.
*
*	@return	the language connection context
*/
protected	final languageconnectioncontext	getlanguageconnectioncontext
return getactivation   getlanguageconnectioncontext
/** @see noputresultset#resultsetnumber() */
public int resultsetnumber
if  sanitymanager debug
sanitymanager throwassert
this getclass   getname
return 0
//////////////////////////////////////////////////////
//
// utils
//
//////////////////////////////////////////////////////
/**
* get a execution factory
*
* @return the execution factory
*/
final executionfactory getexecutionfactory
return activation getexecutionfactory
/**
* get the current transaction controller.
*
*/
final transactioncontroller gettransactioncontroller
if  tc    null
tc   getlanguageconnectioncontext   gettransactionexecute
return tc
/**
* get a compacted version of the candidate row according to the
* columns specified in the bit map. share the holders between rows.
* if there is no bit map, use the candidate row as the compact row.
*
* also, create an array of ints mapping base column positions to
* compact column positions, to make it cheaper to copy columns to
* the compact row, if we ever have to do it again.
*
* @param candidate		the row to get the columns from
* @param accessedcols	a bit map of the columns that are accessed in
*						the candidate row
* @param iskeyed		tells whether to return a valuerow or an indexrow
*
* @return		a compact row.
*/
protected execrow getcompactrow execrow candidate
formatablebitset accessedcols
boolean iskeyed
throws standardexception
int		numcandidatecols   candidate ncolumns
if  accessedcols    null
compactrow    candidate
basecolumnmap   new int
for  int i   0  i < basecolumnmap length  i
basecolumnmap   i
else
int numcols   accessedcols getnumbitsset
basecolumnmap   new int
if  compactrow    null
executionfactory ex   getlanguageconnectioncontext   getlanguageconnectionfactory   getexecutionfactory
if  iskeyed
compactrow   ex getindexablerow numcols
else
compactrow   ex getvaluerow numcols
int position   0
for  int i   accessedcols anysetbit
i     1
i   accessedcols anysetbit i
// stop looking if there are columns beyond the columns
// in the candidate row. this can happen due to the
// othercols bit map.
if  i >  numcandidatecols
break
datavaluedescriptor sc   candidate getcolumn i 1
if  sc    null
compactrow setcolumn
position   1
sc
basecolumnmap   i
position
return compactrow
/**
* copy columns from the candidate row from the store to the given
* compact row. if there is no column map, just use the candidate row.
*
* this method assumes the above method (getcompactrow()) was called
* first. getcompactrow() sets up the basecolumnmap.
*
* @param candidaterow	the candidate row from the store
* @param compactrow	the compact row to fill in
*
* @return	the compact row to use
*/
protected execrow setcompactrow execrow candidaterow  execrow compactrow
execrow	retval
//system.out.println("base col map " + basecolumnmap);
if  basecolumnmap    null
retval   candidaterow
else
retval   compactrow
setcompatrow compactrow  candidaterow getrowarray
return retval
protected final void setcompatrow execrow compactrow  datavaluedescriptor sourcerow
datavaluedescriptor destrow   compactrow getrowarray
int lbcm   basecolumnmap
for  int i   0  i < lbcm length  i
destrow   sourcerow]
/**
* is this resultset or it's source result set for update
* this method will be overriden in the inherited classes
* if it is true
* @return whether or not the result set is for update.
*/
public boolean isforupdate
return false
/**
* checks whether the currently executing statement has been cancelled.
* this is done by checking the statement's allocated statementcontext
* object.
*
* @see statementcontext
*/
public void checkcancellationflag
throws
standardexception
statementcontext localstatementcontext   getlanguageconnectioncontext   getstatementcontext
if  localstatementcontext    null
return
if  localstatementcontext iscancelled
throw standardexception newexception sqlstate lang_statement_cancelled_or_timed_out
protected final void addwarning sqlwarning w
if  istopresultset
if  warnings    null
warnings   w
else
warnings setnextwarning w
return
if  activation    null
resultset rs   activation getresultset
if  rs instanceof basicnoputresultsetimpl
basicnoputresultsetimpl  rs  addwarning w
public final sqlwarning getwarnings
sqlwarning w   warnings
warnings   null
return w