/*
derby - class org.apache.derby.client.am.preparedstatement
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client am
import org apache derby shared common reference jdbc40translation
import org apache derby shared common reference sqlstate
import org apache derby iapi services sanity sanitymanager
import java io inputstream
import java io reader
import java sql sqlexception
import java util arraylist
import java util arrays
import org apache derby client clientpooledconnection
import org apache derby jdbc clientdriver
public class preparedstatement extends statement
implements java sql preparedstatement
preparedstatementcallbackinterface
//---------------------navigational cheat-links-------------------------------
// cheat-links are for convenience only, and are not part of the conceptual model.
// warning:
//   cheat-links should only be defined for invariant state data.
//   that is, the state data is set by the constructor and never changes.
// alias for downcast (materialpreparedstatementproxy) super.materialstatement.
public materialpreparedstatement materialpreparedstatement_   null
//-----------------------------state------------------------------------------
public string sql_
// this variable is only used by batch.
// true if a call sql statement has an out or inout parameter registered.
public boolean outputregistered_   false
// parameter inputs are cached as objects so they may be sent on execute()
public object parameters_
boolean parameterset_
boolean parameterregistered_
void setinput int parameterindex  object input
parameters_   input
parameterset_   true
}
public columnmetadata parametermetadata_     type information for input sqlda
private arraylist parametertypelist
// the problem with storing the scrollable resultset associated with cursorname in scrollablers_ is
// that when the preparedstatement is re-executed, it has a new resultset, however, we always do
// the reposition on the resultset that was stored in scrollablers_, and we never update scrollablers_
// when preparedstatement is re-execute.  so the new resultset that needs to be repositioned never
// gets repositioned.
// so instead of caching the scrollablers_, we will cache the cursorname.  and re-retrieve the scrollable
// result set from the map using this cursorname every time the preparedstatement excutes.
string positionedupdatecursorname_   null
// the clientpooledconnection object used to notify of the events that occur
// on this prepared statement object
protected final clientpooledconnection pooledconnection_
private void initpreparedstatement
materialpreparedstatement_   null
sql_   null
outputregistered_   false
parameters_   null
parameterset_   null
parameterregistered_   null
parametermetadata_   null
parametertypelist   null
isautocommittablestatement_   true
ispreparedstatement_   true
}
protected void initresetpreparedstatement
outputregistered_   false
ispreparedstatement_   true
resetparameters
}
public void reset boolean fullreset  throws sqlexception
if  fullreset
connection_ resetpreparestatement this
else
super initresetpreparedstatement
initresetpreparedstatement
}
}
/**
* resets the prepared statement for reuse in a statement pool.
*
* @throws sqlexception if the reset fails
* @see statement#resetforreuse
*/
void resetforreuse
throws sqlexception
resetparameters
super resetforreuse
}
private void resetparameters
if  parametermetadata_    null
arrays fill parameters_  null
arrays fill parameterset_  false
arrays fill parameterregistered_  false
}
}
/**
*
* the preparedstatement constructor used for jdbc 2 positioned update
* statements. called by material statement constructors.
* it has the clientpooledconnection as one of its parameters
* this is used to raise the statement events when the prepared
* statement is closed
*
* @param agent the instance of netagent associated with this
*              callablestatement object.
* @param connection the connection object associated with this
*                   preparedstatement object.
* @param sql        a string object that is the sql statement to be sent
*                   to the database.
* @param section    section
* @param cpc the clientpooledconnection wraps the underlying physical
*            connection associated with this prepared statement.
*            it is used to pass the statement closed and the statement
*            error occurred events that occur back to the
*            clientpooledconnection.
* @throws sqlexception
*
*/
public preparedstatement agent agent
connection connection
string sql
section section clientpooledconnection cpc
throws sqlexception
super agent  connection
// preparedstatement is poolable by default
ispoolable   true
initpreparedstatement sql  section
pooledconnection_   cpc
}
public void resetpreparedstatement agent agent
connection connection
string sql
section section  throws sqlexception
super resetstatement agent  connection
initpreparedstatement
initpreparedstatement sql  section
}
private void initpreparedstatement string sql  section section  throws sqlexception
sql_   sql
ispreparedstatement_   true
parsesqlandsetsqlmodes sql_
section_   section
}
/**
* the preparedstatementconstructor used for jdbc 2 prepared statements
* with scroll attributes. called by material statement constructors.
* it has the clientpooledconnection as one of its parameters
* this is used to raise the statement events when the prepared
* statement is closed
*
* @param agent the instance of netagent associated with this
*              callablestatement object.
* @param connection  the connection object associated with this
*                    preparedstatement object.
* @param sql         a string object that is the sql statement
*                    to be sent to the database.
* @param type        one of the resultset type constants.
* @param concurrency one of the resultset concurrency constants.
* @param holdability one of the resultset holdability constants.
* @param autogeneratedkeys a flag indicating whether auto-generated
*                          keys should be returned.
* @param columnnames an array of column names indicating the columns that
*                    should be returned from the inserted row or rows.
* @param columnindexes an array of column names indicating the columns that
*                   should be returned from the inserted row.
* @param cpc the clientpooledconnection wraps the underlying physical
*            connection associated with this prepared statement
*            it is used to pass the statement closed and the statement
*            error occurred events that occur back to the
*            clientpooledconnection.
* @throws sqlexception
*/
public preparedstatement agent agent
connection connection
string sql
int type  int concurrency  int holdability
int autogeneratedkeys  string columnnames
int columnindexes
clientpooledconnection cpc
throws sqlexception
super agent  connection  type  concurrency  holdability
autogeneratedkeys  columnnames  columnindexes
// preparedstatement is poolable by default
ispoolable   true
initpreparedstatement sql
pooledconnection_   cpc
}
public void resetpreparedstatement agent agent
connection connection
string sql
int type  int concurrency  int holdability  int autogeneratedkeys  string columnnames
int columnindexes  throws sqlexception
super resetstatement agent  connection  type  concurrency  holdability  autogeneratedkeys
columnnames  columnindexes
initpreparedstatement
initpreparedstatement sql
}
private void initpreparedstatement string sql  throws sqlexception
sql_   super escape sql
parsesqlandsetsqlmodes sql_
ispreparedstatement_   true
// check for positioned update statement and assign a section from the
// same package as the corresponding query section.
// scan the sql for an "update...where current of <cursor-name>".
string cursorname   null
if  sqlupdatemode_    isdeletesql__    sqlupdatemode_    isupdatesql__
string sqlandcursorname   extractcursornamefromwherecurrentof sql_
if  sqlandcursorname    null
cursorname   sqlandcursorname
sql_   sqlandcursorname
}
}
if  cursorname    null
positionedupdatecursorname_   cursorname
// get a new section from the same package as the query section
section_   agent_ sectionmanager_ getpositionedupdatesection cursorname  false      false means get a regular section
if  section_    null
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate cursor_invalid_cursor_name   cursorname
}
//scrollablers_ = agent_.sectionmanager_.getpositionedupdateresultset (cursorname);
// if client's cursor name is set, and the cursor name in the positioned update
// string is the same as the client's cursor name, replace client's cursor name
// with the server's cursor name.
// if the cursor name supplied in the sql string is different from the cursorname
// set by setcursorname(), then server will return "cursor name not defined" error,
// and no subsititution is made here.
if  section_ getclientcursorname      null       cursor name is user defined
cursorname compareto section_ getclientcursorname       0
// client's cursor name is substituted with section's server cursor name
sql_   substituteclientcursornamewithservercursorname sql_  section_
}
else
// we don't need to analyze the sql text to determine if it is a query or not.
// this is up to the server to decide, we just pass thru the sql on flowprepare().
section_   agent_ sectionmanager_ getdynamicsection resultsetholdability_
}
}
public void resetpreparedstatement agent agent
connection connection
string sql
section section
columnmetadata parametermetadata
columnmetadata resultsetmetadata  throws sqlexception
resetpreparedstatement agent  connection  sql  section
initpreparedstatement parametermetadata  resultsetmetadata
}
private void initpreparedstatement columnmetadata parametermetadata
columnmetadata resultsetmetadata  throws sqlexception
ispreparedstatement_   true
parametermetadata_   parametermetadata
resultsetmetadata_   resultsetmetadata
if  parametermetadata_    null
parameters_   new object
//parametersetorregistered_ = new boolean[parametermetadata_.columns_];
parameterset_   new boolean
parameterregistered_   new boolean
}
}
// called immediately after the constructor by connection prepare*() methods
void prepare   throws sqlexception
try
// flow prepare, no static initialization is needed
flowpreparedescribeinputoutput
catch  sqlexception e
this markclosed
throw e
}
}
//------------------- prohibited overrides from statement --------------------
public boolean execute string sql  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
public java sql resultset executequery string sql  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
public int executeupdate string sql  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
// ---------------------------jdbc 1------------------------------------------
public java sql resultset executequery   throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
}
resultset resultset   executequeryx
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     resultset
}
return resultset
}
}
catch   sqlexception se
checkstatementvalidity se
throw se getsqlexception
}
}
// also called by some dbmd methods
resultset executequeryx   throws sqlexception
flowexecute executequerymethod__
return resultset_
}
public int executeupdate   throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
}
int updatevalue   executeupdatex
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     updatevalue
}
return updatevalue
}
}
catch   sqlexception se
checkstatementvalidity se
throw se getsqlexception
}
}
private int executeupdatex   throws sqlexception
flowexecute executeupdatemethod__
return updatecount_
}
public void setnull int parameterindex  int jdbctype  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  jdbctype
}
checkforclosedstatement
// jdbc 4.0 requires us to throw
// sqlfeaturenotsupportedexception for certain target types if
// they are not supported. check for these types before
// checking type compatibility.
checkforsupporteddatatype jdbctype
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes getpossibletypesfornull  paramtype   checktype  jdbctype
//this exception mimic embedded behavior.
//see http://issues.apache.org/jira/browse/derby-1610#action_12432568
possibletypes throw22005exception agent_ logwriter_
jdbctype
paramtype
}
setnullx parameterindex  jdbctype
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// also used by dbmd methods
void setnullx int parameterindex  int jdbctype  throws sqlexception
parametermetadata_ clientparamtertype_   jdbctype
if   parametermetadata_ nullable_
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate lang_null_into_non_null
new integer parameterindex
}
setinput parameterindex  null
}
public void setnull int parameterindex  int jdbctype  string typename  throws sqlexception
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex
jdbctype  typename
}
setnull parameterindex  jdbctype
}
}
public void setboolean int parameterindex  boolean x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_generic_scalar checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types boolean
paramtype
}
parametermetadata_ clientparamtertype_   java sql types bit
setinput parameterindex  new short  short   x ? 1   0
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setbyte int parameterindex  byte x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_generic_scalar checktype  paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types tinyint
paramtype
}
parametermetadata_ clientparamtertype_   java sql types tinyint
setinput parameterindex  new short x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setshort int parameterindex  short x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_generic_scalar checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types smallint
paramtype
}
setshortx parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// also used by dbmd methods
void setshortx int parameterindex  short x  throws sqlexception
parametermetadata_ clientparamtertype_   java sql types smallint
setinput parameterindex  new short x
}
public void setint int parameterindex  int x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_generic_scalar checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types integer
paramtype
}
setintx parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// also used by dbmd methods
void setintx int parameterindex  int x  throws sqlexception
parametermetadata_ clientparamtertype_   java sql types integer
setinput parameterindex  new integer x
}
public void setlong int parameterindex  long x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_generic_scalar checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types integer
paramtype
}
setlongx parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
void setlongx final int parameterindex  final long x
// column numbers starts at 1, clientparamtertype_[0] refers to column 1
parametermetadata_ clientparamtertype_
java sql types bigint
setinput parameterindex  new long x
}
public void setfloat int parameterindex  float x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_generic_scalar checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types float
paramtype
}
parametermetadata_ clientparamtertype_   java sql types real
setinput parameterindex  new float x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setdouble int parameterindex  double x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_generic_scalar checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types double
paramtype
}
parametermetadata_ clientparamtertype_   java sql types double
setinput parameterindex  new double x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setbigdecimal int parameterindex  java math bigdecimal x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_generic_scalar checktype  paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types bigint
paramtype
}
parametermetadata_ clientparamtertype_   java sql types decimal
if  x    null
setnull parameterindex  java sql types decimal
return
}
int registeroutscale   0
setinput parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setdate int parameterindex  java sql date x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_date checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types date
paramtype
}
checkforclosedstatement
parametermetadata_ clientparamtertype_   java sql types date
if  x    null
setnull parameterindex  java sql types date
return
}
setinput parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setdate int parameterindex
java sql date x
java util calendar calendar  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x  calendar
}
checkforclosedstatement
if  calendar    null
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate invalid_api_parameter
}
java util calendar targetcalendar   java util calendar getinstance calendar gettimezone
targetcalendar clear
targetcalendar settime x
java util calendar defaultcalendar   java util calendar getinstance
defaultcalendar clear
defaultcalendar settime x
long timezoneoffset
targetcalendar get java util calendar zone_offset    defaultcalendar get java util calendar zone_offset
targetcalendar get java util calendar dst_offset    defaultcalendar get java util calendar dst_offset
java sql date adjusteddate     timezoneoffset    0      x    null   ? x   new java sql date x gettime     timezoneoffset
setdate parameterindex  adjusteddate
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void settime int parameterindex  java sql time x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_time checktype  paramtype
possibletypes throw22005exception  agent_ logwriter_
java sql types time
paramtype
}
parametermetadata_ clientparamtertype_   java sql types time
if  x    null
setnull parameterindex  java sql types time
return
}
setinput parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void settime int parameterindex
java sql time x
java util calendar calendar  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x  calendar
}
checkforclosedstatement
if  calendar    null
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate invalid_api_parameter
}
java util calendar targetcalendar   java util calendar getinstance calendar gettimezone
targetcalendar clear
targetcalendar settime x
java util calendar defaultcalendar   java util calendar getinstance
defaultcalendar clear
defaultcalendar settime x
long timezoneoffset
targetcalendar get java util calendar zone_offset    defaultcalendar get java util calendar zone_offset
targetcalendar get java util calendar dst_offset    defaultcalendar get java util calendar dst_offset
java sql time adjustedtime     timezoneoffset    0      x    null   ? x   new java sql time x gettime     timezoneoffset
settime parameterindex  adjustedtime
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void settimestamp int parameterindex  java sql timestamp x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_timestamp checktype  paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types timestamp
paramtype
}
parametermetadata_ clientparamtertype_   java sql types timestamp
if  x    null
setnull parameterindex  java sql types timestamp
return
}
setinput parameterindex  x
// once the nanosecond field of timestamp is trim to microsecond for derby, should we throw a warning
//if (getparametertype (parameterindex) == java.sql.types.timestamp && x.getnanos() % 1000 != 0)
//  accumulatewarning (new sqlwarning (agent_.logwriter_, "derby timestamp can only store up to microsecond, conversion from nanosecond to microsecond causes rounding."));
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void settimestamp int parameterindex
java sql timestamp x
java util calendar calendar  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x  calendar
}
checkforclosedstatement
if  calendar    null
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate invalid_api_parameter
}
java util calendar targetcalendar   java util calendar getinstance calendar gettimezone
targetcalendar clear
targetcalendar settime x
java util calendar defaultcalendar   java util calendar getinstance
defaultcalendar clear
defaultcalendar settime x
long timezoneoffset
targetcalendar get java util calendar zone_offset    defaultcalendar get java util calendar zone_offset
targetcalendar get java util calendar dst_offset    defaultcalendar get java util calendar dst_offset
java sql timestamp adjustedtimestamp     timezoneoffset    0      x    null   ? x   new java sql timestamp x gettime     timezoneoffset
if  x    null
adjustedtimestamp setnanos x getnanos
}
settimestamp parameterindex  adjustedtimestamp
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setstring int parameterindex  string x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_string checktype  paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types varchar
paramtype
}
setstringx parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// also used by dbmd methods
void setstringx int parameterindex  string x  throws sqlexception
parametermetadata_ clientparamtertype_   java sql types longvarchar
if  x    null
setnullx parameterindex  java sql types longvarchar
return
}
setinput parameterindex  x
}
public void setbytes int parameterindex  byte x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
final int paramtype
getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_bytes checktype  paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types varbinary
paramtype
}
setbytesx parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// also used by blob
public void setbytesx int parameterindex  byte x  throws sqlexception
parametermetadata_ clientparamtertype_   java sql types longvarbinary
if  x    null
setnullx parameterindex  java sql types longvarbinary
return
}
setinput parameterindex  x
}
/**
* sets the parameter to the  binary stream object
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the binary parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public void setbinarystream int parameterindex
java io inputstream x
long length  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex     new long length
}
checktypeforsetbinarystream parameterindex
checkstreamlength length
setbinarystreamx parameterindex  x   int length
}
}
catch   sqlexception se
throw se getsqlexception
}
}
/**
* sets the parameter to the  binary stream object
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the binary parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public void setbinarystream int parameterindex
java io inputstream x
int length  throws sqlexception
setbinarystream parameterindex x  long length
}
protected void setbinarystreamx int parameterindex
java io inputstream x
int length  throws sqlexception
parametermetadata_ clientparamtertype_   java sql types blob
if  x    null
setnullx parameterindex  java sql types blob
return
}
blob blob
if  length     1
// create a blob of unknown length. this might cause an
// outofmemoryerror due to the temporary implementation in blob.
// the whole stream will be materialzied. see comments in blob.
blob   new blob agent_  x
else
blob   new blob agent_  x  length
}
setinput parameterindex  blob
}
/**
* we do this inefficiently and read it all in here. the target type
* is assumed to be a string.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the ascii parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public void setasciistream int parameterindex
java io inputstream x
long length  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
parameterindex     new long length
}
checktypeforsetasciistream parameterindex
parametermetadata_ clientparamtertype_   java sql types clob
if  x    null
setnull parameterindex  java sql types longvarchar
return
}
checkstreamlength length
setinput parameterindex  new clob agent_  x      int length
}
}
catch   sqlexception se
throw se getsqlexception
}
}
/**
* we do this inefficiently and read it all in here. the target type
* is assumed to be a string.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the ascii parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public void setasciistream int parameterindex
java io inputstream x
int length  throws sqlexception
setasciistream parameterindex x  long length
}
/**
* check the length passed in for the stream that is to be set. if length is
* larger than integer.max_value or smaller that 0, we fail by throwing an
* sqlexception.
* @param length the length of the stream being set
* @throws sqlexception thrown for a negative or too large length.
*/
private void checkstreamlength long length  throws sqlexception
if length > integer max_value
throw new sqlexception
agent_ logwriter_
new clientmessageid
sqlstate client_length_outside_range_for_datatype
new long length
new integer integer max_value
getsqlexception
else if  length < 0
throw new sqlexception
agent_ logwriter_
new clientmessageid sqlstate negative_stream_length
getsqlexception
}
}
private void checktypeforsetasciistream int parameterindex
throws sqlexception  sqlexception
int paramtype   getcolumnmetadatax   getcolumntype parameterindex
if     possibletypes possible_types_in_set_asciistream checktype  paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types longvarchar
paramtype
}
}
private void checktypeforsetbinarystream int parameterindex
throws sqlexception  sqlexception
int paramtype   getcolumnmetadatax   getcolumntype parameterindex
if   possibletypes possible_types_in_set_binarystream
checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types varbinary
paramtype
}
}
private void checktypeforsetcharacterstream int parameterindex
throws sqlexception  sqlexception
int paramtype   getcolumnmetadatax   getcolumntype parameterindex
if   possibletypes possible_types_in_set_characterstream
checktype paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types longvarchar
paramtype
}
}
private void checktypeforsetblob int parameterindex
throws sqlexception  sqlexception
int paramtype   getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_blob checktype  paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types blob
paramtype
}
}
private void checktypeforsetclob int parameterindex
throws sqlexception  sqlexception
int paramtype   getcolumnmetadatax   getcolumntype parameterindex
if    possibletypes possible_types_in_set_clob checktype  paramtype
possibletypes throw22005exception agent_ logwriter_
java sql types clob
paramtype
}
}
/**
* sets the specified parameter to the given input stream. deprecated
* in jdbc 3.0 and this method will always just throw a feature not
* implemented exception.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the unicode parameter
* value
* @param length the number of bytes in the stream
* @exception sqlexception throws feature not implemented.
* @deprecated
*/
public void setunicodestream int parameterindex
java io inputstream x
int length  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ tracedeprecatedentry this
parameterindex
length
}
throw sqlexceptionfactory notimplemented
}
/**
* sets the designated parameter to the given <code>reader</code> object.
* when a very large unicode value is input to a longvarchar parameter, it
* may be more practical to send it via a <code>java.io.reader</code>
* object. the data will be read from the stream as needed until
* end-of-file is reached. the jdbc driver will do any necessary conversion
* from unicode to the database char format.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the <code>java.io.reader</code> object that contains the
*      unicode data
* @throws sqlexception if a database access error occurs or this method is
*      called on a closed <code>preparedstatement</code>
*/
public void setcharacterstream int parameterindex  reader x
throws sqlexception
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
parameterindex  x
}
try
checktypeforsetcharacterstream parameterindex
parametermetadata_ clientparamtertype_
java sql types clob
if  x    null
setnull parameterindex  java sql types longvarchar
return
}
setinput parameterindex  new clob agent_  x
catch  sqlexception se
throw se getsqlexception
}
}
}
/**
* sets the designated parameter to the given reader, which will have
* the specified number of bytes.
*
* @param parameterindex the index of the parameter to which this set
*                       method is applied
* @param x the java reader which contains the unicode value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*
*/
public void setcharacterstream int parameterindex
java io reader x
long length  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x  new long length
}
checktypeforsetcharacterstream parameterindex
parametermetadata_ clientparamtertype_   java sql types clob
if  x    null
setnull parameterindex  java sql types longvarchar
return
}
checkstreamlength length
setinput parameterindex  new clob agent_  x   int length
}
}
catch   sqlexception se
throw se getsqlexception
}
}
/**
* sets the designated parameter to the given reader, which will have
* the specified number of bytes.
*
* @param parameterindex the index of the parameter to which this
*                       set method is applied
* @param x the java reader which contains the unicode value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*
*/
public void setcharacterstream int parameterindex
java io reader x
int length  throws sqlexception
setcharacterstream parameterindex x  long length
}
public void setblob int parameterindex  java sql blob x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
checktypeforsetblob parameterindex
setblobx parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// also used by blob
public void setblobx int parameterindex  java sql blob x  throws sqlexception
parametermetadata_ clientparamtertype_   java sql types blob
if  x    null
setnullx parameterindex  java sql types blob
return
}
setinput parameterindex  x
}
public void setclob int parameterindex  java sql clob x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
checktypeforsetclob parameterindex
setclobx parameterindex  x
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// also used by clob
void setclobx int parameterindex  java sql clob x  throws sqlexception
parametermetadata_ clientparamtertype_   java sql types clob
if  x    null
this setnullx parameterindex  types clob
return
}
setinput parameterindex  x
}
public void setarray int parameterindex  java sql array x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate jdbc_method_not_implemented
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setref int parameterindex  java sql ref x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate jdbc_method_not_implemented
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// the java compiler uses static binding, so we must use instanceof
// rather than to rely on separate setobject() methods for
// each of the java object instance types recognized below.
public void setobject int parameterindex  object x  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
if  x instanceof string
setstring parameterindex   string  x
else if  x instanceof integer
setint parameterindex    integer  x  intvalue
else if  x instanceof double
setdouble parameterindex    double  x  doublevalue
else if  x instanceof float
setfloat parameterindex    float  x  floatvalue
else if  x instanceof boolean
setboolean parameterindex    boolean  x  booleanvalue
else if  x instanceof long
setlong parameterindex    long  x  longvalue
else if  x instanceof byte
setbytes parameterindex   byte  x
else if  x instanceof java math bigdecimal
setbigdecimal parameterindex   java math bigdecimal  x
else if  x instanceof java sql date
setdate parameterindex   java sql date  x
else if  x instanceof java sql time
settime parameterindex   java sql time  x
else if  x instanceof java sql timestamp
settimestamp parameterindex   java sql timestamp  x
else if  x instanceof java sql blob
setblob parameterindex   java sql blob  x
else if  x instanceof java sql clob
setclob parameterindex   java sql clob  x
else if  x instanceof java sql array
setarray parameterindex   java sql array  x
else if  x instanceof java sql ref
setref parameterindex   java sql ref  x
else if  x instanceof short
setshort parameterindex    short  x  shortvalue
else if  x instanceof byte
setbyte parameterindex    byte  x  bytevalue
else
checkforclosedstatement
checkforvalidparameterindex parameterindex
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate unsupported_type
}
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setobject int parameterindex  object x  int targetjdbctype  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x  targetjdbctype
}
checkforclosedstatement
setobjectx parameterindex  x  targetjdbctype  0
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public void setobject int parameterindex
object x
int targetjdbctype
int scale  throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x  targetjdbctype  scale
}
checkforclosedstatement
setobjectx parameterindex  x  targetjdbctype  scale
}
}
catch   sqlexception se
throw se getsqlexception
}
}
private void setobjectx int parameterindex
object x
int targetjdbctype
int scale  throws sqlexception
checkforvalidparameterindex parameterindex
checkforvalidscale scale
// jdbc 4.0 requires us to throw sqlfeaturenotsupportedexception for
// certain target types if they are not supported.
checkforsupporteddatatype targetjdbctype
if  x    null
setnullx parameterindex  targetjdbctype
return
}
// jdbc spec specifies that conversion should occur on the client if
// the targetjdbctype is specified.
int inputparametertype   crossconverters getinputjdbctype targetjdbctype
parametermetadata_ clientparamtertype_   inputparametertype
x   agent_ crossconverters_ setobject inputparametertype  x
// set to round down on setscale like embedded does in sqldecimal
try
if  targetjdbctype    java sql types decimal    targetjdbctype    java sql types numeric
x     java math bigdecimal  x  setscale scale  java math bigdecimal round_down
}
catch  arithmeticexception ae
// any problems with scale should have already been caught by
// checkforvalidscale
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate java_exception
new object  ae getclass   getname    ae getmessage     ae
}
try
setobject parameterindex  x
catch   sqlexception se
throw new sqlexception se
}
}
// since parameters are cached as objects in parameters_[],
// java null may be used to represent sql null.
public void clearparameters   throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
}
checkforclosedstatement
if  parametermetadata_    null
arrays fill parameters_  null
arrays fill parameterset_  false
}
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public boolean execute   throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
}
boolean b   executex
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     b
}
return b
}
}
catch   sqlexception se
checkstatementvalidity se
throw se getsqlexception
}
}
// also used by sqlca
boolean executex   throws sqlexception
flowexecute executemethod__
return resultset_    null
}
//--------------------------jdbc 2.0-----------------------------
public void addbatch   throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
}
checkforclosedstatement
checkthatallparametersareset
if  parametertypelist    null
parametertypelist   new arraylist
}
// assert: since out/inout parameters are not allowed, there should
//         be no problem in sharing the jdbc wrapper object instances
//         since they will not be modified by the driver.
// batch up the parameter values -- deep copy req'd
if  parametermetadata_    null
object inputsclone   new object
system arraycopy parameters_  0  inputsclone  0  parameters_ length
batch_ add inputsclone
// get a copy of the parameter type data and save it in a list
// which will be used later on at the time of batch execution.
parametertypelist add parametermetadata_ clientparamtertype_ clone
else
batch_ add null
parametertypelist add null
}
}
}
catch   sqlexception se
throw se getsqlexception
}
}
// batch requires that input types are exact, we perform no input cross conversion for batch.
// if so, this is an external semantic, and should go into the release notes
public int executebatch   throws sqlexception  batchupdateexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
}
int updatecounts   null
updatecounts   executebatchx false
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     updatecounts
}
return updatecounts
}
}
catch   sqlexception se
throw se getsqlexception
}
}
public java sql resultsetmetadata getmetadata   throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
}
columnmetadata resultsetmetadata   getmetadatax
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     resultsetmetadata
}
return resultsetmetadata
}
}
catch   sqlexception se
throw se getsqlexception
}
}
private columnmetadata getmetadatax   throws sqlexception
super checkforclosedstatement
return resultsetmetadata_
}
//------------------------- jdbc 3.0 -----------------------------------
public boolean execute string sql  int autogeneratedkeys  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  autogeneratedkeys
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
public boolean execute string sql  string columnnames  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  columnnames
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
public boolean execute string sql  int columnindexes  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  columnindexes
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
public int executeupdate string sql  int autogeneratedkeys  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     autogeneratedkeys
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
public int executeupdate string sql  string columnnames  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     columnnames
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
public int executeupdate string sql  int columnindexes  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     columnindexes
}
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate not_for_prepared_statement
getsqlexception
}
public void seturl int parameterindex  java net url x  throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex  x
}
jdbc3featurenotsupported false
}
public java sql parametermetadata getparametermetadata   throws sqlexception
try
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
}
object parametermetadata   getparametermetadatax
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     parametermetadata
}
return  java sql parametermetadata  parametermetadata
}
}
catch   sqlexception se
throw se getsqlexception
}
}
private parametermetadata getparametermetadatax   throws sqlexception
parametermetadata pm   clientdriver getfactory   newparametermetadata
getcolumnmetadatax
return pm
}
private columnmetadata getcolumnmetadatax   throws sqlexception
checkforclosedstatement
return
parametermetadata_    null ?
parametermetadata_
clientdriver getfactory   newcolumnmetadata agent_ logwriter_  0
}
// ------------------------ box car and callback methods --------------------------------
public void writeexecute section section
columnmetadata parametermetadata
object inputs
int numinputcolumns
boolean outputexpected
// this is a hint to the material layer that more write commands will follow.
// it is ignored by the driver in all cases except when blob data is written,
// in which case this boolean is used to optimize the implementation.
// otherwise we wouldn't be able to chain after blob data is sent.
// current servers have a restriction that blobs can only be chained with blobs
boolean chainedwritesfollowingsetlob  throws sqlexception
materialpreparedstatement_ writeexecute_ section
parametermetadata
inputs
numinputcolumns
outputexpected
chainedwritesfollowingsetlob
}
public void readexecute   throws sqlexception
materialpreparedstatement_ readexecute_
}
private void writeopenquery section section
int fetchsize
int resultsettype
int numinputcolumns
columnmetadata parametermetadata
object inputs  throws sqlexception
materialpreparedstatement_ writeopenquery_ section
fetchsize
resultsettype
numinputcolumns
parametermetadata
inputs
}
public void writedescribeinput section section  throws sqlexception
materialpreparedstatement_ writedescribeinput_ section
}
public void readdescribeinput   throws sqlexception
materialpreparedstatement_ readdescribeinput_
}
public void completedescribeinput columnmetadata parametermetadata  sqlca sqlca
int sqlcode   super completesqlca sqlca
if  sqlcode < 0
return
}
parametermetadata_   parametermetadata
// the following code handles the case when
// sqlxparmmode is not supported, in which case server will return 0 (unknown), and
// this could clobber our guessed value for sqlxparmmode.  this is a problem.
// we can solve this problem for non-call statements, since the parmmode is always in (1).
// but what about call statements.  if calls are describable, then we have no
// problem, we assume server won't return unknown.
// if calls are not describable then nothing gets clobbered because we won't
// parse out extended describe, so again  no problem.
if  sqlmode_    iscall__    parametermetadata_    null
// 1 means in parameter
arrays fill parametermetadata_ sqlxparmmode_   short 1
}
if  agent_ loggingenabled
agent_ logwriter_ traceparametermetadata this  parametermetadata_
}
}
public void writedescribeoutput section section  throws sqlexception
materialpreparedstatement_ writedescribeoutput_ section
}
public void readdescribeoutput   throws sqlexception
materialpreparedstatement_ readdescribeoutput_
}
public void completedescribeoutput columnmetadata resultsetmetadata  sqlca sqlca
int sqlcode   super completesqlca sqlca
if  sqlcode < 0
return
}
resultsetmetadata_   resultsetmetadata
if  agent_ loggingenabled
agent_ logwriter_ traceresultsetmetadata this  resultsetmetadata
}
}
void writepreparedescribeinputoutput   throws sqlexception
// notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
writepreparedescribeoutput sql_  section_
writedescribeinput section_
}
void readpreparedescribeinputoutput   throws sqlexception
readpreparedescribeoutput
readdescribeinput
completepreparedescribe
}
void writepreparedescribeinput   throws sqlexception
// performance will be better if we flow prepare with output enable vs. prepare then describe input for callable
// notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
writeprepare sql_  section_
writedescribeinput section_
}
void readpreparedescribeinput   throws sqlexception
readprepare
readdescribeinput
completepreparedescribe
}
void completepreparedescribe
if  parametermetadata_    null
return
}
parameters_   expandobjectarray parameters_  parametermetadata_ columns_
parameterset_   expandbooleanarray parameterset_  parametermetadata_ columns_
parameterregistered_   expandbooleanarray parameterregistered_  parametermetadata_ columns_
}
private object expandobjectarray object array  int newlength
if  array    null
object newarray   new object
return newarray
}
if  array length < newlength
object newarray   new object
system arraycopy array  0  newarray  0  array length
return newarray
}
return array
}
private boolean expandbooleanarray boolean array  int newlength
if  array    null
boolean newarray   new boolean
return newarray
}
if  array length < newlength
boolean newarray   new boolean
system arraycopy array  0  newarray  0  array length
return newarray
}
return array
}
void writepreparedescribeinputoutput string sql
section section  throws sqlexception
// notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
writepreparedescribeoutput sql  section
writedescribeinput section
}
void flowpreparedescribeinputoutput   throws sqlexception
agent_ beginwritechain this
if  sqlmode_    iscall__
writepreparedescribeinput
agent_ flow this
readpreparedescribeinput
agent_ endreadchain
else
writepreparedescribeinputoutput
agent_ flow this
readpreparedescribeinputoutput
agent_ endreadchain
}
}
private void flowexecute int executetype  throws sqlexception
checkforclosedstatement
checkautogeneratedkeysparameters
clearwarningsx
checkforappropriatesqlmode executetype  sqlmode_
checkthatallparametersareset
if  sqlmode_    isupdate__
updatecount_   0
else
updatecount_    1
}
// derby-1036: moved check till execute time to comply with embedded
// behavior. since we check here and not in setcursorname, several
// statements can have the same cursor name as long as their result
// sets are not simultaneously open.
if  sqlmode_    isquery__
checkforduplicatecursorname
}
agent_ beginwritechain this
boolean piggybackedautocommit   writecloseresultsets true       true means permit auto commits
int numinputcolumns
boolean outputexpected
try
numinputcolumns    parametermetadata_    null  ? parametermetadata_ getcolumncount     0
outputexpected    resultsetmetadata_    null    resultsetmetadata_ getcolumncount   > 0
}
catch   sqlexception se
// generate a sqlexception for this, we don't want to throw
// sqlexception in this internal method
throw new sqlexception se
}
boolean chainautocommit   false
boolean commitsubstituted   false
boolean repositionedcursor   false
boolean timeoutsent   false
resultset scrollablers   null
if  dowritetimeout
timeoutarraylist set 0  timeout_statement   timeout_
writesetspecialregister timeoutarraylist
dowritetimeout   false
timeoutsent   true
}
switch  sqlmode_
case isupdate__
if  positionedupdatecursorname_    null
scrollablers   agent_ sectionmanager_ getpositionedupdateresultset positionedupdatecursorname_
}
if  scrollablers    null     scrollablers isrowsetcursor_
repositionedcursor
scrollablers repositionscrollableresultsetbeforejdbc1positionedupdatedelete
if   repositionedcursor
scrollablers   null
}
}
chainautocommit   connection_ willautocommitgenerateflow      isautocommittablestatement_
boolean chainopenqueryforautogeneratedkeys    sqlupdatemode_    isinsertsql__    autogeneratedkeys_    return_generated_keys
writeexecute section_
parametermetadata_
parameters_
numinputcolumns
outputexpected
chainautocommit    chainopenqueryforautogeneratedkeys    chain flag
chain flag
if  chainopenqueryforautogeneratedkeys
prepareautogeneratedkeysstatement
writeopenquery preparedstatementforautogeneratedkeys_ section_
preparedstatementforautogeneratedkeys_ fetchsize_
preparedstatementforautogeneratedkeys_ resultsettype_
}
if  chainautocommit
// we have encountered an error in writing the execute, so do not
// flow an autocommit
if  agent_ accumulatedreadexceptions_    null
// currently, the only write exception we encounter is for
// data truncation: sqlstate 01004, so we don't bother checking for this
connection_ writecommitsubstitute_
commitsubstituted   true
else
// there is no write error, so flow the commit
connection_ writecommit
}
}
break
case isquery__
writeopenquery section_
fetchsize_
resultsettype_
numinputcolumns
parametermetadata_
parameters_
break
case iscall__
writeexecutecall outputregistered_     if no out inout parameter  outputexpected   false

section_
fetchsize_
false     do not suppress resultsets for regular calls
resultsettype_
parametermetadata_
parameters_      cross conversion
break
}
agent_ flow this
super readcloseresultsets true       true means permit auto commits
// turn inunitofwork_ flag back on and add statement
// back on commitlisteners_ list if they were off
// by an autocommit chained to a close cursor.
if  piggybackedautocommit
connection_ completetransactionstart
}
markresultsetsclosed true      true means remove from list of commit and rollback listeners
if  timeoutsent
readsetspecialregister       read response to the excsqlset
}
switch  sqlmode_
case isupdate__
// do not need to reposition for a rowset cursor
if  scrollablers    null     scrollablers isrowsetcursor_
scrollablers readpositioningfetch_
}
else
readexecute
if  sqlupdatemode_    isinsertsql__    autogeneratedkeys_    return_generated_keys
readprepareautogeneratedkeysstatement
preparedstatementforautogeneratedkeys_ readopenquery
generatedkeysresultset_   preparedstatementforautogeneratedkeys_ resultset_
preparedstatementforautogeneratedkeys_ resultset_   null
}
}
if  chainautocommit
if  commitsubstituted
connection_ readcommitsubstitute_
else
connection_ readcommit
}
}
break
case isquery__
try
readopenquery
catch  disconnectexception dise
throw dise
catch  sqlexception e
throw e
}
// resultset_ is null if open query failed.
// check for null resultset_ before using it.
if  resultset_    null
resultset_ parsescrollablerowset
//if (resultset_.scrollable_) resultset_.getrowcount();
// derby-1183: if we set it up earlier, the entry in
// clientcursornamecache_ gets wiped out by the closing of
// result sets happening during readcloseresultsets above
// because resultset#markclosed calls
// statement#removeclientcursornamefromcache.
setupcursornamecacheandmappings
}
break
case iscall__
readexecutecall
break
}
try
agent_ endreadchain
catch  sqlexception e
throw e
}
if  sqlmode_    iscall__
parsestorprocreturnedscrollablerowset
checkforstoredprocresultsetcount executetype
// when there are no result sets back, we will commit immediately when autocommit is true.
// make sure a commit is not performed when making the call to the sqlca message procedure
if  connection_ autocommit_    resultset_    null    resultsetlist_    null    isautocommittablestatement_
connection_ flowautocommit
}
}
// the jdbc spec says that executeupdate() should return 0
// when no row count is returned.
if  executetype    executeupdatemethod__    updatecount_ < 0
updatecount_   0
}
// throw an exception if holdability returned by the server is different from requested.
if  resultset_    null    resultset_ resultsetholdability_    resultsetholdability_    sqlmode_    iscall__
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate unable_to_open_resultset_with_requested_holdabilty
new integer resultsetholdability_
}
}
public int executebatchx boolean supportsquerybatchrequest
throws sqlexception  sqlexception  batchupdateexception
synchronized  connection_
checkforclosedstatement       per jdbc spec  see statement close   javadoc
clearwarningsx       per jdbc spec 0 7  also see getwarnings   javadoc
return executebatchrequestx supportsquerybatchrequest
}
}
private int executebatchrequestx boolean supportsquerybatchrequest
throws sqlexception  batchupdateexception
sqlexception chainbreaker   null
int batchsize   batch_ size
int updatecounts   new int
int numinputcolumns
try
numinputcolumns   parametermetadata_    null ? 0   parametermetadata_ getcolumncount
catch   sqlexception se
throw new sqlexception se
}
object savedinputs   null      used to save restore existing parameters
boolean timeoutsent   false
if  batchsize    0
return updatecounts
}
// the network client has a hard limit of 65,534 commands in a single
// drda request. this is because drda uses a 2-byte correlation id,
// and the values 0 and 0xffff are reserved as special values. so
// that imposes an upper limit on the batch size we can support:
if  batchsize > 65534
throw new batchupdateexception agent_ logwriter_
new clientmessageid sqlstate too_many_commands_for_batch
new integer 65534   updatecounts
// initialize all the updatecounts to indicate failure
// this is done to account for "chain-breaking" errors where we cannot
// read any more replies
for  int i   0  i < batchsize  i
updatecounts    3
}
if   supportsquerybatchrequest    sqlmode_    isquery__
throw new batchupdateexception agent_ logwriter_
new clientmessageid sqlstate cannot_batch_queries   updatecounts
}
if  supportsquerybatchrequest    sqlmode_    isquery__
throw new batchupdateexception agent_ logwriter_
new clientmessageid sqlstate query_batch_on_non_query_statement
updatecounts
}
resultsetlist_   null
if  sqlmode_    isquery__
indexofcurrentresultset_    1    reset resultsetlist
resultsetlist_   new resultset
}
//save the current input set so it can be restored
savedinputs   parameters_
agent_ beginbatchedwritechain this
boolean chainautocommit   connection_ willautocommitgenerateflow      isautocommittablestatement_
if  dowritetimeout
timeoutarraylist set 0  timeout_statement   timeout_
writesetspecialregister timeoutarraylist
dowritetimeout   false
timeoutsent   true
}
for  int i   0  i < batchsize  i
if  parametermetadata_    null
parametermetadata_ clientparamtertype_    int  parametertypelist get i
parameters_    object  batch_ get i
}
if  sqlmode_    iscall__
boolean outputexpected
try
outputexpected    resultsetmetadata_    null    resultsetmetadata_ getcolumncount   > 0
catch   sqlexception se
throw new sqlexception se
}
writeexecute section_
parametermetadata_
parameters_
numinputcolumns
outputexpected
chainautocommit     i    batchsize   1        more statements to chain
else if  outputregistered_     make sure no output parameters are registered
throw new batchupdateexception agent_ logwriter_
new clientmessageid sqlstate output_params_not_allowed
updatecounts
else
writeexecutecall false     no output expected for batched calls
null     no procedure name supplied for prepared calls
section_
fetchsize_
true     suppress resultsets for batch
resultsettype_
parametermetadata_
parameters_
}
}
boolean commitsubstituted   false
if  chainautocommit
// we have encountered an error in writing the execute, so do not
// flow an autocommit
if  agent_ accumulatedreadexceptions_    null
// currently, the only write exception we encounter is for
// data truncation: sqlstate 01004, so we don't bother checking for this
connection_ writecommitsubstitute_
commitsubstituted   true
else
// there is no write error, so flow the commit
connection_ writecommit
}
}
agent_ flowbatch this  batchsize
if  timeoutsent
readsetspecialregister       read response to the excsqlset
}
try
for  int i   0  i < batchsize  i
agent_ setbatchedexceptionlabelindex i
parameters_    object  batch_ get i
if  sqlmode_    iscall__
readexecute
else
readexecutecall
}
updatecounts   updatecount_
}
agent_ disablebatchedexceptiontracking       to prvent the following readcommit   from getting a batch label
if  chainautocommit
if   commitsubstituted
connection_ readcommit
else
connection_ readcommitsubstitute_
}
}
}
// for chain-breaking exception only, all read() methods do their own accumulation
// this catches the entire accumulated chain, we need to be careful not to
// reaccumulate it on the agent since the batch labels will be overwritten if
// batch exception tracking is enabled.
catch  sqlexception e       for chain breaking exception only
chainbreaker   e
chainbreaker setnextexception new sqlexception agent_ logwriter_
new clientmessageid sqlstate batch_chain_breaking_exception
}
// we need to clear the batch before any exception is thrown from agent_.endbatchedreadchain().
batch_ clear
parametertypelist   null
// restore the saved input set, setting it to "current"
parameters_   savedinputs
agent_ endbatchedreadchain updatecounts  chainbreaker
return updatecounts
}
//------------------material layer event callbacks follow-----------------------
boolean listentounitofwork_   false
public void listentounitofwork
if   listentounitofwork_
listentounitofwork_   true
connection_ commitandrollbacklisteners_ put this null
}
}
public void completelocalcommit java util iterator listeneriterator
if  section_    null
openonserver_   false
}
listeneriterator remove
listentounitofwork_   false
}
public void completelocalrollback java util iterator listeneriterator
if  section_    null
openonserver_   false
}
listeneriterator remove
listentounitofwork_   false
}
//----------------------------internal use only helper methods----------------
/**
* returns the name of the java.sql interface implemented by this class.
* @return name of java.sql interface
*/
protected string getjdbcstatementinterfacename
return
}
void checkforvalidparameterindex int parameterindex  throws sqlexception
if  parametermetadata_    null
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate no_input_parameters
if  parameterindex < 1    parameterindex > parametermetadata_ columns_
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate lang_invalid_param_position
new integer parameterindex
new integer parametermetadata_ columns_
}
}
private void checkthatallparametersareset   throws sqlexception
if  parametermetadata_    null
for  int i   0  i < parametermetadata_ columns_  i
if   parameterset_     parameterregistered_
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate lang_missing_parms
}
}
}
}
void checkforvalidscale int scale  throws sqlexception
if  scale < 0    scale > 31
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate bad_scale_value
new integer scale
}
}
/**
* checks whether a data type is supported for
* <code>setobject(int, object, int)</code> and
* <code>setobject(int, object, int, int)</code>.
*
* @param datatype the data type to check
* @exception sqlexception if the type is not supported
*/
private void checkforsupporteddatatype int datatype  throws sqlexception
// jdbc 4.0 javadoc for setobject() says:
//
// throws: (...) sqlfeaturenotsupportedexception - if
// targetsqltype is a array, blob, clob, datalink,
// java_object, nchar, nclob, nvarchar, longnvarchar, ref,
// rowid, sqlxml or struct data type and the jdbc driver does
// not support this data type
//
// of these types, we only support blob, clob and
// (sort of) java_object.
switch  datatype
case java sql types array
case java sql types datalink
case jdbc40translation nchar
case jdbc40translation nclob
case jdbc40translation nvarchar
case jdbc40translation longnvarchar
case java sql types ref
case jdbc40translation rowid
case jdbc40translation sqlxml
case java sql types struct
throw new sqlexception
agent_ logwriter_
new clientmessageid sqlstate data_type_not_supported
types gettypestring datatype
}
}
void checkscaleforinoutdecimal int parameterindex  int registeroutscale  throws sqlexception
java math bigdecimal decimalinput    java math bigdecimal  parameters_
if  decimalinput    null
return
}
// if the register out scale is greater than input scale, input scale is stored in sqlscale_
if  registeroutscale > parametermetadata_ sqlscale_
int inputlength   decimalinput tostring   length
int scaledifference   registeroutscale   decimalinput scale
if  decimalinput signum       1
inputlength
}
// if the new decimal (with bigger scale) cannot fit into the da
if   32   scaledifference  < inputlength
// todo - finish this
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate regoutparam_scale_doesnt_match_setter
}
// if the new decimal (with bigger scale) can fit
else
parameters_   decimalinput setscale registeroutscale
parametermetadata_ sqlscale_   registeroutscale
}
}
// if the register out sacle is smaller than input scale
else if  registeroutscale < parametermetadata_ sqlscale_
// remove 0's at the end of input
try
// if the new decimal (with smaller scale) can fit
parameters_   decimalinput setscale registeroutscale
parametermetadata_ sqlscale_   registeroutscale
catch  arithmeticexception e
// if the new decimal (with smaller scale) cannot fit into the da
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate regoutparam_scale_doesnt_match_setter
}
}
}
/* (non-javadoc)
* @see org.apache.derby.client.am.statement#markclosed(boolean)
*/
protected void markclosed boolean removelistener
if pooledconnection_    null
pooledconnection_ onstatementclose this
super markclosed removelistener
if  parametermetadata_    null
parametermetadata_ markclosed
parametermetadata_   null
}
sql_   null
// apparently, the jvm is not smart enough to traverse parameters_[] and null
// out its members when the entire array is set to null (parameters_=null;).
if  parameters_    null
arrays fill parameters_  null
}
parameters_   null
if removelistener
connection_ commitandrollbacklisteners_ remove this
}
//jdbc 4.0 methods
/**
* sets the designated parameter to the given input stream.
* when a very large ascii value is input to a <code>longvarchar</code>
* parameter, it may be more practical to send it via a
* <code>java.io.inputstream</code>. data will be read from the stream as
* needed until end-of-file is reached. the jdbc driver will do any
* necessary conversion from ascii to the database char format.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream that contains the ascii parameter value
* @throws sqlexception if a database access error occurs or this method is
*      called on a closed <code>preparedstatement</code>
*/
public void setasciistream int parameterindex  inputstream x
throws sqlexception
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
parameterindex  x
}
try
checktypeforsetasciistream parameterindex
parametermetadata_ clientparamtertype_   java sql types clob
if  x    null
setnull parameterindex  java sql types longvarchar
return
}
setinput parameterindex  new clob agent_  x
catch  sqlexception se
throw se getsqlexception
}
}
}
/**
* sets the designated parameter to the given input stream.
* when a very large binary value is input to a <code>longvarbinary</code>
* parameter, it may be more practical to send it via a
* <code>java.io.inputstream</code> object. the data will be read from the
* stream as needed until end-of-file is reached.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the binary parameter value
* @throws sqlexception if a database access error occurs or this method is
*      called on a closed <code>preparedstatement</code>
*/
public void setbinarystream int parameterindex  inputstream x
throws sqlexception
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
parameterindex  x
}
try
checktypeforsetbinarystream parameterindex
setbinarystreamx parameterindex  x   1
catch  sqlexception se
throw se getsqlexception
}
}
}
/**
* sets the designated parameter to a <code>reader</code> object.
*
* @param parameterindex index of the first parameter is 1, the second is
*      2, ...
* @param reader an object that contains the data to set the parameter
*      value to.
* @throws sqlexception if parameterindex does not correspond to a
*      parameter marker in the sql statement; if a database access error
*      occurs; this method is called on a closed preparedstatementor if
*      parameterindex does not correspond to a parameter marker in the sql
*      statement
*/
public void setclob int parameterindex  reader reader
throws sqlexception
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
parameterindex  reader
}
try
checktypeforsetclob parameterindex
checkforclosedstatement
catch  sqlexception se
throw se getsqlexception
}
setinput parameterindex  new clob agent_  reader
}
}
/**
* sets the designated parameter to a reader object.
*
* @param parameterindex index of the first parameter is 1, the second is 2, ...
* @param reader an object that contains the data to set the parameter value to.
* @param length the number of characters in the parameter data.
* @throws sqlexception if parameterindex does not correspond to a parameter
* marker in the sql statement, or if the length specified is less than zero.
*
*/
public void setclob int parameterindex  reader reader  long length
throws sqlexception
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
parameterindex  reader  new long length
}
try
checkforclosedstatement
catch  sqlexception se
throw se getsqlexception
}
if length > integer max_value
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate blob_too_large_for_client
new long length   new integer integer max_value   getsqlexception
else
setinput parameterindex  new clob agent_  reader   int length
}
}
/**
* sets the designated parameter to a <code>inputstream</code> object.
* this method differs from the <code>setbinarystream(int, inputstream)
* </code>  method because it informs the driver that the parameter value
* should be sent to the server as a <code>blob</code>. when the
* <code>setbinarystream</code> method is used, the driver may have to do
* extra work to determine whether the parameter data should be sent to the
* server as a <code>longvarbinary</code> or a <code>blob</code>
*
* @param parameterindex index of the first parameter is 1, the second is
*      2, ...
* @param inputstream an object that contains the data to set the parameter
*      value to.
* @throws sqlexception if a database access error occurs, this method is
*      called on a closed <code>preparedstatement</code> or if
*      <code>parameterindex</code> does not correspond to a parameter
*      marker in the sql statement
*/
public void setblob int parameterindex  inputstream inputstream
throws sqlexception
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex
inputstream
}
try
checktypeforsetblob parameterindex
setbinarystreamx parameterindex  inputstream   1
catch  sqlexception se
throw se getsqlexception
}
}
}
/**
* sets the designated parameter to a inputstream object.
*
* @param parameterindex index of the first parameter is 1,
* the second is 2, ...
* @param inputstream an object that contains the data to set the parameter
* value to.
* @param length the number of bytes in the parameter data.
* @throws sqlexception if parameterindex does not correspond
* to a parameter marker in the sql statement,  if the length specified
* is less than zero or if the number of bytes in the inputstream does not match
* the specfied length.
*
*/
public void setblob int parameterindex  inputstream inputstream  long length
throws sqlexception
synchronized  connection_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     parameterindex
inputstream  new long length
}
if length > integer max_value
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate blob_too_large_for_client
new long length   new integer integer max_value   getsqlexception
else
try
checktypeforsetblob parameterindex
setbinarystreamx parameterindex  inputstream   int length
catch sqlexception se
throw se getsqlexception
}
}
}
}
/*
* method calls onstatementerror occurred on the
* brokeredconnectioncontrol class after checking the
* sqlstate of the sqlexception thrown.
* @param sqle sqlexception
* @throws java.sql.sqlexception
*/
private void checkstatementvalidity sqlexception sqle
throws sqlexception
//check if the statement is already closed
//this might be caused because the connection associated
//with this prepared statement has been closed marking
//its associated prepared statements also as
//closed
if pooledconnection_  null    isclosed
pooledconnection_ onstatementerroroccurred this
sqle getsqlexception
}
}
/**
* possibletypes is information which is set of types.
* a given type is evaluated as *possible* at checktype method if same type was found in the set.
*/
private static class possibletypes
final private int possibletypes
private possibletypes int types
possibletypes   types
arrays sort possibletypes
}
/**
* this is possibletypes of variable which can be set by set method for generic scalar.
*/
final public static possibletypes possible_types_in_set_generic_scalar
new possibletypes  new int
java sql types bigint
java sql types longvarchar
java sql types char
java sql types decimal
java sql types integer
java sql types smallint
java sql types real
java sql types double
java sql types varchar
/**
* this is possibletypes of variable which can be set by setdate method.
*/
final public static possibletypes possible_types_in_set_date
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types date
java sql types timestamp
/**
* this is possibletypes of variable which can be set by settime method.
*/
final public static possibletypes possible_types_in_set_time
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types time
/**
* this is possibletypes of variable which can be set by settimestamp method.
*/
final public static possibletypes possible_types_in_set_timestamp
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types date
java sql types time
java sql types timestamp
/**
* this is possibletypes of variable which can be set by setstring method.
*/
final private static possibletypes possible_types_in_set_string
new possibletypes  new int
java sql types bigint
java sql types longvarchar
java sql types char
java sql types decimal
java sql types integer
java sql types smallint
java sql types real
java sql types double
java sql types varchar
java sql types date
java sql types time
java sql types timestamp
java sql types clob
/**
* this is possibletypes of variable which can be set by setbytes method.
*/
final public static possibletypes possible_types_in_set_bytes
new possibletypes  new int
java sql types longvarbinary
java sql types varbinary
java sql types binary
java sql types longvarchar
java sql types char
java sql types varchar
java sql types blob
/**
* this is possibletypes of variable which can be set by setbinarystream method.
*/
final public static possibletypes possible_types_in_set_binarystream
new possibletypes  new int
java sql types longvarbinary
java sql types varbinary
java sql types binary
java sql types blob
/**
* this is possibletypes of variable which can be set by setasciistream method.
*/
final public static possibletypes possible_types_in_set_asciistream
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types clob
/**
* this is possibletypes of variable which can be set by setcharacterstream method.
*/
final public static possibletypes possible_types_in_set_characterstream
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types clob
/**
* this is possibletypes of variable which can be set by setblob method.
*/
final public static possibletypes possible_types_in_set_blob
new possibletypes  new int
java sql types blob
/**
* this is possibletypes of variable which can be set by setclob method.
*/
final public static possibletypes possible_types_in_set_clob
new possibletypes  new int
java sql types clob
/**
* this is possibletypes of null value which can be assigned to generic scalar typed variable.
*/
final public static possibletypes possible_types_for_generic_scalar_null
new possibletypes  new int
java sql types bit
java sql types tinyint
java sql types bigint
java sql types longvarchar
java sql types char
java sql types numeric
java sql types decimal
java sql types integer
java sql types smallint
java sql types float
java sql types real
java sql types double
java sql types varchar
/**
* this is possibletypes of null value which can be assigned to generic character typed variable.
*/
final public static possibletypes possible_types_for_generic_characters_null
new possibletypes  new int
java sql types bit
java sql types tinyint
java sql types bigint
java sql types longvarchar
java sql types char
java sql types numeric
java sql types decimal
java sql types integer
java sql types smallint
java sql types float
java sql types real
java sql types double
java sql types varchar
java sql types date
java sql types time
java sql types timestamp
/**
* this is possibletypes of null value which can be assigned to varbinary typed variable.
*/
final public static possibletypes possible_types_for_varbinary_null
new possibletypes  new int
java sql types varbinary
java sql types binary
java sql types longvarbinary
/**
* this is possibletypes of null value which can be assigned to binary typed variable.
*/
final public static possibletypes possible_types_for_binary_null
new possibletypes  new int
java sql types varbinary
java sql types binary
java sql types longvarbinary
/**
* this is possibletypes of null value which can be assigned to longvarbinary typed variable.
*/
final public static possibletypes possible_types_for_longvarbinary_null
new possibletypes  new int
java sql types varbinary
java sql types binary
java sql types longvarbinary
/**
* this is possibletypes of null value which can be assigned to date typed variable.
*/
final public static possibletypes possible_types_for_date_null
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types date
java sql types timestamp
/**
* this is possibletypes of null value which can be assigned to time typed variable.
*/
final public static possibletypes possible_types_for_time_null
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types time
java sql types timestamp
/**
* this is possibletypes of null value which can be assigned to timestamp typed variable.
*/
final public static possibletypes possible_types_for_timestamp_null
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types date
java sql types timestamp
/**
* this is possibletypes of null value which can be assigned to clob typed variable.
*/
final public static possibletypes possible_types_for_clob_null
new possibletypes  new int
java sql types longvarchar
java sql types char
java sql types varchar
java sql types clob
/**
* this is possibletypes of null value which can be assigned to blob typed variable.
*/
final public static possibletypes possible_types_for_blob_null
new possibletypes  new int
java sql types blob
/**
* this is possibletypes of null value which can be assigned to other typed variable.
*/
final public static possibletypes default_possible_types_for_null
new possibletypes  new int
java sql types bit
java sql types tinyint
java sql types bigint
java sql types longvarbinary
java sql types varbinary
java sql types binary
java sql types longvarchar
java sql types null
java sql types char
java sql types numeric
java sql types decimal
java sql types integer
java sql types smallint
java sql types float
java sql types real
java sql types double
java sql types varchar
java sql types boolean
java sql types datalink
java sql types date
java sql types time
java sql types timestamp
java sql types other
java sql types java_object
java sql types distinct
java sql types struct
java sql types array
java sql types blob
java sql types clob
java sql types ref
/**
* this method return true if the type is possible.
*/
boolean checktype int type
if sanitymanager debug
for int i   0
i < possibletypes length   1
i
sanitymanager assert possibletypes < possibletypes
}
}
return arrays binarysearch  possibletypes
type   >  0
}
/*
static sqlexception throwlangdatatypesetexception( logwriter logwriter,
int valtype,
int paramtype)
throws sqlexception{
throw new sqlexception( logwriter,
new clientmessageid(sqlstate.lang_data_type_set_mismatch) ,
new object[]{
types.gettypestring(valtype),
types.gettypestring(paramtype)
},
(throwable) null);
}
*/
static sqlexception throw22005exception  logwriter logwriter
int valtype,
int paramtype)
throws sqlexception{
throw new sqlexception( logwriter,
new clientmessageid sqlstate lang_data_type_get_mismatch
new object[]{
types.gettypestring(valtype),
types.gettypestring(paramtype)
},
(throwable) null);
}
/**
* this method return possibletypes of null value in variable typed as typeofvariable.
*/
static possibletypes getpossibletypesfornull int typeofvariable
switch typeofvariable
case java sql types smallint
return possible_types_for_generic_scalar_null
case java sql types integer
return possible_types_for_generic_scalar_null
case java sql types bigint
return possible_types_for_generic_scalar_null
case java sql types real
return possible_types_for_generic_scalar_null
case java sql types float
return possible_types_for_generic_scalar_null
case java sql types double
return possible_types_for_generic_scalar_null
case java sql types decimal
return possible_types_for_generic_scalar_null
case java sql types char
return possible_types_for_generic_characters_null
case java sql types varchar
return possible_types_for_generic_characters_null
case java sql types longvarchar
return possible_types_for_generic_characters_null
case java sql types varbinary
return possible_types_for_varbinary_null
case java sql types binary
return possible_types_for_binary_null
case java sql types longvarbinary
return possible_types_for_longvarbinary_null
case java sql types date
return possible_types_for_date_null
case java sql types time
return possible_types_for_time_null
case java sql types timestamp
return possible_types_for_timestamp_null
case java sql types clob
return possible_types_for_clob_null
case java sql types blob
return possible_types_for_blob_null
}
// as default, accept all type...
return default_possible_types_for_null
}
}
}