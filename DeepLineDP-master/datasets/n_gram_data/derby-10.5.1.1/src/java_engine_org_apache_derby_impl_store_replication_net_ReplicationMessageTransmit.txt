/*
derby - class org.apache.derby.impl.store.replication.net.replicationmessagetransmit
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store replication net
import java io ioexception
import java net inetsocketaddress
import java net socket
import java net sockettimeoutexception
import java security accesscontroller
import java security privilegedactionexception
import java security privilegedexceptionaction
import javax net socketfactory
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby shared common reference messageid
/**
* used to send replication messages to the slave. called by the
* master controller to transmit replication messages wrapped in
* a <code>replicationmessage</code> object to a receiver. the
* receiver is implemented by the <code>replicationmessagereceive</code>
* class.
*/
public class replicationmessagetransmit
/** number of millis to wait for a response message before timing out
*/
private final int default_message_response_timeout   5000
/** the thread that listens for messages from the slave */
private thread msgreceiver   null
/** used to synchronize when waiting for a response message from the slave
*/
private final object receivesemaphore   new object
/** the message received from the slave as a response to sending a
* message. */
private replicationmessage receivedmsg   null
/** whether or not to keep the message receiver thread alive. set to true
* to terminate the thread */
private volatile boolean stopmessagereceiver   false
/**
* contains the address (hostname and port number) of the slave
* to replicate to.
*/
private final slaveaddress slaveaddress
/**
* used to write/read message objects to/from a connection.
*/
private socketconnection socketconn
/**
* the name of the replicated database
*/
private string dbname
/**
* constructor initializes the slave address used in replication.
*
* @param slaveaddress contains the address (host name and port number)
*                     of the slave to connect to.
*/
public replicationmessagetransmit slaveaddress slaveaddress
this slaveaddress   slaveaddress
/**
* used to create a <code>socket</code> connection to the slave and
* establish compatibility with the database version of the slave by
* comparing the uid's of the <code>replicationmessage</code> classes
* of the master and the slave.
*
* @param timeout the amount of time for which the connection should
*                block before being established.
*
* @param synchoninstant the master log instant, used to check
* that the master and slave log files are in synch. if no chunks
* of log records have been shipped to the slave yet, this is the
* end position in the current log file. if a chunk of log has
* been shipped, this is the instant of the log record shipped
* last. note that there is a difference!
* @throws privilegedactionexception if an exception occurs while trying
*                                   to open a connection.
*
* @throws ioexception if an exception occurs while trying to create the
*         <code>socketconnection</code> class.
*
* @throws standardexception if an error message is received from the
*         server indicating incompatible software versions of master
*         and slave.
*
* @throws classnotfoundexception class of a serialized object cannot
*         be found.
*/
public void initconnection int timeout  long synchoninstant  throws
privilegedactionexception
ioexception
standardexception
classnotfoundexception
socket s   null
final int timeout_   timeout
//create a connection to the slave.
s    socket
accesscontroller doprivileged new privilegedexceptionaction
public object run   throws ioexception
socketfactory sf   socketfactory getdefault
inetsocketaddress sockaddr   new inetsocketaddress
slaveaddress gethostaddress
slaveaddress getportnumber
socket s_temp   sf createsocket
s_temp connect sockaddr  timeout_
return s_temp
// keep socket alive even if no log is shipped for a long time
s setkeepalive true
socketconn   new socketconnection s
// start the thread that will listen for incoming messages.
startmessagereceiverthread dbname
// verify that the master and slave have the same software version
// and exactly equal log files.
brokerconnection synchoninstant
/**
* tear down the network connection established with the
* other replication peer
*
* @throws ioexception if an exception occurs while trying to tear
*                     down the network connection
*/
public void teardown   throws ioexception
stopmessagereceiver   true
msgreceiver   null
if socketconn    null
socketconn teardown
socketconn   null
/**
* used to send a replication message to the slave.
*
* @param message a <code>replicationmessage</code> object that contains
*                the message to be transmitted.
*
* @throws ioexception 1) if an exception occurs while transmitting
*                        the message.
*                     2) if the connection handle is invalid.
*/
public void sendmessage replicationmessage message  throws ioexception
checksocketconnection
socketconn writemessage message
/**
* send a replication message to the slave and return the
* message received as a response. will only wait
* default_message_response_timeout millis for the response
* message. if not received when the wait times out, no message is
* returned. the method is synchronized to guarantee that only one
* thread will be waiting for a response message at any time.
*
* @param message a replicationmessage object that contains the message to
* be transmitted.
*
* @return the response message
* @throws ioexception 1) if an exception occurs while sending or receiving
*                        a message.
*                     2) if the connection handle is invalid.
* @throws standardexception if the response message has not been received
* after default_message_response_timeout millis
*/
public synchronized replicationmessage
sendmessagewaitforreply replicationmessage message
throws ioexception  standardexception
receivedmsg   null
checksocketconnection
socketconn writemessage message
synchronized  receivesemaphore
try
receivesemaphore wait default_message_response_timeout
catch  interruptedexception ie
if  receivedmsg    null
throw standardexception
newexception sqlstate replication_connection_lost  dbname
return receivedmsg
/**
* used to send initiator messages to the slave and receive
* information about the compatibility of the slave with the
* master. one message is used to check that the slave and master
* have the same software versions. a second message is used to
* check that the master and slave log files are in synch.
*
* @param synchoninstant the master log instant, used to check
* that the master and slave log files are in synch. if no chunks
* of log records have been shipped to the slave yet, this is the
* end position in the current log file. if a chunk of log has
* been shipped, this is the instant of the log record shipped
* last. note that there is a difference!
*
* @throws ioexception if an exception occurs during the sending or
*                     reading of the message.
*
* @throws standardexception if an error message is received from the
*                           server indicating a mis-match in
*                           serialversionuid or log files out of synch.
*
* @throws classnotfoundexception class of a serialized object cannot
*                                be found.
*/
private void brokerconnection long synchoninstant
throws ioexception  standardexception  classnotfoundexception
// check that master and slave have the same serialversionuid
replicationmessage initiatormsg
new replicationmessage replicationmessage type_initiate_version
new long replicationmessage
serialversionuid
verifymessagetype sendmessagewaitforreply initiatormsg
replicationmessage type_ack
// check that master and slave log files are in synch
initiatormsg
new replicationmessage replicationmessage type_initiate_instant
new long synchoninstant
verifymessagetype sendmessagewaitforreply initiatormsg
replicationmessage type_ack
/**
* used to parse a message received from the slave. if the message
* is an ack of the last shipped message, this method terminates
* quietly. otherwise, it throws the exception received in the
* message from the slave describing why the last message could
* not be acked.
*
* @throws standardexception if an error message is received from
*                           the server
*
* @throws classnotfoundexception class of a serialized object cannot
*                                be found.
*/
private boolean verifymessagetype replicationmessage message
int expectedtype
throws standardexception
//if the message is a type_ack the slave is capable
//of handling the messages and is at a compatible database version.
if  message gettype      expectedtype
return true
else if  message gettype      replicationmessage type_error
// see replicationmessage#type_error
string exception    string message getmessage
throw standardexception
newexception exception  exception
else
//the message format was not recognized. hence throw
//an unexpected exception.
throw standardexception newexception
sqlstate replication_unexpected_exception
/**
* verifies if the <code>socketconnection</code> is valid.
*
* @throws ioexception if the socket connection object is not
*                     valid (is null).
*/
private void checksocketconnection   throws ioexception
if  socketconn    null
throw new ioexception
messageid replication_invalid_connection_handle
private void startmessagereceiverthread string dbname
msgreceiver   new masterreceiverthread dbname
msgreceiver setdaemon true
msgreceiver start
/////////////////
// inner class //
/////////////////
/**
* thread that listens for messages from the slave. a separate thread
* listening for messages from the slave is needed because the slave
* may send messages to the master at any time, and these messages require
* immediate action.
*/
private class masterreceiverthread extends thread
private final replicationmessage pongmsg
new replicationmessage replicationmessage type_pong  null
masterreceiverthread string dbname
super     dbname
public void run
replicationmessage message
while   stopmessagereceiver
try
message   readmessage
switch  message gettype
case replicationmessage type_ping
sendmessage pongmsg
break
case replicationmessage type_ack
case replicationmessage type_error
synchronized  receivesemaphore
receivedmsg   message
receivesemaphore notify
break
default
// handling of other messages (i.e., stop and failover)
// not implemented yet
break
catch  sockettimeoutexception ste
// ignore socket timeout on reads
catch  classnotfoundexception cnfe
// todo: print problem to log
catch  ioexception ex
// todo: print problem to log
// if we get an exception for this socket, the log shipper
// will clean up. stop this thread.
stopmessagereceiver   true
msgreceiver   null
/**
* used to read a replication message sent by the slave. hangs until a
* message is received from the slave
*
* @return the reply message.
*
* @throws classnotfoundexception class of a serialized object cannot
*                                be found.
*
* @throws ioexception 1) if an exception occurs while reading from the
*                        stream.
*                     2) if the connection handle is invalid.
*/
private replicationmessage readmessage   throws
classnotfoundexception  ioexception
checksocketconnection
return  replicationmessage socketconn readmessage