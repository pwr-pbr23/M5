/*
derby - class org.apache.derby.impl.drda.database
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl drda
import java sql connection
import java sql driver
import java sql preparedstatement
import java sql statement
import java sql resultset
import java sql sqlexception
import java util hashtable
import java util enumeration
import java util properties
import org apache derby iapi jdbc engineconnection
import org apache derby iapi reference attribute
import org apache derby iapi tools i18n localizedresource
import org apache derby iapi services sanity sanitymanager
/**
database stores information about the current database
it is used so that a session may have more than one database
*/
class database
protected string dbname 			   database name
protected string shortdbname           database name without attributes
string attrstring                     attribute string
protected int securitymechanism 	   security mechanism
protected string userid 			   user id
protected string password 			   password
protected string decrypteduserid 	   decrypted user id
protected string decryptedpassword 	   decrypted password
protected byte passwordsubstitute    password substitute   secmec_usrssbpwd
protected boolean rdballowupdates   true     database allows updates  default is true
protected int	accesscount 		   number of times we have tried to
// set up access to this database (only 1
// allowed)
protected byte sectokenin 		   security token from app requester
protected byte sectokenout 		   security token sent to app requester
protected byte crrtkn 			   correlation token
protected string typdefnam 			   type definition name
protected int byteorder 			  deduced from typdefnam  save string comparisons
protected int ccsidsbc 				   single byte ccsid
protected int ccsiddbc 				   double byte ccsid
protected int ccsidmbc 				   mixed byte ccsid
protected string ccsidsbcencoding 	   encoding for single byte code page
protected string ccsiddbcencoding 	   encoding for double byte code page
protected string ccsidmbcencoding 	   encoding for mixed byte code page
protected boolean rdbupdrm_sent   false 	  we have sent that an update
// occurred in this transaction
protected boolean sendtrgdftrt   false     send package target default value
/**
* connection to the database in the embedded engine.
*/
private engineconnection conn
drdastatement defaultstatement        default statement used
// for execute imm
private drdastatement currentstatement     current statement we are working on
private hashtable stmttable 		   hash table for storing statements
boolean forxa   false
// constructor
/**
* database constructor
*
* @param dbname	database name
*/
database  string dbname
setdatabasename dbname
this stmttable   new hashtable
initializedefaultstatement
/**
* take database name including attributes and set
* attrstring and shortdbname accordingly.
*
* @param dbname database name, including attributes.
*/
public void setdatabasename string dbname
if  dbname    null
int attroffset   dbname indexof
if  attroffset     1
this attrstring   dbname substring attroffset dbname length
this shortdbname   dbname substring 0 attroffset
else
this shortdbname   dbname
this dbname   dbname
private void initializedefaultstatement
this defaultstatement   new drdastatement this
/**
* set connection and create the sql statement for the default statement
*
* @param conn connection
* @exception sqlexception
*/
final void setconnection engineconnection conn
throws sqlexception
if  this conn    conn
// need to drop the pb session data when switching connections
pbsd_   null
this conn   conn
if conn    null
defaultstatement setstatement conn
/**
* get the connection
*
* @return connection
*/
final engineconnection getconnection
return conn
/**
* get current drda statement
*
* @return drdastatement
* @exception sqlexception
*/
protected drdastatement getcurrentstatement
return currentstatement
/**
* get default statement for use in excimm
*
* @return drdastatement
*/
protected drdastatement getdefaultstatement
currentstatement   defaultstatement
return defaultstatement
/**
* get default statement for use in excimm with specified pkgnamcsn
* the pkgnamcsn has the encoded isolation level
*
* @param pkgnamcsn package/ section # for statement
* @return drdastatement
*/
protected drdastatement getdefaultstatement pkgnamcsn pkgnamcsn
currentstatement   defaultstatement
currentstatement setpkgnamcsn pkgnamcsn
return currentstatement
/**
* get a new drda statement and store it in the stmttable if stortstmt is
* true. if possible recycle an existing statement. when the server gets a
* new statement with a previously used pkgnamcsn, it means that
* client-side statement associated with this pkgnamcsn has been closed. in
* this case, server can re-use the drdastatement by doing the following:
* 1) retrieve the old drdastatement associated with this pkgnamcsn and
* close it.
* 2) reset the drdastatement state for re-use.
*
* @param pkgnamcsn  package name and section
* @return drdastatement
*/
protected drdastatement newdrdastatement pkgnamcsn pkgnamcsn
throws sqlexception
drdastatement stmt   getdrdastatement pkgnamcsn
if  stmt    null
stmt close
stmt reset
else
stmt   new drdastatement this
stmt setpkgnamcsn pkgnamcsn
storestatement stmt
return stmt
/**
* get drda statement based on pkgnamcsn
*
* @param pkgnamcsn - key to access statement
* @return drdastatement
*/
protected drdastatement getdrdastatement pkgnamcsn pkgnamcsn
drdastatement newstmt
drdastatement  stmttable get pkgnamcsn getstatementkey
if  newstmt    null
currentstatement   newstmt
currentstatement setcurrentdrdaresultset pkgnamcsn
return newstmt
/**
* make a new connection using the database name and set
* the connection in the database
* @param p properties for connection attributes to pass to connect
*/
void makeconnection properties p  throws sqlexception
p put attribute username_attr  userid
// take care of case of secmec_usridonl
if  password    null
p put attribute password_attr  password
// contract between network server and embedded engine
// is that any connection returned implements engineconnection.
engineconnection conn    engineconnection
networkservercontrolimpl getdriver   connect attribute protocol
shortdbname   attrstring  p
if  conn    null
conn setautocommit false
setconnection conn
/**
* this makes a dummy connection to the database in order to
* boot and/or create this last one. if database cannot
* be found or authentication does not succeed, this will throw
* a sqlexception which we catch and do nothing. we don't pass a
* userid and password here as we don't need to for the purpose
* of this method - main goal is to cause the database to be
* booted via a dummy connection.
*/
void makedummyconnection
try
// contract between network server and embedded engine
// is that any connection returned implements engineconnection.
engineconnection conn    engineconnection
networkservercontrolimpl getdriver   connect attribute protocol
shortdbname   attrstring  new properties
// if we succeeded in getting a connection, well just close it
if  conn    null
conn close
catch  sqlexception se        simply do nothing
// create string to pass to datasource.setconnectionattributes
string appendattrstring properties p
if  p    null
return null
enumeration pkeys   p propertynames
while  pkeys hasmoreelements
string key    string  pkeys nextelement
attrstring       key        p getproperty key
return attrstring
/**
* store drda prepared statement
* @param  stmt	drda prepared statement
*/
protected void storestatement drdastatement stmt  throws sqlexception
stmttable put stmt getpkgnamcsn   getstatementkey    stmt
protected void removestatement drdastatement stmt  throws sqlexception
stmttable remove stmt getpkgnamcsn   getstatementkey
stmt close
/**
* make statement the current statement
* @param stmt
*
*/
protected void setcurrentstatement drdastatement stmt
currentstatement   stmt
protected void commit   throws sqlexception
if  conn    null
conn commit
protected void rollback   throws sqlexception
if  conn    null
conn rollback
/**
* close the connection and clean up the statement table
* @throws sqlexception on conn.close() error to be handled in drdaconnthread.
*/
protected void close   throws sqlexception
try
if  stmttable    null
for  enumeration e   stmttable elements     e hasmoreelements
drdastatement  e nextelement    close
if  defaultstatement    null
defaultstatement close
if   conn    null      conn isclosed
if    forxa
conn rollback
conn close
finally
conn   null
currentstatement   null
defaultstatement   null
stmttable null
final void setdrdaid string drdaid
if  conn    null
conn setdrdaid drdaid
/**
*  set the internal isolation level to use for preparing statements.
*  subsequent prepares will use this isoalation level
* @param level internal isolation level
*
* @throws sqlexception
* @see engineconnection#setprepareisolation
*
*/
final void setprepareisolation int level  throws sqlexception
conn setprepareisolation level
final int getprepareisolation   throws sqlexception
return conn getprepareisolation
protected string buildruntimeinfo string indent  localizedresource locallangutil
string s   indent
locallangutil gettextmessage
dbname
locallangutil gettextmessage
userid
locallangutil gettextmessage
stmttable size
s    locallangutil gettextmessage
for  enumeration e   stmttable elements     e hasmoreelements
s      drdastatement  e nextelement    todebugstring indent
return s
private boolean locatorsupport   false
private boolean locatorsupportchecked   false
/**
* checks whether database can support locators.  this is done by
* checking whether one of the stored procedures needed for
* locators exists.  (if the database has been soft-upgraded from
* an earlier version, the procedures will not exist).
*
* @throws sqlexception if metadata call fails
* @return <code>true</code> if locators are supported,
*         <code>false</code otherwise
*/
boolean supportslocator   throws sqlexception
if   locatorsupportchecked
// check if locator procedures exist
resultset rs   getconnection   getmetadata
getprocedures null
locatorsupport    rs next        true if procedure exists
rs close
locatorsupportchecked   true
return locatorsupport
/**
* this method resets the state of this database object so that it can
* be re-used.
* note: currently this method resets the variables related to security
* mechanisms that have been investigated as needing a reset.
* todo: investigate what all variables in this class need to be
* reset when this database object is re-used on a connection pooling or
* transaction pooling. see drdaconnthread.parseaccsec (codepoint.rdbnam)
* where database object is re-used on a connection reset.
*/
public void reset
// reset variables for connection re-use. currently only takes care
// of reset the variables that affect eusridpwd and usrssbpwd
// security mechanisms.  (derby-1080)
decrypteduserid   null
decryptedpassword   null
passwordsubstitute   null
sectokenin   null
sectokenout   null
userid   null
password   null
securitymechanism   0
/**
* piggy-backed session data. null if no piggy-backing
* has happened yet. lazy initialization is acceptable since the client's
* cache initially is empty so that any request made prior to the first
* round of piggy-backing will trigger an actual request to the server.
*/
private piggybackedsessiondata pbsd_   null
/**
* get a reference (handle) to the piggybackedsessiondata object. null will
* be returned either if database.conn is not a valid connection, or if the
* create argument is false and no object has yet been created.
* @param createondemand if true create the piggybackedsessiondata on demand
* @return a reference to the pbsd object or null
* @throws java.sql.sqlexception
*/
public piggybackedsessiondata getpiggybackedsessiondata
boolean createondemand  throws sqlexception
pbsd_   piggybackedsessiondata getinstance pbsd_  conn  createondemand
return pbsd_