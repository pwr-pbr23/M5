/*
derby - class org.apache.derby.impl.sql.execute.internaltriggerexecutioncontext
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error publicapi
import org apache derby iapi db triggerexecutioncontext
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql resultset
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql execute execrow
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql execute executionstmtvalidator
import org apache derby iapi sql execute constantaction
import org apache derby iapi sql dictionary triggerdescriptor
import org apache derby iapi error standardexception
import org apache derby iapi services i18n messageservice
import org apache derby iapi reference sqlstate
import org apache derby iapi jdbc connectioncontext
import org apache derby catalog uuid
import java util enumeration
import java util vector
import java util hashtable
import java util map
import java sql connection
import java sql sqlexception
import java sql statement
import org apache derby iapi error exceptionseverity
/**
* there is one of these beasts per insert/delete/update
* statement.  it fulfills the contract for the externally
* visible trigger execution context and it validates
* that a statement that is about to be executed doesn't
* violate the restrictions placed upon what can be executed
* from a trigger.
* <p>
* note that it is crucial that cleanup() is called once
* the dml has completed, cleanup() makes sure that users
* can't do something invalid on a tec reference that they
* were holding from when the trigger fired.
*
*/
public class internaltriggerexecutioncontext implements triggerexecutioncontext  executionstmtvalidator
/*
** immutable
*/
protected int					changedcolids
protected string				changedcolnames
protected int					dmltype
protected string				statementtext
protected connectioncontext		cc
protected uuid					targettableid
protected string				targettablename
protected languageconnectioncontext lcc
/*
** mutable
*/
protected cursorresultset		beforeresultset
protected cursorresultset		afterresultset
/**
* used exclusively for insertresultsets which have autoincrement
* columns.
*/
protected execrow				afterrow
protected boolean				cleanupcalled
protected triggerevent			event
protected triggerdescriptor		triggerd
/*
** used to track all the result sets we have given out to
** users.  when the trigger context is no longer valid,
** we close all the result sets that may be in the user
** space because they can no longer provide meaningful
** results.
*/
private vector	resultsetvector
/**
* aicounters is a vector of autoincrementcounters used to keep state which
* might be used by the trigger. this is only used by insert triggers--
* delete and update triggers do not use this variable.
*
* @see autoincrementcounter
*
*/
private vector aicounters
/**
* aiht is a hashtable of autincrement <key, value> pairs. this is used for
* ai values generated by the trigger.
*/
private hashtable aiht
/**
* build me a big old nasty trigger execution context.
* damnit.
* <p>
* about the only thing of real interest to outside observers
* is that it pushes itself as the trigger execution context
* in the lcc.  be sure to call <i>cleanup()</i> when you
* are done, or you will be flogged like the reprobate that
* you are.
*
* @param lcc	the lcc
* @param statementtext	the text of the statement that caused the
*		trigger to fire.  may be null if we are replicating
* @param changedcolids	the list of columns that changed.  null
*		for all columns or insert/delete.
* @param changedcolnames	the names that correspond to changedcolids
* @param targettableid	the uuid of the table upon which the trigger
*		fired
* @param targettablename	the name of the table upon which the trigger
*		fired
* @param aicounters		a vector of autoincrementcounters to keep state
* 							of the ai columns in this insert trigger.a
*
* @exception standardexception on error
*/
public internaltriggerexecutioncontext
languageconnectioncontext	lcc
connectioncontext			cc
string 						statementtext
int 						dmltype
int						changedcolids
string					changedcolnames
uuid						targettableid
string						targettablename
vector						aicounters
throws standardexception
this dmltype   dmltype
this changedcolids   changedcolids
this changedcolnames   changedcolnames
this statementtext   statementtext
this cc   cc
this lcc   lcc
this targettableid   targettableid
this targettablename   targettablename
this resultsetvector   new vector
this aicounters   aicounters
if  sanitymanager debug
if   changedcolids    null      changedcolnames    null
sanitymanager throwassert
changedcolids    null
changedcolnames    null
if  changedcolids    null
sanitymanager assert changedcolids length    changedcolnames length
lcc pushtriggerexecutioncontext this
void setbeforeresultset cursorresultset rs
beforeresultset   rs
void setafterresultset cursorresultset rs
throws standardexception
afterresultset   rs
if  aicounters    null
if  triggerd isrowtrigger
// an after row trigger needs to see the "first" row inserted
rs open
afterrow   rs getnextrow
rs close
else
// after statement trigger needs to look at the last value.
if   triggerd isbeforetrigger
resetaicounters false
void setcurrenttriggerevent triggerevent event
this event   event
void clearcurrenttriggerevent
event   null
void settrigger triggerdescriptor triggerd
this triggerd   triggerd
void cleartrigger   throws standardexception
event   null
triggerd   null
if  afterresultset    null
afterresultset close
afterresultset   null
if  beforeresultset    null
beforeresultset close
beforeresultset   null
/**
* cleanup the trigger execution context.  <b>must</b>
* be called when the caller is done with the trigger
* execution context.
* <p>
* we go to somewhat exaggerated lengths to free up
* all our resources here because a user may hold on
* to a tec after it is valid, so we clean everything
* up to be on the safe side.
*
* @exception standardexception on unexpected error
*/
protected void cleanup
throws standardexception
lcc poptriggerexecutioncontext this
/*
** explicitly close all result sets that we have
** given out to the user.
*/
for  enumeration e   resultsetvector elements
e hasmoreelements
java sql resultset rs    java sql resultset e nextelement
try
rs close
catch  sqlexception se
resultsetvector   null
/*
** we should have already closed our underlying
** execresultsets by closing the jdbc result sets,
** but in case we got an error that we caught and
** ignored, explicitly close them.
*/
if  afterresultset    null
afterresultset close
afterresultset   null
if  beforeresultset    null
beforeresultset close
beforeresultset   null
lcc   null
cleanupcalled   true
/**
* make sure that the user isn't trying to get a result
* set after we have cleaned up.
*/
private void ensurepropercontext   throws sqlexception
if  cleanupcalled
throw new sqlexception
messageservice gettextmessage
sqlstate lang_statement_closed_no_reason
exceptionseverity statement_severity
/////////////////////////////////////////////////////////
//
// executionstmtvalidator
//
/////////////////////////////////////////////////////////
/**
* make sure that whatever statement is about to be executed
* is ok from the context of this trigger.
* <p>
* note that we are sub classed in replication for checks
* for replication specific language.
*
* @param constantaction the constant action of the action
*	that we are to validate
*
* @exception standardexception on error
*/
public void validatestatement constantaction constantaction  throws standardexception
// ddl statements are not allowed in triggers. direct use of ddl
// statements in a trigger's action statement is disallowed by the
// parser. however, this runtime check is needed to prevent execution
// of ddl statements by procedures within a trigger context.
if  constantaction instanceof ddlconstantaction
throw standardexception newexception sqlstate lang_no_ddl_in_trigger  triggerd getname    constantaction tostring
// no insert/update/delete for a before trigger. there is no need to
// check this here because parser does not allow these dml statements
// in a trigger's action statement in a before trigger. parser also
// disallows creation of before triggers calling procedures that modify
// sql data.
/////////////////////////////////////////////////////////
//
// triggerexectioncontext
//
/////////////////////////////////////////////////////////
/**
* get the target table name upon which the
* trigger event is declared.
*
* @return the target table
*/
public string gettargettablename
return targettablename
/**
* get the target table uuid upon which the
* trigger event is declared.
*
* @return the uuid of the target table
*/
public uuid gettargettableid
return targettableid
/**
* get the type for the event that caused the
* trigger to fire.
*
* @return the event type (e.g. update_event)
*/
public int geteventtype
return dmltype
/**
* get the text of the statement that caused the
* trigger to fire.
*
* @return the statement text
*/
public string geteventstatementtext
return statementtext
/**
* get the columns that have been modified by the statement
* that caused this trigger to fire.  if all columns are
* modified, will return null (e.g. for insert or delete will
* return null).
*
* @return an array of strings
*/
public string getmodifiedcolumns
return changedcolnames
/**
* find out of a column was changed, by column name
*
* @param columnname the column to check
*
* @return true if the column was modified by this statement.
* note that this will always return true for insert
* and delete regardless of the column name passed in.
*/
public boolean wascolumnmodified string columnname
if  changedcolnames    null
return true
for  int i   0  i < changedcolnames length  i
if  changedcolnames equals columnname
return true
return false
/**
* find out of a column was changed, by column number
*
* @param columnnumber the column to check
*
* @return true if the column was modified by this statement.
* note that this will always return true for insert
* and delete regardless of the column name passed in.
*/
public boolean wascolumnmodified int columnnumber
if  changedcolids    null
return true
for  int i   0  i < changedcolnames length  i
if  changedcolids    columnnumber
return true
return false
/**
* returns a result set row the old images of the changed rows.
* for a row trigger, the result set will have a single row.  for
* a statement trigger, this result set has every row that has
* changed or will change.  if a statement trigger does not affect
* a row, then the result set will be empty (i.e. resultset.next()
* will return false).
*
* @return the resultset containing before images of the rows
* changed by the triggering event.
*
* @exception sqlexception if called after the triggering event has
* completed
*/
public java sql resultset getoldrowset   throws sqlexception
ensurepropercontext
if  beforeresultset    null
return null
try
cursorresultset brs   beforeresultset
/* we should really shallow clone the result set, because it could be used
* at multiple places independently in trigger action.  this is a bug found
* during the fix of beetle 4373.
*/
if  brs instanceof temporaryrowholderresultset
brs    cursorresultset    temporaryrowholderresultset  brs  clone
else if  brs instanceof tablescanresultset
brs    cursorresultset    tablescanresultset  brs  clone
brs open
java sql resultset rs   cc getresultset brs
resultsetvector addelement rs
return rs
catch  standardexception se
throw publicapi wrapstandardexception se
/**
* returns a result set row the new images of the changed rows.
* for a row trigger, the result set will have a single row.  for
* a statement trigger, this result set has every row that has
* changed or will change.  if a statement trigger does not affect
* a row, then the result set will be empty (i.e. resultset.next()
* will return false).
*
* @return the resultset containing after images of the rows
* changed by the triggering event.
*
* @exception sqlexception if called after the triggering event has
* completed
*/
public java sql resultset getnewrowset   throws sqlexception
ensurepropercontext
if  afterresultset    null
return null
try
/* we should really shallow clone the result set, because it could be used
* at multiple places independently in trigger action.  this is a bug found
* during the fix of beetle 4373.
*/
cursorresultset ars   afterresultset
if  ars instanceof temporaryrowholderresultset
ars    cursorresultset    temporaryrowholderresultset  ars  clone
else if  ars instanceof tablescanresultset
ars    cursorresultset    tablescanresultset  ars  clone
ars open
java sql resultset rs   cc getresultset ars
resultsetvector addelement rs
return rs
catch  standardexception se
throw publicapi wrapstandardexception se
/**
* like getbeforeresultset(), but returns a result set positioned
* on the first row of the before result set.  used as a convenience
* to get a column for a row trigger.  equivalent to getbeforeresultset()
* followed by next().
*
* @return the resultset positioned on the old row image.
*
* @exception sqlexception if called after the triggering event has
* completed
*/
public java sql resultset getoldrow   throws sqlexception
java sql resultset rs   getoldrowset
if  rs    null
rs next
return rs
/**
* like getafterresultset(), but returns a result set positioned
* on the first row of the before result set.  used as a convenience
* to get a column for a row trigger.  equivalent to getafterresultset()
* followed by next().
*
* @return the resultset positioned on the new row image.
*
* @exception sqlexception if called after the triggering event has
* completed
*/
public java sql resultset getnewrow   throws sqlexception
java sql resultset rs   getnewrowset
if  rs    null
rs next
return rs
public long getautoincrementvalue string identity
// first search the hashtable-- this represents the ai values generated
// by this trigger.
if  aiht    null
long value    long aiht get identity
if  value    null
return value
// if we didn't find it in the hashtable search in the counters which
// represent values inherited by trigger from insert statements.
if  aicounters    null
for  int i   0  i < aicounters size    i
autoincrementcounter aic
autoincrementcounter aicounters elementat i
//				system.out.println("in itec:getaivalue " + aic);
if  identity equals aic getidentity
//					system.out.println("in itec:getvalue--returning " +  aic.getcurrentvalue());
return aic getcurrentvalue
// didn't find it-- return null.
return null
/**
* copy a map of autoincrement values into the trigger
* execution context hashtable of autoincrement values.
*/
public void copyhashtabletoaiht map from
if  from    null
return
if  aiht    null
aiht   new hashtable
aiht putall from
/**
* reset autoincrement counters to the beginning or the end.
*
* @param		begin		if true, reset the autoincremnetcounter to the
*                          beginning-- used to reset the counters for the
* 							next trigger. if false, reset it to the end--
*                          this sets up the counter appropriately for a
*                          after statement trigger.
*/
public void resetaicounters boolean begin
if  aicounters    null
return
afterrow   null
int size   aicounters size
for  int i   0  i < size  i
autoincrementcounter aic
autoincrementcounter aicounters elementat i
aic reset begin
/**
* update autoincrement counters from the last row inserted.
*
*/
public void updateaicounters   throws standardexception
if  aicounters    null
return
int size   aicounters size
for  int i   0  i < size  i
autoincrementcounter aic
autoincrementcounter aicounters elementat i
datavaluedescriptor dvd   afterrow getcolumn aic getcolumnposition
aic update dvd getlong
public string tostring
return triggerd getname