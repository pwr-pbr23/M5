/*
derby - class org.apache.derby.impl.sql.compile.rowresultsetnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services context contextmanager
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile costestimate
import org apache derby iapi sql compile optimizer
import org apache derby iapi sql compile optimizablelist
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile optimizablepredicate
import org apache derby iapi sql compile optimizablepredicatelist
import org apache derby iapi sql compile requiredrowordering
import org apache derby iapi sql compile rowordering
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi sql row
import org apache derby iapi error standardexception
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi store access qualifier
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi util jbitset
import org apache derby iapi reference sqlstate
import org apache derby iapi reference classname
import org apache derby iapi services classfile vmopcode
import java util enumeration
import java util properties
import java util vector
/**
* a rowresultsetnode represents the result set for a values clause.
*
*/
public class rowresultsetnode extends fromtable
subquerylist subquerys
vector		 aggregatevector
orderbylist	 orderbylist
/**
* initializer for a rowresultsetnode.
*
* @param valuesclause	the result column list for the values clause.
* @param tableproperties	properties list associated with the table
*/
public void init object valuesclause  object tableproperties
super init null  tableproperties
resultcolumns    resultcolumnlist  valuesclause
if  resultcolumns    null
resultcolumns markinitialsize
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return
orderbylist    null ? orderbylist tostring
super tostring
else
return
public string statementtostring
return
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  subquerys    null
printlabel depth
subquerys treeprint depth   1
/*
*  optimizable interface
*/
/**
* @see optimizable#estimatecost
*
* @exception standardexception		thrown on error
*/
public costestimate estimatecost optimizablepredicatelist predlist
conglomeratedescriptor cd
costestimate outercost
optimizer optimizer
rowordering rowordering
throws standardexception
/*
** assume for now that the cost of a values clause is zero, with one row
** fetched.  is this true, and if not, does it make a difference?
** there's nothing to optimize in this case.
*/
if  costestimate    null
costestimate   optimizer newcostestimate
costestimate setcost 0 0d  1 0d  1 0d
/* a single row is always ordered */
rowordering optimizablealwaysordered this
return costestimate
/**
* bind the non vti tables in this resultsetnode.  this includes getting their
* descriptors from the data dictionary and numbering them.
*
* @param datadictionary	the datadictionary to use for binding
* @param fromlistparam		fromlist to use/append to.
*
* @return	resultsetnode
*
* @exception standardexception		thrown on error
*/
public resultsetnode bindnonvtitables datadictionary datadictionary
fromlist fromlistparam
throws standardexception
/* assign the tablenumber */
if  tablenumber     1      allow re bind  in which case use old number
tablenumber   getcompilercontext   getnexttablenumber
/* values clause has no tables, so nothing to do */
return this
/**
* bind the expressions in this rowresultsetnode.  this means binding the
* sub-expressions, as well as figuring out what the return type is
* for each expression.
*
* @exception standardexception		thrown on error
*/
public void bindexpressions fromlist fromlistparam
throws standardexception
int nestinglevel
subquerys    subquerylist  getnodefactory   getnode
c_nodetypes subquery_list
getcontextmanager
aggregatevector   new vector
/* verify that there are no defaults in the rcl.
* default is only valid for an insert, and it has
* already been coverted into the tree by the time we get here.
* the grammar allows:
*		values default;
* so we need to check for that here and throw an exception if found.
*/
resultcolumns checkforinvaliddefaults
/* believe it or not, a values clause can contain correlated column references
* and subqueries.  in order to get correlated column resolution working
* correctly, we need to set our nesting level to be 1 deeper than the current
* level and push ourselves into the from list.
*/
/* set the nesting level in this node */
if  fromlistparam size      0
nestinglevel   0
else
nestinglevel     fromtable  fromlistparam elementat 0   getlevel     1
setlevel nestinglevel
fromlistparam insertelementat this  0
resultcolumns bindexpressions fromlistparam  subquerys
aggregatevector
// pop ourselves back out of the from list
fromlistparam removeelementat 0
if  aggregatevector size   > 0
throw standardexception newexception sqlstate lang_no_aggregates_in_where_clause
/**
* bind the expressions in this resultsetnode if it has tables.  this means binding the
* sub-expressions, as well as figuring out what the return type is for
* each expression.
*
* @param fromlistparam		fromlist to use/append to.
*
* @exception standardexception		thrown on error
*/
public void bindexpressionswithtables fromlist fromlistparam
throws standardexception
/* we don't have any tables, so just return */
return
/**
* bind the expressions in the target list.  this means binding the
* sub-expressions, as well as figuring out what the return type is
* for each expression.  this is useful for exists subqueries, where we
* need to validate the target list before blowing it away and replacing
* it with a select true.
*
* @exception standardexception		thrown on error
*/
public void bindtargetexpressions fromlist fromlistparam
throws standardexception
bindexpressions fromlistparam
/**
* bind any untyped null nodes to the types in the given resultcolumnlist.
*
* @param bindingrcl	the resultcolumnlist with the types to bind to.
*
* @exception standardexception		thrown on error
*/
public void binduntypednullstoresultcolumns resultcolumnlist bindingrcl
throws standardexception
/*
** if bindingrcl is null, then we are
** under a cursor node that is inferring
** its rcl from us.  it passes null to
** get union to use both sides of the union
** for the check.  anyway, since there is
** nothing under us but an rcl, just pass
** in our rcl.
*/
if  bindingrcl    null
bindingrcl   resultcolumns
resultcolumns binduntypednullstoresultcolumns bindingrcl
/**
* try to find a resultcolumn in the table represented by this fromtable
* that matches the name in the given columnreference.
*
* @param columnreference	the columnreference whose name we're looking
*				for in the given table.
*
* @return	a resultcolumn whose expression is the columnnode
*			that matches the columnreference.
*		returns null if there is no match.
*
* @exception standardexception		thrown on error
*/
public resultcolumn getmatchingcolumn
columnreference columnreference
throws standardexception
return null
/**
* get the exposed name for this table, which is the name that can
* be used to refer to it in the rest of the query.
*
* @return	the exposed name of this table.
*
* @exception standardexception		thrown on error
*/
public string getexposedname   throws standardexception
return null
/**
* verify that a select * is valid for this type of subquery.
*
* @param outerfromlist	the fromlist from the outer query block(s)
* @param subquerytype	the subquery type
*
* @exception standardexception		thrown on error
*/
public void verifyselectstarsubquery fromlist outerfromlist  int subquerytype
throws standardexception
return
/**
* push the order by list down from the cursor node
* into its child result set so that the optimizer
* has all of the information that it needs to
* consider sort avoidance.
*
* @param orderbylist	the order by list
*/
void pushorderbylist orderbylist orderbylist
this orderbylist   orderbylist
/**
* put a projectrestrictnode on top of each fromtable in the fromlist.
* columnreferences must continue to point to the same resultcolumn, so
* that resultcolumn must percolate up to the new prn.  however,
* that resultcolumn will point to a new expression, a virtualcolumnnode,
* which points to the fromtable and the resultcolumn that is the source for
* the columnreference.
* (the new prn will have the original of the resultcolumnlist and
* the resultcolumns from that list.  the fromtable will get shallow copies
* of the resultcolumnlist and its resultcolumns.  resultcolumn.expression
* will remain at the fromtable, with the prn getting a new
* virtualcolumnnode for each resultcolumn.expression.)
* we then project out the non-referenced columns.  if there are no referenced
* columns, then the prn's resultcolumnlist will consist of a single resultcolumn
* whose expression is 1.
*
* @param numtables			number of tables in the dml statement
* @param gbl				the group by list, if any
* @param fromlist			the from list, if any
*
* @return the generated projectrestrictnode atop the original fromtable.
*
* @exception standardexception		thrown on error
*/
public resultsetnode preprocess int numtables
groupbylist gbl
fromlist fromlist
throws standardexception
if  subquerys size   > 0
subquerys preprocess
numtables
fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
subquerylist  getnodefactory   getnode
c_nodetypes subquery_list
getcontextmanager
predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
/* allocate a dummy referenced table map */
referencedtablemap   new jbitset numtables
referencedtablemap set tablenumber
return this
/**
* ensure that the top of the rsn tree has a predicatelist.
*
* @param numtables			the number of tables in the query.
* @return resultsetnode	a rsn tree with a node which has a predicatelist on top.
*
* @exception standardexception		thrown on error
*/
public resultsetnode ensurepredicatelist int numtables
throws standardexception
return genprojectrestrict numtables
/**
* add a new predicate to the list.  this is useful when doing subquery
* transformations, when we build a new predicate with the left side of
* the subquery operator and the subquery's result column.
*
* @param predicate		the predicate to add
*
* @return resultsetnode	the new top of the tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode addnewpredicate predicate predicate
throws standardexception
predicatelist		predlist
resultcolumnlist	prrclist
resultsetnode		newprn
/* we are the body of a quantified predicate subquery.  we
* need to generate (and return) a prn above us so that there will be
* a place to attach the new predicate.
*/
/* we get a shallow copy of the resultcolumnlist and its
* resultcolumns.  (copy maintains resultcolumn.expression for now.)
*/
prrclist   resultcolumns
resultcolumns   resultcolumns copylistandobjects
/* replace resultcolumn.expression with new virtualcolumnnodes
* in the projectrestrictnode's resultcolumnlist.  (virtualcolumnnodes include
* pointers to source resultsetnode, this, and source resultcolumn.)
*/
prrclist genvirtualcolumnnodes this  resultcolumns
/* put the new predicate in a list */
predlist    predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
predlist addpredicate predicate
/* finally, we create the new projectrestrictnode */
return  resultsetnode  getnodefactory   getnode
c_nodetypes project_restrict_node
this
prrclist
null 	   restriction
predlist       restriction as predicatelist
null 	   project subquery list
null 	   restrict subquery list
tableproperties
getcontextmanager
/**
* evaluate whether or not the subquery in a fromsubquery is flattenable.
* currently, a fsqry is flattenable if all of the following are true:
*		o  subquery is a selectnode or a rowresultsetnode (not a unionnode)
*		o  it contains no top level subqueries.  (resolve - we can relax this)
*		o  it does not contain a group by or having clause
*		o  it does not contain aggregates.
*		o  there is at least one result set in the from list that is
*		   not a rowresultsetnode (the reason is to avoid having
*		   an outer selectnode with an empty fromlist.
*
* @param fromlist	the outer from list
*
* @return boolean	whether or not the fromsubquery is flattenable.
*/
public boolean flattenableinfromsubquery fromlist fromlist
if   subquerys    null
subquerys size   > 0
return false
if   aggregatevector    null
aggregatevector size   > 0
return false
/*
** don't flatten if select list contains something
** that isn't clonable
*/
if     resultcolumns iscloneable
return false
boolean nonrowresultsetfound   false
int flsize   fromlist size
for  int index   0  index < flsize  index
fromtable ft    fromtable  fromlist elementat index
if  ft instanceof fromsubquery
resultsetnode subq     fromsubquery  ft  getsubquery
if      subq instanceof rowresultsetnode
nonrowresultsetfound   true
break
else
nonrowresultsetfound   true
break
return nonrowresultsetfound
/**
* optimize this selectnode.  this means choosing the best access path
* for each table, among other things.
*
* @param datadictionary	the datadictionary to use for optimization
* @param predicatelist		the predicate list to optimize against
* @param outerrows			the number of outer joining rows
*
* @return	resultsetnode	the top of the optimized tree
*
* @exception standardexception		thrown on error
*/
public resultsetnode optimize datadictionary datadictionary
predicatelist	predicatelist
double outerrows
throws standardexception
/*
** get an optimizer.  the only reason we need one is to get a
** costestimate object, so we can represent the cost of this node.
** this seems like overkill, but it's just an object allocation...
*/
optimizer optimizer
getoptimizer
fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
predicatelist
datadictionary
requiredrowordering  null
costestimate   optimizer newcostestimate
// resolve: the cost should take subqueries into account
costestimate setcost 0 0d  outerrows  outerrows
subquerys optimize datadictionary  outerrows
return this
/**
* @see optimizable#modifyaccesspath
*
* @exception standardexception		thrown on error
*/
public optimizable modifyaccesspath jbitset outertables  throws standardexception
/* for most types of optimizable, do nothing */
return  optimizable  modifyaccesspaths
/**
* @see resultsetnode#modifyaccesspaths
*
* @exception standardexception		thrown on error
*/
public resultsetnode modifyaccesspaths   throws standardexception
resultsetnode treetop   this
subquerys modifyaccesspaths
/* generate the orderbynode if a sort is still required for
* the order by.
*/
if  orderbylist    null
treetop    resultsetnode  getnodefactory   getnode
c_nodetypes order_by_node
treetop
orderbylist
tableproperties
getcontextmanager
return treetop
/**
* return whether or not this resultset tree is guaranteed to return
* at most 1 row based on heuristics.  (a rowresultsetnode and a
* select with a non-grouped aggregate will return at most 1 row.)
*
* @return whether or not this resultset tree is guaranteed to return
* at most 1 row based on heuristics.
*/
boolean returnsatmostonerow
return true
/**
* the generated resultset will be:
*
*      rowresultset -- for the values clause
*
*
* @exception standardexception		thrown on error
*/
public void generate activationclassbuilder acb
methodbuilder mb
throws standardexception
if  sanitymanager debug
sanitymanager assert resultcolumns    null
// get our final cost estimate.
costestimate   getfinalcostestimate
/*
** check and see if everything below us is a constant or not.
** if so, we'll let execution know that it can do some caching.
** before we do the check, we are going to temporarily set
*/
boolean cancache   canwecacheresults
/* get the next resultset #, so that we can number this resultsetnode, its
* resultcolumnlist and resultset.
*/
assignresultsetnumber
// we are dealing with
// values(value1, value2, value3)
// so we generate a rowresultset to return the values listed.
// we can reduce the tree to one rowresultset
// since there is nothing but the resultcolumns
// rowresultset takes the row-generating function
// so we generate one and get back the expression
// pointing to it.
//
// generate the expression to return, which is:
// resultsetfactory.getrowresultset(this, planx.exprn)
// [planx is the name of the class being generated,
// exprn is the name of the function being generated.]
acb pushgetresultsetfactoryexpression mb
acb pushthisasactivation mb
resultcolumns generate acb  mb
mb push cancache
mb push resultsetnumber
mb push costestimate rowcount
mb push costestimate getestimatedcost
mb callmethod vmopcode invokeinterface   string  null
classname noputresultset  6
/**
* replace any defaults with the associated tree for the default.
*
* @param ttd	the tabledescriptor for the target table.
* @param tcl	the rcl for the target table.
*
* @exception standardexception		thrown on error
*/
void replacedefaults tabledescriptor ttd  resultcolumnlist tcl
throws standardexception
resultcolumns replacedefaults ttd  tcl
/**
* optimize any subqueries that haven't been optimized any where
* else.  this is useful for a rowresultsetnode as a derived table
* because it doesn't get optimized otherwise.
*
* @exception standardexception		thrown on error
*/
void optimizesubqueries datadictionary dd  double rowcount
throws standardexception
subquerys optimize dd  rowcount
/**
* @see resultsetnode#adjustforsortelimination
*/
void adjustforsortelimination
/*
** check and see if everything below us is a constant or not.
** if so, we'll let execution know that it can do some caching.
** before we do the check, we are going to temporarily set
** parameternodes to constant.  we do this because we know
** that we can cache a row with a parameter value and get
** the param column reset by the user setting a param, so
** we can skip over parameter nodes.  we are doing this
** extra work to optimize inserts of the form:
**
** prepare: insert into mytab values (?,?);
** setparam
** execute()
** setparam
** execute()
*/
private boolean canwecacheresults   throws standardexception
/*
** check the tree below us
*/
hasvariantvaluenodevisitor visitor
new hasvariantvaluenodevisitor qualifier query_invariant  true
super accept visitor
boolean cancache    visitor hasvariant
return cancache