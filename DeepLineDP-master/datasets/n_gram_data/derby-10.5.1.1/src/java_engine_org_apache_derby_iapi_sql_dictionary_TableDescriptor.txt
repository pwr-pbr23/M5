/*
derby - class org.apache.derby.iapi.sql.dictionary.tabledescriptor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import java util enumeration
import java util iterator
import java util list
import java util weakhashmap
import org apache derby catalog dependable
import org apache derby catalog dependablefinder
import org apache derby catalog uuid
import org apache derby iapi error standardexception
import org apache derby iapi services io formatablebitset
import org apache derby iapi services io storedformatids
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql statementtype
import org apache derby iapi sql depend provider
import org apache derby iapi sql execute execrow
import org apache derby iapi types datavaluedescriptor
/**
* this class represents a table descriptor. the external interface to this
* class is:
<p>
<ol>
<li>external interface </li>
<li>public string	getschemaname();</li>
<li>public string	getqualifiedname();</li>
<li>public int	gettabletype();</li>
<li>public long getheapconglomerateid() throws standardexception;</li>
<li>public int getnumberofcolumns();		</li>
<li>public formatablebitset getreferencedcolumnmap();</li>
<li>public void setreferencedcolumnmap(formatablebitset referencedcolumnmap);</li>
<li>public int getmaxcolumnid() throws standardexception;</li>
<li>public void	setuuid(uuid uuid);</li>
<li>public char	getlockgranularity();</li>
<li>public void	settablename(string newtablename);</li>
<li>public void	setlockgranularity(char lockgranularity);</li>
<li>public execrow getemptyexecrow( contextmanager cm) throws standardexception;</li>
<li>public boolean tablenameequals(string otherschemaname, string othertablename);</li>
<li>public referencedkeyconstraintdescriptor getprimarykey() throws standardexception;</li>
<li>public void removeconglomeratedescriptor(conglomeratedescriptor cd)	throws standardexception;</li>
<li>public void removeconstraintdescriptor(constraintdescriptor cd)	throws standardexception;</li>
<li>public void getaffectedindexes(...) throws standardexception;</li>
<li>public void	getallrelevanttriggers(...) throws standardexception;</li>
<li>public void getallrelevantconstraints(...) throws standardexception</li>
<li>public columndescriptorlist getcolumndescriptorlist();</li>
<li> public string[] getcolumnnamesarray();</li>
<li>public long[]   getautoincincrementarray();</li>
<li>public columndescriptor	getcolumndescriptor(string columnname);</li>
<li>public columndescriptor	getcolumndescriptor(int columnnumber);</li>
<li>public conglomeratedescriptor[]	getconglomeratedescriptors() throws standardexception;</li>
<li>public conglomeratedescriptor	getconglomeratedescriptor(long conglomeratenumber)	throws standardexception;</li>
<li>public conglomeratedescriptor	getconglomeratedescriptor(uuid conglomerateuuid) throws standardexception;</li>
<li>public	indexlister	getindexlister() throws standardexception;</li>
<li>public viewdescriptor getviewdescriptor();</li>
<li>public boolean tablehasautoincrement();</li>
<li>public boolean statisticsexist(conglomeratedescriptor cd) throws standardexception;</li>
<li>public double selectivityforconglomerate(...)throws standardexception;</li>
</ol>
<p>
*
*/
public class tabledescriptor extends tupledescriptor
implements uniquesqlobjectdescriptor  provider
public static final int base_table_type   0
public static final int system_table_type   1
public static final int view_type   2
public static final int global_temporary_table_type   3
public static final int synonym_type   4
public static final int vti_type   5
public static final char	row_lock_granularity
public static final char	table_lock_granularity
public static final char	default_lock_granularity   row_lock_granularity
/**
*/
// implementation
private char					lockgranularity
private boolean					oncommitdeleterows    true means on commit delete rows  false means on commit preserve rows of temporary table
private boolean					onrollbackdeleterows    true means on rollback delete rows  this is the only value supported
schemadescriptor				schema
string							tablename
uuid							oid
int								tabletype
long							heapconglomnumber    1
columndescriptorlist		columndescriptorlist
conglomeratedescriptorlist		conglomeratedescriptorlist
constraintdescriptorlist		constraintdescriptorlist
private	genericdescriptorlist	triggerdescriptorlist
viewdescriptor					viewdescriptor
/**
* referencedcolumnmap is thread local (since derby-2861)
*
* it contains a weak hash map keyed by the the tabledescriptor
* and the value is the actual referencedcolumnmap bitmap.  so,
* each thread has a weak hash map it uses to find the appropriate
* referencedcolumnmap for 'this' tabledescriptor.
*
* since the hash map is weak, when the tabledescriptor is no
* longer referenced the hash entry can be garbage collected (it
* is the *key* of a weak hash map that is weak, not the value).
*/
private static threadlocal referencedcolumnmap   new threadlocal
protected object initialvalue
// key: tabledescriptor
// value: formatablebitset
return new weakhashmap
private formatablebitset referencedcolumnmapget
weakhashmap map    weakhashmap  referencedcolumnmap get
return  formatablebitset   map get this
private void referencedcolumnmapput
formatablebitset newreferencedcolumnmap
weakhashmap map    weakhashmap  referencedcolumnmap get
map put this  newreferencedcolumnmap
/** a list of statistics pertaining to this table--
*/
private list					statisticsdescriptorlist
/**
* constructor for a tabledescriptor (this is for a temporary table).
*
* @param datadictionary		the data dictionary that this descriptor lives in
* @param tablename	the name of the temporary table
* @param schema	the schema descriptor for this table.
* @param tabletype	an integer identifier for the type of the table : declared global temporary table
* @param oncommitdeleterows	if true, on commit delete rows else on commit preserve rows of temporary table.
* @param onrollbackdeleterows	if true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
*/
public tabledescriptor
datadictionary		datadictionary
string				tablename
schemadescriptor	schema
int					tabletype
boolean				oncommitdeleterows
boolean				onrollbackdeleterows
this datadictionary  tablename  schema  tabletype
this oncommitdeleterows   oncommitdeleterows
this onrollbackdeleterows   onrollbackdeleterows
/**
* constructor for a tabledescriptor.
*
* @param datadictionary		the data dictionary that this descriptor lives in
* @param tablename	the name of the table
* @param schema	the schema descriptor for this table.
* @param tabletype	an integer identifier for the type of the table
*			(base table, view, etc.)
* @param lockgranularity	the lock granularity.
*/
public tabledescriptor
datadictionary		datadictionary
string				tablename
schemadescriptor	schema
int					tabletype
char				lockgranularity
super  datadictionary
this schema   schema
this tablename   tablename
this tabletype   tabletype
this lockgranularity   lockgranularity
this conglomeratedescriptorlist   new conglomeratedescriptorlist
this columndescriptorlist   new columndescriptorlist
this constraintdescriptorlist   new constraintdescriptorlist
this triggerdescriptorlist   new genericdescriptorlist
//
// tabledescriptor interface
//
/**
* gets the name of the schema the table lives in.
*
* @return	a string containing the name of the schema the table
*		lives in.
*/
public string	getschemaname
return schema getschemaname
/**
* gets the schemadescriptor for this tabledescriptor.
*
* @return schemadescriptor	the schemadescriptor.
*/
public schemadescriptor getschemadescriptor
return schema
/**
* gets the name of the table.
*
* @return	a string containing the name of the table.
*/
public string	getname
return tablename
/**
* sets the the table name in case of rename table.
*
* this is used only by rename table
* @param newtablename	the new table name.
*/
public void	settablename string newtablename
this tablename   newtablename
/**
* gets the full, qualified name of the table.
*
* @return	a string containing the name of the table.
*/
public string	getqualifiedname
//quoteprotectname is for bug 3476.
return quoteprotectname getschemaname
quoteprotectname getname
/**
* if the name has double quotes in it, put two double quotes for every single
* double quote.
* finally put double quotes around string to protect against
* names with blanks, reserved words being used as identifiers etc.
* for eg, if table name is m"n, return it as "m""n". for now, this is used
* by dmlmodstatementnode.parsecheckconstraint().
*
* possible improvement: we could possibly analyze string to
* avoid double quotes in normal cases.
*
* @param name	the string with or without double quotes
*
* @return	the quoted string
*/
private string quoteprotectname string name
string quotedstring   name
int quotepos   name indexof  "
if  quotepos     1
return
//string does have quotes in it.
while quotepos     1
quotedstring   quotedstring substring 0 quotepos     "
quotedstring substring quotepos
quotepos   quotedstring indexof  " quotepos 2
return
/**
* gets the uuid of the table.
*
* @return	the uuid of the table.
*/
public uuid	getuuid
return oid
/**
* gets an identifier telling what type of table this is
* (base table, declared global temporary table, view, etc.)
*
* @return	an identifier telling what type of table this is.
*/
public int	gettabletype
return tabletype
/**
* gets the id for the heap conglomerate of the table.
* there may also be keyed conglomerates, these are
* stored separately in the conglomerates table.
*
* @return the id of the heap conglomerate for the table.
*
* @exception standardexception		thrown on error
*/
public long getheapconglomerateid
throws standardexception
datadictionary dd   getdatadictionary
conglomeratedescriptor cd   null
/* if we've already cached the heap conglomerate number, then
* simply return it.
*/
if  heapconglomnumber     1
return heapconglomnumber
conglomeratedescriptor cds   getconglomeratedescriptors
for  int index   0  index < cds length  index
cd   cds
if     cd isindex
break
if  sanitymanager debug
if  cd    null
sanitymanager throwassert
tablename
if  cd isindex
sanitymanager throwassert
tablename
heapconglomnumber   cd getconglomeratenumber
return heapconglomnumber
/**
* gets the number of columns in the table.
*
* @return the number of columns in the table.
*
*/
public int getnumberofcolumns
return getcolumndescriptorlist   size
/**
* get the referenced column map of the table.
*
* @return the referencedcolumnmap of the table.
*
*/
public formatablebitset getreferencedcolumnmap
return referencedcolumnmapget
/**
* set the referenced column map of the table.
*
* @param	referencedcolumnmap	formatablebitset of referenced columns.
*
*/
public void setreferencedcolumnmap formatablebitset referencedcolumnmap
referencedcolumnmapput referencedcolumnmap
/**
* given a list of columns in the table, construct a bit  map of those
* columns' ids.
*
* @param cdl list of columns whose positions we want to record in the bit map
*/
public formatablebitset makecolumnmap  columndescriptorlist cdl
formatablebitset    result   new formatablebitset  columndescriptorlist size     1
int                         count   cdl size
for   int i   0  i < count  i
columndescriptor    cd   cdl elementat  i
result set  cd getposition
return result
/**
* gets the highest column id in the table. for now this is the same as
* the number of columns. however, in the future, after we implement
* alter table drop column, this correspondence won't hold any longer.
*
* @return the highest column id in the table
*
* @exception standardexception		thrown on error
*/
public int getmaxcolumnid
throws standardexception
int					maxcolumnid   1
int cdlsize   getcolumndescriptorlist   size
for  int index   0  index < cdlsize  index
columndescriptor cd    columndescriptor  columndescriptorlist elementat index
maxcolumnid   math max  maxcolumnid  cd getposition
return maxcolumnid
/**
* sets the uuid of the table
*
* @param oid	the uuid of the table to be set in the descriptor
*/
public void setuuid uuid oid
this oid   oid
/**
* gets the lock granularity for the table.
*
* @return	a char representing the lock granularity for the table.
*/
public char	getlockgranularity
return lockgranularity
/**
* sets the lock granularity for the table to the specified value.
*
* @param lockgranularity	the new lockgranularity.
*/
public void	setlockgranularity char lockgranularity
this lockgranularity   lockgranularity
/**
* gets the on rollback behavior for the declared global temporary table.
*
* @return	a boolean representing the on rollback behavior for the declared global temporary table.
*/
public boolean	isonrollbackdeleterows
return onrollbackdeleterows
/**
* gets the on commit behavior for the declared global temporary table.
*
* @return	a boolean representing the on commit behavior for the declared global temporary table.
*/
public boolean	isoncommitdeleterows
return oncommitdeleterows
/**
* sets the heapconglomnumber to -1 for temporary table since the table was dropped and recreated at the commit time
* and hence its conglomerate id has changed. this is used for temporary table descriptors only
*/
public void	resetheapconglomnumber
if  sanitymanager debug
if  tabletype    tabledescriptor global_temporary_table_type
sanitymanager throwassert
tabletype
heapconglomnumber    1
/**
* gets an execrow for rows stored in the table this describes.
*
*
*	@return	the row.
*  @exception standardexception		thrown on failure
*/
public execrow getemptyexecrow
throws standardexception
int							columncount   getnumberofcolumns
execrow result
getdatadictionary   getexecutionfactory   getvaluerow columncount
for  int index   0  index < columncount  index
columndescriptor cd    columndescriptor  columndescriptorlist elementat index
//string name = column.getcolumnname();
datavaluedescriptor datavalue   cd gettype   getnull
result setcolumn index   1  datavalue
return result
/**
* return an array of collation ids for this table.
* <p>
* return an array of collation ids, one for each column in the
* columndescriptorlist.  this is useful for passing collation id info
* down to store, for instance in createconglomerate().
*
* this is only expected to get called during ddl, so object allocation
* is ok.
*
* @exception  standardexception  standard exception policy.
**/
public int getcolumncollationids
throws standardexception
int collation_ids   new int
for  int index   0  index < collation_ids length  index
columndescriptor cd
columndescriptor  columndescriptorlist elementat index
collation_ids   cd gettype   getcollationtype
return collation_ids
/**
* gets the conglomerate descriptor list
*
* @return	the conglomerate descriptor list for this table descriptor
*/
public conglomeratedescriptorlist getconglomeratedescriptorlist
return conglomeratedescriptorlist
/**
* gets the view descriptor for this tabledescriptor.
*
* @return viewdescriptor	the viewdescriptor, if any.
*/
public viewdescriptor getviewdescriptor
return viewdescriptor
/**
* set (cache) the view descriptor for this tabledescriptor
*
* @param viewdescriptor	the view descriptor to cache.
*/
public void setviewdescriptor viewdescriptor viewdescriptor
if  sanitymanager debug
if  tabletype    tabledescriptor view_type
sanitymanager throwassert
tabletype
this viewdescriptor   viewdescriptor
/**
* is this provider persistent?  a stored dependency will be required
* if both the dependent and provider are persistent.
*
* @return boolean              whether or not this provider is persistent.
*/
public boolean ispersistent
if  tabletype    tabledescriptor global_temporary_table_type
return false
else
return super ispersistent
/**
* is this descriptor represents a synonym?
*
* @return boolean              whether or not this represents a synonym
*/
public boolean issynonymdescriptor
if  tabletype    tabledescriptor synonym_type
return true
return false
/**
* gets the number of indexes on the table, including the backing indexes.
*
* @return the number of columns in the table.
*
*/
public int gettotalnumberofindexes
throws standardexception
int totalnumberofindexes   0
conglomeratedescriptor	cds   getconglomeratedescriptors
for  int index   0  index < cds length  index
if  cds isindex      totalnumberofindexes
return totalnumberofindexes
/**
*	builds a list of all triggers which are relevant to a
*	given statement type, given a list of updated columns.
*
*	@param	statementtype		defined in statementtype
*	@param	changedcolumnids	array of changed columns
*	@param	relevanttriggers	in/out. passed in as an empty list. filled in as we go.
*
* @exception standardexception		thrown on error
*/
public	void	getallrelevanttriggers
int						statementtype
int					changedcolumnids
genericdescriptorlist	relevanttriggers
throws standardexception
if  sanitymanager debug
sanitymanager assert  statementtype    statementtype insert
statementtype    statementtype bulk_insert_replace
statementtype    statementtype update
statementtype    statementtype delete
statementtype
datadictionary				dd   getdatadictionary
enumeration descs   dd gettriggerdescriptors this  elements
while  descs hasmoreelements
triggerdescriptor tgr    triggerdescriptor descs nextelement
if  tgr needstofire statementtype  changedcolumnids
relevanttriggers add tgr
/**
*	gets all of the relevant constraints for a statement, given its
*	statement type and its list of updated columns.
*
*	@param	statementtype			as defined in statementtype.
* @param	skipcheckconstraints	skip check constraints
* @param	changedcolumnids		if null, all columns being changed, otherwise array
*									of 1-based column ids for columns being changed
*	@param	needsdeferredprocessing	in/out. true if the statement already needs
*											deferred processing. set while evaluating this
*											routine if a trigger or constraint requires
*											deferred processing
*	@param	relevantconstraints		in/out. empty list is passed in. we hang constraints on it as we go.
*
* @exception standardexception		thrown on error
*/
public	void	getallrelevantconstraints
int							statementtype
boolean						skipcheckconstraints
int						changedcolumnids
boolean					needsdeferredprocessing
constraintdescriptorlist	relevantconstraints
throws standardexception
if  sanitymanager debug
sanitymanager assert  statementtype    statementtype insert
statementtype    statementtype bulk_insert_replace
statementtype    statementtype update
statementtype    statementtype delete
statementtype
datadictionary					dd   getdatadictionary
constraintdescriptorlist		cdl   dd getconstraintdescriptors this
int cdlsize   cdl size
for  int index   0  index < cdlsize  index
constraintdescriptor cd   cdl elementat index
if  skipcheckconstraints
cd getconstrainttype      datadictionary check_constraint
continue
/*
** for each constraint, figure out if it requires deferred processing.
** note that we need to do this on constraints that don't
** necessarily need to fire -- e.g. for an insert into a
** a table with a self-referencing constraint, we don't
** need to check the primary key constraint (assuming it
** is only referenced by the self-referencing fk on the same
** table), but we have to run in deferred mode nonetheless
** (even though we aren't going to check the pk constraint).
*/
if   needsdeferredprocessing
cd instanceof referencedkeyconstraintdescriptor
statementtype    statementtype update
statementtype    statementtype bulk_insert_replace
/* for insert (bulk or regular) on a non-published table,
* we only need deferred mode if there is a
* self-referencing foreign key constraint.
*/
needsdeferredprocessing     referencedkeyconstraintdescriptor cd
hasselfreferencingfk cdl  constraintdescriptor enabled
if  cd needstofire statementtype  changedcolumnids
/*
** for update, if we are updating a referenced key, then
** we have to do it in deferred mode (in case we update
** multiple rows).
*/
if   cd instanceof referencedkeyconstraintdescriptor
statementtype    statementtype update
statementtype    statementtype bulk_insert_replace
needsdeferredprocessing   true
relevantconstraints add cd
//
// provider interface
//
/**
@return the stored form of this provider
@see dependable#getdependablefinder
*/
public dependablefinder getdependablefinder
if  referencedcolumnmapget      null
return	getdependablefinder storedformatids table_descriptor_finder_v01_id
else
return getcolumndependablefinder
storedformatids column_descriptor_finder_v01_id
referencedcolumnmapget   getbytearray
/**
* return the name of this provider.  (useful for errors.)
*
* @return string	the name of this provider.
*/
public string getobjectname
if  referencedcolumnmapget      null
return tablename
else
string name   new string tablename
boolean first   true
for  int i   0  i < columndescriptorlist size    i
columndescriptor cd    columndescriptor  columndescriptorlist elementat i
if  referencedcolumnmapget   isset cd getposition
if  first
name        cd getcolumnname
first   false
else
name        cd getcolumnname
if    first
name
return name
/**
* get the provider's uuid
*
* @return string	the provider's uuid
*/
public uuid getobjectid
return oid
/**
* get the provider's type.
*
* @return string		the provider's type.
*/
public string getclasstype
return dependable table
//
// class interface
//
/**
* prints the contents of the tabledescriptor
*
* @return the contents as a string
*/
public string tostring
if  sanitymanager debug
string tempstring       schema       tablename
oid       tabletype
conglomeratedescriptorlist
columndescriptorlist
constraintdescriptorlist
heapconglomnumber
if  tabletype    tabledescriptor global_temporary_table_type
tempstring   tempstring           oncommitdeleterows
tempstring   tempstring           onrollbackdeleterows
else
tempstring   tempstring       lockgranularity
return tempstring
else
return
/**
* gets the column descriptor list
*
* @return	the column descriptor list for this table descriptor
*
*/
public columndescriptorlist getcolumndescriptorlist
return columndescriptorlist
/**
* gets the list of columns defined by generation clauses.
*/
public columndescriptorlist getgeneratedcolumns
columndescriptorlist    fulllist   getcolumndescriptorlist
columndescriptorlist    result   new columndescriptorlist
int                                 count   fulllist size
for   int i   0  i < count  i
columndescriptor    cd   fulllist elementat  i
if   cd hasgenerationclause       result add  oid  cd
return result
/**
* turn an array of column names into the corresponding 1-based column positions.
*/
public int    getcolumnids  string names
int     count   names length
int    result   new int
for   int i   0  i < count  i
result   getcolumndescriptor  names   getposition
return result
/**
* gets the constraint descriptor list
*
* @return	the constraint descriptor list for this table descriptor
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptorlist getconstraintdescriptorlist
throws standardexception
return constraintdescriptorlist
/**
* sets the constraint descriptor list
*
* @param newcdl	the new constraint descriptor list for this table descriptor
*/
public void setconstraintdescriptorlist constraintdescriptorlist newcdl
constraintdescriptorlist   newcdl
/**
* empty the constraint descriptor list
*
* @exception standardexception		thrown on failure
*/
public void emptyconstraintdescriptorlist
throws standardexception
// easier just to get a new cdl then to clean out the current one
this constraintdescriptorlist   new constraintdescriptorlist
/**
* gets the primary key, may return null if no primary key
*
* @return	the priamry key or null
*
* @exception standardexception		thrown on failure
*/
public referencedkeyconstraintdescriptor getprimarykey
throws standardexception
constraintdescriptorlist cdl   getdatadictionary   getconstraintdescriptors this
return cdl getprimarykey
/**
* gets the trigger descriptor list
*
* @return	the trigger descriptor list for this table descriptor
*
* @exception standardexception		thrown on failure
*/
public genericdescriptorlist gettriggerdescriptorlist
throws standardexception
return triggerdescriptorlist
/**
* sets the trigger descriptor list
*
* @param newcdl	the new trigger descriptor list for this table descriptor
*/
public void settriggerdescriptorlist genericdescriptorlist newcdl
triggerdescriptorlist   newcdl
/**
* empty the trigger descriptor list
*
* @exception standardexception		thrown on failure
*/
public void emptytriggerdescriptorlist
throws standardexception
// easier just to get a new cdl then to clean out the current one
this triggerdescriptorlist   new genericdescriptorlist
/**
* compare the tables descriptors based on the names.
* null schema names match.
*
* @param othertablename	the other table name
* @param otherschemaname	the other schema name
*
* @return boolean		whether or not the 2 tablenames are equal.
*/
public boolean tablenameequals string othertablename  string otherschemaname
string schemaname   getschemaname
if   schemaname    null
otherschemaname    null
return tablename equals othertablename
else
return	schemaname equals otherschemaname
tablename equals othertablename
/**
* remove this descriptor
*
* @param	cd	the conglomerate descriptor
*
* @exception standardexception on error
*/
public void removeconglomeratedescriptor conglomeratedescriptor cd
throws standardexception
conglomeratedescriptorlist dropconglomeratedescriptor getuuid    cd
/**
* remove this descriptor.  warning, removes by using object
* reference, not uuid.
*
* @param	cd constraint descriptor
*
* @exception standardexception on error
*/
public void removeconstraintdescriptor constraintdescriptor cd
throws standardexception
constraintdescriptorlist remove cd
/**
* get the descriptor for a column in the table,
* either by the column name or by its ordinal position (column number).
* returns null for columns that do not exist.
*
* @param columnname	a string containing the name of the column
*
* @return	a columndescriptor describing the column
*/
public columndescriptor	getcolumndescriptor string columnname
return columndescriptorlist getcolumndescriptor oid  columnname
/**
* @param columnnumber	the ordinal position of the column in the table
*
* @return	a columndescriptor describing the column
*/
public columndescriptor	getcolumndescriptor int columnnumber
return columndescriptorlist getcolumndescriptor oid  columnnumber
/**
* gets a conglomeratedescriptor[] to loop through all the conglomerate descriptors
* for the table.
*
* @return	a conglomeratedescriptor[] for looping through the table's conglomerates
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptors
int size   conglomeratedescriptorlist size
conglomeratedescriptor cdls   new conglomeratedescriptor
conglomeratedescriptorlist toarray cdls
return cdls
/**
* gets a conglomerate descriptor for the given table and conglomerate number.
*
* @param conglomeratenumber	the conglomerate number
*				we're interested in
*
* @return	a conglomeratedescriptor describing the requested
*		conglomerate. returns null if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptor
long conglomeratenumber
throws standardexception
return conglomeratedescriptorlist getconglomeratedescriptor conglomeratenumber
/**
* gets array of conglomerate descriptors for the given table and
* conglomerate number.  more than one descriptors if duplicate indexes
* share one conglomerate.
*
* @param conglomeratenumber	the conglomerate number
*				we're interested in
*
* @return	array of conglomeratedescriptors with the requested
*		conglomerate number. returns size 0 array if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptors
long conglomeratenumber
throws standardexception
return conglomeratedescriptorlist getconglomeratedescriptors conglomeratenumber
/**
* gets a conglomerate descriptor for the given table and conglomerate uuid string.
*
* @param conglomerateuuid	the uuid  for the conglomerate
*				we're interested in
*
* @return	a conglomeratedescriptor describing the requested
*		conglomerate. returns null if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptor
uuid conglomerateuuid
throws standardexception
return conglomeratedescriptorlist getconglomeratedescriptor conglomerateuuid
/**
* gets array of conglomerate descriptors for the given table and
* conglomerate uuid.  more than one descriptors if duplicate indexes
* share one conglomerate.
*
* @param conglomerateuuid	the conglomerate uuid
*				we're interested in
*
* @return	array of conglomeratedescriptors with the requested
*		conglomerate uuid. returns size 0 array if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptors
uuid conglomerateuuid
throws standardexception
return conglomeratedescriptorlist getconglomeratedescriptors conglomerateuuid
/**
* gets an object which lists out all the index row generators on a table together
* with their conglomerate ids.
*
* @return	an object to list out the index row generators.
*
* @exception standardexception		thrown on failure
*/
public	indexlister	getindexlister
throws standardexception
return new indexlister  this
/**
* does the table have an autoincrement column or not?
*
* @return true if the table has atleast one autoincrement column, false
* otherwise
*/
public boolean tablehasautoincrement
int cdlsize   getcolumndescriptorlist   size
for  int index   0  index < cdlsize  index
columndescriptor cd
columndescriptor  columndescriptorlist elementat index
if  cd isautoincrement
return true
return false
/**
* gets an array of column names.
*
* @return an array, filled with the column names in the table.
*
*/
public string getcolumnnamesarray
int size   getnumberofcolumns
string s   new string
for  int i   0  i < size  i
s   getcolumndescriptor i 1  getcolumnname
return s
/**
* gets an array of increment values for autoincrement columns in the target
* table. if column is not an autoincrement column, then increment value is
* 0. if table has no autoincrement columns, returns null.
*
* @return		array containing the increment values of autoincrement
* columns.
*
*/
public long   getautoincincrementarray
if   tablehasautoincrement
return null
int size   getnumberofcolumns
long inc   new long
for  int i   0  i < size  i
columndescriptor cd   getcolumndescriptor i   1
if  cd isautoincrement
inc   cd getautoincinc
return inc
/** returns a list of statistics for this table.
*/
private synchronized list getstatistics   throws standardexception
// if table already has the statistics descriptors initialized
// no need to do anything
if  statisticsdescriptorlist    null
return statisticsdescriptorlist
datadictionary dd   getdatadictionary
return statisticsdescriptorlist   dd getstatisticsdescriptors this
/**
* are there statistics for this particular conglomerate.
*
* @param cd	conglomerate/index for which we want to check if statistics
* exist. cd can be null in which case user wants to know if there are any
* statistics at all on the table.
*/
public boolean statisticsexist conglomeratedescriptor cd
throws standardexception
list sdl   getstatistics
if  cd    null
return  sdl size   > 0
uuid cduuid   cd getuuid
for  iterator li   sdl iterator    li hasnext
statisticsdescriptor statdesc    statisticsdescriptor  li next
if  cduuid equals statdesc getreferenceid
return true
return false
/**
* for this conglomerate (index), return the selectivity of the first
* numkeys. this basically returns the reciprocal of the number of unique
* values in the leading numkey columns of the index. it is assumed that
* statistics exist for the conglomerate if this function is called.
*
* @param cd		conglomeratedescriptor (index) whose
* cardinality we are interested in.
* @param numkeys	number of leading columns of the index for which
* cardinality is desired.
*/
public double selectivityforconglomerate conglomeratedescriptor cd
int numkeys
throws standardexception
if   statisticsexist cd
if  sanitymanager debug
sanitymanager throwassert
cd
else
double selectivity   0 1
for  int i   0  i < numkeys  i
selectivity    0 1
return selectivity
uuid referenceuuid   cd getuuid
list sdl   getstatistics
for  iterator li   sdl iterator    li hasnext
statisticsdescriptor statdesc    statisticsdescriptor  li next
if   referenceuuid equals statdesc getreferenceid
continue
if  statdesc getcolumncount      numkeys
continue
return statdesc getstatistic   selectivity  object null
if  sanitymanager debug
sanitymanager throwassert     cd       numkeys
return 0 1 				   shouldn't come here
/** @see tupledescriptor#getdescriptorname */
public string getdescriptorname     return tablename
/** @see tupledescriptor#getdescriptortype */
public string getdescriptortype
return  tabletype    tabledescriptor synonym_type  ?