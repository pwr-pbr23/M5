/*
derby - class org.apache.derby.iapi.types.sqlchar
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi types
import org apache derby iapi services context contextservice
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io storable
import org apache derby iapi services io storedformatids
import org apache derby iapi services io streamstorable
import org apache derby iapi services io formatidinputstream
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi types stringdatavalue
import org apache derby iapi types numberdatavalue
import org apache derby iapi types booleandatavalue
import org apache derby iapi types concatabledatavalue
import org apache derby iapi reference sqlstate
import org apache derby iapi error standardexception
import org apache derby iapi jdbc characterstreamdescriptor
import org apache derby iapi services cache classsize
import org apache derby iapi services io arrayinputstream
import org apache derby iapi services io inputstreamutil
import org apache derby iapi util stringutil
import org apache derby iapi util utf8util
import org apache derby iapi services i18n localefinder
import org apache derby iapi db databasecontext
import org apache derby iapi types sqlinteger
import org apache derby iapi types sqldate
import org apache derby iapi types sqltime
import org apache derby iapi types sqltimestamp
import java io inputstream
import java io objectoutput
import java io objectinput
import java io ioexception
import java io utfdataformatexception
import java io eofexception
import java io reader
import java sql clob
import java sql date
import java sql resultset
import java sql preparedstatement
import java sql sqlexception
import java sql time
import java sql timestamp
import java text rulebasedcollator
import java text collationkey
import java text dateformat
import java util locale
import java util calendar
/**
the sqlchar represents a char value with ucs_basic collation.
sqlchar may be used directly by any code when it is guaranteed
that the required collation is ucs_basic, e.g. system columns.
<p>
the state may be in char[], a string, a clob, or an unread stream, depending
on how the datatype was created.
<p>
stream notes:
<p>
when the datatype comes from the database layer and the length of the bytes
necessary to store the datatype on disk exceeds the size of a page of the
container holding the data then the store returns a stream rather than reading
all the bytes into a char[] or string.  the hope is that the usual usage case
is that data never need be expanded in the derby layer, and that client can
just be given a stream that can be read a char at a time through the jdbc
layer.  even though sqlchar's can't ever be this big, this code is shared
by all the various character datatypes including sqlclob which is expected
to usually larger than a page.
<p>
the state can also be a stream in the case of insert/update where the client
has used a jdbc interface to set the value as a stream rather than char[].
in this case the hope is that the usual usage case is that stream never need
be read until it is passed to store, read once, and inserted into the database.
**/
public class sqlchar
extends datatype implements stringdatavalue  streamstorable
/**************************************************************************
* static fields of the class
**************************************************************************
*/
/**
* the pad character (space).
*/
private static final char pad
/**
* threshold, that decides when we return space back to the vm
* see getstring() where it is used
*/
protected final static int return_space_threshold   4096
/**
* when we know that the array needs to grow by at least
* one byte, it is not performant to grow by just one byte
* instead this amount is used to provide a reasonable growby size.
*/
private final static int growby_for_char   64
private static final int base_memory_usage
classsize estimatebasefromcatalog  sqlchar class
/**
static array that can be used for blank padding.
*/
private static final char blanks   new char
static
for  int i   0  i < blanks length  i
blanks
/**
* stream header generator for char, varchar and long varchar. currently,
* only one header format is used for these data types.
*/
protected static final streamheadergenerator char_header_generator
new charstreamheadergenerator
/**************************************************************************
* fields of the class
**************************************************************************
*/
/*
* object state
*/
// don't use value directly in most situations. use getstring()
// or use the rawdata array if rawlength != -1.
private     string  value
// rawdata holds the reusable array for reading in sqlchars. it contains a
// valid value if rawlength is greater than or equal to 0. see getstring()
// to see how it is converted to a string. even when converted to a string
// object the rawdata array remains for potential future use, unless
// rawlength is > 4096. in this case the rawdata is set to null to avoid
// huge memory use.
private     char  rawdata
private     int     rawlength    1
// for null strings, ckey = null.
private collationkey ckey
/**
* the value as a user-created clob
*/
protected clob _clobvalue
/**
* the value as a stream in the on-disk format.
*/
inputstream stream
/* locale info (for international support) */
private localefinder localefinder
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
/**
* no-arg constructor, required by formattable.
**/
public sqlchar
public sqlchar string val
value   val
public sqlchar clob val
setvalue  val
/**************************************************************************
* private/protected methods of this class:
**************************************************************************
*/
private static void appendblanks char ca  int offset  int howmany
while  howmany > 0
int count   howmany > blanks length ? blanks length   howmany
system arraycopy blanks  0  ca  offset  count
howmany    count
offset    count
/**************************************************************************
* public methods of this class:
**************************************************************************
*/
/**************************************************************************
* public methods of datavaluedescriptor interface:
*     mostly implemented in datatype.
**************************************************************************
*/
/**
* get boolean from a sqlchar.
*
* <p>
* return false for only "0" or "false" for false. no case insensitivity.
* everything else is true.
* <p>
* the above matches jcc.
*
*
* @see datavaluedescriptor#getboolean
*
* @exception standardexception     thrown on error
**/
public boolean getboolean
throws standardexception
if  isnull
return false
// match jcc, match only "0" or "false" for false. no case
// insensitivity. everything else is true.
string cleanedvalue   getstring   trim
return   cleanedvalue equals       cleanedvalue equals
/**
* get byte from a sqlchar.
*
* <p>
* uses java standard byte.parsebyte() to perform coercion.
*
* @see datavaluedescriptor#getbyte
*
* @exception standardexception thrown on failure to convert
**/
public byte getbyte   throws standardexception
if  isnull
return  byte 0
try
return byte parsebyte getstring   trim
catch  numberformatexception nfe
throw standardexception newexception
sqlstate lang_format_exception
/**
* get short from a sqlchar.
*
* <p>
* uses java standard short.parseshort() to perform coercion.
*
* @see datavaluedescriptor#getshort
*
* @exception standardexception thrown on failure to convert
**/
public short getshort   throws standardexception
if  isnull
return  short 0
try
return short parseshort getstring   trim
catch  numberformatexception nfe
throw standardexception newexception
sqlstate lang_format_exception
/**
* get int from a sqlchar.
*
* <p>
* uses java standard short.parseint() to perform coercion.
*
* @see datavaluedescriptor#getint
*
* @exception standardexception thrown on failure to convert
**/
public int  getint   throws standardexception
if  isnull
return 0
try
return integer parseint getstring   trim
catch  numberformatexception nfe
throw standardexception newexception
sqlstate lang_format_exception
/**
* get long from a sqlchar.
*
* <p>
* uses java standard short.parselong() to perform coercion.
*
* @see datavaluedescriptor#getlong
*
* @exception standardexception thrown on failure to convert
**/
public long getlong   throws standardexception
if  isnull
return 0
try
return long parselong getstring   trim
catch  numberformatexception nfe
throw standardexception newexception
sqlstate lang_format_exception
/**
* get float from a sqlchar.
*
* <p>
* uses java standard float.floatvalue() to perform coercion.
*
* @see datavaluedescriptor#getfloat
*
* @exception standardexception thrown on failure to convert
**/
public float getfloat   throws standardexception
if  isnull
return 0
try
return new float getstring   trim    floatvalue
catch  numberformatexception nfe
throw standardexception newexception
sqlstate lang_format_exception
/**
* get double from a sqlchar.
*
* <p>
* uses java standard double.doublevalue() to perform coercion.
*
* @see datavaluedescriptor#getdouble
*
* @exception standardexception thrown on failure to convert
**/
public double getdouble   throws standardexception
if  isnull
return 0
try
return new double getstring   trim    doublevalue
catch  numberformatexception nfe
throw standardexception newexception
sqlstate lang_format_exception
/**
* get date from a sqlchar.
*
* @see datavaluedescriptor#getdate
*
* @exception standardexception thrown on failure to convert
**/
public date getdate calendar cal
throws standardexception
return getdate cal  getstring    getlocalefinder
/**
* static function to get date from a string.
*
* @see datavaluedescriptor#getdate
*
* @exception standardexception thrown on failure to convert
**/
public static date getdate
java util calendar  cal
string              str
localefinder        localefinder
throws standardexception
if  str    null
return null
sqldate internaldate   new sqldate str  false  localefinder
return internaldate getdate cal
/**
* get time from a sqlchar.
*
* @see datavaluedescriptor#gettime
*
* @exception standardexception thrown on failure to convert
**/
public time gettime calendar cal  throws standardexception
return gettime  cal  getstring    getlocalefinder
/**
* static function to get time from a string.
*
* @see datavaluedescriptor#gettime
*
* @exception standardexception thrown on failure to convert
**/
public static time gettime
calendar        cal
string          str
localefinder    localefinder
throws standardexception
if  str    null
return null
sqltime internaltime   new sqltime  str  false  localefinder  cal
return internaltime gettime  cal
/**
* get timestamp from a sqlchar.
*
* @see datavaluedescriptor#gettimestamp
*
* @exception standardexception thrown on failure to convert
**/
public timestamp gettimestamp  calendar cal  throws standardexception
return gettimestamp  cal  getstring    getlocalefinder
/**
* static function to get timestamp from a string.
*
* @see datavaluedescriptor#gettimestamp
*
* @exception standardexception thrown on failure to convert
**/
public static timestamp gettimestamp
java util calendar  cal
string              str
localefinder        localefinder
throws standardexception
if  str    null
return null
sqltimestamp internaltimestamp
new sqltimestamp  str  false  localefinder  cal
return internaltimestamp gettimestamp  cal
/**************************************************************************
* public methods of streamstorable interface:
**************************************************************************
*/
public inputstream returnstream
return stream
/**
* set this value to the on-disk format stream.
*/
public void setstream inputstream newstream
this value   null
this rawlength    1
this stream   newstream
ckey   null
_clobvalue   null
public void loadstream   throws standardexception
getstring
/**
* @exception standardexception     thrown on error
*/
public object   getobject   throws standardexception
if   _clobvalue    null     return _clobvalue
else   return getstring
/**
* @exception standardexception     thrown on error
*/
public inputstream  getstream   throws standardexception
return stream
/**
* returns a descriptor for the input stream for this character data value.
*
* @return unless the method is overridden, {@code null} is returned.
* @throws standardexception if obtaining the descriptor fails
* @see sqlclob#getstreamwithdescriptor()
*/
public characterstreamdescriptor getstreamwithdescriptor
throws standardexception
// for now return null for all non-clob types.
// todo: is this what we want, or do we want to treat some of the other
//       string types as streams as well?
return null
/**
* char/varchar/long varchar implementation.
* convert to a bigdecimal using getstring.
*/
public int typetobigdecimal    throws standardexception
return java sql types char
/**
* @exception standardexception     thrown on error
*/
public int getlength   throws standardexception
if   _clobvalue    null     return getcloblength
if  rawlength     1
return rawlength
if  stream    null
if  stream instanceof resetable    stream instanceof objectinput
try
// skip the encoded byte length.
inputstreamutil skipfully stream  2
// decode the whole stream to find the character length.
return  int utf8util skipuntileof stream
catch  ioexception ioe
throwstreamingioexception ioe
finally
try
resetable  stream  resetstream
catch  ioexception ioe
throwstreamingioexception ioe
string tmpstring   getstring
if  tmpstring    null
return 0
else
int cloblength   tmpstring length
return cloblength
private int readcharacterlength objectinput in  throws ioexception
int utflen   in readunsignedshort
return utflen
/**
* wraps an {@code ioexception} in a {@code standardexception} then throws
* the wrapping exception.
*
* @param ioe the {@code ioexception} to wrap
* @throws standardexception the wrapping exception
*/
protected void throwstreamingioexception ioexception ioe
throws standardexception
throw standardexception
newexception sqlstate lang_streaming_column_i_o_exception
ioe  gettypename
public string gettypename
return typeid char_name
/**
* if possible, use getchararray() if you don't really
* need a string.  getstring() will cause an extra
* char array to be allocated when it calls the the string()
* constructor (the first time through), so may be
* cheaper to use getchararray().
*
* @exception standardexception     thrown on error
*/
public string getstring   throws standardexception
if  value    null
int len   rawlength
if  len     1
// data is stored in the char[] array
value   new string rawdata  0  len
if  len > return_space_threshold
// free up this char[] array to reduce memory usage
rawdata   null
rawlength    1
ckey   null
else if  _clobvalue    null
try
value   _clobvalue getsubstring  1l  getcloblength
_clobvalue   null
catch  sqlexception se    throw standardexception plainwrapexception  se
else if  stream    null
// data stored as a stream
try
if  stream instanceof formatidinputstream
readexternal  formatidinputstream  stream
else
readexternal new formatidinputstream stream
stream   null
// at this point the value is only in the char[]
// so call again to convert to a string
return getstring
catch  ioexception ioe
throw standardexception newexception
sqlstate lang_streaming_column_i_o_exception
ioe
return value
/**
* get a char array.  typically, this is a simple
* getter that is cheaper than getstring() because
* we always need to create a char array when
* doing i/o.  use this instead of getstring() where
* reasonable.
* <p>
* <b>warning</b>: may return a character array that has spare
* characters at the end.  must be used in conjunction
* with getlength() to be safe.
*
* @exception standardexception     thrown on error
*/
public char getchararray   throws standardexception
if  isnull
return  char null
else if  rawlength     1
return rawdata
else
// this is expensive -- we are getting a
// copy of the char array that the
// string wrapper uses.
getstring
rawdata   value tochararray
rawlength   rawdata length
ckey   null
return rawdata
/*
* storable interface, implies externalizable, typedformat
*/
/**
return my format identifier.
@see org.apache.derby.iapi.services.io.typedformat#gettypeformatid
*/
public int gettypeformatid
return storedformatids sql_char_id
/**
* see if the string value is null.
@see storable#isnull
*/
public boolean isnull
return   value    null      rawlength     1      stream    null      _clobvalue    null
/**
writes a non-clob data value to the modified utf-8 format used by derby.
the maximum stored size is based upon the utf format
used to stored the string. the format consists of
a two byte length field and a maximum number of three
bytes for each character.
<br>
this puts an upper limit on the length of a stored
string. the maximum stored length is 65535, these leads to
the worse case of a maximum string length of 21844 ((65535 - 2) / 3).
<br>
strings with stored length longer than 64k is handled with
the following format:
(1) 2 byte length: will be assigned 0.
(2) utf formated string data.
(3) terminate the string with the following 3 bytes:
first byte is:
+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+
second byte is:
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+
third byte is:
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+
the utf format:
writes a string to the underlying output stream using utf-8
encoding in a machine-independent manner.
<p>
first, two bytes are written to the output stream as if by the
<code>writeshort</code> method giving the number of bytes to
follow. this value is the number of bytes actually written out,
not the length of the string. following the length, each character
of the string is output, in sequence, using the utf-8 encoding
for the character.
@exception  ioexception  if an i/o error occurs.
@since      jdk1.0
@exception ioexception thrown by writeutf
@see java.io.datainputstream
*/
public void writeexternal objectoutput out  throws ioexception
// never called when value is null
if  sanitymanager debug
sanitymanager assert  isnull
//
// this handles the case that a char or varchar value was populated from
// a user clob.
//
if   _clobvalue    null
writeclobutf  out
return
string lvalue   null
char data   null
int strlen   rawlength
boolean israw
if  strlen < 0
lvalue   value
strlen   lvalue length
israw   false
else
data   rawdata
israw   true
// byte length will always be at least string length
int utflen   strlen
for  int i   0    i < strlen      utflen <  65535   i
int c   israw ? data   lvalue charat i
if   c >  0x0001      c <  0x007f
// 1 byte for character
else if  c > 0x07ff
utflen    2     3 bytes for character
else
utflen    1     2 bytes for character
streamheadergenerator header   getstreamheadergenerator
if  sanitymanager debug
sanitymanager assert  header expectscharcount
// generate the header, write it to the destination stream, write the
// user data and finally write an eof-marker is required.
header generateinto out  utflen
writeutf out  strlen  israw  null
header writeeof out  utflen
/**
* writes the user data value to a stream in the modified utf-8 format.
*
* @param out destination stream
* @param strlen string length of the value
* @param israw {@code true} if the source is {@code rawdata}, {@code false}
*      if the source is {@code value}
* @param characterreader reader from _clobvalue if it exists
* @throws ioexception if writing to the destination stream fails
*/
private final void writeutf objectoutput out  int strlen
final boolean israw  reader characterreader
throws ioexception
// copy the source reference into a local variable (optimization).
final char data   israw ? rawdata   null
final string lvalue   israw ? null   value
// iterate through the value and write it as modified utf-8.
for  int i   0   i < strlen   i
int c
if   characterreader    null     c   characterreader read
else   c   israw ? data   lvalue charat i
if   c >  0x0001      c <  0x007f
out write c
else if  c > 0x07ff
out write 0xe0     c >> 12    0x0f
out write 0x80     c >>  6    0x3f
out write 0x80     c >>  0    0x3f
else
out write 0xc0     c >>  6    0x1f
out write 0x80     c >>  0    0x3f
/**
* writes the header and the user data for a clob to the destination stream.
*
* @param out destination stream
* @throws ioexception if writing to the destination stream fails
*/
protected final void writeclobutf objectoutput out
throws ioexception
if  sanitymanager debug
sanitymanager assert  isnull
sanitymanager assert stream    null
boolean  isuserclob     _clobvalue    null
try
boolean israw   rawlength >  0
// assume israw, update afterwards if required.
int strlen   rawlength
if   israw
if   isuserclob     strlen   rawgetcloblength
else   strlen   value length
// generate the header and invoke the encoding routine.
streamheadergenerator header   getstreamheadergenerator
int toencodelen   header expectscharcount   ? strlen    1
header generateinto out  toencodelen
reader characterreader   null
if   isuserclob     characterreader   _clobvalue getcharacterstream
writeutf out  strlen  israw  characterreader
header writeeof out  toencodelen
if   isuserclob     characterreader close
catch  sqlexception se
ioexception ioe   new ioexception  se getmessage
ioe initcause  se
throw ioe
/**
* reads in a string from the specified data input stream. the
* string has been encoded using a modified utf-8 format.
* <p>
* the first two bytes are read as if by
* <code>readunsignedshort</code>. this value gives the number of
* following bytes that are in the encoded string, not
* the length of the resulting string. the following bytes are then
* interpreted as bytes encoding characters in the utf-8 format
* and are converted into characters.
* <p>
* this method blocks until all the bytes are read, the end of the
* stream is detected, or an exception is thrown.
*
* @param      in   a data input stream.
* @exception  eofexception            if the input stream reaches the end
*               before all the bytes.
* @exception  ioexception             if an i/o error occurs.
* @exception  utfdataformatexception  if the bytes do not represent a
*               valid utf-8 encoding of a unicode string.
* @see        java.io.datainputstream#readunsignedshort()
* @see java.io.externalizable#readexternal
*/
public void readexternalfromarray arrayinputstream in
throws ioexception
resetformaterialization
int utflen      in read     0xff  << 8     in read     0xff
if  rawdata    null    rawdata length < utflen
// this array may be as much as three times too big. this happens
// if the content is only 3-byte characters (i.e. cjk).
// todo: decide if a threshold should be introduced, where the
//       content is copied to a smaller array if the number of
//       unused array positions exceeds the threshold.
rawdata   new char
arg_passer          rawdata
rawlength   in readderbyutf arg_passer  utflen
rawdata   arg_passer
char arg_passer   new char
/**
* reads a clob from the source stream and materializes the value in a
* character array.
*
* @param in source stream
* @param charlen the char length of the value, or {@code 0} if unknown
* @throws ioexception if reading from the source fails
*/
protected void readexternalclobfromarray arrayinputstream in  int charlen
throws ioexception
resetformaterialization
if  rawdata    null    rawdata length < charlen
rawdata   new char
arg_passer   rawdata
rawlength   in readderbyutf arg_passer  0
rawdata   arg_passer
/**
* resets state after materializing value from an array.
*/
private void resetformaterialization
value    null
stream   null
ckey   null
public void readexternal objectinput in  throws ioexception
// read the stored length in the stream header.
int utflen   in readunsignedshort
readexternal in  utflen  0
/**
* restores the data value from the source stream, materializing the value
* in memory.
*
* @param in the source stream
* @param utflen the byte length, or {@code 0} if unknown
* @param knownstrlen the char length, or {@code 0} if unknown
* @throws utfdataformatexception if an encoding error is detected
* @throws ioexception if reading the stream fails
*/
protected void readexternal objectinput in  int utflen
final int knownstrlen
throws ioexception
int requiredlength
// minimum amount that is reasonable to grow the array
// when we know the array needs to growby at least one
// byte but we dont want to grow by one byte as that
// is not performant
int mingrowby   growby
if  utflen    0
// the object was not stored as a streaming column
// we know exactly how long it is
requiredlength   utflen
else
// the object was stored as a streaming column
// and we have a clue how much we can read unblocked
// or
// the original string was a 0 length string.
requiredlength   in available
if  requiredlength < mingrowby
requiredlength   mingrowby
char str
if   rawdata    null      requiredlength > rawdata length
str   new char
else
str   rawdata
int arraylength   str length
// set these to null to allow gc of the array if required.
rawdata   null
resetformaterialization
int count   0
int strlen   0
readingloop
while    strlen < knownstrlen      knownstrlen    0
count < utflen      utflen    0
int c
try
c   in readunsignedbyte
catch  eofexception eof
if  utflen    0
throw new eofexception
// this is the case for a 0 length string.
// or the string was originally streamed in
// which puts a 0 for utflen but no trailing
// e0,0,0 markers.
break readingloop
//if (c == -1)      // read eof
//{
//  if (utflen != 0)
//      throw new eofexception();
//  break;
//}
// change it to an unsigned byte
//c &= 0xff;
if  strlen >  arraylength     the char array needs to be grown
int growby   in available
// we know that the array needs to be grown by at least one.
// however, even if the input stream wants to block on every
// byte, we don't want to grow by a byte at a time.
// note, for large data (clob > 32k), it is performant
// to grow the array by atleast 4k rather than a small amount
// even better maybe to grow by 32k but then may be
// a little excess(?) for small data.
// hopefully in.available() will give a fair
// estimate of how much data can be read to grow the
// array by larger and necessary chunks.
// this performance issue due to
// the slow growth of this array was noticed since inserts
// on clobs was taking a really long time as
// the array here grew previously by 64 bytes each time
// till stream was drained.  (derby-302)
// for char, growby 64 seems reasonable, but for varchar
// clob 4k or 32k is performant and hence
// growby() is override correctly to ensure this
if  growby < mingrowby
growby   mingrowby
int newstrlength   arraylength   growby
char oldstr   str
str   new char
system arraycopy oldstr  0  str  0  arraylength
arraylength   newstrlength
/// top fours bits of the first unsigned byte that maps to a
//  1,2 or 3 byte character
//
// 0000xxxx - 0 - 1 byte char
// 0001xxxx - 1 - 1 byte char
// 0010xxxx - 2 - 1 byte char
// 0011xxxx - 3 - 1 byte char
// 0100xxxx - 4 - 1 byte char
// 0101xxxx - 5 - 1 byte char
// 0110xxxx - 6 - 1 byte char
// 0111xxxx - 7 - 1 byte char
// 1000xxxx - 8 - error
// 1001xxxx - 9 - error
// 1010xxxx - 10 - error
// 1011xxxx - 11 - error
// 1100xxxx - 12 - 2 byte char
// 1101xxxx - 13 - 2 byte char
// 1110xxxx - 14 - 3 byte char
// 1111xxxx - 15 - error
int char2  char3
char actualchar
if   c   0x80     0x00
// one byte character
count
actualchar    char  c
else if   c   0x60     0x40     we know the top bit is set here
// two byte character
count    2
if  utflen    0    count > utflen
throw new utfdataformatexception
char2   in readunsignedbyte
if   char2   0xc0     0x80
throw new utfdataformatexception
actualchar    char    c   0x1f  << 6     char2   0x3f
else if   c   0x70     0x60     we know the top bit is set here
// three byte character
count    3
if  utflen    0    count > utflen
throw new utfdataformatexception
char2   in readunsignedbyte
char3   in readunsignedbyte
if   c    0xe0      char2    0      char3    0
utflen    0
// we reached the end of a long string,
// that was terminated with
// (11100000, 00000000, 00000000)
break readingloop
if    char2   0xc0     0x80       char3   0xc0     0x80
throw new utfdataformatexception
actualchar    char    c   0x0f  << 12
char2   0x3f  << 6
char3   0x3f  << 0
else
throw new utfdataformatexception
integer tohexstring c
str   actualchar
rawdata   str
rawlength   strlen
/**
* returns the reasonable minimum amount by
* which the array can grow . see readexternal.
* when we know that the array needs to grow by at least
* one byte, it is not performant to grow by just one byte
* instead this amount is used to provide a resonable growby size.
* @return minimum reasonable growby size
*/
protected int growby
return growby_for_char     seems reasonable for a char
/**
* @see storable#restoretonull
*
*/
public void restoretonull
value   null
stream   null
rawlength    1
ckey   null
/**
@exception standardexception thrown on error
*/
public boolean compare int op
datavaluedescriptor other
boolean orderednulls
boolean unknownrv
throws standardexception
if   orderednulls          nulls are unordered
if  this isnull        datavaluedescriptor  other  isnull
return unknownrv
/* when comparing string types to non-string types, we always
* convert the string type to the non-string type.
*/
if     other instanceof sqlchar
return other compare flip op   this  orderednulls  unknownrv
/* do the comparison */
return super compare op  other  orderednulls  unknownrv
/**
@exception standardexception thrown on error
*/
public int compare datavaluedescriptor other  throws standardexception
/* use compare method from dominant type, negating result
* to reflect flipping of sides.
*/
if  typeprecedence   < other typeprecedence
return    other compare this
// stringcompare deals with null as comparable and smallest
return stringcompare this   sqlchar other
/*
* cloneableobject interface
*/
/** from cloneableobject
*  shallow clone a streamstorable without objectifying.  this is used to
*  avoid unnecessary objectifying of a stream object.  the only
*  difference of this method from getclone is this method does not
*  objectify a stream.
*/
public object cloneobject
if   stream    null      _clobvalue    null      return getclone
sqlchar self    sqlchar  getnewnull
self copystate this
return self
/*
* datavaluedescriptor interface
*/
/** @see datavaluedescriptor#getclone */
public datavaluedescriptor getclone
try
return new sqlchar getstring
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert    se
return null
/**
* @see datavaluedescriptor#getnewnull
*
*/
public datavaluedescriptor getnewnull
return new sqlchar
/** @see stringdatavalue#getvalue(rulebasedcollator) */
public stringdatavalue getvalue rulebasedcollator collatorforcomparison
if  collatorforcomparison    null
null collatorforcomparison means use ucs_basic for collation
return this
else
//non-null collatorforcomparison means use collator sensitive
//implementation of sqlchar
collatorsqlchar s   new collatorsqlchar collatorforcomparison
s copystate this
return s
/**
* @see datavaluedescriptor#setvaluefromresultset
*
* @exception sqlexception      thrown on error
*/
public final void setvaluefromresultset resultset resultset  int colnumber
boolean isnullable
throws sqlexception
setvalue resultset getstring colnumber
/**
set the value into a preparedstatement.
*/
public final void setinto
preparedstatement   ps
int                 position
throws sqlexception  standardexception
ps setstring position  getstring
public void setvalue clob thevalue
stream   null
rawlength    1
ckey   null
value   null
_clobvalue   thevalue
public void setvalue string thevalue
stream   null
rawlength    1
ckey   null
_clobvalue   null
value   thevalue
public void setvalue boolean thevalue  throws standardexception
// match jcc.
setvalue thevalue ?
public void setvalue int thevalue   throws standardexception
setvalue integer tostring thevalue
public void setvalue double thevalue   throws standardexception
setvalue double tostring thevalue
public void setvalue float thevalue   throws standardexception
setvalue float tostring thevalue
public void setvalue short thevalue   throws standardexception
setvalue short tostring thevalue
public void setvalue long thevalue   throws standardexception
setvalue long tostring thevalue
public void setvalue byte thevalue   throws standardexception
setvalue byte tostring thevalue
public void setvalue byte thevalue  throws standardexception
if  thevalue    null
restoretonull
return
/*
** we can't just do a new string(thevalue)
** because that method assumes we are converting
** ascii and it will take on char per byte.
** so we need to convert the byte array to a
** char array and go from there.
**
** if we have an odd number of bytes pad out.
*/
int mod    thevalue length % 2
int len    thevalue length 2    mod
char carray   new char
int cindex   0
int bindex   0
/*
** if we have a left over byte, then get
** that now.
*/
if  mod    1
carray    char  thevalue << 8
for    cindex < len  bindex  2  cindex
carray    char   thevalue << 8
thevalue   0x00ff
setvalue new string carray
/**
only to be called when an application through jdbc is setting a
sqlchar to a java.math.bigdecimal.
*/
public void setbigdecimal number bigdecimal   throws standardexception
if  bigdecimal    null
settonull
else
setvalue bigdecimal tostring
/** @exception standardexception        thrown on error */
public void setvalue date thevalue  calendar cal  throws standardexception
string strvalue   null
if  thevalue    null
if  cal    null
strvalue   thevalue tostring
else
cal settime  thevalue
stringbuffer sb   new stringbuffer
formatjdbcdate  cal  sb
strvalue  sb tostring
setvalue  strvalue
/** @exception standardexception        thrown on error */
public void setvalue time thevalue  calendar cal  throws standardexception
string strvalue   null
if  thevalue    null
if  cal    null
strvalue   thevalue tostring
else
cal settime  thevalue
stringbuffer sb   new stringbuffer
formatjdbctime  cal  sb
strvalue  sb tostring
setvalue  strvalue
/** @exception standardexception        thrown on error */
public void setvalue
timestamp   thevalue
calendar    cal
throws standardexception
string strvalue   null
if  thevalue    null
if  cal    null
strvalue   thevalue tostring
else
cal settime  thevalue
stringbuffer sb   new stringbuffer
formatjdbcdate  cal  sb
sb append
formatjdbctime  cal  sb
int micros
thevalue getnanos     sqltimestamp fraction_to_nano 2
sqltimestamp fraction_to_nano
if  micros > 0
sb append
string microsstr   integer tostring  micros
if microsstr length   > sqltimestamp max_fraction_digits
sb append
microsstr substring
0  sqltimestamp max_fraction_digits
else
for int i   microsstr length
i < sqltimestamp max_fraction_digits   i
sb append
sb append  microsstr
strvalue  sb tostring
setvalue  strvalue
private void formatjdbcdate  calendar cal  stringbuffer sb
sqldate datetostring  cal get  calendar year
cal get  calendar month    calendar january   1
cal get  calendar day_of_month
sb
private void formatjdbctime  calendar cal  stringbuffer sb
sqltime timetostring
cal get calendar hour
cal get calendar minute
cal get calendar second
sb
/**
* set the value from the stream which is in the on-disk format.
* @param thestream on disk format of the stream
* @param valuelength length of the logical value in characters.
*/
public final void setvalue inputstream thestream  int valuelength
setstream thestream
/**
* allow any java type to be cast to a character type using
* object.tostring.
* @see datavaluedescriptor#setobjectforcast
*
* @exception standardexception
*                thrown on failure
*/
public void setobjectforcast
object  thevalue
boolean instanceofresulttype
string  resulttypeclassname
throws standardexception
if  thevalue    null
settonull
return
if    equals resulttypeclassname
setvalue thevalue tostring
else
super setobjectforcast
thevalue  instanceofresulttype  resulttypeclassname
protected void setfrom datavaluedescriptor thevalue
throws standardexception
if   thevalue instanceof sqlchar
sqlchar that    sqlchar  thevalue
if   that _clobvalue    null
setvalue  that _clobvalue
return
setvalue thevalue getstring
/**
* normalization method - this method may be called when putting
* a value into a sqlchar, for example, when inserting into a sqlchar
* column.  see normalizeresultset in execution.
*
* @param desiredtype   the type to normalize the source column to
* @param source        the value to normalize
*
*
* @exception standardexception             thrown for null into
*                                          non-nullable column, and for
*                                          truncation error
*/
public void normalize
datatypedescriptor desiredtype
datavaluedescriptor source
throws standardexception
normalize desiredtype  source getstring
protected void normalize datatypedescriptor desiredtype  string sourcevalue
throws standardexception
int desiredwidth   desiredtype getmaximumwidth
int sourcewidth   sourcevalue length
/*
** if the input is already the right length, no normalization is
** necessary - just return the source.
*/
if  sourcewidth    desiredwidth
setvalue sourcevalue
return
/*
** if the input is shorter than the desired type, construct a new
** sqlchar padded with blanks to the right length.
*/
if  sourcewidth < desiredwidth
settonull
char ca
if   rawdata    null      desiredwidth > rawdata length
ca   rawdata   new char
else
ca   rawdata
sourcevalue getchars 0  sourcewidth  ca  0
sqlchar appendblanks ca  sourcewidth  desiredwidth   sourcewidth
rawlength   desiredwidth
return
/*
** check whether any non-blank characters will be truncated.
*/
hasnonblankchars sourcevalue  desiredwidth  sourcewidth
/*
** no non-blank characters will be truncated.  truncate the blanks
** to the desired width.
*/
string truncatedstring   sourcevalue substring 0  desiredwidth
setvalue truncatedstring
/*
** method to check for truncation of non blank chars.
*/
protected final void hasnonblankchars string source  int start  int end
throws standardexception
/*
** check whether any non-blank characters will be truncated.
*/
for  int posn   start  posn < end  posn
if  source charat posn
throw standardexception newexception
sqlstate lang_string_truncation
gettypename
stringutil formatforprint source
string valueof start
///////////////////////////////////////////////////////////////
//
// variablesizedatavalue interface
//
///////////////////////////////////////////////////////////////
/**
* set the width of the to the desired value.  used
* when casting.  ideally we'd recycle normalize(), but
* the behavior is different (we issue a warning instead
* of an error, and we aren't interested in nullability).
*
* @param desiredwidth  the desired length
* @param desiredscale  the desired scale (ignored)
* @param errorontrunc  throw an error on truncation
*
* @exception standardexception     thrown when errorontrunc
*      is true and when a shrink will truncate non-white
*      spaces.
*/
public void setwidth int desiredwidth
int desiredscale     ignored
boolean errorontrunc
throws standardexception
int sourcewidth
/*
** if the input is null, nothing to do.
*/
if    _clobvalue    null       getstring      null
return
sourcewidth   getlength
/*
** if the input is shorter than the desired type, construct a new
** sqlchar padded with blanks to the right length.  only
** do this if we have a sqlchar -- sqlvarchars don't
** pad.
*/
if  sourcewidth < desiredwidth
if    this instanceof sqlvarchar
stringbuffer    strbuf
strbuf   new stringbuffer getstring
for     sourcewidth < desiredwidth  sourcewidth
strbuf append
setvalue new string strbuf
else if  sourcewidth > desiredwidth    desiredwidth > 0
/*
** check whether any non-blank characters will be truncated.
*/
if  errorontrunc
hasnonblankchars getstring    desiredwidth  sourcewidth
//resolve: should issue a warning instead
/*
** truncate to the desired width.
*/
setvalue getstring   substring 0  desiredwidth
return
/*
** sql operators
*/
/**
* the = operator as called from the language module, as opposed to
* the storage module.
*
* @param left          the value on the left side of the =
* @param right         the value on the right side of the =
*
* @return  a sql boolean value telling whether the two parameters are equal
*
* @exception standardexception     thrown on error
*/
public booleandatavalue equals datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right     0
else
comparison   stringcompare left getstring
right getstring       0
return sqlboolean truthvalue left
right
comparison
/**
* the <> operator as called from the language module, as opposed to
* the storage module.
*
* @param left          the value on the left side of the <>
* @param right         the value on the right side of the <>
*
* @return  a sql boolean value telling whether the two parameters
* are not equal
*
* @exception standardexception     thrown on error
*/
public booleandatavalue notequals datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right     0
else
comparison   stringcompare left getstring
right getstring       0
return sqlboolean truthvalue left
right
comparison
/**
* the < operator as called from the language module, as opposed to
* the storage module.
*
* @param left          the value on the left side of the <
* @param right         the value on the right side of the <
*
* @return  a sql boolean value telling whether the first operand is
*          less than the second operand
*
* @exception standardexception     thrown on error
*/
public booleandatavalue lessthan datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right  < 0
else
comparison   stringcompare left getstring
right getstring    < 0
return sqlboolean truthvalue left
right
comparison
/**
* the > operator as called from the language module, as opposed to
* the storage module.
*
* @param left          the value on the left side of the >
* @param right         the value on the right side of the >
*
* @return  a sql boolean value telling whether the first operand is
*          greater than the second operand
*
* @exception standardexception     thrown on error
*/
public booleandatavalue greaterthan datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right  > 0
else
comparison   stringcompare left getstring
right getstring    > 0
return sqlboolean truthvalue left
right
comparison
/**
* the <= operator as called from the language module, as opposed to
* the storage module.
*
* @param left          the value on the left side of the <=
* @param right         the value on the right side of the <=
*
* @return  a sql boolean value telling whether the first operand is
*          less than or equal to the second operand
*
* @exception standardexception     thrown on error
*/
public booleandatavalue lessorequals datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right  <  0
else
comparison   stringcompare left getstring
right getstring    <  0
return sqlboolean truthvalue left
right
comparison
/**
* the >= operator as called from the language module, as opposed to
* the storage module.
*
* @param left          the value on the left side of the >=
* @param right         the value on the right side of the >=
*
* @return  a sql boolean value telling whether the first operand is
*          greater than or equal to the second operand
*
* @exception standardexception     thrown on error
*/
public booleandatavalue greaterorequals datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right  >  0
else
comparison   stringcompare left getstring
right getstring    >  0
return sqlboolean truthvalue left
right
comparison
/*
** concatable interface
*/
/**
* this method implements the char_length function for char.
*
* @param result    the result of a previous call to this method, null
*                  if not called yet
*
* @return  a sqlinteger containing the length of the char value
*
* @exception standardexception     thrown on error
*
* @see concatabledatavalue#charlength(numberdatavalue)
*/
public numberdatavalue charlength numberdatavalue result
throws standardexception
if  result    null
result   new sqlinteger
if  this isnull
result settonull
return result
result setvalue this getlength
return result
/**
* @see stringdatavalue#concatenate
*
* @exception standardexception     thrown on error
*/
public stringdatavalue concatenate
stringdatavalue leftoperand
stringdatavalue rightoperand
stringdatavalue result
throws standardexception
if  leftoperand isnull      leftoperand getstring      null
rightoperand isnull      rightoperand getstring      null
result settonull
return result
result setvalue
leftoperand getstring   concat rightoperand getstring
return result
/**
* this method implements the like function for char (with no escape value).
*
* @param pattern       the pattern to use
*
* @return  a sql boolean value telling whether the first operand is
*          like the second operand
*
* @exception standardexception     thrown on error
*/
public booleandatavalue like datavaluedescriptor pattern
throws standardexception
boolean likeresult
// note that we call getlength() because the length
// of the char array may be different than the
// length we should be using (i.e. getlength()).
// see getchararray() for more info
char evalchararray   getchararray
char patternchararray     sqlchar pattern  getchararray
likeresult   like like evalchararray
getlength
patternchararray
pattern getlength

return sqlboolean truthvalue this
pattern
likeresult
/**
* this method implements the like function for char with an escape value.
*
* @param pattern       the pattern to use
*
* @return  a sql boolean value telling whether the first operand is
*          like the second operand
*
* @exception standardexception     thrown on error
*/
public booleandatavalue like
datavaluedescriptor pattern
datavaluedescriptor escape
throws standardexception
boolean likeresult
if  sanitymanager debug
sanitymanager assert
pattern instanceof stringdatavalue
escape instanceof stringdatavalue
// ansi states a null escape yields 'unknown' results
//
// this method is only called when we have an escape clause, so this
// test is valid
if  escape isnull
throw standardexception newexception sqlstate lang_escape_is_null
// note that we call getlength() because the length
// of the char array may be different than the
// length we should be using (i.e. getlength()).
// see getchararray() for more info
char evalchararray   getchararray
char patternchararray     sqlchar pattern  getchararray
char escapechararray      sqlchar  escape  getchararray
int escapelength   escape getlength
if  escapechararray    null    escapelength    1
throw standardexception newexception
sqlstate lang_invalid_escape_character
new string escapechararray
likeresult   like like evalchararray
getlength
patternchararray
pattern getlength
escapechararray
escapelength

return sqlboolean truthvalue this
pattern
likeresult
/**
* this method implements the locate function for char.
* @param searchfrom    - the string to search from
* @param start         - the position to search from in string searchfrom
* @param result        - the object to return
*
* note: use getstring() to get the string to search for.
*
* @return  the position in searchfrom the fist occurrence of this.value.
*              0 is returned if searchfrom does not contain this.value.
* @exception standardexception     thrown on error
*/
public numberdatavalue locate   stringdatavalue searchfrom
numberdatavalue start
numberdatavalue result
throws standardexception
int startval
if  result    null
result   new sqlinteger
if  start isnull
startval   1
else
startval   start getint
if  isnull      searchfrom isnull
result settonull
return result
string mysearchfrom   searchfrom getstring
string mysearchfor   this getstring
/* the below 2 if conditions are to emulate db2's behavior */
if  startval < 1
throw standardexception newexception
sqlstate lang_invalid_parameter_for_search_position
new string getstring     new string mysearchfrom
new integer startval
if  mysearchfor length      0
result setvalue  startval
return result
result setvalue  mysearchfrom indexof mysearchfor  startval   1    1
return result
/**
* the sql substr() function.
*
* @param start     start of substr
* @param length    length of substr
* @param result    the result of a previous call to this method,
*                  null if not called yet.
* @param maxlen    maximum length of the result
*
* @return  a concatabledatavalue containing the result of the substr()
*
* @exception standardexception     thrown on error
*/
public concatabledatavalue substring
numberdatavalue start
numberdatavalue length
concatabledatavalue result
int maxlen
throws standardexception
int startint
int lengthint
stringdatavalue stringresult
if  result    null
result   getnewvarchar
stringresult    stringdatavalue  result
/* the result is null if the receiver (this) is null or if the length
* is negative.
* we will return null, which is the only sensible thing to do.
* (if user did not specify a length then length is not a user null.)
*/
if  this isnull      start isnull
length    null    length isnull
stringresult settonull
return stringresult
startint   start getint
// if length is not specified, make it till end of the string
if  length    null
lengthint   length getint
else lengthint   maxlen   startint   1
/* db2 compatibility: added these checks to match db2. we currently
* enforce these limits in both modes. we could do these checks in db2
* mode only, if needed, so leaving earlier code for out of range in
* for now, though will not be exercised
*/
if   startint <  0    lengthint < 0    startint > maxlen
lengthint > maxlen   startint   1
throw standardexception newexception
sqlstate lang_substr_start_or_len_out_of_range
// return null if length is non-positive
if  lengthint < 0
stringresult settonull
return stringresult
/* if startint < 0 then we count from the right of the string */
if  startint < 0
// return '' if window is to left of string.
if  startint   getlength   < 0
startint   getlength     lengthint <  0
stringresult setvalue
return stringresult
// convert startint to positive to get substring from right
startint    getlength
while  startint < 0
startint
lengthint
else if  startint > 0
/* java substring() is 0 based */
startint
/* oracle docs don't say what happens if the window is to the
* left of the string.  return "" if the window
* is to the left or right.
*/
if  lengthint    0
lengthint <  0   startint
startint > getlength
stringresult setvalue
return stringresult
if  lengthint >  getlength     startint
stringresult setvalue getstring   substring startint
else
stringresult setvalue
getstring   substring startint  startint   lengthint
return stringresult
/**
* this function public for testing purposes.
*
* @param trimtype  type of trim (leading, trailing, or both)
* @param trimchar  character to trim
* @param source    string from which to trim trimchar
*
* @return a string containing the result of the trim.
*/
private string triminternal int trimtype  char trimchar  string source
if  source    null
return null
int len   source length
int start   0
if  trimtype    leading    trimtype    both
for    start < len  start
if  trimchar    source charat start
break
if  start    len
return
int end   len   1
if  trimtype    trailing    trimtype    both
for    end >  0  end
if  trimchar    source charat end
break
if  end     1
return
return source substring start  end   1
/**
* @param trimtype  type of trim (leading, trailing, or both)
* @param trimchar  character to trim from this sqlchar (may be null)
* @param result    the result of a previous call to this method,
*                  null if not called yet.
*
* @return a stringdatavalue containing the result of the trim.
*/
public stringdatavalue ansitrim
int             trimtype
stringdatavalue trimchar
stringdatavalue result
throws standardexception
if  result    null
result   getnewvarchar
if  trimchar    null    trimchar getstring      null
result settonull
return result
if  trimchar getstring   length      1
throw standardexception newexception
sqlstate lang_invalid_trim_character  trimchar getstring
char trimcharacter   trimchar getstring   charat 0
result setvalue triminternal trimtype  trimcharacter  getstring
return result
/** @see stringdatavalue#upper
*
* @exception standardexception     thrown on error
*/
public stringdatavalue upper stringdatavalue result
throws standardexception
if  result    null
result    stringdatavalue  getnewnull
if  this isnull
result settonull
return result
string upper   getstring
upper   upper touppercase getlocale
result setvalue upper
return result
/** @see stringdatavalue#lower
*
* @exception standardexception     thrown on error
*/
public stringdatavalue lower stringdatavalue result
throws standardexception
if  result    null
result    stringdatavalue  getnewnull
if  this isnull
result settonull
return result
string lower   getstring
lower   lower tolowercase getlocale
result setvalue lower
return result
/*
* datavaluedescriptor interface
*/
/** @see datavaluedescriptor#typeprecedence */
public int typeprecedence
return typeid char_precedence
/**
* compare two strings using standard sql semantics.
*
* @param op1               the first string
* @param op2               the second string
*
* @return  -1 - op1 <  op2
*           0 - op1 == op2
*           1 - op1 > op2
*/
protected static int stringcompare string op1  string op2
int         posn
char        leftchar
char        rightchar
int         leftlen
int         rightlen
int         retvalifltspace
string      remainingstring
int         remaininglen
/*
** by convention, nulls sort high, and null == null
*/
if  op1    null    op2    null
if  op1    null        op2    null
return  1
if  op2    null        op1    null
return 1
return 0               both null
/*
** compare characters until we find one that isn't equal, or until
** one string or the other runs out of characters.
*/
leftlen   op1 length
rightlen   op2 length
int shorterlen   leftlen < rightlen ? leftlen   rightlen
for  posn   0  posn < shorterlen  posn
leftchar   op1 charat posn
rightchar   op2 charat posn
if  leftchar    rightchar
if  leftchar < rightchar
return  1
else
return 1
/*
** all the characters are equal up to the length of the shorter
** string.  if the two strings are of equal length, the values are
** equal.
*/
if  leftlen    rightlen
return 0
/*
** one string is shorter than the other.  compare the remaining
** characters in the longer string to spaces (the sql standard says
** that in this case the comparison is as if the shorter string is
** padded with blanks to the length of the longer string.
*/
if  leftlen > rightlen
/*
** remaining characters are on the left.
*/
/* if a remaining character is less than a space,
* return -1 (op1 < op2) */
retvalifltspace    1
remainingstring   op1
posn   rightlen
remaininglen   leftlen
else
/*
** remaining characters are on the right.
*/
/* if a remaining character is less than a space,
* return 1 (op1 > op2) */
retvalifltspace   1
remainingstring   op2
posn   leftlen
remaininglen   rightlen
/* look at the remaining characters in the longer string */
for     posn < remaininglen  posn
char    remainingchar
/*
** compare the characters to spaces, and return the appropriate
** value, depending on which is the longer string.
*/
remainingchar   remainingstring charat posn
if  remainingchar <
return retvalifltspace
else if  remainingchar >
return  retvalifltspace
/* the remaining characters in the longer string were all spaces,
** so the strings are equal.
*/
return 0
/**
* compare two sqlchars.
*
* @exception standardexception     thrown on error
*/
protected int stringcompare sqlchar char1  sqlchar char2
throws standardexception
return stringcompare char1 getchararray    char1 getlength
char2 getchararray    char2 getlength
/**
* compare two strings using standard sql semantics.
*
* @param op1               the first string
* @param op2               the second string
*
* @return  -1 - op1 <  op2
*           0 - op1 == op2
*           1 - op1 > op2
*/
protected static int stringcompare
char  op1
int     leftlen
char  op2
int     rightlen
int         posn
char        leftchar
char        rightchar
int         retvalifltspace
char      remainingstring
int         remaininglen
/*
** by convention, nulls sort high, and null == null
*/
if  op1    null    op2    null
if  op1    null        op2    null
return  1
if  op2    null        op1    null
return 1
return 0               both null
/*
** compare characters until we find one that isn't equal, or until
** one string or the other runs out of characters.
*/
int shorterlen   leftlen < rightlen ? leftlen   rightlen
for  posn   0  posn < shorterlen  posn
leftchar   op1
rightchar   op2
if  leftchar    rightchar
if  leftchar < rightchar
return  1
else
return 1
/*
** all the characters are equal up to the length of the shorter
** string.  if the two strings are of equal length, the values are
** equal.
*/
if  leftlen    rightlen
return 0
/*
** one string is shorter than the other.  compare the remaining
** characters in the longer string to spaces (the sql standard says
** that in this case the comparison is as if the shorter string is
** padded with blanks to the length of the longer string.
*/
if  leftlen > rightlen
/*
** remaining characters are on the left.
*/
/* if a remaining character is less than a space,
* return -1 (op1 < op2) */
retvalifltspace    1
remainingstring   op1
posn   rightlen
remaininglen   leftlen
else
/*
** remaining characters are on the right.
*/
/* if a remaining character is less than a space,
* return 1 (op1 > op2) */
retvalifltspace   1
remainingstring   op2
posn   leftlen
remaininglen   rightlen
/* look at the remaining characters in the longer string */
for     posn < remaininglen  posn
char    remainingchar
/*
** compare the characters to spaces, and return the appropriate
** value, depending on which is the longer string.
*/
remainingchar   remainingstring
if  remainingchar <
return retvalifltspace
else if  remainingchar >
return  retvalifltspace
/* the remaining characters in the longer string were all spaces,
** so the strings are equal.
*/
return 0
/**
* this method gets called for the collation sensitive char classes ie
* collatorsqlchar, collatorsqlvarchar, collatorsqllongvarchar,
* collatorsqlclob. these collation sensitive chars need to have the
* collation key in order to do string comparison. and the collation key
* is obtained using the collator object that these classes already have.
*
* @return collationkey obtained using collator on the string
* @throws standardexception
*/
protected collationkey getcollationkey   throws standardexception
char tmpchararray
if  ckey    null
return ckey
if  rawlength     1
/* materialize the string if input is a stream */
tmpchararray   getchararray
if  tmpchararray    null
return null
int lastnonspacechar   rawlength
while  lastnonspacechar > 0
rawdata
lastnonspacechar               count off the trailing spaces
rulebasedcollator rbc   getcollatorforcollation
ckey   rbc getcollationkey new string rawdata  0  lastnonspacechar
return ckey
/*
* string display of value
*/
public string tostring
if  isnull
return
if   value    null      rawlength     1
return new string rawdata  0  rawlength
if  stream    null
try
return getstring
catch  exception e
return e tostring
return value
/*
* hash code
*/
public int hashcode
if  sanitymanager debug
sanitymanager assert   this instanceof collationelementsinterface
try
if  getstring      null
return 0
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert    se
return 0
/* value.hashcode() doesn't work because of the sql blank padding
* behavior.
* we want the hash code to be based on the value after the
* trailing blanks have been trimmed.  calling trim() is too expensive
* since it will create a new object, so here's what we do:
*      o  walk from the right until we've found the 1st
*         non-blank character.
*      o  calculate the hash code based on the characters from the
*         start up to the first non-blank character from the right.
*/
// value will have been set by the getstring() above
string lvalue   value
// find 1st non-blank from the right
int lastnonpadchar   lvalue length     1
while  lastnonpadchar >  0    lvalue charat lastnonpadchar     pad
lastnonpadchar
// build the hash code. it should be identical to what we get from
// lvalue.substring(0, lastnonpadchar+1).hashcode(), but it should be
// cheaper this way since we don't allocate a new string.
int hashcode   0
for  int i   0  i <  lastnonpadchar  i
hashcode   hashcode   31   lvalue charat i
return hashcode
/**
* hash code implementation for collator sensitive subclasses.
*/
int hashcodeforcollation
collationkey key   null
try
key   getcollationkey
catch  standardexception se
// ignore exceptions, like we do in hashcode()
if  sanitymanager debug
sanitymanager throwassert    se
return key    null ? 0   key hashcode
/**
* get a sqlvarchar for a built-in string function.
*
* @return a sqlvarchar.
*
* @exception standardexception     thrown on error
*/
protected stringdatavalue getnewvarchar   throws standardexception
return new sqlvarchar
protected void setlocalefinder localefinder localefinder
this localefinder   localefinder
/** @exception standardexception        thrown on error */
private locale getlocale   throws standardexception
return getlocalefinder   getcurrentlocale
protected rulebasedcollator getcollatorforcollation
throws standardexception
return getlocalefinder   getcollator
protected localefinder getlocalefinder
// this is not very satisfactory, as it creates a dependency on
// the databasecontext. it's the best i could do on short notice,
// though.  -  jeff
if  localefinder    null
databasecontext dc    databasecontext
contextservice getcontext databasecontext context_id
if  dc    null
localefinder   dc getdatabase
return localefinder
protected dateformat getdateformat   throws standardexception
return getlocalefinder   getdateformat
protected dateformat gettimeformat   throws standardexception
return getlocalefinder   gettimeformat
protected dateformat gettimestampformat   throws standardexception
return getlocalefinder   gettimestampformat
protected dateformat getdateformat  calendar cal
throws standardexception
return setdateformatcalendar  getlocalefinder   getdateformat    cal
protected dateformat gettimeformat  calendar cal
throws standardexception
return setdateformatcalendar  getlocalefinder   gettimeformat    cal
protected dateformat gettimestampformat  calendar cal
throws standardexception
return setdateformatcalendar
getlocalefinder   gettimestampformat    cal
private dateformat setdateformatcalendar  dateformat df  calendar cal
if  cal    null    df gettimezone      cal gettimezone
// the dateformat returned by getdateformat may be cached and used
// by other threads.  therefore we cannot change its calendar.
df    dateformat  df clone
df setcalendar  cal
return df
public int estimatememoryusage
int sz   base_memory_usage   classsize estimatememoryusage  value
if  null    rawdata
sz    2 rawdata length
// assume that ckey, stream, and localfinder are shared,
// so do not count their memory usage
return sz
end of estimatememoryusage
protected void copystate sqlchar other
this value   other value
this rawdata   other rawdata
this rawlength   other rawlength
this ckey   other ckey
this stream   other stream
this _clobvalue   other _clobvalue
this localefinder   localefinder
/**
* gets a trace representation for debugging.
*
* @return a trace representation of this sql type.
*/
public string gettracestring   throws standardexception
// check if the value is sql null.
if  isnull
return
return  tostring
/**
* returns the default stream header generator for the string data types.
*
* @return a stream header generator.
*/
public streamheadergenerator getstreamheadergenerator
return char_header_generator
/**
* sets the mode for the database being accessed.
*
* @param insoftupgrademode {@code true} if the database is being accessed
*      in soft upgrade mode, {@code false} if not, and {@code null} if
*      unknown
*/
public void setsoftupgrademode boolean insoftupgrademode
// ignore this for char, varchar and long varchar.
private int getcloblength   throws standardexception
try
return rawgetcloblength
catch  sqlexception se    throw standardexception plainwrapexception  se
private int rawgetcloblength   throws sqlexception
long   maxlength   integer max_value
long   length   _clobvalue length
if   length > integer max_value
standardexception se   standardexception newexception
sqlstate blob_too_large_for_client  long tostring  length    long tostring  maxlength
throw new sqlexception  se getmessage
return  int  length