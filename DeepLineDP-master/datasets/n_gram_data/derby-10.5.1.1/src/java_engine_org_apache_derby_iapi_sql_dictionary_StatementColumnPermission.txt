/*
derby - class org.apache.derby.iapi.sql.dictionary.statementcolumnpermission
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import org apache derby iapi error standardexception
import org apache derby catalog uuid
import org apache derby iapi sql conn authorizer
import org apache derby iapi reference sqlstate
import org apache derby iapi services io formatablebitset
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql activation
import org apache derby iapi sql execute execpreparedstatement
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi services context contextmanager
/**
* this class describes a column permission used (required) by a statement.
*/
public class statementcolumnpermission extends statementtablepermission
private formatablebitset columns
/**
* constructor for statementcolumnpermission. creates an instance of column permission requested
* for the given access.
*
* @param tableuuid	uuid of the table
* @param privtype	access privilege requested
* @param columns	list of columns
*
*/
public statementcolumnpermission uuid tableuuid  int privtype  formatablebitset columns
super  tableuuid  privtype
this columns   columns
/**
* return list of columns that need access
*
* @return	formatablebitset of columns
*/
public formatablebitset getcolumns
return columns
/**
* method to check if another instance of column access descriptor matches this.
* used to ensure only one access descriptor for a table/columns of given privilege is created.
*
* @param obj	another instance of statementpermission
*
* @return	true if match
*/
public boolean equals  object obj
if  obj instanceof statementcolumnpermission
statementcolumnpermission other    statementcolumnpermission  obj
if    columns equals  other columns
return false
return super equals  obj
return false
/**
* @see statementpermission#check
*/
public void check  languageconnectioncontext lcc
string authorizationid
boolean forgrant
activation activation
throws standardexception
datadictionary dd   lcc getdatadictionary
execpreparedstatement ps   activation getpreparedstatement
if  haspermissionontable lcc  activation
authorizationid  forgrant  ps
return
formatablebitset permittedcolumns   null
if    forgrant
permittedcolumns   addpermittedcolumns  dd
false    non grantable permissions
authorizer public_authorization_id
permittedcolumns
permittedcolumns   addpermittedcolumns  dd
false    non grantable permissions
authorizationid
permittedcolumns
permittedcolumns   addpermittedcolumns  dd
true    grantable permissions
authorizer public_authorization_id
permittedcolumns
permittedcolumns   addpermittedcolumns  dd
true    grantable permissions
authorizationid
permittedcolumns
formatablebitset unresolvedcolumns    formatablebitset columns clone
for  int i   unresolvedcolumns anysetbit
i >  0
i   unresolvedcolumns anysetbit i
if  permittedcolumns    null    permittedcolumns get i
// column i (zero-based here) accounted for:
unresolvedcolumns clear i
if  unresolvedcolumns anysetbit   < 0
// all ok
return
// if columns are still unauthorized, look to role closure for
// resolution.
string role   lcc getcurrentroleid activation
rolegrantdescriptor rd   null
if  role    null
// check that role is still granted to current user or
// to public: a revoked role which is current for this
// session, is lazily set to none when it is attempted
// used.
string dbo   dd getauthorizationdatabaseowner
rd   dd getrolegrantdescriptor role  authorizationid  dbo
if  rd    null
rd   dd getrolegrantdescriptor
role
authorizer public_authorization_id
dbo
if  rd    null
// we have lost the right to set this role, so we can't
// make use of any permission granted to it or its ancestors.
lcc setcurrentrole activation  null
else
// the current role is ok, so we can make use of
// any permission granted to it.
//
// look at the current role and, if necessary, the transitive
// closure of roles granted to current role to see if
// permission has been granted to any of the applicable roles.
roleclosureiterator rci
dd createroleclosureiterator
activation gettransactioncontroller
role  true    inverse relation
string r
while  unresolvedcolumns anysetbit   >  0
r   rci next       null
unresolvedcolumns   tryrole lcc  dd  forgrant
r  unresolvedcolumns
int remains   unresolvedcolumns anysetbit
if  remains >  0
// no permission on this column.
tabledescriptor td   gettabledescriptor dd
columndescriptor cd   td getcolumndescriptor remains   1
if cd    null
throw standardexception newexception
sqlstate auth_internal_bad_uuid
else
throw standardexception newexception
forgrant
? sqlstate auth_no_column_permission_for_grant
sqlstate auth_no_column_permission
authorizationid
getprivname
cd getcolumnname
td getschemaname
td getname
else
// we found and successfully applied a role to resolve the
// (remaining) required permissions.
//
// also add a dependency on the role (qua provider), so
// that if role is no longer available to the current
// user (e.g. grant is revoked, role is dropped,
// another role has been set), we are able to
// invalidate the ps or activation (the latter is used
// if the current role changes).
dependencymanager dm   dd getdependencymanager
rolegrantdescriptor rgd
dd getroledefinitiondescriptor role
contextmanager cm   lcc getcontextmanager
dm adddependency ps  rgd  cm
dm adddependency activation  rgd  cm
end of check
/**
* add one user's set of permitted columns to a list of permitted columns.
*/
private formatablebitset addpermittedcolumns  datadictionary dd
boolean forgrant
string authorizationid
formatablebitset permittedcolumns
throws standardexception
if  permittedcolumns    null    permittedcolumns getnumbitsset      permittedcolumns size
return permittedcolumns
colpermsdescriptor perms   dd getcolumnpermissions  tableuuid  privtype  false  authorizationid
if  perms    null
if  permittedcolumns    null
return perms getcolumns
permittedcolumns or  perms getcolumns
return permittedcolumns
end of addpermittedcolumns
/**
* @see statementpermission#getpermissiondescriptor
*/
public permissionsdescriptor getpermissiondescriptor string authid  datadictionary dd
throws standardexception
//if table permission found for authorizationid, then simply return that
if  oneauthhaspermissionontable  dd  authid  false
return dd gettablepermissions tableuuid  authid
//if table permission found for public, then simply return that
if  oneauthhaspermissionontable  dd  authorizer public_authorization_id  false
return dd gettablepermissions tableuuid  authorizer public_authorization_id
//if table level permission not found, then we have to find permissions
//at column level. look for column level permission for the passed
//authorizer. if found any of the required column level permissions,
//return the permission descriptor for it.
colpermsdescriptor colspermsdesc   dd getcolumnpermissions tableuuid  privtype  false  authid
if  colspermsdesc    null
if  colspermsdesc getcolumns      null
formatablebitset permittedcolumns   colspermsdesc getcolumns
for  int i   columns anysetbit    i >  0  i   columns anysetbit  i
if permittedcolumns get i
return colspermsdesc
return null
/**
* this method gets called in execution phase after it is established that
* all the required privileges exist for the given sql. this method gets
* called by create view/trigger/constraint to record their dependency on
* various privileges.
* special code is required to track column level privileges.
* it is possible that some column level privileges are available to the
* passed authorizer id but the rest required column level privileges
* are available at public level. in this method, we check if all the
* required column level privileges are found for the passed authorizer.
* if yes, then simply return null, indicating that no dependency is
* required at public level, because all the required privileges were found
* at the user level. but if some column level privileges are not
* available at user level, then they have to exist at the public
* level when this method gets called.
*/
public permissionsdescriptor getpubliclevelcolpermsdescriptor string authid  datadictionary dd
throws standardexception
colpermsdescriptor colspermsdesc   dd getcolumnpermissions tableuuid  privtype  false  authid
formatablebitset permittedcolumns   colspermsdesc getcolumns
boolean allcolumnscoveredbyuserlevelprivilege   true
for  int i   columns anysetbit    i >  0    allcolumnscoveredbyuserlevelprivilege  i   columns anysetbit  i
if permittedcolumns get i
continue
else
allcolumnscoveredbyuserlevelprivilege   false
if  allcolumnscoveredbyuserlevelprivilege
return null
else
return  dd getcolumnpermissions tableuuid  privtype  false  authorizer public_authorization_id
/**
* returns false if the current role is necessary to cover
* the necessary permission(s).
* @param authid authentication id of the current user
* @param dd data dictionary
*
* @return false if the current role is required
*/
public boolean allcolumnscoveredbyuserorpublic string authid
datadictionary dd
throws standardexception
colpermsdescriptor colspermsdesc
dd getcolumnpermissions tableuuid  privtype  false  authid
formatablebitset permittedcolumns   colspermsdesc getcolumns
formatablebitset unresolvedcolumns    formatablebitset columns clone
boolean result   true
if  permittedcolumns    null       else none at user level
for int i   unresolvedcolumns anysetbit
i >  0
i   unresolvedcolumns anysetbit i
if permittedcolumns get i
unresolvedcolumns clear i
if  unresolvedcolumns anysetbit   >  0
colspermsdesc
dd getcolumnpermissions
tableuuid  privtype  false
authorizer public_authorization_id
permittedcolumns   colspermsdesc getcolumns
if  permittedcolumns    null       else none at public level
for int i   unresolvedcolumns anysetbit
i >  0
i   unresolvedcolumns anysetbit i
if permittedcolumns get i
unresolvedcolumns clear i
if  unresolvedcolumns anysetbit   >  0
// even after trying all grants to user and public there
// are unresolved columns so role must have been used.
result   false
return result
/**
* given the set of yet unresolved column permissions, try to use
* the supplied role r to resolve them. after this is done, return
* the set of columns still unresolved. if the role is used for
* anything, record a dependency.
*
* @param lcc language connection context
* @param dd  data dictionary
* @param forgrant true of a grantable permission is sought
* @param r the role to inspect to see if it can supply the required
*          privileges
* @param unresolvedcolumns the set of columns yet unaccounted for
*/
private formatablebitset tryrole languageconnectioncontext lcc
datadictionary dd
boolean forgrant
string r
formatablebitset unresolvedcolumns
throws standardexception
formatablebitset permittedcolumns   null
if    forgrant
// this is a weaker permission than grantable, so only applicable
// if grantable is not required.
permittedcolumns   addpermittedcolumns dd  false  r  null
// if grantable is given, applicable in both cases, so use union
permittedcolumns   addpermittedcolumns dd  true  r  permittedcolumns
for int i   unresolvedcolumns anysetbit
i >  0
i   unresolvedcolumns anysetbit i
if permittedcolumns    null    permittedcolumns get i
unresolvedcolumns clear i
return unresolvedcolumns
public string tostring
return     getprivname
tableuuid       columns