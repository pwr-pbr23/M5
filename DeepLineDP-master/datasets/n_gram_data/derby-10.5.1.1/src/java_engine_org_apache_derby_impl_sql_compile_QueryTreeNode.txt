/*
derby - class org.apache.derby.impl.sql.compile.querytreenode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import java sql types
import org apache derby catalog aliasinfo
import org apache derby catalog types synonymaliasinfo
import org apache derby iapi services i18n messageservice
import org apache derby iapi error standardexception
import org apache derby iapi reference classname
import org apache derby iapi reference jdbc40translation
import org apache derby iapi reference sqlstate
import org apache derby iapi services classfile vmopcode
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services context contextmanager
import org apache derby iapi services io storedformatids
import org apache derby iapi services loader classfactory
import org apache derby iapi services loader classinspector
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql statementtype
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile nodefactory
import org apache derby iapi sql compile parser
import org apache derby iapi sql compile typecompiler
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql dictionary aliasdescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql execute constantaction
import org apache derby iapi sql execute executionfactory
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby impl sql execute genericconstantactionfactory
import org apache derby impl sql execute genericexecutionfactory
/**
* querytreenode is the root class for all query tree nodes. all
* query tree nodes inherit from querytreenode except for those that extend
* querytreenodevector.
*
*/
public abstract class querytreenode implements visitable
public static final int autoincrement_start_index   0
public static final int autoincrement_inc_index     1
public static final int autoincrement_is_autoincrement_index     2
//parser uses this static field to make a note if the autoincrement column
//is participating in create or alter table.
public static final int autoincrement_create_modify    3
private int		beginoffset    1 		   offset into sql input of the substring
// which this query node encodes.
private int		endoffset    1
private int nodetype
private contextmanager cm
private languageconnectioncontext lcc
private genericconstantactionfactory	constantactionfactory
/**
* in derby sql standard authorization, views, triggers and constraints
* execute with definer's privileges. taking a specific eg of views
* user1
* create table t1 (c11 int);
* create view v1 as select * from user1.t1;
* grant select on v1 to user2;
* user2
* select * from user1.v1;
* running with definer's privileges mean that since user2 has select
* privileges on view v1 owned by user1, then that is sufficient for user2
* to do a select from view v1. view v1 underneath might access some
* objects that user2 doesn't have privileges on, but that is not a problem
* since views execute with definer's privileges. in order to implement this
* behavior, when doing a select from view v1, we only want to check for
* select privilege on view v1. while processing the underlying query for
* view v1, we want to stop collecting the privilege requirements for the
* query underneath. following flag, isprivilegecollectionrequired is used
* for this purpose. the flag will be true when we are the top level of view
* and then it is turned off while we process the query underlying the view
* v1.
*/
boolean isprivilegecollectionrequired   true
/**
* set the contextmanager for this node.
*
* @param cm	the contextmanager.
*/
public void setcontextmanager contextmanager cm
this cm   cm
if  sanitymanager debug
sanitymanager assert cm    null
/**
* get the current contextmanager.
*
* @return the current contextmanager.
*/
public final contextmanager getcontextmanager
if  sanitymanager debug
if  cm    null
sanitymanager throwassert     this getclass
return cm
/**
*	gets the nodefactory for this database.
*
*	@return	the node factory for this database.
*
*/
public	final nodefactory	getnodefactory
return getlanguageconnectioncontext   getlanguageconnectionfactory
getnodefactory
/**
*	gets the constant action factory for this database.
*
*	@return	the constant action factory.
*/
public	final genericconstantactionfactory	getgenericconstantactionfactory
if   constantactionfactory    null
genericexecutionfactory	execfactory    genericexecutionfactory  getexecutionfactory
constantactionfactory   execfactory getconstantactionfactory
return constantactionfactory
public	final	executionfactory	getexecutionfactory
executionfactory	ef   getlanguageconnectioncontext   getlanguageconnectionfactory   getexecutionfactory
return ef
/**
get the classfactory to use with this database.
*/
protected final classfactory getclassfactory
return getlanguageconnectioncontext   getlanguageconnectionfactory
getclassfactory
/**
*	gets the languageconnectioncontext for this connection.
*
*	@return	the lcc for this connection
*
*/
protected final languageconnectioncontext	getlanguageconnectioncontext
if  lcc    null
lcc    languageconnectioncontext  getcontextmanager
getcontext languageconnectioncontext context_id
return lcc
/**
* gets the beginning offset of the sql substring which this
* query node represents.
*
* @return	the beginning offset of the sql substring. -1 means unknown.
*
*/
public	int	getbeginoffset     return beginoffset
/**
* sets the beginning offset of the sql substring which this
* query node represents.
*
* @param	beginoffset	the beginning offset of the sql substring.
*
*/
public	void	setbeginoffset  int beginoffset
this beginoffset   beginoffset
/**
* gets the ending offset of the sql substring which this
* query node represents.
*
* @return	the ending offset of the sql substring. -1 means unknown.
*
*/
public	int	getendoffset      return endoffset
/**
* sets the ending offset of the sql substring which this
* query node represents.
*
* @param	endoffset	the ending offset of the sql substring.
*
*/
public	void	setendoffset  int endoffset
this endoffset   endoffset
/**
* return header information for debug printing of this query
* tree node.
*
* @return	header information for debug printing of this query
*		tree node.
*/
protected string	nodeheader
if  sanitymanager debug
return     this getclass   getname
integer tohexstring hashcode
else
return
/**
* format a node that has been converted to a string for printing
* as part of a tree.  this method indents the string to the given
* depth by inserting tabs at the beginning of the string, and also
* after every newline.
*
* @param nodestring	the node formatted as a string
* @param depth		the depth to indent the given node
*
* @return	the node string reformatted with tab indentation
*/
public static string formatnodestring string nodestring  int depth
if  sanitymanager debug
stringbuffer	nodestringbuffer   new stringbuffer nodestring
int		pos
char		c
char		indent   new char
/*
** form an array of tab characters for indentation.
*/
while  depth > 0
indent
depth
/* indent the beginning of the string */
nodestringbuffer insert 0  indent
/*
** look for newline characters, except for the last character.
** we don't want to indent after the last newline.
*/
for  pos   0  pos < nodestringbuffer length     1  pos
c   nodestringbuffer charat pos
if  c
/* indent again after each newline */
nodestringbuffer insert pos   1  indent
return nodestringbuffer tostring
else
return
/**
* print this tree for debugging purposes.  this recurses through
* all the sub-nodes and prints them indented by their depth in
* the tree.
*/
public void treeprint
if  sanitymanager debug
debugprint nodeheader
debugprint formatnodestring this tostring    0
printsubnodes 0
debugflush
/**
* print this tree for debugging purposes.  this recurses through
* all the sub-nodes and prints them indented by their depth in
* the tree, starting with the given indentation.
*
* @param depth		the depth of this node in the tree, thus,
*			the amount to indent it when printing it.
*/
public void treeprint int depth
if  sanitymanager debug
debugprint formatnodestring nodeheader    depth
debugprint formatnodestring this tostring    depth
printsubnodes depth
/**
* print a string for debugging
*
* @param outputstring	the string to print
*/
public static void debugprint string outputstring
if  sanitymanager debug
sanitymanager get_debug_stream   print outputstring
/**
* flush the debug stream out
*/
protected static void debugflush
if  sanitymanager debug
sanitymanager get_debug_stream   flush
/**
* print the sub-nodes of this node.
*
* each sub-class of querytreenode is expected to provide its own
* printsubnodes() method.  in each case, it calls super.printsubnodes(),
* passing along its depth, to get the sub-nodes of the super-class.
* then it prints its own sub-nodes by calling treeprint() on each
* of its members that is a type of querytreenode.  in each case where
* it calls treeprint(), it should pass "depth + 1" to indicate that
* the sub-node should be indented one more level when printing.
* also, it should call printlabel() to print the name of each sub-node
* before calling treeprint() on the sub-node, so that the reader of
* the printed tree can tell what the sub-node is.
*
* this printsubnodes() exists in here merely to act as a backstop.
* in other words, the calls to printsubnodes() move up the type
* hierarchy, and in this node the calls stop.
*
* i would have liked to put the call to super.printsubnodes() in
* this super-class, but java resolves "super" statically, so it
* wouldn't get to the right super-class.
*
* @param depth		the depth to indent the sub-nodes
*/
public void printsubnodes int depth
/**
* format this node as a string
*
* each sub-class of querytreenode should implement its own tostring()
* method.  in each case, tostring() should format the class members
* that are not sub-types of querytreenode (printsubnodes() takes care
* of following the references to sub-nodes, and tostring() takes care
* of all members that are not sub-nodes).  newlines should be used
* liberally - one good way to do this is to have a newline at the
* end of each formatted member.  it's also a good idea to put the
* name of each member in front of the formatted value.  for example,
* the code might look like:
*
* "membername: " + membername + "\n" + ...
*
* @return	this node formatted as a string
*/
public string tostring
return
/**
* print the given label at the given indentation depth.
*
* @param depth		the depth of indentation to use when printing
*			the label
* @param label		the string to print
*/
public void printlabel int depth  string label
if  sanitymanager debug
debugprint formatnodestring label  depth
/**
* return true if the node references session schema tables (temporary or permanent)
*
* @return	true if references session schema tables, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencessessionschema
throws standardexception
return false
/**
* checks if the passed schema descriptor is for session schema
*
* @return	true if the passed schema descriptor is for session schema
*
* @exception standardexception		thrown on error
*/
final boolean issessionschema schemadescriptor sd
return issessionschema sd getschemaname
/**
* checks if the passed schema name is for session schema
*
* @return	true if the passed schema name is for session schema
*
* @exception standardexception		thrown on error
*/
final boolean issessionschema string schemaname
return schemadescriptor std_declared_global_temporary_tables_schema_name equals schemaname
/**
* triggers, constraints and views get executed with their definer's
* privileges and they can exist in the system only if their definers'
* still have all the privileges to creeate them. based on this, any
* time a trigger/view/constraint is executing, we do not need to waste
* time in checking if the definer still has the right set of privileges.
* at compile time, we wil make sure that we do not collect the privilege
* requirement for objects accessed with definer privileges by calling the
* following method.
*/
public void disableprivilegecollection
isprivilegecollectionrequired   false
/**
* return true from this method means that we need to collect privilege
* requirement for this node. for following cases, this method will
* return true.
* 1)execute view - collect privilege to access view but do not collect
* privilege requirements for objects accessed by actual view uqery
* 2)execute select - collect privilege requirements for objects accessed
* by select statement
* 3)create view -  collect privileges for select statement : the select
* statement for create view falls under 2) category above.
*
* @return true if need to collect privilege requirement for this node
*/
public boolean isprivilegecollectionrequired
return isprivilegecollectionrequired
/**
* get the optimizer's estimate of the number of rows returned or affected
* for an optimized querytree.
*
* for non-optimizable statements (for example, create table),
* return 0. for optimizable statements, this method will be
* over-ridden in the statement's root node (dmlstatementnode
* in all cases we know about so far).
*
* @return	0l
*/
public long	getrowestimate
return	0l
/**
* do the code generation for this node.  this is a place-holder
* method - it should be over-ridden in the sub-classes.
*
* @param acb	the activationclassbuilder for the class being built
* @param mb	the method for the generated code to go into
*
* @exception standardexception		thrown on error
*/
protected void generate
activationclassbuilder acb
methodbuilder mb
throws standardexception
throw standardexception newexception sqlstate lang_unable_to_generate
this nodeheader
/**
* parameter info is stored in the compiler context.
* hide this from the callers.
*
*
* @return	null
*
* @exception standardexception on error
*/
public datatypedescriptor getparametertypes
throws standardexception
return getcompilercontext   getparametertypes
/**
* this creates a class that will do the work that's constant
* across all executions of a preparedstatement. it's up to
* our subclasses to override this method if they need to compile
* constant actions into preparedstatements.
*
* @exception standardexception		thrown on failure
*/
public constantaction	makeconstantaction   throws standardexception
return	null
/**
* set the node type for this node.
*
* @param nodetype the node type.
*/
public void setnodetype int nodetype
this nodetype   nodetype
protected int getnodetype
return nodetype
/**
* for final nodes, return whether or not
* the node represents the specified nodetype.
*
* @param nodetype	the nodetype of interest.
*
* @return whether or not
* the node represents the specified nodetype.
*/
protected boolean isinstanceof int nodetype
return  this nodetype    nodetype
/**
* get the datadictionary
*
* @return the datadictionary
*
*/
public final datadictionary getdatadictionary
return getlanguageconnectioncontext   getdatadictionary
public final dependencymanager getdependencymanager
return getdatadictionary   getdependencymanager
/**
* get the compilercontext
*
* @return the compilercontext
*/
protected final compilercontext getcompilercontext
return  compilercontext  getcontextmanager
getcontext compilercontext context_id
/**
* get the typecompiler associated with the given typeid
*
* @param typeid	the typeid to get a typecompiler for
*
* @return	the corresponding typecompiler
*
*/
protected final typecompiler gettypecompiler typeid typeid
return
getcompilercontext   gettypecompilerfactory   gettypecompiler typeid
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
return v visit this
/**
* get the int value of a property
*
* @param value		property value as a string
* @param key		key value of property
*
* @return	the int value of the property
*
* @exception standardexception		thrown on failure
*/
protected int getintproperty string value  string key
throws standardexception
int intval    1
try
intval   integer parseint value
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_invalid_number_format_for_override
value  key
return intval
/**
** parse the a sql statement from the body
* of another sql statement. pushes and pops a
* separate compilercontext to perform the compilation.
*/
statementnode parsestatement string sql  boolean internalsql  throws standardexception
/*
** get a new compiler context, so the parsing of the text
** doesn't mess up anything in the current context
*/
languageconnectioncontext lcc   getlanguageconnectioncontext
compilercontext newcc   lcc pushcompilercontext
if  internalsql
newcc setreliability compilercontext internal_sql_legal
try
parser p   newcc getparser
return p parsestatement sql
finally
lcc popcompilercontext newcc
/**
* return the type of statement, something from
* statementtype.
*
* @return the type of statement
*/
protected int getstatementtype
return statementtype unknown
public boolean foundstring string list  string search
if  list    null
return false
for  int i   0  i < list length  i
if  list equals search
return true
return false
/**
* get a constantnode to represent a typed null value.
*
* @param type type of the null node.
*
* @return	a constantnode with the specified type, and a value of null
*
* @exception standardexception		thrown on error
*/
public  constantnode getnullnode datatypedescriptor type
throws standardexception
int constantnodetype
switch  type gettypeid   getjdbctypeid
case types varchar
constantnodetype   c_nodetypes varchar_constant_node
break
case types char
constantnodetype   c_nodetypes char_constant_node
break
case types tinyint
constantnodetype   c_nodetypes tinyint_constant_node
break
case types smallint
constantnodetype   c_nodetypes smallint_constant_node
break
case types integer
constantnodetype   c_nodetypes int_constant_node
break
case types bigint
constantnodetype   c_nodetypes longint_constant_node
break
case types real
constantnodetype   c_nodetypes float_constant_node
break
case types double
constantnodetype   c_nodetypes double_constant_node
break
case types numeric
case types decimal
constantnodetype   c_nodetypes decimal_constant_node
break
case types date
case types time
case types timestamp
constantnodetype   c_nodetypes usertype_constant_node
break
case types binary
constantnodetype   c_nodetypes bit_constant_node
break
case types varbinary
constantnodetype   c_nodetypes varbit_constant_node
break
case types longvarchar
constantnodetype   c_nodetypes longvarchar_constant_node
break
case types clob
constantnodetype   c_nodetypes clob_constant_node
break
case types longvarbinary
constantnodetype   c_nodetypes longvarbit_constant_node
break
case types blob
constantnodetype   c_nodetypes blob_constant_node
break
case jdbc40translation sqlxml
constantnodetype   c_nodetypes xml_constant_node
break
case types boolean
constantnodetype   c_nodetypes boolean_constant_node
break
default
if  type gettypeid   usertype
constantnodetype   c_nodetypes usertype_constant_node
else
if  sanitymanager debug
sanitymanager throwassert
type gettypeid   getsqltypename
return null
constantnode constantnode    constantnode  getnodefactory   getnode
constantnodetype
type gettypeid
cm
constantnode settype type getnullabilitytype true
return constantnode
/**
* translate a default node into a default value, given a type descriptor.
*
* @param typedescriptor	a description of the required data type.
*
* @exception standardexception		thrown on error
*/
public datavaluedescriptor convertdefaultnode datatypedescriptor typedescriptor
throws standardexception
/*
** override in cases where node type
** can be converted to default value.
*/
return null
/* initializable methods */
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6
object arg7  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6
object arg7
object arg8  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6
object arg7
object arg8
object arg9  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6
object arg7
object arg8
object arg9
object arg10  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6
object arg7
object arg8
object arg9
object arg10
object arg11  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6
object arg7
object arg8
object arg9
object arg10
object arg11
object arg12  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6
object arg7
object arg8
object arg9
object arg10
object arg11
object arg12
object arg13  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
/**
* initialize a query tree node.
*
* @exception standardexception		thrown on error
*/
public void init object arg1
object arg2
object arg3
object arg4
object arg5
object arg6
object arg7
object arg8
object arg9
object arg10
object arg11
object arg12
object arg13
object arg14  throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
public	tablename	maketablename
string	schemaname
string	flatname
throws standardexception
return maketablename
getnodefactory    getcontextmanager    schemaname  flatname
public	static  tablename	maketablename
nodefactory nodefactory
contextmanager contextmanager
string	schemaname
string	flatname
throws standardexception
return  tablename  nodefactory getnode
c_nodetypes table_name
schemaname
flatname
contextmanager
public boolean isatomic   throws standardexception
if  sanitymanager debug
sanitymanager throwassert     getclass   getname
return false
public object getcursorinfo   throws standardexception
return null
/**
* get the descriptor for the named table within the given schema.
* if the schema parameter is null, it looks for the table in the
* current (default) schema. table descriptors include object ids,
* object types (table, view, etc.)
* if the schema is session, then before looking into the data dictionary
* for persistent tables, it first looks into lcc for temporary tables.
* if no temporary table tablename found for the session schema, then it goes and
* looks through the data dictionary for persistent table
* we added gettabledescriptor here so that we can look for non data dictionary
* tables(ie temp tables) here. any calls to gettabledescriptor in data dictionary
* should be only for persistent tables
*
* @param tablename	the name of the table to get the descriptor for
* @param schema	the descriptor for the schema the table lives in.
*			if null, use the current (default) schema.
*
* @return	the descriptor for the table, null if table does not
*		exist.
*
* @exception standardexception		thrown on failure
*/
protected final tabledescriptor gettabledescriptor string tablename
schemadescriptor schema
throws standardexception
tabledescriptor retval
//following if means we are dealing with session schema.
if  issessionschema schema
//first we need to look in the list of temporary tables to see if this table is a temporary table.
retval   getlanguageconnectioncontext   gettabledescriptorfordeclaredglobaltemptable tablename
if  retval    null
return retval    this is a temporary table
//following if means we are dealing with session schema and we are dealing with in-memory schema (ie there is no physical session schema)
//if following if is true, it means session.table is not a declared table & it can't be physical session.table
//because there is no physical session schema
if  schema getuuid      null
return null
//it is not a temporary table, so go through the data dictionary to find the physical persistent table
tabledescriptor td   getdatadictionary   gettabledescriptor tablename  schema
this getlanguageconnectioncontext   gettransactioncompile
if  td    null    td issynonymdescriptor
return null
return td
/**
* get the descriptor for the named schema. if the schemaname
* parameter is null, it gets the descriptor for the current
* compilation schema.
*
* querytreenodes must obtain schemas using this method or the two argument
* version of it. this is to ensure that the correct default compliation schema
* is returned and to allow determination of if the statement being compiled
* depends on the current schema.
*
* schema descriptors include authorization ids and schema ids.
* sql92 allows a schema to specify a default character set - we will
* not support this.  will check default schema for a match
* before scanning a system table.
*
* @param schemaname	the name of the schema we're interested in.
*			if the name is null, get the descriptor for the
*			current compilation schema.
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on error
*/
final schemadescriptor	getschemadescriptor string schemaname
throws standardexception
//return getschemadescriptor(schemaname, schemaname != null);
return getschemadescriptor schemaname  true
/**
* get the descriptor for the named schema. if the schemaname
* parameter is null, it gets the descriptor for the current
* compilation schema.
*
* querytreenodes must obtain schemas using this method or the single argument
* version of it. this is to ensure that the correct default compliation schema
* is returned and to allow determination of if the statement being compiled
* depends on the current schema.
*
* @param schemaname the name of the schema we're interested in.
* if the name is null, get the descriptor for the current compilation schema.
* @param raiseerror true to raise an error if the schema does not exist,
* false to return null if the schema does not exist.
* @return valid schemadescriptor or null if raiseerror is false and the
* schema does not exist.
* @throws standardexception schema does not exist and raiseerror is true.
*/
final schemadescriptor	getschemadescriptor string schemaname  boolean raiseerror
throws standardexception
/*
** check for a compilation context.  sometimes
** there is a special compilation context in
** place to recompile something that may have
** been compiled against a different schema than
** the current schema (e.g views):
**
** 	create schema x
** 	create table t
** 	create view vt as seelct * from t
** 	set schema app
** 	select * from x.vt
**
** in the above view vt must be compiled against
** the x schema.
*/
schemadescriptor sd   null
boolean iscurrent   false
boolean iscompilation   false
if  schemaname    null
compilercontext cc   getcompilercontext
sd   cc getcompilationschema
if  sd    null
// set the compilation schema to be the default,
// notes that this query has schema dependencies.
sd   getlanguageconnectioncontext   getdefaultschema
iscurrent   true
cc setcompilationschema sd
else
iscompilation   true
schemaname   sd getschemaname
datadictionary datadictionary   getdatadictionary
schemadescriptor sdcatalog   datadictionary getschemadescriptor schemaname
getlanguageconnectioncontext   gettransactioncompile    raiseerror
if  iscurrent    iscompilation
//if we are dealing with a session schema and it is not physically
//created yet, then it's uuid is going to be null. derby-1706
//without the getuuid null check below, following will give npe
//set schema session; -- session schema has not been created yet
//create table t1(c11 int);
if  sdcatalog    null    sdcatalog getuuid      null
// different uuid for default (current) schema than in catalog,
// so reset default schema.
if   sdcatalog getuuid   equals sd getuuid
if  iscurrent
getlanguageconnectioncontext   setdefaultschema sdcatalog
getcompilercontext   setcompilationschema sdcatalog
else
// this schema does not exist, so ensure its uuid is null.
sd setuuid null
sdcatalog   sd
return sdcatalog
/**
* resolve table/view reference to a synonym. may have to follow a synonym chain.
*
* @param	tabname to match for a synonym
*
* @return	synonym tablename if a match is found, null otherwise.
*
* @exception standardexception		thrown on error
*/
public tablename resolvetabletosynonym tablename tabname  throws standardexception
datadictionary dd   getdatadictionary
string nextsynonymtable   tabname gettablename
string nextsynonymschema   tabname getschemaname
boolean found   false
compilercontext cc   getcompilercontext
// circular synonym references should have been detected at the ddl time, so
// the following loop shouldn't loop forever.
for
schemadescriptor nextsd   getschemadescriptor nextsynonymschema  false
if  nextsd    null    nextsd getuuid      null
break
aliasdescriptor nextad   dd getaliasdescriptor nextsd getuuid   tostring
nextsynonymtable  aliasinfo alias_name_space_synonym_as_char
if  nextad    null
break
/* query is dependent on the aliasdescriptor */
cc createdependency nextad
found   true
synonymaliasinfo info     synonymaliasinfo nextad getaliasinfo
nextsynonymtable   info getsynonymtable
nextsynonymschema   info getsynonymschema
if   found
return null
tablename tablename   new tablename
tablename init nextsynonymschema  nextsynonymtable
return tablename
/**
* verify that a java class exists, is accessible (public)
* and not a class representing a primitive type.
* @param javaclassname	the name of the java class to resolve.
*
*
* @exception standardexception		thrown on error
*/
void verifyclassexist string javaclassname
throws standardexception
classinspector classinspector   getclassfactory   getclassinspector
throwable reason   null
boolean foundmatch   false
try
foundmatch   classinspector accessible javaclassname
catch  classnotfoundexception cnfe
reason   cnfe
if   foundmatch
throw standardexception newexception sqlstate lang_type_doesnt_exist2  reason  javaclassname
if  classinspector primitivetype javaclassname
throw standardexception newexception sqlstate lang_type_doesnt_exist3  javaclassname
/**
* set the information gathered from the parent table that is
* required to peform a referential action on dependent table.
*/
public void setrefactioninfo long fkindexconglomid
intfkcolarray
string parentresultsetid
boolean dependentscan
if  sanitymanager debug
sanitymanager throwassert
getclass   getname
/**
add an authorization check into the passed in method.
*/
void generateauthorizecheck activationclassbuilder acb
methodbuilder mb
int sqloperation
// add code to authorize statement execution.
acb pushthisasactivation mb
mb callmethod vmopcode invokeinterface  null
classname languageconnectioncontext  0
mb callmethod vmopcode invokeinterface  null
classname authorizer  0
acb pushthisasactivation mb
mb push sqloperation
mb callmethod vmopcode invokeinterface  null
2
/**
* bind time logic. raises an error if this valuenode, once compiled, returns
* unstable results and if we're in a context where unstable results are
* forbidden.
*
* called by children who may not appear in the where subclauses of add table clauses.
*
*	@param	fragmenttype	type of fragment as a string, for inclusion in error messages.
*	@param	fragmentbitmask	type of fragment as a bitmask of possible fragment types
*
* @exception standardexception		thrown on error
*/
public	void	checkreliability  string fragmenttype  int fragmentbitmask
throws standardexception
// if we're in a context that forbids unreliable fragments, raise an error
if     getcompilercontext   getreliability     fragmentbitmask      0
throwreliabilityexception  fragmenttype  fragmentbitmask
/**
* bind time logic. raises an error if this valuenode, once compiled, returns
* unstable results and if we're in a context where unstable results are
* forbidden.
*
* called by children who may not appear in the where subclauses of add table clauses.
*
*	@param	fragmentbitmask	type of fragment as a bitmask of possible fragment types
*	@param	fragmenttype	type of fragment as a string, to be fetch for the error message.
*
* @exception standardexception		thrown on error
*/
public	void	checkreliability  int fragmentbitmask  string fragmenttype
throws standardexception
// if we're in a context that forbids unreliable fragments, raise an error
if     getcompilercontext   getreliability     fragmentbitmask      0
string fragmenttypetxt   messageservice gettextmessage  fragmenttype
throwreliabilityexception  fragmenttypetxt  fragmentbitmask
/**
* common code for the 2 checkreliability functions.  always throws standardexception.
*
* @param fragmenttype type of fragment as a string, for inclusion in error messages.
* @param fragmentbitmask describes the kinds of expressions we ar suspicious of
* @exception standardexception        throws an error, always.
*/
private void throwreliabilityexception  string fragmenttype  int fragmentbitmask   throws standardexception
string sqlstate
/* error string somewhat dependent on operation due to different
* nodes being allowed for different operations.
*/
if  getcompilercontext   getreliability      compilercontext default_restriction
sqlstate   sqlstate lang_invalid_default_definition
else if  getcompilercontext   getreliability      compilercontext generation_clause_restriction
switch   fragmentbitmask
case compilercontext sql_in_routines_illegal
sqlstate   sqlstate lang_routine_cant_permit_sql
break
default
sqlstate   sqlstate lang_non_deterministic_generation_clause
break
else
sqlstate   sqlstate lang_unreliable_query_fragment
throw standardexception newexception sqlstate  fragmenttype