/*
derby - class org.apache.derby.impl.services.jce.jcecipherfactory
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services jce
import org apache derby iapi services crypto cipherfactory
import org apache derby iapi services crypto cipherprovider
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi services info jvminfo
import org apache derby iapi util stringutil
import org apache derby iapi reference sqlstate
import org apache derby iapi reference attribute
import org apache derby iapi util stringutil
import java util properties
import java util enumeration
import java security key
import java security provider
import java security securerandom
import java security security
import java security invalidkeyexception
import java security nosuchalgorithmexception
import java security messagedigest
import java security spec keyspec
import java security spec invalidkeyspecexception
import java io filenotfoundexception
import java io ioexception
import java io inputstream
import java io datainputstream
import javax crypto keygenerator
import javax crypto secretkey
import javax crypto secretkeyfactory
import javax crypto spec deskeyspec
import javax crypto spec secretkeyspec
import org apache derby iapi store raw rawstorefactory
import org apache derby io storagefactory
import org apache derby io writablestoragefactory
import org apache derby io storagefile
import org apache derby io storagerandomaccessfile
/**
this cipherfactory creates new jcecipherprovider.
@see cipherfactory
*/
public final class jcecipherfactory implements cipherfactory  java security privilegedexceptionaction
private final static string message_digest
private final static string default_algorithm
private final static string des
private final static string desede
private final static string tripledes
private final static string aes
// minimum boot password length in bytes
private final static int block_length   8
/**
aes encryption takes in an default initialization vector length (iv) length of 16 bytes
this is needed to generate an iv to use for encryption and decryption process
@see cipherprovider
*/
private final static int aes_iv_length   16
// key length in bytes
private int keylengthbits
private int encodedkeylength
private string cryptoalgorithm
private string cryptoalgorithmshort
private string cryptoprovider
private string cryptoprovidershort
private messagedigest messagedigest
private secretkey mainsecretkey
private byte mainiv
// properties that needs to be stored in the
// in the service.properties file.
private properties persistentproperties
/**
amount of data that is used for verification of external encryption key
this does not include the md5 checksum bytes
*/
private final static int verifykey_datalen   4096
private storagefile activefile
private int action
private string activeperms
/*
* constructor of jcecipherfactory, initializes the new instances.
*
* @param create    true, if the database is getting configured
*                  for encryption.
* @param props	    encryption properties/attributes to use
*                  for creating the cipher factory.
* @param newattrs  true, if cipher factory has to be created using
*                  should using the new attributes specified by the user.
*                  for example to reencrypt the database with
*                  a new password.
*/
public jcecipherfactory boolean create
properties props
boolean newattributes
throws standardexception
init create  props  newattributes
static string providererrorname string cps
return cps    null ?     cps
private byte generateuniquebytes   throws standardexception
try
string provider   cryptoprovidershort
keygenerator keygen
if  provider    null
keygen   keygenerator getinstance cryptoalgorithmshort
else
if  provider equals
provider
keygen   keygenerator getinstance cryptoalgorithmshort  provider
keygen init keylengthbits
secretkey key   keygen generatekey
return key getencoded
catch  java security nosuchalgorithmexception nsae
throw standardexception newexception sqlstate encryption_nosuch_algorithm  cryptoalgorithm
jcecipherfactory providererrorname cryptoprovidershort
catch  java security nosuchproviderexception nspe
throw standardexception newexception sqlstate encryption_bad_provider
jcecipherfactory providererrorname cryptoprovidershort
/**
encrypt the secretkey with the boot password.
this includes the following steps,
getting muck from the boot password and then using this to generate a key,
generating an appropriate iv using the muck
using the key and iv thus generated to create the appropriate cipher provider
and encrypting the secretkey
@return hexadecimal string of the encrypted secretkey
@exception standardexception standard derby error policy
*/
private string encryptkey byte secretkey  byte bootpassword
throws standardexception
// in case of aes, care needs to be taken to allow for 16 bytes muck as well
// as to have the secretkey that needs encryption to be a aligned appropriately
// aes supports 16 bytes block size
int mucklength   secretkey length
if cryptoalgorithmshort equals aes
mucklength   aes_iv_length
byte muck   getmuckfrombootpassword bootpassword  mucklength
secretkey key   generatekey muck
byte iv   generateiv muck
cipherprovider tmpcipherprovider   createnewcipher encrypt key iv
// store the actual secretkey.length before any possible padding
encodedkeylength   secretkey length
// for the secretkey to be encrypted, first ensure that it is aligned to the block size of the
// encryption algorithm by padding bytes appropriately if needed
secretkey   padkey secretkey tmpcipherprovider getencryptionblocksize
byte result   new byte
// encrypt the secretkey using the key generated of muck from  boot password and the generated iv
tmpcipherprovider encrypt secretkey  0  secretkey length  result  0
return org apache derby iapi util stringutil tohexstring result  0  result length
/**
for block ciphers, and  algorithms using the nopadding scheme, the data that has
to be encrypted needs to be a multiple of the expected block size for the cipher
pad the key with appropriate padding to make it blocksize align
@param     secretkey	the data that needs blocksize alignment
@param     blocksizealign   secretkey needs to be blocksize aligned
@return    a byte array with the contents of secretkey along with padded bytes in the end
to make it blocksize aligned
*/
private byte padkey byte secretkey int blocksizealign
byte  result   secretkey
if secretkey length % blocksizealign    0
int encryptedlength   secretkey length   blocksizealign    secretkey length % blocksizealign
result   new byte
system arraycopy secretkey 0 result 0 secretkey length
return result
/**
decrypt the secretkey with the user key .
this includes the following steps,
retrieve the encryptedkey, generate the muck from the boot password and generate an appropriate iv using
the muck,and using the key and iv decrypt the encryptedkey
@return decrypted key
@exception standardexception standard derby error policy
*/
private byte decryptkey string encryptedkey  int encodedkeycharlength  byte bootpassword
throws standardexception
byte secretkey   org apache derby iapi util stringutil fromhexstring encryptedkey  0  encodedkeycharlength
// in case of aes, care needs to be taken to allow for 16 bytes muck as well
// as to have the secretkey that needs encryption to be a aligned appropriately
// aes supports 16 bytes block size
int mucklength
if cryptoalgorithmshort equals aes
mucklength   aes_iv_length
else
mucklength   secretkey length
byte muck   getmuckfrombootpassword bootpassword  mucklength
// decrypt the encryptedkey with the mucked up boot password to recover
// the secretkey
secretkey key   generatekey muck
byte iv   generateiv muck
createnewcipher decrypt  key  iv
decrypt secretkey  0  secretkey length  secretkey  0
return secretkey
private byte getmuckfrombootpassword byte bootpassword  int encodedkeybytelength
int ulength   bootpassword length
byte muck   new byte
int rotation   0
for  int i   0  i < bootpassword length  i
rotation    bootpassword
for  int i   0  i < encodedkeybytelength  i
muck    byte  bootpassword ^
bootpassword << 4
return muck
/**
generate a key object using the input secretkey that can be used by
jcecipherprovider to encrypt or decrypt.
@exception standardexception standard derby error policy
*/
private secretkey generatekey byte secretkey  throws standardexception
int length   secretkey length
if  length < cipherfactory min_bootpass_length
throw standardexception newexception sqlstate illegal_bp_length  new integer min_bootpass_length
try
if  cryptoalgorithmshort equals des
single des
if  deskeyspec isweak secretkey  0
// ok, it is weak, spice it up
byte spice   stringutil getasciibytes
for  int i   0  i < 7  i
secretkey    byte   spice << 3  ^ secretkey
return new secretkeyspec secretkey  cryptoalgorithmshort
catch  invalidkeyexception ike
throw standardexception newexception sqlstate crypto_exception  ike
/**
generate an iv using the input secretkey that can be used by
jcecipherprovider to encrypt or decrypt.
*/
private byte generateiv byte secretkey
// do a little simple minded muddling to make the iv not
// strictly alphanumeric and the number of total possible keys a little
// bigger.
int ivlen   block_length
byte iv   null
if cryptoalgorithmshort equals aes
ivlen   aes_iv_length
iv   new byte
iv    byte    secretkey << 2    0xf  ^ secretkey
for  int i   1  i < block_length  i
iv    byte    secretkey <<  i%5     0xf  ^ secretkey
for int i   block_length   i < aes_iv_length   i
iv iv
else
iv   new byte
iv    byte    secretkey << 2    0xf  ^ secretkey
for  int i   1  i < block_length  i
iv    byte    secretkey <<  i%5     0xf  ^ secretkey
return iv
private int digest byte input
messagedigest reset
byte digest   messagedigest digest input
byte condensedigest   new byte
// no matter how long the digest is, condense it into an short.
for  int i   0  i < digest length  i
condensedigest ^  digest
int retval    condensedigest   0xff      condensedigest << 8    0xff00
return retval
public securerandom getsecurerandom
return new securerandom mainiv
public cipherprovider createnewcipher int mode
throws standardexception
return createnewcipher mode  mainsecretkey  mainiv
private cipherprovider createnewcipher int mode  secretkey secretkey
byte iv
throws standardexception
return new jcecipherprovider mode  secretkey  iv  cryptoalgorithm  cryptoprovidershort
/*
* initilize the new instance of this class.
*/
public void	init boolean create  properties properties  boolean newattrs
throws standardexception
boolean provider_or_algo_specified   false
boolean storeproperties   create
persistentproperties   new properties
// get the external key specified by the user to
// encrypt the database. if user is reencrypting the
// database with a new encryption key,  read the value of
// the new encryption key.
string externalkey    properties getproperty  newattrs ?
attribute new_crypto_external_key
attribute crypto_external_key
if  externalkey    null
storeproperties   false
cryptoprovider   properties getproperty attribute crypto_provider
if  cryptoprovider    null
provider_or_algo_specified   true
// explictly putting the properties back into the properties
// saves then in service.properties at create time.
//	if (storeproperties)
//		properties.put(attribute.crypto_provider, cryptoprovider);
int dotpos   cryptoprovider lastindexof
if  dotpos     1
cryptoprovidershort   cryptoprovider
else
cryptoprovidershort   cryptoprovider substring dotpos 1
cryptoalgorithm   properties getproperty attribute crypto_algorithm
if  cryptoalgorithm    null
cryptoalgorithm   default_algorithm
else
provider_or_algo_specified   true
// explictly putting the properties back into the properties
// saves then in service.properties at create time.
if  storeproperties
persistentproperties put attribute crypto_algorithm
cryptoalgorithm
int firstslashpos   cryptoalgorithm indexof
int lastslashpos   cryptoalgorithm lastindexof
if  firstslashpos < 0    lastslashpos < 0    firstslashpos    lastslashpos
throw standardexception newexception sqlstate encryption_bad_alg_format  cryptoalgorithm
cryptoalgorithmshort   cryptoalgorithm substring 0 firstslashpos
if  provider_or_algo_specified
// track 3715 - disable use of provider/aglo specification if
// jce environment is not 1.2.1.  the exemptionmechanism class
// exists in jce1.2.1 and not in jce1.2, so try and load the
// class and if you can't find it don't allow the encryption.
// this is a requirement from the government to give cloudscape
// export clearance for 3.6.  note that the check is not needed
// if no provider/algo is specified, in that case we default to
// a des weak encryption algorithm which also is allowed for
// export (this is how 3.5 got it's clearance).
try
class c   class forname
catch  throwable t
throw standardexception newexception
sqlstate encryption_bad_jce
// if connecting to an existing database and attribute.crypto_key_length is set
// then obtain the encoded key length values without padding bytes and retrieve
// the keylength in bits if boot password mechanism is used
// note: attribute.crypto_key_length is set during creation time to a supported
// key length in the connection url. internally , two values are stored in this property
// if encryptionkey is used, this property will have only the encoded key length
// if boot password mechanism is used, this property will have the following
// keylengthbits-encodedkeylength
if  create
// if available, parse the keylengths stored in attribute.crypto_key_length
if properties getproperty attribute crypto_key_length     null
string keylengths   properties getproperty attribute crypto_key_length
int pos   keylengths lastindexof
encodedkeylength   integer parseint keylengths substring pos 1
if pos     1
keylengthbits   integer parseint keylengths substring 0 pos
// case 1 - if 'encryptionkey' is not set and 'encryptionkeylength' is set, then use
// the 'encryptionkeylength' property value  as the keylength in bits.
// case 2 - 'encryptionkey' property is not set and 'encryptionkeylength' is not set, then
// use the defaults keylength:  56bits for des, 168 for desede and 128 for any other encryption
// algorithm
if  externalkey    null    create
if properties getproperty attribute crypto_key_length     null
keylengthbits   integer parseint properties getproperty attribute crypto_key_length
else if  cryptoalgorithmshort equals des
keylengthbits   56
else if  cryptoalgorithmshort equals desede     cryptoalgorithmshort equals tripledes
keylengthbits   168
else
keylengthbits   128
// check the feedback mode
string feedbackmode   cryptoalgorithm substring firstslashpos 1 lastslashpos
if   feedbackmode equals        feedbackmode equals
feedbackmode equals        feedbackmode equals
throw standardexception newexception sqlstate encryption_bad_feedbackmode  feedbackmode
// check the nopadding mode is used
string padding   cryptoalgorithm substring lastslashpos 1 cryptoalgorithm length
if   padding equals
throw standardexception newexception sqlstate encryption_bad_padding  padding
throwable t
try
if  cryptoprovider    null
// provider package should be set by property
if  security getprovider cryptoprovidershort     null
action   1
// add provider through privileged block.
java security accesscontroller doprivileged this
// need this to check the boot password
messagedigest   messagedigest getinstance message_digest
byte generatedkey
if  externalkey    null
// incorrect to specify external key and boot password
if  properties getproperty  newattrs ?
attribute new_boot_password
attribute boot_password      null
throw standardexception newexception sqlstate service_wrong_boot_password
generatedkey
org apache derby iapi util stringutil fromhexstring externalkey
0
externalkey length
if  generatedkey    null
throw standardexception newexception
// if length is even, we assume invalid character(s),
// based on how 'fromhexstring' behaves.
externalkey length   % 2    0
? sqlstate encryption_illegal_exkey_chars
sqlstate encryption_invalid_exkey_length
else
generatedkey   handlebootpassword create  properties  newattrs
if create    newattrs
persistentproperties put attribute crypto_key_length
keylengthbits   generatedkey length
// make a key and iv object out of the generated key
mainsecretkey   generatekey generatedkey
mainiv   generateiv generatedkey
if  create
persistentproperties put attribute data_encryption
// set two new properties to allow for future changes to the log and data encryption
// schemes. this property is introduced in version 10 , value starts at 1.
persistentproperties put rawstorefactory data_encrypt_algorithm_version
string valueof 1
persistentproperties put rawstorefactory log_encrypt_algorithm_version
string valueof 1
return
catch  java security privilegedactionexception  pae
t   pae getexception
catch  nosuchalgorithmexception nsae
t   nsae
catch  securityexception se
t   se
catch  linkageerror le
t   le
catch  classcastexception cce
t   cce
throw standardexception newexception sqlstate missing_encryption_provider  t
private byte handlebootpassword boolean create
properties properties
boolean newpasswd
throws standardexception
// get the key  specifed by the user. if user is reencrypting the
// database; read the value of the new password.
string inputkey   properties getproperty  newpasswd ?
attribute new_boot_password
attribute boot_password
if  inputkey    null
throw standardexception newexception sqlstate service_wrong_boot_password
byte bootpassword   stringutil getasciibytes inputkey
if  bootpassword length < cipherfactory min_bootpass_length
string messageid   create ? sqlstate service_boot_password_too_short
sqlstate service_wrong_boot_password
throw standardexception newexception messageid
// each database has its own unique encryption key that is
// not known even to the user.  however, this key is masked
// with the user input key and stored in the
// services.properties file so that, with the user key, the
// encryption key can easily be recovered.
// to change the user encryption key to a database, simply
// recover the unique real encryption key and masked it
// with the new user key.
byte generatedkey
if  create    newpasswd
//
generatedkey   generateuniquebytes
persistentproperties put rawstorefactory encrypted_key
savesecretkey generatedkey  bootpassword
else
generatedkey   getdatabasesecretkey properties  bootpassword  sqlstate service_wrong_boot_password
return generatedkey
/*
* put all the encyrpion cipger related properties that has to
* be made peristent into the database service properties list.
* @param  properties  properties object that is used to store
*                     cipher properties persistently.
*/
public void saveproperties properties properties
// put the cipher properties to be persistent into the
// system perisistent properties.
for  enumeration e   persistentproperties keys
e hasmoreelements
string key    string  e nextelement
properties put key  persistentproperties get key
// clear the cipher properties to be persistent.
persistentproperties   null
/**
get the secretkey used for encryption and decryption when boot password mechanism is used for encryption
steps include
retrieve the stored key, decrypt the stored key and verify if the correct boot password was passed
there is a possibility that the decrypted key includes the original key and padded bytes in order to have
been block size aligned during encryption phase. hence extract the original key
@param	properties	properties to retrieve the encrypted key
@param	bootpassword	boot password used to connect to the encrypted database
@param	errorstate	errorstate to account for any errors during retrieval /creation of the secretkey
@return the original unencrypted key bytes to use for encryption and decrytion
*/
private byte getdatabasesecretkey properties properties  byte bootpassword  string errorstate  throws standardexception
// recover the generated secret encryption key from the
// services.properties file and the user key.
string keystring   properties getproperty rawstorefactory encrypted_key
if  keystring    null
throw standardexception newexception errorstate
int encodedkeycharlength   keystring indexof
if  encodedkeycharlength     1     bad form
throw standardexception newexception errorstate
int verifykey   integer parseint keystring substring encodedkeycharlength 1
byte generatedkey   decryptkey keystring  encodedkeycharlength  bootpassword
int checkkey   digest generatedkey
if  checkkey    verifykey
throw standardexception newexception errorstate
// if encodedkeylength is not defined, then either it is an old version with no support for different
// key sizes and padding except for defaults
byte result
if encodedkeylength    0
result   new byte
// extract the generated key without the padding bytes
system arraycopy generatedkey 0 result 0 encodedkeylength
return result
return generatedkey
private string savesecretkey byte secretkey  byte bootpassword  throws standardexception
string encryptedkey   encryptkey secretkey  bootpassword
// make a verification key out of the message digest of
// the generated key
int verifykey   digest secretkey
return encryptedkey concat     verifykey
public string changebootpassword string changestring  properties properties  cipherprovider verify
throws standardexception
// the new bootpassword is expected to be of the form
// oldkey , newkey.
int seperator   changestring indexof
if  seperator     1
throw standardexception newexception sqlstate wrong_password_change_format
string oldbp   changestring substring 0  seperator  trim
byte oldbpascii   stringutil getasciibytes oldbp
if  oldbpascii    null    oldbpascii length < cipherfactory min_bootpass_length
throw standardexception newexception sqlstate wrong_boot_password
string newbp   changestring substring seperator 1  trim
byte newbpascii   stringutil getasciibytes newbp
if  newbpascii    null    newbpascii length < cipherfactory min_bootpass_length
throw standardexception newexception sqlstate illegal_bp_length
new integer cipherfactory min_bootpass_length
// verify old key
byte generatedkey   getdatabasesecretkey properties  oldbpascii  sqlstate wrong_boot_password
// make sure the oldkey is correct
byte iv   generateiv generatedkey
if     jcecipherprovider  verify  verifyiv iv
throw standardexception newexception sqlstate wrong_boot_password
// make the new key.  the generated key is unchanged, only the
// encrypted key is changed.
string newkey   savesecretkey generatedkey  newbpascii
properties put attribute crypto_key_length keylengthbits   encodedkeylength
return savesecretkey generatedkey  newbpascii
/**
perform actions with privileges enabled.
*/
public final object run   throws standardexception  instantiationexception  illegalaccessexception
try
switch action
case 1
security addprovider
provider  class forname cryptoprovider  newinstance
break
case 2
// security permission - mp1 and/or op4
// depends on the value of activeperms
return activefile getrandomaccessfile activeperms
case 3
return activefile getinputstream
catch  classnotfoundexception cnfe
throw standardexception newexception sqlstate encryption_no_provider_class cryptoprovider
catch filenotfoundexception fnfe
throw standardexception newexception sqlstate encryption_unable_key_verification cryptoprovider
return null
/**
the database can be encrypted with an encryption key given in connection url.
for security reasons, this key is not made persistent in the database.
but it is necessary to verify the encryption key when booting the database if it is similar
to the one used when creating the database
this needs to happen before we access the data/logs to avoid the risk of corrupting the
database because of a wrong encryption key.
this method performs the steps necessary to verify the encryption key if an external
encryption key is given.
at database creation, 4k of random data is generated using securerandom and md5 is used
to compute the checksum for the random data thus generated.  this 4k page of random data
is then encrypted using the encryption key. the checksum of unencrypted data and
encrypted data is made persistent in the database in file by name given by
attribute.crypto_external_key_verifyfile (verifykey.dat). this file exists directly under the
database root directory.
when trying to boot an existing encrypted database, the given encryption key is used to decrypt
the data in the verifykey.dat and the checksum is calculated and compared against the original
stored checksum. if these checksums dont match an exception is thrown.
please note, this process of verifying the key  does not provide any added security but only is
intended to allow to fail gracefully if a wrong encryption key is used
standardexception is thrown if there are any problems during the process of verification
of the encryption key or if there is any mismatch of the encryption key.
*/
public void verifykey boolean create  storagefactory sf  properties properties
throws standardexception
if properties getproperty attribute crypto_external_key     null
return
// if firsttime ( ie during creation of database, initial key used )
// in order to allow for verifying the external key for future database boot,
// generate random 4k of data and store the encrypted random data and the checksum
// using md5 of the unencrypted data. that way, on next database boot a check is performed
// to verify if the key is the same as used when the database was created
inputstream verifykeyinputstream   null
storagerandomaccessfile verifykeyfile   null
byte data   new byte
try
if create
getsecurerandom   nextbytes data
// get the checksum
byte checksum   getmd5checksum data
cipherprovider tmpcipherprovider   createnewcipher encrypt mainsecretkey mainiv
tmpcipherprovider encrypt data  0  data length  data  0
// openfileforwrite
verifykeyfile   privaccessfile sf attribute crypto_external_key_verify_file
// write the checksum length as int, and then the checksum and then the encrypted data
verifykeyfile writeint checksum length
verifykeyfile write checksum
verifykeyfile write data
verifykeyfile sync true
else
// read from verifykey.dat as an inputstream. this allows for
// reading the information from verifykey.dat successfully even when using the jar
// subprotocol to boot derby. (derby-1373)
verifykeyinputstream   privaccessgetinputstream sf attribute crypto_external_key_verify_file
datainputstream dis   new datainputstream verifykeyinputstream
// then read the checksum length
int checksumlen   dis readint
byte originalchecksum   new byte
dis readfully originalchecksum
dis readfully data
// decrypt data with key
cipherprovider tmpcipherprovider   createnewcipher decrypt mainsecretkey mainiv
tmpcipherprovider decrypt data  0  data length  data  0
byte verifychecksum   getmd5checksum data
if  messagedigest isequal originalchecksum verifychecksum
throw standardexception newexception sqlstate encryption_bad_external_key
catch ioexception ioe
throw standardexception newexception sqlstate encryption_unable_key_verification ioe
finally
try
if verifykeyfile    null
verifykeyfile close
if  verifykeyinputstream    null
verifykeyinputstream close
catch ioexception ioee
throw standardexception newexception sqlstate encryption_unable_key_verification ioee
return
/**
use md5 messagedigest algorithm to generate checksum
@param data	data to be used to compute the hash value
@return returns the hash value computed using the data
*/
private byte getmd5checksum byte data
throws standardexception
try
// get the checksum
messagedigest md5   messagedigest getinstance
return md5 digest data
catch nosuchalgorithmexception nsae
throw standardexception newexception sqlstate encryption_bad_alg_format message_digest
/**
access a file for either read/write
@param storagefactory	factory used for io access
@param	filename		name of the file to create and open for write
the file will be created directly under the database root directory
@param	fileperms		file permissions, if "rw" open file with read and write permissions
if "r" , open file with read permissions
@return	storagerandomaccessfile returns file with filename for writing
@exception ioexception any exception during accessing the file for read/write
*/
private storagerandomaccessfile privaccessfile storagefactory storagefactory string filename string fileperms
throws java io ioexception
storagefile verifykeyfile   storagefactory newstoragefile   filename
activefile    verifykeyfile
this action   2
activeperms   fileperms
try
return  storagerandomaccessfile java security accesscontroller doprivileged this
catch  java security privilegedactionexception pae
throw  java io ioexception pae getexception
/**
access a inputstream for a given file for reading.
@param storagefactory   factory used for io access
@param  filename        name of the file to open as a stream for reading
@return inputstream returns the stream for the file with filename for reading
@exception ioexception any exception during accessing the file for read
*/
private inputstream privaccessgetinputstream storagefactory storagefactory string filename
throws standardexception
storagefile verifykeyfile   storagefactory newstoragefile   filename
activefile    verifykeyfile
this action   3
try
return  inputstream java security accesscontroller doprivileged this
catch  java security privilegedactionexception pae
throw  standardexception pae getexception