/*
derby - class org.apache.derby.impl.sql.execute.projectrestrictresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi services stream infostreams
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn statementcontext
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute noputresultset
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi services loader generatedmethod
import org apache derby iapi error standardexception
import org apache derby iapi types rowlocation
import org apache derby catalog types referencedcolumnsdescriptorimpl
/**
* takes a table and a table filter and returns
* the table's rows satisfying the filter as a result set.
*
*/
class projectrestrictresultset extends noputresultsetimpl
implements cursorresultset
/* run time statistics variables */
public long restrictiontime
public long projectiontime
// set in constructor and not altered during
// life of object.
final noputresultset source
public generatedmethod constantrestriction
public generatedmethod restriction
public boolean doesprojection
private generatedmethod projection
private int			projectmapping
private boolean runtimestatson
private execrow			mappedresultrow
public boolean reuseresult
private boolean shortcircuitopen
private execrow projrow
//
// class interface
//
projectrestrictresultset noputresultset s
activation a
generatedmethod r
generatedmethod p
int resultsetnumber
generatedmethod cr
int maprefitem
boolean reuseresult
boolean doesprojection
double optimizerestimatedrowcount
double optimizerestimatedcost
throws standardexception
super a  resultsetnumber  optimizerestimatedrowcount  optimizerestimatedcost
source   s
// source expected to be non-null, mystery stress test bug
// - sometimes get nullpointerexception in opencore().
if  sanitymanager debug
sanitymanager assert source    null
restriction   r
projection   p
constantrestriction   cr
projectmapping     referencedcolumnsdescriptorimpl  a getpreparedstatement   getsavedobject maprefitem   getreferencedcolumnpositions
this reuseresult   reuseresult
this doesprojection   doesprojection
// allocate a result row if all of the columns are mapped from the source
if  projection    null
mappedresultrow   activation getexecutionfactory   getvaluerow projectmapping length
/* remember whether or not runtimestatistics is on */
runtimestatson   getlanguageconnectioncontext   getruntimestatisticsmode
recordconstructortime
//
// noputresultset interface
//
/**
* open a scan on the table. scan parameters are evaluated
* at each open, so there is probably some way of altering
* their values...
*
* @exception standardexception thrown if cursor finished.
*/
public void	opencore   throws standardexception
boolean constanteval   true
begintime   getcurrenttimemillis
// source expected to be non-null, mystery stress test bug
// - sometimes get nullpointerexception in opencore().
if  sanitymanager debug
sanitymanager assert source    null
// revisit: through the direct db api, this needs to be an
// error, not an assert; users can open twice. only through jdbc
// is access to open controlled and ensured valid.
if  sanitymanager debug
sanitymanager assert    isopen
if  constantrestriction    null
datavaluedescriptor restrictboolean
restrictboolean    datavaluedescriptor
constantrestriction invoke activation
// if the result is null, we make it false --
// so the row won't be returned.
constanteval    restrictboolean    null
restrictboolean isnull
restrictboolean getboolean
if  constanteval
source opencore
else
shortcircuitopen   true
isopen   true
numopens
opentime    getelapsedmillis begintime
/**
* reopen a scan on the table. scan parameters are evaluated
* at each open, so there is probably some way of altering
* their values...
*
* @exception standardexception thrown if cursor finished.
*/
public void	reopencore   throws standardexception
boolean constanteval   true
begintime   getcurrenttimemillis
if  sanitymanager debug
sanitymanager assert isopen
if  constantrestriction    null
datavaluedescriptor restrictboolean
restrictboolean    datavaluedescriptor
constantrestriction invoke activation
// if the result is null, we make it false --
// so the row won't be returned.
constanteval    restrictboolean    null
restrictboolean isnull
restrictboolean getboolean
if  constanteval
source reopencore
else
shortcircuitopen   true
isopen   true
numopens
opentime    getelapsedmillis begintime
/**
* return the requested values computed
* from the next row (if any) for which
* the restriction evaluates to true.
* <p>
* restriction and projection parameters
* are evaluated for each row.
*
* @exception standardexception thrown on failure.
* @exception standardexception resultsetnotopen thrown if not yet open.
*
* @return the next row in the result
*/
public execrow	getnextrowcore   throws standardexception
execrow candidaterow   null
execrow result   null
boolean restrict   false
datavaluedescriptor restrictboolean
long	beginrt   0
/* return null if open was short circuited by false constant expression */
if  shortcircuitopen
return result
begintime   getcurrenttimemillis
do
candidaterow   source getnextrowcore
if  candidaterow    null
beginrt   getcurrenttimemillis
/* if restriction is null, then all rows qualify */
if  restriction    null
restrict   true
else
setcurrentrow candidaterow
restrictboolean    datavaluedescriptor
restriction invoke activation
restrictiontime    getelapsedmillis beginrt
// if the result is null, we make it false --
// so the row won't be returned.
restrict       restrictboolean isnull
restrictboolean getboolean
if    restrict
rowsfiltered
/* update the run time statistics */
rowsseen
while    candidaterow    null
restrict
if  candidaterow    null
beginrt   getcurrenttimemillis
result   doprojection candidaterow
projectiontime    getelapsedmillis beginrt
/* clear the current row, if null */
else
clearcurrentrow
currentrow   result
if  runtimestatson
if    istopresultset
/* this is simply for runtimestats */
/* we first need to get the subquery tracking array via the statementcontext */
statementcontext sc   activation getlanguageconnectioncontext   getstatementcontext
subquerytrackingarray   sc getsubquerytrackingarray
nexttime    getelapsedmillis begintime
return result
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
long tottime   constructortime   opentime   nexttime   closetime
if  type    current_resultset_only
return	tottime   source gettimespent entire_resultset_tree
else
return tottime
// resultset interface
/**
* if the result set has been opened,
* close the open scan.
*
* @exception standardexception thrown on error
*/
public void	close   throws standardexception
/* nothing to do if open was short circuited by false constant expression */
if  shortcircuitopen
isopen   false
shortcircuitopen   false
source close
return
begintime   getcurrenttimemillis
if   isopen
// we don't want to keep around a pointer to the
// row ... so it can be thrown away.
// revisit: does this need to be in a finally
// block, to ensure that it is executed?
clearcurrentrow
source close
super close
else
if  sanitymanager debug
sanitymanager debug
closetime    getelapsedmillis begintime
public void	finish   throws standardexception
source finish
finishandrts
//
// cursorresultset interface
//
/**
* gets information from its source. we might want
* to have this take a cursorresultset in its constructor some day,
* instead of doing a cast here?
*
* @see cursorresultset
*
* @return the row location of the current cursor row.
* @exception standardexception thrown on failure.
*/
public rowlocation getrowlocation   throws standardexception
if  sanitymanager debug
sanitymanager assert source instanceof cursorresultset
return    cursorresultset source   getrowlocation
/**
* gets last row returned.
*
* @see cursorresultset
*
* @return the last row returned.
* @exception standardexception thrown on failure.
*/
/* resolve - this should return activation.getcurrentrow(resultsetnumber),
* once there is such a method.  (currentrow is redundant)
*/
public execrow getcurrentrow   throws standardexception
execrow candidaterow   null
execrow result   null
boolean restrict   false
datavaluedescriptor restrictboolean
if  sanitymanager debug
sanitymanager assert isopen
/* nothing to do if we're not currently on a row */
if  currentrow    null
return null
/* call the child result set to get it's current row.
* if no row exists, then return null, else requalify it
* before returning.
*/
candidaterow     cursorresultset  source  getcurrentrow
if  candidaterow    null
setcurrentrow candidaterow
/* if restriction is null, then all rows qualify */
restrictboolean    datavaluedescriptor
restriction    null  ? null   restriction invoke activation
// if the result is null, we make it false --
// so the row won't be returned.
restrict    restrictboolean    null
restrictboolean isnull
restrictboolean getboolean
if  candidaterow    null    restrict
result   doprojection candidaterow
currentrow   result
/* clear the current row, if null */
if  result    null
clearcurrentrow
return currentrow
/**
* do the projection against the source row.  use reflection
* where necessary, otherwise get the source column into our
* result row.
*
* @param sourcerow		the source row.
*
* @return		the result of the projection
*
* @exception standardexception thrown on failure.
*/
private execrow doprojection execrow sourcerow
throws standardexception
// no need to use reflection if reusing the result
if  reuseresult    projrow    null
/* make sure we reset the current row based on the re-used
* result.  otherwise, if the "current row" for this result
* set was nulled out in a previous call to getnextrow(),
* which can happen if this node is the right-side of
* a left outer join, the "current row" stored for this
* result set in activation.row would remain null, which
* would be wrong. derby-3538.
*/
setcurrentrow projrow
return projrow
execrow result
// use reflection to do as much of projection as required
if  projection    null
result    execrow  projection invoke activation
else
result   mappedresultrow
// copy any mapped columns from the source
for  int index   0  index < projectmapping length  index
if  projectmapping     1
result setcolumn index   1  sourcerow getcolumn projectmapping
/* we need to reset the current row after doing the projection */
setcurrentrow result
/* remember the result if reusing it */
if  reuseresult
projrow   result
return result
/**
* do the projection against the sourcerow. if the source of the result set
* is of type projectrestrictresultset, the projection by that result set
* will also be performed.
*
* @param sourcerow row to be projected
*
* @return the result of the projection
*
* @exception standardexception thrown on failure.
*/
public execrow dobaserowprojection execrow sourcerow
throws standardexception
final execrow result
if  source instanceof projectrestrictresultset
projectrestrictresultset prs    projectrestrictresultset  source
result   prs dobaserowprojection sourcerow
else
result   sourcerow getnewnullrow
result setrowarray sourcerow getrowarray
return doprojection result
/**
* get projection mapping array. the array consist of indexes which
* maps the column in a row array to another position in the row array.
* if the value is projected out of the row, the value is negative.
* @return projection mapping array.
*/
public int getbaseprojectmapping
final int result
if  source instanceof projectrestrictresultset
result   new int
final projectrestrictresultset prs    projectrestrictresultset  source
final int sourcemap   prs getbaseprojectmapping
for  int i 0  i<projectmapping length  i
if  projectmapping > 0
result   sourcemap   1]
else
result   projectmapping
return result
/**
* is this resultset or it's source result set for update
*
* @return whether or not the result set is for update.
*/
public boolean isforupdate
return source isforupdate
/**
* @see noputresultset#updaterow
*/
public void updaterow  execrow row  throws standardexception
source updaterow row
/**
* @see noputresultset#markrowasdeleted
*/
public void markrowasdeleted   throws standardexception
source markrowasdeleted