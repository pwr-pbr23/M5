/*
derby - class org.apache.derby.iapi.sql.dictionary.constraintdescriptor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import org apache derby iapi error standardexception
import org apache derby iapi sql depend provider
import org apache derby iapi sql depend dependent
import org apache derby catalog uuid
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby catalog dependablefinder
import org apache derby catalog dependable
import org apache derby iapi services io storedformatids
import org apache derby iapi sql depend dependencymanager
import	org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi store access transactioncontroller
/**
* this class is used to get information from a constraintdescriptor.
* a constraintdescriptor can represent a constraint on a table or on a
* column.
*
* @version 0.1
*/
public abstract class constraintdescriptor
extends tupledescriptor
implements uniquetupledescriptor  provider  dependent
// used to indicate what type of constraints we
// are interested in
public static final int enabled		  1
public static final int disabled	  2
public static final int all			  3
// field that we want users to be able to know about
public static final int sysconstraints_state_field   6
tabledescriptor		table
final string				constraintname
private final boolean				deferrable
private final boolean				initiallydeferred
boolean				isenabled
private final int				referencedcolumns
final uuid					constraintid
private final schemadescriptor	schemadesc
private columndescriptorlist	coldl
/**
* constructor for a constraintdescriptor
*
* @param datadictionary		the data dictionary that this descriptor lives in
* @param table		the descriptor of the table the constraint is on
* @param constraintname	the name of the constraint.
* @param deferrable		if the constraint can be deferred.
* @param initiallydeferred if the constraint starts life deferred.
* @param referencedcolumns columns that the constraint references
* @param constraintid		uuid of constraint
* @param schemadesc		schemadescriptor
*/
constraintdescriptor
datadictionary datadictionary
tabledescriptor table
string constraintname
boolean deferrable
boolean initiallydeferred
int referencedcolumns
uuid constraintid
schemadescriptor schemadesc
boolean isenabled
super  datadictionary
this table   table
this constraintname   constraintname
this deferrable   deferrable
this initiallydeferred   initiallydeferred
this referencedcolumns   referencedcolumns
this constraintid   constraintid
this schemadesc   schemadesc
this isenabled   isenabled
/**
* gets the uuid of the table the constraint is on.
*
* @return	the uuid of the table the constraint is on.
*/
public uuid	gettableid
return table getuuid
/**
* gets the uuid of the constraint.
*
* @return	the uuid of the constraint.
*/
public uuid	getuuid
return constraintid
/**
* gets the name of the constraint.
*
* @return	a string containing the name of the constraint.
*/
public string	getconstraintname
return constraintname
/**
* gets an identifier telling what type of descriptor it is
* (unique, primary key, foreign key, check).
*
* @return	an identifier telling what type of descriptor it is
*		(unique, primary key, foreign key, check).
*/
public abstract int	getconstrainttype
public abstract uuid getconglomerateid
/**
* get the text of the constraint. (only non-null/meaningful for check
* constraints.)
* @return	the constraint text.
*/
public string getconstrainttext
return null
/**
* returns true if the constraint is deferrable
* (we will probably not do deferrable constraints in the
* initial release, but i want this to be part of the interface).
*
* @return	true if the constraint is deferrable, false if not
*/
public boolean	deferrable
return deferrable
/**
* returns true if the constraint is initially deferred
* (we will probably not do initially deferred constraints
* in the initial release, but i want this to be part of the interface).
*
* @return	true if the constraint is initially deferred,
*		false if not
*/
public boolean	initiallydeferred
return initiallydeferred
/**
* returns an array of column ids (i.e. ordinal positions) for
* the columns referenced in this table for a primary key, unique
* key, referential, or check constraint.
*
* @return	an array of column ids for those constraints that can
*		be on columns (primary, unique key, referential
*		constraints, and check constraints).  for check and
*		unique constraints, it returns an array of columns ids
*		that are referenced in the constraint.  for primary key
*		and referential constraints, it returns an array of
*		column ids for the columns in this table (i.e. the
*		primary key columns for a primary key constraint,
*		and the foreign key columns for a foreign key
*		constraint.
*/
public int	getreferencedcolumns
return referencedcolumns
/**
* does this constraint have a backing index?
*
* @return boolean	whether or not there is a backing index for this constraint.
*/
public abstract boolean hasbackingindex
/**
* get the schemadescriptor for the schema that this constraint
* belongs to.
*
* @return schemadescriptor the schemadescriptor for this constraint.
*/
public schemadescriptor getschemadescriptor
return schemadesc
/**
resolve: for now the constraintdescriptor code stores the array of key
columns in the field 'othercolumns'. jerry plans to re-organize things.
for now to minimize his rototill i've implemented this function on the
old structures. all new code should use getkeycolumns to get a constraint's
key columns.
@see org.apache.derby.iapi.sql.dictionary.keyconstraintdescriptor#getkeycolumns
*/
public int	getkeycolumns
return getreferencedcolumns
/**
* is this constraint active?
*
* @return true/false
*/
public boolean isenabled
return isenabled
/**
* set the constraint to enabled.
* does not update the data dictionary
*/
public void setenabled
isenabled   true
/**
* set the constraint to disabled.
* does not update the data dictionary
*/
public void setdisabled
isenabled   false
/**
* is this constraint referenced?  return
* false.  overridden by referencedkeyconstraints.
*
* @return false
*/
public boolean isreferenced
return false
/**
* get the number of enabled fks that
* reference this key.  overriden by
* referencedkeyconstraints.
*
* @return the number of fks
*/
public int getreferencecount
return 0
/**
* does this constraint need to fire on this type of
* dml?
*
* @param stmttype	the type of dml
* (statementtype.insert|statementtype.update|statementtype.delete)
* @param modifiedcols	the columns modified, or null for all
*
* @return true/false
*/
public abstract boolean needstofire int stmttype  int modifiedcols
/**
* get the table descriptor upon which this constraint
* is declared.
*
* @return the table descriptor
*/
public tabledescriptor gettabledescriptor
return table
/**
* get the column descriptors for all the columns
* referenced by this constraint.
*
* @return the column descriptor list
*
* @exception standardexception on error
*/
public columndescriptorlist getcolumndescriptors
throws standardexception
if  coldl    null
datadictionary dd   getdatadictionary
coldl   new columndescriptorlist
int	refcols   getreferencedcolumns
for  int i   0  i < refcols length  i
coldl add table getcolumndescriptor refcols
return coldl
/**
* indicates whether the column descriptor list is
* type comparable with the constraints columns.  the
* types have to be identical and in the same order
* to succeed.
*
* @param othercolumns the columns to compare
*
* @return true/false
*
* @exception standardexception on error
*/
public boolean arecolumnscomparable columndescriptorlist othercolumns
throws standardexception
columndescriptor		mycolumn
columndescriptor		othercolumn
columndescriptorlist	mycoldl   getcolumndescriptors
/*
** check the lenghts of the lists
*/
if  othercolumns size      mycoldl size
return false
int mysize   mycoldl size
int othersize   othercolumns size
int index
for  index   0  index < mysize    index < othersize  index
mycolumn    columndescriptor  mycoldl elementat index
othercolumn    columndescriptor  othercolumns elementat index
/*
** just compare the types.  note that this will
** say a decimal(x,y) != numeric(x,y) even though
** it does.
*/
if    mycolumn gettype    isexacttypeandlengthmatch
othercolumn gettype
break
return  index    mysize    index    othersize
/**
* does a column intersect with our referenced columns
* @param columnarray columns to check
*
* note-- this is not a static method.
*/
public boolean columnintersects int columnarray
// call static method.
return docolumnsintersect getreferencedcolumns    columnarray
/**
* does a column in the input set intersect with
* our referenced columns?
*
* @param othercolumns the columns to compare. if
*	null, asssumed to mean all columns
*
* @param referencedcolumns the columns referenced by the caller
*
* @return true/false
*/
static boolean docolumnsintersect int othercolumns  int referencedcolumns
/*
** it is assumed that if othercolumns is null, then
** all other columns are modified.  in this case,
** it is assumed that it intersects with some column
** of ours, so just return true.
*/
if   othercolumns    null      referencedcolumns    null
return true
for  int outer   0  outer < referencedcolumns length  outer
for  int inner   0  inner < othercolumns length  inner
if  referencedcolumns    othercolumns
return true
return false
/**
* convert the columndescriptor to a string.
*
* @return	a string representation of this columndescriptor
*/
public string	tostring
if  sanitymanager debug
string tabledesc
table getqualifiedname
table getuuid
table gettabletype
return tabledesc
constraintname
constraintid
deferrable
initiallydeferred
referencedcolumns
schemadesc
else
return
////////////////////////////////////////////////////////////////////
//
// provider interface
//
////////////////////////////////////////////////////////////////////
/**
@return the stored form of this provider
@see dependable#getdependablefinder
*/
public dependablefinder getdependablefinder
return	getdependablefinder storedformatids constraint_descriptor_finder_v01_id
/**
* return the name of this provider.  (useful for errors.)
*
* @return string	the name of this provider.
*/
public string getobjectname
return constraintname
/**
* get the provider's uuid
*
* @return 	the provider's uuid
*/
public uuid getobjectid
return constraintid
/**
* get the provider's type.
*
* @return char		the provider's type.
*/
public string getclasstype
return dependable constraint
//////////////////////////////////////////////////////
//
// dependent interface
//
//////////////////////////////////////////////////////
/**
* check that all of the dependent's dependencies are valid.
*
* @return true if the dependent is currently valid
*/
public synchronized boolean isvalid
return true
/**
* prepare to mark the dependent as invalid (due to at least one of
* its dependencies being invalid).
*
* @param action	the action causing the invalidation
* @param p		the provider
*
* @exception standardexception thrown if unable to make it invalid
*/
public void preparetoinvalidate provider p  int action
languageconnectioncontext lcc
throws standardexception
dependencymanager dm   getdatadictionary   getdependencymanager
switch  action
/*
** a set constraint stmt will throw an set_constraints action
** when enabling/disabling constraints.  we'll ignore it.
** same for set triggers
*/
case dependencymanager set_constraints_enable
case dependencymanager set_constraints_disable
case dependencymanager set_triggers_enable
case dependencymanager set_triggers_disable
//when revoke_privilege gets sent (this happens for privilege
//types select, update, delete, insert, references, trigger), we
//don't do anything here. later in makeinvalid method, we make
//the constraintdescriptor drop itself.
//ditto for role grant conferring a privilege.
case dependencymanager revoke_privilege
case dependencymanager revoke_role
case dependencymanager internal_recompile_request
// only used by activations
case dependencymanager recheck_privileges
break
/*
** currently, the only thing we are depenedent
** on is another constraint or an alias..
*/
//notice that revoke_privilege_restrict is not caught earlier.
//it gets handled in this default: action where an exception
//will be thrown. this is because, if such an invalidation
//action type is ever received by a dependent, the dependent
//should throw an exception.
//in derby, at this point, revoke_privilege_restrict gets sent
//when execute privilege on a routine is getting revoked.
//currently, in derby, a constraint can't depend on a routine
//and hence a revoke_privilege_restrict invalidation action
//should never be received by a constraintdescriptor. but this
//may change in future and when it does, the code to do the right
//thing is already here.
default
throw standardexception newexception sqlstate lang_provider_has_dependent_object
dm getactionstring action
p getobjectname       constraintname
/**
* mark the dependent as invalid (due to at least one of
* its dependencies being invalid).  always an error
* for a constraint -- should never have gotten here.
*
* @param	action	the action causing the invalidation
*
* @exception standardexception thrown if called in sanity mode
*/
public void makeinvalid int action  languageconnectioncontext lcc
throws standardexception
/*
** for constraintdescriptor, set_constraints/triggers and
*  revoke_privilege are the only valid actions
*/
//let's handle revoke_privilege and revoke_role first
if  action    dependencymanager revoke_privilege
action    dependencymanager revoke_role
//at this point (derby 10.2), only a foreign key key constraint can
//depend on a privilege. none of the other constraint types
//can be dependent on a privilege becuse those constraint types
//can not reference a table/routine.
conglomeratedescriptor newbackingconglomcd   drop lcc  true
lcc getlastactivation   addwarning
standardexception newwarning
sqlstate lang_constraint_dropped
getconstraintname
gettabledescriptor   getname
if  newbackingconglomcd    null
/* since foreign keys can never be unique, and since
* we only (currently) share conglomerates if two
* constraints/indexes have identical columns, dropping
* a foreign key should not necessitate the creation of
* another physical conglomerate.  that will change if
* derby-2204 is implemented, but for now we don't expect
* it to happen...
*/
if  sanitymanager debug
sanitymanager throwassert
return
/*
** now, handle set_constraints/triggers
*/
if   action    dependencymanager set_constraints_disable
action    dependencymanager set_constraints_enable
action    dependencymanager set_triggers_enable
action    dependencymanager set_triggers_disable
action    dependencymanager internal_recompile_request
action    dependencymanager recheck_privileges
/*
** we should never get here, we should have barfed on
** preparetoinvalidate().
*/
if  sanitymanager debug
dependencymanager dm
dm   getdatadictionary   getdependencymanager
sanitymanager throwassert
dm getactionstring action
/**
* drop the constraint.  clears dependencies, drops
* the backing index and removes the constraint
* from the list on the table descriptor.  does not
* do an dm.invalidatefor()
*
* @return if the backing conglomerate for this constraint
*  was a) dropped and b) shared by other constraints/indexes,
*  then this method will return a conglomeratedescriptor that
*  describes what a new backing conglomerate must look like
*  to stay "sharable" across the remaining constraints/indexes.
*  it is then up to the caller to create a corresponding
*  conglomerate.  we don't create the conglomerate here
*  because depending on who called us, it might not make
*  sense to create it--ex. if we get here because of a drop
*  table, the droptable action doesn't need to create a
*  new backing conglomerate since the table (and all of
*  its constraints/indexes) are going to disappear anyway.
*/
public conglomeratedescriptor drop languageconnectioncontext lcc
boolean cleardependencies  throws standardexception
datadictionary dd   getdatadictionary
dependencymanager dm   dd getdependencymanager
transactioncontroller tc   lcc gettransactionexecute
if  cleardependencies
dm cleardependencies lcc  this
/* drop the constraint.
* note: this must occur before dropping any backing index, since
* a user is not allowed to drop a backing index without dropping
* the constraint.
*/
dd dropconstraintdescriptor this  tc
/* drop the index, if there's one for this constraint.
* note: there will always be an indexaction. we don't
* force the constraint to exist at bind time, so we always
* generate one.
*/
conglomeratedescriptor newbackingconglomcd   null
if  hasbackingindex
// it may have duplicates, and we drop a backing index
// bug 4307
// we need to get the conglomerate descriptors from the
// dd in case we dropped other constraints in a cascade operation.
conglomeratedescriptorconglomdescs
dd getconglomeratedescriptors getconglomerateid
if  conglomdescs length    0
// typically there is only one conglomeratedescriptor
// for a given uuid, but due to an old bug
// there may be more than one. if there is more
// than one then which one is remvoed does not
// matter since they will all have the same critical
// information since they point to the same physical index.
for  int i   0  i < conglomdescs length  i
if  conglomdescs isconstraint
newbackingconglomcd   conglomdescs drop lcc  table
break
table removeconstraintdescriptor this
return newbackingconglomcd
/** @see tupledescriptor#getdescriptorname */
public string getdescriptorname     return constraintname
public string getdescriptortype     return