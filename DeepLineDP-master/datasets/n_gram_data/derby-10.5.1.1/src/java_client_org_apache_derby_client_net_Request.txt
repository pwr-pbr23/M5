/*
derby - class org.apache.derby.client.net.request
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client net
import org apache derby client am disconnectexception
import org apache derby client am encryptionmanager
import org apache derby client am clientmessageid
import org apache derby client am sqlexception
import org apache derby client am utils
import org apache derby shared common reference sqlstate
import java io bufferedinputstream
import java io unsupportedencodingexception
import java io ioexception
public class request
// byte array buffer used for constructing requests.
// currently requests are built starting at the beginning of the buffer.
protected byte bytes_
// keeps track of the next position to place a byte in the buffer.
// so the last valid byte in the message is at bytes_[offset - 1]
protected int offset_
// a stack is used to keep track of offsets into the buffer where 2 byte
// ddm length values are located.  these length bytes will be automatically updated
// by this object when construction of a particular object has completed.
// right now the max size of the stack is 10. this is an arbitrary number which
// should be sufficiently large enough to handle all situations.
private final static int max_marks_nesting   10
private int markstack_   new int
private int top_   0
// the ccsid manager for the connection is stored in this object.  it will
// be used when constructing character ddm data.  it will not be used for
// building any fdoca data.
protected ccsidmanager ccsidmanager_
//  this object tracks the location of the current
//  dss header length bytes.  this is done so
//  the length bytes can be automatically
//  updated as information is added to this stream.
private int dsslengthlocation_   0
// tracks the request correlation id to use for commands and command objects.
// this is automatically updated as commands are built and sent to the server.
private int correlationid_   0
private boolean simpledssfinalize   false
// used to mask out password when trace is on.
protected boolean passwordincluded_   false
protected int passwordstart_   0
protected int passwordlength_   0
protected netagent netagent_
// construct a request object specifying the minimum buffer size
// to be used to buffer up the built requests.  also specify the ccsid manager
// instance to be used when building ddm character data.
request netagent netagent  int minsize  ccsidmanager ccsidmanager
netagent_   netagent
bytes_   new byte
ccsidmanager_   ccsidmanager
clearbuffer
// construct a request object specifying the ccsid manager instance
// to be used when building ddm character data.  this will also create
// a buffer using the default size (see final static default_buffer_size value).
request netagent netagent  ccsidmanager ccsidmanager  int buffersize
//this (netagent, request.default_buffer_size, ccsidmanager);
this netagent  buffersize  ccsidmanager
protected final void clearbuffer
offset_   0
top_   0
for  int i   0  i < markstack_ length  i
if  markstack_    0
markstack_   0
else
break
dsslengthlocation_   0
final void initialize
clearbuffer
correlationid_   0
// set the ccsid manager value.  this method allows the ccsid manager to be
// changed so a request object can be reused by different connections with
// different ccsid managers.
final void setccsidmgr ccsidmanager ccsidmanager
ccsidmanager_   ccsidmanager
// ensure length at the end of the buffer for a certain amount of data.
// if the buffer does not contain sufficient room for the data, the buffer
// will be expanded by the larger of (2 * current size) or (current size + length).
// the data from the previous buffer is copied into the larger buffer.
protected final void ensurelength int length
if  length > bytes_ length
byte newbytes   new byte
system arraycopy bytes_  0  newbytes  0  offset_
bytes_   newbytes
// creates an request dss in the buffer to contain a ddm command
// object.  calling this method means any previous dss objects in
// the buffer are complete and their length and chaining bytes can
// be updated appropriately.
protected final void createcommand
builddss false  false  false  dssconstants gdsfmt_rqsdss    correlationid_  false
// creates an request dss in the buffer to contain a ddm command
// object.  calling this method means any previous dss objects in
// the buffer are complete and their length and chaining bytes can
// be updated appropriately.
protected void createxacommand
builddss false  false  false  dssconstants gdsfmt_rqsdss_noreply    correlationid_  false
// creates an object dss in the buffer to contain a ddm command
// data object.  calling this method means any previous dss objects in
// the buffer are complete and their length and chaining bytes can
// be updated appropriately.
final void createcommanddata
builddss true
false
false
dssconstants gdsfmt_objdss
correlationid_
false
final void createencryptedcommanddata
if  netagent_ netconnection_ getsecuritymechanism      netconfiguration secmec_eusriddta
netagent_ netconnection_ getsecuritymechanism      netconfiguration secmec_eusrpwddta
builddss true  false  false  dssconstants gdsfmt_encobjdss  correlationid_  false
else
builddss true
false
false
dssconstants gdsfmt_objdss
correlationid_
false
// experimental lob section
private final void builddss boolean dsshassamecorrelator
boolean chainedtonextstructure
boolean nexthassamecorrelator
int dsstype
int corrid
boolean simplefinalizebuildingnextdss
if  doesrequestcontaindata
if  simpledssfinalize
finalizedsslength
else
finalizepreviouschaineddss dsshassamecorrelator
// rqsdss header is 6 bytes long: (ll)(cf)(rc)
ensurelength offset_   6
// save the position of the length bytes, so they can be updated with a
// different value at a later time.
dsslengthlocation_   offset_
// dummy values for the dss length (token ll above).
// the correct length will be inserted when the dss is finalized.
bytes_    byte  0xff
bytes_    byte  0xff
// insert the mandatory 0xd0 (token c).
bytes_    byte  0xd0
// insert the dsstype (token f), which also tells if the dss is chained
// or not. see dssfmt in the drda specification for details.
if  chainedtonextstructure
dsstype    dssconstants gdschain
if  nexthassamecorrelator
dsstype    dssconstants gdschain_same_id
bytes_    byte   dsstype   0xff
// write the request correlation id (two bytes, token rc).
// use method that writes a short
bytes_    byte    corrid >>> 8    0xff
bytes_    byte   corrid   0xff
simpledssfinalize   simplefinalizebuildingnextdss
final void writescalarstream boolean chained
boolean chainedwithsamecorrelator
int codepoint
java io inputstream in
boolean writenullbyte
int parameterindex  throws disconnectexception  sqlexception
writeplainscalarstream chained
chainedwithsamecorrelator
codepoint
in
writenullbyte
parameterindex
final void writescalarstream boolean chained
boolean chainedwithsamecorrelator
int codepoint
int length
java io inputstream in
boolean writenullbyte
int parameterindex  throws disconnectexception  sqlexception
if  netagent_ netconnection_ getsecuritymechanism      netconfiguration secmec_eusriddta
netagent_ netconnection_ getsecuritymechanism      netconfiguration secmec_eusrpwddta
writeencryptedscalarstream chained
chainedwithsamecorrelator
codepoint
length
in
writenullbyte
parameterindex
else
writeplainscalarstream chained
chainedwithsamecorrelator
codepoint
length
in
writenullbyte
parameterindex
// we need to reuse the agent's sql exception accumulation mechanism
// for this write exception, pad if the length is too big, and truncation if the length is too small
final private void writeencryptedscalarstream boolean chained
boolean chainedwithsamecorrelator
int codepoint
int length
java io inputstream in
boolean writenullbyte
int parameterindex  throws disconnectexception  sqlexception
int lefttoread   length
int extendedlengthbytecount   prepscalarstream chained
chainedwithsamecorrelator
writenullbyte
lefttoread
int bytestoread
if  writenullbyte
bytestoread   utils min lefttoread  dssconstants max_dss_len   6   4   1   extendedlengthbytecount
else
bytestoread   utils min lefttoread  dssconstants max_dss_len   6   4   extendedlengthbytecount
byte lengthandcodepoint
lengthandcodepoint   buildlengthandcodepointforencryptedlob codepoint
lefttoread
writenullbyte
extendedlengthbytecount
// we need to stream the input, rather than fully materialize it
// write the data
byte clearedbytes   new byte
int bytesread   0
int totalbytesread   0
int pos   0
do
try
bytesread   in read clearedbytes  pos  lefttoread
totalbytesread    bytesread
catch  java io ioexception e
padscalarstreamforerror lefttoread  bytestoread
// set with sqlstate 01004: the value of a string was truncated when assigned to a host variable.
netagent_ accumulatereadexception new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_ioexception_on_read
new integer parameterindex   e getmessage    e
return
if  bytesread     1
//padscalarstreamforerror(lefttoread, bytestoread);
// set with sqlstate 01004: the value of a string was truncated when assigned to a host variable.
/*throw new sqlexception(netagent_.logwriter_,
"end of stream prematurely reached while reading inputstream, parameter #" +
parameterindex +
".  remaining data has been padded with 0x0.");*/
//is it ok to do a chain break exception here. it's not good to
//pad it with 0 and encrypt and send it to the server because it takes too much time
//can't just throw a sqlexception either because some of the data prpsqlstt etc have already
//been sent to the server, and server is waiting for extdta, server hangs for this.
netagent_ accumulatechainbreakingreadexceptionandthrow
new disconnectexception netagent_
new clientmessageid sqlstate net_premature_eos_disconnect
new integer parameterindex
return
/*netagent_.accumulatereadexception(
new sqlexception(netagent_.logwriter_,
"end of stream prematurely reached while reading inputstream, parameter #" +
parameterindex +
".  remaining data has been padded with 0x0."));
return;*/
else
pos    bytesread
//offset_ += bytesread;  //comment this out for data stream encryption.
lefttoread    bytesread
while  lefttoread > 0
// check to make sure that the specified length wasn't too small
try
if  in read       1
// set with sqlstate 01004: the value of a string was truncated when assigned to a host variable.
netagent_ accumulatereadexception new sqlexception
netagent_ logwriter_
new clientmessageid sqlstate net_inputstream_length_too_small
new integer parameterindex
catch  java io ioexception e
netagent_ accumulatereadexception new sqlexception
netagent_ logwriter_
new clientmessageid
sqlstate net_ioexception_on_streamlen_verification
new integer parameterindex
e getmessage
e
byte newclearedbytes   new byte[clearedbytes length
lengthandcodepoint length]
system arraycopy lengthandcodepoint  0  newclearedbytes  0
lengthandcodepoint length
system arraycopy clearedbytes  0  newclearedbytes  lengthandcodepoint length  clearedbytes length
//it's wrong here, need to add in the real length after the codepoing 146c
byte encryptedbytes
encryptedbytes   netagent_ netconnection_ getencryptionmanager
encryptdata newclearedbytes
netconfiguration secmec_eusridpwd
netagent_ netconnection_ gettargetpublickey
netagent_ netconnection_ gettargetpublickey
int encryptedbyteslength   encryptedbytes length
int sendinglength   bytes_ length   offset_
if  encryptedbyteslength >  bytes_ length   offset_
system arraycopy encryptedbytes  0  bytes_  offset_   bytes_ length   offset_
offset_   32767
try
sendbytes netagent_ getoutputstream
catch  java io ioexception ioe
netagent_ throwcommunicationsfailure ioe
else
system arraycopy encryptedbytes  0  bytes_  offset_  encryptedbyteslength
offset_   offset_   encryptedbytes length
encryptedbyteslength   encryptedbyteslength   sendinglength
while  encryptedbyteslength > 0
//dsslengthlocation_ = offset_;
offset_   0
if   encryptedbyteslength   32765  > 0
bytes_    byte   0xff
bytes_    byte   0xff
system arraycopy encryptedbytes  sendinglength  bytes_  offset_  32765
encryptedbyteslength    32765
sendinglength    32765
offset_   32767
try
sendbytes netagent_ getoutputstream
catch  java io ioexception ioe
netagent_ throwcommunicationsfailure ioe
else
int leftlength   encryptedbyteslength   2
bytes_    byte    leftlength >>> 8    0xff
bytes_    byte   leftlength   0xff
system arraycopy encryptedbytes  sendinglength  bytes_  offset_  encryptedbyteslength
offset_    encryptedbyteslength
dsslengthlocation_   offset_
encryptedbyteslength   0
// we need to reuse the agent's sql exception accumulation mechanism
// for this write exception, pad if the length is too big, and truncation if the length is too small
final private void writeplainscalarstream boolean chained
boolean chainedwithsamecorrelator
int codepoint
int length
java io inputstream in
boolean writenullbyte
int parameterindex  throws disconnectexception  sqlexception
int lefttoread   length
int extendedlengthbytecount   prepscalarstream chained
chainedwithsamecorrelator
writenullbyte
lefttoread
int bytestoread
if  writenullbyte
bytestoread   utils min lefttoread  dssconstants max_dss_len   6   4   1   extendedlengthbytecount
else
bytestoread   utils min lefttoread  dssconstants max_dss_len   6   4   extendedlengthbytecount
buildlengthandcodepointforlob codepoint
lefttoread
writenullbyte
extendedlengthbytecount
int bytesread   0
int totalbytesread   0
do
do
try
bytesread   in read bytes_  offset_  bytestoread
totalbytesread    bytesread
catch  java io ioexception e
padscalarstreamforerror lefttoread  bytestoread
// set with sqlstate 01004: the value of a string was truncated when assigned to a host variable.
netagent_ accumulatereadexception new sqlexception
netagent_ logwriter_
new clientmessageid sqlstate net_ioexception_on_read
new integer parameterindex
e getmessage
e
return
if  bytesread     1
padscalarstreamforerror lefttoread  bytestoread
// set with sqlstate 01004: the value of a string was truncated when assigned to a host variable.
netagent_ accumulatereadexception new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_premature_eos
new integer parameterindex
return
else
bytestoread    bytesread
offset_    bytesread
lefttoread    bytesread
while  bytestoread > 0
bytestoread   flushscalarstreamsegment lefttoread  bytestoread
while  lefttoread > 0
// check to make sure that the specified length wasn't too small
try
if  in read       1
// set with sqlstate 01004: the value of a string was truncated when assigned to a host variable.
netagent_ accumulatereadexception new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_inputstream_length_too_small
new integer parameterindex
catch  java io ioexception e
netagent_ accumulatereadexception new sqlexception
netagent_ logwriter_
new clientmessageid
sqlstate net_ioexception_on_streamlen_verification
new integer parameterindex
e getmessage
e
// we need to reuse the agent's sql exception accumulation mechanism
// for this write exception, pad if the length is too big, and truncation if the length is too small
final private void writeplainscalarstream boolean chained
boolean chainedwithsamecorrelator
int codepoint
java io inputstream in
boolean writenullbyte
int parameterindex  throws disconnectexception  sqlexception
in   new bufferedinputstream  in
flushexistingdss
ensurelength  dssconstants max_dss_len
builddss true
chained
chainedwithsamecorrelator
dssconstants gdsfmt_objdss
correlationid_
true
int spareindss
if  writenullbyte
spareindss   dssconstants max_dss_len   6   4   1
else
spareindss   dssconstants max_dss_len   6   4
buildlengthandcodepointforlob codepoint
writenullbyte
try
int bytesread   0
while    bytesread
in read bytes_  offset_  spareindss
>  1
spareindss    bytesread
offset_    bytesread
if  spareindss <  0
if    peekstream     bufferedinputstream   in
break
flushscalarstreamsegment
bytes_    byte   0xff
bytes_    byte   0xff
spareindss   dssconstants max_dss_len   2
catch  java io ioexception e
final sqlexception sqlex
new sqlexception(netagent_.logwriter_,
new clientmessageid sqlstate net_ioexception_on_read
new integer parameterindex
e getmessage
e
netagent_ accumulatereadexception sqlex
return
// check to make sure that the specified length wasn't too small
try
if  in read       1
// set with sqlstate 01004: the value of a string was truncated when assigned to a host variable.
final sqlexception sqlex
new sqlexception(netagent_.logwriter_,
new clientmessageid sqlstate net_inputstream_length_too_small
new integer parameterindex
netagent_ accumulatereadexception sqlex
catch  java io ioexception e
netagent_ accumulatereadexception new sqlexception
netagent_ logwriter_
new clientmessageid
sqlstate net_ioexception_on_streamlen_verification
new integer parameterindex
e getmessage
e
// throw datatruncation, instead of closing connection if input size mismatches
// an implication of this, is that we need to extend the chaining model
// for writes to accomodate chained write exceptoins
final void writescalarstream boolean chained
boolean chainedwithsamecorrelator
int codepoint
int length
java io reader r
boolean writenullbyte
int parameterindex  throws disconnectexception
sqlexception
writescalarstream chained
chainedwithsamecorrelator
codepoint
length   2
encodedinputstream createutf16bestream r
writenullbyte
parameterindex
final void writescalarstream boolean chained
boolean chainedwithsamecorrelator
int codepoint
java io reader r
boolean writenullbyte
int parameterindex  throws disconnectexception
sqlexception
writescalarstream chained
chainedwithsamecorrelator
codepoint
encodedinputstream createutf16bestream r
writenullbyte
parameterindex
// prepscalarstream does the following prep for writing stream data:
// 1.  flushes an existing dss segment, if necessary
// 2.  determines if extended length bytes are needed
// 3.  creates a new dss/ddm header and a null byte indicator, if applicable
protected final int prepscalarstream boolean chained
boolean chainedwithsamecorrelator
boolean writenullbyte
int lefttoread  throws disconnectexception
int extendedlengthbytecount
int nullindicatorsize   0
if  writenullbyte
// lefttoread is cast to (long) on the off chance that +4+1 pushes it outside the range of int
extendedlengthbytecount   calculateextendedlengthbytecount  long  lefttoread   4   1
nullindicatorsize   1
else
extendedlengthbytecount   calculateextendedlengthbytecount lefttoread   4
// flush the existing dss segment if this stream will not fit in the send buffer
// lefttoread is cast to (long) on the off chance that +4+1 pushes it outside the range of int
if  10   extendedlengthbytecount   nullindicatorsize    long  lefttoread   offset_ > dssconstants max_dss_len
try
if  simpledssfinalize
finalizedsslength
else
finalizepreviouschaineddss true
sendbytes netagent_ getoutputstream
catch  java io ioexception e
netagent_ throwcommunicationsfailure e
if  netagent_ netconnection_ getsecuritymechanism      netconfiguration secmec_eusriddta
netagent_ netconnection_ getsecuritymechanism      netconfiguration secmec_eusrpwddta
builddss true
chained
chainedwithsamecorrelator
dssconstants gdsfmt_encobjdss
correlationid_
true
else
// builddss should not call ensure length.
builddss true
chained
chainedwithsamecorrelator
dssconstants gdsfmt_objdss
correlationid_
true
return extendedlengthbytecount
protected final void flushexistingdss   throws disconnectexception
try
if  simpledssfinalize
finalizedsslength
else
finalizepreviouschaineddss true
sendbytes netagent_ getoutputstream
catch  java io ioexception e
netagent_ throwcommunicationsfailure e
// writes out a scalar stream dss segment, along with dss continuation headers,
// if necessary.
protected final int flushscalarstreamsegment int lefttoread
int bytestoread  throws disconnectexception
int newbytestoread   bytestoread
// either at end of data, end of dss segment, or both.
if  lefttoread    0
// 32k segment filled and not at end of data.
if   utils min 2   lefttoread  32767   >  bytes_ length   offset_
try
sendbytes netagent_ getoutputstream
catch  java io ioexception ioe
netagent_ throwcommunicationsfailure ioe
dsslengthlocation_   offset_
bytes_    byte   0xff
bytes_    byte   0xff
newbytestoread   utils min lefttoread  32765
return newbytestoread
protected final int flushscalarstreamsegment   throws disconnectexception
try
sendbytes netagent_ getoutputstream
catch  java io ioexception ioe
netagent_ throwcommunicationsfailure ioe
dsslengthlocation_   offset_
return dssconstants max_dss_len
// the offset_ must not be updated when an error is encountered
// note valid data may be overwritten
protected final void padscalarstreamforerror int lefttoread  int bytestoread  throws disconnectexception
do
do
bytes_    byte   0x0      use 0x0 as the padding byte
bytestoread
lefttoread
while  bytestoread > 0
bytestoread   flushscalarstreamsegment lefttoread  bytestoread
while  lefttoread > 0
private final void writeextendedlengthbytes int extendedlengthbytecount  long length
int shiftsize    extendedlengthbytecount   1    8
for  int i   0  i < extendedlengthbytecount  i
bytes_    byte    length >>> shiftsize    0xff
shiftsize    8
private final byte writeextendedlengthbytesforencryption int extendedlengthbytecount  long length
int shiftsize    extendedlengthbytecount   1    8
byte extendedlengthbytes   new byte
for  int i   0  i < extendedlengthbytecount  i
extendedlengthbytes    byte    length >>> shiftsize    0xff
shiftsize    8
return extendedlengthbytes
// experimental lob section - end
// used to finialize a dss which is already in the buffer
// before another dss is built.  this includes updating length
// bytes and chaining bits.
protected final void finalizepreviouschaineddss boolean dsshassamecorrelator
finalizedsslength
bytes_    0x40
if  dsshassamecorrelator     for blobs
bytes_    0x10
// method to determine if any data is in the request.
// this indicates there is a dss object already in the buffer.
protected final boolean doesrequestcontaindata
return offset_    0
/**
* signal the completion of a dss layer a object.
* <p>
* the length of the dss object will be calculated based on the difference
* between the start of the dss, saved in the variable
* {@link #dsslengthlocation_}, and the current offset into the buffer which
* marks the end of the data.
* <p>
* in the event the length requires the use of continuation dss headers,
* one for each 32k chunk of data, the data will be shifted and the
* continuation headers will be inserted with the correct values as needed.
* note: in the future, we may try to optimize this approach
* in an attempt to avoid these shifts.
*/
protected final void finalizedsslength
// calculate the total size of the dss and the number of bytes which would
// require continuation dss headers.  the total length already includes the
// the 6 byte dss header located at the beginning of the dss.  it does not
// include the length of any continuation headers.
int totalsize   offset_   dsslengthlocation_
int bytesrequiringcontdssheader   totalsize   32767
// determine if continuation headers are needed
if  bytesrequiringcontdssheader > 0
// the continuation headers are needed, so calculate how many.
// after the first 32767 worth of data, a continuation header is
// needed for every 32765 bytes (32765 bytes of data + 2 bytes of
// continuation header = 32767 dss max size).
int contdssheadercount   bytesrequiringcontdssheader   32765
if  bytesrequiringcontdssheader % 32765    0
contdssheadercount
// right now the code will shift to the right.  in the future we may want
// to try something fancier to help reduce the copying (maybe keep
// space in the beginning of the buffer??).
// the offset points to the next available offset in the buffer to place
// a piece of data, so the last databyte is at offset -1.
// various bytes will need to be shifted by different amounts
// depending on how many dss headers to insert so the amount to shift
// will be calculated and adjusted as needed.  ensure there is enough room
// for all the conutinuation headers and adjust the offset to point to the
// new end of the data.
int databyte   offset_   1
int shiftoffset   contdssheadercount   2
ensurelength offset_   shiftoffset
offset_    shiftoffset
// mark passone to help with calculating the length of the final (first or
// rightmost) continuation header.
boolean passone   true
do
// calculate chunk of data to shift
int datatoshift   bytesrequiringcontdssheader % 32765
if  datatoshift    0
datatoshift   32765
// perform the shift
databyte    datatoshift
system arraycopy bytes_  databyte   1 bytes_  databyte   shiftoffset   1  datatoshift
// calculate the value the value of the 2 byte continuation dss header which
// includes the length of itself.  on the first pass, if the length is 32767
// we do not want to set the continuation dss header flag.
int twobytecontdssheader   datatoshift   2
if  passone
passone   false
else
if  twobytecontdssheader    32767
twobytecontdssheader   0xffff
// insert the header's length bytes
bytes_    byte    twobytecontdssheader >>> 8    0xff
bytes_    byte   twobytecontdssheader   0xff
// adjust the bytesrequiringcontdssheader and the amount to shift for
// data in upstream headers.
bytesrequiringcontdssheader    datatoshift
shiftoffset    2
// shift and insert another header for more data.
while  bytesrequiringcontdssheader > 0
// set the continuation dss header flag on for the first header
totalsize   0xffff
// insert the length bytes in the 6 byte dss header.
bytes_    byte    totalsize >>> 8    0xff
bytes_    byte   totalsize   0xff
// mark the location of a two byte ddm length field in the buffer,
// skip the length bytes for later update, and insert a ddm codepoint
// into the buffer.  the value of the codepoint is not checked.
// this length will be automatically updated when construction of
// the ddm object is complete (see updatelengthbytes method).
// note: this mechanism handles extended length ddms.
protected final void marklengthbytes int codepoint
ensurelength offset_   4
// save the location of length bytes in the mark stack.
mark
// skip the length bytes and insert the codepoint
offset_    2
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
// mark an offest into the buffer by placing the current offset value on
// a stack.
private final void mark
markstack_   offset_
// remove and return the top offset value from mark stack.
private final int popmark
return markstack_
protected final void markforcachingpkgnamcsn
mark
protected final int popmarkforcachingpkgnamcsn
return popmark
// called to update the last ddm length bytes marked (lengths are updated
// in the reverse order that they are marked).  it is up to the caller
// to make sure length bytes were marked before calling this method.
// if the length requires ddm extended length bytes, the data will be
// shifted as needed and the extended length bytes will be automatically
// inserted.
protected final void updatelengthbytes   throws sqlexception
// remove the top length location offset from the mark stack\
// calculate the length based on the marked location and end of data.
int lengthlocation   popmark
int length   offset_   lengthlocation
// determine if any extended length bytes are needed.  the value returned
// from calculateextendedlengthbytecount is the number of extended length
// bytes required. 0 indicates no exteneded length.
int extendedlengthbytecount   calculateextendedlengthbytecount length
if  extendedlengthbytecount    0
// ensure there is enough room in the buffer for the extended length bytes.
ensurelength offset_   extendedlengthbytecount
// calculate the length to be placed in the extended length bytes.
// this length does not include the 4 byte llcp.
int extendedlength   length   4
// shift the data to the right by the number of extended length bytes needed.
int extendedlengthlocation   lengthlocation   4
system arraycopy bytes_
extendedlengthlocation
bytes_
extendedlengthlocation   extendedlengthbytecount
extendedlength
// write the extended length
int shiftsize    extendedlengthbytecount   1    8
for  int i   0  i < extendedlengthbytecount  i
bytes_    byte    extendedlength >>> shiftsize    0xff
shiftsize    8
// adjust the offset to account for the shift and insert
offset_    extendedlengthbytecount
// the two byte length field before the codepoint contains the length
// of itself, the length of the codepoint, and the number of bytes used
// to hold the extended length.  the 2 byte length field also has the first
// bit on to indicate extended length bytes were used.
length   extendedlengthbytecount   4
length    0x8000
// write the 2 byte length field (2 bytes before codepoint).
bytes_    byte    length >>> 8    0xff
bytes_    byte   length   0xff
// helper method to calculate the minimum number of extended length bytes needed
// for a ddm.  a return value of 0 indicates no extended length needed.
private final int calculateextendedlengthbytecount long ddmsize    throws sqlexception
// according to jim and some tests perfomred on lob data,
// the extended length bytes are signed.  assume that
// if this is the case for lobs, it is the case for
// all extended length scenarios.
if  ddmsize <  0x7fff
return 0
else if  ddmsize <  0x7fffffffl
return 4
else if  ddmsize <  0x7fffffffffffl
return 6
else
return 8
// insert the padbyte into the buffer by length number of times.
final void padbytes byte padbyte  int length
ensurelength offset_   length
for  int i   0  i < length  i
bytes_   padbyte
// insert an unsigned single byte value into the buffer.
final void write1byte int value
ensurelength offset_   1
bytes_    byte   value   0xff
// insert 3 unsigned bytes into the buffer.  this was
// moved up from netstatementrequest for performance
final void buildtripletheader int tripletlength
int triplettype
int tripletid
ensurelength offset_   3
bytes_    byte   tripletlength   0xff
bytes_    byte   triplettype   0xff
bytes_    byte   tripletid   0xff
final void writelidandlengths int lidandlengthoverrides  int count  int offset
ensurelength offset_    count   3
for  int i   0  i < count  i    offset
bytes_    byte   lidandlengthoverrides   0xff
bytes_    byte    lidandlengthoverrides >>> 8    0xff
bytes_    byte   lidandlengthoverrides   0xff
// if mdd overrides are not required, lids and lengths are copied straight into the
// buffer.
// otherwise, lookup the protocoltype in the map.  if an entry exists, substitute the
// protocoltype with the corresponding override lid.
final void writelidandlengths int lidandlengthoverrides
int count
int offset
boolean mddrequired
java util hashtable map
if   mddrequired
writelidandlengths lidandlengthoverrides  count  offset
// if mdd overrides are required, lookup the protocoltype in the map, and substitute
// the protocoltype with the override lid.
else
ensurelength offset_    count   3
int protocoltype  overridelid
object entry
for  int i   0  i < count  i    offset
protocoltype   lidandlengthoverrides
// lookup the protocoltype in the protocoltype->overridelid map
// if an entry exists, replace the protocoltype with the overridelid
entry   map get new integer protocoltype
overridelid    entry    null  ? protocoltype     integer  entry  intvalue
bytes_    byte   overridelid   0xff
bytes_    byte    lidandlengthoverrides >>> 8    0xff
bytes_    byte   lidandlengthoverrides   0xff
// perf end
// insert a big endian unsigned 2 byte value into the buffer.
final void write2bytes int value
ensurelength offset_   2
bytes_    byte    value >>> 8    0xff
bytes_    byte   value   0xff
// insert a big endian unsigned 4 byte value into the buffer.
final void write4bytes long value
ensurelength offset_   4
bytes_    byte    value >>> 24    0xff
bytes_    byte    value >>> 16    0xff
bytes_    byte    value >>> 8    0xff
bytes_    byte   value   0xff
// copy length number of bytes starting at offset 0 of the byte array, buf,
// into the buffer.  it is up to the caller to make sure buf has at least length
// number of elements.  no checking will be done by this method.
final void writebytes byte buf  int length
ensurelength offset_   length
system arraycopy buf  0  bytes_  offset_  length
offset_    length
final void writebytes byte buf
ensurelength offset_   buf length
system arraycopy buf  0  bytes_  offset_  buf length
offset_    buf length
// insert a pair of unsigned 2 byte values into the buffer.
final void writecodepoint4bytes int codepoint  int value                                                            should this be writecodepoint2bytes
ensurelength offset_   4
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
bytes_    byte    value >>> 8    0xff
bytes_    byte   value   0xff
// insert a 4 byte length/codepoint pair and a 1 byte unsigned value into the buffer.
// total of 5 bytes inserted in buffer.
protected final void writescalar1byte int codepoint  int value
ensurelength offset_   5
bytes_   0x00
bytes_   0x05
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
bytes_    byte   value   0xff
// insert a 4 byte length/codepoint pair and a 2 byte unsigned value into the buffer.
// total of 6 bytes inserted in buffer.
final void writescalar2bytes int codepoint  int value
ensurelength offset_   6
bytes_   0x00
bytes_   0x06
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
bytes_    byte    value >>> 8    0xff
bytes_    byte   value   0xff
// insert a 4 byte length/codepoint pair and a 4 byte unsigned value into the
// buffer.  total of 8 bytes inserted in the buffer.
protected final void writescalar4bytes int codepoint  long value
ensurelength offset_   8
bytes_   0x00
bytes_   0x08
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
bytes_    byte    value >>> 24    0xff
bytes_    byte    value >>> 16    0xff
bytes_    byte    value >>> 8    0xff
bytes_    byte   value   0xff
// insert a 4 byte length/codepoint pair and a 8 byte unsigned value into the
// buffer.  total of 12 bytes inserted in the buffer.
final void writescalar8bytes int codepoint  long value
ensurelength offset_   12
bytes_   0x00
bytes_   0x0c
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
bytes_    byte    value >>> 56    0xff
bytes_    byte    value >>> 48    0xff
bytes_    byte    value >>> 40    0xff
bytes_    byte    value >>> 32    0xff
bytes_    byte    value >>> 24    0xff
bytes_    byte    value >>> 16    0xff
bytes_    byte    value >>> 8    0xff
bytes_    byte   value   0xff
// insert a 4 byte length/codepoint pair into the buffer.
// total of 4 bytes inserted in buffer.
// note: the length value inserted in the buffer is the same as the value
// passed in as an argument (this value is not incremented by 4 before being
// inserted).
final void writelengthcodepoint int length  int codepoint
ensurelength offset_   4
bytes_    byte    length >>> 8    0xff
bytes_    byte   length   0xff
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
final byte writeextdtalengthcodepointforencryption int length  int codepoint
//how to encure length and offset later?
byte clearedbytes   new byte
clearedbytes    byte    length >>> 8    0xff
clearedbytes    byte   length   0xff
clearedbytes    byte    codepoint >>> 8    0xff
clearedbytes    byte   codepoint   0xff
return clearedbytes
// insert a 4 byte length/codepoint pair into the buffer followed
// by length number of bytes copied from array buf starting at offset 0.
// the length of this scalar must not exceed the max for the two byte length
// field.  this method does not support extended length.  the length
// value inserted in the buffer includes the number of bytes to copy plus
// the size of the llcp (or length + 4). it is up to the caller to make sure
// the array, buf, contains at least length number of bytes.
final void writescalarbytes int codepoint  byte buf  int length
ensurelength offset_   length   4
bytes_    byte     length   4  >>> 8    0xff
bytes_    byte    length   4    0xff
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
for  int i   0  i < length  i
bytes_   buf
// insert a 4 byte length/codepoint pair into the buffer.
// total of 4 bytes inserted in buffer.
// note: datalength will be incremented by the size of the llcp, 4,
// before being inserted.
final void writescalarheader int codepoint  int datalength
ensurelength offset_   datalength   4
bytes_    byte     datalength   4  >>> 8    0xff
bytes_    byte    datalength   4    0xff
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
/**
* write string with no minimum or maximum limit.
* @param codepoint codepoint to write
* @param string    value to write
* @throws sqlexception
*/
final void writescalarstring int codepoint  string string  throws sqlexception
writescalarstring codepoint  string  0 integer max_value null
/**
*  insert a 4 byte length/codepoint pair plus ddm character data into
* the buffer.  this method assumes that the string argument can be
* converted by the ccsid manager.  this should be fine because usually
* there are restrictions on the characters which can be used for ddm
* character data.
* the two byte length field will contain the length of the character data
* and the length of the 4 byte llcp.  this method does not handle
* scenarios which require extended length bytes.
*
* @param codepoint  codepoint to write
* @param string     value
* @param byteminlength minimum length. string will be padded with spaces
* if value is too short. assumes space character is one byte.
* @param bytelengthlimit  limit to string length. sqlexception will be
* thrown if we exceed this limit.
* @param sqlstate  sqlstate to throw with string as param if bytelengthlimit
* is exceeded.
* @throws sqlexception if string exceeds bytelengthlimit
*/
final void writescalarstring int codepoint  string string  int byteminlength
int bytelengthlimit  string sqlstate  throws sqlexception
int maxbytelength   ccsidmanager_ maxbytesperchar     string length
ensurelength offset_   maxbytelength   4
// skip length for now until we know actual length
int lengthoffset   offset_
offset_    2
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
offset_   ccsidmanager_ convertfromucs2 string  bytes_  offset_  netagent_
int stringbytelength   offset_   lengthoffset   4
// reset the buffer and throw an sqlexception if the length is too long
if  stringbytelength > bytelengthlimit
offset_   lengthoffset
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate   string
// pad if we don't reach the byteminlength limit
if  stringbytelength < byteminlength
for  int i   stringbytelength   i < byteminlength  i
bytes_   ccsidmanager_ space_
stringbytelength   byteminlength
// now write the length.  we have the string byte length plus
// 4 bytes, 2 for length and 2 for codepoint.
int totallength   stringbytelength   4
bytes_    byte    totallength >>> 8    0xff
bytes_    byte    totallength    0xff
// this method inserts ddm character data into the buffer and pad's the
// data with the ccsid manager's space character if the character data length
// is less than paddedlength.
// not: this method is not to be used for string truncation and the string length
// must be <= paddedlength.
// this method assumes that the string argument can be
// converted by the ccsid manager.  this should be fine because usually
// there are restrictions on the characters which can be used for ddm
// character data. this method also assumes that the string.length() will
// be the number of bytes following the conversion.
final void writescalarpaddedstring string string  int paddedlength  throws sqlexception
int stringlength   string length
ensurelength offset_   paddedlength
offset_   ccsidmanager_ convertfromucs2 string  bytes_  offset_  netagent_
for  int i   0  i < paddedlength   stringlength  i
bytes_   ccsidmanager_ space_
// this method writes a 4 byte length/codepoint pair plus the bytes contained
// in array buff to the buffer.
// the 2 length bytes in the llcp will contain the length of the data plus
// the length of the llcp.  this method does not handle scenarios which
// require extended length bytes.
final void writescalarbytes int codepoint  byte buff
int bufflength   buff length
ensurelength offset_   bufflength   4
bytes_    byte     bufflength   4  >>> 8    0xff
bytes_    byte    bufflength   4    0xff
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
system arraycopy buff  0  bytes_  offset_  bufflength
offset_    bufflength
// this method inserts a 4 byte length/codepoint pair plus length number of bytes
// from array buff starting at offset start.
// note: no checking will be done on the values of start and length with respect
// the actual length of the byte array.  the caller must provide the correct
// values so an array index out of bounds exception does not occur.
// the length will contain the length of the data plus the length of the llcp.
// this method does not handle scenarios which require extended length bytes.
final void writescalarbytes int codepoint  byte buff  int start  int length
ensurelength offset_   length   4
bytes_    byte     length   4  >>> 8    0xff
bytes_    byte    length   4    0xff
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
system arraycopy buff  start  bytes_  offset_  length
offset_    length
// insert a 4 byte length/codepoint pair plus ddm binary data into the
// buffer.  the binary data is padded if needed with the padbyte
// if the data is less than paddedlength.
// note: this method is not to be used for truncation and buff.length
// must be <= paddedlength.
// the llcp length bytes will contain the length of the data plus
// the length of the llcp or 4.
// this method does not handle scenarios which require extended length bytes.
final void writescalarpaddedbytes int codepoint  byte buff  int paddedlength  byte padbyte
int bufflength   buff length
ensurelength offset_   paddedlength   4
bytes_    byte     paddedlength   4  >>> 8    0xff
bytes_    byte    paddedlength   4    0xff
bytes_    byte    codepoint >>> 8    0xff
bytes_    byte   codepoint   0xff
system arraycopy buff  0  bytes_  offset_  bufflength
offset_    bufflength
for  int i   0  i < paddedlength   bufflength  i
bytes_   padbyte
// this method inserts binary data into the buffer and pads the
// data with the padbyte if the data length is less than the paddedlength.
// not: this method is not to be used for truncation and buff.length
// must be <= paddedlength.
final void writescalarpaddedbytes byte buff  int paddedlength  byte padbyte
int bufflength   buff length
ensurelength offset_   paddedlength
system arraycopy buff  0  bytes_  offset_  bufflength
offset_    bufflength
for  int i   0  i < paddedlength   bufflength  i
bytes_   padbyte
// write the request to the outputstream and flush the outputstream.
// trace the send if protocol trace is on.
protected void flush java io outputstream socketoutputstream  throws java io ioexception
if  doesrequestcontaindata
finalizedsslength
sendbytes socketoutputstream
protected void sendbytes java io outputstream socketoutputstream  throws java io ioexception
try
socketoutputstream write bytes_  0  offset_
socketoutputstream flush
finally
if  netagent_ logwriter_    null    passwordincluded_
// if password is in the buffer, need to mask it out.
maskoutpassword
passwordincluded_   false
if  netagent_ loggingenabled
netlogwriter  netagent_ logwriter_  traceprotocolflow bytes_
0
offset_
netlogwriter type_trace_send
1      tracepoint
clearbuffer
final void maskoutpassword
try
string maskchar
// construct a mask using the maskchar.
stringbuffer mask   new stringbuffer
for  int i   0  i < passwordlength_  i
mask append maskchar
// try to write mask over password.
ccsidmanager_ convertfromucs2 mask tostring    bytes_  passwordstart_  netagent_
catch  sqlexception sqle
// failed to convert mask,
// them simply replace with 0xff.
for  int i   0  i < passwordlength_  i
bytes_    byte  0xff
// insert a java byte into the buffer.
final void writebyte byte v
ensurelength offset_   1
bytes_   v
// insert a java short into the buffer.
final void writeshort short v
ensurelength offset_   2
org apache derby client am signedbinary shorttobigendianbytes bytes_  offset_  v
offset_    2
// insert a java int into the buffer.
void writeint int v
ensurelength offset_   4
org apache derby client am signedbinary inttobigendianbytes bytes_  offset_  v
offset_    4
// insert a java long into the buffer.
final void writelong long v
ensurelength offset_   8
org apache derby client am signedbinary longtobigendianbytes bytes_  offset_  v
offset_    8
//-- the following are the write short/int/long in bigendian byte ordering --
// when writing fdoca data.
protected void writeshortfdocadata short v
ensurelength offset_   2
org apache derby client am signedbinary shorttobigendianbytes bytes_  offset_  v
offset_    2
// when writing fdoca data.
protected void writeintfdocadata int v
ensurelength offset_   4
org apache derby client am signedbinary inttobigendianbytes bytes_  offset_  v
offset_    4
// when writing fdoca data.
protected void writelongfdocadata long v
ensurelength offset_   8
org apache derby client am signedbinary longtobigendianbytes bytes_  offset_  v
offset_    8
// insert a java float into the buffer.
protected void writefloat float v
ensurelength offset_   4
org apache derby client am floatingpoint floattoieee754bytes bytes_  offset_  v
offset_    4
// insert a java double into the buffer.
protected void writedouble double v
ensurelength offset_   8
org apache derby client am floatingpoint doubletoieee754bytes bytes_  offset_  v
offset_    8
// insert a java.math.bigdecimal into the buffer.
final void writebigdecimal java math bigdecimal v
int declaredprecision
int declaredscale  throws sqlexception
ensurelength offset_   16
int length   org apache derby client am decimal bigdecimaltopackeddecimalbytes bytes_  offset_  v  declaredprecision  declaredscale
offset_    length
final void writedate java sql date date  throws sqlexception
try
ensurelength offset_   10
org apache derby client am datetime datetodatebytes bytes_  offset_  date
offset_    10
catch  java io unsupportedencodingexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate unsupported_encoding
e
final void writetime java sql time time  throws sqlexception
try
ensurelength offset_   8
org apache derby client am datetime timetotimebytes bytes_  offset_  time
offset_    8
catch unsupportedencodingexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate unsupported_encoding
e
final void writetimestamp java sql timestamp timestamp  throws sqlexception
try
ensurelength offset_   26
org apache derby client am datetime timestamptotimestampbytes bytes_  offset_  timestamp
offset_    26
catch unsupportedencodingexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate unsupported_encoding
e
// insert a java boolean into the buffer.  the boolean is written
// as a signed byte having the value 0 or 1.
final void writeboolean boolean v
ensurelength offset_   1
bytes_    byte    v ? 1   0    0xff
// follows the typdef rules (note: don't think ddm char data is ever length
// delimited)
// should this throw sqlexception
// will write a varchar mixed or single
//  this was writeldstring
final void writesingleormixedccsidldstring string s  string encoding  throws sqlexception
byte b
try
b   s getbytes encoding
catch  unsupportedencodingexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate unsupported_encoding
e
if  b length > 0x7fff
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate lang_string_too_long
ensurelength offset_   b length   2
writeldbytesx b length  b
final void writeldbytes byte bytes
ensurelength offset_   bytes length   2
writeldbytesx bytes length  bytes
// private helper method which should only be called by a request method.
// must call ensurelength before calling this method.
// added for code reuse and helps perf by reducing ensurelength calls.
// ldsize and bytes.length may not be the same.  this is true
// when writing graphic ld strings.
private final void writeldbytesx int ldsize  byte bytes
bytes_    byte    ldsize >>> 8    0xff
bytes_    byte   ldsize   0xff
system arraycopy bytes  0  bytes_  offset_  bytes length
offset_    bytes length
// does it follows
// ccsid manager or typdef rules.  should this method write ddm character
// data or fodca data right now it is coded for ddm char data only
final void writeddmstring string s  throws sqlexception
ensurelength offset_   s length
offset_   ccsidmanager_ convertfromucs2 s  bytes_  offset_  netagent_
private byte buildlengthandcodepointforencryptedlob int codepoint
int lefttoread
boolean writenullbyte
int extendedlengthbytecount  throws disconnectexception
byte lengthandcodepoint   new byte
byte extendedlengthbytes   new byte
if  extendedlengthbytecount > 0
// method should never ensure length
lengthandcodepoint   writeextdtalengthcodepointforencryption 0x8004   extendedlengthbytecount  codepoint
if  writenullbyte
extendedlengthbytes   writeextendedlengthbytesforencryption extendedlengthbytecount  lefttoread   1
else
extendedlengthbytes   writeextendedlengthbytesforencryption extendedlengthbytecount  lefttoread
else
if  writenullbyte
lengthandcodepoint   writeextdtalengthcodepointforencryption lefttoread   4   1  codepoint
else
lengthandcodepoint   writeextdtalengthcodepointforencryption lefttoread   4  codepoint
if  extendedlengthbytecount > 0
byte newlengthandcodepoint   new byte
system arraycopy lengthandcodepoint  0  newlengthandcodepoint  0  lengthandcodepoint length
system arraycopy extendedlengthbytes  0  newlengthandcodepoint  lengthandcodepoint length  extendedlengthbytes length
lengthandcodepoint   newlengthandcodepoint
if  writenullbyte
byte nullbyte   new byte
system arraycopy lengthandcodepoint  0  nullbyte  0  lengthandcodepoint length
nullbyte   0
lengthandcodepoint   nullbyte
return lengthandcodepoint
private void buildlengthandcodepointforlob int codepoint
int lefttoread
boolean writenullbyte
int extendedlengthbytecount  throws disconnectexception
if  extendedlengthbytecount > 0
// method should never ensure length
writelengthcodepoint 0x8004   extendedlengthbytecount  codepoint
if  writenullbyte
writeextendedlengthbytes extendedlengthbytecount  lefttoread   1
else
writeextendedlengthbytes extendedlengthbytecount  lefttoread
else
if  writenullbyte
writelengthcodepoint lefttoread   4   1  codepoint
else
writelengthcodepoint lefttoread   4  codepoint
// write the null byte, if necessary
if  writenullbyte
write1byte 0x0
private void buildlengthandcodepointforlob int codepoint
boolean writenullbyte  throws disconnectexception
//0x8004 is for layer b streaming.
//see drda, version 3, volume 3: distributed data management (ddm) architecture page 315.
writelengthcodepoint 0x8004  codepoint
// write the null byte, if necessary
if  writenullbyte
write1byte 0x0
public void setdsslengthlocation int location
dsslengthlocation_   location
public void setcorrelationid int id
correlationid_   id
private static boolean peekstream  bufferedinputstream in
throws ioexception
in mark  1
boolean notyet    in read   >  1
in reset
return notyet