/*
derby - class org.apache.derby.impl.sql.compile.projectrestrictnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services context contextmanager
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile optimizablepredicate
import org apache derby iapi sql compile optimizablepredicatelist
import org apache derby iapi sql compile optimizer
import org apache derby iapi sql compile costestimate
import org apache derby iapi sql compile optimizablelist
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile requiredrowordering
import org apache derby iapi sql compile rowordering
import org apache derby iapi sql compile accesspath
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi error standardexception
import org apache derby iapi reference classname
import org apache derby iapi store access transactioncontroller
import org apache derby impl sql compile expressionclassbuilder
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services sanity sanitymanager
import org apache derby catalog types referencedcolumnsdescriptorimpl
import org apache derby iapi util jbitset
import org apache derby iapi services classfile vmopcode
import java util properties
import java util hashset
import java util set
/**
* a projectrestrictnode represents a result set for any of the basic dml
* operations: select, insert, update, and delete.  for insert with
* a values clause, restriction will be null. for both insert and update,
* the resultcolumns in the selectlist will contain the names of the columns
* being inserted into or updated.
*
* note: a projectrestrictnode extends fromtable since it can exist in a fromlist.
*
*/
public class projectrestrictnode extends singlechildresultsetnode
/**
* the valuenode for the restriction to be evaluated here.
*/
public valuenode	restriction
/**
* constant expressions to be evaluated here.
*/
valuenode	constantrestriction   null
/**
* restriction as a predicatelist
*/
public predicatelist restrictionlist
/**
* list of subqueries in projection
*/
subquerylist projectsubquerys
/**
* list of subqueries in restriction
*/
subquerylist restrictsubquerys
private boolean accesspathmodified
private boolean accesspathconsidered
private boolean childresultoptimized
private boolean materialize
/* should we get the table number from this node,
* regardless of the class of our child.
*/
private boolean gettablenumberhere
/**
* initializer for a projectrestrictnode.
*
* @param childresult	the child resultsetnode
* @param projection	the result column list for the projection
* @param restriction	an expression representing the restriction to be
*					    evaluated here.
* @param restrictionlist restriction as a predicatelist
* @param projectsubquerys list of subqueries in the projection
* @param restrictsubquerys list of subqueries in the restriction
* @param tableproperties	properties list associated with the table
*/
public void init
object childresult
object projection
object restriction
object restrictionlist
object projectsubquerys
object restrictsubquerys
object tableproperties
super init childresult  tableproperties
resultcolumns    resultcolumnlist  projection
this restriction    valuenode  restriction
this restrictionlist    predicatelist  restrictionlist
this projectsubquerys    subquerylist  projectsubquerys
this restrictsubquerys    subquerylist  restrictsubquerys
/* a prn will only hold the tableproperties for
* a result set tree if its child is not an
* optimizable.  otherwise, the properties will
* be transferred down to the child.
*/
if  tableproperties    null
childresult instanceof optimizable
optimizable  childresult  setproperties getproperties
setproperties  properties  null
/*
*  optimizable interface
*/
/**
@see optimizable#nextaccesspath
@exception standardexception	thrown on error
*/
public boolean nextaccesspath optimizer optimizer
optimizablepredicatelist predlist
rowordering rowordering
throws standardexception
/*
** if the child result set is an optimizable, let it choose its next
** access path.  if it is not an optimizable, we have to tell the
** caller that there is an access path the first time we are called
** for this position in the join order, and that there are no more
** access paths for subsequent calls for this position in the join
** order.  the startoptimizing() method is called once on each
** optimizable when it is put into a join position.
*/
if  childresult instanceof optimizable
return   optimizable  childresult  nextaccesspath optimizer
restrictionlist
rowordering
else
return super nextaccesspath optimizer  predlist  rowordering
/** @see optimizable#rememberasbest
@exception standardexception	thrown on error
*/
public void rememberasbest int plantype  optimizer optimizer
throws standardexception
super rememberasbest plantype  optimizer
if  childresult instanceof optimizable
optimizable  childresult  rememberasbest plantype  optimizer
/* don't print anything for a prn, as their
* child has the interesting info.
*/
void printrememberingbestaccesspath int plantype  accesspath bestpath
/** @see optimizable#startoptimizing */
public void startoptimizing optimizer optimizer  rowordering rowordering
if  childresult instanceof optimizable
optimizable  childresult  startoptimizing optimizer  rowordering
else
accesspathconsidered   false
super startoptimizing optimizer  rowordering
/** @see optimizable#gettablenumber */
public int gettablenumber
/* gross hack - we need to get the tablenumber after
* calling modifyaccesspaths() on the child when doing
* a hash join on an arbitrary result set.  the problem
* is that the child will always be an optimizable at this
* point.  so, we 1st check to see if we should get it from
* this node.  (we set the boolean to true in the appropriate
* place in modifyaccesspaths().)
*/
if  gettablenumberhere
return super gettablenumber
if  childresult instanceof optimizable
return   optimizable  childresult  gettablenumber
return super gettablenumber
/**
* @see optimizable#optimizeit
*
* @exception standardexception		thrown on error
*/
public costestimate optimizeit
optimizer optimizer
optimizablepredicatelist predlist
costestimate outercost
rowordering rowordering
throws standardexception
/*
** resolve: most types of optimizables only implement estimatecost(),
** and leave it up to optimizeit() in fromtable to figure out the
** total cost of the join.  a projectrestrict can have a non-optimizable
** child, though, in which case we want to tell the child the
** number of outer rows - it could affect the join strategy
** significantly.  so we implement optimizeit() here, which overrides
** the optimizeit() in fromtable.  this assumes that the join strategy
** for which this join node is the inner table is a nested loop join,
** which will not be a valid assumption when we implement other
** strategies like materialization (hash join can work only on
** base tables).  the join strategy for a base table under a
** projectrestrict is set in the base table itself.
*/
costestimate childcost
costestimate   getcostestimate optimizer
/*
** don't re-optimize a child result set that has already been fully
** optimized.  for example, if the child result set is a selectnode,
** it will be changed to a projectrestrictnode, which we don't want
** to re-optimized.
*/
// note: to get the right cost, the child result may have to be
// optimized more than once, because the number of outer rows
// may be different each time.
// if (childresultoptimized)
// 	return costestimate;
// it's possible that a call to optimize the left/right will cause
// a new "truly the best" plan to be stored in the underlying base
// tables.  if that happens and then we decide to skip that plan
// (which we might do if the call to "considercost()" below decides
// the current path is infeasible or not the best) we need to be
// able to revert back to the "truly the best" plans that we had
// saved before we got here.  so with this next call we save the
// current plans using "this" node as the key.  if needed, we'll
// then make the call to revert the plans in optimizerimpl's
// getnextdecoratedpermutation() method.
updatebestplanmap add_plan  this
/* if the childresult is instanceof optimizable, then we optimizeit.
* otherwise, we are going into a new query block.  if the new query
* block has already had its access path modified, then there is
* nothing to do.  otherwise, we must begin the optimization process
* anew on the new query block.
*/
if  childresult instanceof optimizable
childcost     optimizable  childresult  optimizeit
optimizer
restrictionlist
outercost
rowordering
/* copy child cost to this node's cost */
costestimate setcost
childcost getestimatedcost
childcost rowcount
childcost singlescanrowcount
// note: we don't call "optimizer.considercost()" here because
// a) the child will make that call as part of its own
// "optimizeit()" work above, and b) the child might have
// different criteria for "considering" (i.e. rejecting or
// accepting) a plan's cost than this projectrestrictnode does--
// and we don't want to override the child's decision.  so as
// with most operations in this class, if the child is an
// optimizable, we just let it do its own work and make its
// own decisions.
else if     accesspathmodified
if  sanitymanager debug
if      childresult instanceof selectnode
childresult instanceof rowresultsetnode
sanitymanager throwassert
childresult getclass   getname
childresult   childresult optimize optimizer getdatadictionary
restrictionlist
outercost rowcount
/* copy child cost to this node's cost */
childcost   childresult costestimate
costestimate setcost
childcost getestimatedcost
childcost rowcount
childcost singlescanrowcount
/* note: prior to the fix for derby-781 we had calls here
* to set the cost estimate for bestaccesspath and
* bestsortavoidancepath to equal costestimate.  that used
* to be okay because prior to derby-781 we would only
* get here once (per join order) for a given selectnode/
* rowresultsetnode and thus we could safely say that the
* costestimate from the most recent call to "optimize()"
* was the best one so far (because we knew that we would
* only call childresult.optimize() once).  now that we
* support hash joins with subqueries, though, we can get
* here twice per join order: once when the optimizer is
* considering a nested loop join with this prn, and once
* when it is considering a hash join.  this means we can't
* just arbitrarily use the cost estimate for the most recent
* "optimize()" as the best cost because that may not
* be accurate--it's possible that the above call to
* childresult.optimize() was for a hash join, but that
* we were here once before (namely for nested loop) and
* the cost of the nested loop is actually less than
* the cost of the hash join.  in that case it would
* be wrong to use costestimate as the cost of the "best"
* paths because it (costestimate) holds the cost of
* the hash join, not of the nested loop join.  so with
* derby-781 the following calls were removed:
*   getbestaccesspath().setcostestimate(costestimate);
*   getbestsortavoidancepath().setcostestimate(costestimate);
* if costestimate *does* actually hold the estimate for
* the best path so far, then we will set bestaccesspath
* and bestsortavoidancepath as needed in the following
* call to "considercost".
*/
// childresultoptimized = true;
/* resolve - arbitraryhashjoin - passing restriction list here, as above, is correct.
* however,  passing predlist makes the following work:
*	select * from t1, (select * from t2) c properties joinstrategy = hash where t1.c1 = c.c1;
* the following works with restrictionlist:
*	select * from t1, (select c1 + 0 from t2) c(c1) properties joinstrategy = hash where t1.c1 = c.c1;
*/
optimizer considercost this  restrictionlist  getcostestimate    outercost
return costestimate
/**
* @see optimizable#feasiblejoinstrategy
*
* @exception standardexception		thrown on error
*/
public boolean feasiblejoinstrategy optimizablepredicatelist predlist
optimizer optimizer
throws standardexception
accesspath ap
/* the child being an optimizable is a special case.  in that
* case, we want to get the current access path and join strategy
* from the child.  otherwise, we want to get it from this node.
*/
if  childresult instanceof optimizable
// with derby-805 it's possible that, when considering a nested
// loop join with this prn, we pushed predicates down into the
// child if the child is a union node.  at this point, though, we
// may be considering doing a hash join with this prn instead of a
// nested loop join, and if that's the case we need to pull any
// predicates back up so that they can be searched for equijoins
// that will in turn make the hash join possible.  so that's what
// the next call does.  two things to note: 1) if no predicates
// were pushed, this call is a no-op; and 2) if we get here when
// considering a nested loop join, the predicates that we pull
// here (if any) will be re-pushed for subsequent costing/
// optimization as necessary (see optimizerimpl.costpermutation(),
// which will call this class's optimizeit() method and that's
// where the predicates are pushed down again).
if  childresult instanceof unionnode
unionnode childresult  pulloptpredicates restrictionlist
return   optimizable  childresult
feasiblejoinstrategy restrictionlist  optimizer
else
return super feasiblejoinstrategy restrictionlist  optimizer
/** @see optimizable#getcurrentaccesspath */
public accesspath getcurrentaccesspath
if  childresult instanceof optimizable
return   optimizable  childresult  getcurrentaccesspath
return super getcurrentaccesspath
/** @see optimizable#getbestaccesspath */
public accesspath getbestaccesspath
if  childresult instanceof optimizable
return   optimizable  childresult  getbestaccesspath
return super getbestaccesspath
/** @see optimizable#getbestsortavoidancepath */
public accesspath getbestsortavoidancepath
if  childresult instanceof optimizable
return   optimizable  childresult  getbestsortavoidancepath
return super getbestsortavoidancepath
/** @see optimizable#gettrulythebestaccesspath */
public accesspath gettrulythebestaccesspath
/* the childresult will always be an optimizable
* during code generation.  if the childresult was
* not an optimizable during optimization, then this node
* will have the truly the best access path, so we want to
* return it from this node, rather than traversing the tree.
* this can happen for non-flattenable derived tables.
* anyway, we note this state when modifying the access paths.
*/
if  hastrulythebestaccesspath
return super gettrulythebestaccesspath
if  childresult instanceof optimizable
return   optimizable  childresult  gettrulythebestaccesspath
return super gettrulythebestaccesspath
/** @see optimizable#remembersortavoidancepath */
public void remembersortavoidancepath
if  childresult instanceof optimizable
optimizable  childresult  remembersortavoidancepath
else
super remembersortavoidancepath
/** @see optimizable#considersortavoidancepath */
public boolean considersortavoidancepath
if  childresult instanceof optimizable
return   optimizable  childresult  considersortavoidancepath
return super considersortavoidancepath
/**
* @see optimizable#pushoptpredicate
*
* @exception standardexception		thrown on error
*/
public boolean pushoptpredicate optimizablepredicate optimizablepredicate
throws standardexception
if  sanitymanager debug
sanitymanager assert optimizablepredicate instanceof predicate
sanitymanager assert   optimizablepredicate hassubquery
optimizablepredicate hasmethodcall
/* add the matching predicate to the restrictionlist */
if  restrictionlist    null
restrictionlist    predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
restrictionlist addpredicate  predicate  optimizablepredicate
/* remap all of the columnreferences to point to the
* source of the values.
*/
predicate pred    predicate optimizablepredicate
/* if the predicate is scoped then the call to "remapscopedpred()"
* will do the necessary remapping for us and will return true;
* otherwise, we'll just do the normal remapping here.
*/
if   pred remapscopedpred
remapcrsvisitor rcrv   new remapcrsvisitor true
pred getandnode   accept rcrv
return true
/**
* @see optimizable#pulloptpredicates
*
* @exception standardexception		thrown on error
*/
public void pulloptpredicates
optimizablepredicatelist optimizablepredicates
throws standardexception
if  restrictionlist    null
// pull up any predicates that may have been pushed further
// down the tree during optimization.
if  childresult instanceof unionnode
unionnode childresult  pulloptpredicates restrictionlist
remapcrsvisitor rcrv   new remapcrsvisitor false
for  int i   restrictionlist size     1  i >  0  i
optimizablepredicate optpred
restrictionlist getoptpredicate i
predicate  optpred  getandnode   accept rcrv
optimizablepredicates addoptpredicate optpred
restrictionlist removeoptpredicate i
/**
* @see optimizable#modifyaccesspath
*
* @exception standardexception		thrown on error
*/
public optimizable modifyaccesspath jbitset outertables
throws standardexception
boolean origchildoptimizable   true
/* it is okay to optimize most nodes multiple times.  however,
* modifying the access path is something that should only be done
* once per node.  one reason for this is that the predicate list
* will be empty after the 1st call, and we assert that it should
* be non-empty.  multiple calls to modify the access path can
* occur when there is a non-flattenable fromsubquery (or view).
*/
if  accesspathmodified
return this
/*
** do nothing if the child result set is not optimizable, as there
** can be nothing to modify.
*/
boolean alreadypushed   false
if      childresult instanceof optimizable
// remember that the original child was not optimizable
origchildoptimizable   false
/* when we optimized the child we passed in our restriction list
* so that scoped predicates could be pushed further down the
* tree.  we need to do the same when modifying the access
* paths to ensure we generate the same plans the optimizer
* chose.
*/
childresult   childresult modifyaccesspaths restrictionlist
/*
* if we have a subquery select with window function columns, we
* have the following simplified querytre before the above call:
*    select -> prn -> select
* where middle prn is what was originally a fromsubquery node.
* with window functions we pull any windownodes into the tree,
* modify the lower selects rcl, and put a (noop) prn on top in the
* above call. this results in:
*    select -> prn -> prn(noop) -> wn -> ...
* a distinct query will place an additional distinctnode on top of
* the window node:
*    select -> prn -> prn(noop) -> dn -> wn -> ...
* note that the rcl for the initial prn and its child select used
* to be the same object. after the above call, the initial prns rcl
* is incorrect, and we need to regenerate the vcns.
* the above two combinations are the only two possible from
* modifyaccesspaths() that require regeneration of the vcns.
*/
if  childresult instanceof projectrestrictnode
projectrestrictnode prn    projectrestrictnode  childresult
if  prn childresult getresultcolumns
containswindowfunctionresultcolumn
/*
* we have a window function column in the rcl of our child
* prn, and need to regenerate the vcns.
*/
resultcolumns genvirtualcolumnnodes
prn childresult  prn childresult getresultcolumns
/* mark this node as having the truly ... for
* the underlying tree.
*/
hastrulythebestaccesspath   true
/* replace this prn with a hrn if we are doing a hash join */
if  trulythebestaccesspath getjoinstrategy   ishashjoin
if  sanitymanager debug
sanitymanager assert restrictionlist    null
sanitymanager assert restrictionlist size      0
/* we're doing a hash join on an arbitary result set.
* we need to get the table number from this node when
* dividing up the restriction list for a hash join.
* we need to explicitly remember this.
*/
gettablenumberhere   true
else
/* we consider materialization into a temp table as a last step.
* currently, we only materialize vtis that are inner tables
* and can't be instantiated multiple times.  in the future we
* will consider materialization as a cost based option.
*/
return  optimizable  considermaterialization outertables
/* if the child is not a frombasetable, then we want to
* keep going down the tree.  (nothing to do at this node.)
*/
else if    childresult instanceof frombasetable
/* make sure that we have a join strategy */
if  trulythebestaccesspath getjoinstrategy      null
trulythebestaccesspath    accesspathimpl    optimizable  childresult  gettrulythebestaccesspath
// if the childresult is a setoperatornode (esp. a unionnode),
// then it's possible that predicates in our restrictionlist are
// supposed to be pushed further down the tree (as of derby-805).
// we passed the restrictionlist down when we optimized the child
// so that the relevant predicates could be pushed further as part
// of the optimization process; so now that we're finalizing the
// paths, we need to do the same thing: i.e. pass restrictionlist
// down so that the predicates that need to be pushed further
// _can_ be pushed further.
if  childresult instanceof setoperatornode
childresult    resultsetnode
setoperatornode  childresult  modifyaccesspath
outertables  restrictionlist
// take note of the fact that we already pushed predicates
// as part of the modifyaccesspaths call.  this is necessary
// because there may still be predicates in restrictionlist
// that we intentionally decided not to push (ex. if we're
// going to do hash join then we chose to not push the join
// predicates).  whatever the reason for not pushing the
// predicates, we have to make sure we don't inadvertenly
// push them later (esp. as part of the "pushusefulpredicates"
// call below).
alreadypushed   true
else
childresult
resultsetnode    fromtable  childresult
modifyaccesspath outertables
// if we're doing a hash join with _this_ prn (as opposed to
// with this prn's child) then we don't attempt to push
// predicates down.  there are two reasons for this: 1)
// we don't want to push the equijoin predicate that is
// required for the hash join, and 2) if we're doing a
// hash join then we're going to materialize this node,
// but if we push predicates before materialization, we
// can end up with incorrect results (esp. missing rows).
// so don't push anything in this case.
boolean hashjoinwiththisprn   hastrulythebestaccesspath
trulythebestaccesspath getjoinstrategy      null
trulythebestaccesspath getjoinstrategy   ishashjoin
if   restrictionlist    null      alreadypushed     hashjoinwiththisprn
restrictionlist pushusefulpredicates  optimizable  childresult
/*
** the optimizer's decision on the access path for the child result
** set may require the generation of extra result sets.  for
** example, if it chooses an index, we need an indextobaserownode
** above the frombasetable (and the frombasetable has to change
** its column list to match that of the index.
*/
if  origchildoptimizable
childresult   childresult changeaccesspath
accesspathmodified   true
/*
** replace this prn with a htn if a hash join
** is being done at this node.  (hash join on a scan
** is a special case and is handled at the fbt.)
*/
if  trulythebestaccesspath getjoinstrategy      null
trulythebestaccesspath getjoinstrategy   ishashjoin
return replacewithhashtablenode
/* we consider materialization into a temp table as a last step.
* currently, we only materialize vtis that are inner tables
* and can't be instantiated multiple times.  in the future we
* will consider materialization as a cost based option.
*/
return  optimizable  considermaterialization outertables
/**
* this method creates a hashtablenode between the prn and
* it's child when the optimizer chooses hash join on an
* arbitrary (non-fbt) result set tree.
* we divide up the restriction list into 3 parts and
* distribute those parts as described below.
*
* @return the new (same) top of our result set tree.
* @exception standardexception		thrown on error
*/
private optimizable replacewithhashtablenode
throws standardexception
// if this prn has ttb access path for its child, store that access
// path in the child here, so that we can find it later when it
// comes time to generate qualifiers for the hash predicates (we
// need the child's access path when generating qualifiers; if we
// don't pass the path down here, the child won't be able to find
// it).
if  hastrulythebestaccesspath
fromtable childresult  trulythebestaccesspath
accesspathimpl gettrulythebestaccesspath
// if the child itself is another singlechildresultsetnode
// (which is also what a projectrestrictnode is), then tell
// it that it is now holding ttb path for it's own child.  again,
// this info is needed so that child knows where to find the
// access path at generation time.
if  childresult instanceof singlechildresultsetnode
singlechildresultsetnode childresult
hastrulythebestaccesspath   hastrulythebestaccesspath
// while we're at it, add the prn's table number to the
// child's referenced map so that we can find the equijoin
// predicate.  we have to do this because the predicate
// will be referencing the prn's tablenumber, not the
// child's--and since we use the child as the target
// when searching for hash keys (as can be seen in
// hashjoinstrategy.divideuppredicatelists()), the child
// should know what this prn's table number is.  this
// is somewhat bizarre since the child doesn't
// actually "reference" this prn, but since the child's
// reference map is used when searching for the equijoin
// predicate (see "buildtablenumlist" in
// binaryrelationaloperatornode), this is the simplest
// way to pass this prn's table number down.
childresult getreferencedtablemap   set tablenumber
/* we want to divide the predicate list into 3 separate lists -
*	o predicates against the source of the hash table, which will
*	  be applied on the way into the hash table (searchrestrictionlist)
*  o join clauses which are qualifiers and get applied to the
*	  rows in the hash table on a probe (joinrestrictionlist)
*	o non-qualifiers involving both tables which will get
*	  applied after a row gets returned from the htrs (nonqualifiers)
*
* we do some unnecessary work when doing this as we want to reuse
* as much existing code as possible.  the code that we are reusing
* was originally built for hash scans, hence the unnecessary
* requalification list.
*/
predicatelist searchrestrictionlist
predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
predicatelist joinqualifierlist
predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
predicatelist requalificationrestrictionlist
predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
trulythebestaccesspath getjoinstrategy   divideuppredicatelists
this
restrictionlist
searchrestrictionlist
joinqualifierlist
requalificationrestrictionlist
getdatadictionary
/* break out the non-qualifiers from htn's join qualifier list and make that
* the new restriction list for this prn.
*/
restrictionlist    predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
/* for non-base table, we remove first 2 lists from requal list to avoid adding duplicates.
*/
for  int i   0  i < searchrestrictionlist size    i
requalificationrestrictionlist removeoptpredicate  predicate  searchrestrictionlist elementat i
for  int i   0  i < joinqualifierlist size    i
requalificationrestrictionlist removeoptpredicate  predicate  joinqualifierlist elementat i
joinqualifierlist transfernonqualifiers this  restrictionlist     purify joinqual list
requalificationrestrictionlist copypredicatestootherlist restrictionlist     any residual
resultcolumnlist	htrclist
/* we get a shallow copy of the child's resultcolumnlist and its
* resultcolumns.  (copy maintains resultcolumn.expression for now.)
*/
htrclist   childresult getresultcolumns
childresult setresultcolumns htrclist copylistandobjects
/* replace resultcolumn.expression with new virtualcolumnnodes
* in the htn's resultcolumnlist.  (virtualcolumnnodes include
* pointers to source resultsetnode, this, and source resultcolumn.)
* note: we don't want to mark the underlying rcs as referenced, otherwise
* we won't be able to project out any of them.
*/
htrclist genvirtualcolumnnodes childresult  childresult getresultcolumns    false
/* the crs for this side of the join in both the searchrestrictionlist
* the joinqualifierlist now point to the htn's rcl.  we need them
* to point to the rcl in the child of the htn.  (we skip doing this for
* the joinqualifierlist as the code to generate the qualifiers does not
* care.)
*/
remapcrsvisitor rcrv   new remapcrsvisitor true
searchrestrictionlist accept rcrv
/* we can finally put the htn between ourself and our old child. */
childresult    resultsetnode  getnodefactory   getnode
c_nodetypes hash_table_node
childresult
tableproperties
htrclist
searchrestrictionlist
joinqualifierlist
trulythebestaccesspath
getcostestimate
projectsubquerys
restrictsubquerys
hashkeycolumns
getcontextmanager
return this
/** @see optimizable#verifyproperties
* @exception standardexception		thrown on error
*/
public void verifyproperties datadictionary ddictionary
throws standardexception
/* table properties can be attached to this node if
* its child is not an optimizable, otherwise they
* are attached to its child.
*/
if  childresult instanceof optimizable
optimizable  childresult  verifyproperties ddictionary
else
super verifyproperties ddictionary
/**
* @see optimizable#legaljoinorder
*/
public boolean legaljoinorder jbitset assignedtablemap
if  childresult instanceof optimizable
return   optimizable  childresult  legaljoinorder assignedtablemap
else
return true
/**
* @see optimizable#uniquejoin
*
* @exception standardexception		thrown on error
*/
public double uniquejoin optimizablepredicatelist predlist
throws standardexception
if  childresult instanceof optimizable
return   optimizable  childresult  uniquejoin predlist
else
return super uniquejoin predlist
/**
* return the restriction list from this node.
*
* @return	the restriction list from this node.
*/
predicatelist getrestrictionlist
return restrictionlist
/**
* return the user specified join strategy, if any for this table.
*
* @return the user specified join strategy, if any for this table.
*/
string getuserspecifiedjoinstrategy
if  childresult instanceof fromtable
return   fromtable  childresult  getuserspecifiedjoinstrategy
else
return userspecifiedjoinstrategy
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  restriction    null
printlabel depth
restriction treeprint depth   1
if  restrictionlist    null
printlabel depth
restrictionlist treeprint depth   1
if  projectsubquerys    null
printlabel depth
projectsubquerys treeprint depth   1
if  restrictsubquerys    null
printlabel depth
restrictsubquerys treeprint depth   1
/**
* put a projectrestrictnode on top of each fromtable in the fromlist.
* columnreferences must continue to point to the same resultcolumn, so
* that resultcolumn must percolate up to the new prn.  however,
* that resultcolumn will point to a new expression, a virtualcolumnnode,
* which points to the fromtable and the resultcolumn that is the source for
* the columnreference.
* (the new prn will have the original of the resultcolumnlist and
* the resultcolumns from that list.  the fromtable will get shallow copies
* of the resultcolumnlist and its resultcolumns.  resultcolumn.expression
* will remain at the fromtable, with the prn getting a new
* virtualcolumnnode for each resultcolumn.expression.)
* we then project out the non-referenced columns.  if there are no referenced
* columns, then the prn's resultcolumnlist will consist of a single resultcolumn
* whose expression is 1.
*
* @param numtables			number of tables in the dml statement
* @param gbl				the group by list, if any
* @param fromlist			the from list, if any
*
* @return the generated projectrestrictnode atop the original fromtable.
*
* @exception standardexception		thrown on error
*/
public resultsetnode preprocess int numtables
groupbylist gbl
fromlist fromlist
throws standardexception
childresult   childresult preprocess numtables  gbl  fromlist
/* build the referenced table map */
referencedtablemap    jbitset  childresult getreferencedtablemap   clone
return this
/**
* push expressions down to the first resultsetnode which can do expression
* evaluation and has the same referenced table map.
* resolve - this means only pushing down single table expressions to
* projectrestrictnodes today.  once we have a better understanding of how
* the optimizer will work, we can push down join clauses.
*
* @param predicatelist	the predicatelist.
*
* @exception standardexception		thrown on error
*/
public void pushexpressions predicatelist predicatelist
throws standardexception
predicatelist	pushplist   null
if  sanitymanager debug
sanitymanager assert predicatelist    null
/* push single table predicates down to the left of an outer
* join, if possible.  (we need to be able to walk an entire
* join tree.)
*/
if  childresult instanceof joinnode
fromtable  childresult  pushexpressions predicatelist
/* build a list of the single table predicates that we can push down */
pushplist   predicatelist getpushablepredicates referencedtablemap
/* if this is a prn above a selectnode, probably due to a
* view or derived table which couldn't be flattened, then see
* if we can push any of the predicates which just got pushed
* down to our level into the selectnode.
*/
if  pushplist    null
childresult instanceof selectnode
resultcolumns containswindowfunctionresultcolumn
pushplist pushexpressionsintoselect  selectnode  childresult  false
/* derby-649: push simple predicates into unions. it would be up to unionnode
* to decide if these predicates can be pushed further into underlying selectnodes
* or unionnodes.  note, we also keep the predicatelist at this
* projectrestrictnode in case the predicates are not pushable or only
* partially pushable.
*
* it is possible to expand this optimization in unionnode later.
*/
if  pushplist    null     childresult instanceof unionnode
unionnode childresult  pushexpressions pushplist
if  restrictionlist    null
restrictionlist   pushplist
else if  pushplist    null    pushplist size      0
/* concatenate the 2 predicatelists */
restrictionlist destructiveappend pushplist
/* resolve - this looks like the place to try to try to push the
* predicates through the projectrestrict.  seems like we should
* "rebind" the column references and reset the referenced table maps
* in restrictionlist and then call childresult.pushexpressions() on
* restrictionlist.
*/
/**
* add a new predicate to the list.  this is useful when doing subquery
* transformations, when we build a new predicate with the left side of
* the subquery operator and the subquery's result column.
*
* @param predicate		the predicate to add
*
* @return resultsetnode	the new top of the tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode addnewpredicate predicate predicate
throws standardexception
if  restrictionlist    null
restrictionlist    predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
restrictionlist addpredicate predicate
return this
/**
* evaluate whether or not the subquery in a fromsubquery is flattenable.
* currently, a fsqry is flattenable if all of the following are true:
*		o  subquery is a selectnode.
*		o  it contains no top level subqueries.  (resolve - we can relax this)
*		o  it does not contain a group by or having clause
*		o  it does not contain aggregates.
*
* @param fromlist	the outer from list
*
* @return boolean	whether or not the fromsubquery is flattenable.
*/
public boolean flattenableinfromsubquery fromlist fromlist
/* flattening currently involves merging predicates and fromlists.
* we don't have a fromlist, so we can't flatten for now.
*/
/* resolve - this will introduce yet another unnecessary prn */
return false
/**
* ensure that the top of the rsn tree has a predicatelist.
*
* @param numtables			the number of tables in the query.
* @return resultsetnode	a rsn tree with a node which has a predicatelist on top.
*
* @exception standardexception		thrown on error
*/
public resultsetnode ensurepredicatelist int numtables
throws standardexception
return this
/**
* optimize this projectrestrictnode.
*
* @param datadictionary	the datadictionary to use for optimization
* @param predicates		the predicatelist to optimize.  this should
*							be a join predicate.
* @param outerrows			the number of outer joining rows
*
* @return	resultsetnode	the top of the optimized subtree
*
* @exception standardexception		thrown on error
*/
public resultsetnode optimize datadictionary datadictionary
predicatelist predicates
double outerrows
throws standardexception
/* we need to implement this method since a prn can appear above a
* selectnode in a query tree.
*/
childresult   childresult optimize datadictionary
restrictionlist
outerrows
optimizer optimizer   getoptimizer
fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
this
getcontextmanager
predicates
datadictionary
requiredrowordering  null
// resolve: should factor in the non-optimizable predicates that
// were not pushed down
costestimate   optimizer newcostestimate
costestimate setcost childresult getcostestimate   getestimatedcost
childresult getcostestimate   rowcount
childresult getcostestimate   singlescanrowcount
return this
/**
* get the costestimate for this projectrestrictnode.
*
* @return	the costestimate for this projectrestrictnode, which is
* 			the cost estimate for the child node.
*/
public costestimate getcostestimate
/*
** the cost estimate will be set here if either optimize() or
** optimizeit() was called on this node.  it's also possible
** that optimization was done directly on the child node,
** in which case the cost estimate will be null here.
*/
if  costestimate    null
return childresult getcostestimate
else
return costestimate
/**
* get the final costestimate for this projectrestrictnode.
*
* @return	the final costestimate for this projectrestrictnode, which is
* 			the final cost estimate for the child node.
*/
public costestimate getfinalcostestimate
throws standardexception
if  finalcostestimate    null
// we already set it, so just return it.
return finalcostestimate
// if the child result set is an optimizable, then this node's
// final cost is that of the child.  otherwise, this node must
// hold "trulythebestaccesspath" for it's child so we pull
// the final cost from there.
if  childresult instanceof optimizable
finalcostestimate   childresult getfinalcostestimate
else
finalcostestimate   gettrulythebestaccesspath   getcostestimate
return finalcostestimate
/**
* for joins, the tree will be (nodes are left out if the clauses
* are empty):
*
*      projectrestrictresultset -- for the having and the select list
*      sortresultset -- for the group by list
*      projectrestrictresultset -- for the where and the select list (if no group or having)
*      the result set for the fromlist
*
*
* @exception standardexception		thrown on error
*/
public void generate activationclassbuilder acb
methodbuilder mb
throws standardexception
if  sanitymanager debug
sanitymanager assert resultcolumns    null
generateminion  acb  mb  false
/**
* general logic shared by core compilation.
*
* @param acb	the expressionclassbuilder for the class being built
* @param mb	the method the expression will go into
*
*
* @exception standardexception		thrown on error
*/
public void generateresultset expressionclassbuilder acb
methodbuilder mb
throws standardexception
generateminion  acb  mb  true
/**
* logic shared by generate() and generateresultset().
*
* @param acb	the expressionclassbuilder for the class being built
* @param mb	the method the expression will go into
*
* @exception standardexception		thrown on error
*/
private void generateminion expressionclassbuilder acb
methodbuilder mb  boolean genchildresultset
throws standardexception
/* if this projectrestrict doesn't do anything, bypass its generation.
* (remove any true and true predicates first, as they could be left
* by the like transformation.)
*/
if  restrictionlist    null    restrictionlist size   > 0
restrictionlist eliminatebooleantrueandbooleantrue
if  nopprojectrestrict
generatenopprojectrestrict
if  genchildresultset
childresult generateresultset acb  mb
else
childresult generate  activationclassbuilder acb  mb
costestimate   childresult getfinalcostestimate
return
// build up the tree.
/* put the predicates back into the tree */
if  restrictionlist    null
constantrestriction   restrictionlist restoreconstantpredicates
// remove any redundant predicates before restoring
restrictionlist removeredundantpredicates
restriction   restrictionlist restorepredicates
/* allow the restrictionlist to get garbage collected now
* that we're done with it.
*/
restrictionlist   null
// for the restriction, we generate an exprfun
// that evaluates the expression of the clause
// against the current row of the child's result.
// if the restriction is empty, simply pass null
// to optimize for run time performance.
// generate the function and initializer:
// note: boolean lets us return nulls (boolean would not)
// private boolean exprn()
// {
//   return <<restriction.generate(ps)>>;
// }
// static method exprn = method pointer to exprn;
// map the result columns to the source columns
int maparray   resultcolumns mapsourcecolumns
int maparrayitem   acb additem new referencedcolumnsdescriptorimpl maparray
/* will this node do a projection? */
boolean doesprojection   true
/* does a projection unless same # of columns in same order
* as child.
*/
if      reflectionneededforprojection
maparray    null
maparray length    childresult getresultcolumns   size
/* maparray entries are 1-based */
int index   0
for     index < maparray length  index
if  maparray    index   1
break
if  index    maparray length
doesprojection   false
/* generate the projectrestrictset:
*	arg1: childexpress - expression for childresultset
*  arg2: activation
*  arg3: restrictexpress - expression for restriction
*  arg4: projectexpress - expression for projection
*  arg5: resultsetnumber
*  arg6: constantexpress - expression for constant restriction
*			(for example, where 1 = 2)
*  arg7: maparrayitem - item # for mapping of source columns
*  arg8: reuseresult - whether or not the result row can be reused
*						(ie, will it always be the same)
*  arg9: doesprojection - does this node do a projection
*  arg10: estimated row count
*  arg11: estimated cost
*  arg12: close method
*/
acb pushgetresultsetfactoryexpression mb
if  genchildresultset
childresult generateresultset acb  mb
else
childresult generate  activationclassbuilder acb  mb
/* get the next resultset #, so that we can number this resultsetnode, its
* resultcolumnlist and resultset.
*/
assignresultsetnumber
/* set the point of attachment in all subqueries attached
* to this node.
*/
if  projectsubquerys    null    projectsubquerys size   > 0
projectsubquerys setpointofattachment resultsetnumber
if  restrictsubquerys    null    restrictsubquerys size   > 0
restrictsubquerys setpointofattachment resultsetnumber
// load our final cost estimate.
costestimate   getfinalcostestimate
// if there is no restriction, we just want to pass null.
if  restriction    null
mb pushnull classname generatedmethod
else
// this sets up the method and the static field.
// generates:
// 	object userexprfun { }
methodbuilder userexprfun   acb newuserexprfun
// restriction knows it is returning its value;
/* generates:
*    return  <restriction.generate(acb)>;
* and adds it to userexprfun
* note: the explicit cast to datavaluedescriptor is required
* since the restriction may simply be a boolean column or subquery
* which returns a boolean.  for example:
*		where booleancolumn
*/
restriction generateexpression acb  userexprfun
userexprfun methodreturn
// we are done modifying userexprfun, complete it.
userexprfun complete
// restriction is used in the final result set as an access of the new static
// field holding a reference to this new method.
// generates:
//	activationclass.userexprfun
// which is the static field that "points" to the userexprfun
// that evaluates the where clause.
acb pushmethodreference mb  userexprfun
/* determine whether or not reflection is needed for the projection.
* reflection is not needed if all of the columns map directly to source
* columns.
*/
if  reflectionneededforprojection
// for the resultcolumns, we generate a userexprfun
// that creates a new row from expressions against
// the current row of the child's result.
// (generate optimization: see if we can simply
// return the current row -- we could, but don't, optimize
// the function call out and have execution understand
// that a null function pointer means take the current row
// as-is, with the performance trade-off as discussed above.)
/* generate the row function for the projection */
resultcolumns generatecore acb  mb  false
else
mb pushnull classname generatedmethod
mb push resultsetnumber
// if there is no constant restriction, we just want to pass null.
if  constantrestriction    null
mb pushnull classname generatedmethod
else
// this sets up the method and the static field.
// generates:
// 	userexprfun { }
methodbuilder userexprfun   acb newuserexprfun
// restriction knows it is returning its value;
/* generates:
*    return <restriction.generate(acb)>;
* and adds it to userexprfun
* note: the explicit cast to datavaluedescriptor is required
* since the restriction may simply be a boolean column or subquery
* which returns a boolean.  for example:
*		where booleancolumn
*/
constantrestriction generateexpression acb  userexprfun
userexprfun methodreturn
// we are done modifying userexprfun, complete it.
userexprfun complete
// restriction is used in the final result set as an access
// of the new static field holding a reference to this new method.
// generates:
//	activationclass.userexprfun
// which is the static field that "points" to the userexprfun
// that evaluates the where clause.
acb pushmethodreference mb  userexprfun
mb push maparrayitem
mb push resultcolumns reusableresult
mb push doesprojection
mb push costestimate rowcount
mb push costestimate getestimatedcost
mb callmethod vmopcode invokeinterface   string  null
classname noputresultset  10
/**
* determine whether this projectrestrict does anything.  if it doesn't
* filter out any rows or columns, it's a no-op.
*
* @return	true if this projectrestrict is a no-op.
*/
boolean nopprojectrestrict
/*
** this projectrestrictnode is not a no-op if it does any
** restriction.
*/
if    restriction    null
restrictionlist    null    restrictionlist size   > 0
return false
resultcolumnlist	childcolumns   childresult getresultcolumns
resultcolumnlist	prncolumns   this getresultcolumns
/*
** the two lists have the same numbers of elements.  are the lists
** identical?  in other words, is the expression in every resultcolumn
** in the prn's rcl a columnreference that points to the same-numbered
** column?
*/
if  prncolumns nopprojection childcolumns
return true
return false
/**
* bypass the generation of this no-op projectrestrict, and just generate
* its child result set.
*
* @exception standardexception		thrown on error
*/
public void generatenopprojectrestrict
throws standardexception
this getresultcolumns   setredundant
/**
* consider materialization for this resultset tree if it is valid and cost effective
* (it is not valid if incorrect results would be returned.)
*
* @return top of the new/same resultset tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode considermaterialization jbitset outertables
throws standardexception
childresult   childresult considermaterialization outertables
if  childresult performmaterialization outertables
materializeresultsetnode	mrsn
resultcolumnlist			prrclist
/* if the restriction contians a columnreference from another
* table then the mrsn must go above the childresult.  otherwise we can put
* it above ourselves. (the later is optimal since projection and restriction
* will only happen once.)
* put mrsn above prn if any of the following are true:
*	o  prn doesn't have a restriction list
*	o  prn's restriction list is empty
*  o  table's referenced in prn's restriction list are a subset of
*	   table's referenced in prn's childresult.  (note: rather than construct
*     a new, empty jbitset before checking, we simply clone the childresult's
*	   referencedtablemap.  this is done for code simplicity and will not
*	   affect the result.)
*/
referencedtablesvisitor rtv   new referencedtablesvisitor
jbitset  childresult getreferencedtablemap   clone
boolean emptyrestrictionlist    restrictionlist    null    restrictionlist size      0
if    emptyrestrictionlist
restrictionlist accept rtv
if  emptyrestrictionlist
childresult getreferencedtablemap   contains rtv gettablemap
/* we get a shallow copy of the resultcolumnlist and its
* resultcolumns.  (copy maintains resultcolumn.expression for now.)
*/
prrclist   resultcolumns
setresultcolumns resultcolumns copylistandobjects
/* replace resultcolumn.expression with new virtualcolumnnodes
* in the normalizeresultsetnode's resultcolumnlist.  (virtualcolumnnodes include
* pointers to source resultsetnode, this, and source resultcolumn.)
*/
prrclist genvirtualcolumnnodes this  resultcolumns
/* finally, we create the new materializeresultsetnode */
mrsn    materializeresultsetnode  getnodefactory   getnode
c_nodetypes materialize_result_set_node
this
prrclist
tableproperties
getcontextmanager
// propagate the referenced table map if it's already been created
if  referencedtablemap    null
mrsn setreferencedtablemap  jbitset  referencedtablemap clone
return mrsn
else
/* we get a shallow copy of the resultcolumnlist and its
* resultcolumns.  (copy maintains resultcolumn.expression for now.)
*/
prrclist   childresult getresultcolumns
childresult setresultcolumns prrclist copylistandobjects
/* replace resultcolumn.expression with new virtualcolumnnodes
* in the materializeresultsetnode's resultcolumnlist.  (virtualcolumnnodes include
* pointers to source resultsetnode, this, and source resultcolumn.)
*/
prrclist genvirtualcolumnnodes childresult  childresult getresultcolumns
/* resolve - we need to push single table predicates down so that
* they get applied while building the materializeresultset.
*/
/* finally, we create the new materializeresultsetnode */
mrsn    materializeresultsetnode  getnodefactory   getnode
c_nodetypes materialize_result_set_node
childresult
prrclist
tableproperties
getcontextmanager
// propagate the referenced table map if it's already been created
if  childresult getreferencedtablemap      null
mrsn setreferencedtablemap  jbitset  childresult getreferencedtablemap   clone
childresult   mrsn
return this
/**
* determine whether or not the specified name is an exposed name in
* the current query block.
*
* @param name	the specified name to search for as an exposed name.
* @param schemaname	schema name, if non-null.
* @param exactmatch	whether or not we need an exact match on specified schema and table
*						names or match on table id.
*
* @return the fromtable, if any, with the exposed name.
*
* @exception standardexception		thrown on error
*/
protected fromtable getfromtablebyname string name  string schemaname  boolean exactmatch
throws standardexception
return childresult getfromtablebyname name  schemaname  exactmatch
/**
* get the lock mode for the target of an update statement
* (a delete or update).  the update mode will always be row for
* currentofnodes.  it will be table if there is no where clause.
*
* @return	the lock mode
*/
public int updatetargetlockmode
if  restriction    null    constantrestriction    null
return transactioncontroller mode_record
else
return childresult updatetargetlockmode
/**
* is it possible to do a distinct scan on this resultset tree.
* (see selectnode for the criteria.)
*
* @param distinctcolumns the set of distinct columns
* @return whether or not it is possible to do a distinct scan on this resultset tree.
*/
boolean ispossibledistinctscan set distinctcolumns
if  restriction    null
restrictionlist    null    restrictionlist size      0
return false
hashset columns   new hashset
for  int i   0  i < resultcolumns size    i
resultcolumn rc    resultcolumn  resultcolumns elementat i
basecolumnnode bc   rc getbasecolumnnode
if  bc    null  return false
columns add bc
return columns equals distinctcolumns     childresult ispossibledistinctscan distinctcolumns
/**
* mark the underlying scan as a distinct scan.
*/
void markfordistinctscan
childresult markfordistinctscan
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
if  v skipchildren this
return v visit this
visitable returnnode   super accept v
if  restriction    null     v stoptraversal
restriction    valuenode restriction accept v
if  restrictionlist    null     v stoptraversal
restrictionlist    predicatelist restrictionlist accept v
return returnnode
/**
* set the information gathered from the parent table that is
* required to peform a referential action on dependent table.
*/
public void setrefactioninfo long fkindexconglomid
intfkcolarray
string parentresultsetid
boolean dependentscan
childresult setrefactioninfo fkindexconglomid
fkcolarray
parentresultsetid
dependentscan
public void setrestriction valuenode restriction
this restriction   restriction