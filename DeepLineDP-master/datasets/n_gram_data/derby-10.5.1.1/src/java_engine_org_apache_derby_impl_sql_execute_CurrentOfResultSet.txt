/*
derby - class org.apache.derby.impl.sql.execute.currentofresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi sql execute cursoractivation
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi sql preparedstatement
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi types rowlocation
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql depend dependencymanager
/**
* takes a cursor name and returns the current row
* of the cursor; for use in generating the source
* row and row location for positioned update/delete operations.
* <p>
* this result set returns only one row.
*
*/
class currentofresultset extends noputresultsetimpl
implements cursorresultset
private boolean next
private rowlocation rowlocation
private cursorresultset cursor
private cursorresultset target
private execrow			sparserow
// set in constructor and not altered during
// life of object.
private final string cursorname
//
// class interface
//
currentofresultset string cursorname  activation activation
int resultsetnumber
super activation  resultsetnumber  0 0d  0 0d
if  sanitymanager debug
sanitymanager assert  cursorname  null
this cursorname   cursorname
//
// resultset interface (leftover from noputresultset)
//
/**
* open a scan on the table. scan parameters are evaluated
* at each open, so there is probably some way of altering
* their values...
*
* @exception standardexception thrown on failure to open
*/
public void	opencore   throws standardexception
if  sanitymanager debug
sanitymanager assert    isopen
// get the cursor
getcursor
next   false
isopen   true
/**
* if open and not returned yet, returns the row.
*
* @exception standardexception thrown on failure.
*/
public execrow	getnextrowcore   throws standardexception
if   isopen
if     next
next   true
if  sanitymanager debug
sanitymanager assert   cursor isclosed
execrow cursorrow   cursor getcurrentrow
// requalify the current row
if  cursorrow    null
throw standardexception newexception sqlstate no_current_row
// we know it will be requested, may as well get it now.
rowlocation   cursor getrowlocation
// get the row from the base table, which is the real result
// row for the currentofresultset
currentrow   target getcurrentrow
// if the source result set is a scrollinsensitiveresultset, and
// the current row has been deleted (while the cursor was
// opened), the cursor result set (scroll insensitive) will
// return the cached row, while the target result set will
// return null (row has been deleted under owr feet).
if  rowlocation    null
cursorrow    null    currentrow    null
activation addwarning standardexception
newwarning sqlstate cursor_operation_conflict
return null
/* beetle 3865: updateable cursor using index.  if underlying is a covering
* index, target is a tablescanrs (instead of a indexrow2baserowrs) for the
* index scan.  but the problem is it returns a compact row in index key order.
* however the projectrestrictrs above us that sets up the old and new column
* values expects us to return a sparse row in heap order.  we have to do the
* wiring here, since we don't have indexrow2baserowrs to do this work.  this
* problem was not exposed before, because we never used index scan for updateable
* cursors.
*/
if  target instanceof tablescanresultset
tablescanresultset scan    tablescanresultset  target
if  scan indexcols    null    currentrow    null
currentrow   getsparserow currentrow  scan indexcols
/* if we are updating rows from cached rids, we should compare with forward-most
* scan key when deciding whether to add rid to hash table or not.
*/
tablescanresultset scan    tablescanresultset  activation getforupdateindexscan
if  scan    null
if  target instanceof indexrowtobaserowresultset
scan comparetolastkey     indexrowtobaserowresultset  target  currentrowprescanned
else if  target instanceof tablescanresultset
scan comparetolastkey     tablescanresultset  target  currentrowprescanned
// remind: verify the row is still there
// at present we get an ugly exception from the store,
// hopefully someday we can just do this:
//
// if (!rowlocation.rowexists())
//     throw standardexception.newexception(sqlstate.lang_no_current_row, cursorname);
else
currentrow   null
rowlocation   null
else
currentrow   null
rowlocation   null
setcurrentrow currentrow
return currentrow
/**
* return a sparse heap row, based on a compact index row.
*
* @param row		compact referenced index row
* @param indexcols	base column positions of index keys, signed with asc/desc info
*
* @return			a sparse heap row with referenced columns
*/
private execrow getsparserow execrow row  int indexcols  throws standardexception
int colpos
if  sparserow    null
int numcols   1
for  int i   0  i < indexcols length  i
colpos    indexcols > 0  ? indexcols    indexcols
if  colpos > numcols
numcols   colpos
sparserow   new valuerow numcols
for  int i   1  i <  indexcols length  i
colpos    indexcols > 0  ? indexcols    indexcols
sparserow setcolumn colpos  row getcolumn i
return sparserow
/**
* if the result set has been opened,
* close the open scan.
*
* @exception standardexception thrown on error
*/
public void	close   throws standardexception
if   isopen
// we don't want to keep around a pointer to the
// row ... so it can be thrown away.
// revisit: does this need to be in a finally
// block, to ensure that it is executed?
clearcurrentrow
next   false
super close
else
if  sanitymanager debug
sanitymanager debug
public void	finish   throws standardexception
finishandrts
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
/* resolve - runtimestats not implemented yet */
return 0
/**
* this result set has its row location from
* the last fetch done. if it is closed,
* a null is returned.
*
* @see cursorresultset
*
* @return the row location of the current row.
* @exception standardexception thrown on failure to get row location
*/
public rowlocation getrowlocation
return rowlocation
/**
* @see cursorresultset
*
* @return the last row returned by getnextrow.
*/
public execrow getcurrentrow
return currentrow
//
// class implementation
//
/**
because the positioned operation only gets one location
per execution, and the cursor could be completely different
for each execution (closed and reopened, perhaps), we
determine where caching the cursor could be applied.
<p>
when cached, we check if the cursor was closed'd,
and if so, throw it out and
see if there's one in the cache with our name.
*/
private void getcursor   throws standardexception
// need to look again if cursor was closed
if  cursor    null
if  cursor isclosed
cursor   null
target   null
if  cursor    null
languageconnectioncontext lcc   getlanguageconnectioncontext
cursoractivation cursoractivation   lcc lookupcursoractivation cursorname
if  cursoractivation    null
cursor   cursoractivation getcursorresultset
target   cursoractivation gettargetresultset
/* beetle 3865: updateable cursor using index. 2 way communication between
* update activation and cursor activation. cursor passes index scan to
* update and update passes heap conglom controller to cursor.
*/
activation setforupdateindexscan cursoractivation getforupdateindexscan
if  cursoractivation getheapconglomeratecontroller      null
cursoractivation getheapconglomeratecontroller   close
cursoractivation setheapconglomeratecontroller activation getheapconglomeratecontroller
if  cursor    null    cursor isclosed
throw standardexception newexception sqlstate lang_cursor_not_found  cursorname
/**
* @see noputresultset#updaterow
*/
public void updaterow  execrow row  throws standardexception
noputresultset cursor  updaterow row
/**
* @see noputresultset#markrowasdeleted
*/
public void markrowasdeleted   throws standardexception
noputresultset cursor  markrowasdeleted