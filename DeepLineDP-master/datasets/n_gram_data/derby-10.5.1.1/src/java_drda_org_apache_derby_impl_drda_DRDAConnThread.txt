/*
derby - class org.apache.derby.impl.drda.drdaconnthread
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl drda
import java io bytearrayinputstream
import java io bytearrayoutputstream
import java io inputstream
import java io outputstream
import java io inputstreamreader
import java io ioexception
import java io unsupportedencodingexception
import java math bigdecimal
import java sql callablestatement
import java sql connection
import java sql parametermetadata
import java sql preparedstatement
import java sql resultset
import java sql resultsetmetadata
import java sql sqlexception
import java sql sqlwarning
import java sql statement
import java sql types
import java util arraylist
import java util date
import java util properties
import java util vector
import org apache derby catalog systemprocedures
import org apache derby iapi error standardexception
import org apache derby iapi error exceptionseverity
import org apache derby iapi reference attribute
import org apache derby iapi reference drdaconstants
import org apache derby iapi reference jdbc30translation
import org apache derby iapi reference property
import org apache derby iapi reference sqlstate
import org apache derby iapi services info jvminfo
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi tools i18n localizedresource
import org apache derby iapi jdbc authenticationservice
import org apache derby iapi jdbc enginelob
import org apache derby iapi jdbc engineresultset
import org apache derby impl jdbc embedsqlexception
import org apache derby impl jdbc util
import org apache derby jdbc internaldriver
import org apache derby iapi jdbc enginepreparedstatement
/**
* this class translates drda protocol from an application requester to jdbc
* for derby and then translates the results from derby to drda
* for return to the application requester.
*/
class drdaconnthread extends thread
private static final string leftbrace
private static final string rightbrace
private static final byte null_value    byte 0xff
private static final string syntax_err
// manager level 3 constant.
private static final int mgrlvl_3   0x03
// manager level 4 constant.
private static final int mgrlvl_4   0x04
// manager level 5 constant.
private static final int mgrlvl_5   0x05
// manager level 6 constant.
private static final int mgrlvl_6   0x06
// manager level 7 constant.
private static final int mgrlvl_7   0x07
// commit or rollback uowdsp values
private static final int commit   1
private static final int rollback   2
protected ccsidmanager ccsidmanager   new ebcdicccsidmanager
private int correlationid
private inputstream sockis
private outputstream sockos
private ddmreader reader
private ddmwriter writer
private drdaxaprotocol xaproto
private static int  accrdb_required    codepoint rdbacccl
codepoint crrtkn
codepoint prdid
codepoint typdefnam
codepoint typdefovr
private static int max_required_len   5
private int currentrequiredlength   0
private int  required   new int
private networkservercontrolimpl server 			   server who created me
private session	session 	   information about the session
private long timeslice 				   time slice for this thread
private object timeslicesync   new object       sync object for updating time slice
private boolean logconnections 		   log connections to databases
private boolean	sendwarningsoncntqry   false 	   send warnings for select if true
private object logconnectionssync   new object       sync object for log connect
private boolean close 				   end this thread
private object closesync   new object   	   sync object for parent to close us down
private static headerprintwriter logstream
private apprequester apprequester 	   pointer to the application requester
// for the session being serviced
private database database  	   pointer to the current database
private int sqlamlevel 		   sqlam level   determines protocol
// drda diagnostic level, diaglvl0 by default
private byte diagnosticlevel    byte 0xf0
// manager processing
private vector unknownmanagers
private vector knownmanagers
private vector errormanagers
private vector errormanagerslevel
// database accessed failed
private sqlexception databaseaccessexception
// these fields are needed to feed back to jcc about a statement/procedure's pkgnamcsn
/** the value returned by the previous call to
* <code>parsepkgnamcsn()</code>. */
private pkgnamcsn prevpkgnamcsn   null
/** current rdb package name. */
private drdastring rdbnam   new drdastring ccsidmanager
/** current rdb collection identifier. */
private drdastring rdbcolid   new drdastring ccsidmanager
/** current rdb package identifier. */
private drdastring pkgid   new drdastring ccsidmanager
/** current rdb package consistency token. */
private drdastring pkgcnstkn   new drdastring ccsidmanager
/** current rdb package section number. */
private int pkgsn
private final static string timeout_statement
private int pendingstatementtimeout     < 0 means no pending timeout to set
// this flag is for an execute statement/procedure which actually returns a result set;
// do not commit the statement, otherwise result set is closed
// for decryption
private static decryptionmanager decryptionmanager
// public key generated by deffie-hellman algorithm, to be passed to the encrypter,
// as well as used to initialize the cipher
private byte mypublickey
// generated target seed to be used to generate the password substitute
// as part of secmec_usrssbpwd security mechanism
private byte mytargetseed
// some byte[] constants that are frequently written into messages. it is more efficient to
// use these constants than to convert from a string each time
// (this replaces the qryscraft_ and notqryscraft_ static exception objects.)
private static final byte eod00000
private static final byte eod02000
private static final byte nullsqlstate
private static final byte errd4_d6     0  0  0  0  0  0  0  0  0  0  0  0       12x0
private static final byte warn0_warna                                            11x
private final static string authentication_provider_builtin_class
private final static string authentication_provider_none_class
// work around a classloader bug involving interrupt handling during
// class loading. if the first request to load the
// drdaprotocolexceptioninfo class occurs during shutdown, the
// loading of the class may be aborted when the network server calls
// thread.interrupt() on the drdaconnthread. by including a static
// reference to the drdaprotocolexceptioninfo class here, we ensure
// that it is loaded as soon as the drdaconnthread class is loaded,
// and therefore we know we won't be trying to load the class during
// shutdown. see derby-1338 for more background, including pointers
// to the apparent classloader bug in the jvm.
private static final drdaprotocolexceptioninfo dummy
new drdaprotocolexceptioninfo 0 0 0 false
/**
* tells if the reset / connect request is a deferred request.
* this information is used to work around a bug (derby-3596) in a
* compatible manner, which also avoids any changes in the client driver.
* <p>
* the bug manifests itself when a connection pool data source is used and
* logical connections are obtained from the physical connection associated
* with the data source. each new logical connection causes a new physical
* connection on the server, including a new transaction. these connections
* and transactions are not closed / cleaned up.
*/
private boolean deferredreset   false
// constructor
/**
* create a new thread for processing session requests
*
* @param session session requesting processing
* @param server  server starting thread
* @param timeslice timeslice for thread
* @param logconnections
**/
drdaconnthread session session  networkservercontrolimpl server
long timeslice
boolean logconnections
super
// create a more meaningful name for this thread (but preserve its
// thread id from the default name).
networkservercontrolimpl setuniquethreadname this
this session   session
this server   server
this timeslice   timeslice
this logconnections   logconnections
this pendingstatementtimeout    1
initialize
/**
* main routine for thread, loops until the thread is closed
* gets a session, does work for the session
*/
public void run
if  sanitymanager debug
trace
session prevsession
while  closed
// get a new session
prevsession   session
session   server getnextsession session
if  session    null
close
if  closed
break
if  session    prevsession
initializeforsession
try
long timestart   system currenttimemillis
switch  session state
case session init
sessioninitialstate
if  session    null
break
// else fallthrough
case session attexc
case session secacc
case session chksec
long currenttimeslice
do
try
processcommands
catch  drdasockettimeoutexception ste
// just ignore the exception. this was
// a timeout on the read call in
// ddmreader.fill(), which will happen
// only when timeslice is set.
currenttimeslice   gettimeslice
while   currenttimeslice <  0
system currenttimemillis     timestart < currenttimeslice
break
default
// this is an error
agenterror     session state
catch  exception e
if  e instanceof drdaprotocolexception
drdaprotocolexception e  isdisconnectexception
// client went away - this is o.k. here
closesession
else
handleexception e
if  sanitymanager debug
trace
server removethread this
/**
* get input stream
*
* @return input stream
*/
protected inputstream getinputstream
return sockis
/**
* get output stream
*
* @return output stream
*/
protected outputstream getoutputstream
return sockos
/**
*  get ddmreader
* @return ddmreader for this thread
*/
protected ddmreader getreader
return reader
/**
* get  ddmwriter
* @return ddmwriter for this thread
*/
protected ddmwriter getwriter
return writer
/**
* get correlation id
*
* @return correlation id
*/
protected int getcorrelationid
return correlationid
/**
* get session we are working on
*
* @return session
*/
protected session getsession
return session
/**
* get database we are working on
*
* @return database
*/
protected database getdatabase
return database
/**
* get server
*
* @return server
*/
protected networkservercontrolimpl getserver
return server
/**
* get correlation token
*
* @return crrtkn
*/
protected byte getcrrtkn
if  database    null
return database crrtkn
return null
/**
* get database name
*
* @return database name
*/
protected string getdbname
if  database    null
return database dbname
return null
/**
* close drda  connection thread
*/
protected void close
synchronized  closesync
close   true
/**
* set logging of connections
*
* @param value value to set for logging connections
*/
protected void setlogconnections boolean value
synchronized logconnectionssync
logconnections   value
/**
* set time slice value
*
* @param value new value for time slice
*/
protected void settimeslice long value
synchronized timeslicesync
timeslice   value
/**
* indicate a communications failure
*
* @param arg1 - info about the communications failure
* @param arg2 - info about the communications failure
* @param arg3 - info about the communications failure
* @param arg4 - info about the communications failure
*
* @exception drdaprotocolexception  disconnect exception always thrown
*/
protected void markcommunicationsfailure string arg1  string arg2  string arg3
string arg4  throws drdaprotocolexception
markcommunicationsfailure null arg1 arg2 arg3  arg4
/**
* indicate a communications failure. log to derby.log
*
* @param e  - source exception that was thrown
* @param arg1 - info about the communications failure
* @param arg2 - info about the communications failure
* @param arg3 - info about the communications failure
* @param arg4 - info about the communications failure
*
* @exception drdaprotocolexception  disconnect exception always thrown
*/
protected void markcommunicationsfailure exception e  string arg1  string arg2  string arg3
string arg4  throws drdaprotocolexception
string dbname   null
if  database    null
dbname   database dbname
if  e    null
println2log dbname session drdaid  e getmessage
server consoleexceptionprinttrace e
object oa    arg1 arg2 arg3 arg4
throw drdaprotocolexception newdisconnectexception this oa
/**
* syntax error
*
* @param errcd		error code
* @param cparg  code point value
* @exception drdaprotocolexception
*/
protected  void throwsyntaxrm int errcd  int cparg
throws drdaprotocolexception
throw new
drdaprotocolexception drdaprotocolexception drda_proto_syntaxrm
this
cparg
errcd
/**
* agent error - something very bad happened
*
* @param msg	message describing error
*
* @exception drdaprotocolexception  newagenterror always thrown
*/
protected void agenterror string msg  throws drdaprotocolexception
string dbname   null
if  database    null
dbname   database dbname
throw drdaprotocolexception newagenterror this  codepoint svrcod_prmdmg
dbname  msg
/**
* missing code point
*
* @param codepoint  code point value
* @exception drdaprotocolexception
*/
protected void missingcodepoint int codepoint  throws drdaprotocolexception
throwsyntaxrm codepoint synerrcd_req_obj_not_found  codepoint
/**
* print a line to the db2j log
*
* @param dbname  database name
* @param drdaid	drda identifier
* @param msg	message
*/
protected static void println2log string dbname  string drdaid  string msg
if  logstream    null
logstream   monitor getstream
if  dbname    null
int endofname   dbname indexof
if  endofname     1
dbname   dbname substring 0  endofname
logstream printlnwithheader     dbname       drdaid       msg
/**
* write rdbnam
*
* @param rdbnam 	database name
* @exception drdaprotocolexception
*/
protected void writerdbnam string rdbnam
throws drdaprotocolexception
int len   rdbnam length
if  len < codepoint rdbnam_len
len   codepoint rdbnam_len
writer writescalarheader codepoint rdbnam  len
try
writer writescalarpaddedbytes rdbnam getbytes server default_encoding
len  server space_char
catch  unsupportedencodingexception e
agenterror
server default_encoding
/***************************************************************************
*                   private methods
***************************************************************************/
/**
* initialize class
*/
private void initialize
// set input and output sockets
// this needs to be done before creating reader
sockis   session sessioninput
sockos   session sessionoutput
reader   new ddmreader this  session dsstrace
writer   new ddmwriter ccsidmanager  this  session dsstrace
/**
* initialize for a new session
*/
private void initializeforsession
// set input and output sockets
sockis   session sessioninput
sockos   session sessionoutput
// intialize reader and writer
reader initialize this  session dsstrace
writer reset session dsstrace
// initialize local pointers to session info
database   session database
apprequester   session apprequester
// set sqlamlevel
if  session state    session attexc
sqlamlevel   apprequester getmanagerlevel codepoint sqlam
/**
* in initial state for a session,
* determine whether this is a command
* session or a drda protocol session.  a command session is for changing
* the configuration of the net server, e.g., turning tracing on
* if it is a command session, process the command and close the session.
* if it is a drda session, exchange server attributes and change session
* state.
*/
private void sessioninitialstate
throws exception
// process networkservercontrol commands - if it is not either valid protocol  let the
// drda error handling handle it
if  reader iscmd
try
server processcommands reader  writer  session
// reset reader and writer
reader initialize this  null
writer reset null
closesession
catch  throwable t
if  t instanceof interruptedexception
throw  interruptedexception t
else
server consoleexceptionprinttrace t
else
// exchange attributes with application requester
exchangeserverattributes
/**
* cleans up and closes a result set if an exception is thrown
* when collecting qrydta in response to opnqry or cntqry.
*
* @param stmt the drda statement to clean up
* @param sqle the exception that was thrown
* @param writermark start index for the first dss to clear from
* the output buffer
* @exception drdaprotocolexception if a drda protocol error is
* detected
*/
private void cleanupandcloseresultset drdastatement stmt
sqlexception sqle
int writermark
throws drdaprotocolexception
if  stmt    null
writer cleardssesbacktomark writermark
if   stmt rsisclosed
try
stmt rsclose
catch  sqlexception ec
if  sanitymanager debug
trace
writeabnuowrm
writesqlcard sqle  codepoint svrcod_error  0  0
else
writesqlcards sqle  0
errorinchain sqle
/**
* process drda commands we can receive once server attributes have been
* exchanged.
*
* @exception drdaprotocolexception
*/
private void processcommands   throws drdaprotocolexception
drdastatement stmt   null
int updatecount   0
boolean prpsqlsttfailed   false
boolean checksecuritycodepoint   session requiressecuritycodepoint
do
correlationid   reader readdssheader
int codepoint   reader readlengthandcodepoint  false
int writermark   writer markdssclearpoint
if  checksecuritycodepoint
verifyinorderaccsec_secchk codepoint session getrequiredsecuritycodepoint
switch codepoint
case codepoint cntqry
try
stmt   parsecntqry
if  stmt    null
writeqrydta stmt
if  stmt rsisclosed
writeendqryrm codepoint svrcod_warning
writenullsqlcardobject
// send any warnings if jcc can handle them
checkwarning null  null  stmt getresultset    0  false  sendwarningsoncntqry
writepbsd
catch sqlexception e
// if we got a sqlexception we need to clean up and
// close the result set beetle 4758
cleanupandcloseresultset stmt  e  writermark
break
case codepoint excsqlimm
try
updatecount   parseexcsqlimm
// resolve: checking updatecount is not sufficient
// since it will be 0 for creates, we need to know when
// any logged changes are made to the database
// not getting this right for jcc is probably o.k., this
// will probably be a problem for odbc and xa
// the problem is that jdbc doesn't provide this information
// so we would have to expand the jdbc api or call a
// builtin method to check(expensive)
// for now we will assume that every execute immediate
// does an update (that is the most conservative thing)
if  database rdbupdrm_sent    false
writerdbupdrm
// we need to set update count in sqlcard
checkwarning null  database getdefaultstatement   getstatement
null  updatecount  true  true
writepbsd
catch  sqlexception e
writer cleardssesbacktomark writermark
writesqlcards e  0
errorinchain e
break
case codepoint excsqlset
try
if  parseexcsqlset
// all went well.
writesqlcards null 0
catch  sqlwarning w
writesqlcard w  codepoint svrcod_warning  0  0
catch  sqlexception e
writer cleardssesbacktomark writermark
writesqlcards e  0
errorinchain e
break
case codepoint prpsqlstt
int sqldatype
prpsqlsttfailed   false
try
database getconnection   clearwarnings
sqldatype   parseprpsqlstt
if  sqldatype > 0 		   do write sqldard
writesqldard database getcurrentstatement
sqldatype     codepoint typsqlda_light_output
database getconnection   getwarnings
else
checkwarning database getconnection    null  null  0  true  true
catch  sqlexception e
writer cleardssesbacktomark writermark
writesqlcards e  0  true
prpsqlsttfailed   true
errorinchain e
break
case codepoint opnqry
preparedstatement ps   null
try
if  prpsqlsttfailed
// read the command objects
// for ps with parameter
// skip objects/parameters
skipremainder true
// if we failed to prepare, then we fail
// to open, which  means opnqflrm.
writeopnqflrm null
break
pkgnamcsn pkgnamcsn   parseopnqry
if  pkgnamcsn    null
stmt   database getdrdastatement pkgnamcsn
ps   stmt getpreparedstatement
ps clearwarnings
if  pendingstatementtimeout >  0
ps setquerytimeout pendingstatementtimeout
pendingstatementtimeout    1
stmt execute
writeopnqryrm false  stmt
checkwarning null  ps  null  0  false  true
writeqrydsc stmt  false
stmt rssuspend
if  stmt getqryprctyp      codepoint lmtblkprc
stmt getqryrowset      0
// the drda spec allows us to send
// qrydta here if there are no lob
// columns.
drdaresultset drdars
stmt getcurrentdrdaresultset
try
if  drdars    null
drdars haslobcolumns
writeqrydta stmt
catch  sqlexception sqle
cleanupandcloseresultset stmt  sqle
writermark
writepbsd
catch  sqlexception e
writer cleardssesbacktomark writermark
// the fix for derby-1196 removed code
// here to close the prepared statement
// if opnqry failed.
writeopnqflrm e
break
case codepoint rdbcmm
try
if  sanitymanager debug
trace
if   database getconnection   getautocommit
database getconnection   clearwarnings
database commit
writeenduowrm commit
checkwarning database getconnection    null  null  0  true  true
// we only want to write one of these per transaction
// so set to false in preparation for next command
database rdbupdrm_sent   false
catch  sqlexception e
writer cleardssesbacktomark writermark
// even in case of error, we have to write the enduowrm.
writeenduowrm commit
writesqlcards e  0
errorinchain e
break
case codepoint rdbrllbck
try
if  sanitymanager debug
trace
database getconnection   clearwarnings
database rollback
writeenduowrm rollback
checkwarning database getconnection    null  null  0  true  true
// we only want to write one of these per transaction
// so set to false in preparation for next command
database rdbupdrm_sent   false
catch  sqlexception e
writer cleardssesbacktomark writermark
// even in case of error, we have to write the enduowrm.
writeenduowrm rollback
writesqlcards e  0
errorinchain e
break
case codepoint clsqry
try
stmt   parseclsqry
stmt rsclose
writesqlcards null  0
catch  sqlexception e
writer cleardssesbacktomark writermark
writesqlcards e  0
errorinchain e
break
case codepoint excsat
parseexcsat
writeexcsatrd
break
case codepoint accsec
int securitycheckcode   parseaccsec
writeaccsecrd securitycheckcode
checksecuritycodepoint   true
break
case codepoint secchk
if parsedrdaconnection
// security all checked and connection ok
checksecuritycodepoint   false
break
/* since we don't support sqlj, we won't get bind commands from jcc, we
* might get it from ccc; just skip them.
*/
case codepoint bgnbnd
reader skipbytes
writesqlcards null  0
break
case codepoint bndsqlstt
reader skipbytes
parsesqlsttdss
writesqlcards null  0
break
case codepoint sqlsttvrb
// optional
reader skipbytes
break
case codepoint endbnd
reader skipbytes
writesqlcards null  0
break
case codepoint dscsqlstt
if  prpsqlsttfailed
reader skipbytes
writesqlcards null  0
break
try
boolean rtnoutput   parsedscsqlstt
writesqldard database getcurrentstatement    rtnoutput

catch  sqlexception e
writer cleardssesbacktomark writermark
server consoleexceptionprint e
try
writesqldard database getcurrentstatement    true  e
catch  sqlexception e2   	   should not get here since doing nothing with ps
agenterror
errorinchain e
break
case codepoint excsqlstt
if  prpsqlsttfailed
// skip parameters too if they are chained beetle 4867
skipremainder true
writesqlcards null  0
break
try
parseexcsqlstt
drdastatement curstmt   database getcurrentstatement
if  curstmt    null
curstmt rssuspend
writepbsd
catch  sqlexception e
skipremainder true
writer cleardssesbacktomark writermark
if  sanitymanager debug
server consoleexceptionprint e
writesqlcards e  0
errorinchain e
break
case codepoint syncctl
if  xaproto    null
xaproto   new drdaxaprotocol this
xaproto parsesyncctl
try
writepbsd
catch  sqlexception se
server consoleexceptionprint se
errorinchain se
break
default
codepointnotsupported codepoint
if  sanitymanager debug
string cpstr   new codepointnametable   lookup codepoint
try
piggybackedsessiondata pbsd
database getpiggybackedsessiondata false
// derby-3596
// don't perform this assert if a deferred reset is
// happening or has recently taken place, because the
// connection state has been changed under the feet of the
// piggy-backing mechanism.
if   this deferredreset    pbsd    null
// session data has already been piggy-backed. refresh
// the data from the connection, to make sure it has
// not changed behind our back.
pbsd refresh
sanitymanager assert  pbsd ismodified
pbsd
cpstr
// not having a pbsd here is ok. no data has been
// piggy-backed and the client has no cached values.
// if needed it will send an explicit request to get
// session data
catch  sqlexception sqle
server consoleexceptionprint sqle
sanitymanager throwassert
cpstr  sqle
// set the correct chaining bits for whatever
// reply dss(es) we just wrote.  if we've reached
// the end of the chain, this method will send
// the dss(es) across.
finalizechain
while  reader ischainedwithsameid      reader ischainedwithdiffid
/**
* if there's a severe error in the ddm chain, and if the header indicates
* "terminate chain on error", we stop processing further commands in the chain
* nor do we send any reply for them.  in accordance to this, a sqlerrrm message
* indicating the severe error must have been sent! (otherwise application requestor,
* such as jcc, would not terminate the receiving of chain replies.)
*
* each drda command is processed independently. drda defines no interdependencies
* across chained commands. a command is processed the same when received within
* a set of chained commands or received separately.  the chaining was originally
* defined as a way to save network costs.
*
* @param e		the sqlexception raised
* @exception	drdaprotocolexception
*/
private void errorinchain sqlexception e  throws drdaprotocolexception
if  reader terminatechainonerr       getexceptionseverity e  > codepoint svrcod_error
if  sanitymanager debug   trace
skipremainder false
/**
* exchange server attributes with application requester
*
* @exception drdaprotocolexception
*/
private void exchangeserverattributes
throws  drdaprotocolexception
int codepoint
correlationid   reader readdssheader
if  sanitymanager debug
if  correlationid    0
sanitymanager throwassert
correlationid
codepoint   reader readlengthandcodepoint  false
// the first code point in the exchange of attributes must be excsat
if  codepoint    codepoint excsat
//throw prccnvrm
throw
new drdaprotocolexception drdaprotocolexception drda_proto_prccnvrm
this  codepoint
codepoint prccnvcd_excsat_first_after_conn
parseexcsat
writeexcsatrd
finalizechain
session setstate session attexc
private boolean parsedrdaconnection   throws drdaprotocolexception
int codepoint
boolean sessionok   true
int securitycheckcode   parsesecchk
if  sanitymanager debug
trace   securitycheckcode
writesecchkrm securitycheckcode
//at this point if the security check failed, we're done, the session failed
if  securitycheckcode    0
return false
correlationid   reader readdssheader
codepoint   reader readlengthandcodepoint  false
verifyrequiredobject codepoint codepoint accrdb
int svrcod   parseaccrdb
//if network server gets a null connection form internaldriver, reply with
//rdbaflrm and sqlcard with null sqlexception
if database getconnection      null    databaseaccessexception    null
writerdbfailure codepoint rdbaflrm
return false
//if earlier we couldn't access the database
if  databaseaccessexception    null
//if the database was not found we will try ds
int failuretype   getrdbaccesserrorcodepoint
if  failuretype    codepoint rdbnfnrm
failuretype    codepoint rdbathrm
writerdbfailure failuretype
else
writerdbfailure codepoint rdbaflrm
return false
else if  database accesscount > 1  	   already in conversation with database
writerdbfailure codepoint rdbaccrm
return false
else    everything is fine
writeaccrdbrm svrcod
// compare this application requester with previously stored
// application requesters and if we have already seen this one
// use stored application requester
session apprequester   server getapprequester apprequester
return sessionok
/**
* write rdb failure
*
* instance variables
* 	svrcod - severity code - required
*	rdbnam - relational database name - required
*  srvdgn - server diagnostics - optional (not sent for now)
*
* @param	codepoint	codepoint of failure
*/
private void writerdbfailure int codepoint  throws drdaprotocolexception
writer createdssreply
writer startddm codepoint
writer writescalar2bytes codepoint svrcod  codepoint svrcod_error
writerdbnam database dbname
writer endddmanddss
switch codepoint
case codepoint rdbaflrm
//rdbaflrm requires typdefnam and typdefovr
writer createdssobject
writer writescalarstring codepoint typdefnam
codepoint typdefnam_qtdsqlasc
writetypdefovr
writer enddss
case codepoint rdbnfnrm
case codepoint rdbathrm
writesqlcard databaseaccessexception codepoint svrcod_error 0 0
case codepoint rdbaccrm
//ignore anything that was chained to the accrdb.
skipremainder false
// finalize chain state for whatever we wrote in
// response to accrdb.
finalizechain
break
/* check the database access exception and return the appropriate
error codepoint.
rdbnfnrm - database not found
rdbathrm - not authorized
rdbaflrm - access failure
@return rdb access codepoint
*/
private int getrdbaccesserrorcodepoint
string sqlstate   databaseaccessexception getsqlstate
// these tests are ok since database_not_found and
// auth_invalid_user_name are not ambigious error codes (on the first
// five characters) in sqlstate. if they were, we would have to
// perform a similar check as done in method isauthenticationexception
if  sqlstate regionmatches 0 sqlstate database_not_found 0 5
// rdb not found codepoint
return codepoint rdbnfnrm
else
if  isauthenticationexception databaseaccessexception
sqlstate regionmatches 0 sqlstate auth_invalid_user_name 0 5
// not authorized to rdb reply message codepoint
return codepoint rdbathrm
else
// rdb access failed reply message codepoint
return codepoint rdbaflrm
/**
* there are multiple reasons for not getting a connection, and
* all these should throw sqlexceptions with sql state 08004
* according to the sql standard. since only one of these sql
* states indicate that an authentication error has occurred, it
* is not enough to check that the sql state is 08004 and conclude
* that authentication caused the exception to be thrown.
*
* this method tries to cast the exception to an embedsqlexception
* and use getmessageid on that object to check for authentication
* error instead of the sql state we get from
* sqlexceptions#getsqlstate. getmessageid returns the entire id
* as defined in sqlstate (e.g. 08004.c.1), while getsqlstate only
* return the 5 first characters (i.e. 08004 instead of 08004.c.1)
*
* if the cast to embedsqlexception is not successful, the
* assumption that sql state 08004 is caused by an authentication
* failure is followed even though this is not correct. this was
* the pre derby-3060 way of solving the issue.
*
* @param sqlexception the exception that is checked to see if
* this is really caused by an authentication failure
* @return true if sqlexception is (or has to be assumed to be)
* caused by an authentication failure, false otherwise.
* @see sqlstate
*/
private boolean isauthenticationexception  sqlexception sqlexception
boolean authfail   false
// get exception which carries derby messageid and args
sqlexception se   util getexceptionfactory
getargumentferry sqlexception
if  se instanceof embedsqlexception
// derby-3060: if this is an embedsqlexception, we can
// check the messageid to find out what caused the
// exception.
string msgid     embedsqlexception se  getmessageid
// of the 08004.c.x messages, only
// sqlstate.net_connect_auth_failed is an authentication
// exception
if  msgid equals sqlstate net_connect_auth_failed
authfail   true
else
string sqlstate   se getsqlstate
if  sqlstate regionmatches 0 sqlstate login_failed 0 5
// unchanged by derby-3060: this is not an
// embedsqlexception, so we cannot check the
// messageid. as before derby-3060, we assume that all
// 08004 error codes are due to an authentication
// failure, even though this ambigious
authfail   true
return authfail
/**
* verify userid and password
*
* username and password is verified by making a connection to the
* database
*
* @return security check code, 0 is o.k.
* @exception drdaprotocolexception
*/
private int verifyuseridpassword   throws drdaprotocolexception
databaseaccessexception   null
int retsecchkcode   0
string realname   database dbname    first strip off properties
int endofname   realname indexof
if  endofname     1
realname   realname substring 0  endofname
retsecchkcode   getconnfromdatabasename
return retsecchkcode
/**
* get connection from a database name
*
* username and password is verified by making a connection to the
* database
*
* @return security check code, 0 is o.k.
* @exception drdaprotocolexception
*/
private int getconnfromdatabasename   throws drdaprotocolexception
properties p   new properties
databaseaccessexception   null
//if we haven't got the correlation token yet, use session number for drdaid
if  session drdaid    null
session drdaid   leftbrace   session connnum   rightbrace
p put attribute drdaid_attr  session drdaid
// we pass extra property information for the authentication provider
// to successfully re-compute the substitute (hashed) password and
// compare it with what we've got from the requester (source).
//
// if a password attribute appears as part of the connection url
// attributes, we then don't use the substitute hashed password
// to authenticate with the engine _as_ the one (if any) as part
// of the connection url attributes, will be used to authenticate
// against derby's built-in authentication provider - as a reminder,
// derby allows password to be mentioned as part of the connection
// url attributes, as this extra capability could be useful to pass
// passwords to external authentication providers for derby; hence
// a password defined as part of the connection url attributes cannot
// be substituted (single-hashed) as it is not recoverable.
if   database securitymechanism    codepoint secmec_usrssbpwd
database dbname indexof attribute password_attr      1
p put attribute drda_secmec
string valueof database securitymechanism
p put attribute drda_sectkn_in
decryptionmanager tohexstring database sectokenin  0
database sectokenin length
p put attribute drda_sectkn_out
decryptionmanager tohexstring database sectokenout  0
database sectokenout length
try
database makeconnection p
catch  sqlexception se
string sqlstate   se getsqlstate
databaseaccessexception   se
for    se    null  se   se getnextexception
if  sanitymanager debug
trace se getmessage
println2log database dbname  session drdaid  se getmessage
if  isauthenticationexception databaseaccessexception
// need to set the security check code based on the
// reason the connection was denied, derby doesn't say
// whether the userid or password caused the problem,
// so we will just return userid invalid
return codepoint secchkcd_useridinvalid
else
return 0
catch  exception e
// if derby has shut down for some reason,
// we will send  an agent error and then try to
// get the driver loaded again.  we have to get
// rid of the client first in case they are holding
// the drivermanager lock.
println2log database dbname  session drdaid
e getmessage
try
agenterror
catch  drdaprotocolexception dpe
// retry starting the server before rethrowing
// the protocol exception.  then hopfully all
// will be well when they try again.
try
server startnetworkserver
catch  exception re
println2log database dbname  session drdaid     re getmessage
throw dpe
// everything worked so log connection to the database.
if  getlogconnections
println2log database dbname  session drdaid
database dbname
return 0
/**
* parses excsat (exchange server attributes)
* instance variables
*	extnam(external name)	- optional
*  mgrlvlls(manager levels) - optional
*	spvnam(supervisor name) - optional
*  srvclsnm(server class name) - optional
*  srvnam(server name) - optional, ignorable
*  srvrlslv(server product release level) - optional, ignorable
*
* @exception drdaprotocolexception
*/
private void parseexcsat   throws drdaprotocolexception
int codepoint
string strval
// there are three kinds of excsat's we might get.
// 1) initial exchange attributes.
//    for this we need to initialize the apprequester.
//    session state is set to attexc and then the ar must
//    follow up with accsec and secchk to get the connection.
//  2) send of excsat as ping or mangager level adjustment.
//     (see parseexcsat2())
//     for this we just ignore the excsat objects that
//     are already set.
//  3) send of excsat for connection reset. (see parseexcsat2())
//     this is treated just like ping and will be followed up
//     by an accsec request if in fact it is a connection reset.
// if we have already exchanged attributes once just
// process any new manager levels and return (case 2 and 3 above)
this deferredreset   false     always reset  only set to true below
if  apprequester    null
// derby-3596
// don't mess with xa requests, as the logic for these are handled
// by the server side (embedded) objects. note that xa requests
// results in a different database object implementation, and it
// does not have the bug we are working around.
if   apprequester isxarequester
this deferredreset   true     non xa deferred reset detected
parseexcsat2
return
// set up a new application requester to store information about the
// application requester for this session
apprequester   new apprequester
reader markcollection
codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
// optional
case codepoint extnam
apprequester extnam   reader readstring
if  sanitymanager debug
trace     apprequester extnam
if  apprequester extnam length   > codepoint max_name
toobig codepoint extnam
break
// optional
case codepoint mgrlvlls
parsemgrlvlls 1
break
// optional
case codepoint spvnam
apprequester spvnam   reader readstring
// this is specified as a null parameter so length should
// be zero
if  apprequester spvnam    null
badobjectlength codepoint spvnam
break
// optional
case codepoint srvnam
apprequester srvnam   reader readstring
if  sanitymanager debug
trace      apprequester srvnam
if  apprequester srvnam length   > codepoint max_name
toobig codepoint srvnam
break
// optional
case codepoint srvrlslv
apprequester srvrlslv   reader readstring
if  sanitymanager debug
trace     apprequester srvrlslv
if  apprequester srvrlslv length   > codepoint max_name
toobig codepoint srvrlslv
break
// optional
case codepoint srvclsnm
apprequester srvclsnm   reader readstring
if  sanitymanager debug
trace     apprequester srvclsnm
if  apprequester srvclsnm length   > codepoint max_name
toobig codepoint srvclsnm
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
/**
* parses excsat2 (exchange server attributes)
* instance variables
*	extnam(external name)	- optional
*  mgrlvlls(manager levels) - optional
*	spvnam(supervisor name) - optional
*  srvclsnm(server class name) - optional
*  srvnam(server name) - optional, ignorable
*  srvrlslv(server product release level) - optional, ignorable
*
* @exception drdaprotocolexception
*
* this parses a second occurrence of an excsat command
* the target must ignore the values for extnam, srvclsnm, srvnam and srvrlslv.
* i am also going to ignore spvnam since it should be null anyway.
* only new managers can be added.
*/
private void parseexcsat2   throws drdaprotocolexception
int codepoint
reader markcollection
codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
// optional
case codepoint extnam
case codepoint srvnam
case codepoint srvrlslv
case codepoint srvclsnm
case codepoint spvnam
reader skipbytes
break
// optional
case codepoint mgrlvlls
parsemgrlvlls 2
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
/**
*	parse manager levels
*  instance variables
*		mgrlvl - repeatable, required
*		  codepoint
*			ccsidmgr - ccsid manager
*			cmnappc - lu 6.2 conversational communications manager
*			cmnsyncpt - sna lu 6.2 syncpoint conversational communications manager
*			cmntcpip - tcp/ip communication manager
*			dictionary - dictionary
*			rdb - relational database
*			rsyncmgr - resynchronization manager
*			secmgr - security manager
*			sqlam - sql application manager
*			supervisor - supervisor
*			syncptmgr - sync point manager
*		  value
*
*	on the second appearance of this codepoint, it can only add managers
*
* @param time	1 for first time this is seen, 2 for subsequent ones
* @exception drdaprotocolexception
*
*/
private void parsemgrlvlls int time  throws drdaprotocolexception
int manager  managerlevel
int currentlevel
// set up vectors to keep track of manager information
unknownmanagers   new vector
knownmanagers   new vector
errormanagers   new vector
errormanagerslevel   new vector
if  sanitymanager debug
trace
while  reader moreddmdata
manager   reader readnetworkshort
managerlevel   reader readnetworkshort
if  codepoint isknownmanager manager
knownmanagers addelement new integer manager
//if the manager level hasn't been set, set it
currentlevel   apprequester getmanagerlevel manager
if  currentlevel    apprequester mgr_level_unknown
apprequester setmanagerlevel manager  managerlevel
else
//if the level is still the same we'll ignore it
if  currentlevel    managerlevel
//keep a list of conflicting managers
errormanagers addelement new integer manager
errormanagerslevel addelement new integer  managerlevel
else
unknownmanagers addelement new integer manager
if  sanitymanager debug
trace     java lang integer tohexstring manager
managerlevel
sqlamlevel   apprequester getmanagerlevel codepoint sqlam
// did we have any errors
if  errormanagers size   > 0
object  oa   new object
int j   0
for  int i   0  i < errormanagers size    i
oa   errormanagers elementat i
oa   errormanagerslevel elementat i
throw new drdaprotocolexception drdaprotocolexception drda_proto_mgrlvlrm
this  0
0  oa
/**
* write reply to excsat command
* instance variables
*	extnam - external name (optional)
*  mgrlvlls - manager level list (optional)
*  srvclsnm - server class name (optional) - used by jcc
*  srvnam - server name (optional)
*  srvrlslv - server product release level (optional)
*
* @exception drdaprotocolexception
*/
private void writeexcsatrd   throws drdaprotocolexception
writer createdssreply
writer startddm codepoint excsatrd
writer writescalarstring codepoint extnam  server att_extnam
//only reply with manager levels if we got sent some
if  knownmanagers    null    knownmanagers size   > 0
writemgrlevels
writer writescalarstring codepoint srvclsnm  server att_srvclsnm
writer writescalarstring codepoint srvnam  server att_srvnam
writer writescalarstring codepoint srvrlslv  server att_srvrlslv
writer endddmanddss
/**
* write manager levels
* the target server must not provide information for any target
* managers unless the source explicitly requests it.
* for each manager class, if the target server's support level
* is greater than or equal to the source server's level, then the source
* server's level is returned for that class if the target server can operate
* at the source's level; otherwise a level 0 is returned.  if the target
* server's support level is less than the source server's level, the
* target server's level is returned for that class.  if the target server
* does not recognize the code point of a manager class or does not support
* that class, it returns a level of 0.  the target server then waits
* for the next command or for the source server to terminate communications.
* when the source server receives excsatrd, it must compare each of the entries
* in the mgrlvlls parameter it received to the corresponding entries in the mgrlvlls
* parameter it sent.  if any level mismatches, the source server must decide
* whether it can use or adjust to the lower level of target support for that manager
* class.  there are no architectural criteria for making this decision.
* the source server can terminate communications or continue at the target
* servers level of support.  it can also attempt to use whatever
* commands its user requests while receiving error reply messages for real
* functional mismatches.
* the manager levels the source server specifies or the target server
* returns must be compatible with the manager-level dependencies of the specified
* manangers.  incompatible manager levels cannot be specified.
*  instance variables
*		mgrlvl - repeatable, required
*		  codepoint
*			ccsidmgr - ccsid manager
*			cmnappc - lu 6.2 conversational communications manager
*			cmnsyncpt - sna lu 6.2 syncpoint conversational communications manager
*			cmntcpip - tcp/ip communication manager
*			dictionary - dictionary
*			rdb - relational database
*			rsyncmgr - resynchronization manager
*			secmgr - security manager
*			sqlam - sql application manager
*			supervisor - supervisor
*			syncptmgr - sync point manager
*			xamgr - xa manager
*		  value
*/
private void writemgrlevels   throws drdaprotocolexception
int manager
int applevel
int serverlevel
writer startddm codepoint mgrlvlls
for  int i   0  i < knownmanagers size    i
manager     integer knownmanagers elementat i   intvalue
applevel   apprequester getmanagerlevel manager
serverlevel   server getmanagerlevel manager
if  serverlevel >  applevel
//note applevel has already been set to 0 if we can't support
//the original app level
writer writecodepoint4bytes manager  applevel
else
writer writecodepoint4bytes manager  serverlevel
// reset application manager level to server level
apprequester setmanagerlevel manager  serverlevel
// write 0 for all unknown managers
for  int i   0  i < unknownmanagers size    i
manager     integer unknownmanagers elementat i   intvalue
writer writecodepoint4bytes manager  0
writer endddm
/**
*  parse access security
*
*	if the target server supports the secmec requested by the application requester
*	then a single value is returned and it is identical to the secmec value
*	in the accsec command. if the target server does not support the secmec
*	requested, then one or more values are returned and the application requester
*  must choose one of these values for the security mechanism.
*  we currently support
*		- user id and password (default for jcc)
*		- encrypted user id and password
*      - strong password substitute (usrssbpwd w/
*                                    derby network client only)
*
*  instance variables
*    secmgrnm  - security manager name - optional
*	  secmec 	- security mechanism - required
*	  rdbnam	- relational database name - optional
* 	  sectkn	- security token - optional, (required if sec mech. needs it)
*
*  @return security check code - 0 if everything o.k.
*/
private int parseaccsec   throws  drdaprotocolexception
int securitycheckcode   0
int securitymechanism   0
byte  sectokenin   null
reader markcollection
int codepoint   reader getcodepoint
while  codepoint     1
switch codepoint
//optional
case codepoint secmgrnm
// this is defined to be 0 length
if  reader getddmlength      0
badobjectlength codepoint secmgrnm
break
//required
case codepoint secmec
checklength codepoint secmec  2
securitymechanism   reader readnetworkshort
if  sanitymanager debug
trace     securitymechanism
// if property.drda_prop_securitymechanism has been set, then
// network server only accepts connections which use that
// security mechanism. no other types of connections
// are accepted.
// make check to see if this property has been set.
// if set, and if the client requested security mechanism
// is not the same, then return a security check code
// that the server does not support/allow this security
// mechanism
if    server getsecuritymechanism
networkservercontrolimpl invalid_or_notset_securitymechanism
securitymechanism    server getsecuritymechanism
securitycheckcode   codepoint secchkcd_notsupported
if  sanitymanager debug
trace
securitymechanism
server getsecuritymechanism
else
// for plain text userid,password usridpwd, and usridonl
// no need of decryptionmanager
if  securitymechanism    codepoint secmec_usridpwd
securitymechanism    codepoint secmec_usridonl
// these are the only other mechanisms we understand
if    securitymechanism    codepoint secmec_eusridpwd
securitymechanism    codepoint secmec_eusridpwd
server supportseusridpwd
securitymechanism
codepoint secmec_usrssbpwd
//securitycheckcode = codepoint.secchkcd_notsupported;
securitycheckcode   codepoint secchkcd_notsupported
if  sanitymanager debug
trace
else
// we delay the initialization and required
// processing for secmec_usrssbpwd as we need
// to ensure the database is booted so that
// we can verify that the current auth scheme
// is set to built-in or none. for this we need
// to have the rdbnam codepoint available.
//
// see validatesecmecusrssbpwd() call below
if  securitymechanism
codepoint secmec_usrssbpwd
break
// secmec_eusridpwd initialization
try
if  decryptionmanager    null
decryptionmanager   new decryptionmanager
mypublickey   decryptionmanager obtainpublickey
catch  sqlexception e
println2log null  session drdaid  e getmessage
// local security service non-retryable error.
securitycheckcode   codepoint secchkcd_0a
break
//optional (currently required for derby - needed for
//          derby-528 as well)
case codepoint rdbnam
string dbname   parserdbnam
database d   session getdatabase dbname
if  d    null
initializedatabase dbname
else
// reset database for connection re-use
// derby-3596
// if we are reusing resources for a new physical
// connection, reset the database object. if the client
// is in the process of creating a new logical
// connection only, don't reset the database object.
if   deferredreset
d reset
database   d
break
//optional - depending on security mechanism
case codepoint sectkn
sectokenin   reader readbytes
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
// check for required codepoint's
if  securitymechanism    0
missingcodepoint codepoint secmec
if  database    null
initializedatabase null
database securitymechanism   securitymechanism
database sectokenin   sectokenin
// if security mechanism is secmec_usrssbpwd, then ensure it can be
// used for the database or system based on the client's connection
// url and its identity.
if  securitycheckcode    0
database securitymechanism    codepoint secmec_usrssbpwd
if  sanitymanager debug
sanitymanager assert  securitycheckcode    0
securitycheckcode
securitycheckcode   validatesecmecusrssbpwd
// need security token
if  securitycheckcode    0
database securitymechanism    codepoint secmec_eusridpwd
database securitymechanism    codepoint secmec_usrssbpwd
database sectokenin    null
securitycheckcode   codepoint secchkcd_sectknmissing_or_invalid
// shouldn't have security token
if  securitycheckcode    0
database securitymechanism    codepoint secmec_usridpwd
database securitymechanism    codepoint secmec_usridonl
database sectokenin    null
securitycheckcode   codepoint secchkcd_sectknmissing_or_invalid
if  sanitymanager debug
trace     securitycheckcode
// if the security check was successful set the session state to
// security accesseed.  otherwise go back to attributes exchanged so we
// require another accsec
if  securitycheckcode    0
session setstate session secacc
else
session setstate session attexc
return securitycheckcode
/**
* parse opnqry
* instance variables
*  rdbnam - relational database name - optional
*  pkgnamcsn - rdb package name, consistency token and section number - required
*  qryblksz - query block size - required
*  qryblkctl - query block protocol control - optional
*  maxblkext - maximum number of extra blocks - optional - default value 0
*  outovropt - output override option
*  qryrowset - query rowset size - optional - level 7
*  monitor - monitor events - optional.
*
* @return rdb package name, consistency token, and section number
* @exception drdaprotocolexception
*/
private pkgnamcsn parseopnqry   throws drdaprotocolexception  sqlexception
pkgnamcsn pkgnamcsn   null
boolean gotqryblksz   false
int blksize   0
int qryblkctl   codepoint qryblkctl_default
int maxblkext   codepoint maxblkext_default
int qryrowset   codepoint qryrowset_default
int qryclsimp   drdaresultset qryclsimp_default
int outovropt   codepoint outovrfrs
reader markcollection
int codepoint   reader getcodepoint
while  codepoint     1
switch codepoint
//optional
case codepoint rdbnam
setdatabase codepoint opnqry
break
//required
case codepoint pkgnamcsn
pkgnamcsn   parsepkgnamcsn
break
//required
case codepoint qryblksz
blksize   parseqryblksz
gotqryblksz   true
break
//optional
case codepoint qryblkctl
qryblkctl   reader readnetworkshort
//the only type of query block control we can specify here
//is forced fixed row
if  qryblkctl    codepoint frcfixrow
invalidcodepoint qryblkctl
if  sanitymanager debug
trace   integer tohexstring qryblkctl
gotqryblksz   true
break
//optional
case codepoint maxblkext
maxblkext   reader readsignednetworkshort
if  sanitymanager debug
trace   maxblkext
break
// optional
case codepoint outovropt
outovropt   parseoutovropt
break
//optional
case codepoint qryrowset
//note minimum for opnqry is 0
qryrowset   parseqryrowset 0
break
case codepoint qryclsimp
// implicitly close non-scrollable cursor
qryclsimp   parseqryclsimp
break
case codepoint qryclsrls
// ignore release of read locks.  nothing we can do here
parseqryclsrls
break
// optional
case codepoint monitor
parsemonitor
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
// check for required variables
if  pkgnamcsn    null
missingcodepoint codepoint pkgnamcsn
if   gotqryblksz
missingcodepoint codepoint qryblksz
// get the statement we are opening
drdastatement stmt   database getdrdastatement pkgnamcsn
if  stmt    null
//xxx should really throw a sql exception here
invalidvalue codepoint pkgnamcsn
// check that this statement is not already open
// commenting this check out for now
// it turns out that jcc doesn't send a close if executequery is
// done again without closing the previous result set
// this check can't be done since the second executequery should work
//if (stmt.state != drdastatement.not_opened)
//{
//	writeqrypoprm();
//	pkgnamcsn = null;
//}
//else
//{
stmt setopnqryoptions blksize qryblkctl maxblkext outovropt
qryrowset  qryclsimp
//}
// read the command objects
// for ps with parameter
if  reader ischainedwithsameid
if  sanitymanager debug
trace
parseopnqryobjects stmt
return pkgnamcsn
/**
* parse opnqry objects
* objects
*  typdefnam - data type definition name - optional
*  typdefovr - type defintion overrides - optional
*  sqldta- sql program variable data - optional
*
* if typdefnam and typdefovr are supplied, they apply to the objects
* sent with the statement.  once the statement is over, the default values
* sent in the accrdb are once again in effect.  if no values are supplied,
* the values sent in the accrdb are used.
* objects may follow in one dss or in several dss chained together.
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void parseopnqryobjects drdastatement stmt
throws drdaprotocolexception  sqlexception
int codepoint
do
correlationid   reader readdssheader
while  reader moredssdata
codepoint   reader readlengthandcodepoint  false
switch codepoint
// optional
case codepoint typdefnam
setstmtordbbyteorder false  stmt  parsetypdefnam
break
// optional
case codepoint typdefovr
parsetypdefovr stmt
break
// optional
case codepoint sqldta
parsesqldta stmt
break
// optional
case codepoint extdta
readandsetallextparams stmt  false
break
default
invalidcodepoint codepoint
while  reader ischainedwithsameid
/**
* parse outovropt - this indicates whether output description can be
* overridden on just the first cntqry or on any cntqry
*
* @return output override option
* @exception drdaprotocolexception
*/
private int parseoutovropt   throws drdaprotocolexception
checklength codepoint outovropt  1
int outovropt   reader readunsignedbyte
if  sanitymanager debug
trace   outovropt
if  outovropt    codepoint outovrfrs    outovropt    codepoint outovrany
invalidvalue codepoint outovropt
return outovropt
/**
* parse qryblsz - this gives the maximum size of the query blocks that
* can be returned to the requester
*
* @return query block size
* @exception drdaprotocolexception
*/
private int parseqryblksz   throws drdaprotocolexception
checklength codepoint qryblksz  4
int blksize   reader readnetworkint
if  sanitymanager debug
trace   blksize
if  blksize < codepoint qryblksz_min    blksize > codepoint qryblksz_max
invalidvalue codepoint qryblksz
return blksize
/**
* parse qryrowset - this is the number of rows to return
*
* @param minval - minimum value
* @return query row set size
* @exception drdaprotocolexception
*/
private int parseqryrowset int minval  throws drdaprotocolexception
checklength codepoint qryrowset  4
int qryrowset   reader readnetworkint
if  sanitymanager debug
trace     qryrowset
if  qryrowset < minval    qryrowset > codepoint qryrowset_max
invalidvalue codepoint qryrowset
return qryrowset
/** parse a qryclsimp - implicitly close non-scrollable cursor
* after end of data.
* @return  true to close on end of data
*/
private int  parseqryclsimp   throws drdaprotocolexception
checklength codepoint qryclsimp  1
int qryclsimp   reader readunsignedbyte
if  sanitymanager debug
trace      qryclsimp
if  qryclsimp    codepoint qryclsimp_server_choice
qryclsimp    codepoint qryclsimp_yes
qryclsimp    codepoint qryclsimp_no
invalidvalue codepoint qryclsimp
return qryclsimp
private int parseqryclsrls   throws drdaprotocolexception
reader skipbytes
return 0
/**
* write a qrypoprm - query previously opened
* instance variables
*  svrcod - severity code - required - 8 error
*  rdbnam - relational database name - required
*  pkgnamcsn - rdb package name, consistency token, and section number - required
*
* @exception drdaprotocolexception
*/
private void writeqrypoprm   throws drdaprotocolexception
writer createdssreply
writer startddm codepoint qrypoprm
writer writescalar2bytes codepoint svrcod  codepoint svrcod_error
writerdbnam database dbname
writepkgnamcsn
writer endddmanddss
/**
* write a qrynoprm - query not opened
* instance variables
*  svrcod - severity code - required -  4 warning 8 error
*  rdbnam - relational database name - required
*  pkgnamcsn - rdb package name, consistency token, and section number - required
*
* @param svrcod	severity code
* @exception drdaprotocolexception
*/
private void writeqrynoprm int svrcod  throws drdaprotocolexception
writer createdssreply
writer startddm codepoint qrynoprm
writer writescalar2bytes codepoint svrcod  svrcod
writerdbnam database dbname
writepkgnamcsn
writer endddmanddss
/**
* write a opnqflrm - open query failure
* instance variables
*  svrcod - severity code - required - 8 error
*  rdbnam - relational database name - required
*
* @param	e	exception describing failure
*
* @exception drdaprotocolexception
*/
private void writeopnqflrm sqlexception e  throws drdaprotocolexception
writer createdssreply
writer startddm codepoint opnqflrm
writer writescalar2bytes codepoint svrcod  codepoint svrcod_error
writerdbnam database dbname
writer endddm
writer startddm codepoint sqlcard
writesqlcagrp e  getsqlcode getexceptionseverity e    0  0
writer endddmanddss
/**
* write pkgnamcsn
* instance variables
*   namesymdr - database name - not validated
*   rdbcolid - rdb collection identifier
*   pkgid - rdb package identifier
*   pkgcnstkn - rdb package consistency token
*   pkgsn - rdb package section number
*
* there are two possible formats, fixed and extended which includes length
* information for the strings
*
* @throws drdaprotocolexception
*/
private void writepkgnamcsn byte pkgcnstkn  throws drdaprotocolexception
writer startddm codepoint pkgnamcsn
if  rdbnam length   <  codepoint rdbnam_len
rdbcolid length   <  codepoint rdbcolid_len
pkgid length   <  codepoint pkgid_len
if none of rdbnam  rdbcolid and pkgid have a length of
// more than 18, use fixed format
writer writescalarpaddedstring rdbnam  codepoint rdbnam_len
writer writescalarpaddedstring rdbcolid  codepoint rdbcolid_len
writer writescalarpaddedstring pkgid  codepoint pkgid_len
writer writescalarpaddedbytes pkgcnstkn
codepoint pkgcnstkn_len   byte  0
writer writeshort pkgsn
else	   extended format
int len   math max codepoint rdbnam_len  rdbnam length
writer writeshort len
writer writescalarpaddedstring rdbnam  len
len   math max codepoint rdbcolid_len  rdbcolid length
writer writeshort len
writer writescalarpaddedstring rdbcolid  len
len   math max codepoint pkgid_len  pkgid length
writer writeshort len
writer writescalarpaddedstring pkgid  len
writer writescalarpaddedbytes pkgcnstkn
codepoint pkgcnstkn_len   byte  0
writer writeshort pkgsn
writer endddm
private void writepkgnamcsn   throws drdaprotocolexception
writepkgnamcsn pkgcnstkn getbytes
/**
* parse cntqry - continue query
* instance variables
*   rdbnam - relational database name - optional
*   pkgnamcsn - rdb package name, consistency token, and section number - required
*   qryblksz - query block size - required
*   qryrelscr - query relative scrolling action - optional
*   qryscrorn - query scroll orientation - optional - level 7
*   qryrownbr - query row number - optional
*   qryrowsns - query row sensitivity - optional - level 7
*   qryblkrst - query block reset - optional - level 7
*   qryrtndta - query returns data - optional - level 7
*   qryrowset - query rowset size - optional - level 7
*   qryrfrtbl - query refresh answer set table - optional
*   nbrrow - number of fetch or insert rows - optional
*   maxblkext - maximum number of extra blocks - optional
*   rtnextdta - return of extdta option - optional
*   monitor - monitor events - optional.
*
* @return drdastatement we are continuing
* @throws drdaprotocolexception
* @throws sqlexception
*/
private drdastatement parsecntqry   throws drdaprotocolexception  sqlexception
byte val
pkgnamcsn pkgnamcsn   null
boolean gotqryblksz   false
boolean qryrelscr   true
long qryrownbr   1
boolean qryrfrtbl   false
int nbrrow   1
int blksize   0
int maxblkext    1
long qryinsid
boolean gotqryinsid   false
int qryscrorn   codepoint qryscrrel
boolean qryrowsns   false
boolean gotqryrowsns   false
boolean qryblkrst   false
boolean qryrtndta   true
int qryrowset   codepoint qryrowset_default
int rtnextdta   codepoint rtnextrow
reader markcollection
int codepoint   reader getcodepoint
while  codepoint     1
switch codepoint
//optional
case codepoint rdbnam
setdatabase codepoint cntqry
break
//required
case codepoint pkgnamcsn
pkgnamcsn   parsepkgnamcsn
break
//required
case codepoint qryblksz
blksize   parseqryblksz
gotqryblksz   true
break
//optional
case codepoint qryrelscr
qryrelscr   readboolean codepoint qryrelscr
if  sanitymanager debug
trace   qryrelscr
break
//optional
case codepoint qryscrorn
checklength codepoint qryscrorn  1
qryscrorn   reader readunsignedbyte
if  sanitymanager debug
trace   qryscrorn
switch  qryscrorn
case codepoint qryscrrel
case codepoint qryscrabs
case codepoint qryscraft
case codepoint qryscrbef
break
default
invalidvalue codepoint qryscrorn
break
//optional
case codepoint qryrownbr
checklength codepoint qryrownbr  8
qryrownbr   reader readnetworklong
if  sanitymanager debug
trace   qryrownbr
break
//optional
case codepoint qryrowsns
checklength codepoint qryrowsns  1
qryrowsns   readboolean codepoint qryrowsns
if  sanitymanager debug
trace   qryrowsns
gotqryrowsns   true
break
//optional
case codepoint qryblkrst
checklength codepoint qryblkrst  1
qryblkrst   readboolean codepoint qryblkrst
if  sanitymanager debug
trace   qryblkrst
break
//optional
case codepoint qryrtndta
qryrtndta   readboolean codepoint qryrtndta
if  sanitymanager debug
trace   qryrtndta
break
//optional
case codepoint qryrowset
//note minimum for cntqry is 1
qryrowset   parseqryrowset 1
if  sanitymanager debug
trace   qryrowset
break
//optional
case codepoint qryrfrtbl
qryrfrtbl   readboolean codepoint qryrfrtbl
if  sanitymanager debug
trace   qryrfrtbl
break
//optional
case codepoint nbrrow
checklength codepoint nbrrow  4
nbrrow   reader readnetworkint
if  sanitymanager debug
trace   nbrrow
break
//optional
case codepoint maxblkext
checklength codepoint maxblkext  2
maxblkext   reader readsignednetworkshort
if  sanitymanager debug
trace   maxblkext
break
//optional
case codepoint rtnextdta
checklength codepoint rtnextdta  1
rtnextdta   reader readunsignedbyte
if  rtnextdta    codepoint rtnextrow
rtnextdta    codepoint rtnextall
invalidvalue codepoint rtnextdta
if  sanitymanager debug
trace   rtnextdta
break
// required for sqlam >= 7
case codepoint qryinsid
checklength codepoint qryinsid  8
qryinsid   reader readnetworklong
gotqryinsid   true
if  sanitymanager debug
trace   qryinsid
break
// optional
case codepoint monitor
parsemonitor
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
// check for required variables
if  pkgnamcsn    null
missingcodepoint codepoint pkgnamcsn
if   gotqryblksz
missingcodepoint codepoint qryblksz
if  sqlamlevel >  mgrlvl_7     gotqryinsid
missingcodepoint codepoint qryinsid
// get the statement we are continuing
drdastatement stmt   database getdrdastatement pkgnamcsn
if  stmt    null
//xxx should really throw a sql exception here
invalidvalue codepoint cntqry
if  stmt rsisclosed
writeqrynoprm codepoint svrcod_error
skipremainder true
return null
stmt setqueryoptions blksize qryrelscr qryrownbr qryrfrtbl nbrrow maxblkext
qryscrorn qryrowsns qryblkrst qryrtndta qryrowset
rtnextdta
if  reader ischainedwithsameid
parsecntqryobjects stmt
return stmt
/**
* skip remainder of current dss and all chained dss'es
*
* @param onlyskipsameids true if we _only_ want to skip dss'es
*   that are chained with the same id as the current dss.
*   false means skip all chained dsses, whether they're
*   chained with same or different ids.
* @exception drdaprotocolexception
*/
private void skipremainder boolean onlyskipsameids  throws drdaprotocolexception
reader skipdss
while  reader ischainedwithsameid
onlyskipsameids    reader ischainedwithdiffid
reader readdssheader
reader skipdss
/**
* parse cntqry objects
* instance variables
*   outovr - output override descriptor - optional
*
* @param stmt drda statement we are working on
* @exception drdaprotocolexception
*/
private void parsecntqryobjects drdastatement stmt  throws drdaprotocolexception  sqlexception
int codepoint
do
correlationid   reader readdssheader
while  reader moredssdata
codepoint   reader readlengthandcodepoint  false
switch codepoint
// optional
case codepoint outovr
parseoutovr stmt
break
default
invalidcodepoint codepoint
while  reader ischainedwithsameid
/**
* parse outovr - output override descriptor
* this specifies the output format for data to be returned as output to a sql
* statement or as output from a query.
*
* @param stmt	drda statement this applies to
* @exception drdaprotocolexception
*/
private void parseoutovr drdastatement stmt  throws drdaprotocolexception  sqlexception
boolean first   true
int numvars
int dtagrplen
int triptype
int tripid
int precision
int start   0
while  true
dtagrplen   reader readunsignedbyte
triptype   reader readunsignedbyte
tripid   reader readunsignedbyte
// check if we have reached the end of the data
if  triptype    fdocaconstants rlo_triplet_type
//read last part of footer
reader skipbytes
break
numvars    dtagrplen   3    3
if  sanitymanager debug
trace   numvars
int outovr_drdatype   null
if  first
outovr_drdatype   new int
first   false
else
int oldoutovr_drdatype   stmt getoutovr_drdatype
int oldlen   oldoutovr_drdatype length
// create new array and copy over already read stuff
outovr_drdatype   new int
system arraycopy oldoutovr_drdatype  0
outovr_drdatype 0
oldlen
start   oldlen
for  int i   start  i < numvars   start  i
int drdatype   reader readunsignedbyte
if   database supportslocator
// ignore requests for locator when it is not supported
if   drdatype >  drdaconstants drda_type_lobloc
drdatype <  drdaconstants drda_type_nclobloc
if  sanitymanager debug
trace     drdatype
reader readnetworkshort       skip rest
continue
outovr_drdatype   drdatype
if  sanitymanager debug
trace    outovr_drdatype
precision   reader readnetworkshort
if  sanitymanager debug
trace   precision
outovr_drdatype     precision << 8
stmt setoutovr_drdatype outovr_drdatype
/**
* piggy-back any modified session attributes on the current message. writes
* a pbsd conataining one or both of pbsd_iso and pbsd_schema. pbsd_iso is
* followed by the jdbc isolation level as an unsigned byte. pbsd_schema is
* followed by the name of the current schema as an utf-8 string.
* @throws java.sql.sqlexception
* @throws org.apache.derby.impl.drda.drdaprotocolexception
*/
private void writepbsd   throws sqlexception  drdaprotocolexception
if   apprequester supportssessiondatacaching
return
piggybackedsessiondata pbsd   database getpiggybackedsessiondata true
if  sanitymanager debug
sanitymanager assert pbsd    null
// derby-3596
// reset the flag. in sane builds it is used to avoid an assert, but
// we want to reset it as soon as possible to avoid masking real bugs.
// we have to do this because we are changing the connection state
// at an unexpected time (deferred reset, see parsesecchk). this was
// done to avoid having to change the client code.
this deferredreset   false
pbsd refresh
if  pbsd ismodified
writer createdssreply
writer startddm codepoint pbsd
if  pbsd isisomodified
writer writescalar1byte codepoint pbsd_iso  pbsd getiso
if  pbsd isschemamodified
writer startddm codepoint pbsd_schema
writer writestring pbsd getschema
writer endddm
writer endddmanddss
pbsd setunmodified
if  sanitymanager debug
piggybackedsessiondata pbsdnew
database getpiggybackedsessiondata true
sanitymanager assert pbsdnew    pbsd
pbsd refresh
sanitymanager assert
pbsd ismodified
pbsd
/**
* write opnqryrm - open query complete
* instance variables
*   svrcod - severity code - required
*   qryprctyp - query protocol type - required
*   sqlcsrhld - hold cursor position - optional
*   qryattscr - query attribute for scrollability - optional - level 7
*   qryattsns - query attribute for sensitivity - optional - level 7
*   qryattupd - query attribute for updatability -optional - level 7
*   qryinsid - query instance identifier - required - level 7
*   srvdgn - server diagnostic information - optional
*
* @param isdssobject - return as a dss object (part of a reply)
* @param stmt - drda statement we are processing
*
* @exception drdaprotocolexception
*/
private void writeopnqryrm boolean isdssobject  drdastatement stmt
throws drdaprotocolexception  sqlexception
if  sanitymanager debug
trace
if  isdssobject
writer createdssobject
else
writer createdssreply
writer startddm codepoint opnqryrm
writer writescalar2bytes codepoint svrcod codepoint svrcod_info
// there is currently a problem specifying lmtblkprc for lobs with jcc
// jcc will throw an arrayoutofbounds exception.  once this is fixed, we
// don't need to pass the two arguments for getqryprctyp.
int prctype   stmt getqryprctyp
if  sanitymanager debug
trace     prctype
writer writescalar2bytes codepoint qryprctyp  prctype
//pass the sqlcsrhld codepoint only if statement producing the resultset has
//hold cursors over commit set. in case of stored procedures which use server-side
//jdbc, the holdability of the resultset will be the holdability of the statement
//in the stored procedure, not the holdability of the calling statement.
if  stmt getcurrentdrdaresultset   withholdcursor    resultset hold_cursors_over_commit
writer writescalar1byte codepoint sqlcsrhld  codepoint true
if  sqlamlevel >  mgrlvl_7
writer writescalarheader codepoint qryinsid  8
//this is implementer defined.  db2 uses this for the nesting level
//of the query.  a query from an application would be nesting level 0,
//from a stored procedure, nesting level 1, from a recursive call of
//a stored procedure, nesting level 2, etc.
writer writeint 0
//this is a unique sequence number per session
writer writeint session qryinsid
//write the scroll attributes if they are set
if  stmt isscrollable
writer writescalar1byte codepoint qryattscr  codepoint true
if   stmt getconcurtype      resultset concur_updatable
stmt getresultset   gettype
resultset type_scroll_insensitive
writer writescalar1byte codepoint qryattsns
codepoint qrysnsstc
else
writer writescalar1byte codepoint qryattsns
codepoint qryins
if  stmt getconcurtype      resultset concur_updatable
if  stmt getresultset      null
// resultset concurrency can be less than statement
// concurreny if the underlying language resultset
// is not updatable.
if  stmt getresultset   getconcurrency
resultset concur_updatable
writer writescalar1byte codepoint qryattupd
codepoint qryupd
else
writer writescalar1byte codepoint qryattupd
codepoint qryrdo
else
writer writescalar1byte codepoint qryattupd
codepoint qryupd
else
writer writescalar1byte codepoint qryattupd  codepoint qryrdo
writer endddmanddss
/**
* write endqryrm - query process has terminated in such a manner that the
*	query or result set is now closed.  it cannot be resumed with the cntqry
*  command or closed with the clsqry command
* @param svrcod  severity code - warning or error
* @exception drdaprotocolexception
*/
private void writeendqryrm int svrcod  throws drdaprotocolexception
writer createdssreply
writer startddm codepoint endqryrm
writer writescalar2bytes codepoint svrcod svrcod
writer endddmanddss
/**
* write abnuowrm - query process has terminated in an error condition
* such as deadlock or lock timeout.
* severity code is always error
* 	 * @exception drdaprotocolexception
*/
private void writeabnuowrm   throws drdaprotocolexception
writer createdssreply
writer startddm codepoint abnuowrm
writer writescalar2bytes codepoint svrcod codepoint svrcod_error
writerdbnam database dbname
writer endddmanddss
/**
* parse database name
*
* @return database name
*
* @exception drdaprotocolexception
*/
private string parserdbnam   throws drdaprotocolexception
string name
byte  rdbname   reader readbytes
if  rdbname length    0
// throw rdbnfnrm
rdbnotfound null
//sqlam level 7 allows db name up to 255, level 6 fixed len 18
if  rdbname length < codepoint rdbnam_len    rdbname length > codepoint max_name
badobjectlength codepoint rdbnam
name   reader convertbytes rdbname
// trim trailing blanks from the database name
name   name trim
if  sanitymanager debug
trace     name
return name
/**
* write accsecrd
* if the security mechanism is known, we just send it back along with
* the security token if encryption is going to be used.
* if the security mechanism is not known, we send a list of the ones
* we know.
* instance variables
* 	secmec - security mechanism - required
*	sectkn - security token	- optional (required if security mechanism
*						uses encryption)
*  secchkcd - security check code - error occurred in processing accsec
*
* @param securitycheckcode
*
* @exception drdaprotocolexception
*/
private void writeaccsecrd int securitycheckcode
throws drdaprotocolexception
writer createdssreply
writer startddm codepoint accsecrd
if  securitycheckcode    codepoint secchkcd_notsupported
writer writescalar2bytes codepoint secmec  database securitymechanism
else
// if server doesnt recognize or allow the client requested security mechanism,
// then need to return the list of security mechanisms supported/allowed by the server
// check if server is set to accept connections from client at a certain
// security mechanism, if so send only the security mechanism  that the
// server will accept, to the client
if   server getsecuritymechanism      networkservercontrolimpl invalid_or_notset_securitymechanism
writer writescalar2bytes codepoint secmec  server getsecuritymechanism
else
// note: per the ddm manual , accsecrd response is of
// form secmec (value{value..})
// need to fix the below to send a list of supported security
// mechanisms for value of one secmec codepoint (jira 926)
// these are the ones we know about
writer writescalar2bytes codepoint secmec  codepoint secmec_usridpwd
// include eusridpwd in the list of supported secmec only if
// server can truely support it in the jvm that is running in
if   server supportseusridpwd
writer writescalar2bytes codepoint secmec  codepoint secmec_eusridpwd
writer writescalar2bytes codepoint secmec  codepoint secmec_usridonl
writer writescalar2bytes codepoint secmec  codepoint secmec_usrssbpwd
if  securitycheckcode    0
writer writescalar1byte codepoint secchkcd  securitycheckcode
else
// we need to send back the key if encryption is being used
if  database securitymechanism    codepoint secmec_eusridpwd
writer writescalarbytes codepoint sectkn  mypublickey
else if  database securitymechanism    codepoint secmec_usrssbpwd
writer writescalarbytes codepoint sectkn  mytargetseed
writer endddmanddss
if  securitycheckcode    0
// then we have an error and so can ignore the rest of the
// dss request chain.
skipremainder false
finalizechain
/**
* parse security check
* instance variables
*	secmgrnm - security manager name - optional, ignorable
*  secmec	- security mechanism - required
*	sectkn	- security token - optional, (required if encryption used)
*	password - password - optional, (required if security mechanism uses it)
*	newpassword - new password - optional, (required if sec mech. uses it)
*	usrid	- user id - optional, (required if sec mec. uses it)
*	rdbnam	- database name - optional (required if databases can have own sec.)
*
*
* @return security check code
* @exception drdaprotocolexception
*/
private int parsesecchk   throws drdaprotocolexception
int codepoint  securitycheckcode   0
int securitymechanism   0
databaseaccessexception   null
reader markcollection
codepoint   reader getcodepoint
if  this deferredreset
// skip the secchk, but assure a minimal degree of correctness.
while  codepoint     1
switch  codepoint
// note the fall-through.
// minimal level of checking to detect protocol errors.
// note: secmgr level 8 code points are not handled.
case codepoint secmgrnm
case codepoint secmec
case codepoint sectkn
case codepoint password
case codepoint newpassword
case codepoint usrid
case codepoint rdbnam
reader skipbytes
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
else
while  codepoint     1
switch  codepoint
//optional, ignorable
case codepoint secmgrnm
reader skipbytes
break
//required
case codepoint secmec
checklength codepoint secmec  2
securitymechanism   reader readnetworkshort
if  sanitymanager debug
trace     securitymechanism
//resolve - spec is not clear on what should happen
//in this case
if  securitymechanism    database securitymechanism
invalidvalue codepoint secmec
break
//optional - depending on security mechanism
case codepoint sectkn
if   database securitymechanism
codepoint secmec_eusridpwd
database securitymechanism
codepoint secmec_usrssbpwd
securitycheckcode   codepoint secchkcd_sectknmissing_or_invalid
reader skipbytes
else if  database securitymechanism
codepoint secmec_eusridpwd
if  database decrypteduserid    null
try
database decrypteduserid
reader readencryptedstring
decryptionmanager
database securitymechanism
mypublickey
database sectokenin
catch  sqlexception se
println2log database dbname  session drdaid
se getmessage
if  securitycheckcode    0
//userid invalid
securitycheckcode   codepoint secchkcd_13
database userid   database decrypteduserid
if  sanitymanager debug
trace   database userid
else if  database decryptedpassword    null
try
database decryptedpassword
reader readencryptedstring
decryptionmanager
database securitymechanism
mypublickey
database sectokenin
catch  sqlexception se
println2log database dbname  session drdaid
se getmessage
if  securitycheckcode    0
//password invalid
securitycheckcode   codepoint secchkcd_0f
database password   database decryptedpassword
if  sanitymanager debug
trace
database password
else if  database securitymechanism
codepoint secmec_usrssbpwd
if  database passwordsubstitute    null
database passwordsubstitute   reader readbytes
if  sanitymanager debug
trace
decryptionmanager tohexstring
database passwordsubstitute  0
database passwordsubstitute length
database password
decryptionmanager tohexstring
database passwordsubstitute  0
database passwordsubstitute length
else
toomany codepoint sectkn
break
//optional - depending on security mechanism
case codepoint password
database password   reader readstring
if  sanitymanager debug  trace     database password
break
//optional - depending on security mechanism
//we are not supporting this method so we'll skip bytes
case codepoint newpassword
reader skipbytes
break
//optional - depending on security mechanism
case codepoint usrid
database userid   reader readstring
if  sanitymanager debug  trace     database userid
break
//optional - depending on security mechanism
case codepoint rdbnam
string dbname   parserdbnam
if  database    null
if  database dbname    null
// we didn't get the rdbnam on accsec. set it here
database setdatabasename dbname
session adddatabase database
session database   database
else if   database dbname equals dbname
rdbnammismatch codepoint secchk
else
// we should already have added the database in accsec
// added code here in case we make the secmec session rather
// than database wide
initializedatabase dbname
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
// check for secmec which is required
if  securitymechanism    0
missingcodepoint codepoint secmec
// check that we have a database name.
if  database    null     database dbname    null
missingcodepoint codepoint rdbnam
//check if we have a userid and password when we need it
if  securitycheckcode    0
database securitymechanism    codepoint secmec_usridpwd
database securitymechanism    codepoint secmec_usridonl
if  database userid    null
securitycheckcode   codepoint secchkcd_useridmissing
else if  database securitymechanism    codepoint secmec_usridpwd
if  database password    null
securitycheckcode   codepoint secchkcd_passwordmissing
//note, we'll ignore encrypteduserid and encryptedpassword if they
//are also set
if  securitycheckcode    0
database securitymechanism    codepoint secmec_usrssbpwd
if  database userid    null
securitycheckcode   codepoint secchkcd_useridmissing
else if  database passwordsubstitute    null
securitycheckcode   codepoint secchkcd_passwordmissing
if  securitycheckcode    0
database securitymechanism    codepoint secmec_eusridpwd
if  database decrypteduserid    null
securitycheckcode   codepoint secchkcd_useridmissing
else if  database decryptedpassword    null
securitycheckcode   codepoint secchkcd_passwordmissing
// resolve - when we do security we need to decrypt encrypted userid & password
// before proceeding
end   block
// verify userid and password, if we haven't had any errors thus far.
if   securitycheckcode    0      databaseaccessexception    null
// derby-3596: reset server side (embedded) physical connection for
//     use with a new logical connection on the client.
if  this deferredreset
// reset the existing connection here.
try
database getconnection   resetfrompool
database getconnection   setholdability
resultset hold_cursors_over_commit
// reset isolation level to default, as the client is in
// the process of creating a new logical connection.
database getconnection   settransactionisolation
connection transaction_read_committed
catch  sqlexception sqle
handleexception sqle
else
securitycheckcode   verifyuseridpassword
// security all checked
if  securitycheckcode    0
session setstate session chksec
return securitycheckcode
/**
* write security check reply
* instance variables
* 	svrcod - serverity code - required
*	secchkcd	- security check code  - required
*	sectkn - security token - optional, ignorable
*	svcerrno	- security service error number
*	srvdgn	- server diagnostic information
*
* @exception drdaprotocolexception
*/
private void writesecchkrm int securitycheckcode  throws drdaprotocolexception
writer createdssreply
writer startddm codepoint secchkrm
writer writescalar2bytes codepoint svrcod  svrcodfromsecchkcd securitycheckcode
writer writescalar1byte codepoint secchkcd  securitycheckcode
writer endddmanddss
if  securitycheckcode    0
// then we have an error and are going to end up ignoring the rest
// of the dss request chain.
skipremainder false
finalizechain
/**
* calculate svrcod value from secchkcd
*
* @param securitycheckcode
* @return svrcod value
*/
private int svrcodfromsecchkcd int securitycheckcode
if  securitycheckcode    0    securitycheckcode    2
securitycheckcode    5    securitycheckcode    8
return codepoint svrcod_info
else
return codepoint svrcod_error
/**
* parse access rdb
* instance variables
*	rdbacccl - rdb access manager class - required must be sqlam
*  crrtkn - correlation token - required
*  rdbnam - relational database name -required
*  prdid - product specific identifier - required
*  typdefnam	- data type definition name -required
*  typdefovr	- type definition overrides -required
*  rdbalwupd -  rdb allow updates optional
*  prddta - product specific data - optional - ignorable
*  sttdecdel - statement decimal delimiter - optional
*  sttstrdel - statement string delimiter - optional
*  trgdftrt - target default value return - optional
*
* @return severity code
*
* @exception drdaprotocolexception
*/
private int parseaccrdb   throws  drdaprotocolexception
int codepoint
int svrcod   0
copytorequired accrdb_required
reader markcollection
codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
//required
case codepoint rdbacccl
checklength codepoint rdbacccl  2
int sqlam   reader readnetworkshort
if  sanitymanager debug
trace     sqlam
// required to be sqlam
if  sqlam    codepoint sqlam
invalidvalue codepoint rdbacccl
removefromrequired codepoint rdbacccl
break
//required
case codepoint crrtkn
database crrtkn   reader readbytes
if  sanitymanager debug
trace     converttohexstring database crrtkn
removefromrequired codepoint crrtkn
int l   database crrtkn length
if  l > codepoint max_name
toobig codepoint crrtkn
// the format of the crrtkn is defined in the drda reference
// x.yz where x is 1 to 8 bytes (variable)
// 		y is 1 to 8 bytes (variable)
//		x is 6 bytes fixed
//		size is variable between 9 and 23
if  l < 9    l > 23
invalidvalue codepoint crrtkn
byte part1   new byte
for  int i   0  i < part1 length  i
part1   database crrtkn
long time   signedbinary getlong database crrtkn
l 8  signedbinary big_endian      as   as unique
session drdaid   reader convertbytes part1
time   leftbrace   session connnum   rightbrace
if  sanitymanager debug
trace     session drdaid
database setdrdaid session drdaid
break
//required
case codepoint rdbnam
string dbname   parserdbnam
if  database    null
if   database dbname equals dbname
rdbnammismatch codepoint accrdb
else
//first time we have seen a database name
database d   session getdatabase dbname
if  d    null
initializedatabase dbname
else
database   d
database accesscount
removefromrequired codepoint rdbnam
break
//required
case codepoint prdid
apprequester setclientversion reader readstring
if  sanitymanager debug
trace     apprequester prdid
if  apprequester prdid length   > codepoint prdid_max
toobig codepoint prdid
/* if jcc version is 1.5 or later, send sqlwarning on cntqry */
if    apprequester getclienttype      apprequester jcc_client
apprequester greaterthanorequalto 1  5  0
apprequester getclienttype      apprequester dnc_client
sendwarningsoncntqry   true
else sendwarningsoncntqry   false
// the client can not request diaglvl because when run with
// an older server it will cause an exception. older version
// of the server do not recognize requests for diaglvl.
if   apprequester getclienttype      apprequester dnc_client
apprequester greaterthanorequalto 10  2  0
diagnosticlevel   codepoint diaglvl1
removefromrequired codepoint prdid
break
//required
case codepoint typdefnam
setstmtordbbyteorder true  null  parsetypdefnam
removefromrequired codepoint typdefnam
break
//required
case codepoint typdefovr
parsetypdefovr null
removefromrequired codepoint typdefovr
break
//optional
case codepoint rdbalwupd
checklength codepoint rdbalwupd  1
database rdballowupdates   readboolean codepoint rdbalwupd
if  sanitymanager debug
trace   database rdballowupdates
break
//optional, ignorable
case codepoint prddta
// check that it fits in maximum but otherwise ignore for now
if  reader getddmlength   > codepoint max_name
toobig codepoint prddta
reader skipbytes
break
case codepoint trgdftrt
byte b   reader readbyte
if  b    0xf1
database sendtrgdftrt   true
break
//optional - not used in jcc so skip for now
case codepoint sttdecdel
case codepoint sttstrdel
codepointnotsupported codepoint
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
checkrequired codepoint accrdb
// check that we can support the double-byte and mixed-byte ccsids
// set svrcod to warning if they are not supported
if   database ccsiddbc    0     server supportsccsid database ccsiddbc
database ccsidmbc    0     server supportsccsid database ccsidmbc
svrcod   codepoint svrcod_warning
return svrcod
/**
* parse typdefnam
*
* @return typdefnam
* @exception drdaprotocolexception
*/
private string parsetypdefnam   throws drdaprotocolexception
string typdefnam   reader readstring
if  sanitymanager debug  trace     typdefnam
if  typdefnam length   > codepoint max_name
toobig codepoint typdefnam
checkvalidtypdefnam typdefnam
// check if the typedef is one we support
if   typdefnam equals codepoint typdefnam_qtdsqlasc
typdefnam equals codepoint typdefnam_qtdsqljvm
typdefnam equals codepoint typdefnam_qtdsqlx86
valuenotsupported codepoint typdefnam
return typdefnam
/**
* set a statement or the database' byte order, depending on the arguments
*
* @param setdatabase   if true, set database' byte order, otherwise set statement's
* @param stmt          drdastatement, used when setdatabase is false
* @param typdefnam     typdefnam value
*/
private void setstmtordbbyteorder boolean setdatabase  drdastatement stmt  string typdefnam
int byteorder    typdefnam equals codepoint typdefnam_qtdsqlx86  ?
signedbinary little_endian   signedbinary big_endian
if  setdatabase
database typdefnam   typdefnam
database byteorder   byteorder
else
stmt typdefnam   typdefnam
stmt byteorder   byteorder
/**
* write access to rdb completed
* instance variables
*  svrcod - severity code - 0 info, 4 warning -required
*  prdid - product specific identifier -required
*  typdefnam - type definition name -required
*  typdefovr - type definition overrides - required
*  rdbinttkn - token which can be used to interrupt ddm commands - optional
*  crrtkn	- correlation token - only returned if we didn't get one from requester
*  srvdgn - server diagnostic information - optional
*  pkgdftcst - package default character subtype - optional
*  usrid - user id at the target system - optional
*  srvlst - server list
*
* @exception drdaprotocolexception
*/
private void writeaccrdbrm int svrcod  throws drdaprotocolexception
writer createdssreply
writer startddm codepoint accrdbrm
writer writescalar2bytes codepoint svrcod  svrcod
writer writescalarstring codepoint prdid  server prdid
//typdefnam -required - jcc doesn't support qtdsqljvm so for now we
// just use ascii, though we should eventually be able to use qtdsqljvm
// at level 7
writer writescalarstring codepoint typdefnam
codepoint typdefnam_qtdsqlasc
writetypdefovr
writer endddmanddss
finalizechain
private void writetypdefovr   throws drdaprotocolexception
//typdefovr - required - only single byte and mixed byte are specified
writer startddm codepoint typdefovr
writer writescalar2bytes codepoint ccsidsbc  server ccsidsbc
writer writescalar2bytes codepoint ccsidmbc  server ccsidmbc
// pkgdftcst - send character subtype and userid if requested
if  database sendtrgdftrt
// default to multibyte character
writer startddm codepoint pkgdftcst
writer writeshort codepoint cstmbcs
writer endddm
// userid
writer startddm codepoint usrid
writer writestring database userid
writer endddm
writer endddm
/**
* parse type defintion overrides
* 	typdef overrides specifies the coded character set identifiers (ccsids)
*  that are in a named typdef.
* instance variables
*  ccsidsbc - ccsid for single-byte - optional
*  ccsiddbc - ccsid for double-byte - optional
*  ccsidmbc - ccsid for mixed-byte characters -optional
*
* @param st	statement this typdefovr applies to
*
* @exception drdaprotocolexception
*/
private void parsetypdefovr drdastatement st  throws  drdaprotocolexception
int codepoint
int ccsidsbc   0
int ccsiddbc   0
int ccsidmbc   0
string ccsidsbcencoding   null
string ccsiddbcencoding   null
string ccsidmbcencoding   null
reader markcollection
codepoint   reader getcodepoint
// at least one of the following instance variable is required
// if the typdefovr is specified in a command object
if  codepoint     1    st    null
missingcodepoint codepoint ccsidsbc
while  codepoint     1
switch  codepoint
case codepoint ccsidsbc
checklength codepoint ccsidsbc  2
ccsidsbc   reader readnetworkshort
try
ccsidsbcencoding
characterencodings getjavaencoding ccsidsbc
catch  exception e
valuenotsupported codepoint ccsidsbc
if  sanitymanager debug
trace     ccsidsbc       ccsidsbcencoding
break
case codepoint ccsiddbc
checklength codepoint ccsiddbc  2
ccsiddbc   reader readnetworkshort
try
ccsiddbcencoding
characterencodings getjavaencoding ccsiddbc
catch  exception e
// we write a warning later for this so no error
// unless for a statement
ccsiddbcencoding   null
if  st    null
valuenotsupported codepoint ccsidsbc
if  sanitymanager debug
trace     ccsiddbc       ccsiddbcencoding
break
case codepoint ccsidmbc
checklength codepoint ccsidmbc  2
ccsidmbc   reader readnetworkshort
try
ccsidmbcencoding
characterencodings getjavaencoding ccsidmbc
catch  exception e
// we write a warning later for this so no error
ccsidmbcencoding   null
if  st    null
valuenotsupported codepoint ccsidmbc
if  sanitymanager debug
trace     ccsidmbc       ccsidmbcencoding
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
if  st    null
if  ccsidsbc    0
database ccsidsbc   ccsidsbc
database ccsidsbcencoding   ccsidsbcencoding
if  ccsiddbc    0
database ccsiddbc   ccsiddbc
database ccsiddbcencoding   ccsiddbcencoding
if  ccsidmbc    0
database ccsidmbc   ccsidmbc
database ccsidmbcencoding   ccsidmbcencoding
else
if  ccsidsbc    0
st ccsidsbc   ccsidsbc
st ccsidsbcencoding   ccsidsbcencoding
if  ccsiddbc    0
st ccsiddbc   ccsiddbc
st ccsiddbcencoding   ccsiddbcencoding
if  ccsidmbc    0
st ccsidmbc   ccsidmbc
st ccsidmbcencoding   ccsidmbcencoding
/**
* parse prpsqlstt - prepare sql statement
* instance variables
*   rdbnam - relational database name - optional
*   pkgnamcsn - rdb package name, consistency token, and section number - required
*   rtnsqlda - return sql descriptor area - optional
*   monitor - monitor events - optional.
*
* @return return 0 - don't return sqlda, 1 - return input sqlda,
* 		2 - return output sqlda
* @throws drdaprotocolexception
* @throws sqlexception
*/
private int parseprpsqlstt   throws drdaprotocolexception sqlexception
int codepoint
boolean rtnsqlda   false
boolean rtnoutput   true  	   return output sqlda is default
string typdefnam
pkgnamcsn pkgnamcsn   null
drdastatement stmt   null
database databasetoset   null
reader markcollection
codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
// optional
case codepoint rdbnam
setdatabase codepoint prpsqlstt
databasetoset   database
break
// required
case codepoint pkgnamcsn
pkgnamcsn   parsepkgnamcsn
break
//optional
case codepoint rtnsqlda
// return sqlda with description of statement
rtnsqlda   readboolean codepoint rtnsqlda
break
//optional
case codepoint typsqlda
rtnoutput   parsetypsqlda
break
//optional
case codepoint monitor
parsemonitor
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
stmt   database newdrdastatement pkgnamcsn
string sqlstmt   parseprpsqlsttobjects stmt
if  databasetoset    null
stmt setdatabase database
stmt explicitprepare sqlstmt
// set the statement as the current statement
database setcurrentstatement stmt
if   rtnsqlda
return 0
else if  rtnoutput
return 2
else
return 1
/**
* parse prpsqlstt objects
* objects
*  typdefnam - data type definition name - optional
*  typdefovr - type defintion overrides - optional
*  sqlstt - sql statement required
*  sqlattr - cursor attributes on prepare - optional - level 7
*
* if typdefnam and typdefovr are supplied, they apply to the objects
* sent with the statement.  once the statement is over, the default values
* sent in the accrdb are once again in effect.  if no values are supplied,
* the values sent in the accrdb are used.
* objects may follow in one dss or in several dss chained together.
*
* @return sql statement
* @throws drdaprotocolexception
* @throws sqlexception
*/
private string parseprpsqlsttobjects drdastatement stmt
throws drdaprotocolexception  sqlexception
string sqlstmt   null
int codepoint
do
correlationid   reader readdssheader
while  reader moredssdata
codepoint   reader readlengthandcodepoint  false
switch codepoint
// required
case codepoint sqlstt
sqlstmt   parseencodedstring
if  sanitymanager debug
trace     sqlstmt
break
// optional
case codepoint typdefnam
setstmtordbbyteorder false  stmt  parsetypdefnam
break
// optional
case codepoint typdefovr
parsetypdefovr stmt
break
// optional
case codepoint sqlattr
parsesqlattr stmt
break
default
invalidcodepoint codepoint
while  reader ischainedwithsameid
if  sqlstmt    null
missingcodepoint codepoint sqlstt
return sqlstmt
/**
* parse typsqlda - type of the sql descriptor area
*
* @return true if for output; false otherwise
* @exception drdaprotocolexception
*/
private boolean parsetypsqlda   throws drdaprotocolexception
checklength codepoint typsqlda  1
byte sqldatype   reader readbyte
if  sanitymanager debug
trace     sqldatype
if  sqldatype    codepoint typsqlda_std_output
sqldatype    codepoint typsqlda_light_output
sqldatype    codepoint typsqlda_x_output
return true
else if  sqldatype    codepoint typsqlda_std_input
sqldatype    codepoint typsqlda_light_input
sqldatype    codepoint typsqlda_x_input
return false
else
invalidvalue codepoint typsqlda
// shouldn't get here but have to shut up compiler
return false
/**
* parse sqlattr - cursor attributes on prepare
*   this is an encoded string. can have combination of following, eg insensitive scroll with hold
* possible strings are
*  sensitive dynamic scroll [for update]
*  sensitive static scroll [for update]
*  insensitive scroll
*  for update
*  with hold
*
* @param stmt drdastatement
* @exception drdaprotocolexception
*/
protected void parsesqlattr drdastatement stmt  throws drdaprotocolexception
string attrs   parseencodedstring
if  sanitymanager debug
trace     attrs
//let derby handle any errors in the types it doesn't support
//just set the attributes
boolean validattribute   false
if  attrs indexof        1    attrs indexof        1    cli
stmt scrolltype   resultset type_scroll_insensitive
stmt concurtype   resultset concur_read_only
validattribute   true
if   attrs indexof        1      attrs indexof        1
stmt scrolltype   resultset type_scroll_sensitive
validattribute   true
if   attrs indexof        1
validattribute   true
stmt concurtype   resultset concur_updatable
if  attrs indexof        1
stmt withholdcursor   resultset hold_cursors_over_commit
validattribute   true
if   validattribute
invalidvalue codepoint sqlattr
/**
* parse dscsqlstt - describe sql statement previously prepared
* instance variables
*	typsqlda - sqlda type expected (output or input)
*  rdbnam - relational database name - optional
*  pkgnamcsn - rdb package name, consistency token and section number - required
*  monitor - monitor events - optional.
*
* @return expect "output sqlda" or not
* @throws drdaprotocolexception
* @throws sqlexception
*/
private boolean parsedscsqlstt   throws drdaprotocolexception sqlexception
int codepoint
boolean rtnoutput   true 	   default
pkgnamcsn pkgnamcsn   null
reader markcollection
codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
// optional
case codepoint typsqlda
rtnoutput   parsetypsqlda
break
// optional
case codepoint rdbnam
setdatabase codepoint dscsqlstt
break
// required
case codepoint pkgnamcsn
pkgnamcsn   parsepkgnamcsn
drdastatement stmt   database getdrdastatement pkgnamcsn
if  stmt    null
invalidvalue codepoint pkgnamcsn
break
//optional
case codepoint monitor
parsemonitor
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
if  pkgnamcsn    null
missingcodepoint codepoint pkgnamcsn
return rtnoutput
/**
* parse excsqlstt - execute non-cursor sql statement previously prepared
* instance variables
*  rdbnam - relational database name - optional
*  pkgnamcsn - rdb package name, consistency token and section number - required
*  outexp - output expected
*  nbrrow - number of rows to be inserted if it's an insert
*  prcnam - procedure name if specified by host variable, not needed for derby
*  qryblksz - query block size
*  maxrslcnt - max resultset count
*  maxblkext - max number of extra blocks
*  rslsetflg - resultset flag
*  rdbcmtok - rdb commit allowed - optional
*  outovropt - output override option
*  qryrowset - query rowset size - level 7
*  monitor - monitor events - optional.
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void parseexcsqlstt   throws drdaprotocolexception sqlexception
int codepoint
string strval
reader markcollection
codepoint   reader getcodepoint
boolean outputexpected   false
pkgnamcsn pkgnamcsn   null
int numrows   1 	   default value
int blksize    0
int maxrslcnt   0  	   default value
int maxblkext   codepoint maxblkext_default
int qryrowset   codepoint qryrowset_default
int outovropt   codepoint outovrfrs
byte  rslsetflg   null
string procname   null
while  codepoint     1
switch  codepoint
// optional
case codepoint rdbnam
setdatabase codepoint excsqlstt
break
// required
case codepoint pkgnamcsn
pkgnamcsn   parsepkgnamcsn
break
// optional
case codepoint outexp
outputexpected   readboolean codepoint outexp
if  sanitymanager debug
trace    outputexpected
break
// optional
case codepoint nbrrow
checklength codepoint nbrrow  4
numrows   reader readnetworkint
if  sanitymanager debug
trace   numrows
break
// optional
case codepoint prcnam
procname   reader readstring
if  sanitymanager debug
trace     procname
break
// optional
case codepoint qryblksz
blksize   parseqryblksz
break
// optional
case codepoint maxrslcnt
// this is the maximum result set count
// values are 0 - requester is not capabable of receiving result
// sets as reply data in the response to excsqlstt
// -1 - requester is able to receive all result sets
checklength codepoint maxrslcnt  2
maxrslcnt   reader readnetworkshort
if  sanitymanager debug
trace   maxrslcnt
break
// optional
case codepoint maxblkext
// number of extra qury blocks of answer set data per result set
// 0 - no extra query blocks
// -1 - can receive entire result set
checklength codepoint maxblkext  2
maxblkext   reader readnetworkshort
if  sanitymanager debug
trace   maxblkext
break
// optional
case codepoint rslsetflg
//result set flags
rslsetflg   reader readbytes
for  int i 0 i<rslsetflg length i
if  sanitymanager debug
trace   rslsetflg
break
// optional
case codepoint rdbcmtok
parserdbcmtok
break
// optional
case codepoint outovropt
outovropt   parseoutovropt
break
// optional
case codepoint qryrowset
//note minimum for opnqry is 0, we'll assume it is the same
//for excsqlstt though the standard doesn't say
qryrowset   parseqryrowset 0
break
//optional
case codepoint monitor
parsemonitor
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
if  pkgnamcsn    null
missingcodepoint codepoint pkgnamcsn
drdastatement stmt
boolean needpreparecall   false
stmt    database getdrdastatement pkgnamcsn
boolean isprocedure    procname   null
stmt    null
stmt wasexplicitlyprepared
stmt iscall
if  isprocedure 		   stored procedure call
if   stmt    null       stmt wasexplicitlyprepared
stmt    database newdrdastatement pkgnamcsn
stmt setqryprctyp codepoint qryblkctl_default
needpreparecall   true
stmt procname   procname
stmt outputexpected   outputexpected
else
// we can't find the statement
if  stmt    null
invalidvalue codepoint pkgnamcsn
stmt setqryprctyp codepoint qryblkctl_default
stmt nbrrow   numrows
stmt qryrowset   qryrowset
stmt blksize   blksize
stmt maxblkext   maxblkext
stmt maxrslcnt   maxrslcnt
stmt outovropt   outovropt
stmt rslsetflg   rslsetflg
if  pendingstatementtimeout >  0
stmt getpreparedstatement   setquerytimeout pendingstatementtimeout
pendingstatementtimeout    1
// set the statement as the current statement
database setcurrentstatement stmt
boolean hasresultset
if  reader ischainedwithsameid
hasresultset   parseexcsqlsttobjects stmt
else
if  isprocedure      needpreparecall
// if we had parameters the callable statement would
// be prepared with parseexcqlsttobjects, otherwise we
// have to do it here
string preparestring       stmt procname
if  sanitymanager debug
trace    preparestring
database getconnection   clearwarnings
callablestatement cs    callablestatement  stmt prepare preparestring
stmt ps clearwarnings
hasresultset   stmt execute
resultset rs   null
if  hasresultset
rs   stmt getresultset
// temp until ps.execute() return value fixed
hasresultset    rs    null
int numresults   0
if  hasresultset
numresults   stmt getnumresultsets
writerslsetrm stmt
// first of all, we send if there really are output params. otherwise
// cli (.net driver) fails. drda spec (page 151,152) says send sqldtard
// if server has output param data to send.
boolean sendsqldtard   stmt hasoutputparams      outputexpected
if  isprocedure
if  sendsqldtard
writer createdssobject
writer startddm codepoint sqldtard
writer startddm codepoint fdodsc
writeqrydsc stmt  true
writer endddm
writer startddm codepoint fdodta
writefdodta stmt
writer endddm
writer endddmanddss
else if  hasresultset
// drda spec says that we must return either an
// sqldtard or an sqlcard--the former when we have
// output parameters, the latter when we don't.
// if we have a result set, then we have to write
// the sqlcard _now_, since it is expected before
// we send the result set info below; if we don't
// have a result set and we don't send sqldtard,
// then we can wait until we reach the call to
// checkwarning() below, which will write an
// sqlcard for us.
writenullsqlcardobject
//we need to marke that params are finished so that we know we
// are ready to send resultset info.
stmt finishparams
preparedstatement ps   stmt getpreparedstatement
int rsnum   0
do
if  hasresultset
stmt setcurrentdrdaresultset rsnum
//indicate that we are going to return data
stmt setqryrtndta true
if    isprocedure
checkwarning null  ps  null   1  true  true
if  rsnum    0
writesqlrslrd stmt
writeopnqryrm true  stmt
writesqlcinrd stmt
writeqrydsc stmt  false
stmt rssuspend
/* currently, if lmtblkprc is used, a pre-condition is that no lob columns.
* but in the future, when we do support lob in lmtblkprc, the drda spec still
* does not allow lob to be sent with opnqryrm.  so this "if" here will have
* to add "no lob columns".
*/
if  stmt getqryprctyp      codepoint lmtblkprc
writeqrydta stmt
else  if    sendsqldtard
int updatecount   ps getupdatecount
if  false     database rdbupdrm_sent    false
isprocedure
writerdbupdrm
checkwarning database getconnection    stmt ps  null  updatecount  true  true
while hasresultset       rsnum < numresults
return 			   we are done
/**
* parse rdbcmtok - tells the database whether to allow commits or rollbacks
* to be executed as part of the command
* since we don't have a sql commit or rollback command, we will just ignore
* this for now
*
* @exception drdaprotocolexception
*/
private void parserdbcmtok   throws drdaprotocolexception
boolean rdbcmtok   readboolean codepoint rdbcmtok
if  sanitymanager debug
trace     rdbcmtok
/**
* parse excsqlstt command objects
* command objects
*  typdefnam - data type definition name - optional
*  typdefovr - typdef overrides -optional
*	sqldta - optional, variable data, specified if prpared statement has input parameters
*	extdta - optional, externalized fd:oca data
*	outovr - output override descriptor, not allowed for stored procedure calls
*
* if typdefnam and typdefovr are supplied, they apply to the objects
* sent with the statement.  once the statement is over, the default values
* sent in the accrdb are once again in effect.  if no values are supplied,
* the values sent in the accrdb are used.
* objects may follow in one dss or in several dss chained together.
*
* @param stmt	the drdastatement to execute
* @throws drdaprotocolexception
* @throws sqlexception
*/
private boolean parseexcsqlsttobjects drdastatement stmt  throws drdaprotocolexception  sqlexception
int codepoint
boolean gotsqldta   false  gotextdta   false
boolean result   false
do
correlationid   reader readdssheader
while  reader moredssdata
codepoint   reader readlengthandcodepoint  true
switch codepoint
// optional
case codepoint typdefnam
setstmtordbbyteorder false  stmt  parsetypdefnam
stmt settypdefvalues
break
// optional
case codepoint typdefovr
parsetypdefovr stmt
stmt settypdefvalues
break
// required
case codepoint sqldta
parsesqldta stmt
gotsqldta   true
break
// optional
case codepoint extdta
readandsetallextparams stmt  true
stmt ps clearwarnings
result   stmt execute
gotextdta   true
break
// optional
case codepoint outovr
parseoutovr stmt
break
default
invalidcodepoint codepoint
while  reader ischainedwithsameid
// sqldta is required
if    gotsqldta
missingcodepoint codepoint sqldta
if    gotextdta
stmt ps clearwarnings
result   stmt execute
return result
/**
* write sqlcinrd - result set column information
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writesqlcinrd drdastatement stmt  throws drdaprotocolexception sqlexception
resultset rs   stmt getresultset
writer createdssobject
writer startddm codepoint sqlcinrd
if  sqlamlevel >  mgrlvl_7
writesqldhrow   engineresultset  rs  getholdability
resultsetmetadata rsmeta   rs getmetadata
int ncols   rsmeta getcolumncount
writer writeshort ncols  	   num of columns
if  sqlamlevel >  mgrlvl_7
for  int i   0  i < ncols  i
writesqldagrp  rsmeta  null  i  true
else
for  int i   0  i < ncols  i
writevcmorvcs rsmeta getcolumnname i 1
writevcmorvcs rsmeta getcolumnlabel i 1
writevcmorvcs null
writer endddmanddss
/**
* write sqlrslrd - result set reply data
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writesqlrslrd drdastatement stmt  throws drdaprotocolexception sqlexception
int numresults   stmt getnumresultsets
writer createdssobject
writer startddm codepoint sqlrslrd
writer writeshort numresults      num of result sets
for  int i   0  i < numresults  i
writer writeint i  	   rslocator
writevcmorvcs stmt getresultsetcursorname i
writer writeint 1  	   num of rows xxx resolve  it doesn't matter for now
writer endddmanddss
/**
* write rslsetrm
* instance variables
*  svrcod - severity code - information only - required
*  pkgsnlst - list of pkgnamcsn -required
*  srvdgn - server diagnostic information -optional
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writerslsetrm drdastatement stmt  throws drdaprotocolexception sqlexception
int numresults   stmt getnumresultsets
writer createdssreply
writer startddm codepoint rslsetrm
writer writescalar2bytes codepoint svrcod  0
writer startddm codepoint pkgsnlst
for  int i   0  i < numresults  i
writepkgnamcsn stmt getresultsetpkgcnstkn i  getbytes
writer endddm
writer endddmanddss
/**
* parse sqldta - sql program variable data
* and handle exception.
* @see #parsesqldta_work
*/
private void parsesqldta drdastatement stmt  throws drdaprotocolexception sqlexception
try
parsesqldta_work stmt
catch  sqlexception se
skipremainder true
throw se
/**
* parse sqldta - sql program variable data
* instance variables
*  fdodsc - fd:oca data descriptor - required
*  fdodta - fd:oca data - optional
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void parsesqldta_work drdastatement stmt  throws drdaprotocolexception sqlexception
string strval
preparedstatement ps   stmt getpreparedstatement
int codepoint
parametermetadata pmeta   null
// clear params without releasing storage
stmt cleardrdaparams
int numvars   0
boolean rtnparam   false
reader markcollection
codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
// required
case codepoint fdodsc
while  reader getddmlength   > 6    we get parameter info til last 6 byte
int dtagrplen   reader readunsignedbyte
int numvarsingrp    dtagrplen   3    3
if  sanitymanager debug
trace   numvarsingrp
reader readbyte   		   triplettype
reader readbyte   		   id
for  int j   0  j < numvarsingrp  j
final byte t   reader readbyte
if  sanitymanager debug
trace
integer tohexstring t
int drdalength   reader readnetworkshort
if  sanitymanager debug
trace   drdalength
stmt adddrdaparam t  drdalength
numvars   stmt getdrdaparamcount
if  sanitymanager debug
trace     numvars
if  ps    null 		   it is a callablestatement under construction
string marks     	   construct parameter marks
for  int i   1  i < numvars  i
marks
string preparestring       stmt procname   marks
if  sanitymanager debug
trace    preparestring
callablestatement cs   null
try
cs    callablestatement
stmt prepare preparestring
stmt registeralloutparams
catch  sqlexception se
if    stmt outputexpected
se getsqlstate   equals sqlstate lang_no_method_found
throw se
if  sanitymanager debug
trace
// save first sqlexception most likely suspect
if  numvars    1
preparestring       stmt procname
else
preparestring       stmt procname    marks substring 3
if  sanitymanager debug
trace    preparestring
try
cs    callablestatement  stmt prepare preparestring
catch  sqlexception se2
// the first exception is the most likely suspect
throw se
rtnparam   true
ps   cs
stmt ps   ps
pmeta   stmt getparametermetadata
reader readbytes 6  	   descriptor footer
break
// optional
case codepoint fdodta
reader readbyte   	   row indicator
for  int i   0  i < numvars  i
if   stmt getparamdrdatype i 1    0x1     0x1 	   nullable
int nulldata   reader readunsignedbyte
if   nulldata   0xff     fdocaconstants null_data
if  sanitymanager debug
trace
if  pmeta getparametermode i   1
jdbc30translation parameter_mode_out
ps setnull i 1  pmeta getparametertype i 1
if  stmt isoutputparam i 1
stmt registeroutparam i 1
continue
// not null, read and set it
readandsetparams i  stmt  pmeta
break
case codepoint extdta
readandsetallextparams stmt  false
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
private int getbyteorder
drdastatement stmt   database getcurrentstatement
return   stmt    null    stmt typdefnam    null  ? stmt byteorder   database byteorder
/**
* read different types of input parameters and set them in
* preparedstatement
* @param i			index of the parameter
* @param stmt      drda statement
* @param pmeta		parameter meta data
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void readandsetparams int i
drdastatement stmt
parametermetadata pmeta
throws drdaprotocolexception  sqlexception
preparedstatement ps   stmt getpreparedstatement
// mask out null indicator
final int drdatype     stmt getparamdrdatype i 1    0x01    0xff
final int paramlennumbytes   stmt getparamlen i 1
if  ps instanceof callablestatement
if  stmt isoutputparam i 1
callablestatement cs    callablestatement  ps
cs registeroutparameter i 1  stmt getoutputparamtype i 1
switch  drdatype
case drdaconstants drda_type_nsmall
short paramval    short  reader readshort getbyteorder
if  sanitymanager debug
trace   paramval
// db2 does not have a boolean java.sql.bit type, it's sent as small
if  pmeta getparametertype i 1     types boolean
ps setboolean i 1   paramval    1
else
ps setshort i 1  paramval
break
case  drdaconstants drda_type_ninteger
int paramval   reader readint getbyteorder
if  sanitymanager debug
trace   paramval
ps setint i 1  paramval
break
case drdaconstants drda_type_ninteger8
long paramval   reader readlong getbyteorder
if  sanitymanager debug
trace   paramval
ps setlong i 1  paramval
break
case drdaconstants drda_type_nfloat4
float paramval   reader readfloat getbyteorder
if  sanitymanager debug
trace   paramval
ps setfloat i 1  paramval
break
case drdaconstants drda_type_nfloat8
double paramval   reader readdouble getbyteorder
if  sanitymanager debug
trace   paramval
ps setdouble i 1  paramval
break
case drdaconstants drda_type_ndecimal
int precision    paramlennumbytes >> 8    0xff
int scale   paramlennumbytes   0xff
bigdecimal paramval   reader readbigdecimal precision  scale
if  sanitymanager debug
trace   paramval
ps setbigdecimal i 1  paramval
break
case drdaconstants drda_type_ndate
string paramval   reader readstringdata 10  trim       parameter may be char value
if  sanitymanager debug
trace
try
ps setdate i 1  java sql date valueof paramval
catch  java lang illegalargumentexception e
// just use sqlstate as message since, if user wants to
// retrieve it, the message will be looked up by the
// sqlcamessage() proc, which will get the localized
// message based on sqlstate, and will ignore the
// the message we use here...
throw new sqlexception sqlstate lang_date_syntax_exception
sqlstate lang_date_syntax_exception substring 0 5
break
case drdaconstants drda_type_ntime
string paramval   reader readstringdata 8  trim       parameter may be char value
if  sanitymanager debug
trace   paramval
try
ps settime i 1  java sql time valueof paramval
catch  java lang illegalargumentexception e
throw new sqlexception sqlstate lang_date_syntax_exception
sqlstate lang_date_syntax_exception substring 0 5
break
case drdaconstants drda_type_ntimestamp
// jcc represents ts in a slightly different format than java standard, so
// we do the conversion to java standard here.
string paramval   reader readstringdata 26  trim       parameter may be char value
if  sanitymanager debug
trace   paramval
try
string tsstring   paramval substring 0 10
paramval substring 11 19  replace
paramval substring 19
if  sanitymanager debug
trace   tsstring
ps settimestamp i 1  java sql timestamp valueof tsstring
catch  java lang illegalargumentexception e1
// thrown by timestamp.valueof(...) for bad syntax...
throw new sqlexception sqlstate lang_date_syntax_exception
sqlstate lang_date_syntax_exception substring 0 5
catch  java lang stringindexoutofboundsexception e2
// can be thrown by substring(...) if syntax is invalid...
throw new sqlexception sqlstate lang_date_syntax_exception
sqlstate lang_date_syntax_exception substring 0 5
break
case drdaconstants drda_type_nchar
case drdaconstants drda_type_nvarchar
case drdaconstants drda_type_nlong
case drdaconstants drda_type_nvarmix
case drdaconstants drda_type_nlongmix
string paramval   reader readldstringdata stmt ccsidmbcencoding
if  sanitymanager debug
trace   paramval
ps setstring i 1  paramval
break
case  drdaconstants drda_type_nfixbyte
byte paramval   reader readbytes
if  sanitymanager debug
trace    converttohexstring paramval
ps setbytes i 1  paramval
break
case drdaconstants drda_type_nvarbyte
case drdaconstants drda_type_nlongvarbyte
int length   reader readnetworkshort   	  protocol control data always follows big endian
if  sanitymanager debug
trace     length
byte paramval   reader readbytes length
ps setbytes i 1  paramval
break
case drdaconstants drda_type_nlobbytes
case drdaconstants drda_type_nlobcmixed
case drdaconstants drda_type_nlobcsbcs
case drdaconstants drda_type_nlobcdbcs
long length   readloblength paramlennumbytes
if  length    0    can be  1 for cli if   mode  see clifp exec test
stmt addextposition i
else      empty
if  drdatype    drdaconstants drda_type_nlobbytes
ps setbytes i 1  new byte
else
ps setstring i 1
break
case drdaconstants drda_type_nlobloc
//read the locator value
int paramval   reader readint getbyteorder
if  sanitymanager debug
trace   paramval
//map the locator value to the blob object in the
//hash map.
java sql blob blobfromlocator    java sql blob
database getconnection   getlobmapping paramval
//set the preparedstatement parameter to the mapped
//blob object.
ps setblob i 1  blobfromlocator
break
case drdaconstants drda_type_nclobloc
//read the locator value.
int paramval   reader readint getbyteorder
if  sanitymanager debug
trace   paramval
//map the locator value to the clob object in the
//hash map.
java sql clob clobfromlocator    java sql clob
database getconnection   getlobmapping paramval
//set the preparedstatement parameter to the mapped
//clob object.
ps setclob i 1  clobfromlocator
break
default
string paramval   reader readldstringdata stmt ccsidmbcencoding
if  sanitymanager debug
trace   paramval
ps setobject i 1  paramval
private long readloblength int extlenindicator
throws drdaprotocolexception
switch  extlenindicator
case 0x8002
return  long  reader readnetworkshort
case 0x8004
return  long  reader readnetworkint
case 0x8006
return  long  reader readnetworksixbytelong
case 0x8008
return  long  reader readnetworklong
default
throwsyntaxrm codepoint synerrcd_incorrect_extended_len  extlenindicator
return 0l
private void readandsetallextparams final drdastatement stmt  final boolean streamlob
throws sqlexception  drdaprotocolexception
final int numext   stmt getextpositioncount
for  int i   0  i < numext  i
int parampos   stmt getextposition i
// only the last extdta is streamed.  this is because all of
// the parameters have to be set before execution and are
// consecutive in the network server stream, so only the last
// one can be streamed.
final boolean dostreamlob    streamlob    i    numext  1
readandsetextparam parampos
stmt
stmt getparamdrdatype parampos 1
stmt getparamlen parampos 1
dostreamlob
// each extdta in it's own dss
if  i < numext  1
correlationid   reader readdssheader
int codepoint   reader readlengthandcodepoint  true
/**
* read different types of input parameters and set them in preparedstatement
* @param i			index of the parameter
* @param stmt			associated ps
* @param drdatype	drda type of the parameter
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void readandsetextparam  int i  drdastatement stmt
int drdatype  int extlen  boolean streamlob
throws drdaprotocolexception  sqlexception
preparedstatement ps   stmt getpreparedstatement
drdatype    drdatype   0x000000ff      need unsigned value
boolean checknullability   false
if  sqlamlevel >  mgrlvl_7
fdocaconstants isnullable drdatype
checknullability   true
try
final byte parambytes
final string paramstring
switch  drdatype
case  drdaconstants drda_type_lobbytes
case  drdaconstants drda_type_nlobbytes
paramstring
final boolean usesetbinarystream
stmt getparametermetadata   getparametertype i 1   types blob
if  streamlob    usesetbinarystream
parambytes   null
final extdtareaderinputstream stream
reader getextdtareaderinputstream checknullability
// save the streamed parameter so we can drain it if it does not get used
// by embedded when the statement is executed. derby-3085
stmt setstreamedparameter stream
if  stream instanceof standardextdtareaderinputstream
final standardextdtareaderinputstream stdeis
standardextdtareaderinputstream  stream
ps setbinarystream  i   1
stdeis
int  stdeis getlength
else if  stream instanceof layerbstreamedextdtareaderinputstream
enginepreparedstatement   ps  setbinarystream  i   1
stream
else if  stream    null
ps setbytes i 1  null
else
throw new illegalstateexception
if  sanitymanager debug
if  stream  null
trace
else
trace
else
final extdtareaderinputstream stream
reader getextdtareaderinputstream checknullability
if   stream    null
ps setbytes i 1

if  sanitymanager debug
trace
else
bytearrayinputstream bais
convertasbytearrayinputstream  stream
if  sanitymanager debug
trace
bais available
ps setbinarystream i 1
bais
bais available
break
case drdaconstants drda_type_lobcsbcs
case drdaconstants drda_type_nlobcsbcs
setascharacterstream stmt
i
checknullability
reader
streamlob
stmt ccsidsbcencoding
break
case drdaconstants drda_type_lobcdbcs
case drdaconstants drda_type_nlobcdbcs
setascharacterstream stmt
i
checknullability
reader
streamlob
stmt ccsiddbcencoding
break
case drdaconstants drda_type_lobcmixed
case drdaconstants drda_type_nlobcmixed
setascharacterstream stmt
i
checknullability
reader
streamlob
stmt ccsidmbcencoding
break
default
parambytes   null
paramstring
invalidvalue drdatype
catch  java io unsupportedencodingexception e
throw new sqlexception  e getmessage
catch  ioexception e
throw new sqlexception   e getmessage
/**
* parse excsqlimm - execute immediate statement
* instance variables
*  rdbnam - relational database name - optional
*  pkgnamcsn - rdb package name, consistency token and section number - required
*  rdbcmtok - rdb commit allowed - optional
*  monitor - monitor events - optional
*
* command objects
*  typdefnam - data type definition name - optional
*  typdefovr - typdef overrides -optional
*  sqlstt - sql statement -required
*
* @return update count
* @throws drdaprotocolexception
* @throws sqlexception
*/
private int parseexcsqlimm   throws drdaprotocolexception sqlexception
int codepoint
reader markcollection
pkgnamcsn pkgnamcsn   null
codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
// optional
case codepoint rdbnam
setdatabase codepoint excsqlimm
break
// required
case codepoint pkgnamcsn
pkgnamcsn   parsepkgnamcsn
break
case codepoint rdbcmtok
parserdbcmtok
break
//optional
case codepoint monitor
parsemonitor
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
drdastatement drdastmt    database getdefaultstatement pkgnamcsn
// initialize statement for reuse
drdastmt initialize
string sqlstmt   parseexecsqlimmobjects
statement statement   drdastmt getstatement
statement clearwarnings
if  pendingstatementtimeout >  0
statement setquerytimeout pendingstatementtimeout
pendingstatementtimeout    1
int updcount   statement executeupdate sqlstmt
return updcount
/**
* parse excsqlset - execute set sql environment
* instance variables
*  rdbnam - relational database name - optional
*  pkgnamct - rdb package name, consistency token  - optional
*  monitor - monitor events - optional
*
* command objects
*  typdefnam - data type definition name - required
*  typdefovr - typdef overrides - required
*  sqlstt - sql statement - required (at least one; may be more)
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private boolean parseexcsqlset   throws drdaprotocolexception sqlexception
int codepoint
reader markcollection
codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
// optional
case codepoint rdbnam
setdatabase codepoint excsqlset
break
// optional
case codepoint pkgnamct
// we are going to ignore this for excsqlset
// since we are just going to reuse an existing statement
string pkgnamct   parsepkgnamct
break
// optional
case codepoint monitor
parsemonitor
break
// required
case codepoint pkgnamcsn
// we are going to ignore this for excsqlset.
// since we are just going to reuse an existing statement.
// note: this codepoint is not in the ddm spec for 'excsqlset',
// but since it does get sent by jcc1.2, we have to have
// a case for it...
pkgnamcsn pkgnamcsn   parsepkgnamcsn
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
parseexcsqlsetobjects
return true
/**
* parse excsqlimm objects
* objects
*  typdefnam - data type definition name - optional
*  typdefovr - type defintion overrides
*  sqlstt - sql statement required
*
* if typdefnam and typdefovr are supplied, they apply to the objects
* sent with the statement.  once the statement is over, the default values
* sent in the accrdb are once again in effect.  if no values are supplied,
* the values sent in the accrdb are used.
* objects may follow in one dss or in several dss chained together.
*
* @return sql statement
* @throws drdaprotocolexception
* @throws sqlexception
*/
private string parseexecsqlimmobjects   throws drdaprotocolexception  sqlexception
string sqlstmt   null
int codepoint
drdastatement stmt   database getdefaultstatement
do
correlationid   reader readdssheader
while  reader moredssdata
codepoint   reader readlengthandcodepoint  false
switch codepoint
// optional
case codepoint typdefnam
setstmtordbbyteorder false  stmt  parsetypdefnam
break
// optional
case codepoint typdefovr
parsetypdefovr stmt
break
// required
case codepoint sqlstt
sqlstmt   parseencodedstring
if  sanitymanager debug
trace     sqlstmt
break
default
invalidcodepoint codepoint
while  reader ischainedwithsameid
// sqlstt is required
if  sqlstmt    null
missingcodepoint codepoint sqlstt
return sqlstmt
/**
* parse excsqlset objects
* objects
*  typdefnam - data type definition name - optional
*  typdefovr - type defintion overrides - optional
*  sqlstt - sql statement - required (a list of at least one)
*
* objects may follow in one dss or in several dss chained together.
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void parseexcsqlsetobjects
throws drdaprotocolexception  sqlexception
boolean gotsqlstt   false
boolean hadunrecognizedstmt   false
string sqlstmt   null
int codepoint
drdastatement drdastmt   database getdefaultstatement
drdastmt initialize
do
correlationid   reader readdssheader
while  reader moredssdata
codepoint   reader readlengthandcodepoint  false
switch codepoint
// optional
case codepoint typdefnam
setstmtordbbyteorder false  drdastmt  parsetypdefnam
break
// optional
case codepoint typdefovr
parsetypdefovr drdastmt
break
// required
case codepoint sqlstt
sqlstmt   parseencodedstring
if  sqlstmt    null
// then we have at least one sql statement.
gotsqlstt   true
if  sqlstmt startswith timeout_statement
string timeoutstring   sqlstmt substring timeout_statement length
pendingstatementtimeout   integer valueof timeoutstring  intvalue
break
if  canignorestmt sqlstmt
// we _know_ derby doesn't recognize this
// statement; don't bother trying to execute it.
// note: at time of writing, this only applies
// to "set client" commands, and it was decided
// that throwing a warning for these commands
// would confuse people, so even though the ddm
// spec says to do so, we choose not to (but
// only for set client cases).  if this changes
// at some point in the future, simply remove
// the follwing line; we will then throw a
// warning.
//							hadunrecognizedstmt = true;
break
if  sanitymanager debug
trace     sqlstmt
// initialize statement for reuse
drdastmt initialize
drdastmt getstatement   clearwarnings
try
drdastmt getstatement   executeupdate sqlstmt
catch  sqlexception e
// if this is a syntax error, then we take it
// to mean that the given set statement is not
// recognized; take note (so we can throw a
// warning later), but don't interfere otherwise.
if  e getsqlstate   equals syntax_err
hadunrecognizedstmt   true
else
// something else; assume it's serious.
throw e
break
default
invalidcodepoint codepoint
while  reader ischainedwithsameid
// sqlstt is required.
if   gotsqlstt
missingcodepoint codepoint sqlstt
// now that we've processed all set statements (assuming no
// severe exceptions), check for warnings and, if we had any,
// note this in the sqlcard reply object (but don't cause the
// excsqlset statement to fail).
if  hadunrecognizedstmt
sqlwarning warn   new sqlwarning
throw warn
end if
return
private boolean canignorestmt string stmt
if  stmt indexof        1
return true
return false
/**
* write rdbupdrm
* instance variables
*  svrcod - severity code - information only - required
*  rdbnam - relational database name -required
*  srvdgn - server diagnostic information -optional
*
* @exception drdaprotocolexception
*/
private void writerdbupdrm   throws drdaprotocolexception
database rdbupdrm_sent   true
writer createdssreply
writer startddm codepoint rdbupdrm
writer writescalar2bytes codepoint svrcod  codepoint svrcod_info
writerdbnam database dbname
writer endddmanddss
private string parsepkgnamct   throws drdaprotocolexception
reader skipbytes
return null
/**
* parse pkgnamcsn - rdb package name, consistency token, and section number
* instance variables
*   namesymdr - database name - not validated
*   rdbcolid - rdb collection identifier
*   pkgid - rdb package identifier
*   pkgcnstkn - rdb package consistency token
*   pkgsn - rdb package section number
*
* @return <code>pkgnamcsn</code> value
* @throws drdaprotocolexception
*/
private pkgnamcsn parsepkgnamcsn   throws drdaprotocolexception
if  reader getddmlength      codepoint pkgnamcsn_len
// this is a scalar object with the following fields
reader readstring rdbnam  codepoint rdbnam_len  true
if  sanitymanager debug
trace     rdbnam
// a check that the rdbnam field corresponds to a database
// specified in a accrdb term.
// the check is not performed if the client is dnc_client
// with version before 10.3.0 because these clients
// are broken and send incorrect database name
// if multiple connections to different databases
// are created
// this check was added because of derby-1434
// check the client version first
if   apprequester getclienttype      apprequester dnc_client
apprequester greaterthanorequalto 10 3 0
// check the database name
if   rdbnam tostring   equals database dbname
rdbnammismatch codepoint pkgnamcsn
reader readstring rdbcolid  codepoint rdbcolid_len  true
if  sanitymanager debug
trace     rdbcolid
reader readstring pkgid  codepoint pkgid_len  true
if  sanitymanager debug
trace     pkgid
// we need to use the same ucs2 encoding, as this can be
// bounced back to jcc (or keep the byte array)
reader readstring pkgcnstkn  codepoint pkgcnstkn_len  false
if  sanitymanager debug
trace     pkgcnstkn
pkgsn   reader readnetworkshort
if  sanitymanager debug
trace     pkgsn
else	   extended format
int length   reader readnetworkshort
if  length < codepoint rdbnam_len    length > codepoint max_name
badobjectlength codepoint rdbnam
reader readstring rdbnam  length  true
if  sanitymanager debug
trace     rdbnam
// a check that the rdbnam field corresponds to a database
// specified in a accrdb term.
// the check is not performed if the client is dnc_client
// with version before 10.3.0 because these clients
// are broken and send incorrect database name
// if multiple connections to different databases
// are created
// this check was added because of derby-1434
// check the client version first
if   apprequester getclienttype      apprequester dnc_client
apprequester greaterthanorequalto 10 3 0
// check the database name
if   rdbnam tostring   equals database dbname
rdbnammismatch codepoint pkgnamcsn
//rdbcolid can be variable length in this format
length   reader readnetworkshort
reader readstring rdbcolid  length  true
if  sanitymanager debug
trace     rdbcolid
length   reader readnetworkshort
if  length    codepoint pkgid_len
badobjectlength codepoint pkgid
reader readstring pkgid  codepoint pkgid_len  true
if  sanitymanager debug
trace     pkgid
reader readstring pkgcnstkn  codepoint pkgcnstkn_len  false
if  sanitymanager debug
trace     pkgcnstkn
pkgsn   reader readnetworkshort
if  sanitymanager debug
trace     pkgsn
// in most cases, the pkgnamcsn object is equal to the
// previously returned object. to avoid allocation of a new
// object in these cases, we first check to see if the old
// object can be reused.
if   prevpkgnamcsn    null
rdbnam wasmodified
rdbcolid wasmodified
pkgid wasmodified
pkgcnstkn wasmodified
prevpkgnamcsn getpkgsn      pkgsn
// the byte array returned by pkgcnstkn.getbytes() might
// be modified by ddmreader.readstring() later, so we have
// to create a copy of the array.
byte token   new byte
system arraycopy pkgcnstkn getbytes    0  token  0  token length
prevpkgnamcsn
new pkgnamcsn rdbnam tostring    rdbcolid tostring
pkgid tostring    pkgsn
new consistencytoken token
return prevpkgnamcsn
/**
* parse sqlstt dss
* @exception drdaprotocolexception
*/
private string parsesqlsttdss   throws drdaprotocolexception
correlationid   reader readdssheader
int codepoint   reader readlengthandcodepoint  false
string strval   parseencodedstring
if  sanitymanager debug
trace     strval
return strval
/**
* parse an encoded data string from the application requester
*
* @return string value
* @exception drdaprotocolexception
*/
private string parseencodedstring   throws drdaprotocolexception
if  sqlamlevel < 7
return parsevcmorvcs
else
return parsenocmornocs
/**
* parse variable character mixed byte or variable character single byte
* format
*  i2 - vcm length
*  n bytes - vcm value
*  i2 - vcs length
*  n bytes - vcs value
* only 1 of vcm length or vcs length can be non-zero
*
* @return string value
*/
private string parsevcmorvcs   throws drdaprotocolexception
string strval   null
int vcm_length   reader readnetworkshort
if  vcm_length > 0
strval   parseccsidmbc vcm_length
int vcs_length   reader readnetworkshort
if  vcs_length > 0
if  strval    null
agenterror
strval   parseccsidsbc vcs_length
return strval
/**
* parse nullable character mixed byte or nullable character single byte
* format
*  1 byte - null indicator
*  i4 - mixed character length
*  n bytes - mixed character string
*  1 byte - null indicator
*  i4 - single character length
*  n bytes - single character length string
*
* @return string value
* @exception drdaprotocolexception
*/
private string parsenocmornocs   throws drdaprotocolexception
byte nocm_nullbyte   reader readbyte
string strval   null
int length
if  nocm_nullbyte    null_value
length   reader readnetworkint
strval   parseccsidmbc length
byte nocs_nullbyte   reader readbyte
if  nocs_nullbyte    null_value
if  strval    null
agenterror
length   reader readnetworkint
strval   parseccsidsbc length
return strval
/**
* parse mixed character string
*
* @return string value
* @exception drdaprotocolexception
*/
private string parseccsidmbc int length  throws drdaprotocolexception
string strval   null
drdastatement  currentstatement
currentstatement   database getcurrentstatement
if  currentstatement    null
currentstatement   database getdefaultstatement
currentstatement initialize
string ccsidmbcencoding   currentstatement ccsidmbcencoding
if  length    0
return null
byte  bytestr   reader readbytes length
if  ccsidmbcencoding    null
try
strval   new string bytestr  0  length  ccsidmbcencoding
catch  unsupportedencodingexception e
agenterror     ccsidmbcencoding
else
agenterror
return strval
/**
* parse single byte character string
*
* @return string value
* @exception drdaprotocolexception
*/
private string parseccsidsbc int length  throws drdaprotocolexception
string strval   null
drdastatement  currentstatement
currentstatement   database getcurrentstatement
if  currentstatement    null
currentstatement   database getdefaultstatement
currentstatement initialize
string ccsidsbcencoding   currentstatement ccsidsbcencoding
system out println     ccsidsbcencoding
if  length    0
return null
byte  bytestr   reader readbytes length
if  ccsidsbcencoding    null
try
strval   new string bytestr  0  length  ccsidsbcencoding
catch  unsupportedencodingexception e
agenterror     ccsidsbcencoding
else
agenterror
return strval
/**
* parse clsqry
* instance variables
*  rdbnam - relational database name - optional
*  pkgnamcsn - rdb package name, consistency token and section number - required
*  qryinsid - query instance identifier - required - level 7
*  monitor - monitor events - optional.
*
* @return drdastatement being closed
* @throws drdaprotocolexception
* @throws sqlexception
*/
private drdastatement parseclsqry   throws drdaprotocolexception  sqlexception
pkgnamcsn pkgnamcsn   null
reader markcollection
long qryinsid   0
boolean gotqryinsid   false
int codepoint   reader getcodepoint
while  codepoint     1
switch  codepoint
// optional
case codepoint rdbnam
setdatabase codepoint clsqry
break
// required
case codepoint pkgnamcsn
pkgnamcsn   parsepkgnamcsn
break
case codepoint qryinsid
qryinsid   reader readnetworklong
gotqryinsid   true
break
// optional
case codepoint monitor
parsemonitor
break
default
invalidcodepoint codepoint
codepoint   reader getcodepoint
// check for required variables
if  pkgnamcsn    null
missingcodepoint codepoint pkgnamcsn
if  sqlamlevel >  mgrlvl_7     gotqryinsid
missingcodepoint codepoint qryinsid
drdastatement stmt   database getdrdastatement pkgnamcsn
if  stmt    null
//xxx should really throw a sql exception here
invalidvalue codepoint pkgnamcsn
if  stmt wasexplicitlyclosed
// jcc still sends a clsqry even though we have
// implicitly closed the resultset.
// then complains if we send the writeqrynoprm
// so for now don't send it
// also metadata calls seem to get bound to the same
// pgknamcsn, so even for explicit closes we have
// to ignore.
//writeqrynoprm(codepoint.svrcod_error);
pkgnamcsn   null
stmt clsqry
return stmt
/**
* parse monitor
* drda spec says this is optional.  since we
* don't currently support it, we just ignore.
*/
private void parsemonitor
throws drdaprotocolexception
// just ignore it.
reader skipbytes
return
private void writesqlcards sqlexception e  int updatecount
throws drdaprotocolexception
writesqlcards e  updatecount  false
private void writesqlcards sqlexception e  int updatecount  boolean sendsqlerrrm
throws drdaprotocolexception
int severity   codepoint svrcod_info
if  e    null
writesqlcard e severity  updatecount  0
return
// instead of writing a chain of sql error or warning, we send the first one, this is
// jcc/db2 limitation, see beetle 4629
// if it is a real sql error write a sqlerrrm first
severity   getexceptionseverity e
if  severity > codepoint svrcod_error
// for a session ending error > codepoint.srvcod_error you cannot
// send a sqlerrrm. a cmdchkrm is required.  in xa if there is a
// lock timeout it ends the whole session. i am not sure this
// is the correct behaviour but if it occurs we have to send
// a cmdchkrm instead of sqlerrm
writecmdchkrm severity
else if  sendsqlerrrm
writesqlerrrm severity
writesqlcard e severity  updatecount  0
private int getsqlcode int severity
if  severity    codepoint svrcod_warning 		   warning
return 100 		  cli likes it
else if  severity    codepoint svrcod_info
return 0
else
return  1
private void writesqlcard sqlexception e int severity
int updatecount  long rowcount   throws drdaprotocolexception
writer createdssobject
writer startddm codepoint sqlcard
writesqlcagrp e  getsqlcode severity   updatecount  rowcount
writer endddmanddss
// if we have a shutdown exception, restart the server.
if  e    null
string sqlstate   e getsqlstate
if  sqlstate regionmatches 0
sqlstate cloudscape_system_shutdown  0  5
// then we're here because of a shutdown exception;
// "clean up" by restarting the server.
try
server startnetworkserver
catch  exception restart
// any error messages should have already been printed,
// so we ignore this exception here.
/**
* write a null sqlcard as an object
*
* @exception drdaprotocolexception
*/
private void writenullsqlcardobject
throws drdaprotocolexception
writer createdssobject
writer startddm codepoint sqlcard
writesqlcagrp nullsqlstate  0  0  0
writer endddmanddss
/**
* write sqlerrrm
*
* instance variables
* 	svrcod - severity code - required
*
* @param	severity	severity of error
*
* @exception drdaprotocolexception
*/
private void writesqlerrrm int severity  throws drdaprotocolexception
writer createdssreply
writer startddm codepoint sqlerrrm
writer writescalar2bytes codepoint svrcod  severity
writer endddmanddss
/**
* write cmdchkrm
*
* instance variables
* 	svrcod - severity code - required
*
* @param	severity	severity of error
*
* @exception drdaprotocolexception
*/
private void writecmdchkrm int severity  throws drdaprotocolexception
writer createdssreply
writer startddm codepoint cmdchkrm
writer writescalar2bytes codepoint svrcod  severity
writer endddmanddss
/**
* translate from derby exception severity to svrcod
*
* @param e sqlexception
*/
private int getexceptionseverity  sqlexception e
int severity  codepoint svrcod_info
if  e    null
return severity
int ec   e geterrorcode
switch  ec
case exceptionseverity statement_severity
case exceptionseverity transaction_severity
severity   codepoint svrcod_error
break
case exceptionseverity warning_severity
severity   codepoint svrcod_warning
break
case exceptionseverity session_severity
case exceptionseverity database_severity
case exceptionseverity system_severity
severity   codepoint svrcod_sesdmg
break
default
string sqlstate   e getsqlstate
if  sqlstate    null    sqlstate startswith    		   warning
severity   codepoint svrcod_warning
else
severity   codepoint svrcod_error
return severity
/**
* write sqlcagrp
*
* sqlcagrp : fdoca early group
* sql communcations area group description
*
* format for sqlam <= 6
*   sqlcode; drda type i4; envlid 0x02; length override 4
*   sqlstate; drda type fcs; envlid 0x30; length override 5
*   sqlerrproc; drda type fcs; envlid 0x30; length override 8
*   sqlcaxgrp; drda type n-gda; envlid 0x52; length override 0
*
* format for sqlam >= 7
*   sqlcode; drda type i4; envlid 0x02; length override 4
*   sqlstate; drda type fcs; envlid 0x30; length override 5
*   sqlerrproc; drda type fcs; envlid 0x30; length override 8
*   sqlcaxgrp; drda type n-gda; envlid 0x52; length override 0
*   sqldiaggrp; drda type n-gda; envlid 0x56; length override 0
*
* @param e 	sqlexception encountered
* @param sqlcode	sqlcode
*
* @exception drdaprotocolexception
*/
private void writesqlcagrp sqlexception e  int sqlcode  int updatecount
long rowcount  throws drdaprotocolexception
if  e    null
// forwarding to the optimized version when there is no
// exception object
writesqlcagrp nullsqlstate  sqlcode  updatecount  rowcount
return
if  rowcount < 0    updatecount < 0
writer writebyte codepoint nulldata
return
if  sanitymanager debug    server debugoutput    sqlcode < 0
trace
trace   e getmessage
trace   e getsqlstate
trace   e geterrorcode
trace   e getnextexception
server consoleexceptionprint e
trace
//null indicator
writer writebyte 0
// sqlcode
writer writeint sqlcode
// sqlstate
writer writestring e getsqlstate
// sqlerrproc
// write the byte[] constant rather than the string, for efficiency
writer writebytes server prdidbytes_
// sqlcaxgrp
writesqlcaxgrp updatecount  rowcount  buildsqlerrmc e   e getnextexception
/**
* same as writesqlcagrp, but optimized for the case
* when there is no real exception, i.e. the exception is null, or "end
* of data"
*
* sqlcagrp : fdoca early group
* sql communcations area group description
*
* format for sqlam <= 6
*   sqlcode; drda type i4; envlid 0x02; length override 4
*   sqlstate; drda type fcs; envlid 0x30; length override 5
*   sqlerrproc; drda type fcs; envlid 0x30; length override 8
*   sqlcaxgrp; drda type n-gda; envlid 0x52; length override 0
*
* format for sqlam >= 7
*   sqlcode; drda type i4; envlid 0x02; length override 4
*   sqlstate; drda type fcs; envlid 0x30; length override 5
*   sqlerrproc; drda type fcs; envlid 0x30; length override 8
*   sqlcaxgrp; drda type n-gda; envlid 0x52; length override 0
*   sqldiaggrp; drda type n-gda; envlid 0x56; length override 0
*
* @param sqlstate     sqlstate (already converted to utf8)
* @param sqlcode    sqlcode
* @param updatecount
* @param rowcount
*
* @exception drdaprotocolexception
*/
private void writesqlcagrp byte sqlstate  int sqlcode
int updatecount  long rowcount  throws drdaprotocolexception
if  rowcount < 0    updatecount < 0
writer writebyte codepoint nulldata
return
//null indicator
writer writebyte 0
// sqlcode
writer writeint sqlcode
// sqlstate
writer writebytes sqlstate
// sqlerrproc
writer writebytes server prdidbytes_
// sqlcaxgrp (uses null as sqlerrmc since there is no error)
writesqlcaxgrp updatecount  rowcount  null  null
// delimiters for sqlerrmc values.
// the token delimiter value will be used to parse the messageid from the
// sqlerrmc in messageservice.getlocalizedmessage and the messageid will be
// used to retrive the localized message. if this delimiter value is changed
// please make sure to make appropriate changes in
// messageservice.getlocalizedmessage that gets called from
// systemprocedures.sqlcamessage
/**
* <code>sqlerrmc_token_delimiter</code> separates message argument tokens
*/
private static string sqlerrmc_token_delimiter   new string new char   char 20
/**
* <code>sqlerrmc_preformatted_message_delimiter</code>, when full message text is
* sent for severe errors. this value separates the messages.
*/
private static string sqlerrmc_preformatted_message_delimiter   new string
/**
* create error message or message argements to return to client.
* the sqlerrmc will normally be passed back  to the server in a call
* to the sysibm.sqlcamessage but for severe exceptions the stored procedure
* call cannot be made. so for severe messages we will just send the message text.
*
* this method will also truncate the value according the client capacity.
* ccc can only handle 70 characters.
*
* server sends the sqlerrmc using utf8 encoding to the client.
* to get the message, client sends back information to the server
* calling sysibm.sqlcamessage (see sqlca.getmessage).  several parameters
* are sent to this procedure including the locale, the sqlerrmc that the
* client received from the server.
* on server side, the procedure sqlcamessage in systemprocedures then calls
* the messageservice.getlocalizedmessage to retrieve the localized error message.
* in messageservice.getlocalizedmessage the sqlerrmc that is passed in,
* is parsed to retrieve the message id. the value it uses to parse the messageid
* is char value of 20, otherwise it uses the entire sqlerrmc as the message id.
* this messageid is then used to retrieve the localized message if present, to
* the client.
*
* @param se  sqlexception to build sqlerrmc
*
* @return  string which is either the message arguments to be passed to
*          sysibm.sqlcamessage or just message text for severe errors.
*/
private string buildsqlerrmc  sqlexception se
boolean severe    se geterrorcode   >   exceptionseverity session_severity
string sqlerrmc   null
// get exception which carries derby messageid and args, per derby-1178
se   util getexceptionfactory   getargumentferry  se
if  se instanceof embedsqlexception       severe
sqlerrmc   buildtokenizedsqlerrmc se
else
// if this is not an embedsqlexception or is a severe excecption where
// we have no hope of succussfully calling the sysibm.sqlcamessage send
// preformatted message using the server locale
sqlerrmc   buildpreformattedsqlerrmc se
// truncate the sqlerrmc to a length that the client can support.
int maxlen    sqlerrmc    null  ?  1   math min sqlerrmc length
apprequester supportedmessageparamlength
if   maxlen >  0      sqlerrmc length   > maxlen
// have to truncate so the client can handle it.
sqlerrmc   sqlerrmc substring 0  maxlen
return sqlerrmc
/**
* build preformatted sqlexception text
* for severe exceptions or sqlexceptions that are not embedsqlexceptions.
* just send the message text localized to the server locale.
*
* @param se  sqlexception for which to build sqlerrmc
* @return preformated message text
* 			with messages separted by sqlerrmc_preformated_message_delimiter
*
*/
private string  buildpreformattedsqlerrmc sqlexception se
if  se    null
return
stringbuffer sb   new stringbuffer
// string buffer to build up message
do
sb append se getlocalizedmessage
se   se getnextexception
if  se    null
sb append sqlerrmc_preformatted_message_delimiter
se getsqlstate
while  se    null
return sb tostring
/**
* build tokenized sqlerrmc to just send the tokenized arguments to the client.
* for a derby sqlexception or an sqlexception thrown by user code.
* message argument tokens are separated by sqlerrmc_token_delimiter
* multiple messages are separated by systemprocedures.sqlerrmc_message_delimiter
*
*                 ...
* @param se   sqlexception to print
*
*/
private string buildtokenizedsqlerrmc sqlexception se
string sqlerrmc
do
if   se instanceof embedsqlexception
string messageid     embedsqlexception se  getmessageid
// arguments are variable part of a message
object args     embedsqlexception se  getarguments
for  int i   0  args    null     i < args length  i
sqlerrmc    args   sqlerrmc_token_delimiter
sqlerrmc    messageid
se   se getnextexception
else
// this could happen for instance if an sqlexception was thrown
// from a stored procedure.
stringbuffer sb   new stringbuffer
sb append se getlocalizedmessage
se   se getnextexception
if  se    null
sb append sqlerrmc_token_delimiter
se getsqlstate
sqlerrmc    sb tostring
if  se    null
sqlerrmc    systemprocedures sqlerrmc_message_delimiter   se getsqlstate
while  se    null
return sqlerrmc
/**
* write sqlcaxgrp
*
* sqlcaxgrp : early fdoca group
* sql communications area exceptions group description
*
* format for sqlam <= 6
*   sqlrdbnme; drda type fcs; envlid 0x30; length override 18
*   sqlerrd1; drda type i4; envlid 0x02; length override 4
*   sqlerrd2; drda type i4; envlid 0x02; length override 4
*   sqlerrd3; drda type i4; envlid 0x02; length override 4
*   sqlerrd4; drda type i4; envlid 0x02; length override 4
*   sqlerrd5; drda type i4; envlid 0x02; length override 4
*   sqlerrd6; drda type i4; envlid 0x02; length override 4
*   sqlwarn0; drda type fcs; envlid 0x30; length override 1
*   sqlwarn1; drda type fcs; envlid 0x30; length override 1
*   sqlwarn2; drda type fcs; envlid 0x30; length override 1
*   sqlwarn3; drda type fcs; envlid 0x30; length override 1
*   sqlwarn4; drda type fcs; envlid 0x30; length override 1
*   sqlwarn5; drda type fcs; envlid 0x30; length override 1
*   sqlwarn6; drda type fcs; envlid 0x30; length override 1
*   sqlwarn7; drda type fcs; envlid 0x30; length override 1
*   sqlwarn8; drda type fcs; envlid 0x30; length override 1
*   sqlwarn9; drda type fcs; envlid 0x30; length override 1
*   sqlwarna; drda type fcs; envlid 0x30; length override 1
*   sqlerrmsg_m; drda type vcm; envlid 0x3e; length override 70
*   sqlerrmsg_s; drda type vcs; envlid 0x32; length override 70
*
* format for sqlam >= 7
*   sqlerrd1; drda type i4; envlid 0x02; length override 4
*   sqlerrd2; drda type i4; envlid 0x02; length override 4
*   sqlerrd3; drda type i4; envlid 0x02; length override 4
*   sqlerrd4; drda type i4; envlid 0x02; length override 4
*   sqlerrd5; drda type i4; envlid 0x02; length override 4
*   sqlerrd6; drda type i4; envlid 0x02; length override 4
*   sqlwarn0; drda type fcs; envlid 0x30; length override 1
*   sqlwarn1; drda type fcs; envlid 0x30; length override 1
*   sqlwarn2; drda type fcs; envlid 0x30; length override 1
*   sqlwarn3; drda type fcs; envlid 0x30; length override 1
*   sqlwarn4; drda type fcs; envlid 0x30; length override 1
*   sqlwarn5; drda type fcs; envlid 0x30; length override 1
*   sqlwarn6; drda type fcs; envlid 0x30; length override 1
*   sqlwarn7; drda type fcs; envlid 0x30; length override 1
*   sqlwarn8; drda type fcs; envlid 0x30; length override 1
*   sqlwarn9; drda type fcs; envlid 0x30; length override 1
*   sqlwarna; drda type fcs; envlid 0x30; length override 1
*   sqlrdbname; drda type vcs; envlid 0x32; length override 255
*   sqlerrmsg_m; drda type vcm; envlid 0x3e; length override 70
*   sqlerrmsg_s; drda type vcs; envlid 0x32; length override 70
* @param nextexception sqlexception encountered
* @param sqlerrmc sqlcode
*
* @exception drdaprotocolexception
*/
private void writesqlcaxgrp int updatecount   long rowcount  string sqlerrmc
sqlexception nextexception  throws drdaprotocolexception
writer writebyte 0  		   sqlcaxgrp indicator
if  sqlamlevel < 7
writerdbnam database dbname
writesqlcaerrwarn updatecount  rowcount
else
// sql errd1 - d6, warn0-warna (35 bytes)
writesqlcaerrwarn updatecount  rowcount
writer writeshort 0      ccc on win does not take rdbname
writevcmorvcs sqlerrmc
if  sqlamlevel > 7
writesqldiaggrp nextexception
/**
* write the err and warn part of the sqlca
*
* @param updatecount
* @param rowcount
*/
private void writesqlcaerrwarn int updatecount  long rowcount
// sql errd1 - errd2 - row count
writer writeint  int   rowcount>>>32
writer writeint  int  rowcount   0x0000000ffffffffl
// sql errd3 - updatecount
writer writeint updatecount
// sql errd4 - d6 (12 bytes)
writer writebytes errd4_d6      byte constant
// warn0-warna (11 bytes)
writer writebytes warn0_warna      byte constant
/**
* write sqldiaggrp: sql diagnostics group description - identity 0xd1
* nullable group
* sqldiagstt; drda type n-gda; envlid 0xd3; length override 0
* sqldiagcn;  drfa type n-rlo; envlid 0xf6; length override 0
* sqldiagci;  drda type n-rlo; envlid 0xf5; length override 0
*/
private void writesqldiaggrp sqlexception nextexception
throws drdaprotocolexception
// for now we only want to send row_deleted and row_updated warnings
// as extended diagnostics
// move to first row_deleted or row_updated exception. these have been
// added to the end of the warning chain.
while
nextexception    null
nextexception getsqlstate      sqlstate row_updated
nextexception getsqlstate      sqlstate row_deleted
nextexception   nextexception getnextexception
if   nextexception    null
diagnosticlevel    codepoint diaglvl0
writer writebyte codepoint nulldata
return
writer writebyte 0      sqldiaggrp indicator
writesqldiagstt
writesqldiagci nextexception
writesqldiagcn
/*
* writesqldiagstt: write nulldata for now
*/
private void writesqldiagstt
throws drdaprotocolexception
writer writebyte codepoint nulldata
return
/**
* writesqldiagci: sql diagnostics condition information array - identity 0xf5
* sqlnumrow; row lid 0x68; element taken 0(all); rep factor 1
* sqldcirow; row lid 0xe5; element taken 0(all); rep factor 0(all)
*/
private void writesqldiagci sqlexception nextexception
throws drdaprotocolexception
sqlexception se   nextexception
long rownum   1
/* write the number of next exceptions to expect */
writesqlnumrow se
while  se    null
string sqlstate   se getsqlstate
// sqlcode > 0 -> warning
// sqlcode = 0 -> info
// sqlcode < 0 -> error
int severity   getexceptionseverity se
int sqlcode    1
if  severity    codepoint svrcod_warning
sqlcode   1
else if  severity    codepoint svrcod_info
sqlcode   0
string sqlerrmc
if  diagnosticlevel    codepoint diaglvl1
sqlerrmc   se getlocalizedmessage
// arguments are variable part of a message
// only send arguments for diagnostic level 0
if  diagnosticlevel    codepoint diaglvl0
// we are only able to get arguments of embedsqlexception
if  se instanceof embedsqlexception
object args     embedsqlexception se  getarguments
for  int i   0  args    null     i < args length  i
sqlerrmc    args tostring     sqlerrmc_token_delimiter
string dbname   null
if  database    null
dbname   database dbname
writesqldcrow rownum    sqlcode  sqlstate  dbname  sqlerrmc
se   se getnextexception
return
/**
* writesqlnumrow: writes sqlnumrow : fdoca early row
* sql number of elements row description
* format for sqlam levels
* sqlnumgrp; group lid 0x58; element taken 0(all); rep factor 1
*/
private void writesqlnumrow sqlexception nextexception
throws drdaprotocolexception
writesqlnumgrp nextexception
/**
* writesqlnumgrp: writes sqlnumgrp : fdoca early group
* sql number of elements group description
* format for all sqlam levels
* sqlnum; drda type i2; envlid 0x04; length override 2
*/
private void writesqlnumgrp sqlexception nextexception
throws drdaprotocolexception
int i 0
sqlexception se
/* count the number of chained exceptions to be sent */
for  se   nextexception  se    null  se   se getnextexception    i
writer writeshort i
/**
* writesqldcrow: sql diagnostics condition row - identity 0xe5
* sqldcgrp; group lid 0xd5; element taken 0(all); rep factor 1
*/
private void writesqldcrow long rownum  int sqlcode  string sqlstate  string dbname
string sqlerrmc  throws drdaprotocolexception
writesqldcgrp rownum  sqlcode  sqlstate  dbname  sqlerrmc
/**
* writesqldcgrp: sql diagnostics condition group description
*
* sqldccode; drda type i4; envlid 0x02; length override 4
* sqldcstate; drda type fcs; envlid ox30; lengeh override 5
* sqldcreason; drda type i4; envlid 0x02; length override 4
* sqldclinen; drda type i4; envlid 0x02; length override 4
* sqldcrown; drda type fd; envlid 0x0e; lengeh override 31
* sqldcer01; drda type i4; envlid 0x02; length override 4
* sqldcer02; drda type i4; envlid 0x02; length override 4
* sqldcer03; drda type i4; envlid 0x02; length override 4
* sqldcer04; drda type i4; envlid 0x02; length override 4
* sqldcpart; drda type i4; envlid 0x02; length override 4
* sqldcppop; drda type i4; envlid 0x02; length override 4
* sqldcmsgid; drda type fcs; envlid 0x30; length override 10
* sqldcmde; drda type fcs; envlid 0x30; length override 8
* sqldcpmod; drda type fcs; envlid 0x30; length override 5
* sqldcrdb; drda type vcs; envlid 0x32; length override 255
* sqldctoks; drda type n-rlo; envlid 0xf7; length override 0
* sqldcmsg_m; drda type nvmc; envlid 0x3f; length override 32672
* sqldcmsg_s; drda type nvcs; envlid 0x33; length override 32672
* sqldccoln_m; drda type nvcm ; envlid 0x3f; length override 255
* sqldccoln_s; drda type nvcs; envlid 0x33; length override 255
* sqldccurn_m; drda type nvcm; envlid 0x3f; length override 255
* sqldccurn_s; drda type nvcs; envlid 0x33; length override 255
* sqldcpnam_m; drda type nvcm; envlid 0x3f; length override 255
* sqldcpnam_s; drda type nvcs; envlid 0x33; length override 255
* sqldcxgrp; drda type n-gda; envlid 0xd3; length override 1
*/
private void writesqldcgrp long rownum  int sqlcode  string sqlstate  string dbname
string sqlerrmc  throws drdaprotocolexception
// sqldccode
writer writeint sqlcode
// sqldcstate
writer writestring sqlstate
writer writeint 0  						   reason_code
writer writeint 0  						   line_number
writer writelong rownum  				   row_number
byte bytearray   new byte
writer writescalarpaddedbytes bytearray  47   byte  0
writer writeshort 0  					   ccc on win does not take rdbname
writer writebyte codepoint nulldata  	   message_tokens
writer writeldstring sqlerrmc  			   message_text
writevcmorvcs null  					   column_name
writevcmorvcs null  					   parameter_name
writevcmorvcs null  					   extended_name
writer writebyte codepoint nulldata  	   sqldcxgrp
/*
* writesqldiagcn: write nulldata for now
*/
private void writesqldiagcn
throws drdaprotocolexception
writer writebyte codepoint nulldata
return
/**
* write sqldard
*
* sqldard : fdoca early array
* sql descriptor area row description with sql communications area
*
* format for sqlam <= 6
*   sqlcard; row lid 0x64; element taken 0(all); rep factor 1
*   sqlnumrow; row lid 0x68; element taken 0(all); rep factor 1
*   sqldarow; row lid 0x60; element taken 0(all); rep factor 0(all)
*
* format for sqlam >= 7
*   sqlcard; row lid 0x64; element taken 0(all); rep factor 1
*   sqldhrow; row lid 0xe0; element taken 0(all); rep factor 1
*   sqlnumrow; row lid 0x68; element taken 0(all); rep factor 1
*
* @param stmt	prepared statement
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writesqldard drdastatement stmt  boolean rtnoutput  sqlexception e  throws drdaprotocolexception  sqlexception
preparedstatement ps   stmt getpreparedstatement
resultsetmetadata rsmeta   ps getmetadata
parametermetadata pmeta   stmt getparametermetadata
int numelems   0
if  e    null    e instanceof sqlwarning
if  rtnoutput     rsmeta    null
numelems   rsmeta getcolumncount
else if     rtnoutput      pmeta    null
numelems   pmeta getparametercount
writer createdssobject
// all went well we will just write a null sqlca
writer startddm codepoint sqldard
writesqlcagrp e  getsqlcode getexceptionseverity e    0  0
if  sqlamlevel >  mgrlvl_7
writesqldhrow ps getresultsetholdability
//sqlnumrow
if  sanitymanager debug
trace     numelems
writer writeshort numelems
for  int i 0  i < numelems  i
writesqldagrp  rsmeta  pmeta  i  rtnoutput
writer endddmanddss
/**
* write qrydsc - query answer set description
*
* @param stmt drdastatement we are working on
* @param fdodsconly	simply the fdodsc, without the wrap
*
* instance variables
*   sqldtagrp - required
*
* only 84 columns can be sent in a single qrydsc.  if there are more columns
* they must be sent in subsequent qrydsc.
* if the qrydsc will not fit into the current block, as many columns as can
* fit are sent and then the remaining are sent in the following blocks.
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writeqrydsc drdastatement stmt  boolean fdodsconly
throws drdaprotocolexception  sqlexception
resultset rs   null
resultsetmetadata rsmeta   null
parametermetadata pmeta   null
if   stmt needstosendparamdata
rs   stmt getresultset
if  rs    null 		   this is a callablestatement  use parameter meta data
pmeta   stmt getparametermetadata
else
rsmeta   rs getmetadata
int  numcols    rsmeta    null ? rsmeta getcolumncount     pmeta getparametercount
int numgroups   1
int colstart   1
int colend   numcols
int blksize   stmt getblksize   > 0 ? stmt getblksize     codepoint qryblksz_max
// check for remaining space in current query block
// need to mod with blksize so remaining doesn't go negative. 4868
int remaining   blksize    writer getdsslength    % blksize     3
fdocaconstants sqlcadta_sqldtard_rlo_size
// calcuate how may columns can be sent in the current query block
int firstcols   remaining fdocaconstants sqldtagrp_col_dsc_size
// check if it doesn't all fit into the first block and
//	under fdocaconstants.max_vars_in_ngda
if  firstcols < numcols    numcols > fdocaconstants max_vars_in_ngda
// we are limited to fdocaconstants.max_vars_in_ngda
if  firstcols > fdocaconstants max_vars_in_ngda
if  sanitymanager debug
sanitymanager assert numcols > fdocaconstants max_vars_in_ngda
numcols
numgroups   numcols fdocaconstants max_vars_in_ngda
// some left over
if  fdocaconstants max_vars_in_ngda   numgroups < numcols
numgroups
colend   fdocaconstants max_vars_in_ngda
else
colend   firstcols
numgroups     numcols firstcols  fdocaconstants max_vars_in_ngda
if  fdocaconstants max_vars_in_ngda   numgroups < numcols
numgroups
if    fdodsconly
writer createdssobject
writer startddm codepoint qrydsc
for  int i   0  i < numgroups  i
writesqldtagrp stmt  rsmeta  pmeta  colstart  colend
i    0 ? true   false
colstart   colend   1
// 4868 - limit range to max_vars_in_ngda (used to have extra col)
colend   colend   fdocaconstants max_vars_in_ngda
if  colend > numcols
colend   numcols
writer writebytes fdocaconstants sqlcadta_sqldtard_rlo
if    fdodsconly
writer endddmanddss
/**
* write sqldtagrp
* sqldagrp : late fdoca group
* sql data value group descriptor
*  length - length of the sqldtagrp
*  triplet_type - ngda for first, cpt for following
*  id - sqldtagrp_lid for first, null_lid for following
*  for each column
*    drda type
*	  length override
*	    for numeric/decimal types
*		  precison
*		  scale
*	    otherwise
*		  length or display_width
*
* @param stmt		drda statement
* @param rsmeta	resultset meta data
* @param pmeta		parameter meta data for callablestatement
* @param colstart	starting column for group to send
* @param colend	end column to send
* @param first		is this the first group
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writesqldtagrp drdastatement stmt  resultsetmetadata rsmeta
parametermetadata pmeta
int colstart  int colend  boolean first
throws drdaprotocolexception  sqlexception
int length     fdocaconstants sqldtagrp_col_dsc_size
colend 1    colstart     3
writer writebyte length
if  first
writer writebyte fdocaconstants ngda_triplet_type
writer writebyte fdocaconstants sqldtagrp_lid
else
//continued
writer writebyte fdocaconstants cpt_triplet_type
writer writebyte fdocaconstants null_lid
boolean hasrs    rsmeta    null  	    if don't have result  then we look at parameter meta
for  int i   colstart  i <  colend  i
boolean nullable    hasrs ?  rsmeta isnullable i     rsmeta columnnullable
pmeta isnullable i     jdbc30translation parameter_nullable
int coltype    hasrs ? rsmeta getcolumntype i    pmeta getparametertype i
int outlen     1
int drdatype   fdocaconstants mapjdbctypetodrdatype coltype nullable outlen
boolean isdecimal     drdatype   1     drdaconstants drda_type_ndecimal
int precision   0  scale   0
if  hasrs
precision   rsmeta getprecision i
scale   rsmeta getscale i
stmt setrsdrdatype i drdatype
stmt setrsprecision i  precision
stmt setrsscale i scale
else if  isdecimal
if  stmt isoutputparam i
precision   pmeta getprecision i
scale   pmeta getscale i
callablestatement  stmt ps  registeroutparameter i types decimal scale
if  sanitymanager debug
trace     coltype       integer tohexstring drdatype
// length or precision and scale for decimal values.
writer writebyte drdatype
if  isdecimal
writer writebyte precision
writer writebyte scale
else if  outlen     1
writer writeshort outlen
else if  hasrs
writer writeshort rsmeta getcolumndisplaysize i
else
writer writeshort stmt getparamlen i
/**
* holdability passed in as it can represent the holdability of
* the statement or a specific result set.
* @param holdability hold_cursors_over_commit or close_cursors_at_commit
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writesqldhrow int holdability  throws drdaprotocolexception sqlexception
if  jvminfo jdk_id < 2    write null indicator for sqldhrow because there is no holdability support prior to jdk1 3
writer writebyte codepoint nulldata
return
writer writebyte 0  		   sqldhrow indicator
//sqldhold
writer writeshort holdability
//sqldreturn
writer writeshort 0
//sqldscroll
writer writeshort 0
//sqldsensitive
writer writeshort 0
//sqldfcode
writer writeshort 0
//sqldkeytype
writer writeshort 0
//sqlrdbname
writer writeshort 0  	  ccc on windows somehow does not take any dbname
//sqldschema
writevcmorvcs null
/**
* write qrydta - query answer set data
*  contains some or all of the answer set data resulting from a query
*  if the client is not using rowset processing, this routine attempts
*  to pack as much data into the qrydta as it can. this may result in
*  splitting the last row across the block, in which case when the
*  client calls cntqry we will return the remainder of the row.
*
*  splitting a qrydta block is expensive, for several reasons:
*  - extra logic must be run, on both client and server side
*  - more network round-trips are involved
*  - the qrydta block which contains the continuation of the split
*    row is generally wasteful, since it contains the remainder of
*    the split row but no additional rows.
*  since splitting is expensive, the server makes some attempt to
*  avoid it. currently, the server's algorithm for this is to
*  compute the length of the current row, and to stop trying to pack
*  more rows into this buffer if another row of that length would
*  not fit. however, since rows can vary substantially in length,
*  this algorithm is often ineffective at preventing splits. for
*  example, if a short row near the end of the buffer is then
*  followed by a long row, that long row will be split. it is possible
*  to improve this algorithm substantially:
*  - instead of just using the length of the previous row as a guide
*    for whether to attempt packing another row in, use some sort of
*    overall average row size computed over multiple rows (e.g., all
*    the rows we've placed into this qrydta block, or all the rows
*    we've process for this result set)
*  - when we discover that the next row will not fit, rather than
*    splitting the row across qrydta blocks, if it is relatively
*    small, we could just hold the entire row in a buffer to place
*    it entirely into the next qrydta block, or reset the result
*    set cursor back one row to "unread" this row.
*  - when splitting a row across qrydta blocks, we tend to copy
*    data around multiple times. careful coding could remove some
*    of these copies.
*  however, it is important not to over-complicate this code: it is
*  better to be correct than to be efficient, and there have been
*  several bugs in the split logic already.
*
* instance variables
*   byte string
*
* @param stmt	drda statement we are processing
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writeqrydta  drdastatement stmt
throws drdaprotocolexception  sqlexception
boolean getmoredata   true
boolean sentextdata   false
int startlength   0
writer createdssobject
if  sanitymanager debug
trace
writer startddm codepoint qrydta
// check to see if there was leftover data from splitting
// the previous qrydta for this result set. if there was, and
// if we have now sent all of it, send any extdta for that row
// and increment the rowcount which we failed to increment in
// writefdodta when we realized the row needed to be split.
if  processleftoverqrydta stmt
if  stmt getsplitqrydta      null
stmt rowcount    1
if  stmt getextdtaobjects      null
writeextdta stmt
return
while getmoredata
sentextdata   false
getmoredata   writefdodta stmt
if  stmt getextdtaobjects      null
stmt getsplitqrydta      null
writer endddmanddss
writeextdta stmt
getmoredata false
sentextdata   true
// if we don't have enough room for a row of the
// last row's size, don't try to cram it in.
// it would get split up but it is not very efficient.
if  getmoredata    true
int endlength   writer getdsslength
int rowsize   endlength   startlength
if   stmt getblksize     endlength   < rowsize
getmoredata   false
startlength   endlength
// if we sent extdta we will rely on
// writescalarstream to end the dss with the proper chaining.
// otherwise end it here.
if    sentextdata
writer endddmanddss
if   stmt hasdata
final boolean qryclsonlmtblkprc
apprequester supportsqryclsimpforlmtblkprc
if  stmt isrscloseimplicit qryclsonlmtblkprc
stmt rsclose
/**
* this routine places some data into the current qrydta block using
* fdodta (formatted data object data rules).
*
* there are 3 basic types of processing flow for this routine:
* - in normal non-rowset, non-scrollable cursor flow, this routine
*   places a single row into the qrydta block and returns true,
*   indicating that the caller can call us back to place another
*   row into the result set if he wishes. (the caller may need to
*   send externalized data, which would be a reason for him not to
*   place any more rows into the qrydta).
* - in rowset processing, this routine places an entire rowset of
*   rows into the qrydta block and returns false, indicating that
*   the qrydta block is full and should now be sent.
* - in callable statement processing, this routine places the
*   results from the output parameters of the called procedure into
*   the qrydta block. this code path is really dramatically
*   different from the other two paths and shares only a very small
*   amount of common code in this routine.
*
* in all cases, it is possible that the data we wish to return may
* not fit into the qrydta block, in which case we call splitqrydta
* to split the data and remember the remainder data in the result set.
* splitting the data is relatively rare in the normal cursor case,
* because our caller (writeqrydta) uses a coarse estimation
* technique to avoid calling us if he thinks a split is likely.
*
* the overall structure of this routine is implemented as two
* loops:
* - the outer "do ... while ... " loop processes a rowset, one row
*   at a time. for non-rowset cursors, and for callable statements,
*   this loop executes only once.
* - the inner "for ... i < numcols ..." loop processes each column
*   in the current row, or each output parmeter in the procedure.
*
* most column data is written directly inline in the qrydta block.
* some data, however, is written as externalized data. this is
* commonly used for large objects. in that case, an externalized
* data pointer is written into the qrydta block, and the actual
* data flows in separate extdta blocks which are returned
* after this qrydta block.
*/
private boolean writefdodta  drdastatement stmt
throws drdaprotocolexception  sqlexception
boolean hasdata   false
int blksize   stmt getblksize   > 0 ? stmt getblksize     codepoint qryblksz_max
long rowcount   0
resultset rs  null
boolean moredata    stmt getqryprctyp
codepoint lmtblkprc
int  numcols
if   stmt needstosendparamdata
rs   stmt getresultset
if  rs    null
numcols   stmt getnumrscols
if  stmt isscrollable
hasdata   positioncursor stmt  rs
else
hasdata   rs next
else	   it's for a callablestatement
hasdata   stmt hasoutputparams
numcols   stmt getdrdaparamcount
do
if   hasdata
donedata stmt  rs
moredata   false
return moredata
// send resultset warnings if there are any
sqlwarning sqlw    rs    null ? rs getwarnings    null
if  rs    null
rs clearwarnings
// for updatable, insensitive result sets we signal the
// row updated condition to the client via a warning to be
// popped by client onto its rowupdated state, i.e. this
// warning should not reach api level.
if  rs    null    rs rowupdated
sqlwarning w   new sqlwarning    sqlstate row_updated
exceptionseverity warning_severity
if  sqlw    null
sqlw setnextwarning w
else
sqlw   w
// delete holes are manifest as a row consisting of a non-null
// sqlcard and a null data group. the sqlcard has a warning
// sqlstate of 02502
if  rs    null    rs rowdeleted
sqlwarning w   new sqlwarning    sqlstate row_deleted
exceptionseverity warning_severity
if  sqlw    null
sqlw setnextwarning w
else
sqlw   w
if  sqlw    null
writesqlcagrp nullsqlstate  0   1   1
else
writesqlcagrp sqlw  sqlw geterrorcode    1   1
// if we were asked not to return data, mark qrydta null; do not
// return yet, need to make rowcount right
// if the row has been deleted return qrydta null (delete hole)
boolean noretrievers    rs    null
stmt getqryrtndta      rs rowdeleted
if  noretrievers
writer writebyte 0xff      qrydta null indicator  is null
else
writer writebyte 0      qrydta null indicator  not null
for  int i   1  i <  numcols  i
if  noretrievers
break
int drdatype
int ndrdatype
int precision
int scale
object val   null
boolean valnull
if  rs    null
drdatype     stmt getrsdrdatype i    0xff
precision   stmt getrsprecision i
scale   stmt getrsscale i
ndrdatype   drdatype   1
if  sanitymanager debug
trace     java lang integer tohexstring drdatype
precision      scale
switch  ndrdatype
case drdaconstants drda_type_nlobbytes
case  drdaconstants drda_type_nlobcmixed
extdtainputstream extdtastream
extdtainputstream getextdtastream rs  i  drdatype
writefdocaval i extdtastream  drdatype
precision scale extdtastream isnull   stmt
break
case drdaconstants drda_type_ninteger
int ival   rs getint i
valnull   rs wasnull
if  sanitymanager debug
trace    ival       valnull
writenullability drdatype valnull
if    valnull
writer writeint ival
break
case drdaconstants drda_type_nsmall
short sval   rs getshort i
valnull   rs wasnull
if  sanitymanager debug
trace    sval       valnull
writenullability drdatype valnull
if    valnull
writer writeshort sval
break
case drdaconstants drda_type_ninteger8
long lval   rs getlong i
valnull   rs wasnull
if  sanitymanager debug
trace    lval       valnull
writenullability drdatype valnull
if    valnull
writer writelong lval
break
case drdaconstants drda_type_nfloat4
float fval   rs getfloat i
valnull   rs wasnull
if  sanitymanager debug
trace    fval       valnull
writenullability drdatype valnull
if    valnull
writer writefloat fval
break
case drdaconstants drda_type_nfloat8
double dval   rs getdouble i
valnull   rs wasnull
if  sanitymanager debug
trace    dval       valnull
writenullability drdatype valnull
if    valnull
writer writedouble dval
break
case drdaconstants drda_type_nchar
case drdaconstants drda_type_nvarchar
case drdaconstants drda_type_nvarmix
case drdaconstants drda_type_nlong
case drdaconstants drda_type_nlongmix
string valstr   rs getstring i
if  sanitymanager debug
trace    valstr
writefdocaval i  valstr  drdatype
precision scale rs wasnull   stmt
break
default
writefdocaval i  rs getobject i  drdatype
precision scale rs wasnull   stmt
else
drdatype     stmt getparamdrdatype i    0xff
precision   stmt getparamprecision i
scale   stmt getparamscale i
if  stmt isoutputparam i
int outlen   new int
drdatype   fdocaconstants mapjdbctypetodrdatype stmt getoutputparamtype i  true outlen
precision   stmt getoutputparamprecision i
scale   stmt getoutputparamscale i
if  sanitymanager debug
trace   i
val     callablestatement  stmt ps  getobject i
valnull    val    null
writefdocaval i val drdatype precision  scale  valnull stmt
else
writefdocaval i null drdatype precision scale true stmt
// does all this fit in one qrydta
if  writer getdsslength   > blksize
splitqrydta stmt  blksize
return false
if  rs    null
return moredata
//get the next row
rowcount
if  rowcount < stmt getqryrowset
hasdata   rs next
/*(1) scrollable we return at most a row set; or (2) no retrieve data
*/
else if  stmt isscrollable      noretrievers
moredata false
while  hasdata    rowcount < stmt getqryrowset
// add rowcount to statement row count
// for non scrollable cursors
if   stmt isscrollable
stmt rowcount    rowcount
if   hasdata
donedata stmt  rs
moredata false
if   stmt isscrollable
stmt sethasdata hasdata
return moredata
/**
* split qrydta into blksize chunks
*
* this routine is called if the qrydta data will not fit. it writes
* as much data as it can, then stores the remainder in the result
* set. at some later point, when the client returns with a cntqry,
* we will call processleftoverqrydta to handle that data.
*
* the interaction between drdaconnthread and ddmwriter is rather
* complicated here. this routine gets called because drdaconnthread
* realizes that it has constructed a qrydta message which is too
* large. at that point, we need to reclaim the "extra" data and
* hold on to it. to aid us in that processing, ddmwriter provides
* the routines getdsslength, copydssdatatoend, and truncatedss.
* for some additional detail on this complex sub-protocol, the
* interested reader should study bug derby-491 and 492 at:
* http://issues.apache.org/jira/browse/derby-491 and
* http://issues.apache.org/jira/browse/derby-492
*
* @param stmt drda statment
* @param blksize size of query block
*
* @throws sqlexception
* @throws drdaprotocolexception
*/
private void splitqrydta drdastatement stmt  int blksize  throws sqlexception
drdaprotocolexception
// make copy of extra data
byte  temp   writer copydssdatatoend blksize
// truncate to end of blocksize
writer truncatedss blksize
if  temp length    0
agenterror
blksize
stmt setsplitqrydta temp
/**
* process remainder data resulting from a split.
*
* this routine is called at the start of building each qrydta block.
* normally, it observes that there is no remainder data from the
* previous qrydta block, and returns false, indicating that there
* was nothing to do.
*
* however, if it discovers that the previous qrydta block was split,
* then it retrieves the remainder data from the result set, writes
* as much of it as will fit into the qrydta block (hopefully all of
* it will fit, but the row may be very long), and returns true,
* indicating that this qrydta block has been filled with remainder
* data and should now be sent immediately.
*/
private boolean processleftoverqrydta drdastatement stmt
throws sqlexception drdaprotocolexception
byte leftovers   stmt getsplitqrydta
if  leftovers    null
return false
int blksize   stmt getblksize   > 0 ? stmt getblksize     codepoint qryblksz_max
blksize   blksize   10    dss header   qrydta and length
if  leftovers length < blksize
writer writebytes leftovers  0  leftovers length
stmt setsplitqrydta null
else
writer writebytes leftovers  0  blksize
byte newleftovers   new byte
for  int i   0  i < newleftovers length  i
newleftovers   leftovers
stmt setsplitqrydta newleftovers
// finish off query block and send
writer endddmanddss
return true
/**
* done data
* send sqlcard for the end of the data
*
* @param stmt drda statement
* @param rs result set
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void donedata drdastatement stmt  resultset rs
throws drdaprotocolexception  sqlexception
if  sanitymanager debug
trace
int blksize   stmt getblksize   > 0 ? stmt getblksize     codepoint qryblksz_max
if  rs    null
if  stmt isscrollable
//keep isafterlast and isbeforefirst to be able
//to reposition after counting rows
boolean isafterlast   rs isafterlast
boolean isbeforefirst   rs isbeforefirst
// for scrollable cursors - calculate the row count
// since we may not have gone through each row
rs last
stmt rowcount    rs getrow
// reposition after last or before first
if  isafterlast
rs afterlast
if  isbeforefirst
rs beforefirst
else     non scrollable cursor
final boolean qryclsonlmtblkprc
apprequester supportsqryclsimpforlmtblkprc
if  stmt isrscloseimplicit qryclsonlmtblkprc
stmt rsclose
stmt rssuspend
// for scrollable cursor's qryscraft, when we reach here, drda spec says sqlstate
// is 00000, sqlcode is not mentioned.  but db2 cli code expects sqlcode to be 0.
// we return sqlcode 0 in this case, as the db2 server does.
boolean isqryscraft    stmt getqryscrorn      codepoint qryscraft
// using sqlstate 00000 or 02000 for end of data.
writesqlcagrp  isqryscraft ? eod00000   eod02000
isqryscraft ? 0   100   0  stmt rowcount
writer writebyte codepoint nulldata
// does all this fit in one qrydta
if  writer getdsslength   > blksize
splitqrydta stmt  blksize
/**
* position cursor for insensitive scrollable cursors
*
* @param stmt	drda statement
* @param rs	result set
*/
private boolean positioncursor drdastatement stmt  resultset rs
throws sqlexception  drdaprotocolexception
boolean retval   false
switch  stmt getqryscrorn
case codepoint qryscrrel
int rows    int stmt getqryrownbr
if   rs isafterlast      rows > 0      rs isbeforefirst      rows < 0
retval   false
else
retval   rs relative rows
break
case codepoint qryscrabs
// jcc uses an absolute value of 0 which is not allowed in jdbc
// we translate it into beforefirst which seems to work.
if  stmt getqryrownbr      0
rs beforefirst
retval   false
else
retval   rs absolute  int stmt getqryrownbr
break
case codepoint qryscraft
rs afterlast
retval   false
break
case codepoint qryscrbef
rs beforefirst
retval   false
break
default
agenterror    stmt getqryscrorn
return retval
/**
* write sqldagrp
* sqldagrp : early fdoca group
* sql data area group description
*
* format for sqlam <= 6
*   sqlprecision; drda type i2; envlid 0x04; length override 2
*   sqlscale; drda type i2; envlid 0x04; length override 2
*   sqllength; drda type i4; envlid 0x02; length override 4
*   sqltype; drda type i2; envlid 0x04; length override 2
*   sqlccsid; drda type fb; envlid 0x26; length override 2
*   sqlname_m; drda type vcm; envlid 0x3e; length override 30
*   sqlname_s; drda type vcs; envlid 0x32; length override 30
*   sqllabel_m; drda type vcm; envlid 0x3e; length override 30
*   sqllabel_s; drda type vcs; envlid 0x32; length override 30
*   sqlcomments_m; drda type vcm; envlid 0x3e; length override 254
*   sqlcomments_m; drda type vcs; envlid 0x32; length override 254
*
* format for sqlam == 6
*   sqlprecision; drda type i2; envlid 0x04; length override 2
*   sqlscale; drda type i2; envlid 0x04; length override 2
*   sqllength; drda type i8; envlid 0x16; length override 8
*   sqltype; drda type i2; envlid 0x04; length override 2
*   sqlccsid; drda type fb; envlid 0x26; length override 2
*   sqlname_m; drda type vcm; envlid 0x3e; length override 30
*   sqlname_s; drda type vcs; envlid 0x32; length override 30
*   sqllabel_m; drda type vcm; envlid 0x3e; length override 30
*   sqllabel_s; drda type vcs; envlid 0x32; length override 30
*   sqlcomments_m; drda type vcm; envlid 0x3e; length override 254
*   sqlcomments_m; drda type vcs; envlid 0x32; length override 254
*   sqludtgrp; drda type n-gda; envlid 0x51; length override 0
*
* format for sqlam >= 7
*   sqlprecision; drda type i2; envlid 0x04; length override 2
*   sqlscale; drda type i2; envlid 0x04; length override 2
*   sqllength; drda type i8; envlid 0x16; length override 8
*   sqltype; drda type i2; envlid 0x04; length override 2
*   sqlccsid; drda type fb; envlid 0x26; length override 2
*   sqldoptgrp; drda type n-gda; envlid 0xd2; length override 0
*
* @param rsmeta	resultset meta data
* @param pmeta		parameter meta data
* @param elemnum	column number we are returning (in case of result set), or,
*					parameter number (in case of parameter)
* @param rtnoutput	whether this is for a result set
*
* @throws drdaprotocolexception
* @throws sqlexception
*/
private void writesqldagrp resultsetmetadata rsmeta
parametermetadata pmeta
int elemnum  boolean rtnoutput
throws drdaprotocolexception  sqlexception
//jdbc uses offset of 1
int jdbcelemnum   elemnum  1
// length to be retreived as output parameter
int  outlen     1
int elemtype   rtnoutput ? rsmeta getcolumntype jdbcelemnum    pmeta getparametertype jdbcelemnum
int precision   rtnoutput ? rsmeta getprecision jdbcelemnum    pmeta getprecision jdbcelemnum
if  precision > fdocaconstants numeric_max_precision
precision   fdocaconstants numeric_max_precision
// 2-byte precision
writer writeshort precision
// 2-byte scale
int scale    rtnoutput ? rsmeta getscale jdbcelemnum    pmeta getscale jdbcelemnum
writer writeshort scale
boolean nullable   rtnoutput ?  rsmeta isnullable jdbcelemnum
resultsetmetadata columnnullable
pmeta isnullable jdbcelemnum     jdbc30translation parameter_nullable
int sqltype   sqltypes mapjdbctypetodb2sqltype elemtype
nullable
outlen
if  outlen     1    some types not set
switch  elemtype
case types decimal
case types numeric
scale   rtnoutput ? rsmeta getscale jdbcelemnum    pmeta getscale jdbcelemnum
outlen     precision <<8     scale <<0
if  sanitymanager debug
trace    precision
scale
break
default
outlen   math min fdocaconstants longvarchar_max_len
rtnoutput ? rsmeta getcolumndisplaysize jdbcelemnum
pmeta getprecision jdbcelemnum
switch  elemtype
case types binary
case types varbinary
case types longvarbinary
case types blob 			  for cli describe to be correct
case types clob
outlen    rtnoutput ? rsmeta getprecision jdbcelemnum
pmeta getprecision jdbcelemnum
if  sanitymanager debug
trace     java lang integer tohexstring outlen        elemtype
// 8 or 4 byte sqllength
if  sqlamlevel >  mgrlvl_6
writer writelong outlen
else
writer writeint outlen
string typename   rtnoutput ? rsmeta getcolumntypename jdbcelemnum
pmeta getparametertypename jdbcelemnum
if  sanitymanager debug
trace     typename       sqltype      outlen
writer writeshort sqltype
// ccsid
// ccsid should be 0 for binary types.
if  elemtype    java sql types char
elemtype    java sql types varchar
elemtype    java sql types longvarchar
elemtype    java sql types clob
writer writescalar2bytes 1208
else
writer writescalar2bytes 0
if  sqlamlevel < mgrlvl_7
//sqlname
writevcmorvcs rtnoutput ? rsmeta getcolumnname jdbcelemnum    null
//sqllabel
writevcmorvcs null
//sqlcomments
writevcmorvcs null
if  sqlamlevel    mgrlvl_6
writesqludtgrp rsmeta  pmeta  jdbcelemnum  rtnoutput
else
writesqldoptgrp rsmeta  pmeta  jdbcelemnum  rtnoutput
/**
* write variable character mixed byte or single byte
* the preference is to write mixed byte if it is defined for the server,
* since that is our default and we don't allow it to be changed, we always
* write mixed byte.
*
* @param s	string to write
* @exception drdaprotocolexception
*/
private void writevcmorvcs string s
throws drdaprotocolexception
//write only vcm and 0 length for vcs
if  s    null
writer writeshort 0
writer writeshort 0
return
// vcm
writer writeldstring s
// vcs
writer writeshort 0
private void writesqludtgrp resultsetmetadata rsmeta
parametermetadata pmeta
int jdbcelemnum  boolean rtnoutput
throws drdaprotocolexception sqlexception
writer writebyte codepoint nulldata
private void writesqldoptgrp resultsetmetadata rsmeta
parametermetadata pmeta
int jdbcelemnum  boolean rtnoutput
throws drdaprotocolexception sqlexception
writer writebyte 0
//sqlunamed
writer writeshort 0
//sqlname
writevcmorvcs rtnoutput ? rsmeta getcolumnname jdbcelemnum    null
//sqllabel
writevcmorvcs null
//sqlcomments
writevcmorvcs null
//sqldudtgrp
writesqludtgrp rsmeta  pmeta  jdbcelemnum  rtnoutput
//sqldxgrp
writesqldxgrp rsmeta  pmeta  jdbcelemnum  rtnoutput
private void writesqldxgrp resultsetmetadata rsmeta
parametermetadata pmeta
int jdbcelemnum  boolean rtnoutput
throws drdaprotocolexception sqlexception
// null indicator indicates we have data
writer writebyte 0
//   sqlxkeymem; drda type i2; envlid 0x04; length override 2
// hard to get primary key info. send 0 for now
writer writeshort 0
//   sqlxupdateable; drda type i2; envlid 0x04; length override 2
writer writeshort rtnoutput ? rsmeta iswritable jdbcelemnum    false
//   sqlxgenerated; drda type i2; envlid 0x04; length override 2
if  rtnoutput    rsmeta isautoincrement jdbcelemnum
writer writeshort 2
else
writer writeshort 0
//   sqlxparmmode; drda type i2; envlid 0x04; length override 2
if  pmeta    null     rtnoutput
int mode   pmeta getparametermode jdbcelemnum
if  mode     jdbc30translation parameter_mode_unknown
// for old style callable statements. we assume in/out if it
// is an output parameter.
int type    drdastatement getoutputparametertypefromclassname
pmeta getparameterclassname jdbcelemnum
if  type    drdastatement not_output_param
mode   jdbc30translation parameter_mode_in_out
writer writeshort mode
else
writer writeshort 0
//   sqlxrdbnam; drda type vcs; envlid 0x32; length override 255
// jcc uses this as the catalog name so we will send null.
writer writeshort 0
//   sqlxcorname_m; drda type vcm; envlid 0x3e; length override 255
//   sqlxcorname_s; drda type vcs; envlid 0x32; length override 255
writevcmorvcs null
//   sqlxbasename_m; drda type vcm; envlid 0x3e; length override 255
//   sqlxbasename_s; drda type vcs; envlid 0x32; length override 255
writevcmorvcs rtnoutput ? rsmeta gettablename jdbcelemnum    null
//   sqlxschema_m; drda type vcm; envlid 0x3e; length override 255
//   sqlxschema_s; drda type vcs; envlid 0x32; length override 255
writevcmorvcs rtnoutput ? rsmeta getschemaname jdbcelemnum   null
//   sqlxname_m; drda type vcm; envlid 0x3e; length override 255
//   sqlxname_s; drda type vcs; envlid 0x32; length override 255
writevcmorvcs rtnoutput ? rsmeta getcolumnname jdbcelemnum   null
/**
* write fdoca value to client
* @param index     index of column being returned
* @param val       value to write to client
* @param drdatype  fd:oca drda type from fdocaconstants
* @param precision precision
* @param stmt       statement being processed
*
* @exception drdaprotocolexception
*
* @exception sqlexception
*
* @see fdocaconstants
*/
protected void writefdocaval int index  object val  int drdatype
int precision  int scale  boolean valnull
drdastatement stmt  throws drdaprotocolexception  sqlexception
writenullability drdatype valnull
if    valnull
int ndrdatype   drdatype   1
long vallength   0
switch  ndrdatype
case drdaconstants drda_type_nsmall
// db2 does not have a boolean java.sql.bit type,
// so we need to send it as a small
if  val instanceof boolean
writer writeshort   boolean  val  booleanvalue
else if  val instanceof short
writer writeshort   short  val  shortvalue
else if  val instanceof byte
writer writeshort   byte  val  bytevalue
else
writer writeshort   integer  val  shortvalue
break
case  drdaconstants drda_type_ninteger
writer writeint   integer  val  intvalue
break
case drdaconstants drda_type_ninteger8
writer writelong   long  val  longvalue
break
case drdaconstants drda_type_nfloat4
writer writefloat   float  val  floatvalue
break
case drdaconstants drda_type_nfloat8
writer writedouble   double  val  doublevalue
break
case drdaconstants drda_type_ndecimal
if  precision    0
precision   fdocaconstants numeric_default_precision
bigdecimal bd    java math bigdecimal  val
writer writebigdecimal bd precision scale
break
case drdaconstants drda_type_ndate
writer writestring   java sql date  val  tostring
break
case drdaconstants drda_type_ntime
writer writestring   java sql time  val  tostring
break
case drdaconstants drda_type_ntimestamp
// we need to send it in a slightly different format, and pad it
// up to or truncate it into 26 chars
string ts1     java sql timestamp  val  tostring
string ts2   ts1 replace      replace
int tslen   ts2 length
if  tslen < 26
for  int i   0  i < 26 tslen  i
ts2
else if  tslen > 26
ts2   ts2 substring 0 26
writer writestring ts2
break
case drdaconstants drda_type_nchar
writer writestring   string  val  tostring
break
case drdaconstants drda_type_nvarchar
case drdaconstants drda_type_nvarmix
case drdaconstants drda_type_nlong
case drdaconstants drda_type_nlongmix
//writeldstring and generate warning if truncated
// which will be picked up by checkwarning()
writer writeldstring val tostring    index
break
case drdaconstants drda_type_nlobbytes
case drdaconstants drda_type_nlobcmixed
// do not send extdta for lob of length 0, beetle 5967
if      extdtainputstream  val  isemptystream
stmt addextdtaobject val  index
//indicate externalized and size is unknown.
writer writeextendedlength 0x8000
else
writer writeextendedlength 0
break
case  drdaconstants drda_type_nfixbyte
writer writebytes  byte  val
break
case drdaconstants drda_type_nvarbyte
case drdaconstants drda_type_nlongvarbyte
writer writeldbytes  byte  val  index
break
case drdaconstants drda_type_nlobloc
case drdaconstants drda_type_nclobloc
writer writeint   enginelob val  getlocator
break
default
if  sanitymanager debug
trace   ndrdatype
writer writeldstring val tostring    index
/**
* write nullability if this is a nullable drdatype and fdoca null
* value if appropriate
* @param drdatype      fdoca type
* @param valnull       true if this is a null value. false otherwise
*
**/
private void writenullability int drdatype  boolean valnull
if fdocaconstants isnullable drdatype
if  valnull
writer writebyte fdocaconstants null_data
else
writer writebyte fdocaconstants indicator_nullable
/**
* methods to keep track of required codepoints
*/
/**
* copy a list of required code points to template for checking
*
* @param req list of required codepoints
*/
private void copytorequired int  req
currentrequiredlength   req length
if  currentrequiredlength > required length
required   new int
for  int i   0  i < req length  i
required   req
/**
* remove codepoint from required list
*
* @param codepoint - code point to be removed
*/
private void removefromrequired int codepoint
for  int i   0  i < currentrequiredlength  i
if  required    codepoint
required   0
/**
* check whether we have seen all the required code points
*
* @param codepoint code point for which list of code points is required
*/
private void checkrequired int codepoint  throws drdaprotocolexception
int firstmissing   0
for  int i   0  i < currentrequiredlength  i
if  required    0
firstmissing   required
break
if  firstmissing    0
missingcodepoint firstmissing
/**
* error routines
*/
/**
* seen too many of this code point
*
* @param codepoint  code point which has been duplicated
*
* @exception drdaprotocolexception
*/
private void toomany int codepoint  throws drdaprotocolexception
throwsyntaxrm codepoint synerrcd_too_many  codepoint
/**
* object too big
*
* @param codepoint  code point with too big object
* @exception drdaprotocolexception
*/
private void toobig int codepoint  throws drdaprotocolexception
throwsyntaxrm codepoint synerrcd_too_big  codepoint
/**
* object length not allowed
*
* @param codepoint  code point with bad object length
* @exception drdaprotocolexception
*/
private void badobjectlength int codepoint  throws drdaprotocolexception
throwsyntaxrm codepoint synerrcd_obj_len_not_allowed  codepoint
/**
* rdb not found
*
* @param rdbnam  name of database
* @exception drdaprotocolexception
*/
private void rdbnotfound string rdbnam  throws drdaprotocolexception
object oa    rdbnam
throw new
drdaprotocolexception drdaprotocolexception drda_proto_rdbnfnrm
this 0
drdaprotocolexception no_assoc_errcd  oa
/**
* invalid value for this code point
*
* @param codepoint  code point value
* @exception drdaprotocolexception
*/
private void invalidvalue int codepoint  throws drdaprotocolexception
throwsyntaxrm codepoint synerrcd_req_val_not_found  codepoint
/**
* invalid codepoint for this command
*
* @param codepoint code point value
*
* @exception drdaprotocolexception
*/
protected void invalidcodepoint int codepoint  throws drdaprotocolexception
throwsyntaxrm codepoint synerrcd_invalid_cp_for_cmd  codepoint
/**
* don't support this code point
*
* @param codepoint  code point value
* @exception drdaprotocolexception
*/
protected void codepointnotsupported int codepoint  throws drdaprotocolexception
throw new
drdaprotocolexception drdaprotocolexception drda_proto_cmdnsprm
this codepoint
drdaprotocolexception no_assoc_errcd
/**
* don't support this value
*
* @param codepoint  code point value
* @exception drdaprotocolexception
*/
private void valuenotsupported int codepoint  throws drdaprotocolexception
throw new
drdaprotocolexception drdaprotocolexception drda_proto_valnsprm
this codepoint
drdaprotocolexception no_assoc_errcd
/**
* verify that the code point is the required code point
*
* @param codepoint code point we have
* @param reqcodepoint code point required at this time
*
* @exception drdaprotocolexception
*/
private void verifyrequiredobject int codepoint  int reqcodepoint
throws drdaprotocolexception
if  codepoint    reqcodepoint
throwsyntaxrm codepoint synerrcd_req_obj_not_found codepoint
/**
* verify that the code point is in the right order
*
* @param codepoint code point we have
* @param reqcodepoint code point required at this time
*
* @exception drdaprotocolexception
*/
private void verifyinorderaccsec_secchk int codepoint  int reqcodepoint
throws drdaprotocolexception
if  codepoint    reqcodepoint
throw
new drdaprotocolexception drdaprotocolexception drda_proto_prccnvrm
this  codepoint
codepoint prccnvcd_accsec_secchk_wrong_state
/**
* database name given under code point doesn't match previous database names
*
* @param codepoint codepoint where the mismatch occurred
*
* @exception drdaprotocolexception
*/
private void rdbnammismatch int codepoint
throws drdaprotocolexception
throw new drdaprotocolexception drdaprotocolexception drda_proto_prccnvrm
this  codepoint
codepoint prccnvcd_rdbnam_mismatch
/**
* close the current session
*/
private void closesession
if  session    null
return
/* derby-2220: rollback the current xa transaction if it is
still associated with the connection. */
if  xaproto    null
xaproto rollbackcurrenttransaction
server removefromsessiontable session connnum
try
session close
catch  sqlexception se
// if something went wrong closing down the session.
// print an error to the console and close this
//thread. (6013)
sendunexpectedexception se
close
finally
session   null
database   null
apprequester null
sockis   null
sockos null
databaseaccessexception null
/**
* handle exceptions - write error protocol if appropriate and close session
*	or thread as appropriate
*/
private void handleexception exception e
try
if  e instanceof drdaprotocolexception
// protocol error - write error message
sendprotocolexception  drdaprotocolexception  e
else
// something unexpected happened
sendunexpectedexception e
server consoleexceptionprinttrace e
finally
// always close the session and stop the thread after handling
// these exceptions
closesession
close
/**
* notice the client about a protocol error.
*
* @param de <code>drdaprotocolexception</code> to be sent
*/
private void sendprotocolexception drdaprotocolexception de
string dbname   null
if  database    null
dbname   database dbname
try
println2log dbname  session drdaid  de getmessage
server consoleexceptionprinttrace de
reader clearbuffer
de write writer
finalizechain
catch  drdaprotocolexception ioe
// there may be an io exception in the write.
println2log dbname  session drdaid  de getmessage
server consoleexceptionprinttrace ioe
/**
* send unpexpected error to the client
* @param e exception to be sent
*/
private void sendunexpectedexception exception e
drdaprotocolexception unexpde
string dbname   null
try
if  database    null
dbname   database dbname
println2log dbname session drdaid  e getmessage
server consoleexceptionprinttrace e
unexpde   drdaprotocolexception newagenterror this
codepoint svrcod_prmdmg
dbname  e getmessage
reader clearbuffer
unexpde write writer
finalizechain
catch  drdaprotocolexception nde
// we can't tell the client, but we tried.
/**
* test if drda connection thread is closed
*
* @return true if close; false otherwise
*/
private boolean closed
synchronized  closesync
return close
/**
* get whether connections are logged
*
* @return true if connections are being logged; false otherwise
*/
private boolean getlogconnections
synchronized logconnectionssync
return logconnections
/**
* get time slice value for length of time to work on a session
*
* @return time slice
*/
private long gettimeslice
synchronized timeslicesync
return timeslice
/**
* send string to console
*
* @param value - value to print on console
*/
protected  void trace string value
if  sanitymanager debug    server debugoutput    true
server consolemessage value  true
/***
* show runtime memory
*
***/
public static void showmem
runtime rt   null
date d   null
rt   runtime getruntime
rt gc
d   new date
system out println
rt totalmemory
rt freememory
d tostring
/**
* convert byte array to a hex string
*
* @param buf buffer to  convert
* @return hex string representation of byte array
*/
private string converttohexstring byte  buf
stringbuffer str   new stringbuffer
str append
string val
int byteval
for  int i   0  i < buf length  i
byteval   buf   0xff
val   integer tohexstring byteval
if  val length   < 2
str append
str append val
return str tostring
/**
* check that the given typdefnam is acceptable
*
* @param typdefnam
*
* @exception drdaprotocolexception
*/
private void checkvalidtypdefnam string typdefnam
throws drdaprotocolexception
if  typdefnam equals
return
if  typdefnam equals
return
if  typdefnam equals
return
if  typdefnam equals
return
if  typdefnam equals
return
if  typdefnam equals
return
invalidvalue codepoint typdefnam
/**
* check that the length is equal to the required length for this codepoint
*
* @param codepoint	codepoint we are checking
* @param reqlen	required length
*
* @exception drdaprotocolexception
*/
private void checklength int codepoint  int reqlen
throws drdaprotocolexception
long len   reader getddmlength
if  len < reqlen
badobjectlength codepoint
else if  len > reqlen
toobig codepoint
/**
* read and check a boolean value
*
* @param codepoint codepoint to be used in error reporting
* @return true or false depending on boolean value read
*
* @exception drdaprotocolexception
*/
private boolean readboolean int codepoint  throws drdaprotocolexception
checklength codepoint  1
byte val   reader readbyte
if  val    codepoint true
return true
else if  val    codepoint false
return false
else
invalidvalue codepoint
return false 	  to shut the compiler up
/**
* create a new database and intialize the
* drdaconnthread database.
*
* @param dbname database name to initialize. if
* dbnam is non null, add database to the current session
*
*/
private void initializedatabase string dbname
database db
if  apprequester isxarequester
db   new xadatabase dbname
else
db   new database dbname
if  dbname    null
session adddatabase db
session database   db
database   db
/**
* set the current database
*
* @param codepoint 	codepoint we are processing
*
* @exception drdaprotocolexception
*/
private void setdatabase int codepoint  throws drdaprotocolexception
string rdbnam   parserdbnam
// using same database so we are done
if  database    null    database dbname equals rdbnam
return
database d   session getdatabase rdbnam
if  d    null
rdbnammismatch codepoint
else
database   d
session database   d
/**
* write enduowrm
* instance variables
*  svcod - severity code - warning - required
*  uowdsp - unit of work disposition - required
*  rdbnam - relational database name - optional
*  srvdgn - server diagnostics information - optional
*
* @param optype - operation type 1 - commit, 2 -rollback
*/
private void writeenduowrm int optype
writer createdssreply
writer startddm codepoint enduowrm
writer writescalar2bytes codepoint svrcod  codepoint svrcod_warning
writer writescalar1byte codepoint uowdsp  optype
writer endddmanddss
void writeextdta  drdastatement stmt  throws sqlexception  drdaprotocolexception
arraylist extdtavalues   stmt getextdtaobjects
// build the extdta data, if necessary
if  extdtavalues    null
return
boolean chainflag  chainedwithsamecorrelator
boolean writenullbyte   false
for  int i   0  i < extdtavalues size    i
// is this the last extdta to be built?
if  i    extdtavalues size     1       no
chainflag   true
chainedwithsamecorrelator   true
else      yes
chainflag   false    last blob dss stream itself is not chained with the next dss
chainedwithsamecorrelator   false
if  sqlamlevel >  mgrlvl_7
if  stmt isextdtavaluenullable i
writenullbyte   true
object o    extdtavalues get i
if  o instanceof extdtainputstream
extdtainputstream stream    extdtainputstream  o
try
stream initinputstream
writer writescalarstream  chainedwithsamecorrelator
codepoint extdta
stream
writenullbyte
finally
// close the stream when done
closestream stream
// reset extdtavalues after sending
stmt clearextdtaobjects
/**
* check sqlwarning and write sqlcard as needed.
*
* @param conn 		connection to check
* @param stmt 		statement to check
* @param rs 		result set to check
* @param updatecount 	update count to include in sqlcard
* @param alwayssend 	whether always send sqlcard regardless of
*						the existance of warnings
* @param sendwarn 	whether to send any warnings or not.
*
* @exception drdaprotocolexception
*/
private void checkwarning connection conn  statement stmt  resultset rs
int updatecount  boolean alwayssend  boolean sendwarn
throws drdaprotocolexception  sqlexception
// instead of writing a chain of sql warning, we send the first one, this is
// jcc/db2 limitation, see beetle 4629
sqlwarning warning   null
sqlwarning reportwarning   null
try
if  stmt    null
warning   stmt getwarnings
if  warning    null
stmt clearwarnings
reportwarning   warning
if  rs    null
warning   rs getwarnings
if  warning    null
rs clearwarnings
if  reportwarning    null
reportwarning   warning
if  conn    null
warning   conn getwarnings
if  warning    null
conn clearwarnings
if  reportwarning    null
reportwarning   warning
catch  sqlexception se
if  sanitymanager debug
trace
if   alwayssend    reportwarning    null     sendwarn
writesqlcards reportwarning  updatecount
boolean hassession
return session    null
long getbytesread
return reader totalbytecount
long getbyteswritten
return writer totalbytecount
protected string buildruntimeinfo string indent  localizedresource locallangutil
string s
if   hassession
return s
else
s    session buildruntimeinfo    locallangutil
s
return s
/**
* finalize the current dss chain and send it if
* needed.
*/
private void finalizechain   throws drdaprotocolexception
writer finalizechain reader getcurrchainstate    getoutputstream
return
/**
*  validate secmec_usrssbpwd (strong password substitute) can be used as
*  drda security mechanism.
*
*	here we check that the target server can support secmec_usrssbpwd
*	security mechanism based on the environment, application
*	requester's identity (prdid) and connection url.
*
*	important note:
*	--------------
*	secmec_usrssbpwd is only supported by the target server if:
*	    - current authentication provider is derby builtin or
*	      none. (database / system level) (phase i)
*		- application requester is 'dnc' (derby network client)
*		  (phase i)
*
*  @return security check code - 0 if everything o.k.
*/
private int validatesecmecusrssbpwd   throws  drdaprotocolexception
string dbname   null
authenticationservice authenticationservice   null
org apache derby iapi db database databaseobj   null
string srvrlslv   apprequester srvrlslv
// check if application requester is the derby network client (dnc)
//
// we use a trick here - as the product id is not yet available
// since accrdb message is only coming later, we check the server
// release level field sent as part of the initial excsat message;
// indeed, the product id (prdid) is prefixed to in the field.
// derby always sets it as part of the excsat message so if it is
// not available, we stop here and inform the requester that
// secmec_usrssbpwd cannot be supported for this connection.
if   srvrlslv    null      srvrlslv length      0
srvrlslv length   < codepoint prdid_max
srvrlslv indexof drdaconstants derby_drda_client_id
1
return codepoint secchkcd_notsupported     not supported
// client product version is extracted from the srvrlslv field.
// srvrlslv has the format <prdid>/<alternate version format>
// typically, a known derby client has a four part version number
// with a pattern such as dnc10020/10.2.0.3 alpha. if the alternate
// version format is not specified, clientproductversion_ will just
// be set to the srvrlslvl. final fallback will be the product id.
//
// secmec_usrssbpwd is only supported by the derby engine and network
// server code starting at version major '10' and minor '02'. hence,
// as this is the same for the derby client driver, we need to ensure
// our dnc client is at version and release level of 10.2 at least.
// we set the client version in the application requester and check
// if it is at the level we require at a minimum.
apprequester setclientversion
srvrlslv substring 0   int  codepoint prdid_max
if  apprequester supportssecmecusrssbpwd      false
return codepoint secchkcd_notsupported     not supported
dbname   database shortdbname
// check if the database is available (booted)
//
// first we need to have the database name available and it should
// have been set as part of the accsec request (in the case of a derby
// 'dnc' client)
if   dbname    null      dbname length      0
// no database specified in the connection url attributes
//
// in this case, we get the authentication service handle from the
// local driver, as the requester may simply be trying to shutdown
// the engine.
authenticationservice     internaldriver
networkservercontrolimpl getdriver    getauthenticationservice
else
// we get the authentication service from the database as this
// last one might have specified its own auth provider (at the
// database level).
//
// if monitor is never setup by any modulecontrol, getmonitor
// returns null and no derby database has been booted.
if  monitor getmonitor      null
databaseobj    org apache derby iapi db database
monitor findservice property database_module  dbname
if  databaseobj    null
// if database is not found, try connecting to it.
database makedummyconnection
// now try to find it again
databaseobj    org apache derby iapi db database
monitor findservice property database_module  dbname
// if database still could not be found, it means the database
// does not exist - we just return security mechanism not
// supported down below as we could not verify we can handle
// it.
try
if  databaseobj    null
authenticationservice
databaseobj getauthenticationservice
catch  standardexception se
println2log null  session drdaid  se getmessage
// local security service non-retryable error.
return codepoint secchkcd_0a
// now we check if the authentication provider is none or builtin
if  authenticationservice    null
string authclassname   authenticationservice getclass   getname
if   authclassname equals authentication_provider_builtin_class
authclassname equals authentication_provider_none_class
return codepoint secchkcd_notsupported     not supported
// secmec_usrssbpwd target initialization
try
mytargetseed   decryptionmanager generateseed
database sectokenout   mytargetseed
catch  sqlexception se
println2log null  session drdaid  se getmessage
// local security service non-retryable error.
return codepoint secchkcd_0a
return 0     secmec_usrssbpwd is supported
private static int peekstream extdtainputstream is  throws ioexception
is mark 1
try
return is read
finally
is reset
private static void closestream inputstream stream
try
if  stream    null
stream close
catch  ioexception e
util javaexception e
private static bytearrayinputstream
convertasbytearrayinputstream  extdtareaderinputstream stream
throws ioexception
final int bytearraylength
stream instanceof standardextdtareaderinputstream ?
int      standardextdtareaderinputstream   stream   getlength
32    default length
publicbufferoutputstream pbos
new publicbufferoutputstream  bytearraylength
byte buffer   new byte
int c   0
while    c   stream read  buffer
0
buffer length     >  1
pbos write  buffer  0  c
return new bytearrayinputstream  pbos getbuffer
0
pbos getcount
private static class publicbufferoutputstream extends bytearrayoutputstream
publicbufferoutputstream int size
super size
public byte getbuffer
return buf
public int getcount
return count
private static void setascharacterstream drdastatement stmt
int i
boolean checknullability
ddmreader reader
boolean streamlob
string encoding
throws drdaprotocolexception
sqlexception
ioexception
preparedstatement ps   stmt getpreparedstatement
enginepreparedstatement engnps
enginepreparedstatement   ps
final extdtareaderinputstream extdtastream
reader getextdtareaderinputstream checknullability
// derby-3085. save the stream so it can be drained later
// if not  used.
if  streamlob
stmt setstreamedparameter extdtastream
final inputstream is
streamlob ?
inputstream  extdtastream
convertasbytearrayinputstream  extdtastream
final inputstreamreader streamreader
new inputstreamreader  is
encoding
engnps setcharacterstream  i   1
streamreader