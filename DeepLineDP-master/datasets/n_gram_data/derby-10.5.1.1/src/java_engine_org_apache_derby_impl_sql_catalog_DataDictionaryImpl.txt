/*
derby - class org.apache.derby.impl.sql.catalog.datadictionaryimpl
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql catalog
import org apache derby iapi reference attribute
import org apache derby iapi reference enginetype
import org apache derby iapi reference jdbc30translation
import org apache derby iapi reference property
import org apache derby iapi reference sqlstate
import org apache derby iapi reference limits
import org apache derby iapi sql conn authorizer
import org apache derby iapi sql dictionary aliasdescriptor
import org apache derby iapi sql dictionary catalogrowfactory
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary columndescriptorlist
import org apache derby iapi sql dictionary fileinfodescriptor
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi sql dictionary conglomeratedescriptorlist
import org apache derby iapi sql dictionary constraintdescriptorlist
import org apache derby iapi sql dictionary datadescriptorgenerator
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary defaultdescriptor
import org apache derby iapi sql dictionary dependencydescriptor
import org apache derby iapi sql dictionary foreignkeyconstraintdescriptor
import org apache derby iapi sql dictionary genericdescriptorlist
import org apache derby iapi sql dictionary tupledescriptor
import org apache derby iapi sql dictionary indexrowgenerator
import org apache derby iapi sql dictionary keyconstraintdescriptor
import org apache derby iapi sql dictionary tablepermsdescriptor
import org apache derby iapi sql dictionary colpermsdescriptor
import org apache derby iapi sql dictionary routinepermsdescriptor
import org apache derby iapi sql dictionary permissionsdescriptor
import org apache derby iapi sql dictionary referencedkeyconstraintdescriptor
import org apache derby iapi sql dictionary rolegrantdescriptor
import org apache derby iapi sql dictionary roleclosureiterator
import org apache derby iapi sql dictionary spsdescriptor
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary checkconstraintdescriptor
import org apache derby iapi sql dictionary subcheckconstraintdescriptor
import org apache derby iapi sql dictionary subconstraintdescriptor
import org apache derby iapi sql dictionary subkeyconstraintdescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary triggerdescriptor
import org apache derby iapi sql dictionary viewdescriptor
import org apache derby iapi sql dictionary systemcolumn
import org apache derby iapi sql depend dependencymanager
import org apache derby impl sql depend basicdependencymanager
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute executioncontext
import org apache derby iapi sql execute executionfactory
import org apache derby iapi sql execute scanqualifier
import org apache derby iapi types datavaluefactory
import org apache derby iapi types numberdatavalue
import org apache derby iapi types sqlchar
import org apache derby iapi types sqlvarchar
import org apache derby iapi types stringdatavalue
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn languageconnectionfactory
import org apache derby iapi store access accessfactory
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi types orderable
import org apache derby iapi types rowlocation
import org apache derby iapi store access rowutil
import org apache derby iapi store access scancontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store access qualifier
import org apache derby iapi services monitor monitor
import org apache derby iapi services monitor modulecontrol
import org apache derby iapi services monitor modulesupportable
import org apache derby iapi services context contextmanager
import org apache derby iapi services context contextservice
import org apache derby iapi error standardexception
// resolve - paulat - remove this import when track 3677 is fixed
import org apache derby iapi services sanity assertfailure
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute tuplefilter
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services cache cachefactory
import org apache derby iapi services cache cachemanager
import org apache derby iapi services cache cacheable
import org apache derby iapi services cache cacheablefactory
import org apache derby iapi services locks lockfactory
import org apache derby iapi services locks c_lockfactory
import org apache derby iapi services property propertyutil
import org apache derby impl services locks timeout
import org apache derby iapi services uuid uuidfactory
import org apache derby catalog aliasinfo
import org apache derby catalog defaultinfo
import org apache derby catalog typedescriptor
import org apache derby catalog uuid
import org apache derby catalog types routinealiasinfo
import org apache derby iapi services io formatablebitset
import org apache derby iapi services locks compatibilityspace
import org apache derby iapi services locks shexlockable
import org apache derby iapi services locks shexqual
import org apache derby iapi util idutil
import java util calendar
import java util gregoriancalendar
import java util hashtable
import java util hashmap
import java util hashset
import java util properties
import java util vector
import java util list
import java util iterator
import java util linkedlist
import java util enumeration
import java io inputstream
import java io ioexception
import java sql types
// lobstoredprocedure is imported only to get hold of a constant.
import org apache derby impl jdbc lobstoredprocedure
/**
* standard database implementation of the data dictionary
* that stores the information in the system catlogs.
*/
public final class	datadictionaryimpl
implements datadictionary  cacheablefactory  modulecontrol  modulesupportable java security privilegedaction
{
private static final string		cfg_systables_id
private static final string		cfg_systables_index1_id
private static final string		cfg_systables_index2_id
private static final string		cfg_syscolumns_id
private static final string		cfg_syscolumns_index1_id
private static final string		cfg_syscolumns_index2_id
private static final string		cfg_sysconglomerates_id
private static final string		cfg_sysconglomerates_index1_id
private static final string		cfg_sysconglomerates_index2_id
private static final string		cfg_sysconglomerates_index3_id
private static final string		cfg_sysschemas_id
private static final string		cfg_sysschemas_index1_id
private static final string		cfg_sysschemas_index2_id
private	static final int		sysconglomerates_core_num   0
private	static final int		systables_core_num   1
private static final int		syscolumns_core_num   2
private	static final int		sysschemas_core_num   3
private static final int        num_core   4
/**
* sysfun functions. table of functions that automatically appear
* in the sysfun schema. these functions are resolved to directly
* if no schema name is given, e.g.
*
* <code>
* select cos(angle) from room_walls
* </code>
*
* adding a function here is suitable when the function defintion
* can have a single return type and fixed parameter types.
*
* functions that need to have a return type based upon the
* input type(s) are not supported here. typically those are
* added into the parser and methods added into the datavaluedescriptor interface.
* examples are character based functions whose return type
* length is based upon the passed in type, e.g. passed a char(10)
* returns a char(10).
*
*
* this simple table can handle an arbitrary number of arguments
* and returns null on null input. the scheme could be expanded
* to handle other function options such as other parameters if needed.
*[0]    = function name
*[1]    = returns type
*[2]    = java class
*[3]    = method name and signature
*[4]    = "true" or "false" depending on whether the function is determinstic
*[5..n] = arguments (optional, if not present zero arguments is assumed)
*
*/
private static final string sysfun_functions
same as ln
same as ceil
escape function spec
/**
* index into sysfun_functions of the deterministic indicator.
* used to determine whether the system function is deterministic
*/
private static final int sysfun_deterministic_index    4
/**
* the index of the first parameter in entries in the sysfun_functions
* table. used to determine the parameter count (zero to many).
*/
private static final int sysfun_first_parameter_index    5
/**
* runtime definition of the functions from sysfun_functions.
* populated dynamically as functions are called.
*/
private static final aliasdescriptor sysfun_ad
new aliasdescriptor
// the structure that holds all the core table info
private tabinfoimpl coreinfo
/*
** schemadescriptors for system and app schemas.  both
** are canonical.  we cache them for fast lookup.
*/
private schemadescriptor systemschemadesc
private schemadescriptor sysibmschemadesc
private schemadescriptor declaredglobaltemporarytablesschemadesc
private schemadescriptor systemutilschemadesc
// this array of non-core table names *must* be in the same order
// as the non-core table numbers, above.
private static final string noncorenames
private	static final int		num_noncore   noncorenames length
/**
* list of all "system" schemas
* <p>
* this list should contain all schema's used by the system and are
* created when the database is created.  users should not be able to
* create or drop these schema's and should not be able to create or
* drop objects in these schema's.  this list is used by code that
* needs to check if a particular schema is a "system" schema.
**/
private static final string systemschemanames
schemadescriptor ibm_system_cat_schema_name
schemadescriptor ibm_system_fun_schema_name
schemadescriptor ibm_system_proc_schema_name
schemadescriptor ibm_system_stat_schema_name
schemadescriptor ibm_system_nullid_schema_name
schemadescriptor std_system_diag_schema_name
schemadescriptor std_system_util_schema_name
schemadescriptor ibm_system_schema_name
schemadescriptor std_sqlj_schema_name
schemadescriptor std_system_schema_name
/** dictionary version of the on-disk database */
private dd_version  dictionaryversion
/** dictionary version of the currently running engine */
private dd_version  softwareversion
private string authorizationdatabaseowner
private boolean usessqlauthorization
/*
** this property and value are written into the database properties
** when the database is created, and are used to determine whether
** the system catalogs need to be upgraded.
*/
// the structure that holds all the noncore info
private tabinfoimpl noncoreinfo
// no other system tables have id's in the configuration.
public	datadescriptorgenerator		datadescriptorgenerator
private datavaluefactory			dvf
accessfactory               af
//datadictionarycontext				ddc;
private	executionfactory	exfactory
protected uuidfactory		uuidfactory
properties			startupparameters
int					enginetype
/* information about whether or not we are at boot time */
protected	boolean				booting
private transactioncontroller	bootingtc
protected   dependencymanager dmgr
/* cache of table descriptors */
cachemanager	oidtdcache
cachemanager	nametdcache
private cachemanager	spsnamecache
private hashtable		spsidhash
// private hashtable       spstexthash;
int				tdcachesize
int				stmtcachesize
/* cache of permissions data */
cachemanager permissionscache
int permissionscachesize
/*
** lockable object for synchronizing transition from caching to non-caching
*/
shexlockable	cachecoordinator
public	lockfactory		lockfactory
volatile int	cachemode   datadictionary compile_only_mode
/* number of ddl users */
volatile int	ddlusers
/* number of readers that start in ddl_mode */
volatile int	readersinddlmode
/**
true if the database is read only and requires
some form of upgrade, that makes the stored prepared
statements invalid.
with this case the engine is running at a different
version to the underlying stored database. this
can happen in 5.1 if the database is read only
and a different point release (later than 5.1.25?)
to the one that created it, has been booted. (beetle 5170).
<p>
in 5.2 and newer this will be the case if the engine
booting the database is newer than the engine
that created it.
*/
public boolean readonlyupgrade
//systemsqlnamenumber is the number used as the last digit during the previous call to getsystemsqlname.
//if it is 9 for a given calendarforlastsystemsqlname, we will restart the counter to 0
//and increment the calendarforlastsystemsqlname by 10ms.
private int systemsqlnamenumber
private gregoriancalendar calendarforlastsystemsqlname   new gregoriancalendar
private long timeforlastsystemsqlname
/**
* list of procedures in syscs_util schema with public access
*/
private static final string sysutilprocedureswithpublicaccess
/**
* list of functions in syscs_util schema with public access
*/
private static final string sysutilfunctionswithpublicaccess
/**
* collation type for system schemas. in derby 10.3, this will always
* be ucs_basic
*/
private int collationtypeofsystemschemas
/**
* collation type for user schemas. in derby 10.3, this is either
* ucs_basic or territory_based. the exact value is decided by what has
* user asked for through jdbc url optional attribute collation. if that
* atrribute is set to ucs_basic, the collation type for user schemas
* will be ucs_basic. if that attribute is set to territory_based, the
* collation type for user schemas will be territory_based. if the user
* has not provide collation attribute value in the jdbc url at database
* create time, then collation type of user schemas will default to
* ucs_basic. pre-10.3 databases after upgrade to derby 10.3 will also
* use ucs_basic for collation type of user schemas.
*/
private int collationtypeofuserschemas
/*
** constructor
*/
public datadictionaryimpl
}
/**
* this is the data dictionary implementation for
* the standard database engine.
@return true if this service requested is for a database engine.
*/
public boolean cansupport properties startparams
{
return monitor isdesiredtype startparams  enginetype standalone_db
}
/**
* start-up method for this instance of the data dictionary.
*
* @param startparams	the start-up parameters
*
*	@exception standardexception	thrown if the module fails to start
*/
public void boot boolean create  properties startparams
throws standardexception
{
softwareversion   new dd_version this  datadictionary dd_version_derby_10_5
startupparameters   startparams
uuidfactory   monitor getmonitor   getuuidfactory
enginetype   monitor getenginetype  startparams
//set the collation type of system schemas before we start loading
//built-in schemas's schemadescriptor(s). this is because
//schemadescriptor will look to datadictionary to get the correct
//collation type for themselves. we can't load sd for session schema
//just yet because we do not know the collation type for user schemas
//yet. we will know the right collation for user schema little later
//in this boot method.
collationtypeofsystemschemas   stringdatavalue collation_type_ucs_basic
getbuiltinsystemschemas
// remind: actually, we're supposed to get the datavaluefactory
// out of the connection context...this is a bit of a shortcut.
// we get the datavaluefactory early in order to help bootstrap the system catalogs.
languageconnectionfactory langconnfactory    languageconnectionfactory  monitor bootservicemodule
create  this  languageconnectionfactory module  startparams
dvf   langconnfactory getdatavaluefactory
exfactory    executionfactory  monitor bootservicemodule
create  this
executionfactory module
startparams
// initailze the arrays of core and noncore tables
initializecataloginfo
// indicate that we are in the process of booting
booting   true
// set only if child class hasn't overriden this already
if   datadescriptorgenerator    null
datadescriptorgenerator   new datadescriptorgenerator  this
if   create
// systables
coreinfo setheapconglomerate
getbootparameter startparams  cfg_systables_id  true
coreinfo setindexconglomerate systablesrowfactory systables_index1_id
getbootparameter startparams  cfg_systables_index1_id  true
coreinfo setindexconglomerate
systablesrowfactory systables_index2_id
getbootparameter startparams  cfg_systables_index2_id  true
// syscolumns
coreinfo setheapconglomerate
getbootparameter startparams  cfg_syscolumns_id  true
coreinfo setindexconglomerate
syscolumnsrowfactory syscolumns_index1_id
getbootparameter startparams  cfg_syscolumns_index1_id  true
// 2nd syscolumns index added in xena, hence may not be there
coreinfo setindexconglomerate
syscolumnsrowfactory syscolumns_index2_id
getbootparameter startparams  cfg_syscolumns_index2_id  false
// sysconglomerates
coreinfo setheapconglomerate
getbootparameter startparams  cfg_sysconglomerates_id  true
coreinfo setindexconglomerate
sysconglomeratesrowfactory sysconglomerates_index1_id
getbootparameter startparams  cfg_sysconglomerates_index1_id  true
coreinfo setindexconglomerate
sysconglomeratesrowfactory sysconglomerates_index2_id
getbootparameter startparams  cfg_sysconglomerates_index2_id  true
coreinfo setindexconglomerate
sysconglomeratesrowfactory sysconglomerates_index3_id
getbootparameter startparams  cfg_sysconglomerates_index3_id  true
// sysschemas
coreinfo setheapconglomerate
getbootparameter startparams  cfg_sysschemas_id  true
coreinfo setindexconglomerate
sysschemasrowfactory sysschemas_index1_id
getbootparameter startparams  cfg_sysschemas_index1_id  true
coreinfo setindexconglomerate
sysschemasrowfactory sysschemas_index2_id
getbootparameter startparams  cfg_sysschemas_index2_id  true
}
string value   startparams getproperty property lang_td_cache_size
tdcachesize   propertyutil intpropertyvalue property lang_td_cache_size  value
0  integer max_value  property lang_td_cache_size_default
value   startparams getproperty property lang_sps_cache_size
stmtcachesize   propertyutil intpropertyvalue property lang_sps_cache_size  value
0  integer max_value  property lang_sps_cache_size_default
value   startparams getproperty property lang_permissions_cache_size
permissionscachesize   propertyutil intpropertyvalue property lang_permissions_cache_size  value
0  integer max_value  property lang_permissions_cache_size_default
/*
* data dictionary contexts are only associated with connections.
* we have to look for the basic data dictionary, as there is
* no connection, and thus no context stack yet.
*/
/*
* get the table descriptor cache.
*/
cachefactory cf
cachefactory  monitor startsystemmodule org apache derby iapi reference module cachefactory
oidtdcache
cf newcachemanager this
tdcachesize
tdcachesize
nametdcache
cf newcachemanager this
tdcachesize
tdcachesize
if  stmtcachesize > 0
{
spsnamecache
cf newcachemanager this
stmtcachesize
stmtcachesize
spsidhash   new hashtable stmtcachesize
// spstexthash = new hashtable(stmtcachesize);
}
/* get the object to coordinate cache transitions */
cachecoordinator   new shexlockable
/* get accessfactory in order to transaction stuff */
af    accessfactory   monitor findservicemodule this  accessfactory module
/* get the lock factory */
lockfactory   af getlockfactory
/*
* now we need to setup a context stack for the database creation work.
* we assume the system boot process has created a context
* manager already, but not that contexts we need are there.
*/
contextservice csf   contextservice getfactory
contextmanager cm   csf getcurrentcontextmanager
if  sanitymanager debug
sanitymanager assert  cm    null
// resolve other non-standardexception errors.
bootingtc   null
try
{
// get a transaction controller. this has the side effect of
// creating a transaction context if there isn't one already.
bootingtc   af gettransaction cm
/*
we need an execution context so that we can generate rows
remind: maybe only for create case?
*/
exfactory newexecutioncontext cm
datadescriptorgenerator ddg   getdatadescriptorgenerator
//we should set the user schema collation type here now because
//later on, we are going to create user schema app. by the time any
//user schema gets created, we should have the correct collation
//type set for such schemas to use. for this reason, don't remove
//the following if else statement and don't move it later in this
//method.
string userdefinedcollation
if  create
//get the collation attribute from the jdbc url. it can only
//have one of 2 possible values - ucs_basic or territory_based
//this attribute can only be specified at database create time.
//the attribute value has already been verified in dvf.boot and
//hence we can be assured that the attribute value if provided
//is either ucs_basic or territory_based. if none provided,
//then we will take it to be the default which is ucs_basic.
userdefinedcollation   startparams getproperty
attribute collation  property ucs_basic_collation
bootingtc setproperty property collation userdefinedcollation true
else
userdefinedcollation   startparams getproperty
property collation  property ucs_basic_collation
}
//initialize the collation type of user schemas after looking at
//collation property/attribute.
if  userdefinedcollation equalsignorecase property ucs_basic_collation
collationtypeofuserschemas   stringdatavalue collation_type_ucs_basic
else
collationtypeofuserschemas   stringdatavalue collation_type_territory_based
//now is also a good time to create schema descriptor for global
//temporary tables. since this is a user schema, it should use the
//collation type associated with user schemas. since we just
//finished setting up the collation type of user schema, it is
//safe to create user schemadescriptor(s) now.
declaredglobaltemporarytablesschemadesc
newdeclaredglobaltemporarytablesschemadesc
schemadescriptor std_declared_global_temporary_tables_schema_name
if  create
string username   idutil getusernamefromurlprops startparams
authorizationdatabaseowner   idutil getuserauthorizationid username
hashset newlycreatedroutines   new hashset
// create any required tables.
createdictionarytables startparams  bootingtc  ddg
//create procedures for network server metadata
create_sysibm_procedures bootingtc  newlycreatedroutines
//create metadata sps statement required for network server
createsystemsps bootingtc
// create the syscs_util system procedures)
create_syscs_procedures bootingtc  newlycreatedroutines
// now grant execute permission on some of these routines
grantpublicaccesstosystemroutines  newlycreatedroutines  bootingtc  authorizationdatabaseowner
// log the current dictionary version
dictionaryversion   softwareversion
/* set properties for current and create time
* datadictionary versions.
*/
bootingtc setproperty
datadictionary core_data_dictionary_version
dictionaryversion  true
bootingtc setproperty
datadictionary create_data_dictionary_version
dictionaryversion  true
// if sqlauthorization is set as system property during database
// creation, set it as database property also, so it gets persisted.
if  propertyutil getsystemboolean property sql_authorization_property
{
bootingtc setproperty property sql_authorization_property   true
usessqlauthorization true
}
else
// get the ids for non-core tables
loaddictionarytables bootingtc  ddg  startparams
string sqlauth   propertyutil getdatabaseproperty bootingtc
property sql_authorization_property
// feature compatibility check.
if  boolean valueof
startparams getproperty
attribute soft_upgrade_no_feature_check
booleanvalue
// do not perform check if this boot is the first
// phase (soft upgrade boot) of a hard upgrade,
// which happens in two phases beginning with
// derby-2264. in this case, we need to always be
// able to boot to authenticate, notwithstanding
// any feature properties set
// (e.g. derby.database.sqlauthorization) which
// may not yet be supported until that hard
// upgrade has happened, normally causing an error
// below.
//
// feature sqlauthorization is a special case:
// since database ownership checking only happens
// when sqlauthorization is true, we can't afford
// to *not* use it for upgrades from 10.2 or
// later, lest we lose the database owner check.
// for upgrades from 10.1 and earlier there is no
// database owner check at a hard upgrade.
if  dictionaryversion majorversionnumber >
datadictionary dd_version_derby_10_2
usessqlauthorization   boolean valueof sqlauth
booleanvalue
}
else
if  boolean valueof sqlauth  booleanvalue
// sql authorization requires 10.2 or higher database
checkversion datadictionary dd_version_derby_10_2
usessqlauthorization true
}
}
}
if  sanitymanager debug
sanitymanager assert  authorizationdatabaseowner    null
/* commit & destroy the create database */
bootingtc commit
cm getcontext executioncontext context_id  popme       done with ctx
finally
if  bootingtc    null
bootingtc destroy        gets rid of the transaction context
bootingtc   null
}
}
setdependencymanager
booting   false
}
private cachemanager getpermissionscache   throws standardexception
{
if  permissionscache    null
{
cachefactory cf
cachefactory  monitor startsystemmodule org apache derby iapi reference module cachefactory
languageconnectioncontext lcc   getlcc
transactioncontroller tc   lcc gettransactionexecute
permissionscachesize   propertyutil getserviceint  tc
property lang_permissions_cache_size
40     min value
integer max_value
permissionscachesize    value from boot time
permissionscache   cf newcachemanager  this
permissionscachesize
permissionscachesize
}
return permissionscache
end of getpermissionscache
/**
* sets the dependencymanager associated with this dd. subclasses can
* override this to install their own funky dependency manager.
*/
protected void setdependencymanager
{
dmgr   new basicdependencymanager this
}
/**
* returns the dependencymanager associated with this datadictionary.
* @see datadictionary#getdependencymanager
*/
public dependencymanager getdependencymanager
{
return dmgr
}
/**
* stop this module.  in this case, nothing needs to be done.
*/
public void stop
{
}
/*
** cacheablefactory interface
*/
public cacheable newcacheable cachemanager cm
if  cm    oidtdcache
return new oidtdcacheable this
else if  cm    nametdcache
return new nametdcacheable this
else if  cm    permissionscache
return new permissionscacheable this
else
return new spsnamecacheable this
}
}
/*
** methods related to modulecontrol
*/
/**
* @see org.apache.derby.iapi.sql.dictionary.datadictionary#startreading
*
* @exception standardexception		thrown on error
*/
public int startreading languageconnectioncontext lcc
throws standardexception
{
int     bindcount   lcc incrementbindcount
int     localcachemode
boolean needretry   false
do
{
if  needretry
{
// could not get lock while holding the synchronized(this),
// so now wait until we can get the lock.  once we get the
// lock it is automatically released, hopefully when we
// go the the synchronized(this) block we will be able to
// get the lock, while holding the synchronized(this)
// monitor now.
try
{
lockfactory zerodurationlockobject
lcc gettransactionexecute   getlockspace
cachecoordinator
shexqual sh
c_lockfactory wait_forever
}
catch  standardexception e
{
// deadlock, timeout will not happen with wait_forever
lcc decrementbindcount
throw e
}
needretry   false
}
// "this" is used to synchronize between startreading,donereading,
//  and startwriting.
synchronized this
{
localcachemode   getcachemode
/*
** keep track of how deeply nested this bind() operation is.
** it's possible for nested binding to happen if the user
** prepares sql statements from within a static initializer
** of a class, and calls a method on that class (or uses a
** field in the class).
**
** if nested binding is happening, we only want to lock the
** datadictionary on the outermost nesting level.
*/
if  bindcount    1
{
if  localcachemode    datadictionary compile_only_mode
{
if  sanitymanager debug
{
sanitymanager assert ddlusers    0
}
/*
** if we deadlock while waiting for a lock,
** then be sure to restore things as they
** were.
*/
boolean lockgranted   false
try
{
// when the c_lockfactory.no_wait is used this
// routine will not throw timeout or deadlock
// exceptions.  the boolean returned will indicate
// if the lock was granted or not.  if it would
// have had to wait, it just returns immediately
// and returns false.
//
// see if we can get this lock granted without
// waiting (while holding the datadictionary
// synchronization).
compatibilityspace space
lcc gettransactionexecute   getlockspace
lockgranted
lockfactory lockobject
space  space getowner
cachecoordinator
shexqual sh
c_lockfactory no_wait
}
catch  standardexception e
{
// neither timeout or deadlock can happen with
// no_wait flag.  this must be some other exception.
lcc decrementbindcount
throw e
}
if   lockgranted
needretry   true
}
else
{
readersinddlmode
}
}
end of sync block
while  needretry
return localcachemode
}
/* @see org.apache.derby.iapi.sql.dictionary.datadictionary#donereading */
public void donereading int mode  languageconnectioncontext lcc
throws standardexception
{
int bindcount   lcc decrementbindcount
/* this is an arbitrary choice of object to synchronize these methods */
synchronized this
{
/*
** keep track of how deeply nested this bind() operation is.
** it's possible for nested binding to happen if the user
** prepares sql statements from within a static initializer
** of a class, and calls a method on that class (or uses a
** field in the class).
**
** if nested binding is happening, we only want to unlock the
** datadictionary on the outermost nesting level.
*/
if  bindcount    0
{
if  mode    datadictionary compile_only_mode
{
/*
** release the share lock that was acquired by the reader when
** it called startreading().
** beetle 4418, during bind, we may even execute something (eg., in a vti
** constructor) and if a severe error occured, the transaction is rolled
** back and lock released already, so don't try to unlock if statement context
** is cleared.
*/
if   lcc getstatementcontext      null     lcc getstatementcontext   inuse
{
compatibilityspace space
lcc gettransactionexecute   getlockspace
int unlockcount
lockfactory unlock
space  space getowner
cachecoordinator  shexqual sh
if  sanitymanager debug
{
if  unlockcount    1
{
sanitymanager throwassert
unlockcount
}
}
}
}
else
{
readersinddlmode
/*
** we can only switch back to cached (compile_only)
** mode if there aren't any readers that started in
** ddl_mode.  otherwise we could get a reader
** in ddl_mode that reads a cached object that
** was brought in by a reader in compile_only_mode.
** if 2nd reader finished and releases it lock
** on the cache there is nothing to pevent another
** writer from coming along an deleting the cached
** object.
*/
if  ddlusers    0    readersinddlmode    0
{
clearcaches
setcachemode datadictionary compile_only_mode
}
if  sanitymanager debug
{
sanitymanager assert readersinddlmode >  0
}
}
}
}
}
/*
* @see org.apache.derby.iapi.sql.dictionary.datadictionary#startwriting
*
* @exception standardexception		thrown on error
*/
public void startwriting languageconnectioncontext lcc
throws standardexception
{
boolean blocked   true
/*
** don't allow ddl if we're binding a sql statement.
*/
if  lcc getbindcount      0
{
throw standardexception newexception sqlstate lang_ddl_in_bind
}
/*
** check whether we've already done a ddl statement in this
** transaction.  if so, we don't want to re-enter ddl mode, or
** bump the ddl user count.
*/
if     lcc datadictionaryinwritemode
{
for  int i   0  blocked  i
{
/*
** if we already tried 5 times and failed, do
** an unbounded wait for the lock w/o
** synchronization.  immediately unlock and
** sleep a random amount of time and start
** the whole process over again.
*/
if  i > 4
getcachemode      datadictionary compile_only_mode
{
// wait until the settable timeout value for the lock,
// and once granted, immediately release the lock.  if
// this wait time's out then a timeout error is sent
// up the stack.
lockfactory zerodurationlockobject
lcc gettransactionexecute   getlockspace
cachecoordinator
shexqual ex
c_lockfactory timed_wait
i   1
}
if  i > 0
{
try
{
thread sleep
long   java lang math random     1131  % 20
}
catch  interruptedexception ie
{
throw standardexception interrupt ie
}
}
synchronized this
{
if  getcachemode      datadictionary compile_only_mode
{
// when the c_lockfactory.no_wait is used this routine
// will not throw timeout or deadlock exceptions.  the
// boolean returned will indicate if the lock was
// granted or not.  if it would have had to wait, it
// just returns immediately and returns false.
//
// see if we can get this lock granted without waiting
// (while holding the datadictionary synchronization).
boolean lockgranted
lockfactory zerodurationlockobject
lcc gettransactionexecute   getlockspace
cachecoordinator
shexqual ex
c_lockfactory no_wait
if   lockgranted
continue
/* switch the caching mode to ddl */
setcachemode datadictionary ddl_mode
/* clear out all the caches */
clearcaches
}
/* keep track of the number of ddl users */
ddlusers
end synchronized
/*
** tell the connection the dd is in ddl mode, so it can take
** it out of ddl mode when the transaction finishes.
*/
lcc setdatadictionarywritemode
blocked   false
}
}
else if  sanitymanager debug
{
sanitymanager assert getcachemode      datadictionary ddl_mode
}
}
/* @see org.apache.derby.iapi.sql.dictionary.datadictionary#transactionfinished */
public void transactionfinished   throws standardexception
{
/* this is an arbitrary choice of object to synchronize these methods */
synchronized this
{
if  sanitymanager debug
{
sanitymanager assert ddlusers > 0
sanitymanager assert getcachemode      datadictionary ddl_mode
}
ddlusers
/*
** we can only switch back to cached (compile_only)
** mode if there aren't any readers that started in
** ddl_mode.  otherwise we could get a reader
** in ddl_mode that reads a cached object that
** was brought in by a reader in compile_only_mode.
** if 2nd reader finished and releases it lock
** on the cache there is nothing to pevent another
** writer from coming along an deleting the cached
** object.
*/
if  ddlusers    0    readersinddlmode    0
{
clearcaches
setcachemode datadictionary compile_only_mode
}
}
}
/*
** synchronization: no synchronization
** necessary since integer reads/writes
** are atomic
*/
public int getcachemode
{
return cachemode
}
/*
** synchronization: no synchronization
** necessary since integer reads/writes
** are atomic
*/
private void setcachemode int newmode
{
cachemode   newmode
}
/**
* get a datadescriptorgenerator, through which we can create
* objects to be stored in the datadictionary.
*
* @return	a datadescriptorgenerator
*/
public datadescriptorgenerator	getdatadescriptorgenerator
{
return datadescriptorgenerator
}
/**
* get authorizationid of database owner
*
* @return	authorizationid
*/
public string getauthorizationdatabaseowner
{
return authorizationdatabaseowner
}
/**
* @see datadictionary#usessqlauthorization
*/
public boolean usessqlauthorization
{
return usessqlauthorization
}
/** @see datadictionary#getcollationtypeofsystemschemas() */
public int getcollationtypeofsystemschemas
{
return collationtypeofsystemschemas
}
/** @see datadictionary#getcollationtypeofuserschemas() */
public int getcollationtypeofuserschemas
{
return collationtypeofuserschemas
}
/**
* get a datavaluefactory, through which we can create
* data value objects.
*
* @return	a datavaluefactory
*/
public datavaluefactory	getdatavaluefactory
{
return dvf
}
/**
* get executionfactory associated with this database.
*
* @return	the executionfactory
*/
public executionfactory	getexecutionfactory
{
return exfactory
}
/**
* set up the builtin schema descriptors for system schemas.
*/
private void getbuiltinsystemschemas
{
if  systemschemadesc    null
return
systemschemadesc
newsystemschemadesc schemadescriptor std_system_schema_name
schemadescriptor system_schema_uuid
sysibmschemadesc
newsystemschemadesc schemadescriptor ibm_system_schema_name
schemadescriptor sysibm_schema_uuid
systemutilschemadesc
newsystemschemadesc schemadescriptor std_system_util_schema_name
schemadescriptor syscs_util_schema_uuid
}
/**
* get the descriptor for the system schema. schema descriptors include
* authorization ids and schema ids.
*
* sql92 allows a schema to specify a default character set - we will
* not support this.
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getsystemschemadescriptor
throws standardexception
{
return systemschemadesc
}
/**
* get the descriptor for the syscs_util system schema.
* schema descriptors include authorization ids and schema ids.
*
* sql92 allows a schema to specify a default character set - we will
* not support this.
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getsystemutilschemadescriptor
throws standardexception
{
return systemutilschemadesc
}
/**
* get the descriptor for the sysibm schema. schema descriptors include
* authorization ids and schema ids.
*
* sql92 allows a schema to specify a default character set - we will
* not support this.
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getsysibmschemadescriptor
throws standardexception
{
return sysibmschemadesc
}
/**
* get the descriptor for the declared global temporary table schema which
* is always named "session".
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getdeclaredglobaltemporarytablesschemadescriptor
throws standardexception
{
return declaredglobaltemporarytablesschemadesc
}
/**
* determine whether a string is the name of the system schema.
*
* @param name
* @return	true or false
*
* @exception standardexception		thrown on failure
*/
public boolean issystemschemaname  string name
throws standardexception
{
boolean ret_val   false
for  int i   systemschemanames length   1  i >  0
{
if   ret_val   systemschemanames equals name
break
}
return ret_val
}
/**
* get the descriptor for the named schema.
* schema descriptors include authorization ids and schema ids.
* sql92 allows a schema to specify a default character set - we will
* not support this.  will check default schema for a match
* before scanning a system table.
*
* @param schemaname	the name of the schema we're interested in. must not be null.
* @param tc			transactioncontroller
*
* @param raiseerror    whether an exception should be thrown if the schema does not exist.
*
* @return	the descriptor for the schema. can be null (not found) if raiseerror is false.
*
* @exception standardexception		thrown on error
*/
public schemadescriptor	getschemadescriptor string schemaname
transactioncontroller tc
boolean raiseerror
throws standardexception
{
/*
** check for app and sys schemas before going any
** further.
*/
if   tc    null
{
tc   gettransactioncompile
}
if  getsystemschemadescriptor   getschemaname   equals schemaname
{
return getsystemschemadescriptor
}
else if  getsysibmschemadescriptor   getschemaname   equals schemaname
{
// oh you are really asking sysibm, if this db is soft upgraded
// from pre 52, i may have 2 versions for you, one on disk
// (user sysibm), one imaginary (builtin). the
// one on disk (real one, if it exists), should always be used.
if  dictionaryversion checkversion
datadictionary dd_version_cs_5_2  null
{
return getsysibmschemadescriptor
}
}
/*
** manual lookup
*/
schemadescriptor sd   locateschemarow schemaname  tc
//if no schema found and schema name is session, then create an
//in-memory schema descriptor
if  sd    null
getdeclaredglobaltemporarytablesschemadescriptor   getschemaname   equals schemaname
{
return getdeclaredglobaltemporarytablesschemadescriptor
}
if  sd    null    raiseerror
{
throw standardexception newexception
sqlstate lang_schema_does_not_exist  schemaname
}
else
{
return sd
}
}
/**
* get the target schema by searching for a matching row
* in sysschemas by schemaid.  read only scan.
*
* @param schemaid		the id of the schema we're interested in.
*						if non-null, overrides schemaname
*
* @param tc			transactioncontroller.  if null, one
*						is gotten off of the language connection context.
*
* @return	the row for the schema
*
* @exception standardexception		thrown on error
*/
private schemadescriptor locateschemarow uuid schemaid
transactioncontroller tc
throws standardexception
{
return locateschemarowbody
schemaid
transactioncontroller isolation_repeatable_read
tc
}
/**
* get the target schema by searching for a matching row
* in sysschemas by schemaid.  read only scan.
*
* @param schemaid		the id of the schema we're interested in.
*						if non-null, overrides schemaname
* @param isolationlevel use this explicit isolation level. only
*                      isolation_repeatable_read (normal usage) or
*                      isolation_read_uncommitted (corner cases)
*                      supported for now.
* @param tc			transactioncontroller.  if null, one
*						is gotten off of the language connection context.
*
* @return	the row for the schema
*
* @exception standardexception		thrown on error
*/
private schemadescriptor locateschemarow uuid schemaid
int isolationlevel
transactioncontroller tc
throws standardexception
{
return locateschemarowbody
schemaid
isolationlevel
tc
}
private schemadescriptor locateschemarowbody uuid schemaid
int isolationlevel
transactioncontroller tc
throws standardexception
{
datavaluedescriptor		uuidstringorderable
tabinfoimpl					ti   coreinfo
/* use uuidstringorderable in both start and stop positions for scan */
uuidstringorderable   getidvalueaschar schemaid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  uuidstringorderable
return  schemadescriptor
getdescriptorviaindex
sysschemasrowfactory sysschemas_index2_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
isolationlevel
tc
}
/**
* get the target schema by searching for a matching row
* in sysschemas by schema name.  read only scan.
*
* @param schemaname	the name of the schema we're interested in.
*						if schemaid is null, used to qual.
*
* @param tc			transactioncontroller.  if null, one
*						is gotten off of the language connection context.
*
* @return	the row for the schema
*
* @exception standardexception		thrown on error
*/
private schemadescriptor locateschemarow string schemaname
transactioncontroller tc
throws standardexception
{
datavaluedescriptor		  schemanameorderable
tabinfoimpl					  ti   coreinfo
/* use aliasnameorderable in both start
* and stop position for scan.
*/
schemanameorderable   new sqlvarchar schemaname
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  schemanameorderable
return  schemadescriptor
getdescriptorviaindex
sysschemasrowfactory sysschemas_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
tc
}
/**
* get the schemadescriptor for the given schema identifier.
*
* @param schemaid  the id of the schema we're interested in.
*
* @param tc        the transaction controller to us when scanning
*                  sysschemas
*
* @return  the descriptor for the schema, null if no such schema exists.
*
* @exception standardexception     thrown on failure
*/
public schemadescriptor	getschemadescriptor uuid schemaid
transactioncontroller tc
throws standardexception
{
return getschemadescriptorbody
schemaid
transactioncontroller isolation_repeatable_read
tc
}
/**
* get the schemadescriptor for the given schema identifier.
*
* @param schemaid the uuid of the schema we want a descriptor for
* @param isolationlevel use this explicit isolation level. only
*                       isolation_repeatable_read (normal usage) or
*                       isolation_read_uncommitted (corner cases)
*                       supported for now.
* @param tc transaction controller
* @throws standardexception thrown on error
*/
public schemadescriptor	getschemadescriptor uuid schemaid
int isolationlevel
transactioncontroller tc
throws standardexception
{
return getschemadescriptorbody
schemaid
isolationlevel
tc
}
private schemadescriptor getschemadescriptorbody
uuid schemaid
int isolationlevel
transactioncontroller tc  throws standardexception
{
schemadescriptor		sd   null
if   tc    null
{
tc   gettransactioncompile
}
/*
** check for app and sys schemas before going any
** further.
*/
if  schemaid    null
{
if  getsystemschemadescriptor   getuuid   equals schemaid
{
return getsystemschemadescriptor
}
else if  getsysibmschemadescriptor   getuuid   equals schemaid
{
return getsysibmschemadescriptor
}
}
/*
** if we aren't booting, lets see if we already
** have the descriptor.  if we are in the middle
** of booting we cannot get the languageconnectioncontext.
*/
if   booting
{
languageconnectioncontext	lcc   getlcc
if  lcc    null
{
sd   lcc getdefaultschema
if   sd    null
schemaid    null
schemaid equals sd getuuid
{
return sd
}
}
}
return locateschemarow schemaid  isolationlevel  tc
}
/**
* return true of there exists a schema whose authorizationid equals
* authid, i.e.  sys.sysschemas contains a row whose column
* (authorizationid) equals authid.
*
* @param authid authorizationid
* @param tc transactioncontroller
* @return true iff there is a matching schema
* @exception standardexception
*/
public boolean existsschemaownedby string authid
transactioncontroller tc
throws standardexception
tabinfoimpl ti   coreinfo
sysschemasrowfactory
rf    sysschemasrowfactory ti getcatalogrowfactory
conglomeratecontroller
heapcc   tc openconglomerate
ti getheapconglomerate    false  0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
datavaluedescriptor authidorderable   new sqlvarchar authid
scanqualifier scanqualifier   exfactory getscanqualifier 1
scanqualifier setqualifier
sysschemasrowfactory sysschemas_schemaaid   1 	   to zero based
authidorderable
orderable order_op_equals
false
false
false
scancontroller sc   tc openscan
ti getheapconglomerate
false       don't hold open across commit
0           for update
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
formatablebitset  null          all fields as objects
datavaluedescriptor  null     start position
0                                startsearchoperation   none
scanqualifier
datavaluedescriptor  null     stop position  through last row
0                                stopsearchoperation   none
boolean result   false
try
execrow outrow   rf makeemptyrow
if  sc fetchnext outrow getrowarray
result   true
}
finally
if  sc    null
sc close
}
if  heapcc    null
heapcc close
}
}
return result
}
/**
* @see datadictionary#adddescriptor
*/
public void adddescriptor tupledescriptor td  tupledescriptor parent
int catalognumber  boolean duplicatesallowed
transactioncontroller tc
throws standardexception
{
tabinfoimpl ti     catalognumber < num_core  ? coreinfo
getnoncoreti catalognumber
execrow row   ti getcatalogrowfactory   makerow td  parent
int insertretcode   ti insertrow row  tc
if   duplicatesallowed
{
if  insertretcode    tabinfoimpl rownotduplicate
throw duplicatedescriptorexception td  parent
}
}
private standardexception
duplicatedescriptorexception tupledescriptor tuple
tupledescriptor parent
{
if  parent    null
return
standardexception newexception sqlstate lang_object_already_exists_in_object
tuple getdescriptortype
tuple getdescriptorname
parent getdescriptortype
parent getdescriptorname
else return
standardexception newexception sqlstate lang_object_already_exists
tuple getdescriptortype
tuple getdescriptorname
}
/** array version of adddescriptor.
* @see datadictionary#adddescriptor
*/
public void adddescriptorarray tupledescriptor td
tupledescriptor  parent
int catalognumber
boolean allowduplicates
transactioncontroller tc
throws standardexception
{
tabinfoimpl ti     catalognumber < num_core  ? coreinfo
getnoncoreti catalognumber
catalogrowfactory crf   ti getcatalogrowfactory
execrow rl   new execrow
for  int index   0  index < td length  index
{
execrow row   crf makerow td  parent
rl   row
}
int insertretcode   ti insertrowlist  rl  tc
if   allowduplicates    insertretcode    tabinfoimpl rownotduplicate
{
throw duplicatedescriptorexception td  parent
}
}
/**
* @see datadictionary#droprolegrant
*/
public void droprolegrant string rolename
string grantee
string grantor
transactioncontroller tc
throws standardexception
{
datavaluedescriptor rolenameorderable
datavaluedescriptor granteeorderable
datavaluedescriptor grantororderable
tabinfoimpl ti   getnoncoreti sysroles_catalog_num
rolenameorderable   new sqlvarchar rolename
granteeorderable   new sqlvarchar grantee
grantororderable   new sqlvarchar grantor
execindexrow keyrow   null
/* set up the start/stop position for the scan */
keyrow   exfactory getindexablerow 3
keyrow setcolumn 1  rolenameorderable
keyrow setcolumn 2  granteeorderable
keyrow setcolumn 3  grantororderable
ti deleterow tc  keyrow
sysrolesrowfactory sysroles_index_id_ee_or_idx
}
/**
* drop the descriptor for a schema, given the schema's name
*
* @param schemaname	the name of the schema to drop
* @param tc			transactioncontroller for the transaction
*
* @exception standardexception		thrown on error
*/
public void	dropschemadescriptor string schemaname
transactioncontroller tc
throws standardexception
{
execindexrow			keyrow1   null
datavaluedescriptor		schemanameorderable
tabinfoimpl					ti   coreinfo
if  sanitymanager debug
{
schemadescriptor sd   getschemadescriptor schemaname  gettransactioncompile    true
if   isschemaempty sd
{
sanitymanager throwassert   schemaname
}
}
/* use schemanameorderable in both start
* and stop position for index 1 scan.
*/
schemanameorderable   new sqlvarchar schemaname
/* set up the start/stop position for the scan */
keyrow1   exfactory getindexablerow 1
keyrow1 setcolumn 1  schemanameorderable
ti deleterow  tc  keyrow1  sysschemasrowfactory sysschemas_index1_id
}
/**
* get the descriptor for the named table within the given schema.
* if the schema parameter is null, it looks for the table in the
* current (default) schema. table descriptors include object ids,
* object types (table, view, etc.)
*
* @param tablename	the name of the table to get the descriptor for
* @param schema	the descriptor for the schema the table lives in.
*			if null, use the system schema.
* @return	the descriptor for the table, null if table does not
*		exist.
*
* @exception standardexception		thrown on failure
*/
public tabledescriptor		gettabledescriptor string tablename
schemadescriptor schema  transactioncontroller tc
throws standardexception
{
tabledescriptor		retval   null
/*
** if we didn't get a schema descriptor, we had better
** have a system table.
*/
if  sanitymanager debug
{
if   schema    null      tablename startswith
{
sanitymanager throwassert   tablename
}
}
schemadescriptor sd    schema    null  ?
getsystemschemadescriptor
schema
uuid schemauuid   sd getuuid
if  schemadescriptor std_system_diag_schema_name equals
sd getschemaname
{
tabledescriptor td
new tabledescriptor this  tablename  sd
tabledescriptor vti_type
tabledescriptor default_lock_granularity
// ensure a vti class exists
if  getvticlass td  false     null
return td
// otherwise just standard search
}
tablekey tablekey   	new tablekey schemauuid  tablename
/* only use the cache if we're in compile-only mode */
if  getcachemode      datadictionary compile_only_mode
{
nametdcacheable cacheentry    nametdcacheable  nametdcache find tablekey
if  cacheentry    null
{
retval   cacheentry gettabledescriptor
// bind in previous command might have set refernced cols
retval setreferencedcolumnmap null
nametdcache release cacheentry
}
return retval
}
return gettabledescriptorindex1scan tablename  schemauuid tostring
}
/**
* scan systables_index1 (tablename, schemaid) for a match.
*
* @return tabledescriptor	the matching descriptor, if any.
*
* @exception standardexception		thrown on failure
*/
private tabledescriptor gettabledescriptorindex1scan
string tablename
string schemauuid
throws standardexception
{
datavaluedescriptor		  schemaidorderable
datavaluedescriptor		  tablenameorderable
tabledescriptor			  td
tabinfoimpl					  ti   coreinfo
/* use tablenameorderable and schemaidorderable in both start
* and stop position for scan.
*/
tablenameorderable   new sqlvarchar tablename
schemaidorderable   new sqlchar schemauuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 2
keyrow setcolumn 1  tablenameorderable
keyrow setcolumn 2  schemaidorderable
td    tabledescriptor
getdescriptorviaindex
systablesrowfactory systables_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
return finishtabledescriptor td
}
/**
* this method can get called from the datadictionary cache.
*
* @param tablekey	the tablekey of the table
*
* @return	the descriptor for the table, null if the table does
*		not exist.
*
* @exception standardexception		thrown on failure
*/
tabledescriptor getuncachedtabledescriptor tablekey tablekey
throws standardexception
{
return gettabledescriptorindex1scan tablekey gettablename
tablekey getschemaid   tostring
}
/**
* get the descriptor for the table with the given uuid.
*
* note: i'm assuming that the object store will define an uuid for
* persistent objects. i'm also assuming that uuids are unique across
* schemas, and that the object store will be able to do efficient
* lookups across schemas (i.e. that no schema descriptor parameter
* is needed).
*
* @param tableid	the uuid of the table to get the descriptor for
*
* @return	the descriptor for the table, null if the table does
*		not exist.
*
* @exception standardexception		thrown on failure
*/
public tabledescriptor		gettabledescriptor uuid tableid
throws standardexception
{
oidtdcacheable		cacheentry
tabledescriptor	retval   null
/* only use the cache if we're in compile-only mode */
if  getcachemode      datadictionary compile_only_mode
{
cacheentry    oidtdcacheable  oidtdcache find tableid
if  cacheentry    null
{
retval   cacheentry gettabledescriptor
// bind in previous command might have set refernced cols
retval setreferencedcolumnmap null
oidtdcache release cacheentry
}
return retval
}
return gettabledescriptorindex2scan tableid tostring
}
/**
* this method can get called from the datadictionary cache.
*
* @param tableid	the uuid of the table to get the descriptor for
*
* @return	the descriptor for the table, null if the table does
*		not exist.
*
* @exception standardexception		thrown on failure
*/
protected tabledescriptor	getuncachedtabledescriptor uuid tableid
throws standardexception
{
return gettabledescriptorindex2scan tableid tostring
}
/**
* scan systables_index2 (tableid) for a match.
*
* @return tabledescriptor	the matching descriptor, if any.
*
* @exception standardexception		thrown on failure
*/
private tabledescriptor gettabledescriptorindex2scan
string tableuuid
throws standardexception
{
datavaluedescriptor		  tableidorderable
tabledescriptor			  td
tabinfoimpl					  ti   coreinfo
/* use tableidorderable in both start and stop position for scan.
*/
tableidorderable   new sqlchar tableuuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  tableidorderable
td    tabledescriptor
getdescriptorviaindex
systablesrowfactory systables_index2_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
return finishtabledescriptor td
}
/**
* finish filling in the tabledescriptor.
* (build the various lists that hang off the td.)
*
* @param td	the tabledescriptor.
*
* @return the completed tabledescriptor.
*
* @exception standardexception		thrown on failure
*/
private tabledescriptor finishtabledescriptor tabledescriptor td
throws standardexception
{
if  td    null
{
synchronized td
{
getcolumndescriptorsscan td
getconglomeratedescriptorsscan td
}
}
return td
}
/**
* indicate whether there is anything in the
* particular schema.  checks for tables in the
* the schema, on the assumption that there cannot
* be any other objects in a schema w/o a table.
*
* @param sd descriptor
*
* @return true/false
*
* @exception standardexception on error
*/
public boolean isschemaempty schemadescriptor sd
throws standardexception
{
datavaluedescriptor     schemaidorderable
transactioncontroller	tc   gettransactioncompile
schemaidorderable   getidvalueaschar sd getuuid
if  isschemareferenced tc  coreinfo
systablesrowfactory systables_index1_id
systablesrowfactory systables_index1_schemaid
schemaidorderable
{
return false
}
if  isschemareferenced tc  getnoncoreti sysconstraints_catalog_num
sysconstraintsrowfactory sysconstraints_index2_id
2
schemaidorderable
{
return false
}
if  isschemareferenced tc  getnoncoreti sysstatements_catalog_num
sysstatementsrowfactory sysstatements_index2_id
2
schemaidorderable
{
return false
}
if  isschemareferenced tc  getnoncoreti systriggers_catalog_num
systriggersrowfactory systriggers_index2_id
2
schemaidorderable
{
return false
}
return true
}
/**
* is the schema id referenced by the system table in question?
* currently assumes that the schema id is in an index.
* note: could be generalized a bit, and possibly used
* elsewhere...
*
* @param tc	transaction controller
* @param ti	table info for the system table
* @param indexid	index id
* @param indexcol	1 based index column
* @param schemaidorderable	the schemaid in a char orderable
*
* @return true if there is a reference to this schema
*
* @exception standardexception on error
*/
protected boolean isschemareferenced transactioncontroller	tc
tabinfoimpl					ti
int						indexid
int						indexcol
datavaluedescriptor		schemaidorderable
throws standardexception
{
conglomeratecontroller	heapcc   null
execindexrow	  		indexrow1
execindexrow			indextemplaterow
execrow 				outrow
scancontroller			scancontroller   null
boolean					foundrow
formatablebitset					coltocheck   new formatablebitset indexcol
catalogrowfactory		rf   ti getcatalogrowfactory
if  sanitymanager debug
{
sanitymanager assert indexid >  0
}
coltocheck set indexcol   1
scanqualifier qualifier   exfactory getscanqualifier 1
qualifier setqualifier
indexcol   1
schemaidorderable
orderable order_op_equals
false
false
false
outrow   rf makeemptyrow
try
{
heapcc
tc openconglomerate
ti getheapconglomerate    false  0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
scancontroller   tc openscan
ti getindexconglomerate indexid  	   conglomerate to open
false  								   don't hold open across commit
0                                      for read
transactioncontroller mode_record 	   row locking
transactioncontroller isolation_repeatable_read
coltocheck  						   don't get any rows
null    							   start position   first row
scancontroller ge       			   startsearchoperation
qualifier  							   scanqualifier
null    							   stop position   through last row
scancontroller gt       			   stopsearchoperation
foundrow    scancontroller next
}
finally
{
if  scancontroller    null
{
scancontroller close
}
if  heapcc    null
{
heapcc close
}
}
return foundrow
}
/**
* drop the table descriptor.
*
* @param td	the table descriptor to drop
* @param schema		a descriptor for the schema the table
*						is a part of.  if this parameter is
*						null, then the table is part of the
*						current (default) schema
* @param tc			transactioncontroller for the transaction
*
* @exception standardexception		thrown on error
*/
public void	droptabledescriptor tabledescriptor td  schemadescriptor schema
transactioncontroller tc
throws standardexception
{
conglomeratecontroller	heapcc
execindexrow			keyrow1   null
datavaluedescriptor		schemaidorderable
datavaluedescriptor		tablenameorderable
tabinfoimpl					ti   coreinfo
/* use tableidorderable and schemaidorderable in both start
* and stop position for index 1 scan.
*/
tablenameorderable   new sqlvarchar td getname
schemaidorderable   getidvalueaschar schema getuuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 2
keyrow1 setcolumn 1  tablenameorderable
keyrow1 setcolumn 2  schemaidorderable
ti deleterow  tc  keyrow1  systablesrowfactory systables_index1_id
}
/**
* update the lockgranularity for the specified table.
*
* @param td				the tabledescriptor for the table
* @param schema			the schemadescriptor for the table
* @param lockgranularity	the new lockgranularity
* @param tc				the transactioncontroller to use.
*
* @exception standardexception		thrown on error
*/
public void updatelockgranularity tabledescriptor td  schemadescriptor schema
char lockgranularity  transactioncontroller tc
throws standardexception
{
conglomeratecontroller	heapcc
execindexrow			keyrow1   null
execrow    				row
datavaluedescriptor		schemaidorderable
datavaluedescriptor		tablenameorderable
tabinfoimpl					ti   coreinfo
systablesrowfactory  rf    systablesrowfactory  ti getcatalogrowfactory
/* use tableidorderable and schemaidorderable in both start
* and stop position for index 1 scan.
*/
tablenameorderable   new sqlvarchar td getname
schemaidorderable   getidvalueaschar schema getuuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 2
keyrow1 setcolumn 1  tablenameorderable
keyrow1 setcolumn 2  schemaidorderable
// build the row to be stuffed into systables.
row   rf makerow td  schema
// update row in catalog (no indexes)
boolean barray   new boolean
for  int index   0  index < 2  index
{
barray   false
}
ti updaterow keyrow1  row
systablesrowfactory systables_index1_id
barray
int null
tc
}
/**
* drop all table descriptors for a schema.
*
* @param schema	a descriptor for the schema to drop the tables
*			from.
*
* @return  nothing.
*
* @exception standardexception		thrown on failure
*/
/*
public void dropalltabledescriptors(schemadescriptor schema)
throws standardexception
{
if (sanitymanager.debug) sanitymanager.notreached();
}
*/
/**
* get a columndescriptor given its default id.
*
* @param uuid	the uuid of the default
*
* @return the columndescriptor for the column.
*
* @exception standardexception		thrown on failure
*/
public columndescriptor getcolumndescriptorbydefaultid uuid uuid
throws standardexception
{
datavaluedescriptor	uuidstringorderable
tabinfoimpl				ti   coreinfo
/* use uuidstringorderable in both start and stop positions for scan */
uuidstringorderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  uuidstringorderable
return  columndescriptor
getdescriptorviaindex
syscolumnsrowfactory syscolumns_index2_id
keyrow
scanqualifier   null
ti
defaultdescriptor  null
list  null
false
}
/**
* populate the columndescriptorlist for the specified tabledescriptor.
*
* mt synchronization: it is assumed that the caller has synchronized
* on the cdl in the given td.
*
* @param td				the tabledescriptor.
*
* @exception standardexception		thrown on failure
*/
private void getcolumndescriptorsscan tabledescriptor td
throws standardexception
{
getcolumndescriptorsscan
td getuuid
td getcolumndescriptorlist
td
}
/**
* populate the columndescriptorlist for the specified tabledescriptor.
*
* mt synchronization: it is assumed that the caller has synchronized
* on the cdl in the given td.
*
* @param uuid				the referencing uuid
* @param cdl			the column descriptor list
* @param td				the parent tuple descriptor
*
* @exception standardexception		thrown on failure
*/
private void getcolumndescriptorsscan
uuid 					uuid
columndescriptorlist 	cdl
tupledescriptor 		td
throws standardexception
{
columndescriptor		cd
columndescriptorlist    cdlcopy           new columndescriptorlist
datavaluedescriptor		refidorderable    null
tabinfoimpl                 ti                coreinfo
/* use refidorderable in both start and stop position for scan. */
refidorderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  refidorderable
getdescriptorviaindex
syscolumnsrowfactory syscolumns_index1_id
keyrow
scanqualifier   null
ti
td
columndescriptorlist  cdl
false
/* the tabledescriptor's column descriptor list must be ordered by
* columnnumber.  (it is probably not ordered correctly at this point due
* to the index on syscolumns being on (tableid, columnname).)  the
* cheapest way to reorder the list appears to be to copy it (above), and then
* walk the copy and put the elements back into the original in the
* expected locations.
*/
int cdlsize   cdl size
for  int index   0  index < cdlsize  index
{
cdlcopy add  cdl get index
}
for  int index   0  index < cdlsize  index
{
cd    columndescriptor  cdlcopy elementat index
cdl set cd getposition     1  cd
}
}
/**
* given a column name and a table id, drops the column descriptor
* from the table.
*
* @param tableid	the uuid of the table to drop the column from
* @param columnname	the name of the column to drop
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on error
*/
public void	dropcolumndescriptor uuid tableid
string columnname  transactioncontroller tc
throws standardexception
{
datavaluedescriptor	columnnameorderable
datavaluedescriptor	tableidorderable
/* use tableidorderable and columnnameorderable in both start
* and stop position for scan.
*/
tableidorderable   getidvalueaschar tableid
columnnameorderable   new sqlvarchar columnname
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 2
keyrow setcolumn 1  tableidorderable
keyrow setcolumn 2  columnnameorderable
dropcolumndescriptorcore  tc  keyrow
}
/**
* drops all column descriptors from the given table.  useful for
* drop table.
*
* @param tableid	the uuid of the table from which to drop
*			all the column descriptors
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on error
*/
public void	dropallcolumndescriptors uuid tableid  transactioncontroller tc
throws standardexception
{
datavaluedescriptor		tableidorderable
/* use tableidorderable in both start and stop position for scan. */
tableidorderable   getidvalueaschar tableid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  tableidorderable
dropcolumndescriptorcore tc  keyrow
}
/**
* drops all table and column permission descriptors for the given table.
*
* @param tableid	the uuid of the table from which to drop
*			all the permission descriptors
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on error
*/
public void	dropalltableandcolpermdescriptors uuid tableid  transactioncontroller tc
throws standardexception
{
datavaluedescriptor		tableidorderable
// in derby authorization mode, permission catalogs may not be present
if   usessqlauthorization
return
/* use tableidorderable in both start and stop position for scan. */
tableidorderable   getidvalueaschar tableid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  tableidorderable
droptablepermdescriptor tc  keyrow
dropcolumnpermdescriptor tc  keyrow
}
/**
* need to update syscolperms for a given table because a new column has
* been added to that table. syscolperms has a column called "columns"
* which is a bit map for all the columns in a given user table. since
* alter table .. add column .. has added one more column, we need to
* expand "columns" for that new column
*
* currently, this code gets called during execution phase of
* alter table .. add column ..
*
* @param tableid	the uuid of the table to which a column has been added
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on error
*/
public void	updatesyscolpermsforaddcolumntousertable uuid tableid  transactioncontroller tc
throws standardexception
{
rewritesyscolpermsforaltertable tableid  tc  null
}
/**
* update syscolperms due to dropping a column from a table.
*
* since alter table .. drop column .. has removed a column from the
* table, we need to shrink columns by removing the corresponding bit
* position, and shifting all the subsequent bits "left" one position.
*
* @param tableid	the uuid of the table from which a col has been dropped
* @param tc		transactioncontroller for the transaction
* @param columndescriptor   information about the dropped column
*
* @exception standardexception		thrown on error
*/
public void updatesyscolpermsfordropcolumn uuid tableid
transactioncontroller tc  columndescriptor columndescriptor
throws standardexception
{
rewritesyscolpermsforaltertable tableid  tc  columndescriptor
}
/**
* workhorse for alter table-driven mods to syscolperms
*
* this method finds all the syscolperms rows for this table. then it
* iterates through each row, either adding a new column to the end of
* the table, or dropping a column from the table, as appropriate. it
* updates each syscolperms row to store the new columns value.
*
* @param tableid	the uuid of the table being altered
* @param tc		transactioncontroller for the transaction
* @param columndescriptor   dropped column info, or null if adding
*
* @exception standardexception		thrown on error
*/
private void rewritesyscolpermsforaltertable uuid tableid
transactioncontroller tc  columndescriptor columndescriptor
throws standardexception
{
// in derby authorization mode, permission catalogs may not be present
if   usessqlauthorization
return
/* this method has 2 steps to it. first get all the colpermsdescriptor
for given tableid. and next step is to go back to syscolperms to find
unique row corresponding to each of colpermsdescriptor and update the
"columns" column in syscolperms. the reason for this 2 step process is
that syscolperms has a non-unique row on "tableid" column and hence
we can't get a unique handle on each of the affected row in syscolperms
using just the "tableid" column */
// first get all the colpermsdescriptor for the given tableid from
//syscolperms using getdescriptorviaindex().
list permissiondescriptorslist   all colpermsdescriptor for given tableid
datavaluedescriptor		tableidorderable   getidvalueaschar tableid
tabinfoimpl	ti   getnoncoreti syscolperms_catalog_num
syscolpermsrowfactory rf    syscolpermsrowfactory  ti getcatalogrowfactory
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  tableidorderable
permissiondescriptorslist   newslist
getdescriptorviaindex
syscolpermsrowfactory tableid_index_num
keyrow
scanqualifier   null
ti
tupledescriptor  null
permissiondescriptorslist
false
/* next, using each of the colpermdescriptor's uuid, get the unique row
in syscolperms and adjust the "columns" column in syscolperms to
accomodate the added or dropped column in the tableid*/
colpermsdescriptor colpermsdescriptor
execrow currow
execindexrow uuidkey
// not updating any indexes on syscolperms
boolean barray   new boolean
int colstoupdate    syscolpermsrowfactory columns_col_num
for  iterator iterator   permissiondescriptorslist iterator    iterator hasnext
{
colpermsdescriptor    colpermsdescriptor  iterator next
removepermentryincache colpermsdescriptor
uuidkey   rf buildindexkeyrow rf colpermsid_index_num  colpermsdescriptor
currow ti getrow tc  uuidkey  rf colpermsid_index_num
formatablebitset columns    formatablebitset  currow getcolumn
syscolpermsrowfactory columns_col_num  getobject
// see whether this is add column or drop column. if add, then
// add a new bit to the bit set. if drop, then remove the bit
// for the dropped column.
if  columndescriptor    null
{
int currentlength   columns getlength
columns grow currentlength 1
}
else
{
formatablebitset modifiedcolumns new formatablebitset columns
modifiedcolumns shrink columns getlength   1
// all the bits from 0 ... colposition-2 are ok. the bits from
// colposition to the end need to be shifted 1 to the left.
// the bit for colposition-1 simply disappears from columns.
// columnposition values count from 1, while bits in the
// formatablebitset count from 0.
for  int i   columndescriptor getposition   1
i < modifiedcolumns getlength
i
{
if  columns isset i 1
modifiedcolumns set i
else
modifiedcolumns clear i
}
columns   modifiedcolumns
}
currow setcolumn syscolpermsrowfactory columns_col_num
dvf getdatavalue  object  columns
ti updaterow uuidkey  currow
syscolpermsrowfactory colpermsid_index_num
barray
colstoupdate
tc
}
}
/**
* remove permissionsdescriptor from permissions cache if present
*/
private void removepermentryincache permissionsdescriptor perm
throws standardexception
{
// remove cached permissions entry if present
cacheable cacheentry   getpermissionscache   findcached  perm
if  cacheentry    null
getpermissionscache   remove cacheentry
}
/**
* drops all routine permission descriptors for the given routine.
*
* @param routineid	the uuid of the routine from which to drop
*			all the permission descriptors
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on error
*/
public void	dropallroutinepermdescriptors uuid routineid  transactioncontroller tc
throws standardexception
{
tabinfoimpl	ti   getnoncoreti sysroutineperms_catalog_num
sysroutinepermsrowfactory rf    sysroutinepermsrowfactory  ti getcatalogrowfactory
datavaluedescriptor	routineidorderable
execrow currow
permissionsdescriptor perm
// in derby authorization mode, permission catalogs may not be present
if   usessqlauthorization
return
/* use tableidorderable in both start and stop position for scan. */
routineidorderable   getidvalueaschar routineid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  routineidorderable
while   currow ti getrow tc  keyrow  rf aliasid_index_num      null
{
perm    permissionsdescriptor rf builddescriptor currow   tupledescriptor  null  this
removepermentryincache perm
// build new key based on uuid and drop the entry as we want to drop
// only this row
execindexrow uuidkey
uuidkey   rf buildindexkeyrow rf routinepermsid_index_num  perm
ti deleterow tc  uuidkey  rf routinepermsid_index_num
}
}
/**
* @see datadictionary#droprolegrantsbygrantee
*/
public void droprolegrantsbygrantee string grantee
transactioncontroller tc
throws standardexception
{
tabinfoimpl ti   getnoncoreti sysroles_catalog_num
sysrolesrowfactory rf    sysrolesrowfactory ti getcatalogrowfactory
visitrolegrants ti
rf
rf sysroles_grantee_colpos_in_index_id_ee_or
grantee
tc
datadictionaryimpl drop
}
/**
* return true if there exists a role grant to authorization
* identifier.
*
* @param grantee authorization identifier
* @param tc      transaction controller
*
* @return true if there exists such a grant
* @exception standardexception thrown on failure
*/
private boolean existsrolegrantbygrantee string grantee
transactioncontroller tc
throws standardexception
{
tabinfoimpl ti   getnoncoreti sysroles_catalog_num
sysrolesrowfactory rf    sysrolesrowfactory ti getcatalogrowfactory
return visitrolegrants ti
rf
rf sysroles_grantee_colpos_in_index_id_ee_or
grantee
tc
datadictionaryimpl exists
}
/**
* @see datadictionary#droprolegrantsbyname
*/
public void droprolegrantsbyname string rolename
transactioncontroller tc
throws standardexception
{
tabinfoimpl ti   getnoncoreti sysroles_catalog_num
sysrolesrowfactory rf    sysrolesrowfactory ti getcatalogrowfactory
visitrolegrants ti
rf
rf sysroles_roleid_colpos_in_index_id_ee_or
rolename
tc
datadictionaryimpl drop
}
/**
* scan the {roleid, grantee, grantor} index on sysroles,
* locate rows containing authid in column columnno.
*
* the action argument can be either <code>exists</code> or
* <code>drop</code> (to check for existence, or to drop that row).
*
* if the scan proves too slow, we should add more indexes.  only.
*
* @param ti <code>tabinfoimpl</code> for sysroles.
* @param rf row factory for sysroles
* @param columnno the column number to match <code>authid</code> against
* @param tc transaction controller
* @param action drop matching rows (<code>drop</code>), or return
*        <code>true</code> if there is a matching row
*        (<code>exists</code>)
*
* @return action=exists: return {@code true} if there is a matching row
*      else return {@code false}.
* @exception standardexception
*/
private boolean visitrolegrants tabinfoimpl ti
sysrolesrowfactory rf
int columnno
string authid
transactioncontroller tc
int action
throws standardexception
{
conglomeratecontroller heapcc   tc openconglomerate
ti getheapconglomerate    false  0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
datavaluedescriptor authidorderable   new sqlvarchar authid
scanqualifier scanqualifier   exfactory getscanqualifier 1
scanqualifier setqualifier
columnno   1 	   to zero based
authidorderable
orderable order_op_equals
false
false
false
scancontroller sc   tc openscan
ti getindexconglomerate rf sysroles_index_id_ee_or_idx
false       don't hold open across commit
0           for update
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
formatablebitset  null          all fields as objects
datavaluedescriptor  null     start position
0                                startsearchoperation   none
scanqualifier
datavaluedescriptor  null     stop position  through last row
0                                stopsearchoperation   none
try
execrow outrow   rf makeemptyrow
execindexrow indexrow   getindexrowfromheaprow
ti getindexrowgenerator rf sysroles_index_id_ee_or_idx
heapcc newrowlocationtemplate
outrow
while  sc fetchnext indexrow getrowarray
if  action    datadictionaryimpl exists
return true
else if  action    datadictionaryimpl drop
ti deleterow tc  indexrow
rf sysroles_index_id_ee_or_idx
}
}
finally
if  sc    null
sc close
}
if  heapcc    null
heapcc close
}
}
return false
}
/**
* return an in-memory representation of the role grant graph (sans
* grant of roles to users, only role-role relation.
*
* @param tc        transaction controller
* @param inverse   make graph on inverse grant relation
* @return          hash map representing role grant graph.
*                  <ul><li>key: rolename,</li>
*                      <li>value: list<rolegrantdescriptor> representing a
*                      grant of that rolename to another role (not user).
*                      </li>
*                  </ul>
*
* fixme: need to cache graph and invalidate when role graph is modified.
* currently, we always read from sysroles.
*/
hashmap getrolegrantgraph transactioncontroller tc  boolean inverse
throws standardexception
hashmap hm   new hashmap
tabinfoimpl ti   getnoncoreti sysroles_catalog_num
sysrolesrowfactory rf    sysrolesrowfactory  ti getcatalogrowfactory
datavaluedescriptor isdeforderable   new sqlvarchar
scanqualifier scanqualifier   exfactory getscanqualifier 1
scanqualifier setqualifier
sysrolesrowfactory sysroles_isdef   1     to zero based
isdeforderable
orderable order_op_equals
false
false
false
scancontroller sc   tc openscan
ti getheapconglomerate
false       don't hold open across commit
0           for update
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
formatablebitset  null          all fields as objects
datavaluedescriptor  null     start position
0                                startsearchoperation   none
scanqualifier
datavaluedescriptor  null     stop position  through last row
0                                stopsearchoperation   none
execrow outrow    rf makeemptyrow
rolegrantdescriptor grantdescr
while  sc fetchnext outrow getrowarray
grantdescr    rolegrantdescriptor rf builddescriptor
outrow
tupledescriptor  null
this
// next call is potentially inefficient.  we could read in
// definitions first in a separate hash table limiting
// this to a 2-pass scan.
rolegrantdescriptor granteedef   getroledefinitiondescriptor
grantdescr getgrantee
if  granteedef    null
// not a role, must be user authid, skip
continue
}
string hashkey
if  inverse
hashkey   granteedef getrolename
else
hashkey   grantdescr getrolename
}
list arcs    list hm get hashkey
if  arcs    null
arcs   new linkedlist
}
arcs add grantdescr
hm put hashkey  arcs
}
sc close
return hm
}
/**
* @see datadictionary#createroleclosureiterator
*/
public roleclosureiterator createroleclosureiterator
transactioncontroller tc
string role
boolean inverse
throws standardexception
return new roleclosureiteratorimpl role  inverse  this  tc
}
/**
* drop all permission descriptors corresponding to a grant to
* the named authentication identifier
*
* @param authid  the authentication identifier
* @param tc      transaction controller
*
* @exception standardexception thrown on failure
*/
public void dropallpermsbygrantee string authid
transactioncontroller tc
throws standardexception
{
droppermsbygrantee
authid
tc
systableperms_catalog_num
systablepermsrowfactory grantee_table_grantor_index_num
systablepermsrowfactory
grantee_col_num_in_grantee_table_grantor_index
droppermsbygrantee
authid
tc
syscolperms_catalog_num
syscolpermsrowfactory grantee_table_type_grantor_index_num
syscolpermsrowfactory
grantee_col_num_in_grantee_table_type_grantor_index
droppermsbygrantee
authid
tc
sysroutineperms_catalog_num
sysroutinepermsrowfactory grantee_alias_grantor_index_num
sysroutinepermsrowfactory
grantee_col_num_in_grantee_alias_grantor_index
}
/**
* presently only used when dropping roles - user dropping is not under
* derby control (well, built-in users are if properties are stored in
* database), any permissions granted to users remain in place even if the
* user is no more.
*/
private void droppermsbygrantee string authid
transactioncontroller tc
int catalog
int indexno
int granteecolnoinindex
throws standardexception
{
visitpermsbygrantee authid
tc
catalog
indexno
granteecolnoinindex
datadictionaryimpl drop
}
/**
* return true if there exists a permission grant descriptor to this
* authorization id.
*/
private boolean existspermbygrantee string authid
transactioncontroller tc
int catalog
int indexno
int granteecolnoinindex
throws standardexception
{
return visitpermsbygrantee authid
tc
catalog
indexno
granteecolnoinindex
datadictionaryimpl exists
}
/**
* possible action for visitpermsbygrantee and visitrolegrants.
*/
static final int drop     0
/**
* possible action for visitpermsbygrantee and visitrolegrants.
*/
static final int exists   1
/**
* scan <code>indexno</code> index on a permission table
* <code>catalog</code>, looking for match(es) for the grantee column
* (given by granteecolnoinindex for the catalog in question).
*
* the action argument can be either <code>exists</code> or
* <code>drop</code> (to check for existence, or to drop that row).
*
* there is no index on grantee column only on on any of the
* permissions tables, so we use the index which contain grantee
* and scan that, setting up a scan qualifier to match the
* grantee, then fetch the base row.
*
* if this proves too slow, we should add an index on grantee
* only.
*
* @param authid grantee to match against
* @param tc transaction controller
* @param catalog the underlying permission table to visit
* @param indexno the number of the index by which to access the catalog
* @param granteecolnoinindex the column number to match
*        <code>authid</code> against
* @param action drop matching rows (<code>drop</code>), or return
*        <code>true</code> if there is a matching row
*        (<code>exists</code>)
*
* @return action=exists: return {@code true} if there is a matching row
*      else return {@code false}.
* @exception standardexception
*/
private boolean visitpermsbygrantee string authid
transactioncontroller tc
int catalog
int indexno
int granteecolnoinindex
int action
throws standardexception
{
tabinfoimpl ti   getnoncoreti catalog
permissionscatalogrowfactory rf
permissionscatalogrowfactory ti getcatalogrowfactory
conglomeratecontroller heapcc   tc openconglomerate
ti getheapconglomerate    false  0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
datavaluedescriptor authidorderable   new sqlvarchar authid
scanqualifier scanqualifier   exfactory getscanqualifier 1
scanqualifier setqualifier
granteecolnoinindex   1 	   to zero based
authidorderable
orderable order_op_equals
false
false
false
scancontroller sc   tc openscan
ti getindexconglomerate indexno
false                            don't hold open across commit
0                                for update
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
formatablebitset  null          all fields as objects
datavaluedescriptor  null     start position
0                                startsearchoperation   none
scanqualifier
datavaluedescriptor  null     stop position  through last row
0                                stopsearchoperation   none
try
execrow outrow   rf makeemptyrow
execindexrow indexrow   getindexrowfromheaprow
ti getindexrowgenerator indexno
heapcc newrowlocationtemplate
outrow
while  sc fetchnext indexrow getrowarray
rowlocation baserowlocation    rowlocation indexrow getcolumn
indexrow ncolumns
boolean base_row_exists
heapcc fetch
baserowlocation  outrow getrowarray
formatablebitset null
if  sanitymanager debug
// it can not be possible for heap row to
// disappear while holding scan cursor on index at
// isolation_repeatable_read.
sanitymanager assert base_row_exists
}
if  action    datadictionaryimpl exists
return true
else if  action    datadictionaryimpl drop
permissionsdescriptor perm    permissionsdescriptor rf
builddescriptor outrow
tupledescriptor  null
this
removepermentryincache perm
ti deleterow tc  indexrow  indexno
}
}
finally
if  sc    null
sc close
}
if  heapcc    null
heapcc close
}
}
return false
}
/**
* delete the appropriate rows from syscolumns when
* dropping 1 or more columns.
*
* @param tc			the transactioncontroller
* @param keyrow		start/stop position.
*
* @exception standardexception		thrown on failure
*/
private void dropcolumndescriptorcore
transactioncontroller tc
execindexrow keyrow
throws standardexception
{
tabinfoimpl				   ti   coreinfo
ti deleterow  tc  keyrow  syscolumnsrowfactory syscolumns_index1_id
}
/**
* delete the appropriate rows from systableperms when
* dropping a table
*
* @param tc			the transactioncontroller
* @param keyrow		start/stop position.
*
* @exception standardexception		thrown on failure
*/
private void droptablepermdescriptor
transactioncontroller tc
execindexrow keyrow
throws standardexception
{
execrow currow
permissionsdescriptor perm
tabinfoimpl	ti   getnoncoreti systableperms_catalog_num
systablepermsrowfactory rf    systablepermsrowfactory  ti getcatalogrowfactory
while   currow ti getrow tc  keyrow  rf tableid_index_num      null
{
perm    permissionsdescriptor rf builddescriptor currow   tupledescriptor  null  this
removepermentryincache perm
// build key on uuid and drop the entry as we want to drop only this row
execindexrow uuidkey
uuidkey   rf buildindexkeyrow rf tablepermsid_index_num  perm
ti deleterow tc  uuidkey  rf tablepermsid_index_num
}
}
/**
* delete the appropriate rows from syscolperms when
* dropping a table
*
* @param tc			the transactioncontroller
* @param keyrow		start/stop position.
*
* @exception standardexception		thrown on failure
*/
private void dropcolumnpermdescriptor
transactioncontroller tc
execindexrow keyrow
throws standardexception
{
execrow currow
permissionsdescriptor perm
tabinfoimpl	ti   getnoncoreti syscolperms_catalog_num
syscolpermsrowfactory rf    syscolpermsrowfactory  ti getcatalogrowfactory
while   currow ti getrow tc  keyrow  rf tableid_index_num      null
{
perm    permissionsdescriptor rf builddescriptor currow   tupledescriptor  null  this
removepermentryincache perm
// build key on uuid and drop the entry as we want to drop only this row
execindexrow uuidkey
uuidkey   rf buildindexkeyrow rf colpermsid_index_num  perm
ti deleterow tc  uuidkey  rf colpermsid_index_num
}
}
/**
* update the column descriptor in question.  updates
* every row in the base conglomerate.
*
* @param cd					the columndescriptor
* @param formeruuid			the uuid for this column in syscolumns,
*								may differ from what is in cd if this
*								is the column that is being set.
* @param formername			the name for this column in syscolumns
*								may differ from what is in cd if this
*								is the column that is being set.
* @param colstoset 			array of ints of columns to be modified,
*								1 based.  may be null (all cols).
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
private void updatecolumndescriptor columndescriptor cd
uuid		formeruuid
string		formername
int		colstoset
transactioncontroller tc
throws standardexception
{
execindexrow				keyrow1   null
execrow    					row
datavaluedescriptor			refidorderable
datavaluedescriptor			columnnameorderable
tabinfoimpl						ti   coreinfo
syscolumnsrowfactory  rf    syscolumnsrowfactory  ti getcatalogrowfactory
/* use objectid/columnname in both start
* and stop position for index 1 scan.
*/
refidorderable   getidvalueaschar formeruuid
columnnameorderable   new sqlvarchar formername
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 2
keyrow1 setcolumn 1  refidorderable
keyrow1 setcolumn 2  columnnameorderable
// build the row to be stuffed into syscolumns.
row   rf makerow cd  null
/*
** figure out if the index in syscolumns needs
** to be updated.
*/
if  sanitymanager debug
{
sanitymanager assert rf getnumindexes      2
}
boolean barray   new boolean
/*
** do we need to update indexes?
*/
if  colstoset    null
{
barray   true
barray   true
}
else
{
/*
** check the specific columns for indexed
** columns.
*/
for  int i   0  i < colstoset length  i
{
if   colstoset    rf syscolumns_columnname
colstoset    rf syscolumns_referenceid
{
barray   true
break
}
else if  colstoset    rf syscolumns_columndefaultid
{
barray   true
break
}
}
}
ti updaterow keyrow1  row
syscolumnsrowfactory syscolumns_index1_id
barray
colstoset
tc
}
/**
* gets the viewdescriptor for the view with the given uuid.
*
* @param uuid	the uuid for the view
*
* @return  a descriptor for the view
*
* @exception standardexception		thrown on error
*/
public viewdescriptor	getviewdescriptor uuid uuid
throws standardexception
{
return getviewdescriptor gettabledescriptor uuid
}
/**
* gets the viewdescriptor for the view given the tabledescriptor.
*
* @param td	the tabledescriptor for the view.
*
* @return	a descriptor for the view
*
* @exception standardexception		thrown on error
*/
public viewdescriptor	getviewdescriptor tabledescriptor td
throws standardexception
{
tabledescriptor	tdi    tabledescriptor  td
/* see if the view info is cached */
if  tdi getviewdescriptor      null
{
return tdi getviewdescriptor
}
synchronized tdi
{
/* see if we were waiting on someone who just filled it in */
if  tdi getviewdescriptor      null
{
return tdi getviewdescriptor
}
tdi setviewdescriptor  viewdescriptor  getviewdescriptorscan tdi
}
return tdi getviewdescriptor
}
/**
* get the information for the view from sys.sysviews.
*
* @param tdi					the tabledescriptor for the view.
*
* @return viewdescriptor	the viewdescriptor for the view.
*
* @exception standardexception		thrown on error
*/
private viewdescriptor getviewdescriptorscan tabledescriptor tdi
throws standardexception
{
viewdescriptor		  vd
datavaluedescriptor	  viewidorderable
tabinfoimpl				  ti   getnoncoreti sysviews_catalog_num
uuid				  viewid   tdi getuuid
/* use viewidorderable in both start
* and stop position for scan.
*/
viewidorderable   getidvalueaschar viewid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  viewidorderable
vd    viewdescriptor
getdescriptorviaindex
sysviewsrowfactory sysviews_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
if  vd    null
{
vd setviewname tdi getname
}
return vd
}
/**
* drops the view descriptor from the data dictionary.
*
* @param vd		a descriptor for the view to be dropped
* @param tc		transactioncontroller to use
*
* @exception standardexception		thrown on error
*/
public void	dropviewdescriptor viewdescriptor vd
transactioncontroller tc
throws standardexception
{
datavaluedescriptor		viewidorderable
tabinfoimpl					ti   getnoncoreti sysviews_catalog_num
/* use aliasnameorderable in both start
* and stop position for scan.
*/
viewidorderable   getidvalueaschar vd getuuid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  viewidorderable
ti deleterow  tc  keyrow  sysviewsrowfactory sysviews_index1_id
}
/**
* scan sysfiles_index2 (id) for a match.
* @return tabledescriptor	the matching descriptor, or null.
* @exception standardexception		thrown on failure
*/
private fileinfodescriptor
getfileinfodescriptorindex2scan uuid id
throws standardexception
{
datavaluedescriptor		  idorderable
tabinfoimpl					  ti   getnoncoreti sysfiles_catalog_num
idorderable   getidvalueaschar id
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  idorderable
return  fileinfodescriptor
getdescriptorviaindex
sysfilesrowfactory sysfiles_index2_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* @see datadictionary#getfileinfodescriptor
* @exception standardexception		thrown on failure
*/
public fileinfodescriptor getfileinfodescriptor uuid id
throws standardexception
{
return getfileinfodescriptorindex2scan id
}
/**
* scan sysfiles_index1 (schemaid,name) for a match.
* @return the matching descriptor or null.
* @exception standardexception		thrown on failure
*/
private fileinfodescriptor getfileinfodescriptorindex1scan
uuid schemaid
string name
throws standardexception
{
datavaluedescriptor		  schemaidorderable
datavaluedescriptor		  nameorderable
tabinfoimpl					  ti   getnoncoreti sysfiles_catalog_num
nameorderable   new sqlvarchar name
schemaidorderable   getidvalueaschar schemaid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 2
keyrow setcolumn 1  nameorderable
keyrow setcolumn 2  schemaidorderable
fileinfodescriptor r    fileinfodescriptor
getdescriptorviaindex
sysfilesrowfactory sysfiles_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
return r
}
/**
* @see datadictionary#getfileinfodescriptor
* @exception standardexception		thrown on failure
*/
public fileinfodescriptor getfileinfodescriptor schemadescriptor sd  string name
throws standardexception
{
return getfileinfodescriptorindex1scan sd getuuid   name
}
/**
* @see datadictionary#dropfileinfodescriptor
* @exception standardexception		thrown on error
*/
public void	dropfileinfodescriptor fileinfodescriptor fid
throws standardexception
{
conglomeratecontroller	heapcc
execindexrow			keyrow1   null
datavaluedescriptor		idorderable
tabinfoimpl					ti   getnoncoreti sysfiles_catalog_num
transactioncontroller   tc   gettransactionexecute
/* use tableidorderable and schemaidorderable in both start
* and stop position for index 1 scan.
*/
idorderable   getidvalueaschar fid getuuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 1
keyrow1 setcolumn 1  idorderable
ti deleterow  tc  keyrow1  sysfilesrowfactory sysfiles_index2_id
}
/**
* get a spsdescriptor given its uuid.
*
* @param uuid	the uuid
*
* @return the spsdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public spsdescriptor getspsdescriptor uuid uuid
throws standardexception
{
spsdescriptor 		sps
/* make sure that non-core info is initialized */
getnoncoreti sysstatements_catalog_num
/* only use the cache if we're in compile-only mode */
if   spsnamecache    null
getcachemode      datadictionary compile_only_mode
{
sps    spsdescriptor spsidhash get uuid
if  sps    null
{
//system.out.println("found in hash table ");
// system.out.println("stmt text " + sps.gettext());
return sps
}
sps   getspsdescriptorindex2scan uuid tostring
tablekey stmtkey   new tablekey sps getschemadescriptor   getuuid    sps getname
try
{
spsnamecacheable 	cacheentry    spsnamecacheable spsnamecache create stmtkey  sps
spsnamecache release cacheentry
catch  standardexception se
{
/*
** if the error is that the item is already
** in the cache, then that is ok.
*/
if  sqlstate object_exists_in_cache equals se getmessageid
{
return sps
}
else
{
throw se
}
}
}
else
{
sps   getspsdescriptorindex2scan uuid tostring
}
return sps
}
/**
add an entry to the hashtables for lookup from the cache.
*/
void spscacheentryadded spsdescriptor spsd
{
spsidhash put spsd getuuid    spsd
// spstexthash.put(spsd.gettext(), spsd);
}
void spscacheentryremoved spsdescriptor spsd
spsidhash remove spsd getuuid
// spstexthash.remove(spsd.gettext());
}
//public spsdescriptor getspsbysqltext(string text) {
//	return (spsdescriptor) spstexthash.get(text);
//}
/**
* this method can get called from the datadictionary cache.
*
* @param stmtkey	the tablekey of the sps
*
* @return	the descriptor for the sps, null if the sps does
*		not exist.
*
* @exception standardexception		thrown on failure
*/
public spsdescriptor getuncachedspsdescriptor tablekey stmtkey
throws standardexception
{
return getspsdescriptorindex1scan stmtkey gettablename
stmtkey getschemaid   tostring
}
/**
* this method can get called from the datadictionary cache.
*
* @param stmtid	the uuid of the stmt to get the descriptor for
*
* @return	the descriptor for the stmt, null if the table does
*		not exist.
*
* @exception standardexception		thrown on failure
*/
protected spsdescriptor	getuncachedspsdescriptor uuid stmtid
throws standardexception
{
return getspsdescriptorindex2scan stmtid tostring
}
/**
* scan sysstatements_index2 (stmtid) for a match.
* note that we do not do a lookup of parameter info.
*
* @return spsdescriptor	the matching descriptor, if any.
*
* @exception standardexception		thrown on failure
*/
private spsdescriptor getspsdescriptorindex2scan
string stmtuuid
throws standardexception
{
datavaluedescriptor		  stmtidorderable
tabinfoimpl					  ti   getnoncoreti sysstatements_catalog_num
/* use stmtidorderable in both start
* and stop position for scan.
*/
stmtidorderable   new sqlchar stmtuuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  stmtidorderable
spsdescriptor spsd    spsdescriptor
getdescriptorviaindex
sysstatementsrowfactory sysstatements_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
return spsd
}
/**
* get a spsdescriptor given its name.
* currently no cacheing.  with caching
* we need to be very careful about invalidation.
* no caching means invalidations block on
* existing spsd instances (since they were read in
*
* @param stmtname	the statement name
* @param sd	the schemadescriptor
*
* @return the spsdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public spsdescriptor getspsdescriptor string stmtname  schemadescriptor sd
throws standardexception
{
spsdescriptor		sps   null
tablekey			stmtkey
uuid				schemauuid
/*
** if we didn't get a schema descriptor, we had better
** have a system table.
*/
if  sanitymanager debug
{
if  sd    null
{
sanitymanager throwassert   stmtname
}
}
schemauuid   sd getuuid
stmtkey   new tablekey schemauuid  stmtname
/* only use the cache if we're in compile-only mode */
if   spsnamecache    null
getcachemode      datadictionary compile_only_mode
{
spsnamecacheable cacheentry    spsnamecacheable  spsnamecache find stmtkey
if  cacheentry    null
{
sps   cacheentry getspsdescriptor
spsnamecache release cacheentry
}
//system.out.println("found in cache " + stmtname);
//system.out.println("stmt text " + sps.gettext());
return sps
}
return getspsdescriptorindex1scan stmtname  schemauuid tostring
}
/**
* scan sysschemas_index1 (stmtname, schemaid) for a match.
*
* @return spsdescriptor	the matching descriptor, if any.
*
* @exception standardexception		thrown on failure
*/
private spsdescriptor getspsdescriptorindex1scan
string stmtname
string schemauuid
throws standardexception
{
datavaluedescriptor		  schemaidorderable
datavaluedescriptor		  stmtnameorderable
tabinfoimpl					  ti   getnoncoreti sysstatements_catalog_num
/* use stmtnameorderable and schemaidorderable in both start
* and stop position for scan.
*/
stmtnameorderable   new sqlvarchar stmtname
schemaidorderable   new sqlchar schemauuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 2
keyrow setcolumn 1  stmtnameorderable
keyrow setcolumn 2  schemaidorderable
spsdescriptor spsd    spsdescriptor
getdescriptorviaindex
sysstatementsrowfactory sysstatements_index2_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
/*
** set up the parameter defaults.  we are only
** doing this when we look up by name because
** this is the only time we cache, and it can
** be foolish to look up the parameter defaults
** for someone that doesn't need them.
*/
if  spsd    null
{
vector v   new vector
spsd setparams getspsparams spsd  v
object defaults   new object
v copyinto defaults
spsd setparameterdefaults defaults
}
return spsd
}
/**
* adds the given spsdescriptor to the data dictionary,
* associated with the given table and constraint type.
*
* @param descriptor	the descriptor to add
* @param tc			the transaction controller
*
* @exception standardexception		thrown on error
*/
public void	addspsdescriptor
spsdescriptor 			descriptor
transactioncontroller	tc
throws standardexception
{
execrow        			row
tabinfoimpl					ti   getnoncoreti sysstatements_catalog_num
sysstatementsrowfactory	rf    sysstatementsrowfactory  ti getcatalogrowfactory
int						insertretcode
/*
** we must make sure the descriptor is locked
** while we are writing it out.  otherwise,
** the descriptor could be invalidated while
** we are writing.
*/
synchronized descriptor
{
// build the row to be stuffed into sysstatements. this will stuff an
// uuid into the descriptor
boolean	compileme   descriptor initiallycompilable
row   rf makesysstatementsrow compileme  descriptor
// insert row into catalog and all its indices
insertretcode   ti insertrow row  tc
}
// throw an exception duplicate table descriptor
if  insertretcode    tabinfoimpl rownotduplicate
{
throw standardexception newexception sqlstate lang_object_already_exists_in_object
descriptor getdescriptortype
descriptor getdescriptorname
descriptor getschemadescriptor   getdescriptortype
descriptor getschemadescriptor   getschemaname
}
addspsparams descriptor  tc
}
/**
* add a column in sys.syscolumns for each parameter in the
* parameter list.
*/
private void addspsparams spsdescriptor spsd  transactioncontroller tc
throws standardexception
{
uuid 					uuid   spsd getuuid
datatypedescriptor params   spsd getparams
object parameterdefaults   spsd getparameterdefaults
if  params    null
return
/* create the columns */
int pdlsize   params length
for  int index   0  index < pdlsize  index
{
int parameterid   index   1
//resolveautoincrement
columndescriptor cd
new columndescriptor
parameterid
parameterid 	   position
params
parameterdefaults    null        default
index >  parameterdefaults length   ?
datavaluedescriptor null
datavaluedescriptor parameterdefaults
defaultinfo  null
uuid
uuid  null  0  0  0
adddescriptor cd  null  syscolumns_catalog_num
false     no chance of duplicates here
tc
}
}
/**
* get all the parameter descriptors for an sps.
* look up the params in syscolumns and turn them
* into parameter descriptors.
*
* @param spsd	sps descriptor
* @param defaults	vector for storing column defaults
*
* @return array of data type descriptors
*
* @exception standardexception		thrown on error
*/
public datatypedescriptor getspsparams spsdescriptor spsd  vector defaults
throws standardexception
{
columndescriptorlist cdl   new columndescriptorlist
getcolumndescriptorsscan spsd getuuid    cdl  spsd
int cdlsize   cdl size
datatypedescriptor params   new datatypedescriptor
for  int index   0  index < cdlsize  index
{
columndescriptor cd    columndescriptor  cdl elementat index
params   cd gettype
if  defaults    null
{
defaults addelement cd getdefaultvalue
}
}
return params
}
/**
* updates sys.sysstatements with the info from the
* spsd.
*
* @param spsd	the descriptor to add
* @param tc			the transaction controller
* @param updateparamdescriptors if true, will update the
*						parameter descriptors in sys.syscolumns.
* @param firstcompilation  true, if statement is getting compiled for first
*                          time and sps was created with nocompile option.
*
* @exception standardexception		thrown on error
*/
public void	updatesps
spsdescriptor			spsd
transactioncontroller	tc
boolean                 recompile
boolean					updateparamdescriptors
boolean                 firstcompilation
throws standardexception
{
execindexrow				keyrow1   null
execrow    					row
datavaluedescriptor			idorderable
tabinfoimpl						ti   getnoncoreti sysstatements_catalog_num
sysstatementsrowfactory  rf    sysstatementsrowfactory  ti getcatalogrowfactory
int updcols
if  recompile
{
if firstcompilation
{
updcols   new int  sysstatementsrowfactory sysstatements_valid
sysstatementsrowfactory sysstatements_lastcompiled
sysstatementsrowfactory sysstatements_usingtext
sysstatementsrowfactory sysstatements_constantstate
sysstatementsrowfactory sysstatements_initially_compilable
else
{
updcols   new int  sysstatementsrowfactory sysstatements_valid
sysstatementsrowfactory sysstatements_lastcompiled
sysstatementsrowfactory sysstatements_usingtext
sysstatementsrowfactory sysstatements_constantstate
}
}
else
{
updcols   new int	 sysstatementsrowfactory sysstatements_valid
}
idorderable   getidvalueaschar spsd getuuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 1
keyrow1 setcolumn 1  idorderable
row   rf makesysstatementsrow false  	   don't compile
spsd
/*
** not updating any indexes
*/
boolean barray   new boolean
/*
** partial update
*/
ti updaterow keyrow1  row
sysstatementsrowfactory sysstatements_index1_id
barray
updcols
tc
/*
** if we don't need to update the parameter
** descriptors, we are done.
*/
if   updateparamdescriptors
{
return
}
/*
** set the defaults and datatypes for the parameters, if
** there are parameters.
*/
datatypedescriptor params   spsd getparams
if  params    null
{
return
}
if firstcompilation
{
/*beetle:5119, reason for doing add here instead of update
*is with nocompile option of create statement/boot time sps,
*sps statement is not compiled to find out the parameter info.
*because of the parameter info was not inserted at spsdescriptor
*creation time. as this is the first time we are compiling paramter
*infor should be inserted instead of the update.
*/
addspsparams spsd  tc
}
else
{
object parameterdefaults   spsd getparameterdefaults
/*
** update each column with the new defaults and with
** the new datatypes.  it is possible that someone has
** done a drop/create on the underlying table and
** changed the type of a column, which has changed
** the type of a parameter to our statement.
*/
int columnstoset   new int
columnstoset   syscolumnsrowfactory syscolumns_columndatatype
columnstoset   syscolumnsrowfactory syscolumns_columndefault
uuid uuid   spsd getuuid
for  int index   0  index < params length  index
{
int parameterid   index   1
//resolveautoincrement
columndescriptor cd   new columndescriptor     parameterid
parameterid 	   position
params
parameterdefaults    null        default
index >  parameterdefaults length   ?
datavaluedescriptor null
datavaluedescriptor parameterdefaults
defaultinfo  null
uuid
uuid  null
0  0  0
updatecolumndescriptor cd
cd getreferencinguuid
cd getcolumnname
columnstoset
tc
}
}
}
/**
* @see datadictionary#invalidateallspsplans
* @exception standardexception		thrown on error
*/
public void invalidateallspsplans   throws standardexception
{
languageconnectioncontext lcc    languageconnectioncontext
contextservice getcontext languageconnectioncontext context_id
startwriting lcc
for  java util iterator li   getallspsdescriptors   iterator    li hasnext
{
spsdescriptor spsd    spsdescriptor  li next
spsd makeinvalid dependencymanager user_recompile_request  lcc
}
}
/**
* mark all sps plans in the data dictionary invalid. this does
* not invalidate cached plans. this function is for use by
* the boot-up code.
* @exception standardexception		thrown on error
*/
void clearspsplans   throws standardexception
{
tabinfoimpl ti   getnoncoreti sysstatements_catalog_num
faultintabinfo ti
transactioncontroller tc   gettransactionexecute
formatablebitset columntoreadset   new formatablebitset sysstatementsrowfactory sysstatements_column_count
formatablebitset columntoupdateset   new formatablebitset sysstatementsrowfactory sysstatements_column_count
columntoupdateset set sysstatementsrowfactory sysstatements_valid  1
columntoupdateset set sysstatementsrowfactory sysstatements_constantstate  1
datavaluedescriptor replacerow
new datavaluedescriptor
/* set up a couple of row templates for fetching chars */
replacerow
dvf getdatavalue false
replacerow
dvf getdatavalue  object  null
/* scan the entire heap */
scancontroller sc
tc openscan
ti getheapconglomerate
false
transactioncontroller openmode_forupdate
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
columntoreadset
datavaluedescriptor  null
scancontroller na
qualifier  null
datavaluedescriptor  null
scancontroller na
while  sc fetchnext  datavaluedescriptor  null
{
/* replace the column in the table */
sc replace replacerow  columntoupdateset
}
sc close
}
/**
* drops the given spsdescriptor.
*
* @param descriptor	the descriptor to drop
* @param tc	the transactioncontroller.
*
* @exception standardexception		thrown on failure
*/
public void	dropspsdescriptor spsdescriptor descriptor
transactioncontroller tc
throws standardexception
{
dropspsdescriptor descriptor getuuid    tc
}
/**
* drops the given spsdescriptor.
*
* @param uuid	the statement uuid
* @param tc	the transactioncontroller.
*
* @exception standardexception		thrown on failure
*/
public void	dropspsdescriptor
uuid 					uuid
transactioncontroller	tc
throws standardexception
{
datavaluedescriptor		stmtidorderable
tabinfoimpl					ti   getnoncoreti sysstatements_catalog_num
stmtidorderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  stmtidorderable
ti deleterow  tc  keyrow  sysstatementsrowfactory sysstatements_index1_id
/* drop all columns in syscolumns */
dropallcolumndescriptors uuid  tc
}
/**
* get every statement in this database.
* return the spsdescriptors in an list.
*
* @return the list of descriptors
*
* @exception standardexception		thrown on failure
*/
public list getallspsdescriptors
throws standardexception
{
tabinfoimpl					ti   getnoncoreti sysstatements_catalog_num
list list   newslist
getdescriptorviaheap
scanqualifier  null
ti
tupledescriptor  null
list
return list
}
/**
* get every constraint in this database.
* note that this list of constraintdescriptors is
* not going to be the same objects that are typically
* cached off of the table descriptors, so this will
* most likely instantiate some duplicate objects.
*
* @return the list of descriptors
*
* @exception standardexception		thrown on failure
*/
private constraintdescriptorlist getallconstraintdescriptors
throws standardexception
{
tabinfoimpl					ti   getnoncoreti sysconstraints_catalog_num
constraintdescriptorlist list   new constraintdescriptorlist
getconstraintdescriptorviaheap
scanqualifier  null
ti
tupledescriptor  null
list
return list
}
/**
* get every trigger in this database.
* note that this list of triggerdescriptors is
* not going to be the same objects that are typically
* cached off of the table descriptors, so this will
* most likely instantiate some duplicate objects.
*
* @return the list of descriptors
*
* @exception standardexception		thrown on failure
*/
private genericdescriptorlist getalltriggerdescriptors
throws standardexception
{
tabinfoimpl					ti   getnoncoreti systriggers_catalog_num
genericdescriptorlist list   new genericdescriptorlist
getdescriptorviaheap
scanqualifier  null
ti
tupledescriptor  null
list
return list
}
/**
* get a triggerdescriptor given its uuid.
*
* @param uuid	the uuid
*
* @return the triggerdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public triggerdescriptor gettriggerdescriptor uuid uuid
throws standardexception
{
tabinfoimpl					  ti   getnoncoreti systriggers_catalog_num
datavaluedescriptor triggeridorderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  triggeridorderable
return  triggerdescriptor
getdescriptorviaindex
systriggersrowfactory systriggers_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* get the stored prepared statement descriptor given
* a sps name.
*
* @param name	the sps name.
* @param sd	the schema descriptor.
*
* @return the triggerdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public triggerdescriptor gettriggerdescriptor string name  schemadescriptor sd
throws standardexception
{
datavaluedescriptor		  schemaidorderable
datavaluedescriptor		  triggernameorderable
tabinfoimpl					  ti   getnoncoreti systriggers_catalog_num
/* use triggernameorderable and schemaidorderable in both start
* and stop position for scan.
*/
triggernameorderable   new sqlvarchar name
schemaidorderable   getidvalueaschar sd getuuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 2
keyrow setcolumn 1  triggernameorderable
keyrow setcolumn 2  schemaidorderable
return  triggerdescriptor
getdescriptorviaindex
systriggersrowfactory systriggers_index2_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* load up the trigger descriptor list for this table
* descriptor and return it.  if the descriptor list
* is already loaded up, it is retuned without further
* ado.
*
* @param td			the table descriptor.
*
* @return the constraintdescriptorlist for the table
*
* @exception standardexception		thrown on failure
*/
public genericdescriptorlist gettriggerdescriptors tabledescriptor td
throws standardexception
{
genericdescriptorlist	gdl
if  td    null
{
return getalltriggerdescriptors
}
/* build the tabledescriptor's tdl if it is currently empty */
gdl   td gettriggerdescriptorlist
/*
** synchronize the building of the tdl.  the tdl itself is created
** empty when the td is created, so there is no need to synchronize
** the getting of the tdl.
*/
synchronized gdl
{
if   gdl getscanned
{
gettriggerdescriptorsscan td  false
}
}
return gdl
}
/**
* populate the genericdescriptorlist for the specified tabledescriptor.
*
* mt synchronization: it is assumed that the caller has synchronized
* on the cdl in the given td.
*
* @param td				the tabledescriptor.
* @param forupdate			whether or not to open scan for update
*
* @exception standardexception		thrown on failure
*/
private void gettriggerdescriptorsscan tabledescriptor td  boolean forupdate
throws standardexception
{
genericdescriptorlist  	gdl    td  gettriggerdescriptorlist
datavaluedescriptor		tableidorderable   null
tabinfoimpl					ti   getnoncoreti systriggers_catalog_num
/* use tableidorderable in both start and stop positions for scan */
tableidorderable   getidvalueaschar td getuuid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  tableidorderable
getdescriptorviaindex
systriggersrowfactory systriggers_index3_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
gdl
forupdate
gdl setscanned true
}
/**
* drops the given triggerdescriptor.  warning: does
* not drop its spses!!!
*
* @param descriptor	the descriptor to drop
* @param tc	the transactioncontroller.
*
* @exception standardexception		thrown on failure
*/
public void	droptriggerdescriptor
triggerdescriptor 		descriptor
transactioncontroller 	tc
throws standardexception
{
datavaluedescriptor		idorderable
tabinfoimpl					ti   getnoncoreti systriggers_catalog_num
idorderable   getidvalueaschar descriptor getuuid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  idorderable
ti deleterow tc  keyrow  systriggersrowfactory systriggers_index1_id
}
/**
* update the trigger descriptor in question.  updates
* every row in the base conglomerate that matches the uuid.
*
* @param triggerd				the trigger descriptor
* @param formeruuid			the uuid for this column in systriggers,
*								may differ from what is in triggerd if this
*								is the column that is being set.
* @param colstoset 			array of ints of columns to be modified,
*								1 based.  may be null (all cols).
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updatetriggerdescriptor
triggerdescriptor 		triggerd
uuid					formeruuid
int					colstoset
transactioncontroller	tc
throws standardexception
{
execindexrow				keyrow1   null
execrow    					row
datavaluedescriptor			idorderable
datavaluedescriptor			columnnameorderable
tabinfoimpl						ti   getnoncoreti systriggers_catalog_num
systriggersrowfactory  		rf    systriggersrowfactory  ti getcatalogrowfactory
/* use objectid in both start
* and stop position for index 1 scan.
*/
idorderable   getidvalueaschar formeruuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 1
keyrow1 setcolumn 1  idorderable
// build the row to be stuffed into systriggers.
row   rf makerow triggerd  null
/*
** figure out if the index in systriggers needs
** to be updated.
*/
if  sanitymanager debug
{
sanitymanager assert rf getnumindexes      3
}
boolean barray   new boolean
/*
** do we need to update indexes?
*/
if  colstoset    null
{
barray   true
barray   true
barray   true
}
else
{
/*
** check the specific columns for indexed
** columns.
*/
for  int i   0  i < colstoset length  i
{
switch  colstoset
{
case systriggersrowfactory systriggers_triggerid
barray   true
break
case systriggersrowfactory systriggers_triggername
case systriggersrowfactory systriggers_schemaid
barray   true
break
case systriggersrowfactory systriggers_tableid
barray   true
break
}
}
}
ti updaterow keyrow1  row
systriggersrowfactory systriggers_index1_id
barray
colstoset
tc
}
/**
* get a constraintdescriptor given its uuid.  please
* use getconstraintdescriptorbyid() is you have the
* constraints table descriptor, it is much faster.
*
* @param uuid	the uuid
*
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptor uuid uuid
throws standardexception
{
datavaluedescriptor		uuidstringorderable
tabinfoimpl					ti   getnoncoreti sysconstraints_catalog_num
/* use uuidstringorderable in both start and stop positions for scan */
uuidstringorderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  uuidstringorderable
return getconstraintdescriptorviaindex
sysconstraintsrowfactory sysconstraints_index1_id
keyrow
ti
tabledescriptor  null
constraintdescriptorlist  null
false
}
/**
* get a constraintdescriptor given its name and schema id.
* please use getconstraintdescriptorbyname() if you have the
* constraint's table descriptor, it is much faster.
*
* @param constraintname	constraint name.
* @param schemaid			the schema uuid
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptor
string	constraintname
uuid	schemaid
throws standardexception
{
datavaluedescriptor		uuidstringorderable
datavaluedescriptor		constraintnameorderable
tabinfoimpl					ti   getnoncoreti sysconstraints_catalog_num
/* construct keys for both start and stop positions for scan */
constraintnameorderable   new sqlvarchar constraintname
uuidstringorderable   getidvalueaschar schemaid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 2
keyrow setcolumn 1  constraintnameorderable
keyrow setcolumn 2  uuidstringorderable
return getconstraintdescriptorviaindex
sysconstraintsrowfactory sysconstraints_index2_id
keyrow
ti
tabledescriptor  null
constraintdescriptorlist  null
false
}
/** get all the statistiscs descriptors for a given table.
* @param  td	table descriptor for which i need statistics
*/
public list getstatisticsdescriptors tabledescriptor td
throws standardexception
{
tabinfoimpl ti   getnoncoreti sysstatistics_catalog_num
list statdescriptorlist   newslist
datavaluedescriptor uuidstringorderable
/* set up the start/stop position for the scan */
uuidstringorderable   getidvalueaschar td getuuid
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  uuidstringorderable
getdescriptorviaindex sysstatisticsrowfactory sysstatistics_index1_id
keyrow
scanqualifier  null
ti
tupledescriptor null
statdescriptorlist  false
return statdescriptorlist
}
/**
* load up the constraint descriptor list for this table
* descriptor and return it.  if the descriptor list
* is already loaded up, it is retuned without further
* ado.  if no table descriptor is passed in, then all
* constraint descriptors are retrieved.  note that in
* this case, the constraint descriptor objects may be
* duplicates of constraint descriptors that are hung
* off of the table descriptor cache.
*
* @param td			the table descriptor.  if null,
*						all constraint descriptors are returned.
*
*
* @return the constraintdescriptorlist for the table
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptorlist getconstraintdescriptors tabledescriptor td
throws standardexception
{
constraintdescriptorlist	cdl
if  td    null
{
return getallconstraintdescriptors
}
/* resolve - need to look at multi-user aspects of hanging constraint
* descriptor list off of table descriptor when we restore the cache.
*/
/* build the tabledescriptor's cdl if it is currently empty */
cdl   td getconstraintdescriptorlist
/*
** synchronize the building of the cdl.  the cdl itself is created
** empty when the td is created, so there is no need to synchronize
** the getting of the cdl.
*/
synchronized cdl
{
if    cdl getscanned
{
getconstraintdescriptorsscan td  false
}
}
return cdl
}
/**
* convert a constraint descriptor list into a list
* of active constraints, that is, constraints which
* must be enforced. for the core product, these
* are just the constraints on the original list.
* however, during refresh we may have deferred some
* constraints until statement end. this method returns
* the corresponding list of constraints which aren't
* deferred.
*
* @param cdl	the constraint descriptor list to wrap with
*				an active constraint descriptor list.
*
* @return the corresponding active constraintdescriptorlist
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptorlist getactiveconstraintdescriptors constraintdescriptorlist cdl
throws standardexception
return cdl
/**
* reports whether an individual constraint must be
* enforced. for the core product, this routine always
* returns true.
*
* however, during refresh we may have deferred some
* constraints until statement end. this method returns
* false if the constraint deferred
*
* @param constraint	the constraint to check
*
*
* @return the corresponding active constraintdescriptorlist
*
* @exception standardexception		thrown on failure
*/
public boolean activeconstraint  constraintdescriptor constraint
throws standardexception
return true
/**
* get the constraint descriptor given a table and the uuid string
* of the backing index.
*
* @param td			the table descriptor.
* @param uuid			the uuid for the backing index.
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptor tabledescriptor td
uuid uuid
throws standardexception
{
return getconstraintdescriptors td  getconstraintdescriptor uuid
}
/**
* get the constraint descriptor given a table and the uuid string
* of the constraint
*
* @param td			the table descriptor.
* @param uuid			the uuid for the constraint
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptorbyid
tabledescriptor	td
uuid			uuid
throws standardexception
{
return getconstraintdescriptors td  getconstraintdescriptorbyid uuid
}
/**
* get the constraint descriptor given a tabledescriptor and the constraint name.
*
* @param td				the table descriptor.
* @param sd				the schema descriptor for the constraint
* @param constraintname	the constraint name.
* @param forupdate			whether or not access is for update
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptorbyname tabledescriptor td
schemadescriptor sd
string constraintname
boolean forupdate
throws standardexception
{
/* if forupdate, then we need to actually read from the table. */
if  forupdate
{
td emptyconstraintdescriptorlist
getconstraintdescriptorsscan td  true
}
return getconstraintdescriptors td  getconstraintdescriptorbyname sd  constraintname
}
/**
* populate the constraintdescriptorlist for the specified tabledescriptor.
*
* mt synchronization: it is assumed that the caller has synchronized
* on the cdl in the given td.
*
* @param td				the tabledescriptor.
* @param forupdate			whether or not to open scan for update
*
* @exception standardexception		thrown on failure
*/
private void getconstraintdescriptorsscan tabledescriptor td  boolean forupdate
throws standardexception
{
constraintdescriptorlist  cdl   td getconstraintdescriptorlist
datavaluedescriptor		  tableidorderable   null
tabinfoimpl					  ti   getnoncoreti sysconstraints_catalog_num
/* use tableidorderable in both start and stop positions for scan */
tableidorderable   getidvalueaschar td getuuid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  tableidorderable
getconstraintdescriptorviaindex
sysconstraintsrowfactory sysconstraints_index3_id
keyrow
ti
td
cdl
forupdate
cdl setscanned true
}
/**
* return a (single or list of) constraintdescriptor(s) from
* sysconstraints where the access is from the index to the heap.
*
* @param indexid	the id of the index (0 to # of indexes on table) to use
* @param keyrow	the supplied execindexrow for search
* @param ti		the tabinfoimpl to use
* @param td		the tabledescriptor, if supplied.
* @param dlist		the list to build, if supplied.  if null, then caller expects
*					a single descriptor
* @param forupdate			whether or not to open scan for update
*
* @return	the last matching descriptor
*
* @exception standardexception		thrown on error
*/
protected constraintdescriptor getconstraintdescriptorviaindex
int indexid
execindexrow keyrow
tabinfoimpl ti
tabledescriptor td
constraintdescriptorlist dlist
boolean forupdate
throws standardexception
{
sysconstraintsrowfactory rf    sysconstraintsrowfactory  ti getcatalogrowfactory
conglomeratecontroller	heapcc
constraintdescriptor	cd   null
execindexrow	  		indexrow1
execindexrow			indextemplaterow
execrow 				outrow
rowlocation				baserowlocation
scancontroller			scancontroller
transactioncontroller	tc
// get the current transaction controller
tc   gettransactioncompile
outrow   rf makeemptyrow
heapcc
tc openconglomerate
ti getheapconglomerate    false  0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
/* scan the index and go to the data pages for qualifying rows to
* build the column descriptor.
*/
scancontroller   tc openscan
ti getindexconglomerate indexid       conglomerate to open
false     don't hold open across commit
forupdate  ? transactioncontroller openmode_forupdate   0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
formatablebitset  null             all fields as objects
keyrow getrowarray         start position   exact key match
scancontroller ge          startsearchoperation
null                      scanqualifier
keyrow getrowarray         stop position   exact key match
scancontroller gt          stopsearchoperation
while  scancontroller next
{
subconstraintdescriptor subcd   null
// create an index row template
indexrow1   getindexrowfromheaprow
ti getindexrowgenerator indexid
heapcc newrowlocationtemplate
outrow
scancontroller fetch indexrow1 getrowarray
baserowlocation    rowlocation 	indexrow1 getcolumn
indexrow1 ncolumns
boolean base_row_exists
heapcc fetch
baserowlocation  outrow getrowarray     formatablebitset  null
if  sanitymanager debug
{
// it can not be possible for heap row to disappear while
// holding scan cursor on index at isolation_repeatable_read.
sanitymanager assert base_row_exists
}
switch  rf getconstrainttype outrow
{
case datadictionary primarykey_constraint
case datadictionary foreignkey_constraint
case datadictionary unique_constraint
subcd   getsubkeyconstraint
rf getconstraintid outrow   rf getconstrainttype outrow
break
case datadictionary check_constraint
subcd   getsubcheckconstraint
rf getconstraintid outrow
break
default
if  sanitymanager debug
{
sanitymanager throwassert
rf getconstrainttype outrow
}
}
if  sanitymanager debug
{
sanitymanager assert subcd    null
}
/* cache the td in the scd so that
* the row factory doesn't need to go
* out to disk to get it.
*/
subcd settabledescriptor td
cd    constraintdescriptor  rf builddescriptor
outrow
subcd
this
/* if dlist is null, then caller only wants a single descriptor - we're done
* else just add the current descriptor to the list.
*/
if  dlist    null
{
break
}
else
{
dlist add cd
}
}
scancontroller close
heapcc close
return cd
}
/**
* return a (single or list of) catalog row descriptor(s) from
* sysconstraints through a heap scan
*
* @param scanqualifiers			qualifiers
* @param ti						the tabinfoimpl to use
* @param parenttupledescriptor		the parentdescriptor, if applicable.
* @param list						the list to build, if supplied.
*									if null, then caller expects a single descriptor
*
* @return	the last matching descriptor
*
* @exception standardexception		thrown on error
*/
protected tupledescriptor getconstraintdescriptorviaheap
scanqualifier  scanqualifiers
tabinfoimpl ti
tupledescriptor parenttupledescriptor
list list
throws standardexception
{
sysconstraintsrowfactory rf    sysconstraintsrowfactory  ti getcatalogrowfactory
conglomeratecontroller	heapcc
execrow 				outrow
execrow 				templaterow
scancontroller			scancontroller
transactioncontroller	tc
constraintdescriptor	cd   null
// get the current transaction controller
tc   gettransactioncompile
outrow   rf makeemptyrow
/*
** table scan
*/
scancontroller   tc openscan
ti getheapconglomerate   	     conglomerate to open
false  						     don't hold open across commit
0  							     for read
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
formatablebitset  null                   all fields as objects
datavaluedescriptor  null     start position   first row
0       				         startsearchoperation   none
scanqualifiers  		         scanqualifier
datavaluedescriptor  null     stop position  through last row
0       				         stopsearchoperation   none
try
{
while  scancontroller fetchnext outrow getrowarray
{
subconstraintdescriptor subcd   null
switch  rf getconstrainttype outrow
{
case datadictionary primarykey_constraint
case datadictionary foreignkey_constraint
case datadictionary unique_constraint
subcd   getsubkeyconstraint
rf getconstraintid outrow   rf getconstrainttype outrow
break
case datadictionary check_constraint
subcd   getsubcheckconstraint
rf getconstraintid outrow
break
default
if  sanitymanager debug
{
sanitymanager throwassert
rf getconstrainttype outrow
}
}
if  sanitymanager debug
{
sanitymanager assert subcd    null
}
cd    constraintdescriptor  rf builddescriptor
outrow
subcd
this
/* if dlist is null, then caller only wants a single descriptor - we're done
* else just add the current descriptor to the list.
*/
if  list    null
{
break
}
else
{
list add cd
}
}
}
finally
{
scancontroller close
}
return cd
}
/**
* return a table descriptor corresponding to the tableid
* field in sysconstraints where constraintid matches
* the constraintid passsed in.
*
* @param constraintid	the id of the constraint
*
* @return	the corresponding table descriptor
*
* @exception standardexception		thrown on error
*/
public tabledescriptor getconstrainttabledescriptor uuid constraintid
throws standardexception
{
list slist   getconstraints constraintid
sysconstraintsrowfactory sysconstraints_index1_id
sysconstraintsrowfactory sysconstraints_tableid
if  slist size      0
{
return null
}
// get the table descriptor
return gettabledescriptor  uuid slist get 0
}
/**
* return a list of foreign keys constraints referencing
* this constraint.  returns both enabled and disabled
* foreign keys.
*
* @param constraintid	the id of the referenced constraint
*
* @return	list of constraints, empty of there are none
*
* @exception standardexception		thrown on error
*/
public constraintdescriptorlist getforeignkeys uuid constraintid
throws standardexception
{
tabinfoimpl ti   getnoncoreti sysforeignkeys_catalog_num
list fklist   newslist
// use constraintidorderable in both start and stop positions for scan
datavaluedescriptor constraintidorderable   getidvalueaschar constraintid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  constraintidorderable
getdescriptorviaindex
sysforeignkeysrowfactory sysforeignkeys_index2_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
fklist
false
subkeyconstraintdescriptor cd
tabledescriptor td
constraintdescriptorlist cdl   new constraintdescriptorlist
constraintdescriptorlist tmpcdl
for  iterator iterator   fklist iterator    iterator hasnext
{
cd    subkeyconstraintdescriptor  iterator next
td   getconstrainttabledescriptor cd getuuid
cdl add getconstraintdescriptors td  getconstraintdescriptorbyid cd getuuid
}
return cdl
}
/**
* return an list which of the relevant column matching
* the indexed criteria.  if nothing matches, returns an
* empty list (never returns null).
*
* @param uuid	the id of the constraint
* @param indexid		the index id in sys.sysconstraints
* @param columnnum		the column to retrieve
*
* @return a list of uuids in an list.
*
* @exception standardexception		thrown on error
*/
public list getconstraints uuid uuid  int indexid  int columnnum
throws standardexception
{
execindexrow	  		indexrow1
execindexrow			indextemplaterow
execrow 				outrow
rowlocation				baserowlocation
conglomeratecontroller	heapcc   null
scancontroller			scancontroller   null
transactioncontroller	tc
tabinfoimpl 				ti   getnoncoreti sysconstraints_catalog_num
sysconstraintsrowfactory rf    sysconstraintsrowfactory  ti getcatalogrowfactory
tabledescriptor			td   null
list					slist   newslist
if  sanitymanager debug
{
sanitymanager assert indexid    sysconstraintsrowfactory sysconstraints_index1_id
indexid    sysconstraintsrowfactory sysconstraints_index3_id
sanitymanager assert columnnum > 0
columnnum <  sysconstraintsrowfactory sysconstraints_column_count
}
try
{
/* use tableidorderable in both start and stop positions for scan */
datavaluedescriptor orderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  orderable
// get the current transaction controller
tc   gettransactioncompile
outrow   rf makeemptyrow
heapcc
tc openconglomerate
ti getheapconglomerate    false  0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
// create an index row template
indexrow1   getindexrowfromheaprow
ti getindexrowgenerator indexid
heapcc newrowlocationtemplate
outrow
// just interested in one column
datavaluedescriptor rowtemplate
new datavaluedescriptor
formatablebitset  columntogetset
new formatablebitset sysconstraintsrowfactory sysconstraints_column_count
columntogetset set columnnum   1
rowtemplate   new sqlchar
// scan the index and go to the data pages for qualifying rows
scancontroller   tc openscan
ti getindexconglomerate indexid     conglomerate to open
false  							   don't hold open across commit
0  								   for read
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read    resolve  should be level 2
formatablebitset  null                     all fields as objects
keyrow getrowarray   			   start position   exact key match
scancontroller ge  				   startsearchoperation
null  							   scanqualifier  none
keyrow getrowarray   			   stop position   exact key match
scancontroller gt  				   stopsearchoperation
while  scancontroller fetchnext indexrow1 getrowarray
{
baserowlocation    rowlocation
indexrow1 getcolumn indexrow1 ncolumns
// get the row and grab the uuid
boolean base_row_exists
heapcc fetch
baserowlocation  rowtemplate  columntogetset
if  sanitymanager debug
{
// it can not be possible for heap row to disappear while
// holding scan cursor on index at isolation_repeatable_read.
sanitymanager assert base_row_exists
}
slist add uuidfactory recreateuuid
string   datavaluedescriptor rowtemplate  getobject
}
}
finally
{
if  heapcc    null
{
heapcc close
}
if  scancontroller    null
{
scancontroller close
}
}
return slist
}
/**
* adds the given constraintdescriptor to the data dictionary,
* associated with the given table and constraint type.
*
* @param descriptor	the descriptor to add
* @param tc			the transaction controller
*
* @exception standardexception		thrown on error
*/
public void	addconstraintdescriptor
constraintdescriptor descriptor
transactioncontroller tc
throws standardexception
{
execrow        			row   null
int						type   descriptor getconstrainttype
tabinfoimpl					  ti   getnoncoreti sysconstraints_catalog_num
sysconstraintsrowfactory  rf    sysconstraintsrowfactory  ti getcatalogrowfactory
int						insertretcode
if  sanitymanager debug
{
if    type    datadictionary primarykey_constraint
type    datadictionary foreignkey_constraint
type    datadictionary unique_constraint
type    datadictionary check_constraint
{
sanitymanager throwassert     type
}
}
adddescriptor descriptor  descriptor getschemadescriptor
sysconstraints_catalog_num  false
tc
switch  type
{
case datadictionary primarykey_constraint
case datadictionary foreignkey_constraint
case datadictionary unique_constraint
if  sanitymanager debug
{
if    descriptor instanceof keyconstraintdescriptor
{
sanitymanager throwassert
descriptor getclass   getname
}
}
addsubkeyconstraint  keyconstraintdescriptor  descriptor  tc
break
case datadictionary check_constraint
if  sanitymanager debug
{
if    descriptor instanceof checkconstraintdescriptor
{
sanitymanager throwassert
descriptor getclass   getname
}
}
adddescriptor descriptor  null  syschecks_catalog_num  true  tc
break
}
}
/**
* update the constraint descriptor in question.  updates
* every row in the base conglomerate.
*
* @param cd					the constraintescriptor
* @param formeruuid			the uuid for this column in sysconstraints,
*								may differ from what is in cd if this
*								is the column that is being set.
* @param colstoset 			array of ints of columns to be modified,
*								1 based.  may be null (all cols).
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updateconstraintdescriptor constraintdescriptor cd
uuid		formeruuid
int		colstoset
transactioncontroller tc
throws standardexception
{
execindexrow				keyrow1   null
execrow    					row
datavaluedescriptor			idorderable
datavaluedescriptor			columnnameorderable
tabinfoimpl						ti   getnoncoreti sysconstraints_catalog_num
sysconstraintsrowfactory  	rf    sysconstraintsrowfactory  ti getcatalogrowfactory
/* use objectid/columnname in both start
* and stop position for index 1 scan.
*/
idorderable   getidvalueaschar formeruuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 1
keyrow1 setcolumn 1  idorderable
// build the row to be stuffed into sysconstraints.
row   rf makerow cd  null
/*
** figure out if the index in sysconstraints needs
** to be updated.
*/
if  sanitymanager debug
{
sanitymanager assert rf getnumindexes      3
}
boolean barray   new boolean
/*
** do we need to update indexes?
*/
if  colstoset    null
{
barray   true
barray   true
barray   true
}
else
{
/*
** check the specific columns for indexed
** columns.
*/
for  int i   0  i < colstoset length  i
{
switch  colstoset
{
case sysconstraintsrowfactory sysconstraints_constraintid
barray   true
break
case sysconstraintsrowfactory sysconstraints_constraintname
case sysconstraintsrowfactory sysconstraints_schemaid
barray   true
break
case sysconstraintsrowfactory sysconstraints_tableid
barray   true
break
}
}
}
ti updaterow keyrow1  row
sysconstraintsrowfactory sysconstraints_index1_id
barray
colstoset
tc
}
/**
* drops the given constraintdescriptor from the data dictionary.
*
* @param descriptor	the descriptor to drop
* @param tc			the transactioncontroller
*
* @exception standardexception		thrown on error
*/
public void	dropconstraintdescriptor
constraintdescriptor descriptor
transactioncontroller tc
throws standardexception
{
execindexrow			keyrow   null
datavaluedescriptor		schemaidorderable
datavaluedescriptor		constraintnameorderable
tabinfoimpl					ti   getnoncoreti sysconstraints_catalog_num
switch  descriptor getconstrainttype
{
case datadictionary primarykey_constraint
case datadictionary foreignkey_constraint
case datadictionary unique_constraint
dropsubkeyconstraint
descriptor
tc
break
case datadictionary check_constraint
dropsubcheckconstraint
descriptor getuuid
tc
break
}
/* use constraintnameorderable and schemaidorderable in both start
* and stop position for index 2 scan.
*/
constraintnameorderable   new sqlvarchar descriptor getconstraintname
schemaidorderable   getidvalueaschar descriptor getschemadescriptor   getuuid
/* set up the start/stop position for the scan */
keyrow    execindexrow  exfactory getindexablerow 2
keyrow setcolumn 1  constraintnameorderable
keyrow setcolumn 2  schemaidorderable
ti deleterow  tc  keyrow  sysconstraintsrowfactory sysconstraints_index2_id
}
/**
* drops all constraintdescriptors from the data dictionary
* that are associated with the given table,
*
* @param table	the table from which to drop all
*			constraint descriptors
* @param tc	the transactioncontroller
*
* @exception standardexception		thrown on error
*/
public void	dropallconstraintdescriptors tabledescriptor table
transactioncontroller tc
throws standardexception
{
constraintdescriptorlist cdl   getconstraintdescriptors table
// walk the table's cdl and drop each constraintdescriptor.
for  iterator iterator   cdl iterator    iterator hasnext
{
constraintdescriptor cd    constraintdescriptor  iterator next
dropconstraintdescriptor cd  tc
}
/*
** null out the table's constraint descriptor list.  note: this is
** not really necessary at the time of this writing (11/3/97), because
** we do not cache data dictionary objects while ddl is going on,
** but in the future it might be necessary.
*/
table setconstraintdescriptorlist null
}
/**
* get a subkeyconstraintdescriptor from syskeys or sysforeignkeys for
* the specified constraint id.  for primary foreign and and unique
* key constraints.
*
* @param constraintid	the uuid for the constraint.
* @param type	the type of the constraint
*		(e.g. datadictionary.foreignkey_constraint)
*
* @return subkeyconstraintdescriptor	the sub descriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public subkeyconstraintdescriptor getsubkeyconstraint uuid constraintid  int type
throws standardexception
{
datavaluedescriptor		constraintidorderable   null
tabinfoimpl					ti
int						indexnum
int						basenum
if  type    datadictionary foreignkey_constraint
{
basenum   sysforeignkeys_catalog_num
indexnum   sysforeignkeysrowfactory sysforeignkeys_index1_id
}
else
{
basenum   syskeys_catalog_num
indexnum   syskeysrowfactory syskeys_index1_id
}
ti   getnoncoreti basenum
/* use constraintidorderable in both start and stop positions for scan */
constraintidorderable   getidvalueaschar constraintid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  constraintidorderable
return  subkeyconstraintdescriptor
getdescriptorviaindex
indexnum
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* add the matching row to syskeys when adding a unique or primary key constraint
*
* @param descriptor	the keyconstraintdescriptor for the constraint.
* @param tc			the transactioncontroller
*
* @exception standardexception		thrown on failure
*/
private void addsubkeyconstraint keyconstraintdescriptor descriptor
transactioncontroller tc
throws standardexception
{
execrow	row
tabinfoimpl	ti
/*
** foreign keys get a row in sysforeignkeys, and
** all others get a row in syskeys.
*/
if  descriptor getconstrainttype
datadictionary foreignkey_constraint
{
foreignkeyconstraintdescriptor fkdescriptor
foreignkeyconstraintdescriptor descriptor
if  sanitymanager debug
{
if    descriptor instanceof foreignkeyconstraintdescriptor
{
sanitymanager throwassert
descriptor getclass   getname
}
}
ti   getnoncoreti sysforeignkeys_catalog_num
sysforeignkeysrowfactory fkkeysrf    sysforeignkeysrowfactory ti getcatalogrowfactory
row   fkkeysrf makerow fkdescriptor  null
/*
** now we need to bump the reference count of the
** contraint that this fk references
*/
referencedkeyconstraintdescriptor refdescriptor
fkdescriptor getreferencedconstraint
refdescriptor incrementreferencecount
int colstoset   new int
colstoset   sysconstraintsrowfactory sysconstraints_referencecount
updateconstraintdescriptor refdescriptor
refdescriptor getuuid
colstoset
tc
}
else
{
ti   getnoncoreti syskeys_catalog_num
syskeysrowfactory keysrf    syskeysrowfactory  ti getcatalogrowfactory
// build the row to be stuffed into syskeys
row   keysrf makerow descriptor  null
}
// insert row into catalog and all its indices
ti insertrow row  tc
}
/**
* drop the matching row from syskeys when dropping a primary key
* or unique constraint.
*
* @param constraint	the constraint
* @param tc			the transactioncontroller
*
* @exception standardexception		thrown on failure
*/
private void dropsubkeyconstraint constraintdescriptor constraint  transactioncontroller tc
throws standardexception
{
execindexrow			keyrow1   null
datavaluedescriptor		constraintidorderable
tabinfoimpl					ti
int						basenum
int						indexnum
if  constraint getconstrainttype
datadictionary foreignkey_constraint
{
basenum   sysforeignkeys_catalog_num
indexnum   sysforeignkeysrowfactory sysforeignkeys_index1_id
/*
** if we have a foreign key, we need to decrement the
** reference count of the contraint that this fk references.
** we need to do this *before* we drop the foreign key
** because of the way fk.getreferencedconstraint() works.
*/
if  constraint getconstrainttype
datadictionary foreignkey_constraint
{
referencedkeyconstraintdescriptor refdescriptor
referencedkeyconstraintdescriptor
getconstraintdescriptor
foreignkeyconstraintdescriptor constraint
getreferencedconstraintid
if  refdescriptor    null
{
refdescriptor decrementreferencecount
int colstoset   new int
colstoset   sysconstraintsrowfactory sysconstraints_referencecount
updateconstraintdescriptor refdescriptor
refdescriptor getuuid
colstoset
tc
}
}
}
else
{
basenum   syskeys_catalog_num
indexnum   syskeysrowfactory syskeys_index1_id
}
ti   getnoncoreti basenum
/* use constraintidorderable in both start
* and stop position for index 1 scan.
*/
constraintidorderable   getidvalueaschar constraint getuuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 1
keyrow1 setcolumn 1  constraintidorderable
ti deleterow  tc  keyrow1  indexnum
}
/**
* get a subcheckconstraintdescriptor from syschecks for
* the specified constraint id.  (useful for check constraints.)
*
* @param constraintid	the uuid for the constraint.
*
* @return subcheckconstraintdescriptor	the sub descriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
private subcheckconstraintdescriptor getsubcheckconstraint uuid constraintid
throws standardexception
{
datavaluedescriptor			constraintidorderable   null
tabinfoimpl						ti   getnoncoreti syschecks_catalog_num
syschecksrowfactory			rf    syschecksrowfactory  ti getcatalogrowfactory
/* use constraintidorderable in both start and stop positions for scan */
constraintidorderable   getidvalueaschar constraintid
/* set up the start/stop position for the scan */
execindexrow keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  constraintidorderable
return  subcheckconstraintdescriptor
getdescriptorviaindex
syschecksrowfactory syschecks_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* drop the matching row from syschecks when dropping a check constraint.
*
* @param constraintid	the constraint id.
* @param tc			the transactioncontroller
*
* @exception standardexception		thrown on failure
*/
private void dropsubcheckconstraint uuid constraintid  transactioncontroller tc
throws standardexception
{
execindexrow			checkrow1   null
datavaluedescriptor		constraintidorderable
tabinfoimpl					ti   getnoncoreti syschecks_catalog_num
/* use constraintidorderable in both start
* and stop position for index 1 scan.
*/
constraintidorderable   getidvalueaschar constraintid
/* set up the start/stop position for the scan */
checkrow1    execindexrow  exfactory getindexablerow 1
checkrow1 setcolumn 1  constraintidorderable
ti deleterow  tc  checkrow1  syschecksrowfactory syschecks_index1_id
}
/**
* get all of the conglomeratedescriptors in the database and
* hash them by conglomerate number.
* this is useful as a performance optimization for the locking vtis.
* note:  this method will scan sys.sysconglomerates at read uncommitted.
*
* @param tc		transactioncontroller for the transaction
*
* @return	a hashtable with all of the conglomeratedescriptors
*		in the database hashed by conglomerate number.
*
* @exception standardexception		thrown on failure
*/
public hashtable hashallconglomeratedescriptorsbynumber transactioncontroller tc
throws standardexception
{
hashtable ht   new hashtable
conglomeratedescriptor	  cd   null
scancontroller			  scancontroller
execrow 				  outrow
// execindexrow			  keyrow = null;
tabinfoimpl					  ti   coreinfo
sysconglomeratesrowfactory  rf    sysconglomeratesrowfactory  ti getcatalogrowfactory
outrow   rf makeemptyrow
scancontroller   tc openscan
ti getheapconglomerate        conglomerate to open
false     don't hold open across commit
0     for read
transactioncontroller mode_record      scans whole table
transactioncontroller isolation_read_uncommitted
formatablebitset  null     all fields as objects
datavaluedescriptor  null    keyrow getrowarray         start position   first row
scancontroller ge          startsearchoperation
scanqualifier   null
datavaluedescriptor  null    keyrow getrowarray         stop position   through last row
scancontroller gt          stopsearchoperation
// it is important for read uncommitted scans to use fetchnext() rather
// than fetch, so that the fetch happens while latch is held, otherwise
// the next() might position the scan on a row, but the subsequent
// fetch() may find the row deleted or purged from the table.
while  scancontroller fetchnext outrow getrowarray
{
cd    conglomeratedescriptor  rf builddescriptor
outrow
tupledescriptor  null
this
long hashkey   new long cd getconglomeratenumber
ht put hashkey  cd
}
scancontroller close
return ht
}
/**
* get all of the tabledescriptors in the database and hash them
* by tableid this is useful as a performance optimization for the
* locking vtis.  note: this method will scan sys.systables and
* sys.sysschemas at read uncommitted.
*
* @param tc		transactioncontroller for the transaction
*
* @return	a hashtable with all of the table descriptors in the database
*			hashed by tableid
*
*
* @exception standardexception		thrown on failure
*/
public hashtable hashalltabledescriptorsbytableid transactioncontroller tc
throws standardexception
{
hashtable ht   new hashtable
scancontroller			  scancontroller
execrow 				  outrow
tabinfoimpl					ti   coreinfo
systablesrowfactory
rf    systablesrowfactory  ti getcatalogrowfactory
outrow   rf makeemptyrow
scancontroller   tc openscan
ti getheapconglomerate             sys systable
false                              don't hold open across commit
0                                  for read
transactioncontroller mode_record    scans whole table
transactioncontroller isolation_read_uncommitted
formatablebitset  null                     all fields as objects
datavaluedescriptor null        start position   first row
scancontroller ge                  startsearchoperation
scanqualifier null           scanqualifier
datavaluedescriptor null       stop position through last row
scancontroller gt                  stopsearchoperation
// it is important for read uncommitted scans to use fetchnext() rather
// than fetch, so that the fetch happens while latch is held, otherwise
// the next() might position the scan on a row, but the subsequent
// fetch() may find the row deleted or purged from the table.
while scancontroller fetchnext outrow getrowarray
{
tabledescriptor td    tabledescriptor
rf builddescriptor
outrow
tupledescriptor null
this
transactioncontroller isolation_read_uncommitted
ht put td getuuid    td
}
scancontroller close
return ht
}
/**
* get a conglomeratedescriptor given its uuid.  if it is an index
* conglomerate shared by at least another duplicate index, this returns
* one of the conglomeratedescriptors for those indexes.
*
* @param uuid	the uuid
*
*
* @return a conglomeratedescriptor for the conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor getconglomeratedescriptor uuid uuid
throws standardexception
{
conglomeratedescriptor cds   getconglomeratedescriptors uuid
if  cds length    0
return null
return cds
}
/**
* get an array of conglomeratedescriptors given the uuid.  if it is a
* heap conglomerate or an index conglomerate not shared by a duplicate
* index, the size of the return array is 1.
*
* @param uuid	the uuid
*
*
* @return an array of conglomeratedescriptors for the conglomerate.
*				returns size 0 array if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor getconglomeratedescriptors uuid uuid
throws standardexception
{
datavaluedescriptor		uuidstringorderable
sysconglomeratesrowfactory rf
tabinfoimpl					ti   coreinfo
/* use uuidstringorderable in both start and stop positions for scan */
uuidstringorderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  uuidstringorderable
list cdl   newslist
getdescriptorviaindex
sysconglomeratesrowfactory sysconglomerates_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
cdl
false
conglomeratedescriptor cda   new conglomeratedescriptor
cdl toarray cda
return cda
}
/**
* get a conglomeratedescriptor given its conglomerate number.  if it is an
* index conglomerate shared by at least another duplicate index, this
* returns one of the conglomeratedescriptors for those indexes.
*
* @param conglomeratenumber	the conglomerate number.
*
*
* @return a conglomeratedescriptor for the conglomerate.  returns null if
*				no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor getconglomeratedescriptor
long conglomeratenumber
throws standardexception
{
conglomeratedescriptor cds   getconglomeratedescriptors conglomeratenumber
if  cds length    0
return null
return cds
}
/**
* get an array of conglomerate descriptors for the given conglomerate
* number.  if it is a heap conglomerate or an index conglomerate not
* shared by a duplicate index, the size of the return array is 1.
*
* @param conglomeratenumber	the number for the conglomerate
*				we're interested in
*
* @return	an array of conglomeratedescriptors that share the requested
*		conglomerate. returns size 0 array if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor getconglomeratedescriptors
long conglomeratenumber
throws standardexception
{
scancontroller			  scancontroller
transactioncontroller	  tc
execrow 				  outrow
datavaluedescriptor		  conglomnumberorderable   null
tabinfoimpl					  ti   coreinfo
sysconglomeratesrowfactory  rf    sysconglomeratesrowfactory  ti getcatalogrowfactory
conglomnumberorderable
dvf getdatavalue conglomeratenumber
scanqualifier scanqualifier   exfactory getscanqualifier 1
scanqualifier setqualifier
rf sysconglomerates_conglomeratenumber   1 	   column number
conglomnumberorderable
orderable order_op_equals
false
false
false
conglomeratedescriptorlist cdl   new conglomeratedescriptorlist
getdescriptorviaheap scanqualifier
ti

cdl
int size   cdl size
conglomeratedescriptor cda   new conglomeratedescriptor
for  int index   0  index < size  index
cda    conglomeratedescriptor  cdl get index
return cda
}
/**
* populate the conglomeratedescriptorlist for the
* specified tabledescriptor by scanning sysconglomerates.
*
* mt synchronization: it is assumed that the caller has synchronized
* on the cdl in the given td.
*
* @param td			the tabledescriptor.
*
* @exception standardexception		thrown on failure
*/
private void getconglomeratedescriptorsscan tabledescriptor td
throws standardexception
{
conglomeratedescriptorlist cdl   td getconglomeratedescriptorlist
execindexrow			keyrow3   null
datavaluedescriptor		tableidorderable
tabinfoimpl					ti   coreinfo
/* use tableidorderable in both start and stop positions for scan */
tableidorderable   getidvalueaschar td getuuid
/* set up the start/stop position for the scan */
keyrow3    execindexrow  exfactory getindexablerow 1
keyrow3 setcolumn 1  tableidorderable
getdescriptorviaindex
sysconglomeratesrowfactory sysconglomerates_index3_id
keyrow3
scanqualifier   null
ti
tupledescriptor  null
cdl
false
}
/**
* gets a conglomerate descriptor for the named index in the given schema,
* getting an exclusive row lock on the matching row in
* sys.sysconglomerates (for ddl concurrency) if requested.
*
* @param indexname	the name of the index we're looking for
* @param sd		the schema descriptor
* @param forupdate	whether or not to get an exclusive row
*					lock on the row in sys.sysconglomerates.
*
* @return	a conglomeratedescriptor describing the requested
*		conglomerate. returns null if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptor
string indexname
schemadescriptor sd
boolean forupdate
throws standardexception
{
execindexrow			  keyrow2   null
datavaluedescriptor		  nameorderable
datavaluedescriptor		  schemaidorderable   null
tabinfoimpl					  ti   coreinfo
nameorderable   new sqlvarchar indexname
schemaidorderable   getidvalueaschar sd getuuid
/* set up the start/stop position for the scan */
keyrow2   exfactory getindexablerow 2
keyrow2 setcolumn 1  nameorderable
keyrow2 setcolumn 2  schemaidorderable
return  conglomeratedescriptor
getdescriptorviaindex
sysconglomeratesrowfactory sysconglomerates_index2_id
keyrow2
scanqualifier   null
ti
tupledescriptor  null
list  null
forupdate
}
/**
* drops a conglomerate descriptor
*
* @param conglomerate	the conglomeratedescriptor for the conglomerate
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void dropconglomeratedescriptor
conglomeratedescriptor conglomerate
transactioncontroller tc
throws standardexception
{
execindexrow			keyrow2   null
datavaluedescriptor		nameorderable
datavaluedescriptor		schemaidorderable   null
tabinfoimpl					ti   coreinfo
nameorderable   new sqlvarchar conglomerate getconglomeratename
schemaidorderable   getidvalueaschar conglomerate getschemaid
/* set up the start/stop position for the scan */
keyrow2    execindexrow  exfactory getindexablerow 2
keyrow2 setcolumn 1  nameorderable
keyrow2 setcolumn 2  schemaidorderable
ti deleterow  tc  keyrow2  sysconglomeratesrowfactory sysconglomerates_index2_id
}
/**
* drops all conglomerates associated with a table.
*
* @param td		the tabledescriptor of the table
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void dropallconglomeratedescriptors
tabledescriptor td
transactioncontroller tc
throws standardexception
{
execindexrow			keyrow3   null
datavaluedescriptor		tableidorderable
tabinfoimpl					ti   coreinfo
/* use tableidorderable in both start
* and stop position for index 3 scan.
*/
tableidorderable   getidvalueaschar td getuuid
/* set up the start/stop position for the scan */
keyrow3    execindexrow  exfactory getindexablerow 1
keyrow3 setcolumn 1  tableidorderable
ti deleterow  tc  keyrow3  sysconglomeratesrowfactory sysconglomerates_index3_id
}
/**
* update the conglomeratenumber for a conglomeratedescriptor.
* this is useful, in 1.3, when doing a bulkinsert into an
* empty table where we insert into a new conglomerate.
* (this will go away in 1.4.)
*
* @param cd					the conglomeratedescriptor
* @param conglomeratenumber	the new conglomerate number
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updateconglomeratedescriptor conglomeratedescriptor cd
long conglomeratenumber
transactioncontroller tc
throws standardexception
{
conglomeratedescriptor cds   new conglomeratedescriptor
cds   cd
updateconglomeratedescriptor cds  conglomeratenumber  tc
}
/**
* update all system schemas to have new authorizationid. this is needed
* while upgrading pre-10.2 databases to 10.2 or later versions. from 10.2,
* all system schemas would be owned by database owner's authorizationid.
*
* @param aid							authorizationid of database owner
* @param tc							transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updatesystemschemaauthorization string aid
transactioncontroller tc
throws standardexception
{
updateschemaauth schemadescriptor std_system_schema_name  aid  tc
updateschemaauth schemadescriptor ibm_system_schema_name  aid  tc
updateschemaauth schemadescriptor ibm_system_cat_schema_name  aid  tc
updateschemaauth schemadescriptor ibm_system_fun_schema_name  aid  tc
updateschemaauth schemadescriptor ibm_system_proc_schema_name  aid  tc
updateschemaauth schemadescriptor ibm_system_stat_schema_name  aid  tc
updateschemaauth schemadescriptor ibm_system_nullid_schema_name  aid  tc
updateschemaauth schemadescriptor std_sqlj_schema_name  aid  tc
updateschemaauth schemadescriptor std_system_diag_schema_name  aid  tc
updateschemaauth schemadescriptor std_system_util_schema_name  aid  tc
// now reset our understanding of who owns the database
resetdatabaseowner  tc
}
/**
* update authorizationid of specified schemaname
*
* @param schemaname			schema name of system schema
* @param authorizationid		authorizationid of new schema owner
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updateschemaauth string schemaname
string authorizationid
transactioncontroller tc
throws standardexception
{
execindexrow				keyrow
datavaluedescriptor			schemanameorderable
tabinfoimpl						ti   coreinfo
/* use schemanameorderable in both start
* and stop position for index 1 scan.
*/
schemanameorderable   new sqlvarchar schemaname
/* set up the start/stop position for the scan */
keyrow    execindexrow  exfactory getindexablerow 1
keyrow setcolumn 1  schemanameorderable
sysschemasrowfactory	rf    sysschemasrowfactory  ti getcatalogrowfactory
execrow row   rf makeemptyrow
row setcolumn sysschemasrowfactory sysschemas_schemaaid
new sqlvarchar authorizationid
boolean barray    false  false
int colstoupdate    sysschemasrowfactory sysschemas_schemaaid
ti updaterow keyrow  row
sysschemasrowfactory sysschemas_index1_id
barray
colstoupdate
tc
}
/**
* update the conglomeratenumber for an array of conglomeratedescriptors.
* in case of more than one conglomeratedescriptor, each descriptor
* should be updated separately, conglomerate id is not same for all
* the descriptors. even when indexes are sharing the same
* conglomerate(conglomerate number), conglomerate ids are unique.
*
* this is useful, in 1.3, when doing a bulkinsert into an
* empty table where we insert into a new conglomerate.
* (this will go away in 1.4.)
*
* @param cds					the array of conglomeratedescriptors
* @param conglomeratenumber	the new conglomerate number
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updateconglomeratedescriptor conglomeratedescriptor cds
long conglomeratenumber
transactioncontroller tc
throws standardexception
{
execindexrow				keyrow1   null
execrow     				row
datavaluedescriptor			conglomidorderable
tabinfoimpl						ti   coreinfo
sysconglomeratesrowfactory  rf    sysconglomeratesrowfactory  ti getcatalogrowfactory
boolean barray    false  false  false
for  int i   0  i < cds length  i
{
/* use conglomidorderable in both start
* and stop position for index 1 scan.
*/
conglomidorderable   getidvalueaschar cds getuuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 1
keyrow1 setcolumn 1  conglomidorderable
cds setconglomeratenumber conglomeratenumber
// build the row to be stuffed into sysconglomerates.
row   rf makerow cds  null
// update row in catalog (no indexes)
ti updaterow keyrow1  row
sysconglomeratesrowfactory sysconglomerates_index1_id
barray
int null
tc
}
}
/**
* gets a list of the dependency descriptors for the given dependent's id.
*
* @param dependentid		the id of the dependent we're interested in
*
* @return	list			returns a list of dependencydescriptors.
*							returns an empty list if no stored dependencies for the
*							dependent's id.
*
* @exception standardexception		thrown on failure
*/
public list getdependentsdescriptorlist string dependentid
throws standardexception
{
list					ddllist   newslist
datavaluedescriptor		dependentidorderable
tabinfoimpl					ti   getnoncoreti sysdepends_catalog_num
/* use dependentidorderable in both start and stop positions for scan */
dependentidorderable   new sqlchar dependentid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  dependentidorderable
getdescriptorviaindex
sysdependsrowfactory sysdepends_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
ddllist
false
return ddllist
}
/**
* gets a list of the dependency descriptors for the given provider's id.
*
* @param providerid		the id of the provider we're interested in
*
* @return	list			returns a list of dependencydescriptors.
*							returns an empty list if no stored dependencies for the
*							provider's id.
*
* @exception standardexception		thrown on failure
*/
public list getprovidersdescriptorlist string providerid
throws standardexception
{
list					ddllist   newslist
datavaluedescriptor		provideridorderable
tabinfoimpl					ti   getnoncoreti sysdepends_catalog_num
/* use provideridorderable in both start and stop positions for scan */
provideridorderable   new sqlchar providerid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  provideridorderable
getdescriptorviaindex
sysdependsrowfactory sysdepends_index2_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
ddllist
false
return ddllist
}
/**
* build and return an list with dependencydescriptors for
* all of the stored dependencies.
* this is useful for consistency checking.
*
* @return list		list of all dependencydescriptors.
*
* @exception standardexception		thrown on failure
*/
public list getalldependencydescriptorslist
throws standardexception
{
scancontroller			 	scancontroller
transactioncontroller	  	tc
execrow					  	outrow
execrow					 	templaterow
list						ddl   newslist
tabinfoimpl						ti   getnoncoreti sysdepends_catalog_num
sysdependsrowfactory		rf    sysdependsrowfactory  ti getcatalogrowfactory
// get the current transaction controller
tc   gettransactioncompile
outrow   rf makeemptyrow
scancontroller   tc openscan
ti getheapconglomerate        conglomerate to open
false     don't hold open across commit
0     for read
transactioncontroller mode_table       scans entire table
transactioncontroller isolation_repeatable_read
formatablebitset  null                         all fields as objects
null       start position   first row
scancontroller ge          startsearchoperation

null       stop position   through last row
scancontroller gt          stopsearchoperation
while  scancontroller fetchnext outrow getrowarray
{
dependencydescriptor		dependencydescriptor
dependencydescriptor    dependencydescriptor
rf builddescriptor outrow
tupledescriptor  null
this
ddl add dependencydescriptor
}
scancontroller close
return ddl
}
/**
* drop a single dependency from the data dictionary.
*
* @param dd	the dependencydescriptor.
* @param tc	transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void dropstoreddependency dependencydescriptor dd
transactioncontroller tc
throws standardexception
{
execindexrow			keyrow1   null
uuid					dependentid   dd getuuid
uuid					providerid   dd getproviderid
datavaluedescriptor		dependentidorderable   getidvalueaschar dependentid
tabinfoimpl					ti   getnoncoreti sysdepends_catalog_num
/* use dependentidorderable in both start
* and stop position for index 1 scan.
*/
keyrow1    execindexrow  exfactory getindexablerow 1
keyrow1 setcolumn 1  dependentidorderable
// only drop the rows which have this providerid
tuplefilter				filter   new dropdependencyfilter  providerid
ti deleterows  tc
keyrow1 				   start row
scancontroller ge
null                   qualifier
filter 				   filter on base row
keyrow1 				   stop row
scancontroller gt
sysdependsrowfactory sysdepends_index1_id
}
/**
* remove all of the stored dependencies for a given dependent's id
* from the data dictionary.
*
* @param dependentsuuid	dependent's uuid
* @param tc				transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void dropdependentsstoreddependencies uuid dependentsuuid
transactioncontroller tc
throws standardexception
{
dropdependentsstoreddependencies dependentsuuid  tc  true
}
/**
* @inheritdoc
*/
public void dropdependentsstoreddependencies uuid dependentsuuid
transactioncontroller tc
boolean wait
throws standardexception
{
execindexrow			keyrow1   null
datavaluedescriptor		dependentidorderable
tabinfoimpl					ti   getnoncoreti sysdepends_catalog_num
/* use dependentidorderable in both start
* and stop position for index 1 scan.
*/
dependentidorderable   getidvalueaschar dependentsuuid
/* set up the start/stop position for the scan */
keyrow1    execindexrow  exfactory getindexablerow 1
keyrow1 setcolumn 1  dependentidorderable
ti deleterow  tc  keyrow1  sysdependsrowfactory sysdepends_index1_id
wait
}
/**
* get the uuid factory.  (no need to make the uuidfactory a module.)
*
* @return uuidfactory	the uuid factory for this datadictionary.
*/
public uuidfactory getuuidfactory
{
return uuidfactory
}
/**
* get a aliasdescriptor given its uuid.
*
* @param uuid	the uuid
*
*
* @return the aliasdescriptor for the alias.
*
* @exception standardexception		thrown on failure
*/
public aliasdescriptor getaliasdescriptor uuid uuid
throws standardexception
{
datavaluedescriptor		uuidstringorderable
sysaliasesrowfactory	rf
tabinfoimpl					ti   getnoncoreti sysaliases_catalog_num
rf    sysaliasesrowfactory  ti getcatalogrowfactory
/* use uuidstringorderable in both start and stop positions for scan */
uuidstringorderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  uuidstringorderable
return  aliasdescriptor
getdescriptorviaindex
sysaliasesrowfactory sysaliases_index2_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* get a aliasdescriptor by alias name and name space.
* note: caller responsible for handling no match.
*
@param schemaid		schema identifier
* @param aliasname		the alias name.
* @param namespace		the alias type.
*
* @return aliasdescriptor	aliasdescriptor for the alias name and name space
*
* @exception standardexception		thrown on failure
*/
public aliasdescriptor getaliasdescriptor string schemaid  string aliasname  char namespace
throws standardexception
{
datavaluedescriptor		  aliasnameorderable
datavaluedescriptor		  namespaceorderable
tabinfoimpl					  ti   getnoncoreti sysaliases_catalog_num
sysaliasesrowfactory	  rf    sysaliasesrowfactory  ti getcatalogrowfactory
/* use aliasnameorderable and aliastypeorderable in both start
* and stop position for scan.
*/
aliasnameorderable   new sqlvarchar aliasname
char chararray   new char
chararray   namespace
namespaceorderable   new sqlchar new string chararray
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 3
keyrow setcolumn 1  new sqlchar schemaid
keyrow setcolumn 2  aliasnameorderable
keyrow setcolumn 3  namespaceorderable
return  aliasdescriptor
getdescriptorviaindex
sysaliasesrowfactory sysaliases_index1_id
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
get the list of routines matching the schema and routine name.
while we only support a single alias for a given name,namespace just
return a list of zero or one item.
if the schema is sysfun then do not use the system catalogs,
but instead look up the routines from the in-meomry table driven
by the contents of sysfun_functions.
*/
public java util list getroutinelist string schemaid  string routinename  char namespace
throws standardexception
java util list list   new  java util arraylist
// special in-memory table lookup for sysfun
if  schemaid equals schemadescriptor sysfun_schema_uuid
namespace    aliasinfo alias_name_space_function_as_char
{
for  int f   0  f < datadictionaryimpl sysfun_functions length  f
{
string details   datadictionaryimpl sysfun_functions
string name   details
if   name equals routinename
continue
aliasdescriptor ad   datadictionaryimpl sysfun_ad
if  ad    null
{
// details[1] return type
typedescriptor rt
datatypedescriptor getbuiltindatatypedescriptor details  getcatalogtype
boolean isdeterministic   boolean valueof  details   booleanvalue
// determine the number of arguments (could be zero).
int paramcount   details length   sysfun_first_parameter_index
typedescriptor pt   new typedescriptor
string paramnames   new string
int parammodes   new int
for  int i   0  i < paramcount  i
pt   datatypedescriptor getbuiltindatatypedescriptor
details  getcatalogtype
paramnames        i  1      dummy names
// all parameters must be in.
parammodes   jdbc30translation parameter_mode_in
}
// details[3] = java method
routinealiasinfo ai   new routinealiasinfo details
paramcount  paramnames
pt  parammodes  0
routinealiasinfo ps_java  routinealiasinfo no_sql  isdeterministic
false  rt
// details[2] = class name
ad   new aliasdescriptor this  uuidfactory createuuid    name
uuidfactory recreateuuid schemaid
details  aliasinfo alias_type_function_as_char
aliasinfo alias_name_space_function_as_char
true  ai  null
datadictionaryimpl sysfun_ad   ad
}
list add ad
}
return list
}
aliasdescriptor ad   getaliasdescriptor schemaid  routinename  namespace
if  ad    null
list add ad
}
return list
}
/**
* drop a aliasdescriptor from the datadictionary
*
* @param ad	the aliasdescriptor to drop
* @param tc	the transactioncontroller
*
* @exception standardexception		thrown on failure
*/
public void dropaliasdescriptor aliasdescriptor ad
transactioncontroller tc
throws standardexception
{
tabinfoimpl					ti   getnoncoreti sysaliases_catalog_num
/* use aliasnameorderable and namespaceorderable in both start
* and stop position for index 1 scan.
*/
char chararray   new char
chararray   ad getnamespace
/* set up the start/stop position for the scan */
execindexrow keyrow1    execindexrow  exfactory getindexablerow 3
keyrow1 setcolumn 1  getidvalueaschar ad getschemauuid
keyrow1 setcolumn 2  new sqlvarchar ad getdescriptorname
keyrow1 setcolumn 3  new sqlchar new string chararray
ti deleterow  tc  keyrow1  sysaliasesrowfactory sysaliases_index1_id
}
//
// class implementation
//
/**
*	initialize system catalogs. this is where we perform upgrade. it is our
*	pious hope that we won't ever have to upgrade the core catalogs, other than
*	to add fields inside formatable columns in these catalogs.
*
*	if we do have to upgrade the core catalogs, then we may need to move the
*	loadcatalog calls into the upgrade machinery. it's do-able, just not pretty.
*
*
*	@param	tc		transactioncontroller
*	@param	ddg		datadescriptorgenerator
*
* 	@exception standardexception		thrown on error
*/
protected void loaddictionarytables transactioncontroller tc
datadescriptorgenerator ddg
properties startparams
throws standardexception
{
// load the core catalogs first
loadcatalogs ddg  coreinfo
dictionaryversion    dd_version tc getproperty
datadictionary core_data_dictionary_version
resetdatabaseowner  tc
softwareversion upgradeifneeded dictionaryversion  tc  startparams
}
/**
*	reset the database owner according to what is stored in the catalogs.
* this can change at upgrade time so we have factored this logic into
* a separately callable method.
*
*
*	@param	tc		transactioncontroller
*
*  @exception standardexception		thrown on error
*/
public void resetdatabaseowner  transactioncontroller tc
throws standardexception
{
schemadescriptor sd   locateschemarow
schemadescriptor ibm_system_schema_name  tc
authorizationdatabaseowner   sd getauthorizationid
}
/**
* initialize indices for an array of catalogs
*
*	@param	ddg		datadescriptorgenerator
*
*
* @exception standardexception		thrown on error
*/
public void loadcatalogs datadescriptorgenerator ddg  tabinfoimpl catalogarray
throws standardexception
{
int			ictr
int			numindexes
int			indexctr
tabinfoimpl		catalog
int			catalogcount   catalogarray length
/* initialize the various variables associated with index scans of these catalogs */
for  ictr   0  ictr < catalogcount  ictr
{
// note: this only works for core catalogs, which are initialized
// up front.
catalog   catalogarray
numindexes   catalog getnumberofindexes
if  numindexes > 0
{
for  indexctr   0  indexctr < numindexes  indexctr
{
initsystemindexvariables ddg  catalog  indexctr
}
}
}
}
/*
** methods related to create
*/
/**
create all the required dictionary tables. any classes that extend this class
and need to create new tables should override this method, and then
call this method as the first action in the new method, e.g.
<pre>
protected configuration createdictionarytables(configuration cfg, transactioncontroller tc,
datadescriptorgenerator ddg)
throws standardexception
{
super.createdictionarytables(params, tc, ddg);
...
}
</pre>
@exception standardexception standard derby error policy
*/
protected void createdictionarytables properties params  transactioncontroller tc
datadescriptorgenerator ddg)
throws standardexception
{
/*
** create a new schema descriptor -- with no args
** creates the system schema descriptor in which
** all tables reside (sys)
*/
systemschemadesc
newsystemschemadesc
schemadescriptor std_system_schema_name
schemadescriptor system_schema_uuid
/* create the core tables and generate the uuids for their
* heaps (before creating the indexes).
* resolve - this loop will eventually drive all of the
* work for creating the core tables.
*/
for  int corectr   0  corectr < num_core  corectr
{
tabinfoimpl	ti   coreinfo
properties	heapproperties   ti getcreateheapproperties
ti setheapconglomerate
createconglomerate
ti gettablename
tc
ti getcatalogrowfactory   makeemptyrow
heapproperties
// bootstrap indexes on core tables before bootstraping the tables themselves
if  coreinfo getnumberofindexes   > 0
{
bootstrapsystemindexes systemschemadesc  tc  ddg  ti
}
}
// bootstrap the core tables into the data dictionary
for   int ictr   0  ictr < num_core  ictr
{
/* resolve - need to do something with columntype in following table creating code */
tabinfoimpl			ti   coreinfo
addsystemtabletodictionary ti  systemschemadesc  tc  ddg
}
// add the bootstrap information to the configuration
params put cfg_systables_id
long tostring
coreinfo getheapconglomerate
params put cfg_systables_index1_id
long tostring
coreinfo getindexconglomerate
systablesrowfactory  coreinfo
getcatalogrowfactory    systables_index1_id
params put cfg_systables_index2_id
long tostring
coreinfo getindexconglomerate
systablesrowfactory  coreinfo
getcatalogrowfactory    systables_index2_id
params put cfg_syscolumns_id
long tostring
coreinfo getheapconglomerate
params put cfg_syscolumns_index1_id
long tostring
coreinfo getindexconglomerate
syscolumnsrowfactory  coreinfo
getcatalogrowfactory    syscolumns_index1_id
params put cfg_syscolumns_index2_id
long tostring
coreinfo getindexconglomerate
syscolumnsrowfactory  coreinfo
getcatalogrowfactory    syscolumns_index2_id
params put cfg_sysconglomerates_id
long tostring
coreinfo getheapconglomerate
params put cfg_sysconglomerates_index1_id
long tostring
coreinfo getindexconglomerate
sysconglomeratesrowfactory  coreinfo
getcatalogrowfactory    sysconglomerates_index1_id
params put cfg_sysconglomerates_index2_id
long tostring
coreinfo getindexconglomerate
sysconglomeratesrowfactory  coreinfo
getcatalogrowfactory    sysconglomerates_index2_id
params put cfg_sysconglomerates_index3_id
long tostring
coreinfo getindexconglomerate
sysconglomeratesrowfactory  coreinfo
getcatalogrowfactory    sysconglomerates_index3_id
params put cfg_sysschemas_id
long tostring
coreinfo getheapconglomerate
params put cfg_sysschemas_index1_id
long tostring
coreinfo getindexconglomerate
sysschemasrowfactory  coreinfo
getcatalogrowfactory    sysschemas_index1_id
params put cfg_sysschemas_index2_id
long tostring
coreinfo getindexconglomerate
sysschemasrowfactory  coreinfo
getcatalogrowfactory    sysschemas_index2_id
//add the sysibm schema
sysibmschemadesc
addsystemschema
schemadescriptor ibm_system_schema_name
schemadescriptor sysibm_schema_uuid  tc
/* create the non-core tables and generate the uuids for their
* heaps (before creating the indexes).
* resolve - this loop will eventually drive all of the
* work for creating the non-core tables.
*/
for  int noncorectr   0  noncorectr < num_noncore  noncorectr
{
int catalognumber   noncorectr   num_core
boolean isdummy    catalognumber    sysdummy1_catalog_num
tabinfoimpl ti   getnoncoretibynumber catalognumber
makecatalog ti  isdummy ? sysibmschemadesc   systemschemadesc  tc
if  isdummy
populatesysdummy1 tc
// clear the table entry for this non-core table,
// to allow it to be garbage-collected. the idea
// is that a running database might never need to
// reference a non-core table after it was created.
clearnoncoretable noncorectr
}
//add ths system schema
adddescriptor
systemschemadesc  null  sysschemas_catalog_num  false  tc
// add the following system schema's to be compatible with db2,
// currently derby does not use them, but by creating them as
// system schema's it will insure applications can't create them,
// drop them, or create objects in them.  this set includes:
//     syscat
//     sysfun
//     sysproc
//     sysstat
//     nullid
//add the syscat schema
addsystemschema
schemadescriptor ibm_system_cat_schema_name
schemadescriptor syscat_schema_uuid  tc
//add the sysfun schema
addsystemschema
schemadescriptor ibm_system_fun_schema_name
schemadescriptor sysfun_schema_uuid  tc
//add the sysproc schema
addsystemschema
schemadescriptor ibm_system_proc_schema_name
schemadescriptor sysproc_schema_uuid  tc
//add the sysstat schema
addsystemschema
schemadescriptor ibm_system_stat_schema_name
schemadescriptor sysstat_schema_uuid  tc
//add the nullid schema
addsystemschema
schemadescriptor ibm_system_nullid_schema_name
schemadescriptor nullid_schema_uuid  tc
//add the sqlj schema
addsystemschema
schemadescriptor std_sqlj_schema_name
schemadescriptor sqlj_schema_uuid  tc
//add the syscs_diag schema
addsystemschema
schemadescriptor std_system_diag_schema_name
schemadescriptor syscs_diag_schema_uuid  tc
//add the syscs_util schema
addsystemschema
schemadescriptor std_system_util_schema_name
schemadescriptor syscs_util_schema_uuid  tc
//add the app schema
schemadescriptor appschemadesc   new schemadescriptor this
schemadescriptor std_default_schema_name
schemadescriptor default_user_name
uuidfactory recreateuuid  schemadescriptor default_schema_uuid
false
adddescriptor appschemadesc  null  sysschemas_catalog_num  false  tc
}
/**
* add a system schema to the database.
* <p>
*
* @param schema_name   name of the schema to add.
*
* @exception  standardexception  standard exception policy.
**/
private schemadescriptor addsystemschema
string                  schema_name
string                  schema_uuid
transactioncontroller   tc
throws standardexception
{
// create the descriptor
schemadescriptor schema_desc
new schemadescriptor
this
schema_name
authorizationdatabaseowner
uuidfactory recreateuuid schema_uuid
true
// add it to the catalog.
adddescriptor schema_desc  null  sysschemas_catalog_num  false  tc
return schema_desc
}
/** called by the upgrade code (dd_xena etc) to add a new system catalog.
*
* @param 	tc 				transactioncontroller to use.
* @param 	catalognumber	catalognumber
*/
protected void upgrademakecatalog transactioncontroller tc  int catalognumber
throws standardexception
{
tabinfoimpl ti
if  catalognumber >  num_core
ti   getnoncoretibynumber catalognumber
else
ti   coreinfo
makecatalog ti   catalognumber    sysdummy1_catalog_num  ? getsysibmschemadescriptor
getsystemschemadescriptor    tc
}
/**
*	the dirty work of creating a catalog.
*
*	@param	ti			tabinfoimpl describing catalog to create.
*	@param	sd			schema to create catalogs in.
*	@param	tc			transaction context.
*
*	@exception standardexception standard derby error policy
*/
public	void	makecatalog  tabinfoimpl					ti
schemadescriptor			sd
transactioncontroller 		tc
throws standardexception
{
datadescriptorgenerator ddg   getdatadescriptorgenerator
properties	heapproperties   ti getcreateheapproperties
ti setheapconglomerate
createconglomerate
ti gettablename
tc
ti getcatalogrowfactory   makeemptyrow
heapproperties
// bootstrap indexes on core tables before bootstrapping the tables themselves
if  ti getnumberofindexes   > 0
{
bootstrapsystemindexes sd  tc  ddg  ti
}
addsystemtabletodictionary ti  sd  tc  ddg
}
/**
*	upgrade an existing system catalog column's definition
* by setting it to the value it would have in a newly
* created database. this is only used to for a couple
* of columns that had incorrectly nullability. other
* uses (e.g. changing column type) might require more work.
*
*	@param	columnnumber			the column to change
*	@param	tc						transaction controller
*
*	@exception standardexception standard derby error policy
*/
public void upgradefixsystemcolumndefinition catalogrowfactory rowfactory
int columnnumber
transactioncontroller tc
throws standardexception
{
systemcolumn		thecolumn
systemcolumn		columns   rowfactory buildcolumnlist
schemadescriptor	sd   getsystemschemadescriptor
tabledescriptor td   gettabledescriptor rowfactory getcatalogname    sd  tc
thecolumn   columns 	   from 1 to 0 based
columndescriptor cd   makecolumndescriptor thecolumn  columnnumber  td
string columnname   cd getcolumnname
int columnnamecolarray   new int
columnnamecolarray   syscolumnsrowfactory syscolumns_columndatatype
updatecolumndescriptor cd
td getuuid
columnname
columnnamecolarray
tc
}
/**
*	upgrade an existing catalog by adding columns.
*
*	@param	rowfactory				associated with this catalog.
*	@param	newcolumnids			array of 1-based column ids.
*	@param	tc						transaction controller
*
*	@exception standardexception standard derby error policy
*/
public	void	upgrade_addcolumns  catalogrowfactory		rowfactory
int					newcolumnids
transactioncontroller	tc
throws standardexception
{
int					columnid
systemcolumn		currentcolumn
columndescriptor	cd
systemcolumn		columns   rowfactory buildcolumnlist
execrow				templaterow   rowfactory makeemptyrow
int					columncount   newcolumnids length
schemadescriptor	sd   getsystemschemadescriptor
tabledescriptor		td
long				conglomid
// special case when adding a column to systables or syscolumns,
// since we can't go to systables/syscolumns to get the
// table/column descriptor until after we add and populate the new column.
if  rowfactory instanceof systablesrowfactory
{
td   datadescriptorgenerator newtabledescriptor
sd
tabledescriptor base_table_type
tabledescriptor row_lock_granularity
td setuuid getuuidforcoretable    sd getuuid   tostring    tc
conglomid   coreinfo getheapconglomerate
}
else if  rowfactory instanceof syscolumnsrowfactory
{
td   datadescriptorgenerator newtabledescriptor
sd
tabledescriptor base_table_type
tabledescriptor row_lock_granularity
td setuuid getuuidforcoretable    sd getuuid   tostring    tc
conglomid   coreinfo getheapconglomerate
}
else
{
td   gettabledescriptor  rowfactory getcatalogname    sd  tc
conglomid   td getheapconglomerateid
}
widenconglomerate  templaterow  newcolumnids  conglomid  tc
columndescriptor cdarray   new columndescriptor
for   int ix   0  ix < columncount  ix
{
columnid   newcolumnids
currentcolumn   columns 	   from 1 to 0 based
cdarray   makecolumndescriptor  currentcolumn  ix   1  td
}
adddescriptorarray cdarray  td  syscolumns_catalog_num  false  tc
}
/**
*	add invisible columns to an existing system catalog
*
*	@param	rowfactory				associated with this catalog.
*	@param	newcolumnids			array of 1-based column ids.
*	@param	tc						transaction controller
*
*	@exception standardexception standard derby error policy
*/
public	void	upgrade_addinvisiblecolumns
catalogrowfactory		rowfactory
int					newcolumnids
transactioncontroller	tc
throws standardexception
{
execrow				templaterow   rowfactory makeemptyrow
schemadescriptor	sd   getsystemschemadescriptor
long				conglomid   gettabledescriptor  rowfactory getcatalogname    sd  tc   getheapconglomerateid
widenconglomerate  templaterow  newcolumnids  conglomid  tc
}
/**
*	adds columns to the conglomerate underlying a system table.
*
*	@param	templaterow				ultimate shape of base row of table
*	@param	newcolumnids			array of 1-based column ids
*	@param	conglomid				heap id
*	@param	tc						transaction controller
*
*	@exception standardexception standard derby error policy
*/
private	void	widenconglomerate
execrow					templaterow
int					newcolumnids
long					conglomid
transactioncontroller	tc
throws standardexception
{
int					columncount   newcolumnids length
for   int ix   0  ix < columncount  ix
{
int columnid   newcolumnids
int storableposition   columnid   1 			   from 1 to 0 based
// system catalog columns always have ucs_basic collation.
tc addcolumntoconglomerate
conglomid
storableposition
templaterow getcolumn  columnid
stringdatavalue collation_type_ucs_basic
}
}
/**
*	code to add an index to a catalog during upgrade.
*
*	@param	tc						transaction controller
*	@param	ti						information on the catalog that's having a new index added
*	@param	indexnumber				0-based index number
*	@param	heapconglomeratenumber	what it is
*
* @return the conglomerate number of the new index.
*
* @exception standardexception		thrown on failure
*/
public	long	upgrade_makeoneindex
transactioncontroller	tc
tabinfoimpl					ti
int						indexnumber
long					heapconglomeratenumber
throws standardexception
{
schemadescriptor		sd   getsystemschemadescriptor
datadescriptorgenerator ddg   getdatadescriptorgenerator
long					indexconglomeratenumber
conglomeratedescriptor	conglomeratedescriptor   bootstraponeindex
sd  tc  ddg  ti  indexnumber  heapconglomeratenumber
indexconglomeratenumber   conglomeratedescriptor getconglomeratenumber
adddescriptor conglomeratedescriptor  sd
sysconglomerates_catalog_num  false  tc
return indexconglomeratenumber
}
/**
* get the uuid for the specified system table.  prior
* to plato, system tables did not have canonical uuids, so
* we need to scan systables to get the uuid when we
* are updating the core tables.
*
* @param tablename		name of the table
* @param schemauuid	uuid of schema
* @param tc			transactioncontroller to user
*
* @return uuid	the uuid of the core table.
*
* @exception standardexception		thrown on failure
*/
private uuid getuuidforcoretable string tablename
string schemauuid
transactioncontroller tc
throws standardexception
{
conglomeratecontroller	heapcc
execindexrow	  		indexrow1
execrow					row
datavaluedescriptor	    schemaidorderable
datavaluedescriptor		tablenameorderable
scancontroller			scancontroller
tabinfoimpl					ti   coreinfo
systablesrowfactory		rf    systablesrowfactory  ti getcatalogrowfactory
// we only want the 1st column from the heap
row   exfactory getvaluerow 1
/* use tablenameorderable and schemaidorderable in both start
* and stop position for scan.
*/
tablenameorderable   new sqlvarchar tablename
schemaidorderable   new sqlchar schemauuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 2
keyrow setcolumn 1  tablenameorderable
keyrow setcolumn 2  schemaidorderable
heapcc   tc openconglomerate
ti getheapconglomerate    false  0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
execrow indextemplaterow   rf buildemptyindexrow  systablesrowfactory systables_index1_id  heapcc newrowlocationtemplate
/* scan the index and go to the data pages for qualifying rows to
* build the column descriptor.
*/
scancontroller   tc openscan
ti getindexconglomerate systablesrowfactory systables_index1_id       conglomerate to open
false     don't hold open across commit
0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
formatablebitset  null             all fields as objects
keyrow getrowarray         start position   first row
scancontroller ge          startsearchoperation
scanqualifier  null    scanqualifier
keyrow getrowarray         stop position   through last row
scancontroller gt          stopsearchoperation
/* ok to fetch into the template row,
* since we won't be doing a next.
*/
if  scancontroller fetchnext indextemplaterow getrowarray
{
rowlocation	baserowlocation
baserowlocation    rowlocation 	indextemplaterow getcolumn
indextemplaterow ncolumns
/* 1st column is tableid (uuid - char(36)) */
row setcolumn systablesrowfactory systables_tableid  new sqlchar
formatablebitset bi   new formatablebitset 1
bi set 0
boolean base_row_exists
heapcc fetch
baserowlocation  row getrowarray     formatablebitset  null
if  sanitymanager debug
{
// it can not be possible for heap row to disappear while
// holding scan cursor on index at isolation_repeatable_read.
sanitymanager assert base_row_exists
}
}
scancontroller close
heapcc close
return uuidfactory recreateuuid row getcolumn 1  tostring
}
/**
* initialize noncore columns to fixed values
*
* @param tc					the transactioncontroller for the transaction to do the
*								upgrade in.
* @param iscoretable			true if it is a core table
* @param tablenum				the noncore table number
* @param columnstoupdateset	a bit set of columns to update.  zero based
* @param replacerow			an object array of orderables for the new values
*
* @exception standardexception		thrown on error
*/
void upgrade_initsystemtablecols
transactioncontroller 	tc
boolean					iscoretable
int 					tablenum
formatablebitset 				columnstoupdateset
datavaluedescriptor 	replacerow
throws standardexception
{
tabinfoimpl ti    iscoretable  ?  coreinfo
getnoncoretibynumber tablenum
if   iscoretable
faultintabinfo ti
/* scan the entire heap */
scancontroller sc
tc openscan
ti getheapconglomerate
false
transactioncontroller openmode_forupdate
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
rowutil empty_row_bitset
datavaluedescriptor  null
scancontroller na
qualifier  null
datavaluedescriptor  null
scancontroller na
while  sc next
{
/* replace the column in the table */
sc replace replacerow  columnstoupdateset
}
sc close
}
/*
*******************************************************************************
*
*	see repbasicdatadictionary for sample code on how to create a system
*	table.
*
*	what follows here is special code for the core catalogs. these are catalogs
*	which have to exist before any other system tables are created.
*
*	creating a core catalog consists of two steps: 1) creating all the infrastructure
*	needed to make generic systemtablecreation work, 2) actually populating the
*	data dictionary and core conglomerates with tuples.
*
*******************************************************************************
*/
/**
*	infrastructure work for indexes on catalogs.
*
@exception standardexception standard derby error policy
*/
private void bootstrapsystemindexes
schemadescriptor sd
transactioncontroller tc
datadescriptorgenerator ddg
tabinfoimpl ti
throws standardexception
{
conglomeratedescriptor cgd   new conglomeratedescriptor
/* ordering problem with sysconglomerates.  we need to create
* all of the conglomerates first before adding rows to
* sysconglomerates.  (all of the conglomerates for sysconglomerates
* must be there before we can add to them.)
*
*/
for  int indexctr   0  indexctr < ti getnumberofindexes    indexctr
{
cgd   bootstraponeindex  sd  tc  ddg  ti  indexctr  ti getheapconglomerate
}
for  int indexctr   0  indexctr < ti getnumberofindexes    indexctr
{
adddescriptor cgd  sd
sysconglomerates_catalog_num  false  tc
}
}
/**
* @see datadictionary#computeautoincrowlocations
*/
public rowlocation computeautoincrowlocations transactioncontroller tc
tabledescriptor td
throws standardexception
{
int size
if    td tablehasautoincrement
return null
size   td getnumberofcolumns
rowlocation rla   new rowlocation
for  int i   0  i < size  i
{
columndescriptor cd   td getcolumndescriptor i   1
if  cd isautoincrement
rla   computerowlocation tc  td  cd getcolumnname
}
return rla
}
/**
* @see datadictionary#getsetautoincrementvalue
*/
public numberdatavalue getsetautoincrementvalue
rowlocation rl
transactioncontroller tc
boolean doupdate
numberdatavalue newvalue
boolean wait
throws standardexception
{
formatablebitset columntoupdate   new
formatablebitset syscolumnsrowfactory syscolumns_column_count
int columnnum   syscolumnsrowfactory syscolumns_autoincrementvalue
tabinfoimpl ti   coreinfo
conglomeratecontroller heapcc   null
syscolumnsrowfactory	rf    syscolumnsrowfactory  ti getcatalogrowfactory
execrow row   rf makeemptyrow
formatablebitset  columntoread   new
formatablebitset syscolumnsrowfactory syscolumns_column_count
// formatablebitset is 0 based.
columntoread set columnnum   1      current value
columntoread set columnnum          start value
columntoread set columnnum   1      increment value
try
{
/* if wait is true then we need to do a wait while trying to
open/fetch from the conglomerate. note we use wait both to
open as well as fetch from the conglomerate.
*/
heapcc
tc openconglomerate
ti getheapconglomerate
false
transactioncontroller openmode_forupdate
wait  ? 0   transactioncontroller openmode_lock_nowait
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
boolean baserowexists
heapcc fetch rl  row getrowarray    columntoread  wait
columntoupdate set columnnum   1      current value
// while the row interface is 1 based.
numberdatavalue currentai    numberdatavalue row getcolumn columnnum
long currentaivalue   currentai getlong
numberdatavalue increment    numberdatavalue row getcolumn columnnum   2
if  doupdate
{
// we increment and store the new value in syscolumns
currentai   currentai plus currentai  increment  currentai
row setcolumn columnnum  currentai
heapcc replace rl  row getrowarray    columntoupdate
}
// but we return the "currentaivalue"-- i.e the value before
// incrementing it.
if  newvalue    null
{
// user has passed in an object; set the current value in there and
// return it.
newvalue setvalue currentaivalue
return newvalue
}
else
{
// reuse the object read from row.
currentai setvalue currentaivalue
return currentai
}
}
finally
{
if  heapcc    null
heapcc close
}
}
private	conglomeratedescriptor	bootstraponeindex
schemadescriptor		sd
transactioncontroller	tc
datadescriptorgenerator	ddg
tabinfoimpl					ti
int						indexnumber
long					heapconglomeratenumber
throws standardexception
{
boolean						isunique
conglomeratecontroller		cc
execrow						baserow
execindexrow				indexablerow
int							numcolumns
long						conglomid
rowlocation					rl
catalogrowfactory			rf   ti getcatalogrowfactory
indexrowgenerator			irg
conglomeratedescriptor	conglomeratedescriptor
initsystemindexvariables ddg  ti  indexnumber
irg   ti getindexrowgenerator indexnumber
numcolumns   ti getindexcolumncount indexnumber
/* is the index unique */
isunique   ti isindexunique indexnumber
// create an index row template
indexablerow   irg getindexrowtemplate
baserow   rf makeemptyrow
// get a rowlocation template
cc   tc openconglomerate
heapconglomeratenumber  false  0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
rl   cc newrowlocationtemplate
cc close
// get an index row based on the base row
irg getindexrow baserow  rl  indexablerow   formatablebitset  null
// describe the properties of the index to the store using properties
// resolve: the following properties assume a btree index.
properties	indexproperties   ti getcreateindexproperties indexnumber
// tell it the conglomerate id of the base table
indexproperties put
long tostring  heapconglomeratenumber
// all indexes are unique because they contain the rowlocation.
// the number of uniqueness columns must include the rowlocation
// if the user did not specify a unique index.
indexproperties put
integer tostring
isunique ? numcolumns   numcolumns   1
// by convention, the row location column is the last column
indexproperties put
integer tostring numcolumns
// for now, all columns are key fields, including the rowlocation
indexproperties put
integer tostring numcolumns   1
/* create and add the conglomerate (index) */
conglomid   tc createconglomerate
we're requesting an index conglomerate
indexablerow getrowarray
null    default sort order
null    default collation id's for collumns in all system congloms
indexproperties     default properties
transactioncontroller is_default      not temporary
conglomeratedescriptor
ddg newconglomeratedescriptor conglomid
rf getindexname indexnumber
true
irg
false
rf getcanonicalindexuuid indexnumber
rf getcanonicaltableuuid
sd getuuid
ti setindexconglomerate  conglomeratedescriptor
return conglomeratedescriptor
}
public void initsystemindexvariables datadescriptorgenerator ddg
tabinfoimpl ti
int indexnumber
throws standardexception
{
int					numcols   ti getindexcolumncount indexnumber
int				basecolumnpositions   new int
catalogrowfactory	rf   ti getcatalogrowfactory
for  int colctr   0  colctr < numcols  colctr
{
basecolumnpositions
ti getbasecolumnposition indexnumber  colctr
}
boolean isascending   new boolean
for  int i   0  i < basecolumnpositions length  i
isascending          true
indexrowgenerator irg   null
if  softwareversion checkversion
datadictionary dd_version_derby_10_4 null
{
irg   new indexrowgenerator
ti isindexunique indexnumber
false
basecolumnpositions
isascending
basecolumnpositions length
}
else
{
//older version of data disctionary
//use old constructor
irg   new indexrowgenerator
ti isindexunique indexnumber
basecolumnpositions
isascending
basecolumnpositions length
}
// for now, assume that all index columns are ordered columns
ti setindexrowgenerator indexnumber  irg
}
/**
*	populate sysdummy1 table with a single row.
*
* @exception standardexception standard derby error policy
*/
protected void populatesysdummy1
transactioncontroller tc
throws standardexception
{
tabinfoimpl						ti   getnoncoreti sysdummy1_catalog_num
execrow row   ti getcatalogrowfactory   makerow null  null
int insertretcode   ti insertrow row  tc
}
/**
* clear all of the datadictionary caches.
*
* @exception standardexception standard derby error policy
*/
public void clearcaches   throws standardexception
{
nametdcache cleanall
nametdcache ageout
oidtdcache cleanall
oidtdcache ageout
if  spsnamecache    null
{
//system.out.println("clearing sps cache");
spsnamecache cleanall
spsnamecache ageout
spsidhash clear
// spstexthash.clear();
}
}
/**
add the required entries to the data dictionary for a system table.
*/
private void addsystemtabletodictionary tabinfoimpl ti
schemadescriptor sd
transactioncontroller tc
datadescriptorgenerator ddg)
throws standardexception
{
catalogrowfactory	crf   ti getcatalogrowfactory
string				name   ti gettablename
long				conglomid   ti getheapconglomerate
systemcolumn		columnlist   crf buildcolumnlist
uuid				heapuuid   crf getcanonicalheapuuid
string				heapname   crf getcanonicalheapname
tabledescriptor		td
uuid				toid
columndescriptor	cd
int					columncount
systemcolumn		column
// add table to the data dictionary
columncount   columnlist length
td   ddg newtabledescriptor name  sd  tabledescriptor system_table_type
tabledescriptor row_lock_granularity
td setuuid crf getcanonicaltableuuid
adddescriptor td  sd  systables_catalog_num
false  tc
toid   td getuuid
/* add the conglomerate for the heap */
conglomeratedescriptor cgd   ddg newconglomeratedescriptor conglomid
heapname
false

false
heapuuid
toid
sd getuuid
adddescriptor cgd  sd  sysconglomerates_catalog_num  false  tc
/* create the columns */
columndescriptor cdlarray   new columndescriptor
for  int columnnumber   0  columnnumber < columncount  columnnumber
{
column   columnlist
if  sanitymanager debug
{
if  column    null
{
sanitymanager throwassert   columnnumber   ti gettablename
}
}
cdlarray   makecolumndescriptor  column
columnnumber   1  td
}
adddescriptorarray cdlarray  td  syscolumns_catalog_num  false  tc
// now add the columns to the cdl of the table.
columndescriptorlist cdl   td getcolumndescriptorlist
for  int i   0  i < columncount  i
cdl add cdlarray
}
/**
*	converts a systemcolumn to a columndescriptor.
*
*	@param	column	a systemcolumn
* @param  columnposition position of the column in the table, one based.
*	@param	td		descriptor for table that column lives in
*
*	@return	a columndes*criptor
*
*	@exception standardexception standard derby error policy
*/
private	columndescriptor	makecolumndescriptor  systemcolumn		column
int columnposition
tabledescriptor	td
throws standardexception
{
//resolveautoincrement
return new columndescriptor
column getname    columnposition  column gettype    null  null  td
uuid  null     no defaults yet for system columns
0  0
}
/**
*	create a conglomerate for a system table
*
*	@param name 		name of new catalog.
*	@param tc			transaction context.
*	@param rowtemplate	template for rows for the new table
*  @param properties	properties for createconglomerate
*
*	@return	conglomerate id.
@exception standardexception standard derby error policy.
*/
private long createconglomerate string name  transactioncontroller tc
execrow rowtemplate
properties properties
throws standardexception
{
long				conglomid
conglomid   tc createconglomerate
we're requesting a heap conglomerate
rowtemplate getrowarray       row template
null     default sort order
null     default collation ids
properties     default properties
transactioncontroller is_default      not temporary
return conglomid
}
/**
*	converts a uuid to an datavaluedescriptor.
*
*	@return	the uuid converted to an datavaluedescriptor
*
*/
private static sqlchar getidvalueaschar uuid uuid
{
string	uuidstring   uuid tostring
return 	new sqlchar uuidstring
}
/**
*	initialize catalog information. this method is overridden by children.
* @exception standardexception		thrown on error
*/
public	void	initializecataloginfo
throws standardexception
{
initializecoreinfo
initializenoncoreinfo
}
/**
* initialized the core info array.
*/
private void initializecoreinfo
throws standardexception
{
tabinfoimpl lcoreinfo   coreinfo   new tabinfoimpl
uuidfactory luuidfactory   uuidfactory
lcoreinfo
new tabinfoimpl new systablesrowfactory luuidfactory  exfactory  dvf
lcoreinfo
new tabinfoimpl new syscolumnsrowfactory luuidfactory  exfactory  dvf
lcoreinfo
new tabinfoimpl new sysconglomeratesrowfactory luuidfactory  exfactory  dvf
lcoreinfo
new tabinfoimpl new sysschemasrowfactory luuidfactory  exfactory  dvf
}
/**
* initialized the noncore info array.
*/
private void initializenoncoreinfo
throws standardexception
{
noncoreinfo   new tabinfoimpl
}
/**
* get the transactioncontroller to use, when not
* passed in as a parameter.  (this hides logic about
* whether or not we're at boot time in a single
* place.  note:  there's no lcc at boot time.)
* note: all <get> methods in the dd should call this method.
*
* @return transactioncontroller	the tc to use.
*
* @exception standardexception		thrown on error
*/
public transactioncontroller gettransactioncompile
throws standardexception
{
if  bootingtc    null
{
if  sanitymanager debug
{
sanitymanager assert booting
}
return bootingtc
}
else
{
if  sanitymanager debug
{
sanitymanager assert   booting
}
{
languageconnectioncontext lcc   getlcc
return lcc gettransactioncompile
}
}
}
/**
* get the transactioncontroller to use, when not
* passed in as a parameter.  (this hides logic about
* whether or not we're at boot time in a single
* place.  note:  there's no lcc at boot time.)
* note: all <get> methods in the dd should call this method.
*
* @return transactioncontroller	the tc to use.
*
* @exception standardexception		thrown on error
*/
public transactioncontroller gettransactionexecute
throws standardexception
{
if  bootingtc    null
{
if  sanitymanager debug
{
sanitymanager assert booting
}
return bootingtc
}
else
{
if  sanitymanager debug
{
sanitymanager assert   booting
}
{
languageconnectioncontext lcc   getlcc
return lcc gettransactionexecute
}
}
}
/**
* return a (single or list of) catalog row descriptor(s) from a
* system table where the access is from the index to the heap.
*
* @param indexid	the id of the index (0 to # of indexes on table) to use
* @param keyrow	the supplied execindexrow for search
* @param ti		the tabinfoimpl to use
* @param parenttupledescriptor		the parentdescriptor, if applicable.
* @param list      the list to build, if supplied.  if null, then
*                  caller expects a single descriptor
* @param forupdate	whether or not to open the index for update.
*
* @return	the last matching descriptor
*
* @exception standardexception		thrown on error
*/
private final tupledescriptor getdescriptorviaindex
int indexid
execindexrow keyrow
scanqualifier  scanqualifiers
tabinfoimpl ti
tupledescriptor parenttupledescriptor
list list
boolean forupdate
throws standardexception
{
// get the current transaction controller
transactioncontroller tc   gettransactioncompile
return getdescriptorviaindexminion
indexid
keyrow
scanqualifiers
ti
parenttupledescriptor
list
forupdate
transactioncontroller isolation_repeatable_read
tc
}
/**
* return a (single or list of) catalog row descriptor(s) from a
* system table where the access is from the index to the heap.
*
* this overload variant takes an explicit tc, in contrast to the normal
* one which uses the one returned by gettransactioncompile.
*
* @param indexid	the id of the index (0 to # of indexes on table) to use
* @param keyrow	the supplied execindexrow for search
* @param ti		the tabinfoimpl to use
* @param parenttupledescriptor		the parentdescriptor, if applicable.
* @param list      the list to build, if supplied.  if null, then
*					caller expects a single descriptor
* @param forupdate	whether or not to open the index for update.
* @param tc        transaction controller
*
* @return	the last matching descriptor
*
* @exception standardexception		thrown on error
*/
private final tupledescriptor getdescriptorviaindex
int indexid
execindexrow keyrow
scanqualifier  scanqualifiers
tabinfoimpl ti
tupledescriptor parenttupledescriptor
list list
boolean forupdate
transactioncontroller tc
throws standardexception
{
if  tc    null
tc   gettransactioncompile
}
return getdescriptorviaindexminion
indexid
keyrow
scanqualifiers
ti
parenttupledescriptor
list
forupdate
transactioncontroller isolation_repeatable_read
tc
}
/**
* return a (single or list of) catalog row descriptor(s) from a
* system table where the access is from the index to the heap.
*
* this overload variant takes an explicit tc, in contrast to the normal
* one which uses the one returned by gettransactioncompile.
*
* @param indexid   the id of the index (0 to # of indexes on table) to use
* @param keyrow    the supplied execindexrow for search
* @param ti        the tabinfoimpl to use
* @param parenttupledescriptor the parentdescriptor, if applicable.
* @param list      the list to build, if supplied.  if null, then
*                  caller expects a single descriptor
* @param forupdate whether or not to open the index for update.
* @param isolationlevel
*                  use this explicit isolation level. only
*                  isolation_repeatable_read (normal usage) or
*                  isolation_read_uncommitted (corner cases)
*                  supported for now.
* @param tc        transaction controller
*
* @return the last matching descriptor. if isolationlevel is
*         isolation_read_uncommitted, the base row may be gone by the
*         time we access it via the index; in such a case a null is
*         returned.
*
* @exception standardexception thrown on error.
*/
private final tupledescriptor getdescriptorviaindex
int indexid
execindexrow keyrow
scanqualifier  scanqualifiers
tabinfoimpl ti
tupledescriptor parenttupledescriptor
list list
boolean forupdate
int isolationlevel
transactioncontroller tc
throws standardexception
{
if  tc    null
tc   gettransactioncompile
}
return getdescriptorviaindexminion indexid
keyrow
scanqualifiers
ti
parenttupledescriptor
list
forupdate
isolationlevel
tc
}
private final tupledescriptor getdescriptorviaindexminion
int indexid
execindexrow keyrow
scanqualifier  scanqualifiers
tabinfoimpl ti
tupledescriptor parenttupledescriptor
list list
boolean forupdate
int isolationlevel
transactioncontroller tc
throws standardexception
{
catalogrowfactory		rf   ti getcatalogrowfactory
conglomeratecontroller	heapcc
execindexrow	  		indexrow1
execindexrow			indextemplaterow
execrow 				outrow
rowlocation				baserowlocation
scancontroller			scancontroller
tupledescriptor			td   null
if  sanitymanager debug
sanitymanager assert
isolationlevel
transactioncontroller isolation_repeatable_read
isolationlevel
transactioncontroller isolation_read_uncommitted
if  isolationlevel
transactioncontroller isolation_read_uncommitted
// list not used for this case
sanitymanager assert list    null
}
}
outrow   rf makeemptyrow
heapcc   tc openconglomerate
ti getheapconglomerate    false  0
transactioncontroller mode_record
isolationlevel
/* scan the index and go to the data pages for qualifying rows to
* build the column descriptor.
*/
scancontroller   tc openscan
ti getindexconglomerate indexid       conglomerate to open
false     don't hold open across commit
forupdate  ? transactioncontroller openmode_forupdate   0
transactioncontroller mode_record
isolationlevel
formatablebitset  null             all fields as objects
keyrow getrowarray         start position   first row
scancontroller ge          startsearchoperation
scanqualifiers            scanqualifier
keyrow getrowarray         stop position   through last row
scancontroller gt          stopsearchoperation
while  true
{
// create an index row template
indexrow1   getindexrowfromheaprow
ti getindexrowgenerator indexid
heapcc newrowlocationtemplate
outrow
// it is important for read uncommitted scans to use fetchnext()
// rather than fetch, so that the fetch happens while latch is
// held, otherwise the next() might position the scan on a row,
// but the subsequent fetch() may find the row deleted or purged
// from the table.
if   scancontroller fetchnext indexrow1 getrowarray
break
}
baserowlocation    rowlocation 	indexrow1 getcolumn
indexrow1 ncolumns
// resolve paulat - remove the try catch block when track 3677 is fixed
// just leave the contents of the try block
// adding to get more info on track 3677
boolean base_row_exists   false
try
{
base_row_exists
heapcc fetch
baserowlocation  outrow getrowarray     formatablebitset  null
}
catch  runtimeexception re
{
if  sanitymanager debug
{
if  re instanceof assertfailure
{
stringbuffer strbuf   new stringbuffer   ti gettablename
strbuf append   indexrow1   ti getindexname indexid    ti getindexconglomerate indexid
debuggenerateinfo strbuf tc heapcc ti indexid
}
}
throw re
}
catch  standardexception se
{
if  sanitymanager debug
{
// only look for a specific error i.e. that of record on page
// no longer exists
// do not want to catch lock timeout errors here
if  se getsqlstate   equals
{
stringbuffer strbuf   new stringbuffer   ti gettablename
strbuf append   indexrow1   ti getindexname indexid    ti getindexconglomerate indexid
debuggenerateinfo strbuf tc heapcc ti indexid
}
}
throw se
}
if  sanitymanager debug
{
// it can not be possible for heap row to disappear while
// holding scan cursor on index at isolation_repeatable_read.
if    base_row_exists
isolationlevel
transactioncontroller isolation_repeatable_read
stringbuffer strbuf   new stringbuffer   ti gettablename
strbuf append   indexrow1   ti getindexname indexid    ti getindexconglomerate indexid
debuggenerateinfo strbuf tc heapcc ti indexid
// resolve: for now, we are going to kill the vm
// to help debug this problem.
system exit 1
// resolve: not currently reached
//sanitymanager.throwassert(strbuf.tostring());
}
}
if   base_row_exists
isolationlevel
transactioncontroller isolation_read_uncommitted
// if isolationlevel == isolation_read_uncommitted we may
// possibly see that the base row does not exist even if the
// index row did.  this mode is currently only used by
// tablenameinfo's call to hashalltabledescriptorsbytableid,
// cf. derby-3678. a table's schema descriptor is attempted
// read, and if the base row for the schema has gone between
// reading the index and the base table, the table that needs
// this information has gone, too.  so, the table should not
// be needed for printing lock timeout or deadlock
// information, so we can safely just return an empty (schema)
// descriptor. furthermore, neither timeout or deadlock
// diagnostics access the schema of a table descriptor, so it
// seems safe to just return an empty schema descriptor for
// the table.
//
// there is a theoretical chance another row may have taken
// the first one's place, but only if a compress of the base
// table managed to run between the time we read the index and
// the base row, which seems unlikely so we ignore that.
//
// even the index row may be gone in the above use case, of
// course, and that case also returns an empty descriptor
// since no match is found.
td   null
else
// normal case
td   rf builddescriptor outrow  parenttupledescriptor  this
}
/* if list is null, then caller only wants a single descriptor - we're done
* else just add the current descriptor to the list.
*/
if  list    null
{
break
}
else
{
list add td
}
}
scancontroller close
heapcc close
return td
}
private void debuggenerateinfo stringbuffer strbuf
transactioncontroller tc  conglomeratecontroller heapcc  tabinfoimpl ti
int indexid
{
if  sanitymanager debug
try
{
strbuf append
// print the lock table
// will get a nullpointerexception if lcc doesn't yet exist e.g. at boot time
languageconnectioncontext lcc    languageconnectioncontext
contextservice getcontext languageconnectioncontext context_id
if  lcc    null
{
long currenttime   system currenttimemillis
//exclude-start-lockdiag-
enumeration locktable   lockfactory makevirtuallocktable
string locktablestring   timeout buildstring locktable currenttime
strbuf append
strbuf append locktablestring
//exclude-end-lockdiag-
}
// consistency checking etc.
conglomeratecontroller btreecc
tc openconglomerate
ti getindexconglomerate indexid
false
0  transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
btreecc debugconglomerate
heapcc debugconglomerate
heapcc checkconsistency
strbuf append
conglomeratecontroller indexcc   tc openconglomerate
ti getindexconglomerate indexid
false
0
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
indexcc checkconsistency
strbuf append
system err println   strbuf tostring
system out println   strbuf tostring
sanitymanager debug_print    strbuf tostring
}
catch  standardexception se
{
strbuf append   se tostring
}
}
}
/**
* return a (single or list of) catalog row descriptor(s) from a
* system table where the access a heap scan
*
* @param scanqualifiers			qualifiers
* @param ti						the tabinfoimpl to use
* @param parenttupledescriptor		the parentdescriptor, if applicable.
* @param list						the list to build, if supplied.
*									if null, then caller expects a single descriptor
*
* @return	the last matching descriptor
*
* @exception standardexception		thrown on error
*/
protected tupledescriptor getdescriptorviaheap
scanqualifier  scanqualifiers
tabinfoimpl ti
tupledescriptor parenttupledescriptor
list list
throws standardexception
{
catalogrowfactory		rf   ti getcatalogrowfactory
conglomeratecontroller	heapcc
execrow 				outrow
scancontroller			scancontroller
transactioncontroller	tc
tupledescriptor			td   null
// get the current transaction controller
tc   gettransactioncompile
outrow   rf makeemptyrow
/*
** table scan
*/
scancontroller   tc openscan
ti getheapconglomerate   	   conglomerate to open
false  						   don't hold open across commit
0  							   for read
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
formatablebitset  null             all fields as objects
datavaluedescriptor  null 		   start position   first row
0       				   startsearchoperation   none
scanqualifiers  		   scanqualifier
datavaluedescriptor  null 		   stop position   through last row
0       				   stopsearchoperation   none
while  scancontroller fetchnext outrow getrowarray
{
td   rf builddescriptor outrow  parenttupledescriptor  this
/* if dlist is null, then caller only wants a single descriptor - we're done
* else just add the current descriptor to the list.
*/
if  list    null
{
break
}
else
{
list add td
}
}
scancontroller close
return td
}
/**
* get a tabinfoimpl for a non-core table.
* (we fault in information about non-core tables as needed.)
*
* @param catalognumber	the index into noncoretable[].
*
* @exception standardexception		thrown on error
*/
private tabinfoimpl getnoncoreti int catalognumber
throws standardexception
{
tabinfoimpl	ti   getnoncoretibynumber catalognumber
faultintabinfo  ti
return ti
}
/** returns the tabinfo for a non core system catalog. input is a
* catalognumber (defined in datadictionary).
*/
protected tabinfoimpl getnoncoretibynumber int catalognumber
throws standardexception
{
int noncorenum   catalognumber   num_core
// look up the tabinfoimpl in the array. this does not have to be
// synchronized, because getting a reference is atomic.
tabinfoimpl retval   noncoreinfo
if  retval    null
{
// if we did not find the tabinfoimpl, get the right one and
// load it into the array. there is a small chance that
// two threads will do this at the same time. the code will
// work properly in that case, since storing a reference
// is atomic (although we could get extra object instantiation
// if two threads come through here at the same time.
uuidfactory luuidfactory   uuidfactory
switch  catalognumber
{
case sysconstraints_catalog_num
retval   new tabinfoimpl new sysconstraintsrowfactory
luuidfactory  exfactory  dvf
break
case syskeys_catalog_num
retval   new tabinfoimpl new syskeysrowfactory
luuidfactory  exfactory  dvf
break
case sysdepends_catalog_num
retval   new tabinfoimpl new sysdependsrowfactory
luuidfactory  exfactory  dvf
break
case sysviews_catalog_num
retval   new tabinfoimpl new sysviewsrowfactory
luuidfactory  exfactory  dvf
break
case syschecks_catalog_num
retval   new tabinfoimpl new syschecksrowfactory
luuidfactory  exfactory  dvf
break
case sysforeignkeys_catalog_num
retval   new tabinfoimpl new sysforeignkeysrowfactory
luuidfactory  exfactory  dvf
break
case sysstatements_catalog_num
retval   new tabinfoimpl new sysstatementsrowfactory
luuidfactory  exfactory  dvf
break
case sysfiles_catalog_num
retval   new tabinfoimpl new sysfilesrowfactory
luuidfactory  exfactory  dvf
break
case sysaliases_catalog_num
retval   new tabinfoimpl new sysaliasesrowfactory
luuidfactory  exfactory  dvf
break
case systriggers_catalog_num
retval   new tabinfoimpl new systriggersrowfactory
luuidfactory  exfactory  dvf
break
case sysstatistics_catalog_num
retval   new tabinfoimpl new sysstatisticsrowfactory
luuidfactory  exfactory  dvf
break
case sysdummy1_catalog_num
retval   new tabinfoimpl new sysdummy1rowfactory
luuidfactory  exfactory  dvf
break
case systableperms_catalog_num
retval   new tabinfoimpl new systablepermsrowfactory
luuidfactory  exfactory  dvf
break
case syscolperms_catalog_num
retval   new tabinfoimpl new syscolpermsrowfactory
luuidfactory  exfactory  dvf
break
case sysroutineperms_catalog_num
retval   new tabinfoimpl new sysroutinepermsrowfactory
luuidfactory  exfactory  dvf
break
case sysroles_catalog_num
retval   new tabinfoimpl new sysrolesrowfactory
luuidfactory  exfactory  dvf
break
}
initsystemindexvariables retval
noncoreinfo   retval
}
return retval
}
protected void initsystemindexvariables tabinfoimpl ti
throws standardexception
{
int numindexes   ti getnumberofindexes
if  numindexes > 0
{
datadescriptorgenerator ddg   getdatadescriptorgenerator
for  int indexctr   0  indexctr < numindexes  indexctr
{
initsystemindexvariables ddg  ti  indexctr
}
}
}
// expected to be called only during boot time, so no synchronization.
private void clearnoncoretable int noncorenum
{
noncoreinfo   null
}
/**
*	finishes building a tabinfoimpl if it hasn't already been faulted in.
*	nop if tabinfoimpl has already been faulted in.
*
*	@param	ti	tabinfoimpl to fault in.
*
* @exception standardexception		thrown on error
*/
public	void	faultintabinfo  tabinfoimpl ti
throws standardexception
{
int		numindexes
/* most of the time, the noncoreinfo will be complete.
* it's okay to do an unsynchronized check and return
* if it is complete, since it never becomes "un-complete".
* if we change the code, for some reason, to allow
* it to become "un-complete" after being complete,
* then we will have to do a synchronized check here
* as well.
*/
if  ti iscomplete
{
return
}
/* the completing of the noncoreinfo entry must be synchronized.
* note: we are assuming that we will not access a different
* noncoreinfo in the course of completing of this noncoreinfo,
* otherwise a deadlock could occur.
*/
synchronized ti
{
/* now that we can run, the 1st thing that we must do
* is to verify that we still need to complete the
* object.  (we may have been blocked on another user
* doing the same.)
*/
if  ti iscomplete
{
return
}
tabledescriptor td   gettabledescriptor ti gettablename
getsystemschemadescriptor    null
// it's possible that the system table is not there right
// now. this can happen, for example, if we're in the
// process of upgrading a source or target to xena, in
// which case syssyncinstants is dropped and re-created.
// just return in this case, so we don't get a null pointer
// exception.
if  td    null
{
return
}
conglomeratedescriptor cd   null
conglomeratedescriptor cds   td getconglomeratedescriptors
/* init the heap conglomerate here */
for  int index   0  index < cds length  index
{
cd   cds
if    cd isindex
{
ti setheapconglomerate cd getconglomeratenumber
break
}
}
if  sanitymanager debug
{
if  cd    null
{
sanitymanager throwassert
ti gettablename
}
}
/* initialize the index conglomerates */
numindexes   ti getcatalogrowfactory   getnumindexes
if  numindexes    0
{
return
}
/* for each index, we get its id from the cdl */
conglomeratedescriptor icd   null
int	indexcount   0
for  int index   0  index < cds length  index
{
icd   cds
if  icd isindex
{
ti setindexconglomerate icd
indexcount
}
continue
}
if  sanitymanager debug
{
if  indexcount    ti getcatalogrowfactory   getnumindexes
{
sanitymanager throwassert     indexcount
ti getcatalogrowfactory   getnumindexes
}
}
}
}
/**
* get an index row based on a row from the heap.
*
* @param irg		indexrowgenerator to use
* @param rl		rowlocation for heap
* @param heaprow	row from the heap
*
* @return execindexrow	index row.
*
* @exception standardexception		thrown on error
*/
public static	execindexrow getindexrowfromheaprow indexrowgenerator irg
rowlocation rl
execrow heaprow
throws standardexception
{
execindexrow		indexrow
indexrow   irg getindexrowtemplate
// get an index row based on the base row
irg getindexrow heaprow  rl  indexrow   formatablebitset  null
return indexrow
}
public	int	getenginetype
{
return	enginetype
}
/**
* get the heap conglomerate number for sys.syscolumns.
* (useful for adding new index to the table.)
*
* @return the heap conglomerate number for sys.syscolumns.
*/
public long getsyscolumnsheapconglomeratenumber
{
return coreinfo getheapconglomerate
}
void addsyscolumnsindex2property transactioncontroller tc  long index2conglomeratenumber
{
startupparameters put cfg_syscolumns_index2_id
long tostring index2conglomeratenumber
}
/**
*/
private long getbootparameter properties startparams  string key  boolean required
throws standardexception
string value   startparams getproperty key
if  value    null
{
if    required
{
return  1
}
throw standardexception newexception sqlstate property_missing  key
}
try
return long parselong value
catch  numberformatexception nfe
throw standardexception newexception sqlstate property_invalid_value  key  value
}
}
/**
*	returns a unique system generated name of the form sqlyymmddhhmmssxxn
*	  yy - year, mm - month, dd - day of month, hh - hour, mm - minute, ss - second,
*	  xx - the first 2 digits of millisec because we don't have enough space to keep the exact millisec value,
*	  n - number between 0-9
*
*	  the number at the end is to handle more than one system generated name request came at the same time.
*	  in that case, the timestamp will remain the same, we will just increment n at the end of the name.
*
*	  following is how we get around the problem of more than 10 system generated name requestes at the same time:
*	  when the database boots up, we start a counter with value -1 for the last digit in the generated name.
*	  we also keep the time in millisec to keep track of when the last system name was generated. at the
*	  boot time, it will be default to 0l. in addition, we have a calendar object for the time in millisec
*	  that calendar object is used to fetch yy, mm, dd, etc for the string sqlyymmddhhmmssxxn
*
*	  when the first request for the system generated name comes, time of last system generated name will be less than
*	  the current time. we initialize the counter to 0, set the time of last system generated name to the
*	  current time truncated off to lower 10ms time. the first name request is the only time we know for sure the
*	  time of last system generated name will be less than the current time. after this first request, the next request
*	  could be at any time. we go through the following algorithm for every generated name request.
*
*	  first check if the current time(truncated off to lower 10ms) is greater than the timestamp for last system generated name
*
*	    if yes, then we change the timestamp for system generated name to the current timestamp and reset the counter to 0
*	    and generate the name using the current timestamp and 0 as the number at the end of the generated name.
*
*	    if no, then it means this request for generated name has come at the same time as last one.
*	    or it may come at a time less than the last generated name request. this could be because of seasonal time change
*	    or somebody manually changing the time on the computer. in any case,
*	    if the counter is less than 10(meaning this is not yet our 11th request for generated name at a given time),
*	    we use that in the generated name. but if the counter has reached 10(which means, this is the 11th name request
*	    at the same time), then we increment the system generated name timestamp by 10ms and reset the counter to 0
*	    (notice, at this point, the timestamp for system generated names is not in sync with the real current time, but we
*	    need to have this mechanism to get around the problem of more than 10 generated name requests at a same physical time).
*
*	@return	system generated unique name
*/
public string getsystemsqlname
{
//note that we are using date class to change the calendar object time rather than calendar.settimeinmills.
//this is because of java bug 4243802. settimeinmillis and gettimeinmillis were protected prior to jdk14
//but since we still support jdk13, we can't rely on these methods being public starting jdk14.
//because of that, we are using date to do all the time manipulations on the calendar object
stringbuffer generatedsystemsqlname   new stringbuffer
synchronized  this
//get the current timestamp
long timenow    system currenttimemillis   10l  10l
//if the current timestamp is greater than last constraint name generation time, then we reset the counter and
//record the new timestamp
if  timenow > timeforlastsystemsqlname
systemsqlnamenumber   0
calendarforlastsystemsqlname settimeinmillis timenow
timeforlastsystemsqlname   timenow
else
//the request has come at the same time as the last generated name request
//or it has come at a time less than the time the last generated name request. this can happen
//because of seasonal time change or manual update of computer time.
//get the number that was last used for the last digit of generated name and increment it by 1.
systemsqlnamenumber
if  systemsqlnamenumber    10      we have already generated 10 names at the last system generated timestamp value
//so reset the counter
systemsqlnamenumber   0
timeforlastsystemsqlname   timeforlastsystemsqlname   10l
//increment the timestamp for system generated names by 10ms
calendarforlastsystemsqlname settimeinmillis timeforlastsystemsqlname
}
}
generatedsystemsqlname append twodigits calendarforlastsystemsqlname get calendar year
//have to add 1 to the month value returned because the method give 0-january, 1-february and so on and so forth
generatedsystemsqlname append twodigits calendarforlastsystemsqlname get calendar month  1
generatedsystemsqlname append twodigits calendarforlastsystemsqlname get calendar day_of_month
generatedsystemsqlname append twodigits calendarforlastsystemsqlname get calendar hour_of_day
generatedsystemsqlname append twodigits calendarforlastsystemsqlname get calendar minute
generatedsystemsqlname append twodigits calendarforlastsystemsqlname get calendar second
//because we don't have enough space to store the entire millisec value, just store the higher 2 digits.
generatedsystemsqlname append twodigits  int   calendarforlastsystemsqlname get calendar millisecond  10
generatedsystemsqlname append systemsqlnamenumber
}
return generatedsystemsqlname tostring
}
private static string twodigits int val
string retval
if  val < 10
retval       val
else
int retvallength   integer tostring val  length
retval   integer tostring val  substring retvallength 2
}
return retval
}
/**
* sets a new value in syscolumns for a particular
* autoincrement column.
*
* @param tc		 transaction controller to use.
* @param columnname name of the column.
* @param aivalue	 value to write to syscolumns.
* @param incrementneeded whether to increment the value passed in by the
* user (aivalue) or not before writing it to syscolumns.
*/
public void setautoincrementvalue transactioncontroller tc
uuid tableuuid
string columnname
long aivalue  boolean incrementneeded
throws standardexception
{
tabinfoimpl ti   coreinfo
execindexrow keyrow   null
keyrow    execindexrow exfactory getindexablerow 2
keyrow setcolumn 1  getidvalueaschar tableuuid
keyrow setcolumn 2  new sqlchar columnname
syscolumnsrowfactory	rf    syscolumnsrowfactory  ti getcatalogrowfactory
execrow row   rf makeemptyrow
boolean barray   new boolean
for  int index   0  index < 2  index
{
barray   false
}
int colstoupdate   new int
colstoupdate   syscolumnsrowfactory syscolumns_autoincrementvalue
if  incrementneeded
{
execrow readrow   ti getrow tc  keyrow
syscolumnsrowfactory syscolumns_index1_id
numberdatavalue increment
numberdatavalue readrow getcolumn syscolumnsrowfactory syscolumns_autoincrementinc
aivalue    increment getlong
}
row setcolumn syscolumnsrowfactory syscolumns_autoincrementvalue
dvf getdatavalue aivalue
ti updaterow keyrow  row
syscolumnsrowfactory syscolumns_index1_id
barray
colstoupdate
tc
return
}
/**
* computes the rowlocation in syscolumns for a particular
* autoincrement column.
*
* @param tc			transaction controller to use.
* @param td			table descriptor.
* @param columnname	name of column which has autoincrement column.
*
* @exception standardexception thrown on failure.
*/
private rowlocation computerowlocation transactioncontroller tc
tabledescriptor td
string columnname
throws standardexception
{
tabinfoimpl ti   coreinfo
execindexrow keyrow   null
execrow row
uuid tableuuid   td getuuid
keyrow    execindexrow exfactory getindexablerow 2
keyrow setcolumn 1  getidvalueaschar tableuuid
keyrow setcolumn 2  new sqlchar columnname
return ti getrowlocation tc  keyrow
syscolumnsrowfactory syscolumns_index1_id
}
public rowlocation getrowlocationtemplate languageconnectioncontext lcc
tabledescriptor td
throws standardexception
{
rowlocation 			rl
conglomeratecontroller 	heapcc   null
transactioncontroller tc
lcc gettransactioncompile
long tableid   td getheapconglomerateid
heapcc
tc openconglomerate
tableid  false  0  tc mode_record  tc isolation_read_committed
try
{
rl   heapcc newrowlocationtemplate
}
finally
{
heapcc close
}
return rl
}
/**
*
* add a table descriptor to the "other" cache. the other cache is
* determined by the type of the object c.
*
* @param td	tabledescriptor to add to the other cache.
* @param c		cacheable object which lets us figure out the other cache.
*
* @exception	standardexception
*/
public void addtabledescriptortoothercache tabledescriptor td
cacheable c
throws standardexception
{
// get the other cache. if the entry we are setting in the cache is of
// type oidtdcacheable then use the nametdcache
cachemanager othercache
c instanceof oidtdcacheable  ? nametdcache   oidtdcache
object key
tdcacheable othercacheentry   null
if  othercache    nametdcache
key   new tablekey td getschemadescriptor   getuuid    td getname
else
key   td getuuid
try
{
// insert the entry into the the other cache.
othercacheentry    tdcacheable othercache create key  td
}
catch  standardexception se
{
// if the object already exists in cache then somebody beat us to it
// otherwise throw the error.
if    se getmessageid   equals sqlstate object_exists_in_cache
throw se
}
finally
{
if  othercacheentry    null
othercache release othercacheentry
}
}
/** @see datadictionary#dropstatisticsdescriptors */
public void dropstatisticsdescriptors uuid tableuuid  uuid referenceuuid
transactioncontroller tc
throws standardexception
{
tabinfoimpl					ti   getnoncoreti sysstatistics_catalog_num
datavaluedescriptor first  second
first   getidvalueaschar tableuuid
execindexrow keyrow
if  referenceuuid    null
{
keyrow   exfactory getindexablerow 2
second   getidvalueaschar referenceuuid
keyrow setcolumn 2  second
}
else
{
keyrow   exfactory getindexablerow 1
}
keyrow setcolumn 1  first
ti deleterow tc  keyrow
sysstatisticsrowfactory sysstatistics_index1_id
}
private static languageconnectioncontext getlcc
return  languageconnectioncontext
contextservice getcontextornull languageconnectioncontext context_id
}
private schemadescriptor newsystemschemadesc
string  name
string  uuid
{
return new schemadescriptor
this
name
authorizationdatabaseowner
uuidfactory recreateuuid uuid
true
}
private schemadescriptor newdeclaredglobaltemporarytablesschemadesc  string name
{
return new schemadescriptor this
name
authorizationdatabaseowner
uuid  null
false
}
/**
check to see if a database has been upgraded to the required
level in order to use a language feature.
@param requiredmajorversion data dictionary major version
@param feature non-null to throw an error, null to return the state of the version match.
@return true if the database has been upgraded to the required level, false otherwise.
*/
public boolean checkversion int requiredmajorversion  string feature  throws standardexception
if  requiredmajorversion    datadictionary dd_version_current
requiredmajorversion   softwareversion majorversionnumber
}
return dictionaryversion checkversion requiredmajorversion  feature
}
/**
** create system built-in metadata stored prepared statements.
*/
void createsystemsps transactioncontroller tc
throws standardexception
{
// databasemetadata stored plans
createspsset tc  false  getsystemschemadescriptor   getuuid
// network server stored plans
createspsset tc  true  getsysibmschemadescriptor   getuuid
}
/**
create a set of stored prepared statements from a properties file.
key is the statement name, value is the sql statement.
*/
protected void createspsset transactioncontroller tc  boolean net  uuid schemaid
throws standardexception
{
properties p   getquerydescriptions net
enumeration e   p keys
//statement will get compiled on first execution
//note: don't change this to false lcc is not available for compiling
boolean nocompile   true
while  e hasmoreelements
{
string spsname    string e nextelement
string spstext    p getproperty spsname
spsdescriptor spsd   new spsdescriptor this  spsname
getuuidfactory   createuuid
schemaid
schemaid
spsdescriptor sps_type_regular
nocompile 		   it is valid  unless nocompile
spstext    sps text
nocompile
addspsdescriptor spsd  tc
}
}
/**
* generic create procedure routine.
* <p>
* takes the input procedure and inserts it into the appropriate
* catalog.
*
* assumes all arguments are "in" type.
*
* @param routine_name  name of the routine in java and the sql
*                      procedure name.
*
* @param arg_names     string array of procedure argument names in order.
*
* @param arg_types     internal sql types of the arguments
*
* @param routine_sql_control
*                      one of the routinealiasinfo constants:
*                          modifies_sql_data
*                          reads_sql_data
*                          contains_sql
*                          no_sql
*
* @param isdeterministic true if the procedure/function is deterministic
*
* @param return_type   null for procedure.  for functions the return type
*                      of the function.
*
* @param newlycreatedroutines evolving set of routines, some of which may need permissions later on
* @param tc            an instance of the transactioncontroller
*
* @param procclass     the fully qualified name of the class that contains
*                      java definitions for the stored procedures
*
* @return uuid 		uuid of system routine that got created.
*
* @exception  standardexception  standard exception policy.
**/
private final uuid createsystemprocedureorfunction
string                  routine_name
uuid                    schema_uuid
string                arg_names
typedescriptor        arg_types
int						num_out_param
int						num_result_sets
short                   routine_sql_control
boolean               isdeterministic
typedescriptor          return_type
hashset               newlycreatedroutines
transactioncontroller   tc
string procclass
throws standardexception
{
int num_args   0
if  arg_names    null
num_args   arg_names length
if  sanitymanager debug
{
if  num_args    0
{
sanitymanager assert arg_names    null
sanitymanager assert arg_types    null
sanitymanager assert arg_names length    arg_types length
}
}
// all args are only "in" arguments
int arg_modes   null
if  num_args    0
{
arg_modes   new int
int num_in_param   num_args   num_out_param
for  int i   0  i < num_in_param  i
arg_modes   jdbc30translation parameter_mode_in
for  int i   0  i < num_out_param  i
arg_modes   jdbc30translation parameter_mode_out
}
routinealiasinfo routine_alias_info
new routinealiasinfo
routine_name                           name of routine
num_args                               number of params
arg_names                              names of params
arg_types                              types of params
arg_modes                              all   params
num_result_sets                        number of result sets
routinealiasinfo ps_java               link to java routine
routine_sql_control                    one of
//  modifies_sql_data
//  reads_sql_data
//  contains_sql
//  no_sql
isdeterministic                 whether the procedure function is deterministic
true                                   true   calledonnullinput
return_type
uuid routine_uuid   getuuidfactory   createuuid
aliasdescriptor ads
new aliasdescriptor
this
routine_uuid
routine_name
schema_uuid
procclass
return_type    null  ?
aliasinfo alias_type_procedure_as_char
aliasinfo alias_type_function_as_char
return_type    null  ?
aliasinfo alias_name_space_procedure_as_char
aliasinfo alias_name_space_function_as_char
false
routine_alias_info  null
adddescriptor
ads  null  datadictionary sysaliases_catalog_num  false  tc
newlycreatedroutines add  routine_name
return routine_uuid
}
/**
* generic create procedure routine.
* takes the input procedure and inserts it into the appropriate
* catalog.
*
* assumes all arguments are "in" type.
*
* @param routine_name  name of the routine in java and the sql
*                      procedure name.
*
* @param arg_names     string array of procedure argument names in order.
*
* @param arg_types     internal sql types of the arguments
*
* @param routine_sql_control
*                      one of the routinealiasinfo constants:
*                          modifies_sql_data
*                          reads_sql_data
*                          contains_sql
*                          no_sql
*
*
* @param isdeterministic true if the procedure/function is deterministic
*
* @param return_type   null for procedure.  for functions the return type
*                      of the function.
*
* @param newlycreatedroutines evolving set of routines, some of which may need permissions later on
* @param tc            an instance of the transactioncontroller
*
* @return uuid         uuid of system routine that got created.
*
* @throws  standardexception  standard exception policy.
**/
private final uuid createsystemprocedureorfunction
string                  routine_name
uuid                    schema_uuid
string                arg_names
typedescriptor        arg_types
int                     num_out_param
int                     num_result_sets
short                   routine_sql_control
boolean               isdeterministic
typedescriptor          return_type
hashset               newlycreatedroutines
transactioncontroller   tc
throws standardexception
{
uuid routine_uuid   createsystemprocedureorfunction routine_name
schema_uuid  arg_names  arg_types
num_out_param  num_result_sets  routine_sql_control  isdeterministic
return_type  newlycreatedroutines  tc
return routine_uuid
}
/**
* create system procedures
* <p>
* used to add the system procedures to the database when
* it is created.  system procedures are currently added to
* either syscs_util or sqlj schemas.
* <p>
*
* @param tc     transaction controller to use.  counts on caller to
*               commit.
* @param newlycreatedroutines evolving set of routines which may need to be given permissions later on
*
* @exception  standardexception  standard exception policy.
**/
private final void create_syscs_procedures
transactioncontroller   tc  hashset newlycreatedroutines
throws standardexception
{
// types used for routine parameters and return types, all nullable.
typedescriptor varchar32672type   datatypedescriptor getcatalogtype
types varchar  32672
/*
** syscs_util routines.
*/
uuid routine_uuid   null
// used to put procedure into the syscs_util schema
uuid sysutiluuid   getsystemutilschemadescriptor   getuuid
// void syscs_util.syscs_set_database_property(
//     varchar(128), varchar(limits.db2_varchar_maxwidth))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
datatypedescriptor.getcatalogtype(
types varchar  limits db2_varchar_maxwidth
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_compress_table(varchar(128), varchar(128), smallint)
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
typedescriptor smallint
routine_uuid   createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_checkpoint_database()
{
createsystemprocedureorfunction
sysutiluuid


0
0
routinealiasinfo contains_sql
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_freeze_database()
{
createsystemprocedureorfunction
sysutiluuid


0
0
routinealiasinfo contains_sql
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_unfreeze_database()
{
createsystemprocedureorfunction
sysutiluuid


0
0
routinealiasinfo contains_sql
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_backup_database(varchar limits.db2_varchar_maxwidth)
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
datatypedescriptor.getcatalogtype(
types varchar  limits db2_varchar_maxwidth
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_backup_database_and_enable_log_archive_mode(
//     varchar limits.db2_varchar_maxwidth, smallint)
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
datatypedescriptor.getcatalogtype(
types varchar  limits db2_varchar_maxwidth
typedescriptor smallint
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_disable_log_archive_mode(smallint)
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types    typedescriptor smallint
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_set_runtimesttistics(smallint)
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types    typedescriptor smallint
routine_uuid   createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_set_statistics_timing(smallint)
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types    typedescriptor smallint
routine_uuid   createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
typedescriptor  null
newlycreatedroutines
tc
}
// syscs_util functions
//
// todo (mikem) -
// the following need to be functions when that is supported.
// until then calling them will not work.
// varchar(limits.db2_varchar_maxwidth)
// syscs_util.syscs_get_database_property(varchar(128))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types    catalog_type_system_identifier
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo reads_sql_data
false
datatypedescriptor.getcatalogtype(
types varchar  limits db2_varchar_maxwidth
newlycreatedroutines
tc
}
// smallint syscs_util.syscs_check_table(varchar(128), varchar(128))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo reads_sql_data
false
typedescriptor integer
newlycreatedroutines
tc
}
// clob syscs_util.syscs_get_runtimestatistics()
{
routine_uuid   createsystemprocedureorfunction
sysutiluuid


0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types varchar  limits db2_varchar_maxwidth
newlycreatedroutines
/*
todo - mikem, wants to be a clob, but don't know how to do
that yet.  testing it with varchar for now.
datatypedescriptor.getcatalogtype(
types.clob, limits.db2_lob_maxwidth),
*/
tc
}
/*
** sqlj routine.
*/
uuid sqljuuid
getschemadescriptor
schemadescriptor std_sqlj_schema_name  tc  true  getuuid
// sqlj.install_jar(url varchar(??), jar varchar(128), deploy int)
{
string arg_names
typedescriptor arg_types
datatypedescriptor.getcatalogtype(
types varchar  256
catalog_type_system_identifier
typedescriptor integer
createsystemprocedureorfunction
sqljuuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sqlj.replace_jar(url varchar(??), jar varchar(128))
{
string arg_names
typedescriptor arg_types
datatypedescriptor.getcatalogtype(
types varchar  256
catalog_type_system_identifier
createsystemprocedureorfunction
sqljuuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sqlj.remove_jar(jar varchar(128), undeploy int)
{
string arg_names
typedescriptor arg_types
catalog_type_system_identifier
typedescriptor integer
createsystemprocedureorfunction
sqljuuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
/*  syscs_export_table (in schemaname  varchar(128),
* in tablename    varchar(128),  in filename varchar(32672) ,
* in columndelimiter char(1),  in characterdelimiter char(1) ,
* in codeset varchar(128))
*/
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
varchar32672type
datatypedescriptor.getcatalogtype(
types char  1
datatypedescriptor.getcatalogtype(
types char  1
catalog_type_system_identifier
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
/* syscs_export_query (in selectstatement  varchar(32672),
* in filename varchar(32672) ,
* in columndelimiter char(1),  in characterdelimiter char(1) ,
* in codeset varchar(128))
*/
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
varchar32672type
varchar32672type
datatypedescriptor.getcatalogtype(
types char  1
datatypedescriptor.getcatalogtype(
types char  1
catalog_type_system_identifier
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
/*  syscs_import_table(in schemaname varchar(128),
*  in tablename varchar(128),  in filename varchar(32762),
*  in columndelimiter char(1), in characterdelimiter  char(1),
*  in codeset varchar(128) , in  replace smallint)
*/
{
// procedure argument names
string arg_names
// procedure argument types
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
varchar32672type
datatypedescriptor.getcatalogtype(
types char  1
datatypedescriptor.getcatalogtype(
types char  1
catalog_type_system_identifier
typedescriptor smallint
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
/*  syscs_import_data(in schemaname varchar(128),
*  in tablename varchar(128), in insertcolumnlist varchar(32762),
*  in columnindexes varchar(32762), in in filename varchar(32762),
*  in columndelimiter char(1), in characterdelimiter  char(1),
*  in codeset varchar(128) , in  replace smallint)
*/
{
// procedure argument names
string arg_names
// procedure argument types
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
varchar32672type
varchar32672type
varchar32672type
datatypedescriptor.getcatalogtype(
types char  1
datatypedescriptor.getcatalogtype(
types char  1
catalog_type_system_identifier
typedescriptor smallint
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
/*
* syscs_bulk_insert(
*     in schemaname varchar(128),
*     in tablename  varchar(128),
*     in vtiname    varchar(32762),
*     in vtiarg     varchar(32762))
*/
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
varchar32672type
varchar32672type
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// add 10.1 specific system procedures
create_10_1_system_procedures tc  newlycreatedroutines  sysutiluuid
// add 10.2 specific system procedures
create_10_2_system_procedures tc  newlycreatedroutines  sysutiluuid
// add 10.3 specific system procedures
create_10_3_system_procedures tc  newlycreatedroutines
// add 10.5 specific system procedures
create_10_5_system_procedures tc  newlycreatedroutines
}
/**
* create system procedures in sysibm
* <p>
* used to add the system procedures to the database when
* it is created.  full upgrade from version 5.1 or earlier also
* calls this method.
* <p>
*
* @param newlycreatedroutines evolving set of routines which we're adding (some may need permissions later on)
* @param tc     transaction controller to use.  counts on caller to
*               commit.
*
* @exception  standardexception  standard exception policy.
**/
protected final void create_sysibm_procedures
transactioncontroller   tc  hashset newlycreatedroutines
throws standardexception
{
/*
** sysibm routines.
*/
// used to put procedure into the sysibm schema
uuid sysibmuuid   getsysibmschemadescriptor   getuuid
// sysibm.sqlcamessage(
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
typedescriptor smallint
datatypedescriptor.getcatalogtype(
types varchar  limits db2_jcc_max_exception_param_length
datatypedescriptor getcatalogtype types char  8
typedescriptor integer
typedescriptor integer
typedescriptor integer
typedescriptor integer
typedescriptor integer
typedescriptor integer
datatypedescriptor getcatalogtype types char  11
datatypedescriptor getcatalogtype types char  5
datatypedescriptor getcatalogtype types varchar  50
datatypedescriptor getcatalogtype types char  5
datatypedescriptor getcatalogtype types varchar  2400
typedescriptor integer
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
2
0
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlprocedures(varchar(128), varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqltableprivileges(varchar(128), varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlprimarykeys(varchar(128), varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqltables(varchar(128), varchar(128), varchar(128), varchar(4000), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlprocedurecols(varchar(128), varchar(128), varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlcolumns(varchar(128), varchar(128), varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlcolprivileges(varchar(128), varchar(128), varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqludts(varchar(128), varchar(128), varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlforeignkeys(varchar(128), varchar(128), varchar(128), varchar(128),
//						 varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlspecialcolumns(smallint, varchar(128), varchar(128), varchar(128),
//						 	smallint, smallint, varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor smallint
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
typedescriptor smallint
typedescriptor smallint
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlgettypeinfo(smallint, varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor smallint
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlstatistics(varchar(128), varchar(128), varchar(128),
//						 	smallint, smallint, varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
typedescriptor smallint
typedescriptor smallint
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
sysibmuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// void sysibm.metadata()
{
createsystemprocedureorfunction
sysibmuuid


0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
}
/**
* grant public access to specific system routines. currently, this is
* done for some routines in syscs_util schema. we grant access to routines
* which we have just added. doing it this way lets us declare these
* routines in one place and re-use this logic during database creation and
* during upgrade.
*
* @param tc	transactioncontroller to use
* @param authorizationid	authorization id of the permission grantor
* @throws standardexception	standard exception policy.
*/
public void grantpublicaccesstosystemroutines hashset newlycreatedroutines  transactioncontroller tc
string authorizationid  throws standardexception
// get schema id for syscs_util schema
string schemaid   getsystemutilschemadescriptor   getuuid   tostring
for int i 0  i < sysutilprocedureswithpublicaccess length  i
string  routinename   sysutilprocedureswithpublicaccess
if    newlycreatedroutines contains  routinename       continue
grantpublicaccesstosystemroutine schemaid
routinename
aliasinfo alias_name_space_procedure_as_char
tc  authorizationid
}
for int i 0  i < sysutilfunctionswithpublicaccess length  i
string routinename   sysutilfunctionswithpublicaccess
if    newlycreatedroutines contains  routinename       continue
grantpublicaccesstosystemroutine schemaid
routinename
aliasinfo alias_name_space_function_as_char
tc  authorizationid
}
}
/**
* grant public access to a system routine. this method should be used only
* for granting access to a system routine (other than routines in sysfun
* schema). it expects the routine to be present in sysaliases catalog.
*
* @param schemaid	schema id
* @param routinename	routine name
* @param namespace	indicates whether the routine is a function/procedure.
* @param tc	transactioncontroller to use
* @param authorizationid	authorization id of the permission grantor
* @throws standardexception	standard exception policy.
*/
private void grantpublicaccesstosystemroutine string schemaid
string routinename
char namespace
transactioncontroller tc
string authorizationid
throws standardexception
// for system routines, a valid alias descriptor will be returned.
aliasdescriptor ad   getaliasdescriptor schemaid  routinename
namespace
//
// when upgrading from 10.1, it can happen that we haven't yet created
// all public procedures. we forgive that possibility here and just return.
//
if   ad    null     return
uuid routineuuid   ad getuuid
createroutinepermpublicdescriptor routineuuid  tc  authorizationid
}
/**
* create routinepermdescriptor to grant access to public for
* this system routine using the grantor specified in authorizationid.
*
* @param routineuuid	uuid of the routine
* @param tc	transactioncontroller to use
* @param authorizationid	authorization id of the permission grantor
* @throws standardexception	standard exception policy.
*/
void createroutinepermpublicdescriptor
uuid routineuuid
transactioncontroller tc
string authorizationid  throws standardexception
{
routinepermsdescriptor routinepermdesc
new routinepermsdescriptor
this
authorizationid
routineuuid
adddescriptor
routinepermdesc  null  datadictionary sysroutineperms_catalog_num  false  tc
}
/**
* create system procedures added in version 10.1.
* <p>
* create 10.1 system procedures, called by either code creating new
* database, or code doing hard upgrade from previous version.
* <p>
*
* @param tc                 booting transaction
* @param newlycreatedroutines set of routines we are creating (used to add permissions later on)
* @param sysutiluuid   uuid of the sysutil schema.
*
* @exception  standardexception  standard exception policy.
**/
void create_10_1_system_procedures
transactioncontroller   tc
hashset               newlycreatedroutines
uuid                    sysutiluuid
throws standardexception
{
uuid routine_uuid   null
// void syscs_util.syscs_inplace_compress_table(
//     in schemaname        varchar(128),
//     in tablename         varchar(128),
//     in purge_rows        smallint,
//     in defragment_rows   smallint,
//     in truncate_end      smallint
//     )
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
typedescriptor smallint
typedescriptor smallint
typedescriptor smallint
routine_uuid   createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
}
/**
* create system procedures added in version 10.2.
* <p>
* create 10.2 system procedures, called by either code creating new
* database, or code doing hard upgrade from previous version.
* <p>
*
* @param tc booting transaction
* @param newlycreatedroutines set of routines we are creating (used to add permissions later on)
* @param sysutiluuid   uuid of the sysutil schema.
*
* @exception  standardexception  standard exception policy.
**/
void create_10_2_system_procedures
transactioncontroller   tc
hashset               newlycreatedroutines
uuid                    sysutiluuid
throws standardexception
{
// void syscs_util.syscs_backup_database_nowait(
//     in backupdir        varchar(limits.db2_varchar_maxwidth)
//     )
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
datatypedescriptor.getcatalogtype(
types varchar  limits db2_varchar_maxwidth
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// void
// syscs_util.syscs_backup_database_and_enable_log_archive_mode_nowait(
//   in backupdir                 varchar(limits.db2_varchar_maxwidth),
//   in delete_archived_log_files smallint
//   )
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
datatypedescriptor.getcatalogtype(
types varchar  limits db2_varchar_maxwidth
typedescriptor smallint
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlfunctions(varchar(128), varchar(128), varchar(128),
// varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
getsysibmschemadescriptor   getuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// sysibm.sqlfunctionparams(varchar(128), varchar(128),
// varchar(128), varchar(128), varchar(4000))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor getcatalogtype types varchar  4000
createsystemprocedureorfunction
getsysibmschemadescriptor   getuuid
arg_names
arg_types
0
1
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
}
/**
* create system procedures added in version 10.3.
* create 10.3 system procedures related to the lob methods ,
* called by either code creating new
* database, or code doing hard upgrade from previous version.
*
* @param tc            an instance of the transactioncontroller class.
* @param newlycreatedroutines set of routines we are creating (used to add permissions later on)
*
* @throws standardexception  standard exception policy.
**/
private void create_10_3_system_procedures_sysibm
transactioncontroller   tc
hashset               newlycreatedroutines
throws standardexception
//create 10.3 functions used by lob methods.
uuid schema_uuid   getsysibmschemadescriptor   getuuid
{
uuid routine_uuid   null
string arg_names   null
typedescriptor arg_types   null
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
typedescriptor integer
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
typedescriptor arg_types    typedescriptor integer
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false

newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
datatypedescriptor.getcatalogtype(
types varchar
datatypedescriptor.getcatalogtype(
types bigint
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types bigint
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
typedescriptor integer
datatypedescriptor.getcatalogtype(
types bigint
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types bigint
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types    typedescriptor integer
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types bigint
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
datatypedescriptor.getcatalogtype(
types bigint
typedescriptor integer
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types varchar
lobstoredprocedure max_clob_return_len
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
datatypedescriptor.getcatalogtype(
types bigint
typedescriptor integer
datatypedescriptor.getcatalogtype(
types varchar
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false

newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
datatypedescriptor.getcatalogtype(
types bigint
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false

newlycreatedroutines
tc
}
//now create the stored procedures required for blob
{
uuid routine_uuid   null
string arg_names   null
typedescriptor arg_types   null
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
typedescriptor integer
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
typedescriptor arg_types    typedescriptor integer
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false

newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
datatypedescriptor.getcatalogtype(
types varbinary
datatypedescriptor.getcatalogtype(
types bigint
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types bigint
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
typedescriptor integer
datatypedescriptor.getcatalogtype(
types bigint
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types bigint
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types bigint
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
datatypedescriptor.getcatalogtype(
types bigint
typedescriptor integer
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false
datatypedescriptor.getcatalogtype(
types varbinary
lobstoredprocedure max_blob_return_len
newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
datatypedescriptor.getcatalogtype(
types bigint
typedescriptor integer
datatypedescriptor.getcatalogtype(
types varbinary
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false

newlycreatedroutines
tc
}
{
uuid routine_uuid   null
string arg_names
// procedure argument types
typedescriptor arg_types
typedescriptor integer
datatypedescriptor.getcatalogtype(
types bigint
routine_uuid   createsystemprocedureorfunction
schema_uuid
arg_names
arg_types
0
0
routinealiasinfo contains_sql
false

newlycreatedroutines
tc
}
}
/**
* create the system procedures that are added to 10.5.
*
* @param tc an instance of the transactioncontroller.
* @param newlycreatedroutines set of routines we are creating (used to add permissions later on)
* @throws standardexception standard exception policy.
*/
void create_10_5_system_procedures transactioncontroller tc  hashset newlycreatedroutines
throws standardexception
{
// create the procedures in the syscs_util schema.
uuid  sysutiluuid   getsystemutilschemadescriptor   getuuid
// void syscs_util.syscs_update_statistics(varchar(128), varchar(128), varchar(128))
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
catalog_type_system_identifier
uuid routine_uuid   createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
}
/**
* create the system procedures that are added in 10.3.
*
* @param tc an instance of the transactioncontroller.
* @param newlycreatedroutines set of routines we are creating (used to add permissions later on)
* @throws standardexception standard exception policy.
*/
void create_10_3_system_procedures transactioncontroller tc  hashset newlycreatedroutines
throws standardexception
// create the procedures in the syscs_util schema.
create_10_3_system_procedures_syscs_util tc  newlycreatedroutines
//create the procedures in the sysibm schema
create_10_3_system_procedures_sysibm tc  newlycreatedroutines
}
/**
* create system procedures that are part of the
* syscs_util schema added in version 10.3.
* <p>
* create 10.3 system procedures, called by either code creating new
* database, or code doing hard upgrade from previous version.
* <p>
*
* @param tc an instance of the transaction controller.
* @param newlycreatedroutines set of routines we are creating (used to add permissions later on)
* @exception  standardexception  standard exception policy.
**/
void create_10_3_system_procedures_syscs_util  transactioncontroller   tc  hashset newlycreatedroutines
throws standardexception
{
uuid  sysutiluuid   getsystemutilschemadescriptor   getuuid
/* syscs_export_table_lobs_to_extfile(in schemaname  varchar(128),
* in tablename    varchar(128), in filename varchar(32672) ,
* in columndelimiter char(1),  in characterdelimiter char(1) ,
* in codeset varchar(128), in lobsfilename varchar(32672) )
*/
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor.getcatalogtype(
types varchar  32672
datatypedescriptor.getcatalogtype(
types char  1
datatypedescriptor.getcatalogtype(
types char  1
catalog_type_system_identifier
datatypedescriptor.getcatalogtype(
types varchar  32672
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
/* syscs_export_query_lobs_to_extfile(
* in selectstatement  varchar(32672),
* in filename varchar(32672) ,
* in columndelimiter char(1),  in characterdelimiter char(1) ,
* in codeset varchar(128), in lobsfilename varchar(32672))
*/
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
datatypedescriptor.getcatalogtype(
types varchar  32672
datatypedescriptor.getcatalogtype(
types varchar  32672
datatypedescriptor.getcatalogtype(
types char  1
datatypedescriptor.getcatalogtype(
types char  1
catalog_type_system_identifier
datatypedescriptor.getcatalogtype(
types varchar  32672
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo reads_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
/*  syscs_import_table_lobs_from_extfile(in schemaname varchar(128),
*  in tablename varchar(128),  in filename varchar(32762),
*  in columndelimiter char(1), in characterdelimiter  char(1),
*  in codeset varchar(128) , in  replace smallint)
*/
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor.getcatalogtype(
types varchar  32672
datatypedescriptor.getcatalogtype(
types char  1
datatypedescriptor.getcatalogtype(
types char  1
catalog_type_system_identifier
typedescriptor smallint
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
/*  syscs_import_data_lobs_from_extfile(in schemaname varchar(128),
*  in tablename varchar(128), in insertcolumnlist varchar(32762),
*  in columnindexes varchar(32762), in in filename varchar(32762),
*  in columndelimiter char(1), in characterdelimiter  char(1),
*  in codeset varchar(128) , in  replace smallint)
*/
{
// procedure argument names
string arg_names
// procedure argument types
typedescriptor arg_types
catalog_type_system_identifier
catalog_type_system_identifier
datatypedescriptor.getcatalogtype(
types varchar  32672
datatypedescriptor.getcatalogtype(
types varchar  32672
datatypedescriptor.getcatalogtype(
types varchar  32672
datatypedescriptor.getcatalogtype(
types char  1
datatypedescriptor.getcatalogtype(
types char  1
catalog_type_system_identifier
typedescriptor smallint
createsystemprocedureorfunction
sysutiluuid
arg_names
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_reload_security_policy()
{
createsystemprocedureorfunction
sysutiluuid


0
0
routinealiasinfo no_sql
false
typedescriptor  null
newlycreatedroutines
tc
}
// void syscs_util.syscs_set_user_access(user_name varchar(128),
// connection_permission varchar(128))
{
typedescriptor arg_types    catalog_type_system_identifier  catalog_type_system_identifier
createsystemprocedureorfunction
sysutiluuid
new string
arg_types
0
0
routinealiasinfo modifies_sql_data
false
typedescriptor  null
newlycreatedroutines
tc
}
// varchar(128) syscs_util.syscs_set_user_access(user_name varchar(128))
{
typedescriptor arg_types     catalog_type_system_identifier
createsystemprocedureorfunction
sysutiluuid
new string
arg_types
0
0
routinealiasinfo reads_sql_data
false
catalog_type_system_identifier
newlycreatedroutines
tc
}
// void syscs_util.syscs_empty_statement_cache()
{
createsystemprocedureorfunction
sysutiluuid
string  null
typedescriptor  null
0
0
routinealiasinfo no_sql
false
typedescriptor  null
newlycreatedroutines
tc
}
}
/*
** priv block code to load net work server meta data queries.
*/
private string spsset
private final synchronized properties getquerydescriptions boolean net
spsset   net ?
return  properties  java security accesscontroller doprivileged this
}
public final object run
// security permission - ip3
properties p   new properties
try
// security permission - ip3
inputstream is   getclass   getresourceasstream spsset
p load is
is close
catch  ioexception ioe
return p
}
private static list newslist
return java util collections synchronizedlist new java util linkedlist
}
/**
* get one user's privileges on a table
*
* @param tableuuid
* @param authorizationid the user name
*
* @return a tablepermsdescriptor or null if the user has no permissions on the table.
*
* @exception standardexception
*/
public tablepermsdescriptor gettablepermissions  uuid tableuuid  string authorizationid
throws standardexception
{
tablepermsdescriptor key   new tablepermsdescriptor  this  authorizationid   string  null  tableuuid
return  tablepermsdescriptor  getpermissions  key
end of gettablepermissions
/* @see org.apache.derby.iapi.sql.dictionary.datadictionary#gettablepermissions */
public tablepermsdescriptor gettablepermissions  uuid tablepermsuuid
throws standardexception
{
tablepermsdescriptor key   new tablepermsdescriptor  this  tablepermsuuid
return getuncachedtablepermsdescriptor  key
}
private object getpermissions  permissionsdescriptor key  throws standardexception
{
// resolve get a read committed (shared) lock on the permission row
cacheable entry   getpermissionscache   find  key
if  entry    null
return null
object perms   entry getidentity
getpermissionscache   release  entry
return perms
}
/* @see org.apache.derby.iapi.sql.dictionary.datadictionary#getcolumnpermissions */
public colpermsdescriptor getcolumnpermissions  uuid colpermsuuid
throws standardexception
{
colpermsdescriptor key   new colpermsdescriptor  this  colpermsuuid
return getuncachedcolpermsdescriptor  key
}
/**
* get one user's column privileges for a table.
*
* @param tableuuid
* @param privtype (as int) authorizer.select_priv, authorizer.update_priv, or authorizer.references_priv
* @param forgrant
* @param authorizationid the user name
*
* @return a colpermsdescriptor or null if the user has no separate column
*         permissions of the specified type on the table. note that the user may have been granted
*         permission on all the columns of the table (no column list), in which case this routine
*         will return null. you must also call gettablepermissions to see if the user has permission
*         on a set of columns.
*
* @exception standardexception
*/
public colpermsdescriptor getcolumnpermissions  uuid tableuuid
int privtype
boolean forgrant
string authorizationid
throws standardexception
{
string privtypestr   forgrant ? colprivtypemapforgrant   colprivtypemap
if  sanitymanager debug
sanitymanager assert  privtypestr    null
privtype
colpermsdescriptor key   new colpermsdescriptor  this
authorizationid
string  null
tableuuid
privtypestr
return  colpermsdescriptor  getpermissions  key
end of getcolumnpermissions
/**
* get one user's column privileges for a table. this routine gets called
* during revoke privilege processing
*
* @param tableuuid
* @param privtypestr (as string) authorizer.select_priv, authorizer.update_priv, or authorizer.references_priv
* @param forgrant
* @param authorizationid the user name
*
* @return a colpermsdescriptor or null if the user has no separate column
*         permissions of the specified type on the table. note that the user may have been granted
*         permission on all the columns of the table (no column list), in which case this routine
*         will return null. you must also call gettablepermissions to see if the user has permission
*         on a set of columns.
*
* @exception standardexception
*/
public colpermsdescriptor getcolumnpermissions  uuid tableuuid
string privtypestr
boolean forgrant
string authorizationid
throws standardexception
{
colpermsdescriptor key   new colpermsdescriptor  this
authorizationid
string  null
tableuuid
privtypestr
return  colpermsdescriptor  getpermissions  key
}
private static final string colprivtypemap
private static final string colprivtypemapforgrant
static
colprivtypemap   new string
colprivtypemapforgrant   new string
colprivtypemap
colprivtypemapforgrant
colprivtypemap
colprivtypemapforgrant
colprivtypemap
colprivtypemapforgrant
}
/**
* get one user's permissions for a routine (function or procedure).
*
* @param routineuuid
* @param authorizationid the user's name
*
* @return the descriptor of the users permissions for the routine.
*
* @exception standardexception
*/
public routinepermsdescriptor getroutinepermissions  uuid routineuuid  string authorizationid
throws standardexception
{
routinepermsdescriptor key   new routinepermsdescriptor  this  authorizationid   string  null  routineuuid
return  routinepermsdescriptor  getpermissions  key
end of getroutinepermissions
/* @see org.apache.derby.iapi.sql.dictionary.datadictionary#getroutinepermissions */
public routinepermsdescriptor getroutinepermissions  uuid routinepermsuuid
throws standardexception
{
routinepermsdescriptor key   new routinepermsdescriptor  this  routinepermsuuid
return getuncachedroutinepermsdescriptor  key
}
/**
* add or remove a permission to/from the permission database.
*
* @param add if true then the permission is added, if false the permission is removed
* @param perm
* @param grantee
* @param tc
*
* @return true means revoke has removed a privilege from system
* table and hence the caller of this method should send invalidation
* actions to permssiondescriptor's dependents.
*/
public boolean addremovepermissionsdescriptor  boolean add
permissionsdescriptor perm
string grantee
transactioncontroller tc
throws standardexception
{
int catalognumber   perm getcatalognumber
// it is possible for grant statements to look like following
//   grant execute on function f_abs to mamata2, mamata3;
//   grant all privileges on t11 to mamata2, mamata3;
// this means that dd.addremovepermissionsdescriptor will be called
// twice for tablepermsdescriptor and twice for routinepermsdescriptor,
// once for each grantee.
// first it's called for mamta2. when a row is inserted for mamta2
// into the correct system table for the permission descriptor, the
// permission descriptor's uuid gets populated with the uuid of
// the row that just got inserted into the system table for mamta2
// now, when dd.addremovepermissionsdescriptor gets called again for
// mamta3, the permission descriptor's uuid will still be set to
// the uuid that was used for mamta2. if we do not reset the
// uuid to null, we will think that there is a duplicate row getting
// inserted for the same uuid. in order to get around this, we should
// reset the uuid of passed permissiondescriptor everytime this method
// is called. this way, there will be no leftover values from previous
// call of this method.
perm setuuid null
perm setgrantee  grantee
tabinfoimpl ti   getnoncoreti  catalognumber
permissionscatalogrowfactory rf    permissionscatalogrowfactory  ti getcatalogrowfactory
int primaryindexnumber   rf getprimarykeyindexnumber
conglomeratecontroller heapcc   tc openconglomerate  ti getheapconglomerate
false      do not keep open across commits
0
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
rowlocation rl   null
try
{
rl   heapcc newrowlocationtemplate
}
finally
{
heapcc close
heapcc   null
}
execindexrow key   rf buildindexkeyrow  primaryindexnumber  perm
execrow existingrow   ti getrow  tc  key  primaryindexnumber
if  existingrow    null
{
if    add
//we didn't find an entry in system catalog and this is revoke
//so that means there is nothing to revoke. simply return.
//no need to reset permission descriptor's uuid because
//no row was ever found in system catalog for the given
//permission and hence uuid can't be non-null
return false
//we didn't find an entry in system catalog and this is grant so
//so that means we have to enter a new row in system catalog for
//this grant.
execrow row   ti getcatalogrowfactory   makerow  perm   tupledescriptor  null
int insertretcode   ti insertrow row  tc
if  sanitymanager debug
sanitymanager assert  insertretcode    tabinfoimpl rownotduplicate
}
else
{
// add/remove these permissions to/from the existing permissions
boolean colschanged   new boolean
boolean indicestoupdate   new boolean
int changedcolcount   0
if  add
changedcolcount   rf orpermissions  existingrow  perm  colschanged
else
changedcolcount   rf removepermissions  existingrow  perm  colschanged
if  changedcolcount    0
{
//grant/revoke privilege didn't change anything and hence
//just return
return false
}
if   add
{
//set the uuid of the passed permission descriptor to
//corresponding rows's uuid in permissions system table. the
//permission descriptor's uuid is required to have the
//dependency manager send the revoke privilege action to
//all the dependent objects on that permission descriptor.
rf setuuidofthepasseddescriptor existingrow  perm
}
if  changedcolcount < 0
{
// no permissions left in the current row
ti deleterow  tc  key  primaryindexnumber
}
else if  changedcolcount > 0
{
int colstoupdate   new int
changedcolcount   0
for  int i   0  i < colschanged length  i
{
if  colschanged
colstoupdate   i   1
}
if  sanitymanager debug
sanitymanager assert
changedcolcount    colstoupdate length
rf getclass   getname
ti updaterow key  existingrow  primaryindexnumber
indicestoupdate  colstoupdate  tc
}
}
// remove cached permissions data. the cache may hold permissions data for this key even if
// the row in the permissions table is new. in that case the cache may have an entry indicating no
// permissions
removepermentryincache perm
//if we are dealing with grant, then the caller does not need to send
//any invalidation actions to anyone and hence return false
if  add
return false
return true
end of addpermissionsdescriptor
/**
* get a table permissions descriptor from the system tables, without going through the cache.
* this method is called to fill the permissions cache.
*
* @return a tablepermsdescriptor that describes the table permissions granted to the grantee, null
*          if no table-level permissions have been granted to him on the table.
*
* @exception standardexception
*/
tablepermsdescriptor getuncachedtablepermsdescriptor  tablepermsdescriptor key
throws standardexception
{
if  key getobjectid      null
{
//the tablepermsid for systableperms is not known, so use
//table id, grantor and granteee to find tablepermsdescriptor
return  tablepermsdescriptor
getuncachedpermissionsdescriptor  systableperms_catalog_num
systablepermsrowfactory grantee_table_grantor_index_num
key
else
{
//we know the tablepermsid for systableperms, so use that to
//find tablepermsdescriptor from the sytem table
return  tablepermsdescriptor
getuncachedpermissionsdescriptor systableperms_catalog_num
systablepermsrowfactory tablepermsid_index_num key
}
end of getuncachedtablepermsdescriptor
/**
* get a column permissions descriptor from the system tables, without going through the cache.
* this method is called to fill the permissions cache.
*
*
* @return a colpermsdescriptor that describes the column permissions granted to the grantee, null
*          if no column permissions have been granted to him on the table.
*
* @exception standardexception
*/
colpermsdescriptor getuncachedcolpermsdescriptor  colpermsdescriptor key
throws standardexception
{
if  key getobjectid      null
{
//the colpermsid for syscolperms is not known, so use tableid,
//privilege type, grantor and granteee to find colpermsdescriptor
return  colpermsdescriptor
getuncachedpermissionsdescriptor  syscolperms_catalog_num
syscolpermsrowfactory grantee_table_type_grantor_index_num
key
else
{
//we know the colpermsid for syscolperms, so use that to
//find colpermsdescriptor from the sytem table
return  colpermsdescriptor
getuncachedpermissionsdescriptor  syscolperms_catalog_num
syscolpermsrowfactory colpermsid_index_num
key
}
end of getuncachedcolpermsdescriptor
private tupledescriptor getuncachedpermissionsdescriptor  int catalognumber
int indexnumber
permissionsdescriptor key
throws standardexception
{
tabinfoimpl ti   getnoncoreti  catalognumber
permissionscatalogrowfactory rowfactory    permissionscatalogrowfactory  ti getcatalogrowfactory
execindexrow keyrow   rowfactory buildindexkeyrow  indexnumber  key
return
getdescriptorviaindex  indexnumber
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
end of getuncachedpermissionsdescriptor
/**
* get a routine permissions descriptor from the system tables, without going through the cache.
* this method is called to fill the permissions cache.
*
* @return a routinepermsdescriptor that describes the table permissions granted to the grantee, null
*          if no table-level permissions have been granted to him on the table.
*
* @exception standardexception
*/
routinepermsdescriptor getuncachedroutinepermsdescriptor  routinepermsdescriptor key
throws standardexception
{
if  key getobjectid      null
{
//the routinepermsid for sysroutineperms is not known, so use aliasid,
//grantor and granteee to find routinepermsdescriptor
return  routinepermsdescriptor
getuncachedpermissionsdescriptor  sysroutineperms_catalog_num
sysroutinepermsrowfactory grantee_alias_grantor_index_num
key
else
{
//we know the routinepermsid for sysroutineperms, so use that to
//find routinepermsdescriptor from the sytem table
return  routinepermsdescriptor
getuncachedpermissionsdescriptor sysroutineperms_catalog_num
sysroutinepermsrowfactory routinepermsid_index_num key
}
end of getuncachedroutinepermsdescriptor
private string diag_vti_table_classes
{
private string diag_vti_table_function_classes
{
/**
* @see datadictionary#getvticlass(tabledescriptor, boolean)
*/
public string getvticlass tabledescriptor td  boolean astablefunction
throws standardexception
{
if  schemadescriptor std_system_diag_schema_name equals
td getschemaname
return getbuiltinvticlass  td  astablefunction
else    see if it's a user defined table function
{
string                          schemaname   td getschemaname
string                          functionname   td getdescriptorname
schemadescriptor     sd   getschemadescriptor  td getschemaname    null  true
if   sd    null
{
aliasdescriptor         ad   getaliasdescriptor  sd getuuid   tostring    functionname  aliasinfo alias_type_function_as_char
if    ad    null     ad istablefunction       return ad getjavaclassname
throw standardexception newexception
sqlstate lang_not_table_function  schemaname  functionname
}
}
return null
}
/**
* @see datadictionary#getbuiltinvticlass(tabledescriptor, boolean)
*/
public string getbuiltinvticlass tabledescriptor td  boolean astablefunction
throws standardexception
{
if  sanitymanager debug
{
if  td gettabletype      tabledescriptor vti_type
sanitymanager throwassert     td
}
/* first check to see if this is a system vti. note that if no schema was specified then the
* call to "td.getschemaname()" will return the current schema.
*/
if  schemadescriptor std_system_diag_schema_name equals
td getschemaname
{
string  vtimappings   astablefunction
? diag_vti_table_function_classes
diag_vti_table_classes
for  int i   0  i < vtimappings length  i
{
string entry   vtimappings
if  entry equals td getdescriptorname
return entry
}
}
return null
}
/**
* @see datadictionary#getrolegrantdescriptor(uuid)
*/
public rolegrantdescriptor getrolegrantdescriptor uuid uuid
throws standardexception
{
datavaluedescriptor uuidstringorderable
tabinfoimpl ti   getnoncoreti sysroles_catalog_num
/* use uuidstringorderable in both start and stop position for
* scan.
*/
uuidstringorderable   getidvalueaschar uuid
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 1
keyrow setcolumn 1  uuidstringorderable
return  rolegrantdescriptor
getdescriptorviaindex
sysrolesrowfactory sysroles_index_uuid_idx
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* get the target role definition by searching for a matching row
* in sysroles by rolename where isdef==true.  read only scan.
* uses index on (rolename, isdef) columns.
*
* @param rolename the name of the role we're interested in.
*
* @return the descriptor (row) for the role
* @exception standardexception thrown on error
*
* @see datadictionary#getroledefinitiondescriptor
*/
public rolegrantdescriptor getroledefinitiondescriptor string rolename
throws standardexception
{
datavaluedescriptor rolenameorderable
datavaluedescriptor isdeforderable
tabinfoimpl ti   getnoncoreti sysroles_catalog_num
/* use aliasnameorderable , isdeforderable in both start
* and stop position for scan.
*/
rolenameorderable   new sqlvarchar rolename
isdeforderable   new sqlvarchar
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 2
keyrow setcolumn 1  rolenameorderable
keyrow setcolumn 2  isdeforderable
return  rolegrantdescriptor
getdescriptorviaindex
sysrolesrowfactory sysroles_index_id_def_idx
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* get the target role by searching for a matching row
* in sysroles by rolename, grantee and grantor.  read only scan.
* uses index on roleid, grantee and grantor columns.
*
* @param rolename	    the name of the role we're interested in.
* @param grantee       the grantee
* @param grantor       the grantor
*
* @return	            the descriptor for the role grant
*
* @exception standardexception  thrown on error
*
* @see datadictionary#getrolegrantdescriptor(string, string, string)
*/
public rolegrantdescriptor getrolegrantdescriptor string rolename
string grantee
string grantor
throws standardexception
{
datavaluedescriptor rolenameorderable
datavaluedescriptor granteeorderable
datavaluedescriptor grantororderable
tabinfoimpl ti   getnoncoreti sysroles_catalog_num
/* use aliasnameorderable, granteeorderable and
* grantororderable in both start and stop position for scan.
*/
rolenameorderable   new sqlvarchar rolename
granteeorderable   new sqlvarchar grantee
grantororderable   new sqlvarchar grantor
/* set up the start/stop position for the scan */
execindexrow keyrow   exfactory getindexablerow 3
keyrow setcolumn 1  rolenameorderable
keyrow setcolumn 2  granteeorderable
keyrow setcolumn 3  grantororderable
return  rolegrantdescriptor
getdescriptorviaindex
sysrolesrowfactory sysroles_index_id_ee_or_idx
keyrow
scanqualifier   null
ti
tupledescriptor  null
list  null
false
}
/**
* check all dictionary tables and return true if there is any grant
* descriptor containing <code>authid</code> as its grantee.
*
* @param authid grantee for which a grant exists or not
* @param tc transactioncontroller for the transaction
* @return boolean true if such a grant exists
*/
public boolean existsgranttoauthid string authid
transactioncontroller tc
throws standardexception
return
existspermbygrantee
authid
tc
systableperms_catalog_num
systablepermsrowfactory grantee_table_grantor_index_num
systablepermsrowfactory
grantee_col_num_in_grantee_table_grantor_index
existspermbygrantee
authid
tc
syscolperms_catalog_num
syscolpermsrowfactory grantee_table_type_grantor_index_num
syscolpermsrowfactory
grantee_col_num_in_grantee_table_type_grantor_index
existspermbygrantee
authid
tc
sysroutineperms_catalog_num
sysroutinepermsrowfactory grantee_alias_grantor_index_num
sysroutinepermsrowfactory
grantee_col_num_in_grantee_alias_grantor_index
existsrolegrantbygrantee authid  tc
}
/**
* remove metadata stored prepared statements.
* @param tc the xact
*
*
*/
private void dropjdbcmetadataspses transactioncontroller tc  throws standardexception
{
for  java util iterator it   getallspsdescriptors   iterator    it hasnext
{
spsdescriptor spsd    spsdescriptor  it next
schemadescriptor sd   spsd getschemadescriptor
// don't drop statements in non-system schemas
if   sd issystemschema
continue
}
dropspsdescriptor spsd  tc
dropdependentsstoreddependencies spsd getuuid                                                                                                                 tc
}
}
/**
* drop and recreate metadata stored prepared statements.
*
* @param tc the xact
* @throws standardexception
*/
public void updatemetadataspses transactioncontroller tc  throws standardexception
dropjdbcmetadataspses tc
createsystemsps tc
}
}