/*
derby - class org.apache.derby.iapi.types.sqlclob
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi types
import org apache derby iapi error standardexception
import org apache derby iapi jdbc characterstreamdescriptor
import org apache derby iapi services io arrayinputstream
import org apache derby iapi services io inputstreamutil
import org apache derby iapi services io storedformatids
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi util utf8util
import org apache derby shared common reference sqlstate
import java io ioexception
import java io inputstream
import java io objectinput
import java io objectoutput
import java sql clob
import java sql date
import java sql sqlexception
import java sql time
import java sql timestamp
import java text rulebasedcollator
import java util calendar
/**
* sqlclob represents a clob value with ucs_basic collation.
* clob supports like operator only for collation.
*/
public class sqlclob
extends sqlvarchar
/** the maximum number of bytes used by the stream header. */
private static final int max_stream_header_length   5
/** the header generator used for 10.4 (or older) databases. */
private static final streamheadergenerator ten_four_clob_header_generator
new clobstreamheadergenerator true
/** the header generator used for 10.5 databases. */
private static final streamheadergenerator ten_five_clob_header_generator
new clobstreamheadergenerator false
/**
* the descriptor for the stream. if there is no stream this should be
* {@code null}, which is also true if the descriptor hasen't been
* constructed yet.
* <em>note</em>: always check if {@code stream} is non-null before using
* the information stored in the descriptor internally.
*/
private characterstreamdescriptor csd
/** tells if the database is being accessed in soft upgrade mode. */
private boolean insoftupgrademode   null
/*
* datavaluedescriptor interface.
*
* these are actually all implemented in the super-class, but we need
* to duplicate some of them here so they can be called by byte-code
* generation, which needs to know the class the method appears in.
*/
public string gettypename
return typeid clob_name
/*
* datavaluedescriptor interface
*/
/** @see datavaluedescriptor#getclone */
public datavaluedescriptor getclone
// todo: should this be rewritten to clone the stream instead of
//       materializing the value if possible?
try
return new sqlclob getstring
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert    se
return null
/**
* @see datavaluedescriptor#getnewnull
*
*/
public datavaluedescriptor getnewnull
return new sqlclob
/** @see stringdatavalue#getvalue(rulebasedcollator) */
public stringdatavalue getvalue rulebasedcollator collatorforcomparison
if  collatorforcomparison    null
null collatorforcomparison means use ucs_basic for collation
return this
else
//non-null collatorforcomparison means use collator sensitive
//implementation of sqlclob
collatorsqlclob s   new collatorsqlclob collatorforcomparison
s copystate this
return s
/*
* storable interface, implies externalizable, typedformat
*/
/**
return my format identifier.
@see org.apache.derby.iapi.services.io.typedformat#gettypeformatid
*/
public int gettypeformatid
return storedformatids sql_clob_id
/*
* constructors
*/
public sqlclob
public sqlclob string val
super val
public sqlclob clob val
super val
/*
* datavaluedescriptor interface
*/
/* @see datavaluedescriptor#typeprecedence */
public int typeprecedence
return typeid clob_precedence
/*
** disable conversions to/from most types for clob.
** temp - real fix is to re-work class hierachy so
** that clob is towards the root, not at the leaf.
*/
public boolean	getboolean   throws standardexception
throw datatypeconversion
public byte	getbyte   throws standardexception
throw datatypeconversion
public short	getshort   throws standardexception
throw datatypeconversion
public int	getint   throws standardexception
throw datatypeconversion
/**
* returns the character length of this clob.
* <p>
* if the value is stored as a stream, the stream header will be read. if
* the stream header doesn't contain the stream length, the whole stream
* will be decoded to determine the length.
*
* @return the character length of this clob.
* @throws standardexception if obtaining the length fails
*/
public int getlength   throws standardexception
if  stream    null
return super getlength
// the clob is represented as a stream.
// make sure we have a stream descriptor.
boolean repositionstream    csd    null
if  csd    null
getstreamwithdescriptor
// we know the stream is at the first char position here.
if  csd getcharlength      0
return  int csd getcharlength
// we now know that the clob is represented as a stream, but not if the
// length is unknown or actually zero. check.
if  sanitymanager debug
// the stream isn't expecetd to be position aware here.
sanitymanager assert  csd ispositionaware
long charlength   0
try
if  repositionstream
rewindstream csd getdataoffset
charlength   utf8util skipuntileof stream
// we just drained the whole stream. reset it.
rewindstream 0
catch  ioexception ioe
throwstreamingioexception ioe
// update the descriptor in two ways;
//   (1) set the char length, whether it is zero or not.
//   (2) set the current byte pos to zero.
csd   new characterstreamdescriptor builder   copystate csd
charlength charlength  curbytepos 0
curcharpos characterstreamdescriptor before_first  build
return  int charlength
public long	getlong   throws standardexception
throw datatypeconversion
public float	getfloat   throws standardexception
throw datatypeconversion
public double	getdouble   throws standardexception
throw datatypeconversion
public int typetobigdecimal   throws standardexception
throw datatypeconversion
public byte	getbytes   throws standardexception
throw datatypeconversion
public date	getdate java util calendar cal  throws standardexception
throw datatypeconversion
/**
* returns a descriptor for the input stream for this clob value.
* <p>
* the descriptor contains information about header data, current positions,
* length, whether the stream should be buffered or not, and if the stream
* is capable of repositioning itself.
* <p>
* when this method returns, the stream is positioned on the first
* character position, such that the next read will return the first
* character in the stream.
*
* @return a descriptor for the stream, which includes a reference to the
*      stream itself. if the value cannot be represented as a stream,
*      {@code null} is returned instead of a decsriptor.
* @throws standardexception if obtaining the descriptor fails
*/
public characterstreamdescriptor getstreamwithdescriptor
throws standardexception
if  stream    null
// lazily reset the descriptor here, to avoid further changes in
// {@code sqlchar}.
csd   null
return null
// note: getting down here several times is potentially dangerous.
// when the stream is published, we can't assume we know the position
// any more. the best we can do, which may hurt performance to some
// degree in some non-recommended use-cases, is to reset the stream if
// possible.
if  csd    null
if  stream instanceof resetable
try
resetable stream  resetstream
// make sure the stream is in sync with the descriptor.
inputstreamutil skipfully stream  csd getcurbytepos
catch  ioexception ioe
throwstreamingioexception ioe
else
if  sanitymanager debug
sanitymanager throwassert
stream getclass
if  csd    null
// first time, read the header format of the stream.
try
// assume new header format, adjust later if necessary.
byte header   new byte
int read   stream read header
// expect at least two header bytes.
if  sanitymanager debug
sanitymanager assert read > 1
read
headerinfo hdrinfo   investigateheader header  read
if  read > hdrinfo headerlength
// we have read too much. reset the stream.
read   hdrinfo headerlength
rewindstream read
csd   new characterstreamdescriptor builder   stream stream
bufferable false  positionaware false
curcharpos read    0 ?
characterstreamdescriptor before_first   1
curbytepos read
dataoffset hdrinfo headerlength
bytelength hdrinfo bytelength
charlength hdrinfo charlength    build
catch  ioexception ioe
// check here to see if the root cause is a container closed
// exception. if so, this most likely means that the clob was
// accessed after a commit or rollback on the connection.
throwable rootcause   ioe
while  rootcause getcause      null
rootcause   rootcause getcause
if  rootcause instanceof standardexception
standardexception se    standardexception rootcause
if  se getmessageid   equals
sqlstate data_container_closed
throw standardexception newexception
sqlstate blob_accessed_after_commit  ioe
throwstreamingioexception ioe
return this csd
public time	gettime java util calendar cal  throws standardexception
throw datatypeconversion
public timestamp	gettimestamp java util calendar cal  throws standardexception
throw datatypeconversion
/**
* gets a trace representation of the clob for debugging.
*
* @return a trace representation of the clob.
*/
public final string gettracestring   throws standardexception
// check if the value is sql null.
if  isnull
return
// check if we have a stream.
if  getstream      null
return  gettypename         getstream   tostring
return  gettypename         getlength
/**
* normalization method - this method may be called when putting
* a value into a sqlclob, for example, when inserting into a sqlclob
* column.  see normalizeresultset in execution.
* per the sql standard ,if the clob column is not big enough to
* hold the value being inserted,truncation error will result
* if there are trailing non-blanks. truncation of trailing blanks
* is allowed.
* @param desiredtype   the type to normalize the source column to
* @param sourcevalue   the value to normalize
*
*
* @exception standardexception             thrown for null into
*                                          non-nullable column, and for
*                                          truncation error
*/
public void normalize
datatypedescriptor desiredtype
datavaluedescriptor sourcevalue
throws standardexception
// if sourcevalue is of type clob, and has a stream,
// dont materialize it here (as the goal of using a stream is to
// not have to materialize whole object in memory in the server),
// but instead truncation checks will be done when data is streamed in.
// (see readertoutf8stream)
// if sourcevalue is not a stream, then follow the same
// protocol as varchar type for normalization
if  sourcevalue instanceof sqlclob
sqlclob clob    sqlclob sourcevalue
if  clob stream    null
copystate clob
return
super normalize desiredtype sourcevalue
public void setvalue time thevalue  calendar cal  throws standardexception
throwlangsetmismatch
public void setvalue timestamp thevalue  calendar cal  throws standardexception
throwlangsetmismatch
public void setvalue date thevalue  calendar cal  throws standardexception
throwlangsetmismatch
public void setbigdecimal number bigdecimal  throws standardexception
throwlangsetmismatch
/**
* sets a new stream for this clob.
*
* @param stream the new stream
*/
public final void setstream inputstream stream
super setstream stream
// discard the old stream descriptor.
this csd   null
public final void restoretonull
this csd   null
super restoretonull
public void setvalue int thevalue  throws standardexception
throwlangsetmismatch
public void setvalue double thevalue  throws standardexception
throwlangsetmismatch
public void setvalue float thevalue  throws standardexception
throwlangsetmismatch
public void setvalue short thevalue  throws standardexception
throwlangsetmismatch
public void setvalue long thevalue  throws standardexception
throwlangsetmismatch
public void setvalue byte thevalue  throws standardexception
throwlangsetmismatch
public void setvalue boolean thevalue  throws standardexception
throwlangsetmismatch
public void setvalue byte thevalue  throws standardexception
throwlangsetmismatch
/**
* set the value from an non-null java.sql.clob object.
*/
final void setobject object thevalue
throws standardexception
clob vc    clob  thevalue
try
long vcl   vc length
if  vcl < 0l    vcl > integer max_value
throw this outofrange
// for small values, just materialize the value.
// note: using streams for the empty string ("") isn't supported
// down this code path when in soft upgrade mode, because the code
// reading the header bytes ends up reading zero bytes (i.e., it
// doesn't get the header / eof marker).
if  vcl < 32 1024
setvalue vc getsubstring 1   int vcl
else
readertoutf8stream utfin   new readertoutf8stream
vc getcharacterstream     int  vcl  0  typeid clob_name
getstreamheadergenerator
setvalue utfin   int  vcl
catch  sqlexception e
throw datatypeconversion
/**
* writes the clob data value to the given destination stream using the
* modified utf-8 format.
*
* @param out destination stream
* @throws ioexception if writing to the destination stream fails
*/
public void writeexternal objectoutput out
throws ioexception
super writeclobutf out
/**
* returns a stream header generator for a clob.
* <p>
* <em>note</em>: to guarantee a successful generation, one of the following
* two conditions must be met at header or eof generation time:
* <ul> <li>{@code setsoftupgrademode} has been invoked before the header
*          generator was obtained.</li>
*      <li>there is context at generation time, such that the mode can be
*          determined by obtaining the database context and by consulting
*          the data dictionary.</li>
* </ul>
*
* @return a stream header generator.
*/
public streamheadergenerator getstreamheadergenerator
if  insoftupgrademode    null
// we don't know which mode we are running in, return a generator
// the will check this when asked to generate the header.
return new clobstreamheadergenerator this
else
if  insoftupgrademode    boolean true
return ten_four_clob_header_generator
else
return ten_five_clob_header_generator
/**
* tells whether the database is being accessed in soft upgrade mode or not.
*
* @param insoftupgrademode {@code true} if the database is accessed in
*      soft upgrade mode, {@code false} is not, or {@code null} if unknown
*/
public void setsoftupgrademode boolean insoftupgrademode
this insoftupgrademode   insoftupgrademode
/**
* investigates the header and returns length information.
*
* @param hdr the raw header bytes
* @param bytesread number of bytes written into the raw header bytes array
* @return the information obtained from the header.
* @throws ioexception if the header format is invalid, or the stream
*      seems to have been corrupted
*/
private headerinfo investigateheader byte hdr  int bytesread
throws ioexception
int dataoffset   max_stream_header_length
int utflen    1
int strlen    1
// peek at the magic byte.
if  bytesread < dataoffset     hdr   0xf0     0xf0
// we either have a very short value with the old header
// format, or the stream is corrupted.
// assume the former and check later (see further down).
dataoffset   2
// do we have a pre 10.5 header?
if  dataoffset    2
// note that we add the two bytes holding the header to the total
// length only if we know how long the user data is.
utflen     hdr   0xff  << 8      hdr   0xff
// sanity check for small streams:
// the header length pluss the encoded length must be equal to the
// number of bytes read.
if  bytesread < max_stream_header_length
if  dataoffset   utflen    bytesread
throw new ioexception
dataoffset       utflen
bytesread
if  utflen > 0
utflen    dataoffset
else if  dataoffset    5
// we are dealing with the 10.5 stream header format.
int hdrformat   hdr   0x0f
switch  hdrformat
case 0     0xf0
strlen
hdr   0xff  << 24
hdr   0xff  << 16
// ignore the third byte (index 2).
hdr   0xff  <<  8
hdr   0xff  <<  0
break
default
// we don't know how to handle this header format.
throw new ioexception
hdrformat
integer tohexstring hdr   0xff
if  sanitymanager debug
sanitymanager assert utflen >  1    strlen >  1
return new headerinfo dataoffset  dataoffset    5 ? strlen   utflen
/**
* reads and materializes the clob value from the stream.
*
* @param in source stream
* @throws java.io.utfdataformatexception if an encoding error is detected
* @throws ioexception if reading from the stream fails, or the content of
*      the stream header is invalid
*/
public void readexternal objectinput in
throws ioexception
headerinfo hdrinfo
if  csd    null
int hdrlen    int csd getdataoffset
int valuelength    hdrlen    5  ?  int csd getcharlength
int csd getbytelength
hdrinfo   new headerinfo hdrlen  valuelength
// make sure the stream is correctly positioned.
rewindstream hdrlen
else
final boolean markset   stream marksupported
if  markset
stream mark max_stream_header_length
byte header   new byte
int read   in read header
// expect at least two header bytes.
if  sanitymanager debug
sanitymanager assert read > 1      read
hdrinfo   investigateheader header  read
if  read > hdrinfo headerlength
// we read too much data, reset and position on the first byte
// of the user data.
// first see if we set a mark on the stream and can reset it.
// if not, try using the resetable interface.
if  markset
// stream is not a store resetable one, use mark/reset
// functionality instead.
stream reset
inputstreamutil skipfully stream  hdrinfo headerlength
else if  stream instanceof resetable
// we have a store stream.
rewindstream hdrinfo headerlength
// the data will be materialized in memory, in a char array.
// subtract the header length from the byte length if there is a byte
// encoded in the header, otherwise the decode routine will try to read
// too many bytes.
int bytelength   0     zero is interpreted as unknown   unset
if  hdrinfo bytelength      0
bytelength   hdrinfo bytelength     hdrinfo headerlength
super readexternal in  bytelength  hdrinfo charlength
/**
* reads and materializes the clob value from the stream.
*
* @param in source stream
* @throws java.io.utfdataformatexception if an encoding error is detected
* @throws ioexception if reading from the stream fails, or the content of
*      the stream header is invalid
*/
public void readexternalfromarray arrayinputstream in
throws ioexception
// it is expected that the position of the array input stream has been
// set to the correct position before this method is invoked.
int prevpos   in getposition
byte header   new byte
int read   in read header
// expect at least two header bytes.
if  sanitymanager debug
sanitymanager assert read > 1      read
headerinfo hdrinfo   investigateheader header  read
if  read > hdrinfo headerlength
// reset stream. this path will only be taken for clobs stored
// with the pre 10.5 stream header format.
// note that we set the position to before the header again, since
// we know the header will be read again.
in setposition prevpos
super readexternalfromarray in
else
// we read only header bytes, next byte is user data.
super readexternalclobfromarray in  hdrinfo charlength
/**
* rewinds the stream to the beginning and then skips the specified number
* of bytes.
*
* @param pos number of bytes to skip
* @throws ioexception if resetting or reading from the stream fails
*/
private void rewindstream long pos
throws ioexception
try
resetable stream  resetstream
inputstreamutil skipfully stream  pos
catch  standardexception se
ioexception ioe   new ioexception se getmessage
ioe initcause se
throw ioe
/**
* holder class for header information gathered from the raw byte header in
* the stream.
*/
//@immutable
private static class headerinfo
/** the value length, either in bytes or characters. */
private final int valuelength
/** the header length in bytes. */
private final int headerlength
/**
* creates a new header info object.
*
* @param headerlength the header length in bytes
* @param valuelength the value length (chars or bytes)
*/
headerinfo int headerlength  int valuelength
this headerlength   headerlength
this valuelength   valuelength
/**
* returns the header length in bytes.
*
* @return number of bytes occupied by the header.
*/
int headerlength
return this headerlength
/**
* returns the character length encoded in the header, if any.
*
* @return a positive integer if a character count was encoded in the
*       header, or {@code 0} (zero) if the header contained byte length
*       information.
*/
int charlength
return ischarlength   ? valuelength   0
/**
* returns the byte length encoded in the header, if any.
*
* @return a positive integer if a byte count was encoded in the
*       header, or {@code 0} (zero) if the header contained character
*       length information.
*/
int bytelength
return ischarlength   ? 0   valuelength
/**
* tells whether the encoded length was in characters or bytes.
*
* @return {@code true} if the header contained a character count,
*       {@code false} if it contained a byte count.
*/
boolean ischarlength
return  headerlength    5
/**
* returns a textual representation.
*/
public string tostring
return      headerlength
valuelength       ischarlength