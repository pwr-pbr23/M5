package org apache lucene analysis shingle
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util iterator
import java util linkedlist
import org apache lucene analysis token
import org apache lucene analysis tokenfilter
import org apache lucene analysis tokenstream
import org apache lucene analysis tokenattributes offsetattribute
import org apache lucene analysis tokenattributes positionincrementattribute
import org apache lucene analysis tokenattributes termattribute
import org apache lucene analysis tokenattributes typeattribute
import org apache lucene util attributesource
import org apache lucene util attributesource state
/**
* <p>a shinglefilter constructs shingles (token n-grams) from a token stream.
* in other words, it creates combinations of tokens as a single token.
*
* <p>for example, the sentence "please divide this sentence into shingles"
* might be tokenized into shingles "please divide", "divide this",
* "this sentence", "sentence into", and "into shingles".
*
* <p>this filter handles position increments > 1 by inserting filler tokens
* (tokens with termtext "_"). it does not handle a position increment of 0.
*/
public final class shinglefilter extends tokenfilter
private linkedlist<state> shinglebuf   new linkedlist<state>
private stringbuilder shingles
private string tokentype
/**
* filler token for when positionincrement is more than 1
*/
public static final char filler_token
/**
* default maximum shingle size is 2.
*/
public static final int default_max_shingle_size   2
/**
* the string to use when joining adjacent tokens to form a shingle
*/
public static final string token_separator
/**
* by default, we output unigrams (individual tokens) as well as shingles
* (token n-grams).
*/
private boolean outputunigrams   true
/**
* maximum shingle size (number of tokens)
*/
private int maxshinglesize
/**
* constructs a shinglefilter with the specified single size from the
* {@link tokenstream} <code>input</code>
*
* @param input input stream
* @param maxshinglesize maximum shingle size produced by the filter.
*/
public shinglefilter tokenstream input  int maxshinglesize
super input
setmaxshinglesize maxshinglesize
this termatt   addattribute termattribute class
this offsetatt   addattribute offsetattribute class
this posincratt   addattribute positionincrementattribute class
this typeatt   addattribute typeattribute class
/**
* construct a shinglefilter with default shingle size.
*
* @param input input stream
*/
public shinglefilter tokenstream input
this input  default_max_shingle_size
/**
* construct a shinglefilter with the specified token type for shingle tokens.
*
* @param input input stream
* @param tokentype token type for shingle tokens
*/
public shinglefilter tokenstream input  string tokentype
this input  default_max_shingle_size
settokentype tokentype
/**
* set the type of the shingle tokens produced by this filter.
* (default: "shingle")
*
* @param tokentype token tokentype
*/
public void settokentype string tokentype
this tokentype   tokentype
/**
* shall the output stream contain the input tokens (unigrams) as well as
* shingles? (default: true.)
*
* @param outputunigrams whether or not the output stream shall contain
* the input tokens (unigrams)
*/
public void setoutputunigrams boolean outputunigrams
this outputunigrams   outputunigrams
/**
* set the max shingle size (default: 2)
*
* @param maxshinglesize max size of output shingles
*/
public void setmaxshinglesize int maxshinglesize
if  maxshinglesize < 2
throw new illegalargumentexception
shingles   new stringbuilder
for  int i   0  i < shingles length  i
shingles   new stringbuilder
this maxshinglesize   maxshinglesize
/**
* clear the stringbuilders that are used for storing the output shingles.
*/
private void clearshingles
for  int i   0  i < shingles length  i
shingles setlength 0
private attributesource state nexttoken
private int shinglebufferposition
private int endoffsets
/* (non-javadoc)
* @see org.apache.lucene.analysis.tokenstream#next()
*/
@override
public final boolean incrementtoken   throws ioexception
while  true
if  nexttoken    null
if   fillshinglebuffer
return false
nexttoken   shinglebuf getfirst
if  outputunigrams
if  shinglebufferposition    0
restorestate nexttoken
posincratt setpositionincrement 1
shinglebufferposition
return true
else
shinglebufferposition
if  shinglebufferposition < shinglebuf size
restorestate nexttoken
typeatt settype tokentype
offsetatt setoffset offsetatt startoffset    endoffsets
stringbuilder buf   shingles
int termlength   buf length
char termbuffer   termatt termbuffer
if  termbuffer length < termlength
termbuffer   termatt resizetermbuffer termlength
buf getchars 0  termlength  termbuffer  0
termatt settermlength termlength
if     outputunigrams     shinglebufferposition    1
posincratt setpositionincrement 1
else
posincratt setpositionincrement 0
shinglebufferposition
if  shinglebufferposition    shinglebuf size
nexttoken   null
shinglebufferposition   0
return true
else
nexttoken   null
shinglebufferposition   0
private int numfillertokenstoinsert
private attributesource state currenttoken
private boolean hascurrenttoken
private termattribute termatt
private offsetattribute offsetatt
private positionincrementattribute posincratt
private typeattribute typeatt
/**
* get the next token from the input stream and push it on the token buffer.
* if we encounter a token with position increment > 1, we put filler tokens
* on the token buffer.
* <p/>
* returns null when the end of the input stream is reached.
* @return the next token, or null if at end of input stream
* @throws ioexception if the input stream has a problem
*/
private boolean getnexttoken   throws ioexception
while  true
if  numfillertokenstoinsert > 0
if  currenttoken    null
currenttoken   capturestate
else
restorestate currenttoken
numfillertokenstoinsert
// a filler token occupies no space
offsetatt setoffset offsetatt startoffset    offsetatt startoffset
termatt settermbuffer filler_token  0  filler_token length
return true
if  hascurrenttoken
if  currenttoken    null
restorestate currenttoken
currenttoken   null
hascurrenttoken   false
return true
if   input incrementtoken    return false
hascurrenttoken   true
if  posincratt getpositionincrement   > 1
numfillertokenstoinsert   posincratt getpositionincrement     1
/**
* fill the output buffer with new shingles.
*
* @throws ioexception if there's a problem getting the next token
*/
private boolean fillshinglebuffer   throws ioexception
boolean addedtoken   false
/*
* try to fill the shingle buffer.
*/
do
if  getnexttoken
shinglebuf add capturestate
if  shinglebuf size   > maxshinglesize
shinglebuf removefirst
addedtoken   true
else
break
while  shinglebuf size   < maxshinglesize
if  shinglebuf isempty
return false
/*
* if no new token could be added to the shingle buffer, we have reached
* the end of the input stream and have to discard the least recent token.
*/
if    addedtoken
shinglebuf removefirst
if  shinglebuf isempty
return false
clearshingles
endoffsets   new int
for  int i   0  i < endoffsets length  i
endoffsets   0
int i   0
for  iterator<state> it   shinglebuf iterator    it hasnext
restorestate it next
for  int j   i  j < shingles length  j
if  shingles length      0
shingles append token_separator
shingles append termatt termbuffer    0  termatt termlength
endoffsets   offsetatt endoffset
i
return true
@override
public void reset   throws ioexception
super reset
nexttoken   null
shinglebufferposition   0
shinglebuf clear
numfillertokenstoinsert   0
currenttoken   null
hascurrenttoken   false