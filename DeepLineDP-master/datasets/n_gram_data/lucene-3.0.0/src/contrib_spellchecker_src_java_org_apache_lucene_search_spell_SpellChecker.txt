package org apache lucene search spell
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util iterator
import org apache lucene analysis whitespaceanalyzer
import org apache lucene document document
import org apache lucene document field
import org apache lucene index indexreader
import org apache lucene index indexwriter
import org apache lucene index term
import org apache lucene search booleanclause
import org apache lucene search booleanquery
import org apache lucene search indexsearcher
import org apache lucene search query
import org apache lucene search scoredoc
import org apache lucene search termquery
import org apache lucene store directory
/**
* <p>
*   spell checker class  (main class) <br/>
*  (initially inspired by the david spencer code).
* </p>
*
* <p>example usage:
*
* <pre>
*  spellchecker spellchecker = new spellchecker(spellindexdirectory);
*  // to index a field of a user index:
*  spellchecker.indexdictionary(new lucenedictionary(my_lucene_reader, a_field));
*  // to index a file containing words:
*  spellchecker.indexdictionary(new plaintextdictionary(new file("myfile.txt")));
*  string[] suggestions = spellchecker.suggestsimilar("misspelt", 5);
* </pre>
*
*
* @version 1.0
*/
public class spellchecker
/**
* field name for each word in the ngram index.
*/
public static final string f_word
/**
* the spell index
*/
directory spellindex
/**
* boost value for start and end grams
*/
private float bstart   2 0f
private float bend   1 0f
private indexsearcher searcher
// minimum score for hits generated by the spell checker query
private float minscore   0 5f
private stringdistance sd
/**
* use the given directory as a spell checker index. the directory
* is created if it doesn't exist yet.
*
* @param spellindex
* @throws ioexception
*/
public spellchecker directory spellindex stringdistance sd  throws ioexception
this setspellindex spellindex
this setstringdistance sd
public spellchecker directory spellindex  throws ioexception
this spellindex  new levensteindistance
/**
* use a different index as the spell checker index or re-open
* the existing index if <code>spellindex</code> is the same value
* as given in the constructor.
*
* @param spellindex
* @throws ioexception
*/
public void setspellindex directory spellindex  throws ioexception
this spellindex   spellindex
if   indexreader indexexists spellindex
indexwriter writer   new indexwriter spellindex  null  true  indexwriter maxfieldlength unlimited
writer close
// close the old searcher, if there was one
if  searcher    null
searcher close
searcher   new indexsearcher this spellindex  true
public void setstringdistance stringdistance sd
this sd   sd
public stringdistance getstringdistance
return sd
/**
* sets the accuracy 0 &lt; minscore &lt; 1; default 0.5
*/
public void setaccuracy float minscore
this minscore   minscore
/**
* suggest similar words.
*
* <p>as the lucene similarity that is used to fetch the most relevant n-grammed terms
* is not the same as the edit distance strategy used to calculate the best
* matching spell-checked word from the hits that lucene found, one usually has
* to retrieve a couple of numsug's in order to get the true best match.
*
* <p>i.e. if numsug == 1, don't count on that suggestion being the best one.
* thus, you should set this value to <b>at least</b> 5 for a good suggestion.
*
* @param word the word you want a spell check done on
* @param numsug the number of suggested words
* @throws ioexception
* @return string[]
*/
public string suggestsimilar string word  int numsug  throws ioexception
return this suggestsimilar word  numsug  null  null  false
/**
* suggest similar words (optionally restricted to a field of an index).
*
* <p>as the lucene similarity that is used to fetch the most relevant n-grammed terms
* is not the same as the edit distance strategy used to calculate the best
* matching spell-checked word from the hits that lucene found, one usually has
* to retrieve a couple of numsug's in order to get the true best match.
*
* <p>i.e. if numsug == 1, don't count on that suggestion being the best one.
* thus, you should set this value to <b>at least</b> 5 for a good suggestion.
*
* @param word the word you want a spell check done on
* @param numsug the number of suggested words
* @param ir the indexreader of the user index (can be null see field param)
* @param field the field of the user index: if field is not null, the suggested
* words are restricted to the words present in this field.
* @param morepopular return only the suggest words that are as frequent or more frequent than the searched word
* (only if restricted mode = (indexreader!=null and field!=null)
* @throws ioexception
* @return string[] the sorted list of the suggest words with these 2 criteria:
* first criteria: the edit distance, second criteria (only if restricted mode): the popularity
* of the suggest words in the field of the user index
*/
public string suggestsimilar string word  int numsug  indexreader ir
string field  boolean morepopular  throws ioexception
float min   this minscore
final int lengthword   word length
final int freq    ir    null    field    null  ? ir docfreq new term field  word     0
final int goalfreq    morepopular    ir    null    field    null  ? freq   0
// if the word exists in the real index and we don't care for word frequency, return the word itself
if   morepopular    freq > 0
return new string   word
booleanquery query   new booleanquery
string grams
string key
for  int ng   getmin lengthword   ng <  getmax lengthword   ng
key       ng     form key
grams   formgrams word  ng      form word into ngrams  allow dups too
if  grams length    0
continue     hmm
if  bstart > 0       should we boost prefixes?
add query      ng  grams  bstart      matches start of word
if  bend > 0       should we boost suffixes
add query      ng  grams  bend      matches end of word
for  int i   0  i < grams length  i
add query  key  grams
int maxhits   10   numsug
//    system.out.println("q: " + query);
scoredoc hits   searcher search query  null  maxhits  scoredocs
//    system.out.println("hits: " + hits.length());
suggestwordqueue sugqueue   new suggestwordqueue numsug
// go thru more than 'maxr' matches in case the distance filter triggers
int stop   math min hits length  maxhits
suggestword sugword   new suggestword
for  int i   0  i < stop  i
sugword string   searcher doc hits doc  get f_word      get orig word
// don't suggest a word for itself, that would be silly
if  sugword string equals word
continue
// edit distance
sugword score   sd getdistance word sugword string
if  sugword score < min
continue
if  ir    null    field    null       use the user index
sugword freq   ir docfreq new term field  sugword string       freq in the index
// don't suggest a word that is not present in the field
if   morepopular    goalfreq > sugword freq     sugword freq < 1
continue
sugqueue insertwithoverflow sugword
if  sugqueue size      numsug
// if queue full, maintain the minscore score
min   sugqueue top   score
sugword   new suggestword
// convert to array string
string list   new string
for  int i   sugqueue size     1  i >  0  i
list   sugqueue pop   string
return list
/**
* add a clause to a boolean query.
*/
private static void add booleanquery q  string name  string value  float boost
query tq   new termquery new term name  value
tq setboost boost
q add new booleanclause tq  booleanclause occur should
/**
* add a clause to a boolean query.
*/
private static void add booleanquery q  string name  string value
q add new booleanclause new termquery new term name  value    booleanclause occur should
/**
* form all ngrams for a given word.
* @param text the word to parse
* @param ng the ngram length e.g. 3
* @return an array of all ngrams in the word and note that duplicates are not removed
*/
private static string formgrams string text  int ng
int len   text length
string res   new string
for  int i   0  i < len   ng   1  i
res   text substring i  i   ng
return res
/**
* removes all terms from the spell check index.
* @throws ioexception
*/
public void clearindex   throws ioexception
indexwriter writer   new indexwriter spellindex  null  true  indexwriter maxfieldlength unlimited
writer close
//close the old searcher
searcher close
searcher   new indexsearcher this spellindex  true
/**
* check whether the word exists in the index.
* @param word
* @throws ioexception
* @return true iff the word exists in the index
*/
public boolean exist string word  throws ioexception
return searcher docfreq new term f_word  word   > 0
/**
* indexes the data from the given {@link dictionary}.
* @param dict dictionary to index
* @param mergefactor mergefactor to use when indexing
* @param rammb the max amount or memory in mb to use
* @throws ioexception
*/
public void indexdictionary dictionary dict  int mergefactor  int rammb  throws ioexception
indexwriter writer   new indexwriter spellindex  new whitespaceanalyzer    indexwriter maxfieldlength unlimited
writer setmergefactor mergefactor
writer setrambuffersizemb rammb
iterator<string> iter   dict getwordsiterator
while  iter hasnext
string word   iter next
int len   word length
if  len < 3
continue     too short we bail but   is fine
if  this exist word        if the word already exist in the gramindex
continue
// ok index the word
document doc   createdocument word  getmin len   getmax len
writer adddocument doc
// close writer
writer optimize
writer close
// also re-open the spell index to see our own changes when the next suggestion
// is fetched:
searcher close
searcher   new indexsearcher this spellindex  true
/**
* indexes the data from the given {@link dictionary}.
* @param dict the dictionary to index
* @throws ioexception
*/
public void indexdictionary dictionary dict  throws ioexception
indexdictionary dict  300  10
private int getmin int l
if  l > 5
return 3
if  l    5
return 2
return 1
private int getmax int l
if  l > 5
return 4
if  l    5
return 3
return 2
private static document createdocument string text  int ng1  int ng2
document doc   new document
doc add new field f_word  text  field store yes  field index not_analyzed       orig term
addgram text  doc  ng1  ng2
return doc
private static void addgram string text  document doc  int ng1  int ng2
int len   text length
for  int ng   ng1  ng <  ng2  ng
string key       ng
string end   null
for  int i   0  i < len   ng   1  i
string gram   text substring i  i   ng
doc add new field key  gram  field store no  field index not_analyzed
if  i    0
doc add new field     ng  gram  field store no  field index not_analyzed
end   gram
if  end    null       may not be present if len  ng1
doc add new field     ng  end  field store no  field index not_analyzed