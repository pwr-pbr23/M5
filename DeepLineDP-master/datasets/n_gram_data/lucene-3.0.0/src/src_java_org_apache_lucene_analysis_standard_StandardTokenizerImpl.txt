/* the following code was generated by jflex 1.4.1 on 9/4/08 6:49 pm */
package org apache lucene analysis standard
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
/*
warning: if you change standardtokenizerimpl.jflex and need to regenerate
the tokenizer, only use java 1.4 !!!
this grammar currently uses constructs (eg :digit:, :letter:) whose
meaning can vary according to the jre used to run jflex.  see
https://issues.apache.org/jira/browse/lucene-1126 for details.
for current backwards compatibility it is needed to support
only java 1.4 - this will change in lucene 3.1.
*/
import org apache lucene analysis token
import org apache lucene analysis tokenattributes termattribute
/**
* this class is a scanner generated by
* <a href="http://www.jflex.de/">jflex</a> 1.4.1
* on 9/4/08 6:49 pm from the specification file
* <tt>/tango/mike/src/lucene.standarddigit/src/java/org/apache/lucene/analysis/standard/standardtokenizerimpl.jflex</tt>
*/
class standardtokenizerimpl
/** this character denotes the end of file */
public static final int yyeof    1
/** initial size of the lookahead buffer */
private static final int zz_buffersize   16384
/** lexical states */
public static final int yyinitial   0
/**
* translates characters to character classes
*/
private static final string zz_cmap_packed
/**
* translates characters to character classes
*/
private static final char  zz_cmap   zzunpackcmap zz_cmap_packed
/**
* translates dfa states to action switch labels.
*/
private static final int  zz_action   zzunpackaction
private static final string zz_action_packed_0
private static int  zzunpackaction
int  result   new int
int offset   0
offset   zzunpackaction zz_action_packed_0  offset  result
return result
private static int zzunpackaction string packed  int offset  int  result
int i   0           index in packed string
int j   offset      index in unpacked array
int l   packed length
while  i < l
int count   packed charat i
int value   packed charat i
do result   value  while    count > 0
return j
/**
* translates a state to a row index in the transition table
*/
private static final int  zz_rowmap   zzunpackrowmap
private static final string zz_rowmap_packed_0
private static int  zzunpackrowmap
int  result   new int
int offset   0
offset   zzunpackrowmap zz_rowmap_packed_0  offset  result
return result
private static int zzunpackrowmap string packed  int offset  int  result
int i   0      index in packed string
int j   offset      index in unpacked array
int l   packed length
while  i < l
int high   packed charat i    << 16
result   high   packed charat i
return j
/**
* the transition table of the dfa
*/
private static final int  zz_trans   zzunpacktrans
private static final string zz_trans_packed_0
private static int  zzunpacktrans
int  result   new int
int offset   0
offset   zzunpacktrans zz_trans_packed_0  offset  result
return result
private static int zzunpacktrans string packed  int offset  int  result
int i   0           index in packed string
int j   offset      index in unpacked array
int l   packed length
while  i < l
int count   packed charat i
int value   packed charat i
value
do result   value  while    count > 0
return j
/* error codes */
private static final int zz_unknown_error   0
private static final int zz_no_match   1
private static final int zz_pushback_2big   2
/* error messages for the codes above */
private static final string zz_error_msg
/**
* zz_attribute[astate] contains the attributes of state <code>astate</code>
*/
private static final int  zz_attribute   zzunpackattribute
private static final string zz_attribute_packed_0
private static int  zzunpackattribute
int  result   new int
int offset   0
offset   zzunpackattribute zz_attribute_packed_0  offset  result
return result
private static int zzunpackattribute string packed  int offset  int  result
int i   0           index in packed string
int j   offset      index in unpacked array
int l   packed length
while  i < l
int count   packed charat i
int value   packed charat i
do result   value  while    count > 0
return j
/** the input device */
private java io reader zzreader
/** the current state of the dfa */
private int zzstate
/** the current lexical state */
private int zzlexicalstate   yyinitial
/** this buffer contains the current text to be matched and is
the source of the yytext() string */
private char zzbuffer   new char
/** the textposition at the last accepting state */
private int zzmarkedpos
/** the textposition at the last state to be included in yytext */
private int zzpushbackpos
/** the current text position in the buffer */
private int zzcurrentpos
/** startread marks the beginning of the yytext() string in the buffer */
private int zzstartread
/** endread marks the last character in the buffer, that has been read
from input */
private int zzendread
/** number of newlines encountered up to the start of the matched text */
private int yyline
/** the number of characters up to the start of the matched text */
private int yychar
/**
* the number of characters from the last newline up to the start of the
* matched text
*/
private int yycolumn
/**
* zzatbol == true <=> the scanner is currently at the beginning of a line
*/
private boolean zzatbol   true
/** zzateof == true <=> the scanner is at the eof */
private boolean zzateof
/* user code: */
public static final int alphanum            standardtokenizer alphanum
public static final int apostrophe          standardtokenizer apostrophe
public static final int acronym             standardtokenizer acronym
public static final int company             standardtokenizer company
public static final int email               standardtokenizer email
public static final int host                standardtokenizer host
public static final int num                 standardtokenizer num
public static final int cj                  standardtokenizer cj
/**
* @deprecated this solves a bug where hosts that end with '.' are identified
*             as acronyms.
*/
public static final int acronym_dep         standardtokenizer acronym_dep
public static final string  token_types   standardtokenizer token_types
public final int yychar
return yychar
/**
* fills lucene token with the current token text.
*/
final void gettext token t
t settermbuffer zzbuffer  zzstartread  zzmarkedpos zzstartread
/**
* fills termattribute with the current token text.
*/
final void gettext termattribute t
t settermbuffer zzbuffer  zzstartread  zzmarkedpos zzstartread
/**
* creates a new scanner
* there is also a java.io.inputstream version of this constructor.
*
* @param   in  the java.io.reader to read input from.
*/
standardtokenizerimpl java io reader in
this zzreader   in
/**
* creates a new scanner.
* there is also java.io.reader version of this constructor.
*
* @param   in  the java.io.inputstream to read input from.
*/
standardtokenizerimpl java io inputstream in
this new java io inputstreamreader in
/**
* unpacks the compressed character translation table.
*
* @param packed   the packed character translation table
* @return         the unpacked character translation table
*/
private static char  zzunpackcmap string packed
char  map   new char
int i   0      index in packed string
int j   0      index in unpacked array
while  i < 1154
int  count   packed charat i
char value   packed charat i
do map   value  while    count > 0
return map
/**
* refills the input buffer.
*
* @return      <code>false</code>, iff there was new input.
*
* @exception   java.io.ioexception  if any i/o-error occurs
*/
private boolean zzrefill   throws java io ioexception
/* first: make room (if you can) */
if  zzstartread > 0
system arraycopy zzbuffer  zzstartread
zzbuffer  0
zzendread zzstartread
/* translate stored positions */
zzendread   zzstartread
zzcurrentpos   zzstartread
zzmarkedpos   zzstartread
zzpushbackpos   zzstartread
zzstartread   0
/* is the buffer big enough? */
if  zzcurrentpos >  zzbuffer length
/* if not: blow it up */
char newbuffer   new char
system arraycopy zzbuffer  0  newbuffer  0  zzbuffer length
zzbuffer   newbuffer
/* finally: fill the buffer with new input */
int numread   zzreader read zzbuffer  zzendread
zzbuffer length zzendread
if  numread < 0
return true
else
zzendread   numread
return false
/**
* closes the input stream.
*/
public final void yyclose   throws java io ioexception
zzateof   true                indicate end of file
zzendread   zzstartread      invalidate buffer
if  zzreader    null
zzreader close
/**
* resets the scanner to read from a new input stream.
* does not close the old reader.
*
* all internal variables are reset, the old input stream
* <b>cannot</b> be reused (internal buffer is discarded and lost).
* lexical state is set to <tt>zz_initial</tt>.
*
* @param reader   the new input stream
*/
public final void yyreset java io reader reader
zzreader   reader
zzatbol    true
zzateof    false
zzendread   zzstartread   0
zzcurrentpos   zzmarkedpos   zzpushbackpos   0
yyline   yychar   yycolumn   0
zzlexicalstate   yyinitial
/**
* returns the current lexical state.
*/
public final int yystate
return zzlexicalstate
/**
* enters a new lexical state
*
* @param newstate the new lexical state
*/
public final void yybegin int newstate
zzlexicalstate   newstate
/**
* returns the text matched by the current regular expression.
*/
public final string yytext
return new string  zzbuffer  zzstartread  zzmarkedpos zzstartread
/**
* returns the character at position <tt>pos</tt> from the
* matched text.
*
* it is equivalent to yytext().charat(pos), but faster
*
* @param pos the position of the character to fetch.
*            a value from 0 to yylength()-1.
*
* @return the character at position pos
*/
public final char yycharat int pos
return zzbuffer
/**
* returns the length of the matched text region.
*/
public final int yylength
return zzmarkedpos zzstartread
/**
* reports an error that occured while scanning.
*
* in a wellformed scanner (no or only correct usage of
* yypushback(int) and a match-all fallback rule) this method
* will only be called with things that "can't possibly happen".
* if this method is called, something is seriously wrong
* (e.g. a jflex bug producing a faulty scanner etc.).
*
* usual syntax/scanner level error handling should be done
* in error fallback rules.
*
* @param   errorcode  the code of the errormessage to display
*/
private void zzscanerror int errorcode
string message
try
message   zz_error_msg
catch  arrayindexoutofboundsexception e
message   zz_error_msg
throw new error message
/**
* pushes the specified amount of characters back into the input stream.
*
* they will be read again by then next call of the scanning method
*
* @param number  the number of characters to be read again.
*                this number must not be greater than yylength()!
*/
public void yypushback int number
if   number > yylength
zzscanerror zz_pushback_2big
zzmarkedpos    number
/**
* resumes scanning until the next regular expression is matched,
* the end of input is encountered or an i/o-error occurs.
*
* @return      the next token
* @exception   java.io.ioexception  if any i/o-error occurs
*/
public int getnexttoken   throws java io ioexception
int zzinput
int zzaction
// cached fields:
int zzcurrentposl
int zzmarkedposl
int zzendreadl   zzendread
char  zzbufferl   zzbuffer
char  zzcmapl   zz_cmap
int  zztransl   zz_trans
int  zzrowmapl   zz_rowmap
int  zzattrl   zz_attribute
while  true
zzmarkedposl   zzmarkedpos
yychar   zzmarkedposl zzstartread
zzaction    1
zzcurrentposl   zzcurrentpos   zzstartread   zzmarkedposl
zzstate   zzlexicalstate
zzforaction
while  true
if  zzcurrentposl < zzendreadl
zzinput   zzbufferl
else if  zzateof
zzinput   yyeof
break zzforaction
else
// store back cached positions
zzcurrentpos    zzcurrentposl
zzmarkedpos     zzmarkedposl
boolean eof   zzrefill
// get translated positions and possibly new buffer
zzcurrentposl    zzcurrentpos
zzmarkedposl     zzmarkedpos
zzbufferl        zzbuffer
zzendreadl       zzendread
if  eof
zzinput   yyeof
break zzforaction
else
zzinput   zzbufferl
int zznext   zztransl   zzcmapl ]
if  zznext     1  break zzforaction
zzstate   zznext
int zzattributes   zzattrl
if    zzattributes   1     1
zzaction   zzstate
zzmarkedposl   zzcurrentposl
if    zzattributes   8     8   break zzforaction
// store back cached position
zzmarkedpos   zzmarkedposl
switch  zzaction < 0 ? zzaction   zz_action
case 4
return host
case 11  break
case 9
return acronym
case 12  break
case 8
return acronym_dep
case 13  break
case 1
ignore
case 14  break
case 5
return num
case 15  break
case 3
return cj
case 16  break
case 2
return alphanum
case 17  break
case 7
return company
case 18  break
case 6
return apostrophe
case 19  break
case 10
return email
case 20  break
default
if  zzinput    yyeof    zzstartread    zzcurrentpos
zzateof   true
return yyeof
else
zzscanerror zz_no_match