/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy runtime metaclass
import org codehaus groovy runtime reflector
import java security protectiondomain
import java util hashmap
import java util map
/**
* reflector creation helper. this class is used to define the refloctor classes.
* for each classloader such a loader will be created by metaclass.
* special about this loader is, that it knows the classes form the
* groovy runtime. the reflector class is resolved in different ways: during
* the definition of a class reflector will resolve to the reflector class of
* the runtime, even if there is another reflector class in the parent loader.
* after the new class is defined reflector will resolve like other groovy
* classes. this loader is able to resolve all groovy classes even if the
* parent does not know them, but the parent serves first (reflector during a
* class defintion is different).
*
* @author <a href="mailto:blackdrag@gmx.org">jochen theodorou</a>
* @version $revision$
*/
public class reflectorloader extends classloader
private boolean indefine   false
private final map loadedclasses   new hashmap
private final classloader delegatationloader
private static final string reflector   reflector class getname
/**
* tries to find a groovy class.
*
* @return the class if found
* @throws classnotfoundexception if not found
*/
protected class findclass string name  throws classnotfoundexception
if  delegatationloader  null  return super findclass name
return delegatationloader loadclass name
/**
* loads a class per name. unlike a normal loadclass this version
* behaves different during a class definition. in that case it
* checks if the class we want to load is reflector and returns
* class if the check is successful. if it is not during a class
* definition it just calls the super class version of loadclass.
*
* @param name of the class to load
* @param resolve is true if the class should be resolved
* @see reflector
* @see classloader#loadclass(string, boolean)
*/
protected synchronized class loadclass string name  boolean resolve  throws classnotfoundexception
if  indefine
if  name equals reflector   return reflector class
return super loadclass name  resolve
/**
* helper method to define reflector classes.
* @param name of the reflector
* @param bytecode the bytecode
* @param domain  the protection domain
* @return the generated class
*/
public synchronized class defineclass string name  byte bytecode  protectiondomain domain
indefine   true
class c   defineclass name  bytecode  0  bytecode length  domain
loadedclasses put name c
resolveclass c
indefine   false
return c
/**
* creates a relfectorloader.
* @param parent the parent loader. this should never be null!
*/
public reflectorloader classloader parent
super parent
delegatationloader   getclass   getclassloader
/**
* try to load one of the defined reflector classes by name.
* @param name of the reflector class
* @return the reflector class if defined else null.
*/
public synchronized class getloadedclass string name
return  class loadedclasses get name
static string getreflectorname class theclass
string classname   theclass getname
if  classname startswith
string packageprefix
string name   packageprefix   classname
if  theclass isarray
class clazz   theclass
name   packageprefix
int level   0
while  clazz isarray
clazz   clazz getcomponenttype
level
string componentname   clazz getname
name   packageprefix   componentname
if  level>1  name    level
return name
else
string name   classname replace
if  theclass isarray
class clazz   theclass
int level   0
while  clazz isarray
clazz   clazz getcomponenttype
level
string componentname   clazz getname
name   componentname replace
if  level>1  name    level
return name