/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package groovy servlet
import groovy text simpletemplateengine
import groovy text template
import groovy text templateengine
import java io file
import java io filereader
import java io ioexception
import java io writer
import java util date
import java util map
import java util weakhashmap
import javax servlet servletconfig
import javax servlet servletexception
import javax servlet http httpservletrequest
import javax servlet http httpservletresponse
/**
* a generic servlet for serving (mostly html) templates.
*
* <p>
* it delegates work to a <code>groovy.text.templateengine</code> implementation
* processing http requests.
*
* <h4>usage</h4>
*
* <code>helloworld.html</code> is a headless html-like template
* <pre><code>
*  &lt;html&gt;
*    &lt;body&gt;
*      &lt;% 3.times { %&gt;
*        hello world!
*      &lt;% } %&gt;
*      &lt;br&gt;
*    &lt;/body&gt;
*  &lt;/html&gt;
* </code></pre>
*
* minimal <code>web.xml</code> example serving html-like templates
* <pre><code>
* &lt;web-app&gt;
*   &lt;servlet&gt;
*     &lt;servlet-name&gt;template&lt;/servlet-name&gt;
*     &lt;servlet-class&gt;groovy.servlet.templateservlet&lt;/servlet-class&gt;
*   &lt;/servlet&gt;
*   &lt;servlet-mapping&gt;
*     &lt;servlet-name&gt;template&lt;/servlet-name&gt;
*     &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
*   &lt;/servlet-mapping&gt;
* &lt;/web-app&gt;
* </code></pre>
*
* <h4>template engine configuration</h4>
*
* <p>
* by default, the templateserver uses the {@link groovy.text.simpletemplateengine}
* which interprets jsp-like templates. the init parameter <code>template.engine</code>
* defines the fully qualified class name of the template to use:
* <pre>
*   template.engine = [empty] - equals groovy.text.simpletemplateengine
*   template.engine = groovy.text.simpletemplateengine
*   template.engine = groovy.text.gstringtemplateengine
*   template.engine = groovy.text.xmltemplateengine
* </pre>
*
* <h4>logging and extra-output options</h4>
*
* <p>
* this implementation provides a verbosity flag switching log statements.
* the servlet init parameter name is:
* <pre>
*   generate.by = true(default) | false
* </pre>
*
* @see templateservlet#setvariables(servletbinding)
*
* @author christian stein
* @author guillaume laforge
* @version 2.0
*/
public class templateservlet extends abstracthttpservlet
/**
* simple cache entry that validates against last modified and length
* attributes of the specified file.
*
* @author christian stein
*/
private static class templatecacheentry
date date
long hit
long lastmodified
long length
template template
public templatecacheentry file file  template template
this file  template  false      don't get time millis for sake of speed
public templatecacheentry file file  template template  boolean timestamp
if  file    null
throw new nullpointerexception
if  template    null
throw new nullpointerexception
if  timestamp
this date   new date system currenttimemillis
else
this date   null
this hit   0
this lastmodified   file lastmodified
this length   file length
this template   template
/**
* checks the passed file attributes against those cached ones.
*
* @param file
*  other file handle to compare to the cached values.
* @return <code>true</code> if all measured values match, else <code>false</code>
*/
public boolean validate file file
if  file    null
throw new nullpointerexception
if  file lastmodified      this lastmodified
return false
if  file length      this length
return false
hit
return true
public string tostring
if  date    null
return     hit
return     hit       date
/**
* simple file name to template cache map.
*/
private final map cache
/**
* underlying template engine used to evaluate template source files.
*/
private templateengine engine
/**
* flag that controls the appending of the "generated by ..." comment.
*/
private boolean generateby
/**
* create new templateserlvet.
*/
public templateservlet
this cache   new weakhashmap
this engine   null     assigned later by init
this generateby   true     may be changed by init
/**
* gets the template created by the underlying engine parsing the request.
*
* <p>
* this method looks up a simple (weak) hash map for an existing template
* object that matches the source file. if the source file didn't change in
* length and its last modified stamp hasn't changed compared to a precompiled
* template object, this template is used. otherwise, there is no or an
* invalid template object cache entry, a new one is created by the underlying
* template engine. this new instance is put to the cache for consecutive
* calls.
* </p>
*
* @return the template that will produce the response text.
* @param file
*            the httpservletrequest.
* @throws servletexception
*            if the request specified an invalid template source file
*/
protected template gettemplate file file  throws servletexception
string key   file getabsolutepath
template template   null
/*
* test cache for a valid template bound to the key.
*/
if  verbose
log
templatecacheentry entry    templatecacheentry  cache get key
if  entry    null
if  entry validate file
if  verbose
log     entry
template   entry template
else
if  verbose
log
else
if  verbose
log
//
// template not cached or the source file changed - compile new template!
//
if  template    null
if  verbose
log     file
filereader reader   null
try
reader   new filereader file
template   engine createtemplate reader
catch  exception e
throw new servletexception     e  e
finally
if  reader    null
try
reader close
catch  ioexception ignore
// e.printstacktrace();
cache put key  new templatecacheentry file  template  verbose
if  verbose
log     key
//
// last sanity check.
//
if  template    null
throw new servletexception
return template
/**
* initializes the servlet from hints the container passes.
* <p>
* delegates to sub-init methods and parses the following parameters:
* <ul>
* <li> <tt>"generatedby"</tt> : boolean, appends "generated by ..." to the
*     html response text generated by this servlet.
*     </li>
* </ul>
* @param config
*  passed by the servlet container.
* @throws servletexception
*  if this method encountered difficulties
*
* @see templateservlet#inittemplateengine(servletconfig)
*/
public void init servletconfig config  throws servletexception
super init config
this engine   inittemplateengine config
if  engine    null
throw new servletexception
string value   config getinitparameter
if  value    null
this generateby   boolean valueof value  booleanvalue
log     getclass   getname         engine getclass
/**
* creates the template engine.
*
* called by {@link templateservlet#init(servletconfig)} and returns just
* <code>new groovy.text.simpletemplateengine()</code> if the init parameter
* <code>template.engine</code> is not set by the container configuration.
*
* @param config
*  current serlvet configuration passed by the container.
*
* @return the underlying template engine or <code>null</code> on error.
*/
protected templateengine inittemplateengine servletconfig config
string name   config getinitparameter
if  name    null
return new simpletemplateengine
try
return  templateengine  class forname name  newinstance
catch  instantiationexception e
log     name  e
catch  illegalaccessexception e
log     name  e
catch  classnotfoundexception e
log     name  e
return null
/**
* services the request with a response.
* <p>
* first the request is parsed for the source file uri. if the specified file
* could not be found or can not be read an error message is sent as response.
*
* </p>
* @param request
*            the http request.
* @param response
*            the http response.
* @throws ioexception
*            if an input or output error occurs while the servlet is
*            handling the http request
* @throws servletexception
*            if the http request cannot be handled
*/
public void service httpservletrequest request  httpservletresponse response  throws servletexception  ioexception
if  verbose
log
//
// get the template source file handle.
//
file file   super getscripturiasfile request
string name   file getname
if   file exists
response senderror httpservletresponse sc_not_found
return     throw new ioexception file getabsolutepath
if   file canread
response senderror httpservletresponse sc_forbidden
return     throw new ioexception file getabsolutepath
//
// get the requested template.
//
long getmillis   system currenttimemillis
template template   gettemplate file
getmillis   system currenttimemillis     getmillis
//
// create new binding for the current request.
//
servletbinding binding   new servletbinding request  response  servletcontext
setvariables binding
//
// prepare the response buffer content type _before_ getting the writer.
// and set status code to ok
//
response setcontenttype content_type_text_html   encoding
response setstatus httpservletresponse sc_ok
//
// get the output stream writer from the binding.
//
writer out    writer  binding getvariable
if  out    null
out   response getwriter
//
// evaluate the template.
//
if  verbose
log
// string made = template.make(binding.getvariables()).tostring();
// log(" = " + made);
long makemillis   system currenttimemillis
template make binding getvariables    writeto out
makemillis   system currenttimemillis     makemillis
if  generateby
stringbuffer sb   new stringbuffer 100
sb append
sb append long tostring getmillis
sb append
sb append long tostring makemillis
sb append
out write sb tostring
//
// flush the response buffer.
//
response flushbuffer
if  verbose
log        getmillis       makemillis
/**
* override this method to set your variables to the groovy binding.
* <p>
* all variables bound the binding are passed to the template source text,
* e.g. the html file, when the template is merged.
* </p>
* <p>
* the binding provided by templateservlet does already include some default
* variables. as of this writing, they are (copied from
* {@link groovy.servlet.servletbinding}):
* <ul>
* <li><tt>"request"</tt> : httpservletrequest </li>
* <li><tt>"response"</tt> : httpservletresponse </li>
* <li><tt>"context"</tt> : servletcontext </li>
* <li><tt>"application"</tt> : servletcontext </li>
* <li><tt>"session"</tt> : request.getsession(<b>false</b>) </li>
* </ul>
* </p>
* <p>
* and via implicite hard-coded keywords:
* <ul>
* <li><tt>"out"</tt> : response.getwriter() </li>
* <li><tt>"sout"</tt> : response.getoutputstream() </li>
* <li><tt>"html"</tt> : new markupbuilder(response.getwriter()) </li>
* </ul>
* </p>
*
* <p>example binding all servlet context variables:
* <pre><code>
* class mytlet extends templateservlet {
*
*   protected void setvariables(servletbinding binding) {
*     // bind a simple variable
*     binding.setvariable("answer", new long(42));
*
*     // bind all servlet context attributes...
*     servletcontext context = (servletcontext) binding.getvariable("context");
*     enumeration enumeration = context.getattributenames();
*     while (enumeration.hasmoreelements()) {
*       string name = (string) enumeration.nextelement();
*       binding.setvariable(name, context.getattribute(name));
*     }
*   }
*
* }
* <code></pre>
* </p>
*
* @param binding
*  to be modified
*/
protected void setvariables servletbinding binding
// empty