/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package groovy ui text
import javax swing text
import java nio charbuffer
import java util
import java util regex matcher
import java util regex pattern
/**
*
* @author evan "hippy" slatis
*/
public class structuredsyntaxdocumentfilter extends documentfilter
public static final string tab_replacement
private static final mlcomparator ml_comparator   new mlcomparator
/**
* the root of the lexical parsing tree.
*/
protected lexernode lexer   new lexernode true
// the styled document the filter parses
protected defaultstyleddocument styleddocument
// the document buffer and segment
private segment segment   new segment
private charbuffer buffer
/**
* the position tree of multi-line comments.
*/
protected treeset mltextrunset   new treeset ml_comparator
// ensures not adding any regexp with capturing groups
private static void checkregexp string regexp
string checking   regexp replaceall       replaceall
int checked   checking indexof
if  checked >  1
string msg
regexp
for  int i   0  i < checked  i
msg
msg
throw new illegalargumentexception msg
/**
* creates a new instance of structuredsyntaxdocumentfilter
* @param document the styled document to parse
*/
public structuredsyntaxdocumentfilter defaultstyleddocument document
this styleddocument   document
private int calcbeginparse int offset
multilinerun mlr   getmultilinerun offset
if  mlr    null
// means we're in middle of mlr, so start at beginning of mlr
offset   mlr start
else
// otherwise, earliest position in line not part of mlr
offset   styleddocument getparagraphelement offset  getstartoffset
mlr   getmultilinerun offset
offset   mlr    null ? offset   mlr end     1
return offset
private int calcendparse int offset
multilinerun mlr   getmultilinerun offset
if  mlr    null
// means we're in middle of mlr, so end is at end of mlr
offset   mlr end
else
// otherwise, latest position in line not part of mlr
offset   styleddocument getparagraphelement offset  getendoffset
mlr   getmultilinerun offset
offset   mlr    null ? offset   mlr end
return offset
/**
* create a new lexernode for adding to root.
*
* @return a new lexernode
*/
public lexernode createlexernode
return new lexernode false
// given an offset, return the mlr it resides in
private multilinerun getmultilinerun int offset
multilinerun ml   null
if  offset > 0
integer os   new integer offset
sortedset set   mltextrunset headset os
if   set isempty
ml    multilinerun set last
ml   ml end   >  offset ? ml   null
return ml
/**
* get the root node for lexing the document.   children can be added such
* that matching patterns can be further parsed if required.
*
* @return the root lexing node.
*/
public lexernode getrootnode
return lexer
/**
* insert a string into the document, and then parse it if the parser has been
* set.
*
* @param fb
* @param offset
* @param text
* @param attrs
* @throws badlocationexception
*/
public void insertstring documentfilter filterbypass fb  int offset
string text  attributeset attrs
throws badlocationexception
// remove problem meta characters returns
text   replacemetacharacters text
fb insertstring offset  text  attrs
// start on the string that was inserted
parsedocument offset  text length
/**
* parse the document to update the character styles given an initial start
* position.  called by the filter after it has updated the text.
*
* @param offset
* @param length
* @throws badlocationexception
*/
protected void parsedocument int offset  int length  throws badlocationexception
// intialize the segment with the complete document so the segment doesn't
// have an underlying gap in the buffer
styleddocument gettext 0  styleddocument getlength    segment
buffer   charbuffer wrap segment array  asreadonlybuffer
// initialize the lexer if necessary
if   lexer isinitialized
// prime the parser and reparse whole document
lexer initialize
offset   0
length   styleddocument getlength
else
int end   offset   length
offset   calcbeginparse offset
length   calcendparse end    offset
// clean the tree by ensuring multi line styles are reset in area
// of parsing
sortedset set   mltextrunset subset new integer offset
new integer offset   length
if  set    null
set clear
// parse the document
lexer parse buffer  offset  length
/**
* remove a string from the document, and then parse it if the parser has been
* set.
*
* @param fb
* @param offset
* @param length
* @throws badlocationexception
*/
public void remove documentfilter filterbypass fb  int offset  int length
throws badlocationexception
// frickin' hack!!!!! for some reason, deleting a string at offset 0
// does not get done properly, so first replace and remove after parsing
if  offset    0    length    fb getdocument   getlength
fb replace 0  length     lexer defaultstyle
// start on either side of the removed text
parsedocument offset  2
fb remove offset  1
else
fb remove offset  length
// start on either side of the removed text
if  offset   1 < fb getdocument   getlength
parsedocument offset  1
else if  offset   1 > 0
parsedocument offset   1  1
else
// empty text
mltextrunset clear
/**
* replace a string in the document, and then parse it if the parser has been
* set.
*
* @param fb
* @param offset
* @param length
* @param text
* @param attrs
* @throws badlocationexception
*/
public void replace documentfilter filterbypass fb  int offset
int length  string text  attributeset attrs
throws badlocationexception
// remove problem meta characters returns
text   replacemetacharacters text
fb replace offset  length  text  attrs
// start on the text that was replaced
parsedocument offset  text length
// tabs with spaces (i hate tabs)
private string replacemetacharacters string string
// just in case remove carriage returns
string   string replaceall    tab_replacement
return string
public final class lexernode
private style defaultstyle
private map stylemap   new linkedhashmap
private map children   new hashmap
private matcher matcher
private list grouplist   new arraylist
private boolean initialized
private charbuffer lastbuffer
/*
* creates a new instance of lexernode
*/
lexernode boolean isparent
stylecontext sc   stylecontext getdefaultstylecontext
defaultstyle   sc getstyle stylecontext default_style
private string buildregexp string regexps
string regexp
for  int i   0  i < regexps length  i
regexp        regexps
// ensure leading '|' is removed
return regexp substring 1
public style getdefaultstyle
return defaultstyle
private void initialize
matcher   null
grouplist clear
grouplist add null
iterator iter   stylemap keyset   iterator
string regexp
while  iter hasnext
string nextregexp    string iter next
regexp        nextregexp
// have to compile regexp first so that it will match
grouplist add pattern compile nextregexp  pattern
if   regexp equals
matcher   pattern compile regexp substring 1   matcher
iter   children values   iterator
while  iter hasnext
lexernode iter next    initialize
initialized   true
/**
* @return true if initialised
*/
public boolean isinitialized
return initialized
/**
* @param buffer
* @param offset
* @param length
* @throws badlocationexception
*/
public void parse charbuffer buffer  int offset  int length
throws badlocationexception
// get the index of where we can start to look for an exit:
// i.e. after the end of the length of the segment, when we find
// that text in question already is set properly, we can stop
// parsing
int checkpoint   offset   length
// reset the matcher and start parsing string
if  lastbuffer    buffer
matcher reset buffer
lastbuffer   buffer
// the start and end indices of a match in the matcher looking
int matchend   offset
style style   null
while  matchend < checkpoint    matcher find offset
// when we get something other than -1, we know which regexp
// matched; the 0 group is the complete expression of the
// matcher, which would always return a hit based on the above
// while condition
int groupnum   0
while   offset   matcher start   groupnum       1
// if the matching offset is not the same as the end of the
// previous match, we have extra text not matched, so set to
// the default style of this lexer node
if  offset    matchend
offset   offset > checkpoint ? checkpoint   offset
styleddocument setcharacterattributes matchend
offset   matchend
defaultstyle
true
if  offset >  checkpoint
return
// track the end of the matching string
matchend   matcher end groupnum
// retrieve the proper style from groupnum of the grouplist and
// stylemap, then set the attributes of the matching string
style    style stylemap get  string grouplist get groupnum
styleddocument setcharacterattributes offset
matchend   offset
style  true
// if the match was multiline, which we'll know if they span
// multiple paragraph elements, the mark it (this list was cleaned
// above in parsedocument())
if  styleddocument getparagraphelement offset  getstartoffset
styleddocument getparagraphelement matchend  getstartoffset
// mark a ml run
multilinerun mlr   new multilinerun offset  matchend
mltextrunset add mlr
// parse the child regexps, if any, within a matched block
lexernode node    lexernode children get grouplist get groupnum
if  node    null
node parse buffer  offset  matchend   offset
// set the offset to start where we left off
offset   matchend
if  matchend < checkpoint
// if we finished before hitting the end of the checkpoint from
// no mroe matches, then set ensure the text is reset to the
// defaultstyle
styleddocument setcharacterattributes matchend
checkpoint   matchend
defaultstyle
true
/**
*
* @param regexp
* @param node
*/
public void putchild string regexp  lexernode node
node defaultstyle    style stylemap get regexp
// have to compile regexp first so that it will match
children put pattern compile regexp  pattern    node
initialized   false
/**
* @param regexps
* @param node
*/
public void putchild string regexps  lexernode node
putchild buildregexp regexps   node
/**
* @param regexp
* @param style
*/
public void putstyle string regexp  style style
checkregexp regexp
stylemap put regexp  style
initialized   false
/**
* @param regexps
* @param style
*/
public void putstyle string regexps  style style
putstyle buildregexp regexps   style
/**
* @param regexp
*/
public void removechild string regexp
children remove regexp
/**
* @param regexp
*/
public void removestyle string regexp
stylemap remove regexp
children remove regexp
/**
* @param regexps
*/
public void removestyle string regexps
removestyle buildregexp regexps
public void setdefaultstyle style style
defaultstyle   style
protected class multilinerun
private position start
private position end
private int delimetersize
public multilinerun int start  int end  throws badlocationexception
this start  end  2
public multilinerun int start  int end  int delimetersize  throws badlocationexception
if  start > end
string msg
throw new badlocationexception msg  start
if  delimetersize < 1
string msg
delimetersize
throw new illegalargumentexception msg
this start   styleddocument createposition start
this end   styleddocument createposition end
this delimetersize   delimetersize
public int getdelimetersize
return delimetersize
public int end
return end getoffset
public int length
return end getoffset     start getoffset
public int start
return start getoffset
public string tostring
return start tostring         end tostring
private static class mlcomparator implements comparator
public int compare object obj  object obj1
return valueof obj    valueof obj1
private int valueof object obj
return obj instanceof integer ?
integer obj  intvalue
obj instanceof multilinerun  ?
multilinerun obj  start
position obj  getoffset