/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy tools
import groovy text regexutils
import java io
import java net malformedurlexception
import java net url
import java util arraylist
import java util list
import java util regex matcher
import java util regex pattern
/**
* class used to configure a rootloader from a stream or by using
* it's methods.
* <p/>
* the stream can be for example a fileinputstream from a file with
* the following format:
* <p/>
* <pre>
* # comment
* main is classname
* load path
* load file
* load pathwith${property}
* load pathwith!{required.property}
* load path/*.jar
* load path/&#42;&#42;/&#42;.jar
* </pre>
* <ul>
* <li>all lines starting with "#" are ignored.</li>
* <li>the "main is" part may only be once in the file. the string
* afterwards is the name of a class with a main method. </li>
* <li>the "load" command will add the given file or path to the
* classpath in this configuration object. if the path does not
* exist, the path will be ignored.
* </li>
* <li>properties referenced using !{x} are required.</li>
* <li>properties referenced using ${x} are not required. if the
* property does not exist the whole load instruction line will
* be ignored.</li>
* <li>* is used to match zero or more characters in a file.</li>
* <li>** is used to match zero or more directories.</li>
* </ul>
* <p/>
* defining the main class is required unless setrequiremain(boolean) is
* called with false, before reading the configuration.
* you can use the wildcard "*" to filter the path, but only for files, not
* directories. to match directories use "**". the ${propertyname} is replaced by the value of the system's
* property name. you can use user.home here for example. if the property does
* not exist, an empty string will be used. if the path or file after the load
* command does not exist, the path will be ignored.
*
* @author jochen theodorou
* @version $revision$
* @see rootloader
*/
public class loaderconfiguration
private static final string main_prefix      load_prefix
private list classpath   new arraylist
private string main
private boolean requiremain
private static final char wildcard
private static final string all_wildcard       wildcard   wildcard
private static final string match_file_name
private static final string match_all
/**
* creates a new loader configuration
*/
public loaderconfiguration
this requiremain   true
/**
* configures this loader with a stream
*
* @param is stream used to read the configuration
* @throws ioexception if reading or parsing the contents of the stream fails
*/
public void configure inputstream is  throws ioexception
bufferedreader reader   new bufferedreader new inputstreamreader is
int linenumber   0
while  true
string line   reader readline
if  line    null  break
line   line trim
linenumber
if  line startswith       line length      0  continue
if  line startswith load_prefix
string loadpath   line substring load_prefix length    trim
loadpath   assignproperties loadpath
loadfilteredpath loadpath
else if  line startswith main_prefix
if  main    null
throw new ioexception     linenumber       line
main   line substring main_prefix length    trim
else
throw new ioexception     linenumber       line
if  requiremain    main    null  throw new ioexception
/*
* expands the properties inside the given string to it's values.
*/
private string assignproperties string str
int propertyindexstart   0  propertyindexend   0
boolean requireproperty   false
string result
while  propertyindexstart < str length
int i1   str indexof    propertyindexstart
int i2   str indexof    propertyindexstart
if  i1     1
propertyindexstart   i2
else if  i2     1
propertyindexstart   i1
else
propertyindexstart   math min i1  i2
requireproperty   propertyindexstart    i2
if  propertyindexstart     1  break
result    str substring propertyindexend  propertyindexstart
propertyindexend   str indexof    propertyindexstart
if  propertyindexend     1  break
string propertykey   str substring propertyindexstart   2  propertyindexend
string propertyvalue   system getproperty propertykey
// assume properties contain paths
if  propertyvalue    null
if  requireproperty
throw new illegalargumentexception     propertykey       propertykey
else
return null
propertyvalue   getslashypath propertyvalue
result    propertyvalue
propertyindexend
propertyindexstart   propertyindexend
if  propertyindexstart     1    propertyindexstart >  str length
result    str substring propertyindexend
else if  propertyindexend     1
result    str substring propertyindexstart
return result
/*
* load a possibly filtered path. filters are defined
* by using the * wildcard like in any shell.
*/
private void loadfilteredpath string filter
if  filter    null  return
int starindex   filter indexof wildcard
if  starindex     1
addfile new file filter
return
boolean recursive   filter indexof all_wildcard      1
string startdir   filter substring 0  starindex   1
file root   new file startdir
filter   regexutils quote filter
filter   filter replaceall     wildcard       wildcard  match_all
filter   filter replaceall     wildcard  match_file_name
pattern pattern   pattern compile filter
final file files   root listfiles
if  files    null
findmatchingfiles files  pattern  recursive
private void findmatchingfiles file files  pattern pattern  boolean recursive
for  int i   0  i < files length  i
file file   files
string filestring   getslashypath file getpath
matcher m   pattern matcher filestring
if  m matches      file isfile
addfile file
if  file isdirectory      recursive
final file dirfiles   file listfiles
if  dirfiles    null
findmatchingfiles dirfiles  pattern  true
// change path representation to something more system independent.
// this solution is based on an absolute path
private string getslashypath final string path
string changedpath   path
if  file separatorchar
changedpath   changedpath replace file separatorchar
return changedpath
/*
* return true if the parent of the path inside the given
* string does exist
*/
private boolean parentpathdoesexist string path
file dir   new file path  getparentfile
return dir exists
/*
* seperates the given path at the last '/'
*/
private string getparentpath string filter
int index   filter lastindexof
if  index     1  return
return filter substring index   1
/**
* adds a file to the classpath if it exists.
*
* @param file the file to add
*/
public void addfile file file
if  file    null    file exists
try
classpath add file touri   tourl
catch  malformedurlexception e
throw new assertionerror
/**
* adds a file to the classpath if it exists.
*
* @param filename the name of the file to add
*/
public void addfile string filename
if  filename    null  addfile new file filename
/**
* adds a classpath to this configuration. it expects a string with
* multiple paths, seperated by the system dependent path separator
*
* @param path the path as a path separator delimited string
* @see java.io.file#pathseparator
*/
public void addclasspath string path
string paths   path split file pathseparator
for  int i   0  i < paths length  i
addfile new file paths
/**
* the classpath as url[] from this configuration.
* this can be used to construct a class loader.
*
* @return the classpath
* @see java.net.urlclassloader
*/
public url getclasspathurls
return  url  classpath toarray new url
/**
* returns the name of the main class for this configuration.
*
* @return the name of the main class or null if not defined
*/
public string getmainclass
return main
/**
* sets the main class. if there is already a main class
* it is overwritten. calling @see #configure(inputstream)
* after calling this method does not require a main class
* definition inside the stream.
*
* @param classname the name to become the main class
*/
public void setmainclass string classname
main   classname
requiremain   false
/**
* determines if a main class is required when calling.
*
* @param requiremain set to false if no main class is required
* @see #configure(inputstream)
*/
public void setrequiremain boolean requiremain
this requiremain   requiremain