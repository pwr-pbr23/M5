/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy tools
import java net url
import java net urlclassloader
import java util map
import java util hashmap
/**
* this classloader should be used as root of class loaders. any
* rootloader does have it's own classpath. when searching for a
* class or resource this classpath will be used. parent
* classloaders are ignored first. if a class or resource
* can't be found in the classpath of the rootloader, then parent is
* checked.
* <p/>
* <b>note:</b> this is very against the normal behavior of
* classloaders. normal is to first check parent and then look in
* the resources you gave this classloader.
* <p/>
* it's possible to add urls to the classpath at runtime through
* @see #addurl(url)
*      <p/>
*      <b>why using rootloader?</b>
*      if you have to load classes with multiple classloaders and a
*      classloader does know a class which depends on a class only
*      a child of this loader does know, then you won't be able to
*      load the class. to load the class the child is not allowed
*      to redirect it's search for the class to the parent first.
*      that way the child can load the class. if the child does not
*      have all classes to do this, this fails of course.
*      <p/>
*      for example:
*      <p/>
*      <pre>
*       parentloader   (has classpath: a.jar;c.jar)
*           |
*           |
*       childloader    (has classpath: a.jar;b.jar;c.jar)
*       </pre>
*      <p/>
*      class c (from c.jar) extends b (from b.jar)
*      <p/>
*      childloader.find("c")
*      --> parentloader does know c.class, try to load it
*      --> to load c.class it has to load b.class
*      --> parentloader is unable to find b.class in a.jar or c.jar
*      --> noclassdeffoundexception!
*      <p/>
*      if childloader had tried to load the class by itself, there
*      would be no problem. changing childloader to be a rootloader
*      instance will solve that problem.
*
* @author jochen theodorou
*/
public class rootloader extends urlclassloader
private map customclasses   new hashmap
/**
* constructs a new rootloader without classpath
*
* @param parent the parent loader
*/
private rootloader classloader parent
this new url  parent
/**
* constructs a new rootloader with a parent loader and an
* array of urls as classpath
*/
public rootloader url urls  classloader parent
super urls  parent
// major hack here...!
try
customclasses put   super loadclass   false
catch  exception e
private static classloader chooseparent
classloader cl   rootloader class getclassloader
if  cl    null  return cl
return classloader getsystemclassloader
/**
* constructs a new rootloader with a @see loaderconfiguration
* object which holds the classpath
*/
public rootloader loaderconfiguration lc
this chooseparent
thread currentthread   setcontextclassloader this
url urls   lc getclasspathurls
for  int i   0  i < urls length  i
addurl urls
/**
* loads a class using the name of the class
*/
protected class loadclass final string name  boolean resolve  throws classnotfoundexception
class c   this findloadedclass name
if  c    null  return c
c    class  customclasses get name
if  c    null  return c
try
c   oldfindclass name
catch  classnotfoundexception cnfe
// ignore
if  c    null  c   super loadclass name  resolve
if  resolve  resolveclass c
return c
/**
* returns the url of a resource, or null if it is not found
*/
public url getresource string name
url url   findresource name
if  url    null  url   super getresource name
return url
/**
* adds an url to the classpath of this classloader
*/
public void addurl url url
super addurl url
private class oldfindclass string name  throws classnotfoundexception
return super findclass name
protected class findclass string name  throws classnotfoundexception
throw new classnotfoundexception name