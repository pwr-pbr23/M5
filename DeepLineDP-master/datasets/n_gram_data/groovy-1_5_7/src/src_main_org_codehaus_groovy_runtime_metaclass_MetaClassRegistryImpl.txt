/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy runtime metaclass
import groovy lang
import org codehaus groovy reflection cachedclass
import org codehaus groovy reflection cachedmethod
import org codehaus groovy reflection fastarray
import org codehaus groovy reflection reflectioncache
import org codehaus groovy runtime defaultgroovymethods
import org codehaus groovy runtime defaultgroovystaticmethods
import org codehaus groovy vmplugin vmpluginfactory
import java lang ref softreference
import java lang reflect constructor
import java lang reflect modifier
import java util
/**
* a registry of metaclass instances which caches introspection &
* reflection information and allows methods to be dynamically added to
* existing classes at runtime
*
* @author <a href="mailto:james@coredevelopers.net">james strachan</a>
* @author john wilson
* @author <a href="mailto:blackdrag@gmx.org">jochen theodorou</a>
* @author graeme rocher
* @author alex tkachman
*
* @version $revision$
*/
public class metaclassregistryimpl implements metaclassregistry
private volatile int constantmetaclasscount   0
private concurrentreaderhashmap constantmetaclasses   new concurrentreaderhashmap
private memoryawareconcurrentreadmap weakmetaclasses   new memoryawareconcurrentreadmap
private memoryawareconcurrentreadmap loadermap   new memoryawareconcurrentreadmap
private boolean useaccessible
private fastarray instancemethods   new fastarray
private fastarray staticmethods   new fastarray
private volatile integer version   new integer 0
/*
we keep references to meta classes already known to this thread.
it allows us to avoid synchronization. when we need to ask global registry
we do sync but usually it is enough to check if global registry has the
same version as when we asked last time (neither removemetaclass
nor setmetaclass were called), if version changed we prefer to forget
everything we know in the thread and start again (most likely it happens not too often).
unfortunately, we have to keep it in weak map to avoid possible leak of classes.
*/
private class locallyknownclasses extends weakhashmap
int version
public static final int cache_size   5
final metaclass cache    new metaclass
int nextcacheentry
public metaclass getmetaclass class theclass
final int regv   metaclassregistryimpl this version intvalue
if  version    regv
clear
else
metaclass mc   checkcache theclass
if  mc    null
return mc
mc   checkmap theclass
if  mc    null
return mc
return getfromglobal theclass
private metaclass checkcache class theclass
for  int i   0  i    cache_size  i
final metaclass metaclass   cache
if  metaclass    null    metaclass gettheclass      theclass
return metaclass
return null
private metaclass checkmap class theclass
metaclass mc
final softreference ref    softreference  get theclass
if  ref    null     mc    metaclass  ref get       null
puttocache mc
return mc
return null
private metaclass getfromglobal class theclass
metaclass answer   getglobalmetaclass theclass
put theclass  answer
version   metaclassregistryimpl this version intvalue
return answer
public object put object key  object value
puttocache  metaclass  value
return super put key  new softreference value
private void puttocache metaclass value
cache    value
if  nextcacheentry    cache_size
nextcacheentry   0
public void clear
for  int i   0  i < cache length  i
cache    null
super clear
private mythreadlocal locallyknown   new mythreadlocal
public static final int load_default   0
public static final int dont_load_default   1
private static metaclassregistry instanceinclude
private static metaclassregistry instanceexclude
public metaclassregistryimpl
this load_default  true
public metaclassregistryimpl int loaddefault
this loaddefault  true
/**
* @param useaccessible defines whether or not the {@link java.lang.reflect.accessibleobject#setaccessible(boolean)}
*                      method will be called to enable access to all methods when using reflection
*/
public metaclassregistryimpl boolean useaccessible
this load_default  useaccessible
public metaclassregistryimpl final int loaddefault  final boolean useaccessible
this useaccessible   useaccessible
if  loaddefault    load_default
hashmap map   new hashmap
// lets register the default methods
registermethods defaultgroovymethods class  true  map
class plugindgms   vmpluginfactory getplugin   getplugindefaultgroovymethods
for  int i 0  i<plugindgms length  i
registermethods plugindgms  true  map
registermethods defaultgroovystaticmethods class  false  map
for  iterator it   map entryset   iterator    it hasnext
map entry e    map entry  it next
cachedclass cls    cachedclass  e getkey
arraylist list    arraylist  e getvalue
cls setnewmopmethods list
installmetaclasscreationhandle
final metaclass emcmetaclass   metaclasscreationhandle create expandometaclass class  this
emcmetaclass initialize
constantmetaclasses put expandometaclass class emcmetaclass
constantmetaclasscount   1
/**
* looks for a class called 'groovy.runtime.metaclass.custommetaclasscreationhandle' and if it exists uses it as the metaclasscreationhandle
* otherwise uses the default
*
* @see groovy.lang.metaclassregistry.metaclasscreationhandle
*/
private void installmetaclasscreationhandle
try
final class custommetaclasshandle   class forname
final constructor custommetaclasshandleconstructor   custommetaclasshandle getconstructor new class
this metaclasscreationhandle    metaclasscreationhandle custommetaclasshandleconstructor newinstance new object
catch  final classnotfoundexception e
this metaclasscreationhandle   new metaclasscreationhandle
catch  final exception e
throw new groovyruntimeexception    e  e
private void registermethods final class theclass  final boolean useinstancemethods  map map
cachedmethod methods   reflectioncache getcachedclass theclass  getmethods
for  int i   0  i < methods length  i
cachedmethod method   methods
final int mod   method getmodifiers
if  modifier isstatic mod     modifier ispublic mod
cachedclass paramtypes   method getparametertypes
if  paramtypes length > 0
arraylist arr    arraylist  map get paramtypes
if  arr    null
arr   new arraylist 4
map put paramtypes arr
if  useinstancemethods
final newinstancemetamethod metamethod   new newinstancemetamethod method
arr add metamethod
instancemethods add metamethod
else
final newstaticmetamethod metamethod   new newstaticmetamethod method
arr add metamethod
staticmethods add metamethod
private metaclass getglobalmetaclass  class theclass
metaclass answer null
if  constantmetaclasscount  0  answer    metaclass  constantmetaclasses get theclass
if  answer  null  return answer
answer    metaclass  weakmetaclasses get theclass
if  answer  null  return answer
synchronized  theclass
answer    metaclass  weakmetaclasses get theclass
if  answer  null  return answer
// we've got a lock on the class and we need to be sure that we're in
// the reflectioncache before we call metaclass.initialize().
// there is probably another place to do this, but i want to be sure...
final cachedclass foreffect   reflectioncache getcachedclass theclass
answer   metaclasscreationhandle create theclass  this
answer initialize
if  groovysystem iskeepjavametaclasses
constantmetaclasscount
constantmetaclasses put theclass answer
else
weakmetaclasses put theclass  answer
return answer
public metaclass getmetaclass class theclass
return locallyknown getmetaclass theclass
public synchronized void removemetaclass class theclass
version   new integer  version intvalue   1
object answer null
if  constantmetaclasscount  0  answer   constantmetaclasses remove theclass
if  answer  null
weakmetaclasses remove theclass
else
constantmetaclasscount
reflectioncache getcachedclass theclass  setstaticmetaclassfield  null
/**
* registers a new metaclass in the registry to customize the type
*
* @param theclass
* @param themetaclass
*/
public synchronized void setmetaclass class theclass  metaclass themetaclass
version   new integer  version intvalue   1
constantmetaclasscount
constantmetaclasses put theclass  themetaclass
reflectioncache getcachedclass theclass  setstaticmetaclassfield  themetaclass
public boolean useaccessible
return useaccessible
// the following is experimental code, not intended for stable use yet
private metaclasscreationhandle metaclasscreationhandle   new metaclasscreationhandle
/**
* gets a handle internally used to create metaclass implementations
* warning: experimental code, likely to change soon
* @return the handle
*/
public metaclasscreationhandle getmetaclasscreationhandler
return metaclasscreationhandle
/**
* sets a handle internally used to create metaclass implementations.
* when replacing the handle with a custom version, you should
* resuse the old handle to keep custom logic and to use the
* default logic as fallback.
* warning: experimental code, likely to change soon
* @param handle the handle
*/
public void setmetaclasscreationhandle metaclasscreationhandle handle
if handle    null  throw new illegalargumentexception
metaclasscreationhandle   handle
/**
* singleton of metaclassregistry. shall we use threadlocal to store the instance?
*
* @param includeextension
*/
public static metaclassregistry getinstance int includeextension
if  includeextension    dont_load_default
if  instanceinclude    null
instanceinclude   new metaclassregistryimpl
return instanceinclude
else
if  instanceexclude    null
instanceexclude   new metaclassregistryimpl dont_load_default
return instanceexclude
public fastarray getinstancemethods
return instancemethods
public fastarray getstaticmethods
return staticmethods
private class mythreadlocal extends threadlocal
private volatile locallyknownclasses myclasses   new locallyknownclasses
private thread mythread   thread currentthread
protected object initialvalue
return new locallyknownclasses
public metaclass getmetaclass  class theclass
return   locallyknownclasses get    getmetaclass theclass
public object get
if  thread currentthread      mythread
return super get
else
return myclasses