/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package groovy ui
import groovy lang binding
import groovy lang closure
import groovy lang groovyshell
import org codehaus groovy tools shell util messagesource
import org codehaus groovy control compilationfailedexception
import org codehaus groovy control sourceunit
import org codehaus groovy runtime invokerhelper
import org codehaus groovy runtime invokerinvocationexception
import org codehaus groovy runtime defaultgroovymethods
import org codehaus groovy tools errorreporter
import java io ioexception
import java io inputstream
import java io printstream
import java io writer
import java io outputstreamwriter
import java io printwriter
import java lang reflect method
import java util hashmap
import java util iterator
import java util map
import java util set
import org apache commons cli commandline
import org apache commons cli commandlineparser
import org apache commons cli optionbuilder
import org apache commons cli posixparser
import org apache commons cli options
import org apache commons cli helpformatter
import jline consolereader
import jline simplecompletor
//
// todo: see if there is any reason why this class is implemented in java instead of groovy, and if there
//       is none, then port it over ;-)
//
//
// note: after gshell becomes a little more mature, this shell could be easily implemented as a set of gshell
//       commands, and would inherit a lot of functionality and could be extended easily to allow groovysh
//       to become very, very powerful
//
/**
* a simple interactive shell for evaluating groovy expressions on the command line (aka. groovysh).
*
* @author <a href="mailto:james@coredevelopers.net">james strachan</a>
* @author <a href="mailto:cpoirier@dreaming.org"   >chris poirier</a>
* @author yuri schimke
* @author brian mccallistair
* @author guillaume laforge
* @author dierk koenig, include the inspect command, june 2005
* @author <a href="mailto:jason@planet57.com">jason dillon</a>
*
* @version $revision$
*/
public class interactiveshell
implements runnable
private static final string new_line   system getproperty
private static final messagesource messages   new messagesource interactiveshell class
private final groovyshell shell
private final inputstream in     fixme  this doesn't really need to be a field  but hold on to it for now
private final printstream out
private final printstream err
private final consolereader reader
private object lastresult
private closure beforeexecution
private closure afterexecution
/**
* entry point when called directly.
*/
public static void main final string args
try
processcommandlinearguments args
final interactiveshell groovy   new interactiveshell
groovy run
}
catch  exception e
system err println     e
e printstacktrace
system exit 1
}
system exit 0
}
/**
* process cli args when the shell is invoked via main().
*
* @noinspection accessstaticviainstance
*/
private static void processcommandlinearguments final string args  throws exception
assert args    null
//
// todo: let this take a single, optional argument which is a file or url to run?
//
options options   new options
options addoption optionbuilder withlongopt
withdescription messages getmessage
create
options addoption optionbuilder withlongopt
withdescription messages getmessage
create
//
// todo: add more options, maybe even add an option to prime the buffer from a url or file?
//
//
// fixme: this does not currently barf on unsupported options short options, though it does for long ones.
//        same problem with commons-cli 1.0 and 1.1
//
commandlineparser parser   new posixparser
commandline line   parser parse options  args  true
string lineargs   line getargs
// puke if there were arguments, we don't support any right now
if  lineargs length    0
system err println messages format    new object   defaultgroovymethods join lineargs
system exit 1
}
printwriter writer   new printwriter system out
if  line hasoption
helpformatter formatter   new helpformatter
formatter printhelp
writer
80     width
options
4     left pad
4     desc pad
false      auto usage
writer flush
system exit 0
}
if  line hasoption
writer println messages format    new object   invokerhelper getversion
writer flush
system exit 0
}
}
/**
* default constructor, initializes uses new binding and system streams.
*/
public interactiveshell   throws ioexception
this system in  system out  system err
}
/**
* constructs a new interactiveshell instance
*
* @param in the input stream to use
* @param out the output stream to use
* @param err the error stream to use
*/
public interactiveshell final inputstream in  final printstream out  final printstream err  throws ioexception
this null  new binding    in  out  err
}
/**
* constructs a new interactiveshell instance
*
* @param binding the binding instance
* @param in the input stream to use
* @param out the output stream to use
* @param err the error stream to use
*/
public interactiveshell final binding binding  final inputstream in  final printstream out  final printstream err  throws ioexception
this null  binding  in  out  err
}
/**
* constructs a new interactiveshell instance
*
* @param parent the parent classloader
* @param binding the binding instance
* @param in the input stream to use
* @param out the output stream to use
* @param err the error stream to use
*/
public interactiveshell final classloader parent  final binding binding  final inputstream in  final printstream out  final printstream err  throws ioexception
assert binding    null
assert in    null
assert out    null
assert err    null
this in   in
this out   out
this err   err
// initialize the jline console input reader
writer writer   new outputstreamwriter out
reader   new consolereader in  writer
reader setdefaultprompt
// add some completors to fancy things up
reader addcompletor new commandnamecompletor
if  parent    null
shell   new groovyshell parent  binding
}
else {
shell   new groovyshell binding
}
// add some default variables to the shell
map map   shell getcontext   getvariables
//
// fixme: um, is this right?  only set the "shell" var in the context if its set already?
//
if  map get       null
map put    shell
}
}
//---------------------------------------------------------------------------
// command line processing loop
//
// todo: add a general error display handler, and probably add a "error: " prefix to the result for clarity ?
//       maybe add one for warning's too?
//
/**
* reads commands and statements from input stream and processes them.
*/
public void run
// display the startup banner
out println messages format    new object   invokerhelper getversion    system getproperty
out println messages getmessage
while  true
// read a code block to evaluate; this will deal with basic error handling
final string code   read
// if we got a null, then quit
if  code    null
break
}
reset
// evaluate the code block if it was parsed
if  code length   > 0
try
if  beforeexecution    null
beforeexecution call
}
lastresult   shell evaluate code
if  afterexecution    null
afterexecution call
}
// shows the result of the evaluated code
out print
out println lastresult
}
catch  compilationfailedexception e
err println e
}
catch  throwable e
// unroll invoker exceptions
if  e instanceof invokerinvocationexception
e   e getcause
}
filterandprintstacktrace e
}
}
}
}
/**
* a closure that is executed before the exection of a given script
*
* @param beforeexecution the closure to execute
*/
public void setbeforeexecution final closure beforeexecution
this beforeexecution   beforeexecution
}
/**
* a closure that is executed after the execution of the last script. the result of the
* execution is passed as the first argument to the closure (the value of 'it')
*
* @param afterexecution the closure to execute
*/
public void setafterexecution final closure afterexecution
this afterexecution   afterexecution
}
/**
* filter stacktraces to show only relevant lines of the exception thrown.
*
* @param cause the throwable whose stacktrace needs to be filtered
*/
private void filterandprintstacktrace final throwable cause
assert cause    null
//
// todo: use message...
//
err print
err println cause
cause printstacktrace err
//
// fixme: what is the point of this?  afaict, this just produces crappy/corrupt traces and is completely useless
//
//        stacktraceelement[] stacktrace = e.getstacktrace();
//
//        for (int i = 0; i < stacktrace.length; i++) {
//            stacktraceelement element = stacktrace[i];
//            string filename = element.getfilename();
//
//            if ((filename==null || (!filename.endswith(".java")) && (!element.getclassname().startswith("gjdk")))) {
//                err.print("\tat ");
//                err.println(element);
//            }
//        }
}
//---------------------------------------------------------------------------
// command line processing machinery
/** the statement text accepted to date */
private stringbuffer accepted   new stringbuffer
/** a line of statement text not yet accepted */
private string pending
//
// fixme: doesn't look like 'line' is really used/needed anywhere... could drop it, or perhaps
//        could use it to update the prompt er something to show the buffer size?
//
/** the current line number */
private int line
/** set to force clear of accepted */
private boolean stale   false
/** a sourceunit used to check the statement */
private sourceunit parser
/** any actual syntax error caught during parsing */
private exception error
/**
* resets the command-line processing machinery after use.
*/
protected void reset
stale   true
pending   null
line   1
parser   null
error   null
}
//
// fixme: this javadoc is not correct... read() will return the full code block read until "go"
//
/**
* reads a single statement from the command line.  also identifies
* and processes command shell commands.  returns the command text
* on success, or null when command processing is complete.
*
* note: changed, for now, to read until 'execute' is issued.  at
* 'execute', the statement must be complete.
*/
protected string read
reset
boolean complete   false
boolean done   false
while      complete        done
// read a line.  if ioexception or null, or command "exit", terminate processing.
try
pending   reader readline
}
catch  ioexception e
//
// fixme: shouldn't really eat this exception, may be something we need to see... ?
//
}
// if result is null then we are shutting down
if  pending    null
return null
}
// first up, try to process the line as a command and proceed accordingly
// trim what we have for use in command bits, so things like "help " actually show the help screen
string command   pending trim
if  command_mappings containskey command
int code     integer command_mappings get command   intvalue
switch  code
case command_id_exit
return null
case command_id_help
displayhelp
break
case command_id_discard
reset
done   true
break
case command_id_display
displaystatement
break
case command_id_explain
explainstatement
break
case command_id_binding
displaybinding
break
case command_id_execute
if  complete
done   true
}
else {
err println messages getmessage
}
break
case command_id_discard_loaded_classes
resetloadedclasses
break
case command_id_inspect
inspect
break
default
throw new error     code
}
// finished processing command bits, continue reading, don't need to process code
continue
}
// otherwise, it's part of a statement.  if it's just whitespace,
// we'll just accept it and move on.  otherwise, parsing is attempted
// on the cumulated statement text, and errors are reported.  the
// pending input is accepted or rejected based on that parsing.
freshen
if  pending trim   length      0
accept
continue
}
// try to parse the current code buffer
final string code   current
if  parse code
// code parsed fine
accept
complete   true
}
else if  error    null
// um... ???
accept
}
else {
// parse failed, spit out something to the user
report
}
}
// get and return the statement.
return accepted complete
}
private void inspect
if  lastresult    null
err println messages getmessage
return
}
//
// fixme: update this once we have joint compile happy in the core build?
//
// this should read: groovy.inspect.swingui.objectbrowser.inspect(lastresult)
// but this doesnt compile since objectbrowser.groovy is compiled after this class.
//
//
// fixme: when launching this, if the user tries to "exit" and the window is still opened, the shell will
//        hang... not really nice user experence imo.  should try to fix this if we can.
//
try
class type   class forname
method method   type getmethod    new class  object class
method invoke type  new object  lastresult
}
catch  exception e
err println
e printstacktrace
}
}
/**
* returns the accepted statement as a string.  if not complete, returns empty string.
*/
private string accepted final boolean complete
if  complete
return accepted tostring
}
return
}
/**
* returns the current statement, including pending text.
*/
private string current
return accepted tostring     pending   new_line
}
/**
* accepts the pending text into the statement.
*/
private void accept
accepted append pending  append new_line
line    1
}
/**
* clears accepted if stale.
*/
private void freshen
if  stale
accepted setlength 0
stale   false
}
}
//---------------------------------------------------------------------------
// support routines
/**
* attempts to parse the specified code with the specified tolerance.
* updates the <code>parser</code> and <code>error</code> members
* appropriately.  returns true if the text parsed, false otherwise.
* the attempts to identify and suppress errors resulting from the
* unfinished source text.
*/
private boolean parse final string code  final int tolerance
assert code    null
boolean parsed   false
parser   null
error   null
// create the parser and attempt to parse the text as a top-level statement.
try
parser   sourceunit create    code  tolerance
parser parse
parsed   true
}
// we report errors other than unexpected eof to the user.
catch  compilationfailedexception e
if  parser geterrorcollector   geterrorcount   > 1     parser failedwithunexpectedeof
error   e
}
}
catch  exception e
error   e
}
return parsed
}
private boolean parse final string code
return parse code  1
}
/**
* reports the last parsing error to the user.
*/
private void report
err println        todo  i18n
new errorreporter error  false  write err
}
//-----------------------------------------------------------------------
// commands
//
// todo: add a simple command to read in a file/url into the buffer for execution, but need better command
//       support first (aka gshell) so we can allow commands to take args, etc.
//
private static final int command_id_exit   0
private static final int command_id_help   1
private static final int command_id_discard   2
private static final int command_id_display   3
private static final int command_id_explain   4
private static final int command_id_execute   5
private static final int command_id_binding   6
private static final int command_id_discard_loaded_classes   7
private static final int command_id_inspect   8
private static final int last_command_id   8
private static final string commands
private static final map command_mappings   new hashmap
static
for  int i   0  i <  last_command_id  i
command_mappings put commands  new integer i
}
// a few synonyms
command_mappings put    new integer command_id_exit
command_mappings put    new integer command_id_execute
}
private static final map command_help   new hashmap
static
command_help put commands         messages getmessage
command_help put commands         messages getmessage
command_help put commands      messages getmessage
command_help put commands      messages getmessage
//
// fixme: if this is disabled, then er comment it out, so it doesn't confuse the user
//
command_help put commands      messages getmessage
command_help put commands      messages getmessage
command_help put commands      messages getmessage
command_help put commands
messages getmessage
command_help put commands      messages getmessage
}
/**
* displays help text about available commands.
*/
private void displayhelp
out println messages getmessage
for  int i   0  i <  last_command_id  i
out print
out println command_help get commands
}
}
/**
* displays the accepted statement.
*/
private void displaystatement
final string lines   accepted tostring   split new_line
if  lines length    1    lines trim   equals
out println messages getmessage
}
else {
// eh, try to pick a decent pad size... but don't try to hard
int padsize   2
if  lines length >  10  padsize
if  lines length >  100  padsize
if  lines length >  1000  padsize
// dump the current buffer with a line number prefix
for  int i   0  i < lines length  i
// normalize the field size of the line number
string lineno   defaultgroovymethods padleft string valueof i   1   new integer padsize
out print lineno
out print
out println lines
}
}
}
/**
* displays the current binding used when instanciating the shell.
*/
private void displaybinding
binding context   shell getcontext
map variables   context getvariables
set set   variables keyset
if  set isempty
out println messages getmessage
}
else {
out println messages getmessage
iterator iter   set iterator
while  iter hasnext
object key   iter next
out print
out print key
out print
out println variables get key
}
}
}
/**
* attempts to parse the accepted statement and display the parse tree for it.
*/
private void explainstatement
if  parse accepted true   10     error    null
out println messages getmessage
//out.println(tree);
}
else {
out println messages getmessage
}
}
private void resetloadedclasses
shell resetloadedclasses
out println messages getmessage
}
//
// custom jline completors to fancy up the user experence more.
//
private class commandnamecompletor
extends simplecompletor
public commandnamecompletor
super new string
// add each command name/alias as a candidate
iterator iter   command_mappings keyset   iterator
while  iter hasnext
addcandidatestring  string iter next
}
}
}
//
// todo: add local variable completion?
//
//
// todo: add shell method complention?
//
/*
private void findshellmethods(string complete) {
list methods = shell.getmetaclass().getmetamethods();
for (iterator i = methods.iterator(); i.hasnext();) {
metamethod method = (metamethod) i.next();
if (method.getname().startswith(complete)) {
if (method.getparametertypes().length > 0) {
completions.add(method.getname() + "(");
}
else {
completions.add(method.getname() + "()");
}
}
}
}
private void findlocalvariables(string complete) {
set names = shell.getcontext().getvariables().keyset();
for (iterator i = names.iterator(); i.hasnext();) {
string name = (string) i.next();
if (name.startswith(complete)) {
completions.add(name);
}
}
}
*/
}