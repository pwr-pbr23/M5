/*
* $id$
*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package groovy inspect swingui
/**
* a sorter for tablemodels. the sorter has a model (conforming to tablemodel)
* and itself implements tablemodel. tablesorter does not store or copy
* the data in the tablemodel, instead it maintains an array of
* integers which it keeps the same size as the number of rows in its
* model. when the model changes it notifies the sorter that something
* has changed eg. "rowsadded" so that its internal array of integers
* can be reallocated. as requests are made of the sorter (like
* getvalueat(row, col) it redirects them to its model via the mapping
* array. that way the tablesorter appears to hold another copy of the table
* with the rows in a different order. the sorting algorthm used is stable
* which means that it does not move around rows when its comparison
* function returns 0 to denote that they are equivalent.
*
* @version 1.12 01/23/03
* @author philip milne
* @author minimal adjustments by dierk koenig, june 2005
*/
import javax swing
import javax swing event tablemodelevent
import javax swing table jtableheader
import javax swing table tablecolumnmodel
import javax swing table tablemodel
import java awt event mouseadapter
import java awt event mouseevent
import java util date
import java util vector
public class tablesorter extends tablemap
int indexes
vector sortingcolumns   new vector
boolean ascending   true
int lastsortedcolumn    1
public tablesorter
indexes   new int     for consistency
public tablesorter tablemodel model
setmodel model
public void setmodel tablemodel model
super setmodel model
reallocateindexes
public int comparerowsbycolumn int row1  int row2  int column
class type   model getcolumnclass column
tablemodel data   model
// check for nulls
object o1   data getvalueat row1  column
object o2   data getvalueat row2  column
// if both values are null return 0
if  o1    null    o2    null
return 0
else if  o1    null       define null less than everything
return  1
else if  o2    null
return 1
/* we copy all returned values from the getvalue call in case
an optimised model is reusing one object to return many values.
the number subclasses in the jdk are immutable and so will not be used in
this way but other subclasses of number might want to do this to save
space and avoid unnecessary heap allocation.
*/
if  type getsuperclass      java lang number class
return comparenumbers data  row1  column  row2
if  type    java util date class
return comparedates data  row1  column  row2
if  type    string class
return comparestrings data  row1  column  row2
if  type    boolean class
return comparebooleans data  row1  column  row2
return compareobjects data  row1  column  row2
private int compareobjects tablemodel data  int row1  int column  int row2
object v1   data getvalueat row1  column
string s1   v1 tostring
object v2   data getvalueat row2  column
string s2   v2 tostring
int result   s1 compareto s2
if  result < 0
return  1
if  result > 0
return 1
return 0
private int comparebooleans tablemodel data  int row1  int column  int row2
boolean bool1    boolean  data getvalueat row1  column
boolean b1   bool1 booleanvalue
boolean bool2    boolean  data getvalueat row2  column
boolean b2   bool2 booleanvalue
if  b1    b2
return 0
if  b1     define false < true
return 1
return  1
private int comparestrings tablemodel data  int row1  int column  int row2
string s1    string  data getvalueat row1  column
string s2    string  data getvalueat row2  column
int result   s1 compareto s2
if  result < 0
return  1
if  result > 0
return 1
return 0
private int comparedates tablemodel data  int row1  int column  int row2
date d1    date  data getvalueat row1  column
long n1   d1 gettime
date d2    date  data getvalueat row2  column
long n2   d2 gettime
if  n1 < n2
return  1
if  n1 > n2
return 1
return 0
private int comparenumbers tablemodel data  int row1  int column  int row2
number n1    number  data getvalueat row1  column
double d1   n1 doublevalue
number n2    number  data getvalueat row2  column
double d2   n2 doublevalue
if  d1 < d2
return  1
if  d1 > d2
return 1
return 0
public int compare int row1  int row2
for  int level   0  level < sortingcolumns size    level
integer column    integer  sortingcolumns elementat level
int result   comparerowsbycolumn row1  row2  column intvalue
if  result    0
return ascending ? result    result
return 0
public void reallocateindexes
int rowcount   model getrowcount
// set up a new array of indexes with the right number of elements
// for the new data model.
indexes   new int
// initialise with the identity mapping.
for  int row   0  row < rowcount  row
indexes   row
public void tablechanged tablemodelevent e
system out println
reallocateindexes
super tablechanged e
public void checkmodel
if  indexes length    model getrowcount
system err println
public void sort object sender
checkmodel
shuttlesort  int  indexes clone    indexes  0  indexes length
public void n2sort
for  int i   0  i < getrowcount    i
for  int j   i   1  j < getrowcount    j
if  compare indexes  indexes      1
swap i  j
// this is a home-grown implementation which we have not had time
// to research - it may perform poorly in some circumstances. it
// requires twice the space of an in-place algorithm and makes
// nlogn assigments shuttling the values between the two
// arrays. the number of compares appears to vary between n-1 and
// nlogn depending on the initial order but the main reason for
// using it here is that, unlike qsort, it is stable.
public void shuttlesort int from  int to  int low  int high
if  high   low < 2
return
int middle    low   high    2
shuttlesort to  from  low  middle
shuttlesort to  from  middle  high
int p   low
int q   middle
/* this is an optional short-cut; at each recursive call,
check to see if the elements in this subset are already
ordered.  if so, no further comparisons are needed; the
sub-array can just be copied.  the array must be copied rather
than assigned otherwise sister calls in the recursion might
get out of sinc.  when the number of elements is three they
are partitioned so that the first set, [low, mid), has one
element and and the second, [mid, high), has two. we skip the
optimisation when the number of elements is three or less as
the first compare in the normal merge will produce the same
sequence of steps. this optimisation seems to be worthwhile
for partially ordered lists but some analysis is needed to
find out how the performance drops to nlog(n) as the initial
order diminishes - it may drop very quickly.  */
if  high   low >  4    compare from  from  <  0
system arraycopy from  low  to  low  high   low
return
// a normal merge.
for  int i   low  i < high  i
if  q >  high     p < middle    compare from  from  <  0
to   from
else
to   from
public void swap int i  int j
int tmp   indexes
indexes   indexes
indexes   tmp
// the mapping only affects the contents of the data rows.
// pass all requests to these rows through the mapping array: "indexes".
public object getvalueat int arow  int acolumn
checkmodel
return model getvalueat indexes  acolumn
public void setvalueat object avalue  int arow  int acolumn
checkmodel
model setvalueat avalue  indexes  acolumn
public void sortbycolumn int column
sortbycolumn column  true
public void sortbycolumn int column  boolean ascending
this ascending   ascending
sortingcolumns removeallelements
sortingcolumns addelement new integer column
sort this
super tablechanged new tablemodelevent this
// there is no-where else to put this.
// add a mouse listener to the table to trigger a table sort
// when a column heading is clicked in the jtable.
public void addmouselistenertoheaderintable jtable table
final tablesorter sorter   this
final jtable tableview   table
tableview setcolumnselectionallowed false
mouseadapter listmouselistener   new mouseadapter
public void mouseclicked mouseevent e
tablecolumnmodel columnmodel   tableview getcolumnmodel
int viewcolumn   columnmodel getcolumnindexatx e getx
int column   tableview convertcolumnindextomodel viewcolumn
if  e getclickcount      1    column     1
if  lastsortedcolumn    column  ascending    ascending
sorter sortbycolumn column  ascending
lastsortedcolumn   column
jtableheader th   tableview gettableheader
th addmouselistener listmouselistener