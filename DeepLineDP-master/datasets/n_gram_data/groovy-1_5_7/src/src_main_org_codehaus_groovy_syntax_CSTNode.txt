/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy syntax
import org codehaus groovy groovybugerror
import java io stringwriter
import java io printwriter
/**
*  an abstract base class for nodes in the concrete syntax tree that is
*  the result of parsing.  note that the cstnode is inextricably linked
*  with the token in that every cstnode has a token as it's root.
*
*  @see antlr.parser
*  @see token
*  @see org.codehaus.groovy.syntax.reduction
*  @see org.codehaus.groovy.syntax.types
*
*  @author <a href="mailto:bob@werken.com">bob mcwhirter</a>
*  @author <a href="mailto:cpoirier@dreaming.org">chris poirier</a>
*
*  @version $id$
*/
public abstract class cstnode
//---------------------------------------------------------------------------
// node identification and meaning
/**
*  returns the meaning of this node.  if the node isempty(), returns
*  the type of token.null.
*/
public int getmeaning
return getroot  true   getmeaning
/**
*  sets the meaning for this node (and it's root token).  not
*  valid if the node isempty().  returns the node, for convenience.
*/
public cstnode setmeaning  int meaning
getroot   setmeaning  meaning
return this
/**
*  returns the actual type of the node.  if the node isempty(), returns
*  the type of token.null.
*/
public int gettype
return getroot  true   gettype
/**
*  returns true if the node can be coerced to the specified type.
*/
public boolean canmean  int type
return types canmean  getmeaning    type
/**
*  returns true if the node's meaning matches the specified type.
*/
public boolean isa  int type
return types oftype  getmeaning    type
/**
*  returns true if the node's meaning matches any of the specified types.
*/
public boolean isoneof  int types
int meaning   getmeaning
for  int i   0  i < types length  i
if  types oftype meaning  types
return true
return false
/**
*  returns true if the node's meaning matches all of the specified types.
*/
public boolean isallof  int types
int meaning   getmeaning
for  int i   0  i < types length  i
if   types oftype meaning  types
return false
return true
/**
*  returns the first matching meaning of the specified types.
*  returns types.unknown if there are no matches.
*/
public int getmeaningas  int types
for  int i   0  i < types length  i
if  isa types
return types
return types unknown
//---------------------------------------------------------------------------
// type sugar
/**
*  returns true if the node matches the specified type.  effectively
*  a synonym for <code>isa()</code>.  missing nodes are token.null.
*/
boolean matches  int type
return isa type
/**
*  returns true if the node and it's first child match the specified
*  types.  missing nodes are token.null.
*/
boolean matches  int type  int child1
return isa type     get 1  true  isa child1
/**
*  returns true if the node and it's first and second child match the
*  specified types.  missing nodes are token.null.
*/
boolean matches  int type  int child1  int child2
return matches  type  child1      get 2  true  isa child2
/**
*  returns true if the node and it's first three children match the
*  specified types.  missing nodes are token.null.
*/
boolean matches  int type  int child1  int child2  int child3
return matches  type  child1  child2      get 3  true  isa child3
/**
*  returns true if the node an it's first four children match the
*  specified types.  missing nodes have type types.null.
*/
boolean matches  int type  int child1  int child2  int child3  int child4
return matches  type  child1  child2  child3      get 4  true  isa child4
//---------------------------------------------------------------------------
// member access
/**
*  returns true if the node is completely empty (no root, even).
*/
public boolean isempty
return false
/**
*  returns the number of elements in the node (including root).
*/
public abstract int size
/**
*  returns true if the node has any non-root elements.
*/
public boolean haschildren
return children   > 0
/**
*  returns the number of non-root elements in the node.
*/
public int children
int size   size
if  size > 1
return size   1
return 0
/**
*  returns the specified element, or null.
*/
public abstract cstnode get  int index
/**
*  returns the specified element, or token.null if
*  safe is set and the specified element is null (or doesn't
*  exist).
*/
public cstnode get  int index  boolean safe
cstnode element   get  index
if  element    null    safe
element   token null
return element
/**
*  returns the root of the node.  by convention, all nodes have
*  a token as the first element (or root), which indicates the type
*  of the node.  may return null if the node <code>isempty()</code>.
*/
public abstract token getroot
/**
*  returns the root of the node, the token that indicates it's
*  type.  returns a token.null if safe and the actual root is null.
*/
public token getroot  boolean safe
token root   getroot
if  root    null    safe
root   token null
return root
/**
*  returns the text of the root.  uses <code>getroot(true)</code>
*  to get the root, so you will only receive null in return if the
*  root token returns it.
*/
public string getroottext
token root   getroot  true
return root gettext
/**
*  returns a description of the node.
*/
public string getdescription
return types getdescription  getmeaning
/**
*  returns the starting line of the node.  returns -1
*  if not known.
*/
public int getstartline
return getroot true  getstartline
/**
*  returns the starting column of the node.  returns -1
*  if not known.
*/
public int getstartcolumn
return getroot true  getstartcolumn
/**
*  marks the node a complete expression.  not all nodes support
*  this operation!
*/
public void markasexpression
throw new groovybugerror
/**
*  returns true if the node is a complete expression.
*/
public boolean isanexpression
return isa types simple_expression
//---------------------------------------------------------------------------
// operations
/**
*  adds an element to the node.  returns the element for convenience.
*  not all nodes support this operation!
*/
public cstnode add  cstnode element
throw new groovybugerror
/**
*  adds all children of the specified node to this one.  not all
*  nodes support this operation!
*/
public void addchildrenof  cstnode of
for  int i   1  i < of size    i
add  of get i
/**
*  sets an element node in at the specified index.  returns the element
*  for convenience.  not all nodes support this operation!
*/
public cstnode set  int index  cstnode element
throw new groovybugerror
/**
*  creates a <code>reduction</code> from this node.  returns self if the
*  node is already a <code>reduction</code>.
*/
public abstract reduction asreduction
//---------------------------------------------------------------------------
// string conversion
/**
*  formats the node as a <code>string</code> and returns it.
*/
public string tostring
stringwriter string   new stringwriter
write  new printwriter string
string flush
return string tostring
/**
*  formats the node and writes it to the specified <code>writer</code>.
*/
public void write  printwriter writer
write  writer
/**
*  formats the node and writes it to the specified <code>writer</code>.
*  the indent is prepended to each output line, and is increased for each
*  recursion.
*/
protected void write  printwriter writer  string indent
writer print
if   isempty
token  root   getroot  true
int    type   root gettype
int meaning   root getmeaning
//
// display our type, text, and (optional) meaning
writer print  types getdescription type
if  meaning    type
writer print
writer print  types getdescription meaning
if  getstartline   >  1
writer print      getstartline         getstartcolumn
string text   root gettext
int  length   text length
if  length > 0
writer print
if  length > 40
text   text substring  0  17         text substring  length   17  length
writer print   "
writer print  text
writer print    "
else if  children   > 0
writer print
//
// recurse to display the children.
int count   size
if  count > 1
writer println
string indent1   indent
string indent2   indent
for  int i   1  i < count  i
writer print  indent1
writer print  i
writer print
get  i  true   write  writer  indent2
writer print  indent
if  indent length   > 0
writer println
else
writer print