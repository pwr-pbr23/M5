/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy syntax
import org codehaus groovy ast classnode
import org codehaus groovy ast modulenode
import org codehaus groovy control sourceunit
import java util arraylist
import java util hashmap
import java util list
import java util map
/**
* a common base class of ast helper methods which can be shared across the classic and new parsers
*
* @author jochen theodorou
* @author james strachan
* @author bob mcwhirter
* @author sam pullara
* @author chris poirier
* @version $revision$
*/
public class asthelper
/** the sourceunit controlling us */
private sourceunit controller
/** our classloader, which provides information on external types */
private classloader classloader
/** our imports, simple name => fully qualified name */
protected map imports
/** our explicit static imports, simple name => fully qualified name */
protected map staticimports
/** our implicit static imports */
protected list staticdotimports
protected modulenode output
/** the package name in which the module sits */
private string packagename
// todo should this really be static???
protected static map resolutions   new hashmap        cleared on build    to be safe
//    private static string not_resolved = new string();
/** temporarily store the class names that the current modulenode contains */
private final list newclasses   new arraylist
public asthelper sourceunit controller  classloader classloader
this
this controller   controller
this classloader   classloader
}
public asthelper
imports   new hashmap
staticimports   new hashmap
staticdotimports   new arraylist
}
public string getpackagename
return packagename
}
public void setpackagename string packagename
this packagename   packagename
if  packagename  null    packagename length  >0
packagename
}
output setpackagename packagename
}
/**
* returns our class loader (as supplied on construction).
*/
public classloader getclassloader
return classloader
}
public void setclassloader classloader classloader
this classloader   classloader
}
public sourceunit getcontroller
return controller
}
public void setcontroller sourceunit controller
this controller   controller
}
/**
* returns a fully qualified name for any given potential type
* name.  returns null if no qualified name could be determined.
*/
/*    protected string resolvename(string name, boolean safe) {
//
// use our cache of resolutions, if possible
string resolution = (string) resolutions.get(name);
if (not_resolved.equals(resolution)) {
return (safe ? name : null);
}
else if (resolution != null) {
return (string) resolution;
}
try {
getclassloader().loadclass(name);
resolutions.put(name,name);
return name;
} catch (classnotfoundexception cnfe){
if (cnfe.getcause() instanceof multiplecompilationerrorsexception) {
multiplecompilationerrorsexception mcee = (multiplecompilationerrorsexception) cnfe.getcause();
controller.geterrorcollector().addcollectorcontents(mcee.geterrorcollector());
resolutions.put(name,name);
return name;
}
} catch (noclassdeffounderror ncdfe) {
//fall through
}
do {
//
// if the type name contains a ".", it's probably fully
// qualified, and we don't take it to verification here.
if (name.indexof(".") >= 0) {
resolution = name;
break;                                            // <<< flow control <<<<<<<<<
}
//
// otherwise, we'll need the scalar type for checking, and
// the postfix for reassembly.
string scalar = name, postfix = "";
while (scalar.endswith("[]")) {
scalar = scalar.substring(0, scalar.length() - 2);
postfix += "[]";
}
//
// primitive types are all valid...
if (types.oftype(types.lookupkeyword(scalar), types.primitive_type)) {
resolution = name;
break;                                            // <<< flow control <<<<<<<<<
}
//
// next, check our imports and return the qualified name,
// if available.
if (this.imports.containskey(scalar)) {
resolution = ((string) this.imports.get(scalar)) + postfix;
break;                                            // <<< flow control <<<<<<<<<
}
//
// next, see if our class loader can resolve it in the current package.
if (packagename != null && packagename.length() > 0) {
try {
getclassloader().loadclass(dot(packagename, scalar));
resolution = dot(packagename, name);
break;                                        // <<< flow control <<<<<<<<<
} catch (classnotfoundexception cnfe){
if (cnfe.getcause() instanceof compilationfailedexception) {
resolution = dot(packagename, name);
break;
}
} catch (noclassdeffounderror ncdfe) {
//fall through
}
}
// search the package imports path
list packageimports = output.getimportpackages();
for (int i = 0; i < packageimports.size(); i++) {
string pack = (string) packageimports.get(i);
string clsname = pack + name;
try {
getclassloader().loadclass(clsname);
resolution = clsname;
break;
} catch (classnotfoundexception cnfe){
if (cnfe.getcause() instanceof compilationfailedexception) {
resolution = clsname;
break;
}
} catch (noclassdeffounderror ncdfe) {
//fall through
}
}
if (resolution != null) {
break;
}
//
// last chance, check the default imports.
for (int i = 0; i < default_imports.length; i++) {
string qualified = default_imports[i] + scalar;
try {
getclassloader().loadclass(qualified);
resolution = qualified + postfix;
break;                                        // <<< flow control <<<<<<<<<
} catch (classnotfoundexception cnfe){
if (cnfe.getcause() instanceof compilationfailedexception) {
resolution = qualified + postfix;
break;
}
} catch (noclassdeffounderror ncdfee) {
// fall through
}
}
}
while (false);
//
// cache the solution and return it
if (resolution == null) {
resolutions.put(name, not_resolved);
return (safe ? name : null);
}
else {
resolutions.put(name, resolution);
return resolution;
}
}
*/
/**
* returns two names joined by a dot.  if the base name is
* empty, returns the name unchanged.
*/
public static string dot string base  string name
if  base    null    base length   > 0
return base       name
}
return name;
}
protected void makemodule
this newclasses clear
this output   new modulenode controller
resolutions clear
}
/**
* a synonym for <code>dot( base, "" )</code>.
*/
protected string dot string base
return dot base
}
/*protected string resolvenewclassorname(string name, boolean safe) {
if (this.newclasses.contains(name)) {
return dot(packagename, name);
}
else {
return resolvename(name, safe);
}
}*/
protected void addnewclassname string name
this newclasses add name
}
protected void importclass classnode type  string name  string as
if  as    null  as name
output addimport as  type
imports put as  type
}
protected void staticimportmethodorfield classnode type  string name  string alias
if  alias    null  alias   name
output addstaticmethodorfield type  name  alias
}
protected void staticimportclasswithstar classnode type  string importclass
// keep track of the fact that it was a static import
output addstaticimportclass importclass  type
}
protected void importpackagewithstar string importpackage
string classes   output addimportpackage  dot importpackage
for  int i   0  i < classes length  i
imports put  classes  dot importpackage  classes
}
}
}