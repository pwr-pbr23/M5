/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy antlr
import antlr recognitionexception
import antlr tokenstreamexception
import antlr tokenstreamrecognitionexception
import antlr collections ast
import com thoughtworks xstream xstream
import org codehaus groovy groovybugerror
import org codehaus groovy antlr parser groovylexer
import org codehaus groovy antlr parser groovyrecognizer
import org codehaus groovy antlr parser groovytokentypes
import org codehaus groovy antlr treewalker
import org codehaus groovy ast
import org codehaus groovy ast expr
import org codehaus groovy ast stmt
import org codehaus groovy control compilationfailedexception
import org codehaus groovy control parserplugin
import org codehaus groovy control sourceunit
import org codehaus groovy syntax
import org objectweb asm opcodes
import java io
import java security accesscontroller
import java security privilegedaction
import java util arraylist
import java util iterator
import java util linkedlist
import java util list
/**
* a parser plugin which adapts the jsr antlr parser to the groovy runtime
*
* @author <a href="mailto:jstrachan@protique.com">james strachan</a>
* @version $revision$
*/
public class antlrparserplugin extends asthelper implements parserplugin  groovytokentypes
private ast ast
private classnode classnode
private string tokennames
public reduction parsecst final sourceunit sourceunit  reader reader  throws compilationfailedexception
ast   null
setcontroller sourceunit
final sourcebuffer sourcebuffer   new sourcebuffer
unicodeescapingreader unicodereader   new unicodeescapingreader reader sourcebuffer
groovylexer lexer   new groovylexer unicodereader
unicodereader setlexer lexer
groovyrecognizer parser   groovyrecognizer make lexer
parser setsourcebuffer sourcebuffer
tokennames   parser gettokennames
parser setfilename sourceunit getname
// start parsing at the compilationunit rule
try
parser compilationunit
}
catch  tokenstreamrecognitionexception tsre
recognitionexception e   tsre recog
syntaxexception se   new syntaxexception e getmessage   e e getline   e getcolumn
se setfatal true
sourceunit adderror se
}
catch  recognitionexception e
syntaxexception se   new syntaxexception e getmessage   e e getline   e getcolumn
se setfatal true
sourceunit adderror se
}
catch  tokenstreamexception e
sourceunit addexception e
}
ast   parser getast
antlrastprocessor snippets   new antlrastprocesssnippets sourcebuffer
ast   snippets process ast
accesscontroller doprivileged new privilegedaction
public object run
outputastinvariousformsifneeded sourceunit  sourcebuffer
return null;
}
return null    new reduction tpken eof
}
private void outputastinvariousformsifneeded sourceunit sourceunit  sourcebuffer sourcebuffer
// straight xstream output of ast
if    equals system getproperty
saveasxml sourceunit getname    ast
}
// 'pretty printer' output of ast
if    equals system getproperty
try
printstream out   new printstream new fileoutputstream sourceunit getname
visitor visitor   new sourceprinter out tokennames
antlrastprocessor treewalker   new sourcecodetraversal visitor
treewalker process ast
catch  filenotfoundexception e
system out println     sourceunit getname
}
}
// output ast in format suitable for opening in http://freemind.sourceforge.net
// which is a really nice way of seeing the ast, folding nodes etc
if    equals system getproperty
try
printstream out   new printstream new fileoutputstream sourceunit getname
visitor visitor   new mindmapprinter out tokennames
antlrastprocessor treewalker   new preordertraversal visitor
treewalker process ast
catch  filenotfoundexception e
system out println     sourceunit getname
}
}
// include original line/col info and source code on the mindmap output
if    equals system getproperty
try
printstream out   new printstream new fileoutputstream sourceunit getname
visitor visitor   new mindmapprinter out tokennames sourcebuffer
antlrastprocessor treewalker   new preordertraversal visitor
treewalker process ast
catch  filenotfoundexception e
system out println     sourceunit getname
}
}
// html output of ast
if    equals system getproperty
try
printstream out   new printstream new fileoutputstream sourceunit getname
list v   new arraylist
v add new nodeashtmlprinter out tokennames
v add new sourceprinter out tokennames
visitor visitors   new compositevisitor v
antlrastprocessor treewalker   new sourcecodetraversal visitors
treewalker process ast
catch  filenotfoundexception e
system out println     sourceunit getname
}
}
}
private void saveasxml string name  ast ast
xstream xstream   new xstream
try
xstream toxml ast  new filewriter name
system out println     name
}
catch  exception e
system out println     name
e printstacktrace
}
}
public modulenode buildast sourceunit sourceunit  classloader classloader  reduction cst  throws parserexception
setclassloader classloader
makemodule
try
convertgroovy ast
}
catch  astruntimeexception e
throw new astparserexception e getmessage         sourceunit getname    e
}
return output
}
/**
* converts the antlr ast to the groovy ast
*/
protected void convertgroovy ast node
while  node    null
int type   node gettype
switch  type
case package_def
packagedef node
break
case static_import
case import
importdef node
break
case class_def
classdef node
break
case interface_def
interfacedef node
break
case method_def
methoddef node
break
case enum_def
enumdef node
break
default
statement statement   statement node
output addstatement statement
}
}
node   node getnextsibling
}
}
// top level control structures
//-------------------------------------------------------------------------
protected void packagedef ast packagedef
ast node   packagedef getfirstchild
if  istype annotations  node
node   node getnextsibling
}
string name   qualifiedname node
setpackagename name
}
protected void importdef ast importnode
boolean isstatic   importnode gettype      static_import
ast node   importnode getfirstchild
string alias   null
if  istype literal_as  node
//import is like "import foo as bar"
node   node getfirstchild
ast aliasnode   node getnextsibling
alias   identifier aliasnode
}
if  node getnumberofchildren    0
string name   identifier node
// import is like  "import foo"
classnode type   classhelper make name
configureast type importnode
importclass type  name  alias
return
}
ast packagenode   node getfirstchild
string packagename   qualifiedname packagenode
ast namenode   packagenode getnextsibling
if  istype star  namenode
if  isstatic
// import is like "import static foo.bar.*"
// packagename is actually a classname in this case
classnode type   classhelper make packagename
configureast type  importnode
staticimportclasswithstar type  packagename
else
// import is like "import foo.*"
importpackagewithstar packagename
}
if  alias  null  throw new groovybugerror
else
string name   identifier namenode
if  isstatic
// import is like "import static foo.bar.method"
// packagename is really class name in this case
classnode type   classhelper make packagename
configureast type  importnode
staticimportmethodorfield type  name  alias
else
// import is like "import foo.bar"
classnode type   classhelper make packagename   name
configureast type  importnode
importclass type  name  alias
}
}
}
protected void interfacedef ast classdef
list annotations   new arraylist
ast node   classdef getfirstchild
int modifiers   opcodes acc_public
if  istype modifiers  node
modifiers   modifiers node  annotations  modifiers
checknoinvalidmodifier classdef     modifiers  opcodes acc_synchronized
node   node getnextsibling
}
modifiers    opcodes acc_abstract   opcodes acc_interface
string name   identifier node
node   node getnextsibling
classnode superclass   classhelper object_type
genericstype genericstype   null
if  istype type_parameters node
genericstype   makegenericstype node
node   node getnextsibling
}
classnode interfaces   classnode empty_array
if  istype extends_clause  node
interfaces   interfaces node
node   node getnextsibling
}
addnewclassname name
classnode   new classnode dot getpackagename    name   modifiers  superclass  interfaces  null
classnode addannotations annotations
classnode setgenericstypes genericstype
configureast classnode  classdef
assertnodetype objblock  node
objectblock node
output addclass classnode
classnode   null
}
protected void classdef ast classdef
list annotations   new arraylist
ast node   classdef getfirstchild
int modifiers   opcodes acc_public
if  istype modifiers  node
modifiers   modifiers node  annotations  modifiers
checknoinvalidmodifier classdef     modifiers  opcodes acc_synchronized
node   node getnextsibling
}
string name   identifier node
node   node getnextsibling
genericstype genericstype   null
if  istype type_parameters node
genericstype   makegenericstype node
node   node getnextsibling
}
classnode superclass   null
if  istype extends_clause  node
superclass   maketypewitharguments node
node   node getnextsibling
}
classnode interfaces   classnode empty_array
if  istype implements_clause  node
interfaces   interfaces node
node   node getnextsibling
}
// todo read mixins
mixinnode mixins
addnewclassname name
classnode   new classnode dot getpackagename    name   modifiers  superclass  interfaces  mixins
classnode addannotations annotations
classnode setgenericstypes genericstype
configureast classnode  classdef
assertnodetype objblock  node
objectblock node
output addclass classnode
classnode   null
}
protected void objectblock ast objectblock
for  ast node   objectblock getfirstchild    node    null  node   node getnextsibling
int type   node gettype
switch  type
case objblock
objectblock node
break
case method_def
methoddef node
break
case ctor_ident
constructordef node
break
case variable_def
fielddef node
break
case static_init
staticinit node
break
case instance_init
objectinit node
break
case enum_def
enumdef node
break
case enum_constant_def
enumconstantdef node
break
default
unknownast node
}
}
}
protected void enumdef ast enumnode
assertnodetype enum_def  enumnode
list annotations   new arraylist
ast node   enumnode getfirstchild
int modifiers   opcodes acc_public
if  istype modifiers  node
modifiers   modifiers node annotations modifiers
node   node getnextsibling
}
string name   identifier node
node   node getnextsibling
classnode interfaces   interfaces node
node   node getnextsibling
classnode enumclass   enumhelper makeenumnode dot getpackagename   name  modifiers interfaces classnode
classnode oldnode   classnode
classnode   enumclass
assertnodetype objblock  node
objectblock node
classnode   oldnode
output addclass enumclass
}
protected void enumconstantdef ast node
assertnodetype enum_constant_def  node
ast element   node getfirstchild
if  istype annotations element
element   element getnextsibling
}
string identifier   identifier element
expression init   null
element   element getnextsibling
if  element  null  init   expression element
enumhelper addenumconstant classnode  identifier  init
}
protected void throwslist ast node list list
string name
if  istype dot  node
name   qualifiedname node
else
name   identifier node
}
classnode exception   classhelper make name
configureast exception  node
list add exception
ast next   node getnextsibling
if  next  null  throwslist next  list
}
protected void methoddef ast methoddef
list annotations   new arraylist
ast node   methoddef getfirstchild
genericstype generics null
if  istype type_parameters  node
generics   makegenericstype node
node   node getnextsibling
}
int modifiers   opcodes acc_public
if  istype modifiers  node
modifiers   modifiers node  annotations  modifiers
checknoinvalidmodifier methoddef     modifiers  opcodes acc_volatile
node   node getnextsibling
}
if  isaninterface
modifiers    opcodes acc_abstract
}
classnode returntype   null
if  istype type  node
returntype   maketypewitharguments node
node   node getnextsibling
}
string name   identifier node
if  classnode    null
if  classnode getnamewithoutpackage   equals name
if  isaninterface
throw new astruntimeexception methoddef
}
throw new astruntimeexception methoddef
}
}
node   node getnextsibling
assertnodetype parameters  node
parameter parameters   parameters node
if  parameters  null  parameters   parameter empty_array
node   node getnextsibling
classnode exceptions  classnode empty_array
if  istype literal_throws  node
ast throwsnode   node getfirstchild
list exceptionlist   new arraylist
throwslist throwsnode  exceptionlist
exceptions    classnode  exceptionlist toarray exceptions
node   node getnextsibling
}
statement code   null
if   modifiers   opcodes acc_abstract     0
if  node  null
throw new astruntimeexception methoddef
}
assertnodetype slist  node
code   statementlist node
}
methodnode methodnode   new methodnode name  modifiers  returntype  parameters  exceptions  code
methodnode addannotations annotations
methodnode setgenericstypes generics
configureast methodnode  methoddef
if  classnode    null
classnode addmethod methodnode
}
else
output addmethod methodnode
}
}
private void checknoinvalidmodifier ast node  string nodetype  int modifiers  int modifier  string modifiertext
if   modifiers   modifier     0
throw new astruntimeexception node  nodetype       modifiertext
}
}
private boolean isaninterface
return classnode    null     classnode getmodifiers     opcodes acc_interface  > 0
}
protected void staticinit ast staticinit
blockstatement code    blockstatement  statementlist staticinit
classnode addstaticinitializerstatements code getstatements   false
}
protected void objectinit ast init
blockstatement code    blockstatement  statementlist init
classnode addobjectinitializerstatements code
}
protected void constructordef ast constructordef
list annotations   new arraylist
ast node   constructordef getfirstchild
int modifiers   opcodes acc_public
if  istype modifiers  node
modifiers   modifiers node  annotations  modifiers
node   node getnextsibling
}
assertnodetype parameters  node
parameter parameters   parameters node
if  parameters    null  parameters   parameter empty_array
node   node getnextsibling
classnode exceptions  classnode empty_array
if  istype literal_throws  node
ast throwsnode   node getfirstchild
list exceptionlist   new arraylist
throwslist throwsnode  exceptionlist
exceptions    classnode  exceptionlist toarray exceptions
node   node getnextsibling
}
assertnodetype slist  node
statement code   statementlist node
constructornode constructornode   classnode addconstructor modifiers  parameters  exceptions  code
constructornode addannotations annotations
configureast constructornode  constructordef
}
protected void fielddef ast fielddef
list annotations   new arraylist
ast node   fielddef getfirstchild
int modifiers   0
if  istype modifiers  node
modifiers   modifiers node  annotations  modifiers
node   node getnextsibling
}
if  classnode isinterface
modifiers    opcodes acc_static   opcodes acc_final
if    modifiers    opcodes acc_private   opcodes acc_protected      0
modifiers    opcodes acc_public
}
}
classnode type   null
if  istype type  node
type   maketypewitharguments node
node   node getnextsibling
}
string name   identifier node
node   node getnextsibling
expression initialvalue   null
if  node    null
assertnodetype assign  node
initialvalue   expression node getfirstchild
}
if  classnode isinterface      initialvalue    null    type    null
if  type  classhelper int_type
initialvalue   new constantexpression new integer 0
}
else if  type  classhelper long_type
initialvalue   new constantexpression new long 0l
}
else if  type  classhelper double_type
initialvalue   new constantexpression new double 0 0
}
else if  type  classhelper float_type
initialvalue   new constantexpression new float 0 0f
}
else if  type  classhelper boolean_type
initialvalue   constantexpression false
}
else if  type  classhelper short_type
initialvalue   new constantexpression new short  short  0
}
else if  type  classhelper byte_type
initialvalue   new constantexpression new byte  byte  0
}
else if  type  classhelper char_type
initialvalue   new constantexpression new character  char  0
}
}
fieldnode fieldnode   new fieldnode name  modifiers  type  classnode  initialvalue
fieldnode addannotations annotations
configureast fieldnode  fielddef
if   hasvisibility modifiers
// let's set the modifiers on the field
int fieldmodifiers   0
int flags   opcodes acc_static   opcodes acc_transient   opcodes acc_volatile   opcodes acc_final
if   hasvisibility modifiers
modifiers    opcodes acc_public
fieldmodifiers    opcodes acc_private
}
// let's pass along any other modifiers we need
fieldmodifiers     modifiers   flags
fieldnode setmodifiers fieldmodifiers
fieldnode setsynthetic true
// in the case that there is already a field, we would
// like to use that field, instead of the default field
// for the property
fieldnode storednode   classnode getdeclaredfield fieldnode getname
if  storednode  null     classnode hasproperty name
fieldnode   storednode
// we remove it here, because addproperty will add it
// again and we want to avoid it showing up multiple
// times in the fields list.
classnode getfields   remove storednode
}
propertynode propertynode   new propertynode fieldnode  modifiers  null  null
configureast propertynode  fielddef
classnode addproperty propertynode
else
fieldnode setmodifiers modifiers
// if there is a property of that name, then a field of that
// name already exists, which means this new field here should
// be used instead of the field the property originally has.
propertynode pn   classnode getproperty name
if  pn  null    pn getfield   issynthetic
classnode getfields   remove pn getfield
pn setfield fieldnode
}
classnode addfield fieldnode
}
}
protected classnode interfaces ast node
list interfacelist   new arraylist
for  ast implementnode   node getfirstchild    implementnode    null  implementnode   implementnode getnextsibling
interfacelist add maketypewitharguments implementnode
}
classnode interfaces   classnode empty_array
if   interfacelist isempty
interfaces   new classnode
interfacelist toarray interfaces
}
return interfaces
}
protected parameter parameters ast parametersnode
ast node   parametersnode getfirstchild
if  node    null
if  istype implicit_parameters  parametersnode   return parameter empty_array
return null;
}
else
list parameters   new arraylist
do
parameters add parameter node
node   node getnextsibling
}
while  node    null
parameter answer   new parameter
parameters toarray answer
return answer
}
}
protected parameter parameter ast paramnode
list annotations   new arraylist
boolean variableparameterdef   istype variable_parameter_def paramnode
ast node   paramnode getfirstchild
int modifiers   0
if  istype modifiers  node
modifiers   modifiers node  annotations  modifiers
node   node getnextsibling
}
classnode type   classhelper dynamic_type
if  istype type  node
type   maketypewitharguments node
if  variableparameterdef  type   type makearray
node   node getnextsibling
}
string name   identifier node
node   node getnextsibling
variableexpression leftexpression   new variableexpression name  type
configureast leftexpression  paramnode
parameter parameter   null
if  node    null
assertnodetype assign  node
expression rightexpression   expression node getfirstchild
if  isaninterface
throw new astruntimeexception node      name       rightexpression gettext
}
parameter   new parameter type  name  rightexpression
}
else
parameter   new parameter type  name
configureast parameter  paramnode
parameter addannotations annotations
return parameter
}
protected int modifiers ast modifiernode  list annotations  int defaultmodifiers
assertnodetype modifiers  modifiernode
boolean access   false
int answer   0
for  ast node   modifiernode getfirstchild    node    null  node   node getnextsibling
int type   node gettype
switch  type
case static_import
// ignore
break
// annotations
case annotation
annotations add annotation node
break
// core access scope modifiers
case literal_private
answer   setmodifierbit node  answer  opcodes acc_private
access   setaccesstrue node  access
break
case literal_protected
answer   setmodifierbit node  answer  opcodes acc_protected
access   setaccesstrue node  access
break
case literal_public
answer   setmodifierbit node  answer  opcodes acc_public
access   setaccesstrue node  access
break
// other modifiers
case abstract
answer   setmodifierbit node  answer  opcodes acc_abstract
break
case final
answer   setmodifierbit node  answer  opcodes acc_final
break
case literal_native
answer   setmodifierbit node  answer  opcodes acc_native
break
case literal_static
answer   setmodifierbit node  answer  opcodes acc_static
break
case strictfp
answer   setmodifierbit node  answer  opcodes acc_strict
break
case literal_synchronized
answer   setmodifierbit node  answer  opcodes acc_synchronized
break
case literal_transient
answer   setmodifierbit node  answer  opcodes acc_transient
break
case literal_volatile
answer   setmodifierbit node  answer  opcodes acc_volatile
break
default
unknownast node
}
}
if   access
answer    defaultmodifiers
}
return answer
}
protected boolean setaccesstrue ast node  boolean access
if   access
return true
}
else
throw new astruntimeexception node      node gettext
}
}
protected int setmodifierbit ast node  int answer  int bit
if   answer   bit     0
throw new astruntimeexception node      node gettext
}
return answer   bit
}
protected annotationnode annotation ast annotationnode
ast node   annotationnode getfirstchild
string name   qualifiedname node
annotationnode annotatednode   new annotationnode classhelper make name
configureast annotatednode  node
while  true
node   node getnextsibling
if  istype annotation_member_value_pair  node
ast membernode   node getfirstchild
string param   identifier membernode
expression expression   expression membernode getnextsibling
annotatednode addmember param  expression
}
else
break
}
}
return annotatednode
}
// statements
//-------------------------------------------------------------------------
protected statement statement ast node
statement statement   null
int type   node gettype
switch  type
case slist
case literal_finally
statement   statementlist node
break
case method_call
statement   methodcall node
break
case variable_def
statement   variabledef node
break
case labeled_stat
statement   labelledstatement node
break
case literal_assert
statement   assertstatement node
break
case literal_break
statement   breakstatement node
break
case literal_continue
statement   continuestatement node
break
case literal_if
statement   ifstatement node
break
case literal_for
statement   forstatement node
break
case literal_return
statement   returnstatement node
break
case literal_synchronized
statement   synchronizedstatement node
break
case literal_switch
statement   switchstatement node
break
case literal_try
statement   trystatement node
break
case literal_throw
statement   throwstatement node
break
case literal_while
statement   whilestatement node
break
default
statement   new expressionstatement expression node
}
if  statement    null
configureast statement  node
}
return statement
}
protected statement statementlist ast code
return statementlistnochild code getfirstchild
}
protected statement statementlistnochild ast node
blockstatement block   new blockstatement
// no need to configureast(block,node); as node is probably null
for    node    null  node   node getnextsibling
block addstatement statement node
}
return block
}
protected statement assertstatement ast assertnode
ast node   assertnode getfirstchild
booleanexpression booleanexpression   booleanexpression node
expression messageexpression   null
node   node getnextsibling
if  node    null
messageexpression   expression node
}
else
messageexpression   constantexpression null
}
assertstatement assertstatement   new assertstatement booleanexpression  messageexpression
configureast assertstatement  assertnode
return assertstatement
}
protected statement breakstatement ast node
breakstatement breakstatement   new breakstatement label node
configureast breakstatement  node
return breakstatement
}
protected statement continuestatement ast node
continuestatement continuestatement   new continuestatement label node
configureast continuestatement  node
return continuestatement
}
protected statement forstatement ast fornode
ast innode   fornode getfirstchild
expression collectionexpression
parameter forparameter
if  istype closure_list  innode
closurelistexpression clist    closurelistexpression innode
int size   clist getexpressions   size
if  size  3
throw new astruntimeexception innode    size
}
collectionexpression   clist
forparameter forstatement for_loop_dummy
else
ast variablenode   innode getfirstchild
ast collectionnode   variablenode getnextsibling
classnode type   classhelper object_type
if  istype variable_def  variablenode
ast typenode   variablenode getfirstchild
assertnodetype type  typenode
type   type typenode
variablenode   typenode getnextsibling
}
string variable   identifier variablenode
collectionexpression   expression collectionnode
forparameter   new parameter type variable
configureast forparameter variablenode
}
final ast node   innode getnextsibling
statement block
if  istype semi  node
block   emptystatement instance
else
block   statement node
}
forstatement forstatement   new forstatement forparameter  collectionexpression  block
configureast forstatement  fornode
return forstatement
}
protected statement ifstatement ast ifnode
ast node   ifnode getfirstchild
assertnodetype expr  node
booleanexpression booleanexpression   booleanexpression node
node   node getnextsibling
statement ifblock   statement node
statement elseblock   emptystatement instance
node   node getnextsibling
if  node    null
elseblock   statement node
}
ifstatement ifstatement   new ifstatement booleanexpression  ifblock  elseblock
configureast ifstatement  ifnode
return ifstatement
}
protected statement labelledstatement ast labelnode
ast node   labelnode getfirstchild
string label   identifier node
statement statement   statement node getnextsibling
statement setstatementlabel label
return statement
}
protected statement methodcall ast code
expression expression   methodcallexpression code
expressionstatement expressionstatement   new expressionstatement expression
configureast expressionstatement  code
return expressionstatement
}
protected expression declarationexpression ast variabledef
ast node   variabledef getfirstchild
classnode type   null
list annotations   new arraylist
if  istype modifiers  node
// force check of modifier conflicts
modifiers node  annotations  0
node   node getnextsibling
}
if  istype type  node
type   maketypewitharguments node
node   node getnextsibling
}
string name   identifier node
variableexpression leftexpression   new variableexpression name  type
configureast leftexpression  node
node   node getnextsibling
expression rightexpression   constantexpression null
if  node    null
assertnodetype assign  node
rightexpression   expression node getfirstchild
}
token token   maketoken types assign  variabledef
// todo should we have a variable declaration statement?
declarationexpression expression   new declarationexpression leftexpression  token  rightexpression
configureast expression  variabledef
expressionstatement expressionstatement   new expressionstatement expression
configureast expressionstatement  variabledef
return expression
}
protected statement variabledef ast variabledef
expressionstatement expressionstatement   new expressionstatement declarationexpression variabledef
configureast expressionstatement  variabledef
return expressionstatement
}
protected statement returnstatement ast node
ast exprnode = node.getfirstchild();
// this will pick up incorrect sibling node if 'node' is a plain 'return'
//
//if (exprnode == null) {
//    exprnode = node.getnextsibling();
//}
if  exprnode    null
expression expression   expression exprnode
if  expression instanceof constantexpression
constantexpression constantexpr    constantexpression  expression
if  constantexpr getvalue      null
return returnstatement return_null_or_void
}
}
returnstatement returnstatement   new returnstatement expression
configureast returnstatement  node
return returnstatement
}
else
return returnstatement return_null_or_void
}
}
protected statement switchstatement ast switchnode
ast node   switchnode getfirstchild
expression expression   expression node
statement defaultstatement   emptystatement instance
list list   new arraylist
for  node   node getnextsibling    istype case_group  node   node   node getnextsibling
ast child   node getfirstchild
if  istype literal_case  child
list cases   new linkedlist
// default statement can be grouped with previous case
defaultstatement   casestatements child  cases
list addall cases
else
defaultstatement   statement child getnextsibling
}
}
if  node    null
unknownast node
}
switchstatement switchstatement   new switchstatement expression  list  defaultstatement
configureast switchstatement  switchnode
return switchstatement
}
protected statement casestatements ast node  list cases
list expressions   new linkedlist
statement statement   emptystatement instance
statement defaultstatement   emptystatement instance
ast nextsibling   node
do
expression expression   expression nextsibling getfirstchild
expressions add expression
nextsibling   nextsibling getnextsibling
while  istype literal_case  nextsibling
if  nextsibling    null
if  istype literal_default  nextsibling
defaultstatement   statement nextsibling getnextsibling
statement   emptystatement instance
else
statement   statement nextsibling
}
}
for  iterator iterator   expressions iterator    iterator hasnext
expression expr    expression  iterator next
statement stmt
if  iterator hasnext
stmt   new casestatement expr emptystatement instance
else
stmt   new casestatement expr statement
}
configureast stmt node
cases add stmt
}
return defaultstatement
}
protected statement synchronizedstatement ast syncnode
ast node   syncnode getfirstchild
expression expression   expression node
statement code   statement node getnextsibling
synchronizedstatement synchronizedstatement   new synchronizedstatement expression  code
configureast synchronizedstatement  syncnode
return synchronizedstatement
}
protected statement throwstatement ast node
ast expressionnode   node getfirstchild
if  expressionnode    null
expressionnode   node getnextsibling
}
if  expressionnode    null
throw new astruntimeexception node
}
throwstatement throwstatement   new throwstatement expression expressionnode
configureast throwstatement  node
return throwstatement
}
protected statement trystatement ast trystatementnode
ast trynode   trystatementnode getfirstchild
statement trystatement   statement trynode
statement finallystatement   emptystatement instance
ast node   trynode getnextsibling
// let's do the catch nodes
list catches   new arraylist
for    node    null    istype literal_catch  node   node   node getnextsibling
catches add catchstatement node
}
if  istype literal_finally  node
finallystatement   statement node
node   node getnextsibling
}
trycatchstatement trycatchstatement   new trycatchstatement trystatement  finallystatement
configureast trycatchstatement  trystatementnode
for  iterator iter   catches iterator    iter hasnext
catchstatement statement    catchstatement  iter next
trycatchstatement addcatch statement
}
return trycatchstatement
}
protected catchstatement catchstatement ast catchnode
ast node   catchnode getfirstchild
parameter parameter   parameter node
classnode exceptiontype   parameter gettype
string variable   parameter getname
node   node getnextsibling
statement code   statement node
parameter catchparameter   new parameter exceptiontype variable
catchstatement answer   new catchstatement catchparameter  code
configureast answer  catchnode
return answer
}
protected statement whilestatement ast whilenode
ast node   whilenode getfirstchild
assertnodetype expr  node
// todo remove this once we support declarations in the while condition
if  istype variable_def  node getfirstchild
throw new astruntimeexception whilenode
}
booleanexpression booleanexpression   booleanexpression node
node   node getnextsibling
statement block
if  istype semi  node
block   emptystatement instance
else
block   statement node
}
whilestatement whilestatement   new whilestatement booleanexpression  block
configureast whilestatement  whilenode
return whilestatement
}
// expressions
//-------------------------------------------------------------------------
protected expression expression ast node
return expression node false
}
protected expression expression ast node  boolean converttoconstant
expression expression   expressionswitch node
if  converttoconstant
// a method name can never be a variableexprssion, so it must converted
// to a constantexpression then. this is needed as the expression
// method doesn't know we want a constantexpression instead of a
// variableexpression
if   expression    variableexpression this_expression
expression    variableexpression super_expression
expression instanceof variableexpression
variableexpression ve    variableexpression  expression
expression   new constantexpression ve getname
}
}
configureast expression  node
return expression
}
protected expression expressionswitch ast node
int type   node gettype
switch  type
case expr
return expression node getfirstchild
case elist
return expressionlist node
case slist
return blockexpression node
case closable_block
return closureexpression node
case super_ctor_call
return specialconstructorcallexpression node classnode super
case method_call
return methodcallexpression(node);
case literal_new
return constructorcallexpression node
case ctor_call
return specialconstructorcallexpression node classnode this
case question
case elvis_operator
return ternaryexpression node
case optional_dot
case spread_dot
case dot
return dotexpression node
case ident
case literal_boolean
case literal_byte
case literal_char
case literal_double
case literal_float
case literal_int
case literal_long
case literal_short
case literal_void
return variableexpression node
case list_constructor
return listexpression node
case map_constructor
return mapexpression node
case labeled_arg
return mapentryexpression node
case spread_arg
return spreadexpression node
case spread_map_arg
return spreadmapexpression node
// commented out of groovy.g due to non determinisms
//case member_pointer_default:
//    return defaultmethodpointerexpression(node);
case member_pointer
return methodpointerexpression node
case index_op
return indexexpression node
case literal_instanceof
return instanceofexpression node
case literal_as
return asexpression node
case typecast
return castexpression node
// literals
case literal_true
return constantexpression true
case literal_false
return constantexpression false
case literal_null
return constantexpression null
case string_literal
constantexpression constantexpression   new constantexpression node gettext
configureast constantexpression  node
return constantexpression
case string_constructor
return gstring node
case num_double
case num_float
case num_big_decimal
return decimalexpression node
case num_big_int
case num_int
case num_long
return integerexpression node
case literal_this
return variableexpression this_expression
case literal_super
return variableexpression super_expression
// unary expressions
case lnot
notexpression notexpression   new notexpression expression node getfirstchild
configureast notexpression  node
return notexpression
case unary_minus
return unaryminusexpression node
case bnot
bitwisenegationexpression bitwisenegationexpression   new bitwisenegationexpression expression node getfirstchild
configureast bitwisenegationexpression  node
return bitwisenegationexpression
case unary_plus
return unaryplusexpression node
// prefix expressions
case inc
return prefixexpression node  types plus_plus
case dec
return prefixexpression node  types minus_minus
// postfix expressions
case post_inc
return postfixexpression node  types plus_plus
case post_dec
return postfixexpression node  types minus_minus
// binary expressions
case assign
return binaryexpression types assign  node
case equal
return binaryexpression types compare_equal  node
case not_equal
return binaryexpression types compare_not_equal  node
case compare_to
return binaryexpression types compare_to  node
case le
return binaryexpression types compare_less_than_equal  node
case lt
return binaryexpression types compare_less_than  node
case gt
return binaryexpression types compare_greater_than  node
case ge
return binaryexpression types compare_greater_than_equal  node
/**
* todo treble equal?
return binaryexpression(types.compare_identical, node);
case ???:
return binaryexpression(types.logical_and_equal, node);
case ???:
return binaryexpression(types.logical_or_equal, node);
*/
case land
return binaryexpression types logical_and  node
case lor
return binaryexpression types logical_or  node
case band
return binaryexpression types bitwise_and  node
case band_assign
return binaryexpression types bitwise_and_equal  node
case bor
return binaryexpression types bitwise_or  node
case bor_assign
return binaryexpression types bitwise_or_equal  node
case bxor
return binaryexpression types bitwise_xor  node
case bxor_assign
return binaryexpression types bitwise_xor_equal  node
case plus
return binaryexpression types plus  node
case plus_assign
return binaryexpression types plus_equal  node
case minus
return binaryexpression types minus  node
case minus_assign
return binaryexpression types minus_equal  node
case star
return binaryexpression types multiply  node
case star_assign
return binaryexpression types multiply_equal  node
case star_star
return binaryexpression types power  node
case star_star_assign
return binaryexpression types power_equal  node
case div
return binaryexpression types divide  node
case div_assign
return binaryexpression types divide_equal  node
case mod
return binaryexpression types mod  node
case mod_assign
return binaryexpression types mod_equal  node
case sl
return binaryexpression types left_shift  node
case sl_assign
return binaryexpression types left_shift_equal  node
case sr
return binaryexpression types right_shift  node
case sr_assign
return binaryexpression types right_shift_equal  node
case bsr
return binaryexpression types right_shift_unsigned  node
case bsr_assign
return binaryexpression types right_shift_unsigned_equal  node
case variable_def
return declarationexpression node
// regex
case regex_find
return binaryexpression types find_regex  node
case regex_match
return binaryexpression types match_regex  node
// ranges
case range_inclusive
return rangeexpression node  true
case range_exclusive
return rangeexpression node  false
case dynamic_member
return dynamicmemberexpression node
case literal_in
return binaryexpression types keyword_in node
case annotation
return new annotationconstantexpression annotation node
case closure_list
return closurelistexpression node
default
unknownast node
}
return null;
}
private closurelistexpression closurelistexpression ast node
ast exprnode = node.getfirstchild();
linkedlist list   new linkedlist
while  exprnode  null
if  istype expr exprnode
expression expr   expression exprnode
configureast expr  exprnode
list add expr
else
assertnodetype empty_stat  exprnode
list add emptyexpression instance
}
exprnode   exprnode getnextsibling
}
closurelistexpression cle   new closurelistexpression list
configureast cle node
return cle
}
protected expression dynamicmemberexpression ast dynamicmembernode
ast node   dynamicmembernode getfirstchild
return expression node
}
protected expression ternaryexpression ast ternarynode
ast node   ternarynode getfirstchild
expression base   expression node
node   node getnextsibling
expression left   expression node
node   node getnextsibling
expression ret
if  node  null
ret   new elvisoperatorexpression base  left
else
expression right   expression node
booleanexpression booleanexpression   new booleanexpression base
booleanexpression setsourceposition base
ret   new ternaryexpression booleanexpression  left  right
}
configureast ret  ternarynode
return ret
}
protected expression variableexpression ast node
string text   node gettext
// todo we might wanna only try to resolve the name if we are
// on the left hand side of an expression or before a dot?
variableexpression variableexpression   new variableexpression text
configureast variableexpression  node
return variableexpression
}
protected expression rangeexpression ast rangenode  boolean inclusive
ast node   rangenode getfirstchild
expression left   expression node
expression right   expression node getnextsibling
rangeexpression rangeexpression   new rangeexpression left  right  inclusive
configureast rangeexpression  rangenode
return rangeexpression
}
protected expression spreadexpression ast node
ast exprnode = node.getfirstchild();
ast listnode   exprnode getfirstchild
expression right   expression listnode
spreadexpression spreadexpression   new spreadexpression right
configureast spreadexpression  node
return spreadexpression
}
protected expression spreadmapexpression ast node
ast exprnode = node.getfirstchild();
expression expr   expression exprnode
spreadmapexpression spreadmapexpression   new spreadmapexpression expr
configureast spreadmapexpression  node
return spreadmapexpression
}
protected expression methodpointerexpression ast node
ast exprnode = node.getfirstchild();
expression objectexpression   expression exprnode
ast mnode   exprnode getnextsibling
expression methodname
if  istype dynamic_member  mnode
methodname   expression mnode
else
methodname   new constantexpression identifier mnode
}
configureast methodname mnode
methodpointerexpression methodpointerexpression   new methodpointerexpression objectexpression  methodname
configureast(methodpointerexpression, node);
return methodpointerexpression;
}
/*  commented out due to groovy.g non-determinisms
protected expression defaultmethodpointerexpression(ast node) {
ast exprnode = node.getfirstchild();
string methodname = exprnode.tostring();
methodpointerexpression methodpointerexpression = new methodpointerexpression(null, methodname);
configureast(methodpointerexpression, node);
return methodpointerexpression;
}
*/
protected expression listexpression ast listnode
list expressions   new arraylist
ast elist   listnode getfirstchild
assertnodetype elist  elist
for  ast node   elist getfirstchild    node    null  node   node getnextsibling
// check for stray labeled arguments:
switch  node gettype
case labeled_arg        assertnodetype comma  node         break      helpful error?
case spread_map_arg     assertnodetype spread_arg  node    break      helpful error
}
expressions add expression node
}
listexpression listexpression   new listexpression expressions
configureast listexpression  listnode
return listexpression
}
/**
* typically only used for map constructors i think?
*/
protected expression mapexpression ast mapnode
list expressions   new arraylist
ast elist   mapnode getfirstchild
if  elist    null        totally empty in the case of
assertnodetype elist  elist
for  ast node   elist getfirstchild    node    null  node   node getnextsibling
switch  node gettype
case labeled_arg
case spread_map_arg
break      legal cases
case spread_arg
assertnodetype spread_map_arg  node    break      helpful error
default
assertnodetype labeled_arg  node    break      helpful error
}
expressions add mapentryexpression node
}
}
mapexpression mapexpression   new mapexpression expressions
configureast mapexpression  mapnode
return mapexpression
}
protected mapentryexpression mapentryexpression ast node
if  node gettype      spread_map_arg
ast rightnode   node getfirstchild
expression keyexpression   spreadmapexpression node
expression rightexpression   expression rightnode
mapentryexpression mapentryexpression   new mapentryexpression keyexpression  rightexpression
configureast mapentryexpression  node
return mapentryexpression
}
else
ast keynode   node getfirstchild
expression keyexpression   expression keynode
ast valuenode   keynode getnextsibling
expression valueexpression   expression valuenode
mapentryexpression mapentryexpression   new mapentryexpression keyexpression  valueexpression
configureast mapentryexpression  node
return mapentryexpression
}
}
protected expression instanceofexpression ast node
ast leftnode   node getfirstchild
expression leftexpression   expression leftnode
ast rightnode   leftnode getnextsibling
classnode type   buildname rightnode
asserttypenotnull type  rightnode
expression rightexpression   new classexpression type
configureast rightexpression  rightnode
binaryexpression binaryexpression   new binaryexpression leftexpression  maketoken types keyword_instanceof  node   rightexpression
configureast binaryexpression  node
return binaryexpression
}
protected void asserttypenotnull classnode type  ast rightnode
if  type    null
throw new astruntimeexception rightnode      qualifiedname rightnode
}
}
protected expression asexpression ast node
ast leftnode   node getfirstchild
expression leftexpression   expression leftnode
ast rightnode   leftnode getnextsibling
classnode type   buildname rightnode
return castexpression asexpression type  leftexpression
}
protected expression castexpression ast castnode
ast node   castnode getfirstchild
classnode type   buildname node
asserttypenotnull type  node
ast expressionnode   node getnextsibling
expression expression   expression expressionnode
castexpression castexpression   new castexpression type  expression
configureast castexpression  castnode
return castexpression
}
protected expression indexexpression ast indexnode
ast leftnode   indexnode getfirstchild
expression leftexpression   expression leftnode
ast rightnode   leftnode getnextsibling
expression rightexpression   expression rightnode
binaryexpression binaryexpression   new binaryexpression leftexpression  maketoken types left_square_bracket  indexnode   rightexpression
configureast binaryexpression  indexnode
return binaryexpression
}
protected expression binaryexpression int type  ast node
token token   maketoken type  node
ast leftnode   node getfirstchild
expression leftexpression   expression leftnode
ast rightnode   leftnode getnextsibling
if  rightnode    null
return leftexpression
}
if  types oftype type  types assignment_operator
if  leftexpression instanceof variableexpression    leftexpression getclass      propertyexpression class
leftexpression instanceof fieldexpression
leftexpression instanceof attributeexpression
leftexpression instanceof declarationexpression
// do nothing.
}
else if  leftexpression instanceof constantexpression
throw new astruntimeexception node        constantexpression  leftexpression  getvalue
}
else if  leftexpression instanceof binaryexpression
expression leftexp     binaryexpression  leftexpression  getleftexpression
int lefttype     binaryexpression  leftexpression  getoperation   gettype
if   types oftype lefttype  types assignment_operator     lefttype    types left_square_bracket
throw new astruntimeexception node        binaryexpression  leftexpression  gettext
}
}
else if  leftexpression instanceof gstringexpression
throw new astruntimeexception node
}
else if  leftexpression instanceof methodcallexpression
throw new astruntimeexception node
}
else if  leftexpression instanceof mapexpression
throw new astruntimeexception node        mapexpression  leftexpression  gettext
}
else
throw new astruntimeexception node      leftexpression getclass         leftexpression gettext
}
}
/*if (rightnode == null) {
throw new nullpointerexception("no rightnode associated with binary expression");
}*/
expression rightexpression   expression rightnode
binaryexpression binaryexpression   new binaryexpression leftexpression  token  rightexpression
configureast binaryexpression  node
return binaryexpression
}
protected expression prefixexpression ast node  int token
expression expression   expression node getfirstchild
prefixexpression prefixexpression   new prefixexpression maketoken token  node   expression
configureast prefixexpression  node
return prefixexpression
}
protected expression postfixexpression ast node  int token
expression expression   expression node getfirstchild
postfixexpression postfixexpression   new postfixexpression expression  maketoken token  node
configureast postfixexpression  node
return postfixexpression
}
protected booleanexpression booleanexpression ast node
booleanexpression booleanexpression   new booleanexpression expression node
configureast booleanexpression  node
return booleanexpression
}
protected expression dotexpression ast node
// let's decide if this is a property invocation or a method call
ast leftnode   node getfirstchild
if  leftnode    null
ast identifiernode   leftnode getnextsibling
if  identifiernode    null
expression leftexpression   expression leftnode
if  istype select_slot  identifiernode
expression field   expression identifiernode getfirstchild   true
attributeexpression attributeexpression   new attributeexpression leftexpression  field  node gettype      dot
if  node gettype      spread_dot
attributeexpression setspreadsafe true
}
configureast attributeexpression  node
return attributeexpression
}
expression property   expression identifiernode true
propertyexpression propertyexpression   new propertyexpression leftexpression  property  node gettype      dot
if  node gettype      spread_dot
propertyexpression setspreadsafe true
}
configureast propertyexpression  node
return propertyexpression
}
}
return methodcallexpression(node);
}
protected expression specialconstructorcallexpression ast methodcallnode  classnode special
ast node   methodcallnode getfirstchild
expression arguments   arguments node
constructorcallexpression expression   new constructorcallexpression special  arguments
configureast expression  methodcallnode
return expression
}
private int gettypeinparenthesis ast node
if    istype expr node    node   node getfirstchild
while  node  null   istype expr node     node getnextsibling    null
node   node getfirstchild
}
if  node  null  return  1
return node gettype
}
protected expression methodcallexpression ast methodcallnode
ast node   methodcallnode getfirstchild
/* // bad idea, since foo(1)(2) is valid groovy for foo(1).call(2).
if (istype(method_call, node)) {
// sometimes method calls get wrapped in method calls for some wierd reason
return methodcallexpression(node);
}
*/
expression objectexpression
ast selector
ast elist   node getnextsibling
boolean implicitthis   false
boolean safe   istype optional_dot  node
boolean spreadsafe   istype spread_dot  node
if  istype dot  node     safe    spreadsafe
ast objectnode   node getfirstchild
objectexpression   expression objectnode
selector   objectnode getnextsibling
else
implicitthis   true
objectexpression   variableexpression this_expression
selector   node
}
expression name   null
if  istype literal_super  selector
implicitthis   true
name   new constantexpression
if  objectexpression    variableexpression this_expression
objectexpression   variableexpression super_expression
}
else if  isprimitivetypeliteral selector
throw new astruntimeexception selector      selector gettext
else if  istype select_slot  selector
expression field   expression selector getfirstchild   true
attributeexpression attributeexpression   new attributeexpression objectexpression  field  node gettype      dot
configureast attributeexpression  node
expression arguments   arguments elist
methodcallexpression expression   new methodcallexpression attributeexpression     arguments
configureast expression  methodcallnode
return expression
else if
istype dynamic_member  selector     istype ident selector
istype string_constructor selector     istype  string_literal selector
name   expression selector true
else
implicitthis   false
name   new constantexpression
objectexpression   expression selector true
}
expression arguments   arguments elist
methodcallexpression expression   new methodcallexpression objectexpression  name  arguments
expression setsafe safe
expression setspreadsafe spreadsafe
expression setimplicitthis implicitthis
expression ret   expression
//fixme: do we really want this() to create a new object regardless
// the position.. for example not as first statement in a constructor
// this=first statement in constructor is handled by specialconstructorcallexpression
// we may have to add a check and remove this part of the code
if  implicitthis      equals expression getmethodasstring
ret   new constructorcallexpression this classnode  arguments
}
configureast ret  methodcallnode
return ret
}
protected expression constructorcallexpression ast node
ast constructorcallnode   node
classnode type   maketypewitharguments constructorcallnode
if  istype ctor_call  node     istype literal_new  node
node   node getfirstchild
}
ast elist   node getnextsibling
if  elist    null    istype elist  node
elist   node
if    equals type getname
type   classnode
}
}
if  istype array_declarator  elist
ast expressionnode   elist getfirstchild
if  expressionnode    null
throw new astruntimeexception elist
}
list size   arraysizeexpression expressionnode
arrayexpression arrayexpression   new arrayexpression type  null  size
configureast arrayexpression  constructorcallnode
return arrayexpression
}
expression arguments   arguments elist
constructorcallexpression expression   new constructorcallexpression type  arguments
configureast expression  constructorcallnode
return expression
}
protected list arraysizeexpression ast node
list list
expression size   null
if  istype array_declarator node
ast right   node getnextsibling
if  right  null
size   expression right
else
size   constantexpression emtpy_expression
}
list   arraysizeexpression node getfirstchild
else
size   expression node
list   new arraylist
}
list add size
return list
}
protected expression arguments ast elist
list expressionlist   new arraylist
// fixme: all labeled arguments should follow any unlabeled arguments
boolean namedarguments   false
for  ast node   elist  node    null  node   node getnextsibling
if  istype elist  node
for  ast child   node getfirstchild    child    null  child   child getnextsibling
namedarguments    addargumentexpression child  expressionlist
}
}
else
namedarguments    addargumentexpression node  expressionlist
}
}
if  namedarguments
if   expressionlist isempty
// let's remove any non-mapentryexpression instances
// such as if the last expression is a closureexpression
// so let's wrap the named method calls in a map expression
list argumentlist   new arraylist
for  iterator iter   expressionlist iterator    iter hasnext
expression expression    expression  iter next
if    expression instanceof mapentryexpression
argumentlist add expression
}
}
if   argumentlist isempty
expressionlist removeall argumentlist
mapexpression mapexpression   new mapexpression expressionlist
configureast mapexpression  elist
argumentlist add 0  mapexpression
argumentlistexpression argumentlistexpression   new argumentlistexpression argumentlist
configureast argumentlistexpression  elist
return argumentlistexpression
}
}
namedargumentlistexpression namedargumentlistexpression   new namedargumentlistexpression expressionlist
configureast namedargumentlistexpression  elist
return namedargumentlistexpression
}
else
argumentlistexpression argumentlistexpression   new argumentlistexpression expressionlist
configureast argumentlistexpression  elist
return argumentlistexpression
}
}
protected boolean addargumentexpression ast node  list expressionlist
if  node gettype      spread_map_arg
ast rightnode   node getfirstchild
expression keyexpression   spreadmapexpression node
expression rightexpression   expression rightnode
mapentryexpression mapentryexpression   new mapentryexpression keyexpression  rightexpression
expressionlist add mapentryexpression
return true
}
else
expression expression   expression node
expressionlist add expression
return expression instanceof mapentryexpression
}
}
protected expression expressionlist ast node
list expressionlist   new arraylist
for  ast child   node getfirstchild    child    null  child   child getnextsibling
expressionlist add expression child
}
if  expressionlist size      1
return  expression  expressionlist get 0
}
else
listexpression listexpression   new listexpression expressionlist
configureast listexpression  node
return listexpression
}
}
protected closureexpression closureexpression ast node
ast paramnode   node getfirstchild
parameter parameters   null
ast codenode   paramnode
if  istype parameters  paramnode     istype implicit_parameters  paramnode
parameters   parameters paramnode
codenode   paramnode getnextsibling
}
statement code   statementlistnochild codenode
closureexpression closureexpression   new closureexpression parameters  code
configureast closureexpression  node
return closureexpression
}
protected expression blockexpression ast node
ast codenode   node getfirstchild
if  codenode    null   return constantexpression null
if  codenode gettype      expr    codenode getnextsibling      null
// simplify common case of {expr} to expr.
return expression codenode
}
parameter parameters   parameter empty_array
statement code   statementlistnochild codenode
closureexpression closureexpression   new closureexpression parameters  code
configureast closureexpression  node
// call it immediately.
string callname
expression noarguments   new argumentlistexpression
methodcallexpression call   new methodcallexpression closureexpression  callname  noarguments
configureast call  node
return call
}
protected expression unaryminusexpression ast unaryminusexpr
ast node   unaryminusexpr getfirstchild
// if we are a number literal then let's just parse it
// as the negation operator on min_int causes rounding to a long
string text   node gettext
switch  node gettype
case num_double
case num_float
case num_big_decimal
constantexpression constantexpression   new constantexpression numbers parsedecimal     text
configureast constantexpression  unaryminusexpr
return constantexpression
case num_big_int
case num_int
case num_long
constantexpression constantlongexpression   new constantexpression numbers parseinteger     text
configureast constantlongexpression  unaryminusexpr
return constantlongexpression
default
unaryminusexpression unaryminusexpression   new unaryminusexpression expression node
configureast unaryminusexpression  unaryminusexpr
return unaryminusexpression
}
}
protected expression unaryplusexpression ast unaryplusexpr
ast node   unaryplusexpr getfirstchild
switch  node gettype
case num_double
case num_float
case num_big_decimal
case num_big_int
case num_int
case num_long
return expression node
default
unaryplusexpression unaryplusexpression   new unaryplusexpression expression node
configureast unaryplusexpression  unaryplusexpr
return unaryplusexpression
}
}
protected constantexpression decimalexpression ast node
string text   node gettext
constantexpression constantexpression   new constantexpression numbers parsedecimal text
configureast constantexpression  node
return constantexpression
}
protected constantexpression integerexpression ast node
string text   node gettext
constantexpression constantexpression   new constantexpression numbers parseinteger text
configureast constantexpression  node
return constantexpression
}
protected expression gstring ast gstringnode
list strings   new arraylist
list values   new arraylist
stringbuffer buffer   new stringbuffer
boolean isprevstring   false
for  ast node   gstringnode getfirstchild    node    null  node   node getnextsibling
int type   node gettype
string text   null
switch  type
case string_literal
if  isprevstring   assertnodetype ident  node       parser bug
isprevstring   true
text   node gettext
constantexpression constantexpression   new constantexpression text
configureast constantexpression  node
strings add constantexpression
buffer append text
break
default
if   isprevstring   assertnodetype ident  node       parser bug
isprevstring   false
expression expression   expression node
values add expression
buffer append
buffer append expression gettext
}
break
}
}
gstringexpression gstringexpression   new gstringexpression buffer tostring    strings  values
configureast gstringexpression  gstringnode
return gstringexpression
}
protected classnode type ast typenode
// todo intern types?
// todo configureast(...)
return buildname typenode getfirstchild
}
public static string qualifiedname ast qualifiednamenode
if  istype ident  qualifiednamenode
return qualifiednamenode gettext
}
if  istype dot  qualifiednamenode
ast node   qualifiednamenode getfirstchild
stringbuffer buffer   new stringbuffer
boolean first   true
for    node    null     istype type_arguments node   node   node getnextsibling
if  first
first   false
}
else
buffer append
}
buffer append qualifiedname node
}
return buffer tostring
}
else
return qualifiednamenode gettext
}
}
private static ast gettypeargumentsnode ast root
while  root  null     istype type_arguments root
root   root getnextsibling
}
return root
}
private int getboundtype ast node
if  node  null  return  1
if  istype type_upper_bounds node   return type_upper_bounds
if  istype type_lower_bounds node   return type_lower_bounds
throw new astruntimeexception node
gettokenname node
gettokenname type_upper_bounds
gettokenname type_lower_bounds
}
private genericstype makegenericsargumenttype ast typeargument
genericstype gt
ast rootnode   typeargument getfirstchild
if  istype wildcard_type rootnode
classnode base   classhelper makewithoutcaching
if  rootnode getnextsibling    null
int boundtype   getboundtype rootnode getnextsibling
classnode gts   makegenericsbounds rootnode boundtype
if  boundtype  type_upper_bounds
gt   new genericstype base gts null
else
gt   new genericstype base null gts
}
else
gt   new genericstype base null null
}
gt setname
gt setwildcard true
else
classnode argument   maketypewitharguments rootnode
gt   new genericstype argument
}
configureast gt  typeargument
return gt
}
protected classnode maketypewitharguments ast rootnode
classnode basictype   maketype rootnode
linkedlist typeargumentlist   new linkedlist
ast node   rootnode getfirstchild
if  node  null    istype index_op  node     istype array_declarator  node   return basictype
//todo: recognize combinatons of inner classes and generic types
if  istype dot  node   return basictype
node   node getfirstchild
if  node  null  return basictype
assertnodetype type_arguments  node
ast typeargument   node getfirstchild
while  typeargument    null
assertnodetype type_argument  typeargument
genericstype gt   makegenericsargumenttype typeargument
typeargumentlist add gt
typeargument   typeargument getnextsibling
}
if  typeargumentlist size  >0
basictype setgenericstypes  genericstype  typeargumentlist toarray new genericstype
}
return basictype
}
private classnode makegenericsbounds ast rn  int boundtype
ast boundsroot   rn getnextsibling
if  boundsroot  null  return null
assertnodetype boundtype  boundsroot
linkedlist bounds   new linkedlist
for   ast boundsnode   boundsroot getfirstchild
boundsnode  null
boundsnode boundsnode getnextsibling
classnode bound   null
bound   maketypewitharguments boundsnode
configureast bound  boundsnode
bounds add bound
}
if  bounds size    0  return null
return  classnode  bounds toarray new classnode
}
protected genericstype makegenericstype ast rootnode
ast typeparameter   rootnode getfirstchild
linkedlist ret   new linkedlist
assertnodetype type_parameter  typeparameter
while  istype type_parameter  typeparameter
ast typenode   typeparameter getfirstchild
classnode type   maketype typeparameter
genericstype gt   new genericstype type  makegenericsbounds typenode type_upper_bounds  null
configureast gt  typeparameter
ret add gt
typeparameter   typeparameter getnextsibling
}
return  genericstype  ret toarray new genericstype
}
protected classnode maketype ast typenode
classnode answer   classhelper dynamic_type
ast node   typenode getfirstchild
if  node    null
if  istype index_op  node     istype array_declarator  node
answer   maketype node  makearray
else
answer   classhelper make qualifiedname node
}
configureast answer node
}
return answer
}
/**
* performs a name resolution to see if the given name is a type from imports,
* aliases or newly created classes
*/
/*protected string resolvetypename(string name, boolean safe) {
if (name == null) {
return null;
}
return resolvenewclassorname(name, safe);
}*/
/**
* extracts an identifier from the antlr ast and then performs a name resolution
* to see if the given name is a type from imports, aliases or newly created classes
*/
protected classnode buildname ast node
if  istype type  node
node   node getfirstchild
}
classnode answer   null
if  istype dot  node     istype optional_dot  node
answer   classhelper make qualifiedname node
}
else if  isprimitivetypeliteral node
answer   classhelper make node gettext
}
else if  istype index_op  node     istype array_declarator  node
ast child   node getfirstchild
answer   buildname child  makearray
configureast answer  node
return answer
}
else
string identifier   node gettext
answer   classhelper make identifier
}
ast nextsibling   node getnextsibling
if  istype index_op  nextsibling     istype array_declarator  node
answer   answer makearray
configureast answer  node
return answer
}
else
configureast answer  node
return answer
}
}
protected boolean isprimitivetypeliteral ast node
int type   node gettype
switch  type
case literal_boolean
case literal_byte
case literal_char
case literal_double
case literal_float
case literal_int
case literal_long
case literal_short
return true
default
return false
}
}
/**
* extracts an identifier from the antlr ast
*/
protected string identifier ast node
assertnodetype ident  node
return node gettext
}
protected string label ast labelnode
ast node   labelnode getfirstchild
if  node    null
return null;
}
return identifier node
}
// helper methods
//-------------------------------------------------------------------------
/**
* returns true if the modifiers flags contain a visibility modifier
*/
protected boolean hasvisibility int modifiers
return  modifiers    opcodes acc_private   opcodes acc_protected   opcodes acc_public      0
}
protected void configureast astnode node  ast ast
if  ast  null  throw new astruntimeexception ast    node getclass   getname
node setcolumnnumber ast getcolumn
node setlinenumber ast getline
if  ast instanceof groovysourceast
node setlastcolumnnumber   groovysourceast ast  getcolumnlast
node setlastlinenumber   groovysourceast ast  getlinelast
}
// todo we could one day store the antlr ast on the groovy ast
// node.setcstnode(ast);
}
protected static token maketoken int typecode  ast node
return token newsymbol typecode  node getline    node getcolumn
}
protected string getfirstchildtext ast node
ast child   node getfirstchild
return child    null ? child gettext     null
}
public static boolean istype int typecode  ast node
return node    null    node gettype      typecode
}
private string gettokenname int token
if  tokennames  null  return   token
return tokennames
}
private string gettokenname ast node
if  node  null  return
return gettokenname node gettype
}
protected void assertnodetype int type  ast node
if  node    null
throw new astruntimeexception node      gettokenname type
}
if  node gettype      type
throw new astruntimeexception node      gettokenname node        gettokenname type
}
}
protected void notimplementedyet ast node
throw new astruntimeexception node      gettokenname node
}
protected void unknownast ast node
if  node gettype      class_def
throw new astruntimeexception node
}
throw new astruntimeexception node      gettokenname node
}
protected void dumptree ast ast
for  ast node   ast getfirstchild    node    null  node   node getnextsibling
dump node
}
}
protected void dump ast node
system out println     gettokenname node        node gettext
}
}