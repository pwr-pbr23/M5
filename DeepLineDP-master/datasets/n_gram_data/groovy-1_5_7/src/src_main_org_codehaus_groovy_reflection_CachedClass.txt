/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy reflection
import groovy lang metaclass
import groovy lang metamethod
import org codehaus groovy classgen bytecodehelper
import org codehaus groovy runtime reflector
import java lang ref softreference
import java lang reflect constructor
import java lang reflect field
import java lang reflect method
import java security accesscontroller
import java security privilegedaction
import java util
/**
* @author alex.tkachman
*/
public class cachedclass
private cachedclass cachedsuperclass
private static final metamethod empty   new metamethod
int hashcode
private reflector reflector
private volatile object metaclassforclass     either metaclass or softreference<metaclass>
private cachedfield fields
private cachedconstructor constructors
private cachedmethod methods
private final class cachedclass
private metamethod newmetamethods   empty
public  cachedmethod  mopmethods
public static final cachedclass empty_array   new cachedclass
private object staticmetaclassfield
private static final object none   new object
public set getinterfaces
if  interfaces    null
interfaces   new hashset  0
if  gettheclass   isinterface
interfaces add this
class classes   gettheclass   getinterfaces
for  int i   0  i < classes length  i
final cachedclass aclass   reflectioncache getcachedclass classes
if   interfaces contains aclass
interfaces addall aclass getinterfaces
final cachedclass superclass   getcachedsuperclass
if  superclass    null
interfaces addall superclass getinterfaces
return interfaces
private set owninterfaces
public set getowninterfaces
if  owninterfaces    null
owninterfaces   new hashset  0
if  gettheclass   isinterface
owninterfaces add this
class classes   gettheclass   getinterfaces
for  int i   0  i < classes length  i
final cachedclass aclass   reflectioncache getcachedclass classes
if   owninterfaces contains aclass
owninterfaces addall aclass getinterfaces
final cachedclass superclass   getcachedsuperclass
if  superclass    null
owninterfaces addall superclass getinterfaces
return owninterfaces
private set interfaces
public final boolean isarray
public final boolean isprimitive
public final int modifiers
int distance    1
public final boolean isinterface
public final boolean isnumber
public cachedclass class klazz
cachedclass   klazz
isarray   klazz isarray
isprimitive   klazz isprimitive
modifiers   klazz getmodifiers
isinterface   klazz isinterface
isnumber   number class isassignablefrom klazz
/**
* initialization involves making calls back to reflectioncache to popuplate
* the "assignable from" structure.
* package scoped (like our constructor) because reflectioncache is really the
* only place we should be called from.
*
* we don't need to be synchronized here because reflectioncache is careful to
* make sure we're called exactly once.
* by the same token we could however safely lock ourself.
* but the idea here is to take out the bad locks.
*/
final void initialize
for  iterator it   getinterfaces   iterator    it hasnext
cachedclass inf    cachedclass  it next
reflectioncache isassignablefrom cachedclass  inf cachedclass
// if we *were* going to lock the class/cachedclass of our parents,
// it would probably be a better idea to climb to the top then do the
// locking from the top down to here.
// but that shouldn't really be necessary since this is the wrong place for that.
// one of the keys is probably that the constructor and initialization need to be
// separated (like with metaclassimpl).
for  cachedclass cur   this  cur    null  cur   cur getcachedsuperclass
reflectioncache setassignablefrom cur cachedclass  cachedclass
/**
* this can't be final because reflectionclass has an inner class that extends
* cachedclass for java.lang.object (reflectionclass.object_class) that returns
* null for this method.
*/
public cachedclass getcachedsuperclass
if  cachedsuperclass    null
if   isarray
cachedsuperclass   reflectioncache getcachedclass gettheclass   getsuperclass
else
if  cachedclass getcomponenttype   isprimitive      cachedclass getcomponenttype      object class
cachedsuperclass   reflectioncache object_class
else
cachedsuperclass   reflectioncache object_array_class
return cachedsuperclass
public synchronized cachedmethod getmethods
if  methods    null
final method declaredmethods    method
accesscontroller doprivileged new privilegedaction  <method>
public   method   object run
return gettheclass   getdeclaredmethods
arraylist methods   new arraylist declaredmethods length
arraylist mopmethods   new arraylist declaredmethods length
for  int i   0  i    declaredmethods length    i
final cachedmethod cachedmethod   new cachedmethod this  declaredmethods
final string name   cachedmethod getname
if  name indexof    >  0
// skip synthetic methods inserted by jdk 1.5 compilers and later
continue;
else if  modifier isabstract reflectionmethod getmodifiers
continue;
}*/
if  name startswith       name startswith
mopmethods add cachedmethod
else
methods add cachedmethod
this methods    cachedmethod  methods toarray new cachedmethod
arrays sort this methods
final cachedclass superclass   getcachedsuperclass
if  superclass    null
superclass getmethods
final cachedmethod supermopmethods   superclass mopmethods
for  int i   0  i    supermopmethods length    i
mopmethods add supermopmethods
this mopmethods    cachedmethod  mopmethods toarray new cachedmethod
arrays sort this mopmethods  cachedmethodcomparatorbyname instance
return methods
public synchronized cachedfield getfields
if  fields    null
final field declaredfields    field
accesscontroller doprivileged new privilegedaction  <field>
public   field   object run
return gettheclass   getdeclaredfields
fields   new cachedfield
for  int i   0  i    fields length    i
fields   new cachedfield this  declaredfields
return fields
public synchronized cachedconstructor getconstructors
if  constructors    null
final constructor declaredconstructors    constructor
accesscontroller doprivileged new privilegedaction  <constructor>
public   constructor   object run
return gettheclass   getdeclaredconstructors
constructors   new cachedconstructor
for  int i   0  i    constructors length    i
constructors   new cachedconstructor this  declaredconstructors
return constructors
public cachedmethod searchmethods string name  cachedclass parametertypes
cachedmethod methods   getmethods
cachedmethod res   null
for  int i   0  i < methods length  i
cachedmethod m   methods
if  m getname   equals name
reflectioncache arraycontentseq parametertypes  m getparametertypes
res    null    res getreturntype   isassignablefrom m getreturntype
res   m
return res
public final int getmodifiers
return modifiers
public object coerceargument object argument
return argument
public int getsuperclassdistance
// this method is idempotent.  don't put a dangerous lock here!
// synchronized (getcachedclass()) {
if  distance     1
int distance   0
for  class klazz  gettheclass    klazz    null  klazz   klazz getsuperclass
distance
this distance   distance
return distance
//  }
public int hashcode
if  hashcode    0
hashcode   super hashcode
if  hashcode    0
hashcode   0xcafebebe
return hashcode
public boolean isprimitive
return isprimitive
public boolean isvoid
return gettheclass      void class
public void box bytecodehelper helper
helper box gettheclass
public void unbox bytecodehelper helper
helper unbox gettheclass
public boolean isinterface
return isinterface
public void docast bytecodehelper helper
helper docast gettheclass
public string getname
return gettheclass   getname
public string gettypedescription
return bytecodehelper gettypedescription gettheclass
public reflector getreflector
/*if (reflector == null) {
final metaclassregistry metaclassregistry = metaclassregistryimpl.getinstance(metaclassregistryimpl.load_default);
reflector = ((metaclassregistryimpl)metaclassregistry).loadreflector(getcachedclass(), arrays.aslist(getmethods()));
}*/
return reflector
public final class gettheclass
return cachedclass
public metamethod getnewmetamethods
return newmetamethods
public void setnewmopmethods arraylist arr
newmetamethods    metamethod  arr toarray new metamethod
public synchronized void setstaticmetaclassfield metaclass mc
if  staticmetaclassfield    none
return
if  staticmetaclassfield    null
final cachedfield cachedfields   getfields
for  int i   0  i < cachedfields length  i
cachedfield cachedfield   cachedfields
if  cachedfield getname   startswith       cachedfield gettype      metaclass class    cachedfield isstatic
staticmetaclassfield   cachedfield
break
if  staticmetaclassfield    null
staticmetaclassfield   none
return
cachedfield staticmetaclassfield  setproperty null mc
public metaclass getmetaclassforclass
object cur   metaclassforclass
if  cur    null
return null
if  cur instanceof softreference
softreference softreference    softreference  cur
return  metaclass  softreference get
return  metaclass  metaclassforclass
public void setmetaclassforclass metaclass metaclassforclass  boolean isconst
if  isconst    metaclassforclass    null
this metaclassforclass   metaclassforclass
else
this metaclassforclass   new softreference metaclassforclass
setstaticmetaclassfield metaclassforclass
public boolean isassignablefrom class argument
return argument    null    reflectioncache isassignablefrom gettheclass    argument
boolean isdirectlyassignable object argument
return reflectioncache isassignablefrom gettheclass    argument getclass
public static class cachedmethodcomparatorbyname implements comparator
public static final comparator instance   new cachedmethodcomparatorbyname
public int compare object o1  object o2
return   cachedmethod o1  getname   compareto   cachedmethod o2  getname
public static class cachedmethodcomparatorwithstring implements comparator
public static final comparator instance   new cachedmethodcomparatorwithstring
public int compare object o1  object o2
if  o1 instanceof cachedmethod
return   cachedmethod o1  getname   compareto  string o2
else
return   string o1  compareto   cachedmethod o2  getname
public string tostring
return cachedclass tostring