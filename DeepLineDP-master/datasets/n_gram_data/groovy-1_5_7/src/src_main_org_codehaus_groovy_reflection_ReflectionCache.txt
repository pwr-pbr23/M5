/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy reflection
import groovy lang closure
import java lang ref softreference
import java math bigdecimal
import java math biginteger
import java util hashmap
import java util map
import java util weakhashmap
import org codehaus groovy reflection stdclasses
public class reflectioncache
private static map primitivetypesmap   new hashmap
static
primitivetypesmap put byte class  byte class
primitivetypesmap put boolean class  boolean class
primitivetypesmap put char class  character class
primitivetypesmap put double class  double class
primitivetypesmap put float class  float class
primitivetypesmap put int class  integer class
primitivetypesmap put long class  long class
primitivetypesmap put short class  short class
}
public static class autoboxtype class type
final class res    class  primitivetypesmap get type
return res    null ? type   res
/*
final string name = type.getname();
switch (name.charat(0)) {
case 'b':
if ("boolean".equals(name))
return boolean.class;
else
if ("byte".equals(name))
return byte.class;
else
return null;
case 'c':
return "char".equals(name) ? character.class : null;
case 'd':
return "double".equals(name) ? double.class : null;
case 'f':
return "float".equals(name) ? float.class : null;
case 'i':
return "int".equals(name) ? integer.class : null;
case 'l':
return "long".equals(name) ? long.class : null;
case 's':
return "short".equals(name) ? short.class : null;
default:
return null;
}
*/
}
static triplekeyhashmap mopnames   new triplekeyhashmap
public static string getmopmethodname cachedclass declaringclass  string name  boolean usethis
synchronized  mopnames
triplekeyhashmap entry mopnameentry   mopnames getorput declaringclass  name  boolean valueof usethis
if  mopnameentry value    null
mopnameentry value   new stringbuffer   append usethis ?        append declaringclass getsuperclassdistance    append    append name  tostring
}
return  string  mopnameentry value
}
}
static final map   <class softreference<cachedclass>>   cached_class_map   new weakhashmap
static weakdoublekeyhashmap assignablemap   new weakdoublekeyhashmap
private static final cachedclass string_class   new stringcachedclass
public static boolean isarray class klazz
//        cachedclass cachedclass = getcachedclass(klazz);
//        return cachedclass.isarray;
return klazz getname   charat 0
}
static void setassignablefrom class klazz  class aclass
synchronized  assignablemap
weakdoublekeyhashmap entry val   assignablemap getorput klazz  aclass
if  val value    null
val value   boolean true
}
}
}
public static boolean isassignablefrom class klazz  class aclass
if  klazz    aclass
return true
synchronized  assignablemap
weakdoublekeyhashmap entry val   assignablemap getorput klazz  aclass
if  val value    null
val value   boolean valueof klazz isassignablefrom aclass
}
return   boolean val value  booleanvalue
//        return klazz.isassignablefrom(aclass);
}
}
static boolean arraycontentseq object a1  object a2
if  a1    null
return a2    null    a2 length    0
}
if  a2    null
return a1 length    0
}
if  a1 length    a2 length
return false
}
for  int i   0  i < a1 length  i
if  a1    a2
return false
}
}
return true
}
public static final cachedclass object_class   new cachedclass object class
public synchronized cachedclass getcachedsuperclass
return null;
}
public boolean isassignablefrom class argument
return true
}
public static final cachedclass object_array_class   getcachedclass object class
/**
* get the cachedclass for a the given class (which may be a type).
*
* @param klazz
* @return the class
*/
public static cachedclass getcachedclass class klazz
if  klazz    null
return null;
if  klazz    object class
return object_class
if  klazz    string class
return string_class
cachedclass cachedclass
softreference ref
synchronized  cached_class_map
ref    softreference  cached_class_map get klazz
}
if  ref    null     cachedclass    cachedclass  ref get       null
if  number class isassignablefrom klazz     klazz isprimitive
if  klazz    number class
cachedclass   new numbercachedclass klazz
else if  klazz    integer class    klazz     integer type
cachedclass   new integercachedclass klazz  klazz  integer class
else if  klazz    double class    klazz    double type
cachedclass   new doublecachedclass klazz  klazz  double class
else if  klazz    bigdecimal class
cachedclass   new bigdecimalcachedclass klazz
else if  klazz    long class    klazz    long type
cachedclass   new longcachedclass klazz  klazz  long class
else if  klazz    float class    klazz    float type
cachedclass   new floatcachedclass klazz  klazz  float class
else if  klazz    short class    klazz    short type
cachedclass   new shortcachedclass klazz  klazz  short class
else if  klazz    boolean type
cachedclass   new booleancachedclass klazz  false
else if  klazz    character type
cachedclass   new charactercachedclass klazz  false
else if  klazz    biginteger class
cachedclass   new bigintegercachedclass klazz
else if  klazz    byte class    klazz    byte type
cachedclass   new bytecachedclass klazz  klazz  byte class
else
cachedclass   new cachedclass klazz
}
else
if  klazz getname   charat 0
cachedclass   new arraycachedclass klazz
else if  klazz    boolean class
cachedclass   new booleancachedclass klazz  true
else if  klazz    character class
cachedclass   new charactercachedclass klazz  true
else if  closure class isassignablefrom klazz
cachedclass   new cachedclosureclass  klazz
else
cachedclass   new cachedclass klazz
}
}
cachedclass fastercachedclass   null
// double-check put.
synchronized  cached_class_map
ref    softreference  cached_class_map get klazz
if  ref    null     fastercachedclass    cachedclass  ref get       null
cached_class_map put klazz  new softreference cachedclass
else
// we must use the one that there first, we should be able to safely toss the one we made.
// by locking class we would eliminate this race, but until the design is corrected we risk
// deadlock.
cachedclass   fastercachedclass
}
}
if  null    fastercachedclass
// we've got a new cacheclass, now get loaded into the assignablemap.
cachedclass initialize
}
}
return cachedclass
}
}