/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy classgen
import org codehaus groovy groovybugerror
import org codehaus groovy ast classhelper
import org codehaus groovy ast classnode
import org codehaus groovy ast parameter
import org codehaus groovy ast variablescope
import org objectweb asm label
import org objectweb asm methodvisitor
import org objectweb asm opcodes
import java util
/**
* this class is a helper for asmclassgenerator. it manages
* different aspects of the code of a code block like
* handling labels, defining variables, and scopes.
* after a methodnode is visited clear should be called, for
* initialization the method init should be used.
* <p>
* some notes:
* <ul>
* <li> every push method will require a later pop call
* <li> method parameters may define a category 2 variable, so
*      don't ignore the type stored in the variable object
* <li> the index of the variable may not be as assumed when
*      the variable is a parameter of a method because the
*      parameter may be used in a closure, so don't ignore
*      the stored variable index
* <li> the names of temporary variables can be ignored. the names
*      are only used for debugging and do not conflict with each
*      other or normal variables. for accessing the index of the
*      variable must be used.
* <li> never mix temporary and normal variables by changes to this class.
*      while the name is very important for a normal variable, it is only a
*      helper construct for temporary variables. that means for example a
*      name for a temporary variable can be used multiple times without
*      conflict. so mixing them both may lead to the problem that a normal
*      or temporary variable is hidden or even removed. that must not happen!
* </ul>
*
*
* @see org.codehaus.groovy.classgen.asmclassgenerator
* @author jochen theodorou
*/
public class compilestack implements opcodes
/**
* @todo remove optimization of this.foo -> this.@foo
*
*/
// state flag
private boolean clear true
// current scope
private variablescope scope
// current label for continue
private label continuelabel
// current label for break
private label breaklabel
// available variables on stack
private map stackvariables   new hashmap
// index of the last variable on stack
private int currentvariableindex   1
// index for the next variable on stack
private int nextvariableindex   1
// currently temporary variables in use
private final linkedlist temporaryvariables   new linkedlist
// overall used variables for a method/constructor
private final linkedlist usedvariables   new linkedlist
// map containing named labels of parenting blocks
private map superblocknamedlabels   new hashmap
// map containing named labels of current block
private map currentblocknamedlabels   new hashmap
// list containing runnables representing a finally block
// such a block is created by synchronized or finally and
// must be called for break/continue/return
private linkedlist finallyblocks   new linkedlist
// a list of blocks already visiting.
private final list visitedblocks   new linkedlist
private label thisstartlabel  thisendlabel
// current class index
private int currentclassindex   currentmetaclassindex
private methodvisitor mv
private bytecodehelper helper
// helper to handle different stack based variables
private final linkedlist statestack   new linkedlist
// defines the first variable index useable after
// all parameters of a method
private int localvariableoffset
// this is used to store the goals for a "break foo" call
// in a loop where foo is a label.
private final map namedloopbreaklabel   new hashmap
//this is used to store the goals for a "continue foo" call
// in a loop where foo is a label.
private final map namedloopcontinuelabel   new hashmap
private string classname
private class statestackelement
final variablescope scope
final label continuelabel
final label breaklabel
label finallylabel
final int lastvariableindex
final int nextvariableindex
final map stackvariables
list temporaryvariables   new linkedlist
list usedvariables   new linkedlist
final map superblocknamedlabels
final map currentblocknamedlabels
final linkedlist finallyblocks
statestackelement
scope   compilestack this scope
continuelabel   compilestack this continuelabel
breaklabel   compilestack this breaklabel
lastvariableindex   compilestack this currentvariableindex
stackvariables   compilestack this stackvariables
temporaryvariables   compilestack this temporaryvariables
nextvariableindex   compilestack this nextvariableindex
superblocknamedlabels   compilestack this superblocknamedlabels
currentblocknamedlabels   compilestack this currentblocknamedlabels
finallyblocks   compilestack this finallyblocks
private void pushstate
statestack add new statestackelement
stackvariables   new hashmap stackvariables
finallyblocks   new linkedlist finallyblocks
private void popstate
if  statestack size    0
throw new groovybugerror
statestackelement element    statestackelement  statestack removelast
scope   element scope
continuelabel   element continuelabel
breaklabel   element breaklabel
currentvariableindex   element lastvariableindex
stackvariables   element stackvariables
nextvariableindex   element nextvariableindex
finallyblocks   element finallyblocks
public label getcontinuelabel
return continuelabel
public label getbreaklabel
return breaklabel
public void removevar int tempindex
for  iterator iter   temporaryvariables iterator    iter hasnext
variable element    variable  iter next
if  element getindex    tempindex
iter remove
return
throw new groovybugerror
private void setendlabels
label endlabel   new label
mv visitlabel endlabel
for  iterator iter   stackvariables values   iterator    iter hasnext
variable var    variable  iter next
var setendlabel endlabel
thisendlabel   endlabel
public void pop
setendlabels
popstate
public variablescope getscope
return scope
/**
* creates a temporary variable.
*
* @param var defines type and name
* @param store defines if the toplevel argument of the stack should be stored
* @return the index used for this temporary variable
*/
public int definetemporaryvariable org codehaus groovy ast variable var  boolean store
return definetemporaryvariable var getname    var gettype   store
public variable getvariable string variablename
return getvariable variablename true
/**
* returns a normal variable, that was defined before.
* if mustexist is
* to false, then this method will throw a groovybugerror. it is no the
* intention of this method to let this happen! and the exception
* should never be used for flow control. if the exception is thrown
* then it is a bug in the class using compilestack. this mehod can also
* not be used to return a temporary variable. temporary variables are not
* normal variables.
*
* @param variablename name of the variable
* @param mustexist  throw exception if variable does not exist
* @return the normal variable or null if not found (and <code>mustexist</code> not true)
*/
public variable getvariable string variablename  boolean mustexist
if  variablename equals     return variable this_variable
if  variablename equals     return variable super_variable
variable v    variable  stackvariables get variablename
if  v    null
for  iterator it   temporaryvariables iterator    it hasnext
variable tvar    variable  it next
if  tvar getname   equals variablename
v   tvar
break
if  v  null    mustexist   throw new groovybugerror   variablename
return v
/**
* creates a temporary variable.
*
* @param name defines type and name
* @param store defines if the toplevel argument of the stack should be stored
* @return the index used for this temporary variable
*/
public int definetemporaryvariable string name boolean store
return definetemporaryvariable name  classhelper dynamic_type store
/**
* creates a temporary variable.
*
* @param name defines the name
* @param node defines the node
* @param store defines if the toplevel argument of the stack should be stored
* @return the index used for this temporary variable
*/
public int definetemporaryvariable string name  classnode node  boolean store
variable answer   definevar name node false
temporaryvariables addfirst answer      trick  we add at the beginning so when we find for remove or get we always have the last one
usedvariables removelast
if  store  mv visitvarinsn astore  currentvariableindex
return answer getindex
private void resetvariableindex boolean isstatic
if   isstatic
currentvariableindex 1
nextvariableindex 1
else
currentvariableindex 0
nextvariableindex 0
/**
* clears the state of the class. this method should be called
* after a methodnode is visited. note that a call to init will
* fail if clear is not called before
*/
public void clear
if  statestack size  >1
int size   statestack size   1
throw new groovybugerror   size    size  1?
clear   true
// br experiment with local var table so debuggers can retrieve variable names
if  true     asmclassgenerator create_debug_info
if  thisendlabel  null  setendlabels
if   scope isinstaticcontext
// write "this"
mv visitlocalvariable    classname  null  thisstartlabel  thisendlabel  0
for  iterator iterator   usedvariables iterator    iterator hasnext
variable v    variable  iterator next
string type   bytecodehelper gettypedescription v gettype
label start   v getstartlabel
label end   v getendlabel
mv visitlocalvariable v getname    type  null  start  end  v getindex
pop
stackvariables clear
usedvariables clear
scope   null
mv null
resetvariableindex false
superblocknamedlabels clear
currentblocknamedlabels clear
namedloopbreaklabel clear
namedloopcontinuelabel clear
continuelabel null
breaklabel null
helper   null
thisstartlabel null
thisendlabel null
/**
* initializes this class for a methodnode. this method will
* automatically define varibales for the method parameters
* and will create references if needed. the created variables
* can be get by getvariable
*
*/
protected void init variablescope el  parameter parameters  methodvisitor mv  classnode cn
if   clear  throw new groovybugerror
clear false
pushvariablescope el
this mv   mv
this helper   new bytecodehelper mv
definemethodvariables parameters el isinstaticcontext
this classname   bytecodehelper gettypedescription cn
currentclassindex    1  currentmetaclassindex    1
/**
* causes the statestack to add an element and sets
* the given scope as new current variable scope. creates
* a element for the state stack so pop has to be called later
*/
protected void pushvariablescope variablescope el
pushstate
scope   el
superblocknamedlabels   new hashmap superblocknamedlabels
superblocknamedlabels putall currentblocknamedlabels
currentblocknamedlabels   new hashmap
/**
* should be called when decending into a loop that defines
* also a scope. calls pushvariablescope and prepares labels
* for a loop structure. creates a element for the state stack
* so pop has to be called later
*/
protected void pushloop variablescope el  string labelname
pushvariablescope el
initlooplabels labelname
private void initlooplabels string labelname
continuelabel   new label
breaklabel   new label
if  labelname  null
namedloopbreaklabel put labelname breaklabel
namedloopcontinuelabel put labelname continuelabel
/**
* should be called when decending into a loop that does
* not define a scope. creates a element for the state stack
* so pop has to be called later
*/
protected void pushloop string labelname
pushstate
initlooplabels labelname
/**
* used for <code>break foo</code> inside a loop to end the
* execution of the marked loop. this method will return the
* break label of the loop if there is one found for the name.
* if not, the current break label is returned.
*/
protected label getnamedbreaklabel string name
label label   getbreaklabel
label endlabel   null
if  name  null  endlabel    label  namedloopbreaklabel get name
if  endlabel  null  label   endlabel
return label
/**
* used for <code>continue foo</code> inside a loop to continue
* the execution of the marked loop. this method will return
* the break label of the loop if there is one found for the
* name. if not, getlabel is used.
*/
protected label getnamedcontinuelabel string name
label label   getlabel name
label endlabel   null
if  name  null  endlabel    label  namedloopcontinuelabel get name
if  endlabel  null  label   endlabel
return label
/**
* creates a new break label and a element for the state stack
* so pop has to be called later
*/
protected label pushswitch
pushstate
breaklabel   new label
return breaklabel
/**
* because a boolean expression may not be evaluated completly
* it is important to keep the registers clean
*/
protected void pushbooleanexpression
pushstate
private variable definevar string name  classnode type  boolean methodparameterusedinclosure
makenextvariableid type
int index   currentvariableindex
if  methodparameterusedinclosure
index   localvariableoffset
type   classhelper getwrapper type
variable answer   new variable index  type  name
usedvariables add answer
answer setholder methodparameterusedinclosure
return answer
private void makelocalvariablesoffset parameter paras boolean isinstaticcontext
resetvariableindex isinstaticcontext
for  int i   0  i < paras length  i
makenextvariableid paras gettype
localvariableoffset   nextvariableindex
resetvariableindex isinstaticcontext
private void definemethodvariables parameter paras boolean isinstaticcontext
label startlabel    new label
thisstartlabel   startlabel
mv visitlabel startlabel
makelocalvariablesoffset paras isinstaticcontext
boolean hasholder   false
for  int i   0  i < paras length  i
string name   paras getname
variable answer
classnode type   paras gettype
if  paras isclosuresharedvariable
answer   definevar name  type  true
helper load type currentvariableindex
helper box type
createreference answer
hasholder   true
else
answer   definevar name type false
answer setstartlabel startlabel
stackvariables put name  answer
if  hasholder
nextvariableindex   localvariableoffset
private void createreference variable reference
mv visittypeinsn new
mv visitinsn dup_x1
mv visitinsn swap
mv visitmethodinsn invokespecial
mv visitvarinsn astore  reference getindex
/**
* defines a new variable using an ast variable.
* @param initfromstack if true the last element of the
*                      stack will be used to initilize
*                      the new variable. if false null
*                      will be used.
*/
public variable definevariable org codehaus groovy ast variable v  boolean initfromstack
string name   v getname
variable answer   definevar name v gettype   false
if  v isclosuresharedvariable    answer setholder true
stackvariables put name  answer
label startlabel    new label
answer setstartlabel startlabel
if  answer isholder
if   initfromstack  mv visitinsn aconst_null
createreference answer
else
if   initfromstack  mv visitinsn aconst_null
mv visitvarinsn astore  currentvariableindex
mv visitlabel startlabel
return answer
/**
* @param name the name of the variable of interest
* @return true if a variable is already defined
*/
public boolean containsvariable string name
return stackvariables containskey name
/**
* calculates the index of the next free register stores ir
* and sets the current variable index to the old value
*/
private void makenextvariableid classnode type
currentvariableindex   nextvariableindex
if  type  classhelper long_type    type  classhelper double_type
nextvariableindex
nextvariableindex
/**
* returns the label for the given name
*/
public label getlabel string name
if  name  null  return null
label l    label  superblocknamedlabels get name
if  l  null  l   createlocallabel name
return l
/**
* creates a new named label
*/
public label createlocallabel string name
label l    label  currentblocknamedlabels get name
if  l  null
l   new label
currentblocknamedlabels put name l
return l
public int getcurrentclassindex
return currentclassindex
public void setcurrentclassindex int index
currentclassindex index
public int getcurrentmetaclassindex
return currentmetaclassindex
public void setcurrentmetaclassindex int index
currentmetaclassindex index
public void applyfinallyblocks label label  boolean isbreaklabel
// first find the state defining the label. that is the state
// directly after the state not knowing this label. if no state
// in the list knows that label, then the defining state is the
// current state.
statestackelement result   null
for  listiterator iter   statestack listiterator statestack size     iter hasprevious
statestackelement element    statestackelement  iter previous
if   element currentblocknamedlabels values   contains label
if  isbreaklabel    element breaklabel    label
result   element
break
if   isbreaklabel    element continuelabel    label
result   element
break
list blockstoremove
if  result  null
// all blocks do know the label, so use all finally blocks
blockstoremove   collections empty_list
else
blockstoremove   result finallyblocks
arraylist blocks   new arraylist finallyblocks
blocks removeall blockstoremove
applyfinallyblocks blocks
private void applyfinallyblocks list blocks
for  iterator iter   blocks iterator    iter hasnext
runnable block    runnable  iter next
if  visitedblocks contains block   continue
block run
public void applyfinallyblocks
applyfinallyblocks finallyblocks
public boolean hasfinallyblocks
return  finallyblocks isempty
public void pushfinallyblock runnable block
finallyblocks addfirst block
pushstate
public void popfinallyblock
popstate
finallyblocks removefirst
public void pushfinallyblockvisit runnable block
visitedblocks add block
public void popfinallyblockvisit runnable block
visitedblocks remove block