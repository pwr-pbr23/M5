/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy ast
import groovy lang groovyclassloader
import java security codesource
import java util arraylist
import java util hashmap
import java util iterator
import java util list
import java util map
import org codehaus groovy control compilerconfiguration
import org codehaus groovy control sourceunit
import org codehaus groovy control messages syntaxerrormessage
import org codehaus groovy syntax syntaxexception
/**
* represents the entire contents of a compilation step which consists of one
* or more {@link modulenode}instances
*
* @author <a href="mailto:james@coredevelopers.net">james strachan </a>
* @version $revision$
*/
public class compileunit
private final list modules   new arraylist
private map classes   new hashmap
private compilerconfiguration config
private groovyclassloader classloader
private codesource codesource
private map classestocompile   new hashmap
private map classnametosource   new hashmap
public compileunit groovyclassloader classloader  compilerconfiguration config
this classloader  null  config
public compileunit groovyclassloader classloader  codesource codesource  compilerconfiguration config
this classloader   classloader
this config   config
this codesource   codesource
public list getmodules
return modules
public void addmodule modulenode node
// node==null means a compilation error prevented
// groovy from building an ast
if  node  null  return
modules add node
node setunit this
addclasses node getclasses
/**
* @return the classnode for the given qualified name or returns null if
*         the name does not exist in the current compilation unit
*         (ignoring the .class files on the classpath)
*/
public classnode getclass string name
classnode cn    classnode  classes get name
if  cn  null  return cn
return  classnode  classestocompile get name
/**
* @return a list of all the classes in each module in the compilation unit
*/
public list getclasses
list answer   new arraylist
for  iterator iter   modules iterator    iter hasnext
modulenode module    modulenode  iter next
answer addall module getclasses
return answer
public compilerconfiguration getconfig
return config
public groovyclassloader getclassloader
return classloader
public codesource getcodesource
return codesource
/**
* appends all of the fully qualified class names in this
* module into the given map
*/
void addclasses list classlist
for  iterator iter   classlist iterator    iter hasnext
addclass  classnode  iter next
/**
*  adds a class to the unit.
*/
public void addclass classnode node
node   node redirect
string name   node getname
classnode stored    classnode  classes get name
if  stored    null    stored    node
// we have a duplicate class!
// one possibility for this is, that we delcared a script and a
// class in the same file and named the class like the file
sourceunit nodesource   node getmodule   getcontext
sourceunit storedsource   stored getmodule   getcontext
string txt     node getname
if  nodesource  storedsource
// same class in same source
txt      nodesource getname     node getname
if  node isscriptbody      stored isscriptbody
txt
else
txt      nodesource getname     storedsource getname     node getname
nodesource geterrorcollector   adderrorandcontinue
new syntaxerrormessage new syntaxexception txt  node getlinenumber    node getcolumnnumber     nodesource
classes put name  node
if  classestocompile containskey name
classnode cn    classnode  classestocompile get name
cn setredirect node
classestocompile remove name
/**
* this emthod actually does not compile a class. it's only
* a marker that this type has to be compiled by the compilationunit
* at the end of a parse step no node should be be left.
*/
public void addclassnodetocompile classnode node  sourceunit location
classestocompile put node getname   node
classnametosource put node getname   location
public sourceunit getscriptsourcelocation string classname
return  sourceunit  classnametosource get classname
public boolean hasclassnodetocompile
return  classestocompile isempty
public iterator iterateclassnodetocompile
return classestocompile keyset   iterator