/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package groovy util
import java io
import java nio charset charset
import java util collection
/**
* <p>utility class to guess the encoding of a given text file.</p>
*
* <p>unicode files encoded in utf-16 (low or big endian) or utf-8 files
* with a byte order marker are correctly discovered. for utf-8 files with no bom, if the buffer
* is wide enough, the charset should also be discovered.</p>
*
* <p>a byte buffer of 4kb is usually sufficient to be able to guess the encoding.</p>
*
* <p>usage:</p>
* <pre>
* // guess the encoding
* charset guessedcharset = charsettoolkit.guessencoding(file, 4096);
*
* // create a reader with the correct charset
* charsettoolkit toolkit = new charsettoolkit(file);
* bufferedreader reader = toolkit.getreader();
*
* // read the file content
* string line;
* while ((line = br.readline())!= null)
* {
*     system.out.println(line);
* }
* </pre>
*
* @author guillaume laforge
*/
public class charsettoolkit
private byte buffer
private charset defaultcharset
private charset charset
private boolean enforce8bit   true
private final file file
private static final byte empty_byte_array   new byte
/**
* constructor of the <code>charsettoolkit</code> utility class.
*
* @param file of which we want to know the encoding.
*/
public charsettoolkit file file  throws ioexception
this file   file
this defaultcharset   getdefaultsystemcharset
this charset   null
inputstream input   new fileinputstream file
try
byte bytes   new byte
int bytesread   input read bytes
if  bytesread     1
this buffer   empty_byte_array
else if  bytesread < 4096
byte bytestoguess   new byte
system arraycopy bytes  0  bytestoguess  0  bytesread
this buffer   bytestoguess
else
this buffer   bytes
finally
try  input close     catch  ioexception e
// ignore
/**
* defines the default <code>charset</code> used in case the buffer represents
* an 8-bit <code>charset</code>.
*
* @param defaultcharset the default <code>charset</code> to be returned by <code>guessencoding()</code>
* if an 8-bit <code>charset</code> is encountered.
*/
public void setdefaultcharset charset defaultcharset
if  defaultcharset    null
this defaultcharset   defaultcharset
else
this defaultcharset   getdefaultsystemcharset
public charset getcharset
if  this charset    null
this charset   guessencoding
return charset
/**
* if us-ascii is recognized, enforce to return the default encoding, rather than us-ascii.
* it might be a file without any special character in the range 128-255, but that may be or become
* a file encoded with the default <code>charset</code> rather than us-ascii.
*
* @param enforce a boolean specifying the use or not of us-ascii.
*/
public void setenforce8bit boolean enforce
this enforce8bit   enforce
/**
* gets the enforce8bit flag, in case we do not want to ever get a us-ascii encoding.
*
* @return a boolean representing the flag of use of us-ascii.
*/
public boolean getenforce8bit
return this enforce8bit
/**
* retrieves the default charset
*/
public charset getdefaultcharset
return defaultcharset
/**
* <p>guess the encoding of the provided buffer.</p>
* if byte order markers are encountered at the beginning of the buffer, we immidiately
* return the charset implied by this bom. otherwise, the file would not be a human
* readable text file.</p>
*
* <p>if there is no bom, this method tries to discern whether the file is utf-8 or not.
* if it is not utf-8, we assume the encoding is the default system encoding
* (of course, it might be any 8-bit charset, but usually, an 8-bit charset is the default one).</p>
*
* <p>it is possible to discern utf-8 thanks to the pattern of characters with a multi-byte sequence.</p>
* <pre>
* ucs-4 range (hex.)        utf-8 octet sequence (binary)
* 0000 0000-0000 007f       0xxxxxxx
* 0000 0080-0000 07ff       110xxxxx 10xxxxxx
* 0000 0800-0000 ffff       1110xxxx 10xxxxxx 10xxxxxx
* 0001 0000-001f ffff       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
* 0020 0000-03ff ffff       111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
* 0400 0000-7fff ffff       1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
* </pre>
* <p>with utf-8, 0xfe and 0xff never appear.</p>
*
* @return the charset recognized.
*/
private charset guessencoding
// if the file has a byte order marker, we can assume the file is in utf-xx
// otherwise, the file would not be human readable
if  hasutf8bom
return charset forname
if  hasutf16lebom
return charset forname
if  hasutf16bebom
return charset forname
// if a byte has its most significant bit set, the file is in utf-8 or in the default encoding
// otherwise, the file is in us-ascii
boolean highorderbit   false
// if the file is in utf-8, high order bytes must have a certain value, in order to be valid
// if it's not the case, we can assume the encoding is the default encoding of the system
boolean validu8char   true
// todo the buffer is not read up to the end, but up to length - 6
int length   buffer length
int i   0
while  i < length   6
byte b0   buffer
byte b1   buffer
byte b2   buffer
byte b3   buffer
byte b4   buffer
byte b5   buffer
if  b0 < 0
// a high order bit was encountered, thus the encoding is not us-ascii
// it may be either an 8-bit encoding or utf-8
highorderbit   true
// a two-bytes sequence was encoutered
if  istwobytessequence b0
// there must be one continuation byte of the form 10xxxxxx,
// otherwise the following characteris is not a valid utf-8 construct
if   iscontinuationchar b1
validu8char   false
else
i
// a three-bytes sequence was encoutered
else if  isthreebytessequence b0
// there must be two continuation bytes of the form 10xxxxxx,
// otherwise the following characteris is not a valid utf-8 construct
if    iscontinuationchar b1     iscontinuationchar b2
validu8char   false
else
i    2
// a four-bytes sequence was encoutered
else if  isfourbytessequence b0
// there must be three continuation bytes of the form 10xxxxxx,
// otherwise the following characteris is not a valid utf-8 construct
if    iscontinuationchar b1     iscontinuationchar b2     iscontinuationchar b3
validu8char   false
else
i    3
// a five-bytes sequence was encoutered
else if  isfivebytessequence b0
// there must be four continuation bytes of the form 10xxxxxx,
// otherwise the following characteris is not a valid utf-8 construct
if    iscontinuationchar b1
iscontinuationchar b2
iscontinuationchar b3
iscontinuationchar b4
validu8char   false
else
i    4
// a six-bytes sequence was encoutered
else if  issixbytessequence b0
// there must be five continuation bytes of the form 10xxxxxx,
// otherwise the following characteris is not a valid utf-8 construct
if    iscontinuationchar b1
iscontinuationchar b2
iscontinuationchar b3
iscontinuationchar b4
iscontinuationchar b5
validu8char   false
else
i    5
else
validu8char   false
if   validu8char
break
i
// if no byte with an high order bit set, the encoding is us-ascii
// (it might have been utf-7, but this encoding is usually internally used only by mail systems)
if   highorderbit
// returns the default charset rather than us-ascii if the enforce8bit flag is set.
if  this enforce8bit
return this defaultcharset
else
return charset forname
// if no invalid utf-8 were encountered, we can assume the encoding is utf-8,
// otherwise the file would not be human readable
if  validu8char
return charset forname
// finally, if it's not utf-8 nor us-ascii, let's assume the encoding is the default encoding
return this defaultcharset
/**
* if the byte has the form 10xxxxx, then it's a continuation byte of a multiple byte character;
*
* @param b a byte.
* @return true if it's a continuation char.
*/
private static boolean iscontinuationchar byte b
return  128 <  b    b <   65
/**
* if the byte has the form 110xxxx, then it's the first byte of a two-bytes sequence character.
*
* @param b a byte.
* @return true if it's the first byte of a two-bytes sequence.
*/
private static boolean istwobytessequence byte b
return  64 <  b    b <   33
/**
* if the byte has the form 1110xxx, then it's the first byte of a three-bytes sequence character.
*
* @param b a byte.
* @return true if it's the first byte of a three-bytes sequence.
*/
private static boolean isthreebytessequence byte b
return  32 <  b    b <   17
/**
* if the byte has the form 11110xx, then it's the first byte of a four-bytes sequence character.
*
* @param b a byte.
* @return true if it's the first byte of a four-bytes sequence.
*/
private static boolean isfourbytessequence byte b
return  16 <  b    b <   9
/**
* if the byte has the form 11110xx, then it's the first byte of a five-bytes sequence character.
*
* @param b a byte.
* @return true if it's the first byte of a five-bytes sequence.
*/
private static boolean isfivebytessequence byte b
return  8 <  b    b <   5
/**
* if the byte has the form 1110xxx, then it's the first byte of a six-bytes sequence character.
*
* @param b a byte.
* @return true if it's the first byte of a six-bytes sequence.
*/
private static boolean issixbytessequence byte b
return  4 <  b    b <   3
/**
* retrieve the default charset of the system.
*
* @return the default <code>charset</code>.
*/
public static charset getdefaultsystemcharset
return charset forname system getproperty
/**
* has a byte order marker for utf-8 (used by microsoft's notepad and other editors).
*
* @return true if the buffer has a bom for utf8.
*/
public boolean hasutf8bom
if  buffer length >  3
return  buffer     17    buffer     69    buffer     65
else
return false
/**
* has a byte order marker for utf-16 low endian
* (ucs-2le, ucs-4le, and ucs-16le).
*
* @return true if the buffer has a bom for utf-16 low endian.
*/
public boolean hasutf16lebom
if  buffer length >  2
return  buffer     1    buffer     2
else
return false
/**
* has a byte order marker for utf-16 big endian
* (utf-16 and ucs-2).
*
* @return true if the buffer has a bom for utf-16 big endian.
*/
public boolean hasutf16bebom
if  buffer length >  2
return  buffer     2    buffer     1
else
return false
/**
* gets a <code>bufferedreader</code> (indeed a <code>linenumberreader</code>) from the <code>file</code>
* specified in the constructor of <code>charsettoolkit</code> using the charset discovered by the
* method <code>guessencoding()</code>.
*
* @return a <code>bufferedreader</code>
* @throws filenotfoundexception if the file is not found.
*/
public bufferedreader getreader   throws filenotfoundexception
linenumberreader reader   new linenumberreader new inputstreamreader new fileinputstream file   getcharset
if  hasutf8bom      hasutf16lebom      hasutf16bebom
try
reader read
catch  ioexception e
// should never happen, as a file with no content
// but with a bom has at least one char
return reader
/**
* retrieves all the available <code>charset</code>s on the platform,
* among which the default <code>charset</code>.
*
* @return an array of <code>charset</code>s.
*/
public static charset getavailablecharsets
collection collection   charset availablecharsets   values
return  charset  collection toarray new charset