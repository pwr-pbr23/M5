/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package groovy util slurpersupport
import groovy lang buildable
import groovy lang closure
import groovy lang groovyobject
import groovy lang writable
import java io ioexception
import java io writer
import java util hashmap
import java util iterator
import java util linkedlist
import java util list
import java util map
import java util stack
/**
* @author john wilson
*
*/
public class node implements writable
private final string name
private final map attributes
private final map attributenamespaces
private final string namespaceuri
private final list children   new linkedlist
private final stack replacementnodestack   new stack
public node final node parent  final string name  final map attributes  final map attributenamespaces  final string namespaceuri
this name   name
this attributes   attributes
this attributenamespaces   attributenamespaces
this namespaceuri   namespaceuri
public string name
return this name
public string namespaceuri
return this namespaceuri
public map attributes
return this attributes
public list children
return this children
public void addchild final object child
this children add child
public void replacenode final closure replacementclosure  final gpathresult result
this replacementnodestack push new replacementnode
public void build final groovyobject builder  final map namespacemap  final map namespacetaghints
final closure c    closure replacementclosure clone
node this replacementnodestack pop       disable the replacement whilst the closure is being executed
c setdelegate builder
c call new object result
node this replacementnodestack push this
protected void replacebody final object newvalue
this children clear
this children add newvalue
protected void appendnode final object newvalue  final gpathresult result
if  newvalue instanceof closure
this children add new replacementnode
public void build final groovyobject builder  final map namespacemap  final map namespacetaghints
final closure c    closure   closure newvalue  clone
c setdelegate builder
c call new object result
else
this children add newvalue
/* (non-javadoc)
* @see org.codehaus.groovy.sandbox.util.slurpersupport.node#text()
*/
public string text
final stringbuffer buff   new stringbuffer
final iterator iter   this children iterator
while  iter hasnext
final object child   iter next
if  child instanceof node
buff append   node child  text
else
buff append child
return buff tostring
/* (non-javadoc)
* @see org.codehaus.groovy.sandbox.util.slurpersupport.node#childnodes()
*/
public iterator childnodes
return new iterator
private final iterator iter   node this children iterator
private object nextelementnodes   getnextelementnodes
public boolean hasnext
return this nextelementnodes    null
public object next
try
return this nextelementnodes
finally
this nextelementnodes   getnextelementnodes
public void remove
throw new unsupportedoperationexception
private object getnextelementnodes
while  iter hasnext
final object node   iter next
if  node instanceof node
return node
return null
/* (non-javadoc)
* @see org.codehaus.groovy.sandbox.util.slurpersupport.node#writeto(java.io.writer)
*/
public writer writeto final writer out  throws ioexception
if  this replacementnodestack empty
final iterator iter   this children iterator
while  iter hasnext
final object child   iter next
if  child instanceof writable
writable child  writeto out
else
out write child tostring
return out
else
return   writable this replacementnodestack peek    writeto out
public void build final groovyobject builder  final map namespacemap  final map namespacetaghints
if  this replacementnodestack empty
final closure rest   new closure null
public object docall final object o
buildchildren builder  namespacemap  namespacetaghints
return null
if  this namespaceuri length      0    this attributenamespaces isempty
builder invokemethod this name  new object this attributes  rest
else
final list newtags   new linkedlist
builder getproperty
final list namespaces    list builder invokemethod    new object
final map current    map namespaces get 0
final map pending    map namespaces get 1
if  this attributenamespaces isempty
builder getproperty gettagfor this namespaceuri  current  pending  namespacemap  namespacetaghints  newtags  builder
builder invokemethod this name  new object this attributes  rest
else
final map attributeswithnamespaces   new hashmap this attributes
final iterator attrs   this attributes keyset   iterator
while  attrs hasnext
final object key   attrs next
final object attributenamespaceuri   this attributenamespaces get key
if  attributenamespaceuri    null
attributeswithnamespaces put gettagfor attributenamespaceuri  current  pending  namespacemap  namespacetaghints  newtags  builder
key  attributeswithnamespaces remove key
builder getproperty gettagfor this namespaceuri  current  pending  namespacemap namespacetaghints   newtags  builder
builder invokemethod this name  new object attributeswithnamespaces  rest
// remove the new tags we had to define for this element
if   newtags isempty
final iterator iter   newtags iterator
do
pending remove iter next
while  iter hasnext
else
replacementnode this replacementnodestack peek    build builder  namespacemap  namespacetaghints
private static string gettagfor final object namespaceuri  final map current
final map pending  final map local  final map taghints
final list newtags  final groovyobject builder
string tag   findnamespacetag pending  namespaceuri      look in the namespaces whose declaration has already been emitted
if  tag    null
tag   findnamespacetag current  namespaceuri       look in the namespaces who will be declared at the next element
if  tag    null
// we have to declare the namespace - choose a tag
tag   findnamespacetag local  namespaceuri       if the namespace has been decared in the gpath expression use that tag
if  tag    null    tag length      0
tag   findnamespacetag taghints  namespaceuri       if the namespace has been used in the parse documant use that tag
if  tag    null    tag length      0       otherwise make up a new tag and check it has not been used before
int suffix   0
do
final string posibletag       suffix
if   pending containskey posibletag      current containskey posibletag      local containskey posibletag
tag   posibletag
while  tag    null
final map newnamespace   new hashmap
newnamespace put tag  namespaceuri
builder getproperty
builder invokemethod    new object newnamespace
newtags add tag
return tag
private static string findnamespacetag final map tagmap  final object namespaceuri
if  tagmap containsvalue namespaceuri
final iterator entries   tagmap entryset   iterator
while  entries hasnext
final map entry entry    map entry entries next
if  namespaceuri equals entry getvalue
return  string entry getkey
return null
private void buildchildren final groovyobject builder  final map namespacemap  final map namespacetaghints
final iterator iter   this children iterator
while  iter hasnext
final object child   iter next
if  child instanceof node
node child  build builder  namespacemap  namespacetaghints
else if  child instanceof buildable
buildable child  build builder
else
builder getproperty
builder invokemethod    new object child