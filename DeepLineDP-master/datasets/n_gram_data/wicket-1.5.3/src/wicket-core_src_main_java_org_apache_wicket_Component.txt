/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket
import java io serializable
import java lang reflect method
import java util arraylist
import java util iterator
import java util list
import java util locale
import org apache wicket ajax iajaxregionmarkupidprovider
import org apache wicket authorization action
import org apache wicket authorization authorizationexception
import org apache wicket authorization iauthorizationstrategy
import org apache wicket authorization unauthorizedactionexception
import org apache wicket behavior behavior
import org apache wicket event broadcast
import org apache wicket event ievent
import org apache wicket event ieventsink
import org apache wicket event ieventsource
import org apache wicket feedback feedbackmessage
import org apache wicket feedback ifeedback
import org apache wicket markup componenttag
import org apache wicket markup imarkupfragment
import org apache wicket markup markupcache
import org apache wicket markup markupelement
import org apache wicket markup markupexception
import org apache wicket markup markupnotfoundexception
import org apache wicket markup markupstream
import org apache wicket markup wickettag
import org apache wicket markup html iheadercontributor
import org apache wicket markup html iheaderresponse
import org apache wicket markup html internal htmlheadercontainer
import org apache wicket markup html panel defaultmarkupsourcingstrategy
import org apache wicket markup html panel imarkupsourcingstrategy
import org apache wicket model icomponentassignedmodel
import org apache wicket model icomponentinheritedmodel
import org apache wicket model imodel
import org apache wicket model imodelcomparator
import org apache wicket model iwrapmodel
import org apache wicket request irequesthandler
import org apache wicket request request
import org apache wicket request response
import org apache wicket request component irequestablecomponent
import org apache wicket request component irequestablepage
import org apache wicket request cycle requestcycle
import org apache wicket request handler bookmarkablelistenerinterfacerequesthandler
import org apache wicket request handler listenerinterfacerequesthandler
import org apache wicket request handler pageandcomponentprovider
import org apache wicket request mapper parameter pageparameters
import org apache wicket request resource resourcereference
import org apache wicket settings idebugsettings
import org apache wicket util ihierarchical
import org apache wicket util convert iconverter
import org apache wicket util lang args
import org apache wicket util lang classes
import org apache wicket util lang wicketobjects
import org apache wicket util string componentstrings
import org apache wicket util string prependingstringbuffer
import org apache wicket util string strings
import org apache wicket util value valuemap
import org apache wicket util visit ivisit
import org apache wicket util visit ivisitor
import org apache wicket util visit visit
import org slf4j logger
import org slf4j loggerfactory
/**
* component serves as the highest level abstract base class for all components.
*
* <ul>
* <li><b>identity </b>- all components must have a non-null id which is retrieved by calling
* getid(). the id must be unique within the markupcontainer that holds the component, but does not
* have to be globally unique or unique within a page's component hierarchy.
*
* <li><b>hierarchy </b>- a component has a parent which can be retrieved with {@link #getparent()}.
* if a component is an instance of markupcontainer, it may have children. in this way it has a
* place in the hierarchy of components contained on a given page.
*
* <li><b>component paths </b>- the path from the page at the root of the component hierarchy to a
* given component is simply the concatenation with dot separators of each id along the way. for
* example, the path "a.b.c" would refer to the component named "c" inside the markupcontainer named
* "b" inside the container named "a". the path to a component can be retrieved by calling
* getpath(). this path is an absolute path beginning with the id of the page at the root. pages
* bear a pagemap/session-relative identifier as their id, so each absolute path will begin with a
* number, such as "0.a.b.c". to get a component path relative to the page that contains it, you can
* call getpagerelativepath().
*
* <li><b>lifecycle </b>- components participate in the following lifecycle phases:
* <ul>
* <li><b>construction </b>- a component is constructed with the java language new operator.
* children may be added during construction if the component is a markupcontainer.
*
* <li><b>request handling </b>- an incoming request is processed by a protocol request handler such
* as wicketservlet. an associated application object creates session, request and response objects
* for use by a given component in updating its model and rendering a response. these objects are
* stored inside a container called {@link requestcycle} which is accessible via
* {@link component#getrequestcycle()}. the convenience methods {@link component#getrequest()},
* {@link component#getresponse()} and {@link component#getsession()} provide easy access to the
* contents of this container.
*
* <li><b>listener invocation </b>- if the request references a listener on an existing component,
* that listener is called, allowing arbitrary user code to handle events such as link clicks or
* form submits. although arbitrary listeners are supported in wicket, the need to implement a new
* class of listener is unlikely for a web application and even the need to implement a listener
* interface directly is highly discouraged. instead, calls to listeners are routed through logic
* specific to the event, resulting in calls to user code through other overridable methods. for
* example, the {@link org.apache.wicket.markup.html.form.iformsubmitlistener#onformsubmitted()}
* method implemented by the form class is really a private implementation detail of the form class
* that is not designed to be overridden (although unfortunately, it must be public since all
* interface methods in java must be public). instead, form subclasses should override user-oriented
* methods such as onvalidate(), onsubmit() and onerror() (although only the latter two are likely
* to be overridden in practice).
*
* <li><b>form submit </b>- if a form has been submitted and the component is a formcomponent, the
* component's model is validated by a call to formcomponent.validate().
*
* <li><b>form model update </b>- if a valid form has been submitted and the component is a
* formcomponent, the component's model is updated by a call to formcomponent.updatemodel().
*
* <li><b>rendering </b>- a markup response is generated by the component via
* {@link component#render()}, which calls subclass implementation code contained in
* {@link org.apache.wicket.component#onrender()}. once this phase begins, a component becomes
* immutable. attempts to alter the component will result in a wicketruntimeexception.
*
* </ul>
*
* <li><b>component models </b>- the primary responsibility of a component is to use its model (an
* object that implements imodel), which can be set via
* {@link component#setdefaultmodel(imodel model)} and retrieved via
* {@link component#getdefaultmodel()}, to render a response in an appropriate markup language, such
* as html. in addition, form components know how to update their models based on request
* information. since the imodel interface is a wrapper around an actual model object, a convenience
* method {@link component#getdefaultmodelobject()} is provided to retrieve the model object from
* its imodel wrapper. a further convenience method,
* {@link component#getdefaultmodelobjectasstring()} , is provided for the very common operation of
* converting the wrapped model object to a string.
*
* <li><b>visibility </b>- components which have setvisible(false) will return false from
* isvisible() and will not render a response (nor will their children).
*
* <li><b>page </b>- the page containing any given component can be retrieved by calling
* {@link component#getpage()}. if the component is not attached to a page, an illegalstateexception
* will be thrown. an equivalent method, {@link component#findpage()} is available for special
* circumstances where it might be desirable to get a null reference back instead.
*
* <li><b>session </b>- the page for a component points back to the session that contains the page.
* the session for a component can be accessed with the convenience method getsession(), which
* simply calls getpage().getsession().
*
* <li><b>locale </b>- the locale for a component is available through the convenience method
* getlocale(), which is equivalent to getsession().getlocale().
*
* <li><b>string resources </b>- components can have associated string resources via the
* application's localizer, which is available through the method {@link component#getlocalizer()}.
* the convenience methods {@link component#getstring(string key)} and
* {@link component#getstring(string key, imodel model)} wrap the identical methods on the
* application localizer for easy access in components.
*
* <li><b>style </b>- the style ("skin") for a component is available through
* {@link org.apache.wicket.component#getstyle()}, which is equivalent to getsession().getstyle().
* styles are intended to give a particular look to a component or resource that is independent of
* its locale. for example, a style might be a set of resources, including images and markup files,
* which gives the design look of "ocean" to the user. if the session's style is set to "ocean" and
* these resources are given names suffixed with "_ocean", wicket's resource management logic will
* prefer these resources to other resources, such as default resources, which are not as good of a
* match.
*
* <li><b>variation </b>- whereas styles are session (user) specific, variations are component
* specific. e.g. if the style is "ocean" and the variation is "northsea", than the resources are
* given the names suffixed with "_ocean_northsea".
*
* <li><b>attributemodifiers </b>- you can add one or more {@link attributemodifier}s to any
* component if you need to programmatically manipulate attributes of the markup tag to which a
* component is attached.
*
* <li><b>application, applicationsettings and applicationpages </b>- the getapplication() method
* provides convenient access to the application for a component via getsession().getapplication().
* the getapplicationsettings() method is equivalent to getapplication().getsettings(). the
* getapplicationpages is equivalent to getapplication().getpages().
*
* <li><b>feedback messages </b>- the {@link component#debug(serializable)},
* {@link component#info(serializable)}, {@link component#warn(serializable)},
* {@link component#error(java.io.serializable)} and {@link component#fatal(serializable)} methods
* associate feedback messages with a component. it is generally not necessary to use these methods
* directly since wicket validators automatically register feedback messages on components. feedback
* message for a given component can be retrieved with {@link component#getfeedbackmessages}.
*
* <li><b>versioning </b>- pages are the unit of versioning in wicket, but fine-grained control of
* which components should participate in versioning is possible via the
* {@link component#setversioned(boolean)} method. the versioning participation of a given component
* can be retrieved with {@link component#isversioned()}.
*
* <li><b>ajax support</b>- components can be re-rendered after the whole page has been rendered at
* least once by calling dorender().
*
* @author jonathan locke
* @author chris turner
* @author eelco hillenius
* @author johan compagner
* @author juergen donnerstag
* @author igor vaynberg (ivaynberg)
*/
public abstract class component
implements
iclusterable
iconverterlocator
irequestablecomponent
iheadercontributor
ihierarchical<component>
ieventsink
ieventsource
/** log. */
private static final logger log   loggerfactory getlogger component class
private static final long serialversionuid   1l
/**
* action used with iauthorizationstrategy to determine whether a component is allowed to be
* enabled.
* <p>
* if enabling is authorized, a component may decide by itself (typically using it's enabled
* property) whether it is enabled or not. if enabling is not authorized, the given component is
* marked disabled, regardless its enabled property.
* <p>
* when a component is not allowed to be enabled (in effect disabled through the implementation
* of this interface), wicket will try to prevent model updates too. this is not completely fail
* safe, as constructs like:
*
* <pre>
*
* user u = (user)getmodelobject();
* u.setname(&quot;got you there!&quot;);
*
* </pre>
*
* can't be prevented. indeed it can be argued that any model protection is best dealt with in
* your model objects to be completely secured. wicket will catch all normal framework-directed
* use though.
*/
public static final action enable   new action action enable
/** separator for component paths */
public static final char path_separator
/** path segment that represents this component's parent */
public static final string parent_path
/**
* action used with iauthorizationstrategy to determine whether a component and its children are
* allowed to be rendered.
* <p>
* there are two uses for this method:
* <ul>
* <li>the 'normal' use is for controlling whether a component is rendered without having any
* effect on the rest of the processing. if a strategy lets this method return 'false', then the
* target component and its children will not be rendered, in the same fashion as if that
* component had visibility property 'false'.</li>
* <li>the other use is when a component should block the rendering of the whole page. so
* instead of 'hiding' a component, what we generally want to achieve here is that we force the
* user to logon/give-credentials for a higher level of authorization. for this functionality,
* the strategy implementation should throw a {@link authorizationexception}, which will then be
* handled further by the framework.</li>
* </ul>
* </p>
*/
public static final action render   new action action render
/** meta data for user specified markup id */
private static final metadatakey<string> markup_id_key   new metadatakey<string>
private static final long serialversionuid   1l
/** basic model imodelcomparator implementation for normal object models */
private static final imodelcomparator defaultmodelcomparator   new imodelcomparator
private static final long serialversionuid   1l
public boolean compare component component  object b
final object a   component getdefaultmodelobject
if  a    null    b    null
return true
if  a    null    b    null
return false
return a equals b
/** an unused flag */
private static final int flag_unused0   0x20000000
private static final int flag_unused1   0x800000
private static final int flag_unused2   0x1000000
private static final int flag_unused3   0x10000000
/** true when a component is being auto-added */
private static final int flag_auto   0x0001
/** flag for escaping html in model strings */
private static final int flag_escape_model_strings   0x0002
/** boolean whether this component's model is inheritable. */
static final int flag_inheritable_model   0x0004
/** versioning boolean */
private static final int flag_versioned   0x0008
/** visibility boolean */
private static final int flag_visible   0x0010
/** render tag boolean */
private static final int flag_render_body_only   0x0020
/** ignore attribute modifiers */
private static final int flag_ignore_attribute_modifier   0x0040
/** true when a component is enabled for model updates and is reachable. */
private static final int flag_enabled   0x0080
/** reserved subclass-definable flag bit */
protected static final int flag_reserved1   0x0100
/** reserved subclass-definable flag bit */
protected static final int flag_reserved2   0x0200
/** reserved subclass-definable flag bit */
protected static final int flag_reserved3   0x0400
/** reserved subclass-definable flag bit */
protected static final int flag_reserved4   0x0800
/** boolean whether this component was rendered at least once for tracking changes. */
private static final int flag_has_been_rendered   0x1000
/**
* internal indicator of whether this component may be rendered given the current context's
* authorization. it overrides the visible flag in case this is false. authorization is done
* before trying to render any component (otherwise we would end up with a half rendered page in
* the buffer)
*/
private static final int flag_is_render_allowed   0x2000
/** whether or not the component should print out its markup id into the id attribute */
private static final int flag_output_markup_id   0x4000
/**
* output a placeholder tag if the component is not visible. this is useful in ajax mode to go
* to visible(false) to visible(true) without the overhead of repainting a visible parent
* container
*/
private static final int flag_placeholder   0x8000
/** reserved subclass-definable flag bit */
protected static final int flag_reserved5   0x10000
/** oninitialize called */
protected static final int flag_initialized   0x20000
/** reserved subclass-definable flag bit */
private static final int flag_notused7   0x40000
/** reserved subclass-definable flag bit */
protected static final int flag_reserved8   0x80000
/**
* flag that determines whether the model is set. this is necessary because of the way we
* represent component state ({@link #data}). we can't distinguish between model and behavior
* using instanceof, because one object can implement both interfaces. thus we need this flag -
* when the flag is set, first object in {@link #data} is always model.
*/
private static final int flag_model_set   0x100000
/** true when a component is being removed from the hierarchy */
protected static final int flag_removing_from_hierarchy   0x200000
/**
* flag that makes we are in before-render callback phase set after component.onbeforerender is
* invoked (right before invoking beforerender on children)
*/
private static final int flag_rendering   0x2000000
private static final int flag_prepared_for_render   0x4000000
private static final int flag_after_rendering   0x8000000
private static final int flag_markup_attached   0x10000000
/**
* flag that restricts visibility of a component when set to true. this is usually used when a
* component wants to restrict visibility of another component. calling
* {@link #setvisible(boolean)} on a component does not always have the desired effect because
* isvisible() can be overwritten thus this flag offers an alternative that should always work.
*/
private static final int flag_visibility_allowed   0x40000000
private static final int flag_detaching   0x80000000
/**
* the name of attribute that will hold markup id
*/
private static final string markup_id_attr_name
/**
* meta data key for line precise error logging for the moment of addition. made package private
* for access in {@link markupcontainer} and {@link page}
*/
static final metadatakey<string> added_at_key   new metadatakey<string>
private static final long serialversionuid   1l
/**
* meta data key for line precise error logging for the moment of construction. made package
* private for access in {@link page}
*/
static final metadatakey<string> constructed_at_key   new metadatakey<string>
private static final long serialversionuid   1l
/** component flags. see flag_* for possible non-exclusive flag values. */
private int flags   flag_visible   flag_escape_model_strings   flag_versioned   flag_enabled
flag_is_render_allowed   flag_visibility_allowed
private static final short rflag_enabled_in_hierarchy_value   0x1
private static final short rflag_enabled_in_hierarchy_set   0x2
private static final short rflag_visible_in_hieararchy_value   0x4
private static final short rflag_visible_in_hierarchy_set   0x8
/** onconfigure has been called */
private static final short rflag_configured   0x10
private static final short rflag_before_render_super_call_verified   0x20
private static final short rflag_initialize_super_call_verified   0x40
/**
* flags that only keep their value during the request. useful for cache markers, etc. at the
* end of the request the value of this variable is reset to 0
*/
private transient short requestflags   0
/** component id. */
private string id
/** any parent container. */
private markupcontainer parent
/**
* instead of remembering the whole markupid, we just remember the number for this component so
* we can "reconstruct" the markupid on demand. while this could be part of {@link #data},
* profiling showed that having it as separate property consumes less memory.
*/
int generatedmarkupid    1
/** must only be used by auto components */
private transient imarkupfragment markup
/**
* will be re-created instead of persisted when session is replicated. markup sourcing strategy
* are typically stateless (but don't have to).
*/
private transient imarkupsourcingstrategy markupsourcingstrategy
/**
* the object that holds the component state.
* <p>
* what's stored here depends on what attributes are set on component. data can contains
* combination of following attributes:
* <ul>
* <li>model (indicated by {@link #flag_model_set})
* <li>metadataentry (optionally {@link metadataentry}[] if more metadata entries are present) *
* <li>{@link behavior}(s) added to component. the behaviors are not stored in separate array,
* they are part of the {@link #data} array (this is in order to save the space of the pointer
* to an empty array as most components have no behaviours). - fixme - explain why - is this
* correct?
* </ul>
* if there is only one attribute set (i.e. model or metadataentry([]) or one behavior), the
* #data object points directly to value of that attribute. otherwise the data is of type
* object[] where the attributes are ordered as specified above.
* <p>
*/
object data   null
final int data_start
return getflag flag_model_set  ? 1   0
final int data_length
if  data    null
return 0
else if  data instanceof object      data instanceof metadataentry<?>
return   object data  length
else
return 1
final object data_get int index
if  data    null
return null
else if  data instanceof object      data instanceof metadataentry<?>
object array    object data
return index < array length ? array   null
else if  index    0
return data
else
return null
final void data_set int index  object object
if  index > data_length     1
throw new indexoutofboundsexception     index
data_length
else if  index    0      data instanceof object      data instanceof metadataentry<?>
data   object
else
object array    object data
array   object
final void data_add object object
data_insert  1  object
final void data_insert int position  object object
int currentlength   data_length
if  position     1
position   currentlength
if  position > currentlength
throw new indexoutofboundsexception     position
currentlength
if  currentlength    0
data   object
else if  currentlength    1
object array   new object
if  position    0
array   object
array   data
else
array   data
array   object
data   array
else
object array   new object
object current    object data
int after   currentlength   position
if  position > 0
system arraycopy current  0  array  0  position
array   object
if  after > 0
system arraycopy current  position  array  position   1  after
data   array
final void data_remove int position
int currentlength   data_length
if  position > currentlength   1
throw new indexoutofboundsexception
else if  currentlength    1
data   null
else if  currentlength    2
object current    object data
if  position    0
data   current
else
data   current
else
object current    object data
data   new object
if  position > 0
system arraycopy current  0  data  0  position
if  position    currentlength   1
final int left   currentlength   position   1
system arraycopy current  position   1  data  position  left
/**
* constructor. all components have names. a component's id cannot be null. this is the minimal
* constructor of component. it does not register a model.
*
* @param id
*            the non-null id of this component
* @throws wicketruntimeexception
*             thrown if the component has been given a null id.
*/
public component final string id
this id  null
/**
* constructor. all components have names. a component's id cannot be null. this constructor
* includes a model.
*
* @param id
*            the non-null id of this component
* @param model
*            the component's model
*
* @throws wicketruntimeexception
*             thrown if the component has been given a null id.
*/
public component final string id  final imodel<?> model
setid id
getapplication   getcomponentinstantiationlisteners   oninstantiation this
final idebugsettings debugsettings   getapplication   getdebugsettings
if  debugsettings islineprecisereportingonnewcomponentenabled
setmetadata constructed_at_key
componentstrings tostring this  new markupexception
if  model    null
setmodelimpl wrap model
/**
* get the markup associated with the component. if not subclassed, the parent container is
* asked to return the markup of this child component.
* <p/>
* components like panel and border should return the "calling" markup fragment, e.g.
* <code>&lt;span wicket:id="mypanel"&gt;body&lt;/span&gt;</code>. you may use
* panel/border/enclosure.getmarkup(null) to return the associated markup file. and
* panel/border/enclosure.getmarkup(child) will search the child in the appropriate markup
* fragment.
*
* @see markupcontainer#getmarkup(component)
*
* @return the markup fragment
*/
public imarkupfragment getmarkup
// markup already determined or preset?
if  markup    null
return markup
// no parent, than check associated markup files
if  parent    null
// must be a markupcontainer to have associated markup file
if  this instanceof markupcontainer
markupcontainer container    markupcontainer this
if  container hasassociatedmarkup
markup   container getassociatedmarkup
return markup
// don't know how to find the markup
throw new markupnotfoundexception
tostring
// ask the parent for find the markup for me
markup   parent getmarkup this
return markup
/**
* called when the component gets added to a parent
*
* @return false, if it was called the first time
*/
final boolean internalonmarkupattached
boolean rtn   getflag flag_markup_attached
if  rtn    false
setflag flag_markup_attached  true
onmarkupattached
return rtn
/**
* can be subclassed by any user to implement init-like logic which requires the markup to be
* available
*/
protected void onmarkupattached
if  log isdebugenabled
log debug     tostring
/**
* @return the 'id' attribute from the associated markup tag
*/
public final string getmarkupidfrommarkup
componenttag tag   getmarkuptag
if  tag    null
string id   tag getattribute
if  strings isempty id     false
return id trim
return null
/**
* set the markup for the component. note that the component's markup variable is transient and
* thus must only be used for one render cycle. e.g. auto-component are using it. you may also
* it if you subclassed getmarkup().
*
* @param markup
*/
public final void setmarkup final imarkupfragment markup
this markup   markup
/**
* called once per request on components before they are about to be rendered. this method
* should be used to configure such things as visibility and enabled flags.
* <p>
* overrides must call {@code super.onconfigure()}, usually before any other code
* </p>
* <p>
* note: component hierarchy should not be modified inside this method, instead it should be
* done in {@link #onbeforerender()}
* </p>
* <p>
* note: why this method is preferrable to directly overriding {@link #isvisible()} and
* {@link #isenabled()}? because those methods are called multiple times even for processing of
* a single request. if they contain expensive logic they can slow down the response time of the
* entire page. further, overriding those methods directly on form components may lead to
* inconsistent or unexpected state depending on when those methods are called in the form
* processing workflow. it is a better practice to push changes to state rather than pull.
* </p>
* <p>
* note: if component's visibility or another property depends on another component you may call
* {@code other.configure()} followed by {@code other.isvisible()} as mentioned in
* {@link #configure()} javadoc.
* </p>
* <p>
* note: why should {@link #onbeforerender()} not be used for this? because if visibility of a
* component is toggled inside {@link #onbeforerender()} another method needs to be overridden
* to make sure {@link #onbeforerender()} will be invoked on invisible components:
*
* <pre>
* class mycomponent extends webcomponent
* {
* 	protected void onbeforerender()
* 	{
* 		setvisible(math.rand() &gt; 0.5f);
* 		super.onbeforerender();
* 	}
*
* 	// if this override is forgotten, once invisible component will never become visible
* 	protected boolean callonbeforerenderifnotvisible()
* 	{
* 		return true;
* 	}
* }
* </pre>
*
* vs
*
* <pre>
* class mycomponent extends webcomponent
* {
* 	protected void onconfigure()
* 	{
* 		super.onconfigure();
* 		setvisible(math.rand() &gt; 0.5f);
* 	}
* }
* </pre>
*/
protected void onconfigure
/**
* this method is meant to be used as an alternative to initialize components. usually the
* component's constructor is used for this task, but sometimes a component cannot be
* initialized in isolation, it may need to access its parent component or its markup in order
* to fully initialize. this method is invoked once per component's lifecycle when a path exists
* from this component to the {@link page} thus providing the component with an atomic callback
* when the component's environment is built out.
* <p>
* overrides must call super#{@link #oninitialize()}. usually this should be the first thing an
* override does, much like a constructor.
* </p>
* <p>
* parent containers are guaranteed to be initialized before their children
* </p>
*
* <p>
* it is safe to use {@link #getpage()} in this method
* </p>
*
* <p>
* note:the timing of this call is not precise, the contract is that it is called sometime
* before {@link component#onbeforerender()}.
* </p>
*
*/
protected void oninitialize
setrequestflag rflag_initialize_super_call_verified  true
/**
* checks if the component has been initialized - {@link #oninitialize()} has been called
*
* @return {@code true} if component has been initialized
*/
final boolean isinitialized
return getflag flag_initialized
/**
* this method is not part of the public api, do not call it
*
* used to call {@link #oninitialize()}
*/
public void internalinitialize
fireinitialize
/**
* used to call {@link #oninitialize()}
*/
final void fireinitialize
if   getflag flag_initialized
setflag flag_initialized  true
setrequestflag rflag_initialize_super_call_verified  false
oninitialize
if   getrequestflag rflag_initialize_super_call_verified
throw new illegalstateexception component class getname
getclass   getname
setrequestflag rflag_initialize_super_call_verified  false
getapplication   getcomponentinitializationlisteners   oninitialize this
/**
* called on very component after the page is rendered. it will call onafterrender for it self
* and its children.
*/
public final void afterrender
// if the component has been previously attached via attach()
// detach it now
try
setflag flag_after_rendering  true
// always detach children because components can be attached
// independently of their parents
onafterrenderchildren
onafterrender
getapplication   getcomponentonafterrenderlisteners   onafterrender this
if  getflag flag_after_rendering
throw new illegalstateexception component class getname
getclass   getname
finally
// this flag must always be set to false.
setflag flag_rendering  false
/**
*
*/
private final void internalbeforerender
configure
if   determinevisibility        getflag flag_rendering
getflag flag_prepared_for_render
setrequestflag rflag_before_render_super_call_verified  false
getapplication   getcomponentpreonbeforerenderlisteners   onbeforerender this
onbeforerender
getapplication   getcomponentpostonbeforerenderlisteners   onbeforerender this
if   getrequestflag rflag_before_render_super_call_verified
throw new illegalstateexception component class getname
getclass   getname
/**
* we need to postpone calling beforerender() on components that implement {@link ifeedback}, to
* be sure that all other component's beforerender() has been already called, so that ifeedbacks
* can collect all feedback messages. this is the key under list of postponed {@link ifeedback}
* is stored to request cycle metadata. the list is then iterated over in
* {@link #prepareforrender()} after calling {@link #beforerender()}, to initialize postponed
* components.
*/
private static final metadatakey<list<component>> feedback_list   new metadatakey<list<component>>
private static final long serialversionuid   1l
/**
* called for every component when the page is getting to be rendered. it will call
* onbeforerender for this component and all the child components
*/
public final void beforerender
if    this instanceof ifeedback
internalbeforerender
else
// this component is a feedback. feedback must be initialized last, so that
// they can collect messages from other components
list<component> feedbacks   getrequestcycle   getmetadata feedback_list
if  feedbacks    null
feedbacks   new arraylist<component>
getrequestcycle   setmetadata feedback_list  feedbacks
if  this instanceof markupcontainer
markupcontainer this  visitchildren ifeedback class
new ivisitor<component  void>
public void component component component  ivisit<void> visit
component beforerender
if   feedbacks contains this
feedbacks add this
/**
* triggers {@link #onconfigure()} to be invoked on this component if it has not already during
* this request.
* <p>
* this method should be invoked before any calls to {@link #isvisible()} or
* {@link #isenabled()}. usually this method will be called by the framework before the
* component is rendered and so users should not need to call it; however, in cases where
* visibility or enabled or other state of one component depends on the state of another this
* method should be manually invoked on the other component by the user. eg to link visiliby of
* two markup containers the following should be done:
*
* <pre>
* final webmarkupcontainer source=new webmarkupcontainer("a") {
* 	protected void onconfigure() {
*    setvisible(math.rand()>0.5f);
*  }
* };
*
* webmarkupcontainer linked=new webmarkupcontainer("b") {
* 	protected void onconfigure() {
* 		source.configure(); // make sure source is configured
* 		setvisible(source.isvisible());
*  }
* }
* </pre>
*
* </p>
*/
public final void configure
if   getrequestflag rflag_configured
clearenabledinhierarchycache
clearvisibleinhierarchycache
onconfigure
for  behavior behavior   getbehaviors
if  isbehavioraccepted behavior
behavior onconfigure this
setrequestflag rflag_configured  true
/**
* redirects to any intercept page previously specified by a call to redirecttointerceptpage.
*
* @return true if an original destination was redirected to
* @see component#redirecttointerceptpage(page)
*/
public final boolean continuetooriginaldestination
return restartresponseatinterceptpageexception continuetooriginaldestination
/**
* registers a debug feedback message for this component
*
* @param message
*            the feedback message
*/
public final void debug final serializable message
getsession   getfeedbackmessages   debug this  message
getsession   dirty
/**
* signals this component that it is removed from the component hierarchy.
*/
final void internalonremove
setflag flag_removing_from_hierarchy  true
onremove
if  getflag flag_removing_from_hierarchy
throw new illegalstateexception component class getname
getclass   getname
removechildren
/**
* detaches the component. this is called at the end of the request for all the pages that are
* touched in that request.
*/
public final void detach
// if the component has been previously attached via attach()
// detach it now
setflag flag_detaching  true
ondetach
if  getflag flag_detaching
throw new illegalstateexception component class getname
getclass   getname
// always detach models because they can be attached without the
// component. eg component has a compoundpropertymodel and one of its
// children component's getmodelobject is called
detachmodels
// detach any behaviors
new behaviors this  detach
// always detach children because components can be attached
// independently of their parents
detachchildren
// reset the model to null when the current model is a iwrapmodel and
// the model that created it/wrapped in it is a icomponentinheritedmodel
// the model will be created next time.
if  getflag flag_inheritable_model
setmodelimpl null
setflag flag_inheritable_model  false
clearenabledinhierarchycache
clearvisibleinhierarchycache
requestflags   0
internaldetach
// notify any detach listener
idetachlistener detachlistener   getapplication   getframeworksettings
getdetachlistener
if  detachlistener    null
detachlistener ondetach this
/**
* removes the cached markup at the end of the request. for the next request it will be get
* either from the parent's markup or from {@link markupcache}.
*/
private void internaldetach
markup   null
/**
* detaches all models
*/
public void detachmodels
// detach any detachable model from this component
detachmodel
/**
* registers an error feedback message for this component
*
* @param message
*            the feedback message
*/
public final void error final serializable message
getsession   getfeedbackmessages   error this  message
getsession   dirty
/**
* registers an fatal error feedback message for this component
*
* @param message
*            the feedback message
*/
public final void fatal final serializable message
getsession   getfeedbackmessages   fatal this  message
getsession   dirty
/**
* finds the first container parent of this component of the given class.
*
* @param <z>
*            type of parent
*
*
* @param c
*            markupcontainer class to search for
* @return first container parent that is an instance of the given class, or null if none can be
*         found
*/
public final <z> z findparent final class<z> c
// start with immediate parent
markupcontainer current   parent
// walk up containment hierarchy
while  current    null
// is current an instance of this class?
if  c isinstance current
return c cast current
// check parent
current   current getparent
// failed to find component
return null
/**
* @return the nearest markup container with associated markup
*/
public final markupcontainer findparentwithassociatedmarkup
markupcontainer container   parent
while  container    null
if  container hasassociatedmarkup
return container
container   container getparent
// this should never happen since page always has associated markup
throw new wicketruntimeexception
/**
* gets interface to application that this component is a part of.
*
* @return the application associated with the session that this component is in.
* @see application
*/
public final application getapplication
return application get
/**
* @return a path of the form [page-class-name].[page-relative-path]
* @see component#getpagerelativepath()
*/
public final string getclassrelativepath
return getclass   getname     path_separator   getpagerelativepath
/**
* gets the converter that should be used by this component.
*
* @param type
*            the type to convert to
*
* @return the converter that should be used by this component
*/
public <c> iconverter<c> getconverter class<c> type
return getapplication   getconverterlocator   getconverter type
/**
* gets whether model strings should be escaped.
*
* @return returns whether model strings should be escaped
*/
public final boolean getescapemodelstrings
return getflag flag_escape_model_strings
/**
* @return any feedback message for this component
*/
@suppresswarnings
public final feedbackmessage getfeedbackmessage
return getsession   getfeedbackmessages   messageforcomponent this
/**
* @return all feedback messages for this component
*/
public final list<feedbackmessage> getfeedbackmessages
return getsession   getfeedbackmessages   messagesforcomponent this
/**
* gets the id of this component.
*
* @return the id of this component
*/
public string getid
return id
/**
* @return innermost model for this component
*/
public final imodel<?> getinnermostmodel
return getinnermostmodel getdefaultmodel
/**
* gets the locale for this component. by default, it searches its parents for a locale. if no
* parents (it's a recursive search) returns a locale, it gets one from the session.
*
* @return the locale to be used for this component
* @see session#getlocale()
*/
public locale getlocale
if  parent    null
return parent getlocale
return getsession   getlocale
/**
* convenience method to provide easy access to the localizer object within any component.
*
* @return the localizer object
*/
public final localizer getlocalizer
return getapplication   getresourcesettings   getlocalizer
/**
* get the first component tag in the associated markup
*
* @return first component tag
*/
private final componenttag getmarkuptag
imarkupfragment markup   getmarkup
if  markup    null
for  int i   0  i < markup size    i
markupelement elem   markup get i
if  elem instanceof componenttag
return  componenttag elem
return null
/**
* this is wicket internal only. do not use it.
*
* get a copy of the markup's attributes which are associated with the component.
* <p>
* modifications to the map returned don't change the tags attributes. it is just a copy.
* <p>
* note: the component must have been added (directly or indirectly) to a container with an
* associated markup file (page, panel or border).
*
* @return markup attributes
*/
public final valuemap getmarkupattributes
componenttag tag   getmarkuptag
if  tag    null
valuemap attrs   new valuemap tag getattributes
attrs makeimmutable
return attrs
return valuemap empty_map
/**
* get the markupid
*
* @return markupid
*/
public final object getmarkupidimpl
if  generatedmarkupid     1
return generatedmarkupid
string id   getmetadata markup_id_key
// if still no markup id is found, and the component has been attached to a page, try to
// retrieve the id from the markup file.
if  id    null    findpage      null
id   getmarkupidfrommarkup
return id
/**
* find the page and get net value from an auto-index
*
* @return autoindex
*/
private final int nextautoindex
page page   findpage
if  page    null
throw new wicketruntimeexception
return page getautoindex
/**
* retrieves id by which this component is represented within the markup. this is either the id
* attribute set explicitly via a call to {@link #setmarkupid(string)}, id attribute defined in
* the markup, or an automatically generated id - in that order.
* <p>
* if no id is set and <code>createifdoesnotexist</code> is false, this method will return null.
* otherwise it will generate an id value which by default will be unique in the page. this is
* the preferred way as there is no chance of id collision.
* <p>
*
* <p>
* note: this method should only be called after the component or its parent have been added to
* the page.
*
* @param createifdoesnotexist
*            when there is no existing markup id, determines whether it should be generated or
*            whether <code>null</code> should be returned.
*
* @return markup id of the component
*/
public string getmarkupid boolean createifdoesnotexist
object storedmarkupid   getmarkupidimpl
if  storedmarkupid instanceof string
return  string storedmarkupid
if  storedmarkupid    null    createifdoesnotexist    false
return null
final int generatedmarkupid   storedmarkupid instanceof integer ?  integer storedmarkupid
getsession   nextsequencevalue
if  storedmarkupid    null
setmarkupidimpl generatedmarkupid
string markupidprefix
if   getapplication   usesdeploymentconfig
// in non-deployment mode we make the markup id include component id
// so it is easier to debug
markupidprefix   getid
string markupidpostfix   integer tohexstring generatedmarkupid  tolowercase
string markupid   markupidprefix   markupidpostfix
// make sure id is compliant with w3c requirements (starts with a letter)
char c   markupid charat 0
if   character isletter c
markupid       markupid
// escape some noncompliant characters
markupid   strings replaceall markupid        tostring
markupid   markupid replace
markupid   markupid replace
markupid   markupid replace
return markupid
/**
* retrieves id by which this component is represented within the markup. this is either the id
* attribute set explicitly via a call to {@link #setmarkupid(string)}, id attribute defined in
* the markup, or an automatically generated id - in that order.
* <p>
* if no explicit id is set this function will generate an id value that will be unique in the
* page. this is the preferred way as there is no chance of id collision.
* <p>
* note: this method should only be called after the component or its parent have been added to
* the page.
*
* @return markup id of the component
*/
public string getmarkupid
return getmarkupid true
/**
* gets metadata for this component using the given key.
*
* @param <m>
*            the type of the metadata.
*
* @param key
*            the key for the data
* @return the metadata or null of no metadata was found for the given key
* @see metadatakey
*/
public final <m extends serializable> m getmetadata final metadatakey<m> key
return key get getmetadata
/**
*
* @return meta data entry
*/
private metadataentry<?> getmetadata
metadataentry<?> metadata   null
// index where we should expect the entry
int index   getflag flag_model_set  ? 1   0
int length   data_length
if  index < length
object object   data_get index
if  object instanceof metadataentry<?>
metadata    metadataentry<?> object
else if  object instanceof metadataentry
metadata   new metadataentry    metadataentry<?> object
return metadata
/**
* gets the model. it returns the object that wraps the backing model.
*
* @return the model
*/
public final imodel<?> getdefaultmodel
imodel<?> model   getmodelimpl
// if model is null
if  model    null
// give subclass a chance to lazy-init model
model   initmodel
setmodelimpl model
return model
/**
* gets the backing model object. unlike getdefaultmodel().getobject(), this method returns null
* for a null model.
*
* @return the backing model object
*/
public final object getdefaultmodelobject
final imodel<?> model   getdefaultmodel
if  model    null
try
// get model value for this component.
return model getobject
catch  runtimeexception ex
log error
this tostring true   ex
throw ex
return null
/**
* gets a model object as a string. depending on the "escape model strings" flag of the
* component, the string is either html escaped or not. "html escaped" meaning that only html
* sensitive chars are escaped but not all none-ascii chars. proper html encoding should be used
* instead. in case you really need a fully escaped model string you may call
* {@link strings#escapemarkup(charsequence, boolean, boolean)} on the model string returned.
*
* @see strings#escapemarkup(charsequence, boolean, boolean)
* @see #getescapemodelstrings()
*
* @return model object for this component as a string
*/
public final string getdefaultmodelobjectasstring
return getdefaultmodelobjectasstring getdefaultmodelobject
/**
* gets a model object as a string. depending on the "escape model strings" flag of the
* component, the string is either html escaped or not. "html escaped" meaning that only html
* sensitive chars are escaped but not all none-ascii chars. proper html encoding should be used
* instead. in case you really need a fully escaped model string you may call
* {@link strings#escapemarkup(charsequence, boolean, boolean)} on the model string returned.
*
* @see strings#escapemarkup(charsequence, boolean, boolean)
* @see #getescapemodelstrings()
*
* @param modelobject
*            model object to convert to string
* @return the string
*/
@suppresswarnings
public final string getdefaultmodelobjectasstring final object modelobject
if  modelobject    null
// get converter
final class<?> objectclass   modelobject getclass
final iconverter converter   getconverter objectclass
// model string from property
final string modelstring   converter converttostring modelobject  getlocale
if  modelstring    null
// if we should escape the markup
if  getflag flag_escape_model_strings
// escape html sensitive characters only. not all none-ascii chars
return strings escapemarkup modelstring  false  false  tostring
return modelstring
return
/**
* gets whether or not component will output id attribute into the markup. id attribute will be
* set to the value returned from {@link component#getmarkupid()}.
*
* @return whether or not component will output id attribute into the markup
*/
public final boolean getoutputmarkupid
return getflag flag_output_markup_id
/**
* gets whether or not an invisible component will render a placeholder tag.
*
* @return true if a placeholder tag should be rendered
*/
public final boolean getoutputmarkupplaceholdertag
return getflag flag_placeholder
/**
* gets the page holding this component.
*
* @return the page holding this component
* @throws illegalstateexception
*             thrown if component is not yet attached to a page.
*/
public final page getpage
// search for nearest page
final page page   findpage
// if no page was found
if  page    null
// give up with a nice exception
throw new wicketruntimeexception     this
return page
/**
* gets the path to this component relative to the page it is in.
*
* @return the path to this component relative to the page it is in
*/
public final string getpagerelativepath
return strings afterfirstpathcomponent getpath    path_separator
/**
* gets any parent container, or null if there is none.
*
* @return any parent container, or null if there is none
*/
public final markupcontainer getparent
return parent
/**
* gets this component's path.
*
* @return colon separated path to this component in the component hierarchy
*/
public final string getpath
final prependingstringbuffer buffer   new prependingstringbuffer 32
for  component c   this  c    null  c   c getparent
if  buffer length   > 0
buffer prepend path_separator
buffer prepend c getid
return buffer tostring
/**
* if false the component's tag will be printed as well as its body (which is default). if true
* only the body will be printed, but not the component's tag.
*
* @return if true, the component tag will not be printed
*/
public final boolean getrenderbodyonly
return getflag flag_render_body_only
/**
* @return the request for this component's active request cycle
*/
public final request getrequest
requestcycle requestcycle   getrequestcycle
if  requestcycle    null
// happens often with wickettester when one forgets to call
// createrequestcycle()
throw new wicketruntimeexception
return requestcycle getrequest
/**
* gets the active request cycle for this component
*
* @return the request cycle
*/
public final requestcycle getrequestcycle
return requestcycle get
/**
* @return the response for this component's active request cycle
*/
public final response getresponse
return getrequestcycle   getresponse
/**
* gets the current session object.
*
* @return the session that this component is in
*/
public session getsession
return session get
/**
* @return size of this component in bytes
*/
public long getsizeinbytes
final markupcontainer originalparent   parent
parent   null
long size    1
try
size   wicketobjects sizeof this
catch  exception e
log error     this  e
parent   originalparent
return size
/**
* @param key
*            key of string resource in property file
* @return the string
* @see localizer
*/
public final string getstring final string key
return getstring key  null
/**
* @param key
*            the resource key
* @param model
*            the model
* @return the formatted string
* @see localizer
*/
public final string getstring final string key  final imodel<?> model
return getlocalizer   getstring key  this  model
/**
* @param key
*            the resource key
* @param model
*            the model
* @param defaultvalue
*            a default value if the string cannot be found
* @return the formatted string
* @see localizer
*/
public final string getstring final string key  final imodel<?> model  final string defaultvalue
return getlocalizer   getstring key  this  model  defaultvalue
/**
* a convinient method. same as session.get().getstyle().
*
* @return the style of this component respectively the style of the session.
*
* @see org.apache.wicket.session#getstyle()
*/
public final string getstyle
session session   getsession
if  session    null
throw new wicketruntimeexception
return session getstyle
/**
* gets the variation string of this component that will be used to look up markup for this
* component. subclasses can override this method to define by an instance what markup variation
* should be picked up. by default it will return null or the value of a parent.
*
* @return the variation of this component.
*/
public string getvariation
if  parent    null
return parent getvariation
return null
/**
* gets whether this component was rendered at least once.
*
* @return true if the component has been rendered before, false if it is merely constructed
*/
public final boolean hasbeenrendered
return getflag flag_has_been_rendered
/**
* @return true if this component has an error message
*/
public final boolean haserrormessage
return getsession   getfeedbackmessages   haserrormessagefor this
/**
* @return true if this component has some kind of feedback message
*/
public final boolean hasfeedbackmessage
return getsession   getfeedbackmessages   hasmessagefor this
/**
* registers an informational feedback message for this component
*
* @param message
*            the feedback message
*/
public final void info final serializable message
getsession   getfeedbackmessages   info this  message
getsession   dirty
/**
* registers an success feedback message for this component
*
* @param message
*            the feedback message
*/
public final void success final serializable message
getsession   getfeedbackmessages   success this  message
getsession   dirty
/**
* authorizes an action for a component.
*
* @param action
*            the action to authorize
* @return true if the action is allowed
* @throws authorizationexception
*             can be thrown by implementation if action is unauthorized
*/
public final boolean isactionauthorized action action
iauthorizationstrategy authorizationstrategy   getsession   getauthorizationstrategy
if  authorizationstrategy    null
return authorizationstrategy isactionauthorized this  action
return true
/**
* @return true if this component is authorized to be enabled, false otherwise
*/
public final boolean isenableallowed
return isactionauthorized enable
/**
* gets whether this component is enabled. specific components may decide to implement special
* behavior that uses this property, like web form components that add a disabled='disabled'
* attribute when enabled is false.
*
* @return whether this component is enabled.
*/
public boolean isenabled
return getflag flag_enabled
/**
* checks the security strategy if the {@link component#render} action is allowed on this
* component
*
* @return ture if {@link component#render} action is allowed, false otherwise
*/
public final boolean isrenderallowed
return getflag flag_is_render_allowed
/**
* returns if the component is stateless or not. it checks the stateless hint if that is false
* it returns directly false. if that is still true it checks all its behaviors if they can be
* stateless.
*
* @return whether the component is stateless.
*/
public final boolean isstateless
if   getstatelesshint
return false
for  behavior behavior   getbehaviors
if   behavior getstatelesshint this
return false
return true
/**
* @return {@code true} if this component should notify its holding page about changes in its
*         state. if a {@link page} is not versioned then it wont track changes in its
*         components and will use the same {@link page#getpageid()} during its lifetime
*/
public boolean isversioned
// is the component itself versioned?
if   getflag flag_versioned
return false
else
// if there's a parent and this component is versioned
if  parent    null
// check if the parent is unversioned. if any parent
// (recursively) is unversioned, then this component is too
if   parent isversioned
return false
return true
/**
* gets whether this component and any children are visible.
* <p>
* warning: this method can be called multiple times during a request. if you override this
* method, it is a good idea to keep it cheap in terms of processing. alternatively, you can
* call {@link #setvisible(boolean)}.
* <p>
*
* @return true if component and any children are visible
*/
public boolean isvisible
return getflag flag_visible
/**
* checks if the component itself and all its parents are visible.
*
* @return true if the component and all its parents are visible.
*/
public final boolean isvisibleinhierarchy
component parent   getparent
if  parent    null     parent isvisibleinhierarchy
return false
else
return determinevisibility
/**
* this method is not part of the wicket public api. do not use it!
*
* sets the rendering flag and removes the prepared_for_render flag on component and it's
* children.
*
* @param setrenderingflag
*            if this is false only the prepared_for_render flag is removed from component, the
*            rendering flag is not set.
*
* @see #internalprepareforrender(boolean)
*/
public final void markrendering boolean setrenderingflag
internalmarkrendering setrenderingflag
/**
* called to indicate that the model content for this component has been changed
*/
public final void modelchanged
// call user code
internalonmodelchanged
onmodelchanged
/**
* called to indicate that the model content for this component is about to change
*/
public final void modelchanging
checkhierarchychange this
// call user code
onmodelchanging
// tell the page that our model changed
final page page   findpage
if  page    null
page componentmodelchanging this
/**
* this method is not part of the wicket public api. do not use it!
* <p>
* prepares the component and it's children for rendering. on whole page render this method must
* be called on the page. on ajax request, this method must be called on the updated component.
*
* @param setrenderingflag
*            whether to set the rendering flag. this must be true if the page is about to be
*            rendered. however, there are usecases to call this method without an immediate
*            render (e.g. on stateless listener request target to build the component
*            hierarchy), in that case setrenderingflag should be false.
*/
public void internalprepareforrender boolean setrenderingflag
beforerender
if  setrenderingflag
// only process feedback panel when we are about to be rendered.
// setrenderingflag is false in case prepareforrender is called only to build component
// hierarchy (i.e. in bookmarkablelistenerinterfacerequesttarget).
// prepareforrender(true) is always called before the actual rendering is done so
// that's where feedback panels gather the messages
list<component> feedbacks   getrequestcycle   getmetadata feedback_list
if  feedbacks    null
for  component feedback   feedbacks
feedback internalbeforerender
getrequestcycle   setmetadata feedback_list  null
markrendering setrenderingflag
// check authorization
// first the component itself
// (after attach as otherwise list views etc wont work)
setrenderallowed
/**
* this method is not part of the wicket public api. do not use it!
*
* prepares the component and it's children for rendering. on whole page render this method must
* be called on the page. on ajax request, this method must be called on updated component.
*/
public final void prepareforrender
internalprepareforrender true
/**
* redirects browser to an intermediate page such as a sign-in page. the current request's url
* is saved for future use by method continuetooriginaldestination(); only use this method when
* you plan to continue to the current url at some later time; otherwise just use
* setresponsepage or - when you are in a constructor or checkaccessmethod, call redirectto.
*
* @param page
*            the sign in page
*
* @see component#continuetooriginaldestination()
*/
public final void redirecttointerceptpage final page page
throw new restartresponseatinterceptpageexception page
/**
* removes this component from its parent. it's important to remember that a component that is
* removed cannot be referenced from the markup still.
* <p>
* you must not use this method in your callback to any of the
* {@link markupcontainer#visitchildren(ivisitor)} methods. see <a
* href="https://issues.apache.org/jira/browse/wicket-3229">wicket-3329</a>.
*/
public final void remove
if  parent    null
throw new illegalstateexception     this
parent remove this
/**
* render the component.
*/
public final void render
runtimeexception exception   null
try
// invoke prepareforrender only if this is the root component to be rendered
markupcontainer parent   getparent
if   parent    null      parent getflag flag_rendering     false     isauto
internalprepareforrender true
// do the render
internalrender
catch  final runtimeexception ex
// remember it as the originating exception
exception   ex
finally
try
// cleanup
afterrender
catch  runtimeexception ex2
// only remember it if not already another exception happened
if  exception    null
exception   ex2
// re-throw if needed
if  exception    null
throw exception
/**
* performs a render of this component as part of a page level render process.
*/
private final void internalrender
// make sure there is a markup available for the component
imarkupfragment markup   getmarkup
if  markup    null
throw new markupnotfoundexception     tostring
// markupstream is an iterator for the markup
markupstream markupstream   new markupstream markup
// flag: we stated the render process
markrendering true
markupelement elem   markup get 0
if  elem instanceof componenttag
// guarantee that the markupstream is set and determinevisibility not yet tested
// see wicket-2049
componenttag elem  onbeforerender this  markupstream
// determine if component is visible using it's authorization status
// and the isvisible property.
if  determinevisibility
setflag flag_has_been_rendered  true
// rendering is beginning
if  log isdebugenabled
log debug     this
try
notifybehaviorscomponentbeforerender
onrender
notifybehaviorscomponentrendered
// component has been rendered
rendered
catch  runtimeexception ex
onexception ex
if  log isdebugenabled
log debug     this
// elem is null when rendering a page
else if   elem    null      elem instanceof componenttag
if  getflag flag_placeholder
renderplaceholdertag  componenttag elem  getresponse
/**
* called when a runtime exception is caught during the render process
*
* @param ex
*            the exception caught.
*/
private void onexception final runtimeexception ex
// call each behaviors onexception() to allow the
// behavior to clean up
for  behavior behavior   getbehaviors
if  isbehavioraccepted behavior
try
behavior onexception this  ex
catch  throwable ex2
log error    ex2
// re-throw the exception
throw ex
/**
* renders a placeholder tag for the component when it is invisible and
* {@link #setoutputmarkupplaceholdertag(boolean)} has been called with <code>true</code>.
*
* @param tag
*            component tag
* @param response
*            response
*/
protected void renderplaceholdertag final componenttag tag  final response response
string ns   strings isempty tag getnamespace    ? null   tag getnamespace
response write
if  ns    null
response write ns
response write tag getname
response write  "
response write getajaxregionmarkupid
response write   style   >< "
if  ns    null
response write ns
response write tag getname
response write
/**
* returns the id of the markup region that will be updated via ajax. this can be different to
* the markup id of the component if a {@link iajaxregionmarkupidprovider} behavior has been
* added.
*
* @return the markup id of the region to be updated via ajax.
*/
public final string getajaxregionmarkupid
string markupid   null
for  behavior behavior   getbehaviors
if  behavior instanceof iajaxregionmarkupidprovider
markupid     iajaxregionmarkupidprovider behavior  getajaxregionmarkupid this
break
if  markupid    null
if  this instanceof iajaxregionmarkupidprovider
markupid     iajaxregionmarkupidprovider this  getajaxregionmarkupid this
if  markupid    null
markupid   getmarkupid
return markupid
/**
* this method is not part of the wicket public api. do not use it.
* <p>
* renders the component at the current position in the given markup stream. the method
* oncomponenttag() is called to allow the component to mutate the start tag. the method
* oncomponenttagbody() is then called to permit the component to render its body.
*/
public final void internalrendercomponent
final imarkupfragment markup   getmarkup
if  markup    null
throw new markupexception     tostring
final markupstream markupstream   new markupstream markup
// get mutable copy of next tag
final componenttag opentag   markupstream gettag
final componenttag tag   opentag mutable
// call any tag handler
oncomponenttag tag
// if we're an openclose tag
if   tag isopenclose       tag isopen
// we were something other than <tag> or <tag/>
markupstream throwmarkupexception
tag
if  tag isopenclose      opentag isopen
markupstream throwmarkupexception     tag
try
// render open tag
if  getrenderbodyonly      false
rendercomponenttag tag
markupstream next
// render the body only if open-body-close. do not render if open-close.
if  tag isopen
// render the body. the default strategy will simply call the component's
// oncomponenttagbody() implementation.
getmarkupsourcingstrategy   oncomponenttagbody this  markupstream  tag
// render close tag
if  tag isopen
if  opentag isopen
renderclosingcomponenttag markupstream  tag  getrenderbodyonly
else if  getrenderbodyonly      false
if  needtorendertag opentag
// close the manually opened tag. and since the user might have changed the
// tag name ...
getresponse   write tag syntheticclosetagstring
catch  wicketruntimeexception wre
throw wre
catch  runtimeexception re
throw new wicketruntimeexception     this  re
/**
*
* @param opentag
* @return true, if the tag shall be rendered
*/
private boolean needtorendertag final componenttag opentag
// if a open-close tag has been modified to be open-body-close than a
// synthetic close tag must be rendered.
boolean rendertag    opentag    null      opentag instanceof wickettag
if  rendertag    false
rendertag    getapplication   getmarkupsettings   getstripwickettags
return rendertag
/**
* called to indicate that a component has been rendered. this method should only very rarely be
* called at all. some components may render its children without calling render() on them.
* these components need to call rendered() to indicate that its child components were actually
* rendered, the framework would think they had never been rendered, and in development mode
* this would result in a runtime exception.
*/
public final void rendered
page page   findpage
if  page    null
// tell the page that the component rendered
page componentrendered this
else
log error
tostring
/**
* get the markup sourcing strategy for the component. if null,
* {@link #newmarkupsourcingstrategy()} will be called.
*
* @return markup sourcing strategy
*/
protected final imarkupsourcingstrategy getmarkupsourcingstrategy
if  markupsourcingstrategy    null
markupsourcingstrategy   newmarkupsourcingstrategy
// if not strategy by provided, than we use a default one.
if  markupsourcingstrategy    null
markupsourcingstrategy   defaultmarkupsourcingstrategy get
return markupsourcingstrategy
/**
* if {@link #getmarkupsourcingstrategy()} returns null, this method will be called. by default
* it returns null, which means that a default markup strategy will be attached to the
* component.
* <p>
* please note that markup source strategies are not persisted. instead they get re-created by
* calling this method again. that's ok since markup sourcing strategies usually do not maintain
* a state.
*
* @return markup sourcing strategy
*/
protected imarkupsourcingstrategy newmarkupsourcingstrategy
return null
/**
* this method is not part of the wicket public api. do not use it.
*
* print to the web response what ever the component wants to contribute to the head section.
* make sure that all attached behaviors are asked as well.
* <p>
* not intended for overriding by framework clients. rather, use
* {@link component#renderhead(org.apache.wicket.markup.html.iheaderresponse)}
* </p>
*
* @param container
*            the htmlheadercontainer
*/
public void renderhead final htmlheadercontainer container
if  isvisibleinhierarchy      isrenderallowed
if  log isdebugenabled
log debug     tostring false
iheaderresponse response   container getheaderresponse
// allow component to contribute
if  response wasrendered this     false
// make sure the markup source strategy contributes to the header first
// to be backward compatible. wicket-3761
getmarkupsourcingstrategy   renderhead this  container
// then let the component itself to contribute to the header
renderhead this  response
response markrendered this
// than ask all behaviors
for  behavior behavior   getbehaviors
if  isbehavioraccepted behavior
if  response wasrendered behavior     false
behavior renderhead this  response
response markrendered behavior
/**
* replaces this component with another. the replacing component must have the same component id
* as this component. this method serves as a shortcut to
*
* <code>this.getparent().replace(replacement)</code>
*
* and provides a better context for errors.
* <p>
* usage: <code>component = component.replacewith(replacement);</code>
* </p>
*
* @since 1.2.1
*
* @param replacement
*            component to replace this one
* @return the component which replaced this one
*/
public component replacewith component replacement
if  replacement    null
throw new illegalargumentexception
if   getid   equals replacement getid
throw new illegalargumentexception
replacement getid         getid
if  parent    null
throw new illegalstateexception
parent replace replacement
return replacement
/**
* @param component
*            the component to compare with
* @return true if the given component's model is the same as this component's model.
*/
public final boolean sameinnermostmodel final component component
return sameinnermostmodel component getdefaultmodel
/**
* @param model
*            the model to compare with
* @return true if the given component's model is the same as this component's model.
*/
public final boolean sameinnermostmodel final imodel<?> model
// get the two models
imodel<?> thismodel   getdefaultmodel
// if both models are non-null they could be the same
if  thismodel    null    model    null
return getinnermostmodel thismodel     getinnermostmodel model
return false
/**
* sets whether this component is enabled. specific components may decide to implement special
* behavior that uses this property, like web form components that add a disabled='disabled'
* attribute when enabled is false. if it is not enabled, it will not be allowed to call any
* listener method on it (e.g. link.onclick) and the model object will be protected (for the
* common use cases, not for programmer's misuse)
*
* @param enabled
*            whether this component is enabled
* @return this
*/
public final component setenabled final boolean enabled
// is new enabled state a change?
if  enabled    getflag flag_enabled
// tell the page that this component's enabled was changed
if  isversioned
final page page   findpage
if  page    null
addstatechange
// change visibility
setflag flag_enabled  enabled
onenabledstatechanged
return this
void clearenabledinhierarchycache
setrequestflag rflag_enabled_in_hierarchy_set  false
void onenabledstatechanged
clearenabledinhierarchycache
/**
* sets whether model strings should be escaped.
*
* @param escapemarkup
*            true is model strings should be escaped
* @return this
*/
public final component setescapemodelstrings final boolean escapemarkup
setflag flag_escape_model_strings  escapemarkup
return this
/**
* set markup id, which must be string or integer
*
* @param markupid
*/
public final void setmarkupidimpl object markupid
if  markupid    null      markupid instanceof string       markupid instanceof integer
throw new illegalargumentexception
if  markupid instanceof integer
generatedmarkupid    integer markupid
setmetadata markup_id_key  null
return
generatedmarkupid    1
setmetadata markup_id_key   string markupid
setoutputmarkupid true
/**
* copy markupid
*
* @param comp
*/
final void setmarkupid component comp
args notnull comp
generatedmarkupid   comp generatedmarkupid
setmetadata markup_id_key  comp getmetadata markup_id_key
if  comp getoutputmarkupid
setoutputmarkupid true
/**
* sets this component's markup id to a user defined value. it is up to the user to ensure this
* value is unique.
* <p>
* the recommended way is to let wicket generate the value automatically, this method is here to
* serve as an override for that value in cases where a specific id must be used.
* <p>
* if null is passed in the user defined value is cleared and markup id value will fall back on
* automatically generated value
*
* @see #getmarkupid()
*
* @param markupid
*            markup id value or null to clear any previous user defined value
* @return this for chaining
*/
public component setmarkupid string markupid
args notempty markupid
// todo check if an automatic id has already been generated or getmarkupid() called
// previously and throw an illegalstateexception because something else might be depending
// on previous id
setmarkupidimpl markupid
return this
/**
* sets the metadata for this component using the given key. if the metadata object is not of
* the correct type for the metadata key, an illegalargumentexception will be thrown. for
* information on creating metadatakeys, see {@link metadatakey}.
*
* @param <m>
*            the type of the metadata
*
* @param key
*            the singleton key for the metadata
* @param object
*            the metadata object
* @throws illegalargumentexception
* @see metadatakey
*/
public final <m> void setmetadata final metadatakey<m> key  final m object
metadataentry<?> old   getmetadata
object metadata   null
metadataentry<?> metadataarray   key set getmetadata    object
if  metadataarray    null    metadataarray length > 0
metadata    metadataarray length > 1  ? metadataarray   metadataarray
int index   getflag flag_model_set  ? 1   0
if  old    null    metadata    null
data_insert index  metadata
else if  old    null    metadata    null
data_set index  metadata
else if  old    null    metadata    null
data_remove index
/**
* sets the given model.
* <p>
* warning: do not override this method unless you have a very good reason for it. overriding
* this might open up security leaks and break back-button support.
* </p>
*
* @param model
*            the model
* @return this
*/
public component setdefaultmodel final imodel<?> model
imodel<?> prevmodel   getmodelimpl
// detach current model
if  prevmodel    null
prevmodel detach
imodel<?> wrappedmodel   prevmodel
if  prevmodel instanceof iwrapmodel
wrappedmodel     iwrapmodel<?> prevmodel  getwrappedmodel
// change model
if  wrappedmodel    model
if  wrappedmodel    null
addstatechange
setmodelimpl wrap model
modelchanged
return this
/**
* @return model
*/
imodel<?> getmodelimpl
if  getflag flag_model_set
return  imodel<?> data_get 0
return null
/**
*
* @param model
*/
void setmodelimpl imodel<?> model
if  getflag flag_model_set
if  model    null
data_set 0  model
// wicket-3413 reset 'inherited model' flag if model changed
// and a new one is not icomponentinheritedmodel
if  getflag flag_inheritable_model       model instanceof icomponentinheritedmodel
setflag flag_inheritable_model  false
else
data_remove 0
setflag flag_model_set  false
else
if  model    null
data_insert 0  model
setflag flag_model_set  true
/**
* sets the backing model object. unlike <code>getdefaultmodel().setobject(object)</code>, this
* method checks authorisation and model comparator, and invokes <code>modelchanging</code> and
* <code>modelchanged</code> if the value really changes.
*
* @param object
*            the object to set
* @return this
*/
@suppresswarnings
public final component setdefaultmodelobject final object object
final imodel<object> model    imodel<object> getdefaultmodel
// check whether anything can be set at all
if  model    null
throw new illegalstateexception
getpagerelativepath
// check authorization
if   isactionauthorized enable
throw new unauthorizedactionexception this  enable
// check whether this will result in an actual change
if   getmodelcomparator   compare this  object
modelchanging
model setobject object
modelchanged
return this
/**
* sets whether or not component will output id attribute into the markup. id attribute will be
* set to the value returned from {@link component#getmarkupid()}.
*
* @param output
*            true if the component will output the id attribute into markup. please note that
*            the default behavior is to use the same id as the component. this means that your
*            component must begin with [a-za-z] in order to generate a valid markup id
*            according to: http://www.w3.org/tr/html401/types.html#type-name
*
* @return this for chaining
*/
public final component setoutputmarkupid final boolean output
setflag flag_output_markup_id  output
return this
/**
* render a placeholder tag when the component is not visible. the tag is of form:
* &lt;componenttag style="display:none;" id="markupid"/&gt;. this method will also call
* <code>setoutputmarkupid(true)</code>.
*
* this is useful, for example, in ajax situations where the component starts out invisible and
* then becomes visible through an ajax update. with a placeholder tag already in the markup you
* do not need to repaint this component's parent, instead you can repaint the component
* directly.
*
* when this method is called with parameter <code>false</code> the outputmarkupid flag is not
* reverted to false.
*
* @param outputtag
* @return this for chaining
*/
public final component setoutputmarkupplaceholdertag final boolean outputtag
if  outputtag    getflag flag_placeholder
if  outputtag
setoutputmarkupid true
setflag flag_placeholder  true
else
setflag flag_placeholder  false
// i think it's better to not setoutputmarkupid to false...
// user can do it if she want
return this
/**
* if false the component's tag will be printed as well as its body (which is default). if true
* only the body will be printed, but not the component's tag.
*
* @param rendertag
*            if true, the component tag will not be printed
* @return this
*/
public final component setrenderbodyonly final boolean rendertag
setflag flag_render_body_only  rendertag
return this
/**
* sets the page that will respond to this request
*
* @param <c>
*
* @param cls
*            the response page class
* @see requestcycle#setresponsepage(class)
*/
public final <c extends irequestablepage> void setresponsepage final class<c> cls
getrequestcycle   setresponsepage cls  null
/**
* sets the page class and its parameters that will respond to this request
*
* @param <c>
*
* @param cls
*            the response page class
* @param parameters
*            the parameters for this bookmarkable page.
* @see requestcycle#setresponsepage(class, pageparameters)
*/
public final <c extends irequestablepage> void setresponsepage final class<c> cls
pageparameters parameters
getrequestcycle   setresponsepage cls  parameters
/**
* sets the page that will respond to this request
*
* @param page
*            the response page
*
* @see requestcycle#setresponsepage(org.apache.wicket.request.component.irequestablepage)
*/
public final void setresponsepage final page page
getrequestcycle   setresponsepage page
/**
* @param versioned
*            true to turn on versioning for this component, false to turn it off for this
*            component and any children.
* @return this
*/
public component setversioned boolean versioned
setflag flag_versioned  versioned
return this
/**
* sets whether this component and any children are visible.
*
* @param visible
*            true if this component and any children should be visible
* @return this
*/
public final component setvisible final boolean visible
// is new visibility state a change?
if  visible    getflag flag_visible
// record component's visibility change
addstatechange
// change visibility
setflag flag_visible  visible
onvisiblestatechanged
return this
void clearvisibleinhierarchycache
setrequestflag rflag_visible_in_hierarchy_set  false
void onvisiblestatechanged
clearvisibleinhierarchycache
/**
* gets the string representation of this component.
*
* @return the path to this component
*/
@override
public string tostring
return tostring false
/**
* @param detailed
*            true if a detailed string is desired
* @return the string
*/
public string tostring final boolean detailed
try
final stringbuilder buffer   new stringbuilder
buffer append    append getid
if  detailed
final page page   findpage
if  page    null
buffer append
append getpath
append
append classes simplename getclass
else
buffer append
append getpage   getclass   getname
append
append getpath
append
append classes simplename getclass
append
append  determinevisibility
append
append isversioned
if  markup    null
buffer append    append new markupstream getmarkup    tostring
buffer append
return buffer tostring
catch  exception e
log warn    e
return string format
getid    e getclass   getname
/**
* returns a bookmarkable url that references a given page class using a given set of page
* parameters. since the url which is returned contains all information necessary to instantiate
* and render the page, it can be stored in a user's browser as a stable bookmark.
*
* @param <c>
*
* @see requestcycle#urlfor(class, org.apache.wicket.request.mapper.parameter.pageparameters)
*
* @param pageclass
*            class of page
* @param parameters
*            parameters to page
* @return bookmarkable url to page
*/
public final <c extends page> charsequence urlfor final class<c> pageclass
final pageparameters parameters
return getrequestcycle   urlfor pageclass  parameters
/**
* gets a url for the listener interface on a behavior (e.g. ibehaviorlistener on
* ajaxpagingnavigationbehavior).
*
* @param behaviour
*            the behavior that the url should point to
* @param listener
*            the listener interface that the url should call
* @return the url
*/
public final charsequence urlfor final behavior behaviour
final requestlistenerinterface listener
int id   getbehaviorid behaviour
page page   getpage
pageandcomponentprovider provider   new pageandcomponentprovider page  this
irequesthandler handler
if  page ispagestateless
handler   new bookmarkablelistenerinterfacerequesthandler provider  listener  id
else
handler   new listenerinterfacerequesthandler provider  listener  id
return getrequestcycle   urlfor handler
/**
* returns a url that references the given request target.
*
* @see requestcycle#urlfor(irequesthandler)
*
* @param requesthandler
*            the request target to reference
*
* @return a url that references the given request target
*/
public final charsequence urlfor final irequesthandler requesthandler
return getrequestcycle   urlfor requesthandler
/**
* gets a url for the listener interface (e.g. ilinklistener).
*
* @see requestcycle#urlfor(irequesthandler)
*
* @param listener
*            the listener interface that the url should call
* @return the url
*/
public final charsequence urlfor final requestlistenerinterface listener
page page   getpage
pageandcomponentprovider provider   new pageandcomponentprovider page  this
irequesthandler handler
if  page ispagestateless
handler   new bookmarkablelistenerinterfacerequesthandler provider  listener
else
handler   new listenerinterfacerequesthandler provider  listener
return getrequestcycle   urlfor handler
/**
* returns a url that references a shared resource through the provided resource reference.
*
* @see requestcycle#urlfor(irequesthandler)
*
* @param resourcereference
*            the resource reference
* @param parameters
*            parameters or {@code null} if none
* @return the url for the shared resource
*/
public final charsequence urlfor final resourcereference resourcereference
pageparameters parameters
return getrequestcycle   urlfor resourcereference  parameters
/**
* traverses all parent components of the given class in this container, calling the visitor's
* visit method at each one.
*
* @param <r>
* @param c
*            class
* @param visitor
*            the visitor to call at each parent of the given type
* @return first non-null value returned by visitor callback
*/
public final <r> r visitparents final class<?> c  final ivisitor<component  r> visitor
// start here
component current   getparent
visit<r> visit   new visit<r>
// walk up containment hierarchy
while  current    null
// is current an instance of this class?
if  c isinstance current
visitor component current  visit
if  visit isstopped
return visit getresult
// check parent
current   current getparent
return null
/**
* registers a warning feedback message for this component.
*
* @param message
*            the feedback message
*/
public final void warn final serializable message
getsession   getfeedbackmessages   warn this  message
getsession   dirty
/**
* {@link behavior#beforerender(component)} notify all behaviors that are assigned to this
* component that the component is about to be rendered.
*/
private void notifybehaviorscomponentbeforerender
for  behavior behavior   getbehaviors
if  isbehavioraccepted behavior
behavior beforerender this
/**
* {@link behavior#afterrender(component)} notify all behaviors that are assigned to this
* component that the component has rendered.
*/
private void notifybehaviorscomponentrendered
// notify the behaviors that component has been rendered
for  behavior behavior   getbehaviors
if  isbehavioraccepted behavior
behavior afterrender this
/**
* todo wicket-ng rename to something more useful - like componentchanged(), this method used to
* be called with a change object
*
* adds state change to page.
*/
protected final void addstatechange
checkhierarchychange this
final page page   findpage
if  page    null
page componentstatechanging this
/**
* checks whether the given type has the expected name.
*
* @param tag
*            the tag to check
* @param name
*            the expected tag name
* @throws markupexception
*             thrown if the tag is not of the right name
*/
protected final void checkcomponenttag final componenttag tag  final string name
if   tag getname   equalsignorecase name
string msg   string format
getid    getpath    name
tag touserdebugstring
findmarkupstream   throwmarkupexception msg
/**
* checks that a given tag has a required attribute value.
*
* @param tag
*            the tag
* @param key
*            the attribute key
* @param value
*            the required value for the attribute key
* @throws markupexception
*             thrown if the tag does not have the required attribute value
*/
protected final void checkcomponenttagattribute final componenttag tag  final string key
final string value
if  key    null
final string tagattributevalue   tag getattributes   getstring key
if  tagattributevalue    null     value equalsignorecase tagattributevalue
string msg   string format
getid    getpath    key
value  tagattributevalue
findmarkupstream   throwmarkupexception msg
/**
* checks whether the hierarchy may be changed at all, and throws an exception if this is not
* the case.
*
* @param component
*            the component which is about to be added or removed
*/
protected void checkhierarchychange final component component
// throw exception if modification is attempted during rendering
if   component isauto      getflag flag_rendering
throw new wicketruntimeexception
/**
* detaches the model for this component if it is detachable.
*/
protected void detachmodel
imodel<?> model   getmodelimpl
if  model    null
model detach
// also detach the wrapped model of a component assigned wrap (not
// inherited)
if  model instanceof iwrapmodel     getflag flag_inheritable_model
iwrapmodel<?> model  getwrappedmodel   detach
/**
* prefixes an exception message with useful information about this. component.
*
* @param message
*            the message
* @return the modified message
*/
protected final string exceptionmessage final string message
return message       tostring
/**
* finds the markup stream for this component.
*
* @return the markup stream for this component. since a component cannot have a markup stream,
*         we ask this component's parent to search for it.
* @todo can be removed in 1.5
*/
protected final markupstream findmarkupstream
return new markupstream getmarkup
/**
* if this component is a page, returns self. otherwise, searches for the nearest page parent in
* the component hierarchy. if no page parent can be found, null is returned.
*
* @return the page or null if none can be found
*/
protected final page findpage
// search for page
return  page  this instanceof page ? this   findparent page class
/**
* gets the subset of the currently coupled {@link behavior}s that are of the provided type as a
* unmodifiable list. returns an empty list rather than null if there are no behaviors coupled
* to this component.
*
* @param type
*            the type or null for all
* @return the subset of the currently coupled behaviors that are of the provided type as a
*         unmodifiable list or null
* @param <m>
*            a class derived from ibehavior
*/
public <m extends behavior> list<m> getbehaviors class<m> type
return new behaviors this  getbehaviors type
/**
* this method is not part of the wicket public api. do not use it!
*
* @param flag
*            the flag to test
* @return true if the flag is set
*/
protected final boolean getflag final int flag
return  flags   flag     0
/**
* this method is not part of the wicket public api. do not use it!
*
* @param flag
*            the flag to test
* @return true if the flag is set
*/
protected final boolean getrequestflag final short flag
return  requestflags   flag     0
/**
* finds the innermost imodel object for an imodel that might contain nested imodel(s).
*
* @param model
*            the model
* @return the innermost (most nested) model
*/
protected final imodel<?> getinnermostmodel final imodel<?> model
imodel<?> nested   model
while  nested    null    nested instanceof iwrapmodel
final imodel<?> next     iwrapmodel<?> nested  getwrappedmodel
if  nested    next
throw new wicketruntimeexception     nested
nested   next
return nested
/**
* gets the component's current model comparator. implementations can be used for testing the
* current value of the components model data with the new value that is given.
*
* @return the value defaultmodelcomparator
*/
public imodelcomparator getmodelcomparator
return defaultmodelcomparator
/**
* returns whether the component can be stateless. also the component behaviors must be
* stateless, otherwise the component will be treat as stateful. in order for page to be
* stateless (and not to be stored in session), all components (and component behaviors) must be
* stateless.
*
* @return whether the component can be stateless
*/
protected boolean getstatelesshint
return true
/**
* called when a null model is about to be retrieved in order to allow a subclass to provide an
* initial model. this gives formcomponent, for example, an opportunity to instantiate a model
* on the fly using the containing form's model.
*
* @return the model
*/
protected imodel<?> initmodel
imodel<?> foundmodel   null
// search parents for compoundpropertymodel
for  component current   getparent    current    null  current   current getparent
// get model
// don't call the getmodel() that could initialize many inbetween
// completely useless models.
// imodel model = current.getmodel();
imodel<?> model   current getmodelimpl
if  model instanceof iwrapmodel      model instanceof icomponentinheritedmodel
model     iwrapmodel<?> model  getwrappedmodel
if  model instanceof icomponentinheritedmodel
// return the shared inherited
foundmodel     icomponentinheritedmodel<?> model  wraponinheritance this
setflag flag_inheritable_model  true
break
// no model for this component!
return foundmodel
/**
* this method is not part of the wicket public api. do not call or override.
*
* <p>
* called anytime a model is changed via setmodel or setmodelobject.
* </p>
*/
protected void internalonmodelchanged
/**
* components are allowed to reject behavior modifiers.
*
* @param behavior
* @return false, if the component should not apply this behavior
*/
protected boolean isbehavioraccepted final behavior behavior
// ignore attributemodifiers when flag_ignore_attribute_modifier is set
if   behavior instanceof attributemodifier
getflag flag_ignore_attribute_modifier     false
return false
return behavior isenabled this
/**
* if true, all attribute modifiers will be ignored
*
* @return true, if attribute modifiers are to be ignored
*/
protected final boolean isignoreattributemodifier
return getflag flag_ignore_attribute_modifier
/**
* @return component's markup stream
*/
protected markupstream locatemarkupstream
return new markupstream getmarkup
/**
* called just after a component is rendered.
*/
protected void onafterrender
setflag flag_after_rendering  false
/**
* called just before a component is rendered.
* <p>
* <strong>note</strong>: if you override this, you *must* call super.onbeforerender() within
* your implementation.
*
* because this method is responsible for cascading {@link #onbeforerender()} call to its
* children it is strongly recommended that super call is made at the end of the override.
* </p>
*/
protected void onbeforerender
setflag flag_prepared_for_render  true
onbeforerenderchildren
setrequestflag rflag_before_render_super_call_verified  true
/**
* processes the component tag.
*
* overrides of this method most likely should call the super implementation.
*
* @param tag
*            tag to modify
*/
protected void oncomponenttag final componenttag tag
// we can't try to get the id from markup. this could be different than
// id returned from getmarkupid() prior first rendering the component
// (due to transparent resolvers and borders which break the 1:1
// component <-> markup relation)
if  getflag flag_output_markup_id
tag putinternal markup_id_attr_name  getmarkupid
if  getapplication   getdebugsettings   isoutputcomponentpath
string path   getpagerelativepath
path   path replace
path   path replace
tag put    path
// the markup sourcing strategy may also want to work on the tag
getmarkupsourcingstrategy   oncomponenttag this  tag
/**
* processes the body.
*
* @param markupstream
*            the markup stream
* @param opentag
*            the open tag for the body
*/
public void oncomponenttagbody final markupstream markupstream  final componenttag opentag
/**
* called to allow a component to detach resources after use.
*
* overrides of this method must call the super implementation, the most logical place to do
* this is the last line of the override method.
*/
protected void ondetach
setflag flag_detaching  false
/**
* called to notify the component it is being removed from the component hierarchy
*
* overrides of this method must call the super implementation, the most logical place to do
* this is the last line of the override method.
*
*
*/
protected void onremove
setflag flag_removing_from_hierarchy  false
/**
* called anytime a model is changed after the change has occurred
*/
protected void onmodelchanged
/**
* called anytime a model is changed, but before the change actually occurs
*/
protected void onmodelchanging
/**
* implementation that renders this component.
*/
protected abstract void onrender
/**
* writes a simple tag out to the response stream. any components that might be referenced by
* the tag are ignored. also undertakes any tag attribute modifications if they have been added
* to the component.
*
* @param tag
*            the tag to write
*/
protected final void rendercomponenttag componenttag tag
if  needtorendertag tag
// apply behavior modifiers
list<? extends behavior> behaviors   getbehaviors
if   behaviors    null      behaviors isempty       tag isclose
isignoreattributemodifier      false
tag   tag mutable
for  behavior behavior   behaviors
// components may reject some behavior components
if  isbehavioraccepted behavior
behavior oncomponenttag this  tag
// apply behaviors that are attached to the component tag.
if  tag hasbehaviors
iterator<? extends behavior> tagbehaviors   tag getbehaviors
while  tagbehaviors hasnext
final behavior behavior   tagbehaviors next
if  behavior isenabled this
behavior oncomponenttag this  tag
behavior detach this
if   tag instanceof wickettag      tag isclose
getflag flag_ignore_attribute_modifier
if  getflag flag_output_markup_id
log warn string format
getmarkupid
getid    tag getname
if  getflag flag_placeholder
log warn string format
getid    tag getname
// write the tag
tag writeoutput getresponse     needtorendertag null
getmarkup   getmarkupresourcestream   getwicketnamespace
/**
* replaces the body with the given one.
*
* @param markupstream
*            the markup stream to replace the tag body in
* @param tag
*            the tag
* @param body
*            the new markup
*/
protected final void replacecomponenttagbody final markupstream markupstream
final componenttag tag  final charsequence body
// the tag might have been changed from open-close to open. hence
// we'll need what was in the markup itself
componenttag markupopentag   null
// if tag has a body
if  tag isopen
// get what tag was in the markup; not what the user it might
// have changed it to.
markupopentag   markupstream getprevioustag
// if it was an open tag in the markup as well, than ...
if  markupopentag isopen
// skip any raw markup in the body
markupstream skiprawmarkup
if  body    null
// write the new body
getresponse   write body
// if we had an open tag (and not an openclose tag) and we found a
// close tag, we're good
if  tag isopen
// if it was an open tag in the markup, than there must be
// a close tag as well.
if   markupopentag    null     markupopentag isopen       markupstream atclosetag
// there must be a component in this discarded body
markupstream throwmarkupexception     markupopentag
markupstream get
/**
* @param auto
*            true to put component into auto-add mode
*/
protected final void setauto final boolean auto
setflag flag_auto  auto
/**
* this method is not part of the wicket public api. do not use it!
*
* @param flag
*            the flag to set
* @param set
*            true to turn the flag on, false to turn it off
*/
protected final void setflag final int flag  final boolean set
if  set
flags    flag
else
flags    ~flag
/**
* this method is not part of the wicket public api. do not use it!
*
* @param flag
*            the flag to set
* @param set
*            true to turn the flag on, false to turn it off
*/
protected final void setrequestflag final short flag  final boolean set
if  set
requestflags    flag
else
requestflags    ~flag
/**
* if true, all attribute modifiers will be ignored
*
* @param ignore
*            if true, all attribute modifiers will be ignored
* @return this
*/
protected final component setignoreattributemodifier final boolean ignore
setflag flag_ignore_attribute_modifier  ignore
return this
/**
* @param <v>
*            the model type
* @param model
*            the model to wrap if need be
* @return the wrapped model
*/
protected final <v> imodel<v> wrap final imodel<v> model
if  model instanceof icomponentassignedmodel
return   icomponentassignedmodel<v> model  wraponassignment this
return model
/**
* detaches any child components
*/
void detachchildren
/**
* signals this components removal from hierarchy to all its children.
*/
void removechildren
/**
* gets the component at the given path.
*
* @param path
*            path to component
* @return the component at the path
*/
public component get final string path
// path to this component is an empty path
if  path length      0
return this
throw new illegalargumentexception
exceptionmessage
path
/**
* checks whether or not this component has a markup id value generated, whether it is automatic
* or user defined
*
* @return true if this component has a markup id value generated
*/
final boolean hasmarkupidmetadata
return getmarkupid      null
/**
* @param setrenderingflag
*            rendering flag
*/
void internalmarkrendering boolean setrenderingflag
if  setrenderingflag
setflag flag_prepared_for_render  false
setflag flag_rendering  true
else
setflag flag_rendering  false
/**
* @return true if this component or any of its parents is in auto-add mode
*/
public final boolean isauto
// search up hierarchy for flag_auto
for  component current   this  current    null  current   current getparent
if  current getflag flag_auto
return true
return false
/**
*
* @return <code>true</code> if component has been prepared for render
*/
boolean ispreparedforrender
return getflag flag_prepared_for_render
/**
*
*/
protected void onafterrenderchildren
/**
* this method is here for {@link markupcontainer}. it is broken out of
* {@link #onbeforerender()} so we can guarantee that it executes as the last in
* onbeforerender() chain no matter where user places the <code>super.onbeforerender()</code>
* call.
*/
void onbeforerenderchildren
/**
* renders the close tag at the current position in the markup stream.
*
* @param markupstream
*            the markup stream
* @param opentag
*            the tag to render
* @param renderbodyonly
*            if true, the tag will not be written to the output
*/
final void renderclosingcomponenttag final markupstream markupstream
final componenttag opentag  final boolean renderbodyonly
// tag should be open tag and not openclose tag
if  opentag isopen
// if we found a close tag and it closes the open tag, we're good
if  markupstream atclosetag      markupstream gettag   closes opentag
// render the close tag
if   renderbodyonly    false     needtorendertag opentag
getresponse   write opentag syntheticclosetagstring
else if  opentag requiresclosetag
// missing close tag. some tags, e.g. <p> are handled like <p/> by most browsers and
// thus will not throw an exception.
markupstream throwmarkupexception     opentag
/**
* this method is not part of the wicket public api. do not use it!
*
* sets the id of this component.
*
* @param id
*            the non-null id of this component
*/
final void setid final string id
if    this instanceof page
if  strings isempty id
throw new wicketruntimeexception
if   id    null      id indexof        1    id indexof        1
throw new wicketruntimeexception
this id   id
/**
* this is a wicket internal api. do not use it.
*
* sets the parent of a component. typically what you really want is parent.add(child).
* <p/>
* note that calling setparent() and not parent.add() will connect the child to the parent, but
* the parent will not know the child. this might not be a problem in some cases, but e.g.
* child.ondetach() will not be invoked (since the parent doesn't know it is his child).
*
* @param parent
*            the parent container
*/
public final void setparent final markupcontainer parent
if  this parent    null    log isdebugenabled
log debug     this parent       parent
this parent   parent
/**
* sets the render allowed flag.
*
* @param renderallowed
*/
final void setrenderallowed boolean renderallowed
setflag flag_is_render_allowed  renderallowed
/**
* sets the render allowed flag.
*
* visit all this page's children (overridden in markupcontainer) to check rendering
* authorization, as appropriate. we set any result; positive or negative as a temporary boolean
* in the components, and when a authorization exception is thrown it will block the rendering
* of this page
*/
void setrenderallowed
setrenderallowed isactionauthorized render
/**
* sets whether or not this component is allowed to be visible. this method is meant to be used
* by components to control visibility of other components. a call to
* {@link #setvisible(boolean)} will not always have a desired effect because that component may
* have {@link #isvisible()} overridden. both {@link #setvisibilityallowed(boolean)} and
* {@link #isvisibilityallowed()} are <code>final</code> so their contract is enforced always.
*
* @param allowed
* @return <code>this</code> for chaining
*/
public final component setvisibilityallowed boolean allowed
setflag flag_visibility_allowed  allowed
return this
/**
* gets whether or not visibility is allowed on this component. see
* {@link #setvisibilityallowed(boolean)} for details.
*
* @return true if this component is allowed to be visible, false otherwise.
*/
public final boolean isvisibilityallowed
return getflag flag_visibility_allowed
/**
* determines whether or not a component should be visible, taking into account all the factors:
* {@link #isvisible()}, {@link #isvisibilityallowed()}, {@link #isrenderallowed()}
*
* @return <code>true</code> if the component should be visible, <code>false</code> otherwise
*/
public final boolean determinevisibility
return isvisible      isrenderallowed      isvisibilityallowed
/**
* calculates enabled state of the component taking its hierarchy into account. a component is
* enabled iff it is itself enabled ({@link #isenabled()} and {@link #isenableallowed()} both
* return <code>true</code>), and all of its parents are enabled.
*
* @return <code>true</code> if this component is enabled</code>
*/
public final boolean isenabledinhierarchy
if  getrequestflag rflag_enabled_in_hierarchy_set
return getrequestflag rflag_enabled_in_hierarchy_value
final boolean state
component parent   getparent
if  parent    null     parent isenabledinhierarchy
state   false
else
state   isenabled      isenableallowed
setrequestflag rflag_enabled_in_hierarchy_set  true
setrequestflag rflag_enabled_in_hierarchy_value  state
return state
/**
* todo wicket-ng javadoc
*
* @deprecated use {@link #cancalllistenerinterface(method)} instead
*/
@deprecated
public final boolean cancalllistenerinterface
return true
/**
* checks whether or not a listener method can be invoked on this component. usually components deny these invocations if they are either invisible or disabled in hierarchy. components can examine which listener interface is being invoked by examining the declaring class of the passed in {@literal method} parameter.
* <p>
* warning: be careful when overriding this method because it may open security holes - such as allowing a user to click on a link that should be disabled.
* </p>
* <p>
* example usecase for overriding: suppose you are building an component that displays images. the component generates a callback to itself using {@link irequestlistener} interface and uses this callback to stream image data. if such a component is placed inside a disable webmarkupcontainer we still want to allow the invocation of the request listener callback method so that image data can be streamed. such a component would override this method and return {@literal true} if the listener method belongs to {@link irequestlistener}.
* </p>
* @param method listener method about to be invoked on this component
*
* @return {@literal true} iff the listener method can be invoked on this component
*/
public boolean cancalllistenerinterface method method
return isenabledinhierarchy      isvisibleinhierarchy
/**
* caution: this method is not meant to be overridden like it was in wicket 1.4 when
* implementing {@link iheadercontributor}. overload
* {@link component#renderhead(org.apache.wicket.markup.html.iheaderresponse)} instead to
* contribute to the response header.
*
* @param component
* @param response
*/
public final void renderhead component component  iheaderresponse response
if  component    this
throw new illegalstateexception
renderhead response
/**
* render to the web response whatever the component wants to contribute to the head section.
*
* @param response
*            response object
*/
public void renderhead iheaderresponse response
// noop
/** {@inheritdoc} */
public void onevent ievent<?> event
/** {@inheritdoc} */
public final <t> void send ieventsink sink  broadcast type  t payload
new componenteventsender this  getapplication   getframeworksettings    send sink  type
payload
/**
* removes behavior from component
*
* @param behaviors
*            behaviors to remove
*
* @return this (to allow method call chaining)
*/
public component remove final behavior    behaviors
behaviors helper   new behaviors this
for  behavior behavior   behaviors
helper remove behavior
return this
/** {@inheritdoc} */
public final behavior getbehaviorbyid int id
return new behaviors this  getbehaviorbyid id
/** {@inheritdoc} */
public final int getbehaviorid behavior behavior
return new behaviors this  getbehaviorid behavior
/**
* adds a behavior modifier to the component.
*
* <p>
* note: this method is override to enable users to do things like discussed in <a
* href="http://www.nabble.com/why-add%28ibehavior%29-is-final--tf2598263.html#a7248198">this
* thread</a>.
* </p>
*
* @param behaviors
*            the behavior modifier(s) to be added
* @return this (to allow method call chaining)
*/
public component add final behavior    behaviors
new behaviors this  add behaviors
return this
/**
* gets the currently coupled {@link behavior}s as a unmodifiable list. returns an empty list
* rather than null if there are no behaviors coupled to this component.
*
* @return the currently coupled behaviors as a unmodifiable list
*/
public final list<? extends behavior> getbehaviors
return getbehaviors behavior class