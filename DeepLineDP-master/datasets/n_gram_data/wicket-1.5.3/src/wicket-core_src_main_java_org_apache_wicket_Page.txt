/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket
import java util arraylist
import java util hashset
import java util iterator
import java util list
import java util set
import org apache wicket authorization iauthorizationstrategy
import org apache wicket authorization unauthorizedactionexception
import org apache wicket authorization strategies page simplepageauthorizationstrategy
import org apache wicket markup markupexception
import org apache wicket markup markupstream
import org apache wicket markup markuptype
import org apache wicket markup resolver icomponentresolver
import org apache wicket model imodel
import org apache wicket page ipagemanager
import org apache wicket pagestore ipagestore
import org apache wicket request component irequestablepage
import org apache wicket request cycle requestcycle
import org apache wicket request mapper parameter pageparameters
import org apache wicket session isessionstore
import org apache wicket settings idebugsettings
import org apache wicket settings irequestcyclesettings renderstrategy
import org apache wicket util lang classes
import org apache wicket util lang generics
import org apache wicket util lang wicketobjects
import org apache wicket util string stringvalue
import org apache wicket util visit ivisit
import org apache wicket util visit ivisitor
import org slf4j logger
import org slf4j loggerfactory
/**
* abstract base class for pages. as a markupcontainer subclass, a page can contain a component
* hierarchy and markup in some markup language such as html. users of the framework should not
* attempt to subclass page directly. instead they should subclass a subclass of page that is
* appropriate to the markup type they are using, such as webpage (for html markup).
* <ul>
* <li><b>construction </b>- when a page is constructed, it is automatically added to the current
* pagemap in the session. when a page is added to the session's pagemap, the pagemap assigns the
* page an id. a pagemap is roughly equivalent to a browser window and encapsulates a set of pages
* accessible through that window. when a popup window is created, a new pagemap is created for the
* popup.
*
* <li><b>identity </b>- the session that a page is contained in can be retrieved by calling
* page.getsession(). page identifiers start at 0 for each pagemap in the session and increment as
* new pages are added to the map. the pagemap-(and session)-unique identifier assigned to a given
* page can be retrieved by calling getid(). so, the first page added to a new user session will
* always be named "0".
*
* <li><b>lifecycle </b>- subclasses of page which are interested in lifecycle events can override
* onbeginrequest, onendrequest() and onmodelchanged(). the onbeginrequest() method is inherited
* from component. a call to onbeginrequest() is made for every component on a page before page
* rendering begins. at the end of a request (when rendering has completed) to a page, the
* onendrequest() method is called for every component on the page.
*
* <li><b>nested component hierarchy </b>- the page class is a subclass of markupcontainer. all
* markupcontainers can have "associated markup", which resides alongside the java code by default.
* all markupcontainers are also component containers. through nesting, of containers, a page can
* contain any arbitrary tree of components. for more details on markupcontainers, see
* {@link org.apache.wicket.markupcontainer}.
*
* <li><b>bookmarkable pages </b>- pages can be constructed with any constructor when they are being
* used in a wicket session, but if you wish to link to a page using a url that is "bookmarkable"
* (which implies that the url will not have any session information encoded in it, and that you can
* call this page directly without having a session first directly from your browser), you need to
* implement your page with a no-arg constructor or with a constructor that accepts a pageparameters
* argument (which wraps any query string parameters for a request). in case the page has both
* constructors, the constructor with pageparameters will be used.
*
* <li><b>models </b>- pages, like other components, can have models (see {@link imodel}). a page
* can be assigned a model by passing one to the page's constructor, by overriding initmodel() or
* with an explicit invocation of setmodel(). if the model is a
* {@link org.apache.wicket.model.compoundpropertymodel}, components on the page can use the page's
* model implicitly via container inheritance. if a component is not assigned a model, the
* initmodel() override in component will cause that component to use the nearest compoundmodel in
* the parent chain, in this case, the page's model. for basic compoundmodels, the name of the
* component determines which property of the implicit page model the component is bound to. if more
* control is desired over the binding of components to the page model (for example, if you want to
* specify some property expression other than the component's name for retrieving the model
* object), boundcompoundpropertymodel can be used.
*
* <li><b>back button </b>- pages can support the back button by enabling versioning with a call to
* setversioned(boolean). if a page is versioned and changes occur to it which need to be tracked, a
* version manager will be installed using the {@link isessionstore}'s factory method
* newversionmanager().
*
* <li><b>security </b>- see {@link iauthorizationstrategy}, {@link simplepageauthorizationstrategy}
*
* @see org.apache.wicket.markup.html.webpage
* @see org.apache.wicket.markupcontainer
* @see org.apache.wicket.model.compoundpropertymodel
* @see org.apache.wicket.component
*
* @author jonathan locke
* @author chris turner
* @author eelco hillenius
* @author johan compagner
*
*/
public abstract class page extends markupcontainer implements iredirectlistener  irequestablepage
/** true if the page hierarchy has been modified in the current request. */
private static final int flag_is_dirty   flag_reserved3
/** set to prevent marking page as dirty under certain circumstances. */
private static final int flag_prevent_dirty   flag_reserved4
/** true if the page should try to be stateless */
private static final int flag_stateless_hint   flag_reserved5
/** todo wicket-ng javadoc */
private static final int flag_was_created_bookmarkable   flag_reserved8
/** log. */
private static final logger log   loggerfactory getlogger page class
private static final long serialversionuid   1l
/** used to create page-unique numbers */
private int autoindex
/** numeric version of this page's id */
private int numericid
/** set of components that rendered if component use checking is enabled */
private transient set<component> renderedcomponents
/**
* boolean if the page is stateless, so it doesn't have to be in the page map, will be set in
* urlfor
*/
private transient boolean stateless   null
/** page parameters used to construct this page */
private final pageparameters pageparameters
/**
* the purpose of render count is to detect stale listener interface links. for example: there
* is a page a rendered in tab 1. then page a is opened also in tab 2. during render page state
* changes (i.e. some repeater gets rebuilt). this makes all links on tab 1 stale - because they
* no longer match the actual page state. this is done by incrementing render count. when link
* is clicked wicket checks if it's render count matches the render count value of page
*/
private int rendercount   0
/**
* constructor.
*/
protected page
this null  null
/**
* constructor.
*
* @param model
*            see component
* @see component#component(string, imodel)
*/
protected page final imodel<?> model
this null  model
/**
* the {@link pageparameters} parameter will be stored in this page and then those parameters
* will be used to create stateless links to this bookmarkable page.
*
* @param parameters
*            externally passed parameters
* @see pageparameters
*/
protected page final pageparameters parameters
this parameters  null
/**
* construct.
*
* @param parameters
* @param model
*/
private page final pageparameters parameters  imodel<?> model
super null  model
if  parameters    null
pageparameters   new pageparameters
else
pageparameters   parameters
init
/**
* the {@link pageparameters} object that was used to construct this page. this will be used in
* creating stateless/bookmarkable links to this page
*
* @return {@link pageparameters} the construction page parameter
*/
public pageparameters getpageparameters
return pageparameters
/**
* adds a component to the set of rendered components.
*
* @param component
*            the component that was rendered
*/
public final void componentrendered final component component
// inform the page that this component rendered
if  getapplication   getdebugsettings   getcomponentusecheck
if  renderedcomponents    null
renderedcomponents   new hashset<component>
if  renderedcomponents add component     false
throw new markupexception
component
component getclassrelativepath
if  log isdebugenabled
log debug     component
/**
* detaches any attached models referenced by this page.
*/
@override
public void detachmodels
super detachmodels
/**
* @see org.apache.wicket.component#internalprepareforrender(boolean)
*/
@override
public void internalprepareforrender boolean setrenderingflag
if   isinitialized
// initialize the page if not yet initialized
internalinitialize
super internalprepareforrender setrenderingflag
/**
* @see #dirty(boolean)
*/
public final void dirty
dirty false
/** {@inheritdoc} */
public boolean setfreezepageid boolean freeze
boolean frozen   getflag flag_prevent_dirty
setflag flag_prevent_dirty  freeze
return frozen
/**
* mark this page as modified in the session. if versioning is supported then a new version of
* the page will be stored in {@link ipagestore page store}
*
* @param isinitialization
*            a flag whether this is a page instantiation
*/
public void dirty final boolean isinitialization
checkhierarchychange this
if  getflag flag_prevent_dirty
return
final ipagemanager pagemanager   getsession   getpagemanager
if   getflag flag_is_dirty     isversioned      pagemanager supportsversioning
setflag flag_is_dirty  true
setnextavailableid
pagemanager touchpage this
else if  isinitialization
// we need to get pageid for new page instances even when the page doesn't need
// versioning, otherwise pages override each other in the page store and back button
// support is broken
setnextavailableid
/**
* this method is not part of the wicket public api. do not call.
*
* this method is called when a component was rendered standalone. if it is a <code>
* markupcontainer</code> then the rendering for that container is checked.
*
* @param component
*/
public final void endcomponentrender component component
if  component instanceof markupcontainer
checkrendering  markupcontainer component
else
renderedcomponents   null
/**
* this method is not part of the wicket public api. do not call it.
*
* get a page unique number, which will be increased with each call.
*
* @return a page unique number
*/
public final int getautoindex
return autoindex
/**
* @see org.apache.wicket.component#getid()
*/
@override
public final string getid
return integer tostring numericid
/**
*
* @return page class
*/
public final class<? extends page> getpageclass
return getclass
/**
* @return size of this page in bytes
*/
@override
public final long getsizeinbytes
return wicketobjects sizeof this
/**
* returns whether the page should try to be stateless. to be stateless, getstatelesshint() of
* every component on page (and it's behavior) must return true and the page must be
* bookmarkable.
*
* @see org.apache.wicket.component#getstatelesshint()
*/
@override
public final boolean getstatelesshint
return getflag flag_stateless_hint
/**
* @return this page's component hierarchy as a string
*/
public final string hierarchyasstring
final stringbuilder buffer   new stringbuilder
buffer append    append getid
visitchildren new ivisitor<component  void>
public void component final component component  final ivisit<void> visit
int levels   0
for  component current   component  current    null  current   current getparent
levels
buffer append stringvalue repeat levels
append component getpagerelativepath
append
append classes simplename component getclass
return buffer tostring
/**
* bookmarkable page can be instantiated using a bookmarkable url.
*
* @return returns true if the page is bookmarkable.
*/
public boolean isbookmarkable
return getapplication   getpagefactory   isbookmarkable getclass
/**
* override this method and return true if your page is used to display wicket errors. this can
* help the framework prevent infinite failure loops.
*
* @return true if this page is intended to display an error to the end user.
*/
public boolean iserrorpage
return false
/**
* determine the "statelessness" of the page while not changing the cached value.
*
* @return boolean value
*/
private boolean peekpagestateless
boolean old   stateless
boolean res   ispagestateless
stateless   old
return res
/**
* gets whether the page is stateless. components on stateless page must not render any stateful
* urls, and components on stateful page must not render any stateless urls. stateful urls are
* urls, which refer to a certain (current) page instance.
*
* @return whether this page is stateless
*/
public final boolean ispagestateless
if  isbookmarkable      false
stateless   boolean false
if  getstatelesshint
log warn     this
if  getstatelesshint      false
return false
if  stateless    null
if  isstateless      false
stateless   boolean false
if  stateless    null
component statefulcomponent   visitchildren component class
new ivisitor<component  component>
public void component final component component  final ivisit<component> visit
if   component isstateless
visit stop component
stateless   statefulcomponent    null
if  log isdebugenabled       stateless booleanvalue      getstatelesshint
log debug    this
statefulcomponent getpagerelativepath
return stateless
/**
* redirect to this page.
*
* @see org.apache.wicket.iredirectlistener#onredirect()
*/
public final void onredirect
/**
* this method is not part of the wicket public api. do not call.
*
* set the id for this page. this method is called by pagemap when a page is added because the
* id, which is assigned by pagemap, is not known until this time.
*
* @param id
*            the id
*/
public final void setnumericid final int id
numericid   id
/**
* sets whether the page should try to be stateless. to be stateless, getstatelesshint() of
* every component on page (and it's behavior) must return true and the page must be
* bookmarkable.
*
* @param value
*            whether the page should try to be stateless
*/
public final void setstatelesshint boolean value
if  value     isbookmarkable
throw new wicketruntimeexception
this
setflag flag_stateless_hint  value
/**
* this method is not part of the wicket public api. do not call.
*
* this method is called when a component will be rendered standalone.
*
* @param component
*
*/
public final void startcomponentrender component component
renderedcomponents   null
/**
* get the string representation of this container.
*
* @return string representation of this container
*/
@override
public string tostring
return     getclass   getname         getid
getrendercount
/**
* throw an exception if not all components rendered.
*
* @param renderedcontainer
*            the page itself if it was a full page render or the container that was rendered
*            standalone
*/
private void checkrendering final markupcontainer renderedcontainer
// if the application wants component uses checked and
// the response is not a redirect
final idebugsettings debugsettings   getapplication   getdebugsettings
if  debugsettings getcomponentusecheck
final list<component> unrenderedcomponents   new arraylist<component>
final stringbuilder buffer   new stringbuilder
renderedcontainer visitchildren new ivisitor<component  void>
public void component final component component  final ivisit<void> visit
// if component never rendered
if  renderedcomponents    null     renderedcomponents contains component
// if not an auto component ...
if   component isauto      component isvisibleinhierarchy
// increase number of unrendered components
unrenderedcomponents add component
// add to explanatory string to buffer
buffer append integer tostring unrenderedcomponents size
append
append component
append
string metadata   component getmetadata component constructed_at_key
if  metadata    null
buffer append metadata
metadata   component getmetadata component added_at_key
if  metadata    null
buffer append metadata
else
// if the component is not visible in hierarchy we
// should not visit its children since they are also
// not visible
visit dontgodeeper
// throw exception if any errors were found
if  unrenderedcomponents size   > 0
renderedcomponents   null
list<component> transparentcontainerchildren   generics newarraylist
iterator<component> iterator   unrenderedcomponents iterator
outerwhile   while  iterator hasnext
component component   iterator next
// if any of the transparentcontainerchildren is a parent to component, then
// ignore it.
for  component transparentcontainerchild   transparentcontainerchildren
markupcontainer parent   component getparent
while  parent    null
if  parent    transparentcontainerchild
iterator remove
continue outerwhile
parent   parent getparent
if  hasinvisibletransparentchild component getparent    component
// if we found a transparent container that isn't visible then ignore this
// component and only do a debug statement here.
if  log isdebugenabled
log debug
component
transparentcontainerchildren add component
iterator remove
continue outerwhile
// if still > 0
if  unrenderedcomponents size   > 0
// throw exception
throw new wicketruntimeexception
buffer tostring
// get rid of set
renderedcomponents   null
private boolean hasinvisibletransparentchild final markupcontainer root  final component self
for  component sibling   root
if   sibling    self      sibling instanceof icomponentresolver
sibling instanceof markupcontainer
if   sibling isvisible
return true
else
boolean rtn   hasinvisibletransparentchild  markupcontainer sibling  self
if  rtn    true
return true
return false
/**
* initializes page by adding it to the session and initializing it.
*/
private void init
if  isbookmarkable
setstatelesshint true
// set versioning of page based on default
setversioned getapplication   getpagesettings   getversionpagesbydefault
// all pages are born dirty so they get clustered right away
dirty true
// this is a bit of a dirty hack, but calling dirty(true) results in isstateless called
// which is bound to set the stateless cache to true as there are no components yet
stateless   null
/**
*
*/
private void setnextavailableid
setnumericid getsession   nextpageid
/**
* this method will be called for all components that are changed on the page so also auto
* components or components that are not versioned.
*
* if the parent is given that it was a remove or add from that parent of the given component.
* else it was just a internal property change of that component.
*
* @param component
* @param parent
*/
protected void componentchanged component component  markupcontainer parent
if   component isauto
dirty
/**
* this method is not part of the wicket public api. do not call or override.
*
* @see org.apache.wicket.component#internalonmodelchanged()
*/
@override
protected final void internalonmodelchanged
visitchildren new ivisitor<component  void>
public void component final component component  final ivisit<void> visit
// if form component is using form model
if  component sameinnermostmodel page this
component modelchanged
/**
*
* @see org.apache.wicket.component#onbeforerender()
*/
@override
protected void onbeforerender
// first try to check if the page can be rendered:
if   isactionauthorized render
if  log isdebugenabled
log debug     this
throw new unauthorizedactionexception this  component render
// make sure it is really empty
renderedcomponents   null
// if the page is stateless, reset the flag so that it is tested again
if  boolean true equals stateless
stateless   null
super onbeforerender
// if any of the components on page is not stateless, we need to bind the session
// before we start rendering components, as then jsessionid won't be appended
// for links rendered before first stateful component
if  getsession   istemporary       peekpagestateless
getsession   bind
/**
* @see org.apache.wicket.component#onafterrender()
*/
@override
protected void onafterrender
super onafterrender
// check rendering if it happened fully
checkrendering this
// clean up debug meta data if component check is on
if  getapplication   getdebugsettings   getcomponentusecheck
visitchildren new ivisitor<component  void>
public void component final component component  final ivisit<void> visit
component setmetadata component constructed_at_key  null
component setmetadata component added_at_key  null
if   ispagestateless
// trigger creation of the actual session in case it was deferred
getsession   getsessionstore   getsessionid requestcycle get   getrequest    true
// add/touch the response page in the session.
getsession   getpagemanager   touchpage this
if  getapplication   getdebugsettings   isoutputmarkupcontainerclassname
class<?> klass   getclass
while  klass isanonymousclass
klass   klass getsuperclass
getresponse   write
getresponse   write klass getname
getresponse   write
/**
* @see org.apache.wicket.component#ondetach()
*/
@override
protected void ondetach
if  log isdebugenabled
log debug     this       getrequest
setflag flag_is_dirty  false
super ondetach
/**
* @see org.apache.wicket.markupcontainer#onrender()
*/
@override
protected void onrender
// loop through the markup in this container
markupstream markupstream   new markupstream getmarkup
renderall markupstream  null
/**
* a component was added.
*
* @param component
*            the component that was added
*/
final void componentadded final component component
if   component isauto
dirty
/**
* a component's model changed.
*
* @param component
*            the component whose model is about to change
*/
final void componentmodelchanging final component component
dirty
/**
* a component was removed.
*
* @param component
*            the component that was removed
*/
final void componentremoved final component component
if   component isauto
dirty
/**
*
* @param component
*/
final void componentstatechanging final component component
if   component isauto
dirty
/**
* set page stateless
*
* @param stateless
*/
void setpagestateless boolean stateless
this stateless   stateless
/**
* @see org.apache.wicket.markupcontainer#getmarkuptype()
*/
@override
public markuptype getmarkuptype
throw new unsupportedoperationexception
/**
* gets page instance's unique identifier
*
* @return instance unique identifier
*/
public pagereference getpagereference
setstatelesshint false
return new pagereference numericid
/**
* @see org.apache.wicket.page.imanageablepage#getpageid()
*/
public int getpageid
return numericid
/**
* @see org.apache.wicket.request.component.irequestablepage#getrendercount()
*/
public int getrendercount
return rendercount
/**
* todo wicket-ng javadoc
*
* @param wascreatedbookmarkable
*/
public final void setwascreatedbookmarkable boolean wascreatedbookmarkable
setflag flag_was_created_bookmarkable  wascreatedbookmarkable
/** todo wicket-ng javadoc */
public final boolean wascreatedbookmarkable
return getflag flag_was_created_bookmarkable
/**
* @see org.apache.wicket.request.component.irequestablepage#renderpage()
*/
public void renderpage
if  getapplication   getrequestcyclesettings   getrenderstrategy      renderstrategy redirect_to_buffer
// don't increment page id for redirect to render and one pass render during rendering
setfreezepageid true
try
rendercount
render
finally
setfreezepageid false
/**
* this method is not part of the wicket public api. do not call.
*
* @param component
* @return if this component was render in this page
*/
public final boolean wasrendered component component
return renderedcomponents    null    renderedcomponents contains component