/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket validation validator
import java util arrays
import java util hashset
import java util set
import java util regex matcher
import java util regex pattern
import org apache wicket validation ivalidatable
/**
* validator for checking urls. the default schemes allowed are <code>http://</code>,
* <code>https://</code>, and <code>ftp://</code>.
* <p>
* the behavior of validation is modified by passing in one of these options:
* <p>
* <ul>
* <li><code>allow_2_slashes - [false]</code>: allows double '/' characters in the path component.</li>
* <li><code>no_fragment- [false]</code>: by default fragments are allowed. if this option is
* included then fragments are flagged as illegal.</li>
* <li><code>allow_all_schemes - [false]</code>: by default only http, https, and ftp are considered
* valid schemes. enabling this option will let any scheme pass validation.</li>
* </ul>
* <p>
* this was originally based <code>org.apache.commons.validator.urlvalidator</code>, but the
* dependency on jakarta-oro was removed and it now uses java.util.regexp instead. usage example:
* <p>
*
* <pre>
* &lt;code&gt;
* component.add(new urlvalidator({&quot;http&quot;, &quot;https&quot;}));
* &lt;/code&gt;
* </pre>
*
* @author vincent demay
* @since 1.2.6
* @see "http://www.ietf.org/rfc/rfc2396.txt"
*/
public class urlvalidator extends abstractvalidator<string>
private static final long serialversionuid   1l
/**
* allows all validly-formatted schemes to pass validation instead of supplying a set of valid
* schemes.
*/
public static final int allow_all_schemes   1 << 0
/**
* allow two slashes in the path component of the <code>url</code>.
*/
public static final int allow_2_slashes   1 << 1
/**
* enabling this option disallows any <code>url</code> fragments.
*/
public static final int no_fragments   1 << 2
private static final string alpha_chars
private static final string alpha_numeric_chars   alpha_chars
private static final string special_chars
private static final string valid_chars       special_chars
private static final string scheme_chars   alpha_chars
// drop numeric, and "+-." for now
private static final string authority_chars   alpha_numeric_chars
private static final string atom   valid_chars
/**
* this expression derived/taken from the bnf for uri (rfc2396).
*/
private static final string url_pattern
/**
* schema / protocol (<code>http:</code>, <code>ftp:</code>, <code>file:</code>, etc).
*/
private static final int parse_url_scheme   2
private static final int parse_url_authority   4     includes hostname   ip and port number
private static final int parse_url_path   5
private static final int parse_url_query   7
private static final int parse_url_fragment   9
/**
* protocol (<code>http:</code>, <code>ftp:</code>, or <code>https:</code>).
*/
private static final string scheme_pattern       scheme_chars
private static final string authority_pattern       authority_chars
private static final int parse_authority_host_ip   3
private static final int parse_authority_port   4
private static final int parse_authority_extra   5     should always be empty
private static final string path_pattern
private static final string query_pattern
private static final string legal_ascii_pattern
private static final string ip_v4_domain_pattern
private static final string domain_pattern       atom       atom
private static final string port_pattern
private static final string atom_pattern       atom
private static final string alpha_pattern       alpha_chars
/**
* holds the set of current validation options.
*/
private long options   0
/**
* the set of schemes that are allowed to be in a url.
*/
private final set<string> allowedschemes   new hashset<string>
/**
* if no schemes are provided, default to this set of protocols.
*/
protected string defaultschemes
/**
* constructs a <code>urlvalidator</code> with default properties.
*/
public urlvalidator
this null
/**
* constructs a <code>urlvalidator</code> with the given <code>string</code> array of scheme
* options. the validation is modified by passing in options in the <code>schemes</code>
* argument.
*
* @param schemes
*            pass in one or more <code>url</code> schemes to consider valid. passing in a
*            <code>null</code> will default to "<code>http,https,ftp</code>" being used. if a
*            non-<code>null</code> scheme is specified, then all valid schemes must be
*            specified. setting the <code>allow_all_schemes</code> option will ignore the
*            contents of <code>schemes</code>.
*/
public urlvalidator string schemes
this schemes  0
/**
* constructs a <code>urlvalidator</code> with the given validation options.
*
* @param options
*            the options should be set using the public constants declared in this class. to
*            set multiple options you simply add them together. for example,
*            <code>allow_2_slashes</code> + <code>no_fragments</code> enables both of those
*            options.
*/
public urlvalidator int options
this null  options
/**
* constructs a <code>urlvalidator</code> with the given scheme and validation options (see
* class description).
*
* @param schemes
*            pass in one or more <code>url</code> schemes to consider valid. passing in a
*            <code>null</code> will default to "<code>http,https,ftp</code>" being used. if a
*            non-<code>null</code> scheme is specified, then all valid schemes must be
*            specified. setting the <code>allow_all_schemes</code> option will ignore the
*            contents of <code>schemes</code>.
* @param options
*            the options should be set using the public constants declared in this class. to
*            set multiple options you simply add them together. for example,
*            <code>allow_2_slashes</code> + <code>no_fragments</code> enables both of those
*            options.
*
*/
public urlvalidator string schemes  int options
this options   options
if  ison allow_all_schemes
return
if  schemes    null
schemes   defaultschemes
allowedschemes addall arrays aslist schemes
/**
* @see abstractvalidator#onvalidate(ivalidatable)
*/
@override
protected void onvalidate ivalidatable<string> validatable
string url   validatable getvalue
if  url    null     isvalid url
error validatable
/**
* checks if a field has a valid <code>url</code>. this method is public because it is directly
* used in tests.
*
* @param value
*            the value validation is being performed on. a <code>null</code> value is
*            considered invalid.
* @return <code>true</code> if the <code>url</code> is valid
*/
public final boolean isvalid string value
if  value    null
return false
matcher matchasciipat   pattern compile legal_ascii_pattern  matcher value
if   matchasciipat matches
return false
// check the whole url address structure
matcher matchurlpat   pattern compile url_pattern  matcher value
if   matchurlpat matches
return false
if   isvalidscheme matchurlpat group parse_url_scheme
return false
if   isvalidauthority matchurlpat group parse_url_authority
return false
if   isvalidpath matchurlpat group parse_url_path
return false
if   isvalidquery matchurlpat group parse_url_query
return false
if   isvalidfragment matchurlpat group parse_url_fragment
return false
return true
/**
* validates a scheme. if schemes[] was initialized to non-<code>null</code>, then only those
* schemes are allowed. note that this is slightly different than for the constructor.
*
* @param scheme
*            the scheme to validate. a <code>null</code> value is considered invalid.
* @return <code>true</code> if the <code>url</code> is valid
*/
protected boolean isvalidscheme string scheme
if  scheme    null
return false
if   pattern compile scheme_pattern  matcher scheme  matches
return false
if  isoff allow_all_schemes
if   allowedschemes contains scheme
return false
return true
/**
* returns <code>true</code> if the authority is properly formatted. an authority is the
* combination of host name and port. a <code>null</code> authority value is considered invalid.
*
* @param authority
*            an authority value to validate
* @return true if authority (host name and port) is valid.
*/
protected boolean isvalidauthority string authority
if  authority    null
return false
matcher authoritymatcher   pattern compile authority_pattern  matcher authority
if   authoritymatcher matches
return false
boolean ipv4address   false
boolean hostname   false
// check if authority is ip address or hostname
string hostip   authoritymatcher group parse_authority_host_ip
matcher matchipv4pat   pattern compile ip_v4_domain_pattern  matcher hostip
ipv4address   matchipv4pat matches
if  ipv4address
// this is an ip address so check components
for  int i   1  i <  4  i
string ipsegment   matchipv4pat group i
if  ipsegment    null    ipsegment length   <  0
return false
try
if  integer parseint ipsegment  > 255
return false
catch  numberformatexception e
return false
else
// domain is hostname name
hostname   pattern compile domain_pattern  matcher hostip  matches
// rightmost hostname will never start with a digit.
if  hostname
// low-tech fix for validator-202
// todo: rewrite to use arraylist and .add semantics: see
// validator-203
char chars   hostip tochararray
int size   1
for  char ch   chars
if  ch
size
string domainsegment   new string
boolean match   true
int segmentcount   0
int segmentlength   0
while  match
matcher atommatcher   pattern compile atom_pattern  matcher hostip
match   atommatcher find
if  match
domainsegment   atommatcher group 1
segmentlength   domainsegment length     1
hostip    segmentlength >  hostip length    ?
hostip substring segmentlength
segmentcount
if  segmentcount > 1
string toplevel   domainsegment
if  toplevel length   < 2    toplevel length   > 4
return false
// first letter of top level must be a alpha
matcher alphamatcher   pattern compile alpha_pattern  matcher
toplevel substring 0  1
if   alphamatcher matches
return false
if   hostname     ipv4address
return false
string port   authoritymatcher group parse_authority_port
if  port    null
matcher portmatcher   pattern compile port_pattern  matcher port
if   portmatcher matches
return false
string extra   authoritymatcher group parse_authority_extra
if   isblankornull extra
return false
return true
/**
* returns <code>true</code> if the path is valid. a <code>null</code> value is considered
* invalid.
*
* @param path
*            a path value to validate.
* @return <code>true</code> if path is valid.
*/
protected boolean isvalidpath string path
if  path    null
return false
matcher pathmatcher   pattern compile path_pattern  matcher path
if   pathmatcher matches
return false
int slash2count   counttoken    path
if  isoff allow_2_slashes      slash2count > 0
return false
int slashcount   counttoken    path
int dot2count   counttoken    path
if  dot2count > 0
if   slashcount   slash2count   1  <  dot2count
return false
return true
/**
* returns <code>true</code> if the query is <code>null</code> or if it's a properly-formatted
* query string.
*
* @param query
*            a query value to validate
* @return <code>true</code> if the query is valid
*/
protected boolean isvalidquery string query
if  query    null
return true
matcher querymatcher   pattern compile query_pattern  matcher query
return querymatcher matches
/**
* returns <code>true</code> if the given fragment is <code>null</code> or fragments are
* allowed.
*
* @param fragment
*            a fragment value to validate
* @return <code>true</code> if the fragment is valid
*/
protected boolean isvalidfragment string fragment
if  fragment    null
return true
return isoff no_fragments
/**
* returns the number of times the token appears in the target.
*
* @param token
*            a token value to be counted
* @param target
*            a target <code>string</code> to count tokens in
* @return the number of tokens
*/
protected int counttoken string token  string target
int tokenindex   0
int count   0
while  tokenindex     1
tokenindex   target indexof token  tokenindex
if  tokenindex >  1
tokenindex
count
return count
/**
* checks if the field isn't <code>null</code> and if length of the field is greater than zero,
* not including whitespace.
*
* @param value
*            the value validation is being performed on
* @return <code>true</code> if blank or <code>null</code>
*/
public static boolean isblankornull string value
return   value    null      value trim   length      0
// flag management
/**
* tests whether the given flag is on. if the flag is not a power of 2 (ie. 3) this tests
* whether the combination of flags is on.
*
* @param flag
*            flag value to check
* @return whether the specified flag value is on
*/
public boolean ison long flag
return  options   flag  > 0
/**
* tests whether the given flag is off. if the flag is not a power of 2 (ie. 3) this tests
* whether the combination of flags is off.
*
* @param flag
*            flag value to check.
* @return whether the specified flag value is off
*/
public boolean isoff long flag
return  options   flag     0