/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel impl
import java util map
import org apache camel asynccallback
import org apache camel asyncprocessor
import org apache camel asyncproducercallback
import org apache camel camelcontext
import org apache camel endpoint
import org apache camel exchange
import org apache camel exchangepattern
import org apache camel failedtocreateproducerexception
import org apache camel processor
import org apache camel producer
import org apache camel producercallback
import org apache camel servicepoolaware
import org apache camel processor unitofworkproducer
import org apache camel spi servicepool
import org apache camel support servicesupport
import org apache camel util asyncprocessorconverterhelper
import org apache camel util camelcontexthelper
import org apache camel util eventhelper
import org apache camel util lrucache
import org apache camel util lrusoftcache
import org apache camel util servicehelper
import org apache camel util stopwatch
import org slf4j logger
import org slf4j loggerfactory
/**
* cache containing created {@link producer}.
*
* @version
*/
public class producercache extends servicesupport
private static final transient logger log   loggerfactory getlogger producercache class
private final camelcontext camelcontext
private final servicepool<endpoint  producer> pool
private final map<string  producer> producers
private final object source
public producercache object source  camelcontext camelcontext
this source  camelcontext  camelcontexthelper getmaximumcachepoolsize camelcontext
public producercache object source  camelcontext camelcontext  int cachesize
this source  camelcontext  camelcontext getproducerservicepool    createlrucache cachesize
public producercache object source  camelcontext camelcontext  servicepool<endpoint  producer> producerservicepool  map<string  producer> cache
this source   source
this camelcontext   camelcontext
this pool   producerservicepool
this producers   cache
/**
* creates the {@link lrucache} to be used.
* <p/>
* this implementation returns a {@link lrusoftcache} instance.
* @param cachesize the cache size
* @return the cache
*/
protected static lrucache<string  producer> createlrucache int cachesize
// we use a soft reference cache to allow the jvm to re-claim memory if it runs low on memory.
return new lrusoftcache<string  producer> cachesize
public camelcontext getcamelcontext
return camelcontext
/**
* gets the source which uses this cache
*
* @return the source
*/
public object getsource
return source
/**
* acquires a pooled producer which you <b>must</b> release back again after usage using the
* {@link #releaseproducer(org.apache.camel.endpoint, org.apache.camel.producer)} method.
*
* @param endpoint the endpoint
* @return the producer
*/
public producer acquireproducer endpoint endpoint
return dogetproducer endpoint  true
/**
* releases an acquired producer back after usage.
*
* @param endpoint the endpoint
* @param producer the producer to release
* @throws exception can be thrown if error stopping producer if that was needed.
*/
public void releaseproducer endpoint endpoint  producer producer  throws exception
if  producer instanceof servicepoolaware
// release back to the pool
pool release endpoint  producer
else if   producer issingleton
// stop non singleton producers as we should not leak resources
producer stop
/**
* starts the {@link producer} to be used for sending to the given endpoint
* <p/>
* this can be used to early start the {@link producer} to ensure it can be created,
* such as when camel is started. this allows to fail fast in case the {@link producer}
* could not be started.
*
* @param endpoint the endpoint to send the exchange to
* @throws exception is thrown if failed to create or start the {@link producer}
*/
public void startproducer endpoint endpoint  throws exception
producer producer   acquireproducer endpoint
releaseproducer endpoint  producer
/**
* sends the exchange to the given endpoint.
* <p>
* this method will <b>not</b> throw an exception. if processing of the given
* exchange failed then the exception is stored on the provided exchange
*
* @param endpoint the endpoint to send the exchange to
* @param exchange the exchange to send
*/
public void send endpoint endpoint  exchange exchange
sendexchange endpoint  null  null  exchange
/**
* sends an exchange to an endpoint using a supplied
* {@link processor} to populate the exchange
* <p>
* this method will <b>not</b> throw an exception. if processing of the given
* exchange failed then the exception is stored on the return exchange
*
* @param endpoint the endpoint to send the exchange to
* @param processor the transformer used to populate the new exchange
* @throws org.apache.camel.camelexecutionexception is thrown if sending failed
* @return the exchange
*/
public exchange send endpoint endpoint  processor processor
return sendexchange endpoint  null  processor  null
/**
* sends an exchange to an endpoint using a supplied
* {@link processor} to populate the exchange
* <p>
* this method will <b>not</b> throw an exception. if processing of the given
* exchange failed then the exception is stored on the return exchange
*
* @param endpoint the endpoint to send the exchange to
* @param pattern the message {@link exchangepattern} such as
*   {@link exchangepattern#inonly} or {@link exchangepattern#inout}
* @param processor the transformer used to populate the new exchange
* @return the exchange
*/
public exchange send endpoint endpoint  exchangepattern pattern  processor processor
return sendexchange endpoint  pattern  processor  null
/**
* sends an exchange to an endpoint using a supplied callback, using the synchronous processing.
* <p/>
* if an exception was thrown during processing, it would be set on the given exchange
*
* @param endpoint  the endpoint to send the exchange to
* @param exchange  the exchange, can be <tt>null</tt> if so then create a new exchange from the producer
* @param pattern   the exchange pattern, can be <tt>null</tt>
* @param callback  the callback
* @return the response from the callback
* @see #doinasyncproducer(org.apache.camel.endpoint, org.apache.camel.exchange, org.apache.camel.exchangepattern, org.apache.camel.asynccallback, org.apache.camel.asyncproducercallback)
*/
public <t> t doinproducer endpoint endpoint  exchange exchange  exchangepattern pattern  producercallback<t> callback
t answer   null
// get the producer and we do not mind if its pooled as we can handle returning it back to the pool
producer producer   dogetproducer endpoint  true
if  producer    null
if  isstopped
log warn     exchange
return null
else
throw new illegalstateexception     this
stopwatch watch   null
if  exchange    null
// record timing for sending the exchange using the producer
watch   new stopwatch
try
if  exchange    null
eventhelper notifyexchangesending exchange getcontext    exchange  endpoint
// invoke the callback
answer   callback doinproducer producer  exchange  pattern
catch  throwable e
if  exchange    null
exchange setexception e
finally
if  exchange    null
long timetaken   watch stop
// emit event that the exchange was sent to the endpoint
eventhelper notifyexchangesent exchange getcontext    exchange  endpoint  timetaken
if  producer instanceof servicepoolaware
// release back to the pool
pool release endpoint  producer
else if   producer issingleton
// stop non singleton producers as we should not leak resources
try
servicehelper stopservice producer
catch  exception e
// ignore and continue
log warn     producer  e
return answer
/**
* sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.
* <p/>
* if an exception was thrown during processing, it would be set on the given exchange
*
* @param endpoint         the endpoint to send the exchange to
* @param exchange         the exchange, can be <tt>null</tt> if so then create a new exchange from the producer
* @param pattern          the exchange pattern, can be <tt>null</tt>
* @param callback         the asynchronous callback
* @param producercallback the producer template callback to be executed
* @return (donesync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously
*/
public boolean doinasyncproducer final endpoint endpoint  final exchange exchange  final exchangepattern pattern
final asynccallback callback  final asyncproducercallback producercallback
boolean sync   true
// get the producer and we do not mind if its pooled as we can handle returning it back to the pool
final producer producer   dogetproducer endpoint  true
if  producer    null
if  isstopped
log warn     exchange
return false
else
throw new illegalstateexception     this
// record timing for sending the exchange using the producer
final stopwatch watch   exchange    null ? new stopwatch     null
try
if  exchange    null
eventhelper notifyexchangesending exchange getcontext    exchange  endpoint
// invoke the callback
asyncprocessor asyncprocessor   asyncprocessorconverterhelper convert producer
sync   producercallback doinasyncproducer producer  asyncprocessor  exchange  pattern  new asynccallback
@override
public void done boolean donesync
try
if  watch    null
long timetaken   watch stop
// emit event that the exchange was sent to the endpoint
eventhelper notifyexchangesent exchange getcontext    exchange  endpoint  timetaken
if  producer instanceof servicepoolaware
// release back to the pool
pool release endpoint  producer
else if   producer issingleton
// stop non singleton producers as we should not leak resources
try
servicehelper stopservice producer
catch  exception e
// ignore and continue
log warn     producer  e
finally
callback done donesync
catch  throwable e
// ensure exceptions is caught and set on the exchange
if  exchange    null
exchange setexception e
return sync
protected exchange sendexchange final endpoint endpoint  exchangepattern pattern
final processor processor  exchange exchange
return doinproducer endpoint  exchange  pattern  new producercallback<exchange>
public exchange doinproducer producer producer  exchange exchange  exchangepattern pattern
if  exchange    null
exchange   pattern    null ? producer createexchange pattern    producer createexchange
if  processor    null
// lets populate using the processor callback
try
processor process exchange
catch  exception e
// populate failed so return
exchange setexception e
return exchange
// now lets dispatch
log debug    endpoint  exchange
// set property which endpoint we send to
exchange setproperty exchange to_endpoint  endpoint getendpointuri
// send the exchange using the processor
stopwatch watch   new stopwatch
try
eventhelper notifyexchangesending exchange getcontext    exchange  endpoint
// ensure we run in an unit of work
producer target   new unitofworkproducer producer
target process exchange
catch  throwable e
// ensure exceptions is caught and set on the exchange
exchange setexception e
finally
// emit event that the exchange was sent to the endpoint
long timetaken   watch stop
eventhelper notifyexchangesent exchange getcontext    exchange  endpoint  timetaken
return exchange
protected synchronized producer dogetproducer endpoint endpoint  boolean pooled
string key   endpoint getendpointuri
producer answer   producers get key
if  pooled    answer    null
// try acquire from connection pool
answer   pool acquire endpoint
if  answer    null
// create a new producer
try
answer   endpoint createproducer
// must then start service so producer is ready to be used
servicehelper startservice answer
catch  exception e
throw new failedtocreateproducerexception endpoint  e
// add producer to cache or pool if applicable
if  pooled    answer instanceof servicepoolaware
log debug    endpoint  answer
answer   pool addandacquire endpoint  answer
else if  answer issingleton
log debug    endpoint  answer
producers put key  answer
return answer
protected void dostart   throws exception
servicehelper startservices producers values
servicehelper startservices pool
protected void dostop   throws exception
// when stopping we intend to shutdown
servicehelper stopandshutdownservice pool
servicehelper stopandshutdownservices producers values
producers clear
/**
* returns the current size of the cache
*
* @return the current size
*/
public int size
int size   producers size
size    pool size
log trace    size
return size
/**
* gets the maximum cache size (capacity).
* <p/>
* will return <tt>-1</tt> if it cannot determine this if a custom cache was used.
*
* @return the capacity
*/
public int getcapacity
int capacity    1
if  producers instanceof lrucache
lrucache<string  producer> cache    lrucache<string  producer> producers
capacity   cache getmaxcachesize
return capacity
/**
* gets the cache hits statistic
* <p/>
* will return <tt>-1</tt> if it cannot determine this if a custom cache was used.
*
* @return the hits
*/
public long gethits
long hits    1
if  producers instanceof lrucache
lrucache<string  producer> cache    lrucache<string  producer> producers
hits   cache gethits
return hits
/**
* gets the cache misses statistic
* <p/>
* will return <tt>-1</tt> if it cannot determine this if a custom cache was used.
*
* @return the misses
*/
public long getmisses
long misses    1
if  producers instanceof lrucache
lrucache<string  producer> cache    lrucache<string  producer> producers
misses   cache getmisses
return misses
/**
* resets the cache statistics
*/
public void resetcachestatistics
if  producers instanceof lrucache
lrucache<string  producer> cache    lrucache<string  producer> producers
cache resetstatistics
/**
* purges this cache
*/
public synchronized void purge
producers clear
pool purge
@override
public string tostring
return     source       getcapacity