/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component bean
import java lang annotation annotation
import java lang reflect method
import java lang reflect modifier
import java lang reflect proxy
import java util arraylist
import java util arrays
import java util collection
import java util collections
import java util comparator
import java util hashmap
import java util iterator
import java util list
import java util map
import org apache camel attachments
import org apache camel body
import org apache camel camelcontext
import org apache camel exchange
import org apache camel exchangeexception
import org apache camel expression
import org apache camel handler
import org apache camel header
import org apache camel headers
import org apache camel message
import org apache camel outheaders
import org apache camel properties
import org apache camel property
import org apache camel builder expressionbuilder
import org apache camel language languageannotation
import org apache camel spi registry
import org apache camel util castutils
import org apache camel util introspectionsupport
import org apache camel util objecthelper
import org slf4j logger
import org slf4j loggerfactory
import static org apache camel util exchangehelper converttotype
/**
* represents the metadata about a bean type created via a combination of
* introspection and annotations together with some useful sensible defaults
*
* @version
*/
public class beaninfo
private static final transient logger log   loggerfactory getlogger beaninfo class
private static final string cglib_class_separator
private static final list<method> excluded_methods   new arraylist<method>
private final camelcontext camelcontext
private final class<?> type
private final parametermappingstrategy strategy
private final methodinfo defaultmethod
// shared state with details of operations introspected from the bean, created during the constructor
private map<string  list<methodinfo>> operations   new hashmap<string  list<methodinfo>>
private list<methodinfo> operationswithbody   new arraylist<methodinfo>
private list<methodinfo> operationswithnobody   new arraylist<methodinfo>
private list<methodinfo> operationswithcustomannotation   new arraylist<methodinfo>
private list<methodinfo> operationswithhandlerannotation   new arraylist<methodinfo>
private map<method  methodinfo> methodmap   new hashmap<method  methodinfo>
static
// exclude all java.lang.object methods as we dont want to invoke them
excluded_methods addall arrays aslist object class getmethods
// exclude all java.lang.reflect.proxy methods as we dont want to invoke them
excluded_methods addall arrays aslist proxy class getmethods
try
// but keep tostring as this method is okay
excluded_methods remove object class getmethod
excluded_methods remove proxy class getmethod
catch  throwable e
// ignore
public beaninfo camelcontext camelcontext  class<?> type
this camelcontext  type  createparametermappingstrategy camelcontext
public beaninfo camelcontext camelcontext  method explicitmethod
this camelcontext  explicitmethod getdeclaringclass    explicitmethod  createparametermappingstrategy camelcontext
public beaninfo camelcontext camelcontext  class<?> type  parametermappingstrategy strategy
this camelcontext  type  null  strategy
public beaninfo camelcontext camelcontext  class<?> type  method explicitmethod  parametermappingstrategy strategy
this camelcontext   camelcontext
this type   type
this strategy   strategy
if  explicitmethod    null
// must be a valid method
if   isvalidmethod type  explicitmethod
throw new illegalargumentexception     explicitmethod
introspect gettype    explicitmethod
else
introspect gettype
// if there are only 1 method with 1 operation then select it as a default/fallback method
methodinfo method   null
if  operations size      1
list<methodinfo> methods   operations values   iterator   next
if  methods size      1
method   methods get 0
defaultmethod   method
// mark the operations lists as unmodifiable, as they should not change during runtime
// to keep this code thread safe
operations   collections unmodifiablemap operations
operationswithbody   collections unmodifiablelist operationswithbody
operationswithnobody   collections unmodifiablelist operationswithnobody
operationswithcustomannotation   collections unmodifiablelist operationswithcustomannotation
operationswithhandlerannotation   collections unmodifiablelist operationswithhandlerannotation
methodmap   collections unmodifiablemap methodmap
public class<?> gettype
return type
public camelcontext getcamelcontext
return camelcontext
public static parametermappingstrategy createparametermappingstrategy camelcontext camelcontext
// lookup in registry first if there is a user define strategy
registry registry   camelcontext getregistry
parametermappingstrategy answer   registry lookup beanconstants bean_parameter_mapping_strategy  parametermappingstrategy class
if  answer    null
// no then use the default one
answer   new defaultparametermappingstrategy
return answer
public methodinvocation createinvocation object pojo  exchange exchange
throws ambiguousmethodcallexception  methodnotfoundexception
return createinvocation pojo  exchange  null
private methodinvocation createinvocation object pojo  exchange exchange  method explicitmethod
throws ambiguousmethodcallexception  methodnotfoundexception
methodinfo methodinfo   null
// find the explicit method to invoke
if  explicitmethod    null
iterator<list<methodinfo>> it   operations values   iterator
while  it hasnext
list<methodinfo> infos   it next
for  methodinfo info   infos
if  explicitmethod equals info getmethod
return info createmethodinvocation pojo  exchange
throw new methodnotfoundexception exchange  pojo  explicitmethod getname
string methodname   exchange getin   getheader exchange bean_method_name  string class
if  methodname    null
// do not use qualifier for name
string name   methodname
if  methodname contains
name   objecthelper before methodname
// special for getclass, as we want the user to be able to invoke this method
// for example to log the class type or the likes
if    equals name       equals name
try
method method   pojo getclass   getmethod
methodinfo   new methodinfo exchange getcontext    pojo getclass    method  collections <parameterinfo>emptylist    collections <parameterinfo>emptylist    false  false
catch  nosuchmethodexception e
throw new methodnotfoundexception exchange  pojo
else
list<methodinfo> methods   getoperations name
if  methods    null    methods size      1
// only one method then choose it
methodinfo   methods get 0
else if  methods    null
// there are more methods with that name so we cannot decide which to use
// but first let's try to choose a method and see if that complies with the name
// must use the method name which may have qualifiers
methodinfo   choosemethod pojo  exchange  methodname
if  methodinfo    null     name equals methodinfo getmethod   getname
throw new ambiguousmethodcallexception exchange  methods
else
// a specific method was given to invoke but not found
throw new methodnotfoundexception exchange  pojo  methodname
if  methodinfo    null
// no name or type
methodinfo   choosemethod pojo  exchange  null
if  methodinfo    null
methodinfo   defaultmethod
if  methodinfo    null
log trace    methodinfo  pojo
return methodinfo createmethodinvocation pojo  exchange
log debug    pojo
return null
/**
* introspects the given class
*
* @param clazz the class
*/
private void introspect class<?> clazz
// get the target clazz as it could potentially have been enhanced by cglib etc.
clazz   gettargetclass clazz
objecthelper notnull clazz     this
log trace    clazz
// if the class is not public then fallback and use interface methods if possible
// this allow camel to invoke private beans which implements interfaces
list<method> methods   arrays aslist clazz getdeclaredmethods
if   modifier ispublic clazz getmodifiers
log trace    clazz
list<method> interfacemethods   getinterfacemethods clazz
// still keep non-accessible class methods to provide more specific exception if method is non-accessible
interfacemethods addall methods
methods   interfacemethods
for  method method   methods
boolean valid   isvalidmethod clazz  method
log trace    method  valid
if  valid
introspect clazz  method
class<?> superclass   clazz getsuperclass
if  superclass    null     superclass equals object class
introspect superclass
/**
* introspects the given method
*
* @param clazz the class
* @param method the method
* @return the method info, is newer <tt>null</tt>
*/
private methodinfo introspect class<?> clazz  method method
log trace    clazz  method
string opname   method getname
methodinfo methodinfo   createmethodinfo clazz  method
// methods already registered should be preferred to use instead of super classes of existing methods
// we want to us the method from the sub class over super classes, so if we have already registered
// the method then use it (we are traversing upwards: sub (child) -> super (farther) )
methodinfo existingmethodinfo   overridesexistingmethod methodinfo
if  existingmethodinfo    null
log trace    existingmethodinfo
return existingmethodinfo
log trace    opname  methodinfo
if  hasmethod opname
// we have an overloaded method so add the method info to the same key
list<methodinfo> existing   getoperations opname
existing add methodinfo
else
// its a new method we have not seen before so wrap it in a list and add it
list<methodinfo> methods   new arraylist<methodinfo>
methods add methodinfo
operations put opname  methods
if  methodinfo hascustomannotation
operationswithcustomannotation add methodinfo
else if  methodinfo hasbodyparameter
operationswithbody add methodinfo
else
operationswithnobody add methodinfo
if  methodinfo hashandlerannotation
operationswithhandlerannotation add methodinfo
// must add to method map last otherwise we break stuff
methodmap put method  methodinfo
return methodinfo
/**
* returns the {@link methodinfo} for the given method if it exists or null
* if there is no metadata available for the given method
*/
public methodinfo getmethodinfo method method
methodinfo answer   methodmap get method
if  answer    null
// maybe the method is defined on a base class?
if  type    object class
class<?> superclass   type getsuperclass
if  superclass    null    superclass    object class
beaninfo superbeaninfo   new beaninfo camelcontext  superclass  strategy
return superbeaninfo getmethodinfo method
return answer
protected methodinfo createmethodinfo class<?> clazz  method method
class<?> parametertypes   method getparametertypes
list<annotation> parametersannotations   collectparameterannotations clazz  method
list<parameterinfo> parameters   new arraylist<parameterinfo>
list<parameterinfo> bodyparameters   new arraylist<parameterinfo>
boolean hascustomannotation   false
boolean hashandlerannotation   objecthelper hasannotation method getannotations    handler class
int size   parametertypes length
if  log istraceenabled
log trace    new object clazz  method  size
for  int i   0  i < size  i
class<?> parametertype   parametertypes
annotation parameterannotations   parametersannotations toarray new annotation size  ]
expression expression   createparameterunmarshalexpression clazz  method  parametertype  parameterannotations
hascustomannotation    expression    null
parameterinfo parameterinfo   new parameterinfo i  parametertype  parameterannotations  expression
log trace    i  parameterinfo
parameters add parameterinfo
if  expression    null
boolean bodyannotation   objecthelper hasannotation parameterannotations  body class
log trace    i
hascustomannotation    bodyannotation
if  bodyparameters isempty
// okay we have not yet set the body parameter and we have found
// the candidate now to use as body parameter
if  exchange class isassignablefrom parametertype
// use exchange
expression   expressionbuilder exchangeexpression
else
// assume it's the body and it must be mandatory convertible to the parameter type
// but we allow null bodies in case the message really contains a null body
expression   expressionbuilder mandatorybodyexpression parametertype  true
log trace    i  expression
parameterinfo setexpression expression
bodyparameters add parameterinfo
else
// will ignore the expression for parameter evaluation
log trace    i  parameterinfo
// now let's add the method to the repository
return new methodinfo camelcontext  clazz  method  parameters  bodyparameters  hascustomannotation  hashandlerannotation
protected list<annotation> collectparameterannotations class<?> c  method m
@suppresswarnings
list<annotation> annotations   new list
for  int i   0  i < annotations length  i
annotations   new arraylist<annotation>
collectparameterannotations c  m  annotations
return annotations
protected void collectparameterannotations class<?> c  method m  list<annotation> a
try
annotation pa   c getdeclaredmethod m getname    m getparametertypes    getparameterannotations
for  int i   0  i < pa length  i
a addall arrays aslist pa
catch  nosuchmethodexception e
// no method with signature of m declared on c
for  class<?> i   c getinterfaces
collectparameterannotations i  m  a
if   c isinterface      c getsuperclass      null
collectparameterannotations c getsuperclass    m  a
/**
* choose one of the available methods to invoke if we can match
* the message body to the body parameter
*
* @param pojo the bean to invoke a method on
* @param exchange the message exchange
* @param name an optional name of the method that must match, use <tt>null</tt> to indicate all methods
* @return the method to invoke or null if no definitive method could be matched
* @throws ambiguousmethodcallexception is thrown if cannot choose method due to ambiguity
*/
protected methodinfo choosemethod object pojo  exchange exchange  string name  throws ambiguousmethodcallexception
// @handler should be select first
// then any single method that has a custom @annotation
// or any single method that has a match parameter type that matches the exchange payload
// and last then try to select the best among the rest
// must use defensive copy, to avoid altering the shared lists
// and we want to remove unwanted operations from these local lists
final list<methodinfo> localoperationswithbody   new arraylist<methodinfo> operationswithbody
final list<methodinfo> localoperationswithnobody   new arraylist<methodinfo> operationswithnobody
final list<methodinfo> localoperationswithcustomannotation   new arraylist<methodinfo> operationswithcustomannotation
final list<methodinfo> localoperationswithhandlerannotation   new arraylist<methodinfo> operationswithhandlerannotation
if  name    null
// filter all lists to only include methods with this name
removenonmatchingmethods localoperationswithhandlerannotation  name
removenonmatchingmethods localoperationswithcustomannotation  name
removenonmatchingmethods localoperationswithbody  name
removenonmatchingmethods localoperationswithnobody  name
else
// remove all getter/setter as we do not want to consider these methods
removeallsetterorgettermethods localoperationswithhandlerannotation
removeallsetterorgettermethods localoperationswithcustomannotation
removeallsetterorgettermethods localoperationswithbody
removeallsetterorgettermethods localoperationswithnobody
if  localoperationswithhandlerannotation size   > 1
// if we have more than 1 @handler then its ambiguous
throw new ambiguousmethodcallexception exchange  localoperationswithhandlerannotation
if  localoperationswithhandlerannotation size      1
// methods with handler should be preferred
return localoperationswithhandlerannotation get 0
else if  localoperationswithcustomannotation size      1
// if there is one method with an annotation then use that one
return localoperationswithcustomannotation get 0
// named method and with no parameters
boolean noparameters   name    null    name endswith
if  noparameters    localoperationswithnobody size      1
// if there was a method name configured and it has no parameters, then use the method with no body (eg no parameters)
return localoperationswithnobody get 0
else if  localoperationswithbody size      1
// if there is one method with body then use that one
return localoperationswithbody get 0
collection<methodinfo> possibleoperations   new arraylist<methodinfo>
possibleoperations addall localoperationswithbody
possibleoperations addall localoperationswithcustomannotation
if   possibleoperations isempty
// multiple possible operations so find the best suited if possible
methodinfo answer   choosemethodwithmatchingbody exchange  possibleoperations  localoperationswithcustomannotation
if  answer    null
throw new ambiguousmethodcallexception exchange  possibleoperations
else
return answer
// not possible to determine
return null
private methodinfo choosemethodwithmatchingbody exchange exchange  collection<methodinfo> operationlist
list<methodinfo> operationswithcustomannotation
throws ambiguousmethodcallexception
// see if we can find a method whose body param type matches the message body
message in   exchange getin
object body   in getbody
if  body    null
class<?> bodytype   body getclass
if  log istraceenabled
log trace    bodytype getcanonicalname
list<methodinfo> possibles   new arraylist<methodinfo>
list<methodinfo> possibleswithexception   new arraylist<methodinfo>
for  methodinfo methodinfo   operationlist
// test for mep pattern matching
boolean out   exchange getpattern   isoutcapable
if  out    methodinfo isreturntypevoid
// skip this method as the mep is out so the method must return something
continue
// try to match the arguments
if  methodinfo bodyparametermatches bodytype
log trace    methodinfo
if  methodinfo hasexceptionparameter
// methods with accepts exceptions
possibleswithexception add methodinfo
else
// regular methods with no exceptions
possibles add methodinfo
// find best suited method to use
return choosebestpossiblemethodinfo exchange  operationlist  body  possibles  possibleswithexception  operationswithcustomannotation
// no match so return null
return null
private methodinfo choosebestpossiblemethodinfo exchange exchange  collection<methodinfo> operationlist  object body
list<methodinfo> possibles  list<methodinfo> possibleswithexception
list<methodinfo> possiblewithcustomannotation
throws ambiguousmethodcallexception
exception exception   expressionbuilder exchangeexceptionexpression   evaluate exchange  exception class
if  exception    null    possibleswithexception size      1
log trace
// prefer the method that accepts exception in case we have an exception also
return possibleswithexception get 0
else if  possibles size      1
return possibles get 0
else if  possibles isempty
log trace
// let's try converting
object newbody   null
methodinfo matched   null
int matchcounter   0
for  methodinfo methodinfo   operationlist
if  methodinfo getbodyparametertype   isinstance body
return methodinfo
object value   converttotype exchange  methodinfo getbodyparametertype    body
if  value    null
if  log istraceenabled
log trace
body getclass   getcanonicalname    methodinfo getbodyparametertype   getcanonicalname
matchcounter
newbody   value
matched   methodinfo
if  matchcounter > 1
throw new ambiguousmethodcallexception exchange  arrays aslist matched  matched
if  matched    null
log trace    body
message in   exchange getin
in setbody newbody
return matched
else
// if we only have a single method with custom annotations, let's use that one
if  possiblewithcustomannotation size      1
methodinfo answer   possiblewithcustomannotation get 0
log trace    answer
return answer
// phew try to choose among multiple methods with annotations
return choosemethodwithcustomannotations exchange  possibles
// cannot find a good method to use
return null
/**
* validates whether the given method is a valid candidate for camel bean binding.
*
* @param clazz   the class
* @param method  the method
* @return true if valid, false to skip the method
*/
protected boolean isvalidmethod class<?> clazz  method method
// must not be in the excluded list
for  method excluded   excluded_methods
if  objecthelper isoverridingmethod excluded  method
// the method is overriding an excluded method so its not valid
return false
// must be a public method
if   modifier ispublic method getmodifiers
return false
// return type must not be an exchange and it should not be a bridge method
if   method getreturntype      null    exchange class isassignablefrom method getreturntype        method isbridge
return false
return true
/**
* does the given method info override an existing method registered before (from a subclass)
*
* @param methodinfo  the method to test
* @return the already registered method to use, null if not overriding any
*/
private methodinfo overridesexistingmethod methodinfo methodinfo
for  methodinfo info   methodmap values
method source   info getmethod
method target   methodinfo getmethod
boolean override   objecthelper isoverridingmethod source  target
if  override
// same name, same parameters, then its overrides an existing class
return info
return null
private methodinfo choosemethodwithcustomannotations exchange exchange  collection<methodinfo> possibles
throws ambiguousmethodcallexception
// if we have only one method with custom annotations let's choose that
methodinfo chosen   null
for  methodinfo possible   possibles
if  possible hascustomannotation
if  chosen    null
chosen   null
break
else
chosen   possible
if  chosen    null
return chosen
throw new ambiguousmethodcallexception exchange  possibles
/**
* creates an expression for the given parameter type if the parameter can
* be mapped automatically or null if the parameter cannot be mapped due to
* insufficient annotations or not fitting with the default type
* conventions.
*/
private expression createparameterunmarshalexpression class<?> clazz  method method
class<?> parametertype  annotation parameterannotation
// look for a parameter annotation that converts into an expression
for  annotation annotation   parameterannotation
expression answer   createparameterunmarshalexpressionforannotation clazz  method  parametertype  annotation
if  answer    null
return answer
// no annotations then try the default parameter mappings
return strategy getdefaultparametertypeexpression parametertype
private expression createparameterunmarshalexpressionforannotation class<?> clazz  method method
class<?> parametertype  annotation annotation
if  annotation instanceof attachments
return expressionbuilder attachmentsexpression
else if  annotation instanceof property
property propertyannotation    property annotation
return expressionbuilder propertyexpression propertyannotation value
else if  annotation instanceof properties
return expressionbuilder propertiesexpression
else if  annotation instanceof header
header headerannotation    header annotation
return expressionbuilder headerexpression headerannotation value
else if  annotation instanceof headers
return expressionbuilder headersexpression
else if  annotation instanceof outheaders
return expressionbuilder outheadersexpression
else if  annotation instanceof exchangeexception
return expressionbuilder exchangeexceptionexpression castutils cast parametertype  exception class
else
languageannotation languageannotation   annotation annotationtype   getannotation languageannotation class
if  languageannotation    null
class<?> type   languageannotation factory
object object   camelcontext getinjector   newinstance type
if  object instanceof annotationexpressionfactory
annotationexpressionfactory expressionfactory    annotationexpressionfactory  object
return expressionfactory createexpression camelcontext  annotation  languageannotation  parametertype
else
log warn     languageannotation       method
type getname
annotationexpressionfactory class getname
return null
private static list<method> getinterfacemethods class<?> clazz
final list<method> answer   new arraylist<method>
for  class<?> interfaceclazz   clazz getinterfaces
for  method interfacemethod   interfaceclazz getdeclaredmethods
answer add interfacemethod
return answer
private static void removeallsetterorgettermethods list<methodinfo> methods
iterator<methodinfo> it   methods iterator
while  it hasnext
methodinfo info   it next
if  introspectionsupport isgetter info getmethod
// skip getters
it remove
else if  introspectionsupport issetter info getmethod
// skip setters
it remove
private void removenonmatchingmethods list<methodinfo> methods  string name
iterator<methodinfo> it   methods iterator
while  it hasnext
methodinfo info   it next
if   matchmethod info getmethod    name
// method does not match so remove it
it remove
private boolean matchmethod method method  string methodname
if  methodname    null
return true
if  methodname contains        methodname endswith
throw new illegalargumentexception     methodname
// do not use qualifier for name matching
string name   methodname
if  name contains
name   objecthelper before name
// must match name
if   name equals method getname
return false
// match qualifier types which is used to select among overloaded methods
string types   objecthelper between methodname
if  types    null
// we must qualify based on types to match method
iterator<?> it   objecthelper createiterator types
for  int i   0  i < method getparametertypes   length  i
if  it hasnext
class<?> parametertype   method getparametertypes
string qualifytype    string  it next
if  objecthelper isempty qualifytype
continue
// trim the type
qualifytype   qualifytype trim
if    equals qualifytype
// * is a wildcard so we accept and match that parameter type
continue
if  beanhelper isvalidparametervalue qualifytype
// its a parameter value, so continue to next parameter
// as we should only check for fqn/type parameters
continue
// if qualify type indeed is a class, then it must be assignable with the parameter type
boolean assignable   beanhelper isassignabletoexpectedtype getcamelcontext   getclassresolver    qualifytype  parametertype
// the method will return null if the qualifytype is not a class
if  assignable    null     assignable
return false
else
// there method has more parameters than was specified in the method name qualifiers
return false
// if the method has no more types then we can only regard it as matched
// if there are no more qualifiers
if  it hasnext
return false
// the method matched
return true
private static class<?> gettargetclass class<?> clazz
if  clazz    null    clazz getname   contains cglib_class_separator
class<?> superclass   clazz getsuperclass
if  superclass    null     object class equals superclass
return superclass
return clazz
/**
* do we have a method with the given name.
* <p/>
* shorthand method names for getters is supported, so you can pass in eg 'name' and camel
* will can find the real 'getname' method instead.
*
* @param methodname the method name
* @return <tt>true</tt> if we have such a method.
*/
public boolean hasmethod string methodname
return getoperations methodname     null
/**
* do we have a static method with the given name.
* <p/>
* shorthand method names for getters is supported, so you can pass in eg 'name' and camel
* will can find the real 'getname' method instead.
*
* @param methodname the method name
* @return <tt>true</tt> if we have such a static method.
*/
public boolean hasstaticmethod string methodname
list<methodinfo> methods   getoperations methodname
if  methods    null    methods isempty
return false
for  methodinfo method   methods
if  method isstaticmethod
return true
return false
/**
* gets the list of methods sorted by a..z method name.
*
* @return the methods.
*/
public list<methodinfo> getmethods
if  operations isempty
return collections emptylist
list<methodinfo> methods   new arraylist<methodinfo>
for  collection<methodinfo> col   operations values
methods addall col
// sort the methods by name a..z
collections sort methods  new comparator<methodinfo>
public int compare methodinfo o1  methodinfo o2
return o1 getmethod   getname   compareto o2 getmethod   getname
return methods
/**
* get the operation(s) with the given name. we can have multiple when methods is overloaded.
* <p/>
* shorthand method names for getters is supported, so you can pass in eg 'name' and camel
* will can find the real 'getname' method instead.
*
* @param methodname the method name
* @return the found method, or <tt>null</tt> if not found
*/
private list<methodinfo> getoperations string methodname
// do not use qualifier for name
if  methodname contains
methodname   objecthelper before methodname
list<methodinfo> answer   operations get methodname
if  answer    null
return answer
// now try all getters to see if any of those matched the methodname
for  method method   methodmap keyset
if  introspectionsupport isgetter method
string shorthandmethodname   introspectionsupport getgettershorthandname method
// if the two names matches then see if we can find it using that name
if  methodname equals shorthandmethodname
return operations get method getname
return null