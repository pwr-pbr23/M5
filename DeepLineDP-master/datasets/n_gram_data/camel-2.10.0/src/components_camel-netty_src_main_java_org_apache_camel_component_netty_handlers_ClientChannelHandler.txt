/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component netty handlers
import org apache camel asynccallback
import org apache camel camelexchangeexception
import org apache camel exchange
import org apache camel notypeconversionavailableexception
import org apache camel component netty nettycamelstate
import org apache camel component netty nettyconstants
import org apache camel component netty nettyhelper
import org apache camel component netty nettypayloadhelper
import org apache camel component netty nettyproducer
import org apache camel util exchangehelper
import org jboss netty channel channelhandlercontext
import org jboss netty channel channelstateevent
import org jboss netty channel exceptionevent
import org jboss netty channel messageevent
import org jboss netty channel simplechannelupstreamhandler
import org slf4j logger
import org slf4j loggerfactory
/**
* client handler which cannot be shared
*/
public class clientchannelhandler extends simplechannelupstreamhandler
private static final transient logger log   loggerfactory getlogger clientchannelhandler class
private final nettyproducer producer
private volatile boolean messagereceived
private volatile boolean exceptionhandled
public clientchannelhandler nettyproducer producer
this producer   producer
@override
public void channelopen channelhandlercontext ctx  channelstateevent channelstateevent  throws exception
// to keep track of open sockets
producer getallchannels   add channelstateevent getchannel
@override
public void exceptioncaught channelhandlercontext ctx  exceptionevent exceptionevent  throws exception
if  log istraceenabled
log trace     ctx getchannel    exceptionevent getcause
if  exceptionhandled
// ignore subsequent exceptions being thrown
return
exceptionhandled   true
throwable cause   exceptionevent getcause
if  log isdebugenabled
log debug    cause
exchange exchange   getexchange ctx
asynccallback callback   getasynccallback ctx
// the state may not be set
if  exchange    null    callback    null
// set the cause on the exchange
exchange setexception cause
// close channel in case an exception was thrown
nettyhelper close exceptionevent getchannel
// signal callback
callback done false
@override
public void channelclosed channelhandlercontext ctx  channelstateevent e  throws exception
log trace    ctx getchannel
exchange exchange   getexchange ctx
asynccallback callback   getasynccallback ctx
// remove state
producer removestate ctx getchannel
if  producer getconfiguration   issync       messagereceived     exceptionhandled
// session was closed but no message received. this could be because the remote server had an internal error
// and could not return a response. we should count down to stop waiting for a response
if  log isdebugenabled
log debug    producer getconfiguration   getaddress
exchange setexception new camelexchangeexception     producer getconfiguration   getaddress    exchange
// signal callback
callback done false
@override
public void messagereceived channelhandlercontext ctx  messageevent messageevent  throws exception
messagereceived   true
exchange exchange   getexchange ctx
asynccallback callback   getasynccallback ctx
object body   messageevent getmessage
log debug    body
// if textline enabled then covert to a string which must be used for textline
if  producer getconfiguration   istextline
try
body   producer getcontext   gettypeconverter   mandatoryconvertto string class  exchange  body
catch  notypeconversionavailableexception e
exchange setexception e
callback done false
// set the result on either in or out on the original exchange depending on its pattern
if  exchangehelper isoutcapable exchange
nettypayloadhelper setout exchange  body
else
nettypayloadhelper setin exchange  body
try
// should channel be closed after complete?
boolean close
if  exchangehelper isoutcapable exchange
close   exchange getout   getheader nettyconstants netty_close_channel_when_complete  boolean class
else
close   exchange getin   getheader nettyconstants netty_close_channel_when_complete  boolean class
// should we disconnect, the header can override the configuration
boolean disconnect   producer getconfiguration   isdisconnect
if  close    null
disconnect   close
if  disconnect
if  log isdebugenabled
log debug    producer getconfiguration   getaddress
nettyhelper close ctx getchannel
finally
// signal callback
callback done false
private exchange getexchange channelhandlercontext ctx
nettycamelstate state   producer getstate ctx getchannel
return state    null ? state getexchange     null
private asynccallback getasynccallback channelhandlercontext ctx
nettycamelstate state   producer getstate ctx getchannel
return state    null ? state getcallback     null