/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel impl
import java util arraylist
import java util collection
import java util hashmap
import java util linkedhashset
import java util list
import java util map
import java util set
import java util concurrent atomic atomicboolean
import org apache camel camelcontext
import org apache camel channel
import org apache camel consumer
import org apache camel processor
import org apache camel route
import org apache camel service
import org apache camel model oncompletiondefinition
import org apache camel model onexceptiondefinition
import org apache camel model processordefinition
import org apache camel model routedefinition
import org apache camel processor errorhandler
import org apache camel spi lifecyclestrategy
import org apache camel spi routecontext
import org apache camel spi routepolicy
import org apache camel support childservicesupport
import org apache camel util eventhelper
import org apache camel util servicehelper
import org slf4j logger
import org slf4j loggerfactory
/**
* represents the runtime objects for a given {@link routedefinition} so that it can be stopped independently
* of other routes
*
* @version
*/
public class routeservice extends childservicesupport
private static final logger log   loggerfactory getlogger routeservice class
private final defaultcamelcontext camelcontext
private final routedefinition routedefinition
private final list<routecontext> routecontexts
private final list<route> routes
private final string id
private boolean removingroutes
private final map<route  consumer> inputs   new hashmap<route  consumer>
private final atomicboolean warmupdone   new atomicboolean false
private final atomicboolean endpointdone   new atomicboolean false
public routeservice defaultcamelcontext camelcontext  routedefinition routedefinition  list<routecontext> routecontexts  list<route> routes
this camelcontext   camelcontext
this routedefinition   routedefinition
this routecontexts   routecontexts
this routes   routes
this id   routedefinition idorcreate camelcontext getnodeidfactory
public string getid
return id
public camelcontext getcamelcontext
return camelcontext
public list<routecontext> getroutecontexts
return routecontexts
public routedefinition getroutedefinition
return routedefinition
public collection<route> getroutes
return routes
/**
* gets the inputs to the routes.
*
* @return list of {@link consumer} as inputs for the routes
*/
public map<route  consumer> getinputs
return inputs
public boolean isremovingroutes
return removingroutes
public void setremovingroutes boolean removingroutes
this removingroutes   removingroutes
public synchronized void warmup   throws exception
if  endpointdone compareandset false  true
// endpoints should only be started once as they can be reused on other routes
// and whatnot, thus their lifecycle is to start once, and only to stop when camel shutdown
for  route route   routes
// ensure endpoint is started first (before the route services, such as the consumer)
servicehelper startservice route getendpoint
if  warmupdone compareandset false  true
for  route route   routes
// warm up the route first
route warmup
log debug    route getid
list<service> services   route getservices
// callback that we are staring these services
route onstartingservices services
// gather list of services to start as we need to start child services as well
set<service> list   new linkedhashset<service>
for  service service   services
list addall servicehelper getchildservices service
// split into consumers and child services as we need to start the consumers
// afterwards to avoid them being active while the others start
list<service> childservices   new arraylist<service>
for  service service   list
if  service instanceof consumer
inputs put route   consumer  service
else
childservices add service
startchildservice route  childservices
// ensure lifecycle strategy is invoked which among others enlist the route in jmx
for  lifecyclestrategy strategy   camelcontext getlifecyclestrategies
strategy onroutesadd routes
// add routes to camel context
camelcontext addroutecollection routes
protected void dostart   throws exception
// ensure we are warmed up before starting the route
warmup
for  route route   routes
// start the route itself
servicehelper startservice route
// invoke callbacks on route policy
if  routedefinition getroutepolicies      null
for  routepolicy routepolicy   routedefinition getroutepolicies
routepolicy onstart route
// fire event
eventhelper notifyroutestarted camelcontext  route
protected void dostop   throws exception
// if we are stopping camelcontext then we are shutting down
boolean isshutdowncamelcontext   camelcontext isstopping
if  isshutdowncamelcontext    isremovingroutes
// need to call onroutesremove when the camelcontext is shutting down or route is shutdown
for  lifecyclestrategy strategy   camelcontext getlifecyclestrategies
strategy onroutesremove routes
for  route route   routes
log debug    route getid
// gather list of services to stop as we need to start child services as well
list<service> services   new arraylist<service>
services addall route getservices
// also get route scoped services
dogetroutescopedservices services  route
set<service> list   new linkedhashset<service>
for  service service   services
list addall servicehelper getchildservices service
// also get route scoped error handler (which must be done last)
dogetroutescopederrorhandler list  route
// stop services
stopchildservice route  list  isshutdowncamelcontext
// stop the route itself
if  isshutdowncamelcontext
servicehelper stopandshutdownservices route
else
servicehelper stopservices route
// invoke callbacks on route policy
if  routedefinition getroutepolicies      null
for  routepolicy routepolicy   routedefinition getroutepolicies
routepolicy onstop route
// fire event
eventhelper notifyroutestopped camelcontext  route
if  isremovingroutes
camelcontext removeroutecollection routes
// need to warm up again
warmupdone set false
@override
protected void doshutdown   throws exception
for  route route   routes
log debug    route getid
// gather list of services to stop as we need to start child services as well
list<service> services   new arraylist<service>
services addall route getservices
// also get route scoped services
dogetroutescopedservices services  route
set<service> list   new linkedhashset<service>
for  service service   services
list addall servicehelper getchildservices service
// also get route scoped error handler (which must be done last)
dogetroutescopederrorhandler list  route
// shutdown services
stopchildservice route  list  true
// shutdown the route itself
servicehelper stopandshutdownservices route
// endpoints should only be stopped when camel is shutting down
// see more details in the warmup method
servicehelper stopandshutdownservices route getendpoint
// invoke callbacks on route policy
if  routedefinition getroutepolicies      null
for  routepolicy routepolicy   routedefinition getroutepolicies
routepolicy onremove route
// need to call onroutesremove when the camelcontext is shutting down or route is shutdown
for  lifecyclestrategy strategy   camelcontext getlifecyclestrategies
strategy onroutesremove routes
// remove the routes from the inflight registry
for  route route   routes
camelcontext getinflightrepository   removeroute route getid
// remove the routes from the collections
camelcontext removeroutecollection routes
// clear inputs on shutdown
inputs clear
warmupdone set false
endpointdone set false
@override
protected void dosuspend   throws exception
// suspend and resume logic is provided by defaultcamelcontext which leverages shutdownstrategy
// to safely suspend and resume
for  route route   routes
if  routedefinition getroutepolicies      null
for  routepolicy routepolicy   routedefinition getroutepolicies
routepolicy onsuspend route
@override
protected void doresume   throws exception
// suspend and resume logic is provided by defaultcamelcontext which leverages shutdownstrategy
// to safely suspend and resume
for  route route   routes
if  routedefinition getroutepolicies      null
for  routepolicy routepolicy   routedefinition getroutepolicies
routepolicy onresume route
protected void startchildservice route route  list<service> services  throws exception
for  service service   services
log debug    route getid    service
for  lifecyclestrategy strategy   camelcontext getlifecyclestrategies
strategy onserviceadd camelcontext  service  route
servicehelper startservice service
addchildservice service
protected void stopchildservice route route  set<service> services  boolean shutdown  throws exception
for  service service   services
log debug    new object shutdown ?        route getid    service
if  service instanceof errorhandler
// special for error handlers
for  lifecyclestrategy strategy   camelcontext getlifecyclestrategies
strategy onerrorhandlerremove route getroutecontext     processor  service  route getroutecontext   getroute   geterrorhandlerbuilder
else
for  lifecyclestrategy strategy   camelcontext getlifecyclestrategies
strategy onserviceremove camelcontext  service  route
if  shutdown
servicehelper stopandshutdownservice service
else
servicehelper stopservice service
removechildservice service
/**
* gather the route scoped error handler from the given route
*/
private void dogetroutescopederrorhandler set<service> services  route route
// only include error handlers if they are route scoped
boolean includeerrorhandler    routedefinition iscontextscopederrorhandler route getroutecontext   getcamelcontext
list<service> extra   new arraylist<service>
if  includeerrorhandler
for  service service   services
if  service instanceof channel
processor eh     channel  service  geterrorhandler
if  eh    null    eh instanceof service
extra add  service  eh
if   extra isempty
services addall extra
/**
* gather all other kind of route scoped services from the given route, except error handler
*/
private void dogetroutescopedservices list<service> services  route route
for  processordefinition<?> output   route getroutecontext   getroute   getoutputs
if  output instanceof onexceptiondefinition
onexceptiondefinition onexceptiondefinition    onexceptiondefinition  output
if  onexceptiondefinition isroutescoped
processor errorhandler   onexceptiondefinition geterrorhandler route getid
if  errorhandler    null    errorhandler instanceof service
services add  service  errorhandler
else if  output instanceof oncompletiondefinition
oncompletiondefinition oncompletiondefinition    oncompletiondefinition  output
if  oncompletiondefinition isroutescoped
processor oncompletionprocessor   oncompletiondefinition getoncompletion route getid
if  oncompletionprocessor    null    oncompletionprocessor instanceof service
services add  service  oncompletionprocessor