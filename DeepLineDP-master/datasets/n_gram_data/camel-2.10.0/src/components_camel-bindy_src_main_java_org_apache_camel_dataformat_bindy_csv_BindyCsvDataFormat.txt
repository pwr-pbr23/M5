/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel dataformat bindy csv
import java io inputstream
import java io inputstreamreader
import java io outputstream
import java util arraylist
import java util arrays
import java util hashmap
import java util iterator
import java util list
import java util map
import java util scanner
import org apache camel exchange
import org apache camel dataformat bindy bindyabstractdataformat
import org apache camel dataformat bindy bindyabstractfactory
import org apache camel dataformat bindy bindycsvfactory
import org apache camel dataformat bindy util converterutils
import org apache camel spi dataformat
import org apache camel spi packagescanclassresolver
import org apache camel util iohelper
import org apache camel util objecthelper
import org slf4j logger
import org slf4j loggerfactory
/**
* a <a href="http://camel.apache.org/data-format.html">data format</a> (
* {@link dataformat}) using bindy to marshal to and from csv files
*/
public class bindycsvdataformat extends bindyabstractdataformat
private static final transient logger log   loggerfactory getlogger bindycsvdataformat class
public bindycsvdataformat
public bindycsvdataformat string    packages
super packages
public bindycsvdataformat class<?> type
super type
@suppresswarnings
public void marshal exchange exchange  object body  outputstream outputstream  throws exception
bindycsvfactory factory    bindycsvfactory getfactory exchange getcontext   getpackagescanclassresolver
objecthelper notnull factory
// get crlf
byte bytescrlf   converterutils getbytereturn factory getcarriagereturn
if  factory getgenerateheadercolumnnames
string result   factory generateheader
byte bytes   exchange getcontext   gettypeconverter   convertto byte class  exchange  result
outputstream write bytes
// add a carriage return
outputstream write bytescrlf
list<map<string  object>> models   new arraylist<map<string  object>>
// the body is not a prepared list of map that bindy expects so help a bit here and create one for us
iterator<object> it   objecthelper createiterator body
while  it hasnext
object model   it next
if  model instanceof map
models add  map<string  object>  model
else
string name   model getclass   getname
map<string  object> row   new hashmap<string  object> 1
row put name  model
models add row
for  map<string  object> model   models
string result   factory unbind model
byte bytes   exchange getcontext   gettypeconverter   convertto byte class  exchange  result
outputstream write bytes
// add a carriage return
outputstream write bytescrlf
public object unmarshal exchange exchange  inputstream inputstream  throws exception
bindycsvfactory factory    bindycsvfactory getfactory exchange getcontext   getpackagescanclassresolver
objecthelper notnull factory
// list of pojos
list<map<string  object>> models   new arraylist<map<string  object>>
// pojos of the model
map<string  object> model
inputstreamreader in   new inputstreamreader inputstream  iohelper getcharsetname exchange
// scanner is used to read big file
scanner scanner   new scanner in
// retrieve the separator defined to split the record
string separator   factory getseparator
objecthelper notnull separator
int count   0
try
// if the first line of the csv file contains columns name, then we
// skip this line
if  factory getskipfirstline
// check if scanner is empty
if  scanner hasnextline
scanner nextline
while  scanner hasnextline
// read the line
string line   scanner nextline   trim
if  objecthelper isempty line
// skip if line is empty
continue
// increment counter
count
// create pojo where csv data will be stored
model   factory factory
// split the csv record according to the separator defined in
// annotated class @csvrecord
string tokens   line split separator   1
list<string> result   arrays aslist tokens
// must unquote tokens before use
result   unquotetokens result  separator
if  result size      0    result isempty
throw new java lang illegalargumentexception
if  result size   > 0
if  log isdebugenabled
log debug    result size
// bind data from csv record with model classes
factory bind result  model  count
// link objects together
factory link model
// add objects graph to the list
models add model
log debug    model
// test if models list is empty or not
// if this is the case (correspond to an empty stream, ...)
if  models size      0
throw new java lang illegalargumentexception
else
return extractunmarshalresult models
finally
scanner close
iohelper close in     log
/**
* unquote the tokens, by removing leading and trailing quote chars,
* as will handling fixing broken tokens which may have been split
* by a separator inside a quote.
*/
private list<string> unquotetokens list<string> result  string separator
// a current quoted token which we assemble from the broken pieces
// we need to do this as we use the split method on the string class
// to split the line using regular expression, and it does not handle
// if the separator char is also inside a quoted token, therefore we need
// to fix this afterwards
stringbuilder current   new stringbuilder
list<string> answer   new arraylist<string>
for  string s   result
boolean startquote   false
boolean endquote   false
if  s startswith   '"
s   s substring 1
startquote   true
if  s endswith   '"
s   s substring 0  s length     1
endquote   true
// are we in progress of rebuilding a broken token
boolean currentinprogress   current length   > 0
// if we hit a start token then rebuild a broken token
if  currentinprogress    startquote
// append to current if we are in the middle of a start quote
if  currentinprogress
// must append separator back as this is a quoted token that was broken
// but a separator inside the quotes
current append separator
current append s
// are we in progress of rebuilding a broken token
currentinprogress   current length   > 0
if  endquote
// we hit end quote so append current and reset it
answer add current tostring
current setlength 0
else if   currentinprogress
// not rebuilding so add directly as is
answer add s
// any left over from current?
if  current length   > 0
answer add current tostring
current setlength 0
return answer
protected bindyabstractfactory createmodelfactory packagescanclassresolver resolver  throws exception
if  getclasstype      null
return new bindycsvfactory resolver  getclasstype
else
return new bindycsvfactory resolver  getpackages