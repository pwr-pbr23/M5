/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component http4
import java io bytearrayoutputstream
import java io file
import java io ioexception
import java io inputstream
import java io serializable
import java io unsupportedencodingexception
import java net uri
import java net urisyntaxexception
import java util arraylist
import java util hashmap
import java util iterator
import java util list
import java util map
import org apache camel camelexchangeexception
import org apache camel exchange
import org apache camel message
import org apache camel component file genericfile
import org apache camel component http4 helper httphelper
import org apache camel converter stream cachedoutputstream
import org apache camel impl defaultproducer
import org apache camel spi headerfilterstrategy
import org apache camel util exchangehelper
import org apache camel util gziphelper
import org apache camel util iohelper
import org apache camel util messagehelper
import org apache camel util objecthelper
import org apache camel util urisupport
import org apache http header
import org apache http httpentity
import org apache http httpresponse
import org apache http client httpclient
import org apache http client methods httpentityenclosingrequestbase
import org apache http client methods httprequestbase
import org apache http client methods httpurirequest
import org apache http entity bytearrayentity
import org apache http entity fileentity
import org apache http entity inputstreamentity
import org apache http entity stringentity
import org apache http params coreprotocolpnames
import org apache http protocol httpcontext
import org apache http util entityutils
import org slf4j logger
import org slf4j loggerfactory
/**
* @version
*/
public class httpproducer extends defaultproducer
private static final transient logger log   loggerfactory getlogger httpproducer class
private httpclient httpclient
private httpcontext httpcontext
private boolean throwexception
private boolean transferexception
public httpproducer httpendpoint endpoint
super endpoint
this httpclient   endpoint gethttpclient
this httpcontext   endpoint gethttpcontext
this throwexception   endpoint isthrowexceptiononfailure
this transferexception   endpoint istransferexception
public void process exchange exchange  throws exception
// if we bridge endpoint then we need to skip matching headers with the http_query to avoid sending
// duplicated headers to the receiver, so use this skiprequestheaders as the list of headers to skip
map<string  object> skiprequestheaders   null
if  getendpoint   isbridgeendpoint
exchange setproperty exchange skip_gzip_encoding  boolean true
string querystring   exchange getin   getheader exchange http_query  string class
if  querystring    null
skiprequestheaders   urisupport parsequery querystring
httprequestbase httprequest   createmethod exchange
message in   exchange getin
string httpprotocolversion   in getheader exchange http_protocol_version  string class
if  httpprotocolversion    null
// set the http protocol version
httprequest getparams   setparameter coreprotocolpnames protocol_version  httphelper parserhttpversion httpprotocolversion
headerfilterstrategy strategy   getendpoint   getheaderfilterstrategy
// propagate headers as http headers
for  map entry<string  object> entry   in getheaders   entryset
string key   entry getkey
object headervalue   in getheader key
if  headervalue    null
// use an iterator as there can be multiple values. (must not use a delimiter, and allow empty values)
final iterator<?> it   objecthelper createiterator headervalue  null  true
// the value to add as request header
final list<string> values   new arraylist<string>
// if its a multi value then check each value if we can add it and for multi values they
// should be combined into a single value
while  it hasnext
string value   exchange getcontext   gettypeconverter   convertto string class  it next
// we should not add headers for the parameters in the uri if we bridge the endpoint
// as then we would duplicate headers on both the endpoint uri, and in http headers as well
if  skiprequestheaders    null    skiprequestheaders containskey key
object skipvalue   skiprequestheaders get key
if  objecthelper equal skipvalue  value
continue
if  value    null    strategy    null     strategy applyfiltertocamelheaders key  value  exchange
values add value
// add the value(s) as a http request header
if  values size   > 0
// use the default tostring of a arraylist to create in the form [xxx, yyy]
// if multi valued, for a single value, then just output the value as is
string s    values size   > 1 ? values tostring     values get 0
httprequest addheader key  s
// lets store the result in the output message.
httpresponse httpresponse   null
try
if  log isdebugenabled
log debug    httprequest getmethod    httprequest geturi   tostring
httpresponse   executemethod httprequest
int responsecode   httpresponse getstatusline   getstatuscode
log debug    responsecode
if  throwexception     responsecode < 100    responsecode >  300
throw populatehttpoperationfailedexception exchange  httprequest  httpresponse  responsecode
else
populateresponse exchange  httprequest  httpresponse  in  strategy  responsecode
finally
if  httpresponse    null
try
entityutils consume httpresponse getentity
catch  ioexception e
// nothing we could do
@override
public httpendpoint getendpoint
return  httpendpoint  super getendpoint
protected void populateresponse exchange exchange  httprequestbase httprequest  httpresponse httpresponse
message in  headerfilterstrategy strategy  int responsecode  throws ioexception  classnotfoundexception
// we just make the out message is not create when extractresponsebody throws exception
object response   extractresponsebody httprequest  httpresponse  exchange
message answer   exchange getout
answer setheader exchange http_response_code  responsecode
answer setbody response
// propagate http response headers
header headers   httpresponse getallheaders
for  header header   headers
string name   header getname
string value   header getvalue
if  name tolowercase   equals
name   exchange content_type
// use http helper to extract parameter value as it may contain multiple values
object extracted   httphelper extracthttpparametervalue value
if  strategy    null     strategy applyfiltertoexternalheaders name  extracted  exchange
httphelper appendheader answer getheaders    name  extracted
// preserve headers from in by copying any non existing headers
// to avoid overriding existing headers with old values
messagehelper copyheaders exchange getin    answer  false
protected exception populatehttpoperationfailedexception exchange exchange  httprequestbase httprequest  httpresponse httpresponse  int responsecode  throws ioexception  classnotfoundexception
exception answer
string uri   httprequest geturi   tostring
string statustext   httpresponse getstatusline      null ? httpresponse getstatusline   getreasonphrase     null
map<string  string> headers   extractresponseheaders httpresponse getallheaders
object responsebody   extractresponsebody httprequest  httpresponse  exchange
if  transferexception    responsebody    null    responsebody instanceof exception
// if the response was a serialized exception then use that
return  exception  responsebody
// make a defensive copy of the response body in the exception so its detached from the cache
string copy   null
if  responsebody    null
copy   exchange getcontext   gettypeconverter   convertto string class  exchange  responsebody
header locationheader   httpresponse getfirstheader
if  locationheader    null     responsecode >  300    responsecode < 400
answer   new httpoperationfailedexception uri  responsecode  statustext  locationheader getvalue    headers  copy
else
answer   new httpoperationfailedexception uri  responsecode  statustext  null  headers  copy
return answer
/**
* strategy when executing the method (calling the remote server).
*
* @param httprequest the http request to execute
* @return the response
* @throws ioexception can be thrown
*/
protected httpresponse executemethod httpurirequest httprequest  throws ioexception
if  httpcontext    null
return httpclient execute httprequest  httpcontext
else
return httpclient execute httprequest
/**
* extracts the response headers
*
* @param responseheaders the headers
* @return the extracted headers or <tt>null</tt> if no headers existed
*/
protected static map<string  string> extractresponseheaders header responseheaders
if  responseheaders    null    responseheaders length    0
return null
map<string  string> answer   new hashmap<string  string>
for  header header   responseheaders
answer put header getname    header getvalue
return answer
/**
* extracts the response from the method as a inputstream.
*
* @param httprequest the method that was executed
* @return the response either as a stream, or as a deserialized java object
* @throws ioexception can be thrown
*/
protected static object extractresponsebody httprequestbase httprequest  httpresponse httpresponse  exchange exchange  throws ioexception  classnotfoundexception
httpentity entity   httpresponse getentity
if  entity    null
return null
inputstream is   entity getcontent
if  is    null
return null
header header   httpresponse getfirstheader exchange content_encoding
string contentencoding   header    null ? header getvalue     null
if   exchange getproperty exchange skip_gzip_encoding  boolean false  boolean class
is   gziphelper uncompressgzip contentencoding  is
// honor the character encoding
string contenttype   null
header   httprequest getfirstheader
if  header    null
contenttype   header getvalue
// find the charset and set it to the exchange
httphelper setcharsetfromcontenttype contenttype  exchange
inputstream response   doextractresponsebodyasstream is  exchange
// if content type is a serialized java object then de-serialize it back to a java object
if  contenttype    null    contenttype equals httpconstants content_type_java_serialized_object
return httphelper deserializejavaobjectfromstream response
else
return response
private static inputstream doextractresponsebodyasstream inputstream is  exchange exchange  throws ioexception
// as httpclient is using a autocloseinputstream, it will be closed when the connection is closed
// we need to cache the stream for it.
try
// this cachedoutputstream will not be closed when the exchange is oncompletion
cachedoutputstream cos   new cachedoutputstream exchange  false
iohelper copy is  cos
// when the inputstream is closed, the cachedoutputstream will be closed
return cos getwrappedinputstream
finally
iohelper close is     log
/**
* creates the httpmethod to use to call the remote server, either its get or post.
*
* @param exchange the exchange
* @return the created method as either get or post
* @throws urisyntaxexception is thrown if the uri is invalid
* @throws camelexchangeexception is thrown if error creating requestentity
*/
protected httprequestbase createmethod exchange exchange  throws urisyntaxexception  camelexchangeexception
string url   httphelper createurl exchange  getendpoint
uri uri   new uri url
httpentity requestentity   createrequestentity exchange
httpmethods methodtouse   httphelper createmethod exchange  getendpoint    requestentity    null
// is a query string provided in the endpoint uri or in a header (header overrules endpoint)
string querystring   exchange getin   getheader exchange http_query  string class
// we should user the query string from the http_uri header
if  querystring    null
querystring   uri getquery
if  querystring    null
querystring   getendpoint   gethttpuri   getrawquery
if  uri getscheme      null    uri gethost      null
throw new illegalargumentexception     uri
getendpoint
stringbuilder builder   new stringbuilder uri getscheme    append    append uri gethost
if  uri getport       1
builder append    append uri getport
if  uri getpath      null
builder append uri getrawpath
if  querystring    null
builder append
builder append querystring
log debug     builder tostring
httprequestbase httprequest   methodtouse createmethod builder tostring
if  methodtouse isentityenclosing
httpentityenclosingrequestbase  httprequest  setentity requestentity
if  requestentity    null    requestentity getcontenttype      null
log debug    url  exchange
return httprequest
/**
* creates a holder object for the data to send to the remote server.
*
* @param exchange the exchange with the in message with data to send
* @return the data holder
* @throws camelexchangeexception is thrown if error creating requestentity
*/
protected httpentity createrequestentity exchange exchange  throws camelexchangeexception
message in   exchange getin
if  in getbody      null
return null
httpentity answer   in getbody httpentity class
if  answer    null
try
object data   in getbody
if  data    null
string contenttype   exchangehelper getcontenttype exchange
if  contenttype    null    httpconstants content_type_java_serialized_object equals contenttype
// serialized java object
serializable obj   in getmandatorybody serializable class
// write object to output stream
bytearrayoutputstream bos   new bytearrayoutputstream
httphelper writeobjecttostream bos  obj
bytearrayentity entity   new bytearrayentity bos tobytearray
entity setcontenttype httpconstants content_type_java_serialized_object
iohelper close bos
answer   entity
else if  data instanceof file    data instanceof genericfile
// file based (could potentially also be a ftp file etc)
file file   in getbody file class
if  file    null
answer   new fileentity file  contenttype
else if  data instanceof string
// be a bit careful with string as any type can most likely be converted to string
// so we only do an instanceof check and accept string if the body is really a string
// do not fallback to use the default charset as it can influence the request
// (for example application/x-www-form-urlencoded forms being sent)
string charset   iohelper getcharsetname exchange  false
stringentity entity   new stringentity  string  data  charset
entity setcontenttype contenttype
answer   entity
// fallback as input stream
if  answer    null
// force the body as an input stream since this is the fallback
inputstream is   in getmandatorybody inputstream class
inputstreamentity entity   new inputstreamentity is   1
entity setcontenttype contenttype
answer   entity
catch  unsupportedencodingexception e
throw new camelexchangeexception    exchange  e
catch  ioexception e
throw new camelexchangeexception    exchange  e
return answer
public httpclient gethttpclient
return httpclient
public void sethttpclient httpclient httpclient
this httpclient   httpclient