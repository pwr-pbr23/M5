/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component seda
import java util arraylist
import java util hashset
import java util list
import java util set
import java util concurrent blockingqueue
import java util concurrent copyonwritearrayset
import java util concurrent executorservice
import java util concurrent linkedblockingqueue
import org apache camel component
import org apache camel consumer
import org apache camel exchange
import org apache camel message
import org apache camel multipleconsumerssupport
import org apache camel processor
import org apache camel producer
import org apache camel waitfortasktocomplete
import org apache camel api management managedattribute
import org apache camel api management managedoperation
import org apache camel api management managedresource
import org apache camel impl defaultendpoint
import org apache camel processor multicastprocessor
import org apache camel spi browsableendpoint
import org apache camel util endpointhelper
import org apache camel util messagehelper
import org apache camel util servicehelper
import org apache camel util urisupport
/**
* an implementation of the <a
* href="http://camel.apache.org/queue.html">queue components</a> for
* asynchronous seda exchanges on a {@link blockingqueue} within a camelcontext
*/
@managedresource description
public class sedaendpoint extends defaultendpoint implements browsableendpoint  multipleconsumerssupport
private volatile blockingqueue<exchange> queue
private int size
private int concurrentconsumers   1
private volatile executorservice multicastexecutor
private boolean multipleconsumers
private waitfortasktocomplete waitfortasktocomplete   waitfortasktocomplete ifreplyexpected
private long timeout   30000
private final set<sedaproducer> producers   new copyonwritearrayset<sedaproducer>
private final set<sedaconsumer> consumers   new copyonwritearrayset<sedaconsumer>
private volatile multicastprocessor consumermulticastprocessor
private volatile boolean multicaststarted
private boolean blockwhenfull
private int polltimeout   1000
public sedaendpoint
public sedaendpoint string endpointuri  component component  blockingqueue<exchange> queue
this endpointuri  component  queue  1
public sedaendpoint string endpointuri  component component  blockingqueue<exchange> queue  int concurrentconsumers
super endpointuri  component
this queue   queue
this size   queue remainingcapacity
this concurrentconsumers   concurrentconsumers
@override
public sedacomponent getcomponent
return  sedacomponent  super getcomponent
public producer createproducer   throws exception
return new sedaproducer this  getqueue    getwaitfortasktocomplete    gettimeout    isblockwhenfull
public consumer createconsumer processor processor  throws exception
return new sedaconsumer this  processor
public synchronized blockingqueue<exchange> getqueue
if  queue    null
// prefer to lookup queue from component, so if this endpoint is re-created or re-started
// then the existing queue from the component can be used, so new producers and consumers
// can use the already existing queue referenced from the component
if  getcomponent      null
queue   getcomponent   getorcreatequeue getendpointuri    getsize
else
// fallback and create queue (as this endpoint has no component)
queue   createqueue
return queue
protected blockingqueue<exchange> createqueue
if  size > 0
return new linkedblockingqueue<exchange> size
else
return new linkedblockingqueue<exchange>
protected synchronized multicastprocessor getconsumermulticastprocessor   throws exception
if   multicaststarted    consumermulticastprocessor    null
// only start it on-demand to avoid starting it during stopping
servicehelper startservice consumermulticastprocessor
multicaststarted   true
return consumermulticastprocessor
protected synchronized void updatemulticastprocessor   throws exception
if  consumermulticastprocessor    null
servicehelper stopservice consumermulticastprocessor
int size   getconsumers   size
if  size    0    multicastexecutor    null
// stop the multicast executor as its not needed anymore when size is zero
getcamelcontext   getexecutorservicemanager   shutdown multicastexecutor
multicastexecutor   null
if  size > 1
if  multicastexecutor    null
// create multicast executor as we need it when we have more than 1 processor
multicastexecutor   getcamelcontext   getexecutorservicemanager   newdefaultthreadpool this  urisupport sanitizeuri getendpointuri
// create list of consumers to multicast to
list<processor> processors   new arraylist<processor> size
for  sedaconsumer consumer   getconsumers
processors add consumer getprocessor
// create multicast processor
multicaststarted   false
consumermulticastprocessor   new multicastprocessor getcamelcontext    processors  null  true  multicastexecutor  false  false  false  0  null  false
else
// not needed
consumermulticastprocessor   null
public void setqueue blockingqueue<exchange> queue
this queue   queue
this size   queue remainingcapacity
@managedattribute description
public int getsize
return size
public void setsize int size
this size   size
@managedattribute description
public int getcurrentqueuesize
return queue size
public void setblockwhenfull boolean blockwhenfull
this blockwhenfull   blockwhenfull
@managedattribute description
public boolean isblockwhenfull
return blockwhenfull
public void setconcurrentconsumers int concurrentconsumers
this concurrentconsumers   concurrentconsumers
@managedattribute description
public int getconcurrentconsumers
return concurrentconsumers
public waitfortasktocomplete getwaitfortasktocomplete
return waitfortasktocomplete
public void setwaitfortasktocomplete waitfortasktocomplete waitfortasktocomplete
this waitfortasktocomplete   waitfortasktocomplete
@managedattribute
public long gettimeout
return timeout
public void settimeout long timeout
this timeout   timeout
@managedattribute
public boolean ismultipleconsumers
return multipleconsumers
public void setmultipleconsumers boolean multipleconsumers
this multipleconsumers   multipleconsumers
@managedattribute
public int getpolltimeout
return polltimeout
public void setpolltimeout int polltimeout
this polltimeout   polltimeout
public boolean issingleton
return true
/**
* returns the current pending exchanges
*/
public list<exchange> getexchanges
return new arraylist<exchange> getqueue
@managedattribute
public boolean ismultipleconsumerssupported
return ismultipleconsumers
/**
* purges the queue
*/
@managedoperation description
public void purgequeue
queue clear
/**
* returns the current active consumers on this endpoint
*/
public set<sedaconsumer> getconsumers
return new hashset<sedaconsumer> consumers
/**
* returns the current active producers on this endpoint
*/
public set<sedaproducer> getproducers
return new hashset<sedaproducer> producers
@managedoperation description
public long queuesize
return getexchanges   size
@managedoperation description
public string browseexchange integer index
list<exchange> exchanges   getexchanges
if  index >  exchanges size
return null
exchange exchange   exchanges get index
if  exchange    null
return null
// must use java type with jmx such as java.lang.string
return exchange tostring
@managedoperation description
public string browsemessagebody integer index
list<exchange> exchanges   getexchanges
if  index >  exchanges size
return null
exchange exchange   exchanges get index
if  exchange    null
return null
// must use java type with jmx such as java.lang.string
string body
if  exchange hasout
body   exchange getout   getbody string class
else
body   exchange getin   getbody string class
return body
@managedoperation description
public string browsemessageasxml integer index  boolean includebody
list<exchange> exchanges   getexchanges
if  index >  exchanges size
return null
exchange exchange   exchanges get index
if  exchange    null
return null
message msg   exchange hasout   ? exchange getout     exchange getin
string xml   messagehelper dumpasxml msg  includebody
return xml
@managedoperation description
public string browseallmessagesasxml boolean includebody
return browserangemessagesasxml 0  integer max_value  includebody
@managedoperation description
public string browserangemessagesasxml integer fromindex  integer toindex  boolean includebody
return endpointhelper browserangemessagesasxml this  fromindex  toindex  includebody
void onstarted sedaproducer producer
producers add producer
void onstopped sedaproducer producer
producers remove producer
void onstarted sedaconsumer consumer  throws exception
consumers add consumer
if  ismultipleconsumers
updatemulticastprocessor
void onstopped sedaconsumer consumer  throws exception
consumers remove consumer
if  ismultipleconsumers
updatemulticastprocessor
@override
protected void dostart   throws exception
super dostart
// special for unit testing where we can set a system property to make seda poll faster
// and therefore also react faster upon shutdown, which makes overall testing faster of the camel project
string override   system getproperty        getpolltimeout
setpolltimeout integer valueof override
@override
protected void doshutdown   throws exception
// notify component we are shutting down this endpoint
if  getcomponent      null
getcomponent   onshutdownendpoint this
// shutdown thread pool if it was in use
if  multicastexecutor    null
getcamelcontext   getexecutorservicemanager   shutdownnow multicastexecutor
multicastexecutor   null
// clear queue, as we are shutdown, so if re-created then the queue must be updated
queue   null
super doshutdown