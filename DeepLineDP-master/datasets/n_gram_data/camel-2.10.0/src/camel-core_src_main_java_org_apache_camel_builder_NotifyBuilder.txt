/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel builder
import java util arraylist
import java util arrays
import java util eventobject
import java util list
import java util concurrent countdownlatch
import java util concurrent timeunit
import org apache camel camelcontext
import org apache camel endpoint
import org apache camel exchange
import org apache camel expression
import org apache camel predicate
import org apache camel producer
import org apache camel component direct directendpoint
import org apache camel component mock mockendpoint
import org apache camel management event exchangecompletedevent
import org apache camel management event exchangecreatedevent
import org apache camel management event exchangefailedevent
import org apache camel management event exchangesentevent
import org apache camel spi eventnotifier
import org apache camel support eventnotifiersupport
import org apache camel util endpointhelper
import org apache camel util objecthelper
import org apache camel util servicehelper
import org slf4j logger
import org slf4j loggerfactory
/**
* a builder to build an expression based on {@link org.apache.camel.spi.eventnotifier} notifications
* about {@link exchange} being routed.
* <p/>
* this builder can be used for testing purposes where you want to know when a test is supposed to be done.
* the idea is that you can build an expression that explains when the test is done. for example when camel
* have finished routing 5 messages. you can then in your test await for this condition to occur.
*
* @version
*/
public class notifybuilder
private static final logger log   loggerfactory getlogger notifybuilder class
private final camelcontext context
// notifier to hook into camel to listen for events
private final eventnotifier eventnotifier
// the predicates build with this builder
private final list<eventpredicateholder> predicates   new arraylist<eventpredicateholder>
// latch to be used to signal predicates matches
private countdownlatch latch   new countdownlatch 1
// the current state while building an event predicate where we use a stack and the operation
private final list<eventpredicate> stack   new arraylist<eventpredicate>
private eventoperation operation
private boolean created
// keep state of how many weresentto we have added
private int weresenttoindex
// computed value whether all the predicates matched
private boolean matches
/**
* creates a new builder.
*
* @param context the camel context
*/
public notifybuilder camelcontext context
this context   context
eventnotifier   new exchangenotifier
try
servicehelper startservice eventnotifier
catch  exception e
throw objecthelper wrapruntimecamelexception e
context getmanagementstrategy   addeventnotifier eventnotifier
/**
* optionally a <tt>from</tt> endpoint which means that this expression should only be based
* on {@link exchange} which is originated from the particular endpoint(s).
*
* @param endpointuri uri of endpoint or pattern (see the endpointhelper javadoc)
* @return the builder
* @see org.apache.camel.util.endpointhelper#matchendpoint(org.apache.camel.camelcontext, string, string)
*/
public notifybuilder from final string endpointuri
stack add new eventpredicatesupport
@override
public boolean isabstract
// is abstract as its a filter
return true
@override
public boolean onexchange exchange exchange
// filter non matching exchanges
return endpointhelper matchendpoint context  exchange getfromendpoint   getendpointuri    endpointuri
public boolean matches
// should be true as we use the onexchange to filter
return true
@override
public string tostring
return     endpointuri
return this
/**
* optionally a <tt>from</tt> route which means that this expression should only be based
* on {@link exchange} which is originated from the particular route(s).
*
* @param routeid id of route or pattern (see the endpointhelper javadoc)
* @return the builder
* @see org.apache.camel.util.endpointhelper#matchendpoint(org.apache.camel.camelcontext, string, string)
*/
public notifybuilder fromroute final string routeid
stack add new eventpredicatesupport
@override
public boolean isabstract
// is abstract as its a filter
return true
@override
public boolean onexchange exchange exchange
string id   endpointhelper getrouteidfromendpoint exchange getfromendpoint
// filter non matching exchanges
return endpointhelper matchpattern id  routeid
public boolean matches
// should be true as we use the onexchange to filter
return true
@override
public string tostring
return     routeid
return this
private notifybuilder fromroutesonly
// internal and should always be in top of stack
stack add 0  new eventpredicatesupport
@override
public boolean isabstract
// is abstract as its a filter
return true
@override
public boolean onexchange exchange exchange
// always accept direct endpoints as they are a special case as it will create the uow beforehand
// and just continue to route that on the consumer side, which causes the eventnotifier not to
// emit events when the consumer received the exchange, as its already done. for example by
// producertemplate which creates the uow before producing messages.
if  exchange getfromendpoint      null    exchange getfromendpoint   instanceof directendpoint
return true
return endpointhelper matchpattern exchange getfromrouteid
public boolean matches
// should be true as we use the onexchange to filter
return true
@override
public string tostring
// we dont want any to string output as this is an internal predicate to match only from routes
return
return this
/**
* optionally a filter to only allow matching {@link exchange} to be used for matching.
*
* @param predicate the predicate to use for the filter
* @return the builder
*/
public notifybuilder filter final predicate predicate
stack add new eventpredicatesupport
@override
public boolean isabstract
// is abstract as its a filter
return true
@override
public boolean onexchange exchange exchange
// filter non matching exchanges
return predicate matches exchange
public boolean matches
// should be true as we use the onexchange to filter
return true
@override
public string tostring
return     predicate
return this
/**
* optionally a filter to only allow matching {@link exchange} to be used for matching.
*
* @return the builder
*/
public expressionclausesupport<notifybuilder> filter
final expressionclausesupport<notifybuilder> clause   new expressionclausesupport<notifybuilder> this
stack add new eventpredicatesupport
@override
public boolean isabstract
// is abstract as its a filter
return true
@override
public boolean onexchange exchange exchange
// filter non matching exchanges
expression exp   clause createexpression exchange getcontext
return exp evaluate exchange  boolean class
public boolean matches
// should be true as we use the onexchange to filter
return true
@override
public string tostring
return     clause
return clause
/**
* optionally a <tt>sent to</tt> endpoint which means that this expression should only be based
* on {@link exchange} which has been sent to the given endpoint uri.
* <p/>
* notice the {@link exchange} may have been sent to other endpoints as well. this condition will match
* if the {@link exchange} has been sent at least once to the given endpoint.
*
* @param endpointuri uri of endpoint or pattern (see the endpointhelper javadoc)
* @return the builder
* @see org.apache.camel.util.endpointhelper#matchendpoint(org.apache.camel.camelcontext, string, string)
*/
public notifybuilder weresentto final string endpointuri
// insert in start of stack but after the previous weresentto
stack add weresenttoindex    new eventpredicatesupport
private boolean sentto
@override
public boolean isabstract
// is abstract as its a filter
return true
@override
public boolean onexchangecreated exchange exchange
// reset when a new exchange is created
sentto   false
return onexchange exchange
@override
public boolean onexchangesent exchange exchange  endpoint endpoint  long timetaken
if  endpointhelper matchendpoint context  endpoint getendpointuri    endpointuri
sentto   true
return onexchange exchange
@override
public boolean onexchange exchange exchange
// filter only when sentto
return sentto
public boolean matches
// should be true as we use the onexchange to filter
return true
@override
public void reset
sentto   false
@override
public string tostring
return     endpointuri
return this
/**
* sets a condition when <tt>number</tt> of {@link exchange} has been received.
* <p/>
* the number matching is <i>at least</i> based which means that if more messages received
* it will match also.
*
* @param number at least number of messages
* @return the builder
*/
public notifybuilder whenreceived final int number
stack add new eventpredicatesupport
private int current
@override
public boolean onexchangecreated exchange exchange
current
return true
public boolean matches
return current >  number
@override
public void reset
current   0
@override
public string tostring
return     number
return this
/**
* sets a condition when <tt>number</tt> of {@link exchange} is done being processed.
* <p/>
* the number matching is <i>at least</i> based which means that if more messages received
* it will match also.
* <p/>
* the difference between <i>done</i> and <i>completed</i> is that done can also include failed
* messages, where as completed is only successful processed messages.
*
* @param number at least number of messages
* @return the builder
*/
public notifybuilder whendone final int number
stack add new eventpredicatesupport
private int current
@override
public boolean onexchangecompleted exchange exchange
current
return true
@override
public boolean onexchangefailed exchange exchange
current
return true
public boolean matches
return current >  number
@override
public void reset
current   0
@override
public string tostring
return     number
return this
/**
* sets a condition when tne <tt>n'th</tt> (by index) {@link exchange} is done being processed.
* <p/>
* the difference between <i>done</i> and <i>completed</i> is that done can also include failed
* messages, where as completed is only successful processed messages.
*
* @param index the message by index to be done
* @return the builder
*/
public notifybuilder whendonebyindex final int index
stack add new eventpredicatesupport
private int current
private string id
private boolean done
@override
public boolean onexchangecreated exchange exchange
if  current    index
id   exchange getexchangeid
current
return true
@override
public boolean onexchangecompleted exchange exchange
if  exchange getexchangeid   equals id
done   true
return true
@override
public boolean onexchangefailed exchange exchange
if  exchange getexchangeid   equals id
done   true
return true
public boolean matches
return done
@override
public void reset
current   0
id   null
done   false
@override
public string tostring
return     index
return this
/**
* sets a condition when <tt>number</tt> of {@link exchange} has been completed.
* <p/>
* the number matching is <i>at least</i> based which means that if more messages received
* it will match also.
* <p/>
* the difference between <i>done</i> and <i>completed</i> is that done can also include failed
* messages, where as completed is only successful processed messages.
*
* @param number at least number of messages
* @return the builder
*/
public notifybuilder whencompleted final int number
stack add new eventpredicatesupport
private int current
@override
public boolean onexchangecompleted exchange exchange
current
return true
public boolean matches
return current >  number
@override
public void reset
current   0
@override
public string tostring
return     number
return this
/**
* sets a condition when <tt>number</tt> of {@link exchange} has failed.
* <p/>
* the number matching is <i>at least</i> based which means that if more messages received
* it will match also.
*
* @param number at least number of messages
* @return the builder
*/
public notifybuilder whenfailed final int number
stack add new eventpredicatesupport
private int current
@override
public boolean onexchangefailed exchange exchange
current
return true
public boolean matches
return current >  number
@override
public void reset
current   0
@override
public string tostring
return     number
return this
/**
* sets a condition when <tt>number</tt> of {@link exchange} is done being processed.
* <p/>
* messages, where as completed is only successful processed messages.
*
* @param number exactly number of messages
* @return the builder
*/
public notifybuilder whenexactlydone final int number
stack add new eventpredicatesupport
private int current
@override
public boolean onexchangecompleted exchange exchange
current
return true
@override
public boolean onexchangefailed exchange exchange
current
return true
public boolean matches
return current    number
@override
public void reset
current   0
@override
public string tostring
return     number
return this
/**
* sets a condition when <tt>number</tt> of {@link exchange} has been completed.
* <p/>
* the difference between <i>done</i> and <i>completed</i> is that done can also include failed
* messages, where as completed is only successful processed messages.
*
* @param number exactly number of messages
* @return the builder
*/
public notifybuilder whenexactlycompleted final int number
stack add new eventpredicatesupport
private int current
@override
public boolean onexchangecompleted exchange exchange
current
return true
public boolean matches
return current    number
@override
public void reset
current   0
@override
public string tostring
return     number
return this
/**
* sets a condition when <tt>number</tt> of {@link exchange} has failed.
*
* @param number exactly number of messages
* @return the builder
*/
public notifybuilder whenexactlyfailed final int number
stack add new eventpredicatesupport
private int current
@override
public boolean onexchangefailed exchange exchange
current
return true
public boolean matches
return current    number
@override
public void reset
current   0
@override
public string tostring
return     number
return this
/**
* sets a condition that <b>any received</b> {@link exchange} should match the {@link predicate}
*
* @param predicate the predicate
* @return the builder
*/
public notifybuilder whenanyreceivedmatches final predicate predicate
return dowhenanymatches predicate  true
/**
* sets a condition that <b>any done</b> {@link exchange} should match the {@link predicate}
*
* @param predicate the predicate
* @return the builder
*/
public notifybuilder whenanydonematches final predicate predicate
return dowhenanymatches predicate  false
private notifybuilder dowhenanymatches final predicate predicate  final boolean received
stack add new eventpredicatesupport
private boolean matches
@override
public boolean onexchangecompleted exchange exchange
if   received     matches
matches   predicate matches exchange
return true
@override
public boolean onexchangefailed exchange exchange
if   received     matches
matches   predicate matches exchange
return true
@override
public boolean onexchangecreated exchange exchange
if  received     matches
matches   predicate matches exchange
return true
public boolean matches
return matches
@override
public void reset
matches   false
@override
public string tostring
if  received
return     predicate
else
return     predicate
return this
/**
* sets a condition that <b>all received</b> {@link exchange} should match the {@link predicate}
*
* @param predicate the predicate
* @return the builder
*/
public notifybuilder whenallreceivedmatches final predicate predicate
return dowhenallmatches predicate  true
/**
* sets a condition that <b>all done</b> {@link exchange} should match the {@link predicate}
*
* @param predicate the predicate
* @return the builder
*/
public notifybuilder whenalldonematches final predicate predicate
return dowhenallmatches predicate  false
private notifybuilder dowhenallmatches final predicate predicate  final boolean received
stack add new eventpredicatesupport
private boolean matches   true
@override
public boolean onexchangecompleted exchange exchange
if   received    matches
matches   predicate matches exchange
return true
@override
public boolean onexchangefailed exchange exchange
if   received    matches
matches   predicate matches exchange
return true
@override
public boolean onexchangecreated exchange exchange
if  received    matches
matches   predicate matches exchange
return true
public boolean matches
return matches
@override
public void reset
matches   true
@override
public string tostring
if  received
return     predicate
else
return     predicate
return this
/**
* sets a condition when the provided mock is satisfied based on {@link exchange}
* being sent to it when they are <b>done</b>.
* <p/>
* the idea is that you can use mock for setting fine grained expectations
* and then use that together with this builder. the mock provided does <b>not</b>
* have to already exist in the route. you can just create a new pseudo mock
* and this builder will send the done {@link exchange} to it. so its like
* adding the mock to the end of your route(s).
*
* @param mock the mock
* @return the builder
*/
public notifybuilder whendonesatisfied final mockendpoint mock
return dowhensatisfied mock  false
/**
* sets a condition when the provided mock is satisfied based on {@link exchange}
* being sent to it when they are <b>received</b>.
* <p/>
* the idea is that you can use mock for setting fine grained expectations
* and then use that together with this builder. the mock provided does <b>not</b>
* have to already exist in the route. you can just create a new pseudo mock
* and this builder will send the done {@link exchange} to it. so its like
* adding the mock to the end of your route(s).
*
* @param mock the mock
* @return the builder
*/
public notifybuilder whenreceivedsatisfied final mockendpoint mock
return dowhensatisfied mock  true
private notifybuilder dowhensatisfied final mockendpoint mock  final boolean received
stack add new eventpredicatesupport
private producer producer
@override
public boolean onexchangecreated exchange exchange
if  received
sendtomock exchange
return true
@override
public boolean onexchangefailed exchange exchange
if   received
sendtomock exchange
return true
@override
public boolean onexchangecompleted exchange exchange
if   received
sendtomock exchange
return true
private void sendtomock exchange exchange
// send the exchange when its completed to the mock
try
if  producer    null
producer   mock createproducer
producer process exchange
catch  exception e
throw objecthelper wrapruntimecamelexception e
public boolean matches
try
return mock await 0  timeunit seconds
catch  interruptedexception e
throw objecthelper wrapruntimecamelexception e
@override
public void reset
mock reset
@override
public string tostring
if  received
return     mock
else
return     mock
return this
/**
* sets a condition when the provided mock is <b>not</b> satisfied based on {@link exchange}
* being sent to it when they are <b>received</b>.
* <p/>
* the idea is that you can use mock for setting fine grained expectations
* and then use that together with this builder. the mock provided does <b>not</b>
* have to already exist in the route. you can just create a new pseudo mock
* and this builder will send the done {@link exchange} to it. so its like
* adding the mock to the end of your route(s).
*
* @param mock the mock
* @return the builder
*/
public notifybuilder whenreceivednotsatisfied final mockendpoint mock
return dowhennotsatisfied mock  true
/**
* sets a condition when the provided mock is <b>not</b> satisfied based on {@link exchange}
* being sent to it when they are <b>done</b>.
* <p/>
* the idea is that you can use mock for setting fine grained expectations
* and then use that together with this builder. the mock provided does <b>not</b>
* have to already exist in the route. you can just create a new pseudo mock
* and this builder will send the done {@link exchange} to it. so its like
* adding the mock to the end of your route(s).
*
* @param mock the mock
* @return the builder
*/
public notifybuilder whendonenotsatisfied final mockendpoint mock
return dowhennotsatisfied mock  false
private notifybuilder dowhennotsatisfied final mockendpoint mock  final boolean received
stack add new eventpredicatesupport
private producer producer
@override
public boolean onexchangecreated exchange exchange
if  received
sendtomock exchange
return true
@override
public boolean onexchangefailed exchange exchange
if   received
sendtomock exchange
return true
@override
public boolean onexchangecompleted exchange exchange
if   received
sendtomock exchange
return true
private void sendtomock exchange exchange
// send the exchange when its completed to the mock
try
if  producer    null
producer   mock createproducer
producer process exchange
catch  exception e
throw objecthelper wrapruntimecamelexception e
public boolean matches
try
return  mock await 0  timeunit seconds
catch  interruptedexception e
throw objecthelper wrapruntimecamelexception e
@override
public void reset
mock reset
@override
public string tostring
if  received
return     mock
else
return     mock
return this
/**
* sets a condition that the bodies is expected to be <b>received</b> in the order as well.
* <p/>
* this condition will discard any additional messages. if you need a more strict condition
* then use {@link #whenexactbodiesreceived(object...)}
*
* @param bodies the expected bodies
* @return the builder
* @see #whenexactbodiesreceived(object...)
*/
public notifybuilder whenbodiesreceived object    bodies
list<object> bodylist   new arraylist<object>
bodylist addall arrays aslist bodies
return dowhenbodies bodylist  true  false
/**
* sets a condition that the bodies is expected to be <b>done</b> in the order as well.
* <p/>
* this condition will discard any additional messages. if you need a more strict condition
* then use {@link #whenexactbodiesdone(object...)}
*
* @param bodies the expected bodies
* @return the builder
* @see #whenexactbodiesdone(object...)
*/
public notifybuilder whenbodiesdone object    bodies
list<object> bodylist   new arraylist<object>
bodylist addall arrays aslist bodies
return dowhenbodies bodylist  false  false
/**
* sets a condition that the bodies is expected to be <b>received</b> in the order as well.
* <p/>
* this condition is strict which means that it only expect that exact number of bodies
*
* @param bodies the expected bodies
* @return the builder
* @see #whenbodiesreceived(object...)
*/
public notifybuilder whenexactbodiesreceived object    bodies
list<object> bodylist   new arraylist<object>
bodylist addall arrays aslist bodies
return dowhenbodies bodylist  true  true
/**
* sets a condition that the bodies is expected to be <b>done</b> in the order as well.
* <p/>
* this condition is strict which means that it only expect that exact number of bodies
*
* @param bodies the expected bodies
* @return the builder
* @see #whenexactbodiesdone(object...)
*/
public notifybuilder whenexactbodiesdone object    bodies
list<object> bodylist   new arraylist<object>
bodylist addall arrays aslist bodies
return dowhenbodies bodylist  false  true
private notifybuilder dowhenbodies final list<?> bodies  final boolean received  final boolean exact
stack add new eventpredicatesupport
private boolean matches
private int current
@override
public boolean onexchangecreated exchange exchange
if  received
matchbody exchange
return true
@override
public boolean onexchangefailed exchange exchange
if   received
matchbody exchange
return true
@override
public boolean onexchangecompleted exchange exchange
if   received
matchbody exchange
return true
private void matchbody exchange exchange
current
if  current > bodies size
// out of bounds
return
object actual   exchange getin   getbody
object expected   bodies get current   1
matches   objecthelper equal expected  actual
public boolean matches
if  exact
return matches    current    bodies size
else
return matches    current >  bodies size
@override
public void reset
matches   false
current   0
@override
public string tostring
if  received
return      exact ?          bodies
else
return      exact ?          bodies
return this
/**
* prepares to append an additional expression using the <i>and</i> operator.
*
* @return the builder
*/
public notifybuilder and
docreate eventoperation and
return this
/**
* prepares to append an additional expression using the <i>or</i> operator.
*
* @return the builder
*/
public notifybuilder or
docreate eventoperation or
return this
/**
* prepares to append an additional expression using the <i>not</i> operator.
*
* @return the builder
*/
public notifybuilder not
docreate eventoperation not
return this
/**
* creates the expression this builder should use for matching.
* <p/>
* you must call this method when you are finished building the expressions.
*
* @return the created builder ready for matching
*/
public notifybuilder create
docreate eventoperation and
created   true
return this
/**
* does all the expression match?
* <p/>
* this operation will return immediately which means it can be used for testing at this very moment.
*
* @return <tt>true</tt> if matching, <tt>false</tt> otherwise
*/
public boolean matches
if   created
throw new illegalstateexception
return matches
/**
* does all the expression match?
* <p/>
* this operation will wait until the match is <tt>true</tt> or otherwise a timeout occur
* which means <tt>false</tt> will be returned.
*
* @param timeout  the timeout value
* @param timeunit the time unit
* @return <tt>true</tt> if matching, <tt>false</tt> otherwise due to timeout
*/
public boolean matches long timeout  timeunit timeunit
if   created
throw new illegalstateexception
try
latch await timeout  timeunit
catch  interruptedexception e
throw objecthelper wrapruntimecamelexception e
return matches
/**
* does all the expression match?
* <p/>
* this operation will wait until the match is <tt>true</tt> or otherwise a timeout occur
* which means <tt>false</tt> will be returned.
* <p/>
* the timeout value is by default 10 seconds. but it will use the highest <i>maximum result wait time</i>
* from the configured mocks, if such a value has been configured.
* <p/>
* this method is convenient to use in unit tests to have it adhere and wait
* as long as the mock endpoints.
*
* @return <tt>true</tt> if matching, <tt>false</tt> otherwise due to timeout
*/
public boolean matchesmockwaittime
if   created
throw new illegalstateexception
long timeout   0
for  endpoint endpoint   context getendpoints
if  endpoint instanceof mockendpoint
long waittime     mockendpoint  endpoint  getresultwaittime
if  waittime > 0
timeout   math max timeout  waittime
// use 10 sec as default
if  timeout    0
timeout   10000
return matches timeout  timeunit milliseconds
/**
* resets the notifier.
*/
public void reset
for  eventpredicateholder predicate   predicates
predicate reset
latch   new countdownlatch 1
matches   false
@override
public string tostring
stringbuilder sb   new stringbuilder
for  eventpredicateholder eventpredicateholder   predicates
if  sb length   > 0
sb append
sb append eventpredicateholder tostring
// a crude way of skipping the first invisible operation
return objecthelper after sb tostring
private void docreate eventoperation newoperation
// init operation depending on the newoperation
if  operation    null
// if the first new operation is an or then this operation must be an or as well
// otherwise it should be and based
operation   newoperation    eventoperation or ? eventoperation or   eventoperation and
// we have some predicates
if   stack isempty
// we only want to match from routes, so skip for example events
// which is triggered by producer templates etc.
fromroutesonly
// the stack must have at least one non abstract
boolean found   false
for  eventpredicate predicate   stack
if   predicate isabstract
found   true
break
if   found
throw new illegalargumentexception
compoundeventpredicate compound   new compoundeventpredicate stack
stack clear
predicates add new eventpredicateholder operation  compound
operation   newoperation
// reset weresentto index position as this its a new group
weresenttoindex   0
/**
* notifier which hooks into camel to listen for {@link exchange} relevant events for this builder
*/
private final class exchangenotifier extends eventnotifiersupport
public void notify eventobject event  throws exception
if  event instanceof exchangecreatedevent
onexchangecreated  exchangecreatedevent  event
else if  event instanceof exchangecompletedevent
onexchangecompleted  exchangecompletedevent  event
else if  event instanceof exchangefailedevent
onexchangefailed  exchangefailedevent  event
else if  event instanceof exchangesentevent
onexchangesent  exchangesentevent  event
// now compute whether we matched
computematches
public boolean isenabled eventobject event
return true
private void onexchangecreated exchangecreatedevent event
for  eventpredicateholder predicate   predicates
predicate getpredicate   onexchangecreated event getexchange
private void onexchangecompleted exchangecompletedevent event
for  eventpredicateholder predicate   predicates
predicate getpredicate   onexchangecompleted event getexchange
private void onexchangefailed exchangefailedevent event
for  eventpredicateholder predicate   predicates
predicate getpredicate   onexchangefailed event getexchange
private void onexchangesent exchangesentevent event
for  eventpredicateholder predicate   predicates
predicate getpredicate   onexchangesent event getexchange    event getendpoint    event gettimetaken
private synchronized void computematches
// use a temporary answer until we have computed the value to assign
boolean answer   null
for  eventpredicateholder holder   predicates
eventoperation operation   holder getoperation
if  eventoperation and    operation
if  holder getpredicate   matches
answer   true
else
answer   false
// and break out since its an and so it must match
break
else if  eventoperation or    operation
if  holder getpredicate   matches
answer   true
else if  eventoperation not    operation
if  holder getpredicate   matches
answer   false
// and break out since its a not so it must not match
break
else
answer   true
// if we did compute a value then assign that
if  answer    null
matches   answer
if  matches
// signal completion
latch countdown
@override
protected void dostart   throws exception
// we only care about exchange events
setignorecamelcontextevents true
setignorerouteevents true
setignoreserviceevents true
@override
protected void dostop   throws exception
private enum eventoperation
and  or  not
private interface eventpredicate
/**
* evaluates whether the predicate matched or not.
*
* @return <tt>true</tt> if matched, <tt>false</tt> otherwise
*/
boolean matches
/**
* resets the predicate
*/
void reset
/**
* whether the predicate is abstract
*/
boolean isabstract
/**
* callback for {@link exchange} lifecycle
*
* @param exchange the exchange
* @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately
*/
boolean onexchangecreated exchange exchange
/**
* callback for {@link exchange} lifecycle
*
* @param exchange the exchange
* @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately
*/
boolean onexchangecompleted exchange exchange
/**
* callback for {@link exchange} lifecycle
*
* @param exchange the exchange
* @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately
*/
boolean onexchangefailed exchange exchange
/**
* callback for {@link exchange} lifecycle
*
* @param exchange the exchange
* @param endpoint the endpoint sent to
* @param timetaken time taken in millis to send the to endpoint
* @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately
*/
boolean onexchangesent exchange exchange  endpoint endpoint  long timetaken
private abstract class eventpredicatesupport implements eventpredicate
public boolean isabstract
return false
public void reset
// noop
public boolean onexchangecreated exchange exchange
return onexchange exchange
public boolean onexchangecompleted exchange exchange
return onexchange exchange
public boolean onexchangefailed exchange exchange
return onexchange exchange
public boolean onexchangesent exchange exchange  endpoint endpoint  long timetaken
// no need to invoke onexchange as this is a special case when the exchange
// was sent to a specific endpoint
return true
public boolean onexchange exchange exchange
return true
/**
* to hold an operation and predicate
*/
private final class eventpredicateholder
private final eventoperation operation
private final eventpredicate predicate
private eventpredicateholder eventoperation operation  eventpredicate predicate
this operation   operation
this predicate   predicate
public eventoperation getoperation
return operation
public eventpredicate getpredicate
return predicate
public void reset
predicate reset
@override
public string tostring
return operation name         predicate
/**
* to hold multiple predicates which are part of same expression
*/
private final class compoundeventpredicate implements eventpredicate
private list<eventpredicate> predicates   new arraylist<eventpredicate>
private compoundeventpredicate list<eventpredicate> predicates
this predicates addall predicates
public boolean isabstract
return false
public boolean matches
for  eventpredicate predicate   predicates
boolean answer   predicate matches
log trace    predicate  answer
if   answer
// break at first false
return false
return true
public void reset
for  eventpredicate predicate   predicates
log trace    predicate
predicate reset
public boolean onexchangecreated exchange exchange
for  eventpredicate predicate   predicates
boolean answer   predicate onexchangecreated exchange
log trace    predicate  answer
if   answer
// break at first false
return false
return true
public boolean onexchangecompleted exchange exchange
for  eventpredicate predicate   predicates
boolean answer   predicate onexchangecompleted exchange
log trace    predicate  answer
if   answer
// break at first false
return false
return true
public boolean onexchangefailed exchange exchange
for  eventpredicate predicate   predicates
boolean answer   predicate onexchangefailed exchange
log trace    predicate  answer
if   answer
// break at first false
return false
return true
@override
public boolean onexchangesent exchange exchange  endpoint endpoint  long timetaken
for  eventpredicate predicate   predicates
boolean answer   predicate onexchangesent exchange  endpoint  timetaken
log trace    new object endpoint  predicate  answer
if   answer
// break at first false
return false
return true
@override
public string tostring
stringbuilder sb   new stringbuilder
for  eventpredicate eventpredicate   predicates
if  sb length   > 0
sb append
sb append eventpredicate tostring
return sb tostring