/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component mock
import java io file
import java util arraylist
import java util arrays
import java util collection
import java util date
import java util hashmap
import java util hashset
import java util list
import java util map
import java util set
import java util concurrent concurrenthashmap
import java util concurrent copyonwritearraylist
import java util concurrent countdownlatch
import java util concurrent timeunit
import org apache camel asynccallback
import org apache camel camelcontext
import org apache camel component
import org apache camel consumer
import org apache camel endpoint
import org apache camel exchange
import org apache camel exchangepattern
import org apache camel expression
import org apache camel handler
import org apache camel message
import org apache camel predicate
import org apache camel processor
import org apache camel producer
import org apache camel builder processorbuilder
import org apache camel impl defaultasyncproducer
import org apache camel impl defaultendpoint
import org apache camel impl interceptsendtoendpoint
import org apache camel spi browsableendpoint
import org apache camel util camelcontexthelper
import org apache camel util caseinsensitivemap
import org apache camel util exchangehelper
import org apache camel util expressioncomparator
import org apache camel util fileutil
import org apache camel util objecthelper
import org apache camel util stopwatch
import org slf4j logger
import org slf4j loggerfactory
/**
* a mock endpoint which provides a literate, fluent api for testing routes
* using a <a href="http://jmock.org/">jmock style</a> api.
* <p/>
* the mock endpoint have two set of methods
* <ul>
*   <li>expectedxxx or expectsxxx - to set pre conditions, before the test is executed</li>
*   <li>assertxxx - to assert assertions, after the test has been executed</li>
* </ul>
* its <b>important</b> to know the difference between the two set. the former is used to
* set expectations before the test is being started (eg before the mock receives messages).
* the latter is used after the test has been executed, to verify the expectations; or
* other assertions which you can perform after the test has been completed.
*
* @version
*/
public class mockendpoint extends defaultendpoint implements browsableendpoint
private static final transient logger log   loggerfactory getlogger mockendpoint class
// must be volatile so changes is visible between the thread which performs the assertions
// and the threads which process the exchanges when routing messages in camel
protected volatile processor reporter
protected boolean copyonexchange   true
private volatile int expectedcount
private volatile int counter
private volatile processor defaultprocessor
private volatile map<integer  processor> processors
private volatile list<exchange> receivedexchanges
private volatile list<throwable> failures
private volatile list<runnable> tests
private volatile countdownlatch latch
private volatile long sleepforemptytest
private volatile long resultwaittime
private volatile long resultminimumwaittime
private volatile long assertperiod
private volatile int expectedminimumcount
private volatile list<?> expectedbodyvalues
private volatile list<object> actualbodyvalues
private volatile map<string  object> expectedheadervalues
private volatile map<string  object> actualheadervalues
private volatile map<string  object> expectedpropertyvalues
private volatile map<string  object> actualpropertyvalues
private volatile int retainfirst
private volatile int retainlast
public mockendpoint string endpointuri  component component
super endpointuri  component
init
@deprecated
public mockendpoint string endpointuri
super endpointuri
init
public mockendpoint
this null
/**
* a helper method to resolve the mock endpoint of the given uri on the given context
*
* @param context the camel context to try resolve the mock endpoint from
* @param uri the uri of the endpoint to resolve
* @return the endpoint
*/
public static mockendpoint resolve camelcontext context  string uri
return camelcontexthelper getmandatoryendpoint context  uri  mockendpoint class
public static void assertwait long timeout  timeunit unit  mockendpoint    endpoints  throws interruptedexception
long start   system currenttimemillis
long left   unit tomillis timeout
long end   start   left
for  mockendpoint endpoint   endpoints
if   endpoint await left  timeunit milliseconds
throw new assertionerror     endpoint getendpointuri
left   end   system currenttimemillis
if  left <  0
left   0
public static void assertissatisfied long timeout  timeunit unit  mockendpoint    endpoints  throws interruptedexception
assertwait timeout  unit  endpoints
for  mockendpoint endpoint   endpoints
endpoint assertissatisfied
public static void assertissatisfied mockendpoint    endpoints  throws interruptedexception
for  mockendpoint endpoint   endpoints
endpoint assertissatisfied
/**
* asserts that all the expectations on any {@link mockendpoint} instances registered
* in the given context are valid
*
* @param context the camel context used to find all the available endpoints to be asserted
*/
public static void assertissatisfied camelcontext context  throws interruptedexception
objecthelper notnull context
collection<endpoint> endpoints   context getendpoints
for  endpoint endpoint   endpoints
// if the endpoint was intercepted we should get the delegate
if  endpoint instanceof interceptsendtoendpoint
endpoint     interceptsendtoendpoint  endpoint  getdelegate
if  endpoint instanceof mockendpoint
mockendpoint mockendpoint    mockendpoint  endpoint
mockendpoint assertissatisfied
/**
* asserts that all the expectations on any {@link mockendpoint} instances registered
* in the given context are valid
*
* @param context the camel context used to find all the available endpoints to be asserted
* @param timeout timeout
* @param unit    time unit
*/
public static void assertissatisfied camelcontext context  long timeout  timeunit unit  throws interruptedexception
objecthelper notnull context
objecthelper notnull unit
collection<endpoint> endpoints   context getendpoints
long millis   unit tomillis timeout
for  endpoint endpoint   endpoints
// if the endpoint was intercepted we should get the delegate
if  endpoint instanceof interceptsendtoendpoint
endpoint     interceptsendtoendpoint  endpoint  getdelegate
if  endpoint instanceof mockendpoint
mockendpoint mockendpoint    mockendpoint  endpoint
mockendpoint setresultwaittime millis
mockendpoint assertissatisfied
/**
* sets the assert period on all the expectations on any {@link mockendpoint} instances registered
* in the given context.
*
* @param context the camel context used to find all the available endpoints
* @param period the period in millis
*/
public static void setassertperiod camelcontext context  long period
objecthelper notnull context
collection<endpoint> endpoints   context getendpoints
for  endpoint endpoint   endpoints
// if the endpoint was intercepted we should get the delegate
if  endpoint instanceof interceptsendtoendpoint
endpoint     interceptsendtoendpoint  endpoint  getdelegate
if  endpoint instanceof mockendpoint
mockendpoint mockendpoint    mockendpoint  endpoint
mockendpoint setassertperiod period
/**
* reset all mock endpoints
*
* @param context the camel context used to find all the available endpoints to reset
*/
public static void resetmocks camelcontext context
objecthelper notnull context
collection<endpoint> endpoints   context getendpoints
for  endpoint endpoint   endpoints
// if the endpoint was intercepted we should get the delegate
if  endpoint instanceof interceptsendtoendpoint
endpoint     interceptsendtoendpoint  endpoint  getdelegate
if  endpoint instanceof mockendpoint
mockendpoint mockendpoint    mockendpoint  endpoint
mockendpoint reset
public static void expectsmessagecount int count  mockendpoint    endpoints  throws interruptedexception
for  mockendpoint endpoint   endpoints
endpoint setexpectedmessagecount count
public list<exchange> getexchanges
return getreceivedexchanges
public consumer createconsumer processor processor  throws exception
throw new unsupportedoperationexception
public producer createproducer   throws exception
return new defaultasyncproducer this
public boolean process exchange exchange  asynccallback callback
onexchange exchange
callback done true
return true
public void reset
init
// testing api
// -------------------------------------------------------------------------
/**
* handles the incoming exchange.
* <p/>
* this method turns this mock endpoint into a bean which you can use
* in the camel routes, which allows you to inject mockendpoint as beans
* in your routes and use the features of the mock to control the bean.
*
* @param exchange  the exchange
* @throws exception can be thrown
*/
@handler
public void handle exchange exchange  throws exception
onexchange exchange
/**
* set the processor that will be invoked when the index
* message is received.
*/
public void whenexchangereceived int index  processor processor
this processors put index  processor
/**
* set the processor that will be invoked when the some message
* is received.
*
* this processor could be overwritten by
* {@link #whenexchangereceived(int, processor)} method.
*/
public void whenanyexchangereceived processor processor
this defaultprocessor   processor
/**
* set the expression which value will be set to the message body
* @param expression which is use to set the message body
*/
public void returnreplybody expression expression
this defaultprocessor   processorbuilder setbody expression
/**
* set the expression which value will be set to the message header
* @param headername that will be set value
* @param expression which is use to set the message header
*/
public void returnreplyheader string headername  expression expression
this defaultprocessor   processorbuilder setheader headername  expression
/**
* validates that all the available expectations on this endpoint are
* satisfied; or throw an exception
*/
public void assertissatisfied   throws interruptedexception
assertissatisfied sleepforemptytest
/**
* validates that all the available expectations on this endpoint are
* satisfied; or throw an exception
*
* @param timeoutforemptyendpoints the timeout in milliseconds that we
*                should wait for the test to be true
*/
public void assertissatisfied long timeoutforemptyendpoints  throws interruptedexception
log info     this
doassertissatisfied timeoutforemptyendpoints
if  assertperiod > 0
// if an assert period was set then re-assert again to ensure the assertion is still valid
thread sleep assertperiod
log info     this       assertperiod
// do not use timeout when we re-assert
doassertissatisfied 0
protected void doassertissatisfied long timeoutforemptyendpoints  throws interruptedexception
if  expectedcount    0
if  timeoutforemptyendpoints > 0
log debug     timeoutforemptyendpoints
thread sleep timeoutforemptyendpoints
assertequals    expectedcount  getreceivedcounter
else if  expectedcount > 0
if  expectedcount    getreceivedcounter
waitforcompletelatch
assertequals    expectedcount  getreceivedcounter
else if  expectedminimumcount > 0    getreceivedcounter   < expectedminimumcount
waitforcompletelatch
if  expectedminimumcount >  0
int receivedcounter   getreceivedcounter
asserttrue     receivedcounter       expectedminimumcount  expectedminimumcount <  receivedcounter
for  runnable test   tests
test run
for  throwable failure   failures
if  failure    null
log error     getendpointuri         failure  failure
fail     failure
/**
* validates that the assertions fail on this endpoint
*/
public void assertisnotsatisfied   throws interruptedexception
boolean failed   false
try
assertissatisfied
// did not throw expected error... fail!
failed   true
catch  assertionerror e
log info     e
if  failed
// fail() throws the assertionerror to indicate the test failed.
fail
/**
* validates that the assertions fail on this endpoint
* @param timeoutforemptyendpoints the timeout in milliseconds that we
*        should wait for the test to be true
*/
public void assertisnotsatisfied long timeoutforemptyendpoints  throws interruptedexception
boolean failed   false
try
assertissatisfied timeoutforemptyendpoints
// did not throw expected error... fail!
failed   true
catch  assertionerror e
log info     e
if  failed
// fail() throws the assertionerror to indicate the test failed.
fail
/**
* specifies the expected number of message exchanges that should be
* received by this endpoint
*
* @param expectedcount the number of message exchanges that should be
*                expected by this endpoint
*/
public void expectedmessagecount int expectedcount
setexpectedmessagecount expectedcount
/**
* sets a grace period after which the mock endpoint will re-assert
* to ensure the preliminary assertion is still valid.
* <p/>
* this is used for example to assert that <b>exactly</b> a number of messages
* arrives. for example if {@link #expectedmessagecount(int)} was set to 5, then
* the assertion is satisfied when 5 or more message arrives. to ensure that
* exactly 5 messages arrives, then you would need to wait a little period
* to ensure no further message arrives. this is what you can use this
* {@link #setassertperiod(long)} method for.
* <p/>
* by default this period is disabled.
*
* @param period grace period in millis
*/
public void setassertperiod long period
this assertperiod   period
/**
* specifies the minimum number of expected message exchanges that should be
* received by this endpoint
*
* @param expectedcount the number of message exchanges that should be
*                expected by this endpoint
*/
public void expectedminimummessagecount int expectedcount
setminimumexpectedmessagecount expectedcount
/**
* sets an expectation that the given header name & value are received by this endpoint
* <p/>
* you can set multiple expectations for different header names.
* if you set a value of <tt>null</tt> that means we accept either the header is absent, or its value is <tt>null</tt>
*/
public void expectedheaderreceived final string name  final object value
if  expectedheadervalues    null
expectedheadervalues   new caseinsensitivemap
expectedheadervalues put name  value
expects new runnable
public void run
for  int i   0  i < getreceivedexchanges   size    i
exchange exchange   getreceivedexchange i
for  map entry<string  object> entry   expectedheadervalues entryset
string key   entry getkey
object expectedvalue   entry getvalue
// we accept that an expectedvalue of null also means that the header may be absent
if  expectedvalue    null
asserttrue     i      exchange getin   hasheaders
boolean haskey   exchange getin   getheaders   containskey key
asserttrue     key       i  haskey
object actualvalue   exchange getin   getheader key
actualvalue   extractactualvalue exchange  actualvalue  expectedvalue
assertequals     key       i  expectedvalue  actualvalue
/**
* sets an expectation that the given property name & value are received by this endpoint
* <p/>
* you can set multiple expectations for different property names.
* if you set a value of <tt>null</tt> that means we accept either the property is absent, or its value is <tt>null</tt>
*/
public void expectedpropertyreceived final string name  final object value
if  expectedpropertyvalues    null
expectedpropertyvalues   new concurrenthashmap<string  object>
if  value    null
// concurrenthashmap cannot store null values
expectedpropertyvalues put name  value
expects new runnable
public void run
for  int i   0  i < getreceivedexchanges   size    i
exchange exchange   getreceivedexchange i
for  map entry<string  object> entry   expectedpropertyvalues entryset
string key   entry getkey
object expectedvalue   entry getvalue
// we accept that an expectedvalue of null also means that the header may be absent
if  expectedvalue    null
asserttrue     i       exchange getproperties   isempty
boolean haskey   exchange getproperties   containskey key
asserttrue     key       i  haskey
object actualvalue   exchange getproperty key
actualvalue   extractactualvalue exchange  actualvalue  expectedvalue
assertequals     key       i  expectedvalue  actualvalue
/**
* adds an expectation that the given body values are received by this
* endpoint in the specified order
*/
public void expectedbodiesreceived final list<?> bodies
expectedmessagecount bodies size
this expectedbodyvalues   bodies
this actualbodyvalues   new arraylist<object>
expects new runnable
public void run
for  int i   0  i < expectedbodyvalues size    i
exchange exchange   getreceivedexchange i
asserttrue     i  exchange    null
object expectedbody   expectedbodyvalues get i
object actualbody   null
if  i < actualbodyvalues size
actualbody   actualbodyvalues get i
actualbody   extractactualvalue exchange  actualbody  expectedbody
assertequals     i  expectedbody  actualbody
private object extractactualvalue exchange exchange  object actualvalue  object expectedvalue
if  actualvalue    null
return null
if  actualvalue instanceof expression
actualvalue     expression actualvalue  evaluate exchange  expectedvalue    null ? expectedvalue getclass     object class
else if  actualvalue instanceof predicate
actualvalue     predicate actualvalue  matches exchange
else if  expectedvalue    null
string from   actualvalue getclass   getname
string to   expectedvalue getclass   getname
actualvalue   getcamelcontext   gettypeconverter   convertto expectedvalue getclass    actualvalue
asserttrue     from       to  actualvalue    null
return actualvalue
/**
* sets an expectation that the given predicates matches the received messages by this endpoint
*/
public void expectedmessagesmatches predicate    predicates
for  int i   0  i < predicates length  i
final int messageindex   i
final predicate predicate   predicates
final assertionclause clause   new assertionclause this
public void run
addpredicate predicate
applyassertionon mockendpoint this  messageindex  assertexchangereceived messageindex
expects clause
/**
* sets an expectation that the given body values are received by this endpoint
*/
public void expectedbodiesreceived object    bodies
list<object> bodylist   new arraylist<object>
bodylist addall arrays aslist bodies
expectedbodiesreceived bodylist
/**
* adds an expectation that the given body value are received by this endpoint
*/
public assertionclause expectedbodyreceived
expectedmessagecount 1
final assertionclause clause   new assertionclause this
public void run
exchange exchange   getreceivedexchange 0
asserttrue     0  exchange    null
object actualbody   exchange getin   getbody
expression exp   createexpression getcamelcontext
object expectedbody   exp evaluate exchange  object class
assertequals     0  expectedbody  actualbody
expects clause
return clause
/**
* adds an expectation that the given body values are received by this
* endpoint in any order
*/
public void expectedbodiesreceivedinanyorder final list<?> bodies
expectedmessagecount bodies size
this expectedbodyvalues   bodies
this actualbodyvalues   new arraylist<object>
expects new runnable
public void run
set<object> actualbodyvaluesset   new hashset<object> actualbodyvalues
for  int i   0  i < expectedbodyvalues size    i
exchange exchange   getreceivedexchange i
asserttrue     i  exchange    null
object expectedbody   expectedbodyvalues get i
asserttrue     expectedbody
actualbodyvaluesset
actualbodyvaluesset remove expectedbody
/**
* adds an expectation that the given body values are received by this
* endpoint in any order
*/
public void expectedbodiesreceivedinanyorder object    bodies
list<object> bodylist   new arraylist<object>
bodylist addall arrays aslist bodies
expectedbodiesreceivedinanyorder bodylist
/**
* adds an expectation that a file exists with the given name
*
* @param name name of file, will cater for / and \ on different os platforms
*/
public void expectedfileexists final string name
expectedfileexists name  null
/**
* adds an expectation that a file exists with the given name
* <p/>
* will wait at most 5 seconds while checking for the existence of the file.
*
* @param name name of file, will cater for / and \ on different os platforms
* @param content content of file to compare, can be <tt>null</tt> to not compare content
*/
public void expectedfileexists final string name  final string content
final file file   new file fileutil normalizepath name   getabsolutefile
expects new runnable
public void run
// wait at most 5 seconds for the file to exists
final long timeout   system currenttimemillis     5000
boolean stop   false
while   stop     file exists
try
thread sleep 50
catch  interruptedexception e
// ignore
stop   system currenttimemillis   > timeout
asserttrue     name  file exists
if  content    null
string body   getcamelcontext   gettypeconverter   convertto string class  file
assertequals     name  content  body
/**
* adds an expectation that messages received should have the given exchange pattern
*/
public void expectedexchangepattern final exchangepattern exchangepattern
expectedmessagesmatches new predicate
public boolean matches exchange exchange
return exchange getpattern   equals exchangepattern
/**
* adds an expectation that messages received should have ascending values
* of the given expression such as a user generated counter value
*/
public void expectsascending final expression expression
expects new runnable
public void run
assertmessagesascending expression
/**
* adds an expectation that messages received should have ascending values
* of the given expression such as a user generated counter value
*/
public assertionclause expectsascending
final assertionclause clause   new assertionclause this
public void run
assertmessagesascending createexpression getcamelcontext
expects clause
return clause
/**
* adds an expectation that messages received should have descending values
* of the given expression such as a user generated counter value
*/
public void expectsdescending final expression expression
expects new runnable
public void run
assertmessagesdescending expression
/**
* adds an expectation that messages received should have descending values
* of the given expression such as a user generated counter value
*/
public assertionclause expectsdescending
final assertionclause clause   new assertionclause this
public void run
assertmessagesdescending createexpression getcamelcontext
expects clause
return clause
/**
* adds an expectation that no duplicate messages should be received using
* the expression to determine the message id
*
* @param expression the expression used to create a unique message id for
*                message comparison (which could just be the message
*                payload if the payload can be tested for uniqueness using
*                {@link object#equals(object)} and
*                {@link object#hashcode()}
*/
public void expectsnoduplicates final expression expression
expects new runnable
public void run
assertnoduplicates expression
/**
* adds an expectation that no duplicate messages should be received using
* the expression to determine the message id
*/
public assertionclause expectsnoduplicates
final assertionclause clause   new assertionclause this
public void run
assertnoduplicates createexpression getcamelcontext
expects clause
return clause
/**
* asserts that the messages have ascending values of the given expression
*/
public void assertmessagesascending expression expression
assertmessagessorted expression  true
/**
* asserts that the messages have descending values of the given expression
*/
public void assertmessagesdescending expression expression
assertmessagessorted expression  false
protected void assertmessagessorted expression expression  boolean ascending
string type   ascending ?
expressioncomparator comparator   new expressioncomparator expression
list<exchange> list   getreceivedexchanges
for  int i   1  i < list size    i
int j   i   1
exchange e1   list get j
exchange e2   list get i
int result   comparator compare e1  e2
if  result    0
fail     type       j       i
expression evaluate e1  object class        expression       e1       e2
else
if   ascending
result   result    1
if  result > 0
fail     type       j       expression evaluate e1  object class
i       expression evaluate e2  object class
expression       e1       e2
public void assertnoduplicates expression expression
map<object  exchange> map   new hashmap<object  exchange>
list<exchange> list   getreceivedexchanges
for  int i   0  i < list size    i
exchange e2   list get i
object key   expression evaluate e2  object class
exchange e1   map get key
if  e1    null
fail     i       key       expression       e1       e2
else
map put key  e2
/**
* adds the expectation which will be invoked when enough messages are received
*/
public void expects runnable runnable
tests add runnable
/**
* adds an assertion to the given message index
*
* @param messageindex the number of the message
* @return the assertion clause
*/
public assertionclause message final int messageindex
final assertionclause clause   new assertionclause this
public void run
applyassertionon mockendpoint this  messageindex  assertexchangereceived messageindex
expects clause
return clause
/**
* adds an assertion to all the received messages
*
* @return the assertion clause
*/
public assertionclause allmessages
final assertionclause clause   new assertionclause this
public void run
list<exchange> list   getreceivedexchanges
int index   0
for  exchange exchange   list
applyassertionon mockendpoint this  index    exchange
expects clause
return clause
/**
* asserts that the given index of message is received (starting at zero)
*/
public exchange assertexchangereceived int index
int count   getreceivedcounter
asserttrue     count  count > index
return getreceivedexchange index
// properties
// -------------------------------------------------------------------------
public list<throwable> getfailures
return failures
public int getreceivedcounter
return counter
public list<exchange> getreceivedexchanges
return receivedexchanges
public int getexpectedcount
return expectedcount
public long getsleepforemptytest
return sleepforemptytest
/**
* allows a sleep to be specified to wait to check that this endpoint really
* is empty when {@link #expectedmessagecount(int)} is called with zero
*
* @param sleepforemptytest the milliseconds to sleep for to determine that
*                this endpoint really is empty
*/
public void setsleepforemptytest long sleepforemptytest
this sleepforemptytest   sleepforemptytest
public long getresultwaittime
return resultwaittime
/**
* sets the maximum amount of time (in millis) the {@link #assertissatisfied()} will
* wait on a latch until it is satisfied
*/
public void setresultwaittime long resultwaittime
this resultwaittime   resultwaittime
/**
* sets the minimum expected amount of time (in millis) the {@link #assertissatisfied()} will
* wait on a latch until it is satisfied
*/
public void setminimumresultwaittime long resultminimumwaittime
this resultminimumwaittime   resultminimumwaittime
/**
* specifies the expected number of message exchanges that should be
* received by this endpoint.
* <p/>
* if you want to assert that <b>exactly</b> n'th message arrives to this mock
* endpoint, then see also the {@link #setassertperiod(long)} method for further details.
*
* @param expectedcount the number of message exchanges that should be
*                expected by this endpoint
* @see #setassertperiod(long)
*/
public void setexpectedmessagecount int expectedcount
this expectedcount   expectedcount
if  expectedcount <  0
latch   null
else
latch   new countdownlatch expectedcount
/**
* specifies the minimum number of expected message exchanges that should be
* received by this endpoint
*
* @param expectedcount the number of message exchanges that should be
*                expected by this endpoint
*/
public void setminimumexpectedmessagecount int expectedcount
this expectedminimumcount   expectedcount
if  expectedcount <  0
latch   null
else
latch   new countdownlatch expectedminimumcount
public processor getreporter
return reporter
/**
* allows a processor to added to the endpoint to report on progress of the test
*/
public void setreporter processor reporter
this reporter   reporter
/**
* specifies to only retain the first n'th number of received {@link exchange}s.
* <p/>
* this is used when testing with big data, to reduce memory consumption by not storing
* copies of every {@link exchange} this mock endpoint receives.
* <p/>
* <b>important:</b> when using this limitation, then the {@link #getreceivedcounter()}
* will still return the actual number of received {@link exchange}s. for example
* if we have received 5000 {@link exchange}s, and have configured to only retain the first
* 10 {@link exchange}s, then the {@link #getreceivedcounter()} will still return <tt>5000</tt>
* but there is only the first 10 {@link exchange}s in the {@link #getexchanges()} and
* {@link #getreceivedexchanges()} methods.
* <p/>
* when using this method, then some of the other expectation methods is not supported,
* for example the {@link #expectedbodiesreceived(object...)} sets a expectation on the first
* number of bodies received.
* <p/>
* you can configure both {@link #setretainfirst(int)} and {@link #setretainlast(int)} methods,
* to limit both the first and last received.
*
* @param retainfirst  to limit and only keep the first n'th received {@link exchange}s, use
*                     <tt>0</tt> to not retain any messages, or <tt>-1</tt> to retain all.
* @see #setretainlast(int)
*/
public void setretainfirst int retainfirst
this retainfirst   retainfirst
/**
* specifies to only retain the last n'th number of received {@link exchange}s.
* <p/>
* this is used when testing with big data, to reduce memory consumption by not storing
* copies of every {@link exchange} this mock endpoint receives.
* <p/>
* <b>important:</b> when using this limitation, then the {@link #getreceivedcounter()}
* will still return the actual number of received {@link exchange}s. for example
* if we have received 5000 {@link exchange}s, and have configured to only retain the last
* 20 {@link exchange}s, then the {@link #getreceivedcounter()} will still return <tt>5000</tt>
* but there is only the last 20 {@link exchange}s in the {@link #getexchanges()} and
* {@link #getreceivedexchanges()} methods.
* <p/>
* when using this method, then some of the other expectation methods is not supported,
* for example the {@link #expectedbodiesreceived(object...)} sets a expectation on the first
* number of bodies received.
* <p/>
* you can configure both {@link #setretainfirst(int)} and {@link #setretainlast(int)} methods,
* to limit both the first and last received.
*
* @param retainlast  to limit and only keep the last n'th received {@link exchange}s, use
*                     <tt>0</tt> to not retain any messages, or <tt>-1</tt> to retain all.
* @see #setretainfirst(int)
*/
public void setretainlast int retainlast
this retainlast   retainlast
// implementation methods
// -------------------------------------------------------------------------
private void init
expectedcount    1
counter   0
defaultprocessor   null
processors   new hashmap<integer  processor>
receivedexchanges   new copyonwritearraylist<exchange>
failures   new copyonwritearraylist<throwable>
tests   new copyonwritearraylist<runnable>
latch   null
sleepforemptytest   0
resultwaittime   0
resultminimumwaittime   0l
assertperiod   0l
expectedminimumcount    1
expectedbodyvalues   null
actualbodyvalues   new arraylist<object>
expectedheadervalues   null
actualheadervalues   null
expectedpropertyvalues   null
actualpropertyvalues   null
retainfirst    1
retainlast    1
protected synchronized void onexchange exchange exchange
try
if  reporter    null
reporter process exchange
exchange copy   exchange
if  copyonexchange
// copy the exchange so the mock stores the copy and not the actual exchange
copy   exchangehelper createcopy exchange  true
performassertions exchange  copy
catch  throwable e
// must catch java.lang.throwable as assertionexception extends java.lang.error
failures add e
finally
// make sure latch is counted down to avoid test hanging forever
if  latch    null
latch countdown
/**
* performs the assertions on the incoming exchange.
*
* @param exchange   the actual exchange
* @param copy       a copy of the exchange (only store this)
* @throws exception can be thrown if something went wrong
*/
protected void performassertions exchange exchange  exchange copy  throws exception
message in   copy getin
object actualbody   in getbody
if  expectedheadervalues    null
if  actualheadervalues    null
actualheadervalues   new caseinsensitivemap
if  in hasheaders
actualheadervalues putall in getheaders
if  expectedpropertyvalues    null
if  actualpropertyvalues    null
actualpropertyvalues   new concurrenthashmap<string  object>
actualpropertyvalues putall copy getproperties
if  expectedbodyvalues    null
int index   actualbodyvalues size
if  expectedbodyvalues size   > index
object expectedbody   expectedbodyvalues get index
if  expectedbody    null
// prefer to convert body early, for example when using files
// we need to read the content at this time
object body   in getbody expectedbody getclass
if  body    null
actualbody   body
actualbodyvalues add actualbody
// let counter be 0 index-based in the logs
if  log isdebugenabled
string msg   getendpointuri         counter       copy       actualbody
if  copy getin   hasheaders
msg        copy getin   getheaders
log debug msg
// record timestamp when exchange was received
copy setproperty exchange received_timestamp  new date
// add a copy of the received exchange
addreceivedexchange copy
// and then increment counter after adding received exchange
counter
processor processor   processors get getreceivedcounter       null
? processors get getreceivedcounter      defaultprocessor
if  processor    null
try
// must process the incoming exchange and not the copy as the idea
// is the end user can manipulate the exchange
processor process exchange
catch  exception e
// set exceptions on exchange so we can throw exceptions to simulate errors
exchange setexception e
/**
* adds the received exchange.
*
* @param copy  a copy of the received exchange
*/
protected void addreceivedexchange exchange copy
if  retainfirst    0    retainlast    0
// do not retain any messages at all
else if  retainfirst < 0    retainlast < 0
// no limitation so keep them all
receivedexchanges add copy
else
// okay there is some sort of limitations, so figure out what to retain
if  retainfirst > 0    counter < retainfirst
// store a copy as its within the retain first limitation
receivedexchanges add copy
else if  retainlast > 0
// remove the oldest from the last retained boundary,
int index   receivedexchanges size     retainlast
if  index >  0
// but must be outside the first range as well
// otherwise we should not remove the oldest
if  retainfirst <  0    retainfirst <  index
receivedexchanges remove index
// store a copy of the last n'th received
receivedexchanges add copy
protected void waitforcompletelatch   throws interruptedexception
if  latch    null
fail
stopwatch watch   new stopwatch
waitforcompletelatch resultwaittime
long delta   watch stop
log debug    delta
if  resultminimumwaittime > 0    delta < resultminimumwaittime
fail     resultminimumwaittime
delta
protected void waitforcompletelatch long timeout  throws interruptedexception
// wait for a default 10 seconds if resultwaittime is not set
long waittime   timeout    0 ? 10000l   timeout
// now let's wait for the results
log debug     timeout
latch await waittime  timeunit milliseconds
protected void assertequals string message  object expectedvalue  object actualvalue
if   objecthelper equal expectedvalue  actualvalue
fail message       expectedvalue       actualvalue
protected void asserttrue string message  boolean predicate
if   predicate
fail message
protected void fail object message
if  log isdebugenabled
list<exchange> list   getreceivedexchanges
int index   0
for  exchange exchange   list
log debug    new object getendpointuri      index  exchange
throw new assertionerror getendpointuri         message
public int getexpectedminimumcount
return expectedminimumcount
public void await   throws interruptedexception
if  latch    null
latch await
public boolean await long timeout  timeunit unit  throws interruptedexception
if  latch    null
return latch await timeout  unit
return true
public boolean issingleton
return true
public boolean islenientproperties
return true
private exchange getreceivedexchange int index
if  index <  receivedexchanges size     1
return receivedexchanges get index
else
return null