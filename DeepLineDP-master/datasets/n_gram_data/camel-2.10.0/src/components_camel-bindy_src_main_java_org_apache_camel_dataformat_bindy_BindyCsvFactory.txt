/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel dataformat bindy
import java lang reflect field
import java util arraylist
import java util hashmap
import java util iterator
import java util linkedhashmap
import java util linkedlist
import java util list
import java util map
import java util map entry
import java util treemap
import org apache camel dataformat bindy annotation csvrecord
import org apache camel dataformat bindy annotation datafield
import org apache camel dataformat bindy annotation link
import org apache camel dataformat bindy annotation onetomany
import org apache camel dataformat bindy annotation section
import org apache camel dataformat bindy format formatexception
import org apache camel dataformat bindy util converterutils
import org apache camel spi packagescanclassresolver
import org apache camel util objecthelper
import org slf4j logger
import org slf4j loggerfactory
/**
* the bindycsvfactory is the class who allows to : generate a model associated
* to a csv record, bind data from a record to the pojos, export data of pojos
* to a csv record and format data into string, date, double, ... according to
* the format/pattern defined
*/
public class bindycsvfactory extends bindyabstractfactory implements bindyfactory
private static final transient logger log   loggerfactory getlogger bindycsvfactory class
boolean isonetomany
private map<integer  datafield> datafields   new linkedhashmap<integer  datafield>
private map<integer  field> annotatedfields   new linkedhashmap<integer  field>
private map<string  integer> sections   new hashmap<string  integer>
private int numberoptionalfields
private int numbermandatoryfields
private int totalfields
private string separator
private boolean skipfirstline
private boolean generateheadercolumnnames
private boolean messageordered
private string quote
public bindycsvfactory packagescanclassresolver resolver  string    packagenames  throws exception
super resolver  packagenames
// initialize specific parameters of the csv model
initcsvmodel
public bindycsvfactory packagescanclassresolver resolver  class<?> type  throws exception
super resolver  type
// initialize specific parameters of the csv model
initcsvmodel
/**
* method uses to initialize the model representing the classes who will
* bind the data. this process will scan for classes according to the
* package name provided, check the annotated classes and fields and
* retrieve the separator of the csv record
*
* @throws exception
*/
public void initcsvmodel   throws exception
// find annotated datafields declared in the model classes
initannotatedfields
// initialize csv parameter(s)
// separator and skip first line from @csvrecord annotation
initcsvrecordparameters
public void initannotatedfields
for  class<?> cl   models
list<field> linkfields   new arraylist<field>
if  log isdebugenabled
log debug    cl getname
for  field field   cl getdeclaredfields
datafield datafield   field getannotation datafield class
if  datafield    null
if  log isdebugenabled
log debug
new object cl getname    datafield pos    datafield
if  datafield required
numbermandatoryfields
else
numberoptionalfields
datafields put datafield pos    datafield
annotatedfields put datafield pos    field
link linkfield   field getannotation link class
if  linkfield    null
if  log isdebugenabled
log debug    cl getname    field
linkfields add field
if   linkfields isempty
annotatedlinkfields put cl getname    linkfields
totalfields   numbermandatoryfields   numberoptionalfields
if  log isdebugenabled
log debug    numberoptionalfields
log debug    numbermandatoryfields
log debug    totalfields
public void bind list<string> tokens  map<string  object> model  int line  throws exception
int pos   1
int countermandatoryfields   0
for  string data   tokens
// get datafield from model
datafield datafield   datafields get pos
objecthelper notnull datafield      pos       data       line
if  datafield trim
data   data trim
if  datafield required
// increment counter of mandatory fields
countermandatoryfields
// check if content of the field is empty
// this is not possible for mandatory fields
if  data equals
throw new illegalargumentexception     pos       line
// get field to be setted
field field   annotatedfields get pos
field setaccessible true
if  log isdebugenabled
log debug    new object pos  data  field gettype
format<?> format
// get pattern defined for the field
string pattern   datafield pattern
// create format object to format the field
format   formatfactory getformat field gettype    pattern  getlocale    datafield precision
// field object to be set
object modelfield   model get field getdeclaringclass   getname
// format the data received
object value   null
if   data equals
try
value   format parse data
catch  formatexception ie
throw new illegalargumentexception ie getmessage         pos       line  ie
catch  exception e
throw new illegalargumentexception     pos       line  e
else
if   datafield defaultvalue   isempty
value   format parse datafield defaultvalue
else
value   getdefaultvalueforprimitive field gettype
field set modelfield  value
pos
log debug    countermandatoryfields
if  countermandatoryfields < numbermandatoryfields
throw new illegalargumentexception     line
if  pos < totalfields
setdefaultvaluesforfields model
public string unbind map<string  object> model  throws exception
stringbuilder buffer   new stringbuilder
map<integer  list<string>> results   new hashmap<integer  list<string>>
// check if separator exists
objecthelper notnull this separator
char separator   converterutils getchardelimiter this getseparator
if  log isdebugenabled
log debug    integer tohexstring separator   this getseparator
for  class<?> clazz   models
if  model containskey clazz getname
object obj   model get clazz getname
if  log isdebugenabled
log debug    obj  obj getclass   getname
if  obj    null
// generate csv table
generatecsvpositionmap clazz  obj  results
// transpose result
list<list<string>> l   new arraylist<list<string>>
if  isonetomany
l   product results
else
// convert map<integer, list> into list<list>
treemap<integer  list<string>> sortvalues   new treemap<integer  list<string>> results
list<string> temp   new arraylist<string>
for  entry<integer  list<string>> entry   sortvalues entryset
// get list of values
list<string> val   entry getvalue
// for one to one relation
// there is only one item in the list
string value   val get 0
// add the value to the temp array
if  value    null
temp add value
else
temp add
l add temp
if  l    null
iterator<list<string>> it   l iterator
while  it hasnext
list<string> tokens   it next
iterator<string> itx   tokens iterator
while  itx hasnext
string res   itx next
if  res    null
// the field may be enclosed in quotes if a quote was configured
if  quote    null
buffer append quote
buffer append res
if  quote    null
buffer append quote
if  itx hasnext
buffer append separator
if  it hasnext
buffer append converterutils getstringcarriagereturn getcarriagereturn
return buffer tostring
private list<list<string>> product map<integer  list<string>> values
treemap<integer  list<string>> sortvalues   new treemap<integer  list<string>> values
list<list<string>> product   new arraylist<list<string>>
map<integer  integer> index   new hashmap<integer  integer>
int idx   0
int idxsize   0
do
idxsize   0
list<string> v   new arraylist<string>
for  int ii   1  ii <  sortvalues lastkey    ii
list<string> l   values get ii
if  l    null
v add
idxsize
continue
if  l size   >  idx   1
v add l get idx
index put ii  idx
if  log isdebugenabled
log debug    new object l get idx   ii  idx
else
v add l get 0
index put ii  0
idxsize
if  log isdebugenabled
log debug    new object l get 0   ii  0
if  idxsize    sortvalues lastkey
product add v
idx
while  idxsize    sortvalues lastkey
return product
/**
*
* generate a table containing the data formatted and sorted with their position/offset
* if the model is ordered than a key is created combining the annotation @section and position of the field
* if a relation @onetomany is defined, than we iterate recursively through this function
* the result is placed in the map<integer, list> results
*/
private void generatecsvpositionmap class<?> clazz  object obj  map<integer  list<string>> results  throws exception
string result
for  field field   clazz getdeclaredfields
field setaccessible true
datafield datafield   field getannotation datafield class
if  datafield    null
if  obj    null
// retrieve the format, pattern and precision associated to
// the type
class<?> type   field gettype
string pattern   datafield pattern
int precision   datafield precision
// create format
format<?> format   formatfactory getformat type  pattern  getlocale    precision
// get field value
object value   field get obj
result   formatstring format  value
if  datafield trim
result   result trim
if  datafield clip      result length   > datafield length
result   result substring 0  datafield length
if  log isdebugenabled
log debug    new object value  datafield pos    result
else
result
integer key
if  ismessageordered      obj    null
// generate a key using the number of the section
// and the position of the field
integer key1   sections get obj getclass   getname
integer key2   datafield position
integer keygenerated   generatekey key1  key2
if  log isdebugenabled
log debug    string valueof keygenerated   key1
key   keygenerated
else
key   datafield pos
if   results containskey key
list<string> list   new linkedlist<string>
list add result
results put key  list
else
list<string> list   results get key
list add result
onetomany onetomany   field getannotation onetomany class
if  onetomany    null
// set global variable
// will be used during generation of csv
isonetomany   true
list<?> list    list<?> field get obj
if  list    null
iterator<?> it   list iterator
while  it hasnext
object target   it next
generatecsvpositionmap target getclass    target  results
else
// call this function to add empty value
// in the table
generatecsvpositionmap field getclass    null  results
/**
* generate for the first line the headers of the columns
*
* @return the headers columns
*/
public string generateheader
map<integer  datafield> datafieldssorted   new treemap<integer  datafield> datafields
iterator<integer> it   datafieldssorted keyset   iterator
stringbuilder builderheader   new stringbuilder
while  it hasnext
datafield datafield   datafieldssorted get it next
// retrieve the field
field field   annotatedfields get datafield pos
// change accessibility to allow to read protected/private fields
field setaccessible true
// get datafield
if   datafield columnname   equals
builderheader append datafield columnname
else
builderheader append field getname
if  it hasnext
builderheader append separator
return builderheader tostring
/**
* get parameters defined in @csvrecord annotation
*/
private void initcsvrecordparameters
if  separator    null
for  class<?> cl   models
// get annotation @csvrecord from the class
csvrecord record   cl getannotation csvrecord class
// get annotation @section from the class
section section   cl getannotation section class
if  record    null
log debug    record
// get skipfirstline parameter
skipfirstline   record skipfirstline
log debug     skipfirstline
// get generateheadercolumnnames parameter
generateheadercolumnnames   record generateheadercolumns
log debug    generateheadercolumnnames
// get separator parameter
objecthelper notnull record separator
separator   record separator
log debug    separator
// get carriage return parameter
crlf   record crlf
log debug    crlf
// get isordered parameter
messageordered   record isordered
log debug    messageordered
if  objecthelper isnotempty record quote
quote   record quote
log debug    quote
if  section    null
// test if section number is not null
objecthelper notnull section number
// get section number and add it to the sections
sections put cl getname    section number
/**
* set the default values for the non defined fields.
* @param model the model which has its default fields set.
* @throws illegalaccessexception if the underlying fields are inaccessible
* @throws exception in case the field cannot be parsed
*/
private void setdefaultvaluesforfields final map<string  object> model  throws illegalaccessexception
exception
// set the default values, if defined
for  int i   1  i <  datafields size    i
field field   annotatedfields get i
field setaccessible true
datafield datafield   datafields get i
object modelfield   model get field getdeclaringclass   getname
if  field get modelfield     null     datafield defaultvalue   isempty
string pattern   datafield pattern
format<?> format   formatfactory getformat field gettype    pattern  getlocale
datafield precision
object value   format parse datafield defaultvalue
field set modelfield  value
/**
* find the separator used to delimit the csv fields
*/
public string getseparator
return separator
/**
* flag indicating if the first line of the csv must be skipped
*/
public boolean getgenerateheadercolumnnames
return generateheadercolumnnames
/**
* find the separator used to delimit the csv fields
*/
public boolean getskipfirstline
return skipfirstline
/**
* flag indicating if the message must be ordered
*
* @return boolean
*/
public boolean ismessageordered
return messageordered