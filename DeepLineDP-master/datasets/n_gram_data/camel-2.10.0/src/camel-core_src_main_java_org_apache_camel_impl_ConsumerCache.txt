/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel impl
import java util map
import org apache camel camelcontext
import org apache camel endpoint
import org apache camel exchange
import org apache camel failedtocreateconsumerexception
import org apache camel issingleton
import org apache camel pollingconsumer
import org apache camel support servicesupport
import org apache camel util camelcontexthelper
import org apache camel util lrucache
import org apache camel util lrusoftcache
import org apache camel util servicehelper
import org slf4j logger
import org slf4j loggerfactory
/**
* cache containing created {@link org.apache.camel.consumer}.
*
* @version
*/
public class consumercache extends servicesupport
private static final transient logger log   loggerfactory getlogger consumercache class
private final camelcontext camelcontext
private final map<string  pollingconsumer> consumers
private final object source
public consumercache object source  camelcontext camelcontext
this source  camelcontext  camelcontexthelper getmaximumcachepoolsize camelcontext
public consumercache object source  camelcontext camelcontext  int cachesize
this source  camelcontext  createlrucache cachesize
public consumercache object source  camelcontext camelcontext  map<string  pollingconsumer> cache
this camelcontext   camelcontext
this consumers   cache
this source   source
/**
* creates the {@link lrucache} to be used.
* <p/>
* this implementation returns a {@link org.apache.camel.util.lrusoftcache} instance.
* @param cachesize the cache size
* @return the cache
*/
protected static lrucache<string  pollingconsumer> createlrucache int cachesize
// we use a soft reference cache to allow the jvm to re-claim memory if it runs low on memory.
return new lrusoftcache<string  pollingconsumer> cachesize
public synchronized pollingconsumer getconsumer endpoint endpoint
string key   endpoint getendpointuri
pollingconsumer answer   consumers get key
if  answer    null
try
answer   endpoint createpollingconsumer
answer start
catch  exception e
throw new failedtocreateconsumerexception endpoint  e
boolean singleton   true
if  answer instanceof issingleton
singleton     issingleton  answer  issingleton
if  singleton
log debug    endpoint  answer
consumers put key  answer
else
log debug    key
return answer
public exchange receive endpoint endpoint
log debug    endpoint
pollingconsumer consumer   getconsumer endpoint
return consumer receive
public exchange receive endpoint endpoint  long timeout
log debug    endpoint
pollingconsumer consumer   getconsumer endpoint
return consumer receive timeout
public exchange receivenowait endpoint endpoint
log debug    endpoint
pollingconsumer consumer   getconsumer endpoint
return consumer receivenowait
public camelcontext getcamelcontext
return camelcontext
/**
* gets the source which uses this cache
*
* @return the source
*/
public object getsource
return source
/**
* returns the current size of the cache
*
* @return the current size
*/
public int size
int size   consumers size
log trace    size
return size
/**
* gets the maximum cache size (capacity).
* <p/>
* will return <tt>-1</tt> if it cannot determine this if a custom cache was used.
*
* @return the capacity
*/
public int getcapacity
int capacity    1
if  consumers instanceof lrucache
lrucache<string  pollingconsumer> cache    lrucache<string  pollingconsumer> consumers
capacity   cache getmaxcachesize
return capacity
/**
* gets the cache hits statistic
* <p/>
* will return <tt>-1</tt> if it cannot determine this if a custom cache was used.
*
* @return the hits
*/
public long gethits
long hits    1
if  consumers instanceof lrucache
lrucache<string  pollingconsumer> cache    lrucache<string  pollingconsumer> consumers
hits   cache gethits
return hits
/**
* gets the cache misses statistic
* <p/>
* will return <tt>-1</tt> if it cannot determine this if a custom cache was used.
*
* @return the misses
*/
public long getmisses
long misses    1
if  consumers instanceof lrucache
lrucache<string  pollingconsumer> cache    lrucache<string  pollingconsumer> consumers
misses   cache getmisses
return misses
/**
* resets the cache statistics
*/
public void resetcachestatistics
if  consumers instanceof lrucache
lrucache<string  pollingconsumer> cache    lrucache<string  pollingconsumer> consumers
cache resetstatistics
/**
* purges this cache
*/
public synchronized void purge
consumers clear
@override
public string tostring
return     source       getcapacity
protected void dostart   throws exception
servicehelper startservices consumers values
protected void dostop   throws exception
// when stopping we intend to shutdown
servicehelper stopandshutdownservices consumers values
consumers clear