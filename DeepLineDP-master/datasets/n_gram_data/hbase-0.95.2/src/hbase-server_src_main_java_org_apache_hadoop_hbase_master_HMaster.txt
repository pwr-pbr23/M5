/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase master
import java io ioexception
import java lang reflect constructor
import java lang reflect invocationtargetexception
import java net inetaddress
import java net inetsocketaddress
import java net unknownhostexception
import java util arraylist
import java util collection
import java util collections
import java util comparator
import java util hashset
import java util iterator
import java util list
import java util map
import java util set
import java util concurrent callable
import java util concurrent executionexception
import java util concurrent executors
import java util concurrent future
import java util concurrent timeunit
import java util concurrent atomic atomicreference
import javax management objectname
import com google common collect lists
import com google common collect sets
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop conf configuration
import org apache hadoop fs path
import org apache hadoop hbase abortable
import org apache hadoop hbase chore
import org apache hadoop hbase clusterid
import org apache hadoop hbase clusterstatus
import org apache hadoop hbase tablename
import org apache hadoop hbase hbaseioexception
import org apache hadoop hbase namespacedescriptor
import org apache hadoop hbase constraint constraintexception
import org apache hadoop hbase exceptions deserializationexception
import org apache hadoop hbase hcolumndescriptor
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase healthcheckchore
import org apache hadoop hbase masternotrunningexception
import org apache hadoop hbase pleaseholdexception
import org apache hadoop hbase server
import org apache hadoop hbase serverload
import org apache hadoop hbase servername
import org apache hadoop hbase tabledescriptors
import org apache hadoop hbase tablenotdisabledexception
import org apache hadoop hbase tablenotfoundexception
import org apache hadoop hbase unknownregionexception
import org apache hadoop hbase catalog catalogtracker
import org apache hadoop hbase catalog metareader
import org apache hadoop hbase client hconnectionmanager
import org apache hadoop hbase client metascanner
import org apache hadoop hbase client metascanner metascannervisitor
import org apache hadoop hbase client metascanner metascannervisitorbase
import org apache hadoop hbase client result
import org apache hadoop hbase coprocessor coprocessorhost
import org apache hadoop hbase exceptions mergeregionexception
import org apache hadoop hbase exceptions unknownprotocolexception
import org apache hadoop hbase executor executorservice
import org apache hadoop hbase executor executortype
import org apache hadoop hbase ipc rpcserver
import org apache hadoop hbase ipc rpcserver blockingserviceandinterface
import org apache hadoop hbase ipc rpcserverinterface
import org apache hadoop hbase ipc serverrpccontroller
import org apache hadoop hbase master balancer balancerchore
import org apache hadoop hbase master balancer clusterstatuschore
import org apache hadoop hbase master balancer loadbalancerfactory
import org apache hadoop hbase master cleaner hfilecleaner
import org apache hadoop hbase master cleaner logcleaner
import org apache hadoop hbase master handler createtablehandler
import org apache hadoop hbase master handler deletetablehandler
import org apache hadoop hbase master handler disabletablehandler
import org apache hadoop hbase master handler dispatchmergingregionhandler
import org apache hadoop hbase master handler enabletablehandler
import org apache hadoop hbase master handler modifytablehandler
import org apache hadoop hbase master handler tableaddfamilyhandler
import org apache hadoop hbase master handler tabledeletefamilyhandler
import org apache hadoop hbase master handler tablemodifyfamilyhandler
import org apache hadoop hbase master snapshot snapshotmanager
import org apache hadoop hbase monitoring memoryboundedlogmessagebuffer
import org apache hadoop hbase monitoring monitoredtask
import org apache hadoop hbase monitoring taskmonitor
import org apache hadoop hbase protobuf protobufutil
import org apache hadoop hbase protobuf requestconverter
import org apache hadoop hbase protobuf responseconverter
import org apache hadoop hbase protobuf generated clientprotos
import org apache hadoop hbase protobuf generated clusterstatusprotos
import org apache hadoop hbase protobuf generated hbaseprotos
import org apache hadoop hbase protobuf generated hbaseprotos namestringpair
import org apache hadoop hbase protobuf generated hbaseprotos regionspecifier regionspecifiertype
import org apache hadoop hbase protobuf generated hbaseprotos snapshotdescription
import org apache hadoop hbase protobuf generated masteradminprotos
import org apache hadoop hbase protobuf generated masteradminprotos addcolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos addcolumnresponse
import org apache hadoop hbase protobuf generated masteradminprotos assignregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos assignregionresponse
import org apache hadoop hbase protobuf generated masteradminprotos balancerequest
import org apache hadoop hbase protobuf generated masteradminprotos balanceresponse
import org apache hadoop hbase protobuf generated masteradminprotos catalogscanrequest
import org apache hadoop hbase protobuf generated masteradminprotos catalogscanresponse
import org apache hadoop hbase protobuf generated masteradminprotos createtablerequest
import org apache hadoop hbase protobuf generated masteradminprotos createtableresponse
import org apache hadoop hbase protobuf generated masteradminprotos deletecolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos deletecolumnresponse
import org apache hadoop hbase protobuf generated masteradminprotos deletesnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos deletesnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos deletetablerequest
import org apache hadoop hbase protobuf generated masteradminprotos deletetableresponse
import org apache hadoop hbase protobuf generated masteradminprotos disabletablerequest
import org apache hadoop hbase protobuf generated masteradminprotos disabletableresponse
import org apache hadoop hbase protobuf generated masteradminprotos dispatchmergingregionsrequest
import org apache hadoop hbase protobuf generated masteradminprotos dispatchmergingregionsresponse
import org apache hadoop hbase protobuf generated masteradminprotos enablecatalogjanitorrequest
import org apache hadoop hbase protobuf generated masteradminprotos enablecatalogjanitorresponse
import org apache hadoop hbase protobuf generated masteradminprotos enabletablerequest
import org apache hadoop hbase protobuf generated masteradminprotos enabletableresponse
import org apache hadoop hbase protobuf generated masteradminprotos iscatalogjanitorenabledrequest
import org apache hadoop hbase protobuf generated masteradminprotos iscatalogjanitorenabledresponse
import org apache hadoop hbase protobuf generated masteradminprotos isrestoresnapshotdonerequest
import org apache hadoop hbase protobuf generated masteradminprotos isrestoresnapshotdoneresponse
import org apache hadoop hbase protobuf generated masteradminprotos issnapshotdonerequest
import org apache hadoop hbase protobuf generated masteradminprotos issnapshotdoneresponse
import org apache hadoop hbase protobuf generated masteradminprotos listsnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos listsnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos modifycolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos modifycolumnresponse
import org apache hadoop hbase protobuf generated masteradminprotos modifytablerequest
import org apache hadoop hbase protobuf generated masteradminprotos modifytableresponse
import org apache hadoop hbase protobuf generated masteradminprotos moveregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos moveregionresponse
import org apache hadoop hbase protobuf generated masteradminprotos offlineregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos offlineregionresponse
import org apache hadoop hbase protobuf generated masteradminprotos restoresnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos restoresnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos setbalancerrunningrequest
import org apache hadoop hbase protobuf generated masteradminprotos setbalancerrunningresponse
import org apache hadoop hbase protobuf generated masteradminprotos shutdownrequest
import org apache hadoop hbase protobuf generated masteradminprotos shutdownresponse
import org apache hadoop hbase protobuf generated masteradminprotos stopmasterrequest
import org apache hadoop hbase protobuf generated masteradminprotos stopmasterresponse
import org apache hadoop hbase protobuf generated masteradminprotos takesnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos takesnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos unassignregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos unassignregionresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos
import org apache hadoop hbase protobuf generated mastermonitorprotos getclusterstatusrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos getclusterstatusresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos getschemaalterstatusrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos getschemaalterstatusresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos gettabledescriptorsrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos gettabledescriptorsresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos gettablenamesrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos gettablenamesresponse
import org apache hadoop hbase protobuf generated masterprotos ismasterrunningrequest
import org apache hadoop hbase protobuf generated masterprotos ismasterrunningresponse
import org apache hadoop hbase protobuf generated regionserverstatusprotos
import org apache hadoop hbase protobuf generated regionserverstatusprotos getlastflushedsequenceidrequest
import org apache hadoop hbase protobuf generated regionserverstatusprotos getlastflushedsequenceidresponse
import org apache hadoop hbase protobuf generated regionserverstatusprotos regionserverreportrequest
import org apache hadoop hbase protobuf generated regionserverstatusprotos regionserverreportresponse
import org apache hadoop hbase protobuf generated regionserverstatusprotos regionserverstartuprequest
import org apache hadoop hbase protobuf generated regionserverstatusprotos regionserverstartupresponse
import org apache hadoop hbase protobuf generated regionserverstatusprotos reportrsfatalerrorrequest
import org apache hadoop hbase protobuf generated regionserverstatusprotos reportrsfatalerrorresponse
import org apache hadoop hbase replication regionserver replication
import org apache hadoop hbase security user
import org apache hadoop hbase snapshot clientsnapshotdescriptionutils
import org apache hadoop hbase snapshot snapshotdescriptionutils
import org apache hadoop hbase trace spanreceiverhost
import org apache hadoop hbase util bytes
import org apache hadoop hbase util compressiontest
import org apache hadoop hbase util fstabledescriptors
import org apache hadoop hbase util fsutils
import org apache hadoop hbase util hfilearchiveutil
import org apache hadoop hbase util hasthread
import org apache hadoop hbase util infoserver
import org apache hadoop hbase util pair
import org apache hadoop hbase util sleeper
import org apache hadoop hbase util strings
import org apache hadoop hbase util threads
import org apache hadoop hbase util versioninfo
import org apache hadoop hbase zookeeper clusterstatustracker
import org apache hadoop hbase zookeeper drainingservertracker
import org apache hadoop hbase zookeeper loadbalancertracker
import org apache hadoop hbase zookeeper masteraddresstracker
import org apache hadoop hbase zookeeper regionservertracker
import org apache hadoop hbase zookeeper zkclusterid
import org apache hadoop hbase zookeeper zktable
import org apache hadoop hbase zookeeper zkutil
import org apache hadoop hbase zookeeper zookeeperlistener
import org apache hadoop hbase zookeeper zookeeperwatcher
import org apache hadoop metrics util mbeanutil
import org apache hadoop net dns
import org apache zookeeper keeperexception
import org apache zookeeper watcher
import com google common collect maps
import com google protobuf descriptors
import com google protobuf message
import com google protobuf rpccallback
import com google protobuf rpccontroller
import com google protobuf service
import com google protobuf serviceexception
/**
* hmaster is the "master server" for hbase. an hbase cluster has one active
* master.  if many masters are started, all compete.  whichever wins goes on to
* run the cluster.  all others park themselves in their constructor until
* master or cluster shutdown or until the active master loses its lease in
* zookeeper.  thereafter, all running master jostle to take over master role.
*
* <p>the master can be asked shutdown the cluster. see {@link #shutdown()}.  in
* this case it will tell all regionservers to go down and then wait on them
* all reporting in that they are down.  this master will then shut itself down.
*
* <p>you can also shutdown just this master.  call {@link #stopmaster()}.
*
* @see watcher
*/
@interfaceaudience private
@suppresswarnings
public class hmaster extends hasthread
implements mastermonitorprotos mastermonitorservice blockinginterface
masteradminprotos masteradminservice blockinginterface
regionserverstatusprotos regionserverstatusservice blockinginterface
masterservices  server
private static final log log   logfactory getlog hmaster class getname
// master is name of the webapp and the attribute name used stuffing this
//instance into web context.
public static final string master
// the configuration for the master
private final configuration conf
// server for the web ui
private infoserver infoserver
// our zk client.
private zookeeperwatcher zookeeper
// manager and zk listener for master election
private activemastermanager activemastermanager
// region server tracker
regionservertracker regionservertracker
// draining region server tracker
private drainingservertracker drainingservertracker
// tracker for load balancer state
private loadbalancertracker loadbalancertracker
// master address manager and watcher
private masteraddresstracker masteraddressmanager
// rpc server for the hmaster
private final rpcserverinterface rpcserver
// set after we've called hbaseserver#openserver and ready to receive rpcs.
// set back to false after we stop rpcserver.  used by tests.
private volatile boolean rpcserveropen   false
/** namespace stuff */
private tablenamespacemanager tablenamespacemanager
private namespacejanitor namespacejanitorchore
/**
* this servers address.
*/
private final inetsocketaddress isa
// metrics for the hmaster
private final metricsmaster metricsmaster
// file system manager for the master fs operations
private masterfilesystem filesystemmanager
// server manager to deal with region server info
servermanager servermanager
// manager of assignment nodes in zookeeper
assignmentmanager assignmentmanager
// manager of catalog regions
private catalogtracker catalogtracker
// cluster status zk tracker and local setter
private clusterstatustracker clusterstatustracker
// buffer for "fatal error" notices from region servers
// in the cluster. this is only used for assisting
// operations/debugging.
private memoryboundedlogmessagebuffer rsfatals
// this flag is for stopping this master instance.  its set when we are
// stopping or aborting
private volatile boolean stopped   false
// set on abort -- usually failure of our zk session.
private volatile boolean abort   false
// flag set after we become the active master (used for testing)
private volatile boolean isactivemaster   false
// flag set after we complete initialization once active,
// it is not private since it's used in unit tests
volatile boolean initialized   false
// flag set after we complete assignmeta.
private volatile boolean servershutdownhandlerenabled   false
// instance of the hbase executor service.
executorservice executorservice
private loadbalancer balancer
private thread balancerchore
private thread clusterstatuschore
private clusterstatuspublisher clusterstatuspublisherchore   null
private catalogjanitor catalogjanitorchore
private logcleaner logcleaner
private hfilecleaner hfilecleaner
private mastercoprocessorhost cphost
private final servername servername
private tabledescriptors tabledescriptors
// table level lock manager for schema changes
private tablelockmanager tablelockmanager
// time stamps for when a hmaster was started and when it became active
private long masterstarttime
private long masteractivetime
/** time interval for emitting metrics values */
private final int msginterval
/**
* mx bean for masterinfo
*/
private objectname mxbean   null
//should we check the compression codec type at master side, default true, hbase-6370
private final boolean mastercheckcompression
private spanreceiverhost spanreceiverhost
private map<string  service> coprocessorservicehandlers   maps newhashmap
// monitor for snapshot of hbase tables
private snapshotmanager snapshotmanager
/** the health check chore. */
private healthcheckchore healthcheckchore
/**
* is in distributedlogreplay mode. when true, splitlogworker directly replays wal edits to newly
* assigned region servers instead of creating recovered.edits files.
*/
private final boolean distributedlogreplay
/** flag used in test cases in order to simulate rs failures during master initialization */
private volatile boolean initializationbeforemetaassignment   false
/** the following is used in master recovery scenario to re-register listeners */
private list<zookeeperlistener> registeredzklistenersbeforerecovery
/**
* initializes the hmaster. the steps are as follows:
* <p>
* <ol>
* <li>initialize hmaster rpc and address
* <li>connect to zookeeper.
* </ol>
* <p>
* remaining steps of initialization occur in {@link #run()} so that they
* run in their own thread rather than within the context of the constructor.
* @throws interruptedexception
*/
public hmaster final configuration conf
throws ioexception  keeperexception  interruptedexception
this conf   new configuration conf
// disable the block cache on the master
this conf setfloat hconstants hfile_block_cache_size_key  0 0f
// server to handle client requests.
string hostname   conf get
strings domainnamepointertohostname dns getdefaulthost
conf get
conf get
int port   conf getint hconstants master_port  hconstants default_master_port
// test that the hostname is reachable
inetsocketaddress initialisa   new inetsocketaddress hostname  port
if  initialisa getaddress      null
throw new illegalargumentexception     initialisa
string name       initialisa tostring
// set how many times to retry talking to another server over hconnection.
hconnectionmanager setserversidehconnectionretries this conf  name  log
int numhandlers   conf getint
conf getint    25
this rpcserver   new rpcserver this  name  getservices
initialisa     bindaddress is ip we got for this server
numhandlers
0     we dont use high priority handlers in master
conf
0      this is a dnc w o high priority handlers
// set our address.
this isa   this rpcserver getlisteneraddress
this servername
new servername this isa gethostname    this isa getport    system currenttimemillis
this rsfatals   new memoryboundedlogmessagebuffer
conf getlong    1 1024 1024
// login the zookeeper client principal (if using security)
zkutil loginclient this conf
this isa gethostname
// initialize server principal (if using secure hadoop)
user login conf
this isa gethostname
log info     fsutils getrootdir this conf
this conf getboolean    false
// set the thread name now we have an address
setname master       this servername toshortstring
replication decoratemasterconfiguration this conf
// hack! maps dfsclient => master for logs.  hdfs made this
// config param for task trackers, but we can piggyback off of it.
if  this conf get       null
this conf set        this servername tostring
this zookeeper   new zookeeperwatcher conf  master       isa getport    this  true
this rpcserver startthreads
// metrics interval: using the same property as region server.
this msginterval   conf getint    3   1000
//should we check the compression codec type at master side, default true, hbase-6370
this mastercheckcompression   conf getboolean    true
this metricsmaster   new metricsmaster  new metricsmasterwrapperimpl this
// health checker thread.
int sleeptime   this conf getint hconstants health_chore_wake_freq
hconstants default_thread_wake_frequency
if  ishealthcheckerconfigured
healthcheckchore   new healthcheckchore sleeptime  this  getconfiguration
// do we publish the status?
class<? extends clusterstatuspublisher publisher> publisherclass
conf getclass clusterstatuspublisher status_publisher_class
clusterstatuspublisher default_status_publisher_class
clusterstatuspublisher publisher class
if  publisherclass    null
clusterstatuspublisherchore   new clusterstatuspublisher this  conf  publisherclass
threads setdaemonthreadrunning clusterstatuspublisherchore getthread
distributedlogreplay   this conf getboolean hconstants distributed_log_replay_key
hconstants default_distributed_log_replay_config
/**
* @return list of blocking services and their security info classes that this server supports
*/
private list<blockingserviceandinterface> getservices
list<blockingserviceandinterface> bssi   new arraylist<blockingserviceandinterface> 3
bssi add new blockingserviceandinterface
mastermonitorprotos mastermonitorservice newreflectiveblockingservice this
mastermonitorprotos mastermonitorservice blockinginterface class
bssi add new blockingserviceandinterface
masteradminprotos masteradminservice newreflectiveblockingservice this
masteradminprotos masteradminservice blockinginterface class
bssi add new blockingserviceandinterface
regionserverstatusprotos regionserverstatusservice newreflectiveblockingservice this
regionserverstatusprotos regionserverstatusservice blockinginterface class
return bssi
/**
* stall startup if we are designated a backup master; i.e. we want someone
* else to become the master before proceeding.
* @param c configuration
* @param amm
* @throws interruptedexception
*/
private static void stallifbackupmaster final configuration c
final activemastermanager amm
throws interruptedexception
// if we're a backup master, stall until a primary to writes his address
if   c getboolean hconstants master_type_backup
hconstants default_master_type_backup
return
log debug
// this will only be a minute or so while the cluster starts up,
// so don't worry about setting watches on the parent znode
while   amm isactivemaster
log debug
thread sleep
c getint hconstants zk_session_timeout  hconstants default_zk_session_timeout
metricsmaster getmetrics
return metricsmaster
/**
* main processing loop for the hmaster.
* <ol>
* <li>block until becoming active master
* <li>finish initialization via finishinitialization(monitoredtask)
* <li>enter loop until we are stopped
* <li>stop services and perform cleanup once stopped
* </ol>
*/
@override
public void run
monitoredtask startupstatus
taskmonitor get   createstatus
startupstatus setdescription
masterstarttime   system currenttimemillis
try
this registeredzklistenersbeforerecovery   this zookeeper getlisteners
this masteraddressmanager   new masteraddresstracker getzookeeperwatcher    this
this masteraddressmanager start
// put up info server.
int port   this conf getint    60010
if  port >  0
string a   this conf get
this infoserver   new infoserver master  a  port  false  this conf
this infoserver addservlet       masterstatusservlet class
this infoserver addservlet       masterdumpservlet class
this infoserver setattribute master  this
this infoserver start
/*
* block on becoming the active master.
*
* we race with other masters to write our address into zookeeper.  if we
* succeed, we are the primary/active master and finish initialization.
*
* if we do not succeed, there is another active master and we should
* now wait until it dies to try and become the next active master.  if we
* do not succeed on our first attempt, this is no longer a cluster startup.
*/
becomeactivemaster startupstatus
// we are either the active master or we were asked to shutdown
if   this stopped
finishinitialization startupstatus  false
loop
catch  throwable t
// hbase-5680: likely hadoop23 vs hadoop 20.x/1.x incompatibility
if  t instanceof noclassdeffounderror
t getmessage   contains
// improved error message for this special case
abort
org apache hadoop util versioninfo getversion
t
else
abort    t
finally
startupstatus cleanup
stopchores
// wait for all the remaining region servers to report in iff we were
// running a cluster shutdown and we were not aborting.
if   this abort    this servermanager    null
this servermanager isclustershutdown
this servermanager letregionserversshutdown
stopservicethreads
// stop services started for both backup and active masters
if  this activemastermanager    null  this activemastermanager stop
if  this catalogtracker    null  this catalogtracker stop
if  this servermanager    null  this servermanager stop
if  this assignmentmanager    null  this assignmentmanager stop
if  this filesystemmanager    null  this filesystemmanager stop
if  this snapshotmanager    null  this snapshotmanager stop
this zookeeper close
log info
/**
* try becoming active master.
* @param startupstatus
* @return true if we could successfully become the active master.
* @throws interruptedexception
*/
private boolean becomeactivemaster monitoredtask startupstatus
throws interruptedexception
// todo: this is wrong!!!! should have new servername if we restart ourselves,
// if we come back to life.
this activemastermanager   new activemastermanager zookeeper  this servername
this
this zookeeper registerlistener activemastermanager
stallifbackupmaster this conf  this activemastermanager
// the clusterstatustracker is setup before the other
// zkbasedsystemtrackers because it's needed by the activemastermanager
// to check if the cluster should be shutdown.
this clusterstatustracker   new clusterstatustracker getzookeeper    this
this clusterstatustracker start
return this activemastermanager blockuntilbecomingactivemaster startupstatus
/**
* initialize all zk based system trackers.
* @throws ioexception
* @throws interruptedexception
*/
void initializezkbasedsystemtrackers   throws ioexception
interruptedexception  keeperexception
this catalogtracker   createcatalogtracker this zookeeper  this conf  this
this catalogtracker start
this balancer   loadbalancerfactory getloadbalancer conf
this loadbalancertracker   new loadbalancertracker zookeeper  this
this loadbalancertracker start
this assignmentmanager   new assignmentmanager this  servermanager
this catalogtracker  this balancer  this executorservice  this metricsmaster
this tablelockmanager
zookeeper registerlistenerfirst assignmentmanager
this regionservertracker   new regionservertracker zookeeper  this
this servermanager
this regionservertracker start
this drainingservertracker   new drainingservertracker zookeeper  this
this servermanager
this drainingservertracker start
// set the cluster as up.  if new rss, they'll be waiting on this before
// going ahead with their startup.
boolean wasup   this clusterstatustracker isclusterup
if   wasup  this clusterstatustracker setclusterup
log info     this servername
long tohexstring this zookeeper getrecoverablezookeeper   getsessionid
wasup
// create the snapshot manager
this snapshotmanager   new snapshotmanager this  this metricsmaster
/**
* create catalogtracker.
* in its own method so can intercept and mock it over in tests.
* @param zk if zk is null, we'll create an instance (and shut it down
* when {@link #stop(string)} is called) else we'll use what is passed.
* @param conf
* @param abortable if fatal exception we'll call abort on this.  may be null.
* if it is we'll use the connection associated with the passed
* {@link configuration} as our {@link abortable}.
* ({@link object#wait(long)} when passed a <code>0</code> waits for ever).
* @throws ioexception
*/
catalogtracker createcatalogtracker final zookeeperwatcher zk
final configuration conf  abortable abortable
throws ioexception
return new catalogtracker zk  conf  abortable
// check if we should stop every 100ms
private sleeper stopsleeper   new sleeper 100  this
private void loop
long lastmsgts   0l
long now   0l
while   this stopped
now   system currenttimemillis
if   now   lastmsgts  >  this msginterval
dometrics
lastmsgts   system currenttimemillis
stopsleeper sleep
/**
* emit the hmaster metrics, such as region in transition metrics.
* surrounding in a try block just to be sure metrics doesn't abort hmaster.
*/
private void dometrics
try
this assignmentmanager updateregionsintransitionmetrics
catch  throwable e
log error     e getmessage
/**
* finish initialization of hmaster after becoming the primary master.
*
* <ol>
* <li>initialize master components - file system manager, server manager,
*     assignment manager, region server tracker, catalog tracker, etc</li>
* <li>start necessary service threads - rpc server, info server,
*     executor services, etc</li>
* <li>set cluster as up in zookeeper</li>
* <li>wait for regionservers to check-in</li>
* <li>split logs and perform data recovery, if necessary</li>
* <li>ensure assignment of meta regions<li>
* <li>handle either fresh cluster start or master failover</li>
* </ol>
*
* @param masterrecovery
*
* @throws ioexception
* @throws interruptedexception
* @throws keeperexception
*/
private void finishinitialization monitoredtask status  boolean masterrecovery
throws ioexception  interruptedexception  keeperexception
isactivemaster   true
/*
* we are active master now... go initialize components we need to run.
* note, there may be dross in zk from previous runs; it'll get addressed
* below after we determine if cluster startup or failover.
*/
status setstatus
this masteractivetime   system currenttimemillis
// todo: do this using dependency injection, using picocontainer, guice or spring.
this filesystemmanager   new masterfilesystem this  this  metricsmaster  masterrecovery
this tabledescriptors
new fstabledescriptors this filesystemmanager getfilesystem
this filesystemmanager getrootdir
// publish cluster id
status setstatus
zkclusterid setclusterid this zookeeper  filesystemmanager getclusterid
if   masterrecovery
this executorservice   new executorservice getservername   toshortstring
this servermanager   createservermanager this  this
//initialize table lock manager, and ensure that all write locks held previously
//are invalidated
this tablelockmanager   tablelockmanager createtablelockmanager conf  zookeeper  servername
if   masterrecovery
this tablelockmanager reapwritelocks
status setstatus
initializezkbasedsystemtrackers
if   masterrecovery
// initialize master side coprocessors before we start handling requests
status setstatus
this cphost   new mastercoprocessorhost this  this conf
spanreceiverhost   spanreceiverhost getinstance getconfiguration
// start up all service threads.
status setstatus
startservicethreads
// wait for region servers to report in.
this servermanager waitforregionservers status
// check zk for region servers that are up but didn't register
for  servername sn  this regionservertracker getonlineservers
if   this servermanager isserveronline sn
servermanager checkalreadysamehostportandrecordnewserver
sn  serverload empty_serverload
log info
sn
if   masterrecovery
this assignmentmanager starttimeoutmonitor
// get a list for previously failed rs which need log splitting work
// we recover .meta. region servers inside master initialization and
// handle other failed servers in ssh in order to start up master node asap
set<servername> previouslyfailedservers   this filesystemmanager
getfailedserversfromlogfolders
// remove stale recovering regions from previous run
this filesystemmanager removestalerecoveringregionsfromzk previouslyfailedservers
// log splitting for .meta. server
servername oldmetaserverlocation   this catalogtracker getmetalocation
if  oldmetaserverlocation    null    previouslyfailedservers contains oldmetaserverlocation
splitmetalogbeforeassignment oldmetaserverlocation
// note: we can't remove oldmetaserverlocation from previousfailedservers list because it
// may also host user regions
set<servername> previouslyfailedmetarss   getpreviouselyfailedmetaserversfromzk
this initializationbeforemetaassignment   true
// make sure meta assigned before proceeding.
status setstatus
assignmeta status
// check if master is shutting down because above assignmeta could return even meta isn't
// assigned when master is shutting down
if this stopped  return
if  this distributedlogreplay      previouslyfailedmetarss isempty
// replay wal edits mode need new .meta. rs is assigned firstly
status setstatus
// need to use union of previouslyfailedmetarss recorded in zk and previouslyfailedservers
// instead of oldmetaserverlocation to address the following two situations:
// 1) the chained failure situation(recovery failed multiple times in a row).
// 2) master get killed right before it could delete the recovering meta from zk while the
// same server still has non-meta wals to be replayed so that
// removestalerecoveringregionsfromzk can't delete the stale meta region
// passing more servers into splitmetalog is all right. if a server doesn't have .meta. wal,
// there is no op for the server.
previouslyfailedmetarss addall previouslyfailedservers
this filesystemmanager splitmetalog previouslyfailedmetarss
status setstatus
// make sure system tables are assigned before proceeding.
assignsystemtables status
enableservershutdownhandler
status setstatus
// master has recovered meta region server and we put
// other failed region servers in a queue to be handled later by ssh
for  servername tmpserver   previouslyfailedservers
this servermanager processdeadserver tmpserver  true
// update meta with new pb serialization if required. i.e migrate all hri to pb serialization
// in meta. this must happen before we assign all user regions or else the assignment will
// fail.
org apache hadoop hbase catalog metamigrationconvertingtopb
updatemetaifnecessary this
this balancer setmasterservices this
// fix up assignment manager status
status setstatus
this assignmentmanager joincluster
this balancer setclusterstatus getclusterstatus
if   masterrecovery
// start balancer and meta catalog janitor after meta and regions have
// been assigned.
status setstatus
this clusterstatuschore   getandstartclusterstatuschore this
this balancerchore   getandstartbalancerchore this
this catalogjanitorchore   new catalogjanitor this  this
this namespacejanitorchore   new namespacejanitor this
startcatalogjanitorchore
startnamespacejanitorchore
status markcomplete
log info
initialized   true
// clear the dead servers with same host name and port of online server because we are not
// removing dead server with same hostname and port of rs which is trying to check in before
// master initialization. see hbase-5916.
this servermanager cleardeadserverswithsamehostnameandportofonlineserver
if   masterrecovery
if  this cphost    null
// don't let cp initialization errors kill the master
try
this cphost poststartmaster
catch  ioexception ioe
log error    ioe
/**
* useful for testing purpose also where we have
* master restart scenarios.
*/
protected void startcatalogjanitorchore
threads setdaemonthreadrunning catalogjanitorchore getthread
/**
* useful for testing purpose also where we have
* master restart scenarios.
*/
protected void startnamespacejanitorchore
threads setdaemonthreadrunning namespacejanitorchore getthread
/**
* create a {@link servermanager} instance.
* @param master
* @param services
* @return an instance of {@link servermanager}
* @throws org.apache.hadoop.hbase.zookeeperconnectionexception
* @throws ioexception
*/
servermanager createservermanager final server master
final masterservices services
throws ioexception
// we put this out here in a method so can do a mockito.spy and stub it out
// w/ a mocked up servermanager.
return new servermanager master  services
/**
* if servershutdownhandler is disabled, we enable it and expire those dead
* but not expired servers.
*/
private void enableservershutdownhandler
if   servershutdownhandlerenabled
servershutdownhandlerenabled   true
this servermanager processqueueddeadservers
/**
* check <code>.meta.</code> is assigned. if not, assign it.
* @param status monitoredtask
* @throws interruptedexception
* @throws ioexception
* @throws keeperexception
*/
void assignmeta monitoredtask status
throws interruptedexception  ioexception  keeperexception
// work on meta region
int assigned   0
long timeout   this conf getlong    1000
boolean beingexpired   false
status setstatus
assignmentmanager getregionstates   createregionstate hregioninfo first_meta_regioninfo
boolean rit   this assignmentmanager
processregionintransitionandblockuntilassigned hregioninfo first_meta_regioninfo
boolean metaregionlocation   this catalogtracker verifymetaregionlocation timeout
if   rit     metaregionlocation
servername currentmetaserver   this catalogtracker getmetalocation
if  currentmetaserver    null
beingexpired   expireifonline currentmetaserver
if  beingexpired
splitmetalogbeforeassignment currentmetaserver
assignmentmanager assignmeta
// make sure a .meta. location is set.
enablesshandwaitformeta
assigned
if  beingexpired    this distributedlogreplay
// in replay wal mode, we need the new .meta. server online
this filesystemmanager splitmetalog currentmetaserver
else if  rit     metaregionlocation
// make sure a .meta. location is set.
enablesshandwaitformeta
assigned
else
// region already assigned. we didn't assign it. add to in-memory state.
this assignmentmanager regiononline hregioninfo first_meta_regioninfo
this catalogtracker getmetalocation
enablemeta tablename meta_table_name
log info     assigned       rit
catalogtracker getmetalocation
status setstatus
private void splitmetalogbeforeassignment servername currentmetaserver  throws ioexception
if  this distributedlogreplay
// in log replay mode, we mark meta region as recovering in zk
set<hregioninfo> regions   new hashset<hregioninfo>
regions add hregioninfo first_meta_regioninfo
this filesystemmanager preparelogreplay currentmetaserver  regions
else
// in recovered.edits mode: create recovered edits file for .meta. server
this filesystemmanager splitmetalog currentmetaserver
private void splitlogbeforeassignment servername currentserver
set<hregioninfo> regions  throws ioexception
if  this distributedlogreplay
this filesystemmanager preparelogreplay currentserver  regions
else
// in recovered.edits mode: create recovered edits file for region server
this filesystemmanager splitlog currentserver
void assignsystemtables monitoredtask status
throws interruptedexception  ioexception  keeperexception
// skip assignment for regions of tables in disabling state because during clean cluster startup
// no rs is alive and regions map also doesn't have any information about the regions.
// see hbase-6281.
set<tablename> disabledordisablingorenabling   zktable getdisabledordisablingtables zookeeper
disabledordisablingorenabling addall zktable getenablingtables zookeeper
// scan meta for all system regions, skipping any disabled tables
map<hregioninfo  servername> allregions
metareader fullscan catalogtracker  disabledordisablingorenabling  true
for iterator<hregioninfo> iter   allregions keyset   iterator
iter hasnext
if   htabledescriptor issystemtable iter next   gettablename
iter remove
int assigned   0
boolean beingexpired   false
status setstatus
for map entry<hregioninfo  servername> entry  allregions entryset
hregioninfo regioninfo   entry getkey
servername currserver   entry getvalue
assignmentmanager getregionstates   createregionstate regioninfo
boolean rit   this assignmentmanager
processregionintransitionandblockuntilassigned regioninfo
boolean regionlocation   false
if  currserver    null
regionlocation   verifyregionlocation currserver  regioninfo
if   rit     regionlocation
beingexpired   expireifonline currserver
if  beingexpired
splitlogbeforeassignment currserver  sets newhashset regioninfo
assignmentmanager assign regioninfo  true
// make sure a region location is set.
this assignmentmanager waitforassignment regioninfo
assigned
if  beingexpired    this distributedlogreplay
// in replay wal mode, we need the new region server online
this filesystemmanager splitlog currserver
else if  rit     regionlocation
if   waitverifiedregionlocation regioninfo   return
assigned
else
// region already assigned. we didn't assign it. add to in-memory state.
this assignmentmanager regiononline regioninfo  currserver
if   this assignmentmanager getzktable   isenabledtable regioninfo gettablename
this assignmentmanager setenabledtable regioninfo gettablename
log info     assigned       rit
catalogtracker getmetalocation
status setstatus
initnamespace
private void enablesshandwaitformeta   throws ioexception  interruptedexception
enableservershutdownhandler
this catalogtracker waitformeta
// above check waits for general meta availability but this does not
// guarantee that the transition has completed
this assignmentmanager waitforassignment hregioninfo first_meta_regioninfo
private boolean waitverifiedregionlocation hregioninfo regioninfo  throws ioexception
while   this stopped
pair<hregioninfo  servername> p   metareader getregion catalogtracker
regioninfo getregionname
if  verifyregionlocation p getsecond    p getfirst     break
// we got here because we came of above loop.
return  this stopped
private boolean verifyregionlocation servername currserver  hregioninfo regioninfo
try
return
protobufutil getregioninfo hconnectionmanager getconnection conf
getadmin currserver
regioninfo getregionname       null
catch  ioexception e
log info   currserver  e
return false
private void enablemeta tablename metatablename
if   this assignmentmanager getzktable   isenabledtable metatablename
this assignmentmanager setenabledtable metatablename
/**
* expire a server if we find it is one of the online servers.
* @param sn servername to check.
* @return true when server <code>sn<code> is being expired by the function.
* @throws ioexception
*/
private boolean expireifonline final servername sn
throws ioexception
if  sn    null     servermanager isserveronline sn
return false
log info     sn
servermanager expireserver sn
return true
void initnamespace   throws ioexception
//create namespace manager
tablenamespacemanager   new tablenamespacemanager this
tablenamespacemanager start
/**
* this function returns a set of region server names under .meta. recovering region zk node
* @return set of meta server names which were recorded in zk
* @throws keeperexception
*/
private set<servername> getpreviouselyfailedmetaserversfromzk   throws keeperexception
set<servername> result   new hashset<servername>
string metarecoveringznode   zkutil joinznode zookeeper recoveringregionsznode
hregioninfo first_meta_regioninfo getencodedname
list<string> regionfailedservers   zkutil listchildrennowatch zookeeper  metarecoveringznode
if  regionfailedservers    null  return result
for string failedserver   regionfailedservers
servername server   servername parseservername failedserver
result add server
return result
@override
public tabledescriptors gettabledescriptors
return this tabledescriptors
/** @return infoserver object. maybe null.*/
public infoserver getinfoserver
return this infoserver
@override
public configuration getconfiguration
return this conf
@override
public servermanager getservermanager
return this servermanager
@override
public executorservice getexecutorservice
return this executorservice
@override
public masterfilesystem getmasterfilesystem
return this filesystemmanager
/**
* get the zk wrapper object - needed by master_jsp.java
* @return the zookeeper wrapper
*/
public zookeeperwatcher getzookeeperwatcher
return this zookeeper
public activemastermanager getactivemastermanager
return this activemastermanager
public masteraddresstracker getmasteraddressmanager
return this masteraddressmanager
/*
* start up all services. if any of these threads gets an unhandled exception
* then they just die with a logged message.  this should be fine because
* in general, we do not expect the master to get such unhandled exceptions
*  as oomes; it should be lightly loaded. see what hregionserver does if
*  need to install an unexpected exception handler.
*/
void startservicethreads   throws ioexception
// start the executor service pools
this executorservice startexecutorservice executortype master_open_region
conf getint    5
this executorservice startexecutorservice executortype master_close_region
conf getint    5
this executorservice startexecutorservice executortype master_server_operations
conf getint    5
this executorservice startexecutorservice executortype master_meta_server_operations
conf getint    5
this executorservice startexecutorservice executortype m_log_replay_ops
conf getint    10
// we depend on there being only one instance of this executor running
// at a time.  to do concurrency, would need fencing of enable/disable of
// tables.
this executorservice startexecutorservice executortype master_table_operations  1
// start log cleaner thread
string n   thread currentthread   getname
int cleanerinterval   conf getint    60   1000
this logcleaner
new logcleaner cleanerinterval
this  conf  getmasterfilesystem   getfilesystem
getmasterfilesystem   getoldlogdir
threads setdaemonthreadrunning logcleaner getthread    n
//start the hfile archive cleaner thread
path archivedir   hfilearchiveutil getarchivepath conf
this hfilecleaner   new hfilecleaner cleanerinterval  this  conf  getmasterfilesystem
getfilesystem    archivedir
threads setdaemonthreadrunning hfilecleaner getthread    n
// start the health checker
if  this healthcheckchore    null
threads setdaemonthreadrunning this healthcheckchore getthread    n
// start allowing requests to happen.
this rpcserver openserver
this rpcserveropen   true
if  log istraceenabled
log trace
/**
* use this when trying to figure when its ok to send in rpcs.  used by tests.
* @return true if we have successfully run {@link rpcserver#openserver()}
*/
boolean isrpcserveropen
return this rpcserveropen
private void stopservicethreads
if  log isdebugenabled
log debug
if  this rpcserver    null  this rpcserver stop
this rpcserveropen   false
// clean up and close up shop
if  this logcleaner   null  this logcleaner interrupt
if  this hfilecleaner    null  this hfilecleaner interrupt
if  this infoserver    null
log info
try
this infoserver stop
catch  exception ex
ex printstacktrace
if  this executorservice    null  this executorservice shutdown
if  this healthcheckchore    null
this healthcheckchore interrupt
private static thread getandstartclusterstatuschore hmaster master
if  master    null    master balancer    null
return null
chore chore   new clusterstatuschore master  master balancer
return threads setdaemonthreadrunning chore getthread
private static thread getandstartbalancerchore final hmaster master
// start up the load balancer chore
chore chore   new balancerchore master
return threads setdaemonthreadrunning chore getthread
private void stopchores
if  this balancerchore    null
this balancerchore interrupt
if  this clusterstatuschore    null
this clusterstatuschore interrupt
if  this catalogjanitorchore    null
this catalogjanitorchore interrupt
if  this clusterstatuspublisherchore    null
clusterstatuspublisherchore interrupt
if  this namespacejanitorchore    null
namespacejanitorchore interrupt
@override
public regionserverstartupresponse regionserverstartup
rpccontroller controller  regionserverstartuprequest request  throws serviceexception
// register with server manager
try
inetaddress ia   getremoteinetaddress request getport    request getserverstartcode
servername rs   this servermanager regionserverstartup ia  request getport
request getserverstartcode    request getservercurrenttime
// send back some config info
regionserverstartupresponse builder resp   createconfigurationsubset
namestringpair builder entry   namestringpair newbuilder
setname hconstants key_for_hostname_seen_by_master
setvalue rs gethostname
resp addmapentries entry build
return resp build
catch  ioexception ioe
throw new serviceexception ioe
/**
* @return get remote side's inetaddress
* @throws unknownhostexception
*/
inetaddress getremoteinetaddress final int port  final long serverstartcode
throws unknownhostexception
// do it out here in its own little method so can fake an address when
// mocking up in tests.
return rpcserver getremoteip
/**
* @return subset of configuration to pass initializing regionservers: e.g.
* the filesystem to use and root directory to use.
*/
protected regionserverstartupresponse builder createconfigurationsubset
regionserverstartupresponse builder resp   addconfig
regionserverstartupresponse newbuilder    hconstants hbase_dir
return addconfig resp
private regionserverstartupresponse builder addconfig
final regionserverstartupresponse builder resp  final string key
namestringpair builder entry   namestringpair newbuilder
setname key
setvalue this conf get key
resp addmapentries entry build
return resp
@override
public getlastflushedsequenceidresponse getlastflushedsequenceid rpccontroller controller
getlastflushedsequenceidrequest request  throws serviceexception
byte regionname   request getregionname   tobytearray
long seqid   servermanager getlastflushedsequenceid regionname
return responseconverter buildgetlastflushedsequenceidresponse seqid
@override
public regionserverreportresponse regionserverreport
rpccontroller controller  regionserverreportrequest request  throws serviceexception
try
clusterstatusprotos serverload sl   request getload
this servermanager regionserverreport protobufutil toservername request getserver     new serverload sl
if  sl    null    this metricsmaster    null
// up our metrics.
this metricsmaster incrementrequests sl gettotalnumberofrequests
catch  ioexception ioe
throw new serviceexception ioe
return regionserverreportresponse newbuilder   build
@override
public reportrsfatalerrorresponse reportrsfatalerror
rpccontroller controller  reportrsfatalerrorrequest request  throws serviceexception
string errortext   request geterrormessage
servername sn   protobufutil toservername request getserver
string msg       sn
errortext
log error msg
rsfatals add msg
return reportrsfatalerrorresponse newbuilder   build
public boolean ismasterrunning
return  isstopped
public ismasterrunningresponse ismasterrunning rpccontroller c  ismasterrunningrequest req
throws serviceexception
return ismasterrunningresponse newbuilder   setismasterrunning ismasterrunning    build
@override
public catalogscanresponse runcatalogscan rpccontroller c
catalogscanrequest req  throws serviceexception
try
return responseconverter buildcatalogscanresponse catalogjanitorchore scan
catch  ioexception ioe
throw new serviceexception ioe
@override
public enablecatalogjanitorresponse enablecatalogjanitor rpccontroller c
enablecatalogjanitorrequest req  throws serviceexception
return enablecatalogjanitorresponse newbuilder
setprevvalue catalogjanitorchore setenabled req getenable     build
@override
public iscatalogjanitorenabledresponse iscatalogjanitorenabled rpccontroller c
iscatalogjanitorenabledrequest req  throws serviceexception
boolean isenabled   catalogjanitorchore    null ? catalogjanitorchore getenabled     false
return iscatalogjanitorenabledresponse newbuilder   setvalue isenabled  build
/**
* @return maximum time we should run balancer for
*/
private int getbalancercutofftime
int balancercutofftime
getconfiguration   getint     1
if  balancercutofftime     1
// no time period set so create one
int balancerperiod
getconfiguration   getint    300000
balancercutofftime   balancerperiod
// if nonsense period, set it to balancerperiod
if  balancercutofftime <  0  balancercutofftime   balancerperiod
return balancercutofftime
public boolean balance   throws hbaseioexception
// if master not initialized, don't run balancer.
if   this initialized
log debug
return false
// if balance not true, don't run balancer.
if   this loadbalancertracker isbalanceron    return false
// do this call outside of synchronized block.
int maximumbalancetime   getbalancercutofftime
boolean balancerran
synchronized  this balancer
// only allow one balance run at at time.
if  this assignmentmanager getregionstates   isregionsintransition
map<string  regionstate> regionsintransition
this assignmentmanager getregionstates   getregionsintransition
log debug     regionsintransition size
org apache commons lang stringutils
abbreviate regionsintransition tostring    256
return false
if  this servermanager aredeadserversinprogress
log debug
this servermanager getdeadservers
return false
if  this cphost    null
try
if  this cphost prebalance
log debug
return false
catch  ioexception ioe
log error    ioe
return false
map<tablename  map<servername  list<hregioninfo>>> assignmentsbytable
this assignmentmanager getregionstates   getassignmentsbytable
list<regionplan> plans   new arraylist<regionplan>
//give the balancer the current cluster state.
this balancer setclusterstatus getclusterstatus
for  map<servername  list<hregioninfo>> assignments   assignmentsbytable values
list<regionplan> partialplans   this balancer balancecluster assignments
if  partialplans    null  plans addall partialplans
long cutofftime   system currenttimemillis     maximumbalancetime
int rpcount   0      number of regionplans balanced so far
long totalregplanexectime   0
balancerran   plans    null
if  plans    null     plans isempty
for  regionplan plan  plans
log info     plan
long balstarttime   system currenttimemillis
//todo: bulk assign
this assignmentmanager balance plan
totalregplanexectime    system currenttimemillis   balstarttime
rpcount
if  rpcount < plans size
// if performing next balance exceeds cutoff time, exit the loop
system currenttimemillis      totalregplanexectime   rpcount   > cutofftime
//todo: after balance, there should not be a cutoff time (keeping it as a security net for now)
log debug
maximumbalancetime
break
if  this cphost    null
try
this cphost postbalance rpcount < plans size   ? plans sublist 0  rpcount    plans
catch  ioexception ioe
// balancing already succeeded so don't change the result
log error    ioe
return balancerran
@override
public balanceresponse balance rpccontroller c  balancerequest request  throws serviceexception
try
return balanceresponse newbuilder   setbalancerran balance    build
catch  hbaseioexception ex
throw new serviceexception ex
enum balanceswitchmode
sync
async
/**
* assigns balancer switch according to balanceswitchmode
* @param b new balancer switch
* @param mode balanceswitchmode
* @return old balancer switch
*/
public boolean switchbalancer final boolean b  balanceswitchmode mode  throws ioexception
boolean oldvalue   this loadbalancertracker isbalanceron
boolean newvalue   b
try
if  this cphost    null
newvalue   this cphost prebalanceswitch newvalue
try
if  mode    balanceswitchmode sync
synchronized  this balancer
this loadbalancertracker setbalanceron newvalue
else
this loadbalancertracker setbalanceron newvalue
catch  keeperexception ke
throw new ioexception ke
log info     newvalue
if  this cphost    null
this cphost postbalanceswitch oldvalue  newvalue
catch  ioexception ioe
log warn    ioe
return oldvalue
public boolean synchronousbalanceswitch final boolean b  throws ioexception
return switchbalancer b  balanceswitchmode sync
public boolean balanceswitch final boolean b  throws ioexception
return switchbalancer b  balanceswitchmode async
@override
public setbalancerrunningresponse setbalancerrunning
rpccontroller controller  setbalancerrunningrequest req  throws serviceexception
try
boolean prevvalue    req getsynchronous   ?
synchronousbalanceswitch req geton    balanceswitch req geton
return setbalancerrunningresponse newbuilder   setprevbalancevalue prevvalue  build
catch  ioexception ioe
throw new serviceexception ioe
/**
* switch for the background catalogjanitor thread.
* used for testing.  the thread will continue to run.  it will just be a noop
* if disabled.
* @param b if false, the catalog janitor won't do anything.
*/
public void setcatalogjanitorenabled final boolean b
this catalogjanitorchore setenabled b
@override
public dispatchmergingregionsresponse dispatchmergingregions
rpccontroller controller  dispatchmergingregionsrequest request
throws serviceexception
final byte encodednameofregiona   request getregiona   getvalue
tobytearray
final byte encodednameofregionb   request getregionb   getvalue
tobytearray
final boolean forcible   request getforcible
if  request getregiona   gettype      regionspecifiertype encoded_region_name
request getregionb   gettype      regionspecifiertype encoded_region_name
log warn
regionspecifiertype encoded_region_name
request getregiona   gettype
request getregionb   gettype
regionstate regionstatea   assignmentmanager getregionstates
getregionstate bytes tostring encodednameofregiona
regionstate regionstateb   assignmentmanager getregionstates
getregionstate bytes tostring encodednameofregionb
if  regionstatea    null    regionstateb    null
throw new serviceexception new unknownregionexception
bytes tostringbinary regionstatea    null ? encodednameofregiona
encodednameofregionb
if   regionstatea isopened       regionstateb isopened
throw new serviceexception new mergeregionexception
regionstatea       regionstateb
hregioninfo regioninfoa   regionstatea getregion
hregioninfo regioninfob   regionstateb getregion
if  regioninfoa compareto regioninfob     0
throw new serviceexception new mergeregionexception
regioninfoa       regioninfob
if   forcible     hregioninfo areadjacent regioninfoa  regioninfob
throw new serviceexception new mergeregionexception
regioninfoa getregionnameasstring
regioninfob getregionnameasstring
forcible
try
dispatchmergingregions regioninfoa  regioninfob  forcible
catch  ioexception ioe
throw new serviceexception ioe
return dispatchmergingregionsresponse newbuilder   build
@override
public void dispatchmergingregions final hregioninfo region_a
final hregioninfo region_b  final boolean forcible  throws ioexception
checkinitialized
this executorservice submit new dispatchmergingregionhandler this
this catalogjanitorchore  region_a  region_b  forcible
@override
public moveregionresponse moveregion rpccontroller controller  moveregionrequest req
throws serviceexception
final byte  encodedregionname   req getregion   getvalue   tobytearray
regionspecifiertype type   req getregion   gettype
final byte  destservername    req hasdestservername   ?
bytes tobytes protobufutil toservername req getdestservername    getservername    null
moveregionresponse mrr   moveregionresponse newbuilder   build
if  type    regionspecifiertype encoded_region_name
log warn     regionspecifiertype encoded_region_name
type
try
move encodedregionname  destservername
catch  hbaseioexception ioe
throw new serviceexception ioe
return mrr
void move final byte encodedregionname
final byte destservername  throws hbaseioexception
regionstate regionstate   assignmentmanager getregionstates
getregionstate bytes tostring encodedregionname
if  regionstate    null
throw new unknownregionexception bytes tostringbinary encodedregionname
hregioninfo hri   regionstate getregion
servername dest
if  destservername    null    destservername length    0
log info
final list<servername> destservers   this servermanager createdestinationserverslist
regionstate getservername
dest   balancer randomassignment hri  destservers
else
dest   new servername bytes tostring destservername
if  dest equals regionstate getservername
log debug     hri getregionnameasstring
dest
return
// now we can do the move
regionplan rp   new regionplan hri  regionstate getservername    dest
try
checkinitialized
if  this cphost    null
if  this cphost premove hri  rp getsource    rp getdestination
return
log info     rp
this assignmentmanager balance rp
if  this cphost    null
this cphost postmove hri  rp getsource    rp getdestination
catch  ioexception ioe
if  ioe instanceof hbaseioexception
throw  hbaseioexception ioe
throw new hbaseioexception ioe
@override
public void createtable htabledescriptor htabledescriptor
byte  splitkeys
throws ioexception
if   ismasterrunning
throw new masternotrunningexception
string namespace   htabledescriptor gettablename   getnamespaceasstring
if  getnamespacedescriptor namespace     null
throw new constraintexception     namespace
hregioninfo newregions   gethregioninfos htabledescriptor  splitkeys
checkinitialized
checkcompression htabledescriptor
if  cphost    null
cphost precreatetable htabledescriptor  newregions
this executorservice submit new createtablehandler this
this filesystemmanager  htabledescriptor  conf
newregions  this  prepare
if  cphost    null
cphost postcreatetable htabledescriptor  newregions
private void checkcompression final htabledescriptor htd
throws ioexception
if   this mastercheckcompression  return
for  hcolumndescriptor hcd   htd getcolumnfamilies
checkcompression hcd
private void checkcompression final hcolumndescriptor hcd
throws ioexception
if   this mastercheckcompression  return
compressiontest testcompression hcd getcompression
compressiontest testcompression hcd getcompactioncompression
@override
public createtableresponse createtable rpccontroller controller  createtablerequest req
throws serviceexception
htabledescriptor htabledescriptor   htabledescriptor convert req gettableschema
byte  splitkeys   protobufutil getsplitkeysarray req
try
createtable htabledescriptor splitkeys
catch  ioexception ioe
throw new serviceexception ioe
return createtableresponse newbuilder   build
private hregioninfo gethregioninfos htabledescriptor htabledescriptor
byte splitkeys
hregioninfo hregioninfos   null
if  splitkeys    null    splitkeys length    0
hregioninfos   new hregioninfo
new hregioninfo htabledescriptor gettablename    null  null
else
int numregions   splitkeys length   1
hregioninfos   new hregioninfo
byte startkey   null
byte endkey   null
for  int i   0  i < numregions  i
endkey    i    splitkeys length  ? null   splitkeys
hregioninfos
new hregioninfo htabledescriptor gettablename    startkey  endkey
startkey   endkey
return hregioninfos
private static boolean iscatalogtable final tablename tablename
return tablename equals tablename meta_table_name
@override
public void deletetable final tablename tablename  throws ioexception
checkinitialized
if  cphost    null
cphost predeletetable tablename
this executorservice submit new deletetablehandler tablename  this  this  prepare
if  cphost    null
cphost postdeletetable tablename
@override
public deletetableresponse deletetable rpccontroller controller  deletetablerequest request
throws serviceexception
try
deletetable protobufutil totablename request gettablename
catch  ioexception ioe
throw new serviceexception ioe
return deletetableresponse newbuilder   build
/**
* get the number of regions of the table that have been updated by the alter.
*
* @return pair indicating the number of regions updated pair.getfirst is the
*         regions that are yet to be updated pair.getsecond is the total number
*         of regions of the table
* @throws ioexception
*/
@override
public getschemaalterstatusresponse getschemaalterstatus
rpccontroller controller  getschemaalterstatusrequest req  throws serviceexception
// todo: currently, we query using the table name on the client side. this
// may overlap with other table operations or the table operation may
// have completed before querying this api. we need to refactor to a
// transaction system in the future to avoid these ambiguities.
tablename tablename   protobufutil totablename req gettablename
try
pair<integer integer> pair   this assignmentmanager getreopenstatus tablename
getschemaalterstatusresponse builder ret   getschemaalterstatusresponse newbuilder
ret setyettoupdateregions pair getfirst
ret settotalregions pair getsecond
return ret build
catch  ioexception ioe
throw new serviceexception ioe
@override
public void addcolumn final tablename tablename  final hcolumndescriptor column
throws ioexception
checkinitialized
if  cphost    null
if  cphost preaddcolumn tablename  column
return
//todo: we should process this (and some others) in an executor
new tableaddfamilyhandler tablename  column  this  this
prepare   process
if  cphost    null
cphost postaddcolumn tablename  column
@override
public addcolumnresponse addcolumn rpccontroller controller  addcolumnrequest req
throws serviceexception
try
addcolumn protobufutil totablename req gettablename
hcolumndescriptor convert req getcolumnfamilies
catch  ioexception ioe
throw new serviceexception ioe
return addcolumnresponse newbuilder   build
@override
public void modifycolumn tablename tablename  hcolumndescriptor descriptor
throws ioexception
checkinitialized
checkcompression descriptor
if  cphost    null
if  cphost premodifycolumn tablename  descriptor
return
new tablemodifyfamilyhandler tablename  descriptor  this  this
prepare   process
if  cphost    null
cphost postmodifycolumn tablename  descriptor
@override
public modifycolumnresponse modifycolumn rpccontroller controller  modifycolumnrequest req
throws serviceexception
try
modifycolumn protobufutil totablename req gettablename
hcolumndescriptor convert req getcolumnfamilies
catch  ioexception ioe
throw new serviceexception ioe
return modifycolumnresponse newbuilder   build
@override
public void deletecolumn final tablename tablename  final byte columnname
throws ioexception
checkinitialized
if  cphost    null
if  cphost predeletecolumn tablename  columnname
return
new tabledeletefamilyhandler tablename  columnname  this  this  prepare   process
if  cphost    null
cphost postdeletecolumn tablename  columnname
@override
public deletecolumnresponse deletecolumn rpccontroller controller  deletecolumnrequest req
throws serviceexception
try
deletecolumn protobufutil totablename req gettablename
req getcolumnname   tobytearray
catch  ioexception ioe
throw new serviceexception ioe
return deletecolumnresponse newbuilder   build
@override
public void enabletable final tablename tablename  throws ioexception
checkinitialized
if  cphost    null
cphost preenabletable tablename
this executorservice submit new enabletablehandler this  tablename
catalogtracker  assignmentmanager  tablelockmanager  false  prepare
if  cphost    null
cphost postenabletable tablename
@override
public enabletableresponse enabletable rpccontroller controller  enabletablerequest request
throws serviceexception
try
enabletable protobufutil totablename request gettablename
catch  ioexception ioe
throw new serviceexception ioe
return enabletableresponse newbuilder   build
@override
public void disabletable final tablename tablename  throws ioexception
checkinitialized
if  cphost    null
cphost predisabletable tablename
this executorservice submit new disabletablehandler this  tablename
catalogtracker  assignmentmanager  tablelockmanager  false  prepare
if  cphost    null
cphost postdisabletable tablename
@override
public disabletableresponse disabletable rpccontroller controller  disabletablerequest request
throws serviceexception
try
disabletable protobufutil totablename request gettablename
catch  ioexception ioe
throw new serviceexception ioe
return disabletableresponse newbuilder   build
/**
* return the region and current deployment for the region containing
* the given row. if the region cannot be found, returns null. if it
* is found, but not currently deployed, the second element of the pair
* may be null.
*/
pair<hregioninfo  servername> gettableregionforrow
final tablename tablename  final byte  rowkey
throws ioexception
final atomicreference<pair<hregioninfo  servername>> result
new atomicreference<pair<hregioninfo  servername>> null
metascannervisitor visitor
new metascannervisitorbase
@override
public boolean processrow result data  throws ioexception
if  data    null    data size   <  0
return true
pair<hregioninfo  servername> pair   hregioninfo gethregioninfoandservername data
if  pair    null
return false
if   pair getfirst   gettablename   equals tablename
return false
result set pair
return true
metascanner metascan conf  visitor  tablename  rowkey  1
return result get
@override
public void modifytable final tablename tablename  final htabledescriptor descriptor
throws ioexception
checkinitialized
checkcompression descriptor
if  cphost    null
cphost premodifytable tablename  descriptor
new modifytablehandler tablename  descriptor  this  this  prepare   process
if  cphost    null
cphost postmodifytable tablename  descriptor
@override
public modifytableresponse modifytable rpccontroller controller  modifytablerequest req
throws serviceexception
try
modifytable protobufutil totablename req gettablename
htabledescriptor convert req gettableschema
catch  ioexception ioe
throw new serviceexception ioe
return modifytableresponse newbuilder   build
@override
public void checktablemodifiable final tablename tablename
throws ioexception  tablenotfoundexception  tablenotdisabledexception
if  iscatalogtable tablename
throw new ioexception
if   metareader tableexists getcatalogtracker    tablename
throw new tablenotfoundexception tablename
if   getassignmentmanager   getzktable
isdisabledtable tablename
throw new tablenotdisabledexception tablename
@override
public getclusterstatusresponse getclusterstatus rpccontroller controller
getclusterstatusrequest req
throws serviceexception
getclusterstatusresponse builder response   getclusterstatusresponse newbuilder
response setclusterstatus getclusterstatus   convert
return response build
/**
* @return cluster status
*/
public clusterstatus getclusterstatus
// build set of backup masters from zk nodes
list<string> backupmasterstrings
try
backupmasterstrings   zkutil listchildrennowatch this zookeeper
this zookeeper backupmasteraddressesznode
catch  keeperexception e
log warn this zookeeper prefix     e
backupmasterstrings   new arraylist<string> 0
list<servername> backupmasters   new arraylist<servername>
backupmasterstrings size
for  string s  backupmasterstrings
try
byte  bytes
zkutil getdata this zookeeper  zkutil joinznode
this zookeeper backupmasteraddressesznode  s
if  bytes    null
servername sn
try
sn   servername parsefrom bytes
catch  deserializationexception e
log warn    e
continue
backupmasters add sn
catch  keeperexception e
log warn this zookeeper prefix
e
collections sort backupmasters  new comparator<servername>
public int compare servername s1  servername s2
return s1 getservername   compareto s2 getservername
return new clusterstatus versioninfo getversion
this filesystemmanager getclusterid   tostring
this servermanager getonlineservers
this servermanager getdeadservers   copyservernames
this servername
backupmasters
this assignmentmanager getregionstates   getregionsintransition
this getcoprocessors    this loadbalancertracker isbalanceron
public string getclusterid
if  filesystemmanager    null
return
clusterid id   filesystemmanager getclusterid
if  id    null
return
return id tostring
/**
* the set of loaded coprocessors is stored in a static set. since it's
* statically allocated, it does not require that hmaster's cphost be
* initialized prior to accessing it.
* @return a string representation of the set of names of the loaded
* coprocessors.
*/
public static string getloadedcoprocessors
return coprocessorhost getloadedcoprocessors   tostring
/**
* @return timestamp in millis when hmaster was started.
*/
public long getmasterstarttime
return masterstarttime
/**
* @return timestamp in millis when hmaster became the active master.
*/
public long getmasteractivetime
return masteractivetime
/**
* @return array of coprocessor simplenames.
*/
public string getcoprocessors
set<string> mastercoprocessors
getcoprocessorhost   getcoprocessors
return mastercoprocessors toarray new string
@override
public void abort final string msg  final throwable t
if  cphost    null
// hbase-4014: dump a list of loaded coprocessors.
log fatal
getloadedcoprocessors
if  abortnow msg  t
if  t    null  log fatal msg  t
else log fatal msg
this abort   true
stop
/**
* we do the following in a different thread.  if it is not completed
* in time, we will time it out and assume it is not easy to recover.
*
* 1. create a new zk session. (since our current one is expired)
* 2. try to become a primary master again
* 3. initialize all zk based system trackers.
* 4. assign meta. (they are already assigned, but we need to update our
* internal memory state to reflect it)
* 5. process any rit if any during the process of our recovery.
*
* @return true if we could successfully recover from zk session expiry.
* @throws interruptedexception
* @throws ioexception
* @throws keeperexception
* @throws executionexception
*/
private boolean tryrecoveringexpiredzksession   throws interruptedexception
ioexception  keeperexception  executionexception
this zookeeper unregisteralllisteners
// add back listeners which were registered before master initialization
// because they won't be added back in below master re-initialization code
if  this registeredzklistenersbeforerecovery    null
for  zookeeperlistener curlistener   this registeredzklistenersbeforerecovery
this zookeeper registerlistener curlistener
this zookeeper reconnectafterexpiration
callable<boolean> callable   new callable<boolean>
public boolean call   throws interruptedexception
ioexception  keeperexception
monitoredtask status
taskmonitor get   createstatus
try
if   becomeactivemaster status
return boolean false
servershutdownhandlerenabled   false
initialized   false
finishinitialization status  true
return  stopped
finally
status cleanup
long timeout
conf getlong    300000
java util concurrent executorservice executor
executors newsinglethreadexecutor
future<boolean> result   executor submit callable
executor shutdown
if  executor awaittermination timeout  timeunit milliseconds
result isdone
boolean recovered   result get
if  recovered    null
return recovered booleanvalue
executor shutdownnow
return false
/**
* check to see if the current trigger for abort is due to zookeeper session
* expiry, and if yes, whether we can recover from zk session expiry.
*
* @param msg original abort message
* @param t   the cause for current abort request
* @return true if we should proceed with abort operation, false other wise.
*/
private boolean abortnow final string msg  final throwable t
if   this isactivemaster    this stopped
return true
if  t    null    t instanceof keeperexception sessionexpiredexception
try
log info
return  tryrecoveringexpiredzksession
catch  throwable newt
log error
newt
return true
@override
public zookeeperwatcher getzookeeper
return zookeeper
@override
public mastercoprocessorhost getcoprocessorhost
return cphost
@override
public servername getservername
return this servername
@override
public catalogtracker getcatalogtracker
return catalogtracker
@override
public assignmentmanager getassignmentmanager
return this assignmentmanager
@override
public tablelockmanager gettablelockmanager
return this tablelockmanager
public memoryboundedlogmessagebuffer getregionserverfatallogbuffer
return rsfatals
public void shutdown
if  spanreceiverhost    null
spanreceiverhost closereceivers
if  cphost    null
try
cphost preshutdown
catch  ioexception ioe
log error    ioe
if  mxbean    null
mbeanutil unregistermbean mxbean
mxbean   null
if  this assignmentmanager    null  this assignmentmanager shutdown
if  this servermanager    null  this servermanager shutdowncluster
try
if  this clusterstatustracker    null
this clusterstatustracker setclusterdown
catch  keeperexception e
log error    e
@override
public shutdownresponse shutdown rpccontroller controller  shutdownrequest request
throws serviceexception
shutdown
return shutdownresponse newbuilder   build
public void stopmaster
if  cphost    null
try
cphost prestopmaster
catch  ioexception ioe
log error    ioe
stop     thread currentthread   getname
@override
public stopmasterresponse stopmaster rpccontroller controller  stopmasterrequest request
throws serviceexception
stopmaster
return stopmasterresponse newbuilder   build
@override
public void stop final string why
log info why
this stopped   true
// we wake up the stopsleeper to stop immediately
stopsleeper skipsleepcycle
// if we are a backup master, we need to interrupt wait
if  this activemastermanager    null
synchronized  this activemastermanager clusterhasactivemaster
this activemastermanager clusterhasactivemaster notifyall
// if no region server is online then master may stuck waiting on .meta. to come on line.
// see hbase-8422.
if  this catalogtracker    null    this servermanager getonlineservers   isempty
this catalogtracker stop
@override
public boolean isstopped
return this stopped
public boolean isaborted
return this abort
void checkinitialized   throws pleaseholdexception
if   this initialized
throw new pleaseholdexception
/**
* report whether this master is currently the active master or not.
* if not active master, we are parked on zk waiting to become active.
*
* this method is used for testing.
*
* @return true if active master, false if not.
*/
public boolean isactivemaster
return isactivemaster
/**
* report whether this master has completed with its initialization and is
* ready.  if ready, the master is also the active master.  a standby master
* is never ready.
*
* this method is used for testing.
*
* @return true if master is ready to go, false if not.
*/
public boolean isinitialized
return initialized
/**
* servershutdownhandlerenabled is set false before completing
* assignmeta to prevent processing of servershutdownhandler.
* @return true if assignmeta has completed;
*/
public boolean isservershutdownhandlerenabled
return this servershutdownhandlerenabled
/**
* report whether this master has started initialization and is about to do meta region assignment
* @return true if master is in initialization & about to assign meta regions
*/
public boolean isinitializationstartsmetaregionassignment
return this initializationbeforemetaassignment
@override
public assignregionresponse assignregion rpccontroller controller  assignregionrequest req
throws serviceexception
try
final byte  regionname   req getregion   getvalue   tobytearray
regionspecifiertype type   req getregion   gettype
assignregionresponse arr   assignregionresponse newbuilder   build
checkinitialized
if  type    regionspecifiertype region_name
log warn     regionspecifiertype region_name
type
hregioninfo regioninfo   assignmentmanager getregionstates   getregioninfo regionname
if  regioninfo    null  throw new unknownregionexception bytes tostring regionname
if  cphost    null
if  cphost preassign regioninfo
return arr
assignmentmanager assign regioninfo  true  true
if  cphost    null
cphost postassign regioninfo
return arr
catch  ioexception ioe
throw new serviceexception ioe
public void assignregion hregioninfo hri
assignmentmanager assign hri  true
@override
public unassignregionresponse unassignregion rpccontroller controller  unassignregionrequest req
throws serviceexception
try
final byte  regionname   req getregion   getvalue   tobytearray
regionspecifiertype type   req getregion   gettype
final boolean force   req getforce
unassignregionresponse urr   unassignregionresponse newbuilder   build
checkinitialized
if  type    regionspecifiertype region_name
log warn     regionspecifiertype region_name
type
pair<hregioninfo  servername> pair
metareader getregion this catalogtracker  regionname
if  pair    null  throw new unknownregionexception bytes tostring regionname
hregioninfo hri   pair getfirst
if  cphost    null
if  cphost preunassign hri  force
return urr
log debug     hri getregionnameasstring
force
this assignmentmanager unassign hri  force
if   this assignmentmanager getregionstates   isregionintransition hri
this assignmentmanager getregionstates   isregionassigned hri
log debug     hri getregionnameasstring
assignregion hri
if  cphost    null
cphost postunassign hri  force
return urr
catch  ioexception ioe
throw new serviceexception ioe
/**
* get list of tabledescriptors for requested tables.
* @param controller unused (set to null).
* @param req gettabledescriptorsrequest that contains:
* - tablenames: requested tables, or if empty, all are requested
* @return gettabledescriptorsresponse
* @throws serviceexception
*/
public gettabledescriptorsresponse gettabledescriptors
rpccontroller controller  gettabledescriptorsrequest req  throws serviceexception
list<htabledescriptor> descriptors   new arraylist<htabledescriptor>
list<tablename> tablenamelist   new arraylist<tablename>
for hbaseprotos tablename tablenamepb  req gettablenameslist
tablenamelist add protobufutil totablename tablenamepb
boolean bypass   false
if  this cphost    null
try
bypass   this cphost pregettabledescriptors tablenamelist  descriptors
catch  ioexception ioe
throw new serviceexception ioe
if   bypass
if  req gettablenamescount      0
// request for all tabledescriptors
map<string  htabledescriptor> descriptormap   null
try
descriptormap   this tabledescriptors getall
catch  ioexception e
log warn    e
if  descriptormap    null
for htabledescriptor desc  descriptormap values
if  htabledescriptor issystemtable desc gettablename
descriptors add desc
else
for  tablename s  tablenamelist
try
htabledescriptor desc   this tabledescriptors get s
if  desc    null
descriptors add desc
catch  ioexception e
log warn     s  e
if  this cphost    null
try
this cphost postgettabledescriptors descriptors
catch  ioexception ioe
throw new serviceexception ioe
gettabledescriptorsresponse builder builder   gettabledescriptorsresponse newbuilder
for  htabledescriptor htd  descriptors
builder addtableschema htd convert
return builder build
/**
* get list of userspace table names
* @param controller unused (set to null).
* @param req gettablenamesrequest
* @return gettablenamesresponse
* @throws serviceexception
*/
public gettablenamesresponse gettablenames
rpccontroller controller  gettablenamesrequest req  throws serviceexception
try
collection<htabledescriptor> descriptors   this tabledescriptors getall   values
gettablenamesresponse builder builder   gettablenamesresponse newbuilder
for  htabledescriptor descriptor  descriptors
if  descriptor ismetatable
continue
builder addtablenames protobufutil toprototablename descriptor gettablename
return builder build
catch  ioexception e
throw new serviceexception e
/**
* compute the average load across all region servers.
* currently, this uses a very naive computation - just uses the number of
* regions being served, ignoring stats about number of requests.
* @return the average load
*/
public double getaverageload
if  this assignmentmanager    null
return 0
regionstates regionstates   this assignmentmanager getregionstates
if  regionstates    null
return 0
return regionstates getaverageload
/**
* offline specified region from master's in-memory state. it will not attempt to
* reassign the region as in unassign.
*
* this is a special method that should be used by experts or hbck.
*
*/
@override
public offlineregionresponse offlineregion rpccontroller controller  offlineregionrequest request
throws serviceexception
final byte  regionname   request getregion   getvalue   tobytearray
regionspecifiertype type   request getregion   gettype
if  type    regionspecifiertype region_name
log warn     regionspecifiertype region_name
type
try
pair<hregioninfo  servername> pair
metareader getregion this catalogtracker  regionname
if  pair    null  throw new unknownregionexception bytes tostringbinary regionname
hregioninfo hri   pair getfirst
if  cphost    null
cphost preregionoffline hri
this assignmentmanager regionoffline hri
if  cphost    null
cphost postregionoffline hri
catch  ioexception ioe
throw new serviceexception ioe
return offlineregionresponse newbuilder   build
@override
public boolean registerservice service instance
/*
* no stacking of instances is allowed for a single service name
*/
descriptors servicedescriptor servicedesc   instance getdescriptorfortype
if  coprocessorservicehandlers containskey servicedesc getfullname
log error   servicedesc getfullname
instance
return false
coprocessorservicehandlers put servicedesc getfullname    instance
if  log isdebugenabled
log debug   servicedesc getfullname
return true
@override
public clientprotos coprocessorserviceresponse execmasterservice final rpccontroller controller
final clientprotos coprocessorservicerequest request  throws serviceexception
try
serverrpccontroller execcontroller   new serverrpccontroller
clientprotos coprocessorservicecall call   request getcall
string servicename   call getservicename
string methodname   call getmethodname
if   coprocessorservicehandlers containskey servicename
throw new unknownprotocolexception null
servicename
service service   coprocessorservicehandlers get servicename
descriptors servicedescriptor servicedesc   service getdescriptorfortype
descriptors methoddescriptor methoddesc   servicedesc findmethodbyname methodname
if  methoddesc    null
throw new unknownprotocolexception service getclass
methodname   servicename
//invoke the method
message execrequest   service getrequestprototype methoddesc  newbuilderfortype
mergefrom call getrequest    build
final message builder responsebuilder
service getresponseprototype methoddesc  newbuilderfortype
service callmethod methoddesc  execcontroller  execrequest  new rpccallback<message>
@override
public void run message message
if  message    null
responsebuilder mergefrom message
message execresult   responsebuilder build
if  execcontroller getfailedon      null
throw execcontroller getfailedon
clientprotos coprocessorserviceresponse builder builder
clientprotos coprocessorserviceresponse newbuilder
builder setregion requestconverter buildregionspecifier
regionspecifiertype region_name  hconstants empty_byte_array
builder setvalue
builder getvaluebuilder   setname execresult getclass   getname
setvalue execresult tobytestring
return builder build
catch  ioexception ie
throw new serviceexception ie
/**
* utility for constructing an instance of the passed hmaster class.
* @param masterclass
* @param conf
* @return hmaster instance.
*/
public static hmaster constructmaster class<? extends hmaster> masterclass
final configuration conf
try
constructor<? extends hmaster> c
masterclass getconstructor configuration class
return c newinstance conf
catch  invocationtargetexception ite
throwable target   ite gettargetexception      null?
ite gettargetexception    ite
if  target getcause      null  target   target getcause
throw new runtimeexception
masterclass tostring    target
catch  exception e
throw new runtimeexception
masterclass tostring       e getcause      null ?
e getcause   getmessage        e
/**
* @see org.apache.hadoop.hbase.master.hmastercommandline
*/
public static void main string  args
versioninfo logversion
new hmastercommandline hmaster class  domain args
public hfilecleaner gethfilecleaner
return this hfilecleaner
/**
* exposed for testing!
* @return the underlying snapshot manager
*/
public snapshotmanager getsnapshotmanagerfortesting
return this snapshotmanager
/**
* triggers an asynchronous attempt to take a snapshot.
* {@inheritdoc}
*/
@override
public takesnapshotresponse snapshot rpccontroller controller  takesnapshotrequest request
throws serviceexception
try
this snapshotmanager checksnapshotsupport
catch  unsupportedoperationexception e
throw new serviceexception e
log debug
clientsnapshotdescriptionutils tostring request getsnapshot
// get the snapshot information
snapshotdescription snapshot   snapshotdescriptionutils validate request getsnapshot
this conf
try
snapshotmanager takesnapshot snapshot
catch  ioexception e
throw new serviceexception e
// send back the max amount of time the client should wait for the snapshot to complete
long waittime   snapshotdescriptionutils getmaxmastertimeout conf  snapshot gettype
snapshotdescriptionutils default_max_wait_time
return takesnapshotresponse newbuilder   setexpectedtimeout waittime  build
/**
* list the currently available/stored snapshots. any in-progress snapshots are ignored
*/
@override
public listsnapshotresponse getcompletedsnapshots rpccontroller controller
listsnapshotrequest request  throws serviceexception
try
listsnapshotresponse builder builder   listsnapshotresponse newbuilder
list<snapshotdescription> snapshots   snapshotmanager getcompletedsnapshots
// convert to protobuf
for  snapshotdescription snapshot   snapshots
builder addsnapshots snapshot
return builder build
catch  ioexception e
throw new serviceexception e
/**
* execute delete snapshot operation.
* @return deletesnapshotresponse (a protobuf wrapped void) if the snapshot existed and was
*    deleted properly.
* @throws serviceexception wrapping snapshotdoesnotexistexception if specified snapshot did not
*    exist.
*/
@override
public deletesnapshotresponse deletesnapshot rpccontroller controller
deletesnapshotrequest request  throws serviceexception
try
this snapshotmanager checksnapshotsupport
catch  unsupportedoperationexception e
throw new serviceexception e
try
snapshotmanager deletesnapshot request getsnapshot
return deletesnapshotresponse newbuilder   build
catch  ioexception e
throw new serviceexception e
/**
* checks if the specified snapshot is done.
* @return true if the snapshot is in file system ready to use,
*   false if the snapshot is in the process of completing
* @throws serviceexception wrapping unknownsnapshotexception if invalid snapshot, or
*  a wrapped hbasesnapshotexception with progress failure reason.
*/
@override
public issnapshotdoneresponse issnapshotdone rpccontroller controller
issnapshotdonerequest request  throws serviceexception
log debug
clientsnapshotdescriptionutils tostring request getsnapshot
try
issnapshotdoneresponse builder builder   issnapshotdoneresponse newbuilder
boolean done   snapshotmanager issnapshotdone request getsnapshot
builder setdone done
return builder build
catch  ioexception e
throw new serviceexception e
/**
* execute restore/clone snapshot operation.
*
* <p>if the specified table exists a "restore" is executed, replacing the table
* schema and directory data with the content of the snapshot.
* the table must be disabled, or a unsupportedoperationexception will be thrown.
*
* <p>if the table doesn't exist a "clone" is executed, a new table is created
* using the schema at the time of the snapshot, and the content of the snapshot.
*
* <p>the restore/clone operation does not require copying hfiles. since hfiles
* are immutable the table can point to and use the same files as the original one.
*/
@override
public restoresnapshotresponse restoresnapshot rpccontroller controller
restoresnapshotrequest request  throws serviceexception
try
this snapshotmanager checksnapshotsupport
catch  unsupportedoperationexception e
throw new serviceexception e
try
snapshotdescription reqsnapshot   request getsnapshot
snapshotmanager restoresnapshot reqsnapshot
return restoresnapshotresponse newbuilder   build
catch  ioexception e
throw new serviceexception e
/**
* returns the status of the requested snapshot restore/clone operation.
* this method is not exposed to the user, it is just used internally by hbaseadmin
* to verify if the restore is completed.
*
* no exceptions are thrown if the restore is not running, the result will be "done".
*
* @return done <tt>true</tt> if the restore/clone operation is completed.
* @throws serviceexception if the operation failed.
*/
@override
public isrestoresnapshotdoneresponse isrestoresnapshotdone rpccontroller controller
isrestoresnapshotdonerequest request  throws serviceexception
try
snapshotdescription snapshot   request getsnapshot
isrestoresnapshotdoneresponse builder builder   isrestoresnapshotdoneresponse newbuilder
boolean done   snapshotmanager isrestoredone snapshot
builder setdone done
return builder build
catch  ioexception e
throw new serviceexception e
@override
public masteradminprotos modifynamespaceresponse modifynamespace rpccontroller controller
masteradminprotos modifynamespacerequest request  throws serviceexception
try
modifynamespace protobufutil tonamespacedescriptor request getnamespacedescriptor
return masteradminprotos modifynamespaceresponse getdefaultinstance
catch  ioexception e
throw new serviceexception e
@override
public masteradminprotos createnamespaceresponse createnamespace rpccontroller controller
masteradminprotos createnamespacerequest request  throws serviceexception
try
createnamespace protobufutil tonamespacedescriptor request getnamespacedescriptor
return masteradminprotos createnamespaceresponse getdefaultinstance
catch  ioexception e
throw new serviceexception e
@override
public masteradminprotos deletenamespaceresponse deletenamespace rpccontroller controller  masteradminprotos deletenamespacerequest request  throws serviceexception
try
deletenamespace request getnamespacename
return masteradminprotos deletenamespaceresponse getdefaultinstance
catch  ioexception e
throw new serviceexception e
@override
public masteradminprotos getnamespacedescriptorresponse getnamespacedescriptor
rpccontroller controller  masteradminprotos getnamespacedescriptorrequest request
throws serviceexception
try
return masteradminprotos getnamespacedescriptorresponse newbuilder
setnamespacedescriptor
protobufutil toprotonamespacedescriptor getnamespacedescriptor request getnamespacename
build
catch  ioexception e
throw new serviceexception e
@override
public masteradminprotos listnamespacedescriptorsresponse listnamespacedescriptors
rpccontroller controller  masteradminprotos listnamespacedescriptorsrequest request
throws serviceexception
try
masteradminprotos listnamespacedescriptorsresponse builder response
masteradminprotos listnamespacedescriptorsresponse newbuilder
for namespacedescriptor ns  listnamespacedescriptors
response addnamespacedescriptor protobufutil toprotonamespacedescriptor ns
return response build
catch  ioexception e
throw new serviceexception e
@override
public masteradminprotos listtabledescriptorsbynamespaceresponse listtabledescriptorsbynamespace
rpccontroller controller  masteradminprotos listtabledescriptorsbynamespacerequest request
throws serviceexception
try
masteradminprotos listtabledescriptorsbynamespaceresponse builder b
masteradminprotos listtabledescriptorsbynamespaceresponse newbuilder
for htabledescriptor htd  listtabledescriptorsbynamespace request getnamespacename
b addtableschema htd convert
return b build
catch  ioexception e
throw new serviceexception e
@override
public masteradminprotos listtablenamesbynamespaceresponse listtablenamesbynamespace
rpccontroller controller  masteradminprotos listtablenamesbynamespacerequest request
throws serviceexception
try
masteradminprotos listtablenamesbynamespaceresponse builder b
masteradminprotos listtablenamesbynamespaceresponse newbuilder
for  tablename tablename  listtablenamesbynamespace request getnamespacename
b addtablename protobufutil toprototablename tablename
return b build
catch  ioexception e
throw new serviceexception e
private boolean ishealthcheckerconfigured
string healthscriptlocation   this conf get hconstants health_script_loc
return org apache commons lang stringutils isnotblank healthscriptlocation
public void createnamespace namespacedescriptor descriptor  throws ioexception
tablename islegalnamespacename bytes tobytes descriptor getname
if  cphost    null
if  cphost precreatenamespace descriptor
return
tablenamespacemanager create descriptor
if  cphost    null
cphost postcreatenamespace descriptor
public void modifynamespace namespacedescriptor descriptor  throws ioexception
tablename islegalnamespacename bytes tobytes descriptor getname
if  cphost    null
if  cphost premodifynamespace descriptor
return
tablenamespacemanager update descriptor
if  cphost    null
cphost postmodifynamespace descriptor
public void deletenamespace string name  throws ioexception
if  cphost    null
if  cphost predeletenamespace name
return
tablenamespacemanager remove name
if  cphost    null
cphost postdeletenamespace name
public namespacedescriptor getnamespacedescriptor string name  throws ioexception
return tablenamespacemanager get name
public list<namespacedescriptor> listnamespacedescriptors   throws ioexception
return lists newarraylist tablenamespacemanager list
public list<htabledescriptor> listtabledescriptorsbynamespace string name  throws ioexception
return lists newarraylist tabledescriptors getbynamespace name  values
public list<tablename> listtablenamesbynamespace string name  throws ioexception
list<tablename> tablenames   lists newarraylist
for  htabledescriptor descriptor  tabledescriptors getbynamespace name  values
tablenames add tablename valueof name  descriptor getnameasstring
return tablenames