/*
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase coprocessor
import java io ioexception
import java util list
import java util navigableset
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import org apache hadoop hbase coprocessor
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase keyvalue
import org apache hadoop hbase client append
import org apache hadoop hbase client delete
import org apache hadoop hbase client get
import org apache hadoop hbase client increment
import org apache hadoop hbase client mutation
import org apache hadoop hbase client put
import org apache hadoop hbase client result
import org apache hadoop hbase client scan
import org apache hadoop hbase client durability
import org apache hadoop hbase filter comparefilter compareop
import org apache hadoop hbase filter bytearraycomparable
import org apache hadoop hbase regionserver hregion
import org apache hadoop hbase regionserver internalscanner
import org apache hadoop hbase regionserver keyvaluescanner
import org apache hadoop hbase regionserver minibatchoperationinprogress
import org apache hadoop hbase regionserver regionscanner
import org apache hadoop hbase regionserver scantype
import org apache hadoop hbase regionserver store
import org apache hadoop hbase regionserver storefile
import org apache hadoop hbase regionserver storefilescanner
import org apache hadoop hbase regionserver compactions compactionrequest
import org apache hadoop hbase regionserver wal hlogkey
import org apache hadoop hbase regionserver wal waledit
import com google common collect immutablelist
import org apache hadoop hbase util pair
/**
* coprocessors implement this interface to observe and mediate client actions
* on the region.
*/
@interfaceaudience public
@interfacestability evolving
public interface regionobserver extends coprocessor
/**
* called before the region is reported as open to the master.
* @param c the environment provided by the region server
* @throws ioexception if an error occurred on the coprocessor
*/
void preopen final observercontext<regioncoprocessorenvironment> c  throws ioexception
/**
* called after the region is reported as open to the master.
* @param c the environment provided by the region server
*/
void postopen final observercontext<regioncoprocessorenvironment> c
/**
* called before a memstore is flushed to disk and prior to creating the scanner to read from
* the memstore.  to override or modify how a memstore is flushed,
* implementing classes can return a new scanner to provide the keyvalues to be
* stored into the new {@code storefile} or null to perform the default processing.
* calling {@link org.apache.hadoop.hbase.coprocessor.observercontext#bypass()} has no
* effect in this hook.
* @param c the environment provided by the region server
* @param store the store being flushed
* @param memstorescanner the scanner for the memstore that is flushed
* @param s the base scanner, if not {@code null}, from previous regionobserver in the chain
* @return the scanner to use during the flush.  {@code null} if the default implementation
* is to be used.
* @throws ioexception if an error occurred on the coprocessor
*/
internalscanner preflushscanneropen final observercontext<regioncoprocessorenvironment> c
final store store  final keyvaluescanner memstorescanner  final internalscanner s
throws ioexception
/**
* called before the memstore is flushed to disk.
* @param c the environment provided by the region server
* @throws ioexception if an error occurred on the coprocessor
* @deprecated use {@link #preflush(observercontext, store, internalscanner)} instead
*/
void preflush final observercontext<regioncoprocessorenvironment> c  throws ioexception
/**
* called before a store's memstore is flushed to disk.
* @param c the environment provided by the region server
* @param store the store where compaction is being requested
* @param scanner the scanner over existing data used in the store file
* @return the scanner to use during compaction.  should not be {@code null}
* unless the implementation is writing new store files on its own.
* @throws ioexception if an error occurred on the coprocessor
*/
internalscanner preflush final observercontext<regioncoprocessorenvironment> c  final store store
final internalscanner scanner  throws ioexception
/**
* called after the memstore is flushed to disk.
* @param c the environment provided by the region server
* @throws ioexception if an error occurred on the coprocessor
* @deprecated use {@link #preflush(observercontext, store, internalscanner)} instead.
*/
void postflush final observercontext<regioncoprocessorenvironment> c  throws ioexception
/**
* called after a store's memstore is flushed to disk.
* @param c the environment provided by the region server
* @param store the store being flushed
* @param resultfile the new store file written out during compaction
* @throws ioexception if an error occurred on the coprocessor
*/
void postflush final observercontext<regioncoprocessorenvironment> c  final store store
final storefile resultfile  throws ioexception
/**
* called prior to selecting the {@link storefile storefiles} to compact from the list of
* available candidates. to alter the files used for compaction, you may mutate the passed in list
* of candidates.
* @param c the environment provided by the region server
* @param store the store where compaction is being requested
* @param candidates the store files currently available for compaction
* @param request custom compaction request
* @throws ioexception if an error occurred on the coprocessor
*/
void precompactselection final observercontext<regioncoprocessorenvironment> c
final store store  final list<storefile> candidates  final compactionrequest request
throws ioexception
/**
* called prior to selecting the {@link storefile}s to compact from the list of available
* candidates. to alter the files used for compaction, you may mutate the passed in list of
* candidates.
* @param c the environment provided by the region server
* @param store the store where compaction is being requested
* @param candidates the store files currently available for compaction
* @throws ioexception if an error occurred on the coprocessor
* @deprecated use {@link #precompactselection(observercontext, store, list, compactionrequest)}
*             instead
*/
@deprecated
void precompactselection final observercontext<regioncoprocessorenvironment> c
final store store  final list<storefile> candidates  throws ioexception
/**
* called after the {@link storefile}s to compact have been selected from the available
* candidates.
* @param c the environment provided by the region server
* @param store the store being compacted
* @param selected the store files selected to compact
* @param request custom compaction request
*/
void postcompactselection final observercontext<regioncoprocessorenvironment> c
final store store  final immutablelist<storefile> selected  compactionrequest request
/**
* called after the {@link storefile}s to compact have been selected from the available
* candidates.
* @param c the environment provided by the region server
* @param store the store being compacted
* @param selected the store files selected to compact
* @deprecated use {@link #postcompactselection(observercontext, store, immutablelist,
*             compactionrequest)} instead.
*/
@deprecated
void postcompactselection final observercontext<regioncoprocessorenvironment> c
final store store  final immutablelist<storefile> selected
/**
* called prior to writing the {@link storefile}s selected for compaction into a new
* {@code storefile}. to override or modify the compaction process, implementing classes have two
* options:
* <ul>
* <li>wrap the provided {@link internalscanner} with a custom implementation that is returned
* from this method. the custom scanner can then inspect {@link keyvalue}s from the wrapped
* scanner, applying its own policy to what gets written.</li>
* <li>call {@link org.apache.hadoop.hbase.coprocessor.observercontext#bypass()} and provide a
* custom implementation for writing of new {@link storefile}s. <strong>note: any implementations
* bypassing core compaction using this approach must write out new store files themselves or the
* existing data will no longer be available after compaction.</strong></li>
* </ul>
* @param c the environment provided by the region server
* @param store the store being compacted
* @param scanner the scanner over existing data used in the store file rewriting
* @param scantype type of scan
* @param request the requested compaction
* @return the scanner to use during compaction. should not be {@code null} unless the
*         implementation is writing new store files on its own.
* @throws ioexception if an error occurred on the coprocessor
*/
internalscanner precompact final observercontext<regioncoprocessorenvironment> c
final store store  final internalscanner scanner  final scantype scantype
compactionrequest request  throws ioexception
/**
* called prior to writing the {@link storefile}s selected for compaction into a new
* {@code storefile}. to override or modify the compaction process, implementing classes have two
* options:
* <ul>
* <li>wrap the provided {@link internalscanner} with a custom implementation that is returned
* from this method. the custom scanner can then inspect {@link keyvalue}s from the wrapped
* scanner, applying its own policy to what gets written.</li>
* <li>call {@link org.apache.hadoop.hbase.coprocessor.observercontext#bypass()} and provide a
* custom implementation for writing of new {@link storefile}s. <strong>note: any implementations
* bypassing core compaction using this approach must write out new store files themselves or the
* existing data will no longer be available after compaction.</strong></li>
* </ul>
* @param c the environment provided by the region server
* @param store the store being compacted
* @param scanner the scanner over existing data used in the store file rewriting
* @param scantype type of scan
* @return the scanner to use during compaction. should not be {@code null} unless the
*         implementation is writing new store files on its own.
* @throws ioexception if an error occurred on the coprocessor
* @deprecated use
*             {@link #precompact(observercontext, store, internalscanner,
*             scantype, compactionrequest)} instead
*/
@deprecated
internalscanner precompact final observercontext<regioncoprocessorenvironment> c
final store store  final internalscanner scanner  final scantype scantype  throws ioexception
/**
* called prior to writing the {@link storefile}s selected for compaction into a new
* {@code storefile} and prior to creating the scanner used to read the input files. to override
* or modify the compaction process, implementing classes can return a new scanner to provide the
* keyvalues to be stored into the new {@code storefile} or null to perform the default
* processing. calling {@link org.apache.hadoop.hbase.coprocessor.observercontext#bypass()} has no
* effect in this hook.
* @param c the environment provided by the region server
* @param store the store being compacted
* @param scanners the list {@link storefilescanner}s to be read from
* @param scantype the {@link scantype} indicating whether this is a major or minor compaction
* @param earliestputts timestamp of the earliest put that was found in any of the involved store
*          files
* @param s the base scanner, if not {@code null}, from previous regionobserver in the chain
* @param request the requested compaction
* @return the scanner to use during compaction. {@code null} if the default implementation is to
*         be used.
* @throws ioexception if an error occurred on the coprocessor
*/
internalscanner precompactscanneropen final observercontext<regioncoprocessorenvironment> c
final store store  list<? extends keyvaluescanner> scanners  final scantype scantype
final long earliestputts  final internalscanner s  compactionrequest request
throws ioexception
/**
* called prior to writing the {@link storefile}s selected for compaction into a new
* {@code storefile} and prior to creating the scanner used to read the input files. to override
* or modify the compaction process, implementing classes can return a new scanner to provide the
* keyvalues to be stored into the new {@code storefile} or null to perform the default
* processing. calling {@link org.apache.hadoop.hbase.coprocessor.observercontext#bypass()} has no
* effect in this hook.
* @param c the environment provided by the region server
* @param store the store being compacted
* @param scanners the list {@link storefilescanner}s to be read from
* @param scantype the {@link scantype} indicating whether this is a major or minor compaction
* @param earliestputts timestamp of the earliest put that was found in any of the involved store
*          files
* @param s the base scanner, if not {@code null}, from previous regionobserver in the chain
* @return the scanner to use during compaction. {@code null} if the default implementation is to
*         be used.
* @throws ioexception if an error occurred on the coprocessor
* @deprecated use
*             {@link #precompactscanneropen(observercontext, store, list, scantype, long,
*             internalscanner, compactionrequest)} instead.
*/
@deprecated
internalscanner precompactscanneropen final observercontext<regioncoprocessorenvironment> c
final store store  list<? extends keyvaluescanner> scanners  final scantype scantype
final long earliestputts  final internalscanner s  throws ioexception
/**
* called after compaction has completed and the new store file has been moved in to place.
* @param c the environment provided by the region server
* @param store the store being compacted
* @param resultfile the new store file written out during compaction
* @param request the requested compaction
* @throws ioexception if an error occurred on the coprocessor
*/
void postcompact final observercontext<regioncoprocessorenvironment> c  final store store
storefile resultfile  compactionrequest request  throws ioexception
/**
* called after compaction has completed and the new store file has been moved in to place.
* @param c the environment provided by the region server
* @param store the store being compacted
* @param resultfile the new store file written out during compaction
* @throws ioexception if an error occurred on the coprocessor
* @deprecated use {@link #postcompact(observercontext, store, storefile, compactionrequest)}
*             instead
*/
@deprecated
void postcompact final observercontext<regioncoprocessorenvironment> c  final store store
storefile resultfile  throws ioexception
/**
* called before the region is split.
* @param c the environment provided by the region server
* (e.getregion() returns the parent region)
* @throws ioexception if an error occurred on the coprocessor
* @deprecated use presplit(
*    final observercontext<regioncoprocessorenvironment> c, byte[] splitrow)
*/
void presplit final observercontext<regioncoprocessorenvironment> c  throws ioexception
/**
* called before the region is split.
* @param c the environment provided by the region server
* (e.getregion() returns the parent region)
* @throws ioexception if an error occurred on the coprocessor
*/
void presplit final observercontext<regioncoprocessorenvironment> c  byte splitrow
throws ioexception
/**
* called after the region is split.
* @param c the environment provided by the region server
* (e.getregion() returns the parent region)
* @param l the left daughter region
* @param r the right daughter region
* @throws ioexception if an error occurred on the coprocessor
* @deprecated use postcompletesplit() instead
*/
void postsplit final observercontext<regioncoprocessorenvironment> c  final hregion l
final hregion r  throws ioexception
/**
* this will be called before the roll back of the split region is completed
* @param ctx
* @throws ioexception
*/
void prerollbacksplit final observercontext<regioncoprocessorenvironment> ctx  throws ioexception
/**
* this will be called after the roll back of the split region is completed
* @param ctx
* @throws ioexception
*/
void postrollbacksplit final observercontext<regioncoprocessorenvironment> ctx
throws ioexception
/**
* called after any split request is processed.  this will be called irrespective of success or
* failure of the split.
* @param ctx
* @throws ioexception
*/
void postcompletesplit final observercontext<regioncoprocessorenvironment> ctx
throws ioexception
/**
* called before the region is reported as closed to the master.
* @param c the environment provided by the region server
* @param abortrequested true if the region server is aborting
* @throws ioexception
*/
void preclose final observercontext<regioncoprocessorenvironment> c
boolean abortrequested  throws ioexception
/**
* called after the region is reported as closed to the master.
* @param c the environment provided by the region server
* @param abortrequested true if the region server is aborting
*/
void postclose final observercontext<regioncoprocessorenvironment> c
boolean abortrequested
/**
* called before a client makes a getclosestrowbefore request.
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param row the row
* @param family the family
* @param result the result to return to the client if default processing
* is bypassed. can be modified. will not be used if default processing
* is not bypassed.
* @throws ioexception if an error occurred on the coprocessor
*/
void pregetclosestrowbefore final observercontext<regioncoprocessorenvironment> c
final byte  row  final byte  family  final result result
throws ioexception
/**
* called after a client makes a getclosestrowbefore request.
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param row the row
* @param family the desired family
* @param result the result to return to the client, modify as necessary
* @throws ioexception if an error occurred on the coprocessor
*/
void postgetclosestrowbefore final observercontext<regioncoprocessorenvironment> c
final byte  row  final byte  family  final result result
throws ioexception
/**
* called before the client performs a get
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param get the get request
* @param result the result to return to the client if default processing
* is bypassed. can be modified. will not be used if default processing
* is not bypassed.
* @throws ioexception if an error occurred on the coprocessor
*/
void preget final observercontext<regioncoprocessorenvironment> c  final get get
final list<keyvalue> result
throws ioexception
/**
* called after the client performs a get
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param get the get request
* @param result the result to return to the client, modify as necessary
* @throws ioexception if an error occurred on the coprocessor
*/
void postget final observercontext<regioncoprocessorenvironment> c  final get get
final list<keyvalue> result
throws ioexception
/**
* called before the client tests for existence using a get.
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param get the get request
* @param exists
* @return the value to return to the client if bypassing default processing
* @throws ioexception if an error occurred on the coprocessor
*/
boolean preexists final observercontext<regioncoprocessorenvironment> c  final get get
final boolean exists
throws ioexception
/**
* called after the client tests for existence using a get.
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param get the get request
* @param exists the result returned by the region server
* @return the result to return to the client
* @throws ioexception if an error occurred on the coprocessor
*/
boolean postexists final observercontext<regioncoprocessorenvironment> c  final get get
final boolean exists
throws ioexception
/**
* called before the client stores a value.
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param put the put object
* @param edit the waledit object that will be written to the wal
* @param durability persistence guarantee for this put
* @throws ioexception if an error occurred on the coprocessor
*/
void preput final observercontext<regioncoprocessorenvironment> c
final put put  final waledit edit  final durability durability
throws ioexception
/**
* called after the client stores a value.
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param put the put object
* @param edit the waledit object for the wal
* @param durability persistence guarantee for this put
* @throws ioexception if an error occurred on the coprocessor
*/
void postput final observercontext<regioncoprocessorenvironment> c
final put put  final waledit edit  final durability durability
throws ioexception
/**
* called before the client deletes a value.
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param delete the delete object
* @param edit the waledit object for the wal
* @param durability persistence guarantee for this delete
* @throws ioexception if an error occurred on the coprocessor
*/
void predelete final observercontext<regioncoprocessorenvironment> c
final delete delete  final waledit edit  final durability durability
throws ioexception
/**
* called after the client deletes a value.
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param delete the delete object
* @param edit the waledit object for the wal
* @param durability persistence guarantee for this delete
* @throws ioexception if an error occurred on the coprocessor
*/
void postdelete final observercontext<regioncoprocessorenvironment> c
final delete delete  final waledit edit  final durability durability
throws ioexception
/**
* this will be called for every batch mutation operation happening at the server. this will be
* called after acquiring the locks on the mutating rows and after applying the proper timestamp
* for each mutation at the server. the batch may contain put/delete. by setting operationstatus
* of mutations ({@link minibatchoperationinprogress#setoperationstatus(int, operationstatus)}),
* {@link regionobserver} can make hregion to skip these mutations.
* @param c the environment provided by the region server
* @param minibatchop batch of mutations getting applied to region.
* @throws ioexception if an error occurred on the coprocessor
*/
void prebatchmutate final observercontext<regioncoprocessorenvironment> c
final minibatchoperationinprogress<mutation> minibatchop  throws ioexception
/**
* this will be called after applying a batch of mutations on a region. the mutations are added to
* memstore and wal.
* @param c the environment provided by the region server
* @param minibatchop batch of mutations applied to region.
* @throws ioexception if an error occurred on the coprocessor
*/
void postbatchmutate final observercontext<regioncoprocessorenvironment> c
final minibatchoperationinprogress<mutation> minibatchop  throws ioexception
/**
* called before checkandput
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param compareop the comparison operation
* @param comparator the comparator
* @param put data to put if check succeeds
* @param result
* @return the return value to return to client if bypassing default
* processing
* @throws ioexception if an error occurred on the coprocessor
*/
boolean precheckandput final observercontext<regioncoprocessorenvironment> c
final byte  row  final byte  family  final byte  qualifier
final compareop compareop  final bytearraycomparable comparator
final put put  final boolean result
throws ioexception
/**
* called after checkandput
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param compareop the comparison operation
* @param comparator the comparator
* @param put data to put if check succeeds
* @param result from the checkandput
* @return the possibly transformed return value to return to client
* @throws ioexception if an error occurred on the coprocessor
*/
boolean postcheckandput final observercontext<regioncoprocessorenvironment> c
final byte  row  final byte  family  final byte  qualifier
final compareop compareop  final bytearraycomparable comparator
final put put  final boolean result
throws ioexception
/**
* called before checkanddelete
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param compareop the comparison operation
* @param comparator the comparator
* @param delete delete to commit if check succeeds
* @param result
* @return the value to return to client if bypassing default processing
* @throws ioexception if an error occurred on the coprocessor
*/
boolean precheckanddelete final observercontext<regioncoprocessorenvironment> c
final byte  row  final byte  family  final byte  qualifier
final compareop compareop  final bytearraycomparable comparator
final delete delete  final boolean result
throws ioexception
/**
* called after checkanddelete
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param compareop the comparison operation
* @param comparator the comparator
* @param delete delete to commit if check succeeds
* @param result from the checkanddelete
* @return the possibly transformed returned value to return to client
* @throws ioexception if an error occurred on the coprocessor
*/
boolean postcheckanddelete final observercontext<regioncoprocessorenvironment> c
final byte  row  final byte  family  final byte  qualifier
final compareop compareop  final bytearraycomparable comparator
final delete delete  final boolean result
throws ioexception
/**
* called before incrementcolumnvalue
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param amount long amount to increment
* @param writetowal true if the change should be written to the wal
* @return value to return to the client if bypassing default processing
* @throws ioexception if an error occurred on the coprocessor
* @deprecated this hook is no longer called by the regionserver
*/
@deprecated
long preincrementcolumnvalue final observercontext<regioncoprocessorenvironment> c
final byte  row  final byte  family  final byte  qualifier
final long amount  final boolean writetowal
throws ioexception
/**
* called after incrementcolumnvalue
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param amount long amount to increment
* @param writetowal true if the change should be written to the wal
* @param result the result returned by incrementcolumnvalue
* @return the result to return to the client
* @throws ioexception if an error occurred on the coprocessor
* @deprecated this hook is no longer called by the regionserver
*/
@deprecated
long postincrementcolumnvalue final observercontext<regioncoprocessorenvironment> c
final byte  row  final byte  family  final byte  qualifier
final long amount  final boolean writetowal  final long result
throws ioexception
/**
* called before append
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param append append object
* @return result to return to the client if bypassing default processing
* @throws ioexception if an error occurred on the coprocessor
*/
result preappend final observercontext<regioncoprocessorenvironment> c
final append append
throws ioexception
/**
* called after append
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param append append object
* @param result the result returned by increment
* @return the result to return to the client
* @throws ioexception if an error occurred on the coprocessor
*/
result postappend final observercontext<regioncoprocessorenvironment> c
final append append  final result result
throws ioexception
/**
* called before increment
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param increment increment object
* @return result to return to the client if bypassing default processing
* @throws ioexception if an error occurred on the coprocessor
*/
result preincrement final observercontext<regioncoprocessorenvironment> c
final increment increment
throws ioexception
/**
* called after increment
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param increment increment object
* @param result the result returned by increment
* @return the result to return to the client
* @throws ioexception if an error occurred on the coprocessor
*/
result postincrement final observercontext<regioncoprocessorenvironment> c
final increment increment  final result result
throws ioexception
/**
* called before the client opens a new scanner.
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param scan the scan specification
* @param s if not null, the base scanner
* @return an regionscanner instance to use instead of the base scanner if
* overriding default behavior, null otherwise
* @throws ioexception if an error occurred on the coprocessor
*/
regionscanner prescanneropen final observercontext<regioncoprocessorenvironment> c
final scan scan  final regionscanner s
throws ioexception
/**
* called before a store opens a new scanner.
* this hook is called when a "user" scanner is opened.
* <p>
* see {@link #preflushscanneropen(observercontext, store, keyvaluescanner, internalscanner)}
* and {@link #precompactscanneropen(observercontext,
*  store, list, scantype, long, internalscanner)}
* to override scanners created for flushes or compactions, resp.
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors.
* calling {@link org.apache.hadoop.hbase.coprocessor.observercontext#bypass()} has no
* effect in this hook.
* @param c the environment provided by the region server
* @param store the store being scanned
* @param scan the scan specification
* @param targetcols columns to be used in the scanner
* @param s the base scanner, if not {@code null}, from previous regionobserver in the chain
* @return a keyvaluescanner instance to use or {@code null} to use the default implementation
* @throws ioexception if an error occurred on the coprocessor
*/
keyvaluescanner prestorescanneropen final observercontext<regioncoprocessorenvironment> c
final store store  final scan scan  final navigableset<byte> targetcols
final keyvaluescanner s  throws ioexception
/**
* called after the client opens a new scanner.
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param scan the scan specification
* @param s if not null, the base scanner
* @return the scanner instance to use
* @throws ioexception if an error occurred on the coprocessor
*/
regionscanner postscanneropen final observercontext<regioncoprocessorenvironment> c
final scan scan  final regionscanner s
throws ioexception
/**
* called before the client asks for the next row on a scanner.
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param s the scanner
* @param result the result to return to the client if default processing
* is bypassed. can be modified. will not be returned if default processing
* is not bypassed.
* @param limit the maximum number of results to return
* @param hasnext the 'has more' indication
* @return 'has more' indication that should be sent to client
* @throws ioexception if an error occurred on the coprocessor
*/
boolean prescannernext final observercontext<regioncoprocessorenvironment> c
final internalscanner s  final list<result> result
final int limit  final boolean hasnext
throws ioexception
/**
* called after the client asks for the next row on a scanner.
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param s the scanner
* @param result the result to return to the client, can be modified
* @param limit the maximum number of results to return
* @param hasnext the 'has more' indication
* @return 'has more' indication that should be sent to client
* @throws ioexception if an error occurred on the coprocessor
*/
boolean postscannernext final observercontext<regioncoprocessorenvironment> c
final internalscanner s  final list<result> result  final int limit
final boolean hasnext
throws ioexception
/**
* this will be called by the scan flow when the current scanned row is being filtered out by the
* filter. the filter may be filtering out the row via any of the below scenarios
* <ol>
* <li>
* <code>boolean filterrowkey(byte [] buffer, int offset, int length)</code> returning true</li>
* <li>
* <code>boolean filterrow()</code> returning true</li>
* <li>
* <code>void filterrow(list<keyvalue> kvs)</code> removing all the kvs from the passed list</li>
* </ol>
* @param c the environment provided by the region server
* @param s the scanner
* @param currentrow the current rowkey which got filtered out
* @param hasmore the 'has more' indication
* @return whether more rows are available for the scanner or not
* @throws ioexception
*/
boolean postscannerfilterrow final observercontext<regioncoprocessorenvironment> c
final internalscanner s  final byte currentrow  final boolean hasmore  throws ioexception
/**
* called before the client closes a scanner.
* <p>
* call coprocessorenvironment#bypass to skip default actions
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param s the scanner
* @throws ioexception if an error occurred on the coprocessor
*/
void prescannerclose final observercontext<regioncoprocessorenvironment> c
final internalscanner s
throws ioexception
/**
* called after the client closes a scanner.
* <p>
* call coprocessorenvironment#complete to skip any subsequent chained
* coprocessors
* @param c the environment provided by the region server
* @param s the scanner
* @throws ioexception if an error occurred on the coprocessor
*/
void postscannerclose final observercontext<regioncoprocessorenvironment> c
final internalscanner s
throws ioexception
/**
* called before a {@link org.apache.hadoop.hbase.regionserver.wal.waledit}
* replayed for this region.
*
* @param ctx
* @param info
* @param logkey
* @param logedit
* @throws ioexception
*/
void prewalrestore final observercontext<regioncoprocessorenvironment> ctx
hregioninfo info  hlogkey logkey  waledit logedit  throws ioexception
/**
* called after a {@link org.apache.hadoop.hbase.regionserver.wal.waledit}
* replayed for this region.
*
* @param ctx
* @param info
* @param logkey
* @param logedit
* @throws ioexception
*/
void postwalrestore final observercontext<regioncoprocessorenvironment> ctx
hregioninfo info  hlogkey logkey  waledit logedit  throws ioexception
/**
* called before bulkloadhfile. users can create a storefile instance to
* access the contents of a hfile.
*
* @param ctx
* @param familypaths pairs of { cf, hfile path } submitted for bulk load. adding
* or removing from this list will add or remove hfiles to be bulk loaded.
* @throws ioexception
*/
void prebulkloadhfile final observercontext<regioncoprocessorenvironment> ctx
list<pair<byte  string>> familypaths  throws ioexception
/**
* called after bulkloadhfile.
*
* @param ctx
* @param familypaths pairs of { cf, hfile path } submitted for bulk load
* @param hasloaded whether the bulkload was successful
* @return the new value of hasloaded
* @throws ioexception
*/
boolean postbulkloadhfile final observercontext<regioncoprocessorenvironment> ctx
list<pair<byte  string>> familypaths  boolean hasloaded  throws ioexception