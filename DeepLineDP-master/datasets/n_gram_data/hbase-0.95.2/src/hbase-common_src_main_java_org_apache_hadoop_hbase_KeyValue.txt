/**
* copyright the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase
import java io datainput
import java io dataoutput
import java io ioexception
import java io inputstream
import java io outputstream
import java nio bufferoverflowexception
import java nio bytebuffer
import java util arrays
import java util comparator
import java util hashmap
import java util map
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import org apache hadoop hbase io heapsize
import org apache hadoop hbase util bytes
import org apache hadoop hbase util classsize
import org apache hadoop io ioutils
import org apache hadoop io rawcomparator
import com google common primitives longs
/**
* an hbase key/value. this is the fundamental hbase type.
* <p>
* if being used client-side, the primary methods to access individual fields are {@link #getrow()},
* {@link #getfamily()}, {@link #getqualifier()}, {@link #gettimestamp()}, and {@link #getvalue()}.
* these methods allocate new byte arrays and return copies. avoid their use server-side.
* <p>
* instances of this class are immutable. they do not implement comparable but comparators are
* provided. comparators change with context, whether user table or a catalog table comparison. its
* critical you use the appropriate comparator. there are comparators for keyvalue instances and
* then for just the key portion of a keyvalue used mostly by hfile.
* <p>
* keyvalue wraps a byte array and takes offsets and lengths into passed array at where to start
* interpreting the content as keyvalue. the keyvalue format inside a byte array is:
* <code>&lt;keylength> &lt;valuelength> &lt;key> &lt;value></code> key is further decomposed as:
* <code>&lt;rowlength> &lt;row> &lt;columnfamilylength> &lt;columnfamily> &lt;columnqualifier> &lt;timestamp> &lt;keytype></code>
* the <code>rowlength</code> maximum is <code>short.max_size</code>, column family length maximum
* is <code>byte.max_size</code>, and column qualifier + key length must be <
* <code>integer.max_size</code>. the column does not contain the family/qualifier delimiter,
* {@link #column_family_delimiter}
*/
@interfaceaudience public
@interfacestability evolving
public class keyvalue implements cell  heapsize  cloneable
static final log log   logfactory getlog keyvalue class
// todo: group key-only comparators and operations into a key class, just
// for neatness sake, if can figure what to call it.
/**
* colon character in utf-8
*/
public static final char column_family_delimiter
public static final byte column_family_delim_array
new byte column_family_delimiter
/**
* comparator for plain key/values; i.e. non-catalog table key/values.
*/
public static final kvcomparator comparator   new kvcomparator
/**
* comparator for plain key; i.e. non-catalog table key.  works on key portion
* of keyvalue only.
*/
public static final keycomparator key_comparator   new keycomparator
/**
* a {@link kvcomparator} for <code>.meta.</code> catalog table
* {@link keyvalue}s.
*/
public static final kvcomparator meta_comparator   new metacomparator
/**
* get the appropriate row comparator for the specified table.
*
* hopefully we can get rid of this, i added this here because it's replacing
* something in hsk.  we should move completely off of that.
*
* @param tablename  the table name.
* @return the comparator.
*/
public static keycomparator getrowcomparator tablename tablename
if tablename meta_table_name equals tablename
return meta_comparator getrawcomparator
return comparator getrawcomparator
/** size of the key length field in bytes*/
public static final int key_length_size   bytes sizeof_int
/** size of the key type field in bytes */
public static final int type_size   bytes sizeof_byte
/** size of the row length field in bytes */
public static final int row_length_size   bytes sizeof_short
/** size of the family length field in bytes */
public static final int family_length_size   bytes sizeof_byte
/** size of the timestamp field in bytes */
public static final int timestamp_size   bytes sizeof_long
// size of the timestamp and type byte on end of a key -- a long + a byte.
public static final int timestamp_type_size   timestamp_size   type_size
// size of the length shorts and bytes in key.
public static final int key_infrastructure_size   row_length_size
family_length_size   timestamp_type_size
// how far into the key the row starts at. first thing to read is the short
// that says how long the row is.
public static final int row_offset
bytes sizeof_int   keylength
bytes sizeof_int   valuelength
// size of the length ints in a keyvalue datastructure.
public static final int keyvalue_infrastructure_size   row_offset
/**
* computes the number of bytes that a <code>keyvalue</code> instance with the provided
* characteristics would take up for its underlying data structure.
*
* @param rlength row length
* @param flength family length
* @param qlength qualifier length
* @param vlength value length
*
* @return the <code>keyvalue</code> data structure length
*/
public static long getkeyvaluedatastructuresize int rlength
int flength  int qlength  int vlength
return keyvalue keyvalue_infrastructure_size
getkeydatastructuresize rlength  flength  qlength    vlength
/**
* computes the number of bytes that a <code>keyvalue</code> instance with the provided
* characteristics would take up in its underlying data structure for the key.
*
* @param rlength row length
* @param flength family length
* @param qlength qualifier length
*
* @return the key data structure length
*/
public static long getkeydatastructuresize int rlength  int flength  int qlength
return keyvalue key_infrastructure_size   rlength   flength   qlength
/**
* key type.
* has space for other key types to be added later.  cannot rely on
* enum ordinals . they change if item is removed or moved.  do our own codes.
*/
public static enum type
minimum  byte 0
put  byte 4
delete  byte 8
deletefamilyversion  byte 10
deletecolumn  byte 12
deletefamily  byte 14
// maximum is used when searching; you look from maximum on down.
maximum  byte 255
private final byte code
type final byte c
this code   c
public byte getcode
return this code
/**
* cannot rely on enum ordinals . they change if item is removed or moved.
* do our own codes.
* @param b
* @return type associated with passed code.
*/
public static type codetotype final byte b
for  type t   type values
if  t getcode      b
return t
throw new runtimeexception     b
/**
* lowest possible key.
* makes a key with highest possible timestamp, empty row and column.  no
* key can be equal or lower than this one in memstore or in store file.
*/
public static final keyvalue lowestkey
new keyvalue hconstants empty_byte_array  hconstants latest_timestamp
private byte  bytes   null
private int offset   0
private int length   0
/**
* @return true if a delete type, a {@link keyvalue.type#delete} or
* a {keyvalue.type#deletefamily} or a {@link keyvalue.type#deletecolumn}
* keyvalue type.
*/
public static boolean isdelete byte t
return type delete getcode   <  t    t <  type deletefamily getcode
/** here be dragons **/
// used to achieve atomic operations in the memstore.
@override
public long getmvccversion
return memstorets
public void setmvccversion long mvccversion
this memstorets   mvccversion
@deprecated
public long getmemstorets
return getmvccversion
@deprecated
public void setmemstorets long memstorets
setmvccversion memstorets
// default value is 0, aka dnc
private long memstorets   0
/** dragon time over, return to normal business */
/** writable constructor -- do not use */
public keyvalue
/**
* creates a keyvalue from the start of the specified byte array.
* presumes <code>bytes</code> content is formatted as a keyvalue blob.
* @param bytes byte array
*/
public keyvalue final byte  bytes
this bytes  0
/**
* creates a keyvalue from the specified byte array and offset.
* presumes <code>bytes</code> content starting at <code>offset</code> is
* formatted as a keyvalue blob.
* @param bytes byte array
* @param offset offset to start of keyvalue
*/
public keyvalue final byte  bytes  final int offset
this bytes  offset  getlength bytes  offset
/**
* creates a keyvalue from the specified byte array, starting at offset, and
* for length <code>length</code>.
* @param bytes byte array
* @param offset offset to start of the keyvalue
* @param length length of the keyvalue
*/
public keyvalue final byte  bytes  final int offset  final int length
this bytes   bytes
this offset   offset
this length   length
/**
* creates a keyvalue from the specified byte array, starting at offset,
* for length <code>length</code>, and a known <code>keylength</code>.
* @param bytes byte array
* @param offset offset to start of the keyvalue
* @param length length of the keyvalue
* @param keylength length of the key portion of the keyvalue
*/
public keyvalue final byte  bytes  final int offset  final int length  final int keylength
this bytes   bytes
this offset   offset
this length   length
this keylength   keylength
/** constructors that build a new backing byte array from fields */
/**
* constructs keyvalue structure filled with null value.
* sets type to {@link keyvalue.type#maximum}
* @param row - row key (arbitrary byte array)
* @param timestamp
*/
public keyvalue final byte  row  final long timestamp
this row  timestamp  type maximum
/**
* constructs keyvalue structure filled with null value.
* @param row - row key (arbitrary byte array)
* @param timestamp
*/
public keyvalue final byte  row  final long timestamp  type type
this row  null  null  timestamp  type  null
/**
* constructs keyvalue structure filled with null value.
* sets type to {@link keyvalue.type#maximum}
* @param row - row key (arbitrary byte array)
* @param family family name
* @param qualifier column qualifier
*/
public keyvalue final byte  row  final byte  family
final byte  qualifier
this row  family  qualifier  hconstants latest_timestamp  type maximum
/**
* constructs keyvalue structure filled with null value.
* @param row - row key (arbitrary byte array)
* @param family family name
* @param qualifier column qualifier
*/
public keyvalue final byte  row  final byte  family
final byte  qualifier  final byte  value
this row  family  qualifier  hconstants latest_timestamp  type put  value
/**
* constructs keyvalue structure filled with specified values.
* @param row row key
* @param family family name
* @param qualifier column qualifier
* @param timestamp version timestamp
* @param type key type
* @throws illegalargumentexception
*/
public keyvalue final byte row  final byte family
final byte qualifier  final long timestamp  type type
this row  family  qualifier  timestamp  type  null
/**
* constructs keyvalue structure filled with specified values.
* @param row row key
* @param family family name
* @param qualifier column qualifier
* @param timestamp version timestamp
* @param value column value
* @throws illegalargumentexception
*/
public keyvalue final byte row  final byte family
final byte qualifier  final long timestamp  final byte value
this row  family  qualifier  timestamp  type put  value
/**
* constructs keyvalue structure filled with specified values.
* @param row row key
* @param family family name
* @param qualifier column qualifier
* @param timestamp version timestamp
* @param type key type
* @param value column value
* @throws illegalargumentexception
*/
public keyvalue final byte row  final byte family
final byte qualifier  final long timestamp  type type
final byte value
this row  family  qualifier  0  qualifier  null ? 0   qualifier length
timestamp  type  value  0  value  null ? 0   value length
/**
* constructs keyvalue structure filled with specified values.
* @param row row key
* @param family family name
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
* @param timestamp version timestamp
* @param type key type
* @param value column value
* @param voffset value offset
* @param vlength value length
* @throws illegalargumentexception
*/
public keyvalue byte  row  byte  family
byte  qualifier  int qoffset  int qlength  long timestamp  type type
byte  value  int voffset  int vlength
this row  0  row  null ? 0   row length
family  0  family  null ? 0   family length
qualifier  qoffset  qlength  timestamp  type
value  voffset  vlength
/**
* constructs keyvalue structure filled with specified values.
* <p>
* column is split into two fields, family and qualifier.
* @param row row key
* @param roffset row offset
* @param rlength row length
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
* @param timestamp version timestamp
* @param type key type
* @param value column value
* @param voffset value offset
* @param vlength value length
* @throws illegalargumentexception
*/
public keyvalue final byte  row  final int roffset  final int rlength
final byte  family  final int foffset  final int flength
final byte  qualifier  final int qoffset  final int qlength
final long timestamp  final type type
final byte  value  final int voffset  final int vlength
this bytes   createbytearray row  roffset  rlength
family  foffset  flength  qualifier  qoffset  qlength
timestamp  type  value  voffset  vlength
this length   bytes length
this offset   0
/**
* constructs an empty keyvalue structure, with specified sizes.
* this can be used to partially fill up keyvalues.
* <p>
* column is split into two fields, family and qualifier.
* @param rlength row length
* @param flength family length
* @param qlength qualifier length
* @param timestamp version timestamp
* @param type key type
* @param vlength value length
* @throws illegalargumentexception
*/
public keyvalue final int rlength
final int flength
final int qlength
final long timestamp  final type type
final int vlength
this bytes   createemptybytearray rlength
flength  qlength
timestamp  type  vlength
this length   bytes length
this offset   0
/**
* create an empty byte[] representing a keyvalue
* all lengths are preset and can be filled in later.
* @param rlength
* @param flength
* @param qlength
* @param timestamp
* @param type
* @param vlength
* @return the newly created byte array.
*/
static byte createemptybytearray final int rlength  int flength
int qlength  final long timestamp  final type type  int vlength
if  rlength > short max_value
throw new illegalargumentexception     short max_value
if  flength > byte max_value
throw new illegalargumentexception     byte max_value
// qualifier length
if  qlength > integer max_value   rlength   flength
throw new illegalargumentexception     integer max_value
// key length
long longkeylength   getkeydatastructuresize rlength  flength  qlength
if  longkeylength > integer max_value
throw new illegalargumentexception     longkeylength
integer max_value
int keylength    int longkeylength
// value length
if  vlength > hconstants maximum_value_length       findbugs int_vacuous_comparison
throw new illegalargumentexception
hconstants maximum_value_length
// allocate right-sized byte array.
byte  bytes
new byte
// write the correct size markers
int pos   0
pos   bytes putint bytes  pos  keylength
pos   bytes putint bytes  pos  vlength
pos   bytes putshort bytes  pos   short  rlength   0x0000ffff
pos    rlength
pos   bytes putbyte bytes  pos   byte  flength   0x0000ff
pos    flength   qlength
pos   bytes putlong bytes  pos  timestamp
pos   bytes putbyte bytes  pos  type getcode
return bytes
/**
* constructs keyvalue structure filled with specified values. uses the provided buffer as its
* backing data buffer.
* <p>
* column is split into two fields, family and qualifier.
*
* @param buffer the bytes buffer to use
* @param row row key
* @param roffset row offset
* @param rlength row length
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
* @param timestamp version timestamp
* @param type key type
* @param value column value
* @param voffset value offset
* @param vlength value length
* @throws illegalargumentexception an illegal value was passed or there is insufficient space
* remaining in the buffer
*/
public keyvalue byte  buffer
final byte  row  final int roffset  final int rlength
final byte  family  final int foffset  final int flength
final byte  qualifier  final int qoffset  final int qlength
final long timestamp  final type type
final byte  value  final int voffset  final int vlength
this buffer  0
row  roffset  rlength
family  foffset  flength
qualifier  qoffset  qlength
timestamp  type
value  voffset  vlength
/**
* constructs keyvalue structure filled with specified values. uses the provided buffer as the
* data buffer.
* <p>
* column is split into two fields, family and qualifier.
*
* @param buffer the bytes buffer to use
* @param boffset buffer offset
* @param row row key
* @param roffset row offset
* @param rlength row length
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
* @param timestamp version timestamp
* @param type key type
* @param value column value
* @param voffset value offset
* @param vlength value length
* @throws illegalargumentexception an illegal value was passed or there is insufficient space
* remaining in the buffer
*/
public keyvalue byte  buffer  final int boffset
final byte  row  final int roffset  final int rlength
final byte  family  final int foffset  final int flength
final byte  qualifier  final int qoffset  final int qlength
final long timestamp  final type type
final byte  value  final int voffset  final int vlength
this bytes    buffer
this length   writebytearray buffer  boffset
row  roffset  rlength
family  foffset  flength  qualifier  qoffset  qlength
timestamp  type  value  voffset  vlength
this offset   boffset
/**
* checks the parameters passed to a constructor.
*
* @param row row key
* @param rlength row length
* @param family family name
* @param flength family length
* @param qualifier column qualifier
* @param qlength qualifier length
* @param value column value
* @param vlength value length
*
* @throws illegalargumentexception an illegal value was passed
*/
private static void checkparameters final byte  row  final int rlength
final byte  family  int flength
final byte  qualifier  int qlength
final byte  value  int vlength
throws illegalargumentexception
if  rlength > short max_value
throw new illegalargumentexception     short max_value
if  row    null
throw new illegalargumentexception
// family length
flength   family    null ? 0   flength
if  flength > byte max_value
throw new illegalargumentexception     byte max_value
// qualifier length
qlength   qualifier    null ? 0   qlength
if  qlength > integer max_value   rlength   flength
throw new illegalargumentexception     integer max_value
// key length
long longkeylength   getkeydatastructuresize rlength  flength  qlength
if  longkeylength > integer max_value
throw new illegalargumentexception     longkeylength
integer max_value
// value length
vlength   value    null? 0   vlength
if  vlength > hconstants maximum_value_length       findbugs int_vacuous_comparison
throw new illegalargumentexception     vlength
hconstants maximum_value_length
/**
* write keyvalue format into the provided byte array.
*
* @param buffer the bytes buffer to use
* @param boffset buffer offset
* @param row row key
* @param roffset row offset
* @param rlength row length
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
* @param timestamp version timestamp
* @param type key type
* @param value column value
* @param voffset value offset
* @param vlength value length
*
* @return the number of useful bytes in the buffer.
*
* @throws illegalargumentexception an illegal value was passed or there is insufficient space
* remaining in the buffer
*/
static int writebytearray byte  buffer  final int boffset
final byte  row  final int roffset  final int rlength
final byte  family  final int foffset  int flength
final byte  qualifier  final int qoffset  int qlength
final long timestamp  final type type
final byte  value  final int voffset  int vlength
checkparameters row  rlength  family  flength  qualifier  qlength  value  vlength
int keylength    int  getkeydatastructuresize rlength  flength  qlength
int keyvaluelength    int  getkeyvaluedatastructuresize rlength  flength  qlength  vlength
if  keyvaluelength > buffer length   boffset
throw new illegalargumentexception      buffer length   boffset
keyvaluelength
// write key, value and key row length.
int pos   boffset
pos   bytes putint buffer  pos  keylength
pos   bytes putint buffer  pos  vlength
pos   bytes putshort buffer  pos   short  rlength   0x0000ffff
pos   bytes putbytes buffer  pos  row  roffset  rlength
pos   bytes putbyte buffer  pos   byte   flength   0x0000ff
if  flength    0
pos   bytes putbytes buffer  pos  family  foffset  flength
if  qlength    0
pos   bytes putbytes buffer  pos  qualifier  qoffset  qlength
pos   bytes putlong buffer  pos  timestamp
pos   bytes putbyte buffer  pos  type getcode
if  value    null    value length > 0
pos   bytes putbytes buffer  pos  value  voffset  vlength
return keyvaluelength
/**
* write keyvalue format into a byte array.
*
* @param row row key
* @param roffset row offset
* @param rlength row length
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
* @param timestamp version timestamp
* @param type key type
* @param value column value
* @param voffset value offset
* @param vlength value length
* @return the newly created byte array.
*/
static byte  createbytearray final byte  row  final int roffset
final int rlength  final byte  family  final int foffset  int flength
final byte  qualifier  final int qoffset  int qlength
final long timestamp  final type type
final byte  value  final int voffset  int vlength
checkparameters row  rlength  family  flength  qualifier  qlength  value  vlength
// allocate right-sized byte array.
int keylength    int  getkeydatastructuresize rlength  flength  qlength
byte  bytes
new byte
// write key, value and key row length.
int pos   0
pos   bytes putint bytes  pos  keylength
pos   bytes putint bytes  pos  vlength
pos   bytes putshort bytes  pos   short  rlength   0x0000ffff
pos   bytes putbytes bytes  pos  row  roffset  rlength
pos   bytes putbyte bytes  pos   byte  flength   0x0000ff
if flength    0
pos   bytes putbytes bytes  pos  family  foffset  flength
if qlength    0
pos   bytes putbytes bytes  pos  qualifier  qoffset  qlength
pos   bytes putlong bytes  pos  timestamp
pos   bytes putbyte bytes  pos  type getcode
if  value    null    value length > 0
pos   bytes putbytes bytes  pos  value  voffset  vlength
return bytes
/**
* write keyvalue format into a byte array.
* <p>
* takes column in the form <code>family:qualifier</code>
* @param row - row key (arbitrary byte array)
* @param roffset
* @param rlength
* @param column
* @param coffset
* @param clength
* @param timestamp
* @param type
* @param value
* @param voffset
* @param vlength
* @return the newly created byte array.
*/
static byte  createbytearray final byte  row  final int roffset
final int rlength
final byte  column  final int coffset  int clength
final long timestamp  final type type
final byte  value  final int voffset  int vlength
// if column is non-null, figure where the delimiter is at.
int delimiteroffset   0
if  column    null    column length > 0
delimiteroffset   getfamilydelimiterindex column  coffset  clength
if  delimiteroffset > byte max_value
throw new illegalargumentexception     byte max_value
else
return createbytearray row roffset rlength null 0 0 null 0 0 timestamp
type value voffset vlength
int flength   delimiteroffset coffset
int qlength   clength   flength   1
return createbytearray row  roffset  rlength  column  coffset
flength  column  delimiteroffset 1  qlength  timestamp  type
value  voffset  vlength
/**
* needed doing 'contains' on list.  only compares the key portion, not the value.
*/
@override
public boolean equals object other
if    other instanceof cell
return false
return cellcomparator equals this   cell other
@override
public int hashcode
byte b   getbuffer
int start   getoffset    end   getoffset     getlength
int h   b
for  int i   start  i < end  i
h    h   13  ^ b
return h
//---------------------------------------------------------------------------
//
//  keyvalue cloning
//
//---------------------------------------------------------------------------
/**
* clones a keyvalue.  this creates a copy, re-allocating the buffer.
* @return fully copied clone of this keyvalue
* @throws clonenotsupportedexception
*/
@override
public keyvalue clone   throws clonenotsupportedexception
super clone
byte  b   new byte
system arraycopy this bytes  this offset  b  0  this length
keyvalue ret   new keyvalue b  0  b length
// important to clone the memstorets as well - otherwise memstore's
// update-in-place methods (eg increment) will end up creating
// new entries
ret setmvccversion memstorets
return ret
/**
* creates a shallow copy of this keyvalue, reusing the data byte buffer.
* http://en.wikipedia.org/wiki/object_copy
* @return shallow copy of this keyvalue
*/
public keyvalue shallowcopy
keyvalue shallowcopy   new keyvalue this bytes  this offset  this length
shallowcopy setmvccversion this memstorets
return shallowcopy
//---------------------------------------------------------------------------
//
//  string representation
//
//---------------------------------------------------------------------------
public string tostring
if  this bytes    null    this bytes length    0
return
return keytostring this bytes  this offset   row_offset  getkeylength
getvaluelength         memstorets
/**
* @param k key portion of a keyvalue.
* @return key as a string.
*/
public static string keytostring final byte  k
return keytostring k  0  k length
/**
* use for logging.
* @param b key portion of a keyvalue.
* @param o offset to start of key
* @param l length of key.
* @return key as a string.
*/
/**
* produces a string map for this key/value pair. useful for programmatic use
* and manipulation of the data stored in an hlogkey, for example, printing
* as json. values are left out due to their tendency to be large. if needed,
* they can be added manually.
*
* @return the map<string,?> containing data from this key
*/
public map<string  object> tostringmap
map<string  object> stringmap   new hashmap<string  object>
stringmap put    bytes tostringbinary getrow
stringmap put    bytes tostringbinary getfamily
stringmap put    bytes tostringbinary getqualifier
stringmap put    gettimestamp
stringmap put    getvaluelength
return stringmap
public static string keytostring final byte  b  final int o  final int l
if  b    null  return
int rowlength   bytes toshort b  o
string row   bytes tostringbinary b  o   bytes sizeof_short  rowlength
int columnoffset   o   bytes sizeof_short   1   rowlength
int familylength   b
int columnlength   l     columnoffset   o    timestamp_type_size
string family   familylength    0?
bytes tostringbinary b  columnoffset  familylength
string qualifier   columnlength    0?
bytes tostringbinary b  columnoffset   familylength
columnlength   familylength
long timestamp   bytes tolong b  o    l   timestamp_type_size
string timestampstr   humanreadabletimestamp timestamp
byte type   b
return row       family
family    null    family length   > 0?
qualifier       timestampstr       type codetotype type
public static string humanreadabletimestamp final long timestamp
if  timestamp    hconstants latest_timestamp
return
if  timestamp    hconstants oldest_timestamp
return
return string valueof timestamp
//---------------------------------------------------------------------------
//
//  public member accessors
//
//---------------------------------------------------------------------------
/**
* @return the byte array backing this keyvalue.
*/
public byte  getbuffer
return this bytes
/**
* @return offset into {@link #getbuffer()} at which this keyvalue starts.
*/
public int getoffset
return this offset
/**
* @return length of bytes this keyvalue occupies in {@link #getbuffer()}.
*/
public int getlength
return length
//---------------------------------------------------------------------------
//
//  length and offset calculators
//
//---------------------------------------------------------------------------
/**
* determines the total length of the keyvalue stored in the specified
* byte array and offset.  includes all headers.
* @param bytes byte array
* @param offset offset to start of the keyvalue
* @return length of entire keyvalue, in bytes
*/
private static int getlength byte  bytes  int offset
return row_offset
bytes toint bytes  offset
bytes toint bytes  offset   bytes sizeof_int
/**
* @return key offset in backing buffer..
*/
public int getkeyoffset
return this offset   row_offset
public string getkeystring
return bytes tostringbinary getbuffer    getkeyoffset    getkeylength
/**
* @return length of key portion.
*/
private int keylength   0
public int getkeylength
if  keylength    0
keylength   bytes toint this bytes  this offset
return keylength
/**
* @return the backing array of the entire keyvalue (all keyvalue fields are in a single array)
*/
@override
public byte getvaluearray
return bytes
/**
* @return value offset
*/
@override
public int getvalueoffset
return getkeyoffset     getkeylength
/**
* @return value length
*/
@override
public int getvaluelength
return bytes toint this bytes  this offset   bytes sizeof_int
/**
* @return the backing array of the entire keyvalue (all keyvalue fields are in a single array)
*/
@override
public byte getrowarray
return bytes
/**
* @return row offset
*/
@override
public int getrowoffset
return getkeyoffset     bytes sizeof_short
/**
* @return row length
*/
@override
public short getrowlength
return bytes toshort this bytes  getkeyoffset
/**
* @return the backing array of the entire keyvalue (all keyvalue fields are in a single array)
*/
@override
public byte getfamilyarray
return bytes
/**
* @return family offset
*/
@override
public int getfamilyoffset
return getfamilyoffset getrowlength
/**
* @return family offset
*/
public int getfamilyoffset int rlength
return this offset   row_offset   bytes sizeof_short   rlength   bytes sizeof_byte
/**
* @return family length
*/
@override
public byte getfamilylength
return getfamilylength getfamilyoffset
/**
* @return family length
*/
public byte getfamilylength int foffset
return this bytes
/**
* @return the backing array of the entire keyvalue (all keyvalue fields are in a single array)
*/
@override
public byte getqualifierarray
return bytes
/**
* @return qualifier offset
*/
@override
public int getqualifieroffset
return getqualifieroffset getfamilyoffset
/**
* @return qualifier offset
*/
public int getqualifieroffset int foffset
return foffset   getfamilylength foffset
/**
* @return qualifier length
*/
@override
public int getqualifierlength
return getqualifierlength getrowlength   getfamilylength
/**
* @return qualifier length
*/
public int getqualifierlength int rlength  int flength
return getkeylength      int  getkeydatastructuresize rlength  flength  0
/**
* @return column (family + qualifier) length
*/
public int gettotalcolumnlength
int rlength   getrowlength
int foffset   getfamilyoffset rlength
return gettotalcolumnlength rlength foffset
/**
* @return column (family + qualifier) length
*/
public int gettotalcolumnlength int rlength  int foffset
int flength   getfamilylength foffset
int qlength   getqualifierlength rlength flength
return flength   qlength
/**
* @return timestamp offset
*/
public int gettimestampoffset
return gettimestampoffset getkeylength
/**
* @param keylength pass if you have it to save on a int creation.
* @return timestamp offset
*/
public int gettimestampoffset final int keylength
return getkeyoffset     keylength   timestamp_type_size
/**
* @return true if this keyvalue has a latest_timestamp timestamp.
*/
public boolean islatesttimestamp
return bytes equals getbuffer    gettimestampoffset    bytes sizeof_long
hconstants latest_timestamp_bytes  0  bytes sizeof_long
/**
* @return true if this is a "fake" kv created for internal seeking purposes,
* which should not be seen by user code
*/
public boolean isinternal
byte type   gettype
return type    type minimum code    type    type maximum code
/**
* @param now time to set into <code>this</code> iff timestamp ==
* {@link hconstants#latest_timestamp} (else, its a noop).
* @return true is we modified this.
*/
public boolean updatelateststamp final byte  now
if  this islatesttimestamp
int tsoffset   gettimestampoffset
system arraycopy now  0  this bytes  tsoffset  bytes sizeof_long
// clear cache or else gettimestamp() possibly returns an old value
return true
return false
//---------------------------------------------------------------------------
//
//  methods that return copies of fields
//
//---------------------------------------------------------------------------
/**
* do not use unless you have to.  used internally for compacting and testing.
*
* use {@link #getrow()}, {@link #getfamily()}, {@link #getqualifier()}, and
* {@link #getvalue()} if accessing a keyvalue client-side.
* @return copy of the key portion only.
*/
public byte  getkey
int keylength   getkeylength
byte  key   new byte
system arraycopy getbuffer    getkeyoffset    key  0  keylength
return key
/**
* returns value in a new byte array.
* primarily for use client-side. if server-side, use
* {@link #getbuffer()} with appropriate offsets and lengths instead to
* save on allocations.
* @return value in a new byte array.
*/
public byte  getvalue
int o   getvalueoffset
int l   getvaluelength
byte  result   new byte
system arraycopy getbuffer    o  result  0  l
return result
/**
* returns the value wrapped in a new <code>bytebuffer</code>.
*
* @return the value
*/
public bytebuffer getvalueasbytebuffer
return bytebuffer wrap getbuffer    getvalueoffset    getvaluelength
/**
* loads this object's value into the provided <code>bytebuffer</code>.
* <p>
* does not clear or flip the buffer.
*
* @param dst the buffer where to write the value
*
* @throws bufferoverflowexception if there is insufficient space remaining in the buffer
*/
public void loadvalue bytebuffer dst  throws bufferoverflowexception
dst put getbuffer    getvalueoffset    getvaluelength
/**
* primarily for use client-side.  returns the row of this keyvalue in a new
* byte array.<p>
*
* if server-side, use {@link #getbuffer()} with appropriate offsets and
* lengths instead.
* @return row in a new byte array.
*/
public byte  getrow
int o   getrowoffset
short l   getrowlength
byte result   new byte
system arraycopy getbuffer    o  result  0  l
return result
/**
*
* @return timestamp
*/
@override
public long gettimestamp
return gettimestamp getkeylength
/**
* @param keylength pass if you have it to save on a int creation.
* @return timestamp
*/
long gettimestamp final int keylength
int tsoffset   gettimestampoffset keylength
return bytes tolong this bytes  tsoffset
/**
* @return type of this keyvalue.
*/
public byte gettype
return gettype getkeylength
/**
* @return keyvalue.type byte representation
*/
@override
public byte gettypebyte
return gettype getkeylength
/**
* @param keylength pass if you have it to save on a int creation.
* @return type of this keyvalue.
*/
byte gettype final int keylength
return this bytes
/**
* @return true if a delete type, a {@link keyvalue.type#delete} or
* a {keyvalue.type#deletefamily} or a {@link keyvalue.type#deletecolumn}
* keyvalue type.
*/
public boolean isdelete
return keyvalue isdelete gettype
/**
* @return true if this kv is a {@link keyvalue.type#delete} type.
*/
public boolean isdeletetype
// todo: fix this method name vis-a-vis isdelete!
return gettype      type delete getcode
/**
* @return true if this kv is a delete family type.
*/
public boolean isdeletefamily
return gettype      type deletefamily getcode
/**
* @return true if this kv is a delete family-version type.
*/
public boolean isdeletefamilyversion
return gettype      type deletefamilyversion getcode
/**
*
* @return true if this kv is a delete family or column type.
*/
public boolean isdeletecolumnorfamily
int t   gettype
return t    type deletecolumn getcode      t    type deletefamily getcode
/**
* primarily for use client-side.  returns the family of this keyvalue in a
* new byte array.<p>
*
* if server-side, use {@link #getbuffer()} with appropriate offsets and
* lengths instead.
* @return returns family. makes a copy.
*/
public byte  getfamily
int o   getfamilyoffset
int l   getfamilylength o
byte  result   new byte
system arraycopy this bytes  o  result  0  l
return result
/**
* primarily for use client-side.  returns the column qualifier of this
* keyvalue in a new byte array.<p>
*
* if server-side, use {@link #getbuffer()} with appropriate offsets and
* lengths instead.
* use {@link #getbuffer()} with appropriate offsets and lengths instead.
* @return returns qualifier. makes a copy.
*/
public byte  getqualifier
int o   getqualifieroffset
int l   getqualifierlength
byte  result   new byte
system arraycopy this bytes  o  result  0  l
return result
//---------------------------------------------------------------------------
//
//  keyvalue splitter
//
//---------------------------------------------------------------------------
/**
* utility class that splits a keyvalue buffer into separate byte arrays.
* <p>
* should get rid of this if we can, but is very useful for debugging.
*/
public static class splitkeyvalue
private byte  split
splitkeyvalue
this split   new byte
public void setrow byte  value    this split   value
public void setfamily byte  value    this split   value
public void setqualifier byte  value    this split   value
public void settimestamp byte  value    this split   value
public void settype byte  value    this split   value
public void setvalue byte  value    this split   value
public byte  getrow     return this split
public byte  getfamily     return this split
public byte  getqualifier     return this split
public byte  gettimestamp     return this split
public byte  gettype     return this split
public byte  getvalue     return this split
public splitkeyvalue split
splitkeyvalue split   new splitkeyvalue
int splitoffset   this offset
int keylen   bytes toint bytes  splitoffset
splitoffset    bytes sizeof_int
int vallen   bytes toint bytes  splitoffset
splitoffset    bytes sizeof_int
short rowlen   bytes toshort bytes  splitoffset
splitoffset    bytes sizeof_short
byte  row   new byte
system arraycopy bytes  splitoffset  row  0  rowlen
splitoffset    rowlen
split setrow row
byte famlen   bytes
splitoffset    bytes sizeof_byte
byte  family   new byte
system arraycopy bytes  splitoffset  family  0  famlen
splitoffset    famlen
split setfamily family
int collen   keylen
rowlen   famlen   bytes sizeof_short   bytes sizeof_byte
bytes sizeof_long   bytes sizeof_byte
byte  qualifier   new byte
system arraycopy bytes  splitoffset  qualifier  0  collen
splitoffset    collen
split setqualifier qualifier
byte  timestamp   new byte
system arraycopy bytes  splitoffset  timestamp  0  bytes sizeof_long
splitoffset    bytes sizeof_long
split settimestamp timestamp
byte  type   new byte
type   bytes
splitoffset    bytes sizeof_byte
split settype type
byte  value   new byte
system arraycopy bytes  splitoffset  value  0  vallen
split setvalue value
return split
//---------------------------------------------------------------------------
//
//  compare specified fields against those contained in this keyvalue
//
//---------------------------------------------------------------------------
/**
* @param family
* @return true if matching families.
*/
public boolean matchingfamily final byte  family
return matchingfamily family  0  family length
public boolean matchingfamily final byte family  int offset  int length
if  this length    0    this bytes length    0
return false
return bytes equals family  offset  length
this bytes  getfamilyoffset    getfamilylength
public boolean matchingfamily final keyvalue other
return matchingfamily other getbuffer    other getfamilyoffset
other getfamilylength
/**
* @param qualifier
* @return true if matching qualifiers.
*/
public boolean matchingqualifier final byte  qualifier
return matchingqualifier qualifier  0  qualifier length
public boolean matchingqualifier final byte  qualifier  int offset  int length
return bytes equals qualifier  offset  length
this bytes  getqualifieroffset    getqualifierlength
public boolean matchingqualifier final keyvalue other
return matchingqualifier other getbuffer    other getqualifieroffset
other getqualifierlength
public boolean matchingrow final byte  row
return matchingrow row  0  row length
public boolean matchingrow final byte row  int offset  int length
return bytes equals row  offset  length
this bytes  getrowoffset    getrowlength
public boolean matchingrow keyvalue other
return matchingrow other getbuffer    other getrowoffset
other getrowlength
/**
* @param column column minus its delimiter
* @return true if column matches.
*/
public boolean matchingcolumnnodelimiter final byte  column
int rl   getrowlength
int o   getfamilyoffset rl
int fl   getfamilylength o
int l   fl   getqualifierlength rl fl
return bytes equals column  0  column length  this bytes  o  l
/**
*
* @param family column family
* @param qualifier column qualifier
* @return true if column matches
*/
public boolean matchingcolumn final byte family  final byte qualifier
return matchingcolumn family  0  family    null ? 0   family length
qualifier  0  qualifier    null ? 0   qualifier length
/**
* checks if column matches.
*
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
*
* @return true if column matches
*/
public boolean matchingcolumn final byte  family  final int foffset  final int flength
final byte  qualifier  final int qoffset  final int qlength
int rl   getrowlength
int o   getfamilyoffset rl
int fl   getfamilylength o
if   bytes equals family  foffset  flength  this bytes  o  fl
return false
int ql   getqualifierlength rl  fl
if  qualifier    null    qlength    0
return  ql    0
return bytes equals qualifier  qoffset  qlength  this bytes  o   fl  ql
/**
* @param left
* @param loffset
* @param llength
* @param lfamilylength offset of family delimiter in left column.
* @param right
* @param roffset
* @param rlength
* @param rfamilylength offset of family delimiter in right column.
* @return the result of the comparison.
*/
static int comparecolumns final byte  left  final int loffset
final int llength  final int lfamilylength
final byte  right  final int roffset  final int rlength
final int rfamilylength
// compare family portion first.
int diff   bytes compareto left  loffset  lfamilylength
right  roffset  rfamilylength
if  diff    0
return diff
// compare qualifier portion
return bytes compareto left  loffset   lfamilylength
llength   lfamilylength
right  roffset   rfamilylength  rlength   rfamilylength
/**
* @return true if non-null row and column.
*/
public boolean nonnullrowandcolumn
return getrowlength   > 0     isemptycolumn
/**
* @return true if column is empty.
*/
public boolean isemptycolumn
return getqualifierlength      0
/**
* creates a new keyvalue that only contains the key portion (the value is
* set to be null).
* @param lenasval replace value with the actual value length (false=empty)
*/
public keyvalue createkeyonly boolean lenasval
// kv format:  <keylen:4><valuelen:4><key:keylen><value:valuelen>
// rebuild as: <keylen:4><0:4><key:keylen>
int datalen   lenasval? bytes sizeof_int   0
byte  newbuffer   new byte
system arraycopy this bytes  this offset  newbuffer  0
math min newbuffer length this length
bytes putint newbuffer  bytes sizeof_int  datalen
if  lenasval
bytes putint newbuffer  newbuffer length   datalen  this getvaluelength
return new keyvalue newbuffer
/**
* splits a column in family:qualifier form into separate byte arrays.
* <p>
* not recommend to be used as this is old-style api.
* @param c  the column.
* @return the parsed column.
*/
public static byte  parsecolumn byte  c
final int index   getdelimiter c  0  c length  column_family_delimiter
if  index     1
// if no delimiter, return array of size 1
return new byte    c
else if index    c length   1
// only a family, return array size 1
byte  family   new byte
system arraycopy c  0  family  0  family length
return new byte    family
// family and column, return array size 2
final byte  result   new byte
result   new byte
system arraycopy c  0  result  0  index
final int len   c length    index   1
result   new byte
system arraycopy c  index   1   skip delimiter    result  0
len
return result
/**
* makes a column in family:qualifier form from separate byte arrays.
* <p>
* not recommended for usage as this is old-style api.
* @param family
* @param qualifier
* @return family:qualifier
*/
public static byte  makecolumn byte  family  byte  qualifier
return bytes add family  column_family_delim_array  qualifier
/**
* @param b
* @return index of the family-qualifier colon delimiter character in passed
* buffer.
*/
public static int getfamilydelimiterindex final byte  b  final int offset
final int length
return getrequireddelimiter b  offset  length  column_family_delimiter
private static int getrequireddelimiter final byte  b
final int offset  final int length  final int delimiter
int index   getdelimiter b  offset  length  delimiter
if  index < 0
throw new illegalargumentexception      char delimiter
bytes tostring b            length       offset
return index
/**
* this function is only used in meta key comparisons so its error message
* is specific for meta key errors.
*/
static int getrequireddelimiterinreverse final byte  b
final int offset  final int length  final int delimiter
int index   getdelimiterinreverse b  offset  length  delimiter
if  index < 0
throw new illegalargumentexception      char delimiter
return index
/**
* @param b
* @param delimiter
* @return index of delimiter having started from start of <code>b</code>
* moving rightward.
*/
public static int getdelimiter final byte  b  int offset  final int length
final int delimiter
if  b    null
throw new illegalargumentexception
int result    1
for  int i   offset  i < length   offset  i
if  b    delimiter
result   i
break
return result
/**
* find index of passed delimiter walking from end of buffer backwards.
* @param b
* @param delimiter
* @return index of delimiter
*/
public static int getdelimiterinreverse final byte  b  final int offset
final int length  final int delimiter
if  b    null
throw new illegalargumentexception
int result    1
for  int i    offset   length    1  i >  offset  i
if  b    delimiter
result   i
break
return result
/**
* a {@link kvcomparator} for <code>.meta.</code> catalog table
* {@link keyvalue}s.
*/
public static class metacomparator extends kvcomparator
private final keycomparator rawcomparator   new metakeycomparator
public keycomparator getrawcomparator
return this rawcomparator
@override
protected object clone   throws clonenotsupportedexception
return new metacomparator
/**
* override the row key comparision to parse and compare the meta row key parts.
*/
@override
protected int comparerowkey final cell l  final cell r
byte left   l getrowarray
int loffset   l getrowoffset
int llength   l getrowlength
byte right   r getrowarray
int roffset   r getrowoffset
int rlength   r getrowlength
int leftdelimiter   getdelimiter left  loffset  llength
hconstants delimiter
int rightdelimiter   getdelimiter right  roffset  rlength
hconstants delimiter
if  leftdelimiter < 0    rightdelimiter >  0
// nothing between .meta. and regionid.  its first key.
return  1
else if  rightdelimiter < 0    leftdelimiter >  0
return 1
else if  leftdelimiter < 0    rightdelimiter < 0
return 0
// compare up to the delimiter
int result   bytes compareto left  loffset  leftdelimiter   loffset
right  roffset  rightdelimiter   roffset
if  result    0
return result
// compare middle bit of the row.
// move past delimiter
leftdelimiter
rightdelimiter
int leftfardelimiter   getrequireddelimiterinreverse left  leftdelimiter
llength    leftdelimiter   loffset   hconstants delimiter
int rightfardelimiter   getrequireddelimiterinreverse right
rightdelimiter  rlength    rightdelimiter   roffset
hconstants delimiter
// now compare middlesection of row.
result   bytes compareto
left   leftdelimiter   leftfardelimiter   leftdelimiter
right  rightdelimiter  rightfardelimiter   rightdelimiter
if  result    0
return result
// compare last part of row, the rowid.
leftfardelimiter
rightfardelimiter
result   bytes compareto
left   leftfardelimiter   llength    leftfardelimiter   loffset
right  rightfardelimiter  rlength    rightfardelimiter   roffset
return result
/**
* compare keyvalues.  when we compare keyvalues, we only compare the key
* portion.  this means two keyvalues with same key but different values are
* considered the same as far as this comparator is concerned.
* hosts a {@link keycomparator}.
*/
public static class kvcomparator implements java util comparator<cell>
private final keycomparator rawcomparator   new keycomparator
/**
* @return rawcomparator that can compare the key portion of a keyvalue.
* used in hfile where indices are the key portion of a keyvalue.
*/
public keycomparator getrawcomparator
return this rawcomparator
protected int comparerowkey final cell left  final cell right
return bytes compareto
left getrowarray     left getrowoffset     left getrowlength
right getrowarray    right getrowoffset    right getrowlength
/**
* compares the key of a cell -- with fields being more significant in this order:
* rowkey, colfam/qual, timestamp, type, mvcc
*/
public int compare final cell left  final cell right
// compare row
int compare   comparerowkey left  right
if  compare    0
return compare
// compare vs minimum
byte ltype   left gettypebyte
byte rtype   right gettypebyte
// if the column is not specified, the "minimum" key type appears the
// latest in the sorted order, regardless of the timestamp. this is used
// for specifying the last key/value in a given row, because there is no
// "lexicographically last column" (it would be infinitely long). the
// "maximum" key type does not need this behavior.
int lcfqlen   left getfamilylength     left getqualifierlength
int rcfqlen   right getfamilylength     right getqualifierlength
if  lcfqlen    0    ltype    type minimum getcode
// left is "bigger", i.e. it appears later in the sorted order
return 1
if  rcfqlen    0    rtype    type minimum getcode
return  1
// compare col family / col fam + qual
// if left family size is not equal to right family size, we need not
// compare the qualifiers.
compare   bytes compareto
left getfamilyarray     left getfamilyoffset     left getfamilylength
right getfamilyarray    right getfamilyoffset    right getfamilylength
if  compare    0
return compare
// compare qualifier
compare   bytes compareto
left getqualifierarray    left getqualifieroffset    left getqualifierlength
right getqualifierarray    right getqualifieroffset    right getqualifierlength
if  compare   0
return compare
// compare timestamp
long ltimestamp   left gettimestamp
long rtimestamp   right gettimestamp
compare   keycomparator comparetimestamps ltimestamp  rtimestamp
if  compare    0
return compare
// compare types. let the delete types sort ahead of puts; i.e. types
// of higher numbers sort before those of lesser numbers. maximum (255)
// appears ahead of everything, and minimum (0) appears after
// everything.
compare    0xff   rtype     0xff   ltype
if  compare    0
return compare
// compare mvcc version
// negate this comparison so later edits show up first
return  longs compare left getmvccversion    right getmvccversion
public int comparetimestamps final keyvalue left  final keyvalue right
return comparetimestamps left  left getkeylength    right
right getkeylength
int comparetimestamps final keyvalue left  final int lkeylength
final keyvalue right  final int rkeylength
// compare timestamps
long ltimestamp   left gettimestamp lkeylength
long rtimestamp   right gettimestamp rkeylength
return keycomparator comparetimestamps ltimestamp  rtimestamp
/**
* @param left
* @param right
* @return result comparing rows.
*/
public int comparerows final keyvalue left  final keyvalue right
return comparerows left  left getrowlength    right
right getrowlength
/**
* @param left
* @param lrowlength length of left row.
* @param right
* @param rrowlength length of right row.
* @return result comparing rows.
*/
public int comparerows final keyvalue left  final short lrowlength
final keyvalue right  final short rrowlength
return getrawcomparator   comparerows left getbuffer
left getrowoffset    lrowlength
right getbuffer    right getrowoffset    rrowlength
/**
* @param left
* @param row - row key (arbitrary byte array)
* @return rawcomparator
*/
public int comparerows final keyvalue left  final byte  row
return getrawcomparator   comparerows left getbuffer
left getrowoffset    left getrowlength    row  0  row length
public int comparerows byte  left  int loffset  int llength
byte  right  int roffset  int rlength
return getrawcomparator   comparerows left  loffset  llength
right  roffset  rlength
public int comparecolumns final keyvalue left  final byte  right
final int roffset  final int rlength  final int rfamilyoffset
int offset   left getfamilyoffset
int length   left getfamilylength     left getqualifierlength
return getrawcomparator   comparecolumns left getbuffer    offset  length
left getfamilylength offset
right  roffset  rlength  rfamilyoffset
int comparecolumns final keyvalue left  final short lrowlength
final keyvalue right  final short rrowlength
int lfoffset   left getfamilyoffset lrowlength
int rfoffset   right getfamilyoffset rrowlength
int lclength   left gettotalcolumnlength lrowlength lfoffset
int rclength   right gettotalcolumnlength rrowlength  rfoffset
int lfamilylength   left getfamilylength lfoffset
int rfamilylength   right getfamilylength rfoffset
return getrawcomparator   comparecolumns left getbuffer    lfoffset
lclength  lfamilylength
right getbuffer    rfoffset  rclength  rfamilylength
/**
* compares the row and column of two keyvalues for equality
* @param left
* @param right
* @return true if same row and column.
*/
public boolean matchingrowcolumn final keyvalue left
final keyvalue right
short lrowlength   left getrowlength
short rrowlength   right getrowlength
// tsoffset = end of column data. just comparing row+cf length of each
return   left gettimestampoffset     left getoffset
right gettimestampoffset     right getoffset
matchingrows left  lrowlength  right  rrowlength
comparecolumns left  lrowlength  right  rrowlength     0
/**
* @param left
* @param right
* @return true if rows match.
*/
public boolean matchingrows final keyvalue left  final byte  right
return bytes equals left getbuffer    left getrowoffset    left getrowlength
right  0  right length
/**
* compares the row of two keyvalues for equality
* @param left
* @param right
* @return true if rows match.
*/
public boolean matchingrows final keyvalue left  final keyvalue right
short lrowlength   left getrowlength
short rrowlength   right getrowlength
return matchingrows left  lrowlength  right  rrowlength
/**
* @param left
* @param lrowlength
* @param right
* @param rrowlength
* @return true if rows match.
*/
public boolean matchingrows final keyvalue left  final short lrowlength
final keyvalue right  final short rrowlength
return lrowlength    rrowlength
bytes equals left getbuffer    left getrowoffset    lrowlength
right getbuffer    right getrowoffset    rrowlength
public boolean matchingrows final byte  left  final int loffset
final int llength
final byte  right  final int roffset  final int rlength
return bytes equals left  loffset  llength
right  roffset  rlength
/**
* compares the row and timestamp of two keys
* was called matcheswithoutcolumn in hstorekey.
* @param right key to compare against.
* @return true if same row and timestamp is greater than the timestamp in
* <code>right</code>
*/
public boolean matchingrowsgreatertimestamp final keyvalue left
final keyvalue right
short lrowlength   left getrowlength
short rrowlength   right getrowlength
if   matchingrows left  lrowlength  right  rrowlength
return false
return left gettimestamp   >  right gettimestamp
@override
protected object clone   throws clonenotsupportedexception
return new kvcomparator
/**
* creates a keyvalue that is last on the specified row id. that is,
* every other possible keyvalue for the given row would compareto()
* less than the result of this call.
* @param row row key
* @return last possible keyvalue on passed <code>row</code>
*/
public static keyvalue createlastonrow final byte row
return new keyvalue row  null  null  hconstants latest_timestamp  type minimum
/**
* create a keyvalue that is smaller than all other possible keyvalues
* for the given row. that is any (valid) keyvalue on 'row' would sort
* _after_ the result.
*
* @param row - row key (arbitrary byte array)
* @return first possible keyvalue on passed <code>row</code>
*/
public static keyvalue createfirstonrow final byte  row
return createfirstonrow row  hconstants latest_timestamp
/**
* create a keyvalue that is smaller than all other possible keyvalues
* for the given row. that is any (valid) keyvalue on 'row' would sort
* _after_ the result.
*
* @param row - row key (arbitrary byte array)
* @return first possible keyvalue on passed <code>row</code>
*/
public static keyvalue createfirstonrow final byte  row  int roffset  short rlength
return new keyvalue row  roffset  rlength
null  0  0  null  0  0  hconstants latest_timestamp  type maximum  null  0  0
/**
* creates a keyvalue that is smaller than all other keyvalues that
* are older than the passed timestamp.
* @param row - row key (arbitrary byte array)
* @param ts - timestamp
* @return first possible key on passed <code>row</code> and timestamp.
*/
public static keyvalue createfirstonrow final byte  row
final long ts
return new keyvalue row  null  null  ts  type maximum
/**
* create a keyvalue for the specified row, family and qualifier that would be
* smaller than all other possible keyvalues that have the same row,family,qualifier.
* used for seeking.
* @param row - row key (arbitrary byte array)
* @param family - family name
* @param qualifier - column qualifier
* @return first possible key on passed <code>row</code>, and column.
*/
public static keyvalue createfirstonrow final byte  row  final byte  family
final byte  qualifier
return new keyvalue row  family  qualifier  hconstants latest_timestamp  type maximum
/**
* create a delete family keyvalue for the specified row and family that would
* be smaller than all other possible delete family keyvalues that have the
* same row and family.
* used for seeking.
* @param row - row key (arbitrary byte array)
* @param family - family name
* @return first delete family possible key on passed <code>row</code>.
*/
public static keyvalue createfirstdeletefamilyonrow final byte  row
final byte  family
return new keyvalue row  family  null  hconstants latest_timestamp
type deletefamily
/**
* @param row - row key (arbitrary byte array)
* @param f - family name
* @param q - column qualifier
* @param ts - timestamp
* @return first possible key on passed <code>row</code>, column and timestamp
*/
public static keyvalue createfirstonrow final byte  row  final byte  f
final byte  q  final long ts
return new keyvalue row  f  q  ts  type maximum
/**
* create a keyvalue for the specified row, family and qualifier that would be
* smaller than all other possible keyvalues that have the same row,
* family, qualifier.
* used for seeking.
* @param row row key
* @param roffset row offset
* @param rlength row length
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
* @return first possible key on passed row, family, qualifier.
*/
public static keyvalue createfirstonrow final byte  row
final int roffset  final int rlength  final byte  family
final int foffset  final int flength  final byte  qualifier
final int qoffset  final int qlength
return new keyvalue row  roffset  rlength  family
foffset  flength  qualifier  qoffset  qlength
hconstants latest_timestamp  type maximum  null  0  0
/**
* create a keyvalue for the specified row, family and qualifier that would be
* smaller than all other possible keyvalues that have the same row,
* family, qualifier.
* used for seeking.
*
* @param buffer the buffer to use for the new <code>keyvalue</code> object
* @param row the value key
* @param family family name
* @param qualifier column qualifier
*
* @return first possible key on passed row, family, qualifier.
*
* @throws illegalargumentexception the resulting <code>keyvalue</code> object would be larger
* than the provided buffer or than <code>integer.max_value</code>
*/
public static keyvalue createfirstonrow byte  buffer  final byte  row
final byte  family  final byte  qualifier
throws illegalargumentexception
return createfirstonrow buffer  0  row  0  row length
family  0  family length
qualifier  0  qualifier length
/**
* create a keyvalue for the specified row, family and qualifier that would be
* smaller than all other possible keyvalues that have the same row,
* family, qualifier.
* used for seeking.
*
* @param buffer the buffer to use for the new <code>keyvalue</code> object
* @param boffset buffer offset
* @param row the value key
* @param roffset row offset
* @param rlength row length
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
*
* @return first possible key on passed row, family, qualifier.
*
* @throws illegalargumentexception the resulting <code>keyvalue</code> object would be larger
* than the provided buffer or than <code>integer.max_value</code>
*/
public static keyvalue createfirstonrow byte  buffer  final int boffset
final byte  row  final int roffset  final int rlength
final byte  family  final int foffset  final int flength
final byte  qualifier  final int qoffset  final int qlength
throws illegalargumentexception
long llength   getkeyvaluedatastructuresize rlength  flength  qlength  0
if  llength > integer max_value
throw new illegalargumentexception     llength       integer max_value
int ilength    int  llength
if  buffer length   boffset < ilength
throw new illegalargumentexception      buffer length   boffset
ilength
return new keyvalue buffer  boffset
row  roffset  rlength
family  foffset  flength
qualifier  qoffset  qlength
hconstants latest_timestamp  keyvalue type maximum
null  0  0
/**
* create a keyvalue for the specified row, family and qualifier that would be
* larger than or equal to all other possible keyvalues that have the same
* row, family, qualifier.
* used for reseeking.
* @param row row key
* @param roffset row offset
* @param rlength row length
* @param family family name
* @param foffset family offset
* @param flength family length
* @param qualifier column qualifier
* @param qoffset qualifier offset
* @param qlength qualifier length
* @return last possible key on passed row, family, qualifier.
*/
public static keyvalue createlastonrow final byte  row
final int roffset  final int rlength  final byte  family
final int foffset  final int flength  final byte  qualifier
final int qoffset  final int qlength
return new keyvalue row  roffset  rlength  family
foffset  flength  qualifier  qoffset  qlength
hconstants oldest_timestamp  type minimum  null  0  0
/**
* similar to {@link #createlastonrow(byte[], int, int, byte[], int, int,
* byte[], int, int)} but creates the last key on the row/column of this kv
* (the value part of the returned kv is always empty). used in creating
* "fake keys" for the multi-column bloom filter optimization to skip the
* row/column we already know is not in the file.
* @return the last key on the row/column of the given key-value pair
*/
public keyvalue createlastonrowcol
return new keyvalue
bytes  getrowoffset    getrowlength
bytes  getfamilyoffset    getfamilylength
bytes  getqualifieroffset    getqualifierlength
hconstants oldest_timestamp  type minimum  null  0  0
/**
* creates the first kv with the row/family/qualifier of this kv and the
* given timestamp. uses the "maximum" kv type that guarantees that the new
* kv is the lowest possible for this combination of row, family, qualifier,
* and timestamp. this kv's own timestamp is ignored. while this function
* copies the value from this kv, it is normally used on key-only kvs.
*/
public keyvalue createfirstonrowcolts long ts
return new keyvalue
bytes  getrowoffset    getrowlength
bytes  getfamilyoffset    getfamilylength
bytes  getqualifieroffset    getqualifierlength
ts  type maximum  bytes  getvalueoffset    getvaluelength
/**
* @param b
* @return a keyvalue made of a byte array that holds the key-only part.
* needed to convert hfile index members to keyvalues.
*/
public static keyvalue createkeyvaluefromkey final byte  b
return createkeyvaluefromkey b  0  b length
/**
* @param bb
* @return a keyvalue made of a byte buffer that holds the key-only part.
* needed to convert hfile index members to keyvalues.
*/
public static keyvalue createkeyvaluefromkey final bytebuffer bb
return createkeyvaluefromkey bb array    bb arrayoffset    bb limit
/**
* @param b
* @param o
* @param l
* @return a keyvalue made of a byte array that holds the key-only part.
* needed to convert hfile index members to keyvalues.
*/
public static keyvalue createkeyvaluefromkey final byte  b  final int o
final int l
byte  newb   new byte
system arraycopy b  o  newb  row_offset  l
bytes putint newb  0  l
bytes putint newb  bytes sizeof_int  0
return new keyvalue newb
/**
* @param in where to read bytes from.  creates a byte array to hold the keyvalue
* backing bytes copied from the steam.
* @return keyvalue created by deserializing from <code>in</code> or if we find a length
* of zero, we will return null which can be useful marking a stream as done.
* @throws ioexception
*/
public static keyvalue create final datainput in  throws ioexception
return create in readint    in
/**
* create a keyvalue reading <code>length</code> from <code>in</code>
* @param length
* @param in
* @return created keyvalue or if we find a length of zero, we will return null which
* can be useful marking a stream as done.
* @throws ioexception
*/
public static keyvalue create int length  final datainput in  throws ioexception
if  length    0  return null
// this is how the old writables.readfrom used to deserialize.  didn't even vint.
byte  bytes   new byte
in readfully bytes
return new keyvalue bytes  0  length
/**
* create a keyvalue reading from the raw inputstream.
* named <code>iscreate</code> so doesn't clash with {@link #create(datainput)}
* @param in
* @return created keyvalue or if we find a length of zero, we will return null which
* can be useful marking a stream as done.
* @throws ioexception
*/
public static keyvalue iscreate final inputstream in  throws ioexception
byte  intbytes   new byte
int bytesread   0
while  bytesread < intbytes length
int n   in read intbytes  bytesread  intbytes length   bytesread
if  n < 0
if  bytesread    0  return null     eof at start is ok
throw new ioexception     bytesread
bytesread    n
// todo: perhaps some sanity check is needed here.
byte  bytes   new byte
ioutils readfully in  bytes  0  bytes length
return new keyvalue bytes  0  bytes length
/**
* write out a keyvalue in the manner in which we used to when keyvalue was a writable.
* @param kv
* @param out
* @return length written on stream
* @throws ioexception
* @see #create(datainput) for the inverse function
*/
public static long write final keyvalue kv  final dataoutput out  throws ioexception
// this is how the old writables write used to serialize kvs.  need to figure way to make it
// work for all implementations.
int length   kv getlength
out writeint length
out write kv getbuffer    kv getoffset    length
return length   bytes sizeof_int
/**
* write out a keyvalue in the manner in which we used to when keyvalue was a writable but do
* not require a {@link dataoutput}, just take plain {@link outputstream}
* named <code>oswrite</code> so does not clash with {@link #write(keyvalue, dataoutput)}
* @param kv
* @param out
* @return length written on stream
* @throws ioexception
* @see #create(datainput) for the inverse function
* @see #write(keyvalue, dataoutput)
*/
public static long oswrite final keyvalue kv  final outputstream out  throws ioexception
int length   kv getlength
// this does same as dataouput#writeint (big-endian, etc.)
out write bytes tobytes length
out write kv getbuffer    kv getoffset    length
return length   bytes sizeof_int
/**
* comparator that compares row component only of a keyvalue.
*/
public static class rowcomparator implements comparator<keyvalue>
final kvcomparator comparator
public rowcomparator final kvcomparator c
this comparator   c
public int compare keyvalue left  keyvalue right
return comparator comparerows left  right
/**
* compare key portion of a {@link keyvalue} for keys in <code>.meta.</code>
* table.
*/
public static class metakeycomparator extends keycomparator
public int comparerows byte  left  int loffset  int llength
byte  right  int roffset  int rlength
int leftdelimiter   getdelimiter left  loffset  llength
hconstants delimiter
int rightdelimiter   getdelimiter right  roffset  rlength
hconstants delimiter
if  leftdelimiter < 0    rightdelimiter >  0
// nothing between .meta. and regionid.  its first key.
return  1
else if  rightdelimiter < 0    leftdelimiter >  0
return 1
else if  leftdelimiter < 0    rightdelimiter < 0
return 0
// compare up to the delimiter
int result   bytes compareto left  loffset  leftdelimiter   loffset
right  roffset  rightdelimiter   roffset
if  result    0
return result
// compare middle bit of the row.
// move past delimiter
leftdelimiter
rightdelimiter
int leftfardelimiter   getrequireddelimiterinreverse left  leftdelimiter
llength    leftdelimiter   loffset   hconstants delimiter
int rightfardelimiter   getrequireddelimiterinreverse right
rightdelimiter  rlength    rightdelimiter   roffset
hconstants delimiter
// now compare middlesection of row.
result   super comparerows left  leftdelimiter
leftfardelimiter   leftdelimiter  right  rightdelimiter
rightfardelimiter   rightdelimiter
if  result    0
return result
// compare last part of row, the rowid.
leftfardelimiter
rightfardelimiter
result   comparerowid left  leftfardelimiter
llength    leftfardelimiter   loffset
right  rightfardelimiter  rlength    rightfardelimiter   roffset
return result
@override
public byte getshortmidpointkey final byte leftkey  final byte rightkey
return arrays copyof rightkey  rightkey length
protected int comparerowid byte left  int loffset  int llength
byte right  int roffset  int rlength
return bytes compareto left  loffset  llength  right  roffset  rlength
/**
* avoids redundant comparisons for better performance.
*/
public interface sameprefixcomparator<t>
/**
* compare two keys assuming that the first n bytes are the same.
* @param commonprefix how many bytes are the same.
*/
int compareignoringprefix
int commonprefix  t left  int loffset  int llength  t right  int roffset  int rlength
/**
* compare key portion of a {@link keyvalue}.
*/
public static class keycomparator
implements rawcomparator<byte >  sameprefixcomparator<byte>
public int compare byte left  int loffset  int llength  byte right
int roffset  int rlength
// compare row
short lrowlength   bytes toshort left  loffset
short rrowlength   bytes toshort right  roffset
int compare   comparerows left  loffset   bytes sizeof_short
lrowlength  right  roffset   bytes sizeof_short  rrowlength
if  compare    0
return compare
// compare the rest of the two kvs without making any assumptions about
// the common prefix. this function will not compare rows anyway, so we
// don't need to tell it that the common prefix includes the row.
return comparewithoutrow 0  left  loffset  llength  right  roffset
rlength  rrowlength
/**
* compare the two key-values, ignoring the prefix of the given length
* that is known to be the same between the two.
* @param commonprefix the prefix length to ignore
*/
@override
public int compareignoringprefix int commonprefix  byte left
int loffset  int llength  byte right  int roffset  int rlength
// compare row
short lrowlength   bytes toshort left  loffset
short rrowlength
int comparisonresult   0
if  commonprefix < row_length_size
// almost nothing in common
rrowlength   bytes toshort right  roffset
comparisonresult   comparerows left  loffset   row_length_size
lrowlength  right  roffset   row_length_size  rrowlength
else      the row length is the same
rrowlength   lrowlength
if  commonprefix < row_length_size   rrowlength
// the rows are not the same. exclude the common prefix and compare
// the rest of the two rows.
int common   commonprefix   row_length_size
comparisonresult   comparerows
left  loffset   common   row_length_size  lrowlength   common
right  roffset   common   row_length_size  rrowlength   common
if  comparisonresult    0
return comparisonresult
assert lrowlength    rrowlength
return comparewithoutrow commonprefix  left  loffset  llength  right
roffset  rlength  lrowlength
/**
* compare columnfamily, qualifier, timestamp, and key type (everything
* except the row). this method is used both in the normal comparator and
* the "same-prefix" comparator. note that we are assuming that row portions
* of both kvs have already been parsed and found identical, and we don't
* validate that assumption here.
* @param commonprefix
*          the length of the common prefix of the two key-values being
*          compared, including row length and row
*/
private int comparewithoutrow int commonprefix  byte left  int loffset
int llength  byte right  int roffset  int rlength  short rowlength
/***
* keyvalue format and commonlength:
* |_keylen_|_vallen_|_rowlen_|_rowkey_|_familen_|_fami_|_quali_|....
* ------------------|-------commonlength--------|--------------
*/
int commonlength   row_length_size   family_length_size   rowlength
// commonlength + timestamp_type_size
int commonlengthwithtsandtype   timestamp_type_size   commonlength
// columnfamily + qualifier length.
int lcolumnlength   llength   commonlengthwithtsandtype
int rcolumnlength   rlength   commonlengthwithtsandtype
byte ltype   left
byte rtype   right
// if the column is not specified, the "minimum" key type appears the
// latest in the sorted order, regardless of the timestamp. this is used
// for specifying the last key/value in a given row, because there is no
// "lexicographically last column" (it would be infinitely long). the
// "maximum" key type does not need this behavior.
if  lcolumnlength    0    ltype    type minimum getcode
// left is "bigger", i.e. it appears later in the sorted order
return 1
if  rcolumnlength    0    rtype    type minimum getcode
return  1
int lfamilyoffset   commonlength   loffset
int rfamilyoffset   commonlength   roffset
// column family length.
int lfamilylength   left
int rfamilylength   right
// if left family size is not equal to right family size, we need not
// compare the qualifiers.
boolean samefamilysize    lfamilylength    rfamilylength
int common   0
if  commonprefix > 0
common   math max 0  commonprefix   commonlength
if   samefamilysize
// common should not be larger than math.min(lfamilylength,
// rfamilylength).
common   math min common  math min lfamilylength  rfamilylength
else
common   math min common  math min lcolumnlength  rcolumnlength
if   samefamilysize
// comparing column family is enough.
return bytes compareto left  lfamilyoffset   common  lfamilylength
common  right  rfamilyoffset   common  rfamilylength   common
// compare family & qualifier together.
final int comparison   bytes compareto left  lfamilyoffset   common
lcolumnlength   common  right  rfamilyoffset   common
rcolumnlength   common
if  comparison    0
return comparison
return comparetimestampandtype left  loffset  llength  right  roffset
rlength  ltype  rtype
private int comparetimestampandtype byte left  int loffset  int llength
byte right  int roffset  int rlength  byte ltype  byte rtype
int compare
// get timestamps.
long ltimestamp   bytes tolong left
loffset    llength   timestamp_type_size
long rtimestamp   bytes tolong right
roffset    rlength   timestamp_type_size
compare   comparetimestamps ltimestamp  rtimestamp
if  compare    0
return compare
// compare types. let the delete types sort ahead of puts; i.e. types
// of higher numbers sort before those of lesser numbers. maximum (255)
// appears ahead of everything, and minimum (0) appears after
// everything.
return  0xff   rtype     0xff   ltype
public int compare byte left  byte right
return compare left  0  left length  right  0  right length
public int comparerows byte  left  int loffset  int llength
byte  right  int roffset  int rlength
return bytes compareto left  loffset  llength  right  roffset  rlength
/**
* generate a faked byte array if possible. it aims to:
* 1)reduce key length, which expects to reduce hfile index memory footprint
* 2)replace ts field with latest_timestamp(to avoid seeking previous block)
* see hbase-7845 for more details
* we need to ensure: leftkey < newkey <= rightkey
* @param leftkey the previous block's real stop key usually
* @param rightkey the current block's real start key usually
* @return newkey: the newly generated faked key
*/
public byte getshortmidpointkey final byte leftkey  final byte rightkey
if  rightkey    null
throw new illegalargumentexception
if  leftkey    null
return arrays copyof rightkey  rightkey length
if  compare leftkey  rightkey  >  0
throw new illegalargumentexception     bytes tostring leftkey
bytes tostring rightkey
short leftrowlength   bytes toshort leftkey  0
short rightrowlength   bytes toshort rightkey  0
int leftcommonlength   row_length_size   family_length_size   leftrowlength
int rightcommonlength   row_length_size   family_length_size   rightrowlength
int leftcommonlengthwithtsandtype   timestamp_type_size   leftcommonlength
int rightcommonlengthwithtsandtype   timestamp_type_size   rightcommonlength
int leftcolumnlength   leftkey length   leftcommonlengthwithtsandtype
int rightcolumnlength   rightkey length   rightcommonlengthwithtsandtype
// rows are equal
if  leftrowlength    rightrowlength    comparerows leftkey  row_length_size  leftrowlength
rightkey  row_length_size  rightrowlength     0
// compare family & qualifier together.
int comparison   bytes compareto leftkey  leftcommonlength  leftcolumnlength  rightkey
rightcommonlength  rightcolumnlength
// same with "row + family + qualifier", return rightkey directly
if  comparison    0
return arrays copyof rightkey  rightkey length
// "family + qualifier" are different, generate a faked key per rightkey
byte newkey   arrays copyof rightkey  rightkey length
bytes putlong newkey  rightkey length   timestamp_type_size  hconstants latest_timestamp
bytes putbyte newkey  rightkey length   type_size  type maximum getcode
return newkey
// rows are different
short minlength   leftrowlength < rightrowlength ? leftrowlength   rightrowlength
short diffidx   0
while  diffidx < minlength
leftkey    rightkey
diffidx
if  diffidx >  minlength
// leftkey's row is prefix of rightkey's. we can optimize it in future
return arrays copyof rightkey  rightkey length
int diffbyte   leftkey
if   0xff   diffbyte  < 0xff     diffbyte   1  <
rightkey   0xff
byte newrowkey   new byte
system arraycopy leftkey  row_length_size  newrowkey  0  diffidx
newrowkey    byte   diffbyte   1
int rightfamilylength   rightkey
byte family   null
if  rightfamilylength > 0
family   new byte
system arraycopy rightkey  rightcommonlength  family  0  rightfamilylength
int rightqualifierlength   rightcolumnlength   rightfamilylength
byte qualifier   null
if  rightqualifierlength > 0
qualifier   new byte
system arraycopy rightkey  rightcommonlength   rightfamilylength  qualifier  0
rightqualifierlength
return new keyvalue newrowkey  null  null  hconstants latest_timestamp
type maximum  getkey
// the following is optimizable in future
return arrays copyof rightkey  rightkey length
protected int comparecolumns
byte  left  int loffset  int llength  final int lfamilylength
byte  right  int roffset  int rlength  final int rfamilylength
return keyvalue comparecolumns left  loffset  llength  lfamilylength
right  roffset  rlength  rfamilylength
static int comparetimestamps final long ltimestamp  final long rtimestamp
// the below older timestamps sorting ahead of newer timestamps looks
// wrong but it is intentional. this way, newer timestamps are first
// found when we iterate over a memstore and newer versions are the
// first we trip over when reading from a store file.
if  ltimestamp < rtimestamp
return 1
else if  ltimestamp > rtimestamp
return  1
return 0
/**
* heapsize implementation
*
* we do not count the bytes in the rowcache because it should be empty for a keyvalue in the
* memstore.
*/
@override
public long heapsize
int sum   0
sum    classsize object    the keyvalue object itself
sum    classsize reference    pointer to
sum    classsize align classsize array
sum    classsize align length     number of bytes of data in the   array
sum    3   bytes sizeof_int    offset  length  keylength
sum    bytes sizeof_long    memstorets
return classsize align sum
@override
public int gettagsoffset
throw new unsupportedoperationexception
@override
public int gettagslength
throw new unsupportedoperationexception
@override
public byte gettagsarray
throw new unsupportedoperationexception