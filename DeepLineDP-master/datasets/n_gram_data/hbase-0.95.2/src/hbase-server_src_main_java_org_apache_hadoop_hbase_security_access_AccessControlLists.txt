/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase security access
import java io bytearrayinputstream
import java io datainput
import java io datainputstream
import java io ioexception
import java util arraylist
import java util arrays
import java util list
import java util map
import java util set
import java util treemap
import java util treeset
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop hbase tablename
import org apache hadoop hbase exceptions deserializationexception
import org apache hadoop hbase hcolumndescriptor
import org apache hadoop hbase hconstants
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase keyvalue
import org apache hadoop hbase namespacedescriptor
import org apache hadoop hbase catalog metareader
import org apache hadoop hbase client delete
import org apache hadoop hbase client get
import org apache hadoop hbase client htable
import org apache hadoop hbase client put
import org apache hadoop hbase client result
import org apache hadoop hbase client resultscanner
import org apache hadoop hbase client scan
import org apache hadoop hbase filter comparefilter compareop
import org apache hadoop hbase filter qualifierfilter
import org apache hadoop hbase filter regexstringcomparator
import org apache hadoop hbase io compress compression
import org apache hadoop hbase master masterservices
import org apache hadoop hbase protobuf protobufutil
import org apache hadoop hbase protobuf generated accesscontrolprotos
import org apache hadoop hbase regionserver bloomtype
import org apache hadoop hbase regionserver hregion
import org apache hadoop hbase regionserver internalscanner
import org apache hadoop hbase util bytes
import org apache hadoop hbase util pair
import org apache hadoop io text
import com google common collect arraylistmultimap
import com google common collect listmultimap
import com google protobuf invalidprotocolbufferexception
/**
* maintains lists of permission grants to users and groups to allow for
* authorization checks by {@link accesscontroller}.
*
* <p>
* access control lists are stored in an "internal" metadata table named
* {@code _acl_}. each table's permission grants are stored as a separate row,
* keyed by the table name. keyvalues for permissions assignments are stored
* in one of the formats:
* <pre>
* key                      desc
* --------                 --------
* user                     table level permissions for a user [r=read, w=write]
* group                    table level permissions for a group
* user,family              column family level permissions for a user
* group,family             column family level permissions for a group
* user,family,qualifier    column qualifier level permissions for a user
* group,family,qualifier   column qualifier level permissions for a group
* </pre>
* all values are encoded as byte arrays containing the codes from the
* org.apache.hadoop.hbase.security.access.tablepermission.action enum.
* </p>
*/
public class accesscontrollists
/** internal storage table for access control lists */
public static final tablename acl_table_name
tablename valueof namespacedescriptor system_namespace_name_str
public static final byte acl_global_name   acl_table_name getname
/** column family used to store acl grants */
public static final string acl_list_family_str
public static final byte acl_list_family   bytes tobytes acl_list_family_str
public static final char namespace_prefix
/** table descriptor for acl internal table */
public static final htabledescriptor acl_tabledesc   new htabledescriptor acl_table_name
static
acl_tabledesc addfamily
new hcolumndescriptor acl_list_family
10     ten is arbitrary number   keep versions to help debugging
compression algorithm none getname    true  true  8   1024
hconstants forever  bloomtype none tostring
hconstants replication_scope_local
/**
* delimiter to separate user, column family, and qualifier in
* _acl_ table info: column keys */
public static final char acl_key_delimiter
/** prefix character to denote group names */
public static final string group_prefix
/** configuration key for superusers */
public static final string superuser_conf_key
private static log log   logfactory getlog accesscontrollists class
/**
* check for existence of {@code _acl_} table and create it if it does not exist
* @param master reference to hmaster
*/
static void init masterservices master  throws ioexception
if   metareader tableexists master getcatalogtracker    acl_table_name
master createtable acl_tabledesc  null
/**
* stores a new user permission grant in the access control lists table.
* @param conf the configuration
* @param userperm the details of the permission to be granted
* @throws ioexception in the case of an error accessing the metadata table
*/
static void adduserpermission configuration conf  userpermission userperm
throws ioexception
permission action actions   userperm getactions
byte rowkey   userpermissionrowkey userperm
put p   new put rowkey
byte key   userpermissionkey userperm
if   actions    null      actions length    0
log warn   bytes tostring userperm getuser
return
byte value   new byte
for  int i   0  i < actions length  i
value   actions code
p add acl_list_family  key  value
if  log isdebugenabled
log debug
bytes tostring rowkey
bytes tostring key    bytes tostringbinary value
htable acls   null
try
acls   new htable conf  acl_table_name
acls put p
finally
if  acls    null  acls close
/**
* removes a previously granted permission from the stored access control
* lists.  the {@link tablepermission} being removed must exactly match what
* is stored -- no wildcard matching is attempted.  ie, if user "bob" has
* been granted "read" access to the "data" table, but only to column family
* plus qualifier "info:cola", then trying to call this method with only
* user "bob" and the table name "data" (but without specifying the
* column qualifier "info:cola") will have no effect.
*
* @param conf the configuration
* @param userperm the details of the permission to be revoked
* @throws ioexception if there is an error accessing the metadata table
*/
static void removeuserpermission configuration conf  userpermission userperm
throws ioexception
delete d   new delete userpermissionrowkey userperm
byte key   userpermissionkey userperm
if  log isdebugenabled
log debug    userperm tostring
d deletecolumns acl_list_family  key
htable acls   null
try
acls   new htable conf  acl_table_name
acls delete d
finally
if  acls    null  acls close
/**
* remove specified table from the _acl_ table.
*/
static void removetablepermissions configuration conf  tablename tablename
throws ioexception
delete d   new delete tablename getname
if  log isdebugenabled
log debug    tablename
htable acls   null
try
acls   new htable conf  acl_table_name
acls delete d
finally
if  acls    null  acls close
/**
* remove specified namespace from the acl table.
*/
static void removenamespacepermissions configuration conf  string namespace
throws ioexception
delete d   new delete bytes tobytes tonamespaceentry namespace
if  log isdebugenabled
log debug    namespace
htable acls   null
try
acls   new htable conf  acl_table_name
acls delete d
finally
if  acls    null  acls close
/**
* remove specified table column from the acl table.
*/
static void removetablepermissions configuration conf  tablename tablename  byte column
throws ioexception
if  log isdebugenabled
log debug     bytes tostring column
tablename
htable acls   null
try
acls   new htable conf  acl_table_name
scan scan   new scan
scan addfamily acl_list_family
string columnname   bytes tostring column
scan setfilter new qualifierfilter compareop equal  new regexstringcomparator
string format
acl_key_delimiter  columnname  acl_key_delimiter
acl_key_delimiter  columnname
set<byte> qualifierset   new treeset<byte> bytes bytes_comparator
resultscanner scanner   acls getscanner scan
try
for  result res   scanner
for  byte q   res getfamilymap acl_list_family  navigablekeyset
qualifierset add q
finally
scanner close
if  qualifierset size   > 0
delete d   new delete tablename getname
for  byte qualifier   qualifierset
d deletecolumns acl_list_family  qualifier
acls delete d
finally
if  acls    null  acls close
static byte userpermissionrowkey userpermission userperm
byte row
if userperm hasnamespace
row   bytes tobytes tonamespaceentry userperm getnamespace
else if userperm isglobal
row   acl_global_name
else
row   userperm gettable   getname
return row
/**
* build qualifier key from user permission:
*  username
*  username,family
*  username,family,qualifier
*/
static byte userpermissionkey userpermission userperm
byte qualifier   userperm getqualifier
byte family   userperm getfamily
byte key   userperm getuser
if  family    null    family length > 0
key   bytes add key  bytes add new byte acl_key_delimiter   family
if  qualifier    null    qualifier length > 0
key   bytes add key  bytes add new byte acl_key_delimiter   qualifier
return key
/**
* returns {@code true} if the given region is part of the {@code _acl_}
* metadata table.
*/
static boolean isaclregion hregion region
return acl_table_name equals region gettabledesc   gettablename
/**
* returns {@code true} if the given table is {@code _acl_} metadata table.
*/
static boolean isacltable htabledescriptor desc
return acl_table_name equals desc gettablename
/**
* loads all of the permission grants stored in a region of the {@code _acl_}
* table.
*
* @param aclregion
* @return a map of the permissions for this table.
* @throws ioexception
*/
static map<byte  listmultimap<string tablepermission>> loadall
hregion aclregion
throws ioexception
if   isaclregion aclregion
throw new ioexception   acl_table_name
map<byte  listmultimap<string  tablepermission>> allperms
new treemap<byte  listmultimap<string  tablepermission>>
// do a full scan of _acl_ table
scan scan   new scan
scan addfamily acl_list_family
internalscanner iscanner   null
try
iscanner   aclregion getscanner scan
while  true
list<keyvalue> row   new arraylist<keyvalue>
boolean hasnext   iscanner next row
listmultimap<string tablepermission> perms   arraylistmultimap create
byte entry   null
for  keyvalue kv   row
if  entry    null
entry   kv getrow
pair<string tablepermission> permissionsofuserontable
parsepermissionrecord entry  kv
if  permissionsofuserontable    null
string username   permissionsofuserontable getfirst
tablepermission permissions   permissionsofuserontable getsecond
perms put username  permissions
if  entry    null
allperms put entry  perms
if   hasnext
break
finally
if  iscanner    null
iscanner close
return allperms
/**
* load all permissions from the region server holding {@code _acl_},
* primarily intended for testing purposes.
*/
static map<byte  listmultimap<string tablepermission>> loadall
configuration conf  throws ioexception
map<byte  listmultimap<string tablepermission>> allperms
new treemap<byte  listmultimap<string tablepermission>> bytes bytes_rawcomparator
// do a full scan of _acl_, filtering on only first table region rows
scan scan   new scan
scan addfamily acl_list_family
htable acls   null
resultscanner scanner   null
try
acls   new htable conf  acl_table_name
scanner   acls getscanner scan
for  result row   scanner
listmultimap<string tablepermission> resultperms
parsepermissions row getrow    row
allperms put row getrow    resultperms
finally
if  scanner    null  scanner close
if  acls    null  acls close
return allperms
static listmultimap<string  tablepermission> gettablepermissions configuration conf
tablename tablename  throws ioexception
return getpermissions conf  tablename    null ? tablename getname     null
static listmultimap<string  tablepermission> getnamespacepermissions configuration conf
string namespace  throws ioexception
return getpermissions conf  bytes tobytes tonamespaceentry namespace
/**
* reads user permission assignments stored in the <code>l:</code> column
* family of the first table row in <code>_acl_</code>.
*
* <p>
* see {@link accesscontrollists class documentation} for the key structure
* used for storage.
* </p>
*/
static listmultimap<string  tablepermission> getpermissions configuration conf
byte entryname  throws ioexception
if  entryname    null  entryname   acl_table_name getname
// for normal user tables, we just read the table row from _acl_
listmultimap<string  tablepermission> perms   arraylistmultimap create
htable acls   null
try
acls   new htable conf  acl_table_name
get get   new get entryname
get addfamily acl_list_family
result row   acls get get
if   row isempty
perms   parsepermissions entryname  row
else
log info     acl_table_name
bytes tostring entryname
finally
if  acls    null  acls close
return perms
/**
* returns the currently granted permissions for a given table as a list of
* user plus associated permissions.
*/
static list<userpermission> getusertablepermissions
configuration conf  tablename tablename  throws ioexception
return getuserpermissions conf  tablename getname
static list<userpermission> getusernamespacepermissions
configuration conf  string namespace  throws ioexception
return getuserpermissions conf  bytes tobytes tonamespaceentry namespace
static list<userpermission> getuserpermissions
configuration conf  byte entryname
throws ioexception
listmultimap<string tablepermission> allperms   getpermissions
conf  entryname
list<userpermission> perms   new arraylist<userpermission>
for  map entry<string  tablepermission> entry   allperms entries
userpermission up   new userpermission bytes tobytes entry getkey
entry getvalue   gettable    entry getvalue   getfamily
entry getvalue   getqualifier    entry getvalue   getactions
perms add up
return perms
private static listmultimap<string  tablepermission> parsepermissions
byte entryname  result result
listmultimap<string  tablepermission> perms   arraylistmultimap create
if  result    null    result size   > 0
for  keyvalue kv   result raw
pair<string tablepermission> permissionsofuserontable
parsepermissionrecord entryname  kv
if  permissionsofuserontable    null
string username   permissionsofuserontable getfirst
tablepermission permissions   permissionsofuserontable getsecond
perms put username  permissions
return perms
private static pair<string  tablepermission> parsepermissionrecord
byte entryname  keyvalue kv
// return x given a set of permissions encoded in the permissionrecord kv.
byte family   kv getfamily
if   bytes equals family  acl_list_family
return null
byte key   kv getqualifier
byte value   kv getvalue
if  log isdebugenabled
log debug
bytes tostringbinary key
bytes tostringbinary value
// check for a column family appended to the key
// todo: avoid the string conversion to make this more efficient
string username   bytes tostring key
//handle namespace entry
if isnamespaceentry entryname
return new pair<string  tablepermission> username
new tablepermission bytes tostring fromnamespaceentry entryname    value
//handle table and global entry
//todo global entry should be handled differently
int idx   username indexof acl_key_delimiter
byte permfamily   null
byte permqualifier   null
if  idx > 0    idx < username length   1
string remainder   username substring idx 1
username   username substring 0  idx
idx   remainder indexof acl_key_delimiter
if  idx > 0    idx < remainder length   1
permfamily   bytes tobytes remainder substring 0  idx
permqualifier   bytes tobytes remainder substring idx 1
else
permfamily   bytes tobytes remainder
return new pair<string tablepermission> username
new tablepermission tablename valueof entryname   permfamily  permqualifier  value
/**
* writes a set of permissions as {@link org.apache.hadoop.io.writable} instances
* and returns the resulting byte array.
*
* writes a set of permission [user: table permission]
*/
public static byte writepermissionsasbytes listmultimap<string  tablepermission> perms
configuration conf
return protobufutil prependpbmagic protobufutil tousertablepermissions perms  tobytearray
/**
* reads a set of permissions as {@link org.apache.hadoop.io.writable} instances
* from the input stream.
*/
public static listmultimap<string  tablepermission> readpermissions byte data
configuration conf
throws deserializationexception
if  protobufutil ispbmagicprefix data
int pblen   protobufutil lengthofpbmagic
try
accesscontrolprotos usersandpermissions perms
accesscontrolprotos usersandpermissions newbuilder   mergefrom
data  pblen  data length   pblen  build
return protobufutil tousertablepermissions perms
catch  invalidprotocolbufferexception e
throw new deserializationexception e
else
listmultimap<string tablepermission> perms   arraylistmultimap create
try
datainput in   new datainputstream new bytearrayinputstream data
int length   in readint
for  int i 0  i<length  i
string user   text readstring in
list<tablepermission> userperms
list hbaseobjectwritablefor96migration readobject in  conf
perms putall user  userperms
catch  ioexception e
throw new deserializationexception e
return perms
/**
* returns whether or not the given name should be interpreted as a group
* principal.  currently this simply checks if the name starts with the
* special group prefix character ("@").
*/
public static boolean isgroupprincipal string name
return name    null    name startswith group_prefix
/**
* returns the actual name for a group principal (stripped of the
* group prefix).
*/
public static string getgroupname string aclkey
if   isgroupprincipal aclkey
return aclkey
return aclkey substring group_prefix length
public static boolean isnamespaceentry string entryname
return entryname charat 0     namespace_prefix
public static boolean isnamespaceentry byte entryname
return entryname    namespace_prefix
public static string tonamespaceentry string namespace
return namespace_prefix   namespace
public static string fromnamespaceentry string namespace
if namespace charat 0     namespace_prefix
throw new illegalargumentexception
return namespace substring 1
public static byte tonamespaceentry byte namespace
byte ret   new byte
ret   namespace_prefix
system arraycopy namespace  0  ret  1  namespace length
return ret
public static byte fromnamespaceentry byte namespace
if namespace    namespace_prefix
throw new illegalargumentexception
bytes tostring namespace
return arrays copyofrange namespace  1  namespace length