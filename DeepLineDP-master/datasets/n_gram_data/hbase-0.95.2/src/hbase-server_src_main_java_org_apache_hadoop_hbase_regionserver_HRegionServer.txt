/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver
import java io ioexception
import java lang thread uncaughtexceptionhandler
import java lang annotation retention
import java lang annotation retentionpolicy
import java lang management managementfactory
import java lang management memoryusage
import java lang reflect constructor
import java net bindexception
import java net inetsocketaddress
import java util arraylist
import java util collection
import java util collections
import java util comparator
import java util hashmap
import java util hashset
import java util iterator
import java util list
import java util map
import java util map entry
import java util random
import java util set
import java util sortedmap
import java util treemap
import java util treeset
import java util concurrent concurrenthashmap
import java util concurrent concurrentmap
import java util concurrent concurrentskiplistmap
import java util concurrent locks reentrantreadwritelock
import javax management objectname
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop conf configuration
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hbase cellscannable
import org apache hadoop hbase cellscanner
import org apache hadoop hbase cellutil
import org apache hadoop hbase chore
import org apache hadoop hbase daemonthreadfactory
import org apache hadoop hbase tablename
import org apache hadoop hbase hbaseconfiguration
import org apache hadoop hbase hconstants
import org apache hadoop hbase hconstants operationstatuscode
import org apache hadoop hbase clockoutofsyncexception
import org apache hadoop hbase donotretryioexception
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase healthcheckchore
import org apache hadoop hbase notservingregionexception
import org apache hadoop hbase keyvalue
import org apache hadoop hbase remoteexceptionhandler
import org apache hadoop hbase servername
import org apache hadoop hbase stoppable
import org apache hadoop hbase tabledescriptors
import org apache hadoop hbase unknownscannerexception
import org apache hadoop hbase youaredeadexception
import org apache hadoop hbase znodeclearer
import org apache hadoop hbase catalog catalogtracker
import org apache hadoop hbase catalog metaeditor
import org apache hadoop hbase catalog metareader
import org apache hadoop hbase client append
import org apache hadoop hbase client delete
import org apache hadoop hbase client get
import org apache hadoop hbase client hconnectionmanager
import org apache hadoop hbase client increment
import org apache hadoop hbase client mutation
import org apache hadoop hbase client put
import org apache hadoop hbase client result
import org apache hadoop hbase client rowmutations
import org apache hadoop hbase client scan
import org apache hadoop hbase coprocessor coprocessorhost
import org apache hadoop hbase exceptions failedsanitycheckexception
import org apache hadoop hbase exceptions outoforderscannernextexception
import org apache hadoop hbase exceptions regionmovedexception
import org apache hadoop hbase exceptions regionopeningexception
import org apache hadoop hbase executor executorservice
import org apache hadoop hbase executor executortype
import org apache hadoop hbase filter bytearraycomparable
import org apache hadoop hbase filter comparefilter compareop
import org apache hadoop hbase fs hfilesystem
import org apache hadoop hbase io hfile cacheconfig
import org apache hadoop hbase ipc hbaserpcerrorhandler
import org apache hadoop hbase ipc payloadcarryingrpccontroller
import org apache hadoop hbase ipc rpcclient
import org apache hadoop hbase ipc rpcserver
import org apache hadoop hbase ipc servernotrunningyetexception
import org apache hadoop hbase ipc rpcserver blockingserviceandinterface
import org apache hadoop hbase ipc rpcserverinterface
import org apache hadoop hbase ipc serverrpccontroller
import org apache hadoop hbase master splitlogmanager
import org apache hadoop hbase master tablelockmanager
import org apache hadoop hbase protobuf protobufutil
import org apache hadoop hbase protobuf requestconverter
import org apache hadoop hbase protobuf responseconverter
import org apache hadoop hbase protobuf generated adminprotos
import org apache hadoop hbase protobuf generated adminprotos closeregionrequest
import org apache hadoop hbase protobuf generated adminprotos closeregionresponse
import org apache hadoop hbase protobuf generated adminprotos compactregionrequest
import org apache hadoop hbase protobuf generated adminprotos compactregionresponse
import org apache hadoop hbase protobuf generated adminprotos flushregionrequest
import org apache hadoop hbase protobuf generated adminprotos flushregionresponse
import org apache hadoop hbase protobuf generated adminprotos getonlineregionrequest
import org apache hadoop hbase protobuf generated adminprotos getonlineregionresponse
import org apache hadoop hbase protobuf generated adminprotos getregioninforequest
import org apache hadoop hbase protobuf generated adminprotos getregioninforesponse
import org apache hadoop hbase protobuf generated adminprotos getserverinforequest
import org apache hadoop hbase protobuf generated adminprotos getserverinforesponse
import org apache hadoop hbase protobuf generated adminprotos getstorefilerequest
import org apache hadoop hbase protobuf generated adminprotos getstorefileresponse
import org apache hadoop hbase protobuf generated adminprotos mergeregionsrequest
import org apache hadoop hbase protobuf generated adminprotos mergeregionsresponse
import org apache hadoop hbase protobuf generated adminprotos openregionrequest
import org apache hadoop hbase protobuf generated adminprotos openregionrequest regionopeninfo
import org apache hadoop hbase protobuf generated adminprotos openregionresponse
import org apache hadoop hbase protobuf generated adminprotos openregionresponse regionopeningstate
import org apache hadoop hbase protobuf generated adminprotos replicatewalentryrequest
import org apache hadoop hbase protobuf generated adminprotos replicatewalentryresponse
import org apache hadoop hbase protobuf generated adminprotos rollwalwriterrequest
import org apache hadoop hbase protobuf generated adminprotos rollwalwriterresponse
import org apache hadoop hbase protobuf generated adminprotos splitregionrequest
import org apache hadoop hbase protobuf generated adminprotos splitregionresponse
import org apache hadoop hbase protobuf generated adminprotos stopserverrequest
import org apache hadoop hbase protobuf generated adminprotos stopserverresponse
import org apache hadoop hbase protobuf generated clientprotos
import org apache hadoop hbase protobuf generated clientprotos actionresult
import org apache hadoop hbase protobuf generated clientprotos bulkloadhfilerequest
import org apache hadoop hbase protobuf generated clientprotos bulkloadhfilerequest familypath
import org apache hadoop hbase protobuf generated clientprotos bulkloadhfileresponse
import org apache hadoop hbase protobuf generated clientprotos condition
import org apache hadoop hbase protobuf generated clientprotos coprocessorservicerequest
import org apache hadoop hbase protobuf generated clientprotos coprocessorserviceresponse
import org apache hadoop hbase protobuf generated clientprotos getrequest
import org apache hadoop hbase protobuf generated clientprotos getresponse
import org apache hadoop hbase protobuf generated clientprotos multigetrequest
import org apache hadoop hbase protobuf generated clientprotos multigetresponse
import org apache hadoop hbase protobuf generated clientprotos multirequest
import org apache hadoop hbase protobuf generated clientprotos multiresponse
import org apache hadoop hbase protobuf generated clientprotos mutaterequest
import org apache hadoop hbase protobuf generated clientprotos mutateresponse
import org apache hadoop hbase protobuf generated clientprotos mutationproto
import org apache hadoop hbase protobuf generated clientprotos resultcellmeta
import org apache hadoop hbase protobuf generated clientprotos mutationproto mutationtype
import org apache hadoop hbase protobuf generated clientprotos scanrequest
import org apache hadoop hbase protobuf generated clientprotos scanresponse
import org apache hadoop hbase protobuf generated clusterstatusprotos
import org apache hadoop hbase protobuf generated clusterstatusprotos regionload
import org apache hadoop hbase protobuf generated hbaseprotos coprocessor
import org apache hadoop hbase protobuf generated hbaseprotos namestringpair
import org apache hadoop hbase protobuf generated hbaseprotos regionspecifier
import org apache hadoop hbase protobuf generated hbaseprotos regionspecifier regionspecifiertype
import org apache hadoop hbase protobuf generated regionserverstatusprotos getlastflushedsequenceidrequest
import org apache hadoop hbase protobuf generated regionserverstatusprotos regionserverreportrequest
import org apache hadoop hbase protobuf generated regionserverstatusprotos regionserverstartuprequest
import org apache hadoop hbase protobuf generated regionserverstatusprotos regionserverstartupresponse
import org apache hadoop hbase protobuf generated regionserverstatusprotos regionserverstatusservice
import org apache hadoop hbase protobuf generated regionserverstatusprotos reportrsfatalerrorrequest
import org apache hadoop hbase regionserver hregion operation
import org apache hadoop hbase regionserver leases leasestillheldexception
import org apache hadoop hbase regionserver compactions compactionprogress
import org apache hadoop hbase regionserver handler closemetahandler
import org apache hadoop hbase regionserver handler closeregionhandler
import org apache hadoop hbase regionserver handler openmetahandler
import org apache hadoop hbase regionserver handler openregionhandler
import org apache hadoop hbase regionserver snapshot regionserversnapshotmanager
import org apache hadoop hbase regionserver wal hlog
import org apache hadoop hbase regionserver wal hlogfactory
import org apache hadoop hbase regionserver wal hlogutil
import org apache hadoop hbase regionserver wal walactionslistener
import org apache hadoop hbase security user
import org apache hadoop hbase trace spanreceiverhost
import org apache hadoop hbase util bytes
import org apache hadoop hbase util compressiontest
import org apache hadoop hbase util environmentedgemanager
import org apache hadoop hbase util fstabledescriptors
import org apache hadoop hbase util fsutils
import org apache hadoop hbase util infoserver
import org apache hadoop hbase util pair
import org apache hadoop hbase util sleeper
import org apache hadoop hbase util strings
import org apache hadoop hbase util threads
import org apache hadoop hbase util versioninfo
import org apache hadoop hbase zookeeper clusterstatustracker
import org apache hadoop hbase zookeeper masteraddresstracker
import org apache hadoop hbase zookeeper metaregiontracker
import org apache hadoop hbase zookeeper recoveringregionwatcher
import org apache hadoop hbase zookeeper zkclusterid
import org apache hadoop hbase zookeeper zkutil
import org apache hadoop hbase zookeeper zookeepernodetracker
import org apache hadoop hbase zookeeper zookeeperwatcher
import org apache hadoop ipc remoteexception
import org apache hadoop metrics util mbeanutil
import org apache hadoop net dns
import org apache hadoop util reflectionutils
import org apache hadoop util stringutils
import org apache zookeeper keeperexception
import org apache zookeeper data stat
import org cliffc high_scale_lib counter
import com google protobuf blockingrpcchannel
import com google protobuf bytestring
import com google protobuf message
import com google protobuf rpccontroller
import com google protobuf serviceexception
import com google protobuf textformat
/**
* hregionserver makes a set of hregions available to clients. it checks in with
* the hmaster. there are many hregionservers in a single hbase deployment.
*/
@interfaceaudience private
@suppresswarnings
public class hregionserver implements clientprotos clientservice blockinginterface
adminprotos adminservice blockinginterface  runnable  regionserverservices
hbaserpcerrorhandler  lastsequenceid
public static final log log   logfactory getlog hregionserver class
private final random rand
/*
* strings to be used in forming the exception message for
* regionsalreadyintransitionexception.
*/
protected static final string open
protected static final string close
//regionname vs current action in progress
//true - if open region action in progress
//false - if close region action in progress
protected final concurrentmap<byte  boolean> regionsintransitioninrs
new concurrentskiplistmap<byte  boolean> bytes bytes_comparator
protected long maxscannerresultsize
// cache flushing
protected memstoreflusher cacheflusher
// catalog tracker
protected catalogtracker catalogtracker
// watch if a region is out of recovering state from zookeeper
@suppresswarnings
private recoveringregionwatcher recoveringregionwatcher
/**
* go here to get table descriptors.
*/
protected tabledescriptors tabledescriptors
// replication services. if no replication, this handler will be null.
protected replicationsourceservice replicationsourcehandler
protected replicationsinkservice replicationsinkhandler
// compactions
public compactsplitthread compactsplitthread
final concurrenthashmap<string  regionscannerholder> scanners
new concurrenthashmap<string  regionscannerholder>
/**
* map of regions currently being served by this region server. key is the
* encoded region name.  all access should be synchronized.
*/
protected final map<string  hregion> onlineregions
new concurrenthashmap<string  hregion>
/**
* map of encoded region names to the datanode locations they should be hosted on
* we store the value as inetsocketaddress since this is used only in hdfs
* api (create() that takes favored nodes as hints for placing file blocks).
* we could have used servername here as the value class, but we'd need to
* convert it to inetsocketaddress at some point before the hdfs api call, and
* it seems a bit weird to store servername since servername refers to regionservers
* and here we really mean datanode locations.
*/
protected final map<string  inetsocketaddress> regionfavorednodesmap
new concurrenthashmap<string  inetsocketaddress>
/**
* set of regions currently being in recovering state which means it can accept writes(edits from
* previous failed region server) but not reads. a recovering region is also an online region.
*/
protected final map<string  hregion> recoveringregions   collections
synchronizedmap new hashmap<string  hregion>
// leases
protected leases leases
// instance of the hbase executor service.
protected executorservice service
// request counter. (includes requests that are not serviced by regions.)
final counter requestcount   new counter
// if false, the file system has become unavailable
protected volatile boolean fsok
protected hfilesystem fs
// set when a report to the master comes back with a message asking us to
// shutdown. also set by call to stop when debugging or running unit tests
// of hregionserver in isolation.
protected volatile boolean stopped   false
// go down hard. used if file system becomes unavailable and also in
// debugging and unit tests.
protected volatile boolean abortrequested
// port we put up the webui on.
protected int webuiport    1
concurrentmap<string  integer> rowlocks   new concurrenthashmap<string  integer>
// a state before we go into stopped state.  at this stage we're closing user
// space regions.
private boolean stopping   false
private volatile boolean killed   false
protected final configuration conf
private boolean usehbasechecksum     verify hbase checksums?
private path rootdir
protected final reentrantreadwritelock lock   new reentrantreadwritelock
final int numretries
protected final int threadwakefrequency
private final int msginterval
protected final int numregionstoreport
// stub to do region server status calls against the master.
private regionserverstatusservice blockinginterface rssstub
// rpc client. used to make the stub above that does region server status checking.
rpcclient rpcclient
// server to handle client requests. default access so can be accessed by
// unit tests.
rpcserverinterface rpcserver
private final inetsocketaddress isa
private uncaughtexceptionhandler uncaughtexceptionhandler
// info server. default access so can be used by unit tests. regionserver
// is name of the webapp and the attribute name used stuffing this instance
// into web context.
infoserver infoserver
/** region server process name */
public static final string regionserver
/** region server configuration name */
public static final string regionserver_conf
private metricsregionserver metricsregionserver
private spanreceiverhost spanreceiverhost
/*
* check for compactions requests.
*/
chore compactionchecker
/*
* check for flushes
*/
chore periodicflusher
// hlog and hlog roller. log is protected rather than private to avoid
// eclipse warning when accessed by inner classes
protected volatile hlog hlog
// the meta updates are written to a different hlog. if this
// regionserver holds meta regions, then this field will be non-null.
protected volatile hlog hlogformeta
logroller hlogroller
logroller metahlogroller
// flag set after we're done setting up server threads (used for testing)
protected volatile boolean isonline
// zookeeper connection and watcher
private zookeeperwatcher zookeeper
// master address manager and watcher
private masteraddresstracker masteraddressmanager
// cluster status tracker
private clusterstatustracker clusterstatustracker
// log splitting worker
private splitlogworker splitlogworker
// a sleeper that sleeps for msginterval.
private final sleeper sleeper
private final int rpctimeout
private final regionserveraccounting regionserveraccounting
// cache configuration and block cache reference
final cacheconfig cacheconfig
// reference to the thrift server.
volatile private hregionthriftserver thriftserver
/** the health check chore. */
private healthcheckchore healthcheckchore
/**
* the server name the master sees us as.  its made from the hostname the
* master passes us, port, and server startcode. gets set after registration
* against  master.  the hostname can differ from the hostname in {@link #isa}
* but usually doesn't if both servers resolve .
*/
private servername servernamefrommasterpov
/**
* this servers startcode.
*/
private final long startcode
/**
* unique identifier for the cluster we are a part of.
*/
private string clusterid
/**
* mx bean for regionserverinfo
*/
private objectname mxbean   null
/**
* chore to clean periodically the moved region list
*/
private movedregionscleaner movedregionscleaner
/**
* the lease timeout period for client scanners (milliseconds).
*/
private final int scannerleasetimeoutperiod
/**
* the reference to the qosfunction
*/
private final qosfunction qosfunction
private regionservercoprocessorhost rshost
/** handle all the snapshot requests to this server */
regionserversnapshotmanager snapshotmanager
// configuration setting on if replay wal edits directly to another rs
private final boolean distributedlogreplay
// table level lock manager for locking for region operations
private tablelockmanager tablelockmanager
/**
* starts a hregionserver at the default location
*
* @param conf
* @throws ioexception
* @throws interruptedexception
*/
public hregionserver configuration conf
throws ioexception  interruptedexception
this fsok   true
this conf   conf
this isonline   false
checkcodecs this conf
// do we use checksum verification in the hbase? if hbase checksum verification
// is enabled, then we automatically switch off hdfs checksum verification.
this usehbasechecksum   conf getboolean hconstants hbase_checksum_verification  false
// check that the user has not set the "dfs.client.read.shortcircuit.skip.checksum" property.
boolean shortcircuitskipchecksum   conf getboolean
false
if  shortcircuitskipchecksum
log warn  dfs client read shortcircuit skip checksum
this usehbasechecksum ?
assert  shortcircuitskipchecksum    this will fail if assertions are on
// config'ed params
this numretries   this conf getint hconstants hbase_client_retries_number
hconstants default_hbase_client_retries_number
this threadwakefrequency   conf getint hconstants thread_wake_frequency  10   1000
this msginterval   conf getint    3   1000
this sleeper   new sleeper this msginterval  this
this maxscannerresultsize   conf getlong
hconstants hbase_client_scanner_max_result_size_key
hconstants default_hbase_client_scanner_max_result_size
this numregionstoreport   conf getint
10
this rpctimeout   conf getint
hconstants hbase_rpc_shortoperation_timeout_key
hconstants default_hbase_rpc_shortoperation_timeout
this abortrequested   false
this stopped   false
this scannerleasetimeoutperiod   hbaseconfiguration getint conf
hconstants hbase_client_scanner_timeout_period
hconstants hbase_regionserver_lease_period_key
hconstants default_hbase_client_scanner_timeout_period
// server to handle client requests.
string hostname   conf get
strings domainnamepointertohostname dns getdefaulthost
conf get
conf get
int port   conf getint hconstants regionserver_port
hconstants default_regionserver_port
// creation of a hsa will force a resolve.
inetsocketaddress initialisa   new inetsocketaddress hostname  port
if  initialisa getaddress      null
throw new illegalargumentexception     initialisa
this rand   new random initialisa hashcode
string name       initialisa tostring
// set how many times to retry talking to another server over hconnection.
hconnectionmanager setserversidehconnectionretries this conf  name  log
this rpcserver   new rpcserver this  name  getservices
/*hbaserpcerrorhandler.class, onlineregions.class},*/
initialisa     bindaddress is ip we got for this server
conf getint    10
conf getint    10
conf  hconstants qos_threshold
// set our address.
this isa   this rpcserver getlisteneraddress
this rpcserver seterrorhandler this
this rpcserver setqosfunction  qosfunction   new qosfunction this
this startcode   system currenttimemillis
// login the zookeeper client principal (if using security)
zkutil loginclient this conf
this isa gethostname
// login the server principal (if using secure hadoop)
user login this conf
this isa gethostname
regionserveraccounting   new regionserveraccounting
cacheconfig   new cacheconfig conf
uncaughtexceptionhandler   new uncaughtexceptionhandler
@override
public void uncaughtexception thread t  throwable e
abort     t getname    e
this rshost   new regionservercoprocessorhost this  this conf
this distributedlogreplay   this conf getboolean hconstants distributed_log_replay_key
hconstants default_distributed_log_replay_config
/**
* @return list of blocking services and their security info classes that this server supports
*/
private list<blockingserviceandinterface> getservices
list<blockingserviceandinterface> bssi   new arraylist<blockingserviceandinterface> 2
bssi add new blockingserviceandinterface
clientprotos clientservice newreflectiveblockingservice this
clientprotos clientservice blockinginterface class
bssi add new blockingserviceandinterface
adminprotos adminservice newreflectiveblockingservice this
adminprotos adminservice blockinginterface class
return bssi
/**
* run test on configured codecs to make sure supporting libs are in place.
* @param c
* @throws ioexception
*/
private static void checkcodecs final configuration c  throws ioexception
// check to see if the codec list is available:
string  codecs   c getstrings     string null
if  codecs    null  return
for  string codec   codecs
if   compressiontest testcompression codec
throw new ioexception     codec
string getclusterid
return this clusterid
@retention retentionpolicy runtime
protected @interface qospriority
int priority   default 0
qosfunction getqosfunction
return qosfunction
regionscanner getscanner long scannerid
string scanneridstring   long tostring scannerid
regionscannerholder scannerholder   scanners get scanneridstring
if  scannerholder    null
return scannerholder s
return null
/**
* all initialization needed before we go register with master.
*
* @throws ioexception
* @throws interruptedexception
*/
private void preregistrationinitialization
try
initializezookeeper
initializethreads
catch  throwable t
// call stop if error or process will stick around for ever since server
// puts up non-daemon threads.
this rpcserver stop
abort    t
/**
* bring up connection to zk ensemble and then wait until a master for this
* cluster and then after that, wait until cluster 'up' flag has been set.
* this is the order in which master does things.
* finally put up a catalog tracker.
* @throws ioexception
* @throws interruptedexception
*/
private void initializezookeeper   throws ioexception  interruptedexception
// open connection to zookeeper and set primary watcher
this zookeeper   new zookeeperwatcher conf  regionserver
this isa getport    this
// create the master address manager, register with zk, and start it.  then
// block until a master is available.  no point in starting up if no master
// running.
this masteraddressmanager   new masteraddresstracker this zookeeper  this
this masteraddressmanager start
blockandcheckifstopped this masteraddressmanager
// wait on cluster being up.  master will set this flag up in zookeeper
// when ready.
this clusterstatustracker   new clusterstatustracker this zookeeper  this
this clusterstatustracker start
blockandcheckifstopped this clusterstatustracker
// create the catalog tracker and start it;
this catalogtracker   new catalogtracker this zookeeper  this conf  this
catalogtracker start
// retrieve clusterid
// since cluster status is now up
// id should have already been set by hmaster
try
clusterid   zkclusterid readclusteridznode this zookeeper
if  clusterid    null
this abort
log info   clusterid
catch  keeperexception e
this abort   e
// watch for snapshots
try
this snapshotmanager   new regionserversnapshotmanager this
catch  keeperexception e
this abort
this tablelockmanager   tablelockmanager createtablelockmanager conf  zookeeper
new servername isa gethostname    isa getport    startcode
// register watcher for recovering regions
if this distributedlogreplay
this recoveringregionwatcher   new recoveringregionwatcher this zookeeper  this
/**
* utilty method to wait indefinitely on a znode availability while checking
* if the region server is shut down
* @param tracker znode tracker to use
* @throws ioexception any io exception, plus if the rs is stopped
* @throws interruptedexception
*/
private void blockandcheckifstopped zookeepernodetracker tracker
throws ioexception  interruptedexception
while  tracker blockuntilavailable this msginterval  false     null
if  this stopped
throw new ioexception
/**
* @return false if cluster shutdown in progress
*/
private boolean isclusterup
return this clusterstatustracker isclusterup
private void initializethreads   throws ioexception
// cache flushing thread.
this cacheflusher   new memstoreflusher conf  this
// compaction thread
this compactsplitthread   new compactsplitthread this
// background thread to check for compactions; needed if region has not gotten updates
// in a while. it will take care of not checking too frequently on store-by-store basis.
this compactionchecker   new compactionchecker this  this threadwakefrequency  this
this periodicflusher   new periodicmemstoreflusher this threadwakefrequency  this
// health checker thread.
int sleeptime   this conf getint hconstants health_chore_wake_freq
hconstants default_thread_wake_frequency
if  ishealthcheckerconfigured
healthcheckchore   new healthcheckchore sleeptime  this  getconfiguration
this leases   new leases this threadwakefrequency
// create the thread for the thriftserver.
if  conf getboolean    false
thriftserver   new hregionthriftserver this  conf
thriftserver start
log info
// create the thread to clean the moved regions list
movedregionscleaner   movedregionscleaner createandstart this
// setup rpc client for master communication
rpcclient   new rpcclient conf  clusterid  new inetsocketaddress
this isa getaddress    0
/**
* the hregionserver sticks in this loop until closed.
*/
@override
public void run
try
// do pre-registration initializations; zookeeper, lease threads, etc.
preregistrationinitialization
catch  throwable e
abort    e
try
// try and register with the master; tell it we are here.  break if
// server is stopped or the clusterup flag is down or hdfs went wacky.
while  keeplooping
regionserverstartupresponse w   reportforduty
if  w    null
log warn
this sleeper sleep
else
handlereportfordutyresponse w
break
if   this stopped    ishealthy
// start the snapshot handler, since the server is ready to run
this snapshotmanager start
// we registered with the master.  go into run mode.
long lastmsg   0
long oldrequestcount    1
// the main run loop.
while   this stopped    ishealthy
if   isclusterup
if  isonlineregionsempty
stop
else if   this stopping
this stopping   true
log info
closeuserregions this abortrequested
else if  this stopping
boolean alluserregionsoffline   arealluserregionsoffline
if  alluserregionsoffline
// set stopped if no requests since last time we went around the loop.
// the remaining meta regions will be closed on our way out.
if  oldrequestcount    this requestcount get
stop
break
oldrequestcount   this requestcount get
else
// make sure all regions have been closed -- some regions may
// have not got it because we were splitting at the time of
// the call to closeuserregions.
closeuserregions this abortrequested
log debug     getonlineregionsasprintablestring
long now   system currenttimemillis
if   now   lastmsg  >  msginterval
tryregionserverreport lastmsg  now
lastmsg   system currenttimemillis
if   this stopped  this sleeper sleep
for
catch  throwable t
if   checkoome t
string prefix   t instanceof youaredeadexception?
abort prefix   t getmessage    t
// run shutdown.
if  mxbean    null
mbeanutil unregistermbean mxbean
mxbean   null
if  this thriftserver    null  this thriftserver shutdown
this leases closeafterleasesexpire
this rpcserver stop
if  this splitlogworker    null
splitlogworker stop
if  this infoserver    null
log info
try
this infoserver stop
catch  exception e
e printstacktrace
// send cache a shutdown.
if  cacheconfig isblockcacheenabled
cacheconfig getblockcache   shutdown
movedregionscleaner stop
// send interrupts to wake up threads if sleeping so they notice shutdown.
// todo: should we check they are alive? if oome could have exited already
if  this cacheflusher    null  this cacheflusher interruptifnecessary
if  this compactsplitthread    null  this compactsplitthread interruptifnecessary
if  this hlogroller    null  this hlogroller interruptifnecessary
if  this metahlogroller    null  this metahlogroller interruptifnecessary
if  this compactionchecker    null
this compactionchecker interrupt
if  this healthcheckchore    null
this healthcheckchore interrupt
// stop the snapshot handler, forcefully killing all running tasks
try
if  snapshotmanager    null  snapshotmanager stop this abortrequested    this killed
catch  ioexception e
log warn    e
if  this killed
// just skip out w/o closing regions.  used when testing.
else if  abortrequested
if  this fsok
closeuserregions abortrequested      don't leave any open file handles
log info     this servernamefrommasterpov
else
closeuserregions abortrequested
closeallscanners
log info     this servernamefrommasterpov
// interrupt catalog tracker here in case any regions being opened out in
// handlers are stuck waiting on meta.
if  this catalogtracker    null  this catalogtracker stop
// closing the compactsplit thread before closing meta regions
if   this killed    containsmetatableregions
if   abortrequested    this fsok
if  this compactsplitthread    null
this compactsplitthread join
this compactsplitthread   null
closemetatableregions abortrequested
if   this killed    this fsok
waitonallregionstoclose abortrequested
log info     this servernamefrommasterpov
//fsok flag may be changed when closing regions throws exception.
if  this fsok
closewal  abortrequested
// make sure the proxy is down.
if  this rssstub    null
this rssstub   null
this rpcclient stop
this leases close
if   killed
join
try
deletemyephemeralnode
catch  keeperexception e
log warn    e
// we may have failed to delete the znode at the previous step, but
//  we delete the file anyway: a second attempt to delete the znode is likely to fail again.
znodeclearer deletemyephemeralnodeondisk
this zookeeper close
log info     this servernamefrommasterpov
log info thread currentthread   getname
private boolean containsmetatableregions
return onlineregions containskey hregioninfo first_meta_regioninfo getencodedname
private boolean arealluserregionsoffline
if  getnumberofonlineregions   > 2  return false
boolean alluserregionsoffline   true
for  map entry<string  hregion> e  this onlineregions entryset
if   e getvalue   getregioninfo   ismetatable
alluserregionsoffline   false
break
return alluserregionsoffline
void tryregionserverreport long reportstarttime  long reportendtime
throws ioexception
if  this rssstub    null
// the current server is stopping.
return
clusterstatusprotos serverload sl   buildserverload reportstarttime  reportendtime
try
regionserverreportrequest builder request   regionserverreportrequest newbuilder
servername sn   servername parseversionedservername
this servernamefrommasterpov getversionedbytes
request setserver protobufutil toservername sn
request setload sl
this rssstub regionserverreport null  request build
catch  serviceexception se
ioexception ioe   protobufutil getremoteexception se
if  ioe instanceof youaredeadexception
// this will be caught and handled as a fatal error in run()
throw ioe
// couldn't connect to the master, get location from zk and reconnect
// method blocks until new master is found or we are stopped
pair<servername  regionserverstatusservice blockinginterface> p
createregionserverstatusstub
this rssstub   p getsecond
clusterstatusprotos serverload buildserverload long reportstarttime  long reportendtime
// we're getting the metricsregionserverwrapper here because the wrapper computes requests
// per second, and other metrics  as long as metrics are part of serverload it's best to use
// the wrapper to compute those numbers in one place.
// in the long term most of these should be moved off of serverload and the heart beat.
// instead they should be stored in an hbase table so that external visibility into hbase is
// improved; additionally the load balancer will be able to take advantage of a more complete
// history.
metricsregionserverwrapper regionserverwrapper   this metricsregionserver getregionserverwrapper
collection<hregion> regions   getonlineregionslocalcontext
memoryusage memory
managementfactory getmemorymxbean   getheapmemoryusage
clusterstatusprotos serverload builder serverload
clusterstatusprotos serverload newbuilder
serverload setnumberofrequests  int  regionserverwrapper getrequestspersecond
serverload settotalnumberofrequests  int  regionserverwrapper gettotalrequestcount
serverload setusedheapmb  int  memory getused     1024   1024
serverload setmaxheapmb  int   memory getmax     1024   1024
set<string> coprocessors   this hlog getcoprocessorhost   getcoprocessors
for  string coprocessor   coprocessors
serverload addcoprocessors
coprocessor newbuilder   setname coprocessor  build
for  hregion region   regions
serverload addregionloads createregionload region
serverload setreportstarttime reportstarttime
serverload setreportendtime reportendtime
if  this infoserver    null
serverload setinfoserverport this infoserver getport
else
serverload setinfoserverport  1
return serverload build
string getonlineregionsasprintablestring
stringbuilder sb   new stringbuilder
for  hregion r  this onlineregions values
if  sb length   > 0  sb append
sb append r getregioninfo   getencodedname
return sb tostring
/**
* wait on regions close.
*/
private void waitonallregionstoclose final boolean abort
// wait till all regions are closed before going out.
int lastcount    1
long previouslogtime   0
set<string> closedregions   new hashset<string>
while   isonlineregionsempty
int count   getnumberofonlineregions
// only print a message if the count of regions has changed.
if  count    lastcount
// log every second at most
if  system currenttimemillis   >  previouslogtime   1000
previouslogtime   system currenttimemillis
lastcount   count
log info     count
// only print out regions still closing if a small number else will
// swamp the log.
if  count < 10    log isdebugenabled
log debug this onlineregions
// ensure all user regions have been sent a close. use this to
// protect against the case where an open comes in after we start the
// iterator of onlineregions to close all user regions.
for  map entry<string  hregion> e   this onlineregions entryset
hregioninfo hri   e getvalue   getregioninfo
if   this regionsintransitioninrs containskey hri getencodednameasbytes
closedregions contains hri getencodedname
closedregions add hri getencodedname
// don't update zk with this close transition; pass false.
closeregionignoreerrors hri  abort
// no regions in rit, we could stop waiting now.
if  this regionsintransitioninrs isempty
if   isonlineregionsempty
log info
break
threads sleep 200
private void closewal final boolean delete
if  this hlogformeta    null
// all hlogs (meta and non-meta) are in the same directory. don't call
// closeanddelete here since that would delete all hlogs not just the
// meta ones. we will just 'close' the hlog for meta here, and leave
// the directory cleanup to the follow-on closeanddelete call.
try
this hlogformeta close
catch  throwable e
log error    remoteexceptionhandler checkthrowable e
if  this hlog    null
try
if  delete
hlog closeanddelete
else
hlog close
catch  throwable e
log error    remoteexceptionhandler checkthrowable e
private void closeallscanners
// close any outstanding scanners. means they'll get an unknownscanner
// exception next time they come in.
for  map entry<string  regionscannerholder> e   this scanners entryset
try
e getvalue   s close
catch  ioexception ioe
log warn     e getkey    ioe
/*
* run init. sets up hlog and starts up all server threads.
*
* @param c extra configuration.
*/
protected void handlereportfordutyresponse final regionserverstartupresponse c
throws ioexception
try
for  namestringpair e   c getmapentrieslist
string key   e getname
// the hostname the master sees us as.
if  key equals hconstants key_for_hostname_seen_by_master
string hostnamefrommasterpov   e getvalue
this servernamefrommasterpov   new servername hostnamefrommasterpov
this isa getport    this startcode
if   hostnamefrommasterpov equals this isa gethostname
log info
this isa gethostname         hostnamefrommasterpov
continue
string value   e getvalue
if  log isdebugenabled
log debug     key       value
this conf set key  value
// hack! maps dfsclient => regionserver for logs.  hdfs made this
// config param for task trackers, but we can piggyback off of it.
if  this conf get       null
this conf set
this servernamefrommasterpov tostring
// set our ephemeral znode up in zookeeper now we have a name.
createmyephemeralnode
// save it in a file, this will allow to see if we crash
znodeclearer writemyephemeralnodeondisk getmyephemeralnodepath
// master sent us hbase.rootdir to use. should be fully qualified
// path with file system specification included. set 'fs.defaultfs'
// to match the filesystem on hbase.rootdir else underlying hadoop hdfs
// accessors will be going against wrong filesystem (unless all is set
// to defaults).
fsutils setfsdefault this conf  fsutils getrootdir this conf
// get fs instance used by this rs
this fs   new hfilesystem this conf  this usehbasechecksum
this rootdir   fsutils getrootdir this conf
this tabledescriptors   new fstabledescriptors this fs  this rootdir  true
this hlog   setupwalandreplication
// init in here rather than in constructor after thread name has been set
this metricsregionserver   new metricsregionserver new metricsregionserverwrapperimpl this
spanreceiverhost   spanreceiverhost getinstance getconfiguration
startservicethreads
log info     this servernamefrommasterpov
this isa
long tohexstring this zookeeper getrecoverablezookeeper   getsessionid
isonline   true
catch  throwable e
this isonline   false
stop
throw convertthrowabletoioe cleanup e
finally
sleeper skipsleepcycle
private void createmyephemeralnode   throws keeperexception
zkutil createephemeralnodeandwatch this zookeeper  getmyephemeralnodepath
hconstants empty_byte_array
private void deletemyephemeralnode   throws keeperexception
zkutil deletenode this zookeeper  getmyephemeralnodepath
@override
public regionserveraccounting getregionserveraccounting
return regionserveraccounting
@override
public tablelockmanager gettablelockmanager
return tablelockmanager
/*
* @param r region to get regionload for.
*
* @return regionload instance.
*
* @throws ioexception
*/
private regionload createregionload final hregion r
byte name   r getregionname
int stores   0
int storefiles   0
int storeuncompressedsizemb   0
int storefilesizemb   0
int memstoresizemb    int   r memstoresize get     1024   1024
int storefileindexsizemb   0
int rootindexsizekb   0
int totalstaticindexsizekb   0
int totalstaticbloomsizekb   0
long totalcompactingkvs   0
long currentcompactedkvs   0
synchronized  r stores
stores    r stores size
for  store store   r stores values
storefiles    store getstorefilescount
storeuncompressedsizemb     int   store getstoresizeuncompressed
1024   1024
storefilesizemb     int   store getstorefilessize     1024   1024
storefileindexsizemb     int   store getstorefilesindexsize     1024   1024
compactionprogress progress   store getcompactionprogress
if  progress    null
totalcompactingkvs    progress totalcompactingkvs
currentcompactedkvs    progress currentcompactedkvs
rootindexsizekb
int   store getstorefilesindexsize     1024
totalstaticindexsizekb
int   store gettotalstaticindexsize     1024
totalstaticbloomsizekb
int   store gettotalstaticbloomsize     1024
regionload builder regionload   regionload newbuilder
regionspecifier builder regionspecifier   regionspecifier newbuilder
regionspecifier settype regionspecifiertype region_name
regionspecifier setvalue bytestring copyfrom name
regionload setregionspecifier regionspecifier build
setstores stores
setstorefiles storefiles
setstoreuncompressedsizemb storeuncompressedsizemb
setstorefilesizemb storefilesizemb
setmemstoresizemb memstoresizemb
setstorefileindexsizemb storefileindexsizemb
setrootindexsizekb rootindexsizekb
settotalstaticindexsizekb totalstaticindexsizekb
settotalstaticbloomsizekb totalstaticbloomsizekb
setreadrequestscount  int  r readrequestscount get
setwriterequestscount  int  r writerequestscount get
settotalcompactingkvs totalcompactingkvs
setcurrentcompactedkvs currentcompactedkvs
setcompletesequenceid r completesequenceid
return regionload build
/**
* @param encodedregionname
* @return an instance of regionload.
*/
public regionload createregionload final string encodedregionname
hregion r   null
r   this onlineregions get encodedregionname
return r    null ? createregionload r    null
/*
* inner class that runs on a long period checking if regions need compaction.
*/
private static class compactionchecker extends chore
private final hregionserver instance
private final int majorcompactpriority
private final static int default_priority   integer max_value
private long iteration   0
compactionchecker final hregionserver h  final int sleeptime
final stoppable stopper
super    sleeptime  h
this instance   h
log info this getname         stringutils formattime sleeptime
/* majorcompactpriority is configurable.
* if not set, the compaction will use default priority.
*/
this majorcompactpriority   this instance conf
getint
default_priority
@override
protected void chore
for  hregion r   this instance onlineregions values
if  r    null
continue
for  store s   r getstores   values
try
long multiplier   s getcompactioncheckmultiplier
assert multiplier > 0
if  iteration % multiplier    0  continue
if  s needscompaction
// queue a compaction. will recognize if major is needed.
this instance compactsplitthread requestsystemcompaction r  s  getname
else if  s ismajorcompaction
if  majorcompactpriority    default_priority
majorcompactpriority > r getcompactpriority
this instance compactsplitthread requestcompaction r  s  getname

else
this instance compactsplitthread requestcompaction r  s  getname
this majorcompactpriority  null
catch  ioexception e
log warn     r  e
iteration    iteration    long max_value  ? 0    iteration   1
class periodicmemstoreflusher extends chore
final hregionserver server
final static int range_of_delay   20000    millisec
final static int min_delay_time   3000    millisec
public periodicmemstoreflusher int cacheflushinterval  final hregionserver server
super server getservername        cacheflushinterval  server
this server   server
@override
protected void chore
for  hregion r   this server onlineregions values
if  r    null
continue
if  r shouldflush
flushrequester requester   server getflushrequester
if  requester    null
long randomdelay   rand nextint range_of_delay    min_delay_time
log info getname         r getregionnameasstring
randomdelay
//throttle the flushes by putting a delay. if we don't throttle, and there
//is a balanced write-load on the regions in a table, we might end up
//overwhelming the filesystem with too many flushes at once.
requester requestdelayedflush r  randomdelay
/**
* report the status of the server. a server is online once all the startup is
* completed (setting up filesystem, starting service threads, etc.). this
* method is designed mostly to be useful in tests.
*
* @return true if online, false if not.
*/
public boolean isonline
return isonline
/**
* setup wal log and replication if enabled.
* replication setup is done in here because it wants to be hooked up to wal.
* @return a wal instance.
* @throws ioexception
*/
private hlog setupwalandreplication   throws ioexception
final path oldlogdir   new path rootdir  hconstants hregion_oldlogdir_name
final string logname
hlogutil gethlogdirectoryname this servernamefrommasterpov tostring
path logdir   new path rootdir  logname
if  log isdebugenabled    log debug     logdir
if  this fs exists logdir
throw new regionserverrunningexception
this servernamefrommasterpov tostring
// instantiate replication manager if replication enabled.  pass it the
// log directories.
createnewreplicationinstance conf  this  this fs  logdir  oldlogdir
return instantiatehlog rootdir  logname
private hlog getmetawal   throws ioexception
if  this hlogformeta    null  return this hlogformeta
final string logname   hlogutil gethlogdirectoryname this servernamefrommasterpov tostring
path logdir   new path rootdir  logname
if  log isdebugenabled    log debug     logdir
this hlogformeta   hlogfactory createmetahlog this fs getbackingfs    rootdir  logname
this conf  getmetawalactionlisteners    this servernamefrommasterpov tostring
return this hlogformeta
/**
* called by {@link #setupwalandreplication()} creating wal instance.
* @param rootdir
* @param logname
* @return wal instance.
* @throws ioexception
*/
protected hlog instantiatehlog path rootdir  string logname  throws ioexception
return hlogfactory createhlog this fs getbackingfs    rootdir  logname  this conf
getwalactionlisteners    this servernamefrommasterpov tostring
/**
* called by {@link #instantiatehlog(path, string)} setting up wal instance.
* add any {@link walactionslistener}s you want inserted before wal startup.
* @return list of walactionslistener that will be passed in to
* {@link org.apache.hadoop.hbase.regionserver.wal.fshlog} on construction.
*/
protected list<walactionslistener> getwalactionlisteners
list<walactionslistener> listeners   new arraylist<walactionslistener>
// log roller.
this hlogroller   new logroller this  this
listeners add this hlogroller
if  this replicationsourcehandler    null
this replicationsourcehandler getwalactionslistener      null
// replication handler is an implementation of walactionslistener.
listeners add this replicationsourcehandler getwalactionslistener
return listeners
protected list<walactionslistener> getmetawalactionlisteners
list<walactionslistener> listeners   new arraylist<walactionslistener>
// using a tmp log roller to ensure metalogroller is alive once it is not
// null
metalogroller tmplogroller   new metalogroller this  this
string n   thread currentthread   getname
threads setdaemonthreadrunning tmplogroller getthread
n      uncaughtexceptionhandler
this metahlogroller   tmplogroller
tmplogroller   null
listeners add this metahlogroller
return listeners
protected logroller getlogroller
return hlogroller
public metricsregionserver getmetrics
return this metricsregionserver
/**
* @return master address tracker instance.
*/
public masteraddresstracker getmasteraddressmanager
return this masteraddressmanager
/*
* start maintenance threads, server, worker and lease checker threads.
* install an uncaughtexceptionhandler that calls abort of regionserver if we
* get an unhandled exception. we cannot set the handler on all threads.
* server's internal listener thread is off limits. for server, if an oome, it
* waits a while then retries. meantime, a flush or a compaction that tries to
* run should trigger same critical condition and the shutdown will run. on
* its way out, this server will shut down server. leases are sort of
* inbetween. it has an internal thread that while it inherits from chore, it
* keeps its own internal stop mechanism so needs to be stopped by this
* hosting server. worker logs the exception and exits.
*/
private void startservicethreads   throws ioexception
string n   thread currentthread   getname
// start executor services
this service   new executorservice getservername   toshortstring
this service startexecutorservice executortype rs_open_region
conf getint    3
this service startexecutorservice executortype rs_open_meta
conf getint    1
this service startexecutorservice executortype rs_close_region
conf getint    3
this service startexecutorservice executortype rs_close_meta
conf getint    1
if  conf getboolean storescanner storescanner_parallel_seek_enable  false
this service startexecutorservice executortype rs_parallel_seek
conf getint    10
threads setdaemonthreadrunning this hlogroller getthread    n
uncaughtexceptionhandler
this cacheflusher start uncaughtexceptionhandler
threads setdaemonthreadrunning this compactionchecker getthread    n
uncaughtexceptionhandler
threads setdaemonthreadrunning this periodicflusher getthread    n
uncaughtexceptionhandler
if  this healthcheckchore    null
threads
setdaemonthreadrunning this healthcheckchore getthread    n
uncaughtexceptionhandler
// leases is not a thread. internally it runs a daemon thread. if it gets
// an unhandled exception, it will just exit.
this leases setname n
this leases start
// put up the webui.  webui may come up on port other than configured if
// that port is occupied. adjust serverinfo if this is the case.
this webuiport   putupwebui
if  this replicationsourcehandler    this replicationsinkhandler
this replicationsourcehandler    null
this replicationsourcehandler startreplicationservice
else if  this replicationsourcehandler    null
this replicationsourcehandler startreplicationservice
else if  this replicationsinkhandler    null
this replicationsinkhandler startreplicationservice
// start server.  this service is like leases in that it internally runs
// a thread.
this rpcserver start
// create the log splitting worker and start it
// set a smaller retries to fast fail otherwise splitlogworker could be blocked for
// quite a while inside hconnection layer. the worker won't be available for other
// tasks even after current task is preempted after a split task times out.
configuration sinkconf   hbaseconfiguration create conf
sinkconf setint hconstants hbase_client_retries_number
conf getint    8       8 retries take about 23 seconds
sinkconf setint hconstants hbase_rpc_timeout_key
conf getint    30000       default 30 seconds
sinkconf setint    1
this splitlogworker   new splitlogworker this zookeeper  sinkconf  this  this
splitlogworker start
/**
* puts up the webui.
* @return returns final port -- maybe different from what we started with.
* @throws ioexception
*/
private int putupwebui   throws ioexception
int port   this conf getint hconstants regionserver_info_port  60030
// -1 is for disabling info server
if  port < 0  return port
string addr   this conf get
// check if auto port bind enabled
boolean auto   this conf getboolean hconstants regionserver_info_port_auto
false
while  true
try
this infoserver   new infoserver    addr  port  false  this conf
this infoserver addservlet       rsstatusservlet class
this infoserver addservlet       rsdumpservlet class
this infoserver setattribute regionserver  this
this infoserver setattribute regionserver_conf  conf
this infoserver start
break
catch  bindexception e
if   auto
// auto bind disabled throw bindexception
log error     port
throw e
// auto bind enabled, try to use another port
log info     port
port
return port
/*
* verify that server is healthy
*/
private boolean ishealthy
if   fsok
// file system problem
return false
// verify that all threads are alive
if    leases isalive
cacheflusher isalive      hlogroller isalive
this compactionchecker isalive
this periodicflusher isalive
stop
return false
if  metahlogroller    null     metahlogroller isalive
stop
return false
return true
public hlog getwal
try
return getwal null
catch  ioexception e
log warn     e
return null
@override
public hlog getwal hregioninfo regioninfo  throws ioexception
//todo: at some point this should delegate to the hlogfactory
//currently, we don't care about the region as much as we care about the
//table.. (hence checking the tablename below)
//_root_ and .meta. regions have separate wal.
if  regioninfo    null    regioninfo ismetatable
return getmetawal
return this hlog
@override
public catalogtracker getcatalogtracker
return this catalogtracker
@override
public void stop final string msg
try
this rshost prestop msg
this stopped   true
log info     msg
// wakes run() if it is sleeping
sleeper skipsleepcycle
catch  ioexception exp
log warn    exp
public void waitforserveronline
while   isonline       isstopped
sleeper sleep
@override
public void postopendeploytasks final hregion r  final catalogtracker ct
throws keeperexception  ioexception
checkopen
log info     r getregionnameasstring
// do checks to see if we need to compact (references or too many files)
for  store s   r getstores   values
if  s hasreferences      s needscompaction
this compactsplitthread requestsystemcompaction r  s
long openseqnum   r getopenseqnum
if  openseqnum    hconstants no_seqnum
// if we opened a region, we should have read some sequence number from it.
log error     r getregionnameasstring
openseqnum   0
// update flushed sequence id of a recovering region in zk
updaterecoveringregionlastflushedsequenceid r
// update zk, or meta
if  r getregioninfo   ismetaregion
metaregiontracker setmetalocation getzookeeper
this servernamefrommasterpov
else
metaeditor updateregionlocation ct  r getregioninfo
this servernamefrommasterpov  openseqnum
log info
r getregionnameasstring
@override
public rpcserverinterface getrpcserver
return rpcserver
/**
* cause the server to exit without closing the regions it is serving, the log
* it is using and without notifying the master. used unit testing and on
* catastrophic events such as hdfs is yanked out from under hbase or we oome.
*
* @param reason
*          the reason we are aborting
* @param cause
*          the exception that caused the abort, or null
*/
@override
public void abort string reason  throwable cause
string msg       this       reason
if  cause    null
log fatal msg  cause
else
log fatal msg
this abortrequested   true
// hbase-4014: show list of coprocessors that were loaded to help debug
// regionserver crashes.note that we're implicitly using
// java.util.hashset's tostring() method to print the coprocessor names.
log fatal
coprocessorhost getloadedcoprocessors
// do our best to report our abort to the master, but this may not work
try
if  cause    null
msg        stringutils stringifyexception cause
// report to the master but only if we have already registered with the master.
if  rssstub    null    this servernamefrommasterpov    null
reportrsfatalerrorrequest builder builder
reportrsfatalerrorrequest newbuilder
servername sn
servername parseversionedservername this servernamefrommasterpov getversionedbytes
builder setserver protobufutil toservername sn
builder seterrormessage msg
rssstub reportrsfatalerror null  builder build
catch  throwable t
log warn    t
stop reason
/**
* @see hregionserver#abort(string, throwable)
*/
public void abort string reason
abort reason  null
@override
public boolean isaborted
return this abortrequested
/*
* simulate a kill -9 of this server. exits w/o closing regions or cleaninup
* logs but it does close socket in case want to bring up server on old
* hostname+port immediately.
*/
protected void kill
this killed   true
abort
/**
* wait on all threads to finish. presumption is that all closes and stops
* have already been called.
*/
protected void join
threads shutdown this compactionchecker getthread
threads shutdown this periodicflusher getthread
this cacheflusher join
if  this healthcheckchore    null
threads shutdown this healthcheckchore getthread
if  this spanreceiverhost    null
this spanreceiverhost closereceivers
if  this hlogroller    null
threads shutdown this hlogroller getthread
if  this metahlogroller    null
threads shutdown this metahlogroller getthread
if  this compactsplitthread    null
this compactsplitthread join
if  this service    null  this service shutdown
if  this replicationsourcehandler    null
this replicationsourcehandler    this replicationsinkhandler
this replicationsourcehandler stopreplicationservice
else if  this replicationsourcehandler    null
this replicationsourcehandler stopreplicationservice
else if  this replicationsinkhandler    null
this replicationsinkhandler stopreplicationservice
/**
* @return return the object that implements the replication
* source service.
*/
replicationsourceservice getreplicationsourceservice
return replicationsourcehandler
/**
* @return return the object that implements the replication
* sink service.
*/
replicationsinkservice getreplicationsinkservice
return replicationsinkhandler
/**
* get the current master from zookeeper and open the rpc connection to it.
*
* method will block until a master is available. you can break from this
* block by requesting the server stop.
*
* @return master + port, or null if server has been stopped
*/
private pair<servername  regionserverstatusservice blockinginterface>
createregionserverstatusstub
servername sn   null
long previouslogtime   0
regionserverstatusservice blockinginterface master   null
boolean refresh   false     for the first time  use cached data
regionserverstatusservice blockinginterface intf   null
while  keeplooping      master    null
sn   this masteraddressmanager getmasteraddress refresh
if  sn    null
if   keeplooping
// give up with no connection.
log debug
return null
log debug
previouslogtime   system currenttimemillis
refresh   true     let's try pull it from zk directly
sleeper sleep
continue
new inetsocketaddress sn gethostname    sn getport
try
blockingrpcchannel channel   this rpcclient createblockingrpcchannel sn
user getcurrent    this rpctimeout
intf   regionserverstatusservice newblockingstub channel
break
catch  ioexception e
e   e instanceof remoteexception ?
remoteexception e  unwrapremoteexception     e
if  e instanceof servernotrunningyetexception
if  system currenttimemillis   >  previouslogtime 1000
log info
previouslogtime   system currenttimemillis
else
if  system currenttimemillis   >  previouslogtime   1000
log warn    e
previouslogtime   system currenttimemillis
try
thread sleep 200
catch  interruptedexception ignored
return new pair<servername  regionserverstatusservice blockinginterface> sn  intf
/**
* @return true if we should break loop because cluster is going down or
* this server has been stopped or hdfs has gone bad.
*/
private boolean keeplooping
return  this stopped    isclusterup
/*
* let the master know we're here run initialization using parameters passed
* us by the master.
* @return a map of key/value configurations we got from the master else
* null if we failed to register.
* @throws ioexception
*/
private regionserverstartupresponse reportforduty   throws ioexception
regionserverstartupresponse result   null
pair<servername  regionserverstatusservice blockinginterface> p
createregionserverstatusstub
this rssstub   p getsecond
servername masterservername   p getfirst
if  masterservername    null  return result
try
this requestcount set 0
log info     masterservername       this isa getport
this startcode
long now   environmentedgemanager currenttimemillis
int port   this isa getport
regionserverstartuprequest builder request   regionserverstartuprequest newbuilder
request setport port
request setserverstartcode this startcode
request setservercurrenttime now
result   this rssstub regionserverstartup null  request build
catch  serviceexception se
ioexception ioe   protobufutil getremoteexception se
if  ioe instanceof clockoutofsyncexception
log fatal    ioe
// re-throw ioe will cause rs to abort
throw ioe
else if  ioe instanceof servernotrunningyetexception
log debug
else
log warn    se
return result
@override
public long getlastsequenceid byte region
long lastflushedsequenceid    1l
try
getlastflushedsequenceidrequest req   requestconverter
buildgetlastflushedsequenceidrequest region
lastflushedsequenceid   rssstub getlastflushedsequenceid null  req
getlastflushedsequenceid
catch  serviceexception e
lastflushedsequenceid    1l
log warn        e
return lastflushedsequenceid
/**
* closes all regions.  called on our way out.
* assumes that its not possible for new regions to be added to onlineregions
* while this method runs.
*/
protected void closeallregions final boolean abort
closeuserregions abort
closemetatableregions abort
/**
* close meta region if we carry it
* @param abort whether we're running an abort.
*/
void closemetatableregions final boolean abort
hregion meta   null
this lock writelock   lock
try
for  map entry<string  hregion> e  onlineregions entryset
hregioninfo hri   e getvalue   getregioninfo
if  hri ismetaregion
meta   e getvalue
if  meta    null  break
finally
this lock writelock   unlock
if  meta    null  closeregionignoreerrors meta getregioninfo    abort
/**
* schedule closes on all user regions.
* should be safe calling multiple times because it wont' close regions
* that are already closed or that are closing.
* @param abort whether we're running an abort.
*/
void closeuserregions final boolean abort
this lock writelock   lock
try
for  map entry<string  hregion> e  this onlineregions entryset
hregion r   e getvalue
if   r getregioninfo   ismetatable      r isavailable
// don't update zk with this close transition; pass false.
closeregionignoreerrors r getregioninfo    abort
finally
this lock writelock   unlock
/** @return the info server */
public infoserver getinfoserver
return infoserver
/**
* @return true if a stop has been requested.
*/
@override
public boolean isstopped
return this stopped
@override
public boolean isstopping
return this stopping
@override
public map<string  hregion> getrecoveringregions
return this recoveringregions
/**
*
* @return the configuration
*/
@override
public configuration getconfiguration
return conf
/** @return the write lock for the server */
reentrantreadwritelock writelock getwritelock
return lock writelock
public int getnumberofonlineregions
return this onlineregions size
boolean isonlineregionsempty
return this onlineregions isempty
/**
* for tests, web ui and metrics.
* this method will only work if hregionserver is in the same jvm as client;
* hregion cannot be serialized to cross an rpc.
*/
public collection<hregion> getonlineregionslocalcontext
collection<hregion> regions   this onlineregions values
return collections unmodifiablecollection regions
@override
public void addtoonlineregions hregion region
this onlineregions put region getregioninfo   getencodedname    region
/**
* @return a new map of online regions sorted by region size with the first entry being the
* biggest.  if two regions are the same size, then the last one found wins; i.e. this method
* may not return all regions.
*/
sortedmap<long  hregion> getcopyofonlineregionssortedbysize
// we'll sort the regions in reverse
sortedmap<long  hregion> sortedregions   new treemap<long  hregion>
new comparator<long>
@override
public int compare long a  long b
return  1   a compareto b
// copy over all regions. regions are sorted by size with biggest first.
for  hregion region   this onlineregions values
sortedregions put region memstoresize get    region
return sortedregions
/**
* @return time stamp in millis of when this region server was started
*/
public long getstartcode
return this startcode
/** @return reference to flushrequester */
@override
public flushrequester getflushrequester
return this cacheflusher
/**
* get the top n most loaded regions this server is serving so we can tell the
* master which regions it can reallocate if we're overloaded. todo: actually
* calculate which regions are most loaded. (right now, we're just grabbing
* the first n regions being served regardless of load.)
*/
protected hregioninfo getmostloadedregions
arraylist<hregioninfo> regions   new arraylist<hregioninfo>
for  hregion r   onlineregions values
if   r isavailable
continue
if  regions size   < numregionstoreport
regions add r getregioninfo
else
break
return regions toarray new hregioninfo
@override
public leases getleases
return leases
/**
* @return return the rootdir.
*/
protected path getrootdir
return rootdir
/**
* @return return the fs.
*/
@override
public filesystem getfilesystem
return fs
@override
public string tostring
return getservername   tostring
/**
* interval at which threads should run
*
* @return the interval
*/
public int getthreadwakefrequency
return threadwakefrequency
@override
public zookeeperwatcher getzookeeper
return zookeeper
@override
public servername getservername
// our servername could change after we talk to the master.
return this servernamefrommasterpov    null?
new servername this isa gethostname    this isa getport    this startcode
this servernamefrommasterpov
@override
public compactionrequestor getcompactionrequester
return this compactsplitthread
public zookeeperwatcher getzookeeperwatcher
return this zookeeper
public regionservercoprocessorhost getcoprocessorhost
return this rshost
@override
public concurrentmap<byte  boolean> getregionsintransitioninrs
return this regionsintransitioninrs
@override
public executorservice getexecutorservice
return service
//
// main program and support routines
//
/**
* load the replication service objects, if any
*/
static private void createnewreplicationinstance configuration conf
hregionserver server  filesystem fs  path logdir  path oldlogdir  throws ioexception
// if replication is not enabled, then return immediately.
if   conf getboolean hconstants replication_enable_key  false
return
// read in the name of the source replication class from the config file.
string sourceclassname   conf get hconstants replication_source_service_classname
hconstants replication_service_classname_default
// read in the name of the sink replication class from the config file.
string sinkclassname   conf get hconstants replication_sink_service_classname
hconstants replication_service_classname_default
// if both the sink and the source class names are the same, then instantiate
// only one object.
if  sourceclassname equals sinkclassname
server replicationsourcehandler    replicationsourceservice
newreplicationinstance sourceclassname
conf  server  fs  logdir  oldlogdir
server replicationsinkhandler    replicationsinkservice
server replicationsourcehandler
else
server replicationsourcehandler    replicationsourceservice
newreplicationinstance sourceclassname
conf  server  fs  logdir  oldlogdir
server replicationsinkhandler    replicationsinkservice
newreplicationinstance sinkclassname
conf  server  fs  logdir  oldlogdir
static private replicationservice newreplicationinstance string classname
configuration conf  hregionserver server  filesystem fs  path logdir
path oldlogdir  throws ioexception
class<?> clazz   null
try
classloader classloader   thread currentthread   getcontextclassloader
clazz   class forname classname  true  classloader
catch  java lang classnotfoundexception nfe
throw new ioexception     classname
// create an instance of the replication object.
replicationservice service    replicationservice
reflectionutils newinstance clazz  conf
service initialize server  fs  logdir  oldlogdir
return service
/**
* @param hrs
* @return thread the regionserver is running in correctly named.
* @throws ioexception
*/
public static thread startregionserver final hregionserver hrs
throws ioexception
return startregionserver hrs      hrs isa getport
/**
* @param hrs
* @param name
* @return thread the regionserver is running in correctly named.
* @throws ioexception
*/
public static thread startregionserver final hregionserver hrs
final string name  throws ioexception
thread t   new thread hrs
t setname name
t start
// install shutdown hook that will catch signals and run an orderly shutdown
// of the hrs.
shutdownhook install hrs getconfiguration    filesystem get hrs
getconfiguration     hrs  t
return t
/**
* utility for constructing an instance of the passed hregionserver class.
*
* @param regionserverclass
* @param conf2
* @return hregionserver instance.
*/
public static hregionserver constructregionserver
class<? extends hregionserver> regionserverclass
final configuration conf2
try
constructor<? extends hregionserver> c   regionserverclass
getconstructor configuration class
return c newinstance conf2
catch  exception e
throw new runtimeexception
regionserverclass tostring    e
/**
* @see org.apache.hadoop.hbase.regionserver.hregionservercommandline
*/
public static void main string args  throws exception
versioninfo logversion
configuration conf   hbaseconfiguration create
@suppresswarnings
class<? extends hregionserver> regionserverclass    class<? extends hregionserver>  conf
getclass hconstants region_server_impl  hregionserver class
new hregionservercommandline regionserverclass  domain args
/**
* gets the online regions of the specified table.
* this method looks at the in-memory onlineregions.  it does not go to <code>.meta.</code>.
* only returns <em>online</em> regions.  if a region on this table has been
* closed during a disable, etc., it will not be included in the returned list.
* so, the returned list may not necessarily be all regions in this table, its
* all the online regions in the table.
* @param tablename
* @return online regions from <code>tablename</code>
*/
@override
public list<hregion> getonlineregions tablename tablename
list<hregion> tableregions   new arraylist<hregion>
synchronized  this onlineregions
for  hregion region  this onlineregions values
hregioninfo regioninfo   region getregioninfo
if regioninfo gettablename   equals tablename
tableregions add region
return tableregions
// used by org/apache/hbase/tmpl/regionserver/rsstatustmpl.jamon (hbase-4070).
public string getcoprocessors
treeset<string> coprocessors   new treeset<string>
this hlog getcoprocessorhost   getcoprocessors
collection<hregion> regions   getonlineregionslocalcontext
for  hregion region  regions
coprocessors addall region getcoprocessorhost   getcoprocessors
return coprocessors toarray new string
/**
* instantiated as a scanner lease. if the lease times out, the scanner is
* closed
*/
private class scannerlistener implements leaselistener
private final string scannername
scannerlistener final string n
this scannername   n
@override
public void leaseexpired
regionscannerholder rsh   scanners remove this scannername
if  rsh    null
regionscanner s   rsh s
log info     this scannername
s getregioninfo   getregionnameasstring
try
hregion region   getregion s getregioninfo   getregionname
if  region    null    region getcoprocessorhost      null
region getcoprocessorhost   prescannerclose s
s close
if  region    null    region getcoprocessorhost      null
region getcoprocessorhost   postscannerclose s
catch  ioexception e
log error
s getregioninfo   getregionnameasstring    e
else
log info     this scannername
/**
* called to verify that this server is up and running.
*
* @throws ioexception
*/
protected void checkopen   throws ioexception
if  this stopped    this abortrequested
throw new regionserverstoppedexception     getservername
this abortrequested ?
if   fsok
throw new regionserverstoppedexception
/**
* try to close the region, logs a warning on failure but continues.
* @param region region to close
*/
private void closeregionignoreerrors hregioninfo region  final boolean abort
try
if   closeregion region getencodedname    abort  false   1  null
log warn     region getregionnameasstring
catch  notservingregionexception e
log warn     region getregionnameasstring
e
/**
* close asynchronously a region, can be called from the master or internally by the regionserver
* when stopping. if called from the master, the region will update the znode status.
*
* <p>
* if an opening was in progress, this method will cancel it, but will not start a new close. the
* coprocessors are not called in this case. a notservingregionexception exception is thrown.
* </p>
* <p>
*   if a close was in progress, this new request will be ignored, and an exception thrown.
* </p>
*
* @param encodedname region to close
* @param abort true if we are aborting
* @param zk true if we are to update zk about the region close; if the close
* was orchestrated by master, then update zk.  if the close is being run by
* the regionserver because its going down, don't update zk.
* @param versionofclosingnode the version of znode to compare when rs transitions the znode from
*   closing state.
* @return true if closed a region.
* @throws notservingregionexception if the region is not online or if a close
* request in in progress.
*/
protected boolean closeregion string encodedname  final boolean abort
final boolean zk  final int versionofclosingnode  final servername sn
throws notservingregionexception
//check for permissions to close.
final hregion actualregion   this getfromonlineregions encodedname
if   actualregion    null      actualregion getcoprocessorhost      null
try
actualregion getcoprocessorhost   preclose false
catch  ioexception exp
log warn    exp
return false
final boolean previous   this regionsintransitioninrs putifabsent encodedname getbytes
boolean false
if  boolean true equals previous
log info     encodedname
if   regionsintransitioninrs replace encodedname getbytes    previous  boolean false
// the replace failed. that should be an exceptional case, but theoretically it can happen.
// we're going to try to do a standard close then.
log warn     encodedname
return closeregion encodedname  abort  zk  versionofclosingnode  sn
else
log info
// the master deletes the znode when it receives this exception.
throw new notservingregionexception     encodedname
else if  boolean false equals previous
log info     encodedname
// the master deletes the znode when it receives this exception.
throw new notservingregionexception     encodedname
if  actualregion    null
log error
this regionsintransitioninrs remove encodedname getbytes
// the master deletes the znode when it receives this exception.
throw new notservingregionexception     encodedname
closeregionhandler crh
final hregioninfo hri   actualregion getregioninfo
if  hri ismetaregion
crh   new closemetahandler this  this  hri  abort  zk  versionofclosingnode
else
crh   new closeregionhandler this  this  hri  abort  zk  versionofclosingnode  sn
this service submit crh
return true
/**
* @param regionname
* @return hregion for the passed binary <code>regionname</code> or null if
*         named region is not member of the online regions.
*/
public hregion getonlineregion final byte regionname
string encodedregionname   hregioninfo encoderegionname regionname
return this onlineregions get encodedregionname
public inetsocketaddress getregionblocklocations final string encodedregionname
return this regionfavorednodesmap get encodedregionname
@override
public hregion getfromonlineregions final string encodedregionname
return this onlineregions get encodedregionname
@override
public boolean removefromonlineregions final hregion r  servername destination
hregion toreturn   this onlineregions remove r getregioninfo   getencodedname
if  destination    null
hlog wal   getwal
long closeseqnum   wal getearliestmemstoreseqnum r getregioninfo   getencodednameasbytes
if  closeseqnum    hconstants no_seqnum
// no edits in wal for this region; get the sequence number when the region was opened.
closeseqnum   r getopenseqnum
if  closeseqnum    hconstants no_seqnum
closeseqnum   0
addtomovedregions r getregioninfo   getencodedname    destination  closeseqnum
this regionfavorednodesmap remove r getregioninfo   getencodedname
return toreturn    null
/**
* protected utility method for safely obtaining an hregion handle.
*
* @param regionname
*          name of online {@link hregion} to return
* @return {@link hregion} for <code>regionname</code>
* @throws notservingregionexception
*/
protected hregion getregion final byte regionname
throws notservingregionexception
string encodedregionname   hregioninfo encoderegionname regionname
return getregionbyencodedname encodedregionname
protected hregion getregionbyencodedname string encodedregionname
throws notservingregionexception
hregion region   this onlineregions get encodedregionname
if  region    null
movedregioninfo moveinfo   getmovedregion encodedregionname
if  moveinfo    null
throw new regionmovedexception moveinfo getservername    moveinfo getseqnum
boolean isopening   this regionsintransitioninrs get bytes tobytes encodedregionname
if  isopening    null    isopening booleanvalue
throw new regionopeningexception     encodedregionname
throw new notservingregionexception     encodedregionname
return region
/*
* cleanup after throwable caught invoking method. converts <code>t</code> to
* ioe if it isn't already.
*
* @param t throwable
*
* @return throwable converted to an ioe; methods can only let out ioes.
*/
protected throwable cleanup final throwable t
return cleanup t  null
/*
* cleanup after throwable caught invoking method. converts <code>t</code> to
* ioe if it isn't already.
*
* @param t throwable
*
* @param msg message to log in error. can be null.
*
* @return throwable converted to an ioe; methods can only let out ioes.
*/
protected throwable cleanup final throwable t  final string msg
// don't log as error if nsre; nsre is 'normal' operation.
if  t instanceof notservingregionexception
log debug     t getmessage
return t
if  msg    null
log error    remoteexceptionhandler checkthrowable t
else
log error msg  remoteexceptionhandler checkthrowable t
if   checkoome t
checkfilesystem
return t
/*
* @param t
*
* @return make <code>t</code> an ioe if it isn't already.
*/
protected ioexception convertthrowabletoioe final throwable t
return convertthrowabletoioe t  null
/*
* @param t
*
* @param msg message to put in new ioe if passed <code>t</code> is not an ioe
*
* @return make <code>t</code> an ioe if it isn't already.
*/
protected ioexception convertthrowabletoioe final throwable t  final string msg
return  t instanceof ioexception ?  ioexception  t   msg    null
msg length      0 ? new ioexception t    new ioexception msg  t
/*
* check if an oome and, if so, abort immediately to avoid creating more objects.
*
* @param e
*
* @return true if we oome'd and are aborting.
*/
@override
public boolean checkoome final throwable e
boolean stop   false
try
if  e instanceof outofmemoryerror
e getcause      null    e getcause   instanceof outofmemoryerror
e getmessage      null    e getmessage   contains
stop   true
log fatal
e
finally
if  stop
runtime getruntime   halt 1
return stop
/**
* checks to see if the file system is still accessible. if not, sets
* abortrequested and stoprequested
*
* @return false if file system is not available
*/
public boolean checkfilesystem
if  this fsok    this fs    null
try
fsutils checkfilesystemavailable this fs
catch  ioexception e
abort    e
this fsok   false
return this fsok
protected long addscanner regionscanner s  throws leasestillheldexception
long scannerid    1
while  true
scannerid   rand nextlong
if  scannerid     1  continue
string scannername   string valueof scannerid
regionscannerholder existing   scanners putifabsent scannername  new regionscannerholder s
if  existing    null
this leases createlease scannername  this scannerleasetimeoutperiod
new scannerlistener scannername
break
return scannerid
/**
* generate a random positive long number
*
* @return a random positive long number
*/
protected long nextlong
long n   rand nextlong
if  n    0
return nextlong
if  n < 0
n    n
return n
// start client methods
/**
* get data from a table.
*
* @param controller the rpc controller
* @param request the get request
* @throws serviceexception
*/
@override
public getresponse get final rpccontroller controller
final getrequest request  throws serviceexception
long before   environmentedgemanager currenttimemillis
try
requestcount increment
hregion region   getregion request getregion
getresponse builder builder   getresponse newbuilder
clientprotos get get   request getget
boolean existence   null
result r   null
if  request getclosestrowbefore
if  get getcolumncount      1
throw new donotretryioexception
get getcolumncount
byte row   get getrow   tobytearray
byte family   get getcolumn 0  getfamily   tobytearray
r   region getclosestrowbefore row  family
else
get clientget   protobufutil toget get
if  request getexistenceonly      region getcoprocessorhost      null
existence   region getcoprocessorhost   preexists clientget
if  existence    null
r   region get clientget
if  request getexistenceonly
boolean exists   r    null     r isempty
if  region getcoprocessorhost      null
exists   region getcoprocessorhost   postexists clientget  exists
existence   exists
if  existence    null
builder setexists existence booleanvalue
else if  r    null
builder setresult protobufutil toresult r
return builder build
catch  ioexception ie
throw new serviceexception ie
finally
metricsregionserver updateget environmentedgemanager currenttimemillis     before
/**
* get multi data from a table.
*
* @param controller the rpc controller
* @param request multi-the get request
* @throws serviceexception
*/
@override
public multigetresponse multiget final rpccontroller controller  final multigetrequest request
throws serviceexception
long before   environmentedgemanager currenttimemillis
try
requestcount add request getgetcount
hregion region   getregion request getregion
multigetresponse builder builder   multigetresponse newbuilder
for  clientprotos get get  request getgetlist
boolean existence   null
result r   null
if  request getclosestrowbefore
if  get getcolumncount      1
throw new donotretryioexception
get getcolumncount
byte row   get getrow   tobytearray
byte family   get getcolumn 0  getfamily   tobytearray
r   region getclosestrowbefore row  family
else
get clientget   protobufutil toget get
if  request getexistenceonly      region getcoprocessorhost      null
existence   region getcoprocessorhost   preexists clientget
if  existence    null
r   region get clientget
if  request getexistenceonly
boolean exists   r    null     r isempty
if  region getcoprocessorhost      null
exists   region getcoprocessorhost   postexists clientget  exists
existence   exists
if  existence    null
builder addexists existence booleanvalue
else if  r    null
builder addresult protobufutil toresult r
return builder build
catch  ioexception ie
throw new serviceexception ie
finally
metricsregionserver updateget environmentedgemanager currenttimemillis     before
/**
* mutate data in a table.
*
* @param rpcc the rpc controller
* @param request the mutate request
* @throws serviceexception
*/
@override
public mutateresponse mutate final rpccontroller rpcc
final mutaterequest request  throws serviceexception
// rpc controller is how we bring in data via the back door;  it is unprotobuf'ed data.
// it is also the conduit via which we pass back data.
payloadcarryingrpccontroller controller    payloadcarryingrpccontroller rpcc
cellscanner cellscanner   controller    null? controller cellscanner    null
// clear scanner so we are not holding on to reference across call.
controller setcellscanner null
try
requestcount increment
hregion region   getregion request getregion
mutateresponse builder builder   mutateresponse newbuilder
mutationproto mutation   request getmutation
if   region getregioninfo   ismetatable
cacheflusher reclaimmemstorememory
result r   null
boolean processed   null
mutationtype type   mutation getmutatetype
switch  type
case append
r   append region  mutation  cellscanner
break
case increment
r   increment region  mutation  cellscanner
break
case put
put put   protobufutil toput mutation  cellscanner
if  request hascondition
condition condition   request getcondition
byte row   condition getrow   tobytearray
byte family   condition getfamily   tobytearray
byte qualifier   condition getqualifier   tobytearray
compareop compareop   compareop valueof condition getcomparetype   name
bytearraycomparable comparator
protobufutil tocomparator condition getcomparator
if  region getcoprocessorhost      null
processed   region getcoprocessorhost   precheckandput
row  family  qualifier  compareop  comparator  put
if  processed    null
boolean result   region checkandmutate row  family
qualifier  compareop  comparator  put  true
if  region getcoprocessorhost      null
result   region getcoprocessorhost   postcheckandput row  family
qualifier  compareop  comparator  put  result
processed   result
else
region put put
processed   boolean true
break
case delete
delete delete   protobufutil todelete mutation  cellscanner
if  request hascondition
condition condition   request getcondition
byte row   condition getrow   tobytearray
byte family   condition getfamily   tobytearray
byte qualifier   condition getqualifier   tobytearray
compareop compareop   compareop valueof condition getcomparetype   name
bytearraycomparable comparator
protobufutil tocomparator condition getcomparator
if  region getcoprocessorhost      null
processed   region getcoprocessorhost   precheckanddelete
row  family  qualifier  compareop  comparator  delete
if  processed    null
boolean result   region checkandmutate row  family
qualifier  compareop  comparator  delete  true
if  region getcoprocessorhost      null
result   region getcoprocessorhost   postcheckanddelete row  family
qualifier  compareop  comparator  delete  result
processed   result
else
region delete delete
processed   boolean true
break
default
throw new donotretryioexception
type name
cellscannable cellstoreturn   null
if  processed    null
builder setprocessed processed booleanvalue
else if  r    null
builder setresult protobufutil toresultnodata r
cellstoreturn   r
if  cellstoreturn    null
controller setcellscanner cellstoreturn cellscanner
return builder build
catch  ioexception ie
checkfilesystem
throw new serviceexception ie
//
// remote scanner interface
//
/**
* scan data in a table.
*
* @param controller the rpc controller
* @param request the scan request
* @throws serviceexception
*/
@override
public scanresponse scan final rpccontroller controller
final scanrequest request  throws serviceexception
leases lease lease   null
string scannername   null
try
if   request hasscannerid       request hasscan
throw new donotretryioexception
long scannerid    1
if  request hasscannerid
scannerid   request getscannerid
scannername   string valueof scannerid
try
checkopen
catch  ioexception e
// if checkopen failed, server not running or filesystem gone,
// cancel this lease; filesystem is gone or we're closing or something.
if  scannername    null
try
leases cancellease scannername
catch  leaseexception le
log info
scannername
throw e
requestcount increment
try
int ttl   0
hregion region   null
regionscanner scanner   null
regionscannerholder rsh   null
boolean moreresults   true
boolean closescanner   false
scanresponse builder builder   scanresponse newbuilder
if  request hasclosescanner
closescanner   request getclosescanner
int rows   1
if  request hasnumberofrows
rows   request getnumberofrows
if  request hasscannerid
rsh   scanners get scannername
if  rsh    null
log info     scannername
throw new unknownscannerexception
scannername
scanner   rsh s
region   getregion scanner getregioninfo   getregionname
else
region   getregion request getregion
clientprotos scan protoscan   request getscan
boolean isloadingcfsondemandset   protoscan hasloadcolumnfamiliesondemand
scan scan   protobufutil toscan protoscan
// if the request doesn't set this, get the default region setting.
if   isloadingcfsondemandset
scan setloadcolumnfamiliesondemand region isloadingcfsondemanddefault
byte hasmetrics   scan getattribute scan scan_attributes_metrics_enable
region preparescanner scan
if  region getcoprocessorhost      null
scanner   region getcoprocessorhost   prescanneropen scan
if  scanner    null
scanner   region getscanner scan
if  region getcoprocessorhost      null
scanner   region getcoprocessorhost   postscanneropen scan  scanner
scannerid   addscanner scanner
scannername   string valueof scannerid
ttl   this scannerleasetimeoutperiod
if  rows > 0
// if nextcallseq does not match throw exception straight away. this needs to be
// performed even before checking of lease.
// see hbase-5974
if  request hasnextcallseq
if  rsh    null
rsh   scanners get scannername
if  rsh    null
if  request getnextcallseq      rsh nextcallseq
throw new outoforderscannernextexception     rsh nextcallseq
request getnextcallseq
textformat shortdebugstring request
// increment the nextcallseq value which is the next expected from client.
rsh nextcallseq
try
// remove lease while its being processed in server; protects against case
// where processing of request takes > lease expiration time.
lease   leases removelease scannername
list<result> results   new arraylist<result> rows
long currentscanresultsize   0
boolean done   false
// call coprocessor. get region info from scanner.
if  region    null    region getcoprocessorhost      null
boolean bypass   region getcoprocessorhost   prescannernext
scanner  results  rows
if   results isempty
for  result r   results
if  maxscannerresultsize < long max_value
for  keyvalue kv   r raw
currentscanresultsize    kv heapsize
if  bypass    null    bypass booleanvalue
done   true
if   done
long maxresultsize   scanner getmaxresultsize
if  maxresultsize <  0
maxresultsize   maxscannerresultsize
list<keyvalue> values   new arraylist<keyvalue>
multiversionconsistencycontrol setthreadreadpoint scanner getmvccreadpoint
region startregionoperation operation scan
try
int i   0
synchronized scanner
for    i < rows
currentscanresultsize < maxresultsize  i
// collect values to be returned here
boolean morerows   scanner nextraw values
if   values isempty
if  maxscannerresultsize < long max_value
for  keyvalue kv   values
currentscanresultsize    kv heapsize
results add new result values
if   morerows
break
values clear
region readrequestscount add i
finally
region closeregionoperation
// coprocessor postnext hook
if  region    null    region getcoprocessorhost      null
region getcoprocessorhost   postscannernext scanner  results  rows  true
// if the scanner's filter - if any - is done with the scan
// and wants to tell the client to stop the scan. this is done by passing
// a null result, and setting moreresults to false.
if  scanner isfilterdone      results isempty
moreresults   false
results   null
else
resultcellmeta builder rcmbuilder   resultcellmeta newbuilder
list<cellscannable> cellscannables   new arraylist<cellscannable> results size
for  result res   results
cellscannables add res
rcmbuilder addcellslength res size
builder setresultcellmeta rcmbuilder build
// todo is this okey to assume the type and cast
payloadcarryingrpccontroller  controller  setcellscanner cellutil
createcellscanner cellscannables
finally
// we're done. on way out re-add the above removed lease.
// adding resets expiration time on lease.
if  scanners containskey scannername
if  lease    null  leases addlease lease
ttl   this scannerleasetimeoutperiod
if   moreresults    closescanner
ttl   0
moreresults   false
if  region    null    region getcoprocessorhost      null
if  region getcoprocessorhost   prescannerclose scanner
return builder build       bypass
rsh   scanners remove scannername
if  rsh    null
scanner   rsh s
scanner close
leases cancellease scannername
if  region    null    region getcoprocessorhost      null
region getcoprocessorhost   postscannerclose scanner
if  ttl > 0
builder setttl ttl
builder setscannerid scannerid
builder setmoreresults moreresults
return builder build
catch  throwable t
if  scannername    null    t instanceof notservingregionexception
scanners remove scannername
throw convertthrowabletoioe cleanup t
catch  ioexception ie
throw new serviceexception ie
/**
* atomically bulk load several hfiles into an open region
* @return true if successful, false is failed but recoverably (no action)
* @throws ioexception if failed unrecoverably
*/
@override
public bulkloadhfileresponse bulkloadhfile final rpccontroller controller
final bulkloadhfilerequest request  throws serviceexception
try
requestcount increment
hregion region   getregion request getregion
list<pair<byte  string>> familypaths   new arraylist<pair<byte  string>>
for  familypath familypath  request getfamilypathlist
familypaths add new pair<byte  string> familypath getfamily   tobytearray
familypath getpath
boolean bypass   false
if  region getcoprocessorhost      null
bypass   region getcoprocessorhost   prebulkloadhfile familypaths
boolean loaded   false
if   bypass
loaded   region bulkloadhfiles familypaths  request getassignseqnum
if  region getcoprocessorhost      null
loaded   region getcoprocessorhost   postbulkloadhfile familypaths  loaded
bulkloadhfileresponse builder builder   bulkloadhfileresponse newbuilder
builder setloaded loaded
return builder build
catch  ioexception ie
throw new serviceexception ie
@override
public coprocessorserviceresponse execservice final rpccontroller controller
final coprocessorservicerequest request  throws serviceexception
try
requestcount increment
hregion region   getregion request getregion
// ignore the passed in controller (from the serialized call)
serverrpccontroller execcontroller   new serverrpccontroller
message result   region execservice execcontroller  request getcall
if  execcontroller getfailedon      null
throw execcontroller getfailedon
coprocessorserviceresponse builder builder
coprocessorserviceresponse newbuilder
builder setregion requestconverter buildregionspecifier
regionspecifiertype region_name  region getregionname
builder setvalue
builder getvaluebuilder   setname result getclass   getname
setvalue result tobytestring
return builder build
catch  ioexception ie
throw new serviceexception ie
/**
* execute multiple actions on a table: get, mutate, and/or execcoprocessor
*
* @param rpcc the rpc controller
* @param request the multi request
* @throws serviceexception
*/
@override
public multiresponse multi final rpccontroller rpcc  final multirequest request
throws serviceexception
// rpc controller is how we bring in data via the back door;  it is unprotobuf'ed data.
// it is also the conduit via which we pass back data.
payloadcarryingrpccontroller controller    payloadcarryingrpccontroller rpcc
cellscanner cellscanner   controller    null? controller cellscanner    null
// clear scanner so we are not holding on to reference across call.
controller setcellscanner null
list<cellscannable> cellstoreturn   null
try
hregion region   getregion request getregion
multiresponse builder builder   multiresponse newbuilder
list<mutationproto> mutations   new arraylist<mutationproto> request getactioncount
// do a bunch of mutations atomically.  mutations are puts and deletes.  not gets.
if  request hasatomic      request getatomic
// multiaction is union type.  has a get or a mutate.
for  clientprotos multiaction actionunion   request getactionlist
if  actionunion hasmutation
mutations add actionunion getmutation
else
throw new donotretryioexception     actionunion
// todo: we are not updating a metric here.  should we up requestcount?
if   mutations isempty    mutaterows region  mutations  cellscanner
else
// do a bunch of actions.
actionresult builder resultbuilder   null
cellstoreturn   new arraylist<cellscannable> request getactioncount
for  clientprotos multiaction actionunion   request getactionlist
this requestcount increment
clientprotos result result   null
try
if  actionunion hasget
get get   protobufutil toget actionunion getget
result r   region get get
if  r    null
// get a result with no data.  the data will be carried alongside pbs, not as pbs.
result   protobufutil toresultnodata r
// add the result to controller so it gets serialized apart from pb.  get
// results could be big so good if they are not serialized as pb.
cellstoreturn add r
else if  actionunion hasmutation
mutationproto mutation   actionunion getmutation
mutationtype type   mutation getmutatetype
if  type    mutationtype put    type    mutationtype delete
if   mutations isempty
dobatchop builder  region  mutations  cellscanner
mutations clear
else if   region getregioninfo   ismetatable
cacheflusher reclaimmemstorememory
result r   null
switch  type
case append
r   append region  mutation  cellscanner
break
case increment
r   increment region  mutation  cellscanner
break
case put
case delete
mutations add mutation
break
default
throw new donotretryioexception     type name
if  r    null
// put the data into the cellstoreturn and the metadata about the result is all that
// we will pass back in the protobuf result.
result   protobufutil toresultnodata r
cellstoreturn add r
else
log warn     actionunion
throw new donotretryioexception
if  result    null
if  resultbuilder    null
resultbuilder   actionresult newbuilder
else
resultbuilder clear
resultbuilder setvalue result
builder addresult resultbuilder build
catch  ioexception ie
builder addresult responseconverter buildactionresult ie
if   mutations isempty
dobatchop builder  region  mutations  cellscanner
// load the controller with the cells to return.
if  cellstoreturn    null     cellstoreturn isempty
controller setcellscanner cellutil createcellscanner cellstoreturn
return builder build
catch  ioexception ie
throw new serviceexception ie
// end client methods
// start admin methods
@override
@qospriority priority hconstants high_qos
public getregioninforesponse getregioninfo final rpccontroller controller
final getregioninforequest request  throws serviceexception
try
checkopen
requestcount increment
hregion region   getregion request getregion
hregioninfo info   region getregioninfo
getregioninforesponse builder builder   getregioninforesponse newbuilder
builder setregioninfo hregioninfo convert info
if  request hascompactionstate      request getcompactionstate
builder setcompactionstate region getcompactionstate
builder setisrecovering region isrecovering
return builder build
catch  ioexception ie
throw new serviceexception ie
@override
public getstorefileresponse getstorefile final rpccontroller controller
final getstorefilerequest request  throws serviceexception
try
hregion region   getregion request getregion
requestcount increment
set<byte> columnfamilies
if  request getfamilycount      0
columnfamilies   region getstores   keyset
else
columnfamilies   new treeset<byte> bytes bytes_rawcomparator
for  bytestring cf  request getfamilylist
columnfamilies add cf tobytearray
int ncf   columnfamilies size
list<string>  filelist   region getstorefilelist
columnfamilies toarray new byte
getstorefileresponse builder builder   getstorefileresponse newbuilder
builder addallstorefile filelist
return builder build
catch  ioexception ie
throw new serviceexception ie
@override
@qospriority priority hconstants high_qos
public getonlineregionresponse getonlineregion final rpccontroller controller
final getonlineregionrequest request  throws serviceexception
try
checkopen
requestcount increment
list<hregioninfo> list   new arraylist<hregioninfo> onlineregions size
for  hregion region  this onlineregions values
list add region getregioninfo
collections sort list
return responseconverter buildgetonlineregionresponse list
catch  ioexception ie
throw new serviceexception ie
// region open/close direct rpcs
/**
* open asynchronously a region or a set of regions on the region server.
*
* the opening is coordinated by zookeeper, and this method requires the znode to be created
*  before being called. as a consequence, this method should be called only from the master.
* <p>
* different manages states for the region are:<ul>
*  <li>region not opened: the region opening will start asynchronously.</li>
*  <li>a close is already in progress: this is considered as an error.</li>
*  <li>an open is already in progress: this new open request will be ignored. this is important
*  because the master can do multiple requests if it crashes.</li>
*  <li>the region is already opened:  this new open request will be ignored./li>
*  </ul>
* </p>
* <p>
* bulk assign: if there are more than 1 region to open, it will be considered as a bulk assign.
* for a single region opening, errors are sent through a serviceexception. for bulk assign,
* errors are put in the response as failed_opening.
* </p>
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
@qospriority priority hconstants high_qos
public openregionresponse openregion final rpccontroller controller
final openregionrequest request  throws serviceexception
try
checkopen
catch  ioexception ie
throw new serviceexception ie
requestcount increment
openregionresponse builder builder   openregionresponse newbuilder
final int regioncount   request getopeninfocount
final map<tablename  htabledescriptor> htds
new hashmap<tablename  htabledescriptor> regioncount
final boolean isbulkassign   regioncount > 1
for  regionopeninfo regionopeninfo   request getopeninfolist
final hregioninfo region   hregioninfo convert regionopeninfo getregion
int versionofofflinenode    1
if  regionopeninfo hasversionofofflinenode
versionofofflinenode   regionopeninfo getversionofofflinenode
htabledescriptor htd
try
final hregion onlineregion   getfromonlineregions region getencodedname
if  onlineregion    null
//check if the region can actually be opened.
if  onlineregion getcoprocessorhost      null
onlineregion getcoprocessorhost   preopen
// see hbase-5094. cross check with meta if still this rs is owning
// the region.
pair<hregioninfo  servername> p   metareader getregion
this catalogtracker  region getregionname
if  this getservername   equals p getsecond
boolean closing   regionsintransitioninrs get region getencodednameasbytes
// map regionsintransitioninrsonly has an entry for a region only if the region
// is in transition on this rs, so here closing can be null. if not null, it can
// be true or false. true means the region is opening on this rs; while false
// means the region is closing. only return already_opened if not closing (i.e.
// not in transition any more, or still transition to open.
if   boolean false equals closing
getfromonlineregions region getencodedname       null
log warn     region getencodedname
builder addopeningstate regionopeningstate already_opened
continue
else
log warn     region getencodedname
removefromonlineregions onlineregion  null
log info     region getregionnameasstring
htd   htds get region gettablename
if  htd    null
htd   this tabledescriptors get region gettablename
htds put region gettablename    htd
final boolean previous   this regionsintransitioninrs putifabsent
region getencodednameasbytes    boolean true
if  boolean false equals previous
// there is a close in progress. we need to mark this open as failed in zk.
openregionhandler
trytransitionfromofflinetofailedopen this  region  versionofofflinenode
throw new regionalreadyintransitionexception
region getregionnameasstring
if  boolean true equals previous
// an open is in progress. this is supported, but let's log this.
log info
region getregionnameasstring
// we are opening this region. if it moves back and forth for whatever reason, we don't
// want to keep returning the stale moved record while we are opening/if we close again.
removefrommovedregions region getencodedname
if  previous    null
// check if the region to be opened is marked in recovering state in zk
if  splitlogmanager isregionmarkedrecoveringinzk this getzookeeper
region getencodedname
this recoveringregions put region getencodedname    null
// if there is no action in progress, we can submit a specific handler.
// need to pass the expected version in the constructor.
if  region ismetaregion
this service submit new openmetahandler this  this  region  htd
versionofofflinenode
else
updateregionfavorednodesmapping region getencodedname
regionopeninfo getfavorednodeslist
this service submit new openregionhandler this  this  region  htd
versionofofflinenode
builder addopeningstate regionopeningstate opened
catch  keeperexception zookeeperex
log error    zookeeperex
throw new serviceexception zookeeperex
catch  ioexception ie
log warn     region getregionnameasstring    ie
if  isbulkassign
builder addopeningstate regionopeningstate failed_opening
else
throw new serviceexception ie
return builder build
@override
public void updateregionfavorednodesmapping string encodedregionname
list<org apache hadoop hbase protobuf generated hbaseprotos servername> favorednodes
inetsocketaddress addr   new inetsocketaddress
// refer to the comment on the declaration of regionfavorednodesmap on why
// it is a map of region name to inetsocketaddress[]
for  int i   0  i < favorednodes size    i
addr   inetsocketaddress createunresolved favorednodes get i  gethostname
favorednodes get i  getport
regionfavorednodesmap put encodedregionname  addr
/**
* return the favored nodes for a region given its encoded name. look at the
* comment around {@link #regionfavorednodesmap} on why it is inetsocketaddress[]
* @param encodedregionname
* @return array of favored locations
*/
@override
public inetsocketaddress getfavorednodesforregion string encodedregionname
return regionfavorednodesmap get encodedregionname
/**
* close a region on the region server.
*
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
@qospriority priority hconstants high_qos
public closeregionresponse closeregion final rpccontroller controller
final closeregionrequest request  throws serviceexception
int versionofclosingnode    1
if  request hasversionofclosingnode
versionofclosingnode   request getversionofclosingnode
boolean zk   request gettransitioninzk
final servername sn    request hasdestinationserver   ?
protobufutil toservername request getdestinationserver      null
try
checkopen
final string encodedregionname   protobufutil getregionencodedname request getregion
// can be null if we're calling close on a region that's not online
final hregion region   this getfromonlineregions encodedregionname
if   region     null      region  getcoprocessorhost      null
region getcoprocessorhost   preclose false
requestcount increment
log info     encodedregionname
zk ?
versionofclosingnode
sn
boolean closed   closeregion encodedregionname  false  zk  versionofclosingnode  sn
closeregionresponse builder builder   closeregionresponse newbuilder   setclosed closed
return builder build
catch  ioexception ie
throw new serviceexception ie
/**
* flush a region on the region server.
*
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
@qospriority priority hconstants high_qos
public flushregionresponse flushregion final rpccontroller controller
final flushregionrequest request  throws serviceexception
try
checkopen
requestcount increment
hregion region   getregion request getregion
log info     region getregionnameasstring
boolean shouldflush   true
if  request hasifolderthants
shouldflush   region getlastflushtime   < request getifolderthants
flushregionresponse builder builder   flushregionresponse newbuilder
if  shouldflush
boolean result   region flushcache
if  result
this compactsplitthread requestsystemcompaction region
builder setflushed result
builder setlastflushtime region getlastflushtime
return builder build
catch  ioexception ie
throw new serviceexception ie
/**
* split a region on the region server.
*
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
@qospriority priority hconstants high_qos
public splitregionresponse splitregion final rpccontroller controller
final splitregionrequest request  throws serviceexception
try
checkopen
requestcount increment
hregion region   getregion request getregion
region startregionoperation operation split_region
log info     region getregionnameasstring
region flushcache
byte splitpoint   null
if  request hassplitpoint
splitpoint   request getsplitpoint   tobytearray
region forcesplit splitpoint
compactsplitthread requestsplit region  region checksplit
return splitregionresponse newbuilder   build
catch  ioexception ie
throw new serviceexception ie
/**
* merge regions on the region server.
*
* @param controller the rpc controller
* @param request the request
* @return merge regions response
* @throws serviceexception
*/
@override
@qospriority priority   hconstants high_qos
public mergeregionsresponse mergeregions final rpccontroller controller
final mergeregionsrequest request  throws serviceexception
try
checkopen
requestcount increment
hregion regiona   getregion request getregiona
hregion regionb   getregion request getregionb
boolean forcible   request getforcible
regiona startregionoperation operation merge_region
regionb startregionoperation operation merge_region
log info     regiona       regionb
forcible
regiona flushcache
regionb flushcache
compactsplitthread requestregionsmerge regiona  regionb  forcible
return mergeregionsresponse newbuilder   build
catch  ioexception ie
throw new serviceexception ie
/**
* compact a region on the region server.
*
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
@qospriority priority hconstants high_qos
public compactregionresponse compactregion final rpccontroller controller
final compactregionrequest request  throws serviceexception
try
checkopen
requestcount increment
hregion region   getregion request getregion
region startregionoperation operation compact_region
log info     region getregionnameasstring
boolean major   false
byte  family   null
store store   null
if  request hasfamily
family   request getfamily   tobytearray
store   region getstore family
if  store    null
throw new serviceexception new ioexception     bytes tostring family
region getregionnameasstring
if  request hasmajor
major   request getmajor
if  major
if  family    null
store triggermajorcompaction
else
region triggermajorcompaction
string familylogmsg    family    null ?    bytes tostring family
log trace
region getregionnameasstring     familylogmsg
string log        major ?              familylogmsg
if family    null
compactsplitthread requestcompaction region  store  log
store priority_user  null
else
compactsplitthread requestcompaction region  log
store priority_user  null
return compactregionresponse newbuilder   build
catch  ioexception ie
throw new serviceexception ie
/**
* replicate wal entries on the region server.
*
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
@qospriority priority hconstants replication_qos
public replicatewalentryresponse replicatewalentry final rpccontroller controller
final replicatewalentryrequest request
throws serviceexception
try
if  replicationsinkhandler    null
checkopen
requestcount increment
this replicationsinkhandler replicatelogentries request getentrylist
payloadcarryingrpccontroller controller  cellscanner
return replicatewalentryresponse newbuilder   build
catch  ioexception ie
throw new serviceexception ie
/**
* replay the given changes when distributedlogreplay wal edits from a failed rs. the guarantee is
* that the given mutations will be durable on the receiving rs if this method returns without any
* exception.
* @param rpcc the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
@qospriority priority   hconstants replay_qos
public multiresponse replay final rpccontroller rpcc  final multirequest request
throws serviceexception
long before   environmentedgemanager currenttimemillis
payloadcarryingrpccontroller controller    payloadcarryingrpccontroller  rpcc
cellscanner cellscanner   controller    null ? controller cellscanner     null
// clear scanner so we are not holding on to reference across call.
controller setcellscanner null
try
checkopen
hregion region   getregion request getregion
multiresponse builder builder   multiresponse newbuilder
list<mutationproto> mutates   new arraylist<mutationproto>
for  clientprotos multiaction actionunion   request getactionlist
if  actionunion hasmutation
mutationproto mutate   actionunion getmutation
mutationtype type   mutate getmutatetype
switch  type
case put
case delete
mutates add mutate
break
default
throw new donotretryioexception     type name
else
log warn     actionunion
throw new donotretryioexception
if   mutates isempty
dobatchop builder  region  mutates  cellscanner  true
return builder build
catch  ioexception ie
throw new serviceexception ie
finally
metricsregionserver updatereplay environmentedgemanager currenttimemillis     before
/**
* roll the wal writer of the region server.
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
public rollwalwriterresponse rollwalwriter final rpccontroller controller
final rollwalwriterrequest request  throws serviceexception
try
requestcount increment
hlog wal   this getwal
byte regionstoflush   wal rollwriter true
rollwalwriterresponse builder builder   rollwalwriterresponse newbuilder
if  regionstoflush    null
for  byte region  regionstoflush
builder addregiontoflush bytestring copyfrom region
return builder build
catch  ioexception ie
throw new serviceexception ie
/**
* stop the region server.
*
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
public stopserverresponse stopserver final rpccontroller controller
final stopserverrequest request  throws serviceexception
requestcount increment
string reason   request getreason
stop reason
return stopserverresponse newbuilder   build
/**
* get some information of the region server.
*
* @param controller the rpc controller
* @param request the request
* @throws serviceexception
*/
@override
public getserverinforesponse getserverinfo final rpccontroller controller
final getserverinforequest request  throws serviceexception
servername servername   getservername
requestcount increment
return responseconverter buildgetserverinforesponse servername  webuiport
// end admin methods
/**
* find the hregion based on a region specifier
*
* @param regionspecifier the region specifier
* @return the corresponding region
* @throws ioexception if the specifier is not null,
*    but failed to find the region
*/
protected hregion getregion
final regionspecifier regionspecifier  throws ioexception
return getregionbyencodedname
protobufutil getregionencodedname regionspecifier
/**
* execute an append mutation.
*
* @param region
* @param m
* @param cellscanner
* @return result to return to client if default operation should be
* bypassed as indicated by regionobserver, null otherwise
* @throws ioexception
*/
protected result append final hregion region
final mutationproto m  final cellscanner cellscanner  throws ioexception
long before   environmentedgemanager currenttimemillis
append append   protobufutil toappend m  cellscanner
result r   null
if  region getcoprocessorhost      null
r   region getcoprocessorhost   preappend append
if  r    null
r   region append append
if  region getcoprocessorhost      null
region getcoprocessorhost   postappend append  r
metricsregionserver updateappend environmentedgemanager currenttimemillis     before
return r
/**
* execute an increment mutation.
*
* @param region
* @param mutation
* @return the result
* @throws ioexception
*/
protected result increment final hregion region  final mutationproto mutation
final cellscanner cells
throws ioexception
long before   environmentedgemanager currenttimemillis
increment increment   protobufutil toincrement mutation  cells
result r   null
if  region getcoprocessorhost      null
r   region getcoprocessorhost   preincrement increment
if  r    null
r   region increment increment
if  region getcoprocessorhost      null
r   region getcoprocessorhost   postincrement increment  r
metricsregionserver updateincrement environmentedgemanager currenttimemillis     before
return r
/**
* execute a list of put/delete mutations.
*/
protected void dobatchop final multiresponse builder builder
final hregion region  final list<mutationproto> mutates  final cellscanner cells
dobatchop builder  region  mutates  cells  false
/**
* execute a list of put/delete mutations.
*
* @param builder
* @param region
* @param mutations
*/
protected void dobatchop final multiresponse builder builder  final hregion region
final list<mutationproto> mutations  final cellscanner cells  boolean isreplay
mutation marray   new mutation
long before   environmentedgemanager currenttimemillis
boolean batchcontainsputs   false  batchcontainsdelete   false
try
actionresult builder resultbuilder   actionresult newbuilder
resultbuilder setvalue clientprotos result newbuilder   build
actionresult result   resultbuilder build
int i   0
for  mutationproto m   mutations
mutation mutation
if  m getmutatetype      mutationtype put
mutation   protobufutil toput m  cells
batchcontainsputs   true
else
mutation   protobufutil todelete m  cells
batchcontainsdelete   true
marray   mutation
builder addresult result
requestcount add mutations size
if   region getregioninfo   ismetatable
cacheflusher reclaimmemstorememory
operationstatus codes   region batchmutate marray  isreplay
for  i   0  i < codes length  i
switch  codes getoperationstatuscode
case bad_family
result   responseconverter buildactionresult
new nosuchcolumnfamilyexception codes getexceptionmsg
builder setresult i  result
break
case sanity_check_failure
result   responseconverter buildactionresult
new failedsanitycheckexception codes getexceptionmsg
builder setresult i  result
break
default
result   responseconverter buildactionresult
new donotretryioexception codes getexceptionmsg
builder setresult i  result
break
case success
break
if  isreplay    codes getoperationstatuscode      operationstatuscode success
// in replay mode, we only need to catpure the first error because we will retry the whole
// batch when an error happens
break
catch  ioexception ie
actionresult result   responseconverter buildactionresult ie
for  int i   0  i < mutations size    i
builder setresult i  result
if  isreplay
// in replay mode, we only need to catpure the first error because we will retry the whole
// batch when an error happens
break
long after   environmentedgemanager currenttimemillis
if  batchcontainsputs
metricsregionserver updateput after   before
if  batchcontainsdelete
metricsregionserver updatedelete after   before
/**
* mutate a list of rows atomically.
*
* @param region
* @param mutations
* @param cellscanner if non-null, the mutation data -- the cell content.
* @throws ioexception
*/
protected void mutaterows final hregion region  final list<mutationproto> mutations
final cellscanner cellscanner
throws ioexception
mutationproto firstmutate   mutations get 0
if   region getregioninfo   ismetatable
cacheflusher reclaimmemstorememory
byte  row   firstmutate getrow   tobytearray
rowmutations rm   new rowmutations row
for  mutationproto mutate  mutations
mutationtype type   mutate getmutatetype
switch  mutate getmutatetype
case put
rm add protobufutil toput mutate  cellscanner
break
case delete
rm add protobufutil todelete mutate  cellscanner
break
default
throw new donotretryioexception
type name
region mutaterow rm
private static class movedregioninfo
private final servername servername
private final long seqnum
private final long ts
public movedregioninfo servername servername  long closeseqnum
this servername   servername
this seqnum   closeseqnum
ts   environmentedgemanager currenttimemillis
public servername getservername
return servername
public long getseqnum
return seqnum
public long getmovetime
return ts
// this map will contains all the regions that we closed for a move.
//  we add the time it was moved as we don't want to keep too old information
protected map<string  movedregioninfo> movedregions
new concurrenthashmap<string  movedregioninfo> 3000
// we need a timeout. if not there is a risk of giving a wrong information: this would double
//  the number of network calls instead of reducing them.
private static final int timeout_region_moved    2   60   1000
protected void addtomovedregions string encodedname  servername destination  long closeseqnum
if  servername issamehostnameandport destination  this getservername
log warn     encodedname
return
log info     encodedname
destination getservername         destination getport
closeseqnum
movedregions put encodedname  new movedregioninfo destination  closeseqnum
private void removefrommovedregions string encodedname
movedregions remove encodedname
private movedregioninfo getmovedregion final string encodedregionname
movedregioninfo dest   movedregions get encodedregionname
long now   environmentedgemanager currenttimemillis
if  dest    null
if  dest getmovetime   >  now   timeout_region_moved
return dest
else
movedregions remove encodedregionname
return null
/**
* remove the expired entries from the moved regions list.
*/
protected void cleanmovedregions
final long cutoff   system currenttimemillis     timeout_region_moved
iterator<entry<string  movedregioninfo>> it   movedregions entryset   iterator
while  it hasnext
map entry<string  movedregioninfo> e   it next
if  e getvalue   getmovetime   < cutoff
it remove
/**
* creates a chore thread to clean the moved region cache.
*/
protected static class movedregionscleaner extends chore implements stoppable
private hregionserver regionserver
stoppable stoppable
private movedregionscleaner
hregionserver regionserver  stoppable stoppable
super   regionserver  timeout_region_moved  stoppable
this regionserver   regionserver
this stoppable   stoppable
static movedregionscleaner createandstart hregionserver rs
stoppable stoppable   new stoppable
private volatile boolean isstopped   false
@override public void stop string why    isstopped   true
@override public boolean isstopped    return isstopped
return new movedregionscleaner rs  stoppable
@override
protected void chore
regionserver cleanmovedregions
@override
public void stop string why
stoppable stop why
@override
public boolean isstopped
return stoppable isstopped
private string getmyephemeralnodepath
return zkutil joinznode this zookeeper rsznode  getservername   tostring
/**
* holder class which holds the regionscanner and nextcallseq together.
*/
private static class regionscannerholder
private regionscanner s
private long nextcallseq   0l
public regionscannerholder regionscanner s
this s   s
private boolean ishealthcheckerconfigured
string healthscriptlocation   this conf get hconstants health_script_loc
return org apache commons lang stringutils isnotblank healthscriptlocation
/**
* @return the underlying {@link compactsplitthread} for the servers
*/
public compactsplitthread getcompactsplitthread
return this compactsplitthread
/**
* a helper function to store the last flushed sequence id with the previous failed rs for a
* recovering region. the id is used to skip wal edits which are flushed. since the flushed
* sequence id is only valid for each rs, we associate the id with corresponding failed rs.
* @throws keeperexception
* @throws ioexception
*/
private void updaterecoveringregionlastflushedsequenceid hregion r  throws keeperexception
ioexception
if   r isrecovering
// return immdiately for non-recovering regions
return
hregioninfo region   r getregioninfo
zookeeperwatcher zkw   getzookeeper
string previousrsname   this getlastfailedrsfromzk region getencodedname
map<byte  long> maxseqidinstores   r getmaxstoreseqidforlogreplay
long minseqidforlogreplay    1
for  byte columnfamily   maxseqidinstores keyset
long storeseqidforreplay   maxseqidinstores get columnfamily
if  minseqidforlogreplay     1    storeseqidforreplay < minseqidforlogreplay
minseqidforlogreplay   storeseqidforreplay
long lastrecordedflushedsequenceid    1
string nodepath   zkutil joinznode this zookeeper recoveringregionsznode
region getencodedname
// recovering-region level
byte data   zkutil getdata zkw  nodepath
if  data    null
lastrecordedflushedsequenceid   splitlogmanager parselastflushedsequenceidfrom data
if  data    null    lastrecordedflushedsequenceid < minseqidforlogreplay
zkutil setdata zkw  nodepath  zkutil positiontobytearray minseqidforlogreplay
if  previousrsname    null
// one level deeper for the failed rs
nodepath   zkutil joinznode nodepath  previousrsname
zkutil setdata zkw  nodepath
zkutil regionsequenceidstobytearray minseqidforlogreplay  maxseqidinstores
log debug     region getencodedname
previousrsname
else
log warn     region getencodedname
/**
* return the last failed rs name under /hbase/recovering-regions/encodedregionname
* @param encodedregionname
* @return
* @throws ioexception
* @throws keeperexception
*/
private string getlastfailedrsfromzk string encodedregionname  throws keeperexception
string result   null
long maxzxid   0
zookeeperwatcher zkw   this getzookeeper
string nodepath   zkutil joinznode zkw recoveringregionsznode  encodedregionname
list<string> failedservers   zkutil listchildrennowatch zkw  nodepath
if  failedservers    null    failedservers isempty
return result
for  string failedserver   failedservers
string rspath   zkutil joinznode nodepath  failedserver
stat stat   new stat
zkutil getdatanowatch zkw  rspath  stat
if  maxzxid < stat getczxid
maxzxid   stat getczxid
result   failedserver
return result