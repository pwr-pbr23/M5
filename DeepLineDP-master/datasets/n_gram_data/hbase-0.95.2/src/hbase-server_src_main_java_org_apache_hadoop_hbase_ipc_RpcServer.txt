/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase ipc
import static org apache hadoop fs commonconfigurationkeys hadoop_security_authorization
import java io bytearrayinputstream
import java io bytearrayoutputstream
import java io dataoutputstream
import java io ioexception
import java net bindexception
import java net inetaddress
import java net inetsocketaddress
import java net serversocket
import java net socket
import java net socketexception
import java net unknownhostexception
import java nio bytebuffer
import java nio channels cancelledkeyexception
import java nio channels channels
import java nio channels closedchannelexception
import java nio channels readablebytechannel
import java nio channels selectionkey
import java nio channels selector
import java nio channels serversocketchannel
import java nio channels socketchannel
import java nio channels writablebytechannel
import java security privilegedexceptionaction
import java util arraylist
import java util collections
import java util hashmap
import java util iterator
import java util linkedlist
import java util list
import java util map
import java util random
import java util concurrent blockingqueue
import java util concurrent executorservice
import java util concurrent executors
import java util concurrent linkedblockingqueue
import java util concurrent atomic atomicinteger
import javax security sasl sasl
import javax security sasl saslexception
import javax security sasl saslserver
import com google common collect lists
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop conf configuration
import org apache hadoop hbase cellscanner
import org apache hadoop hbase tablename
import org apache hadoop hbase donotretryioexception
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase client operation
import org apache hadoop hbase codec codec
import org apache hadoop hbase exceptions regionmovedexception
import org apache hadoop hbase io bytebufferoutputstream
import org apache hadoop hbase monitoring monitoredrpchandler
import org apache hadoop hbase monitoring taskmonitor
import org apache hadoop hbase protobuf protobufutil
import org apache hadoop hbase protobuf generated rpcprotos cellblockmeta
import org apache hadoop hbase protobuf generated rpcprotos connectionheader
import org apache hadoop hbase protobuf generated rpcprotos exceptionresponse
import org apache hadoop hbase protobuf generated rpcprotos requestheader
import org apache hadoop hbase protobuf generated rpcprotos responseheader
import org apache hadoop hbase protobuf generated rpcprotos userinformation
import org apache hadoop hbase regionserver hregionserver
import org apache hadoop hbase security authmethod
import org apache hadoop hbase security hbasepolicyprovider
import org apache hadoop hbase security hbasesaslrpcserver
import org apache hadoop hbase security hbasesaslrpcserver sasldigestcallbackhandler
import org apache hadoop hbase security hbasesaslrpcserver saslgsscallbackhandler
import org apache hadoop hbase security saslstatus
import org apache hadoop hbase security saslutil
import org apache hadoop hbase security user
import org apache hadoop hbase security token authenticationtokensecretmanager
import org apache hadoop hbase util bytes
import org apache hadoop hbase util pair
import org apache hadoop io byteswritable
import org apache hadoop io intwritable
import org apache hadoop io writable
import org apache hadoop io writableutils
import org apache hadoop io compress compressioncodec
import org apache hadoop hbase server
import org apache hadoop security accesscontrolexception
import org apache hadoop security usergroupinformation
import org apache hadoop security usergroupinformation authenticationmethod
import org apache hadoop security authorize authorizationexception
import org apache hadoop security authorize policyprovider
import org apache hadoop security authorize proxyusers
import org apache hadoop security authorize serviceauthorizationmanager
import org apache hadoop security token secretmanager
import org apache hadoop security token secretmanager invalidtoken
import org apache hadoop security token tokenidentifier
import org apache hadoop util stringutils
import org cliffc high_scale_lib counter
import org cloudera htrace trace
import org cloudera htrace traceinfo
import org cloudera htrace tracescope
import org codehaus jackson map objectmapper
import com google common base function
import com google common util concurrent threadfactorybuilder
import com google protobuf blockingservice
import com google protobuf codedinputstream
import com google protobuf descriptors methoddescriptor
import com google protobuf message
import com google protobuf message builder
import com google protobuf serviceexception
import com google protobuf textformat
// uses writables doing sasl
/**
* an rpc server that hosts protobuf described services.
* <p>once was copied from hadoop to local to fix hbase-900 but deviated long ago.
*
* @see rpcclient
*/
@interfaceaudience private
public class rpcserver implements rpcserverinterface
// the logging package is deliberately outside of standard o.a.h.h package so it is not on
// by default.
public static final log log   logfactory getlog
private final boolean authorize
private boolean issecurityenabled
public static final byte current_version   0
/**
* how many calls/handler are allowed in the queue.
*/
private static final int default_max_callqueue_length_per_handler   10
/**
* the maximum size that we can hold in the rpc queue
*/
private static final int default_max_callqueue_size   1024   1024   1024
static final int buffer_initial_size   1024
private static final string warn_delayed_calls
private static final int default_warn_delayed_calls   1000
private final int warndelayedcalls
private atomicinteger delayedcalls
private final ipcutil ipcutil
private static final string auth_failed_for
private static final string auth_successful_for
private static final log auditlog   logfactory getlog
server class getname
protected secretmanager<tokenidentifier> secretmanager
protected serviceauthorizationmanager authmanager
protected static final threadlocal<rpcserverinterface> server   new threadlocal<rpcserverinterface>
private volatile boolean started   false
/** this is set to call object before handler invokes an rpc and reset
* after the call returns.
*/
protected static final threadlocal<call> curcall   new threadlocal<call>
protected final inetsocketaddress isa
protected int port                                 port we listen on
private int handlercount                           number of handler threads
private int priorityhandlercount
private int readthreads                            number of read threads
protected int maxidletime                          the maximum idle time after
// which a client may be
// disconnected
protected int thresholdidleconnections             the number of idle
// connections after which we
// will start cleaning up idle
// connections
int maxconnectionstonuke                           the max number of
// connections to nuke
// during a cleanup
protected metricshbaseserver metrics
protected final configuration conf
private int maxqueuelength
private int maxqueuesize
protected int socketsendbuffersize
protected final boolean tcpnodelay       if t then disable nagle's algorithm
protected final boolean tcpkeepalive     if t then use keepalives
protected final long purgetimeout        in milliseconds
protected volatile boolean running   true             true while server runs
protected blockingqueue<call> callqueue     queued calls
protected final counter callqueuesize   new counter
protected blockingqueue<call> prioritycallqueue
protected int highprioritylevel      what level a high priority call is at
protected final list<connection> connectionlist
collections synchronizedlist new linkedlist<connection>
//maintain a list
//of client connections
private listener listener   null
protected responder responder   null
protected int numconnections   0
private handler handlers   null
private handler priorityhandlers   null
/** replication related queue; */
protected blockingqueue<call> replicationqueue
private int numofreplicationhandlers   0
private handler replicationhandlers   null
protected hbaserpcerrorhandler errorhandler   null
private static final string warn_response_time
private static final string warn_response_size
/** default value for above params */
private static final int default_warn_response_time   10000     milliseconds
private static final int default_warn_response_size   100   1024   1024
private static final objectmapper mapper   new objectmapper
private final int warnresponsetime
private final int warnresponsesize
private final object serverinstance
private final list<blockingserviceandinterface> services
/**
* datastructure that holds all necessary to a method invocation and then afterward, carries
* the result.
*/
class call implements rpccallcontext
protected int id                                 the client's call id
protected blockingservice service
protected methoddescriptor md
protected message param                          the parameter passed
// optional cell data passed outside of protobufs.
protected cellscanner cellscanner
protected connection connection                  connection to client
protected long timestamp          the time received when response is null
// the time served when response is not null
protected bytebuffer response                    the response for this call
protected boolean delayresponse
protected responder responder
protected boolean delayreturnvalue               if the return value should be
// set at call completion
protected long size                              size of current call
protected boolean iserror
protected traceinfo tinfo
protected string effectiveuser
call int id  final blockingservice service  final methoddescriptor md  message param
cellscanner cellscanner  connection connection  responder responder  long size
traceinfo tinfo  string effectiveuser
this id   id
this service   service
this md   md
this param   param
this cellscanner   cellscanner
this connection   connection
this timestamp   system currenttimemillis
this response   null
this delayresponse   false
this responder   responder
this iserror   false
this size   size
this tinfo   tinfo
this effectiveuser   effectiveuser
@override
public string tostring
return toshortstring
this param    null? protobufutil getshorttextformat this param
connection tostring
/*
* short string representation without param info because param itself could be huge depends on
* the payload of a command
*/
string toshortstring
string servicename   this connection service    null?
this connection service getdescriptorfortype   getname
stringbuilder sb   new stringbuilder
sb append
sb append this id
sb append
sb append servicename
sb append
sb append  this md    null  ? this md getname
sb append
sb append stringutils humanreadableint this size
sb append
sb append connection tostring
return sb tostring
string totracestring
string servicename   this connection service    null ?
this connection service getdescriptorfortype   getname
string methodname    this md    null  ? this md getname
string result   servicename       methodname
return result
protected synchronized void setsasltokenresponse bytebuffer response
this response   response
protected synchronized void setresponse object m  final cellscanner cells
throwable t  string errormsg
if  this iserror  return
if  t    null  this iserror   true
bytebufferoutputstream bbos   null
try
responseheader builder headerbuilder   responseheader newbuilder
// presume it a pb message.  could be null.
message result    message m
// call id.
headerbuilder setcallid this id
if  t    null
exceptionresponse builder exceptionbuilder   exceptionresponse newbuilder
exceptionbuilder setexceptionclassname t getclass   getname
exceptionbuilder setstacktrace errormsg
exceptionbuilder setdonotretry t instanceof donotretryioexception
if  t instanceof regionmovedexception
// special casing for this exception.  this is only one carrying a payload.
// do this instead of build a generic system for allowing exceptions carry
// any kind of payload.
regionmovedexception rme    regionmovedexception t
exceptionbuilder sethostname rme gethostname
exceptionbuilder setport rme getport
// set the exception as the result of the method invocation.
headerbuilder setexception exceptionbuilder build
bytebuffer cellblock
ipcutil buildcellblock this connection codec  this connection compressioncodec  cells
if  cellblock    null
cellblockmeta builder cellblockbuilder   cellblockmeta newbuilder
// presumes the cellblock bytebuffer has been flipped so limit has total size in it.
cellblockbuilder setlength cellblock limit
headerbuilder setcellblockmeta cellblockbuilder build
message header   headerbuilder build
bbos   ipcutil write header  result  cellblock
if  connection usewrap
wrapwithsasl bbos
catch  ioexception e
log warn     e
bytebuffer bb   null
if  bbos    null
// todo: if sasl, maybe buffer already been flipped and written?
bb   bbos getbytebuffer
bb position 0
this response   bb
private void wrapwithsasl bytebufferoutputstream response
throws ioexception
if  connection usesasl
// getbytebuffer calls flip()
bytebuffer buf   response getbytebuffer
byte token
// synchronization may be needed since there can be multiple handler
// threads using saslserver to wrap responses.
synchronized  connection saslserver
token   connection saslserver wrap buf array
buf arrayoffset    buf remaining
if  log isdebugenabled
log debug     token length
buf clear
dataoutputstream saslout   new dataoutputstream response
saslout writeint token length
saslout write token  0  token length
@override
public synchronized void enddelay object result  throws ioexception
assert this delayresponse
assert this delayreturnvalue    result    null
this delayresponse   false
delayedcalls decrementandget
if  this delayreturnvalue
this setresponse result  null  null  null
this responder dorespond this
@override
public synchronized void enddelay   throws ioexception
this enddelay null
@override
public synchronized void startdelay boolean delayreturnvalue
assert  this delayresponse
this delayresponse   true
this delayreturnvalue   delayreturnvalue
int numdelayed   delayedcalls incrementandget
if  numdelayed > warndelayedcalls
log warn     warndelayedcalls       numdelayed
@override
public synchronized void enddelaythrowing throwable t  throws ioexception
this setresponse null  null  t  stringutils stringifyexception t
this delayresponse   false
this sendresponseifready
@override
public synchronized boolean isdelayed
return this delayresponse
@override
public synchronized boolean isreturnvaluedelayed
return this delayreturnvalue
@override
public void throwexceptionifcallerdisconnected string regionname
throws callerdisconnectedexception
if   connection channel isopen
long aftertime   system currenttimemillis     timestamp
throw new callerdisconnectedexception
regionname
this       aftertime
public long getsize
return this size
/**
* if we have a response, and delay is not set, then respond
* immediately.  otherwise, do not respond to client.  this is
* called the by the rpc code in the context of the handler thread.
*/
public synchronized void sendresponseifready   throws ioexception
if   this delayresponse
this responder dorespond this
/** listens on the socket. creates jobs for the handler threads*/
private class listener extends thread
private serversocketchannel acceptchannel   null    the accept channel
private selector selector   null    the selector that we use for the server
private reader readers   null
private int currentreader   0
private random rand   new random
private long lastcleanupruntime   0    the last time when a cleanup connec
//-tion (for idle connections) ran
private long cleanupinterval   10000    the minimum interval between
//two cleanup runs
private int backloglength   conf getint    128
private executorservice readpool
public listener final string name  throws ioexception
super name
// create a new server socket and set to non blocking mode
acceptchannel   serversocketchannel open
acceptchannel configureblocking false
// bind the server socket to the local host and port
bind acceptchannel socket    isa  backloglength
port   acceptchannel socket   getlocalport      could be an ephemeral port
// create a selector;
selector  selector open
readers   new reader
readpool   executors newfixedthreadpool readthreads
new threadfactorybuilder   setnameformat
port  setdaemon true  build
for  int i   0  i < readthreads    i
reader reader   new reader
readers   reader
readpool execute reader
log info getname         readthreads
// register accepts on the server socket with the selector.
acceptchannel register selector  selectionkey op_accept
this setname     port
this setdaemon true
private class reader implements runnable
private volatile boolean adding   false
private final selector readselector
reader   throws ioexception
this readselector   selector open
public void run
try
dorunloop
finally
try
readselector close
catch  ioexception ioe
log error getname         getname    ioe
private synchronized void dorunloop
while  running
selectionkey key   null
try
readselector select
while  adding
this wait 1000
iterator<selectionkey> iter   readselector selectedkeys   iterator
while  iter hasnext
key   iter next
iter remove
if  key isvalid
if  key isreadable
doread key
key   null
catch  interruptedexception e
if  running                            unexpected    log it
log info getname
stringutils stringifyexception e
catch  ioexception ex
log error getname        ex
/**
* this gets reader into the state that waits for the new channel
* to be registered with readselector. if it was waiting in select()
* the thread will be woken up, otherwise whenever select() is called
* it will return even if there is nothing to read and wait
* in while(adding) for finishadd call
*/
public void startadd
adding   true
readselector wakeup
public synchronized selectionkey registerchannel socketchannel channel
throws ioexception
return channel register readselector  selectionkey op_read
public synchronized void finishadd
adding   false
this notify
/** cleanup connections from connectionlist. choose a random range
* to scan and also have a limit on the number of the connections
* that will be cleanedup per run. the criteria for cleanup is the time
* for which the connection was idle. if 'force' is true then all
* connections will be looked at for the cleanup.
* @param force all connections will be looked at for cleanup
*/
private void cleanupconnections boolean force
if  force    numconnections > thresholdidleconnections
long currenttime   system currenttimemillis
if   force     currenttime   lastcleanupruntime  < cleanupinterval
return
int start   0
int end   numconnections   1
if   force
start   rand nextint   % numconnections
end   rand nextint   % numconnections
int temp
if  end < start
temp   start
start   end
end   temp
int i   start
int numnuked   0
while  i <  end
connection c
synchronized  connectionlist
try
c   connectionlist get i
catch  exception e   return
if  c timedout currenttime
if  log isdebugenabled
log debug getname         c gethostaddress
closeconnection c
numnuked
end
//noinspection unusedassignment
c   null
if   force    numnuked    maxconnectionstonuke  break
else i
lastcleanupruntime   system currenttimemillis
@override
public void run
log info getname
server set rpcserver this
while  running
selectionkey key   null
try
selector select       findbugs is2_inconsistent_sync
iterator<selectionkey> iter   selector selectedkeys   iterator
while  iter hasnext
key   iter next
iter remove
try
if  key isvalid
if  key isacceptable
doaccept key
catch  ioexception ignored
key   null
catch  outofmemoryerror e
if  errorhandler    null
if  errorhandler checkoome e
log info getname
closecurrentconnection key  e
cleanupconnections true
return
else
// we can run out of memory if we have too many threads
// log the event and sleep for a minute and give
// some thread(s) a chance to finish
log warn getname        e
closecurrentconnection key  e
cleanupconnections true
try   thread sleep 60000     catch  exception ignored
catch  exception e
closecurrentconnection key  e
cleanupconnections false
log info getname
synchronized  this
try
acceptchannel close
selector close
catch  ioexception ignored
selector  null
acceptchannel  null
// clean up all connections
while   connectionlist isempty
closeconnection connectionlist remove 0
private void closecurrentconnection selectionkey key  throwable e
if  key    null
connection c    connection key attachment
if  c    null
if  log isdebugenabled
log debug getname         c gethostaddress
e    null ?     e getmessage
closeconnection c
key attach null
inetsocketaddress getaddress
return  inetsocketaddress acceptchannel socket   getlocalsocketaddress
void doaccept selectionkey key  throws ioexception  outofmemoryerror
connection c
serversocketchannel server    serversocketchannel  key channel
socketchannel channel
while   channel   server accept       null
channel configureblocking false
channel socket   settcpnodelay tcpnodelay
channel socket   setkeepalive tcpkeepalive
reader reader   getreader
try
reader startadd
selectionkey readkey   reader registerchannel channel
c   getconnection channel  system currenttimemillis
readkey attach c
synchronized  connectionlist
connectionlist add numconnections  c
numconnections
if  log isdebugenabled
log debug getname         c tostring
numconnections
callqueue size
finally
reader finishadd
void doread selectionkey key  throws interruptedexception
int count   0
connection c    connection key attachment
if  c    null
return
c setlastcontact system currenttimemillis
try
count   c readandprocess
catch  interruptedexception ieo
throw ieo
catch  exception e
log warn getname         count  e
count    1    so that the  count < 0  block is executed
if  count < 0
if  log isdebugenabled
log debug getname         c tostring
count
numconnections
closeconnection c
// c = null;
else
c setlastcontact system currenttimemillis
synchronized void dostop
if  selector    null
selector wakeup
thread yield
if  acceptchannel    null
try
acceptchannel socket   close
catch  ioexception e
log info getname         e
readpool shutdownnow
// the method that will return the next reader to work with
// simplistic implementation of round robin for now
reader getreader
currentreader    currentreader   1  % readers length
return readers
// sends responses of rpc back to clients.
protected class responder extends thread
private final selector writeselector
private int pending             connections waiting to register
responder   throws ioexception
this setname
this setdaemon true
writeselector   selector open       create a selector
pending   0
@override
public void run
log info getname
server set rpcserver this
try
dorunloop
finally
log info getname
try
writeselector close
catch  ioexception ioe
log error getname        ioe
private void dorunloop
long lastpurgetime   0       last check for old calls
while  running
try
waitpending           if a channel is being registered  wait
writeselector select purgetimeout
iterator<selectionkey> iter   writeselector selectedkeys   iterator
while  iter hasnext
selectionkey key   iter next
iter remove
try
if  key isvalid      key iswritable
doasyncwrite key
catch  ioexception e
log info getname        e
long now   system currenttimemillis
if  now < lastpurgetime   purgetimeout
continue
lastpurgetime   now
//
// if there were some calls that have not been sent out for a
// long time, discard them.
//
if  log isdebugenabled    log debug getname
arraylist<call> calls
// get the list of channels from list of keys.
synchronized  writeselector keys
calls   new arraylist<call> writeselector keys   size
iter   writeselector keys   iterator
while  iter hasnext
selectionkey key   iter next
call call    call key attachment
if  call    null    key channel      call connection channel
calls add call
for call call   calls
try
dopurge call  now
catch  ioexception e
log warn getname         e
catch  outofmemoryerror e
if  errorhandler    null
if  errorhandler checkoome e
log info getname
return
else
//
// we can run out of memory if we have too many threads
// log the event and sleep for a minute and give
// some thread(s) a chance to finish
//
log warn getname        e
try   thread sleep 60000     catch  exception ignored
catch  exception e
log warn getname
stringutils stringifyexception e
log info getname
private void doasyncwrite selectionkey key  throws ioexception
call call    call key attachment
if  call    null
return
if  key channel      call connection channel
throw new ioexception
synchronized call connection responsequeue
if  processresponse call connection responsequeue  false
try
key interestops 0
catch  cancelledkeyexception e
/* the listener/reader might have closed the socket.
* we don't explicitly cancel the key, so not sure if this will
* ever fire.
* this warning could be removed.
*/
log warn     e
//
// remove calls that have been pending in the responsequeue
// for a long time.
//
private void dopurge call call  long now  throws ioexception
synchronized  call connection responsequeue
iterator<call> iter   call connection responsequeue listiterator 0
while  iter hasnext
call nextcall   iter next
if  now > nextcall timestamp   purgetimeout
closeconnection nextcall connection
break
// processes one response. returns true if there are no more pending
// data for this channel.
//
private boolean processresponse final linkedlist<call> responsequeue  boolean inhandler
throws ioexception
boolean error   true
boolean done   false           there is more data for this channel
int numelements
call call   null
try
//noinspection synchronizationonlocalvariableormethodparameter
synchronized  responsequeue
//
// if there are no items for this channel, then we are done
//
numelements   responsequeue size
if  numelements    0
error   false
return true                  no more data for this channel
//
// extract the first call
//
call   responsequeue removefirst
socketchannel channel   call connection channel
//
// send as much data as we can in the non-blocking fashion
//
int numbytes   channelwrite channel  call response
if  numbytes < 0
return true
if   call response hasremaining
call connection decrpccount
//noinspection redundantifstatement
if  numelements    1          last call fully processes
done   true                 no more data for this channel
else
done   false                more calls pending to be sent
if  log isdebugenabled
log debug getname         call id       numbytes
else
//
// if we were unable to write the entire response out, then
// insert in selector queue.
//
call connection responsequeue addfirst call
if  inhandler
// set the serve time when the response has to be sent later
call timestamp   system currenttimemillis
if  enqueueinselector call
done   true
if  log isdebugenabled
log debug getname     call toshortstring
numbytes
error   false                  everything went off well
finally
if  error    call    null
log warn getname     call toshortstring
done   true                   error  no more data for this channel
closeconnection call connection
return done
//
// enqueue for background thread to send responses out later.
//
private boolean enqueueinselector call call  throws ioexception
boolean done   false
incpending
try
// wake up the thread blocked on select, only then can the call
// to channel.register() complete.
socketchannel channel   call connection channel
writeselector wakeup
channel register writeselector  selectionkey op_write  call
catch  closedchannelexception e
//it's ok.  channel might be closed else where.
done   true
finally
decpending
return done
//
// enqueue a response from the application.
//
void dorespond call call  throws ioexception
// set the serve time when the response has to be sent later
call timestamp   system currenttimemillis
boolean doregister   false
synchronized  call connection responsequeue
call connection responsequeue addlast call
if  call connection responsequeue size      1
doregister    processresponse call connection responsequeue  false
if  doregister
enqueueinselector call
private synchronized void incpending          call waiting to be enqueued
pending
private synchronized void decpending        call done enqueueing
pending
notify
private synchronized void waitpending   throws interruptedexception
while  pending > 0
wait
@suppresswarnings
public static class callqueuetoobigexception extends ioexception
callqueuetoobigexception
super
private function<pair<requestheader  message>  integer> qosfunction   null
/**
* gets the qos level for this call.  if it is higher than the highprioritylevel and there
* are priorityhandlers available it will be processed in it's own thread set.
*
* @param newfunc
*/
@override
public void setqosfunction function<pair<requestheader  message>  integer> newfunc
qosfunction   newfunc
protected int getqoslevel pair<requestheader  message> headerandparam
if  qosfunction    null  return 0
integer res   qosfunction apply headerandparam
return res    null? 0  res
/** reads calls from a connection and queues them for handling. */
@edu umd cs findbugs annotations suppresswarnings
value
justification
public class connection
// if initial preamble with version and magic has been read or not.
private boolean connectionpreambleread   false
// if the connection header has been read or not.
private boolean connectionheaderread   false
protected socketchannel channel
private bytebuffer data
private bytebuffer datalengthbuffer
protected final linkedlist<call> responsequeue
private volatile int rpccount   0     number of outstanding rpcs
private long lastcontact
private inetaddress addr
protected socket socket
// cache the remote host & port info so that even if the socket is
// disconnected, we can say where it used to connect to.
protected string hostaddress
protected int remoteport
connectionheader connectionheader
/**
* codec the client asked use.
*/
private codec codec
/**
* compression codec the client asked us use.
*/
private compressioncodec compressioncodec
blockingservice service
protected usergroupinformation user   null
private authmethod authmethod
private boolean saslcontextestablished
private boolean skipinitialsaslhandshake
private bytebuffer unwrappeddata
// when is this set?  findbugs wants to know!  says np
private bytebuffer unwrappeddatalengthbuffer   bytebuffer allocate 4
boolean usesasl
saslserver saslserver
private boolean usewrap   false
// fake 'call' for failed authorization response
private static final int authroization_failed_callid    1
private final call authfailedcall
new call authroization_failed_callid  this service  null
null  null  this  null  0  null  null
private bytearrayoutputstream authfailedresponse
new bytearrayoutputstream
// fake 'call' for sasl context setup
private static final int sasl_callid    33
private final call saslcall
new call sasl_callid  this service  null  null  null  this  null  0  null  null
public usergroupinformation attemptinguser   null     user name before auth
public connection socketchannel channel  long lastcontact
this channel   channel
this lastcontact   lastcontact
this data   null
this datalengthbuffer   bytebuffer allocate 4
this socket   channel socket
this addr   socket getinetaddress
if  addr    null
this hostaddress
else
this hostaddress   addr gethostaddress
this remoteport   socket getport
this responsequeue   new linkedlist<call>
if  socketsendbuffersize    0
try
socket setsendbuffersize socketsendbuffersize
catch  ioexception e
log warn
socketsendbuffersize
@override
public string tostring
return gethostaddress         remoteport
public string gethostaddress
return hostaddress
public inetaddress gethostinetaddress
return addr
public int getremoteport
return remoteport
public void setlastcontact long lastcontact
this lastcontact   lastcontact
public long getlastcontact
return lastcontact
/* return true if the connection has no outstanding rpc */
private boolean isidle
return rpccount    0
/* decrement the outstanding rpc count */
protected void decrpccount
rpccount
/* increment the outstanding rpc count */
protected void incrpccount
rpccount
protected boolean timedout long currenttime
return isidle      currenttime   lastcontact > maxidletime
private usergroupinformation getauthorizedugi string authorizedid
throws ioexception
if  authmethod    authmethod digest
tokenidentifier tokenid   hbasesaslrpcserver getidentifier authorizedid
secretmanager
usergroupinformation ugi   tokenid getuser
if  ugi    null
throw new accesscontrolexception
ugi addtokenidentifier tokenid
return ugi
else
return usergroupinformation createremoteuser authorizedid
private void saslreadandprocess byte sasltoken  throws ioexception
interruptedexception
if  saslcontextestablished
if  log isdebugenabled
log debug     sasltoken length
if   usewrap
processonerpc sasltoken
else
byte  plaintextdata   saslserver unwrap sasltoken  0  sasltoken length
processunwrappeddata plaintextdata
else
byte replytoken   null
try
if  saslserver    null
switch  authmethod
case digest
if  secretmanager    null
throw new accesscontrolexception
saslserver   sasl createsaslserver authmethod digest
getmechanismname    null  saslutil sasl_default_realm
saslutil sasl_props  new sasldigestcallbackhandler
secretmanager  this
break
default
usergroupinformation current   usergroupinformation
getcurrentuser
string fullname   current getusername
if  log isdebugenabled
log debug     fullname
final string names   saslutil splitkerberosname fullname
if  names length    3
throw new accesscontrolexception
fullname
current doas new privilegedexceptionaction<object>
@override
public object run   throws saslexception
saslserver   sasl createsaslserver authmethod kerberos
getmechanismname    names  names
saslutil sasl_props  new saslgsscallbackhandler
return null
if  saslserver    null
throw new accesscontrolexception
authmethod getmechanismname
if  log isdebugenabled
log debug     authmethod getmechanismname
if  log isdebugenabled
log debug     sasltoken length
replytoken   saslserver evaluateresponse sasltoken
catch  ioexception e
ioexception sendtoclient   e
throwable cause   e
while  cause    null
if  cause instanceof invalidtoken
sendtoclient    invalidtoken  cause
break
cause   cause getcause
dorawsaslreply saslstatus error  null  sendtoclient getclass   getname
sendtoclient getlocalizedmessage
metrics authenticationfailure
string clientip   this tostring
// attempting user could be null
auditlog warn auth_failed_for   clientip       attemptinguser
throw e
if  replytoken    null
if  log isdebugenabled
log debug     replytoken length
dorawsaslreply saslstatus success  new byteswritable replytoken   null

if  saslserver iscomplete
string qop    string  saslserver getnegotiatedproperty sasl qop
usewrap   qop    null       equalsignorecase qop
user   getauthorizedugi saslserver getauthorizationid
if  log isdebugenabled
log debug
user
saslserver getnegotiatedproperty sasl qop
metrics authenticationsuccess
auditlog info auth_successful_for   user
saslcontextestablished   true
/**
* no protobuf encoding of raw sasl messages
*/
private void dorawsaslreply saslstatus status  writable rv
string errorclass  string error  throws ioexception
//in my testing, have noticed that sasl messages are usually
//in the ballpark of 100-200. that's why the initialcapacity is 256.
bytebufferoutputstream saslresponse   new bytebufferoutputstream 256
dataoutputstream out   new dataoutputstream saslresponse
out writeint status state      write status
if  status    saslstatus success
rv write out
else
writableutils writestring out  errorclass
writableutils writestring out  error
saslcall setsasltokenresponse saslresponse getbytebuffer
saslcall responder   responder
saslcall sendresponseifready
private void disposesasl
if  saslserver    null
try
saslserver dispose
saslserver   null
catch  saslexception ignored
/**
* read off the wire.
* @return returns -1 if failure (and caller will close connection) else return how many
* bytes were read and processed
* @throws ioexception
* @throws interruptedexception
*/
public int readandprocess   throws ioexception  interruptedexception
while  true
// try and read in an int.  if new connection, the int will hold the 'hbas' header.  if it
// does, read in the rest of the connection preamble, the version and the auth method.
// else it will be length of the data to read (or -1 if a ping).  we catch the integer
// length into the 4-byte this.datalengthbuffer.
int count
if  this datalengthbuffer remaining   > 0
count   channelread channel  this datalengthbuffer
if  count < 0    this datalengthbuffer remaining   > 0
return count
// if we have not read the connection setup preamble, look to see if that is on the wire.
if   connectionpreambleread
// check for 'hbas' magic.
this datalengthbuffer flip
if   hconstants rpc_header equals datalengthbuffer
return dobadpreamblehandling
bytes tostringbinary hconstants rpc_header array
bytes tostringbinary datalengthbuffer array
tostring
// now read the next two bytes, the version and the auth to use.
bytebuffer versionandauthbytes   bytebuffer allocate 2
count   channelread channel  versionandauthbytes
if  count < 0    versionandauthbytes remaining   > 0
return count
int version   versionandauthbytes get 0
byte authbyte   versionandauthbytes get 1
this authmethod   authmethod valueof authbyte
if  version    current_version
string msg   getfatalconnectionstring version  authbyte
return dobadpreamblehandling msg  new wrongversionexception msg
if  authmethod    null
string msg   getfatalconnectionstring version  authbyte
return dobadpreamblehandling msg  new badauthexception msg
if  issecurityenabled    authmethod    authmethod simple
accesscontrolexception ae   new accesscontrolexception
setupresponse authfailedresponse  authfailedcall  ae  ae getmessage
responder dorespond authfailedcall
throw ae
if   issecurityenabled    authmethod    authmethod simple
dorawsaslreply saslstatus success  new intwritable
saslutil switch_to_simple_auth   null  null
authmethod   authmethod simple
// client has already sent the initial sasl message and we
// should ignore it. both client and server should fall back
// to simple auth from now on.
skipinitialsaslhandshake   true
if  authmethod    authmethod simple
usesasl   true
connectionpreambleread   true
// preamble checks out. go around again to read actual connection header.
datalengthbuffer clear
continue
// we have read a length and we have read the preamble.  it is either the connection header
// or it is a request.
if  data    null
datalengthbuffer flip
int datalength   datalengthbuffer getint
if  datalength    rpcclient ping_call_id
if   usewrap      covers the  usesasl too
datalengthbuffer clear
return 0     ping message
if  datalength < 0
throw new illegalargumentexception
datalength       gethostaddress
data   bytebuffer allocate datalength
incrpccount        increment the rpc count
count   channelread channel  data
if  count < 0
return count
else if  data remaining      0
datalengthbuffer clear
data flip
if  skipinitialsaslhandshake
data   null
skipinitialsaslhandshake   false
continue
boolean headerread   connectionheaderread
if  usesasl
saslreadandprocess data array
else
processonerpc data array
this data   null
if   headerread
continue
else
// more to read still; go around again.
if  log istraceenabled    log trace     data remaining
continue
return count
private string getfatalconnectionstring final int version  final byte authbyte
return     current_version
version       authbyte
authmethod    null        tostring
private int dobadpreamblehandling final string msg  throws ioexception
return dobadpreamblehandling msg  new fatalconnectionexception msg
private int dobadpreamblehandling final string msg  final exception e  throws ioexception
log warn msg
call fakecall   new call  1  null  null  null  null  this  responder   1  null  null
setupresponse null  fakecall  e  msg
responder dorespond fakecall
// returning -1 closes out the connection.
return  1
// reads the connection header following version
private void processconnectionheader byte buf  throws ioexception
this connectionheader   connectionheader parsefrom buf
string servicename   connectionheader getservicename
if  servicename    null  throw new emptyservicenameexception
this service   getservice services  servicename
if  this service    null  throw new unknownserviceexception servicename
setupcellblockcodecs this connectionheader
usergroupinformation protocoluser   createuser connectionheader
if   usesasl
user   protocoluser
if  user    null
user setauthenticationmethod authmethod simple authenticationmethod
else
// user is authenticated
user setauthenticationmethod authmethod authenticationmethod
//now we check if this is a proxy user case. if the protocol user is
//different from the 'user', it is a proxy user scenario. however,
//this is not allowed if user authenticated with digest.
if   protocoluser    null
protocoluser getusername   equals user getusername
if  authmethod    authmethod digest
// not allowed to doas if token authentication is used
throw new accesscontrolexception     user
protocoluser
else
// effective user can be different from authenticated user
// for simple auth or kerberos auth
// the user is the real user. now we create a proxy user
usergroupinformation realuser   user
user   usergroupinformation createproxyuser protocoluser
getusername    realuser
// now the user is a proxy user, set authentication method proxy.
user setauthenticationmethod authenticationmethod proxy
/**
* set up cell block codecs
* @param header
* @throws fatalconnectionexception
*/
private void setupcellblockcodecs final connectionheader header
throws fatalconnectionexception
// todo: plug in other supported decoders.
string classname   header getcellblockcodecclass
try
this codec    codec class forname classname  newinstance
catch  exception e
throw new unsupportedcellcodecexception classname  e
if   header hascellblockcompressorclass    return
classname   header getcellblockcompressorclass
try
this compressioncodec    compressioncodec class forname classname  newinstance
catch  exception e
throw new unsupportedcompressioncodecexception classname  e
private void processunwrappeddata byte inbuf  throws ioexception
interruptedexception
readablebytechannel ch   channels newchannel new bytearrayinputstream inbuf
// read all rpcs contained in the inbuf, even partial ones
while  true
int count    1
if  unwrappeddatalengthbuffer remaining   > 0
count   channelread ch  unwrappeddatalengthbuffer
if  count <  0    unwrappeddatalengthbuffer remaining   > 0
return
if  unwrappeddata    null
unwrappeddatalengthbuffer flip
int unwrappeddatalength   unwrappeddatalengthbuffer getint
if  unwrappeddatalength    rpcclient ping_call_id
if  log isdebugenabled
log debug
unwrappeddatalengthbuffer clear
continue     ping message
unwrappeddata   bytebuffer allocate unwrappeddatalength
count   channelread ch  unwrappeddata
if  count <  0    unwrappeddata remaining   > 0
return
if  unwrappeddata remaining      0
unwrappeddatalengthbuffer clear
unwrappeddata flip
processonerpc unwrappeddata array
unwrappeddata   null
private void processonerpc byte buf  throws ioexception  interruptedexception
if  connectionheaderread
processrequest buf
else
processconnectionheader buf
this connectionheaderread   true
if   authorizeconnection
// throw fatalconnectionexception wrapping ace so client does right thing and closes
// down the connection instead of trying to read non-existent retun.
throw new accesscontrolexception     this
connectionheader getservicename         user
/**
* @param buf has the request header and the request param and optionally encoded data buffer
* all in this one array.
* @throws ioexception
* @throws interruptedexception
*/
protected void processrequest byte buf  throws ioexception  interruptedexception
long totalrequestsize   buf length
int offset   0
// here we read in the header.  we avoid having pb
// do its default 4k allocation for codedinputstream.  we force it to use backing array.
codedinputstream cis   codedinputstream newinstance buf  offset  buf length
int headersize   cis readrawvarint32
offset   cis gettotalbytesread
requestheader header   requestheader newbuilder   mergefrom buf  offset  headersize  build
offset    headersize
int id   header getcallid
if  log istraceenabled
log trace     textformat shortdebugstring header
totalrequestsize
// enforcing the call queue size, this triggers a retry in the client
// this is a bit late to be doing this check - we have already read in the total request.
if   totalrequestsize   callqueuesize get    > maxqueuesize
final call calltoobig
new call id  this service  null  null  null  this
responder  totalrequestsize  null  null
bytearrayoutputstream responsebuffer   new bytearrayoutputstream
setupresponse responsebuffer  calltoobig  new callqueuetoobigexception
responder dorespond calltoobig
return
methoddescriptor md   null
message param   null
cellscanner cellscanner   null
string effectiveuser   null
try
if  header hasrequestparam      header getrequestparam
md   this service getdescriptorfortype   findmethodbyname header getmethodname
builder builder   this service getrequestprototype md  newbuilderfortype
// to read the varint, i need an inputstream; might as well be a cis.
cis   codedinputstream newinstance buf  offset  buf length
int paramsize   cis readrawvarint32
offset    cis gettotalbytesread
if  builder    null
param   builder mergefrom buf  offset  paramsize  build
offset    paramsize
if  header hascellblockmeta
cellscanner   ipcutil createcellscanner this codec  this compressioncodec
buf  offset  buf length
if  header haseffectiveuser
effectiveuser   header geteffectiveuser
catch  throwable t
string msg       gethostaddress
log warn msg  t
final call readparamsfailedcall
new call id  this service  null  null  null  this
responder  totalrequestsize  null  null
bytearrayoutputstream responsebuffer   new bytearrayoutputstream
setupresponse responsebuffer  readparamsfailedcall  t
msg       t getmessage
responder dorespond readparamsfailedcall
return
call call   null
if  header hastraceinfo
call   new call id  this service  md  param  cellscanner  this
responder  totalrequestsize  new traceinfo header gettraceinfo   gettraceid
header gettraceinfo   getparentid     effectiveuser
else
call   new call id  this service  md  param  cellscanner  this  responder
totalrequestsize  null  effectiveuser
callqueuesize add totalrequestsize
pair<requestheader  message> headerandparam
new pair<requestheader  message> header  param
if  prioritycallqueue    null    getqoslevel headerandparam  > highprioritylevel
prioritycallqueue put call
else if  replicationqueue    null
getqoslevel headerandparam     hconstants replication_qos
replicationqueue put call
else
callqueue put call                   queue the call  maybe blocked here
private boolean authorizeconnection   throws ioexception
try
// if auth method is digest, the token was obtained by the
// real user for the effective user, therefore not required to
// authorize real user. doas is allowed only for simple or kerberos
// authentication
if  user    null    user getrealuser      null
authmethod    authmethod digest
proxyusers authorize user  this gethostaddress    conf
authorize user  connectionheader  gethostinetaddress
if  log isdebugenabled
log debug     textformat shortdebugstring connectionheader
metrics authorizationsuccess
catch  authorizationexception ae
log debug     ae getmessage    ae
metrics authorizationfailure
setupresponse authfailedresponse  authfailedcall  ae  ae getmessage
responder dorespond authfailedcall
return false
return true
protected synchronized void close
disposesasl
data   null
this datalengthbuffer   null
if   channel isopen
return
try  socket shutdownoutput     catch exception ignored        findbugs de_might_ignore
if  channel isopen
try  channel close     catch exception ignored
try  socket close     catch exception ignored
private usergroupinformation createuser connectionheader head
usergroupinformation ugi   null
if   head hasuserinfo
return null
userinformation userinfoproto   head getuserinfo
string effectiveuser   null
if  userinfoproto haseffectiveuser
effectiveuser   userinfoproto geteffectiveuser
string realuser   null
if  userinfoproto hasrealuser
realuser   userinfoproto getrealuser
if  effectiveuser    null
if  realuser    null
usergroupinformation realuserugi
usergroupinformation createremoteuser realuser
ugi   usergroupinformation createproxyuser effectiveuser  realuserugi
else
ugi   usergroupinformation createremoteuser effectiveuser
return ugi
/** handles queued calls . */
private class handler extends thread
private final blockingqueue<call> mycallqueue
private monitoredrpchandler status
public handler final blockingqueue<call> cq  int instancenumber
this mycallqueue   cq
this setdaemon true
string threadname       instancenumber       port
if  cq    prioritycallqueue
// this is just an amazing hack, but it works.
threadname       threadname
else if  cq    replicationqueue
threadname       threadname
this setname threadname
this status   taskmonitor get   createrpcstatus threadname
@override
public void run
log info getname
status setstatus
server set rpcserver this
while  running
try
status pause
call call   mycallqueue take       pop the queue  maybe blocked here
status setstatus
status setconnection call connection gethostaddress    call connection getremoteport
if  log isdebugenabled
usergroupinformation remoteuser   call connection user
log debug call toshortstring
remoteuser    null ?    remoteuser getusername
throwable errorthrowable   null
string error   null
pair<message  cellscanner> resultpair   null
curcall set call
tracescope tracescope   null
try
if   started
throw new servernotrunningyetexception
if  call tinfo    null
tracescope   trace startspan call totracestring    call tinfo
user user
if  call effectiveuser    null
user   user create call connection user
else
usergroupinformation ugi   usergroupinformation createproxyuser
call effectiveuser  call connection user
proxyusers authorize ugi  call connection gethostaddress    conf
if  log isdebugenabled
log debug     call connection user
call effectiveuser
user   user create ugi
requestcontext set user  getremoteip    call connection service
// make the call
resultpair   call call service  call md  call param  call cellscanner  call timestamp
status
catch  throwable e
log debug getname         call toshortstring    e
errorthrowable   e
error   stringutils stringifyexception e
finally
if  tracescope    null
tracescope close
// must always clear the request context to avoid leaking
// credentials between requests.
requestcontext clear
curcall set null
callqueuesize add call getsize      1
// set the response for undelayed calls and delayed calls with
// undelayed responses.
if   call isdelayed       call isreturnvaluedelayed
message param   resultpair    null? resultpair getfirst    null
cellscanner cells   resultpair    null? resultpair getsecond    null
call setresponse param  cells  errorthrowable  error
call sendresponseifready
status markcomplete
catch  interruptedexception e
if  running                                unexpected    log it
log info getname         stringutils stringifyexception e
catch  outofmemoryerror e
if  errorhandler    null
if  errorhandler checkoome e
log info getname
return
else
// rethrow if no handler
throw e
catch  closedchannelexception cce
log warn getname
cce getmessage
catch  exception e
log warn getname         stringutils stringifyexception e
log info getname
/**
* datastructure for passing a {@link blockingservice} and its associated class of
* protobuf service interface.  for example, a server that fielded what is defined
* in the client protobuf service would pass in an implementation of the client blocking service
* and then its clientservice.blockinginterface.class.  used checking connection setup.
*/
public static class blockingserviceandinterface
private final blockingservice service
private final class<?> serviceinterface
public blockingserviceandinterface final blockingservice service
final class<?> serviceinterface
this service   service
this serviceinterface   serviceinterface
public class<?> getserviceinterface
return this serviceinterface
public blockingservice getblockingservice
return this service
/**
* minimal setup.  used by tests mostly.
* @param service
* @param isa
* @param conf
* @throws ioexception
*/
public rpcserver final blockingservice service  final inetsocketaddress isa
final configuration conf
throws ioexception
this null     lists newarraylist new blockingserviceandinterface service  null
isa  3  3  conf
hconstants qos_threshold
/**
* constructs a server listening on the named port and address.
* @param serverinstance hosting instance of {@link server}. we will do authentications if an
* instance else pass null for no authentication check.
* @param name used keying this rpc servers' metrics and for naming the listener thread.
* @param services a list of services.
* @param isa where to listen
* @param handlercount the number of handler threads that will be used to process calls
* @param priorityhandlercount how many threads for priority handling.
* @param conf
* @param highprioritylevel
* @throws ioexception
*/
public rpcserver final server serverinstance  final string name
final list<blockingserviceandinterface> services
final inetsocketaddress isa  int handlercount  int priorityhandlercount  configuration conf
int highprioritylevel
throws ioexception
this serverinstance   serverinstance
this services   services
this isa   isa
this conf   conf
this handlercount   handlercount
this priorityhandlercount   priorityhandlercount
this socketsendbuffersize   0
this maxqueuelength   this conf getint
handlercount   default_max_callqueue_length_per_handler
this maxqueuesize
this conf getint    default_max_callqueue_size
this readthreads   conf getint    10
this callqueue    new linkedblockingqueue<call> maxqueuelength
if  priorityhandlercount > 0
this prioritycallqueue   new linkedblockingqueue<call> maxqueuelength      todo hack on size
else
this prioritycallqueue   null
this highprioritylevel   highprioritylevel
this maxidletime   2 conf getint    1000
this maxconnectionstonuke   conf getint    10
this thresholdidleconnections   conf getint    4000
this purgetimeout   conf getlong
2   hconstants default_hbase_rpc_timeout
this numofreplicationhandlers   conf getint    3
if  numofreplicationhandlers > 0
this replicationqueue   new linkedblockingqueue<call> maxqueuesize
this warnresponsetime   conf getint warn_response_time  default_warn_response_time
this warnresponsesize   conf getint warn_response_size  default_warn_response_size
// start the listener here and let it bind to the port
listener   new listener name
this port   listener getaddress   getport
this metrics   new metricshbaseserver name  new metricshbaseserverwrapperimpl this
this tcpnodelay   conf getboolean    true
this tcpkeepalive   conf getboolean    true
this warndelayedcalls   conf getint warn_delayed_calls  default_warn_delayed_calls
this delayedcalls   new atomicinteger 0
this ipcutil   new ipcutil conf
// create the responder here
responder   new responder
this authorize   conf getboolean hadoop_security_authorization  false
this issecurityenabled   user ishbasesecurityenabled this conf
if  issecurityenabled
hbasesaslrpcserver init conf
/**
* subclasses of hbaseserver can override this to provide their own
* connection implementations.
*/
protected connection getconnection socketchannel channel  long time
return new connection channel  time
/**
* setup response for the rpc call.
*
* @param response buffer to serialize the response into
* @param call {@link call} to which we are setting up the response
* @param error error message, if the call failed
* @param t
* @throws ioexception
*/
private void setupresponse bytearrayoutputstream response  call call  throwable t  string error
throws ioexception
if  response    null  response reset
call setresponse null  null  t  error
protected void closeconnection connection connection
synchronized  connectionlist
if  connectionlist remove connection
numconnections
connection close
configuration getconf
return conf
/** sets the socket buffer size used for responding to rpcs.
* @param size send size
*/
@override
public void setsocketsendbufsize int size    this socketsendbuffersize   size
/** starts the service.  must be called before any calls will be handled. */
@override
public void start
startthreads
openserver
/**
* open a previously started server.
*/
@override
public void openserver
started   true
/**
* starts the service threads but does not allow requests to be responded yet.
* client will get {@link servernotrunningyetexception} instead.
*/
@override
public synchronized void startthreads
authenticationtokensecretmanager mgr   createsecretmanager
if  mgr    null
setsecretmanager mgr
mgr start
this authmanager   new serviceauthorizationmanager
hbasepolicyprovider init conf  authmanager
responder start
listener start
handlers   starthandlers callqueue  handlercount
priorityhandlers   starthandlers prioritycallqueue  priorityhandlercount
replicationhandlers   starthandlers replicationqueue  numofreplicationhandlers
@override
public void refreshauthmanager policyprovider pp
this authmanager refresh this conf  pp
private handler starthandlers blockingqueue<call> queue  int numofhandlers
if  numofhandlers <  0
return null
handler handlers   new handler
for  int i   0  i < numofhandlers  i
handlers   new handler queue  i
handlers start
return handlers
private authenticationtokensecretmanager createsecretmanager
if   issecurityenabled  return null
if  serverinstance    null  return null
if    serverinstance instanceof org apache hadoop hbase server   return null
org apache hadoop hbase server server    org apache hadoop hbase server serverinstance
configuration conf   server getconfiguration
long keyupdateinterval
conf getlong    24 60 60 1000
long maxage
conf getlong    7 24 60 60 1000
return new authenticationtokensecretmanager conf  server getzookeeper
server getservername   tostring    keyupdateinterval  maxage
public secretmanager<? extends tokenidentifier> getsecretmanager
return this secretmanager
@suppresswarnings
public void setsecretmanager secretmanager<? extends tokenidentifier> secretmanager
this secretmanager    secretmanager<tokenidentifier>  secretmanager
/**
* this is a server side method, which is invoked over rpc. on success
* the return response has protobuf response payload. on failure, the
* exception name and the stack trace are returned in the protobuf response.
*/
public pair<message  cellscanner> call blockingservice service  methoddescriptor md
message param  cellscanner cellscanner  long receivetime  monitoredrpchandler status
throws ioexception
try
status setrpc md getname    new object param   receivetime
// todo: review after we add in encoded data blocks.
status setrpcpacket param
status resume
//get an instance of the method arg type
long starttime   system currenttimemillis
payloadcarryingrpccontroller controller   new payloadcarryingrpccontroller cellscanner
message result   service callblockingmethod md  controller  param
int processingtime    int   system currenttimemillis     starttime
int qtime    int   starttime   receivetime
if  log istraceenabled
log trace curcall get   tostring
textformat shortdebugstring result
qtime
processingtime
metrics dequeuedcall qtime
metrics processedcall processingtime
long responsesize   result getserializedsize
// log any rpc responses that are slower than the configured warn
// response time or larger than configured warning size
boolean tooslow    processingtime > warnresponsetime    warnresponsetime >  1
boolean toolarge    responsesize > warnresponsesize    warnresponsesize >  1
if  tooslow    toolarge
// when tagging, we let toolarge trump toosmall to keep output simple
// note that large responses will often also be slow.
stringbuilder buffer   new stringbuilder 256
buffer append md getname
buffer append
buffer append param getclass   getname
buffer append
logresponse new object param
md getname    buffer tostring     toolarge ?
status getclient    starttime  processingtime  qtime
responsesize
return new pair<message  cellscanner> result
controller    null? controller cellscanner    null
catch  throwable e
// the above callblockingmethod will always return a se.  strip the se wrapper before
// putting it on the wire.  its needed to adhere to the pb service interface but we don't
// need to pass it over the wire.
if  e instanceof serviceexception  e   e getcause
if  e instanceof ioexception  throw  ioexception e
log error    e
throw new ioexception e getmessage    e
/**
* logs an rpc response to the log file, producing valid json objects for
* client operations.
* @param params the parameters received in the call.
* @param methodname the name of the method invoked
* @param call the string representation of the call
* @param tag  the tag that will be used to indicate this event in the log.
* @param clientaddress   the address of the client who made this call.
* @param starttime       the time that the call was initiated, in ms.
* @param processingtime  the duration that the call took to run, in ms.
* @param qtime           the duration that the call spent on the queue
*                        prior to being initiated, in ms.
* @param responsesize    the size in bytes of the response buffer.
*/
void logresponse object params  string methodname  string call  string tag
string clientaddress  long starttime  int processingtime  int qtime
long responsesize
throws ioexception
// base information that is reported regardless of type of call
map<string  object> responseinfo   new hashmap<string  object>
responseinfo put    starttime
responseinfo put    processingtime
responseinfo put    qtime
responseinfo put    responsesize
responseinfo put    clientaddress
responseinfo put    serverinstance    null?    serverinstance getclass   getsimplename
responseinfo put    methodname
if  params length    2    serverinstance instanceof hregionserver
params instanceof byte
params instanceof operation
// if the slow process is a query, we want to log its table as well
// as its own fingerprint
tablename tablename   tablename valueof
hregioninfo parseregionname  byte  params
responseinfo put    tablename getnameasstring
// annotate the response map with operation details
responseinfo putall   operation  params  tomap
// report to the log file
log warn     tag
mapper writevalueasstring responseinfo
else if  params length    1    serverinstance instanceof hregionserver
params instanceof operation
// annotate the response map with operation details
responseinfo putall   operation  params  tomap
// report to the log file
log warn     tag
mapper writevalueasstring responseinfo
else
// can't get json details, so just report call.tostring() along with
// a more generic tag.
responseinfo put    call
log warn     tag       mapper writevalueasstring responseinfo
/** stops the service.  no new calls will be handled after this is called. */
@override
public synchronized void stop
log info     port
running   false
stophandlers handlers
stophandlers priorityhandlers
stophandlers replicationhandlers
listener interrupt
listener dostop
responder interrupt
notifyall
private void stophandlers handler handlers
if  handlers    null
for  handler handler   handlers
if  handler    null
handler interrupt
/** wait for the server to be stopped.
* does not wait for all subthreads to finish.
*  see {@link #stop()}.
* @throws interruptedexception e
*/
@override
public synchronized void join   throws interruptedexception
while  running
wait
/**
* return the socket (ip+port) on which the rpc server is listening to.
* @return the socket (ip+port) on which the rpc server is listening to.
*/
@override
public synchronized inetsocketaddress getlisteneraddress
return listener getaddress
/**
* set the handler for calling out of rpc for error conditions.
* @param handler the handler implementation
*/
@override
public void seterrorhandler hbaserpcerrorhandler handler
this errorhandler   handler
/**
* returns the metrics instance for reporting rpc call statistics
*/
public metricshbaseserver getmetrics
return metrics
/**
* authorize the incoming client connection.
*
* @param user client user
* @param connection incoming connection
* @param addr inetaddress of incoming connection
* @throws org.apache.hadoop.security.authorize.authorizationexception when the client isn't authorized to talk the protocol
*/
@suppresswarnings
public void authorize usergroupinformation user  connectionheader connection  inetaddress addr
throws authorizationexception
if  authorize
class<?> c   getserviceinterface services  connection getservicename
this authmanager authorize user    null ? user   null  c  getconf    addr
/**
* when the read or write buffer size is larger than this limit, i/o will be
* done in chunks of this size. most rpc requests and responses would be
* be smaller.
*/
private static int nio_buffer_limit   64   1024    should not be more than 64kb
/**
* this is a wrapper around {@link java.nio.channels.writablebytechannel#write(java.nio.bytebuffer)}.
* if the amount of data is large, it writes to channel in smaller chunks.
* this is to avoid jdk from creating many direct buffers as the size of
* buffer increases. this also minimizes extra copies in nio layer
* as a result of multiple write operations required to write a large
* buffer.
*
* @param channel writable byte channel to write to
* @param buffer buffer to write
* @return number of bytes written
* @throws java.io.ioexception e
* @see java.nio.channels.writablebytechannel#write(java.nio.bytebuffer)
*/
protected int channelwrite writablebytechannel channel
bytebuffer buffer  throws ioexception
int count     buffer remaining   <  nio_buffer_limit  ?
channel write buffer    channelio null  channel  buffer
if  count > 0
metrics sentbytes count
return count
/**
* this is a wrapper around {@link java.nio.channels.readablebytechannel#read(java.nio.bytebuffer)}.
* if the amount of data is large, it writes to channel in smaller chunks.
* this is to avoid jdk from creating many direct buffers as the size of
* bytebuffer increases. there should not be any performance degredation.
*
* @param channel writable byte channel to write on
* @param buffer buffer to write
* @return number of bytes written
* @throws java.io.ioexception e
* @see java.nio.channels.readablebytechannel#read(java.nio.bytebuffer)
*/
protected int channelread readablebytechannel channel
bytebuffer buffer  throws ioexception
int count    buffer remaining   <  nio_buffer_limit  ?
channel read buffer    channelio channel  null  buffer
if  count > 0
metrics receivedbytes count
return count
/**
* helper for {@link #channelread(java.nio.channels.readablebytechannel, java.nio.bytebuffer)}
* and {@link #channelwrite(java.nio.channels.writablebytechannel, java.nio.bytebuffer)}. only
* one of readch or writech should be non-null.
*
* @param readch read channel
* @param writech write channel
* @param buf buffer to read or write into/out of
* @return bytes written
* @throws java.io.ioexception e
* @see #channelread(java.nio.channels.readablebytechannel, java.nio.bytebuffer)
* @see #channelwrite(java.nio.channels.writablebytechannel, java.nio.bytebuffer)
*/
private static int channelio readablebytechannel readch
writablebytechannel writech
bytebuffer buf  throws ioexception
int originallimit   buf limit
int initialremaining   buf remaining
int ret   0
while  buf remaining   > 0
try
int iosize   math min buf remaining    nio_buffer_limit
buf limit buf position     iosize
ret    readch    null  ? writech write buf    readch read buf
if  ret < iosize
break
finally
buf limit originallimit
int nbytes   initialremaining   buf remaining
return  nbytes > 0  ? nbytes   ret
/**
* needed for delayed calls.  we need to be able to store the current call
* so that we can complete it later.
* @return call the server is currently handling.
*/
public static rpccallcontext getcurrentcall
return curcall get
/**
* @param servicename some arbitrary string that represents a 'service'.
* @param services available service instances
* @return matching blockingserviceandinterface pair
*/
static blockingserviceandinterface getserviceandinterface
final list<blockingserviceandinterface> services  final string servicename
for  blockingserviceandinterface bs   services
if  bs getblockingservice   getdescriptorfortype   getname   equals servicename
return bs
return null
/**
* @param servicename some arbitrary string that represents a 'service'.
* @param services available services and their service interfaces.
* @return service interface class for <code>servicename</code>
*/
static class<?> getserviceinterface
final list<blockingserviceandinterface> services
final string servicename
blockingserviceandinterface bsasi
getserviceandinterface services  servicename
return bsasi    null? null  bsasi getserviceinterface
/**
* @param servicename some arbitrary string that represents a 'service'.
* @param services available services and their service interfaces.
* @return blockingservice that goes with the passed <code>servicename</code>
*/
static blockingservice getservice
final list<blockingserviceandinterface> services
final string servicename
blockingserviceandinterface bsasi
getserviceandinterface services  servicename
return bsasi    null? null  bsasi getblockingservice
/** returns the remote side ip address when invoked inside an rpc
*  returns null incase of an error.
*  @return inetaddress
*/
public static inetaddress getremoteip
call call   curcall get
if  call    null
return call connection socket getinetaddress
return null
/** returns remote address as a string when invoked inside an rpc.
*  returns null in case of an error.
*  @return string
*/
public static string getremoteaddress
call call   curcall get
if  call    null
return call connection gethostaddress
return null
/**
* may be called under
* {@code #call(class, rpcrequestbody, long, monitoredrpchandler)} implementations,
* and under protobuf methods of parameters and return values.
* permits applications to access the server context.
* @return the server instance called under or null
*/
public static rpcserverinterface get
return server get
/**
* a convenience method to bind to a given address and report
* better exceptions if the address is not a valid host.
* @param socket the socket to bind
* @param address the address to bind to
* @param backlog the number of connections allowed in the queue
* @throws bindexception if the address can't be bound
* @throws unknownhostexception if the address isn't a valid host name
* @throws ioexception other random errors from bind
*/
public static void bind serversocket socket  inetsocketaddress address
int backlog  throws ioexception
try
socket bind address  backlog
catch  bindexception e
bindexception bindexception
new bindexception     address
e getmessage
bindexception initcause e
throw bindexception
catch  socketexception e
// if they try to bind to a different host's address, give a better
// error message.
if    equals e getmessage
throw new unknownhostexception
address gethostname
throw e