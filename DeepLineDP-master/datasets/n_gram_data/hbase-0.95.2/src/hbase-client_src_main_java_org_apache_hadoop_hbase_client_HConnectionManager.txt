/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import java io closeable
import java io ioexception
import java lang reflect constructor
import java lang reflect undeclaredthrowableexception
import java net socketexception
import java util arraylist
import java util hashmap
import java util hashset
import java util linkedhashmap
import java util list
import java util map
import java util map entry
import java util navigablemap
import java util set
import java util concurrent concurrenthashmap
import java util concurrent concurrentmap
import java util concurrent copyonwritearrayset
import java util concurrent executorservice
import java util concurrent synchronousqueue
import java util concurrent threadpoolexecutor
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomicinteger
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import org apache hadoop conf configuration
import org apache hadoop hbase chore
import org apache hadoop hbase tablename
import org apache hadoop hbase donotretryioexception
import org apache hadoop hbase hbaseconfiguration
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase hregionlocation
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase keyvalue
import org apache hadoop hbase masternotrunningexception
import org apache hadoop hbase servername
import org apache hadoop hbase stoppable
import org apache hadoop hbase tablenotfoundexception
import org apache hadoop hbase zookeeperconnectionexception
import org apache hadoop hbase client metascanner metascannervisitor
import org apache hadoop hbase client metascanner metascannervisitorbase
import org apache hadoop hbase client coprocessor batch
import org apache hadoop hbase exceptions regionmovedexception
import org apache hadoop hbase exceptions regionopeningexception
import org apache hadoop hbase ipc rpcclient
import org apache hadoop hbase protobuf protobufutil
import org apache hadoop hbase protobuf requestconverter
import org apache hadoop hbase protobuf generated adminprotos adminservice
import org apache hadoop hbase protobuf generated clientprotos clientservice
import org apache hadoop hbase protobuf generated clientprotos coprocessorservicerequest
import org apache hadoop hbase protobuf generated clientprotos coprocessorserviceresponse
import org apache hadoop hbase protobuf generated masteradminprotos modifynamespaceresponse
import org apache hadoop hbase protobuf generated masteradminprotos modifynamespacerequest
import org apache hadoop hbase protobuf generated masteradminprotos createnamespaceresponse
import org apache hadoop hbase protobuf generated masteradminprotos createnamespacerequest
import org apache hadoop hbase protobuf generated masteradminprotos deletenamespaceresponse
import org apache hadoop hbase protobuf generated masteradminprotos deletenamespacerequest
import org apache hadoop hbase protobuf generated masteradminprotos getnamespacedescriptorresponse
import org apache hadoop hbase protobuf generated masteradminprotos getnamespacedescriptorrequest
import org apache hadoop hbase protobuf generated masteradminprotos
listnamespacedescriptorsresponse
import org apache hadoop hbase protobuf generated masteradminprotos
listnamespacedescriptorsrequest
import org apache hadoop hbase protobuf generated masteradminprotos
listtabledescriptorsbynamespaceresponse
import org apache hadoop hbase protobuf generated masteradminprotos
listtabledescriptorsbynamespacerequest
import org apache hadoop hbase protobuf generated masteradminprotos
listtablenamesbynamespaceresponse
import org apache hadoop hbase protobuf generated masteradminprotos
listtablenamesbynamespacerequest
import org apache hadoop hbase protobuf generated masteradminprotos addcolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos addcolumnresponse
import org apache hadoop hbase protobuf generated masteradminprotos assignregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos assignregionresponse
import org apache hadoop hbase protobuf generated masteradminprotos balancerequest
import org apache hadoop hbase protobuf generated masteradminprotos balanceresponse
import org apache hadoop hbase protobuf generated masteradminprotos catalogscanrequest
import org apache hadoop hbase protobuf generated masteradminprotos catalogscanresponse
import org apache hadoop hbase protobuf generated masteradminprotos createtablerequest
import org apache hadoop hbase protobuf generated masteradminprotos createtableresponse
import org apache hadoop hbase protobuf generated masteradminprotos deletecolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos deletecolumnresponse
import org apache hadoop hbase protobuf generated masteradminprotos deletesnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos deletesnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos deletetablerequest
import org apache hadoop hbase protobuf generated masteradminprotos deletetableresponse
import org apache hadoop hbase protobuf generated masteradminprotos disabletablerequest
import org apache hadoop hbase protobuf generated masteradminprotos disabletableresponse
import org apache hadoop hbase protobuf generated masteradminprotos dispatchmergingregionsrequest
import org apache hadoop hbase protobuf generated masteradminprotos dispatchmergingregionsresponse
import org apache hadoop hbase protobuf generated masteradminprotos enablecatalogjanitorrequest
import org apache hadoop hbase protobuf generated masteradminprotos enablecatalogjanitorresponse
import org apache hadoop hbase protobuf generated masteradminprotos enabletablerequest
import org apache hadoop hbase protobuf generated masteradminprotos enabletableresponse
import org apache hadoop hbase protobuf generated masteradminprotos iscatalogjanitorenabledrequest
import org apache hadoop hbase protobuf generated masteradminprotos iscatalogjanitorenabledresponse
import org apache hadoop hbase protobuf generated masteradminprotos isrestoresnapshotdonerequest
import org apache hadoop hbase protobuf generated masteradminprotos isrestoresnapshotdoneresponse
import org apache hadoop hbase protobuf generated masteradminprotos issnapshotdonerequest
import org apache hadoop hbase protobuf generated masteradminprotos issnapshotdoneresponse
import org apache hadoop hbase protobuf generated masteradminprotos listsnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos listsnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos masteradminservice
import org apache hadoop hbase protobuf generated masteradminprotos modifycolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos modifycolumnresponse
import org apache hadoop hbase protobuf generated masteradminprotos modifytablerequest
import org apache hadoop hbase protobuf generated masteradminprotos modifytableresponse
import org apache hadoop hbase protobuf generated masteradminprotos moveregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos moveregionresponse
import org apache hadoop hbase protobuf generated masteradminprotos offlineregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos offlineregionresponse
import org apache hadoop hbase protobuf generated masteradminprotos restoresnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos restoresnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos setbalancerrunningrequest
import org apache hadoop hbase protobuf generated masteradminprotos setbalancerrunningresponse
import org apache hadoop hbase protobuf generated masteradminprotos shutdownrequest
import org apache hadoop hbase protobuf generated masteradminprotos shutdownresponse
import org apache hadoop hbase protobuf generated masteradminprotos stopmasterrequest
import org apache hadoop hbase protobuf generated masteradminprotos stopmasterresponse
import org apache hadoop hbase protobuf generated masteradminprotos takesnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos takesnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos unassignregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos unassignregionresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos getclusterstatusrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos getclusterstatusresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos getschemaalterstatusrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos getschemaalterstatusresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos gettabledescriptorsrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos gettabledescriptorsresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos gettablenamesrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos gettablenamesresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos mastermonitorservice
import org apache hadoop hbase protobuf generated masterprotos
import org apache hadoop hbase protobuf generated masterprotos ismasterrunningrequest
import org apache hadoop hbase protobuf generated masterprotos ismasterrunningresponse
import org apache hadoop hbase regionserver regionserverstoppedexception
import org apache hadoop hbase security user
import org apache hadoop hbase util bytes
import org apache hadoop hbase util environmentedgemanager
import org apache hadoop hbase util softvaluesortedmap
import org apache hadoop hbase util threads
import org apache hadoop hbase zookeeper masteraddresstracker
import org apache hadoop hbase zookeeper zkutil
import org apache hadoop hbase zookeeper zookeeperwatcher
import org apache hadoop ipc remoteexception
import org apache zookeeper keeperexception
import com google protobuf blockingrpcchannel
import com google protobuf rpccontroller
import com google protobuf serviceexception
/**
* a non-instantiable class that manages creation of {@link hconnection}s.
* <p>the simplest way to use this class is by using {@link #createconnection(configuration)}.
* this creates a new {@link hconnection} that is managed by the caller.
* from this {@link hconnection} {@link htableinterface} implementations are retrieved
* with {@link hconnection#gettable(byte[])}. example:
* <pre>
* {@code
* hconnection connection = hconnectionmanager.createconnection(config);
* htableinterface table = connection.gettable("table1");
* // use the table as needed, for a single operation and a single thread
* table.close();
* connection.close();
* }
* </pre>
* <p>the following logic and api will be removed in the future:
* <p>this class has a static map of {@link hconnection} instances keyed by
* {@link configuration}; all invocations of {@link #getconnection(configuration)}
* that pass the same {@link configuration} instance will be returned the same
* {@link  hconnection} instance (adding properties to a configuration
* instance does not change its object identity; for more on how this is done see
* {@link hconnectionkey}).  sharing {@link hconnection}
* instances is usually what you want; all clients of the {@link hconnection}
* instances share the hconnections' cache of region locations rather than each
* having to discover for itself the location of meta, etc.  it makes
* sense for the likes of the pool of htables class {@link htablepool}, for
* instance (if concerned that a single {@link hconnection} is insufficient
* for sharing amongst clients in say an heavily-multithreaded environment,
* in practise its not proven to be an issue.  besides, {@link hconnection} is
* implemented atop hadoop rpc and as of this writing, hadoop rpc does a
* connection per cluster-member, exclusively).
*
* <p>but sharing connections makes clean up of {@link hconnection} instances a little awkward.
* currently, clients cleanup by calling {@link #deleteconnection(configuration)}. this will
* shutdown the zookeeper connection the hconnection was using and clean up all
* hconnection resources as well as stopping proxies to servers out on the
* cluster. not running the cleanup will not end the world; it'll
* just stall the closeup some and spew some zookeeper connection failed
* messages into the log.  running the cleanup on a {@link hconnection} that is
* subsequently used by another will cause breakage so be careful running
* cleanup.
* <p>to create a {@link hconnection} that is not shared by others, you can
* create a new {@link configuration} instance, pass this new instance to
* {@link #getconnection(configuration)}, and then when done, close it up by
* doing something like the following:
* <pre>
* {@code
* configuration newconfig = new configuration(originalconf);
* hconnection connection = hconnectionmanager.getconnection(newconfig);
* // use the connection to your hearts' delight and then when done...
* hconnectionmanager.deleteconnection(newconfig, true);
* }
* </pre>
* <p>cleanup used to be done inside in a shutdown hook.  on startup we'd
* register a shutdown hook that called {@link #deleteallconnections()}
* on its way out but the order in which shutdown hooks run is not defined so
* were problematic for clients of hconnection that wanted to register their
* own shutdown hooks so we removed ours though this shifts the onus for
* cleanup to the client.
*/
@suppresswarnings
@interfaceaudience public
@interfacestability evolving
public class hconnectionmanager
static final log log   logfactory getlog hconnectionmanager class
public static final string retries_by_server_key
// an lru map of hconnectionkey -> hconnection (tableserver).  all
// access must be synchronized.  this map is not private because tests
// need to be able to tinker with it.
static final map<hconnectionkey  hconnectionimplementation> connection_instances
public static final int max_cached_connection_instances
static
// we set instances to one more than the value specified for {@link
// hconstants#zookeeper_max_client_cnxns}. by default, the zk default max
// connections to the ensemble from the one client is 30, so in that case we
// should run into zk issues before the lru hit this value of 31.
max_cached_connection_instances   hbaseconfiguration create   getint
hconstants zookeeper_max_client_cnxns  hconstants default_zookeper_max_client_cnxns    1
connection_instances   new linkedhashmap<hconnectionkey  hconnectionimplementation>
int   max_cached_connection_instances   0 75f    1  0 75f  true
@override
protected boolean removeeldestentry
map entry<hconnectionkey  hconnectionimplementation> eldest
return size   > max_cached_connection_instances
/*
* non-instantiable.
*/
private hconnectionmanager
super
/**
* get the connection that goes with the passed <code>conf</code> configuration instance.
* if no current connection exists, method creates a new connection and keys it using
* connection-specific properties from the passed {@link configuration}; see
* {@link hconnectionkey}.
* @param conf configuration
* @return hconnection object for <code>conf</code>
* @throws zookeeperconnectionexception
*/
@deprecated
@suppresswarnings
public static hconnection getconnection final configuration conf
throws ioexception
hconnectionkey connectionkey   new hconnectionkey conf
synchronized  connection_instances
hconnectionimplementation connection   connection_instances get connectionkey
if  connection    null
connection    hconnectionimplementation createconnection conf  true
connection_instances put connectionkey  connection
else if  connection isclosed
hconnectionmanager deleteconnection connectionkey  true
connection    hconnectionimplementation createconnection conf  true
connection_instances put connectionkey  connection
connection inccount
return connection
/**
* create a new hconnection instance using the passed <code>conf</code> instance.
* <p>note: this bypasses the usual hconnection life cycle management done by
* {@link #getconnection(configuration)}. the caller is responsible for
* calling {@link hconnection#close()} on the returned connection instance.
*
* this is the recommended way to create hconnections.
* {@code
* hconnection connection = hconnectionmanager.createconnection(conf);
* htableinterface table = connection.gettable("mytable");
* table.get(...);
* ...
* table.close();
* connection.close();
* }
*
* @param conf configuration
* @return hconnection object for <code>conf</code>
* @throws zookeeperconnectionexception
*/
public static hconnection createconnection configuration conf
throws ioexception
return createconnection conf  false  null
/**
* create a new hconnection instance using the passed <code>conf</code> instance.
* <p>note: this bypasses the usual hconnection life cycle management done by
* {@link #getconnection(configuration)}. the caller is responsible for
* calling {@link hconnection#close()} on the returned connection instance.
* this is the recommended way to create hconnections.
* {@code
* executorservice pool = ...;
* hconnection connection = hconnectionmanager.createconnection(conf, pool);
* htableinterface table = connection.gettable("mytable");
* table.get(...);
* ...
* table.close();
* connection.close();
* }
* @param conf configuration
* @param pool the thread pool to use for batch operation in htables used via this hconnection
* @return hconnection object for <code>conf</code>
* @throws zookeeperconnectionexception
*/
public static hconnection createconnection configuration conf  executorservice pool
throws ioexception
return createconnection conf  false  pool
@deprecated
static hconnection createconnection final configuration conf  final boolean managed
throws ioexception
return createconnection conf  managed  null
@deprecated
static hconnection createconnection final configuration conf  final boolean managed  final executorservice pool
throws ioexception
string classname   conf get
hconnectionmanager hconnectionimplementation class getname
class<?> clazz   null
try
clazz   class forname classname
catch  classnotfoundexception e
throw new ioexception e
try
// default hcm#hci is not accessible; make it so before invoking.
constructor<?> constructor
clazz getdeclaredconstructor configuration class  boolean class  executorservice class
constructor setaccessible true
return  hconnection  constructor newinstance conf  managed  pool
catch  exception e
throw new ioexception e
/**
* delete connection information for the instance specified by passed configuration.
* if there are no more references to the designated connection connection, this method will
* then close connection to the zookeeper ensemble and let go of all associated resources.
*
* @param conf configuration whose identity is used to find {@link hconnection} instance.
* @deprecated
*/
public static void deleteconnection configuration conf
deleteconnection new hconnectionkey conf   false
/**
* cleanup a known stale connection.
* this will then close connection to the zookeeper ensemble and let go of all resources.
*
* @param connection
* @deprecated
*/
public static void deletestaleconnection hconnection connection
deleteconnection connection  true
/**
* delete information for all connections. close or not the connection, depending on the
*  staleconnection boolean and the ref count. by default, you should use it with
*  staleconnection to true.
* @deprecated
*/
public static void deleteallconnections boolean staleconnection
synchronized  connection_instances
set<hconnectionkey> connectionkeys   new hashset<hconnectionkey>
connectionkeys addall connection_instances keyset
for  hconnectionkey connectionkey   connectionkeys
deleteconnection connectionkey  staleconnection
connection_instances clear
/**
* delete information for all connections..
* @deprecated kept for backward compatibility, but the behavior is broken. hbase-8983
*/
@deprecated
public static void deleteallconnections
deleteallconnections false
@deprecated
private static void deleteconnection hconnection connection  boolean staleconnection
synchronized  connection_instances
for  entry<hconnectionkey  hconnectionimplementation> e  connection_instances entryset
if  e getvalue      connection
deleteconnection e getkey    staleconnection
break
@deprecated
private static void deleteconnection hconnectionkey connectionkey  boolean staleconnection
synchronized  connection_instances
hconnectionimplementation connection   connection_instances get connectionkey
if  connection    null
connection deccount
if  connection iszeroreference      staleconnection
connection_instances remove connectionkey
connection internalclose
else
log error
connectionkey      new exception
/**
* it is provided for unit test cases which verify the behavior of region
* location cache prefetch.
* @return number of cached regions for the table.
* @throws zookeeperconnectionexception
*/
static int getcachedregioncount configuration conf  final tablename tablename
throws ioexception
return execute new hconnectable<integer> conf
@override
public integer connect hconnection connection
return   hconnectionimplementation connection  getnumberofcachedregionlocations tablename
/**
* it's provided for unit test cases which verify the behavior of region
* location cache prefetch.
* @return true if the region where the table and row reside is cached.
* @throws zookeeperconnectionexception
*/
static boolean isregioncached configuration conf
final tablename tablename
final byte row
throws ioexception
return execute new hconnectable<boolean> conf
@override
public boolean connect hconnection connection
return   hconnectionimplementation  connection  isregioncached tablename  row
/**
* this convenience method invokes the given {@link hconnectable#connect}
* implementation using a {@link hconnection} instance that lasts just for the
* duration of the invocation.
*
* @param <t> the return type of the connect method
* @param connectable the {@link hconnectable} instance
* @return the value returned by the connect method
* @throws ioexception
*/
public static <t> t execute hconnectable<t> connectable  throws ioexception
if  connectable    null    connectable conf    null
return null
configuration conf   connectable conf
hconnection connection   hconnectionmanager getconnection conf
boolean connectsucceeded   false
try
t returnvalue   connectable connect connection
connectsucceeded   true
return returnvalue
finally
try
connection close
catch  exception e
if  connectsucceeded
throw new ioexception     connection
e
/** encapsulates connection to zookeeper and regionservers.*/
@edu umd cs findbugs annotations suppresswarnings
value
justification
static class hconnectionimplementation implements hconnection  closeable
static final log log   logfactory getlog hconnectionimplementation class
private final long pause
private final int numtries
final int rpctimeout
private final int prefetchregionlimit
private volatile boolean closed
private volatile boolean aborted
// package protected for the tests
clusterstatuslistener clusterstatuslistener
private final object userregionlock   new object
// we have a single lock for master & zk to prevent deadlocks. having
//  one lock for zk and one lock for master is not possible:
//  when creating a connection to master, we need a connection to zk to get
//  its address. but another thread could have taken the zk lock, and could
//  be waiting for the master lock => deadlock.
private final object masterandzklock   new object
private long keepzookeeperwatcheraliveuntil   long max_value
private final delayedclosing delayedclosing
delayedclosing createandstart this
// thread executor shared by all htableinterface instances created
// by this connection
private volatile executorservice batchpool   null
private volatile boolean cleanuppool   false
private final configuration conf
// client rpc instance.
private rpcclient rpcclient
/**
* map of table to table {@link hregionlocation}s.
*/
private final map<tablename  softvaluesortedmap<byte  hregionlocation>>
cachedregionlocations
new hashmap<tablename  softvaluesortedmap<byte  hregionlocation>>
// the presence of a server in the map implies it's likely that there is an
// entry in cachedregionlocations that map to this server; but the absence
// of a server in this map guarentees that there is no entry in cache that
// maps to the absent server.
// the access to this attribute must be protected by a lock on cachedregionlocations
private final set<servername> cachedservers   new hashset<servername>
// region cache prefetch is enabled by default. this set contains all
// tables whose region cache prefetch are disabled.
private final set<integer> regioncacheprefetchdisabledtables
new copyonwritearrayset<integer>
private int refcount
// indicates whether this connection's life cycle is managed (by us)
private boolean managed
/**
* cluster registry of basic info such as clusterid and meta region location.
*/
registry registry
hconnectionimplementation configuration conf  boolean managed  throws ioexception
this conf  managed  null
/**
* constructor
* @param conf configuration object
* @param managed if true, does not do full shutdown on close; i.e. cleanup of connection
* to zk and shutdown of all services; we just close down the resources this connection was
* responsible for and decrement usage counters.  it is up to the caller to do the full
* cleanup.  it is set when we want have connection sharing going on -- reuse of zk connection,
* and cached region locations, established regionserver connections, etc.  when connections
* are shared, we have reference counting going on and will only do full cleanup when no more
* users of an hconnectionimplementation instance.
*/
hconnectionimplementation configuration conf  boolean managed  executorservice pool  throws ioexception
this conf
this batchpool   pool
this managed   managed
this registry   setupregistry
retrieveclusterid
this rpcclient   new rpcclient this conf  this clusterid
// do we publish the status?
class<? extends clusterstatuslistener listener> listenerclass
conf getclass clusterstatuslistener status_listener_class
clusterstatuslistener default_status_listener_class
clusterstatuslistener listener class
if  listenerclass    null
clusterstatuslistener   new clusterstatuslistener
new clusterstatuslistener deadserverhandler
@override
public void newdead servername sn
clearcaches sn
rpcclient cancelconnections sn gethostname    sn getport
new socketexception sn getservername
conf  listenerclass
/**
* for tests.
*/
protected hconnectionimplementation configuration conf
this conf   conf
this closed   false
this pause   conf getlong hconstants hbase_client_pause
hconstants default_hbase_client_pause
this numtries   conf getint hconstants hbase_client_retries_number
hconstants default_hbase_client_retries_number
this rpctimeout   conf getint
hconstants hbase_rpc_timeout_key
hconstants default_hbase_rpc_timeout
this prefetchregionlimit   conf getint
hconstants hbase_client_prefetch_limit
hconstants default_hbase_client_prefetch_limit
@override
public htableinterface gettable string tablename  throws ioexception
return gettable tablename valueof tablename
@override
public htableinterface gettable byte tablename  throws ioexception
return gettable tablename valueof tablename
@override
public htableinterface gettable tablename tablename  throws ioexception
return gettable tablename  getbatchpool
@override
public htableinterface gettable string tablename  executorservice pool  throws ioexception
return gettable tablename valueof tablename   pool
@override
public htableinterface gettable byte tablename  executorservice pool  throws ioexception
return gettable tablename valueof tablename   pool
@override
public htableinterface gettable tablename tablename  executorservice pool  throws ioexception
if  managed
throw new ioexception
return new htable tablename  this  pool
private executorservice getbatchpool
if  batchpool    null
// shared htable thread executor not yet initialized
synchronized  this
if  batchpool    null
int maxthreads   conf getint
integer max_value
if  maxthreads    0
maxthreads   runtime getruntime   availableprocessors
long keepalivetime   conf getlong
60
this batchpool   new threadpoolexecutor
runtime getruntime   availableprocessors
maxthreads
keepalivetime
timeunit seconds
new synchronousqueue<runnable>
threads newdaemonthreadfactory
threadpoolexecutor  this batchpool
allowcorethreadtimeout true
this cleanuppool   true
return this batchpool
protected executorservice getcurrentbatchpool
return batchpool
private void shutdownbatchpool
if  this cleanuppool    this batchpool    null     this batchpool isshutdown
this batchpool shutdown
try
if   this batchpool awaittermination 10  timeunit seconds
this batchpool shutdownnow
catch  interruptedexception e
this batchpool shutdownnow
/**
* @return the cluster registry implementation to use.
* @throws ioexception
*/
private registry setupregistry   throws ioexception
string registryclass   this conf get
zookeeperregistry class getname
registry registry   null
try
registry    registry class forname registryclass  newinstance
catch  throwable t
throw new ioexception t
registry init this
return registry
/**
* for tests only.
* @param rpcclient client we should use instead.
* @return previous rpcclient
*/
rpcclient setrpcclient final rpcclient rpcclient
rpcclient oldrpcclient   this rpcclient
this rpcclient   rpcclient
return oldrpcclient
/**
* an identifier that will remain the same for a given connection.
* @return
*/
public string tostring
return     integer tohexstring hashcode
protected string clusterid   null
void retrieveclusterid
if  clusterid    null  return
this clusterid   this registry getclusterid
if  clusterid    null
clusterid   hconstants cluster_id_default
log debug     clusterid
@override
public configuration getconfiguration
return this conf
private void checkifbasenodeavailable zookeeperwatcher zkw
throws masternotrunningexception
string errormsg
try
if  zkutil checkexists zkw  zkw baseznode      1
errormsg       zkw baseznode
log error errormsg
throw new masternotrunningexception errormsg
catch  keeperexception e
errormsg       e getmessage
log error errormsg
throw new masternotrunningexception errormsg  e
/**
* @return true if the master is running, throws an exception otherwise
* @throws masternotrunningexception - if the master is not running
* @throws zookeeperconnectionexception
*/
@override
public boolean ismasterrunning
throws masternotrunningexception  zookeeperconnectionexception
// when getting the master connection, we check it's running,
// so if there is no exception, it means we've been able to get a
// connection on a running master
mastermonitorkeepaliveconnection m   getkeepalivemastermonitorservice
try
m close
catch  ioexception e
throw new masternotrunningexception    e
return true
@override
public hregionlocation getregionlocation final tablename tablename
final byte  row  boolean reload
throws ioexception
return reload? relocateregion tablename  row   locateregion tablename  row
@override
public hregionlocation getregionlocation final byte tablename
final byte  row  boolean reload
throws ioexception
return getregionlocation tablename valueof tablename   row  reload
@override
public boolean istableenabled tablename tablename  throws ioexception
return this registry istableonlinestate tablename  true
@override
public boolean istableenabled byte tablename  throws ioexception
return istableenabled tablename valueof tablename
@override
public boolean istabledisabled tablename tablename  throws ioexception
return this registry istableonlinestate tablename  false
@override
public boolean istabledisabled byte tablename  throws ioexception
return istabledisabled tablename valueof tablename
@override
public boolean istableavailable final tablename tablename  throws ioexception
final atomicboolean available   new atomicboolean true
final atomicinteger regioncount   new atomicinteger 0
metascannervisitor visitor   new metascannervisitorbase
@override
public boolean processrow result row  throws ioexception
hregioninfo info   metascanner gethregioninfo row
if  info    null
if  tablename equals info gettablename
servername server   hregioninfo getservername row
if  server    null
available set false
return false
regioncount incrementandget
else if  tablename compareto
info gettablename    < 0
// return if we are done with the current table
return false
return true
metascanner metascan conf  this  visitor  tablename
return available get       regioncount get   > 0
@override
public boolean istableavailable final byte tablename  throws ioexception
return istableavailable tablename valueof tablename
@override
public boolean istableavailable final tablename tablename  final byte splitkeys
throws ioexception
final atomicboolean available   new atomicboolean true
final atomicinteger regioncount   new atomicinteger 0
metascannervisitor visitor   new metascannervisitorbase
@override
public boolean processrow result row  throws ioexception
hregioninfo info   metascanner gethregioninfo row
if  info    null
if  tablename equals info gettablename
servername server   hregioninfo getservername row
if  server    null
available set false
return false
if   bytes equals info getstartkey    hconstants empty_byte_array
for  byte splitkey   splitkeys
// just check if the splitkey is available
if  bytes equals info getstartkey    splitkey
regioncount incrementandget
break
else
// always empty start row should be counted
regioncount incrementandget
else if  tablename compareto info gettablename    < 0
// return if we are done with the current table
return false
return true
metascanner metascan conf  this  visitor  tablename
// +1 needs to be added so that the empty start row is also taken into account
return available get       regioncount get      splitkeys length   1
@override
public boolean istableavailable final byte tablename  final byte splitkeys
throws ioexception
return istableavailable tablename valueof tablename   splitkeys
@override
public hregionlocation locateregion final byte regionname  throws ioexception
return locateregion hregioninfo gettablename regionname
hregioninfo getstartkey regionname   false  true
@override
public boolean isdeadserver servername sn
if  clusterstatuslistener    null
return false
else
return clusterstatuslistener isdeadserver sn
@override
public list<hregionlocation> locateregions final tablename tablename
throws ioexception
return locateregions  tablename  false  true
@override
public list<hregionlocation> locateregions final byte tablename
throws ioexception
return locateregions tablename valueof tablename
@override
public list<hregionlocation> locateregions final tablename tablename
final boolean usecache  final boolean offlined  throws ioexception
navigablemap<hregioninfo  servername> regions   metascanner alltableregions conf  this
tablename  offlined
final list<hregionlocation> locations   new arraylist<hregionlocation>
for  hregioninfo regioninfo   regions keyset
locations add locateregion tablename  regioninfo getstartkey    usecache  true
return locations
@override
public list<hregionlocation> locateregions final byte tablename
final boolean usecache  final boolean offlined  throws ioexception
return locateregions tablename valueof tablename   usecache  offlined
@override
public hregionlocation locateregion final tablename tablename
final byte  row
throws ioexception
return locateregion tablename  row  true  true
@override
public hregionlocation locateregion final byte tablename
final byte  row
throws ioexception
return locateregion tablename valueof tablename   row
@override
public hregionlocation relocateregion final tablename tablename
final byte  row  throws ioexception
// since this is an explicit request not to use any caching, finding
// disabled tables should not be desirable.  this will ensure that an exception is thrown when
// the first time a disabled table is interacted with.
if  istabledisabled tablename
throw new donotretryioexception tablename getnameasstring
return locateregion tablename  row  false  true
@override
public hregionlocation relocateregion final byte tablename
final byte  row  throws ioexception
return relocateregion tablename valueof tablename   row
private hregionlocation locateregion final tablename tablename
final byte  row  boolean usecache  boolean retry
throws ioexception
if  this closed  throw new ioexception tostring
if  tablename   null    tablename getname   length    0
throw new illegalargumentexception
if  tablename equals tablename meta_table_name
return this registry getmetaregionlocation
else
// region not in the cache - have to go to the meta rs
return locateregioninmeta tablename meta_table_name  tablename  row
usecache  userregionlock  retry
/*
* search .meta. for the hregionlocation info that contains the table and
* row we're seeking. it will prefetch certain number of regions info and
* save them to the global region cache.
*/
private void prefetchregioncache final tablename tablename
final byte row
// implement a new visitor for metascanner, and use it to walk through
// the .meta.
metascannervisitor visitor   new metascannervisitorbase
public boolean processrow result result  throws ioexception
try
hregioninfo regioninfo   metascanner gethregioninfo result
if  regioninfo    null
return true
// possible we got a region of a different table...
if   regioninfo gettablename   equals tablename
return false     stop scanning
if  regioninfo isoffline
// don't cache offline regions
return true
servername servername   hregioninfo getservername result
if  servername    null
return true     don't cache it
// instantiate the location
long seqnum   hregioninfo getseqnumduringopen result
hregionlocation loc   new hregionlocation regioninfo  servername  seqnum
// cache this meta entry
cachelocation tablename  null  loc
return true
catch  runtimeexception e
throw new ioexception e
try
// pre-fetch certain number of regions info at region cache.
metascanner metascan conf  this  visitor  tablename  row
this prefetchregionlimit  tablename meta_table_name
catch  ioexception e
log warn    e
/*
* search the .meta. table for the hregionlocation
* info that contains the table and row we're seeking.
*/
private hregionlocation locateregioninmeta final tablename parenttable
final tablename tablename  final byte  row  boolean usecache
object regionlockobject  boolean retry
throws ioexception
hregionlocation location
// if we are supposed to be using the cache, look in the cache to see if
// we already have the region.
if  usecache
location   getcachedlocation tablename  row
if  location    null
return location
int localnumretries   retry ? numtries   1
// build the key of the meta region we should be looking for.
// the extra 9's on the end are necessary to allow "exact" matches
// without knowing the precise region names.
byte  metakey   hregioninfo createregionname tablename  row
hconstants nines  false
for  int tries   0  true  tries
if  tries >  localnumretries
throw new noserverforregionexception
bytes tostringbinary row        numtries
hregionlocation metalocation   null
try
// locate the meta region
metalocation   locateregion parenttable  metakey  true  false
// if null still, go around again.
if  metalocation    null  continue
clientservice blockinginterface service   getclient metalocation getservername
result regioninforow
// this block guards against two threads trying to load the meta
// region at the same time. the first will load the meta region and
// the second will use the value that the first one found.
synchronized  regionlockobject
// check the cache again for a hit in case some other thread made the
// same query while we were waiting on the lock.
if  usecache
location   getcachedlocation tablename  row
if  location    null
return location
// if the parent table is meta, we may want to pre-fetch some
// region info into the global region cache for this table.
if  parenttable equals tablename meta_table_name
getregioncacheprefetch tablename
prefetchregioncache tablename  row
location   getcachedlocation tablename  row
if  location    null
return location
else
// if we are not supposed to be using the cache, delete any existing cached location
// so it won't interfere.
forcedeletecachedlocation tablename  row
// query the meta region for the location of the meta region
regioninforow   protobufutil getroworbefore service
metalocation getregioninfo   getregionname    metakey
hconstants catalog_family
if  regioninforow    null
throw new tablenotfoundexception tablename
// convert the row result into the hregionlocation we need!
hregioninfo regioninfo   metascanner gethregioninfo regioninforow
if  regioninfo    null
throw new ioexception
parenttable       regioninforow
// possible we got a region of a different table...
if   regioninfo gettablename   equals tablename
throw new tablenotfoundexception
tablename
regioninfo gettablename
if  regioninfo issplit
throw new regionofflineexception
regioninfo getregionnameasstring
if  regioninfo isoffline
throw new regionofflineexception
regioninfo getregionnameasstring
servername servername   hregioninfo getservername regioninforow
if  servername    null
throw new noserverforregionexception
parenttable
regioninfo getregionnameasstring
bytes tostringbinary row
if  isdeadserver servername
throw new regionserverstoppedexception
regioninfo getregionnameasstring       servername
// instantiate the location
location   new hregionlocation regioninfo  servername
hregioninfo getseqnumduringopen regioninforow
cachelocation tablename  null  location
return location
catch  tablenotfoundexception e
// if we got this error, probably means the table just plain doesn't
// exist. rethrow the error immediately. this should always be coming
// from the htable constructor.
throw e
catch  ioexception e
if  e instanceof remoteexception
e     remoteexception e  unwrapremoteexception
if  tries < numtries   1
if  log isdebugenabled
log debug
parenttable
metalocation    null ?        metalocation
tries
this numtries
connectionutils getpausetime this pause  tries        e getmessage
else
throw e
// only relocate the parent region if necessary
if   e instanceof regionofflineexception
e instanceof noserverforregionexception
relocateregion parenttable  metakey
try
thread sleep connectionutils getpausetime this pause  tries
catch  interruptedexception e
thread currentthread   interrupt
throw new ioexception
/*
* search the cache for a location that fits our table and row key.
* return null if no suitable region is located. todo: synchronization note
*
* <p>todo: this method during writing consumes 15% of cpu doing lookup
* into the soft reference sortedmap.  improve.
*
* @param tablename
* @param row
* @return null or region location found in cache.
*/
hregionlocation getcachedlocation final tablename tablename
final byte  row
softvaluesortedmap<byte  hregionlocation> tablelocations
gettablelocations tablename
// start to examine the cache. we can only do cache actions
// if there's something in the cache for this table.
if  tablelocations isempty
return null
hregionlocation possibleregion   tablelocations get row
if  possibleregion    null
return possibleregion
possibleregion   tablelocations lowervaluebykey row
if  possibleregion    null
return null
// make sure that the end key is greater than the row we're looking
// for, otherwise the row actually belongs in the next region, not
// this one. the exception case is when the endkey is
// hconstants.empty_end_row, signifying that the region we're
// checking is actually the last region in the table.
byte endkey   possibleregion getregioninfo   getendkey
if  bytes equals endkey  hconstants empty_end_row
keyvalue getrowcomparator tablename  comparerows
endkey  0  endkey length  row  0  row length  > 0
return possibleregion
// passed all the way through, so we got nothing - complete cache miss
return null
/**
* delete a cached location, no matter what it is. called when we were told to not use cache.
* @param tablename tablename
* @param row
*/
void forcedeletecachedlocation final tablename tablename  final byte  row
hregionlocation rl   null
synchronized  this cachedregionlocations
map<byte  hregionlocation> tablelocations   gettablelocations tablename
// start to examine the cache. we can only do cache actions
// if there's something in the cache for this table.
if   tablelocations isempty
rl   getcachedlocation tablename  row
if  rl    null
tablelocations remove rl getregioninfo   getstartkey
if   rl    null     log isdebugenabled
log debug     rl gethostname         rl getport
rl getregioninfo   getregionnameasstring
tablename
/*
* delete all cached entries of a table that maps to a specific location.
*/
@override
public void clearcaches final servername servername
boolean deletedsomething   false
synchronized  this cachedregionlocations
if   cachedservers contains servername
return
for  map<byte  hregionlocation> tablelocations
cachedregionlocations values
for  entry<byte  hregionlocation> e   tablelocations entryset
hregionlocation value   e getvalue
if  value    null
servername equals value getservername
tablelocations remove e getkey
deletedsomething   true
cachedservers remove servername
if  deletedsomething    log isdebugenabled
log debug     servername
/*
* @param tablename
* @return map of cached locations for passed <code>tablename</code>
*/
private softvaluesortedmap<byte  hregionlocation> gettablelocations
final tablename tablename
// find the map of cached locations for this table
softvaluesortedmap<byte  hregionlocation> result
synchronized  this cachedregionlocations
result   this cachedregionlocations get tablename
// if tablelocations for this table isn't built yet, make one
if  result    null
result   new softvaluesortedmap<byte  hregionlocation> bytes bytes_comparator
this cachedregionlocations put tablename  result
return result
@override
public void clearregioncache
synchronized this cachedregionlocations
this cachedregionlocations clear
this cachedservers clear
@override
public void clearregioncache final tablename tablename
synchronized  this cachedregionlocations
this cachedregionlocations remove tablename
@override
public void clearregioncache final byte tablename
clearregioncache tablename valueof tablename
/**
* put a newly discovered hregionlocation into the cache.
* @param tablename the table name.
* @param source the source of the new location, if it's not coming from meta
* @param location the new location
*/
private void cachelocation final tablename tablename  final hregionlocation source
final hregionlocation location
boolean isfrommeta    source    null
byte  startkey   location getregioninfo   getstartkey
map<byte  hregionlocation> tablelocations
gettablelocations tablename
boolean isnewcacheentry   false
boolean isstaleupdate   false
hregionlocation oldlocation   null
synchronized  this cachedregionlocations
cachedservers add location getservername
oldlocation   tablelocations get startkey
isnewcacheentry    oldlocation    null
// if the server in cache sends us a redirect, assume it's always valid.
if   isnewcacheentry     oldlocation equals source
long newlocationseqnum   location getseqnum
// meta record is stale - some (probably the same) server has closed the region
// with later seqnum and told us about the new location.
boolean isstalemetarecord   isfrommeta     oldlocation getseqnum   > newlocationseqnum
// same as above for redirect. however, in this case, if the number is equal to previous
// record, the most common case is that first the region was closed with seqnum, and then
// opened with the same seqnum; hence we will ignore the redirect.
// there are so many corner cases with various combinations of opens and closes that
// an additional counter on top of seqnum would be necessary to handle them all.
boolean isstaleredirect    isfrommeta     oldlocation getseqnum   >  newlocationseqnum
isstaleupdate    isstalemetarecord    isstaleredirect
if   isstaleupdate
tablelocations put startkey  location
if  isnewcacheentry
if  log istraceenabled
log trace
location getregioninfo   getregionnameasstring
location gethostnameport
else if  isstaleupdate     location equals oldlocation
if  log istraceenabled
log trace
location getregioninfo   getregionnameasstring
location gethostnameport         location getseqnum
oldlocation gethostnameport         oldlocation getseqnum
// map keyed by service name + regionserver to service stub implementation
private final concurrenthashmap<string  object> stubs
new concurrenthashmap<string  object>
// map of locks used creating service stubs per regionserver.
private final concurrenthashmap<string  string> connectionlock
new concurrenthashmap<string  string>
/**
* maintains current state of masterservice instance.
*/
static abstract class masterservicestate
hconnection connection
int usercount
long keepaliveuntil   long max_value
masterservicestate  final hconnection connection
super
this connection   connection
abstract object getstub
abstract void clearstub
abstract boolean ismasterrunning   throws serviceexception
/**
* state of the masteradminservice connection/setup.
*/
static class masteradminservicestate extends masterservicestate
masteradminservice blockinginterface stub
masteradminservicestate final hconnection connection
super connection
@override
public string tostring
return
@override
object getstub
return this stub
@override
void clearstub
this stub   null
@override
boolean ismasterrunning   throws serviceexception
masterprotos ismasterrunningresponse response
this stub ismasterrunning null  requestconverter buildismasterrunningrequest
return response    null? response getismasterrunning    false
/**
* state of the mastermonitorservice connection/setup.
*/
static class mastermonitorservicestate extends masterservicestate
mastermonitorservice blockinginterface stub
mastermonitorservicestate final hconnection connection
super connection
@override
public string tostring
return
@override
object getstub
return this stub
@override
void clearstub
this stub   null
@override
boolean ismasterrunning   throws serviceexception
masterprotos ismasterrunningresponse response
this stub ismasterrunning null  requestconverter buildismasterrunningrequest
return response    null? response getismasterrunning    false
/**
* makes a client-side stub for master services. sub-class to specialize.
* depends on hosting class so not static.  exists so we avoid duplicating a bunch of code
* when setting up the mastermonitorservice and masteradminservice.
*/
abstract class stubmaker
/**
* returns the name of the service stub being created.
*/
protected abstract string getservicename
/**
* make stub and cache it internal so can be used later doing the ismasterrunning call.
* @param channel
*/
protected abstract object makestub final blockingrpcchannel channel
/**
* once setup, check it works by doing ismasterrunning check.
* @throws serviceexception
*/
protected abstract void ismasterrunning   throws serviceexception
/**
* create a stub. try once only.  it is not typed because there is no common type to
* protobuf services nor their interfaces.  let the caller do appropriate casting.
* @return a stub for master services.
* @throws ioexception
* @throws keeperexception
* @throws serviceexception
*/
private object makestubnoretries   throws ioexception  keeperexception  serviceexception
zookeeperkeepaliveconnection zkw
try
zkw   getkeepalivezookeeperwatcher
catch  ioexception e
throw new zookeeperconnectionexception    e
try
checkifbasenodeavailable zkw
servername sn   masteraddresstracker getmasteraddress zkw
if  sn    null
string msg
log info msg
throw new masternotrunningexception msg
if  isdeadserver sn
throw new masternotrunningexception sn
// use the security info interface name as our stub key
string key   getstubkey getservicename    sn gethostandport
connectionlock putifabsent key  key
object stub   null
synchronized  connectionlock get key
stub   stubs get key
if  stub    null
blockingrpcchannel channel   rpcclient createblockingrpcchannel sn
user getcurrent    rpctimeout
stub   makestub channel
ismasterrunning
stubs put key  stub
return stub
finally
zkw close
/**
* create a stub against the master.  retry if necessary.
* @return a stub to do <code>intf</code> against the master
* @throws masternotrunningexception
*/
@edu umd cs findbugs annotations suppresswarnings  value
object makestub   throws masternotrunningexception
// the lock must be at the beginning to prevent multiple master creations
//  (and leaks) in a multithread context
synchronized  masterandzklock
exception exceptioncaught   null
object stub   null
int tries   0
while   closed    stub    null
tries
try
stub   makestubnoretries
catch  ioexception e
exceptioncaught   e
catch  keeperexception e
exceptioncaught   e
catch  serviceexception e
exceptioncaught   e
if  exceptioncaught    null
// it failed. if it's not the last try, we're going to wait a little
if  tries < numtries
// tries at this point is 1 or more; decrement to start from 0.
long pausetime   connectionutils getpausetime pause  tries   1
log info     tries       numtries
pausetime
exceptioncaught
try
thread sleep pausetime
catch  interruptedexception e
thread currentthread   interrupt
throw new runtimeexception
e
else
// enough tries, we stop now
log info     tries       numtries
exceptioncaught
throw new masternotrunningexception exceptioncaught
if  stub    null
// implies this.closed true
throw new masternotrunningexception
return stub
/**
* class to make a mastermonitorservice stub.
*/
class mastermonitorservicestubmaker extends stubmaker
private mastermonitorservice blockinginterface stub
@override
protected string getservicename
return mastermonitorservice getdescriptor   getname
@override
@edu umd cs findbugs annotations suppresswarnings
mastermonitorservice blockinginterface makestub   throws masternotrunningexception
return  mastermonitorservice blockinginterface super makestub
@override
protected object makestub blockingrpcchannel channel
this stub   mastermonitorservice newblockingstub channel
return this stub
@override
protected void ismasterrunning   throws serviceexception
this stub ismasterrunning null  requestconverter buildismasterrunningrequest
/**
* class to make a masteradminservice stub.
*/
class masteradminservicestubmaker extends stubmaker
private masteradminservice blockinginterface stub
@override
protected string getservicename
return masteradminservice getdescriptor   getname
@override
@edu umd cs findbugs annotations suppresswarnings
masteradminservice blockinginterface makestub   throws masternotrunningexception
return  masteradminservice blockinginterface super makestub
@override
protected object makestub blockingrpcchannel channel
this stub   masteradminservice newblockingstub channel
return this stub
@override
protected void ismasterrunning   throws serviceexception
this stub ismasterrunning null  requestconverter buildismasterrunningrequest
@override
public adminservice blockinginterface getadmin final servername servername
throws ioexception
return getadmin servername  false
@override
// nothing is done w/ the 'master' parameter.  it is ignored.
public adminservice blockinginterface getadmin final servername servername
final boolean master
throws ioexception
if  isdeadserver servername
throw new regionserverstoppedexception servername
string key   getstubkey adminservice blockinginterface class getname
servername gethostandport
this connectionlock putifabsent key  key
adminservice blockinginterface stub   null
synchronized  this connectionlock get key
stub    adminservice blockinginterface this stubs get key
if  stub    null
blockingrpcchannel channel   this rpcclient createblockingrpcchannel servername
user getcurrent    this rpctimeout
stub   adminservice newblockingstub channel
this stubs put key  stub
return stub
@override
public clientservice blockinginterface getclient final servername sn
throws ioexception
if  isdeadserver sn
throw new regionserverstoppedexception sn
string key   getstubkey clientservice blockinginterface class getname    sn gethostandport
this connectionlock putifabsent key  key
clientservice blockinginterface stub   null
synchronized  this connectionlock get key
stub    clientservice blockinginterface this stubs get key
if  stub    null
blockingrpcchannel channel   this rpcclient createblockingrpcchannel sn
user getcurrent    this rpctimeout
stub   clientservice newblockingstub channel
// in old days, after getting stub/proxy, we'd make a call.  we are not doing that here.
// just fail on first actual call rather than in here on setup.
this stubs put key  stub
return stub
static string getstubkey final string servicename  final string rshostnameport
return servicename       rshostnameport
private zookeeperkeepaliveconnection keepalivezookeeper
private int keepalivezookeeperusercount
private boolean canclosezkw   true
// keepalive time, in ms. no reason to make it configurable.
private static final long keepalive   5   60   1000
/**
* retrieve a shared zookeeperwatcher. you must close it it once you've have finished with it.
* @return the shared instance. never returns null.
*/
zookeeperkeepaliveconnection getkeepalivezookeeperwatcher
throws ioexception
synchronized  masterandzklock
if  keepalivezookeeper    null
if  this closed
throw new ioexception tostring
// we don't check that our link to zookeeper is still valid
// but there is a retry mechanism in the zookeeperwatcher itself
keepalivezookeeper   new zookeeperkeepaliveconnection conf  this tostring    this
keepalivezookeeperusercount
keepzookeeperwatcheraliveuntil   long max_value
return keepalivezookeeper
void releasezookeeperwatcher final zookeeperwatcher zkw
if  zkw    null
return
synchronized  masterandzklock
keepalivezookeeperusercount
if  keepalivezookeeperusercount <  0
keepzookeeperwatcheraliveuntil   system currenttimemillis     keepalive
/**
* creates a chore thread to check the connections to master & zookeeper
*  and close them when they reach their closing time (
*  {@link masterservicestate#keepaliveuntil} and
*  {@link #keepzookeeperwatcheraliveuntil}). keep alive time is
*  managed by the release functions and the variable {@link #keepalive}
*/
private static class delayedclosing extends chore implements stoppable
private hconnectionimplementation hci
stoppable stoppable
private delayedclosing
hconnectionimplementation hci  stoppable stoppable
super
hci
60 1000     we check every minutes
stoppable
this hci   hci
this stoppable   stoppable
static delayedclosing createandstart hconnectionimplementation hci
stoppable stoppable   new stoppable
private volatile boolean isstopped   false
@override public void stop string why    isstopped   true
@override public boolean isstopped    return isstopped
return new delayedclosing hci  stoppable
protected void closemasterprotocol masterservicestate protocolstate
if  system currenttimemillis   > protocolstate keepaliveuntil
hci closemasterservice protocolstate
protocolstate keepaliveuntil   long max_value
@override
protected void chore
synchronized  hci masterandzklock
if  hci canclosezkw
if  system currenttimemillis   >
hci keepzookeeperwatcheraliveuntil
hci closezookeeperwatcher
hci keepzookeeperwatcheraliveuntil   long max_value
closemasterprotocol hci adminmasterservicestate
closemasterprotocol hci monitormasterservicestate
@override
public void stop string why
stoppable stop why
@override
public boolean isstopped
return stoppable isstopped
private void closezookeeperwatcher
synchronized  masterandzklock
if  keepalivezookeeper    null
log info
long tohexstring
keepalivezookeeper getrecoverablezookeeper   getsessionid
keepalivezookeeper internalclose
keepalivezookeeper   null
keepalivezookeeperusercount   0
final masteradminservicestate adminmasterservicestate   new masteradminservicestate this
final mastermonitorservicestate monitormasterservicestate
new mastermonitorservicestate this
@override
public masteradminservice blockinginterface getmasteradmin   throws masternotrunningexception
return getkeepalivemasteradminservice
@override
public mastermonitorservice blockinginterface getmastermonitor
throws masternotrunningexception
return getkeepalivemastermonitorservice
private void resetmasterservicestate final masterservicestate mss
mss usercount
mss keepaliveuntil   long max_value
@override
public masteradminkeepaliveconnection getkeepalivemasteradminservice
throws masternotrunningexception
synchronized  masterandzklock
if   iskeepalivemasterconnectedandrunning this adminmasterservicestate
masteradminservicestubmaker stubmaker   new masteradminservicestubmaker
this adminmasterservicestate stub   stubmaker makestub
resetmasterservicestate this adminmasterservicestate
// ugly delegation just so we can add in a close method.
final masteradminservice blockinginterface stub   this adminmasterservicestate stub
return new masteradminkeepaliveconnection
masteradminservicestate mss   adminmasterservicestate
@override
public addcolumnresponse addcolumn rpccontroller controller
addcolumnrequest request  throws serviceexception
return stub addcolumn controller  request
@override
public deletecolumnresponse deletecolumn rpccontroller controller
deletecolumnrequest request  throws serviceexception
return stub deletecolumn controller  request
@override
public modifycolumnresponse modifycolumn rpccontroller controller
modifycolumnrequest request  throws serviceexception
return stub modifycolumn controller  request
@override
public moveregionresponse moveregion rpccontroller controller
moveregionrequest request  throws serviceexception
return stub moveregion controller  request
@override
public dispatchmergingregionsresponse dispatchmergingregions
rpccontroller controller  dispatchmergingregionsrequest request
throws serviceexception
return stub dispatchmergingregions controller  request
@override
public assignregionresponse assignregion rpccontroller controller
assignregionrequest request  throws serviceexception
return stub assignregion controller  request
@override
public unassignregionresponse unassignregion rpccontroller controller
unassignregionrequest request  throws serviceexception
return stub unassignregion controller  request
@override
public offlineregionresponse offlineregion rpccontroller controller
offlineregionrequest request  throws serviceexception
return stub offlineregion controller  request
@override
public deletetableresponse deletetable rpccontroller controller
deletetablerequest request  throws serviceexception
return stub deletetable controller  request
@override
public enabletableresponse enabletable rpccontroller controller
enabletablerequest request  throws serviceexception
return stub enabletable controller  request
@override
public disabletableresponse disabletable rpccontroller controller
disabletablerequest request  throws serviceexception
return stub disabletable controller  request
@override
public modifytableresponse modifytable rpccontroller controller
modifytablerequest request  throws serviceexception
return stub modifytable controller  request
@override
public createtableresponse createtable rpccontroller controller
createtablerequest request  throws serviceexception
return stub createtable controller  request
@override
public shutdownresponse shutdown rpccontroller controller
shutdownrequest request  throws serviceexception
return stub shutdown controller  request
@override
public stopmasterresponse stopmaster rpccontroller controller
stopmasterrequest request  throws serviceexception
return stub stopmaster controller  request
@override
public balanceresponse balance rpccontroller controller
balancerequest request  throws serviceexception
return stub balance controller  request
@override
public setbalancerrunningresponse setbalancerrunning
rpccontroller controller  setbalancerrunningrequest request
throws serviceexception
return stub setbalancerrunning controller  request
@override
public catalogscanresponse runcatalogscan rpccontroller controller
catalogscanrequest request  throws serviceexception
return stub runcatalogscan controller  request
@override
public enablecatalogjanitorresponse enablecatalogjanitor
rpccontroller controller  enablecatalogjanitorrequest request
throws serviceexception
return stub enablecatalogjanitor controller  request
@override
public iscatalogjanitorenabledresponse iscatalogjanitorenabled
rpccontroller controller  iscatalogjanitorenabledrequest request
throws serviceexception
return stub iscatalogjanitorenabled controller  request
@override
public coprocessorserviceresponse execmasterservice
rpccontroller controller  coprocessorservicerequest request
throws serviceexception
return stub execmasterservice controller  request
@override
public takesnapshotresponse snapshot rpccontroller controller
takesnapshotrequest request  throws serviceexception
return stub snapshot controller  request
@override
public listsnapshotresponse getcompletedsnapshots
rpccontroller controller  listsnapshotrequest request
throws serviceexception
return stub getcompletedsnapshots controller  request
@override
public deletesnapshotresponse deletesnapshot rpccontroller controller
deletesnapshotrequest request  throws serviceexception
return stub deletesnapshot controller  request
@override
public issnapshotdoneresponse issnapshotdone rpccontroller controller
issnapshotdonerequest request  throws serviceexception
return stub issnapshotdone controller  request
@override
public restoresnapshotresponse restoresnapshot
rpccontroller controller  restoresnapshotrequest request
throws serviceexception
return stub restoresnapshot controller  request
@override
public isrestoresnapshotdoneresponse isrestoresnapshotdone
rpccontroller controller  isrestoresnapshotdonerequest request
throws serviceexception
return stub isrestoresnapshotdone controller  request
@override
public ismasterrunningresponse ismasterrunning
rpccontroller controller  ismasterrunningrequest request
throws serviceexception
return stub ismasterrunning controller  request
@override
public modifynamespaceresponse modifynamespace rpccontroller controller  modifynamespacerequest request  throws serviceexception
return stub modifynamespace controller  request
@override
public createnamespaceresponse createnamespace rpccontroller controller  createnamespacerequest request  throws serviceexception
return stub createnamespace controller  request
@override
public deletenamespaceresponse deletenamespace rpccontroller controller  deletenamespacerequest request  throws serviceexception
return stub deletenamespace controller  request
@override
public getnamespacedescriptorresponse getnamespacedescriptor rpccontroller controller  getnamespacedescriptorrequest request  throws serviceexception
return stub getnamespacedescriptor controller  request
@override
public listnamespacedescriptorsresponse listnamespacedescriptors rpccontroller controller  listnamespacedescriptorsrequest request  throws serviceexception
return stub listnamespacedescriptors controller  request
@override
public listtabledescriptorsbynamespaceresponse listtabledescriptorsbynamespace rpccontroller controller  listtabledescriptorsbynamespacerequest request  throws serviceexception
return stub listtabledescriptorsbynamespace controller  request
@override
public listtablenamesbynamespaceresponse listtablenamesbynamespace rpccontroller controller
listtablenamesbynamespacerequest request  throws serviceexception
return stub listtablenamesbynamespace controller  request
@override
public void close
release this mss
private static void release masterservicestate mss
if  mss    null    mss connection    null
hconnectionimplementation mss connection  releasemaster mss
@override
public mastermonitorkeepaliveconnection getkeepalivemastermonitorservice
throws masternotrunningexception
synchronized  masterandzklock
if   iskeepalivemasterconnectedandrunning this monitormasterservicestate
mastermonitorservicestubmaker stubmaker   new mastermonitorservicestubmaker
this monitormasterservicestate stub   stubmaker makestub
resetmasterservicestate this monitormasterservicestate
// ugly delegation just so can implement close
final mastermonitorservice blockinginterface stub   this monitormasterservicestate stub
return new mastermonitorkeepaliveconnection
final mastermonitorservicestate mss   monitormasterservicestate
@override
public getschemaalterstatusresponse getschemaalterstatus
rpccontroller controller  getschemaalterstatusrequest request
throws serviceexception
return stub getschemaalterstatus controller  request
@override
public gettabledescriptorsresponse gettabledescriptors
rpccontroller controller  gettabledescriptorsrequest request
throws serviceexception
return stub gettabledescriptors controller  request
@override
public gettablenamesresponse gettablenames
rpccontroller controller  gettablenamesrequest request
throws serviceexception
return stub gettablenames controller  request
@override
public getclusterstatusresponse getclusterstatus
rpccontroller controller  getclusterstatusrequest request
throws serviceexception
return stub getclusterstatus controller  request
@override
public ismasterrunningresponse ismasterrunning
rpccontroller controller  ismasterrunningrequest request
throws serviceexception
return stub ismasterrunning controller  request
@override
public void close   throws ioexception
release this mss
private boolean iskeepalivemasterconnectedandrunning masterservicestate mss
if  mss getstub      null
return false
try
return mss ismasterrunning
catch  undeclaredthrowableexception e
// it's somehow messy, but we can receive exceptions such as
//  java.net.connectexception but they're not declared. so we catch it...
log info    e getundeclaredthrowable
return false
catch  serviceexception se
log warn    se
return false
void releasemaster masterservicestate mss
if  mss getstub      null  return
synchronized  masterandzklock
mss usercount
if  mss usercount <  0
mss keepaliveuntil   system currenttimemillis     keepalive
private void closemasterservice masterservicestate mss
if  mss getstub      null
log info     mss
mss clearstub
mss usercount   0
/**
* immediate close of the shared master. can be by the delayed close or when closing the
* connection itself.
*/
private void closemaster
synchronized  masterandzklock
closemasterservice adminmasterservicestate
closemasterservice monitormasterservicestate
void updatecachedlocation hregioninfo hri  hregionlocation source
servername servername  long seqnum
hregionlocation newhrl   new hregionlocation hri  servername  seqnum
synchronized  this cachedregionlocations
cachelocation hri gettablename    source  newhrl
/**
* deletes the cached location of the region if necessary, based on some error from source.
* @param hri the region in question.
* @param source the source of the error that prompts us to invalidate cache.
*/
void deletecachedlocation hregioninfo hri  hregionlocation source
boolean isstaledelete   false
hregionlocation oldlocation
synchronized  this cachedregionlocations
map<byte  hregionlocation> tablelocations
gettablelocations hri gettablename
oldlocation   tablelocations get hri getstartkey
if  oldlocation    null
// do not delete the cache entry if it's not for the same server that gave us the error.
isstaledelete    source    null      oldlocation equals source
if   isstaledelete
tablelocations remove hri getstartkey
@override
public void deletecachedregionlocation final hregionlocation location
if  location    null
return
synchronized  this cachedregionlocations
tablename tablename   location getregioninfo   gettablename
map<byte  hregionlocation> tablelocations
gettablelocations tablename
if   tablelocations isempty
// delete if there's something in the cache for this region.
hregionlocation removedlocation
tablelocations remove location getregioninfo   getstartkey
if  log isdebugenabled      removedlocation    null
log debug
location getregioninfo   getregionnameasstring
tablename
/**
* update the location with the new value (if the exception is a regionmovedexception)
* or delete it from the cache.
* @param exception an object (to simplify user code) on which we will try to find a nested
*                  or wrapped or both regionmovedexception
* @param source server that is the source of the location update.
*/
@override
public void updatecachedlocations final tablename tablename  byte rowkey
final object exception  final hregionlocation source
if  rowkey    null    tablename    null
log warn      rowkey    null ?     rowkey
tablename    null ?     tablename
return
// is it something we have already updated?
final hregionlocation oldlocation   getcachedlocation tablename  rowkey
if  oldlocation    null
// there is no such location in the cache => it's been removed already => nothing to do
return
hregioninfo regioninfo   oldlocation getregioninfo
final regionmovedexception rme   regionmovedexception find exception
if  rme    null
if  log istraceenabled
log trace     regioninfo getregionnameasstring
rme gethostname         rme getport         source gethostnameport
updatecachedlocation
regioninfo  source  rme getservername    rme getlocationseqnum
else if  regionopeningexception find exception     null
if  log istraceenabled
log trace     regioninfo getregionnameasstring
source gethostnameport
else
deletecachedlocation regioninfo  source
@override
public void updatecachedlocations final byte tablename  byte rowkey
final object exception  final hregionlocation source
updatecachedlocations tablename valueof tablename   rowkey  exception  source
@override
@deprecated
public void processbatch list<? extends row> list
final tablename tablename
executorservice pool
object results  throws ioexception  interruptedexception
// this belongs in htable!!! not in here.  st.ack
// results must be the same size as list
if  results length    list size
throw new illegalargumentexception
processbatchcallback list  tablename  pool  results  null
@override
@deprecated
public void processbatch list<? extends row> list
final byte tablename
executorservice pool
object results  throws ioexception  interruptedexception
processbatch list  tablename valueof tablename   pool  results
/**
* send the queries in parallel on the different region servers. retries on failures.
* if the method returns it means that there is no error, and the 'results' array will
* contain no exception. on error, an exception is thrown, and the 'results' array will
* contain results and exceptions.
* @deprecated since 0.96 - use {@link htable#processbatchcallback} instead
*/
@override
@deprecated
public <r> void processbatchcallback
list<? extends row> list
tablename tablename
executorservice pool
object results
batch callback<r> callback
throws ioexception  interruptedexception
// to fulfill the original contract, we have a special callback. this callback
//  will set the results in the object array.
objectresultfiller<r> cb   new objectresultfiller<r> results  callback
asyncprocess<?> asyncprocess   createasyncprocess tablename  pool  cb  conf
// we're doing a submit all. this way, the originalindex will match the initial list.
asyncprocess submitall list
asyncprocess waituntildone
if  asyncprocess haserror
throw asyncprocess geterrors
@override
@deprecated
public <r> void processbatchcallback
list<? extends row> list
byte tablename
executorservice pool
object results
batch callback<r> callback
throws ioexception  interruptedexception
processbatchcallback list  tablename valueof tablename   pool  results  callback
// for tests.
protected <r> asyncprocess createasyncprocess tablename tablename  executorservice pool
asyncprocess asyncprocesscallback<r> callback  configuration conf
return new asyncprocess<r> this  tablename  pool  callback  conf
rpcretryingcallerfactory instantiate conf
/**
* fill the result array for the interfaces using it.
*/
private static class objectresultfiller<res>
implements asyncprocess asyncprocesscallback<res>
private final object results
private batch callback<res> callback
objectresultfiller object results  batch callback<res> callback
this results   results
this callback   callback
@override
public void success int pos  byte region  row row  res result
assert pos < results length
results   result
if  callback    null
callback update region  row getrow    result
@override
public boolean failure int pos  byte region  row row  throwable t
assert pos < results length
results   t
//batch.callback<res> was not called on failure in 0.94. we keep this.
return true     we want to have this failure in the failures list
@override
public boolean retriablefailure int originalindex  row row  byte region
throwable exception
return true     we retry
/*
* return the number of cached region for a table. it will only be called
* from a unit test.
*/
int getnumberofcachedregionlocations final tablename tablename
synchronized  this cachedregionlocations
map<byte  hregionlocation> tablelocs   this cachedregionlocations get tablename
if  tablelocs    null
return 0
return tablelocs values   size
/**
* check the region cache to see whether a region is cached yet or not.
* called by unit tests.
* @param tablename tablename
* @param row row
* @return region cached or not.
*/
boolean isregioncached tablename tablename  final byte row
hregionlocation location   getcachedlocation tablename  row
return location    null
@override
public void setregioncacheprefetch final tablename tablename
final boolean enable
if   enable
regioncacheprefetchdisabledtables add bytes mapkey tablename getname
else
regioncacheprefetchdisabledtables remove bytes mapkey tablename getname
@override
public void setregioncacheprefetch final byte tablename
final boolean enable
setregioncacheprefetch tablename valueof tablename   enable
@override
public boolean getregioncacheprefetch tablename tablename
return  regioncacheprefetchdisabledtables contains bytes mapkey tablename getname
@override
public boolean getregioncacheprefetch byte tablename
return getregioncacheprefetch tablename valueof tablename
@override
public void abort final string msg  throwable t
if  t instanceof keeperexception sessionexpiredexception
keepalivezookeeper    null
synchronized  masterandzklock
if  keepalivezookeeper    null
log warn
t
closezookeeperwatcher
else
if  t    null
log fatal msg  t
else
log fatal msg
this aborted   true
close
this closed   true
@override
public boolean isclosed
return this closed
@override
public boolean isaborted
return this aborted
@override
public int getcurrentnrhrs   throws ioexception
return this registry getcurrentnrhrs
/**
* increment this client's reference count.
*/
void inccount
refcount
/**
* decrement this client's reference count.
*/
void deccount
if  refcount > 0
refcount
/**
* return if this client has no reference
*
* @return true if this client has no reference; false otherwise
*/
boolean iszeroreference
return refcount    0
void internalclose
if  this closed
return
delayedclosing stop
closemaster
shutdownbatchpool
this closed   true
closezookeeperwatcher
this stubs clear
if  clusterstatuslistener    null
clusterstatuslistener close
@override
public void close
if  managed
if  aborted
hconnectionmanager deletestaleconnection this
else
hconnectionmanager deleteconnection this  false
else
internalclose
/**
* close the connection for good, regardless of what the current value of
* {@link #refcount} is. ideally, {@link #refcount} should be zero at this
* point, which would be the case if all of its consumers close the
* connection. however, on the off chance that someone is unable to close
* the connection, perhaps because it bailed out prematurely, the method
* below will ensure that this {@link hconnection} instance is cleaned up.
* caveat: the jvm may take an unknown amount of time to call finalize on an
* unreachable object, so our hope is that every consumer cleans up after
* itself, like any good citizen.
*/
@override
protected void finalize   throws throwable
super finalize
// pretend as if we are about to release the last remaining reference
refcount   1
close
@override
public htabledescriptor listtables   throws ioexception
mastermonitorkeepaliveconnection master   getkeepalivemastermonitorservice
try
gettabledescriptorsrequest req
requestconverter buildgettabledescriptorsrequest  list<tablename> null
return protobufutil gethtabledescriptorarray master gettabledescriptors null  req
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
@override
public string gettablenames   throws ioexception
tablename tablenames   listtablenames
string result   new string
for  int i   0  i < tablenames length  i
result   tablenames getnameasstring
return result
@override
public tablename listtablenames   throws ioexception
mastermonitorkeepaliveconnection master   getkeepalivemastermonitorservice
try
return protobufutil gettablenamearray master gettablenames null
gettablenamesrequest newbuilder   build
gettablenameslist
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
@override
public htabledescriptor gethtabledescriptorsbytablename
list<tablename> tablenames  throws ioexception
if  tablenames    null    tablenames isempty    return new htabledescriptor
mastermonitorkeepaliveconnection master   getkeepalivemastermonitorservice
try
gettabledescriptorsrequest req
requestconverter buildgettabledescriptorsrequest tablenames
return protobufutil gethtabledescriptorarray master gettabledescriptors null  req
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
@override
public htabledescriptor gethtabledescriptors
list<string> names  throws ioexception
list<tablename> tablenames   new arraylist names size
for string name   names
tablenames add tablename valueof name
return gethtabledescriptorsbytablename tablenames
/**
* connects to the master to get the table descriptor.
* @param tablename table name
* @return
* @throws ioexception if the connection to master fails or if the table
*  is not found.
*/
@override
public htabledescriptor gethtabledescriptor final tablename tablename
throws ioexception
if  tablename    null  return null
if  tablename equals tablename meta_table_name
return htabledescriptor meta_tabledesc
mastermonitorkeepaliveconnection master   getkeepalivemastermonitorservice
gettabledescriptorsresponse htds
try
gettabledescriptorsrequest req
requestconverter buildgettabledescriptorsrequest tablename
htds   master gettabledescriptors null  req
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
if   htds gettableschemalist   isempty
return htabledescriptor convert htds gettableschemalist   get 0
throw new tablenotfoundexception tablename getnameasstring
@override
public htabledescriptor gethtabledescriptor final byte tablename
throws ioexception
return gethtabledescriptor tablename valueof tablename
/**
* the record of errors for servers.
*/
static class servererrortracker
// we need a concurrent map here, as we could have multiple threads updating it in parallel.
private final concurrentmap<hregionlocation  servererrors> errorsbyserver
new concurrenthashmap<hregionlocation  servererrors>
private long canretryuntil   0
public servererrortracker long timeout
log trace     timeout
this canretryuntil   environmentedgemanager currenttimemillis     timeout
boolean canretrymore
return environmentedgemanager currenttimemillis   < this canretryuntil
/**
* calculates the back-off time for a retrying request to a particular server.
*
* @param server    the server in question.
* @param basepause the default hci pause.
* @return the time to wait before sending next request.
*/
long calculatebackofftime hregionlocation server  long basepause
long result   0
servererrors errorstats   errorsbyserver get server
if  errorstats    null
result   connectionutils getpausetime basepause  errorstats retries
// adjust by the time we already waited since last talking to this server.
long now   environmentedgemanager currenttimemillis
long timesincelasterror   now   errorstats getlasterrortime
if  timesincelasterror > 0
result   math max 0  result   timesincelasterror
// finally, see if the backoff time overshoots the timeout.
if  result > 0     now   result > this canretryuntil
result   math max 0  this canretryuntil   now
return result
/**
* reports that there was an error on the server to do whatever bean-counting necessary.
*
* @param server the server in question.
*/
void reportservererror hregionlocation server
servererrors errors   errorsbyserver get server
if  errors    null
errors adderror
else
errorsbyserver put server  new servererrors
/**
* the record of errors for a server.
*/
private static class servererrors
public long lasterrortime
public int retries
public servererrors
this lasterrortime   environmentedgemanager currenttimemillis
this retries   0
public void adderror
this lasterrortime   environmentedgemanager currenttimemillis
this retries
public long getlasterrortime
return this lasterrortime
/**
* set the number of retries to use serverside when trying to communicate
* with another server over {@link hconnection}.  used updating catalog
* tables, etc.  call this method before we create any connections.
* @param c the configuration instance to set the retries into.
* @param log used to log what we set in here.
*/
public static void setserversidehconnectionretries final configuration c  final string sn
final log log
int hcretries   c getint hconstants hbase_client_retries_number
hconstants default_hbase_client_retries_number
// go big.  multiply by 10.  if we can't get to meta after this many retries
// then something seriously wrong.
int serversidemultiplier   c getint    10
int retries   hcretries   serversidemultiplier
c setint hconstants hbase_client_retries_number  retries
log debug sn       retries