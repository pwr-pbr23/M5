/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import java io ioexception
import java util arraylist
import java util collections
import java util hashset
import java util list
import java util set
import java util concurrent callable
import java util concurrent concurrenthashmap
import java util concurrent executionexception
import java util concurrent executorservice
import java util concurrent executors
import java util concurrent future
import org apache commons cli commandline
import org apache commons cli commandlineparser
import org apache commons cli gnuparser
import org apache commons cli helpformatter
import org apache commons cli option
import org apache commons cli options
import org apache commons cli parseexception
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configured
import org apache hadoop fs fsdatainputstream
import org apache hadoop fs filestatus
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hbase hbaseconfiguration
import org apache hadoop hbase io hfilelink
import org apache hadoop hbase io hfile fixedfiletrailer
import org apache hadoop hbase regionserver hregionfilesystem
import org apache hadoop hbase regionserver storefileinfo
import org apache hadoop util tool
import org apache hadoop util toolrunner
/**
* tool to detect presence of any hfilev1 in the given directory. it prints all such regions which
* have such files.
* <p>
* to print the help section of the tool:
* <ul>
* <li>./bin/hbase org.apache.hadoop.hbase.util.hfilev1detector --h or,
* <li>java -cp `hbase classpath` org.apache.hadoop.hbase.util.hfilev1detector --h
* </ul>
* it also supports -h, --help, -help options.
* </p>
*/
public class hfilev1detector extends configured implements tool
private filesystem fs
private static final log log   logfactory getlog hfilev1detector class
private static final int default_num_of_threads   10
private int numofthreads
private path dirtoprocess
private final set<path> corruptedhfiles   collections
newsetfrommap new concurrenthashmap<path  boolean>
private final set<path> hfilev1set   collections
newsetfrommap new concurrenthashmap<path  boolean>
private options options   new options
public hfilev1detector
option pathoption   new option       true
pathoption setrequired false
options addoption pathoption
option threadoption   new option       true
threadoption setrequired false
options addoption threadoption
options addoption       false
private boolean parseoption string args  throws parseexception  ioexception
if  args length    0
return true     no args will process with default values
commandlineparser parser   new gnuparser
commandline cmd   parser parse options  args
if  cmd hasoption
helpformatter formatter   new helpformatter
formatter printhelp    options  true
system out
println
system out println
system out println
system out println     this getclass   getname
system out println
return false
if  cmd hasoption
dirtoprocess   new path cmd getoptionvalue
try
if  cmd hasoption
int n   integer parseint cmd getoptionvalue
if  n < 0    n > 100
system out println
default_num_of_threads
return true
numofthreads   n
catch  numberformatexception nfe
system err println
return false
return true
@override
public int run string args  throws ioexception  parseexception
fs   filesystem get getconf
numofthreads   default_num_of_threads
dirtoprocess   fsutils getrootdir getconf
if   parseoption args
system exit 1
executorservice exec   executors newfixedthreadpool numofthreads
set<path> regionswithhfilev1
try
regionswithhfilev1   checkforv1files dirtoprocess  exec
printhregionswithhfilev1 regionswithhfilev1
printallhfilev1
printcorruptedhfiles
if  hfilev1set isempty      corruptedhfiles isempty
// all clear.
system out println
catch  exception e
system err println e
return 1
finally
exec shutdown
fs close
return 0
/**
* takes a directory path, and lists out any hfilev1, if present.
* @param targetdir directory to start looking for hfilev1.
* @param exec
* @return set of regions that have hfilev1
* @throws ioexception
*/
private set<path> checkforv1files path targetdir  final executorservice exec  throws ioexception
if  istabledir fs  targetdir
return processtable targetdir  exec
// user has passed a hbase installation directory.
if   fs exists targetdir
throw new ioexception     targetdir
set<path> regionswithhfilev1   new hashset<path>
filestatus fsstats   fs liststatus targetdir
for  filestatus fsstat   fsstats
if  istabledir fs  fsstat getpath
// look for regions and find out any v1 file.
regionswithhfilev1 addall processtable fsstat getpath    exec
else
log info     fsstat getpath
return regionswithhfilev1
/**
* find out the regions in the table which has an hfile v1 in it.
* @param tabledir
* @param exec
* @return the set of regions containing hfile v1.
* @throws ioexception
*/
private set<path> processtable path tabledir  final executorservice exec  throws ioexception
// list out the regions and then process each file in it.
log info     tabledir
list<future<path>> regionlevelresults   new arraylist<future<path>>
set<path> regionswithhfilev1   new hashset<path>
filestatus fsstats   fs liststatus tabledir
for  filestatus fsstat   fsstats
// process each region
if  isregiondir fs  fsstat getpath
regionlevelresults add processregion fsstat getpath    exec
for  future<path> f   regionlevelresults
try
if  f get      null
regionswithhfilev1 add f get
catch  interruptedexception e
system err println e
catch  executionexception e
system err println e      might be a bad hfile  we print it at the end
return regionswithhfilev1
/**
* each region is processed by a separate handler. if a hregion has a hfilev1, its path is
* returned as the future result, otherwise, a null value is returned.
* @param regiondir region to process.
* @param exec
* @return corresponding future object.
*/
private future<path> processregion final path regiondir  final executorservice exec
log info     regiondir
callable<path> regioncallable   new callable<path>
@override
public path call   throws exception
for  path familydir   fsutils getfamilydirs fs  regiondir
filestatus storefiles   fsutils liststatus fs  familydir
if  storefiles    null    storefiles length    0  continue
for  filestatus storefile   storefiles
path storefilepath   storefile getpath
fsdatainputstream fsdis   null
long lentoread   0
try
// check whether this path is a reference.
if  storefileinfo isreference storefilepath   continue
// check whether this path is a hfilelink.
else if  hfilelink ishfilelink storefilepath
hfilelink filelink   new hfilelink getconf    storefilepath
fsdis   filelink open fs
lentoread   filelink getfilestatus fs  getlen
else
// a regular hfile
fsdis   fs open storefilepath
lentoread   storefile getlen
fixedfiletrailer trailer   fixedfiletrailer readfromstream fsdis  lentoread
int version   trailer getmajorversion
if  version    1
hfilev1set add storefilepath
// return this region path, as it needs to be compacted.
return regiondir
catch  exception iae
corruptedhfiles add storefilepath
finally
if  fsdis    null  fsdis close
return null
future<path> f   exec submit regioncallable
return f
private static boolean istabledir final filesystem fs  final path path  throws ioexception
return fstabledescriptors gettableinfopath fs  path     null
private static boolean isregiondir final filesystem fs  final path path  throws ioexception
path regioninfo   new path path  hregionfilesystem region_info_file
return fs exists regioninfo
private void printhregionswithhfilev1 set<path> regionshavinghfilev1
if   regionshavinghfilev1 isempty
system out println
system out println
system out println
for  path r   regionshavinghfilev1
system out println r
system out println
private void printallhfilev1
if   hfilev1set isempty
system out println
system out println
system out println
for  path r   hfilev1set
system out println r
system out println
private void printcorruptedhfiles
if   corruptedhfiles isempty
system out println
system out println
system out println
for  path r   corruptedhfiles
system out println r
system out println
public static void main string args  throws exception
system exit toolrunner run hbaseconfiguration create    new hfilev1detector    args