/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import static org apache hadoop hbase util order ascending
import static org apache hadoop hbase util order descending
import java math bigdecimal
import java math biginteger
import java math mathcontext
import java math roundingmode
import java nio charset charset
import java util comparator
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import com google common annotations visiblefortesting
/**
* utility class that handles ordered byte arrays. that is, unlike
* {@link bytes}, these methods produce byte arrays which maintain the sort
* order of the original values.
* <h3>encoding format summary</h3>
* <p>
* each value is encoded as one or more bytes. the first byte of the encoding,
* its meaning, and a terse description of the bytes that follow is given by
* the following table:
* <table>
* <tr><th>content type</th><th>encoding</th></tr>
* <tr><td>null</td><td>0x05</td></tr>
* <tr><td>negative infinity</td><td>0x07</td></tr>
* <tr><td>negative large</td><td>0x08, ~e, ~m</td></tr>
* <tr><td>negative medium</td><td>0x13-e, ~m</td></tr>
* <tr><td>negative small</td><td>0x14, -e, ~m</td></tr>
* <tr><td>zero</td><td>0x15</td></tr>
* <tr><td>positive small</td><td>0x16, ~-e, m</td></tr>
* <tr><td>positive medium</td><td>0x17+e, m</td></tr>
* <tr><td>positive large</td><td>0x22, e, m</td></tr>
* <tr><td>positive infinity</td><td>0x23</td></tr>
* <tr><td>nan</td><td>0x25</td></tr>
* <tr><td>fixed-length 32-bit integer</td><td>0x27, i</td></tr>
* <tr><td>fixed-length 64-bit integer</td><td>0x28, i</td></tr>
* <tr><td>fixed-length 32-bit float</td><td>0x30, f</td></tr>
* <tr><td>fixed-length 64-bit float</td><td>0x31, f</td></tr>
* <tr><td>text</td><td>0x33, t</td></tr>
* <tr><td>variable length blob</td><td>0x35, b</td></tr>
* <tr><td>byte-for-byte blob</td><td>0x36, x</td></tr>
* </table>
* </p>
*
* <h3>null encoding</h3>
* <p>
* each value that is a null encodes as a single byte of 0x05. since every
* other value encoding begins with a byte greater than 0x05, this forces null
* values to sort first.
* </p>
* <h3>text encoding</h3>
* <p>
* each text value begins with a single byte of 0x33 and ends with a single
* byte of 0x00. there are zero or more intervening bytes that encode the text
* value. the intervening bytes are chosen so that the encoding will sort in
* the desired collating order. the intervening bytes may not contain a 0x00
* character; the only 0x00 byte allowed in a text encoding is the final byte.
* </p>
* <p>
* the text encoding ends in 0x00 in order to ensure that when there are two
* strings where one is a prefix of the other that the shorter string will
* sort first.
* </p>
* <h3>binary encoding</h3>
* <p>
* there are two encoding strategies for binary fields, referred to as
* "blobvar" and "blobcopy". blobvar is less efficient in both space and
* encoding time. it has no limitations on the range of encoded values.
* blobcopy is a byte-for-byte copy of the input data followed by a
* termination byte. it is extremely fast to encode and decode. it carries the
* restriction of not allowing a 0x00 value in the input byte[] as this value
* is used as the termination byte.
* </p>
* <h4>blobvar</h4>
* <p>
* "blobvar" encodes the input byte[] in a manner similar to a variable length
* integer encoding. as with the other {@code orderedbytes} encodings,
* the first encoded byte is used to indicate what kind of value follows. this
* header byte is 0x35 for blobvar encoded values. as with the traditional
* varint encoding, the most significant bit of each subsequent encoded
* {@code byte} is used as a continuation marker. the 7 remaining bits
* contain the 7 most significant bits of the first unencoded byte. the next
* encoded byte starts with a continuation marker in the msb. the least
* significant bit from the first unencoded byte follows, and the remaining 6
* bits contain the 6 msbs of the second unencoded byte. the encoding
* continues, encoding 7 bytes on to 8 encoded bytes. the msb of the final
* encoded byte contains a termination marker rather than a continuation
* marker, and any remaining bits from the final input byte. any trailing bits
* in the final encoded byte are zeros.
* </p>
* <h4>blobcopy</h4>
* <p>
* "blobcopy" is a simple byte-for-byte copy of the input data. it uses 0x36
* as the header byte, and is terminated by 0x00 in the descending case. this
* alternative encoding is faster and more space-efficient, but it cannot
* accept values containing a 0x00 byte in descending order.
* </p>
* <h3>variable-length numeric encoding</h3>
* <p>
* numeric values must be coded so as to sort in numeric order. we assume that
* numeric values can be both integer and floating point values. clients must
* be careful to use inspection methods for encoded values (such as
* {@link #isnumericinfinite(positionedbyterange)} and
* {@link #isnumericnan(positionedbyterange)} to protect against decoding
* values into object which do not support these numeric concepts (such as
* {@link long} and {@link bigdecimal}).
* </p>
* <p>
* simplest cases first: if the numeric value is a nan, then the encoding is a
* single byte of 0x25. this causes nan values to sort after every other
* numeric value.
* </p>
* <p>
* if the numeric value is a negative infinity then the encoding is a single
* byte of 0x07. since every other numeric value except nan has a larger
* initial byte, this encoding ensures that negative infinity will sort prior
* to every other numeric value other than nan.
* </p>
* <p>
* if the numeric value is a positive infinity then the encoding is a single
* byte of 0x23. every other numeric value encoding begins with a smaller
* byte, ensuring that positive infinity always sorts last among numeric
* values. 0x23 is also smaller than 0x33, the initial byte of a text value,
* ensuring that every numeric value sorts before every text value.
* </p>
* <p>
* if the numeric value is exactly zero then it is encoded as a single byte of
* 0x15. finite negative values will have initial bytes of 0x08 through 0x14
* and finite positive values will have initial bytes of 0x16 through 0x22.
* </p>
* <p>
* for all numeric values, we compute a mantissa m and an exponent e. the
* mantissa is a base-100 representation of the value. the exponent e
* determines where to put the decimal point.
* </p>
* <p>
* each centimal digit of the mantissa is stored in a byte. if the value of
* the centimal digit is x (hence x&ge;0 and x&le;99) then the byte value will
* be 2*x+1 for every byte of the mantissa, except for the last byte which
* will be 2*x+0. the mantissa must be the minimum number of bytes necessary
* to represent the value; trailing x==0 digits are omitted. this means that
* the mantissa will never contain a byte with the value 0x00.
* </p>
* <p>
* if we assume all digits of the mantissa occur to the right of the decimal
* point, then the exponent e is the power of one hundred by which one must
* multiply the mantissa to recover the original value.
* </p>
* <p>
* values are classified as large, medium, or small according to the value of
* e. if e is 11 or more, the value is large. for e between 0 and 10, the
* value is medium. for e less than zero, the value is small.
* </p>
* <p>
* large positive values are encoded as a single byte 0x22 followed by e as a
* varint and then m. medium positive values are a single byte of 0x17+e
* followed by m. small positive values are encoded as a single byte 0x16
* followed by the ones-complement of the varint for -e followed by m.
* </p>
* <p>
* small negative values are encoded as a single byte 0x14 followed by -e as a
* varint and then the ones-complement of m. medium negative values are
* encoded as a byte 0x13-e followed by the ones-complement of m. large
* negative values consist of the single byte 0x08 followed by the
* ones-complement of the varint encoding of e followed by the ones-complement
* of m.
* </p>
* <h3>fixed-length integer encoding</h3>
* <p>
* all 4-byte integers are serialized to a 5-byte, fixed-width, sortable byte
* format. all 8-byte integers are serialized to the equivelant 9-byte format.
* serialization is performed by writing a header byte, inverting the integer
* sign bit and writing the resulting bytes to the byte array in big endian
* order.
* </p>
* <h3>fixed-length floating point encoding</h3>
* <p>
* 32-bit and 64-bit floating point numbers are encoded to a 5-byte and 9-byte
* encoding format, respectively. the format is identical, save for the
* precision respected in each step of the operation.
* <p>
* this format ensures the following total ordering of floating point values:
* float.negative_infinity &lt; -float.max_value &lt; ... &lt;
* -float.min_value &lt; -0.0 &lt; +0.0; &lt; float.min_value &lt; ... &lt;
* float.max_value &lt; float.positive_infinity &lt; float.nan
* </p>
* <p>
* floating point numbers are encoded as specified in ieee 754. a 32-bit
* single precision float consists of a sign bit, 8-bit unsigned exponent
* encoded in offset-127 notation, and a 23-bit significand. the format is
* described further in the <a
* href="http://en.wikipedia.org/wiki/single_precision"> single precision
* floating point wikipedia page</a>
* </p>
* <p>
* the value of a normal float is -1 <sup>sign bit</sup> &times;
* 2<sup>exponent - 127</sup> &times; 1.significand
* </p>
* <p>
* the iee754 floating point format already preserves sort ordering for
* positive floating point numbers when the raw bytes are compared in most
* significant byte order. this is discussed further at <a href=
* "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">
* http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm</a>
* </p>
* <p>
* thus, we need only ensure that negative numbers sort in the the exact
* opposite order as positive numbers (so that say, negative infinity is less
* than negative 1), and that all negative numbers compare less than any
* positive number. to accomplish this, we invert the sign bit of all floating
* point numbers, and we also invert the exponent and significand bits if the
* floating point number was negative.
* </p>
* <p>
* more specifically, we first store the floating point bits into a 32-bit int
* {@code j} using {@link float#floattointbits}. this method collapses
* all nans into a single, canonical nan value but otherwise leaves the bits
* unchanged. we then compute
* </p>
*
* <pre>
* j &circ;= (j &gt;&gt; (integer.size - 1)) | integer.min_size
* </pre>
* <p>
* which inverts the sign bit and xor's all other bits with the sign bit
* itself. comparing the raw bytes of {@code j} in most significant byte
* order is equivalent to performing a single precision floating point
* comparison on the underlying bits (ignoring nan comparisons, as nans don't
* compare equal to anything when performing floating point comparisons).
* </p>
* <p>
* the resulting integer is then converted into a byte array by serializing
* the integer one byte at a time in most significant byte order. the
* serialized integer is prefixed by a single header byte. all serialized
* values are 5 bytes in length.
* </p>
* <p>
* {@code orderedbytes} encodings are heavily influenced by the <a href="
* http://sqlite.org/src4/doc/trunk/www/key_encoding.wiki">sqlite4 key
* encoding</a>. slight deviations are make in the interest of order
* correctness and user extensibility. fixed-width {@code long} and
* {@link double} encodings are based on implementations from the now defunct
* orderly library.
* </p>
*/
@interfaceaudience public
@interfacestability evolving
public class orderedbytes
/*
* these constants define header bytes used to identify encoded values. note
* that the values here are not exhaustive as the numeric format encodes
* portions of its value within the header byte. the values listed here are
* directly applied to persisted data -- do not modify the values specified
* here. instead, gaps are placed intentionally between values so that new
* implementations can be inserted into the total ordering enforced here.
*/
private static final byte null   0x05
private static final byte neg_inf   0x07
private static final byte neg_large   0x08
private static final byte neg_med_min   0x09
private static final byte neg_med_max   0x13
private static final byte neg_small   0x14
private static final byte zero   0x15
private static final byte pos_small   0x16
private static final byte pos_med_min   0x17
private static final byte pos_med_max   0x21
private static final byte pos_large   0x22
private static final byte pos_inf   0x23
private static final byte nan   0x25
private static final byte fixed_int32   0x27
private static final byte fixed_int64   0x28
private static final byte fixed_float32   0x30
private static final byte fixed_float64   0x31
private static final byte text   0x33
private static final byte blob_var   0x35
private static final byte blob_copy   0x36
/*
* the following constant values are used by encoding implementations
*/
public static final charset utf8   charset forname
private static final byte term   0x00
private static final bigdecimal e8   bigdecimal valueof 1e8
private static final bigdecimal e32   bigdecimal valueof 1e32
private static final bigdecimal en2   bigdecimal valueof 1e 2
private static final bigdecimal en10   bigdecimal valueof 1e 10
/**
* max precision guaranteed to fit into a {@code long}.
*/
public static final int max_precision   31
/**
* the context used to normalize {@link bigdecimal} values.
*/
public static final mathcontext default_math_context
new mathcontext max_precision  roundingmode half_up
/**
* creates the standard exception when the encoded header byte is unexpected for the decoding
* context.
* @param header value used in error message.
*/
private static illegalargumentexception unexpectedheader byte header
throw new illegalargumentexception
long tohexstring header
/**
* perform unsigned comparison between two long values. conforms to the same interface as
* {@link comparator#compare(object, object)}.
*/
private static int unsignedcmp long x1  long x2
int cmp
if   cmp    x1 < x2 ?  1    x1    x2 ? 0   1       0  return 0
// invert the result when either value is negative
if   x1 < 0      x2 < 0   return  cmp
return cmp
/**
* write a 32-bit unsigned integer to {@code dst} as 4 big-endian bytes.
* @return number of bytes written.
*/
private static int putuint32 positionedbyterange dst  int val
dst put  byte   val >>> 24
put  byte   val >>> 16
put  byte   val >>> 8
put  byte  val
return 4
/**
* encode an unsigned 64-bit unsigned integer {@code val} into {@code dst}.
* @param dst the destination to which encoded bytes are written.
* @param val the value to write.
* @param comp compliment the encoded value when {@code comp} is true.
* @return number of bytes written.
*/
@visiblefortesting
static int putvaruint64 positionedbyterange dst  long val  boolean comp
int w  y  len   0
final int offset   dst getoffset    start   dst getposition
byte a   dst getbytes
order ord   comp ? descending   ascending
if   1    unsignedcmp val  241l
dst put  byte  val
len   dst getposition     start
ord apply a  offset   start  len
return len
if   1    unsignedcmp val  2288l
y    int   val   240
dst put  byte   y   256   241
put  byte   y % 256
len   dst getposition     start
ord apply a  offset   start  len
return len
if   1    unsignedcmp val  67824l
y    int   val   2288
dst put  byte  249
put  byte   y   256
put  byte   y % 256
len   dst getposition     start
ord apply a  offset   start  len
return len
y    int  val
w    int   val >>> 32
if  w    0
if   1    unsignedcmp y  16777216l
dst put  byte  250
put  byte   y >>> 16
put  byte   y >>> 8
put  byte  y
len   dst getposition     start
ord apply a  offset   start  len
return len
dst put  byte  251
putuint32 dst  y
len   dst getposition     start
ord apply a  offset   start  len
return len
if   1    unsignedcmp w  256l
dst put  byte  252
put  byte  w
putuint32 dst  y
len   dst getposition     start
ord apply a  offset   start  len
return len
if   1    unsignedcmp w  65536l
dst put  byte  253
put  byte   w >>> 8
put  byte  w
putuint32 dst  y
len   dst getposition     start
ord apply a  offset   start  len
return len
if   1    unsignedcmp w  16777216l
dst put  byte  254
put  byte   w >>> 16
put  byte   w >>> 8
put  byte  w
putuint32 dst  y
len   dst getposition     start
ord apply a  offset   start  len
return len
dst put  byte  255
putuint32 dst  w
putuint32 dst  y
len   dst getposition     start
ord apply a  offset   start  len
return len
/**
* inspect {@code src} for an encoded varuint64 for its length in bytes.
* preserves the state of {@code src}.
* @param src source buffer
* @param comp if true, parse the compliment of the value.
* @return the number of bytes consumed by this value.
*/
@visiblefortesting
static int lengthvaruint64 positionedbyterange src  boolean comp
int a0    comp ? descending   ascending  apply src peek      0xff
if  a0 <  240  return 1
if  a0 >  241    a0 <  248  return 2
if  a0    249  return 3
if  a0    250  return 4
if  a0    251  return 5
if  a0    252  return 6
if  a0    253  return 7
if  a0    254  return 8
if  a0    255  return 9
throw unexpectedheader src peek
/**
* skip {@code src} over the encoded varuint64.
* @param src source buffer
* @param cmp if true, parse the compliment of the value.
* @return the number of bytes skipped.
*/
@visiblefortesting
static int skipvaruint64 positionedbyterange src  boolean cmp
final int len   lengthvaruint64 src  cmp
src setposition src getposition     len
return len
/**
* decode a sequence of bytes in {@code src} as a varuint64. compliment the
* encoded value when {@code comp} is true.
* @return the decoded value.
*/
@visiblefortesting
static long getvaruint64 positionedbyterange src  boolean comp
assert src getremaining   >  lengthvaruint64 src  comp
final long ret
order ord   comp ? descending   ascending
byte x   src get
final int a0   ord apply x    0xff  a1  a2  a3  a4  a5  a6  a7  a8
if   1    unsignedcmp a0  241
return a0
x   src get
a1   ord apply x    0xff
if   1    unsignedcmp a0  249
return  a0   241    256   a1   240
x   src get
a2   ord apply x    0xff
if  a0    249
return 2288   256   a1   a2
x   src get
a3   ord apply x    0xff
if  a0    250
return  a1 << 16     a2 << 8    a3
x   src get
a4   ord apply x    0xff
ret      long  a1  << 24     a2 << 16     a3 << 8    a4
if  a0    251
return ret
x   src get
a5   ord apply x    0xff
if  a0    252
return  ret << 8    a5
x   src get
a6   ord apply x    0xff
if  a0    253
return  ret << 16     a5 << 8    a6
x   src get
a7   ord apply x    0xff
if  a0    254
return  ret << 24     a5 << 16     a6 << 8    a7
x   src get
a8   ord apply x    0xff
return  ret << 32       long  a5  << 24     a6 << 16     a7 << 8    a8
/**
* strip all trailing zeros to ensure that no digit will be zero and round
* using our default context to ensure precision doesn't exceed max allowed.
* from phoenix's {@code numberutil}.
* @return new {@link bigdecimal} instance
*/
@visiblefortesting
static bigdecimal normalize bigdecimal val
return null    val ? null   val striptrailingzeros   round default_math_context
/**
* read significand digits from {@code src} according to the magnitude
* of {@code e}.
* @param src the source from which to read encoded digits.
* @param e the magnitude of the first digit read.
* @param comp treat encoded bytes as compliments when {@code comp} is true.
* @return the decoded value.
* @throws illegalargumentexception when read exceeds the remaining length
*     of {@code src}.
*/
private static bigdecimal decodesignificand positionedbyterange src  int e  boolean comp
// todo: can this be made faster?
byte a   src getbytes
final int start   src getposition    offset   src getoffset    remaining   src getremaining
order ord   comp ? descending   ascending
bigdecimal m   bigdecimal zero
e
for  int i   0   i
if  i > remaining
// we've exceeded this range's window
src setposition start
throw new illegalargumentexception
offset
start   i
// base-100 digits are encoded as val * 2 + 1 except for the termination digit.
m   m add     m
new bigdecimal biginteger one  e    2  multiply     100 ^ p
bigdecimal valueof  ord apply a    0xff    2
e
// detect termination digit
if   ord apply a    1     0
src setposition start   i   1
break
return normalize m
/**
* skip {@code src} over the significand bytes.
* @param src the source from which to read encoded digits.
* @param comp treat encoded bytes as compliments when {@code comp} is true.
* @return the number of bytes skipped.
*/
private static int skipsignificand positionedbyterange src  boolean comp
byte a   src getbytes
final int offset   src getoffset    start   src getposition
int i   src getposition
while    comp ? descending   ascending  apply a    1     0
src setposition i
return i   start
/**
* <p>
* encode the small magnitude floating point number {@code val} using the
* key encoding. the caller guarantees that 1.0 > abs(val) > 0.0.
* </p>
* <p>
* a floating point value is encoded as an integer exponent {@code e} and a
* mantissa {@code m}. the original value is equal to {@code (m * 100^e)}.
* {@code e} is set to the smallest value possible without making {@code m}
* greater than or equal to 1.0.
* </p>
* <p>
* for this routine, {@code e} will always be zero or negative, since the
* original value is less than one. the encoding written by this routine is
* the ones-complement of the varint of the negative of {@code e} followed
* by the mantissa:
* <pre>
*   encoding:   ~-e  m
* </pre>
* </p>
* @param dst the destination to which encoded digits are written.
* @param val the value to encode.
* @return the number of bytes written.
*/
private static int encodenumericsmall positionedbyterange dst  bigdecimal val
// todo: this can be done faster?
// assert 1.0 > abs(val) > 0.0
bigdecimal abs   val abs
assert bigdecimal zero compareto abs  < 0    bigdecimal one compareto abs  > 0
byte a   dst getbytes
boolean isneg   val signum       1
final int offset   dst getoffset    start   dst getposition
int e   0  d  startm
if  isneg       small negative number  0x14   e  ~m
dst put neg_small
else      small positive number  0x16  ~ e  m
dst put pos_small
// normalize abs(val) to determine e
while  abs compareto en10  < 0    abs   abs movepointright 8   e    4
while  abs compareto en2  < 0    abs   abs movepointright 2   e
putvaruint64 dst  e   isneg      encode appropriate e value
// encode m by peeling off centimal digits, encoding x as 2x+1
startm   dst getposition
// todo: 18 is an arbitrary encoding limit. reevaluate once we have a better handling of
// numeric scale.
for  int i   0  i < 18    abs compareto bigdecimal zero     0  i
abs   abs movepointright 2
d   abs intvalue
dst put  byte    2   d   1    0xff
abs   abs subtract bigdecimal valueof d
a    0xfe     terminal digit should be 2x
if  isneg
// negative values encoded as ~m
descending apply a  offset   startm  dst getposition     startm
return dst getposition     start
/**
* encode the large magnitude floating point number {@code val} using
* the key encoding. the caller guarantees that {@code val} will be
* finite and abs(val) >= 1.0.
* <p>
* a floating point value is encoded as an integer exponent {@code e}
* and a mantissa {@code m}. the original value is equal to
* {@code (m * 100^e)}. {@code e} is set to the smallest value
* possible without making {@code m} greater than or equal to 1.0.
* </p>
* <p>
* each centimal digit of the mantissa is stored in a byte. if the value of
* the centimal digit is {@code x} (hence {@code x>=0} and
* {@code x<=99}) then the byte value will be {@code 2*x+1} for
* every byte of the mantissa, except for the last byte which will be
* {@code 2*x+0}. the mantissa must be the minimum number of bytes
* necessary to represent the value; trailing {@code x==0} digits are
* omitted. this means that the mantissa will never contain a byte with the
* value {@code 0x00}.
* </p>
* <p>
* if {@code e > 10}, then this routine writes of {@code e} as a
* varint followed by the mantissa as described above. otherwise, if
* {@code e <= 10}, this routine only writes the mantissa and leaves
* the {@code e} value to be encoded as part of the opening byte of the
* field by the calling function.
*
* <pre>
*   encoding:  m       (if e<=10)
*              e m     (if e>10)
* </pre>
* </p>
* @param dst the destination to which encoded digits are written.
* @param val the value to encode.
* @return the number of bytes written.
*/
private static int encodenumericlarge positionedbyterange dst  bigdecimal val
// todo: this can be done faster
bigdecimal abs   val abs
byte a   dst getbytes
boolean isneg   val signum       1
final int start   dst getposition    offset   dst getoffset
int e   0  d  startm
if  isneg       large negative number  0x08  ~e  ~m
dst put neg_large
else      large positive number  0x22  e  m
dst put pos_large
// normalize abs(val) to determine e
while  abs compareto e32  >  0    e <  350    abs   abs movepointleft 32   e   16
while  abs compareto e8  >  0    e <  350    abs   abs movepointleft 8   e   4
while  abs compareto bigdecimal one  >  0    e <  350    abs   abs movepointleft 2   e
// encode appropriate header byte and/or e value.
if  e > 10       large number  write out  ~  e
putvaruint64 dst  e  isneg
else
if  isneg       medium negative number  0x13 e  ~m
dst put start   byte   neg_med_max   e
else      medium positive number  0x17 e  m
dst put start   byte   pos_med_min   e
// encode m by peeling off centimal digits, encoding x as 2x+1
startm   dst getposition
// todo: 18 is an arbitrary encoding limit. reevaluate once we have a better handling of
// numeric scale.
for  int i   0  i < 18    abs compareto bigdecimal zero     0  i
abs   abs movepointright 2
d   abs intvalue
dst put  byte   2   d   1
abs   abs subtract bigdecimal valueof d
a    0xfe     terminal digit should be 2x
if  isneg
// negative values encoded as ~m
descending apply a  offset   startm  dst getposition     startm
return dst getposition     start
/**
* encode a numerical value using the variable-length encoding.
* @param dst the destination to which encoded digits are written.
* @param val the value to encode.
* @param ord the {@link order} to respect while encoding {@code val}.
* @return the number of bytes written.
*/
public static int encodenumeric positionedbyterange dst  long val  order ord
return encodenumeric dst  bigdecimal valueof val   ord
/**
* encode a numerical value using the variable-length encoding.
* @param dst the destination to which encoded digits are written.
* @param val the value to encode.
* @param ord the {@link order} to respect while encoding {@code val}.
* @return the number of bytes written.
*/
public static int encodenumeric positionedbyterange dst  double val  order ord
if  val    0 0
dst put ord apply zero
return 1
if  double isnan val
dst put ord apply nan
return 1
if  val    double negative_infinity
dst put ord apply neg_inf
return 1
if  val    double positive_infinity
dst put ord apply pos_inf
return 1
return encodenumeric dst  bigdecimal valueof val   ord
/**
* encode a numerical value using the variable-length encoding.
* @param dst the destination to which encoded digits are written.
* @param val the value to encode.
* @param ord the {@link order} to respect while encoding {@code val}.
* @return the number of bytes written.
*/
public static int encodenumeric positionedbyterange dst  bigdecimal val  order ord
final int len  offset   dst getoffset    start   dst getposition
if  null    val
return encodenull dst  ord
else if  bigdecimal zero compareto val     0
dst put ord apply zero
return 1
bigdecimal abs   val abs
if  bigdecimal one compareto abs  <  0       abs v  >  1 0
len   encodenumericlarge dst  normalize val
else      1 0 > abs v  >  0 0
len   encodenumericsmall dst  normalize val
ord apply dst getbytes    offset   start  len
return len
/**
* decode a {@link bigdecimal} from {@code src}. assumes {@code src} encodes
* a value in numeric encoding and is within the valid range of
* {@link bigdecimal} values. {@link bigdecimal} does not support {@code nan}
* or {@code infinte} values.
* @see #decodenumericasdouble(byte[], int)
*/
private static bigdecimal decodenumericvalue positionedbyterange src
final int e
byte header   src get
boolean dsc    1    integer signum header
header   dsc ? descending apply header    header
if  header    null  return null
if  header    neg_large       large negative number  0x08  ~e  ~m
e    int  getvaruint64 src   dsc
return decodesignificand src  e   dsc  negate
if  header >  neg_med_min    header <  neg_med_max
/* medium negative number: 0x13-e, ~m */
e   neg_med_max   header
return decodesignificand src  e   dsc  negate
if  header    neg_small       small negative number  0x14   e  ~m
e    int   getvaruint64 src  dsc
return decodesignificand src  e   dsc  negate
if  header    zero
return bigdecimal zero
if  header    pos_small       small positive number  0x16  ~ e  m
e    int   getvaruint64 src   dsc
return decodesignificand src  e  dsc
if  header >  pos_med_min    header <  pos_med_max
/* medium positive number: 0x17+e, m */
e   header   pos_med_min
return decodesignificand src  e  dsc
if  header    pos_large       large positive number  0x22  e  m
e    int  getvaruint64 src  dsc
return decodesignificand src  e  dsc
throw unexpectedheader header
/**
* decode a primitive {@code double} value from the numeric encoding. numeric
* encoding is based on {@link bigdecimal}; in the event the encoded value is
* larger than can be represented in a {@code double}, this method performs
* an implicit narrowing conversion as described in
* {@link bigdecimal#doublevalue()}.
* @throws nullpointerexception when the encoded value is {@code null}.
* @throws illegalargumentexception when the encoded value is not a numeric.
* @see #encodenumeric(positionedbyterange, double, order)
* @see bigdecimal#doublevalue()
*/
public static double decodenumericasdouble positionedbyterange src
// todo: should an encoded null value throw unexpectedheader() instead?
if  isnull src
throw new nullpointerexception
if  isnumericnan src
src get
return double nan
if  isnumericzero src
src get
return double valueof 0 0
byte header    1    integer signum src peek    ? descending apply src peek      src peek
if  header    neg_inf
src get
return double negative_infinity
else if  header    pos_inf
src get
return double positive_infinity
else
return decodenumericvalue src  doublevalue
/**
* decode a primitive {@code long} value from the numeric encoding. numeric
* encoding is based on {@link bigdecimal}; in the event the encoded value is
* larger than can be represented in a {@code long}, this method performs an
* implicit narrowing conversion as described in
* {@link bigdecimal#doublevalue()}.
* @throws nullpointerexception when the encoded value is {@code null}.
* @throws illegalargumentexception when the encoded value is not a numeric.
* @see #encodenumeric(positionedbyterange, long, order)
* @see bigdecimal#longvalue()
*/
public static long decodenumericaslong positionedbyterange src
// todo: should an encoded null value throw unexpectedheader() instead?
if  isnull src   throw new nullpointerexception
if   isnumeric src   throw unexpectedheader src peek
if  isnumericnan src   throw unexpectedheader src peek
if  isnumericinfinite src   throw unexpectedheader src peek
if  isnumericzero src
src get
return long valueof 0
return decodenumericvalue src  longvalue
/**
* decode a {@link bigdecimal} value from the variable-length encoding.
* @throws illegalargumentexception when the encoded value is not a numeric.
* @see #encodenumeric(positionedbyterange, bigdecimal, order)
*/
public static bigdecimal decodenumericasbigdecimal positionedbyterange src
if  isnull src
src get
return null
if   isnumeric src   throw unexpectedheader src peek
if  isnumericnan src   throw unexpectedheader src peek
if  isnumericinfinite src   throw unexpectedheader src peek
return decodenumericvalue src
/**
* encode a string value. string encoding is 0x00-terminated and so it does
* not support {@code \u0000} codepoints in the value.
* @param dst the destination to which the encoded value is written.
* @param val the value to encode.
* @param ord the {@link order} to respect while encoding {@code val}.
* @return the number of bytes written.
* @throws illegalargumentexception when {@code val} contains a {@code \u0000}.
*/
public static int encodestring positionedbyterange dst  string val  order ord
if  null    val
return encodenull dst  ord
if  val contains
throw new illegalargumentexception
final int offset   dst getoffset    start   dst getposition
dst put text
// todo: is there no way to decode into dst directly?
dst put val getbytes utf8
dst put term
ord apply dst getbytes    offset   start  dst getposition     start
return dst getposition     start
/**
* decode a string value.
*/
public static string decodestring positionedbyterange src
final byte header   src get
if  header    null    header    descending apply null
return null
assert header    text    header    descending apply text
order ord   header    text ? ascending   descending
byte a   src getbytes
final int offset   src getoffset    start   src getposition
final byte terminator   ord apply term
int i   offset   start
for    a    terminator  i
src setposition i   offset   1      advance position to term   1
if  descending    ord
// make a copy so that we don't disturb encoded value with ord.
byte copy   new byte
system arraycopy a  offset   start  copy  0  copy length
ord apply copy
return new string copy  utf8
else
return new string a  offset   start  i   offset   1  utf8
/**
* calculate the expected blobvar encoded length based on unencoded length.
*/
public static int blobvarencodedlength int len
if  0    len
return 2     1 byte header   1 byte terminator
else
return  int
math ceil
len   8     8 bits per input byte
7 0        7 bits of input data per encoded byte  rounded up
1              1 byte header
/**
* calculate the expected blobvar decoded length based on encoded length.
*/
@visiblefortesting
static int blobvardecodedlength int len
return
len
1     1 byte header
7     7 bits of payload per encoded byte
8     8 bits per byte
/**
* encode a blob value using a modified varint encoding scheme.
* <p>
* this format encodes a byte[] value such that no limitations on the input
* value are imposed. the first byte encodes the encoding scheme that
* follows, {@link #blob_var}. each encoded byte thereafter consists of a
* header bit followed by 7 bits of payload. a header bit of '1' indicates
* continuation of the encoding. a header bit of '0' indicates this byte
* contains the last of the payload. an empty input value is encoded as the
* header byte immediately followed by a termination byte {@code 0x00}. this
* is not ambiguous with the encoded value of {@code []}, which results in
* {@code [0x80, 0x00]}.
* </p>
* @return the number of bytes written.
*/
public static int encodeblobvar positionedbyterange dst  byte val  int voff  int vlen
order ord
if  null    val
return encodenull dst  ord
// empty value is null-terminated. all other values are encoded as 7-bits per byte.
assert dst getremaining   >  blobvarencodedlength vlen
final int offset   dst getoffset    start   dst getposition
dst put blob_var
if  0    vlen
dst put term
else
byte s   1  t   0
for  int i   voff  i < vlen  i
dst put  byte   0x80   t     val   0xff  >>> s
if  s < 7
t    byte   val <<  7   s
s
else
dst put  byte   0x80   val
s   1
t   0
if  s > 1
dst put  byte   0x7f   t
else
dst getbytes      0x7f
ord apply dst getbytes    offset   start  dst getposition     start
return dst getposition     start
/**
* encode a blob value using a modified varint encoding scheme.
* @return the number of bytes written.
* @see #encodeblobvar(positionedbyterange, byte[], int, int, order)
*/
public static int encodeblobvar positionedbyterange dst  byte val  order ord
return encodeblobvar dst  val  0  null    val ? val length   0  ord
/**
* decode a blob value that was encoded using blobvar encoding.
*/
public static byte decodeblobvar positionedbyterange src
final byte header   src get
if  header    null    header    descending apply null
return null
assert header    blob_var    header    descending apply blob_var
order ord   blob_var    header ? ascending   descending
if  src peek      ord apply term
// skip empty input buffer.
src get
return new byte
final int offset   src getoffset    start   src getposition
int end
byte a   src getbytes
for  end   start   byte   ord apply a    0x80     term  end
end       increment end to 1 past last byte
// create ret buffer using length of encoded data + 1 (header byte)
positionedbyterange ret   new simplepositionedbyterange blobvardecodedlength end   start   1
int s   6
byte t    byte    ord apply a  << 1    0xff
for  int i   start   1  i < end  i
if  s    7
ret put  byte   t    ord apply a    0x7f
i
else
ret put  byte   t     ord apply a    0x7f  >>> s
if  i    end  break
t    byte    ord apply a  << 8   s    0xff
s   s    1 ? 7   s   1
src setposition end
assert t    0
assert ret getposition      ret getlength
return ret getbytes
/**
* encode a blob value as a byte-for-byte copy. blobcopy encoding in
* descending order is null terminated so as to preserve proper sorting of
* {@code []} and so it does not support {@code 0x00} in the value.
* @return the number of bytes written.
* @throws illegalargumentexception when {@code ord} is descending and
*    {@code val} contains a {@code 0x00} byte.
*/
public static int encodeblobcopy positionedbyterange dst  byte val  int voff  int vlen
order ord
if  null    val
encodenull dst  ord
if  ascending    ord  return 1
else
// descending ordered blobcopy requires a termination bit to preserve
// sort-order semantics of null values.
dst put ord apply term
return 2
// blobs as final entry in a compound key are written unencoded.
assert dst getremaining   >  vlen    ascending    ord ? 1   2
if  descending    ord
for  int i   0  i < vlen  i
if  term    val
throw new illegalargumentexception
final int offset   dst getoffset    start   dst getposition
dst put blob_copy
dst put val  voff  vlen
// descending ordered blobcopy requires a termination bit to preserve
// sort-order semantics of null values.
if  descending    ord  dst put term
ord apply dst getbytes    offset   start  dst getposition     start
return dst getposition     start
/**
* encode a blob value as a byte-for-byte copy. blobcopy encoding in
* descending order is null terminated so as to preserve proper sorting of
* {@code []} and so it does not support {@code 0x00} in the value.
* @return the number of bytes written.
* @throws illegalargumentexception when {@code ord} is descending and
*    {@code val} contains a {@code 0x00} byte.
* @see #encodeblobcopy(positionedbyterange, byte[], int, int, order)
*/
public static int encodeblobcopy positionedbyterange dst  byte val  order ord
return encodeblobcopy dst  val  0  null    val ? val length   0  ord
/**
* decode a blob value, byte-for-byte copy.
* @see #encodeblobcopy(positionedbyterange, byte[], int, int, order)
*/
public static byte decodeblobcopy positionedbyterange src
byte header   src get
if  header    null    header    descending apply null
return null
assert header    blob_copy    header    descending apply blob_copy
order ord   header    blob_copy ? ascending   descending
final int length   src getremaining      ascending    ord ? 0   1
byte ret   new byte
src get ret
ord apply ret  0  ret length
// descending ordered blobcopy requires a termination bit to preserve
// sort-order semantics of null values.
if  descending    ord  src get
return ret
/**
* encode a null value.
* @param dst the destination to which encoded digits are written.
* @param ord the {@link order} to respect while encoding {@code val}.
* @return the number of bytes written.
*/
public static int encodenull positionedbyterange dst  order ord
dst put ord apply null
return 1
/**
* encode an {@code int32} value using the fixed-length encoding.
* @return the number of bytes written.
* @see #encodeint64(positionedbyterange, long, order)
* @see #decodeint32(positionedbyterange)
*/
public static int encodeint32 positionedbyterange dst  int val  order ord
final int offset   dst getoffset    start   dst getposition
dst put fixed_int32
put  byte    val >> 24  ^ 0x80
put  byte   val >> 16
put  byte   val >> 8
put  byte  val
ord apply dst getbytes    offset   start  5
return 5
/**
* decode an {@code int32} value.
* @see #encodeint32(positionedbyterange, int, order)
*/
public static int decodeint32 positionedbyterange src
final byte header   src get
assert header    fixed_int32    header    descending apply fixed_int32
order ord   header    fixed_int32 ? ascending   descending
int val    ord apply src get    ^ 0x80    0xff
for  int i   1  i < 4  i
val    val << 8     ord apply src get      0xff
return val
/**
* encode an {@code int64} value using the fixed-length encoding.
* <p>
* this format ensures that all longs sort in their natural order, as they
* would sort when using signed long comparison.
* </p>
* <p>
* all longs are serialized to an 8-byte, fixed-width sortable byte format.
* serialization is performed by inverting the integer sign bit and writing
* the resulting bytes to the byte array in big endian order. the encoded
* value is prefixed by the {@link #fixed_int64} header byte. this encoding
* is designed to handle java language primitives and so null values are not
* supported by this implementation.
* </p>
* <p>
* for example:
* </p>
* <pre>
* input:   0x0000000000000005 (5)
* result:  0x288000000000000005
*
* input:   0xfffffffffffffffb (-4)
* result:  0x280000000000000004
*
* input:   0x7fffffffffffffff (long.max_value)
* result:  0x28ffffffffffffffff
*
* input:   0x8000000000000000 (long.min_value)
* result:  0x287fffffffffffffff
* </pre>
* <p>
* this encoding format, and much of this documentation string, is based on
* orderly's {@code fixedintwritablerowkey}.
* </p>
* @return the number of bytes written.
* @see #decodeint64(positionedbyterange)
*/
public static int encodeint64 positionedbyterange dst  long val  order ord
final int offset   dst getoffset    start   dst getposition
dst put fixed_int64
put  byte    val >> 56  ^ 0x80
put  byte   val >> 48
put  byte   val >> 40
put  byte   val >> 32
put  byte   val >> 24
put  byte   val >> 16
put  byte   val >> 8
put  byte  val
ord apply dst getbytes    offset   start  9
return 9
/**
* decode an {@code int64} value.
* @see #encodeint64(positionedbyterange, long, order)
*/
public static long decodeint64 positionedbyterange src
final byte header   src get
assert header    fixed_int64    header    descending apply fixed_int64
order ord   header    fixed_int64 ? ascending   descending
long val    ord apply src get    ^ 0x80    0xff
for  int i   1  i < 8  i
val    val << 8     ord apply src get      0xff
return val
/**
* encode a 32-bit floating point value using the fixed-length encoding.
* encoding format is described at length in
* {@link #encodefloat64(positionedbyterange, double, order)}.
* @return the number of bytes written.
* @see #decodefloat32(positionedbyterange)
* @see #encodefloat64(positionedbyterange, double, order)
*/
public static int encodefloat32 positionedbyterange dst  float val  order ord
final int offset   dst getoffset    start   dst getposition
int i   float floattointbits val
i ^    i >> integer size   1    integer min_value
dst put fixed_float32
put  byte   i >> 24
put  byte   i >> 16
put  byte   i >> 8
put  byte  i
ord apply dst getbytes    offset   start  5
return 5
/**
* decode a 32-bit floating point value using the fixed-length encoding.
* @see #encodefloat32(positionedbyterange, float, order)
*/
public static float decodefloat32 positionedbyterange src
final byte header   src get
assert header    fixed_float32    header    descending apply fixed_float32
order ord   header    fixed_float32 ? ascending   descending
int val   ord apply src get      0xff
for  int i   1  i < 4  i
val    val << 8     ord apply src get      0xff
val ^   ~val >> integer size   1    integer min_value
return float intbitstofloat val
/**
* encode a 64-bit floating point value using the fixed-length encoding.
* <p>
* this format ensures the following total ordering of floating point
* values: double.negative_infinity &lt; -double.max_value &lt; ... &lt;
* -double.min_value &lt; -0.0 &lt; +0.0; &lt; double.min_value &lt; ...
* &lt; double.max_value &lt; double.positive_infinity &lt; double.nan
* </p>
* floating point numbers are encoded as specified in ieee 754. a 64-bit
* double precision float consists of a sign bit, 11-bit unsigned exponent
* encoded in offset-1023 notation, and a 52-bit significand. the format is
* described further in the <a
* href="http://en.wikipedia.org/wiki/double_precision"> double precision
* floating point wikipedia page</a> </p>
* <p>
* the value of a normal float is -1 <sup>sign bit</sup> &times;
* 2<sup>exponent - 1023</sup> &times; 1.significand
* </p>
* <p>
* the iee754 floating point format already preserves sort ordering for
* positive floating point numbers when the raw bytes are compared in most
* significant byte order. this is discussed further at <a href=
* "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"
* > http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.
* htm</a>
* </p>
* <p>
* thus, we need only ensure that negative numbers sort in the the exact
* opposite order as positive numbers (so that say, negative infinity is
* less than negative 1), and that all negative numbers compare less than
* any positive number. to accomplish this, we invert the sign bit of all
* floating point numbers, and we also invert the exponent and significand
* bits if the floating point number was negative.
* </p>
* <p>
* more specifically, we first store the floating point bits into a 64-bit
* long {@code l} using {@link double#doubletolongbits}. this method
* collapses all nans into a single, canonical nan value but otherwise
* leaves the bits unchanged. we then compute
* </p>
* <pre>
* l &circ;= (l &gt;&gt; (long.size - 1)) | long.min_size
* </pre>
* <p>
* which inverts the sign bit and xor's all other bits with the sign bit
* itself. comparing the raw bytes of {@code l} in most significant
* byte order is equivalent to performing a double precision floating point
* comparison on the underlying bits (ignoring nan comparisons, as nans
* don't compare equal to anything when performing floating point
* comparisons).
* </p>
* <p>
* the resulting long integer is then converted into a byte array by
* serializing the long one byte at a time in most significant byte order.
* the serialized integer is prefixed by a single header byte. all
* serialized values are 9 bytes in length.
* </p>
* <p>
* this encoding format, and much of this highly detailed documentation
* string, is based on orderly's {@code doublewritablerowkey}.
* </p>
* @return the number of bytes written.
* @see #decodefloat64(positionedbyterange)
*/
public static int encodefloat64 positionedbyterange dst  double val  order ord
final int offset   dst getoffset    start   dst getposition
long lng   double doubletolongbits val
lng ^    lng >> long size   1    long min_value
dst put fixed_float64
put  byte   lng >> 56
put  byte   lng >> 48
put  byte   lng >> 40
put  byte   lng >> 32
put  byte   lng >> 24
put  byte   lng >> 16
put  byte   lng >> 8
put  byte  lng
ord apply dst getbytes    offset   start  9
return 9
/**
* decode a 64-bit floating point value using the fixed-length encoding.
* @see #encodefloat64(positionedbyterange, double, order)
*/
public static double decodefloat64 positionedbyterange src
final byte header   src get
assert header    fixed_float64    header    descending apply fixed_float64
order ord   header    fixed_float64 ? ascending   descending
long val   ord apply src get      0xff
for  int i   1  i < 8  i
val    val << 8     ord apply src get      0xff
val ^   ~val >> long size   1    long min_value
return double longbitstodouble val
/**
* returns true when {@code src} appears to be positioned an encoded value,
* false otherwise.
*/
public static boolean isencodedvalue positionedbyterange src
return isnull src     isnumeric src     isfixedint32 src     isfixedint64 src
isfixedfloat32 src     isfixedfloat64 src     istext src     isblobcopy src
isblobvar src
/**
* return true when the next encoded value in {@code src} is null, false
* otherwise.
*/
public static boolean isnull positionedbyterange src
return null
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses numeric
* encoding, false otherwise. {@code nan}, {@code +/-inf} are valid numeric
* values.
*/
public static boolean isnumeric positionedbyterange src
byte x     1    integer signum src peek    ? descending   ascending  apply src peek
return x >  neg_inf    x <  nan
/**
* return true when the next encoded value in {@code src} uses numeric
* encoding and is {@code infinite}, false otherwise.
*/
public static boolean isnumericinfinite positionedbyterange src
byte x     1    integer signum src peek    ? descending   ascending  apply src peek
return neg_inf    x    pos_inf    x
/**
* return true when the next encoded value in {@code src} uses numeric
* encoding and is {@code nan}, false otherwise.
*/
public static boolean isnumericnan positionedbyterange src
return nan      1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses numeric
* encoding and is {@code 0}, false otherwise.
*/
public static boolean isnumericzero positionedbyterange src
return zero
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses fixed-width
* int32 encoding, false otherwise.
*/
public static boolean isfixedint32 positionedbyterange src
return fixed_int32
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses fixed-width
* int64 encoding, false otherwise.
*/
public static boolean isfixedint64 positionedbyterange src
return fixed_int64
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses fixed-width
* float32 encoding, false otherwise.
*/
public static boolean isfixedfloat32 positionedbyterange src
return fixed_float32
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses fixed-width
* float64 encoding, false otherwise.
*/
public static boolean isfixedfloat64 positionedbyterange src
return fixed_float64
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses text encoding,
* false otherwise.
*/
public static boolean istext positionedbyterange src
return text
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses blobvar
* encoding, false otherwise.
*/
public static boolean isblobvar positionedbyterange src
return blob_var
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* return true when the next encoded value in {@code src} uses blobcopy
* encoding, false otherwise.
*/
public static boolean isblobcopy positionedbyterange src
return blob_copy
1    integer signum src peek    ? descending   ascending  apply src peek
/**
* skip {@code buff}'s position forward over one encoded value.
* @return number of bytes skipped.
*/
public static int skip positionedbyterange src
final int start   src getposition
byte header   src get
order ord     1    integer signum header   ? descending   ascending
header   ord apply header
switch  header
case null
case neg_inf
return 1
case neg_large     large negative number  0x08  ~e  ~m
skipvaruint64 src  descending    ord
skipsignificand src  descending    ord
return src getposition     start
case neg_med_min     medium negative number  0x13 e  ~m
case neg_med_min   0x01
case neg_med_min   0x02
case neg_med_min   0x03
case neg_med_min   0x04
case neg_med_min   0x05
case neg_med_min   0x06
case neg_med_min   0x07
case neg_med_min   0x08
case neg_med_min   0x09
case neg_med_max
skipsignificand src  descending    ord
return src getposition     start
case neg_small     small negative number  0x14   e  ~m
skipvaruint64 src  descending    ord
skipsignificand src  descending    ord
return src getposition     start
case zero
return 1
case pos_small     small positive number  0x16  ~ e  m
skipvaruint64 src  descending    ord
skipsignificand src  descending    ord
return src getposition     start
case pos_med_min     medium positive number  0x17 e  m
case pos_med_min   0x01
case pos_med_min   0x02
case pos_med_min   0x03
case pos_med_min   0x04
case pos_med_min   0x05
case pos_med_min   0x06
case pos_med_min   0x07
case pos_med_min   0x08
case pos_med_min   0x09
case pos_med_max
skipsignificand src  descending    ord
return src getposition     start
case pos_large     large positive number  0x22  e  m
skipvaruint64 src  descending    ord
skipsignificand src  descending    ord
return src getposition     start
case pos_inf
return 1
case nan
return 1
case fixed_int32
src setposition src getposition     4
return src getposition     start
case fixed_int64
src setposition src getposition     8
return src getposition     start
case fixed_float32
src setposition src getposition     4
return src getposition     start
case fixed_float64
src setposition src getposition     8
return src getposition     start
case text
// for null-terminated values, skip to the end.
do
header   ord apply src get
while  header    term
return src getposition     start
case blob_var
// read until we find a 0 in the msb
do
header   ord apply src get
while   byte   header   0x80     term
return src getposition     start
case blob_copy
if  order descending    ord
// if descending, read to termination byte.
do
header   ord apply src get
while  header    term
return src getposition     start
else
// otherwise, just skip to the end.
src setposition src getlength
return src getposition     start
default
throw unexpectedheader header
/**
* return the number of encoded entries remaining in {@code buff}. the
* state of {@code buff} is not modified through use of this method.
*/
public static int length positionedbyterange buff
positionedbyterange b
new simplepositionedbyterange buff getbytes    buff getoffset    buff getlength
b setposition buff getposition
int cnt   0
for    isencodedvalue b   skip buff   cnt
return cnt