/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import java io closeable
import java io ioexception
import java io interruptedioexception
import java net sockettimeoutexception
import java util arraylist
import java util arrays
import java util linkedlist
import java util list
import java util concurrent atomic atomicinteger
import java util concurrent atomic atomicreference
import java util regex pattern
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import org apache hadoop conf configuration
import org apache hadoop hbase abortable
import org apache hadoop hbase clusterstatus
import org apache hadoop hbase tablename
import org apache hadoop hbase hbaseconfiguration
import org apache hadoop hbase hbaseioexception
import org apache hadoop hbase hcolumndescriptor
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase hregionlocation
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase namespacedescriptor
import org apache hadoop hbase masternotrunningexception
import org apache hadoop hbase notservingregionexception
import org apache hadoop hbase regionexception
import org apache hadoop hbase servername
import org apache hadoop hbase tableexistsexception
import org apache hadoop hbase tablenotenabledexception
import org apache hadoop hbase tablenotfoundexception
import org apache hadoop hbase unknownregionexception
import org apache hadoop hbase zookeeperconnectionexception
import org apache hadoop hbase catalog catalogtracker
import org apache hadoop hbase catalog metareader
import org apache hadoop hbase client metascanner metascannervisitor
import org apache hadoop hbase client metascanner metascannervisitorbase
import org apache hadoop hbase exceptions deserializationexception
import org apache hadoop hbase regionserver wal failedlogcloseexception
import org apache hadoop hbase snapshot hbasesnapshotexception
import org apache hadoop hbase exceptions mergeregionexception
import org apache hadoop hbase snapshot restoresnapshotexception
import org apache hadoop hbase snapshot snapshotcreationexception
import org apache hadoop hbase snapshot unknownsnapshotexception
import org apache hadoop hbase ipc coprocessorrpcchannel
import org apache hadoop hbase ipc mastercoprocessorrpcchannel
import org apache hadoop hbase ipc payloadcarryingrpccontroller
import org apache hadoop hbase protobuf protobufutil
import org apache hadoop hbase protobuf requestconverter
import org apache hadoop hbase protobuf responseconverter
import org apache hadoop hbase protobuf generated adminprotos adminservice
import org apache hadoop hbase protobuf generated adminprotos closeregionrequest
import org apache hadoop hbase protobuf generated adminprotos closeregionresponse
import org apache hadoop hbase protobuf generated adminprotos compactregionrequest
import org apache hadoop hbase protobuf generated adminprotos flushregionrequest
import org apache hadoop hbase protobuf generated adminprotos getregioninforequest
import org apache hadoop hbase protobuf generated adminprotos getregioninforesponse
import org apache hadoop hbase protobuf generated adminprotos getregioninforesponse compactionstate
import org apache hadoop hbase protobuf generated adminprotos rollwalwriterrequest
import org apache hadoop hbase protobuf generated adminprotos rollwalwriterresponse
import org apache hadoop hbase protobuf generated adminprotos stopserverrequest
import org apache hadoop hbase protobuf generated clientprotos clientservice
import org apache hadoop hbase protobuf generated clientprotos scanrequest
import org apache hadoop hbase protobuf generated clientprotos scanresponse
import org apache hadoop hbase protobuf generated hbaseprotos
import org apache hadoop hbase protobuf generated hbaseprotos snapshotdescription
import org apache hadoop hbase protobuf generated hbaseprotos tableschema
import org apache hadoop hbase protobuf generated masteradminprotos
import org apache hadoop hbase protobuf generated masteradminprotos addcolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos assignregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos createtablerequest
import org apache hadoop hbase protobuf generated masteradminprotos deletecolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos deletesnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos deletetablerequest
import org apache hadoop hbase protobuf generated masteradminprotos disabletablerequest
import org apache hadoop hbase protobuf generated masteradminprotos dispatchmergingregionsrequest
import org apache hadoop hbase protobuf generated masteradminprotos enabletablerequest
import org apache hadoop hbase protobuf generated masteradminprotos isrestoresnapshotdonerequest
import org apache hadoop hbase protobuf generated masteradminprotos isrestoresnapshotdoneresponse
import org apache hadoop hbase protobuf generated masteradminprotos issnapshotdonerequest
import org apache hadoop hbase protobuf generated masteradminprotos issnapshotdoneresponse
import org apache hadoop hbase protobuf generated masteradminprotos listsnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos modifycolumnrequest
import org apache hadoop hbase protobuf generated masteradminprotos modifytablerequest
import org apache hadoop hbase protobuf generated masteradminprotos moveregionrequest
import org apache hadoop hbase protobuf generated masteradminprotos restoresnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos restoresnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos setbalancerrunningrequest
import org apache hadoop hbase protobuf generated masteradminprotos shutdownrequest
import org apache hadoop hbase protobuf generated masteradminprotos stopmasterrequest
import org apache hadoop hbase protobuf generated masteradminprotos takesnapshotrequest
import org apache hadoop hbase protobuf generated masteradminprotos takesnapshotresponse
import org apache hadoop hbase protobuf generated masteradminprotos unassignregionrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos getclusterstatusrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos getschemaalterstatusrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos getschemaalterstatusresponse
import org apache hadoop hbase protobuf generated mastermonitorprotos gettabledescriptorsrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos gettabledescriptorsresponse
import org apache hadoop hbase snapshot clientsnapshotdescriptionutils
import org apache hadoop hbase util addressing
import org apache hadoop hbase util bytes
import org apache hadoop hbase util environmentedgemanager
import org apache hadoop hbase util pair
import org apache hadoop ipc remoteexception
import org apache hadoop util stringutils
import org apache zookeeper keeperexception
import com google protobuf bytestring
import com google protobuf serviceexception
/**
* provides an interface to manage hbase database table metadata + general
* administrative functions.  use hbaseadmin to create, drop, list, enable and
* disable tables. use it also to add and drop table column families.
*
* <p>see {@link htable} to add, update, and delete data from an individual table.
* <p>currently hbaseadmin instances are not expected to be long-lived.  for
* example, an hbaseadmin instance will not ride over a master restart.
*/
@interfaceaudience public
@interfacestability evolving
public class hbaseadmin implements abortable  closeable
private static final log log   logfactory getlog hbaseadmin class
// we use the implementation class rather then the interface because we
//  need the package protected functions to get the connection to master
private hconnection connection
private volatile configuration conf
private final long pause
private final int numretries
// some operations can take a long time such as disable of big table.
// numretries is for 'normal' stuff... multiply by this factor when
// want to wait a long time.
private final int retrylongermultiplier
private boolean aborted
private boolean cleanupconnectiononclose   false     close the connection in close
private rpcretryingcallerfactory rpccallerfactory
/**
* constructor.
* see {@link #hbaseadmin(hconnection connection)}
*
* @param c configuration object. copied internally.
*/
public hbaseadmin configuration c
throws masternotrunningexception  zookeeperconnectionexception  ioexception
// will not leak connections, as the new implementation of the constructor
// does not throw exceptions anymore.
this hconnectionmanager getconnection new configuration c
this cleanupconnectiononclose   true
/**
* constructor for externally managed hconnections.
* the connection to master will be created when required by admin functions.
*
* @param connection the hconnection instance to use
* @throws masternotrunningexception, zookeeperconnectionexception are not
*  thrown anymore but kept into the interface for backward api compatibility
*/
public hbaseadmin hconnection connection
throws masternotrunningexception  zookeeperconnectionexception
this conf   connection getconfiguration
this connection   connection
this pause   this conf getlong    1000
this numretries   this conf getint hconstants hbase_client_retries_number
hconstants default_hbase_client_retries_number
this retrylongermultiplier   this conf getint
10
this rpccallerfactory   rpcretryingcallerfactory instantiate this conf
/**
* @return a new catalogtracker instance; call {@link #cleanupcatalogtracker(catalogtracker)}
* to cleanup the returned catalog tracker.
* @throws org.apache.hadoop.hbase.zookeeperconnectionexception
* @throws ioexception
* @see #cleanupcatalogtracker(catalogtracker)
*/
private synchronized catalogtracker getcatalogtracker
throws zookeeperconnectionexception  ioexception
catalogtracker ct   null
try
ct   new catalogtracker this conf
ct start
catch  interruptedexception e
// let it out as an ioe for now until we redo all so tolerate ies
thread currentthread   interrupt
throw new ioexception    e
return ct
private void cleanupcatalogtracker final catalogtracker ct
ct stop
@override
public void abort string why  throwable e
// currently does nothing but throw the passed message and exception
this aborted   true
throw new runtimeexception why  e
@override
public boolean isaborted
return this aborted
/** @return hconnection used by this object. */
public hconnection getconnection
return connection
/** @return - true if the master server is running. throws an exception
*  otherwise.
* @throws zookeeperconnectionexception
* @throws masternotrunningexception
*/
public boolean ismasterrunning
throws masternotrunningexception  zookeeperconnectionexception
return connection ismasterrunning
/**
* @param tablename table to check.
* @return true if table exists already.
* @throws ioexception
*/
public boolean tableexists final tablename tablename
throws ioexception
boolean b   false
catalogtracker ct   getcatalogtracker
try
b   metareader tableexists ct  tablename
finally
cleanupcatalogtracker ct
return b
public boolean tableexists final byte tablename
throws ioexception
return tableexists tablename valueof tablename
public boolean tableexists final string tablename
throws ioexception
return tableexists tablename valueof tablename
/**
* list all the userspace tables.  in other words, scan the meta table.
*
* if we wanted this to be really fast, we could implement a special
* catalog table that just contains table names and their descriptors.
* right now, it only exists as part of the meta table's region info.
*
* @return - returns an array of htabledescriptors
* @throws ioexception if a remote or network exception occurs
*/
public htabledescriptor listtables   throws ioexception
return this connection listtables
/**
* list all the userspace tables matching the given pattern.
*
* @param pattern the compiled regular expression to match against
* @return - returns an array of htabledescriptors
* @throws ioexception if a remote or network exception occurs
* @see #listtables()
*/
public htabledescriptor listtables pattern pattern  throws ioexception
list<htabledescriptor> matched   new linkedlist<htabledescriptor>
htabledescriptor tables   listtables
for  htabledescriptor table   tables
if  pattern matcher table gettablename   getnameasstring    matches
matched add table
return matched toarray new htabledescriptor
/**
* list all the userspace tables matching the given regular expression.
*
* @param regex the regular expression to match against
* @return - returns an array of htabledescriptors
* @throws ioexception if a remote or network exception occurs
* @see #listtables(java.util.regex.pattern)
*/
public htabledescriptor listtables string regex  throws ioexception
return listtables pattern compile regex
/**
* list all of the names of userspace tables.
* @return string[] table names
* @throws ioexception if a remote or network exception occurs
*/
@deprecated
public string gettablenames   throws ioexception
return this connection gettablenames
/**
* list all of the names of userspace tables matching the given regular expression.
* @param pattern the regular expression to match against
* @return string[] table names
* @throws ioexception if a remote or network exception occurs
*/
@deprecated
public string gettablenames pattern pattern  throws ioexception
list<string> matched   new arraylist<string>
for  string name  this connection gettablenames
if  pattern matcher name  matches
matched add name
return matched toarray new string
/**
* list all of the names of userspace tables matching the given regular expression.
* @param regex the regular expression to match against
* @return string[] table names
* @throws ioexception if a remote or network exception occurs
*/
@deprecated
public string gettablenames string regex  throws ioexception
return gettablenames pattern compile regex
/**
* list all of the names of userspace tables.
* @return tablename[] table names
* @throws ioexception if a remote or network exception occurs
*/
public tablename listtablenames   throws ioexception
return this connection listtablenames
/**
* method for getting the tabledescriptor
* @param tablename as a byte []
* @return the tabledescriptor
* @throws tablenotfoundexception
* @throws ioexception if a remote or network exception occurs
*/
public htabledescriptor gettabledescriptor final tablename tablename
throws tablenotfoundexception  ioexception
return this connection gethtabledescriptor tablename
public htabledescriptor gettabledescriptor final byte tablename
throws tablenotfoundexception  ioexception
return gettabledescriptor tablename valueof tablename
private long getpausetime int tries
int triescount   tries
if  triescount >  hconstants retry_backoff length
triescount   hconstants retry_backoff length   1
return this pause   hconstants retry_backoff
/**
* creates a new table.
* synchronous operation.
*
* @param desc table descriptor for table
*
* @throws illegalargumentexception if the table name is reserved
* @throws masternotrunningexception if master is not running
* @throws tableexistsexception if table already exists (if concurrent
* threads, the table may have been created between test-for-existence
* and attempt-at-creation).
* @throws ioexception if a remote or network exception occurs
*/
public void createtable htabledescriptor desc
throws ioexception
createtable desc  null
/**
* creates a new table with the specified number of regions.  the start key
* specified will become the end key of the first region of the table, and
* the end key specified will become the start key of the last region of the
* table (the first region has a null start key and the last region has a
* null end key).
*
* biginteger math will be used to divide the key range specified into
* enough segments to make the required number of total regions.
*
* synchronous operation.
*
* @param desc table descriptor for table
* @param startkey beginning of key range
* @param endkey end of key range
* @param numregions the total number of regions to create
*
* @throws illegalargumentexception if the table name is reserved
* @throws masternotrunningexception if master is not running
* @throws org.apache.hadoop.hbase.tableexistsexception if table already exists (if concurrent
* threads, the table may have been created between test-for-existence
* and attempt-at-creation).
* @throws ioexception
*/
public void createtable htabledescriptor desc  byte  startkey
byte  endkey  int numregions
throws ioexception
if numregions < 3
throw new illegalargumentexception
else if bytes compareto startkey  endkey  >  0
throw new illegalargumentexception
if  numregions    3
createtable desc  new byte startkey  endkey
return
byte  splitkeys   bytes split startkey  endkey  numregions   3
if splitkeys    null    splitkeys length    numregions   1
throw new illegalargumentexception
createtable desc  splitkeys
/**
* creates a new table with an initial set of empty regions defined by the
* specified split keys.  the total number of regions created will be the
* number of split keys plus one. synchronous operation.
* note : avoid passing empty split key.
*
* @param desc table descriptor for table
* @param splitkeys array of split keys for the initial regions of the table
*
* @throws illegalargumentexception if the table name is reserved, if the split keys
* are repeated and if the split key has empty byte array.
* @throws masternotrunningexception if master is not running
* @throws org.apache.hadoop.hbase.tableexistsexception if table already exists (if concurrent
* threads, the table may have been created between test-for-existence
* and attempt-at-creation).
* @throws ioexception
*/
public void createtable final htabledescriptor desc  byte  splitkeys
throws ioexception
try
createtableasync desc  splitkeys
catch  sockettimeoutexception ste
log warn     desc gettablename        ste
int numregs   splitkeys    null ? 1   splitkeys length   1
int prevregcount   0
boolean donewithmetascan   false
for  int tries   0  tries < this numretries   this retrylongermultiplier
tries
if   donewithmetascan
// wait for new table to come on-line
final atomicinteger actualregcount   new atomicinteger 0
metascannervisitor visitor   new metascannervisitorbase
@override
public boolean processrow result rowresult  throws ioexception
hregioninfo info   hregioninfo gethregioninfo rowresult
if  info    null
log warn     rowresult
return true
if   info gettablename   equals desc gettablename
return false
servername servername   hregioninfo getservername rowresult
// make sure that regions are assigned to server
if    info isoffline      info issplit       servername    null
servername gethostandport      null
actualregcount incrementandget
return true
metascanner metascan conf  connection  visitor  desc gettablename
if  actualregcount get      numregs
if  tries    this numretries   this retrylongermultiplier   1
throw new regionofflineexception     actualregcount get
numregs
try      sleep
thread sleep getpausetime tries
catch  interruptedexception e
throw new interruptedioexception
actualregcount get         numregs
if  actualregcount get   > prevregcount       making progress
prevregcount   actualregcount get
tries    1
else
donewithmetascan   true
tries    1
else if  istableenabled desc gettablename
return
else
try      sleep
thread sleep getpausetime tries
catch  interruptedexception e
throw new interruptedioexception
throw new tablenotenabledexception
desc gettablename
/**
* creates a new table but does not block and wait for it to come online.
* asynchronous operation.  to check if the table exists, use
* {@link #istableavailable} -- it is not safe to create an htable
* instance to this table before it is available.
* note : avoid passing empty split key.
* @param desc table descriptor for table
*
* @throws illegalargumentexception bad table name, if the split keys
* are repeated and if the split key has empty byte array.
* @throws masternotrunningexception if master is not running
* @throws org.apache.hadoop.hbase.tableexistsexception if table already exists (if concurrent
* threads, the table may have been created between test-for-existence
* and attempt-at-creation).
* @throws ioexception
*/
public void createtableasync
final htabledescriptor desc  final byte  splitkeys
throws ioexception
if desc gettablename      null
throw new illegalargumentexception
if splitkeys    null    splitkeys length > 0
arrays sort splitkeys  bytes bytes_comparator
// verify there are no duplicate split keys
byte  lastkey   null
for byte  splitkey   splitkeys
if  bytes compareto splitkey  hconstants empty_byte_array     0
throw new illegalargumentexception
if lastkey    null    bytes equals splitkey  lastkey
throw new illegalargumentexception
bytes tostringbinary splitkey
bytes tostringbinary lastkey
lastkey   splitkey
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
createtablerequest request   requestconverter buildcreatetablerequest desc  splitkeys
masteradmin createtable null  request
return null
public void deletetable final string tablename  throws ioexception
deletetable tablename valueof tablename
public void deletetable final byte tablename  throws ioexception
deletetable tablename valueof tablename
/**
* deletes a table.
* synchronous operation.
*
* @param tablename name of table to delete
* @throws ioexception if a remote or network exception occurs
*/
public void deletetable final tablename tablename  throws ioexception
hregionlocation firstmetaserver   getfirstmetaserverfortable tablename
boolean tableexists   true
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
deletetablerequest req   requestconverter builddeletetablerequest tablename
masteradmin deletetable null req
return null
// wait until all regions deleted
for  int tries   0  tries <  this numretries   this retrylongermultiplier   tries
try
scan scan   metareader getscanfortablename tablename
scan addcolumn hconstants catalog_family  hconstants regioninfo_qualifier
scanrequest request   requestconverter buildscanrequest
firstmetaserver getregioninfo   getregionname    scan  1  true
result values   null
// get a batch at a time.
clientservice blockinginterface server   connection getclient firstmetaserver
getservername
payloadcarryingrpccontroller controller   new payloadcarryingrpccontroller
try
scanresponse response   server scan controller  request
values   responseconverter getresults controller cellscanner    response
catch  serviceexception se
throw protobufutil getremoteexception se
// let us wait until .meta. table is updated and
// hmaster removes the table from its htabledescriptors
if  values    null    values length    0
tableexists   false
gettabledescriptorsresponse htds
mastermonitorkeepaliveconnection master   connection getkeepalivemastermonitorservice
try
gettabledescriptorsrequest req
requestconverter buildgettabledescriptorsrequest tablename
htds   master gettabledescriptors null  req
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
tableexists    htds gettableschemalist   isempty
if   tableexists
break
catch  ioexception ex
if tries    numretries   1                 no more tries left
if  ex instanceof remoteexception
throw   remoteexception  ex  unwrapremoteexception
else
throw ex
try
thread sleep getpausetime tries
catch  interruptedexception e
// continue
if  tableexists
throw new ioexception
tablename
// delete cached information to prevent clients from using old locations
this connection clearregioncache tablename
log info     tablename
/**
* deletes tables matching the passed in pattern and wait on completion.
*
* warning: use this method carefully, there is no prompting and the effect is
* immediate. consider using {@link #listtables(java.lang.string)} and
* {@link #deletetable(byte[])}
*
* @param regex the regular expression to match table names against
* @return table descriptors for tables that couldn't be deleted
* @throws ioexception
* @see #deletetables(java.util.regex.pattern)
* @see #deletetable(java.lang.string)
*/
public htabledescriptor deletetables string regex  throws ioexception
return deletetables pattern compile regex
/**
* delete tables matching the passed in pattern and wait on completion.
*
* warning: use this method carefully, there is no prompting and the effect is
* immediate. consider using {@link #listtables(java.util.regex.pattern) } and
* {@link #deletetable(byte[])}
*
* @param pattern the pattern to match table names against
* @return table descriptors for tables that couldn't be deleted
* @throws ioexception
*/
public htabledescriptor deletetables pattern pattern  throws ioexception
list<htabledescriptor> failed   new linkedlist<htabledescriptor>
for  htabledescriptor table   listtables pattern
try
deletetable table gettablename
catch  ioexception ex
log info     table gettablename    ex
failed add table
return failed toarray new htabledescriptor
/**
* enable a table.  may timeout.  use {@link #enabletableasync(byte[])}
* and {@link #istableenabled(byte[])} instead.
* the table has to be in disabled state for it to be enabled.
* @param tablename name of the table
* @throws ioexception if a remote or network exception occurs
* there could be couple types of ioexception
* tablenotfoundexception means the table doesn't exist.
* tablenotdisabledexception means the table isn't in disabled state.
* @see #istableenabled(byte[])
* @see #disabletable(byte[])
* @see #enabletableasync(byte[])
*/
public void enabletable final tablename tablename
throws ioexception
enabletableasync tablename
// wait until all regions are enabled
waituntiltableisenabled tablename
log info     tablename
public void enabletable final byte tablename
throws ioexception
enabletable tablename valueof tablename
public void enabletable final string tablename
throws ioexception
enabletable tablename valueof tablename
/**
* wait for the table to be enabled and available
* if enabling the table exceeds the retry period, an exception is thrown.
* @param tablename name of the table
* @throws ioexception if a remote or network exception occurs or
*    table is not enabled after the retries period.
*/
private void waituntiltableisenabled final tablename tablename  throws ioexception
boolean enabled   false
long start   environmentedgemanager currenttimemillis
for  int tries   0  tries <  this numretries   this retrylongermultiplier   tries
enabled   istableenabled tablename     istableavailable tablename
if  enabled
break
long sleep   getpausetime tries
if  log isdebugenabled
log debug     sleep
tablename
try
thread sleep sleep
catch  interruptedexception e
thread currentthread   interrupt
// do this conversion rather than let it out because do not want to
// change the method signature.
throw new ioexception    e
if   enabled
long msec   environmentedgemanager currenttimemillis     start
throw new ioexception     tablename
msec
/**
* brings a table on-line (enables it).  method returns immediately though
* enable of table may take some time to complete, especially if the table
* is large (all regions are opened as part of enabling process).  check
* {@link #istableenabled(byte[])} to learn when table is fully online.  if
* table is taking too long to online, check server logs.
* @param tablename
* @throws ioexception
* @since 0.90.0
*/
public void enabletableasync final tablename tablename
throws ioexception
tablename islegalfullyqualifiedtablename tablename getname
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
log info     tablename
enabletablerequest req   requestconverter buildenabletablerequest tablename
masteradmin enabletable null req
return null
public void enabletableasync final byte tablename
throws ioexception
enabletable tablename valueof tablename
public void enabletableasync final string tablename
throws ioexception
enabletableasync tablename valueof tablename
/**
* enable tables matching the passed in pattern and wait on completion.
*
* warning: use this method carefully, there is no prompting and the effect is
* immediate. consider using {@link #listtables(java.lang.string)} and
* {@link #enabletable(byte[])}
*
* @param regex the regular expression to match table names against
* @throws ioexception
* @see #enabletables(java.util.regex.pattern)
* @see #enabletable(java.lang.string)
*/
public htabledescriptor enabletables string regex  throws ioexception
return enabletables pattern compile regex
/**
* enable tables matching the passed in pattern and wait on completion.
*
* warning: use this method carefully, there is no prompting and the effect is
* immediate. consider using {@link #listtables(java.util.regex.pattern) } and
* {@link #enabletable(byte[])}
*
* @param pattern the pattern to match table names against
* @throws ioexception
*/
public htabledescriptor enabletables pattern pattern  throws ioexception
list<htabledescriptor> failed   new linkedlist<htabledescriptor>
for  htabledescriptor table   listtables pattern
if  istabledisabled table gettablename
try
enabletable table gettablename
catch  ioexception ex
log info     table gettablename    ex
failed add table
return failed toarray new htabledescriptor
/**
* starts the disable of a table.  if it is being served, the master
* will tell the servers to stop serving it.  this method returns immediately.
* the disable of a table can take some time if the table is large (all
* regions are closed as part of table disable operation).
* call {@link #istabledisabled(byte[])} to check for when disable completes.
* if table is taking too long to online, check server logs.
* @param tablename name of table
* @throws ioexception if a remote or network exception occurs
* @see #istabledisabled(byte[])
* @see #istableenabled(byte[])
* @since 0.90.0
*/
public void disabletableasync final tablename tablename  throws ioexception
tablename islegalfullyqualifiedtablename tablename getname
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
log info     tablename
disabletablerequest req   requestconverter builddisabletablerequest tablename
masteradmin disabletable null req
return null
public void disabletableasync final byte tablename  throws ioexception
disabletableasync tablename valueof tablename
public void disabletableasync final string tablename  throws ioexception
disabletableasync tablename valueof tablename
/**
* disable table and wait on completion.  may timeout eventually.  use
* {@link #disabletableasync(byte[])} and {@link #istabledisabled(string)}
* instead.
* the table has to be in enabled state for it to be disabled.
* @param tablename
* @throws ioexception
* there could be couple types of ioexception
* tablenotfoundexception means the table doesn't exist.
* tablenotenabledexception means the table isn't in enabled state.
*/
public void disabletable final tablename tablename
throws ioexception
disabletableasync tablename
// wait until table is disabled
boolean disabled   false
for  int tries   0  tries <  this numretries   this retrylongermultiplier   tries
disabled   istabledisabled tablename
if  disabled
break
long sleep   getpausetime tries
if  log isdebugenabled
log debug     sleep
tablename
try
thread sleep sleep
catch  interruptedexception e
// do this conversion rather than let it out because do not want to
// change the method signature.
thread currentthread   interrupt
throw new ioexception    e
if   disabled
throw new regionexception
tablename
log info     tablename
public void disabletable final byte tablename
throws ioexception
disabletable tablename valueof tablename
public void disabletable final string tablename
throws ioexception
disabletable tablename valueof tablename
/**
* disable tables matching the passed in pattern and wait on completion.
*
* warning: use this method carefully, there is no prompting and the effect is
* immediate. consider using {@link #listtables(java.lang.string)} and
* {@link #disabletable(byte[])}
*
* @param regex the regular expression to match table names against
* @return table descriptors for tables that couldn't be disabled
* @throws ioexception
* @see #disabletables(java.util.regex.pattern)
* @see #disabletable(java.lang.string)
*/
public htabledescriptor disabletables string regex  throws ioexception
return disabletables pattern compile regex
/**
* disable tables matching the passed in pattern and wait on completion.
*
* warning: use this method carefully, there is no prompting and the effect is
* immediate. consider using {@link #listtables(java.util.regex.pattern) } and
* {@link #disabletable(byte[])}
*
* @param pattern the pattern to match table names against
* @return table descriptors for tables that couldn't be disabled
* @throws ioexception
*/
public htabledescriptor disabletables pattern pattern  throws ioexception
list<htabledescriptor> failed   new linkedlist<htabledescriptor>
for  htabledescriptor table   listtables pattern
if  istableenabled table gettablename
try
disabletable table gettablename
catch  ioexception ex
log info     table gettablename    ex
failed add table
return failed toarray new htabledescriptor
/**
* @param tablename name of table to check
* @return true if table is on-line
* @throws ioexception if a remote or network exception occurs
*/
public boolean istableenabled tablename tablename  throws ioexception
return connection istableenabled tablename
public boolean istableenabled byte tablename  throws ioexception
return istableenabled tablename valueof tablename
public boolean istableenabled string tablename  throws ioexception
return istableenabled tablename valueof tablename
/**
* @param tablename name of table to check
* @return true if table is off-line
* @throws ioexception if a remote or network exception occurs
*/
public boolean istabledisabled tablename tablename  throws ioexception
return connection istabledisabled tablename
public boolean istabledisabled byte tablename  throws ioexception
return istabledisabled tablename valueof tablename
public boolean istabledisabled string tablename  throws ioexception
return istabledisabled tablename valueof tablename
/**
* @param tablename name of table to check
* @return true if all regions of the table are available
* @throws ioexception if a remote or network exception occurs
*/
public boolean istableavailable tablename tablename  throws ioexception
return connection istableavailable tablename
public boolean istableavailable byte tablename  throws ioexception
return istableavailable tablename valueof tablename
public boolean istableavailable string tablename  throws ioexception
return istableavailable tablename valueof tablename
/**
* use this api to check if the table has been created with the specified number of
* splitkeys which was used while creating the given table.
* note : if this api is used after a table's region gets splitted, the api may return
* false.
* @param tablename
*          name of table to check
* @param splitkeys
*          keys to check if the table has been created with all split keys
* @throws ioexception
*           if a remote or network excpetion occurs
*/
public boolean istableavailable tablename tablename
byte splitkeys  throws ioexception
return connection istableavailable tablename  splitkeys
public boolean istableavailable byte tablename
byte splitkeys  throws ioexception
return istableavailable tablename valueof tablename   splitkeys
public boolean istableavailable string tablename
byte splitkeys  throws ioexception
return istableavailable tablename valueof tablename   splitkeys
/**
* get the status of alter command - indicates how many regions have received
* the updated schema asynchronous operation.
*
* @param tablename tablename instance
* @return pair indicating the number of regions updated pair.getfirst() is the
*         regions that are yet to be updated pair.getsecond() is the total number
*         of regions of the table
* @throws ioexception
*           if a remote or network exception occurs
*/
public pair<integer  integer> getalterstatus final tablename tablename
throws ioexception
return executecallable new mastermonitorcallable<pair<integer  integer>> getconnection
@override
public pair<integer  integer> call   throws serviceexception
getschemaalterstatusrequest req   requestconverter
buildgetschemaalterstatusrequest tablename
getschemaalterstatusresponse ret   mastermonitor getschemaalterstatus null  req
pair<integer  integer> pair   new pair<integer  integer> integer valueof ret
getyettoupdateregions     integer valueof ret gettotalregions
return pair
/**
* get the status of alter command - indicates how many regions have received
* the updated schema asynchronous operation.
*
* @param tablename
*          name of the table to get the status of
* @return pair indicating the number of regions updated pair.getfirst() is the
*         regions that are yet to be updated pair.getsecond() is the total number
*         of regions of the table
* @throws ioexception
*           if a remote or network exception occurs
*/
public pair<integer  integer> getalterstatus final byte tablename
throws ioexception
return getalterstatus tablename valueof tablename
/**
* add a column to an existing table.
* asynchronous operation.
*
* @param tablename name of the table to add column to
* @param column column descriptor of column to be added
* @throws ioexception if a remote or network exception occurs
*/
public void addcolumn final byte tablename  hcolumndescriptor column
throws ioexception
addcolumn tablename valueof tablename   column
/**
* add a column to an existing table.
* asynchronous operation.
*
* @param tablename name of the table to add column to
* @param column column descriptor of column to be added
* @throws ioexception if a remote or network exception occurs
*/
public void addcolumn final string tablename  hcolumndescriptor column
throws ioexception
addcolumn tablename valueof tablename   column
/**
* add a column to an existing table.
* asynchronous operation.
*
* @param tablename name of the table to add column to
* @param column column descriptor of column to be added
* @throws ioexception if a remote or network exception occurs
*/
public void addcolumn final tablename tablename  final hcolumndescriptor column
throws ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
addcolumnrequest req   requestconverter buildaddcolumnrequest tablename  column
masteradmin addcolumn null req
return null
/**
* delete a column from a table.
* asynchronous operation.
*
* @param tablename name of table
* @param columnname name of column to be deleted
* @throws ioexception if a remote or network exception occurs
*/
public void deletecolumn final byte tablename  final string columnname
throws ioexception
deletecolumn tablename valueof tablename   bytes tobytes columnname
/**
* delete a column from a table.
* asynchronous operation.
*
* @param tablename name of table
* @param columnname name of column to be deleted
* @throws ioexception if a remote or network exception occurs
*/
public void deletecolumn final string tablename  final string columnname
throws ioexception
deletecolumn tablename valueof tablename   bytes tobytes columnname
/**
* delete a column from a table.
* asynchronous operation.
*
* @param tablename name of table
* @param columnname name of column to be deleted
* @throws ioexception if a remote or network exception occurs
*/
public void deletecolumn final tablename tablename  final byte  columnname
throws ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
deletecolumnrequest req   requestconverter builddeletecolumnrequest tablename  columnname
masteradmin deletecolumn null req
return null
/**
* modify an existing column family on a table.
* asynchronous operation.
*
* @param tablename name of table
* @param descriptor new column descriptor to use
* @throws ioexception if a remote or network exception occurs
*/
public void modifycolumn final string tablename  hcolumndescriptor descriptor
throws ioexception
modifycolumn tablename valueof tablename   descriptor
/**
* modify an existing column family on a table.
* asynchronous operation.
*
* @param tablename name of table
* @param descriptor new column descriptor to use
* @throws ioexception if a remote or network exception occurs
*/
public void modifycolumn final byte tablename  hcolumndescriptor descriptor
throws ioexception
modifycolumn tablename valueof tablename   descriptor
/**
* modify an existing column family on a table.
* asynchronous operation.
*
* @param tablename name of table
* @param descriptor new column descriptor to use
* @throws ioexception if a remote or network exception occurs
*/
public void modifycolumn final tablename tablename  final hcolumndescriptor descriptor
throws ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
modifycolumnrequest req   requestconverter buildmodifycolumnrequest tablename  descriptor
masteradmin modifycolumn null req
return null
/**
* close a region. for expert-admins.  runs close on the regionserver.  the
* master will not be informed of the close.
* @param regionname region name to close
* @param servername if supplied, we'll use this location rather than
* the one currently in <code>.meta.</code>
* @throws ioexception if a remote or network exception occurs
*/
public void closeregion final string regionname  final string servername
throws ioexception
closeregion bytes tobytes regionname   servername
/**
* close a region.  for expert-admins  runs close on the regionserver.  the
* master will not be informed of the close.
* @param regionname region name to close
* @param servername the servername of the regionserver.  if passed null we
* will use servername found in the .meta. table. a server name
* is made of host, port and startcode.  here is an example:
* <code> host187.example.com,60020,1289493121758</code>
* @throws ioexception if a remote or network exception occurs
*/
public void closeregion final byte  regionname  final string servername
throws ioexception
catalogtracker ct   getcatalogtracker
try
if  servername    null
pair<hregioninfo  servername> pair   metareader getregion ct  regionname
if  pair    null    pair getfirst      null
throw new unknownregionexception bytes tostringbinary regionname
else
closeregion new servername servername   pair getfirst
else
pair<hregioninfo  servername> pair   metareader getregion ct  regionname
if  pair    null
throw new unknownregionexception bytes tostringbinary regionname
else if  pair getsecond      null
throw new noserverforregionexception bytes tostringbinary regionname
else
closeregion pair getsecond    pair getfirst
finally
cleanupcatalogtracker ct
/**
* for expert-admins. runs close on the regionserver. closes a region based on
* the encoded region name. the region server name is mandatory. if the
* servername is provided then based on the online regions in the specified
* regionserver the specified region will be closed. the master will not be
* informed of the close. note that the regionname is the encoded regionname.
*
* @param encodedregionname
*          the encoded region name; i.e. the hash that makes up the region
*          name suffix: e.g. if regionname is
*          <code>testtable,0094429456,1289497600452.527db22f95c8a9e0116f0cc13c680396.</code>
*          , then the encoded region name is:
*          <code>527db22f95c8a9e0116f0cc13c680396</code>.
* @param servername
*          the servername of the regionserver. a server name is made of host,
*          port and startcode. this is mandatory. here is an example:
*          <code> host187.example.com,60020,1289493121758</code>
* @return true if the region was closed, false if not.
* @throws ioexception
*           if a remote or network exception occurs
*/
public boolean closeregionwithencodedregionname final string encodedregionname
final string servername  throws ioexception
if  null    servername        equals servername trim
throw new illegalargumentexception
servername sn   new servername servername
adminservice blockinginterface admin   this connection getadmin sn
// close the region without updating zk state.
closeregionrequest request
requestconverter buildcloseregionrequest encodedregionname  false
try
closeregionresponse response   admin closeregion null  request
boolean isregionclosed   response getclosed
if  false    isregionclosed
log error     encodedregionname
return isregionclosed
catch  serviceexception se
throw protobufutil getremoteexception se
/**
* close a region.  for expert-admins  runs close on the regionserver.  the
* master will not be informed of the close.
* @param sn
* @param hri
* @throws ioexception
*/
public void closeregion final servername sn  final hregioninfo hri
throws ioexception
adminservice blockinginterface admin   this connection getadmin sn
// close the region without updating zk state.
protobufutil closeregion admin  hri getregionname    false
/**
* get all the online regions on a region server.
*/
public list<hregioninfo> getonlineregions
final servername sn  throws ioexception
adminservice blockinginterface admin   this connection getadmin sn
return protobufutil getonlineregions admin
/**
* flush a table or an individual region.
* synchronous operation.
*
* @param tablenameorregionname table or region to flush
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void flush final string tablenameorregionname
throws ioexception  interruptedexception
flush bytes tobytes tablenameorregionname
/**
* flush a table or an individual region.
* synchronous operation.
*
* @param tablenameorregionname table or region to flush
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void flush final byte tablenameorregionname
throws ioexception  interruptedexception
catalogtracker ct   getcatalogtracker
try
pair<hregioninfo  servername> regionserverpair
getregion tablenameorregionname  ct
if  regionserverpair    null
if  regionserverpair getsecond      null
throw new noserverforregionexception bytes tostringbinary tablenameorregionname
else
flush regionserverpair getsecond    regionserverpair getfirst
else
final tablename tablename   checktableexists
tablename valueof tablenameorregionname   ct
list<pair<hregioninfo  servername>> pairs
metareader gettableregionsandlocations ct
tablename
for  pair<hregioninfo  servername> pair  pairs
if  pair getfirst   isoffline    continue
if  pair getsecond      null  continue
try
flush pair getsecond    pair getfirst
catch  notservingregionexception e
if  log isdebugenabled
log debug     pair getfirst
stringutils stringifyexception e
finally
cleanupcatalogtracker ct
private void flush final servername sn  final hregioninfo hri
throws ioexception
adminservice blockinginterface admin   this connection getadmin sn
flushregionrequest request
requestconverter buildflushregionrequest hri getregionname
try
admin flushregion null  request
catch  serviceexception se
throw protobufutil getremoteexception se
/**
* compact a table or an individual region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to compact
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void compact final string tablenameorregionname
throws ioexception  interruptedexception
compact bytes tobytes tablenameorregionname
/**
* compact a table or an individual region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to compact
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void compact final byte tablenameorregionname
throws ioexception  interruptedexception
compact tablenameorregionname  null  false
/**
* compact a column family within a table or region.
* asynchronous operation.
*
* @param tableorregionname table or region to compact
* @param columnfamily column family within a table or region
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void compact string tableorregionname  string columnfamily
throws ioexception   interruptedexception
compact bytes tobytes tableorregionname   bytes tobytes columnfamily
/**
* compact a column family within a table or region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to compact
* @param columnfamily column family within a table or region
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void compact final byte tablenameorregionname  final byte columnfamily
throws ioexception  interruptedexception
compact tablenameorregionname  columnfamily  false
/**
* major compact a table or an individual region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to major compact
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void majorcompact final string tablenameorregionname
throws ioexception  interruptedexception
majorcompact bytes tobytes tablenameorregionname
/**
* major compact a table or an individual region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to major compact
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void majorcompact final byte tablenameorregionname
throws ioexception  interruptedexception
compact tablenameorregionname  null  true
/**
* major compact a column family within a table or region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to major compact
* @param columnfamily column family within a table or region
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void majorcompact final string tablenameorregionname
final string columnfamily  throws ioexception  interruptedexception
majorcompact bytes tobytes tablenameorregionname
bytes tobytes columnfamily
/**
* major compact a column family within a table or region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to major compact
* @param columnfamily column family within a table or region
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void majorcompact final byte tablenameorregionname
final byte columnfamily  throws ioexception  interruptedexception
compact tablenameorregionname  columnfamily  true
/**
* compact a table or an individual region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to compact
* @param columnfamily column family within a table or region
* @param major true if we are to do a major compaction.
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
private void compact final byte tablenameorregionname
final byte columnfamily final boolean major
throws ioexception  interruptedexception
catalogtracker ct   getcatalogtracker
try
pair<hregioninfo  servername> regionserverpair
getregion tablenameorregionname  ct
if  regionserverpair    null
if  regionserverpair getsecond      null
throw new noserverforregionexception bytes tostringbinary tablenameorregionname
else
compact regionserverpair getsecond    regionserverpair getfirst    major  columnfamily
else
final tablename tablename
checktableexists tablename valueof tablenameorregionname   ct
list<pair<hregioninfo  servername>> pairs
metareader gettableregionsandlocations ct
tablename
for  pair<hregioninfo  servername> pair  pairs
if  pair getfirst   isoffline    continue
if  pair getsecond      null  continue
try
compact pair getsecond    pair getfirst    major  columnfamily
catch  notservingregionexception e
if  log isdebugenabled
log debug      major ?
pair getfirst
stringutils stringifyexception e
finally
cleanupcatalogtracker ct
private void compact final servername sn  final hregioninfo hri
final boolean major  final byte  family
throws ioexception
adminservice blockinginterface admin   this connection getadmin sn
compactregionrequest request
requestconverter buildcompactregionrequest hri getregionname    major  family
try
admin compactregion null  request
catch  serviceexception se
throw protobufutil getremoteexception se
/**
* move the region <code>r</code> to <code>dest</code>.
* @param encodedregionname the encoded region name; i.e. the hash that makes
* up the region name suffix: e.g. if regionname is
* <code>testtable,0094429456,1289497600452.527db22f95c8a9e0116f0cc13c680396.</code>,
* then the encoded region name is: <code>527db22f95c8a9e0116f0cc13c680396</code>.
* @param destservername the servername of the destination regionserver.  if
* passed the empty byte array we'll assign to a random server.  a server name
* is made of host, port and startcode.  here is an example:
* <code> host187.example.com,60020,1289493121758</code>
* @throws unknownregionexception thrown if we can't find a region named
* <code>encodedregionname</code>
* @throws zookeeperconnectionexception
* @throws masternotrunningexception
*/
public void move final byte  encodedregionname  final byte  destservername
throws hbaseioexception  masternotrunningexception  zookeeperconnectionexception
masteradminkeepaliveconnection stub   connection getkeepalivemasteradminservice
try
moveregionrequest request
requestconverter buildmoveregionrequest encodedregionname  destservername
stub moveregion null request
catch  serviceexception se
ioexception ioe   protobufutil getremoteexception se
if  ioe instanceof hbaseioexception
throw  hbaseioexception ioe
log error     se
catch  deserializationexception de
log error     de
finally
stub close
/**
* @param regionname
*          region name to assign.
* @throws masternotrunningexception
* @throws zookeeperconnectionexception
* @throws ioexception
*/
public void assign final byte regionname  throws masternotrunningexception
zookeeperconnectionexception  ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
assignregionrequest request   requestconverter buildassignregionrequest regionname
masteradmin assignregion null request
return null
/**
* unassign a region from current hosting regionserver.  region will then be
* assigned to a regionserver chosen at random.  region could be reassigned
* back to the same server.  use {@link #move(byte[], byte[])} if you want
* to control the region movement.
* @param regionname region to unassign. will clear any existing regionplan
* if one found.
* @param force if true, force unassign (will remove region from
* regions-in-transition too if present. if results in double assignment
* use hbck -fix to resolve. to be used by experts).
* @throws masternotrunningexception
* @throws zookeeperconnectionexception
* @throws ioexception
*/
public void unassign final byte  regionname  final boolean force
throws masternotrunningexception  zookeeperconnectionexception  ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
unassignregionrequest request
requestconverter buildunassignregionrequest regionname  force
masteradmin unassignregion null request
return null
/**
* special method, only used by hbck.
*/
public void offline final byte  regionname
throws ioexception
masteradminkeepaliveconnection master   connection getkeepalivemasteradminservice
try
master offlineregion null requestconverter buildofflineregionrequest regionname
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
/**
* turn the load balancer on or off.
* @param on if true, enable balancer. if false, disable balancer.
* @param synchronous if true, it waits until current balance() call, if outstanding, to return.
* @return previous balancer value
*/
public boolean setbalancerrunning final boolean on  final boolean synchronous
throws masternotrunningexception  zookeeperconnectionexception
masteradminkeepaliveconnection stub   connection getkeepalivemasteradminservice
try
setbalancerrunningrequest req
requestconverter buildsetbalancerrunningrequest on  synchronous
return stub setbalancerrunning null  req  getprevbalancevalue
catch  serviceexception se
ioexception ioe   protobufutil getremoteexception se
if  ioe instanceof masternotrunningexception
throw  masternotrunningexception ioe
if  ioe instanceof zookeeperconnectionexception
throw  zookeeperconnectionexception ioe
// throwing masternotrunningexception even though not really valid in order to not
// break interface by adding additional exception type.
throw new masternotrunningexception   se
finally
stub close
/**
* invoke the balancer.  will run the balancer and if regions to move, it will
* go ahead and do the reassignments.  can not run for various reasons.  check
* logs.
* @return true if balancer ran, false otherwise.
*/
public boolean balancer
throws masternotrunningexception  zookeeperconnectionexception  serviceexception
masteradminkeepaliveconnection stub   connection getkeepalivemasteradminservice
try
return stub balance null requestconverter buildbalancerequest    getbalancerran
finally
stub close
/**
* enable/disable the catalog janitor
* @param enable if true enables the catalog janitor
* @return the previous state
* @throws serviceexception
* @throws masternotrunningexception
*/
public boolean enablecatalogjanitor boolean enable
throws serviceexception  masternotrunningexception
masteradminkeepaliveconnection stub   connection getkeepalivemasteradminservice
try
return stub enablecatalogjanitor null
requestconverter buildenablecatalogjanitorrequest enable   getprevvalue
finally
stub close
/**
* ask for a scan of the catalog table
* @return the number of entries cleaned
* @throws serviceexception
* @throws masternotrunningexception
*/
public int runcatalogscan   throws serviceexception  masternotrunningexception
masteradminkeepaliveconnection stub   connection getkeepalivemasteradminservice
try
return stub runcatalogscan null
requestconverter buildcatalogscanrequest    getscanresult
finally
stub close
/**
* query on the catalog janitor state (enabled/disabled?)
* @throws serviceexception
* @throws org.apache.hadoop.hbase.masternotrunningexception
*/
public boolean iscatalogjanitorenabled   throws serviceexception  masternotrunningexception
masteradminkeepaliveconnection stub   connection getkeepalivemasteradminservice
try
return stub iscatalogjanitorenabled null
requestconverter buildiscatalogjanitorenabledrequest    getvalue
finally
stub close
/**
* merge two regions. asynchronous operation.
* @param encodednameofregiona encoded name of region a
* @param encodednameofregionb encoded name of region b
* @param forcible true if do a compulsory merge, otherwise we will only merge
*          two adjacent regions
* @throws ioexception
*/
public void mergeregions final byte encodednameofregiona
final byte encodednameofregionb  final boolean forcible
throws ioexception
masteradminkeepaliveconnection master   connection
getkeepalivemasteradminservice
try
dispatchmergingregionsrequest request   requestconverter
builddispatchmergingregionsrequest encodednameofregiona
encodednameofregionb  forcible
master dispatchmergingregions null  request
catch  serviceexception se
ioexception ioe   protobufutil getremoteexception se
if  ioe instanceof unknownregionexception
throw  unknownregionexception  ioe
if  ioe instanceof mergeregionexception
throw  mergeregionexception  ioe
log error     se
catch  deserializationexception de
log error     de
finally
master close
/**
* split a table or an individual region.
* asynchronous operation.
*
* @param tablenameorregionname table or region to split
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void split final string tablenameorregionname
throws ioexception  interruptedexception
split bytes tobytes tablenameorregionname
/**
* split a table or an individual region.  implicitly finds an optimal split
* point.  asynchronous operation.
*
* @param tablenameorregionname table to region to split
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
*/
public void split final byte tablenameorregionname
throws ioexception  interruptedexception
split tablenameorregionname  null
public void split final string tablenameorregionname
final string splitpoint  throws ioexception  interruptedexception
split bytes tobytes tablenameorregionname   bytes tobytes splitpoint
/**
* split a table or an individual region.
* asynchronous operation.
*
* @param tablenameorregionname table to region to split
* @param splitpoint the explicit position to split on
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception interrupt exception occurred
*/
public void split final byte tablenameorregionname
final byte  splitpoint  throws ioexception  interruptedexception
catalogtracker ct   getcatalogtracker
try
pair<hregioninfo  servername> regionserverpair
getregion tablenameorregionname  ct
if  regionserverpair    null
if  regionserverpair getsecond      null
throw new noserverforregionexception bytes tostringbinary tablenameorregionname
else
split regionserverpair getsecond    regionserverpair getfirst    splitpoint
else
final tablename tablename
checktableexists tablename valueof tablenameorregionname   ct
list<pair<hregioninfo  servername>> pairs
metareader gettableregionsandlocations ct
tablename
for  pair<hregioninfo  servername> pair  pairs
// may not be a server for a particular row
if  pair getsecond      null  continue
hregioninfo r   pair getfirst
// check for parents
if  r issplitparent    continue
// if a split point given, only split that particular region
if  splitpoint    null     r containsrow splitpoint   continue
// call out to region server to do split now
split pair getsecond    pair getfirst    splitpoint
finally
cleanupcatalogtracker ct
private void split final servername sn  final hregioninfo hri
byte splitpoint  throws ioexception
adminservice blockinginterface admin   this connection getadmin sn
protobufutil split admin  hri  splitpoint
/**
* modify an existing table, more irb friendly version.
* asynchronous operation.  this means that it may be a while before your
* schema change is updated across all of the table.
*
* @param tablename name of table.
* @param htd modified description of the table
* @throws ioexception if a remote or network exception occurs
*/
public void modifytable final tablename tablename  final htabledescriptor htd
throws ioexception
if   tablename equals htd gettablename
throw new illegalargumentexception     tablename
htd gettablename
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
modifytablerequest request   requestconverter buildmodifytablerequest tablename  htd
masteradmin modifytable null  request
return null
public void modifytable final byte tablename  final htabledescriptor htd
throws ioexception
modifytable tablename valueof tablename   htd
public void modifytable final string tablename  final htabledescriptor htd
throws ioexception
modifytable tablename valueof tablename   htd
/**
* @param tablenameorregionname name of a table or name of a region.
* @param ct a {@link catalogtracker} instance (caller of this method usually has one).
* @return a pair of hregioninfo and servername if <code>tablenameorregionname</code> is
*  a verified region name (we call {@link  metareader#getregion( catalogtracker, byte[])}
*  else null.
* throw an exception if <code>tablenameorregionname</code> is null.
* @throws ioexception
*/
pair<hregioninfo  servername> getregion final byte tablenameorregionname
final catalogtracker ct  throws ioexception
if  tablenameorregionname    null
throw new illegalargumentexception
pair<hregioninfo  servername> pair   metareader getregion ct  tablenameorregionname
if  pair    null
final atomicreference<pair<hregioninfo  servername>> result
new atomicreference<pair<hregioninfo  servername>> null
final string encodedname   bytes tostring tablenameorregionname
metascannervisitor visitor   new metascannervisitorbase
@override
public boolean processrow result data  throws ioexception
hregioninfo info   hregioninfo gethregioninfo data
if  info    null
log warn     data
return true
if   encodedname equals info getencodedname     return true
servername sn   hregioninfo getservername data
result set new pair<hregioninfo  servername> info  sn
return false     found the region  stop
metascanner metascan conf  connection  visitor  null
pair   result get
return pair
/**
* check if table exists or not
* @param tablename name of a table.
* @param ct a {@link catalogtracker} instance (caller of this method usually has one).
* @return tablename instance
* @throws ioexception if a remote or network exception occurs.
* @throws tablenotfoundexception if table does not exist.
*/
//todo rename this method
private tablename checktableexists
final tablename tablename  catalogtracker ct
throws ioexception
if   metareader tableexists ct  tablename
throw new tablenotfoundexception tablename
return tablename
/**
* shuts down the hbase cluster
* @throws ioexception if a remote or network exception occurs
*/
public synchronized void shutdown   throws ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
masteradmin shutdown null shutdownrequest newbuilder   build
return null
/**
* shuts down the current hbase master only.
* does not shutdown the cluster.
* @see #shutdown()
* @throws ioexception if a remote or network exception occurs
*/
public synchronized void stopmaster   throws ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
masteradmin stopmaster null stopmasterrequest newbuilder   build
return null
/**
* stop the designated regionserver
* @param hostnameport hostname and port delimited by a <code>:</code> as in
* <code>example.org:1234</code>
* @throws ioexception if a remote or network exception occurs
*/
public synchronized void stopregionserver final string hostnameport
throws ioexception
string hostname   addressing parsehostname hostnameport
int port   addressing parseport hostnameport
adminservice blockinginterface admin
this connection getadmin new servername hostname  port  0
stopserverrequest request   requestconverter buildstopserverrequest
this connection tostring
try
admin stopserver null  request
catch  serviceexception se
throw protobufutil getremoteexception se
/**
* @return cluster status
* @throws ioexception if a remote or network exception occurs
*/
public clusterstatus getclusterstatus   throws ioexception
return executecallable new mastermonitorcallable<clusterstatus> getconnection
@override
public clusterstatus call   throws serviceexception
getclusterstatusrequest req   requestconverter buildgetclusterstatusrequest
return clusterstatus convert mastermonitor getclusterstatus null req  getclusterstatus
private hregionlocation getfirstmetaserverfortable final tablename tablename
throws ioexception
return connection locateregion tablename meta_table_name
hregioninfo createregionname tablename  null  hconstants nines  false
/**
* @return configuration used by the instance.
*/
public configuration getconfiguration
return this conf
/**
* create a new namespace
* @param descriptor descriptor which describes the new namespace
* @throws ioexception
*/
public void createnamespace final namespacedescriptor descriptor  throws ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws exception
masteradmin createnamespace null
masteradminprotos createnamespacerequest newbuilder
setnamespacedescriptor protobufutil
toprotonamespacedescriptor descriptor   build
return null
/**
* modify an existing namespace
* @param descriptor descriptor which describes the new namespace
* @throws ioexception
*/
public void modifynamespace final namespacedescriptor descriptor  throws ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws exception
masteradmin modifynamespace null
masteradminprotos modifynamespacerequest newbuilder
setnamespacedescriptor protobufutil
toprotonamespacedescriptor descriptor   build
return null
/**
* delete an existing namespace. only empty namespaces (no tables) can be removed.
* @param name namespace name
* @throws ioexception
*/
public void deletenamespace final string name  throws ioexception
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws exception
masteradmin deletenamespace null
masteradminprotos deletenamespacerequest newbuilder
setnamespacename name  build
return null
/**
* get a namespace descriptor by name
* @param name name of namespace descriptor
* @return a descriptor
* @throws ioexception
*/
public namespacedescriptor getnamespacedescriptor final string name  throws ioexception
return
executecallable new masteradmincallable<namespacedescriptor> getconnection
@override
public namespacedescriptor call   throws exception
return protobufutil tonamespacedescriptor
masteradmin getnamespacedescriptor null
masteradminprotos getnamespacedescriptorrequest newbuilder
setnamespacename name  build    getnamespacedescriptor
/**
* list available namespace descriptors
* @return list of descriptors
* @throws ioexception
*/
public namespacedescriptor listnamespacedescriptors   throws ioexception
return
executecallable new masteradmincallable<namespacedescriptor> getconnection
@override
public namespacedescriptor call   throws exception
list<hbaseprotos namespacedescriptor> list
masteradmin listnamespacedescriptors null
masteradminprotos listnamespacedescriptorsrequest newbuilder   build
getnamespacedescriptorlist
namespacedescriptor res   new namespacedescriptor
for int i   0  i < list size    i
res   protobufutil tonamespacedescriptor list get i
return res
/**
* get list of table descriptors by namespace
* @param name namespace name
* @return a descriptor
* @throws ioexception
*/
public htabledescriptor listtabledescriptorsbynamespace final string name  throws ioexception
return
executecallable new masteradmincallable<htabledescriptor> getconnection
@override
public htabledescriptor call   throws exception
list<tableschema> list
masteradmin listtabledescriptorsbynamespace null
masteradminprotos listtabledescriptorsbynamespacerequest newbuilder
setnamespacename name  build
gettableschemalist
htabledescriptor res   new htabledescriptor
for int i 0  i < list size    i
res   htabledescriptor convert list get i
return res
/**
* get list of table names by namespace
* @param name namespace name
* @return the list of table names in the namespace
* @throws ioexception
*/
public tablename listtablenamesbynamespace final string name  throws ioexception
return
executecallable new masteradmincallable<tablename> getconnection
@override
public tablename call   throws exception
list<hbaseprotos tablename> tablenames
masteradmin listtablenamesbynamespace null
masteradminprotos listtablenamesbynamespacerequest newbuilder
setnamespacename name  build
gettablenamelist
tablename result   new tablename
for  int i   0  i < tablenames size    i
result   protobufutil totablename tablenames get i
return result
/**
* check to see if hbase is running. throw an exception if not.
* we consider that hbase is running if zookeeper and master are running.
*
* @param conf system configuration
* @throws masternotrunningexception if the master is not running
* @throws zookeeperconnectionexception if unable to connect to zookeeper
*/
public static void checkhbaseavailable configuration conf
throws masternotrunningexception  zookeeperconnectionexception  serviceexception  ioexception
configuration copyofconf   hbaseconfiguration create conf
// we set it to make it fail as soon as possible if hbase is not available
copyofconf setint hconstants hbase_client_retries_number  1
copyofconf setint    0
hconnectionmanager hconnectionimplementation connection
hconnectionmanager hconnectionimplementation
hconnectionmanager getconnection copyofconf
try
// check zk first.
// if the connection exists, we may have a connection to zk that does
//  not work anymore
zookeeperkeepaliveconnection zkw   null
try
zkw   connection getkeepalivezookeeperwatcher
zkw getrecoverablezookeeper   getzookeeper   exists
zkw baseznode  false
catch  ioexception e
throw new zookeeperconnectionexception    e
catch  interruptedexception e
thread currentthread   interrupt
throw new zookeeperconnectionexception    e
catch  keeperexception e
throw new zookeeperconnectionexception    e
finally
if  zkw    null
zkw close
// check master
connection ismasterrunning
finally
connection close
/**
* get the regions of a given table.
*
* @param tablename the name of the table
* @return ordered list of {@link hregioninfo}.
* @throws ioexception
*/
public list<hregioninfo> gettableregions final tablename tablename
throws ioexception
catalogtracker ct   getcatalogtracker
list<hregioninfo> regions   null
try
regions   metareader gettableregions ct  tablename  true
finally
cleanupcatalogtracker ct
return regions
public list<hregioninfo> gettableregions final byte tablename
throws ioexception
return gettableregions tablename valueof tablename
@override
public void close   throws ioexception
if  cleanupconnectiononclose    this connection    null
this connection close
/**
* get tabledescriptors
* @param tablenames list of table names
* @return htd[] the tabledescriptor
* @throws ioexception if a remote or network exception occurs
*/
public htabledescriptor gettabledescriptorsbytablename list<tablename> tablenames
throws ioexception
return this connection gethtabledescriptorsbytablename tablenames
/**
* get tabledescriptors
* @param names list of table names
* @return htd[] the tabledescriptor
* @throws ioexception if a remote or network exception occurs
*/
public htabledescriptor gettabledescriptors list<string> names
throws ioexception
list<tablename> tablenames   new arraylist<tablename> names size
for string name   names
tablenames add tablename valueof name
return gettabledescriptorsbytablename tablenames
/**
* roll the log writer. that is, start writing log messages to a new file.
*
* @param servername
*          the servername of the regionserver. a server name is made of host,
*          port and startcode. this is mandatory. here is an example:
*          <code> host187.example.com,60020,1289493121758</code>
* @return if lots of logs, flush the returned regions so next time through
* we can clean logs. returns null if nothing to flush.  names are actual
* region names as returned by {@link hregioninfo#getencodedname()}
* @throws ioexception if a remote or network exception occurs
* @throws failedlogcloseexception
*/
public synchronized  byte rollhlogwriter string servername
throws ioexception  failedlogcloseexception
servername sn   new servername servername
adminservice blockinginterface admin   this connection getadmin sn
rollwalwriterrequest request   requestconverter buildrollwalwriterrequest
try
rollwalwriterresponse response   admin rollwalwriter null  request
int regioncount   response getregiontoflushcount
byte regionstoflush   new byte
for  int i   0  i < regioncount  i
bytestring region   response getregiontoflush i
regionstoflush   region tobytearray
return regionstoflush
catch  serviceexception se
throw protobufutil getremoteexception se
public string getmastercoprocessors
try
return getclusterstatus   getmastercoprocessors
catch  ioexception e
log error   e
return null
/**
* get the current compaction state of a table or region.
* it could be in a major compaction, a minor compaction, both, or none.
*
* @param tablenameorregionname table or region to major compact
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
* @return the current compaction state
*/
public compactionstate getcompactionstate final string tablenameorregionname
throws ioexception  interruptedexception
return getcompactionstate bytes tobytes tablenameorregionname
/**
* get the current compaction state of a table or region.
* it could be in a major compaction, a minor compaction, both, or none.
*
* @param tablenameorregionname table or region to major compact
* @throws ioexception if a remote or network exception occurs
* @throws interruptedexception
* @return the current compaction state
*/
public compactionstate getcompactionstate final byte tablenameorregionname
throws ioexception  interruptedexception
compactionstate state   compactionstate none
catalogtracker ct   getcatalogtracker
try
pair<hregioninfo  servername> regionserverpair
getregion tablenameorregionname  ct
if  regionserverpair    null
if  regionserverpair getsecond      null
throw new noserverforregionexception bytes tostringbinary tablenameorregionname
else
servername sn   regionserverpair getsecond
adminservice blockinginterface admin   this connection getadmin sn
getregioninforequest request   requestconverter buildgetregioninforequest
regionserverpair getfirst   getregionname    true
getregioninforesponse response   admin getregioninfo null  request
return response getcompactionstate
else
final tablename tablename
checktableexists tablename valueof tablenameorregionname   ct
list<pair<hregioninfo  servername>> pairs
metareader gettableregionsandlocations ct  tablename
for  pair<hregioninfo  servername> pair  pairs
if  pair getfirst   isoffline    continue
if  pair getsecond      null  continue
try
servername sn   pair getsecond
adminservice blockinginterface admin   this connection getadmin sn
getregioninforequest request   requestconverter buildgetregioninforequest
pair getfirst   getregionname    true
getregioninforesponse response   admin getregioninfo null  request
switch  response getcompactionstate
case major_and_minor
return compactionstate major_and_minor
case major
if  state    compactionstate minor
return compactionstate major_and_minor
state   compactionstate major
break
case minor
if  state    compactionstate major
return compactionstate major_and_minor
state   compactionstate minor
break
case none
default     nothing  continue
catch  notservingregionexception e
if  log isdebugenabled
log debug
pair getfirst
stringutils stringifyexception e
catch  serviceexception se
throw protobufutil getremoteexception se
finally
cleanupcatalogtracker ct
return state
/**
* take a snapshot for the given table. if the table is enabled, a flush-type snapshot will be
* taken. if the table is disabled, an offline snapshot is taken.
* <p>
* snapshots are considered unique based on <b>the name of the snapshot</b>. attempts to take a
* snapshot with the same name (even a different type or with different parameters) will fail with
* a {@link snapshotcreationexception} indicating the duplicate naming.
* <p>
* snapshot names follow the same naming constraints as tables in hbase. see
* {@link org.apache.hadoop.hbase.tablename#islegalfullyqualifiedtablename(byte[])}.
* @param snapshotname name of the snapshot to be created
* @param tablename name of the table for which snapshot is created
* @throws ioexception if a remote or network exception occurs
* @throws snapshotcreationexception if snapshot creation failed
* @throws illegalargumentexception if the snapshot request is formatted incorrectly
*/
public void snapshot(final string snapshotname,
final tablename tablename  throws ioexception
snapshotcreationexception  illegalargumentexception
snapshot snapshotname  tablename  snapshotdescription type flush
public void snapshot(final string snapshotname,
final string tablename  throws ioexception
snapshotcreationexception  illegalargumentexception
snapshot snapshotname  tablename valueof tablename
snapshotdescription type flush
/**
public void snapshot(final string snapshotname,
* create a timestamp consistent snapshot for the given table.
final byte[] tablename) throws ioexception,
* <p>
* snapshots are considered unique based on <b>the name of the snapshot</b>. attempts to take a
* snapshot with the same name (even a different type or with different parameters) will fail with
* a {@link snapshotcreationexception} indicating the duplicate naming.
* <p>
* snapshot names follow the same naming constraints as tables in hbase.
* @param snapshotname name of the snapshot to be created
* @param tablename name of the table for which snapshot is created
* @throws ioexception if a remote or network exception occurs
* @throws snapshotcreationexception if snapshot creation failed
* @throws illegalargumentexception if the snapshot request is formatted incorrectly
*/
public void snapshot final byte snapshotname
final tablename tablename  throws ioexception
snapshotcreationexception  illegalargumentexception
snapshot bytes tostring snapshotname   tablename  snapshotdescription type flush
public void snapshot final byte snapshotname
final byte[] tablename) throws ioexception,
snapshotcreationexception  illegalargumentexception
snapshot bytes tostring snapshotname   tablename valueof tablename
snapshotdescription type flush
/**
* create typed snapshot of the table.
* <p>
* snapshots are considered unique based on <b>the name of the snapshot</b>. attempts to take a
* snapshot with the same name (even a different type or with different parameters) will fail with
* a {@link snapshotcreationexception} indicating the duplicate naming.
* <p>
* snapshot names follow the same naming constraints as tables in hbase. see
* {@link org.apache.hadoop.hbase.tablename#islegalfullyqualifiedtablename(byte[])}.
* <p>
* @param snapshotname name to give the snapshot on the filesystem. must be unique from all other
*          snapshots stored on the cluster
* @param tablename name of the table to snapshot
* @param type type of snapshot to take
* @throws ioexception we fail to reach the master
* @throws snapshotcreationexception if snapshot creation failed
* @throws illegalargumentexception if the snapshot request is formatted incorrectly
*/
public void snapshot(final string snapshotname,
final tablename tablename
snapshotdescription type type  throws ioexception  snapshotcreationexception
illegalargumentexception
snapshotdescription builder builder   snapshotdescription newbuilder
builder settable tablename getnameasstring
builder setname snapshotname
builder settype type
snapshot builder build
public void snapshot(final string snapshotname,
final string tablename
snapshotdescription type type  throws ioexception  snapshotcreationexception
illegalargumentexception
snapshot snapshotname  tablename valueof tablename   type
public void snapshot(final string snapshotname,
final byte tablename
snapshotdescription type type  throws ioexception  snapshotcreationexception
illegalargumentexception
snapshot snapshotname  tablename valueof tablename   type
/**
* take a snapshot and wait for the server to complete that snapshot (blocking).
* <p>
* only a single snapshot should be taken at a time for an instance of hbase, or results may be
* undefined (you can tell multiple hbase clusters to snapshot at the same time, but only one at a
* time for a single cluster).
* <p>
* snapshots are considered unique based on <b>the name of the snapshot</b>. attempts to take a
* snapshot with the same name (even a different type or with different parameters) will fail with
* a {@link snapshotcreationexception} indicating the duplicate naming.
* <p>
* snapshot names follow the same naming constraints as tables in hbase. see
* {@link org.apache.hadoop.hbase.tablename#islegalfullyqualifiedtablename(byte[])}.
* <p>
* you should probably use {@link #snapshot(string, string)} or {@link #snapshot(byte[], byte[])}
* unless you are sure about the type of snapshot that you want to take.
* @param snapshot snapshot to take
* @throws ioexception or we lose contact with the master.
* @throws snapshotcreationexception if snapshot failed to be taken
* @throws illegalargumentexception if the snapshot request is formatted incorrectly
*/
public void snapshot snapshotdescription snapshot  throws ioexception  snapshotcreationexception
illegalargumentexception
// actually take the snapshot
takesnapshotresponse response   takesnapshotasync snapshot
final issnapshotdonerequest request   issnapshotdonerequest newbuilder   setsnapshot snapshot
build
issnapshotdoneresponse done   null
long start   environmentedgemanager currenttimemillis
long max   response getexpectedtimeout
long maxpausetime   max   this numretries
int tries   0
log debug     max
clientsnapshotdescriptionutils tostring snapshot
maxpausetime
while  tries    0
environmentedgemanager currenttimemillis     start  < max     done getdone
try
// sleep a backoff <= pausetime amount
long sleep   getpausetime tries
sleep   sleep > maxpausetime ? maxpausetime   sleep
log debug     tries       sleep
thread sleep sleep
catch  interruptedexception e
log debug     snapshot
thread currentthread   interrupt
log debug
done   executecallable new masteradmincallable<issnapshotdoneresponse> getconnection
@override
public issnapshotdoneresponse call   throws serviceexception
return masteradmin issnapshotdone null  request
if   done getdone
throw new snapshotcreationexception     snapshot getname
max      snapshot
/**
* take a snapshot without waiting for the server to complete that snapshot (asynchronous)
* <p>
* only a single snapshot should be taken at a time, or results may be undefined.
* @param snapshot snapshot to take
* @return response from the server indicating the max time to wait for the snapshot
* @throws ioexception if the snapshot did not succeed or we lose contact with the master.
* @throws snapshotcreationexception if snapshot creation failed
* @throws illegalargumentexception if the snapshot request is formatted incorrectly
*/
public takesnapshotresponse takesnapshotasync snapshotdescription snapshot  throws ioexception
snapshotcreationexception
clientsnapshotdescriptionutils assertsnapshotrequestisvalid snapshot
final takesnapshotrequest request   takesnapshotrequest newbuilder   setsnapshot snapshot
build
// run the snapshot on the master
return executecallable new masteradmincallable<takesnapshotresponse> getconnection
@override
public takesnapshotresponse call   throws serviceexception
return masteradmin snapshot null  request
/**
* check the current state of the passed snapshot.
* <p>
* there are three possible states:
* <ol>
* <li>running - returns <tt>false</tt></li>
* <li>finished - returns <tt>true</tt></li>
* <li>finished with error - throws the exception that caused the snapshot to fail</li>
* </ol>
* <p>
* the cluster only knows about the most recent snapshot. therefore, if another snapshot has been
* run/started since the snapshot your are checking, you will recieve an
* {@link unknownsnapshotexception}.
* @param snapshot description of the snapshot to check
* @return <tt>true</tt> if the snapshot is completed, <tt>false</tt> if the snapshot is still
*         running
* @throws ioexception if we have a network issue
* @throws hbasesnapshotexception if the snapshot failed
* @throws unknownsnapshotexception if the requested snapshot is unknown
*/
public boolean issnapshotfinished final snapshotdescription snapshot
throws ioexception  hbasesnapshotexception  unknownsnapshotexception
return executecallable new masteradmincallable<issnapshotdoneresponse> getconnection
@override
public issnapshotdoneresponse call   throws serviceexception
return masteradmin issnapshotdone null
issnapshotdonerequest newbuilder   setsnapshot snapshot  build
getdone
/**
* restore the specified snapshot on the original table. (the table must be disabled)
* before restoring the table, a new snapshot with the current table state is created.
* in case of failure, the table will be rolled back to its original state.
*
* @param snapshotname name of the snapshot to restore
* @throws ioexception if a remote or network exception occurs
* @throws restoresnapshotexception if snapshot failed to be restored
* @throws illegalargumentexception if the restore request is formatted incorrectly
*/
public void restoresnapshot final byte snapshotname
throws ioexception  restoresnapshotexception
restoresnapshot bytes tostring snapshotname
/**
* restore the specified snapshot on the original table. (the table must be disabled)
* before restoring the table, a new snapshot with the current table state is created.
* in case of failure, the table will be rolled back to the its original state.
*
* @param snapshotname name of the snapshot to restore
* @throws ioexception if a remote or network exception occurs
* @throws restoresnapshotexception if snapshot failed to be restored
* @throws illegalargumentexception if the restore request is formatted incorrectly
*/
public void restoresnapshot final string snapshotname
throws ioexception  restoresnapshotexception
string rollbacksnapshot   snapshotname       environmentedgemanager currenttimemillis
tablename tablename   null
for  snapshotdescription snapshotinfo  listsnapshots
if  snapshotinfo getname   equals snapshotname
tablename   tablename valueof snapshotinfo gettable
break
if  tablename    null
throw new restoresnapshotexception
snapshotname
// take a snapshot of the current state
snapshot rollbacksnapshot  tablename
// restore snapshot
try
internalrestoresnapshot snapshotname  tablename
catch  ioexception e
// try to rollback
try
string msg       snapshotname
rollbacksnapshot
log error msg  e
internalrestoresnapshot rollbacksnapshot  tablename
throw new restoresnapshotexception msg  e
catch  ioexception ex
string msg       rollbacksnapshot
log error msg  ex
throw new restoresnapshotexception msg  ex
/**
* create a new table by cloning the snapshot content.
*
* @param snapshotname name of the snapshot to be cloned
* @param tablename name of the table where the snapshot will be restored
* @throws ioexception if a remote or network exception occurs
* @throws tableexistsexception if table to be created already exists
* @throws restoresnapshotexception if snapshot failed to be cloned
* @throws illegalargumentexception if the specified table has not a valid name
*/
public void clonesnapshot final byte snapshotname  final byte tablename
throws ioexception  tableexistsexception  restoresnapshotexception  interruptedexception
clonesnapshot bytes tostring snapshotname   tablename valueof tablename
/**
* create a new table by cloning the snapshot content.
*
* @param snapshotname name of the snapshot to be cloned
* @param tablename name of the table where the snapshot will be restored
* @throws ioexception if a remote or network exception occurs
* @throws tableexistsexception if table to be created already exists
* @throws restoresnapshotexception if snapshot failed to be cloned
* @throws illegalargumentexception if the specified table has not a valid name
*/
public void clonesnapshot final byte snapshotname  final tablename tablename
throws ioexception  tableexistsexception  restoresnapshotexception  interruptedexception
clonesnapshot bytes tostring snapshotname   tablename
/**
* create a new table by cloning the snapshot content.
*
* @param snapshotname name of the snapshot to be cloned
* @param tablename name of the table where the snapshot will be restored
* @throws ioexception if a remote or network exception occurs
* @throws tableexistsexception if table to be created already exists
* @throws restoresnapshotexception if snapshot failed to be cloned
* @throws illegalargumentexception if the specified table has not a valid name
*/
public void clonesnapshot final string snapshotname  final string tablename
throws ioexception  tableexistsexception  restoresnapshotexception  interruptedexception
clonesnapshot snapshotname  tablename valueof tablename
/**
* create a new table by cloning the snapshot content.
*
* @param snapshotname name of the snapshot to be cloned
* @param tablename name of the table where the snapshot will be restored
* @throws ioexception if a remote or network exception occurs
* @throws tableexistsexception if table to be created already exists
* @throws restoresnapshotexception if snapshot failed to be cloned
* @throws illegalargumentexception if the specified table has not a valid name
*/
public void clonesnapshot final string snapshotname  final tablename tablename
throws ioexception  tableexistsexception  restoresnapshotexception  interruptedexception
if  tableexists tablename
throw new tableexistsexception     tablename
internalrestoresnapshot snapshotname  tablename
waituntiltableisenabled tablename
/**
* execute restore/clone snapshot and wait for the server to complete (blocking).
* to check if the cloned table exists, use {@link #istableavailable} -- it is not safe to
* create an htable instance to this table before it is available.
* @param snapshotname snapshot to restore
* @param tablename table name to restore the snapshot on
* @throws ioexception if a remote or network exception occurs
* @throws restoresnapshotexception if snapshot failed to be restored
* @throws illegalargumentexception if the restore request is formatted incorrectly
*/
private void internalrestoresnapshot final string snapshotname  final tablename
tablename
throws ioexception  restoresnapshotexception
snapshotdescription snapshot   snapshotdescription newbuilder
setname snapshotname  settable tablename getnameasstring    build
// actually restore the snapshot
internalrestoresnapshotasync snapshot
final isrestoresnapshotdonerequest request   isrestoresnapshotdonerequest newbuilder
setsnapshot snapshot  build
isrestoresnapshotdoneresponse done   isrestoresnapshotdoneresponse newbuilder   buildpartial
final long maxpausetime   5000
int tries   0
while   done getdone
try
// sleep a backoff <= pausetime amount
long sleep   getpausetime tries
sleep   sleep > maxpausetime ? maxpausetime   sleep
log debug tries       sleep
thread sleep sleep
catch  interruptedexception e
log debug     snapshot
thread currentthread   interrupt
log debug
done   executecallable new masteradmincallable<isrestoresnapshotdoneresponse>
getconnection
@override
public isrestoresnapshotdoneresponse call   throws serviceexception
return masteradmin isrestoresnapshotdone null  request
if   done getdone
throw new restoresnapshotexception     snapshot getname
/**
* execute restore/clone snapshot and wait for the server to complete (asynchronous)
* <p>
* only a single snapshot should be restored at a time, or results may be undefined.
* @param snapshot snapshot to restore
* @return response from the server indicating the max time to wait for the snapshot
* @throws ioexception if a remote or network exception occurs
* @throws restoresnapshotexception if snapshot failed to be restored
* @throws illegalargumentexception if the restore request is formatted incorrectly
*/
private restoresnapshotresponse internalrestoresnapshotasync final snapshotdescription snapshot
throws ioexception  restoresnapshotexception
clientsnapshotdescriptionutils assertsnapshotrequestisvalid snapshot
final restoresnapshotrequest request   restoresnapshotrequest newbuilder   setsnapshot snapshot
build
// run the snapshot restore on the master
return executecallable new masteradmincallable<restoresnapshotresponse> getconnection
@override
public restoresnapshotresponse call   throws serviceexception
return masteradmin restoresnapshot null  request
/**
* list completed snapshots.
* @return a list of snapshot descriptors for completed snapshots
* @throws ioexception if a network error occurs
*/
public list<snapshotdescription> listsnapshots   throws ioexception
return executecallable new masteradmincallable<list<snapshotdescription>> getconnection
@override
public list<snapshotdescription> call   throws serviceexception
return masteradmin getcompletedsnapshots null  listsnapshotrequest newbuilder   build
getsnapshotslist
/**
* list all the completed snapshots matching the given regular expression.
*
* @param regex the regular expression to match against
* @return - returns a list of snapshotdescription
* @throws ioexception if a remote or network exception occurs
*/
public list<snapshotdescription> listsnapshots string regex  throws ioexception
return listsnapshots pattern compile regex
/**
* list all the completed snapshots matching the given pattern.
*
* @param pattern the compiled regular expression to match against
* @return - returns a list of snapshotdescription
* @throws ioexception if a remote or network exception occurs
*/
public list<snapshotdescription> listsnapshots pattern pattern  throws ioexception
list<snapshotdescription> matched   new linkedlist<snapshotdescription>
list<snapshotdescription> snapshots   listsnapshots
for  snapshotdescription snapshot   snapshots
if  pattern matcher snapshot getname    matches
matched add snapshot
return matched
/**
* delete an existing snapshot.
* @param snapshotname name of the snapshot
* @throws ioexception if a remote or network exception occurs
*/
public void deletesnapshot final byte snapshotname  throws ioexception
deletesnapshot bytes tostring snapshotname
/**
* delete an existing snapshot.
* @param snapshotname name of the snapshot
* @throws ioexception if a remote or network exception occurs
*/
public void deletesnapshot final string snapshotname  throws ioexception
// make sure the snapshot is possibly valid
tablename islegalfullyqualifiedtablename bytes tobytes snapshotname
// do the delete
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
masteradmin deletesnapshot null
deletesnapshotrequest newbuilder
setsnapshot snapshotdescription newbuilder   setname snapshotname  build    build
return null
/**
* delete existing snapshots whose names match the pattern passed.
* @param regex the regular expression to match against
* @throws ioexception if a remote or network exception occurs
*/
public void deletesnapshots final string regex  throws ioexception
deletesnapshots pattern compile regex
/**
* delete existing snapshots whose names match the pattern passed.
* @param pattern pattern for names of the snapshot to match
* @throws ioexception if a remote or network exception occurs
*/
public void deletesnapshots final pattern pattern  throws ioexception
list<snapshotdescription> snapshots   listsnapshots pattern
for  final snapshotdescription snapshot   snapshots
// do the delete
executecallable new masteradmincallable<void> getconnection
@override
public void call   throws serviceexception
this masteradmin deletesnapshot null
deletesnapshotrequest newbuilder   setsnapshot snapshot  build
return null
/**
* @see {@link #executecallable(org.apache.hadoop.hbase.client.hbaseadmin.mastercallable)}
*/
abstract static class masteradmincallable<v> extends mastercallable<v>
protected masteradminkeepaliveconnection masteradmin
public masteradmincallable final hconnection connection
super connection
@override
public void prepare boolean reload  throws ioexception
this masteradmin   this connection getkeepalivemasteradminservice
@override
public void close   throws ioexception
this masteradmin close
/**
* @see {@link #executecallable(org.apache.hadoop.hbase.client.hbaseadmin.mastercallable)}
*/
abstract static class mastermonitorcallable<v> extends mastercallable<v>
protected mastermonitorkeepaliveconnection mastermonitor
public mastermonitorcallable final hconnection connection
super connection
@override
public void prepare boolean reload  throws ioexception
this mastermonitor   this connection getkeepalivemastermonitorservice
@override
public void close   throws ioexception
this mastermonitor close
/**
* parent of {@link mastermonitorcallable} and {@link masteradmincallable}.
* has common methods.
* @param <v>
*/
abstract static class mastercallable<v> implements retryingcallable<v>  closeable
protected hconnection connection
public mastercallable final hconnection connection
this connection   connection
@override
public void throwable throwable t  boolean retrying
@override
public string getexceptionmessageadditionaldetail
return
@override
public long sleep long pause  int tries
return connectionutils getpausetime pause  tries
private <v> v executecallable mastercallable<v> callable  throws ioexception
rpcretryingcaller<v> caller   rpccallerfactory newcaller
try
return caller callwithretries callable
finally
callable close
/**
* creates and returns a {@link com.google.protobuf.rpcchannel} instance
* connected to the active master.
*
* <p>
* the obtained {@link com.google.protobuf.rpcchannel} instance can be used to access a published
* coprocessor {@link com.google.protobuf.service} using standard protobuf service invocations:
* </p>
*
* <div style="background-color: #cccccc; padding: 2px">
* <blockquote><pre>
* coprocessorrpcchannel channel = myadmin.coprocessorservice();
* myservice.blockinginterface service = myservice.newblockingstub(channel);
* mycallrequest request = mycallrequest.newbuilder()
*     ...
*     .build();
* mycallresponse response = service.mycall(null, request);
* </pre></blockquote></div>
*
* @return a mastercoprocessorrpcchannel instance
*/
public coprocessorrpcchannel coprocessorservice
return new mastercoprocessorrpcchannel connection