/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007, 2008 ola bini <ola@ologix.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util
import java io file
import java util arraylist
import java util arrays
import java util enumeration
import java util list
import java util jar jarentry
import java util jar jarfile
import org jruby ext posix javasecuredfile
/**
* this class exists as a counterpart to the dir.c file in
* mri source. it contains many methods useful for
* file matching and globbing.
*
* @author <a href="mailto:ola.bini@ki.se">ola bini</a>
*/
public class dir
public final static boolean dosish   system getproperty    indexof        1
public final static boolean casefold_filesystem   dosish
public final static int fnm_noescape   0x01
public final static int fnm_pathname   0x02
public final static int fnm_dotmatch   0x04
public final static int fnm_casefold   0x08
public final static int fnm_syscase   casefold_filesystem ? fnm_casefold   0
public final static int fnm_nomatch   1
public final static int fnm_error     2
public final static byte empty   new byte
public final static byte slash   new byte
public final static byte star   new byte
public final static byte double_star   new byte
private static boolean isdirsep byte c
return dosish ?  c         c         c
private static int rb_path_next byte _s  int s  int send
while s < send     isdirsep _s
s
return s
private static int fnmatch_helper byte bytes  int pstart  int pend  byte string  int sstart  int send  int flags
char test
int s   sstart
int pat   pstart
boolean escape    flags   fnm_noescape     0
boolean pathname    flags   fnm_pathname     0
boolean period    flags   fnm_dotmatch     0
boolean nocase    flags   fnm_casefold     0
while pat<pend
byte c   bytes
switch c
case
if s >  send     pathname    isdirsep string
period    string          s    0     pathname    isdirsep string
return fnm_nomatch
s
break
case
while pat < pend     c   bytes
if s < send     period    string          s    0     pathname    isdirsep string
return fnm_nomatch
if pat > pend     pat    pend    c
if pathname    rb_path_next string  s  send  < send
return fnm_nomatch
else
return 0
else if  pathname    isdirsep c
s   rb_path_next string  s  send
if s < send
s
break
return fnm_nomatch
test    char   escape    c         pat < pend ? bytes   c  0xff
test   character tolowercase test
pat
while s < send
if  c         c         character tolowercase  char  string     test
fnmatch bytes  pat  pend  string  s  send  flags   fnm_dotmatch     0
return 0
else if  pathname    isdirsep string
break
s
return fnm_nomatch
case
if s >  send     pathname    isdirsep string
period    string          s    0     pathname    isdirsep string
return fnm_nomatch
pat   range bytes  pat  pend   char  string 0xff   flags
if pat     1
return fnm_nomatch
s
break
case
if escape
dosish
pat < pend      indexof  char bytes      1
if pat >  pend
c
else
c   bytes
default
if s >  send
return fnm_nomatch
if dosish     pathname    isdirsep c     isdirsep string
else
if  nocase
if character tolowercase  char c     character tolowercase  char string
return fnm_nomatch
else
if c     char string
return fnm_nomatch
s
break
return s >  send ? 0   fnm_nomatch
public static int fnmatch
byte bytes  int pstart  int pend
byte string  int sstart  int send  int flags
// this method handles '**/' patterns and delegates to
// fnmatch_helper for the main work.
boolean period    flags   fnm_dotmatch     0
boolean pathname    flags   fnm_pathname     0
int pat_pos   pstart
int str_pos   sstart
int ptmp    1
int stmp    1
if  pathname
while  true
if  isdoublestarandslash bytes  pat_pos
do   pat_pos    3    while  isdoublestarandslash bytes  pat_pos
ptmp   pat_pos
stmp   str_pos
int patslashidx   nextslashindex bytes  pat_pos  pend
int strslashidx   nextslashindex string  str_pos  send
if  fnmatch_helper bytes  pat_pos  patslashidx
string  str_pos  strslashidx  flags     0
if  patslashidx < pend    strslashidx < send
pat_pos     patslashidx
str_pos     strslashidx
continue
if  patslashidx    pend    strslashidx    send
return 0
/* failed : try next recursion */
if  ptmp     1    stmp     1      period    string
stmp   nextslashindex string  stmp  send
if  stmp < send
pat_pos   ptmp
stmp
str_pos   stmp
continue
return fnm_nomatch
else
return fnmatch_helper bytes  pstart  pend  string  sstart  send  flags
// are we at '**/'
private static boolean isdoublestarandslash byte bytes  int pos
if   bytes length   pos  <  2
return false     not enough bytes
return bytes
bytes
bytes
// look for slash, starting from 'start' position, until 'end'.
private static int nextslashindex byte bytes  int start  int end
int idx   start
while  idx < end    idx < bytes length    bytes
idx
return idx
public static int range byte _pat  int pat  int pend  char test  int flags
boolean not
boolean ok   false
boolean nocase    flags   fnm_casefold     0
boolean escape    flags   fnm_noescape     0
not   _pat         _pat
if not
pat
if  nocase
test   character tolowercase test
while _pat
char cstart  cend
if escape    _pat
pat
if pat >  pend
return  1
cstart   cend    char  _pat 0xff
if _pat         _pat
pat
if escape    _pat
pat
if pat >  pend
return  1
cend    char  _pat   0xff
if  nocase
if  character tolowercase cstart  <  test
test <  character tolowercase cend
ok   true
else
if  cstart <  test    test <  cend
ok   true
return ok    not ?  1   pat   1
public static list<bytelist> push_glob string cwd  bytelist globbytelist  int flags
list<bytelist> result   new arraylist<bytelist>
if  globbytelist length   > 0
push_braces cwd  result  new globpattern globbytelist  flags
return result
private static class globpattern
final byte bytes
final int begin
final int end
int flags
int index
public globpattern bytelist bytelist  int flags
this bytelist bytes  bytelist begin   bytelist begin   bytelist realsize  flags
public globpattern byte bytes  int index  int end  int flags
this bytes   bytes
this index   index
this begin   index
this end   end
this flags   flags
public int findclosingindexof int lefttokenindex
if  lefttokenindex     1    lefttokenindex > end  return  1
byte lefttoken   bytes
byte righttoken
switch  lefttoken
case    righttoken      break
case    righttoken      break
default  return  1
int nest   1     lefttoken made us start as nest 1
index   lefttokenindex   1
while  hasnext
byte c   next
if  c    lefttoken
nest
else if  c    righttoken      nest    0
return index
return  1
public boolean hasnext
return index < end
public void reset
index   begin
public void setindex int value
index   value
// get index of last read byte
public int index
return index   1
public int indexof byte c
while  hasnext    if  next      c  return index
return  1
public byte next
return bytes
private static interface globfunc
int call byte ptr  int p  int len  object ary
private static class globargs
globfunc func
int c    1
list<bytelist> v
public globargs globfunc func  list<bytelist> arg
this func   func
this v   arg
public final static globfunc push_pattern   new globfunc
@suppresswarnings
public int call byte ptr  int p  int len  object ary
list  ary  add new bytelist ptr  p  len
return 0
public final static globfunc glob_caller   new globfunc
public int call byte ptr  int p  int len  object ary
globargs args    globargs ary
args c   p
return args func call ptr  args c  len  args v
/*
* process {}'s (example: dir.glob("{jruby,jython}/readme*")
*/
private static int push_braces string cwd  list<bytelist> result  globpattern pattern
pattern reset
int lbrace   pattern indexof  byte         index of left most brace
int rbrace   pattern findclosingindexof lbrace     index of right most brace
// no or mismatched braces..move along..nothing to see here
if  lbrace     1    rbrace     1  return push_globs cwd  result  pattern
// peel onion...make subpatterns out of outer layer of glob and recall with each subpattern
// example: foo{a{c},b}bar -> fooa{c}bar, foobbar
bytelist buf   new bytelist 20
int middleregionindex
int i   lbrace
while  pattern bytes
middleregionindex   i   1
for i   middleregionindex  i < pattern end    pattern bytes         pattern bytes       i
if  pattern bytes       i   pattern findclosingindexof i      skip inner braces
buf length 0
buf append pattern bytes  pattern begin  lbrace   pattern begin
buf append pattern bytes  middleregionindex  i   middleregionindex
buf append pattern bytes  rbrace   1  pattern end    rbrace   1
int status   push_braces cwd  result  new globpattern buf bytes  buf begin  buf realsize  pattern flags
if status    0  return status
return 0     all braces pushed
private static int push_globs string cwd  list<bytelist> ary  globpattern pattern
pattern flags    fnm_syscase
return glob_helper cwd  pattern bytes  pattern begin  pattern end   1  pattern flags  glob_caller  new globargs push_pattern  ary
private static boolean has_magic byte bytes  int begin  int end  int flags
boolean escape    flags   fnm_noescape     0
boolean nocase    flags   fnm_casefold     0
int open   0
for  int i   begin  i < end  i
switch bytes
case
case
return true
case   	   only accept an open brace if there is a close
open   	   brace to match it   bracket expressions must be
continue 	   complete  according to posix 2
case
if  open > 0  return true
continue
case
if  escape    i    end  return false
break
default
if  fnm_syscase    0    nocase    character isletter  char  bytes 0xff    return true
return false
private static int remove_backslashes byte bytes  int index  int len
int t   index
for    index < len  index    t
if  bytes           index    len  break
bytes   bytes
return t
private static int strchr byte bytes  int begin  int end  byte ch
for  int i   begin  i < end  i
if  bytes    ch  return i
return  1
private static byte extract_path byte bytes  int begin  int end
int len   end   begin
if  len > 1    bytes           dosish     len < 2    bytes         len
byte alloc   new byte
system arraycopy bytes begin alloc 0 len
return alloc
private static byte extract_elem byte bytes  int begin  int end
int elementend   strchr bytes  begin  end   byte
if  elementend     1  elementend   end
return extract_path bytes  begin  elementend
private static boolean base byte base
return dosish ?
base length > 0       isdirsep base     base length < 2      base length > 2    base         isdirsep base     base length < 4
base length > 0      isdirsep base     base length < 2
private static boolean isjarfilepath byte bytes  int begin  int end
return end > 6    bytes         bytes
bytes         bytes         bytes
private static string files file directory
string files   directory list
if  files    null
string filesplusdotfiles   new string
system arraycopy files  0  filesplusdotfiles  2  files length
filesplusdotfiles
filesplusdotfiles
return filesplusdotfiles
else
return new string
private static int glob_helper string cwd  byte bytes  int begin  int end  int sub  int flags  globfunc func  globargs arg
int p m
int status   0
byte newpath   null
file st
p   sub     1 ? sub   begin
if   has_magic bytes  p  end  flags
if  dosish     flags   fnm_noescape     0
newpath   new byte
system arraycopy bytes 0 newpath 0 end
if  sub     1
p    sub   begin
end   remove_backslashes newpath  p  end
sub   p
else
end   remove_backslashes newpath  0  end
bytes   newpath
if  bytes          dosish    begin 2<end    bytes         isdirsep bytes
if  new javasecuredfile newstringfromutf8 bytes  begin  end   begin   exists
status   func call bytes  begin  end  arg
else if  isjarfilepath bytes  begin  end
int ix   end
for int i   0 i<end i
if bytes
ix   i
break
st   new javasecuredfile newstringfromutf8 bytes  begin 5  ix 5
string jar   newstringfromutf8 bytes  begin ix 1  end  ix 1
try
jarfile jf   new jarfile st
if  jar startswith     jar   jar substring 1
if  jf getentry jar         null  jar   jar
if  jf getentry jar     null
status   func call bytes  begin  end  arg
catch exception e
else if   end   begin  > 0       length check is a hack   we should not be reeiving   as a filename ever
if  new javasecuredfile cwd  newstringfromutf8 bytes  begin  end   begin   exists
status   func call bytes  begin  end   begin  arg
return status
bytelist buf   new bytelist 20
list<bytelist> link   new arraylist<bytelist>
mainloop  while p     1    status    0
if  bytes       p
m   strchr bytes  p  end   byte
if has_magic bytes  p  m     1 ? end   m  flags
finalize  do
byte base   extract_path bytes  begin  p
byte dir   begin    p ? new byte      base
byte magic   extract_elem bytes p end
boolean recursive   false
string jar   null
jarfile jf   null
if dir           dosish    2<dir length    dir         isdirsep dir
st   new javasecuredfile newstringfromutf8 dir
else if isjarfilepath dir  0  dir length
int ix   dir length
for int i   0 i<dir length i
if dir
ix   i
break
st   new javasecuredfile newstringfromutf8 dir  5  ix 5
jar   newstringfromutf8 dir  ix 1  dir length  ix 1
try
jf   new jarfile st
if  jar startswith     jar   jar substring 1
if  jf getentry jar         null  jar   jar
catch exception e
jar   null
jf   null
else
st   new javasecuredfile cwd  newstringfromutf8 dir
if  jf    null       equals jar      jf getjarentry jar     null    jf getjarentry jar  isdirectory         st isdirectory
if m     1    arrays equals magic  double_star
int n   base length
recursive   true
buf length 0
buf append base
buf append bytes   base length > 0 ? m   m   1   end    base length > 0 ? m   m   1
status   glob_helper cwd  buf bytes  buf begin  buf realsize  n  flags  func  arg
if status    0
break finalize
else
break mainloop
if jar    null
string dirp   files st
for int i 0 i<dirp length i
if recursive
byte bs   getbytesinutf8 dirp
if  fnmatch star 0 1 bs 0 bs length flags     0
continue
buf length 0
buf append base
buf append  base base  ? slash   empty
buf append getbytesinutf8 dirp
if  buf bytes          dosish    2<buf realsize    buf bytes         isdirsep buf bytes
st   new javasecuredfile newstringfromutf8 buf bytes  buf begin  buf realsize
else
st   new javasecuredfile cwd  newstringfromutf8 buf bytes  buf begin  buf realsize
if st isdirectory         equals dirp        equals dirp
int t   buf realsize
buf append slash
buf append double_star
buf append bytes  m  end   m
status   glob_helper cwd  buf bytes  buf begin  buf realsize  t  flags  func  arg
if status    0
break
continue
byte bs   getbytesinutf8 dirp
if fnmatch magic 0 magic length bs 0  bs length flags     0
buf length 0
buf append base
buf append  base base  ? slash   empty
buf append getbytesinutf8 dirp
if m     1
status   func call buf bytes 0 buf realsize arg
if status    0
break
continue
link add buf
buf   new bytelist 20
else
try
list<jarentry> dirp   new arraylist<jarentry>
for enumeration<jarentry> eje   jf entries    eje hasmoreelements
jarentry je   eje nextelement
string name   je getname
int ix   name indexof    jar length
if  ix     1    ix    name length   1
if   equals jar      name startswith jar     name length  >jar length
dirp add je
for jarentry je   dirp
byte bs   getbytesinutf8 je getname
int len   bs length
if je isdirectory
len
if recursive
if fnmatch star 0 1 bs 0 len flags     0
continue
buf length 0
buf append base  0  base length   jar length
buf append  base base  ? slash   empty
buf append bs  0  len
if je isdirectory
int t   buf realsize
buf append slash
buf append double_star
buf append bytes  m  end   m
status   glob_helper cwd  buf bytes  buf begin  buf realsize  t  flags  func  arg
if status    0
break
continue
if fnmatch magic 0 magic length bs 0 len flags     0
buf length 0
buf append base  0  base length   jar length
buf append  base base  ? slash   empty
buf append bs  0  len
if m     1
status   func call buf bytes 0 buf realsize arg
if status    0
break
continue
link add buf
buf   new bytelist 20
catch exception e
while false
if  link size   > 0
for  bytelist b   link
if  status    0
if b bytes           dosish    2<b realsize    b bytes         isdirsep b bytes
st   new javasecuredfile newstringfromutf8 b bytes  0  b realsize
else
st   new javasecuredfile cwd  newstringfromutf8 b bytes  0  b realsize
if st isdirectory
int len   b realsize
buf length 0
buf append b
buf append bytes  m  end   m
status   glob_helper cwd buf bytes 0 buf realsize len flags func arg
break mainloop
p   m
return status
private static byte getbytesinutf8 string s
try
return s getbytes
catch  java io unsupportedencodingexception ex
return s getbytes       not reached here
private static string newstringfromutf8 byte buf  int offset  int len
try
return new string buf  offset  len
catch  java io unsupportedencodingexception ex
return new string buf  offset  len      not reached here
private static string newstringfromutf8 byte buf
try
return new string buf
catch  java io unsupportedencodingexception ex
return new string buf      not reached here