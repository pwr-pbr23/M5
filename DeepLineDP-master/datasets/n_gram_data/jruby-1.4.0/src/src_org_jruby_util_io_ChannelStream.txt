/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2004-2005 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2005 charles o nutter <headius@headius.com>
* copyright (c) 2007 damian steer <pldms@mac.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util io
import static java util logging logger getlogger
import java io eofexception
import java io filedescriptor
import java io filenotfoundexception
import java io ioexception
import java io inputstream
import java io outputstream
import java io randomaccessfile
import java nio bytebuffer
import java nio channels channel
import java nio channels channels
import java nio channels filechannel
import java nio channels illegalblockingmodeexception
import java nio channels readablebytechannel
import java nio channels selectablechannel
import java nio channels writablebytechannel
import org jruby finalizable
import org jruby ruby
import org jruby util bytelist
import org jruby util jrubyfile
/**
* <p>this file implements a seekable io file.</p>
*/
public class channelstream implements stream  finalizable
private final static boolean debug   false
/**
* the size of the read/write buffer allocated for this stream.
*
* this size has been scaled back from its original 16k because although
* the larger buffer size results in raw file.open times being rather slow
* (due to the cost of instantiating a relatively large buffer). we should
* try to find a happy medium, or potentially pool buffers, or perhaps even
* choose a value based on platform(??), but for now i am reducing it along
* with changes for the "large read" patch from jruby-2657.
*/
private final static int bufsize   4   1024
/**
* the size at which a single read should turn into a chunkier bulk read.
* currently, this size is about 4x a normal buffer size.
*
* this size was not really arrived at experimentally, and could potentially
* be increased. however, it seems like a "good size" and we should
* probably only adjust it if it turns out we would perform better with a
* larger buffer for large bulk reads.
*/
private final static int bulk_read_size   16   1024
private final static bytebuffer empty_buffer   bytebuffer allocate 0
private ruby runtime
protected modeflags modes
protected boolean sync   false
protected volatile bytebuffer buffer     r w buffer
protected boolean reading     are we reading or writing?
private channeldescriptor descriptor
private boolean blocking   true
protected int ungotc    1
private volatile boolean closedexplicitly   false
private volatile boolean eof   false
public channelstream ruby runtime  channeldescriptor descriptor  modeflags modes  filedescriptor filedescriptor  throws invalidvalueexception
descriptor checknewmodes modes
this runtime   runtime
this descriptor   descriptor
this modes   modes
this buffer   bytebuffer allocate bufsize
buffer flip
this reading   true
// this constructor is used by fdopen, so we don't increment descriptor ref count
public channelstream ruby runtime  channeldescriptor descriptor
this runtime  descriptor  descriptor getfiledescriptor
public channelstream ruby runtime  channeldescriptor descriptor  filedescriptor filedescriptor
this runtime   runtime
this descriptor   descriptor
this modes   descriptor getoriginalmodes
buffer   bytebuffer allocate bufsize
buffer flip
this reading   true
public channelstream ruby runtime  channeldescriptor descriptor  modeflags modes  throws invalidvalueexception
descriptor checknewmodes modes
this runtime   runtime
this descriptor   descriptor
this modes   modes
buffer   bytebuffer allocate bufsize
buffer flip
this reading   true
public ruby getruntime
return runtime
public void checkreadable   throws ioexception
if   modes isreadable    throw new ioexception
public void checkwritable   throws ioexception
if   modes iswritable    throw new ioexception
public void checkpermissionssubsetof modeflags subsetmodes
subsetmodes issubsetof modes
public modeflags getmodes
return modes
public boolean issync
return sync
public void setsync boolean sync
this sync   sync
/**
* implement io#wait as per io/wait in mri.
* waits until input available or timed out and returns self, or nil when eof reached.
*
* the default implementation loops while ready returns 0.
*/
public void waituntilready   throws ioexception  interruptedexception
while  ready      0
thread sleep 10
public boolean readdatabuffered
return reading    buffer hasremaining
public boolean writedatabuffered
return  reading    buffer position   > 0
private final int refillbuffer   throws ioexception
buffer clear
int n     readablebytechannel  descriptor getchannel    read buffer
buffer flip
return n
public synchronized bytelist fgets bytelist separatorstring  throws ioexception  baddescriptorexception
checkreadable
ensureread
if  separatorstring    null
return readall
final bytelist separator    separatorstring    paragraph_delimeter  ?
paragraph_separator   separatorstring
descriptor checkopen
if  feof
return null
int c   read
if  c     1
return null
// unread back
buffer position buffer position     1
bytelist buf   new bytelist 40
byte first   separator bytes
lineloop   while  true
readloop  while  true
byte bytes   buffer array
int offset   buffer position
int max   buffer limit
// iterate over remainder of buffer until we find a match
for  int i   offset  i < max  i
c   bytes
if  c    first
// terminate and advance buffer when we find our char
buf append bytes  offset  i   offset
if  i >  max
buffer clear
else
buffer position i   1
break readloop
// no match, append remainder of buffer and continue with next block
buf append bytes  offset  buffer remaining
int read   refillbuffer
if  read     1  break lineloop
// found a match above, check if remaining separator characters match, appending as we go
for  int i   0  i < separator realsize  i
if  c     1
break lineloop
else if  c    separator bytes
buf append c
continue lineloop
buf append c
if  i < separator realsize   1
c   read
break
if  separatorstring    paragraph_delimeter
while  c    separator bytes
c   read
ungetc c
return buf
public synchronized int getline bytelist dst  byte terminator  throws ioexception  baddescriptorexception
checkreadable
ensureread
descriptor checkopen
int totalread   0
boolean found   false
if  ungotc     1
dst append  byte  ungotc
found   ungotc    terminator
ungotc    1
totalread
while   found
final byte bytes   buffer array
final int begin   buffer arrayoffset     buffer position
final int end   begin   buffer remaining
int len   0
for  int i   begin  i < end     found    i
found   bytes    terminator
len
if  len > 0
dst append buffer  len
totalread    len
if   found
int n   refillbuffer
if  n <  0
if  n < 0    totalread < 1
return  1
break
return totalread
public synchronized int getline bytelist dst  byte terminator  long limit  throws ioexception  baddescriptorexception
checkreadable
ensureread
descriptor checkopen
int totalread   0
boolean found   false
if  ungotc     1
dst append  byte  ungotc
found   ungotc    terminator
ungotc    1
limit
totalread
while   found
final byte bytes   buffer array
final int begin   buffer arrayoffset     buffer position
final int end   begin   buffer remaining
int len   0
for  int i   begin  i < end    limit   > 0     found    i
found   bytes    terminator
len
if  limit < 1  found   true
if  len > 0
dst append buffer  len
totalread    len
if   found
int n   refillbuffer
if  n <  0
if  n < 0    totalread < 1
return  1
break
return totalread
public synchronized bytelist readall   throws ioexception  baddescriptorexception
final long filesize   descriptor isseekable      descriptor getchannel   instanceof filechannel
?   filechannel  descriptor getchannel    size     0
//
// check file size - special files in /proc have zero size and need to be
// handled by the generic read path.
//
if  filesize > 0
ensureread
filechannel channel    filechannel descriptor getchannel
final long left   filesize   channel position     bufferedbytesavailable
if  left <  0
eof   true
return null
if  left > integer max_value
if  getruntime      null
throw getruntime   newioerror
else
throw new ioexception
bytelist result   new bytelist  int  left
bytebuffer buf   bytebuffer wrap result unsafebytes
result begin     int  left
//
// copy any buffered data (including ungetc byte)
//
copybufferedbytes buf
//
// now read unbuffered directly from the file
//
while  buf hasremaining
final int max_read_chunk   1   1024   1024
//
// when reading into a heap buffer, the jvm allocates a temporary
// direct bytebuffer of the requested size.  to avoid allocating
// a huge direct buffer when doing ludicrous reads (e.g. 1g or more)
// we split the read up into chunks of no more than 1m
//
bytebuffer tmp   buf duplicate
if  tmp remaining   > max_read_chunk
tmp limit tmp position     max_read_chunk
int n   channel read tmp
if  n <  0
break
buf position tmp position
eof   true
result length buf position
return result
else if  descriptor isnull
return new bytelist 0
else
checkreadable
bytelist bytelist   new bytelist
bytelist read   fread bufsize
if  read    null
eof   true
return bytelist
while  read    null
bytelist append read
read   fread bufsize
return bytelist
/**
* copies bytes from the channel buffer into a destination <tt>bytebuffer</tt>
*
* @param dst a <tt>bytebuffer</tt> to place the data in.
* @return the number of bytes copied.
*/
private final int copybufferedbytes bytebuffer dst
final int bytestocopy   dst remaining
if  ungotc     1    dst hasremaining
dst put  byte  ungotc
ungotc    1
if  buffer hasremaining      dst hasremaining
if  dst remaining   >  buffer remaining
//
// copy out any buffered bytes
//
dst put buffer
else
//
// need to clamp source (buffer) size to avoid overrun
//
bytebuffer tmp   buffer duplicate
tmp limit dst remaining
dst put tmp
return bytestocopy   dst remaining
/**
* copies bytes from the channel buffer into a destination <tt>bytebuffer</tt>
*
* @param dst a <tt>bytelist</tt> to place the data in.
* @param len the maximum number of bytes to copy.
* @return the number of bytes copied.
*/
private final int copybufferedbytes bytelist dst  int len
int bytescopied   0
dst ensure math min len  bufferedbytesavailable
if  bytescopied < len    ungotc     1
bytescopied
dst append  byte  ungotc
ungotc    1
//
// copy out any buffered bytes
//
if  bytescopied < len    buffer hasremaining
int n   math min buffer remaining    len   bytescopied
dst append buffer  n
bytescopied    n
return bytescopied
/**
* returns a count of how many bytes are available in the read buffer
*
* @return the number of bytes that can be read without reading the underlying stream.
*/
private final int bufferedbytesavailable
return buffer remaining      reading    ungotc     1 ? 1   0
/**
* <p>close io handler resources.</p>
* @throws ioexception
* @throws baddescriptorexception
*
* @see org.jruby.util.iohandler#close()
*/
public synchronized void fclose   throws ioexception  baddescriptorexception
closedexplicitly   true
close false      not closing from finalize
/**
* internal close, to safely work for finalizing.
* @param finalizing true if this is in a finalizing context
* @throws ioexception
* @throws baddescriptorexception
*/
private void close boolean finalizing  throws ioexception  baddescriptorexception
try
flushwrite
descriptor close
buffer   empty_buffer
if  debug  getlogger    info
descriptor getfileno
finally
ruby localruntime   getruntime
if   finalizing    localruntime    null  localruntime removeinternalfinalizer this
// clear runtime so it doesn't get stuck in memory (jruby-2933)
runtime   null
/**
* internal close, to safely work for finalizing.
* @param finalizing true if this is in a finalizing context
* @throws ioexception
* @throws baddescriptorexception
*/
private void closeforfinalize
try
close true
catch  baddescriptorexception ex
// silence
catch  ioexception ex
// silence
/**
* @throws ioexception
* @throws baddescriptorexception
* @see org.jruby.util.iohandler#flush()
*/
public synchronized int fflush   throws ioexception  baddescriptorexception
checkwritable
try
flushwrite
catch  eofexception eof
return  1
return 0
/**
* flush the write buffer to the channel (if needed)
* @throws ioexception
*/
private void flushwrite   throws ioexception  baddescriptorexception
if  reading     modes iswritable      buffer position      0  return     don't bother
int len   buffer position
buffer flip
int n   descriptor write buffer
if n    len
// todo: check the return value here
buffer clear
/**
* flush the write buffer to the channel (if needed)
* @throws ioexception
*/
private boolean flushwrite final boolean block  throws ioexception  baddescriptorexception
if  reading     modes iswritable      buffer position      0  return false     don't bother
int len   buffer position
int nwritten   0
buffer flip
// for sockets, only write as much as will fit.
if  descriptor getchannel   instanceof selectablechannel
selectablechannel selectablechannel    selectablechannel descriptor getchannel
synchronized  selectablechannel blockinglock
boolean oldblocking   selectablechannel isblocking
try
if  oldblocking    block
selectablechannel configureblocking block
nwritten   descriptor write buffer
finally
if  oldblocking    block
selectablechannel configureblocking oldblocking
else
nwritten   descriptor write buffer
if  nwritten    len
buffer compact
return false
buffer clear
return true
/**
* @see org.jruby.util.iohandler#getinputstream()
*/
public inputstream newinputstream
inputstream in   descriptor getbaseinputstream
if  in    null
return channels newinputstream  readablebytechannel descriptor getchannel
else
return in
/**
* @see org.jruby.util.iohandler#getoutputstream()
*/
public outputstream newoutputstream
return channels newoutputstream  writablebytechannel descriptor getchannel
public void clearerr
eof   false
/**
* @throws ioexception
* @throws baddescriptorexception
* @see org.jruby.util.iohandler#iseof()
*/
public boolean feof   throws ioexception  baddescriptorexception
checkreadable
if  eof
return true
else
return false
/**
* @throws ioexception
* @see org.jruby.util.iohandler#pos()
*/
public synchronized long fgetpos   throws ioexception  pipeexception  invalidvalueexception  baddescriptorexception
// correct position for read / write buffering (we could invalidate, but expensive)
if  descriptor isseekable
filechannel filechannel    filechannel descriptor getchannel
long pos   filechannel position
// adjust for buffered data
if  reading
pos    buffer remaining
return pos    pos > 0    ungotc     1 ? 1   0
else
return pos   buffer position
else if  descriptor isnull
return 0
else
throw new pipeexception
/**
* implementation of libc "lseek", which seeks on seekable streams, raises
* epipe if the fd is assocated with a pipe, socket, or fifo, and doesn't
* do anything for other cases (like stdio).
*
* @throws ioexception
* @throws invalidvalueexception
* @see org.jruby.util.iohandler#seek(long, int)
*/
public synchronized void lseek long offset  int type  throws ioexception  invalidvalueexception  pipeexception  baddescriptorexception
if  descriptor isseekable
filechannel filechannel    filechannel descriptor getchannel
ungotc    1
int adj   0
if  reading
// for seek_cur, need to adjust for buffered data
adj   buffer remaining
buffer clear
buffer flip
else
flushwrite
try
switch  type
case seek_set
filechannel position offset
break
case seek_cur
filechannel position filechannel position     adj   offset
break
case seek_end
filechannel position filechannel size     offset
break
catch  illegalargumentexception e
throw new invalidvalueexception
catch  ioexception ioe
ioe printstacktrace
throw ioe
else if  descriptor getchannel   instanceof selectablechannel
// todo: it's perhaps just a coincidence that all the channels for
// which we should raise are instanceof selectablechannel, since
// stdio is not...so this bothers me slightly. -con
throw new pipeexception
else
/**
* @see org.jruby.util.iohandler#sync()
*/
public synchronized void sync   throws ioexception  baddescriptorexception
flushwrite
/**
* ensure buffer is ready for reading, flushing remaining writes if required
* @throws ioexception
*/
private void ensureread   throws ioexception  baddescriptorexception
if  reading  return
flushwrite
buffer clear
buffer flip
reading   true
/**
* ensure buffer is ready for reading, flushing remaining writes if required
* @throws ioexception
*/
private void ensurereadnonbuffered   throws ioexception  baddescriptorexception
if  reading
if  buffer hasremaining
ruby localruntime   getruntime
if  localruntime    null
throw localruntime newioerror
else
throw new ioexception
else
// libc flushes writes on any read from the actual file, so we flush here
flushwrite
buffer clear
buffer flip
reading   true
private void resetforwrite   throws ioexception
if  descriptor isseekable
filechannel filechannel    filechannel descriptor getchannel
if  buffer hasremaining         we have read ahead  and need to back up
filechannel position filechannel position     buffer remaining
// fixme: clearing read buffer here...is this appropriate?
buffer clear
reading   false
/**
* ensure buffer is ready for writing.
* @throws ioexception
*/
private void ensurewrite   throws ioexception
if   reading  return
resetforwrite
public synchronized bytelist read int number  throws ioexception  baddescriptorexception
checkreadable
ensurereadnonbuffered
bytelist bytelist   new bytelist number
// todo this should entry into error handling somewhere
int bytesread   descriptor read number  bytelist
if  bytesread     1
eof   true
return bytelist
private bytelist bufferedread int number  throws ioexception  baddescriptorexception
checkreadable
ensureread
int resultsize   0
// 128k seems to be the minimum at which the stat+seek is faster than reallocation
final int bulk_threshold   128   1024
if  number >  bulk_threshold    descriptor isseekable      descriptor getchannel   instanceof filechannel
//
// if it is a file channel, then we can pre-allocate the output buffer
// to the total size of buffered + remaining bytes in file
//
filechannel filechannel    filechannel  descriptor getchannel
resultsize    int  math min filechannel size     filechannel position     bufferedbytesavailable    number
else
//
// cannot discern the total read length - allocate at least enough for the buffered data
//
resultsize   math min bufferedbytesavailable    number
bytelist result   new bytelist resultsize
bufferedread result  number
return result
private int bufferedread bytelist dst  int number  throws ioexception  baddescriptorexception
int bytesread   0
//
// copy what is in the buffer, if there is some buffered data
//
bytesread    copybufferedbytes dst  number
boolean done   false
//
// avoid double-copying for reads that are larger than the buffer size
//
while   number   bytesread  >  bufsize
//
// limit each iteration to a max of bulk_read_size to avoid over-size allocations
//
final int bytestoread   math min bulk_read_size  number   bytesread
final int n   descriptor read bytestoread  dst
if  n     1
eof   true
done   true
break
else if  n    0
done   true
break
bytesread    n
//
// complete the request by filling the read buffer first
//
while   done    bytesread < number
int read   refillbuffer
if  read     1
eof   true
break
else if  read    0
break
// append what we read into our buffer and allow the loop to continue
final int len   math min buffer remaining    number   bytesread
dst append buffer  len
bytesread    len
if  bytesread    0    number    0
if  eof
throw new eofexception
return bytesread
private int bufferedread bytebuffer dst  boolean partial  throws ioexception  baddescriptorexception
checkreadable
ensureread
boolean done   false
int bytesread   0
//
// copy what is in the buffer, if there is some buffered data
//
bytesread    copybufferedbytes dst
//
// avoid double-copying for reads that are larger than the buffer size, or
// the destination is a direct buffer.
//
while   bytesread < 1     partial      dst remaining   >  bufsize    dst isdirect
bytebuffer tmpdst   dst
if   dst isdirect
//
// we limit reads to bulk_read_sized chunks to avoid nio allocating
// a huge temporary native buffer, when doing reads into a heap buffer
// if the dst buffer is direct, then no need to limit.
//
int bytestoread   math min bulk_read_size  dst remaining
if  bytestoread < dst remaining
tmpdst   dst duplicate
tmpdst limit bytestoread
int n   descriptor read tmpdst
if  n     1
eof   true
done   true
break
else if  n    0
done   true
break
else
bytesread    n
//
// complete the request by filling the read buffer first
//
while   done    dst hasremaining       bytesread < 1     partial
int read   refillbuffer
if  read     1
eof   true
done   true
break
else if  read    0
done   true
break
else
// append what we read into our buffer and allow the loop to continue
bytesread    copybufferedbytes dst
if  eof    bytesread    0    dst remaining      0
throw new eofexception
return bytesread
private int bufferedread   throws ioexception  baddescriptorexception
ensureread
if   buffer hasremaining
int len   refillbuffer
if  len     1
eof   true
return  1
else if  len    0
return  1
return buffer get     0xff
/**
* @throws ioexception
* @throws baddescriptorexception
* @see org.jruby.util.iohandler#syswrite(string buf)
*/
private int bufferedwrite bytelist buf  throws ioexception  baddescriptorexception
checkwritable
ensurewrite
// ruby ignores empty syswrites
if  buf    null    buf length      0  return 0
if  buf length   > buffer capacity         doesn't fit in buffer  write immediately
flushwrite       ensure nothing left to write
int n   descriptor write bytebuffer wrap buf unsafebytes    buf begin    buf length
if n    buf length
// todo: check the return value here
else
if  buf length   > buffer remaining    flushwrite
buffer put buf unsafebytes    buf begin    buf length
if  issync    flushwrite
return buf realsize
/**
* @throws ioexception
* @throws baddescriptorexception
* @see org.jruby.util.iohandler#syswrite(string buf)
*/
private int bufferedwrite int c  throws ioexception  baddescriptorexception
checkwritable
ensurewrite
if   buffer hasremaining    flushwrite
buffer put  byte  c
if  issync    flushwrite
return 1
public synchronized void ftruncate long newlength  throws ioexception
baddescriptorexception  invalidvalueexception
channel ch   descriptor getchannel
if    ch instanceof filechannel
throw new invalidvalueexception
invalidatebuffer
filechannel filechannel    filechannel ch
if  newlength > filechannel size
// truncate can't lengthen files, so we save position, seek/write, and go back
long position   filechannel position
int difference    int  newlength   filechannel size
filechannel position filechannel size
// fixme: this worries me a bit, since it could allocate a lot with a large newlength
filechannel write bytebuffer allocate difference
filechannel position position
else
filechannel truncate newlength
/**
* invalidate buffer before a position change has occurred (e.g. seek),
* flushing writes if required, and correcting file position if reading
* @throws ioexception
*/
private void invalidatebuffer   throws ioexception  baddescriptorexception
if   reading  flushwrite
int posoverrun   buffer remaining       how far ahead we are when reading
buffer clear
if  reading
buffer flip
// if the read buffer is ahead, back up
filechannel filechannel    filechannel descriptor getchannel
if  posoverrun    0  filechannel position filechannel position     posoverrun
/**
* ensure close (especially flush) when we're finished with
*/
@override
public synchronized void finalize
if  closedexplicitly  return
// fixme: i got a bunch of npes when i didn't check for nulls here...how?!
if  descriptor    null    descriptor isseekable      descriptor isopen
closeforfinalize       close without removing from finalizers
public int ready   throws ioexception
if  descriptor getchannel   instanceof selectablechannel
int ready_stat   0
java nio channels selector sel   java nio channels selector open
selectablechannel selchan    selectablechannel descriptor getchannel
synchronized  selchan blockinglock
boolean is_block   selchan isblocking
try
selchan configureblocking false
selchan register sel  java nio channels selectionkey op_read
ready_stat   sel selectnow
sel close
catch  throwable ex
ex printstacktrace
finally
if  sel    null
try
sel close
catch  exception e
selchan configureblocking is_block
return ready_stat
else
return newinputstream   available
public synchronized void fputc int c  throws ioexception  baddescriptorexception
bufferedwrite c
public int ungetc int c
if  c     1
return  1
// putting a bit back, so we're not at eof anymore
eof   false
// save the ungot
ungotc   c
return c
public synchronized int fgetc   throws ioexception  baddescriptorexception
if  eof
return  1
checkreadable
int c   read
if  c     1
eof   true
return c
return c   0xff
public synchronized int fwrite bytelist string  throws ioexception  baddescriptorexception
return bufferedwrite string
public synchronized int writenonblock bytelist buf  throws ioexception  baddescriptorexception
checkwritable
ensurewrite
// ruby ignores empty syswrites
if  buf    null    buf length      0  return 0
if  buffer position      0     flushwrite false   return 0
if  descriptor getchannel   instanceof selectablechannel
selectablechannel selectablechannel    selectablechannel descriptor getchannel
synchronized  selectablechannel blockinglock
boolean oldblocking   selectablechannel isblocking
try
if  oldblocking
selectablechannel configureblocking false
return descriptor write bytebuffer wrap buf unsafebytes    buf begin    buf length
finally
if  oldblocking
selectablechannel configureblocking oldblocking
else
return descriptor write bytebuffer wrap buf unsafebytes    buf begin    buf length
public synchronized bytelist fread int number  throws ioexception  baddescriptorexception
try
if  number    0
if  eof
return null
else
return new bytelist 0
return bufferedread number
catch  eofexception e
eof   true
return null
public synchronized bytelist readnonblock int number  throws ioexception  baddescriptorexception  eofexception
assert number >  0
if  number    0
return null
if  descriptor getchannel   instanceof selectablechannel
selectablechannel selectablechannel    selectablechannel descriptor getchannel
synchronized  selectablechannel blockinglock
boolean oldblocking   selectablechannel isblocking
try
selectablechannel configureblocking false
return readpartial number
finally
selectablechannel configureblocking oldblocking
else if  descriptor getchannel   instanceof filechannel
return fread number
else
return null
public synchronized bytelist readpartial int number  throws ioexception  baddescriptorexception  eofexception
assert number >  0
if  number    0
return null
if  descriptor getchannel   instanceof filechannel
return fread number
if  bufferedbytesavailable   > 0
// already have some bytes buffered, just return those
return bufferedread math min bufferedbytesavailable    number
else
// otherwise, we try an unbuffered read to get whatever's available
return read number
public synchronized int read bytebuffer dst  throws ioexception  baddescriptorexception  eofexception
return read dst    descriptor getchannel   instanceof filechannel
public synchronized int read bytebuffer dst  boolean partial  throws ioexception  baddescriptorexception  eofexception
assert dst hasremaining
return bufferedread dst  partial
public synchronized int read   throws ioexception  baddescriptorexception
try
descriptor checkopen
if  ungotc >  0
int c   ungotc
ungotc    1
return c
return bufferedread
catch  eofexception e
eof   true
return  1
public channeldescriptor getdescriptor
return descriptor
public void setblocking boolean block  throws ioexception
if    descriptor getchannel   instanceof selectablechannel
return
synchronized    selectablechannel  descriptor getchannel    blockinglock
blocking   block
try
selectablechannel  descriptor getchannel    configureblocking block
catch  illegalblockingmodeexception e
// ignore this; select() will set the correct mode when it is finished
public boolean isblocking
return blocking
public synchronized void freopen ruby runtime  string path  modeflags modes  throws directoryasfileexception  ioexception  invalidvalueexception  pipeexception  baddescriptorexception
// flush first
flushwrite
// reset buffer
buffer clear
if  reading
buffer flip
this modes   modes
if  descriptor isopen
descriptor close
if  path equals       path equalsignorecase       path equalsignorecase
descriptor   new channeldescriptor new nullchannel    descriptor getfileno    modes  new filedescriptor
else
string cwd   runtime getcurrentdirectory
jrubyfile thefile   jrubyfile create cwd path
if  thefile isdirectory      modes iswritable    throw new directoryasfileexception
if  modes iscreate
if  thefile exists      modes isexclusive
throw runtime newerrnoeexisterror     path
thefile createnewfile
else
if   thefile exists
throw runtime newerrnoenoenterror     path
// we always open this rw since we can only open it r or rw.
randomaccessfile file   new randomaccessfile thefile  modes tojavamodestring
if  modes istruncate    file setlength 0l
descriptor   new channeldescriptor file getchannel    descriptor getfileno    modes  file getfd
if  modes isappendable    lseek 0  seek_end
public static stream fopen ruby runtime  string path  modeflags modes  throws filenotfoundexception  directoryasfileexception  fileexistsexception  ioexception  invalidvalueexception  pipeexception  baddescriptorexception
string cwd   runtime getcurrentdirectory
channeldescriptor descriptor   channeldescriptor open cwd  path  modes
stream stream   fdopen runtime  descriptor  modes
if  modes isappendable    stream lseek 0  stream seek_end
return stream
public static stream fdopen ruby runtime  channeldescriptor descriptor  modeflags modes  throws invalidvalueexception
stream handler   new channelstream runtime  descriptor  modes  descriptor getfiledescriptor
return handler