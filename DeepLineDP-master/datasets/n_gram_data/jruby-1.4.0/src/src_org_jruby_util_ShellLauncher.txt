/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007 nick sieger <nicksieger@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util
import java io file
import java io fileinputstream
import java io fileoutputstream
import java io filterinputstream
import java io filteroutputstream
import java io ioexception
import java io inputstream
import java io outputstream
import java io pipedinputstream
import java io pipedoutputstream
import java io printstream
import java lang reflect field
import static java lang system
import java nio bytebuffer
import java nio channels filechannel
import java util hashmap
import java util iterator
import java util map
import org jruby main
import org jruby ruby
import org jruby rubyarray
import org jruby rubyhash
import org jruby rubyinstanceconfig
import org jruby rubymodule
import org jruby ext posix util fieldaccess
import org jruby ext posix util platform
import org jruby javasupport util runtimehelpers
import org jruby runtime threadcontext
import org jruby runtime builtin irubyobject
import org jruby util io modeflags
/**
* this mess of a class is what happens when all java gives you is
* runtime.getruntime().exec(). thanks dude, that really helped.
* @author nicksieger
*/
public class shelllauncher
private static final boolean debug   false
private static class scriptthreadprocess extends process implements runnable
private final string argarray
private final string env
private final file pwd
private final boolean pipedstreams
private final pipedinputstream processoutput
private final pipedinputstream processerror
private final pipedoutputstream processinput
private rubyinstanceconfig config
private thread processthread
private int result
private ruby parentruntime
public scriptthreadprocess ruby parentruntime  final string argarray  final string env  final file dir
this parentruntime  argarray  env  dir  true
public scriptthreadprocess ruby parentruntime  final string argarray  final string env  final file dir  final boolean pipedstreams
this parentruntime   parentruntime
this argarray   argarray
this env   env
this pwd   dir
this pipedstreams   pipedstreams
if  pipedstreams
processoutput   new pipedinputstream
processerror   new pipedinputstream
processinput   new pipedoutputstream
else
processoutput   processerror   null
processinput   null
public void run
try
this result   new main config  run argarray
catch  throwable throwable
throwable printstacktrace this config geterror
this result    1
finally
this config getoutput   close
this config geterror   close
try  this config getinput   close     catch  ioexception ioe
private map<string  string> environmentmap string env
map<string  string> m   new hashmap<string  string>
for  int i   0  i < env length  i
string kv   env split    2
m put kv  kv
return m
public void start   throws ioexception
config   new rubyinstanceconfig parentruntime getinstanceconfig
setenvironment environmentmap env
setcurrentdirectory pwd tostring
if  pipedstreams
config setinput new pipedinputstream processinput
config setoutput new printstream new pipedoutputstream processoutput
config seterror new printstream new pipedoutputstream processerror
string procname
if  argarray length > 0
procname   argarray
processthread   new thread this      procname
processthread setdaemon true
processthread start
public outputstream getoutputstream
return processinput
public inputstream getinputstream
return processoutput
public inputstream geterrorstream
return processerror
public int waitfor   throws interruptedexception
processthread join
return result
public int exitvalue
return result
public void destroy
if  pipedstreams
closestreams
processthread interrupt
private void closestreams
try   processinput close      catch  ioexception io
try   processoutput close      catch  ioexception io
try   processerror close      catch  ioexception io
private static string getcurrentenv ruby runtime
rubyhash hash    rubyhash runtime getobject   fastgetconstant
string ret   new string
int i 0
for iterator iter   hash directentryset   iterator   iter hasnext   i
map entry e    map entry iter next
ret   e getkey   tostring         e getvalue   tostring
return ret
public static int runandwait ruby runtime  irubyobject rawargs
return runandwait runtime  rawargs  runtime getoutputstream
public static long runwithoutwait ruby runtime  irubyobject rawargs
return runwithoutwait runtime  rawargs  runtime getoutputstream
public static int execandwait ruby runtime  irubyobject rawargs
string args   parsecommandline runtime getcurrentcontext    runtime  rawargs
if  shouldruninprocess runtime  args
// exec needs to behave differently in-process, because it's technically
// supposed to replace the calling process. so if we're supposed to run
// in-process, we allow it to use the default streams and not use
// pumpers at all. see jruby-2156 and jruby-2154.
try
file pwd   new file runtime getcurrentdirectory
string command   args
// snip off ruby or jruby command from list of arguments
// leave alone if the command is the name of a script
int startindex   command endswith    ? 0   1
if  command trim   endswith
startindex   0
args   runtime getjrubyhome     file separator       file separator
string newargs   new string
system arraycopy args  startindex  newargs  0  newargs length
scriptthreadprocess ipscript   new scriptthreadprocess runtime  newargs  getcurrentenv runtime   pwd  false
ipscript start
return ipscript waitfor
catch  ioexception e
throw runtime newioerrorfromexception e
catch  interruptedexception e
throw runtime newthreaderror
else
return runandwait runtime  rawargs
public static int runandwait ruby runtime  irubyobject rawargs  outputstream output
outputstream error   runtime geterrorstream
inputstream input   runtime getinputstream
try
process aprocess   run runtime  rawargs
handlestreams aprocess input output error
return aprocess waitfor
catch  ioexception e
throw runtime newioerrorfromexception e
catch  interruptedexception e
throw runtime newthreaderror
public static long runwithoutwait ruby runtime  irubyobject rawargs  outputstream output
try
popenprocess aprocess   new popenprocess popenshared runtime  rawargs   runtime
return getpidfromprocess aprocess
catch  ioexception e
throw runtime newioerrorfromexception e
public static long getpidfromprocess process process
if  process instanceof scriptthreadprocess
return process hashcode
else if  process instanceof popenprocess
return reflectpidfromprocess   popenprocess process  getchild
else
return reflectpidfromprocess process
private static final class unixprocess
private static final field unixprocess_pid
private static final class processimpl
private static final field processimpl_handle
private interface pidgetter   public long getpid process process
private static final pidgetter pid_getter
static
// default pidgetter
pidgetter pg   new pidgetter
public long getpid process process
return process hashcode
class up   null
field pid   null
try
up   class forname
pid   up getdeclaredfield
pid setaccessible true
catch  exception e
// ignore and try windows version
unixprocess   up
unixprocess_pid   pid
class pi   null
field handle   null
try
pi   class forname
handle   pi getdeclaredfield
handle setaccessible true
catch  exception e
// ignore and use hashcode
processimpl   pi
processimpl_handle   handle
if  unixprocess_pid    null
if  processimpl_handle    null
// try both
pg   new pidgetter
public long getpid process process
try
if  unixprocess isinstance process
return  integer unixprocess_pid get process
else if  processimpl isinstance process
return  long processimpl_handle get process
catch  exception e
// ignore and use hashcode
return process hashcode
else
// just unix
pg   new pidgetter
public long getpid process process
try
if  unixprocess isinstance process
return  integer unixprocess_pid get process
catch  exception e
// ignore and use hashcode
return process hashcode
else if  processimpl_handle    null
// just windows
pg   new pidgetter
public long getpid process process
try
if  processimpl isinstance process
return  long processimpl_handle get process
catch  exception e
// ignore and use hashcode
return process hashcode
else
// neither
pg   new pidgetter
public long getpid process process
return process hashcode
pid_getter   pg
public static long reflectpidfromprocess process process
return pid_getter getpid process
public static process run ruby runtime  irubyobject string  throws ioexception
return run runtime  new irubyobject  string
public static popenprocess popen ruby runtime  irubyobject string  modeflags modes  throws ioexception
return new popenprocess popenshared runtime  new irubyobject  string    runtime  modes
public static popenprocess popen3 ruby runtime  irubyobject strings  throws ioexception
return new popenprocess popenshared runtime  strings   runtime
private static process popenshared ruby runtime  irubyobject strings  throws ioexception
string shell   getshell runtime
process childprocess   null
file pwd   new file runtime getcurrentdirectory
// con: popen is a case where i think we should just always shell out.
if  strings length    1
// single string command, pass to sh to expand wildcards
string argarray   new string
argarray   shell
argarray   shell endswith    ?
argarray   strings asjavastring
childprocess   runtime getruntime   exec argarray  getcurrentenv runtime   pwd
else
// direct invocation of the command
string args   parsecommandline runtime getcurrentcontext    runtime  strings
childprocess   runtime getruntime   exec args  getcurrentenv runtime   pwd
return childprocess
/**
* unwrap all filtering streams between the given stream and its actual
* unfiltered stream. this is primarily to unwrap streams that have
* buffers that would interfere with interactivity.
*
* @param filteredstream the stream to unwrap
* @return an unwrapped stream, presumably unbuffered
*/
public static outputstream unwrapbufferedstream outputstream filteredstream
while  filteredstream instanceof filteroutputstream
try
filteredstream    outputstream
fieldaccess getprotectedfieldvalue filteroutputstream class
filteredstream
catch  exception e
break     break out if we've dug as deep as we can
return filteredstream
/**
* unwrap all filtering streams between the given stream and its actual
* unfiltered stream. this is primarily to unwrap streams that have
* buffers that would interfere with interactivity.
*
* @param filteredstream the stream to unwrap
* @return an unwrapped stream, presumably unbuffered
*/
public static inputstream unwrapbufferedstream inputstream filteredstream
while  filteredstream instanceof filterinputstream
try
filteredstream    inputstream
fieldaccess getprotectedfieldvalue filterinputstream class
filteredstream
catch  exception e
break     break out if we've dug as deep as we can
return filteredstream
public static class popenprocess extends process
private final process child
private final ruby runtime
private final modeflags modes
private inputstream input
private outputstream output
private inputstream inerr
private filechannel inputchannel
private filechannel outputchannel
private filechannel inerrchannel
private pumper inputpumper
private pumper inerrpumper
private pumper outputpumper
public popenprocess process child  ruby runtime  modeflags modes
this child   child
this runtime   runtime
this modes   modes
if  modes iswritable
prepareoutput child
else
// close process output
// see jruby-3405; hooking up to parent process stdin caused
// problems for irb etc using stdin.
try  child getoutputstream   close     catch  ioexception ioe
if  modes isreadable
prepareinput child
else
pumpinput child  runtime
pumpinerr child  runtime
public popenprocess process child  ruby runtime
this child   child
this runtime   runtime
this modes   null
prepareoutput child
prepareinput child
prepareinerr child
@override
public outputstream getoutputstream
return output
@override
public inputstream getinputstream
return input
@override
public inputstream geterrorstream
return inerr
public filechannel getinput
return inputchannel
public filechannel getoutput
return outputchannel
public filechannel geterror
return inerrchannel
public boolean hasoutput
return output    null    outputchannel    null
public process getchild
return child
@override
public int waitfor   throws interruptedexception
if  outputpumper    null
try
if  output    null  output close
catch  ioexception ioe
// ignore, we're on the way out
else
outputpumper quit
int result   child waitfor
return result
@override
public int exitvalue
return child exitvalue
@override
public void destroy
try
if  input    null  input close
if  inerr    null  inerr close
if  output    null  output close
if  inputchannel    null  inputchannel close
if  inerrchannel    null  inerrchannel close
if  outputchannel    null  outputchannel close
// processes seem to have some peculiar locking sequences, so we
// need to ensure nobody is trying to close/destroy while we are
synchronized  this
if  inputpumper    null  synchronized inputpumper   inputpumper quit
if  inerrpumper    null  synchronized inerrpumper   inerrpumper quit
if  outputpumper    null  synchronized outputpumper   outputpumper quit
child destroy
catch  ioexception ioe
throw new runtimeexception ioe
private void prepareinput process child
// popen callers wants to be able to read, provide subprocess in directly
input   unwrapbufferedstream child getinputstream
if  input instanceof fileinputstream
inputchannel     fileinputstream  input  getchannel
else
inputchannel   null
inputpumper   null
private void prepareinerr process child
// popen callers wants to be able to read, provide subprocess in directly
inerr   unwrapbufferedstream child geterrorstream
if  inerr instanceof fileinputstream
inerrchannel     fileinputstream  inerr  getchannel
else
inerrchannel   null
inerrpumper   null
private void prepareoutput process child
// popen caller wants to be able to write, provide subprocess out directly
output   unwrapbufferedstream child getoutputstream
if  output instanceof fileoutputstream
outputchannel     fileoutputstream  output  getchannel
else
outputchannel   null
outputpumper   null
private void pumpinput process child  ruby runtime
// no read requested, hook up read to parents output
inputstream childin   unwrapbufferedstream child getinputstream
filechannel childinchannel   null
if  childin instanceof fileinputstream
childinchannel     fileinputstream  childin  getchannel
outputstream parentout   unwrapbufferedstream runtime getout
filechannel parentoutchannel   null
if  parentout instanceof fileoutputstream
parentoutchannel     fileoutputstream  parentout  getchannel
if  childinchannel    null    parentoutchannel    null
inputpumper   new channelpumper childinchannel  parentoutchannel  pumper slave in  this
else
inputpumper   new streampumper childin  parentout  false  pumper slave in  this
inputpumper start
input   null
inputchannel   null
private void pumpinerr process child  ruby runtime
// no read requested, hook up read to parents output
inputstream childin   unwrapbufferedstream child geterrorstream
filechannel childinchannel   null
if  childin instanceof fileinputstream
childinchannel     fileinputstream  childin  getchannel
outputstream parentout   unwrapbufferedstream runtime getout
filechannel parentoutchannel   null
if  parentout instanceof fileoutputstream
parentoutchannel     fileoutputstream  parentout  getchannel
if  childinchannel    null    parentoutchannel    null
inerrpumper   new channelpumper childinchannel  parentoutchannel  pumper slave in  this
else
inerrpumper   new streampumper childin  parentout  false  pumper slave in  this
inerrpumper start
inerr   null
inerrchannel   null
public static process run ruby runtime  irubyobject rawargs  throws ioexception
string shell   getshell runtime
process aprocess   null
file pwd   new file runtime getcurrentdirectory
string args   parsecommandline runtime getcurrentcontext    runtime  rawargs
if  shouldruninprocess runtime  args
string command   args
// snip off ruby or jruby command from list of arguments
// leave alone if the command is the name of a script
int startindex   command endswith    ? 0   1
if  command trim   endswith
startindex   0
args   runtime getjrubyhome     file separator       file separator
string newargs   new string
system arraycopy args  startindex  newargs  0  newargs length
scriptthreadprocess ipscript   new scriptthreadprocess runtime  newargs  getcurrentenv runtime   pwd
ipscript start
aprocess   ipscript
else if  rawargs length    1    shouldruninshell shell  args
// execute command with sh -c
// this does shell expansion of wildcards
string argarray   new string
string cmdline   rawargs tostring
argarray   shell
argarray   shell endswith    ?
argarray   cmdline
aprocess   runtime getruntime   exec argarray  getcurrentenv runtime   pwd
else
aprocess   runtime getruntime   exec args  getcurrentenv runtime   pwd
return aprocess
private interface pumper extends runnable
public enum slave   in  out
public void start
public void quit
private static class streampumper extends thread implements pumper
private final inputstream in
private final outputstream out
private final boolean onlyifavailable
private final object waitlock   new object
private final object sync
private final slave slave
private volatile boolean quit
streampumper inputstream in  outputstream out  boolean avail  slave slave  object sync
this in   in
this out   out
this onlyifavailable   avail
this slave   slave
this sync   sync
setdaemon true
@override
public void run
byte buf   new byte
int numread
boolean hasreadsomething   false
try
while   quit
// the problem we trying to solve below: stdin in java
// is blocked and non-interruptible, so if we invoke read
// on it, we might never be able to interrupt such thread.
// so, we use in.available() to see if there is any input
// ready, and only then read it. but this approach can't
// tell whether the end of stream reached or not, so we
// might end up looping right at the end of the stream.
// well, at least, we can improve the situation by checking
// if some input was ever available, and if so, not
// checking for available anymore, and just go to read.
if  onlyifavailable     hasreadsomething
if  in available      0
synchronized  waitlock
waitlock wait 10
continue
else
hasreadsomething   true
if   numread   in read buf       1
break
out write buf  0  numread
catch  exception e
finally
if  onlyifavailable
synchronized  sync
// we need to close the out, since some
// processes would just wait for the stream
// to be closed before they process its content,
// and produce the output. e.g.: "cat".
if  slave    slave out
// we only close out if it's the slave stream, to avoid
// closing a directly-mapped stream from parent process
try   out close      catch  ioexception ioe
public void quit
this quit   true
synchronized  waitlock
waitlock notify
private static class channelpumper extends thread implements pumper
private final filechannel inchannel
private final filechannel outchannel
private final slave slave
private final object sync
private volatile boolean quit
channelpumper filechannel inchannel  filechannel outchannel  slave slave  object sync
if  debug  out println
this inchannel   inchannel
this outchannel   outchannel
this slave   slave
this sync   sync
setdaemon true
@override
public void run
bytebuffer buf   bytebuffer allocatedirect 1024
buf clear
try
while   quit    inchannel isopen      outchannel isopen
int read   inchannel read buf
if  read     1  break
buf flip
outchannel write buf
buf clear
catch  exception e
finally
// processes seem to have some peculiar locking sequences, so we
// need to ensure nobody is trying to close/destroy while we are
synchronized  sync
switch  slave
case out
try   outchannel close      catch  ioexception ioe
break
case in
try   inchannel close      catch  ioexception ioe
public void quit
interrupt
this quit   true
private static void handlestreams process p  inputstream in  outputstream out  outputstream err  throws ioexception
inputstream pout   p getinputstream
inputstream perr   p geterrorstream
outputstream pin   p getoutputstream
streampumper t1   new streampumper pout  out  false  pumper slave in  p
streampumper t2   new streampumper perr  err  false  pumper slave in  p
// the assumption here is that the 'in' stream provides
// proper available() support. if available() always
// returns 0, we'll hang!
streampumper t3   new streampumper in  pin  true  pumper slave out  p
t1 start
t2 start
t3 start
try   t1 join      catch  interruptedexception ie
try   t2 join      catch  interruptedexception ie
t3 quit
try   err flush      catch  ioexception io
try   out flush      catch  ioexception io
try   pin close      catch  ioexception io
try   pout close      catch  ioexception io
try   perr close      catch  ioexception io
// force t3 to quit, just in case if it's stuck.
// note: on some platforms, even interrupt might not
// have an effect if the thread is io blocked.
try   t3 interrupt      catch  securityexception se
private static string parsecommandline threadcontext context  ruby runtime  irubyobject rawargs
string args
if  rawargs length    1
synchronized  runtime getloadservice
runtime getloadservice   require
rubymodule pathhelper   runtime getclassfrompath
rubyarray parts    rubyarray  runtimehelpers invoke context  pathhelper     rawargs
args   new string
for  int i   0  i < parts getlength    i
args   parts entry i  tostring
else
args   new string
for  int i   0  i < rawargs length  i
args   rawargs tostring
return args
/**
* only run an in-process script if the script name has "ruby", ".rb", or "irb" in the name
*/
private static boolean shouldruninprocess ruby runtime  string commands
if   runtime getinstanceconfig   isrunrubyinprocess
return false
// check for special shell characters [<>|] at the beginning
// and end of each command word and don't run in process if we find them.
for  int i   0  i < commands length  i
string c   commands
if  c trim   length      0
continue
char firstlast   new char  c charat 0   c charat c length   1
for  int j   0  j < firstlast length  j
switch  firstlast
case    case    case    case
case    case    case    case
case    case    case    case
case    case    case    case
case    case    case    case
return false
case
if c length   > 1    c charat 1
return false
string command   commands
string slashdelimitedtokens   command split
string finaltoken   slashdelimitedtokens
int indexofruby   finaltoken indexof
return   indexofruby     1    indexofruby     finaltoken length     4
finaltoken endswith
finaltoken endswith
/**
* this hack is to work around a problem with cmd.exe on windows where it can't
* interpret a filename with spaces in the first argument position as a command.
* in that case it's better to try passing the bare arguments to runtime.exec.
* on all other platforms we'll always run the command in the shell.
*/
private static boolean shouldruninshell string shell  string args
return  platform is_windows
shell    null    args length > 1     new file args  exists
private static string getshell ruby runtime
return runtime evalscriptlet    tostring