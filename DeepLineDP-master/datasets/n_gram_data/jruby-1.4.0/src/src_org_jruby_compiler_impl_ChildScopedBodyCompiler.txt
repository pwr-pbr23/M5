package org jruby compiler impl
import org jruby ruby
import org jruby compiler astinspector
import org jruby compiler compilercallback
import org jruby compiler notcompilableexception
import org jruby exceptions jumpexception
import org jruby parser staticscope
import org jruby runtime block
import org jruby runtime threadcontext
import org jruby runtime builtin irubyobject
import org objectweb asm label
import static org jruby util codegenutils
public class childscopedbodycompiler extends basebodycompiler
public childscopedbodycompiler standardasmcompiler scriptcompiler  string closuremethodname  astinspector inspector  staticscope scope
super scriptcompiler  closuremethodname  inspector  scope
protected string getsignature
return standardasmcompiler getstaticclosuresignature script getclassname
protected void createvariablecompiler
if  inspector    null
variablecompiler   new heapbasedvariablecompiler this  method  scope  false  standardasmcompiler args_index  getfirsttempindex
else if  inspector hasclosure      inspector hasscopeawaremethods
variablecompiler   new heapbasedvariablecompiler this  method  scope  false  standardasmcompiler args_index  getfirsttempindex
else
variablecompiler   new stackbasedvariablecompiler this  method  scope  false  standardasmcompiler args_index  getfirsttempindex
public void beginmethod compilercallback args  staticscope scope
method start
// set up a local iruby variable
method aload standardasmcompiler threadcontext_index
invokethreadcontext    sig ruby class
method astore getruntimeindex
// grab nil for local variables
method aload getruntimeindex
invokeruby    sig irubyobject class
method astore getnilindex
if  scope    null
// not using a new scope, use saved one for a flat closure
variablecompiler beginflatclosure args  this scope
else
// normal closure
variablecompiler beginclosure args  scope
redojump   new label
method label scopestart
public void beginclass compilercallback bodyprep  staticscope scope
throw new notcompilableexception
public chainedchildbodycompiler outline string methodname
// chain to the next segment of this giant method
method aload standardasmcompiler this
// load all arguments straight through
for  int i   1  i <  3  i
method aload i
// we append an index to ensure two identical method names will not conflict
methodname   methodname       script getandincrementmethodindex
method invokestatic script getclassname    methodname  getsignature
chainedchildbodycompiler methodcompiler   new chainedchildbodycompiler script  methodname  inspector  scope  this
methodcompiler beginchainedmethod
return methodcompiler
public void endbody
// end of scoping for closure's vars
method areturn
method label scopeend
// we only need full-on redo exception handling if there's logic that might produce it
if  inspector    null    inspector hasscopeawaremethods
// handle redos by restarting the block
method pop
method go_to scopestart
method trycatch scopestart  scopeend  scopeend  p jumpexception redojump class
// method is done, declare all variables
variablecompiler declarelocals scope  scopestart  scopeend
method end
@override
public void loadblock
loadthreadcontext
invokethreadcontext    sig block class
public void performreturn
loadthreadcontext
invokeutilitymethod    sig jumpexception returnjump class  irubyobject class  threadcontext class
method athrow
public void issuebreakevent compilercallback value
if  currentlooplabels    null
value call this
issueloopbreak
else
loadthreadcontext
value call this
invokeutilitymethod    sig irubyobject class  threadcontext class  irubyobject class
public void issuenextevent compilercallback value
if  currentlooplabels    null
value call this
issueloopnext
else
value call this
invokeutilitymethod    sig irubyobject class  irubyobject class
public void issueredoevent
// fixme: this isn't right for within ensured/rescued code
if  currentlooplabels    null
issueloopredo
else if  innestedmethod
invokeutilitymethod    sig irubyobject class
else
// jump back to the top of the main body of this closure
method go_to scopestart