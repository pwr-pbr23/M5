/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 charles o nutter <headius@headius.com>
* copyright (c) 2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006-2007 mirko stocker <me@misto.ch>
* copyright (c) 2006 thomas corbat <tcorbat@hsr.ch>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby parser
import org jruby compatversion
import org jruby ast andnode
import org jruby ast argspreoneargnode
import org jruby ast argspretwoargnode
import org jruby ast argscatnode
import org jruby ast argsnoargnode
import org jruby ast argsnode
import org jruby ast argspushnode
import org jruby ast argumentnode
import org jruby ast arraynode
import org jruby ast assignablenode
import org jruby ast attrassignnode
import org jruby ast attrassignoneargnode
import org jruby ast attrassignthreeargnode
import org jruby ast attrassigntwoargnode
import org jruby ast backrefnode
import org jruby ast beginnode
import org jruby ast bignumnode
import org jruby ast blockargnode
import org jruby ast blocknode
import org jruby ast blockpassnode
import org jruby ast breaknode
import org jruby ast callmanyargsblocknode
import org jruby ast callmanyargsblockpassnode
import org jruby ast callmanyargsnode
import org jruby ast callnoargblocknode
import org jruby ast callnoargblockpassnode
import org jruby ast callnoargnode
import org jruby ast callnode
import org jruby ast calloneargnode
import org jruby ast calloneargblocknode
import org jruby ast calloneargblockpassnode
import org jruby ast calloneargfixnumnode
import org jruby ast callspecialargnode
import org jruby ast callspecialargblocknode
import org jruby ast callspecialargblockpassnode
import org jruby ast callthreeargblocknode
import org jruby ast callthreeargblockpassnode
import org jruby ast callthreeargnode
import org jruby ast calltwoargblocknode
import org jruby ast calltwoargblockpassnode
import org jruby ast calltwoargnode
import org jruby ast casenode
import org jruby ast classvarasgnnode
import org jruby ast classvardeclnode
import org jruby ast classvarnode
import org jruby ast colon2constnode
import org jruby ast colon2implicitnode
import org jruby ast colon2methodnode
import org jruby ast colon2node
import org jruby ast colon3node
import org jruby ast constdeclnode
import org jruby ast constnode
import org jruby ast dasgnnode
import org jruby ast dregexpnode
import org jruby ast dstrnode
import org jruby ast dotnode
import org jruby ast encodingnode
import org jruby ast evstrnode
import org jruby ast fcallmanyargsblocknode
import org jruby ast fcallmanyargsblockpassnode
import org jruby ast fcallmanyargsnode
import org jruby ast fcallnoargblocknode
import org jruby ast fcallnoargblockpassnode
import org jruby ast fcallnoargnode
import org jruby ast fcalloneargblocknode
import org jruby ast fcalloneargblockpassnode
import org jruby ast fcalloneargnode
import org jruby ast fcallspecialargblocknode
import org jruby ast fcallspecialargblockpassnode
import org jruby ast fcallspecialargnode
import org jruby ast fcallthreeargblocknode
import org jruby ast fcallthreeargblockpassnode
import org jruby ast fcallthreeargnode
import org jruby ast fcalltwoargblocknode
import org jruby ast fcalltwoargblockpassnode
import org jruby ast fcalltwoargnode
import org jruby ast falsenode
import org jruby ast filenode
import org jruby ast fixnumnode
import org jruby ast flipnode
import org jruby ast floatnode
import org jruby ast globalasgnnode
import org jruby ast globalvarnode
import org jruby ast iargumentnode
import org jruby ast ifnode
import org jruby ast instasgnnode
import org jruby ast instvarnode
import org jruby ast iternode
import org jruby ast listnode
import org jruby ast localasgnnode
import org jruby ast match2node
import org jruby ast match3node
import org jruby ast matchnode
import org jruby ast multipleasgnnode
import org jruby ast newlinenode
import org jruby ast nilimplicitnode
import org jruby ast nilnode
import org jruby ast node
import org jruby ast nthrefnode
import org jruby ast opelementasgnnode
import org jruby ast opelementoneargandasgnnode
import org jruby ast opelementoneargasgnnode
import org jruby ast opelementoneargorasgnnode
import org jruby ast ornode
import org jruby ast regexpnode
import org jruby ast restargnode
import org jruby ast rootnode
import org jruby ast svaluenode
import org jruby ast selfnode
import org jruby ast splatnode
import org jruby ast strnode
import org jruby ast supernode
import org jruby ast symbolnode
import org jruby ast truenode
import org jruby ast whennode
import org jruby ast whenoneargnode
import org jruby ast yieldnode
import org jruby ast yieldonenode
import org jruby ast yieldthreenode
import org jruby ast yieldtwonode
import org jruby ast zyieldnode
import org jruby ast types iliteralnode
import org jruby ast types inamenode
import org jruby common irubywarnings
import org jruby common irubywarnings id
import org jruby lexer yacc isourceposition
import org jruby lexer yacc isourcepositionholder
import org jruby lexer yacc rubyyacclexer
import org jruby lexer yacc syntaxexception
import org jruby lexer yacc token
import org jruby lexer yacc syntaxexception pid
import org jruby runtime dynamicscope
import org jruby util bytelist
import org jruby util idutil
/**
*
*/
public class parsersupport
// parser states:
protected staticscope currentscope
protected rubyyacclexer lexer
// is the parser current within a singleton (value is number of nested singletons)
private int insingleton
// is the parser currently within a method definition
private boolean indefinition
protected irubywarnings warnings
private parserconfiguration configuration
private rubyparserresult result
public void reset
insingleton   0
indefinition   false
public void allowdubyextension isourceposition position
if   configuration isdubyextensionsenabled
throw new syntaxexception pid duby_extensions_off  position
lexer getcurrentline
public staticscope getcurrentscope
return currentscope
public parserconfiguration getconfiguration
return configuration
public void popcurrentscope
currentscope   currentscope getenclosingscope
public void pushblockscope
currentscope   new blockstaticscope currentscope
public void pushlocalscope
currentscope   new localstaticscope currentscope
public node arg_concat isourceposition position  node node1  node node2
return node2    null ? node1   new argscatnode position  node1  node2
public node arg_blk_pass node firstnode  blockpassnode secondnode
if  secondnode    null
secondnode setargsnode firstnode
return secondnode
return firstnode
/**
* we know for callers of this that it cannot be any of the specials checked in gettable.
*
* @param node to check its variable type
* @return an ast node representing this new variable
*/
public node gettable2 node node
switch  node getnodetype
case dasgnnode     localvar
case localasgnnode
return currentscope declare node getposition      inamenode  node  getname
case constdeclnode     constant
return currentscope declare node getposition      inamenode  node  getname
case instasgnnode     instance variable
return new instvarnode node getposition      inamenode  node  getname
case classvardeclnode
case classvarasgnnode
return new classvarnode node getposition      inamenode  node  getname
case globalasgnnode
return new globalvarnode node getposition      inamenode  node  getname
getteridentifiererror node getposition      inamenode  node  getname
return null
/**
* create ast node representing variable type it represents.
*
* @param token to check its variable type
* @return an ast node representing this new variable
*/
public node gettable token token
switch  token gettype
case tokens kself
return new selfnode token getposition
case tokens knil
return new nilnode token getposition
case tokens ktrue
return new truenode token getposition
case tokens kfalse
return new falsenode token getposition
case tokens k__file__
return new filenode token getposition    bytelist create token getposition   getfile
case tokens k__line__
return new fixnumnode token getposition    token getposition   getstartline   1
case tokens k__encoding__
return new encodingnode token getposition
case tokens tidentifier
return currentscope declare token getposition     string  token getvalue
case tokens tconstant
return new constnode token getposition     string  token getvalue
case tokens tivar
return new instvarnode token getposition     string  token getvalue
case tokens tcvar
return new classvarnode token getposition     string  token getvalue
case tokens tgvar
return new globalvarnode token getposition     string  token getvalue
getteridentifiererror token getposition     string  token getvalue
return null
protected void getteridentifiererror isourceposition position  string identifier
throw new syntaxexception pid bad_identifier  position  lexer getcurrentline
identifier      identifier
public assignablenode assignable token lhs  node value
checkexpression value
switch  lhs gettype
case tokens kself
throw new syntaxexception pid cannot_change_self  lhs getposition
lexer getcurrentline
case tokens knil
throw new syntaxexception pid invalid_assignment  lhs getposition
lexer getcurrentline
case tokens ktrue
throw new syntaxexception pid invalid_assignment  lhs getposition
lexer getcurrentline
case tokens kfalse
throw new syntaxexception pid invalid_assignment  lhs getposition
lexer getcurrentline
case tokens k__file__
throw new syntaxexception pid invalid_assignment  lhs getposition
lexer getcurrentline
case tokens k__line__
throw new syntaxexception pid invalid_assignment  lhs getposition
lexer getcurrentline
case tokens tidentifier
return currentscope assign lhs getposition     string  lhs getvalue    makenullnil value
case tokens tconstant
if  isindef      isinsingle
throw new syntaxexception pid dynamic_constant_assignment  lhs getposition
lexer getcurrentline
return new constdeclnode lhs getposition     string  lhs getvalue    null  value
case tokens tivar
return new instasgnnode lhs getposition     string  lhs getvalue    value
case tokens tcvar
if  isindef      isinsingle
return new classvarasgnnode lhs getposition     string  lhs getvalue    value
return new classvardeclnode lhs getposition     string  lhs getvalue    value
case tokens tgvar
return new globalasgnnode lhs getposition     string  lhs getvalue    value
throw new syntaxexception pid bad_identifier  lhs getposition    lexer getcurrentline
string  lhs getvalue        lhs getvalue
/**
*  wraps node with newline node.
*
*@param node
*@return a newlinenode or null if node is null.
*/
public node newline_node node node  isourceposition position
if  node    null  return null
return node instanceof newlinenode ? node   new newlinenode position  node
public node addrootnode node topofast  isourceposition position
position   topofast    null ? topofast getposition     position
if  result getbeginnodes   size      0
if  topofast    null  topofast   nilimplicitnode nil
return new rootnode position  result getscope    topofast
blocknode newtopofast   new blocknode position
for  node beginnode  result getbeginnodes
appendtoblock newtopofast  beginnode
// add real top to new top (unless this top is empty [only begin/end nodes or truly empty])
if  topofast    null  newtopofast add topofast
return new rootnode position  result getscope    newtopofast
/* mri: block_append */
public node appendtoblock node head  node tail
if  tail    null  return head
if  head    null  return tail
// reduces overhead in interp by not set position every single line we encounter.
if   configuration hasextrapositioninformation
head   compactnewlines head
if    head instanceof blocknode
head   new blocknode head getposition    add head
if  warnings isverbose      isbreakstatement   listnode  head  getlast
warnings warning id statement_not_reached  tail getposition
// assumption: tail is never a list node
listnode  head  addall tail
return head
public node getoperatorcallnode node firstnode  string operator
checkexpression firstnode
return new callnoargnode firstnode getposition    firstnode  operator
public node getoperatorcallnode node firstnode  string operator  node secondnode
return getoperatorcallnode firstnode  operator  secondnode  null
public node getoperatorcallnode node firstnode  string operator  node secondnode  isourceposition defaultposition
if  defaultposition    null
firstnode   checkfornilnode firstnode  defaultposition
secondnode   checkfornilnode secondnode  defaultposition
checkexpression firstnode
checkexpression secondnode
return new_call_one_arg firstnode getposition    firstnode  operator  secondnode
//        return new calloneargnode(firstnode.getposition(), firstnode, operator, new arraynode(secondnode.getposition(), secondnode));
public node getmatchnode node firstnode  node secondnode
if  firstnode instanceof dregexpnode    firstnode instanceof regexpnode
return new match2node firstnode getposition    firstnode  secondnode
else if  secondnode instanceof dregexpnode    secondnode instanceof regexpnode
return new match3node firstnode getposition    secondnode  firstnode
return getoperatorcallnode firstnode     secondnode
/**
* define an array set condition so we can return lhs
*
* @param receiver array being set
* @param index node which should evalute to index of array set
* @return an attrassignnode
*/
public node aryset node receiver  node index
checkexpression receiver
return new_attrassign receiver getposition    receiver     index
/**
* define an attribute set condition so we can return lhs
*
* @param receiver object which contains attribute
* @param name of the attribute being set
* @return an attrassignnode
*/
public node attrset node receiver  string name
checkexpression receiver
return new_attrassign receiver getposition    receiver  name      null
public void backrefassignerror node node
if  node instanceof nthrefnode
string varname         nthrefnode  node  getmatchnumber
throw new syntaxexception pid invalid_assignment  node getposition
varname      varname
else if  node instanceof backrefnode
string varname         backrefnode  node  gettype
throw new syntaxexception pid invalid_assignment  node getposition        varname      varname
public node arg_add isourceposition position  node node1  node node2
if  node1    null
if  node2    null
return new arraynode position  nilimplicitnode nil
else
return new arraynode node2 getposition    node2
if  node1 instanceof arraynode  return   arraynode  node1  add node2
return new argspushnode position  node1  node2
/**
* @fixme position
**/
public node node_assign node lhs  node rhs
if  lhs    null  return null
node newnode   lhs
checkexpression rhs
if  lhs instanceof assignablenode
assignablenode  lhs  setvaluenode rhs
else if  lhs instanceof iargumentnode
iargumentnode invokablenode    iargumentnode  lhs
return invokablenode setargsnode arg_add lhs getposition    invokablenode getargsnode    rhs
return newnode
public node ret_args node node  isourceposition position
if  node    null
if  node instanceof blockpassnode
throw new syntaxexception pid dynamic_constant_assignment  position
lexer getcurrentline
else if  node instanceof arraynode      arraynode node  size      1
node     arraynode node  get 0
else if  node instanceof splatnode
node   new svaluenode position  node
return node
/**
* is the supplied node a break/control statement?
*
* @param node to be checked
* @return true if a control node, false otherwise
*/
public boolean isbreakstatement node node
breakloop  do
if  node    null  return false
switch  node getnodetype
case newlinenode
node     newlinenode  node  getnextnode
continue breakloop
case breaknode  case nextnode  case redonode
case retrynode  case returnnode
return true
default
return false
while  true
public void warnunlesseoption id id  node node  string message
if   configuration isinlinesource
warnings warn id  node getposition    message
public void warningunlesseoption id id  node node  string message
if  warnings isverbose       configuration isinlinesource
warnings warning id  node getposition    message
/**
* does this node represent an expression?
* @param node to be checked
* @return true if an expression, false otherwise
*/
public void checkexpression node node
if  warnings isverbose       isexpression node
warnings warning id void_value_expression  node getposition
private node compactnewlines node head
while  head instanceof newlinenode
node nextnode     newlinenode  head  getnextnode
if    nextnode instanceof newlinenode
break
head   nextnode
return head
private boolean isexpression node node
do
if  node    null  return true
switch  node getnodetype
case beginnode
node     beginnode  node  getbodynode
break
case blocknode
node     blocknode  node  getlast
break
case breaknode
node     breaknode  node  getvaluenode
break
case classnode  case defnnode  case defsnode  case modulenode  case nextnode
case redonode  case retrynode  case returnnode  case untilnode  case whilenode
return false
case ifnode
return isexpression   ifnode  node  getthenbody
isexpression   ifnode  node  getelsebody
case newlinenode
node     newlinenode  node  getnextnode
break
default     node
return true
while  true
/**
* is this a literal in the sense that mri has a node_lit for.  this is different than
* iliteralnode.  we should pick a different name since iliteralnode is something we created
* which is similiar but used for a slightly different condition (can i do singleton things).
*
* @param node to be tested
* @return true if it is a literal
*/
public boolean isliteral node node
return node    null     node instanceof fixnumnode    node instanceof bignumnode
node instanceof floatnode    node instanceof symbolnode
node instanceof regexpnode
regexpnode  node  getoptions     ~reoptions re_option_once     0
private void handleuselesswarn node node  string useless
warnings warn id useless_expression  node getposition        useless      useless
/**
* check to see if current node is an useless statement.  if useless a warning if printed.
*
* @param node to be checked.
*/
public void checkuselessstatement node node
if   warnings isverbose    return
uselessloop  do
if  node    null  return
switch  node getnodetype
case newlinenode
node     newlinenode  node  getnextnode
continue uselessloop
case callnode
string name     callnode  node  getname
if  name         name         name         name         name
name         name         name         name         name
name         name         name         name         name
name         name         name
handleuselesswarn node  name
return
case backrefnode  case dvarnode  case globalvarnode
case localvarnode  case nthrefnode  case classvarnode
case instvarnode
handleuselesswarn node      return
// fixme: temporarily disabling because this fires way too much running rails tests. jruby-518
/*case constnode:
handleuselesswarn(node, "a constant"); return;*/
case bignumnode  case dregexpnode  case dstrnode  case dsymbolnode
case fixnumnode  case floatnode  case regexpnode
case strnode  case symbolnode
handleuselesswarn node      return
// fixme: temporarily disabling because this fires way too much running rails tests. jruby-518
/*case classnode: case colon2node:
handleuselesswarn(node, "::"); return;*/
case dotnode
handleuselesswarn node    dotnode  node  isexclusive   ?         return
case definednode
handleuselesswarn node      return
case falsenode
handleuselesswarn node      return
case nilnode
handleuselesswarn node      return
// fixme: temporarily disabling because this fires way too much running rails tests. jruby-518
/*case selfnode:
handleuselesswarn(node, "self"); return;*/
case truenode
handleuselesswarn node      return
default  return
while  true
/**
* check all nodes but the last one in a blocknode for useless (void context) statements.
*
* @param blocknode to be checked.
*/
public void checkuselessstatements blocknode blocknode
if  warnings isverbose
node lastnode   blocknode getlast
for  int i   0  i < blocknode size    i
node currentnode   blocknode get i
if  lastnode    currentnode
checkuselessstatement currentnode
/**
* assign_in_cond
**/
private boolean checkassignmentincondition node node
if  node instanceof multipleasgnnode
throw new syntaxexception pid multiple_assignment_in_conditional  node getposition
lexer getcurrentline
else if  node instanceof localasgnnode    node instanceof dasgnnode    node instanceof globalasgnnode    node instanceof instasgnnode
node valuenode     assignablenode  node  getvaluenode
if  valuenode instanceof iliteralnode    valuenode instanceof nilnode    valuenode instanceof truenode    valuenode instanceof falsenode
warnings warn id assignment_in_conditional  node getposition
return true
return false
protected node makenullnil node node
return node    null ? nilimplicitnode nil   node
private node cond0 node node
checkassignmentincondition node
node leftnode   null
node rightnode   null
// fixme: dstr,evstr,str: warning "string literal in condition"
switch node getnodetype
case dregexpnode
isourceposition position   node getposition
return new match2node position  node  new globalvarnode position
case andnode
leftnode   cond0   andnode  node  getfirstnode
rightnode   cond0   andnode  node  getsecondnode
return new andnode node getposition    makenullnil leftnode   makenullnil rightnode
case ornode
leftnode   cond0   ornode  node  getfirstnode
rightnode   cond0   ornode  node  getsecondnode
return new ornode node getposition    makenullnil leftnode   makenullnil rightnode
case dotnode
dotnode dotnode    dotnode  node
if  dotnode isliteral    return node
string label   string valueof     node hashcode
currentscope getlocalscope   addvariable label
int slot   currentscope isdefined label
return new flipnode node getposition
getflipconditionnode   dotnode  node  getbeginnode
getflipconditionnode   dotnode  node  getendnode
dotnode isexclusive    slot
case regexpnode
warningunlesseoption id regexp_literal_in_condition  node
return new matchnode node getposition    node
return node
public node getconditionnode node node
if  node    null  return nilimplicitnode nil
if  node instanceof newlinenode
return new newlinenode node getposition    cond0   newlinenode  node  getnextnode
return cond0 node
/* mri: range_op */
private node getflipconditionnode node node
if   configuration isinlinesource    return node
node   getconditionnode node
if  node instanceof newlinenode  return   newlinenode  node  getnextnode
if  node instanceof fixnumnode
warnunlesseoption id literal_in_conditional_range  node
return getoperatorcallnode node     new globalvarnode node getposition
return node
public splatnode newsplatnode isourceposition position  node node
return new splatnode position  makenullnil node
public arraynode newarraynode isourceposition position  node firstnode
return new arraynode position  makenullnil firstnode
public isourceposition position isourcepositionholder one  isourcepositionholder two
return one    null ? two getposition     one getposition
public andnode newandnode isourceposition position  node left  node right
checkexpression left
if  left    null    right    null  return new andnode position  makenullnil left   makenullnil right
return new andnode position left  right   makenullnil left   makenullnil right
public ornode newornode isourceposition position  node left  node right
checkexpression left
if  left    null    right    null  return new ornode position  makenullnil left   makenullnil right
return new ornode position left  right   makenullnil left   makenullnil right
/**
* ok i admit that this is somewhat ugly.  we post-process a chain of when nodes and analyze
* them to re-insert them back into our new casenode the way we want.  the grammar is being
* difficult and until i go back into the depths of that this is where things are.
*
* @param expression of the case node (e.g. case foo)
* @param firstwhennode first when (which could also be the else)
* @return a new case node
*/
public casenode newcasenode isourceposition position  node expression  node firstwhennode
arraynode cases   new arraynode firstwhennode    null ? firstwhennode getposition     position
casenode casenode   new casenode position  expression  cases
for  node current   firstwhennode  current    null  current     whennode  current  getnextcase
if  current instanceof whenoneargnode
cases add current
else if  current instanceof whennode
simplifymultipleargumentwhennodes  whennode  current  cases
else
casenode setelsenode current
break
return casenode
/*
* this method exists for us to break up multiple expression when nodes (e.g. when 1,2,3:)
* into individual whennodes.  the primary reason for this is to ensure lazy evaluation of
* the arguments (when foo,bar,gar:) to prevent side-effects.  in the old code this was done
* using nested when statements, which was awful for interpreter and compilation.
*
* notes: this has semantic equivalence but will not be lexically equivalent.  compiler
* needs to detect same bodies to simplify bytecode generated.
*/
private void simplifymultipleargumentwhennodes whennode sourcewhen  arraynode cases
node expressionnodes   sourcewhen getexpressionnodes
if  expressionnodes instanceof splatnode    expressionnodes instanceof argscatnode
cases add sourcewhen
return
if  expressionnodes instanceof listnode
listnode list    listnode  expressionnodes
isourceposition position   sourcewhen getposition
node bodynode   sourcewhen getbodynode
for  int i   0  i < list size    i
node expression   list get i
if  expression instanceof splatnode    expression instanceof argscatnode
cases add new whennode position  expression  bodynode  null
else
cases add new whenoneargnode position  expression  bodynode  null
else
cases add sourcewhen
public whennode newwhennode isourceposition position  node expressionnodes  node bodynode  node nextcase
if  bodynode    null  bodynode   nilimplicitnode nil
if  expressionnodes instanceof splatnode    expressionnodes instanceof argscatnode
return new whennode position  expressionnodes  bodynode  nextcase
listnode list    listnode  expressionnodes
if  list size      1
node element   list get 0
if    element instanceof splatnode
return new whenoneargnode position  element  bodynode  nextcase
return new whennode position  expressionnodes  bodynode  nextcase
public node getreturnargsnode node node
if  node instanceof arraynode      arraynode  node  size      1
return   listnode  node  get 0
else if  node instanceof blockpassnode
throw new syntaxexception pid block_arg_unexpected  node getposition
lexer getcurrentline
return node
public node new_opelementasgnnode isourceposition position  node receivernode  string operatorname  node argsnode  node valuenode
if  argsnode instanceof arraynode
arraynode array    arraynode  argsnode
if  array size      1
if  operatorname equals
return new opelementoneargorasgnnode position  receivernode  operatorname  array  valuenode
else if  operatorname equals
return new opelementoneargandasgnnode position  receivernode  operatorname  array  valuenode
else
return new opelementoneargasgnnode position  receivernode  operatorname  array  valuenode
return new opelementasgnnode position  receivernode  operatorname  argsnode  valuenode
public node new_attrassign isourceposition position  node receiver  string name  node args
if    args instanceof arraynode   return new attrassignnode position  receiver  name  args
arraynode argsnode    arraynode  args
switch  argsnode size
case 1
return new attrassignoneargnode position  receiver  name  argsnode
case 2
return new attrassigntwoargnode position  receiver  name  argsnode
case 3
return new attrassignthreeargnode position  receiver  name  argsnode
default
return new attrassignnode position  receiver  name  argsnode
private node new_call_noargs node receiver  token name  iternode iter
isourceposition position   position receiver  name
if  receiver    null  receiver   nilimplicitnode nil
if  iter    null  return new callnoargblocknode position  receiver   string  name getvalue    iter
return new callnoargnode position  receiver   string  name getvalue
private node new_call_complexargs node receiver  token name  node args  node iter
if  args instanceof blockpassnode
// block and block pass passed in at same time....uh oh
if  iter    null
throw new syntaxexception pid block_arg_and_block_given  iter getposition
lexer getcurrentline
return new_call_blockpass receiver  name   blockpassnode  args
if  iter    null  return new callspecialargblocknode position receiver  args   receiver  string  name getvalue    args   iternode  iter
return new callspecialargnode position receiver  args   receiver   string  name getvalue    args
private node new_call_blockpass node receiver  token operation  blockpassnode blockpass
isourceposition position   position receiver  blockpass
string name    string  operation getvalue
node args   blockpass getargsnode
if  args    null  return new callnoargblockpassnode position  receiver  name  args  blockpass
if    args instanceof arraynode   return new callspecialargblockpassnode position  receiver  name  args  blockpass
switch    arraynode  args  size
case 0      foo
return new callnoargblockpassnode position  receiver  name  args  blockpass
case 1
return new calloneargblockpassnode position  receiver  name   arraynode  args  blockpass
case 2
return new calltwoargblockpassnode position  receiver  name   arraynode  args  blockpass
case 3
return new callthreeargblockpassnode position  receiver  name   arraynode  args  blockpass
default
return new callmanyargsblockpassnode position  receiver  name  args  blockpass
private boolean isnumericoperator string name
if  name length      1
switch  name charat 0
case    case    case    case    case    case
return true
else if  name length      2
switch  name charat 0
case    case    case
switch  name charat 1
case    case
return true
return false
private node new_call_one_arg isourceposition position  node receiver  string name  node first
if  first instanceof fixnumnode    isnumericoperator name
return new calloneargfixnumnode position  receiver  name  new arraynode position  first
return new calloneargnode position  receiver  name  new arraynode position  first
public node new_call node receiver  token name  node argsnode  node iter
if  argsnode    null  return new_call_noargs receiver  name   iternode  iter
if    argsnode instanceof arraynode   return new_call_complexargs receiver  name  argsnode  iter
arraynode args    arraynode  argsnode
switch  args size
case 0
if  iter    null  return new callnoargblocknode position receiver  args   receiver   string  name getvalue    args   iternode  iter
return new callnoargnode position receiver  args   receiver  args   string  name getvalue
case 1
if  iter    null  return new calloneargblocknode position receiver  args   receiver   string  name getvalue    args   iternode  iter
return new calloneargnode position receiver  args   receiver   string  name getvalue    args
case 2
if  iter    null  return new calltwoargblocknode position receiver  args   receiver   string  name getvalue    args   iternode  iter
return new calltwoargnode position receiver  args   receiver   string  name getvalue    args
case 3
if  iter    null  return new callthreeargblocknode position receiver  args   receiver   string  name getvalue    args   iternode  iter
return new callthreeargnode position receiver  args   receiver   string  name getvalue    args
default
if  iter    null  return new callmanyargsblocknode position receiver  args   receiver   string  name getvalue    args   iternode  iter
return new callmanyargsnode position receiver  args   receiver   string  name getvalue    args
public node new_aref node receiver  token name  node argsnode
if  argsnode instanceof arraynode
arraynode args    arraynode  argsnode
if  args size      1    args get 0  instanceof fixnumnode
return new calloneargfixnumnode position receiver  args   receiver     args
return new_call receiver  name  argsnode  null
public colon2node new_colon2 isourceposition position  node leftnode  string name
if  idutil isconstant name
if  leftnode    null  return new colon2implicitnode position  name
return new colon2constnode position  leftnode  name
return new colon2methodnode position  leftnode  name
public colon3node new_colon3 isourceposition position  string name
return new colon3node position  name
private node new_fcall_noargs token operation  iternode iter
if  iter    null  return new fcallnoargblocknode operation getposition     string  operation getvalue    iter
return new fcallnoargnode operation getposition     string  operation getvalue
private node new_fcall_simpleargs token operation  arraynode args  node iter
string name    string  operation getvalue
isourceposition position   position operation  args
switch  args size
case 0      foo
if  iter    null  return new fcallnoargblocknode position  name  args   iternode  iter
return new fcallnoargnode position  args  name
case 1
if  iter    null  return new fcalloneargblocknode position  name  args   iternode  iter
return new fcalloneargnode position  name  args
case 2
if  iter    null  return new fcalltwoargblocknode position  name  args   iternode  iter
return new fcalltwoargnode position  name  args
case 3
if  iter    null  return new fcallthreeargblocknode position  name  args   iternode  iter
return new fcallthreeargnode position  name  args
default
if  iter    null  return new fcallmanyargsblocknode position  name  args   iternode  iter
return new fcallmanyargsnode position  name  args
private node new_fcall_blockpass token operation  blockpassnode blockpass
isourceposition position   position operation  blockpass
string name    string  operation getvalue
node args   blockpass getargsnode
if  args    null  return new fcallnoargblockpassnode position  name  args  blockpass
if    args instanceof arraynode   return new fcallspecialargblockpassnode position  name  args  blockpass
switch    arraynode  args  size
case 0      foo
return new fcallnoargblockpassnode position  name  args  blockpass
case 1
return new fcalloneargblockpassnode position  name   arraynode  args  blockpass
case 2
return new fcalltwoargblockpassnode position  name   arraynode  args  blockpass
case 3
return new fcallthreeargblockpassnode position  name   arraynode  args  blockpass
default
return new fcallmanyargsblockpassnode position  name  args  blockpass
public node new_fcall token operation  node args  node iter
if  args    null  return new_fcall_noargs operation   iternode  iter
if  args instanceof arraynode  return new_fcall_simpleargs operation   arraynode  args  iter
if  args instanceof blockpassnode
if  iter    null  return new_fcall_blockpass operation   blockpassnode  args
throw new syntaxexception pid block_arg_and_block_given  iter getposition
lexer getcurrentline
if  iter    null  new fcallspecialargblocknode position operation  args    string  operation getvalue    args   iternode  iter
return new fcallspecialargnode position operation  args    string  operation getvalue    args
public node new_super node args  token operation
if  args    null    args instanceof blockpassnode
return new supernode position operation  args     blockpassnode  args  getargsnode    args
return new supernode operation getposition    args
/**
*  description of the rubymethod
*/
public void inittoplocalvariables
dynamicscope scope   configuration getscope
currentscope   scope getstaticscope
result setscope scope
/** getter for property insingle.
* @return value of property insingle.
*/
public boolean isinsingle
return insingleton    0
/** setter for property insingle.
* @param insingle new value of property insingle.
*/
public void setinsingle int insingle
this insingleton   insingle
public boolean isindef
return indefinition
public void setindef boolean indef
this indefinition   indef
/** getter for property insingle.
* @return value of property insingle.
*/
public int getinsingle
return insingleton
/**
* gets the result.
* @return returns a rubyparserresult
*/
public rubyparserresult getresult
return result
/**
* sets the result.
* @param result the result to set
*/
public void setresult rubyparserresult result
this result   result
/**
* sets the configuration.
* @param configuration the configuration to set
*/
public void setconfiguration parserconfiguration configuration
this configuration   configuration
public void setwarnings irubywarnings warnings
this warnings   warnings
public void setlexer rubyyacclexer lexer
this lexer   lexer
public node literal_concat isourceposition position  node head  node tail
if  head    null  return tail
if  tail    null  return head
if  head instanceof evstrnode
head   new dstrnode head getposition    add head
if  tail instanceof strnode
if  head instanceof strnode
return new strnode head getposition     strnode  head   strnode  tail
head setposition head getposition
return   listnode  head  add tail
else if  tail instanceof dstrnode
if  head instanceof strnode
dstrnode tail  prepend head
return tail
return   listnode  head  addall tail
// tail must be evstrnode at this point
if  head instanceof strnode
//do not add an empty string node
if   strnode  head  getvalue   length      0
head   new dstrnode head getposition
else
head   new dstrnode head getposition    add head
return   dstrnode  head  add tail
public node newevstrnode isourceposition position  node node
node head   node
while  true
if  node    null  break
if  node instanceof strnode    node instanceof dstrnode    node instanceof evstrnode
return node
if    node instanceof newlinenode   break
node     newlinenode  node  getnextnode
return new evstrnode position  head
public node new_yield isourceposition position  node node
boolean state   true
if  node    null
if  node instanceof blockpassnode
throw new syntaxexception pid block_arg_unexpected  node getposition
lexer getcurrentline
if  node instanceof arraynode    configuration getversion      compatversion ruby1_8
arraynode node  size      1
node     arraynode node  get 0
state   false
if  node    null    node instanceof splatnode
state   true
else
return new zyieldnode position
if  state    node instanceof arraynode
arraynode args    arraynode  node
switch  args size
case 0
return new zyieldnode position
case 1
return new yieldonenode position  args
case 2
return new yieldtwonode position  args
case 3
return new yieldthreenode position  args
if  node instanceof fixnumnode
return new yieldonenode position   fixnumnode  node
return new yieldnode position  node  state
public node negateinteger node integernode
if  integernode instanceof fixnumnode
fixnumnode fixnumnode    fixnumnode  integernode
fixnumnode setvalue  fixnumnode getvalue
return fixnumnode
else if  integernode instanceof bignumnode
bignumnode bignumnode    bignumnode  integernode
bignumnode setvalue bignumnode getvalue   negate
return integernode
public floatnode negatefloat floatnode floatnode
floatnode setvalue  floatnode getvalue
return floatnode
// fixme: remove this from grammars.
public isourceposition createemptyargsnodeposition isourceposition pos
return pos
public node unwrapnewlinenode node node
if node instanceof newlinenode
return   newlinenode  node  getnextnode
return node
private node checkfornilnode node node  isourceposition defaultposition
return  node    null  ? new nilnode defaultposition    node
public argumentnode getrestargnode token token
int index     integer  token getvalue    intvalue
if index < 0
return null
string name   getcurrentscope   getlocalscope   getvariables
return new argumentnode token getposition    name
public node new_args isourceposition position  listnode pre  listnode optional  restargnode rest
listnode post  blockargnode block
// zero-argument declaration
if  optional    null    rest    null    post    null    block    null
if  pre    null    pre size      0  return new argsnoargnode position
if  pre size      1  return new argspreoneargnode position  pre
if  pre size      2  return new argspretwoargnode position  pre
return new argsnode position  pre  optional  rest  post  block