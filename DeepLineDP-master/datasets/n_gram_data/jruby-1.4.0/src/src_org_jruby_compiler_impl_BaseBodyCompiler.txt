/*
* to change this template, choose tools | templates
* and open the template in the editor.
*/
package org jruby compiler impl
import java io printstream
import java lang reflect invocationtargetexception
import java math biginteger
import java util arrays
import java util hashmap
import java util hashset
import java util iterator
import java util list
import java util map
import java util set
import java util sortedmap
import java util treemap
import org jruby metaclass
import org jruby ruby
import org jruby rubyarray
import org jruby rubybignum
import org jruby rubyboolean
import org jruby rubyclass
import org jruby rubyexception
import org jruby rubyfixnum
import org jruby rubyfloat
import org jruby rubyhash
import org jruby rubyinstanceconfig
import org jruby rubymatchdata
import org jruby rubymodule
import org jruby rubyproc
import org jruby rubyrange
import org jruby rubyregexp
import org jruby rubystring
import org jruby rubysymbol
import org jruby ast nodetype
import org jruby ast util argsutil
import org jruby compiler astinspector
import org jruby compiler argumentscallback
import org jruby compiler arraycallback
import org jruby compiler branchcallback
import org jruby compiler compilercallback
import org jruby compiler invocationcompiler
import org jruby compiler bodycompiler
import org jruby compiler fastswitchtype
import org jruby compiler notcompilableexception
import org jruby compiler variablecompiler
import org jruby exceptions jumpexception
import org jruby exceptions raiseexception
import org jruby internal runtime globalvariables
import org jruby internal runtime methods callconfiguration
import org jruby internal runtime methods dynamicmethod
import org jruby javasupport javautil
import org jruby javasupport util runtimehelpers
import org jruby lexer yacc isourceposition
import org jruby parser reoptions
import org jruby parser staticscope
import org jruby runtime block
import org jruby runtime blockbody
import org jruby runtime calltype
import org jruby runtime compiledblockcallback
import org jruby runtime dynamicscope
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
import org jruby runtime builtin instancevariables
import org jruby util bytelist
import org jruby util javanamemangler
import org objectweb asm label
import static org objectweb asm opcodes
import static org jruby util codegenutils
/**
* basebodycompiler encapsulates all common behavior between bodycompiler
* implementations.
*/
public abstract class basebodycompiler implements bodycompiler
protected skinnymethodadapter method
protected variablecompiler variablecompiler
protected invocationcompiler invocationcompiler
protected int argparamcount
protected label currentlooplabels
protected label scopestart   new label
protected label scopeend   new label
protected label redojump
protected boolean innestedmethod   false
private int lastline    1
private int lastpositionline    1
protected staticscope scope
protected astinspector inspector
protected string methodname
protected standardasmcompiler script
public basebodycompiler standardasmcompiler scriptcompiler  string methodname  astinspector inspector  staticscope scope
this script   scriptcompiler
this scope   scope
this inspector   inspector
this methodname   methodname
if  shoulduseboxedargs scope
argparamcount   1     use irubyobject
else
argparamcount   scope getrequiredargs       specific arity
method   new skinnymethodadapter script getclassvisitor   visitmethod acc_public   acc_static  methodname  getsignature    null  null
createvariablecompiler
if  standardasmcompiler invdyninvcompilerconstructor    null
try
invocationcompiler    invocationcompiler  standardasmcompiler invdyninvcompilerconstructor newinstance this  method
catch  instantiationexception ie
// do nothing, fall back on default compiler below
catch  illegalaccessexception ie
// do nothing, fall back on default compiler below
catch  invocationtargetexception ie
// do nothing, fall back on default compiler below
if  invocationcompiler    null
invocationcompiler   new standardinvocationcompiler this  method
protected boolean shoulduseboxedargs staticscope scope
return scope getrestarg   >  0    scope getrestarg       2    scope getoptionalargs   > 0    scope getrequiredargs   > 3
protected abstract string getsignature
protected abstract void createvariablecompiler
public abstract void beginmethod compilercallback args  staticscope scope
public abstract void endbody
public bodycompiler chaintomethod string methodname
bodycompiler compiler   outline methodname
endbody
return compiler
public void beginchainedmethod
method start
method aload standardasmcompiler threadcontext_index
method invokevirtual p threadcontext class      sig ruby class
method astore getruntimeindex
// grab nil for local variables
method aload getruntimeindex
method invokevirtual p ruby class      sig irubyobject class
method astore getnilindex
method aload standardasmcompiler threadcontext_index
method invokevirtual p threadcontext class      sig dynamicscope class
method astore getdynamicscopeindex
// if more than 4 locals, get the locals array too
if  scope getnumberofvariables   > 4
method aload getdynamicscopeindex
method invokevirtual p dynamicscope class      sig irubyobject class
method astore getvarsarrayindex
// visit a label to start scoping for local vars in this method
method label scopestart
public abstract basebodycompiler outline string methodname
public standardasmcompiler getscriptcompiler
return script
public void linenumber isourceposition position
int thisline   position getstartline
// no point in updating number if last number was same value.
if  thisline    lastline
lastline   thisline
else
return
label line   new label
method label line
method visitlinenumber thisline   1  line
public void loadthreadcontext
method aload standardasmcompiler threadcontext_index
public void loadself
method aload standardasmcompiler self_index
protected int getclosureindex
return standardasmcompiler args_index   argparamcount   standardasmcompiler closure_offset
protected int getruntimeindex
return standardasmcompiler args_index   argparamcount   standardasmcompiler runtime_offset
protected int getnilindex
return standardasmcompiler args_index   argparamcount   standardasmcompiler nil_offset
protected int getpreviousexceptionindex
return standardasmcompiler args_index   argparamcount   standardasmcompiler previous_exception_offset
protected int getdynamicscopeindex
return standardasmcompiler args_index   argparamcount   standardasmcompiler dynamic_scope_offset
protected int getvarsarrayindex
return standardasmcompiler args_index   argparamcount   standardasmcompiler vars_array_offset
protected int getfirsttempindex
return standardasmcompiler args_index   argparamcount   standardasmcompiler first_temp_offset
protected int getexceptionindex
return standardasmcompiler args_index   argparamcount   standardasmcompiler exception_offset
public void loadthis
method aload standardasmcompiler this
public void loadruntime
method aload getruntimeindex
public void loadblock
method aload getclosureindex
public void loadnil
method aload getnilindex
public void loadnull
method aconst_null
public void loadobject
loadruntime
invokeruby    sig rubyclass class  params
/**
* this is for utility methods used by the compiler, to reduce the amount of code generation
* necessary.  all of these live in compilerhelpers.
*/
public void invokeutilitymethod string methodname  string signature
method invokestatic p runtimehelpers class   methodname  signature
public void invokethreadcontext string methodname  string signature
method invokevirtual standardasmcompiler threadcontext  methodname  signature
public void invokeruby string methodname  string signature
method invokevirtual standardasmcompiler ruby  methodname  signature
public void invokeirubyobject string methodname  string signature
method invokeinterface standardasmcompiler irubyobject  methodname  signature
public void consumecurrentvalue
method pop
public void duplicatecurrentvalue
method dup
public void swapvalues
method swap
public void reversevalues int count
switch  count
case 2
method swap
break
case 3
method dup_x2
method pop
method swap
break
case 4
method swap
method dup2_x2
method pop2
method swap
break
case 5
case 6
case 7
case 8
case 9
case 10
// up to ten, stuff into tmp locals, load in reverse order, and assign
// fixme: there's probably a slightly smarter way, but is it important?
int tmplocals   new int
for  int i   0  i < count  i
tmplocals   getvariablecompiler   grabtemplocal
getvariablecompiler   settemplocal tmplocals
for  int i   0  i < count  i
getvariablecompiler   gettemplocal tmplocals
getvariablecompiler   releasetemplocal
break
default
throw new notcompilableexception
public void retrieveself
loadself
public void retrieveselfclass
loadself
metaclass
public variablecompiler getvariablecompiler
return variablecompiler
public invocationcompiler getinvocationcompiler
return invocationcompiler
public void assignconstantincurrent string name
loadthreadcontext
method ldc name
invokeutilitymethod    sig irubyobject class  params irubyobject class  threadcontext class  string class
public void assignconstantinmodule string name
method ldc name
loadthreadcontext
invokeutilitymethod    sig irubyobject class  irubyobject class  irubyobject class  string class  threadcontext class
public void assignconstantinobject string name
// load object under value
loadobject
method swap
assignconstantinmodule name
public void retrieveconstant string name
script getcachecompiler   cacheconstant this  name
public void retrieveconstantfrommodule string name
invokeutilitymethod    sig rubymodule class  irubyobject class
script getcachecompiler   cacheconstantfrom this  name
public void retrieveconstantfromobject string name
loadobject
script getcachecompiler   cacheconstantfrom this  name
public void retrieveclassvariable string name
loadthreadcontext
loadruntime
loadself
method ldc name
invokeutilitymethod    sig irubyobject class  params threadcontext class  ruby class  irubyobject class  string class
public void assignclassvariable string name
loadthreadcontext
method swap
loadruntime
method swap
loadself
method swap
method ldc name
method swap
invokeutilitymethod    sig irubyobject class  params threadcontext class  ruby class  irubyobject class  string class  irubyobject class
public void assignclassvariable string name  compilercallback value
loadthreadcontext
loadruntime
loadself
method ldc name
value call this
invokeutilitymethod    sig irubyobject class  params threadcontext class  ruby class  irubyobject class  string class  irubyobject class
public void declareclassvariable string name
loadthreadcontext
method swap
loadruntime
method swap
loadself
method swap
method ldc name
method swap
invokeutilitymethod    sig irubyobject class  params threadcontext class  ruby class  irubyobject class  string class  irubyobject class
public void declareclassvariable string name  compilercallback value
loadthreadcontext
loadruntime
loadself
method ldc name
value call this
invokeutilitymethod    sig irubyobject class  params threadcontext class  ruby class  irubyobject class  string class  irubyobject class
public void createnewfloat double value
loadruntime
method ldc new double value
invokeruby    sig rubyfloat class  params double type
public void createnewfixnum long value
script getcachecompiler   cachefixnum this  value
public void createnewbignum biginteger value
loadruntime
script getcachecompiler   cachebiginteger this  value
method invokestatic p rubybignum class      sig rubybignum class  params ruby class  biginteger class
public void createnewstring arraycallback callback  int count
loadruntime
method ldc standardasmcompiler starting_dstr_size
method invokestatic p rubystring class      sig rubystring class  ruby class  int class
for  int i   0  i < count  i
callback nextvalue this  null  i
method invokevirtual p rubystring class      sig rubystring class  params irubyobject class
public void createnewsymbol arraycallback callback  int count
loadruntime
createnewstring callback  count
tojavastring
invokeruby    sig rubysymbol class  params string class
public void createnewstring bytelist value
script getcachecompiler   cachestring this  value
public void createnewsymbol string name
script getcachecompiler   cachesymbol this  name
public void createnewarray boolean lightweight
loadruntime
// put under object array already present
method swap
if  lightweight
method invokestatic p rubyarray class      sig rubyarray class  params ruby class  irubyobject class
else
method invokestatic p rubyarray class      sig rubyarray class  params ruby class  irubyobject class
public void createnewarray object sourcearray  arraycallback callback  boolean lightweight
loadruntime
buildrubyarray sourcearray  callback  lightweight
public void createemptyarray
loadruntime
invokeruby    sig rubyarray class
public void createobjectarray object sourcearray  arraycallback callback
buildobjectarray standardasmcompiler irubyobject  sourcearray  callback
public void createobjectarray int elementcount
// if element count is less than 6, use helper methods
if  elementcount < 6
class params   new class
arrays fill params  irubyobject class
invokeutilitymethod    sig irubyobject class  params
else
// this is pretty inefficient for building an array, so just raise an error if someone's using it for a lot of elements
throw new notcompilableexception
private void buildobjectarray string type  object sourcearray  arraycallback callback
if  sourcearray length    0
method getstatic p irubyobject class      ci irubyobject class
else if  sourcearray length <  runtimehelpers max_specific_arity_object_array
// if we have a specific-arity helper to construct an array for us, use that
for  int i   0  i < sourcearray length  i
callback nextvalue this  sourcearray  i
invokeutilitymethod    sig irubyobject class  params irubyobject class  sourcearray length
else
// brute force construction inline
method pushint sourcearray length
method anewarray type
for  int i   0  i < sourcearray length  i
method dup
method pushint i
callback nextvalue this  sourcearray  i
method arraystore
private void buildrubyarray object sourcearray  arraycallback callback  boolean light
if  sourcearray length    0
method invokestatic p rubyarray class      sig rubyarray class  ruby class
else if  sourcearray length <  runtimehelpers max_specific_arity_object_array
// if we have a specific-arity helper to construct an array for us, use that
for  int i   0  i < sourcearray length  i
callback nextvalue this  sourcearray  i
invokeutilitymethod    sig rubyarray class  params ruby class  irubyobject class  sourcearray length
else
// brute force construction inline
method pushint sourcearray length
method anewarray p irubyobject class
for  int i   0  i < sourcearray length  i
method dup
method pushint i
callback nextvalue this  sourcearray  i
method arraystore
if  light
method invokestatic p rubyarray class      sig rubyarray class  ruby class  irubyobject class
else
method invokestatic p rubyarray class      sig rubyarray class  ruby class  irubyobject class
public void createemptyhash
loadruntime
method invokestatic p rubyhash class      sig rubyhash class  params ruby class
public void createnewhash object elements  arraycallback callback  int keycount
createnewhashcommon elements  callback  keycount
public void createnewhash19 object elements  arraycallback callback  int keycount
createnewhashcommon elements  callback  keycount
private void createnewhashcommon object elements  arraycallback callback  int keycount
string constructorname  string methodname
loadruntime
// use specific-arity for as much as possible
int i   0
for    i < keycount    i < runtimehelpers max_specific_arity_hash  i
callback nextvalue this  elements  i
invokeutilitymethod constructorname  sig rubyhash class  params ruby class  irubyobject class  i   2
for    i < keycount  i
method dup
loadruntime
callback nextvalue this  elements  i
method invokevirtual p rubyhash class   methodname  sig void class  params ruby class  irubyobject class  irubyobject class
public void createnewrange compilercallback beginendcallback  boolean isexclusive
loadruntime
loadthreadcontext
beginendcallback call this
if  isexclusive
method invokestatic p rubyrange class      sig rubyrange class  params ruby class  threadcontext class  irubyobject class  irubyobject class
else
method invokestatic p rubyrange class      sig rubyrange class  params ruby class  threadcontext class  irubyobject class  irubyobject class
public void createnewlambda compilercallback closure
loadthreadcontext
closure call this
loadself
invokeutilitymethod    sig rubyproc class  threadcontext class  block class  irubyobject class
/**
* invoke irubyobject.istrue
*/
private void istrue
invokeirubyobject    sig boolean type
public void performbooleanbranch branchcallback truebranch  branchcallback falsebranch
label afterjmp   new label
label falsejmp   new label
// call istrue on the result
istrue
method ifeq falsejmp      eq    0  i e  false
truebranch branch this
method go_to afterjmp
// fixme: optimize for cases where we have no false branch
method label falsejmp
falsebranch branch this
method label afterjmp
public void performlogicaland branchcallback longbranch
label falsejmp   new label
// dup it since we need to return appropriately if it's false
method dup
// call istrue on the result
istrue
method ifeq falsejmp      eq    0  i e  false
// pop the extra result and replace with the send part of the and
method pop
longbranch branch this
method label falsejmp
public void performlogicalor branchcallback longbranch
// fixme: after jump is not in here.  will if ever be?
//label afterjmp = new label();
label falsejmp   new label
// dup it since we need to return appropriately if it's false
method dup
// call istrue on the result
istrue
method ifne falsejmp      eq    0  i e  false
// pop the extra result and replace with the send part of the and
method pop
longbranch branch this
method label falsejmp
public void performbooleanloopsafe branchcallback condition  branchcallback body  boolean checkfirst
string mname   getnewrescuename
basebodycompiler nested   outline mname
nested performbooleanloopsafeinner condition  body  checkfirst
private void performbooleanloopsafeinner branchcallback condition  branchcallback body  boolean checkfirst
performbooleanloop condition  body  checkfirst
endbody
public void performbooleanloop branchcallback condition  final branchcallback body  boolean checkfirst
label trybegin   new label
label tryend   new label
label catchnext   new label
label catchbreak   new label
label endofbody   new label
label conditioncheck   new label
final label topofbody   new label
label done   new label
label normalloopend   new label
method trycatch trybegin  tryend  catchnext  p jumpexception nextjump class
method trycatch trybegin  tryend  catchbreak  p jumpexception breakjump class
method label trybegin
label oldlooplabels   currentlooplabels
currentlooplabels   new label endofbody  topofbody  done
// fixme: if we terminate immediately, this appears to break while in method arguments
// we need to push a nil for the cases where we will never enter the body
if  checkfirst
method go_to conditioncheck
method label topofbody
runnable redobody   new runnable     public void run
runnable raisebody   new runnable     public void run
body branch basebodycompiler this
runnable raisecatch   new runnable     public void run
loadthreadcontext
invokeutilitymethod    sig throwable class  raiseexception class  threadcontext class
method athrow
method trycatch p raiseexception class   raisebody  raisecatch
runnable redocatch   new runnable     public void run
method pop
method go_to topofbody
method trycatch p jumpexception redojump class   redobody  redocatch
method label endofbody
// clear body or next result after each successful loop
method pop
method label conditioncheck
// check the condition
condition branch this
istrue
method ifne topofbody      ne    nonzero  i e  true
currentlooplabels   oldlooplabels
method label tryend
// skip catch block
method go_to normalloopend
// catch logic for flow-control: next, break
// next jump
method label catchnext
method pop
// exceptionnext target is for a next that doesn't push a new value, like this one
method go_to conditioncheck
// break jump
method label catchbreak
loadthreadcontext
invokeutilitymethod    sig irubyobject class  jumpexception breakjump class  threadcontext class
method go_to done
method label normalloopend
loadnil
method label done
public void performbooleanlooplight branchcallback condition  branchcallback body  boolean checkfirst
label endofbody   new label
label conditioncheck   new label
label topofbody   new label
label done   new label
label oldlooplabels   currentlooplabels
currentlooplabels   new label endofbody  topofbody  done
// fixme: if we terminate immediately, this appears to break while in method arguments
// we need to push a nil for the cases where we will never enter the body
if  checkfirst
method go_to conditioncheck
method label topofbody
body branch this
method label endofbody
// clear body or next result after each successful loop
method pop
method label conditioncheck
// check the condition
condition branch this
istrue
method ifne topofbody      ne    nonzero  i e  true
currentlooplabels   oldlooplabels
loadnil
method label done
public void createnewclosure
int line
staticscope scope
int arity
compilercallback body
compilercallback args
boolean hasmultipleargshead
nodetype argsnodeid
astinspector inspector
string closuremethodname       script getandincrementinnerindex
childscopedbodycompiler closurecompiler   new childscopedbodycompiler script  closuremethodname  inspector  scope
closurecompiler beginmethod args  scope
body call closurecompiler
closurecompiler endbody
// done with closure compilation
loadthreadcontext
loadself
script getcachecompiler   cacheclosure this  closuremethodname  arity  scope  hasmultipleargshead  argsnodeid  inspector
invokeutilitymethod    sig block class
params threadcontext class  irubyobject class  blockbody class
public void createnewclosure19
int line
staticscope scope
int arity
compilercallback body
compilercallback args
boolean hasmultipleargshead
nodetype argsnodeid
astinspector inspector
string closuremethodname       script getandincrementinnerindex
childscopedbodycompiler19 closurecompiler   new childscopedbodycompiler19 script  closuremethodname  inspector  scope
closurecompiler beginmethod args  scope
body call closurecompiler
closurecompiler endbody
// done with closure compilation
loadthreadcontext
loadself
script getcachecompiler   cacheclosure19 this  closuremethodname  arity  scope  hasmultipleargshead  argsnodeid  inspector
invokeutilitymethod    sig block class
params threadcontext class  irubyobject class  blockbody class
public void runbeginblock staticscope scope  compilercallback body
string closuremethodname       script getandincrementinnerindex
childscopedbodycompiler closurecompiler   new childscopedbodycompiler script  closuremethodname  null  scope
closurecompiler beginmethod null  scope
body call closurecompiler
closurecompiler endbody
// done with closure compilation
loadthreadcontext
loadself
standardasmcompiler buildstaticscopenames method  scope
script getcachecompiler   cachespecialclosure this  closuremethodname
invokeutilitymethod    sig irubyobject class
params threadcontext class  irubyobject class  string class  compiledblockcallback class
public void createnewforloop int arity  compilercallback body  compilercallback args  boolean hasmultipleargshead  nodetype argsnodeid  astinspector inspector
string closuremethodname       script getandincrementinnerindex
childscopedbodycompiler closurecompiler   new childscopedbodycompiler script  closuremethodname  inspector  scope
closurecompiler beginmethod args  null
body call closurecompiler
closurecompiler endbody
// done with closure compilation
loadthreadcontext
loadself
method pushint arity
script getcachecompiler   cachespecialclosure this  closuremethodname
method ldc boolean valueof hasmultipleargshead
method ldc blockbody asargumenttype argsnodeid
invokeutilitymethod    sig block class
params threadcontext class  irubyobject class  integer type  compiledblockcallback class  boolean type  integer type
public void createnewendblock compilercallback body
string closuremethodname       script getandincrementinnerindex
childscopedbodycompiler closurecompiler   new childscopedbodycompiler script  closuremethodname  null  scope
closurecompiler beginmethod null  null
body call closurecompiler
closurecompiler endbody
// done with closure compilation
loadthreadcontext
loadself
method iconst_0
script getcachecompiler   cachespecialclosure this  closuremethodname
method iconst_0       false
method iconst_0       zero
invokeutilitymethod    sig block class
params threadcontext class  irubyobject class  integer type  compiledblockcallback class  boolean type  integer type
loadruntime
invokeutilitymethod    sig void class  block class  ruby class
loadnil
public void getcompiledclass
method aload standardasmcompiler this
method getfield script getclassname       ci class class
public void println
method dup
method getstatic p system class      ci printstream class
method swap
method invokevirtual p printstream class      sig void type  params object class
public void definealias string newname  string oldname
loadthreadcontext
method ldc newname
method ldc oldname
invokeutilitymethod    sig irubyobject class  threadcontext class  string class  string class
public void loadfalse
// todo: cache?
loadruntime
invokeruby    sig rubyboolean class
public void loadtrue
// todo: cache?
loadruntime
invokeruby    sig rubyboolean class
public void loadcurrentmodule
loadthreadcontext
invokethreadcontext    sig dynamicscope class
method invokevirtual p dynamicscope class      sig staticscope class
method invokevirtual p staticscope class      sig rubymodule class
public void retrieveinstancevariable string name
script getcachecompiler   cachedgetvariable this  name
public void assigninstancevariable string name
final int tmp   getvariablecompiler   grabtemplocal
getvariablecompiler   settemplocal tmp
compilercallback callback   new compilercallback
public void call bodycompiler context
context getvariablecompiler   gettemplocal tmp
script getcachecompiler   cachedsetvariable this  name  callback
public void assigninstancevariable string name  compilercallback value
script getcachecompiler   cachedsetvariable this  name  value
public void retrieveglobalvariable string name
loadruntime
method ldc name
invokeutilitymethod    sig irubyobject class  ruby class  string class
public void assignglobalvariable string name
loadruntime
method ldc name
invokeutilitymethod    sig irubyobject class  irubyobject class  ruby class  string class
public void assignglobalvariable string name  compilercallback value
value call this
loadruntime
method ldc name
invokeutilitymethod    sig irubyobject class  irubyobject class  ruby class  string class
public void negatecurrentvalue
loadruntime
invokeutilitymethod    sig irubyobject class  irubyobject class  ruby class
public void splatcurrentvalue
method invokestatic p runtimehelpers class      sig rubyarray class  params irubyobject class
public void singlifysplattedvalue
method invokestatic p runtimehelpers class      sig irubyobject class  params irubyobject class
public void arytoary
method invokestatic p runtimehelpers class      sig irubyobject class  params irubyobject class
public void ensurerubyarray
invokeutilitymethod    sig rubyarray class  params irubyobject class
public void ensuremultipleassignablerubyarray boolean masgnhashead
loadruntime
method pushboolean masgnhashead
invokeutilitymethod    sig rubyarray class  params irubyobject class  ruby class  boolean class
public void foreachinvaluearray int start  int count  object source  arraycallback callback  compilercallback argscallback
if  start < count    argscallback    null
int templocal   getvariablecompiler   grabtemplocal
getvariablecompiler   settemplocal templocal
for    start < count  start
getvariablecompiler   gettemplocal templocal
switch  start
case 0
invokeutilitymethod    sig irubyobject class  rubyarray class
break
case 1
invokeutilitymethod    sig irubyobject class  rubyarray class
break
case 2
invokeutilitymethod    sig irubyobject class  rubyarray class
break
default
method pushint start
invokeutilitymethod    sig irubyobject class  rubyarray class  int class
break
callback nextvalue this  source  start
if  argscallback    null
getvariablecompiler   gettemplocal templocal
loadruntime
method pushint start
invokeutilitymethod    sig rubyarray class  rubyarray class  ruby class  int class
argscallback call this
getvariablecompiler   gettemplocal templocal
getvariablecompiler   releasetemplocal
public void foreachinvaluearray int start  int precount  object presource  int postcount  object postsource  arraycallback callback  compilercallback argscallback
if  start < precount    argscallback    null
int templocal   getvariablecompiler   grabtemplocal
getvariablecompiler   settemplocal templocal
for    start < precount  start
getvariablecompiler   gettemplocal templocal
switch  start
case 0
invokeutilitymethod    sig irubyobject class  rubyarray class
break
case 1
invokeutilitymethod    sig irubyobject class  rubyarray class
break
case 2
invokeutilitymethod    sig irubyobject class  rubyarray class
break
default
method pushint start
invokeutilitymethod    sig irubyobject class  rubyarray class  int class
break
callback nextvalue this  presource  start
if  argscallback    null
getvariablecompiler   gettemplocal templocal
loadruntime
method pushint start
invokeutilitymethod    sig rubyarray class  rubyarray class  ruby class  int class
argscallback call this
if  postcount > 0
throw new notcompilableexception
getvariablecompiler   gettemplocal templocal
getvariablecompiler   releasetemplocal
public void asstring
method invokeinterface p irubyobject class      sig rubystring class
public void tojavastring
method invokevirtual p object class      sig string class
public void nthref int match
method pushint match
backref
method invokestatic p rubyregexp class      sig irubyobject class  params integer type  irubyobject class
public void match
loadthreadcontext
method invokevirtual p rubyregexp class      sig irubyobject class  params threadcontext class
public void match2 compilercallback value
loadthreadcontext
value call this
method invokevirtual p rubyregexp class      sig irubyobject class  params threadcontext class  irubyobject class
public void match3
loadthreadcontext
invokeutilitymethod    sig irubyobject class  rubyregexp class  irubyobject class  threadcontext class
public void createnewregexp final bytelist value  final int options
script getcachecompiler   cacheregexp this  value tostring    options
public void createnewregexp compilercallback createstringcallback  final int options
boolean onceonly    options   reoptions re_option_once     0       for regular expressions with the  o flag
if  onceonly
script getcachecompiler   cachedregexp this  createstringcallback  options
else
loadruntime
createstringcallback call this
method pushint options
method invokestatic p rubyregexp class      sig rubyregexp class  params ruby class  rubystring class  int class
public void pollthreadevents
if   rubyinstanceconfig threadless_compile_enabled
loadthreadcontext
invokethreadcontext    sig void type
public void nulltonil
label notnull   new label
method dup
method ifnonnull notnull
method pop
loadnil
method label notnull
public void isinstanceof class clazz  branchcallback truebranch  branchcallback falsebranch
method instance_of p clazz
label falsejmp   new label
label afterjmp   new label
method ifeq falsejmp      eq    0  i e  false
truebranch branch this
method go_to afterjmp
method label falsejmp
falsebranch branch this
method label afterjmp
public void iscaptured final int number  final branchcallback truebranch  final branchcallback falsebranch
backref
method dup
isinstanceof rubymatchdata class  new branchcallback
public void branch bodycompiler context
method visittypeinsn checkcast  p rubymatchdata class
method pushint number
method invokevirtual p rubymatchdata class      sig irubyobject class  params int class
method invokeinterface p irubyobject class      sig boolean class
label isnil   new label
label after   new label
method ifne isnil
truebranch branch context
method go_to after
method label isnil
falsebranch branch context
method label after
new branchcallback
public void branch bodycompiler context
method pop
falsebranch branch context
public void backref
loadruntime
loadthreadcontext
invokeutilitymethod    sig irubyobject class  ruby class  threadcontext class
public void backrefmethod string methodname
backref
method invokestatic p rubyregexp class   methodname  sig irubyobject class  params irubyobject class
public void issueloopbreak
// inside a loop, break out of it
// go to end of loop, leaving break value on stack
method go_to currentlooplabels
public void issueloopnext
// inside a loop, jump to conditional
method go_to currentlooplabels
public void issueloopredo
// inside a loop, jump to body
method go_to currentlooplabels
protected string getnewensurename
return      script getandincrementensurenumber
public void protect branchcallback regularcode  branchcallback protectedcode  class ret
string mname   getnewensurename
skinnymethodadapter mv   new skinnymethodadapter
script getclassvisitor   visitmethod
acc_public   acc_synthetic   acc_static
mname
sig ret      script getclassname        threadcontext class  irubyobject class  block class


skinnymethodadapter old_method   null
skinnymethodadapter var_old_method   null
skinnymethodadapter inv_old_method   null
boolean oldinnestedmethod   innestedmethod
innestedmethod   true
label oldlooplabels   currentlooplabels
currentlooplabels   null
int oldargcount   argparamcount
argparamcount   0     synthetic methods always have zero arg parameters
try
old_method   this method
var_old_method   getvariablecompiler   getmethodadapter
inv_old_method   getinvocationcompiler   getmethodadapter
this method   mv
getvariablecompiler   setmethodadapter mv
getinvocationcompiler   setmethodadapter mv
mv visitcode
// set up a local iruby variable
mv aload standardasmcompiler threadcontext_index
mv dup
mv invokevirtual p threadcontext class      sig ruby class
mv dup
mv astore getruntimeindex
// grab nil for local variables
mv invokevirtual p ruby class      sig irubyobject class
mv astore getnilindex
mv invokevirtual p threadcontext class      sig dynamicscope class
mv dup
mv astore getdynamicscopeindex
mv invokevirtual p dynamicscope class      sig irubyobject class
mv astore getvarsarrayindex
label codebegin   new label
label codeend   new label
label ensurebegin   new label
label ensureend   new label
method label codebegin
regularcode branch this
method label codeend
protectedcode branch this
mv areturn
method label ensurebegin
method astore getexceptionindex
method label ensureend
protectedcode branch this
method aload getexceptionindex
method athrow
method trycatch codebegin  codeend  ensurebegin  null
method trycatch ensurebegin  ensureend  ensurebegin  null
mv visitmaxs 1  1
mv visitend
finally
this method   old_method
getvariablecompiler   setmethodadapter var_old_method
getinvocationcompiler   setmethodadapter inv_old_method
innestedmethod   oldinnestedmethod
currentlooplabels   oldlooplabels
argparamcount   oldargcount
method aload standardasmcompiler this
loadthreadcontext
loadself
if  this instanceof childscopedbodycompiler
pushnull
else
loadblock
method invokestatic
script getclassname
mname
sig ret      script getclassname        threadcontext class  irubyobject class  block class
public void performensure branchcallback regularcode  branchcallback protectedcode
string mname   getnewensurename
basebodycompiler ensure   outline mname
ensure performensureinner regularcode  protectedcode
private void performensureinner branchcallback regularcode  branchcallback protectedcode
label codebegin   new label
label codeend   new label
label ensurebegin   new label
label ensureend   new label
method label codebegin
regularcode branch this
method label codeend
protectedcode branch this
method areturn
method label ensurebegin
method astore getexceptionindex
method label ensureend
protectedcode branch this
method aload getexceptionindex
method athrow
method trycatch codebegin  codeend  ensurebegin  null
method trycatch ensurebegin  ensureend  ensurebegin  null
loadnil
endbody
protected string getnewrescuename
return      script getandincrementrescuenumber
public void storeexceptioninerrorinfo
loadexception
loadthreadcontext
invokeutilitymethod    sig void class  throwable class  threadcontext class
public void clearerrorinfo
loadthreadcontext
invokeutilitymethod    sig void class  threadcontext class
public void rescue branchcallback regularcode  class exception  branchcallback catchcode  class ret
string mname   getnewrescuename
skinnymethodadapter mv   new skinnymethodadapter
script getclassvisitor   visitmethod
acc_public   acc_synthetic   acc_static
mname
sig ret      script getclassname        threadcontext class  irubyobject class  block class


skinnymethodadapter old_method   null
skinnymethodadapter var_old_method   null
skinnymethodadapter inv_old_method   null
label aftermethodbody   new label
label catchretry   new label
label catchraised   new label
label catchjumps   new label
label exitrescue   new label
boolean oldwithinprotection   innestedmethod
innestedmethod   true
label oldlooplabels   currentlooplabels
currentlooplabels   null
int oldargcount   argparamcount
argparamcount   0     synthetic methods always have zero arg parameters
try
old_method   this method
var_old_method   getvariablecompiler   getmethodadapter
inv_old_method   getinvocationcompiler   getmethodadapter
this method   mv
getvariablecompiler   setmethodadapter mv
getinvocationcompiler   setmethodadapter mv
mv start
// set up a local iruby variable
mv aload standardasmcompiler threadcontext_index
mv invokevirtual p threadcontext class      sig ruby class
mv astore getruntimeindex
// store previous exception for restoration if we rescue something
loadthreadcontext
invokethreadcontext    sig irubyobject class
mv astore getpreviousexceptionindex
// grab nil for local variables
loadruntime
mv invokevirtual p ruby class      sig irubyobject class
mv astore getnilindex
mv aload standardasmcompiler threadcontext_index
mv invokevirtual p threadcontext class      sig dynamicscope class
mv astore getdynamicscopeindex
// if more than 4 vars, get values array too
if  scope getnumberofvariables   > 4
mv aload getdynamicscopeindex
mv invokevirtual p dynamicscope class      sig irubyobject class
mv astore getvarsarrayindex
label beforebody   new label
label afterbody   new label
label catchblock   new label
mv trycatch beforebody  afterbody  catchblock  p exception
mv label beforebody
regularcode branch this
mv label afterbody
mv go_to exitrescue
mv label catchblock
mv astore getexceptionindex
catchcode branch this
mv label aftermethodbody
mv go_to exitrescue
// retry handling in the rescue block
mv trycatch catchblock  aftermethodbody  catchretry  p jumpexception retryjump class
mv label catchretry
mv pop
mv go_to beforebody
// any exceptions raised must continue to be raised, skipping $! restoration
mv trycatch beforebody  aftermethodbody  catchraised  p raiseexception class
mv label catchraised
mv athrow
// and remaining jump exceptions should restore $!
mv trycatch beforebody  aftermethodbody  catchjumps  p jumpexception class
mv label catchjumps
loadthreadcontext
method aload getpreviousexceptionindex
invokethreadcontext    sig irubyobject class  irubyobject class
method pop
mv athrow
mv label exitrescue
// restore the original exception
loadthreadcontext
method aload getpreviousexceptionindex
invokethreadcontext    sig irubyobject class  irubyobject class
method pop
mv areturn
mv end
finally
innestedmethod   oldwithinprotection
this method   old_method
getvariablecompiler   setmethodadapter var_old_method
getinvocationcompiler   setmethodadapter inv_old_method
currentlooplabels   oldlooplabels
argparamcount   oldargcount
method aload standardasmcompiler this
loadthreadcontext
loadself
if  this instanceof childscopedbodycompiler
pushnull
else
loadblock
method invokestatic
script getclassname
mname
sig ret      script getclassname        threadcontext class  irubyobject class  block class
public void performrescue branchcallback regularcode  branchcallback rubycatchcode  boolean needsretry
string mname   getnewrescuename
basebodycompiler rescuemethod   outline mname
rescuemethod performrescuelight regularcode  rubycatchcode  needsretry
rescuemethod endbody
public void performrescuelight branchcallback regularcode  branchcallback rubycatchcode  boolean needsretry
label afterrubycatchbody   new label
label catchretry   new label
label catchjumps   new label
label exitrescue   new label
// store previous exception for restoration if we rescue something
loadthreadcontext
invokethreadcontext    sig irubyobject class
method astore getpreviousexceptionindex
label beforebody   new label
label afterbody   new label
label rubycatchblock   new label
label flowcatchblock   new label
method visittrycatchblock beforebody  afterbody  flowcatchblock  p jumpexception flowcontrolexception class
method visittrycatchblock beforebody  afterbody  rubycatchblock  p throwable class
method visitlabel beforebody
regularcode branch this
method label afterbody
method go_to exitrescue
// handle flow exceptions, just propagating them
method label flowcatchblock
// rethrow to outer flow catcher
method athrow
// handle ruby exceptions (raiseexception)
method label rubycatchblock
method astore getexceptionindex
rubycatchcode branch this
method label afterrubycatchbody
method go_to exitrescue
// retry handling in the rescue blocks
if  needsretry
method trycatch rubycatchblock  afterrubycatchbody  catchretry  p jumpexception retryjump class
method label catchretry
method pop
method go_to beforebody
// and remaining jump exceptions should restore $!
method trycatch beforebody  afterrubycatchbody  catchjumps  p jumpexception flowcontrolexception class
method label catchjumps
loadthreadcontext
method aload getpreviousexceptionindex
invokethreadcontext    sig irubyobject class  irubyobject class
method pop
method athrow
method label exitrescue
// restore the original exception
loadthreadcontext
method aload getpreviousexceptionindex
invokethreadcontext    sig irubyobject class  irubyobject class
method pop
public void wrapjavaexception
loadruntime
loadexception
wrapjavaobject
public void wrapjavaobject
method invokestatic p javautil class      sig irubyobject class  ruby class  object class
public void indefined
method aload standardasmcompiler threadcontext_index
method iconst_1
invokethreadcontext    sig void class  params boolean class
public void outdefined
method aload standardasmcompiler threadcontext_index
method iconst_0
invokethreadcontext    sig void class  params boolean class
public void stringornil
loadruntime
loadnil
invokeutilitymethod    sig irubyobject class  string class  ruby class  irubyobject class
public void pushnull
method aconst_null
public void pushstring string str
method ldc str
public void ismethodbound string name  branchcallback truebranch  branchcallback falsebranch
metaclass
method ldc name
method iconst_0       push false
method invokevirtual p rubyclass class      sig boolean class  params string class  boolean class
label falselabel   new label
label exitlabel   new label
method ifeq falselabel      eq    0  i e  false
truebranch branch this
method go_to exitlabel
method label falselabel
falsebranch branch this
method label exitlabel
public void hasblock branchcallback truebranch  branchcallback falsebranch
loadblock
method invokevirtual p block class      sig boolean class
label falselabel   new label
label exitlabel   new label
method ifeq falselabel      eq    0  i e  false
truebranch branch this
method go_to exitlabel
method label falselabel
falsebranch branch this
method label exitlabel
public void isglobaldefined string name  branchcallback truebranch  branchcallback falsebranch
loadruntime
invokeruby    sig globalvariables class
method ldc name
method invokevirtual p globalvariables class      sig boolean class  params string class
label falselabel   new label
label exitlabel   new label
method ifeq falselabel      eq    0  i e  false
truebranch branch this
method go_to exitlabel
method label falselabel
falsebranch branch this
method label exitlabel
public void isconstantdefined string name  branchcallback truebranch  branchcallback falsebranch
loadthreadcontext
method ldc name
invokethreadcontext    sig boolean class  params string class
label falselabel   new label
label exitlabel   new label
method ifeq falselabel      eq    0  i e  false
truebranch branch this
method go_to exitlabel
method label falselabel
falsebranch branch this
method label exitlabel
public void isinstancevariabledefined string name  branchcallback truebranch  branchcallback falsebranch
loadself
invokeirubyobject    sig instancevariables class
method ldc name
//method.invokeinterface(p(irubyobject.class), "getinstancevariable", sig(irubyobject.class, params(string.class)));
method invokeinterface p instancevariables class      sig boolean class  params string class
label truelabel   new label
label exitlabel   new label
//method.ifnonnull(truelabel);
method ifne truelabel
falsebranch branch this
method go_to exitlabel
method label truelabel
truebranch branch this
method label exitlabel
public void isclassvardefined string name  branchcallback truebranch  branchcallback falsebranch
method ldc name
method invokevirtual p rubymodule class      sig boolean class  params string class
label truelabel   new label
label exitlabel   new label
method ifne truelabel
falsebranch branch this
method go_to exitlabel
method label truelabel
truebranch branch this
method label exitlabel
public object getnewending
return new label
public void isnil branchcallback truebranch  branchcallback falsebranch
method invokeinterface p irubyobject class      sig boolean class
label falselabel   new label
label exitlabel   new label
method ifeq falselabel      eq    0  i e  false
truebranch branch this
method go_to exitlabel
method label falselabel
falsebranch branch this
method label exitlabel
public void isnull branchcallback truebranch  branchcallback falsebranch
label falselabel   new label
label exitlabel   new label
method ifnonnull falselabel
truebranch branch this
method go_to exitlabel
method label falselabel
falsebranch branch this
method label exitlabel
public void ifnull object gototoken
method ifnull  label  gototoken
public void ifnotnull object gototoken
method ifnonnull  label  gototoken
public void setending object endingtoken
method label  label  endingtoken
public void go object gototoken
method go_to  label  gototoken
public void isconstantbranch final branchcallback setup  final branchcallback isconstant  final branchcallback ismethod  final branchcallback none  final string name
rescue new branchcallback
public void branch bodycompiler context
setup branch basebodycompiler this
method dup
method instance_of p rubymodule class
label falsejmp   new label
label afterjmp   new label
label nextjmp   new label
label nextjmppop   new label
method ifeq nextjmp      eq    0  i e  false
method visittypeinsn checkcast  p rubymodule class
method dup
method ldc name
method invokevirtual p rubymodule class      sig irubyobject class  params string class
method dup
method ifnull nextjmppop
method pop
method pop
isconstant branch basebodycompiler this
method go_to afterjmp
method label nextjmppop
method pop
method label nextjmp
metaclass
method ldc name
method iconst_1       push true
method invokevirtual p rubyclass class      sig boolean class  params string class  boolean class
method ifeq falsejmp      eq    0  i e  false
ismethod branch basebodycompiler this
method go_to afterjmp
method label falsejmp
none branch basebodycompiler this
method label afterjmp
jumpexception class  none  string class
public void metaclass
invokeirubyobject    sig rubyclass class
public void aprintln
method aprintln
public void getvisibilityfor string name
method ldc name
method invokevirtual p rubyclass class      sig dynamicmethod class  params string class
method invokevirtual p dynamicmethod class      sig visibility class
public void isprivate object gototoken  int toconsume
method getstatic p visibility class      ci visibility class
label temp   new label
method if_acmpne temp
while   toconsume    > 0
method pop
method go_to  label  gototoken
method label temp
public void isnotprotected object gototoken  int toconsume
method getstatic p visibility class      ci visibility class
label temp   new label
method if_acmpeq temp
while   toconsume    > 0
method pop
method go_to  label  gototoken
method label temp
public void selfiskindof object gototoken
method invokevirtual p rubyclass class      sig rubyclass class
loadself
method invokevirtual p rubymodule class      sig boolean class  params irubyobject class
method ifne  label  gototoken      eq    0  i e  true
public void notismoduleandclassvardefined string name  object gototoken
method dup
method instance_of p rubymodule class
label falsepopjmp   new label
label successjmp   new label
method ifeq falsepopjmp
method visittypeinsn checkcast  p rubymodule class
method ldc name
method invokevirtual p rubymodule class      sig boolean class  params string class
method ifeq  label  gototoken
method go_to successjmp
method label falsepopjmp
method pop
method go_to  label  gototoken
method label successjmp
public void ifsingleton object gototoken
method invokevirtual p rubymodule class      sig boolean class
method ifne  label  gototoken      eq    0  i e  false
public void getinstancevariable string name
method ldc name
invokeirubyobject    sig instancevariables class
method invokeinterface p instancevariables class      sig irubyobject class  params string class
public void getframename
loadthreadcontext
invokethreadcontext    sig string class
public void getframeklazz
loadthreadcontext
invokethreadcontext    sig rubymodule class
public void superclass
method invokevirtual p rubymodule class      sig rubyclass class
public void attached
method visittypeinsn checkcast  p metaclass class
method invokevirtual p metaclass class      sig irubyobject class
public void ifnotsupermethodbound object token
method swap
method iconst_0
method invokevirtual p rubymodule class      sig boolean class  params string class  boolean class
method ifeq  label  token
public void concatarrays
method invokevirtual p rubyarray class      sig rubyarray class  params irubyobject class
public void concatobjectarrays
invokeutilitymethod    sig irubyobject class  params irubyobject class  irubyobject class
public void appendtoarray
method invokevirtual p rubyarray class      sig rubyarray class  params irubyobject class
public void appendtoobjectarray
invokeutilitymethod    sig irubyobject class  params irubyobject class  irubyobject class
public void converttojavaarray
method invokestatic p argsutil class      sig irubyobject class  params irubyobject class
public void aliasglobal string newname  string oldname
loadruntime
invokeruby    sig globalvariables class
method ldc newname
method ldc oldname
method invokevirtual p globalvariables class      sig void type  params string class  string class
loadnil
public void raisetypeerror string msg
loadruntime
method ldc msg
invokeruby    sig raiseexception class  params string class
method athrow
public void undefmethod string name
loadthreadcontext
invokethreadcontext    sig rubymodule class
label notnull   new label
method dup
method ifnonnull notnull
method pop
loadruntime
method ldc     name
invokeruby    sig raiseexception class  params string class
method athrow
method label notnull
loadthreadcontext
method ldc name
method invokevirtual p rubymodule class      sig void type  params threadcontext class  string class
loadnil
public void defineclass
final string name
final staticscope staticscope
final compilercallback supercallback
final compilercallback pathcallback
final compilercallback bodycallback
final compilercallback receivercallback
final astinspector inspector
string classmethodname   null
if  receivercallback    null
string mangledname   javanamemangler manglestringforcleanjavaidentifier name
classmethodname       script getandincrementmethodindex         mangledname
else
classmethodname       script getandincrementmethodindex
final rootscopedbodycompiler classbody   new classbodycompiler script  classmethodname  inspector  staticscope
compilercallback bodyprep   new compilercallback
public void call bodycompiler context
if  receivercallback    null
// no receiver for singleton class
if  supercallback    null
// but there's a superclass passed in, use it
classbody loadruntime
classbody method aload standardasmcompiler self_index
classbody invokeutilitymethod    sig rubyclass class  params ruby class  irubyobject class
else
classbody method aconst_null
classbody loadthreadcontext
pathcallback call classbody
classbody invokeutilitymethod    sig rubymodule class  params threadcontext class  irubyobject class
classbody method swap
classbody method ldc name
classbody method swap
classbody method invokevirtual p rubymodule class      sig rubyclass class  params string class  rubyclass class
else
classbody loadruntime
// we re-set self to the class, but store the old self in a temporary local variable
// this is to prevent it gcing in case the singleton is short-lived
classbody method aload standardasmcompiler self_index
int selftemp   classbody getvariablecompiler   grabtemplocal
classbody getvariablecompiler   settemplocal selftemp
classbody method aload standardasmcompiler self_index
classbody invokeutilitymethod    sig rubyclass class  params ruby class  irubyobject class
// set self to the class
classbody method dup
classbody method astore standardasmcompiler self_index
// class body
classbody loadthreadcontext
classbody method swap
// static scope
script getcachecompiler   cachestaticscope classbody  staticscope
if  inspector hasclosure      inspector hasscopeawaremethods
classbody invokethreadcontext    sig void type  params rubymodule class  staticscope class
else
classbody invokethreadcontext    sig void type  params rubymodule class  staticscope class
// here starts the logic for the class definition
label start   new label
label end   new label
label after   new label
label noexception   new label
classbody method trycatch start  end  after  null
classbody beginmethod bodyprep  staticscope
classbody method label start
bodycallback call classbody
classbody method label end
// finally with no exception
classbody loadthreadcontext
classbody invokethreadcontext    sig void type  params
classbody method go_to noexception
classbody method label after
// finally with exception
classbody loadthreadcontext
classbody invokethreadcontext    sig void type  params
classbody method athrow
classbody method label noexception
classbody endbody
// prepare to call class definition method
method aload standardasmcompiler this
loadthreadcontext
if  receivercallback    null
// if there's no receiver, evaluate and pass in the superclass, or
// pass self if it no superclass
if  supercallback    null
supercallback call this
else
method aload standardasmcompiler self_index
else
// otherwise, there's a receiver, so we pass that in directly for the sclass logic
receivercallback call this
method getstatic p block class      ci block class
method invokestatic script getclassname    classmethodname  standardasmcompiler getstaticmethodsignature script getclassname    0
public void definemodule final string name  final staticscope staticscope  final compilercallback pathcallback  final compilercallback bodycallback  final astinspector inspector
string mangledname   javanamemangler manglestringforcleanjavaidentifier name
string modulemethodname       script getandincrementmethodindex         mangledname
final rootscopedbodycompiler classbody   new classbodycompiler script  modulemethodname  inspector  staticscope
compilercallback bodyprep   new compilercallback
public void call bodycompiler context
classbody loadthreadcontext
pathcallback call classbody
classbody invokeutilitymethod    sig rubymodule class  params threadcontext class  irubyobject class
classbody method ldc name
classbody method invokevirtual p rubymodule class      sig rubymodule class  params string class
// set self to the class
classbody method dup
classbody method astore standardasmcompiler self_index
// class body
classbody loadthreadcontext
classbody method swap
// static scope
script getcachecompiler   cachestaticscope classbody  staticscope
if  inspector hasclosure      inspector hasscopeawaremethods
classbody invokethreadcontext    sig void type  params rubymodule class  staticscope class
else
classbody invokethreadcontext    sig void type  params rubymodule class  staticscope class
// here starts the logic for the class definition
label start   new label
label end   new label
label after   new label
label noexception   new label
classbody method trycatch start  end  after  null
classbody beginmethod bodyprep  staticscope
classbody method label start
bodycallback call classbody
classbody method label end
classbody method go_to noexception
classbody method label after
classbody loadthreadcontext
classbody invokethreadcontext    sig void type  params
classbody method athrow
classbody method label noexception
classbody loadthreadcontext
classbody invokethreadcontext    sig void type  params
classbody endbody
// prepare to call class definition method
method aload standardasmcompiler this
loadthreadcontext
loadself
method getstatic p irubyobject class      ci irubyobject class
method getstatic p block class      ci block class
method invokestatic script getclassname    modulemethodname  standardasmcompiler getstaticmethodsignature script getclassname    4
public void unwrappassedblock
loadblock
invokeutilitymethod    sig block class  params irubyobject class  block class
public void performbackref char type
loadthreadcontext
switch  type
case
invokeutilitymethod    sig irubyobject class  params threadcontext class
break
case
invokeutilitymethod    sig irubyobject class  params threadcontext class
break
case
invokeutilitymethod    sig irubyobject class  params threadcontext class
break
case
invokeutilitymethod    sig irubyobject class  params threadcontext class
break
case
invokeutilitymethod    sig irubyobject class  params threadcontext class
break
default
throw new notcompilableexception
public void callzsuper compilercallback closure
argumentscallback argscallback   new argumentscallback
public int getarity
return  1
public void call bodycompiler context
loadthreadcontext
invokeutilitymethod    sig irubyobject class  threadcontext class
getinvocationcompiler   invokedynamic null  null  argscallback  calltype super  closure  false
public void checkisexceptionhandled argumentscallback rescueargs
// original exception is on stack
rescueargs call this
loadthreadcontext
switch  rescueargs getarity
case 1
invokeutilitymethod    sig irubyobject class  throwable class  irubyobject class  threadcontext class
break
case 2
invokeutilitymethod    sig irubyobject class  throwable class  irubyobject class  irubyobject class  threadcontext class
break
case 3
invokeutilitymethod    sig irubyobject class  throwable class  irubyobject class  irubyobject class  irubyobject class  threadcontext class
break
default
invokeutilitymethod    sig irubyobject class  throwable class  irubyobject class  threadcontext class
public void rethrowexception
loadexception
method athrow
public void loadclass string name
loadruntime
method ldc name
invokeruby    sig rubyclass class  string class
public void loadstandarderror
loadruntime
invokeruby    sig rubyclass class
public void unwrapraiseexception
// raiseexception is on stack, get rubyexception out
method invokevirtual p raiseexception class      sig rubyexception class
public void loadexception
method aload getexceptionindex
public void setfileposition isourceposition position
if   rubyinstanceconfig positionless_compile_enabled
loadthreadcontext
method ldc position getfile
invokethreadcontext    sig void class  params string class
public void setlineposition isourceposition position
if   rubyinstanceconfig positionless_compile_enabled
if  lastpositionline    position getstartline
// updating position for same line; skip
return
else
lastpositionline   position getstartline
loadthreadcontext
method pushint position getstartline
method invokestatic script getclassname       sig void class  params threadcontext class  int class
public void checkwhenwithsplat
loadthreadcontext
invokeutilitymethod    sig rubyboolean class  irubyobject class  irubyobject class  threadcontext class
public void issueretryevent
invokeutilitymethod    sig irubyobject class
public void definenewmethod string name  int methodarity  staticscope scope
compilercallback body  compilercallback args
compilercallback receiver  astinspector inspector  boolean root
// todo: build arg list based on number of args, optionals, etc
string newmethodname
if  root    boolean getboolean
newmethodname   name
else
string mangledname   javanamemangler manglestringforcleanjavaidentifier name
newmethodname       script getandincrementmethodindex         mangledname
bodycompiler methodcompiler   script startmethod name  newmethodname  args  scope  inspector
// callbacks to fill in method body
body call methodcompiler
methodcompiler endbody
// prepare to call "def" utility method to handle def logic
loadthreadcontext
loadself
if  receiver    null
receiver call this             script object
method aload standardasmcompiler this
method ldc name
method ldc newmethodname
standardasmcompiler buildstaticscopenames method  scope
method pushint methodarity
// arities
method pushint scope getrequiredargs
method pushint scope getoptionalargs
method pushint scope getrestarg
method getstatic p callconfiguration class   inspector getcallconfig   name    ci callconfiguration class
if  receiver    null
invokeutilitymethod    sig irubyobject class
params threadcontext class  irubyobject class  irubyobject class  object class  string class  string class  string class  int class  int class  int class  int class  callconfiguration class
else
invokeutilitymethod    sig irubyobject class
params threadcontext class  irubyobject class  object class  string class  string class  string class  int class  int class  int class  int class  callconfiguration class
public void rethrowifsystemexit
loadruntime
method ldc
method invokevirtual p ruby class      sig rubyclass class  string class
method swap
method invokevirtual p rubymodule class      sig boolean class  params irubyobject class
method iconst_0
label ifend   new label
method if_icmpeq ifend
loadexception
method athrow
method label ifend
public void literalswitch int cases  object bodies  arraycallback arraycallback  compilercallback defaultcallback
// todo assuming case is a fixnum
method checkcast p rubyfixnum class
method invokevirtual p rubyfixnum class      sig long class
method l2i
map<object  label> labelmap   new hashmap<object  label>
label labels   new label
for  int i   0  i < labels length  i
object body   bodies
label label   labelmap get body
if  label    null
label   new label
labelmap put body  label
labels   label
label defaultlabel   new label
label endlabel   new label
method lookupswitch defaultlabel  cases  labels
set<label> labeldone   new hashset<label>
for  int i   0  i < cases length  i
if  labeldone contains labels   continue
labeldone add labels
method label labels
arraycallback nextvalue this  bodies  i
method go_to endlabel
method label defaultlabel
defaultcallback call this
method label endlabel
public void typecheckbranch class type  branchcallback truecallback  branchcallback falsecallback
label elselabel   new label
label done   new label
method dup
method instance_of p type
method ifeq elselabel
truecallback branch this
method go_to done
method label elselabel
falsecallback branch this
method label done
public void loadfilename
loadruntime
loadthis
method getfield getscriptcompiler   getclassname       ci string class
method invokestatic p rubystring class      sig rubystring class  ruby class  charsequence class
public void compilesequencedconditional
compilercallback inputvalue
fastswitchtype fastswitchtype
map<compilercallback  int> switchcases
list<argumentscallback> conditionals
list<compilercallback> bodies
compilercallback fallback
map<compilercallback  label> bodylabels   new hashmap<compilercallback  label>
label defaultcase   new label
label slowpath   new label
compilercallback getcasevalue   null
final int tmp   getvariablecompiler   grabtemplocal
if  inputvalue    null
// we have an input case, prepare branching logic
inputvalue call this
getvariablecompiler   settemplocal tmp
getcasevalue   new compilercallback
public void call bodycompiler context
getvariablecompiler   gettemplocal tmp
if  switchcases    null
// we have optimized switch cases, build a lookupswitch
sortedmap<integer  label> optimizedlabels   new treemap<integer  label>
for  map entry<compilercallback  int> entry   switchcases entryset
label lbl   new label
bodylabels put entry getkey    lbl
for  int i   entry getvalue
optimizedlabels put i  lbl
int casevalues   new int
label caselabels   new label
set<map entry<integer  label>> entryset   optimizedlabels entryset
iterator<map entry<integer  label>> iterator   entryset iterator
for  int i   0  i < entryset size    i
map entry<integer  label> entry   iterator next
casevalues   entry getkey
caselabels   entry getvalue
// checkcast the value; if match, fast path; otherwise proceed to slow logic
getcasevalue call this
method instance_of p fastswitchtype getassociatedclass
method ifeq slowpath
switch  fastswitchtype
case fixnum
getcasevalue call this
method checkcast p rubyfixnum class
method invokevirtual p rubyfixnum class      sig long class
method l2i
break
case single_char_string
getcasevalue call this
invokeutilitymethod    sig boolean class  irubyobject class
method ifeq slowpath
getcasevalue call this
invokeutilitymethod    sig int class  irubyobject class
break
case string
getcasevalue call this
invokeutilitymethod    sig boolean class  irubyobject class
method ifeq slowpath
getcasevalue call this
invokeutilitymethod    sig int class  irubyobject class
break
case single_char_symbol
getcasevalue call this
invokeutilitymethod    sig boolean class  irubyobject class
method ifeq slowpath
getcasevalue call this
invokeutilitymethod    sig int class  irubyobject class
break
case symbol
getcasevalue call this
invokeutilitymethod    sig boolean class  irubyobject class
method ifeq slowpath
getcasevalue call this
invokeutilitymethod    sig int class  irubyobject class
break
method lookupswitch defaultcase  casevalues  caselabels
label done   new label
// expression-based tests + bodies
label currentlabel   slowpath
for  int i   0  i < conditionals size    i
argumentscallback conditional   conditionals get i
compilercallback body   bodies get i
method label currentlabel
getinvocationcompiler   invokeeqq conditional  getcasevalue
if  i   1 < conditionals size
// normal case, create a new label
currentlabel   new label
else
// last conditional case, use defaultcase
currentlabel   defaultcase
method ifeq currentlabel
label bodylabel   bodylabels get body
if  bodylabel    null  method label bodylabel
body call this
method go_to done
// "else" body
method label currentlabel
fallback call this
method label done
getvariablecompiler   releasetemplocal