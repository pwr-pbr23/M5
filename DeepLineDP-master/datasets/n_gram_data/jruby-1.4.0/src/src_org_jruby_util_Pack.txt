/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2003-2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2005 derek berner <derek.berner@state.nm.us>
* copyright (c) 2006 evan buswell <ebuswell@gmail.com>
* copyright (c) 2007 nick sieger <nicksieger@gmail.com>
* copyright (c) 2009 joseph lafata <joe@quibb.org>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util
import java math biginteger
import java nio bytebuffer
import java nio byteorder
import org jcodings specific asciiencoding
import org jruby platform platform
import org jruby ruby
import org jruby rubyarray
import org jruby rubybignum
import org jruby rubyfixnum
import org jruby rubyfloat
import org jruby rubykernel
import org jruby rubynumeric
import org jruby rubystring
import org jruby runtime builtin irubyobject
public class pack
private static final byte ssp10     getbytes
private static final byte snil10     getbytes
private static final int is_star    1
private static final asciiencoding ascii   asciiencoding instance
/** native pack type.
**/
private static final string native_codes
private static final string mapped_codes
private static final string stoofew
private static final byte hex_table
private static final byte uu_table
private static final byte b64_table
private static final byte shexdigits
private static final int b64_xtable   new int
private static final converter converters   new converter
private static final biginteger quad_min   new biginteger    16
private static final biginteger quad_max   new biginteger    16
/*
* convert into longs, returning unsigned 64-bit values as signed longs
* ( num2long raises a rangeerror on values > long.max_value )
*/
private static long num2quad irubyobject arg
if  arg    arg getruntime   getnil
return 0l
else if  arg instanceof rubybignum
biginteger big     rubybignum arg  getvalue
if  big compareto quad_min  < 0    big compareto quad_max  > 0
throw arg getruntime   newrangeerror
return big longvalue
return rubynumeric num2long arg
private static float obj2flt ruby runtime  irubyobject o
if o instanceof rubystring
string str   o asjavastring
float f    float rubynumeric num2dbl o converttofloat
if str matches
return f
else
throw runtime newtypeerror
return  float rubykernel new_float o  o  getdoublevalue
private static double obj2dbl ruby runtime  irubyobject o
if o instanceof rubystring
string str   o asjavastring
double d   rubynumeric num2dbl o converttofloat
if str matches
return d
else
throw runtime newtypeerror
return rubykernel new_float o  o  getdoublevalue
static
hex_table   bytelist plain
uu_table
bytelist plain  #$% '        0123456789  < >?@abcdefghijklmnopqrstuvwxyz^_"
b64_table
bytelist plain
shexdigits   bytelist plain
// b64_xtable for decoding base 64
for  int i   0  i < 256  i
b64_xtable    1
for  int i   0  i < 64  i
b64_xtable]   i
// single precision, little-endian
converters   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return rubyfloat newfloat runtime  decodefloatlittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
encodefloatlittleendian result  obj2flt runtime  o
// single precision, big-endian
converters   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return rubyfloat newfloat runtime  decodefloatbigendian enc
public void encode ruby runtime  irubyobject o  bytelist result
encodefloatbigendian result  obj2flt runtime  o
// single precision, native
converter tmp   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
if  platform byte_order    platform big_endian
return rubyfloat newfloat runtime  decodefloatbigendian enc
else
return rubyfloat newfloat runtime  decodefloatlittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
if  platform byte_order    platform big_endian
encodefloatbigendian result  obj2flt runtime  o
else
encodefloatlittleendian result  obj2flt runtime  o
converters   tmp     single precision  native
converters   tmp     single precision  native
// double precision, little-endian
converters   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
return rubyfloat newfloat runtime  decodedoublelittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
encodedoublelittleendian result  obj2dbl runtime  o
// double precision, big-endian
converters   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
return rubyfloat newfloat runtime  decodedoublebigendian enc
public void encode ruby runtime  irubyobject o  bytelist result
encodedoublebigendian result  obj2dbl runtime  o
// double precision, native
tmp   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
if  platform byte_order    platform big_endian
return rubyfloat newfloat runtime  decodedoublebigendian enc
else
return rubyfloat newfloat runtime  decodedoublelittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
if  platform byte_order    platform big_endian
encodedoublebigendian result  obj2dbl runtime  o
else
encodedoublelittleendian result  obj2dbl runtime  o
converters   tmp     double precision  native
converters   tmp     double precision  native
// signed short, little-endian
converters   new converter 2
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum
decodeshortunsignedlittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
int s   o    runtime getnil   ? 0    int   num2quad o    0xffff
encodeshortlittleendian result  s
// signed short, big-endian
converters   new converter 2
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum
decodeshortunsignedbigendian enc
public void encode ruby runtime  irubyobject o  bytelist result
int s   o    runtime getnil   ? 0    int   num2quad o    0xffff
encodeshortbigendian result  s
// signed short, native
converters   new converter 2
public irubyobject decode ruby runtime  bytebuffer enc
if  platform byte_order    platform big_endian
return runtime newfixnum decodeshortbigendian enc
else
return runtime newfixnum decodeshortlittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
int s   o    runtime getnil   ? 0    int  num2quad o    0xffff      xxx  0xffff0000 on be?
if  platform byte_order    platform big_endian
encodeshortbigendian result  s
else
encodeshortlittleendian result  s
// unsigned short, native
converters   new converter 2
public irubyobject decode ruby runtime  bytebuffer enc
if  platform byte_order    platform big_endian
return runtime newfixnum decodeshortunsignedbigendian enc
else
return runtime newfixnum decodeshortunsignedlittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
int s   o    runtime getnil   ? 0    int   num2quad o    0xffff
if  platform byte_order    platform big_endian
encodeshortbigendian result  s
else
encodeshortlittleendian result  s
// signed char
converters   new converter 1
public irubyobject decode ruby runtime  bytebuffer enc
int c   enc get
return runtime newfixnum c >  char  127 ? c 256   c
public void encode ruby runtime  irubyobject o  bytelist result
byte c   o    runtime getnil   ? 0    byte   rubynumeric num2long o    0xff
result append c
// unsigned char
converters   new converter 1
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum enc get     0xff
public void encode ruby runtime  irubyobject o  bytelist result
byte c   o    runtime getnil   ? 0    byte   rubynumeric num2long o    0xff
result append c
// long, little-endian
converters   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum
decodeintunsignedlittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
int s   o    runtime getnil   ? 0    int  rubynumeric num2long o
encodeintlittleendian result  s
// long, big-endian
converters   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum
decodeintunsignedbigendian enc
public void encode ruby runtime  irubyobject o  bytelist result
int s   o    runtime getnil   ? 0    int  rubynumeric num2long o
encodeintbigendian result  s
// unsigned int, native
tmp   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
if  platform byte_order    platform big_endian
return runtime newfixnum decodeintunsignedbigendian enc
else
return runtime newfixnum decodeintunsignedlittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
int s   o    runtime getnil   ? 0    int  rubynumeric num2long o
if  platform byte_order    platform big_endian
encodeintbigendian result  s
else
encodeintlittleendian result  s
converters   tmp     unsigned int  native
converters   tmp     unsigned long  native
// int, native
tmp   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
if  platform byte_order    platform big_endian
return runtime newfixnum decodeintbigendian enc
else
return runtime newfixnum decodeintlittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
int s   o    runtime getnil   ? 0    int rubynumeric num2long o
if  platform byte_order    platform big_endian
encodeintbigendian result  s
else
encodeintlittleendian result  s
converters   tmp     int  native
converters   tmp     long  native
// 64-bit number, native (as bignum)
converters   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
long l
if  platform byte_order    platform big_endian
l   decodelongbigendian enc
else
l   decodelonglittleendian enc
return rubybignum bignorm runtime biginteger valueof l  and
new biginteger    16
public void encode ruby runtime  irubyobject o  bytelist result
long l   num2quad o
if  platform byte_order    platform big_endian
encodelongbigendian result  l
else
encodelonglittleendian result  l
// 64-bit number, native (as fixnum)
converters   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
if  platform byte_order    platform big_endian
return runtime newfixnum decodelongbigendian enc
else
return runtime newfixnum decodelonglittleendian enc
public void encode ruby runtime  irubyobject o  bytelist result
long l   num2quad o
if  platform byte_order    platform big_endian
encodelongbigendian result  l
else
encodelonglittleendian result  l
/**
* encodes a string in base64 or its uuencode variant.
* appends the result of the encoding in a stringbuffer
* @param io2append the stringbuffer which should receive the result
* @param i2encode the string to encode
* @param ilength the max number of characters to encode
* @param itype the type of encoding required (this is the same type as used by the pack method)
* @return the io2append buffer
**/
private static bytelist encodes ruby runtime  bytelist io2append bytecharstoencode  int startindex  int length  int charcount  byte encodingtype
charcount   charcount < length ? charcount   length
io2append ensure charcount   4   3   6
int i   startindex
byte ltranslationtable   encodingtype      ? uu_table   b64_table
byte lpadding
if  encodingtype
if  charcount >  ltranslationtable length
throw runtime newargumenterror
charcount
ltranslationtable length
io2append append ltranslationtable
lpadding
else
lpadding
while  charcount >  3
byte lcurchar   charstoencode
byte lnextchar   charstoencode
byte lnextnextchar   charstoencode
io2append append ltranslationtable
io2append append ltranslationtable
io2append append ltranslationtable
io2append append ltranslationtable
charcount    3
if  charcount    2
byte lcurchar   charstoencode
byte lnextchar   charstoencode
io2append append ltranslationtable
io2append append ltranslationtable
io2append append ltranslationtable
io2append append lpadding
else if  charcount    1
byte lcurchar   charstoencode
io2append append ltranslationtable
io2append append ltranslationtable
io2append append lpadding
io2append append lpadding
io2append append
return io2append
/**
* encodes a string with the quoted printable, mime encoding (see rfc2045).
* appends the result of the encoding in a stringbuffer
* @param io2append the stringbuffer which should receive the result
* @param i2encode the string to encode
* @param ilength the max number of characters to encode
* @return the io2append buffer
**/
private static bytelist qpencode bytelist io2append  bytelist i2encode  int ilength
io2append ensure 1024
int lcurlinelength   0
int lprevchar    1
byte l2encode   i2encode bytes
try
int end   i2encode begin   i2encode realsize
for  int i   i2encode begin  i < end  i
int lcurchar   l2encode   0xff
if  lcurchar > 126     lcurchar < 32    lcurchar         lcurchar          lcurchar
io2append append
io2append append hex_table
io2append append hex_table
lcurlinelength    3
lprevchar    1
else if  lcurchar
if  lprevchar         lprevchar
io2append append
io2append append lcurchar
io2append append lcurchar
lcurlinelength   0
lprevchar   lcurchar
else
io2append append lcurchar
lcurlinelength
lprevchar   lcurchar
if  lcurlinelength > ilength
io2append append
io2append append
lcurlinelength   0
lprevchar
catch  arrayindexoutofboundsexception e
//normal exit, this should be faster than a test at each iterations for string with more than
//about 40 char
if  lcurlinelength > 0
io2append append
io2append append
return io2append
/**
*    decodes <i>str</i> (which may contain binary data) according to the format
*       string, returning an array of each value extracted.
*       the format string consists of a sequence of single-character directives.<br/>
*       each directive may be followed by a number, indicating the number of times to repeat with this directive.  an asterisk (``<code>*</code>'') will use up all
*       remaining elements.  <br/>
*       the directives <code>ssiill</code> may each be followed by an underscore (``<code>_</code>'') to use the underlying platform's native size for the specified type; otherwise, it uses a platform-independent consistent size.  <br/>
*       spaces are ignored in the format string.
*           @see rubyarray#pack
*       <table border="2" width="500" bgcolor="#ffe0e0">
*           <tr>
*             <td>
* <p></p>
*         <b>directives for <a href="ref_c_string.html#string.unpack">
*                   <code>string#unpack</code>
*                 </a>
*               </b>        <table class="codebox" cellspacing="0" border="0" cellpadding="3">
* <tr bgcolor="#ff9999">
*   <td valign="top">
*                     <b>format</b>
*                   </td>
*   <td valign="top">
*                     <b>function</b>
*                   </td>
*   <td valign="top">
*                     <b>returns</b>
*                   </td>
* </tr>
* <tr>
*   <td valign="top">a</td>
*   <td valign="top">string with trailing nulls and spaces removed.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">a</td>
*   <td valign="top">string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">b</td>
*   <td valign="top">extract bits from each character (msb first).</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">b</td>
*   <td valign="top">extract bits from each character (lsb first).</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">c</td>
*   <td valign="top">extract a character as an unsigned integer.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">c</td>
*   <td valign="top">extract a character as an integer.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">d</td>
*   <td valign="top">treat <em>sizeof(double)</em> characters as a native
*           double.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">e</td>
*   <td valign="top">treat <em>sizeof(double)</em> characters as a double in
*           little-endian byte order.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">e</td>
*   <td valign="top">treat <em>sizeof(float)</em> characters as a float in
*           little-endian byte order.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">f</td>
*   <td valign="top">treat <em>sizeof(float)</em> characters as a native float.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">g</td>
*   <td valign="top">treat <em>sizeof(double)</em> characters as a double in
*           network byte order.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">g</td>
*   <td valign="top">treat <em>sizeof(float)</em> characters as a float in
*           network byte order.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">h</td>
*   <td valign="top">extract hex nibbles from each character (most
*           significant first).</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">h</td>
*   <td valign="top">extract hex nibbles from each character (least
*           significant first).</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">i</td>
*   <td valign="top">treat <em>sizeof(int)</em>
*                     <sup>1</sup> successive
*           characters as an unsigned native integer.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">i</td>
*   <td valign="top">treat <em>sizeof(int)</em>
*                     <sup>1</sup> successive
*           characters as a signed native integer.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">l</td>
*   <td valign="top">treat four<sup>1</sup> successive
*           characters as an unsigned native
*           long integer.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">l</td>
*   <td valign="top">treat four<sup>1</sup> successive
*           characters as a signed native
*           long integer.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">m</td>
*   <td valign="top">extract a quoted-printable string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">m</td>
*   <td valign="top">extract a base64 encoded string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">n</td>
*   <td valign="top">treat four characters as an unsigned long in network
*           byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">n</td>
*   <td valign="top">treat two characters as an unsigned short in network
*           byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">p</td>
*   <td valign="top">treat <em>sizeof(char *)</em> characters as a pointer, and
*           return <em>len</em> characters from the referenced location.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">p</td>
*   <td valign="top">treat <em>sizeof(char *)</em> characters as a pointer to a
*           null-terminated string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">s</td>
*   <td valign="top">treat two<sup>1</sup> successive characters as an unsigned
*           short in
*           native byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">s</td>
*   <td valign="top">treat two<sup>1</sup> successive
*           characters as a signed short in
*           native byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">u</td>
*   <td valign="top">extract utf-8 characters as unsigned integers.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">u</td>
*   <td valign="top">extract a uu-encoded string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">v</td>
*   <td valign="top">treat four characters as an unsigned long in little-endian
*           byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">v</td>
*   <td valign="top">treat two characters as an unsigned short in little-endian
*           byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">x</td>
*   <td valign="top">skip backward one character.</td>
*   <td valign="top">---</td>
* </tr>
* <tr>
*   <td valign="top">x</td>
*   <td valign="top">skip forward one character.</td>
*   <td valign="top">---</td>
* </tr>
* <tr>
*   <td valign="top">z</td>
*   <td valign="top">string with trailing nulls removed.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">@</td>
*   <td valign="top">skip to the offset given by the length argument.</td>
*   <td valign="top">---</td>
* </tr>
* <tr>
*                   <td colspan="9" bgcolor="#ff9999" height="2"><img src="dot.gif" width="1" height="1"></td>
*                 </tr>
*               </table>
* <p></p>
*         <sup>1</sup>&nbsp;may be modified by appending ``_'' to the directive.
* <p></p>
*       </td>
*           </tr>
*         </table>
*
**/
public static rubyarray unpack ruby runtime  bytelist encodedstring  bytelist formatstring
rubyarray result   runtime newarray
// fixme: potentially could just use bytelist here?
bytebuffer format   bytebuffer wrap formatstring unsafebytes    formatstring begin    formatstring length
bytebuffer encode   bytebuffer wrap encodedstring unsafebytes    encodedstring begin    encodedstring length
int type   0
int next   safeget format
while  next    0
type   next
next   safeget format
// next indicates to decode using native encoding format
if  next         next
int index   native_codes indexof type
if  index     1
throw runtime newargumenterror     next
native_codes
type   mapped_codes charat index
next   safeget format
// how many occurrences of 'type' we want
int occurrences   0
if  next    0
occurrences   1
else
if  next
occurrences   is_star
next   safeget format
else if  ascii isdigit next
occurrences   0
do
occurrences   occurrences   10   character digit  char  next   0xff   10
next   safeget format
while  next    0    ascii isdigit next
else
occurrences   type      ? 0   1
// see if we have a converter for the job...
converter converter   converters
if  converter    null
decode runtime  encode  occurrences  result  converter
type   next
continue
// otherwise the unpack should be here...
switch  type
case
try
if  occurrences    is_star
encode position encode remaining
else
encode position occurrences
catch  illegalargumentexception iae
throw runtime newargumenterror
break
case
throw runtime newargumenterror
case
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
byte potential   new byte
encode get potential
for  int t   occurrences   1  occurrences > 0  occurrences    t
byte c   potential
if  c         c
break
result append rubystring newstring runtime  new bytelist potential  0  occurrences false
break
case
boolean isstar    occurrences    is_star
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
byte potential   new byte
int t   0
while  t < occurrences
byte b   encode get
if  b    0
break
potential   b
t
result append rubystring newstring runtime  new bytelist potential  0  t  false
// in case when the number of occurences is
// explicitly specified, we have to read up
// the remaining garbage after the '\0' to
// satisfy the requested pattern.
if   isstar
if  t < occurrences
// we encountered '\0' when
// were reading the buffer above,
// increment the number of read bytes.
t
while  t < occurrences
encode get
t
break
case
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
byte potential   new byte
encode get potential
result append rubystring newstring runtime  new bytelist potential  false
break
case
if  occurrences    is_star    occurrences > encode remaining     8
occurrences   encode remaining     8
int bits   0
byte lelem   new byte
for  int lcurbyte   0  lcurbyte < occurrences  lcurbyte
if   lcurbyte   7     0
bits >>>  1
else
bits   encode get
lelem    bits   1     0 ?  byte      byte
result append rubystring newstring runtime  new bytelist lelem  false
break
case
if  occurrences    is_star    occurrences > encode remaining     8
occurrences   encode remaining     8
int bits   0
byte lelem   new byte
for  int lcurbyte   0  lcurbyte < occurrences  lcurbyte
if   lcurbyte   7     0
bits <<  1
else
bits   encode get
lelem    bits   128     0 ?  byte      byte
result append rubystring newstring runtime  new bytelist lelem  false
break
case
if  occurrences    is_star    occurrences > encode remaining     2
occurrences   encode remaining     2
int bits   0
byte lelem   new byte
for  int lcurbyte   0  lcurbyte < occurrences  lcurbyte
if   lcurbyte   1     0
bits >>>  4
else
bits   encode get
lelem   shexdigits
result append rubystring newstring runtime  new bytelist lelem  false
break
case
if  occurrences    is_star    occurrences > encode remaining     2
occurrences   encode remaining     2
int bits   0
byte lelem   new byte
for  int lcurbyte   0  lcurbyte < occurrences  lcurbyte
if   lcurbyte   1     0
bits <<  4
else
bits   encode get
lelem   shexdigits
result append rubystring newstring runtime  new bytelist lelem  false
break
case
int length   encode remaining     3   4
byte lelem   new byte
int index   0
int s
int total   0
s   encode get
while  encode hasremaining      s >      s <
int a  b  c  d
byte hunk   new byte
int len    s        077
s   safeget encode
total    len
if  total > length
len    total   length
total   length
while  len > 0
int mlen   len > 3 ? 3   len
if  encode hasremaining      s >
a    s        077
s   safeget encode
else
a   0
if  encode hasremaining      s >
b    s        077
s   safeget encode
else
b   0
if  encode hasremaining      s >
c    s        077
s   safeget encode
else
c   0
if  encode hasremaining      s >
d    s        077
s   safeget encode
else
d   0
hunk    byte   a << 2   b >> 4    255
hunk    byte   b << 4   c >> 2    255
hunk    byte   c << 6   d    255
for  int i   0  i < mlen  i    lelem   hunk
len    mlen
if  s
s   safeget encode
if  s
s   safeget encode
else if  encode hasremaining
if  safeget encode
safeget encode      possible checksum byte
else if  encode hasremaining
encode position encode position     1
result append rubystring newstring runtime  new bytelist lelem  0  index  false
break
case
int length   encode remaining   3 4
byte lelem   new byte
int a    1  b    1  c   0  d
int index   0
int s    1
while  encode hasremaining
a   b   c   d    1
// obtain a
s   safeget encode
while    a   b64_xtable      1     encode hasremaining
s   safeget encode
if  a     1  break
// obtain b
s   safeget encode
while    b   b64_xtable      1     encode hasremaining
s   safeget encode
if  b     1  break
// obtain c
s   safeget encode
while    c   b64_xtable      1     encode hasremaining
if  s       break
s   safeget encode
if   s          c     1
if  s
encode position encode position     1
break
// obtain d
s   safeget encode
while    d   b64_xtable      1     encode hasremaining
if  s       break
s   safeget encode
if   s          d     1
if  s
encode position encode position     1
break
// calculate based on a, b, c and d
lelem    byte   a << 2   b >> 4    255
lelem    byte   b << 4   c >> 2    255
lelem    byte   c << 6   d    255
if  a     1    b     1
if  c     1    s
lelem    byte   a << 2   b >> 4    255
else if c     1    s
lelem    byte   a << 2   b >> 4    255
lelem    byte   b << 4   c >> 2    255
result append rubystring newstring runtime  new bytelist lelem  0  index  false
break
case
byte lelem   new byte
int index   0
for
if   encode hasremaining    break
int c   safeget encode
if  c
lelem    byte c
else
if   encode hasremaining    break
encode mark
int c1   safeget encode
if  c1       continue
int d1   character digit c1  16
if  d1     1
encode reset
break
encode mark
if   encode hasremaining    break
int c2   safeget encode
int d2   character digit c2  16
if  d2     1
encode reset
break
byte value    byte  d1 << 4   d2
lelem   value
result append rubystring newstring runtime  new bytelist lelem  0  index  false
break
case
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
while  occurrences   > 0    encode remaining   > 0
try
// todo: for now, we use a faithful
// reimplementation of mri's algorithm,
// but should use utf8encoding facilities
// from joni, once it starts prefroming
// utf-8 content validation.
result append
runtime newfixnum utf8decode encode
catch  illegalargumentexception e
throw runtime newargumenterror e getmessage
break
case
if  occurrences    is_star
// mri behavior: contrary to what seems to be logical,
// when '*' is given, mri calculates the distance
// to the end, in order to go backwards.
occurrences     encode limit       encode remaining
try
encode position encode position     occurrences
catch  illegalargumentexception e
throw runtime newargumenterror
break
case
if  occurrences    is_star
occurrences   encode remaining
try
encode position encode position     occurrences
catch  illegalargumentexception e
throw runtime newargumenterror
break
case
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
long ul   0
long ulmask    0xfe << 56    0xffffffff
rubybignum big128   rubybignum newbignum runtime  128
int pos   encode position
while  occurrences > 0    pos < encode limit
ul <<  7
ul    encode get pos    0x7f
if  encode get pos      0x80     0
result append rubyfixnum newfixnum runtime  ul
occurrences
ul   0
else if  ul   ulmask     0
rubybignum big   rubybignum newbignum runtime  ul
while occurrences > 0    pos < encode limit
big    rubybignum big op_mul runtime getcurrentcontext    big128
irubyobject v   big op_plus runtime getcurrentcontext
rubybignum newbignum runtime  encode get pos    0x7f
if v instanceof rubyfixnum
big   rubybignum newbignum runtime  rubynumeric fix2long v
else if  v instanceof rubybignum
big    rubybignum v
if  encode get pos      0x80     0
result add big
occurrences
ul   0
break
try
encode position pos
catch  illegalargumentexception e
throw runtime newargumenterror
break
return result
/** rb_uv_to_utf8
*
*/
public static int utf8decode ruby runtime  byteto  int p  int code
if  code <  0x7f
to    byte code
return 1
if  code <  0x7ff
to    byte    code >>> 6    0xff    0xc0
to    byte   code   0x3f    0x80
return 2
if  code <  0xffff
to    byte    code >>> 12    0xff    0xe0
to    byte    code >>> 6    0x3f    0x80
to    byte   code   0x3f    0x80
return 3
if  code <  0x1fffff
to    byte    code >>> 18    0xff    0xf0
to    byte    code >>> 12    0x3f    0x80
to    byte    code >>> 6    0x3f    0x80
to    byte   code   0x3f    0x80
return 4
if  code <  0x3ffffff
to    byte    code >>> 24    0xff    0xf8
to    byte    code >>> 18    0x3f    0x80
to    byte    code >>> 12    0x3f    0x80
to    byte    code >>> 6    0x3f    0x80
to    byte   code   0x3f    0x80
return 5
if  code <  0x7fffffff
to    byte    code >>> 30    0xff    0xfc
to    byte    code >>> 24    0x3f    0x80
to    byte    code >>> 18    0x3f    0x80
to    byte    code >>> 12    0x3f    0x80
to    byte    code >>> 6    0x3f    0x80
to    byte   code   0x3f    0x80
return 6
throw runtime newrangeerror
/** utf8_to_uv
*/
private static int utf8decode bytebuffer buffer
int c   buffer get     0xff
int uv   c
int n
if   c   0x80     0
return c
if   c   0x40     0
throw new illegalargumentexception
if        uv   0x20     0    n   2  uv    0x1f
else if   uv   0x10     0    n   3  uv    0x0f
else if   uv   0x08     0    n   4  uv    0x07
else if   uv   0x04     0    n   5  uv    0x03
else if   uv   0x02     0    n   6  uv    0x01
else
throw new illegalargumentexception
if  n > buffer remaining     1
throw new illegalargumentexception
n
buffer remaining     1
int limit   n   1
n
if  n    0
while  n      0
c   buffer get     0xff
if   c   0xc0     0x80
throw new illegalargumentexception
else
c    0x3f
uv   uv << 6   c
if  uv < utf8_limits
throw new illegalargumentexception
return uv
private static final long utf8_limits
0x0                            1
0x80                           2
0x800                          3
0x10000                        4
0x200000                       5
0x4000000                      6
0x80000000                     7
private static int safeget bytebuffer encode
return encode hasremaining   ? encode get     0xff   0
public static void decode ruby runtime  bytebuffer encode  int occurrences
rubyarray result  converter converter
int lpadlength   0
if  occurrences    is_star
occurrences   encode remaining     converter size
else if  occurrences > encode remaining     converter size
lpadlength   occurrences   encode remaining     converter size
occurrences   encode remaining     converter size
for    occurrences   > 0
result append converter decode runtime  encode
// mri behavior:  for 'q', do not add trailing nils
if  converter    converters
for    lpadlength   > 0
result append runtime getnil
public static int encode ruby runtime  int occurrences  bytelist result
rubyarray list  int index  converter converter
int listsize   list size
while  occurrences   > 0
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal index
converter encode runtime  from  result
return index
public abstract static class converter
public int size
public converter int size
this size   size
public abstract irubyobject decode ruby runtime  bytebuffer format
public abstract void encode ruby runtime  irubyobject from  bytelist result
/**
* shrinks a stringbuffer.
* shrinks a stringbuffer by a number of characters.
* @param i2shrink the stringbuffer
* @param ilength how much to shrink
* @return the stringbuffer
**/
private static final bytelist shrink bytelist i2shrink  int ilength
ilength   i2shrink length     ilength
if  ilength < 0
throw new illegalargumentexception
i2shrink length ilength
return i2shrink
/**
* grows a stringbuffer.
* uses the strings to pad the buffer for a certain length
* @param i2grow the buffer to grow
* @param ipads the string used as padding
* @param ilength how much padding is needed
* @return the padded buffer
**/
private static final bytelist grow bytelist i2grow  byteipads  int ilength
int lpadlength   ipads length
while  ilength >  lpadlength
i2grow append ipads
ilength    lpadlength
i2grow append ipads  0  ilength
return i2grow
/**
* pack_pack
*
* template characters for array#pack directive  meaning
*              <table class="codebox" cellspacing="0" border="0" cellpadding="3">
* <tr bgcolor="#ff9999">
*   <td valign="top">
*                     <b>directive</b>
*                   </td>
*   <td valign="top">
*                     <b>meaning</b>
*                   </td>
* </tr>
* <tr>
*   <td valign="top">@</td>
*   <td valign="top">moves to absolute position</td>
* </tr>
* <tr>
*   <td valign="top">a</td>
*   <td valign="top">ascii string (space padded, count is width)</td>
* </tr>
* <tr>
*   <td valign="top">a</td>
*   <td valign="top">ascii string (null padded, count is width)</td>
* </tr>
* <tr>
*   <td valign="top">b</td>
*   <td valign="top">bit string (descending bit order)</td>
* </tr>
* <tr>
*   <td valign="top">b</td>
*   <td valign="top">bit string (ascending bit order)</td>
* </tr>
* <tr>
*   <td valign="top">c</td>
*   <td valign="top">unsigned char</td>
* </tr>
* <tr>
*   <td valign="top">c</td>
*   <td valign="top">char</td>
* </tr>
* <tr>
*   <td valign="top">d</td>
*   <td valign="top">double-precision float, native format</td>
* </tr>
* <tr>
*   <td valign="top">e</td>
*   <td valign="top">double-precision float, little-endian byte order</td>
* </tr>
* <tr>
*   <td valign="top">e</td>
*   <td valign="top">single-precision float, little-endian byte order</td>
* </tr>
* <tr>
*   <td valign="top">f</td>
*   <td valign="top">single-precision float, native format</td>
* </tr>
* <tr>
*   <td valign="top">g</td>
*   <td valign="top">double-precision float, network (big-endian) byte order</td>
* </tr>
* <tr>
*   <td valign="top">g</td>
*   <td valign="top">single-precision float, network (big-endian) byte order</td>
* </tr>
* <tr>
*   <td valign="top">h</td>
*   <td valign="top">hex string (high nibble first)</td>
* </tr>
* <tr>
*   <td valign="top">h</td>
*   <td valign="top">hex string (low nibble first)</td>
* </tr>
* <tr>
*   <td valign="top">i</td>
*   <td valign="top">unsigned integer</td>
* </tr>
* <tr>
*   <td valign="top">i</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">l</td>
*   <td valign="top">unsigned long</td>
* </tr>
* <tr>
*   <td valign="top">l</td>
*   <td valign="top">long</td>
* </tr>
* <tr>
*   <td valign="top">m</td>
*   <td valign="top">quoted printable, mime encoding (see rfc2045)</td>
* </tr>
* <tr>
*   <td valign="top">m</td>
*   <td valign="top">base64 encoded string</td>
* </tr>
* <tr>
*   <td valign="top">n</td>
*   <td valign="top">long, network (big-endian) byte order</td>
* </tr>
* <tr>
*   <td valign="top">n</td>
*   <td valign="top">short, network (big-endian) byte-order</td>
* </tr>
* <tr>
*   <td valign="top">p</td>
*   <td valign="top">pointer to a structure (fixed-length string)</td>
* </tr>
* <tr>
*   <td valign="top">p</td>
*   <td valign="top">pointer to a null-terminated string</td>
* </tr>
* <tr>
*   <td valign="top">q</td>
*   <td valign="top">unsigned 64-bit number</td>
* </tr>
* <tr>
*   <td valign="top">q</td>
*   <td valign="top">64-bit number</td>
* </tr>
* <tr>
*   <td valign="top">s</td>
*   <td valign="top">unsigned short</td>
* </tr>
* <tr>
*   <td valign="top">s</td>
*   <td valign="top">short</td>
* </tr>
* <tr>
*   <td valign="top">u</td>
*   <td valign="top">utf-8</td>
* </tr>
* <tr>
*   <td valign="top">u</td>
*   <td valign="top">uu-encoded string</td>
* </tr>
* <tr>
*   <td valign="top">v</td>
*   <td valign="top">long, little-endian byte order</td>
* </tr>
* <tr>
*   <td valign="top">v</td>
*   <td valign="top">short, little-endian byte order</td>
* </tr>
* <tr>
*   <td valign="top">x</td>
*   <td valign="top">back up a byte</td>
* </tr>
* <tr>
*   <td valign="top">x</td>
*   <td valign="top">null byte</td>
* </tr>
* <tr>
*   <td valign="top">z</td>
*   <td valign="top">same as ``a''</td>
* </tr>
* <tr>
*                   <td colspan="9" bgcolor="#ff9999" height="2"><img src="dot.gif" width="1" height="1"></td>
*                 </tr>
*               </table>
*
*
* packs the contents of arr into a binary sequence according to the directives in
* atemplatestring (see preceding table).
* directives ``a,'' ``a,'' and ``z'' may be followed by a count, which gives the
* width of the resulting field.
* the remaining directives also may take a count, indicating the number of array
* elements to convert.
* if the count is an asterisk (``*''] = all remaining array elements will be
* converted.
* any of the directives ``ssiill'' may be followed by an underscore (``_'') to use
* the underlying platform's native size for the specified type; otherwise, they
* use a platform-independent size. spaces are ignored in the template string.
* @see rubystring#unpack
**/
@suppresswarnings
public static rubystring pack ruby runtime  rubyarray list  bytelist formatstring
bytebuffer format   bytebuffer wrap formatstring unsafebytes    formatstring begin    formatstring length
bytelist result   new bytelist
boolean taintoutput   false
int listsize   list size
int type   0
int next   safeget format
int idx   0
bytelist lcurelemstring
mainloop  while  next    0
type   next
next   safeget format
// skip all whitespace in pack format string
while  ascii isspace type
if  next    0  break mainloop
type   next
next   safeget format
// skip embedded comments in pack format string
if  type
while  type
if  next    0  break mainloop
type   next
next   safeget format
if  next         next
int index   native_codes indexof type
if  index     1
throw runtime newargumenterror     next
native_codes
type   mapped_codes charat index
next   safeget format
// determine how many of type are needed (default: 1)
int occurrences   1
boolean isstar   false
if  next    0
if  next
if    indexof type      1
occurrences   0
else
occurrences   list size     idx
isstar   true
next   safeget format
else if  ascii isdigit next
occurrences   0
do
occurrences   occurrences   10   character digit  char  next   0xff   10
next   safeget format
while  next    0    ascii isdigit next
converter converter   converters
if  converter    null
idx   encode runtime  occurrences  result  list  idx  converter
continue
switch  type
case
throw runtime newargumenterror
case
case
case
case
case
case
case
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
if from istaint
taintoutput   true
lcurelemstring   from    runtime getnil   ? bytelist empty_bytelist   from converttostring   getbytelist
if  isstar
occurrences   lcurelemstring length
// 'z' adds extra null pad (versus 'a')
if  type       occurrences
switch  type
case
case
case
if  lcurelemstring length   >  occurrences
result append lcurelemstring bytes  lcurelemstring begin  occurrences
else    need padding
//i'm fairly sure there is a library call to create a
//string filled with a given char with a given length but i couldn't find it
result append lcurelemstring
occurrences    lcurelemstring length
switch  type
case
case
grow result  snil10  occurrences
break
default
grow result  ssp10  occurrences
break
break
case
int currentbyte   0
int padlength   0
if  occurrences > lcurelemstring length
padlength    occurrences   lcurelemstring length      2   occurrences % 2
occurrences   lcurelemstring length
for  int i   0  i < occurrences
if   lcurelemstring charat i      1     0     if the low bit is set
currentbyte    128    set the high bit of the result
if   i   7     0
result append  byte   currentbyte   0xff
currentbyte   0
continue
//if the index is not a multiple of 8, we are not on a byte boundary
currentbyte >>  1    shift the byte
if   occurrences   7     0      if the length is not a multiple of 8
currentbyte >>  7    occurrences   7     we need to pad the last byte
result append  byte   currentbyte   0xff
//do some padding, i don't understand the padding strategy
result length result length     padlength
break
case
int currentbyte   0
int padlength   0
if  occurrences > lcurelemstring length
padlength    occurrences   lcurelemstring length      2   occurrences % 2
occurrences   lcurelemstring length
for  int i   0  i < occurrences
currentbyte    lcurelemstring charat i      1
// we filled up current byte; append it and create next one
if   i   7     0
result append  byte   currentbyte   0xff
currentbyte   0
continue
//if the index is not a multiple of 8, we are not on a byte boundary
currentbyte <<  1
if   occurrences   7     0      if the length is not a multiple of 8
currentbyte <<  7    occurrences   7     we need to pad the last byte
result append  byte   currentbyte   0xff
result length result length     padlength
break
case
int currentbyte   0
int padlength   0
if  occurrences > lcurelemstring length
padlength   occurrences   lcurelemstring length     1
occurrences   lcurelemstring length
for  int i   0  i < occurrences
byte currentchar    byte lcurelemstring charat i
if  character isjavaidentifierstart currentchar
//this test may be too lax but it is the same as in mri
currentbyte       currentchar   15    9    15  << 4
else
currentbyte     currentchar   15  << 4
if   i   1     0
currentbyte >>  4
else
result append  byte   currentbyte   0xff
currentbyte   0
if   occurrences   1     0
result append  byte   currentbyte   0xff
if padlength > 0
padlength
result length result length     padlength   2
break
case
int currentbyte   0
int padlength   0
if  occurrences > lcurelemstring length
padlength   occurrences   lcurelemstring length     1
occurrences   lcurelemstring length
for  int i   0  i < occurrences
byte currentchar    byte lcurelemstring charat i
if  character isjavaidentifierstart currentchar
//this test may be too lax but it is the same as in mri
currentbyte      currentchar   15    9    15
else
currentbyte    currentchar   15
if   i   1     0
currentbyte <<  4
else
result append  byte   currentbyte   0xff
currentbyte   0
if   occurrences   1     0
result append  byte   currentbyte   0xff
if padlength > 0
padlength
result length result length     padlength   2
break
break
case
grow result  snil10  occurrences
break
case
try
shrink result  occurrences
catch  illegalargumentexception e
throw runtime newargumenterror
break
case
occurrences    result length
if  occurrences > 0
grow result  snil10  occurrences
occurrences    occurrences
if  occurrences > 0
shrink result  occurrences
break
case
case
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
lcurelemstring   from    runtime getnil   ? bytelist empty_bytelist   from converttostring   getbytelist
occurrences   occurrences <  2 ? 45   occurrences   3   3
if  lcurelemstring length      0  break
byte charstoencode   lcurelemstring bytes
for  int i   0  i < lcurelemstring length    i    occurrences
encodes runtime  result  charstoencode
i   lcurelemstring begin  lcurelemstring length     i
occurrences   byte type
break
case
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
lcurelemstring   from    runtime getnil   ? bytelist empty_bytelist   from asstring   getbytelist
if  occurrences <  1
occurrences   72
qpencode result  lcurelemstring  occurrences
break
case
while  occurrences   > 0
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
int code   from    runtime getnil   ? 0   rubynumeric num2int from
if  code < 0
throw runtime newrangeerror
result ensure result realsize   6
result realsize    utf8decode runtime  result bytes  result begin   result realsize  code
break
case
while  occurrences   > 0
if  listsize   <  0
throw runtime newargumenterror stoofew
bytelist buf   new bytelist
irubyobject from   list eltinternal idx
if from isnil
throw runtime newtypeerror
if from instanceof rubybignum
rubybignum big128   rubybignum newbignum runtime  128
while  from instanceof rubybignum
rubybignum bignum    rubybignum from
rubyarray ary    rubyarray bignum divmod runtime getcurrentcontext    big128
buf append  byte  rubynumeric fix2int ary at rubyfixnum one runtime      0x80    0xff
from   ary at rubyfixnum zero runtime
long l   rubynumeric num2long from
// we don't deal with negatives.
if  l >  0
while l    0
buf append  byte    l   0x7f    0x80    0xff
l >>  7
int left   0
int right   buf realsize   1
if right >  0
buf bytes    0x7f
else
buf append 0
while left < right
byte tmp   buf bytes
buf bytes   buf bytes
buf bytes   tmp
left
right
result append buf
else
throw runtime newargumenterror
break
rubystring output   runtime newstring result
if taintoutput
output taint runtime getcurrentcontext
return output
/**
* retrieve an encoded int in little endian starting at index in the
* string value.
*
* @param encode string to get int from
* @return the decoded integer
*/
private static int decodeintlittleendian bytebuffer encode
encode order byteorder little_endian
int value   encode getint
encode order byteorder big_endian
return value
/**
* retrieve an encoded int in little endian starting at index in the
* string value.
*
* @param encode string to get int from
* @return the decoded integer
*/
private static int decodeintbigendian bytebuffer encode
return encode getint
/**
* retrieve an encoded int in big endian starting at index in the string
* value.
*
* @param encode string to get int from
* @return the decoded integer
*/
private static long decodeintunsignedbigendian bytebuffer encode
return  long encode getint     0xffffffffl
/**
* retrieve an encoded int in little endian starting at index in the
* string value.
*
* @param encode the encoded string
* @return the decoded integer
*/
private static long decodeintunsignedlittleendian bytebuffer encode
encode order byteorder little_endian
long value   encode getint     0xffffffffl
encode order byteorder big_endian
return value
/**
* encode an int in little endian format into a packed representation.
*
* @param result to be appended to
* @param s the integer to encode
*/
private static void encodeintlittleendian bytelist result  int s
result append  byte   s   0xff   append  byte    s >> 8    0xff
result append  byte    s>>16    0xff   append  byte    s>>24   0xff
/**
* encode an int in big-endian format into a packed representation.
*
* @param result to be appended to
* @param s the integer to encode
*/
private static void encodeintbigendian bytelist result  int s
result append  byte    s>>24   0xff   append  byte    s>>16   0xff
result append  byte    s >> 8    0xff   append  byte   s   0xff
/**
* decode a long in big-endian format from a packed value
*
* @param encode string to get int from
* @return the long value
*/
private static long decodelongbigendian bytebuffer encode
int c1   decodeintbigendian encode
int c2   decodeintbigendian encode
return   long  c1 << 32     c2   0xffffffffl
/**
* decode a long in little-endian format from a packed value
*
* @param encode string to get int from
* @return the long value
*/
private static long decodelonglittleendian bytebuffer encode
int c1   decodeintlittleendian encode
int c2   decodeintlittleendian encode
return   long  c2 << 32     c1   0xffffffffl
/**
* encode a long in little-endian format into a packed value
*
* @param result to pack long into
* @param l is the long to encode
*/
private static void encodelonglittleendian bytelist result  long l
encodeintlittleendian result   int   l   0xffffffff
encodeintlittleendian result   int   l >>> 32
/**
* encode a long in big-endian format into a packed value
*
* @param result to pack long into
* @param l is the long to encode
*/
private static void encodelongbigendian bytelist result  long l
encodeintbigendian result   int   l >>> 32
encodeintbigendian result   int   l   0xffffffff
/**
* decode a double from a packed value
*
* @param encode string to get int from
* @return the double value
*/
private static double decodedoublelittleendian bytebuffer encode
return double longbitstodouble decodelonglittleendian encode
/**
* decode a double in big-endian from a packed value
*
* @param encode string to get int from
* @return the double value
*/
private static double decodedoublebigendian bytebuffer encode
return double longbitstodouble decodelongbigendian encode
/**
* encode a double in little endian format into a packed value
*
* @param result to pack double into
* @param d is the double to encode
*/
private static void encodedoublelittleendian bytelist result  double d
encodelonglittleendian result  double doubletorawlongbits d
/**
* encode a double in big-endian format into a packed value
*
* @param result to pack double into
* @param d is the double to encode
*/
private static void encodedoublebigendian bytelist result  double d
encodelongbigendian result  double doubletorawlongbits d
/**
* decode a float in big-endian from a packed value
*
* @param encode string to get int from
* @return the double value
*/
private static float decodefloatbigendian bytebuffer encode
return float intbitstofloat decodeintbigendian encode
/**
* decode a float in little-endian from a packed value
*
* @param encode string to get int from
* @return the double value
*/
private static float decodefloatlittleendian bytebuffer encode
return float intbitstofloat decodeintlittleendian encode
/**
* encode a float in little endian format into a packed value
* @param result to pack float into
* @param f is the float to encode
*/
private static void encodefloatlittleendian bytelist result  float f
encodeintlittleendian result  float floattorawintbits f
/**
* encode a float in big-endian format into a packed value
* @param result to pack float into
* @param f is the float to encode
*/
private static void encodefloatbigendian bytelist result  float f
encodeintbigendian result  float floattorawintbits f
/**
* decode a short in little-endian from a packed value
*
* @param encode string to get int from
* @return the short value
*/
private static int decodeshortunsignedlittleendian bytebuffer encode
encode order byteorder little_endian
int value   encode getshort     0xffff
encode order byteorder big_endian
return value
/**
* decode a short in big-endian from a packed value
*
* @param encode string to get int from
* @return the short value
*/
private static int decodeshortunsignedbigendian bytebuffer encode
int value   encode getshort     0xffff
return value
/**
* decode a short in little-endian from a packed value
*
* @param encode string to get int from
* @return the short value
*/
private static int decodeshortlittleendian bytebuffer encode
encode order byteorder little_endian
int value   encode getshort
encode order byteorder big_endian
return value
/**
* decode a short in big-endian from a packed value
*
* @param encode string to get int from
* @return the short value
*/
private static short decodeshortbigendian bytebuffer encode
return encode getshort
/**
* encode an short in little endian format into a packed representation.
*
* @param result to be appended to
* @param s the short to encode
*/
private static void encodeshortlittleendian bytelist result  int s
result append  byte   s   0xff   append  byte    s   0xff00  >> 8
/**
* encode an shortin big-endian format into a packed representation.
*
* @param result to be appended to
* @param s the short to encode
*/
private static void encodeshortbigendian bytelist result  int s
result append  byte    s   0xff00  >> 8   append  byte   s   0xff