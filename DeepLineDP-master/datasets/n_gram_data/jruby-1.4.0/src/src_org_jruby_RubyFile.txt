/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2003 joey gibson <joey@joeygibson.com>
* copyright (c) 2004-2007 thomas e enebo <enebo@acm.org>
* copyright (c) 2004-2007 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 miguel covarrubias <mlcovarrubias@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby
import com kenai constantine platform openflags
import org jcodings encoding
import org jruby util io openfile
import org jruby util io channeldescriptor
import java io file
import java io filedescriptor
import java io filenotfoundexception
import java io ioexception
import java io inputstream
import java io reader
import java nio channels channels
import java nio channels filechannel
import java nio channels filelock
import org jruby anno jrubyclass
import org jruby anno jrubymethod
import org jruby anno jrubymodule
import org jruby ext posix util platform
import org jruby runtime block
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
import org jruby runtime encoding encodingcapable
import org jruby util bytelist
import org jruby util io directoryasfileexception
import org jruby util io stream
import org jruby util io channelstream
import org jruby util io modeflags
import org jruby util jrubyfile
import org jruby util typeconverter
import org jruby util io baddescriptorexception
import org jruby util io fileexistsexception
import org jruby util io invalidvalueexception
import org jruby util io pipeexception
/**
* ruby file class equivalent in java.
**/
@jrubyclass name    parent    include
public class rubyfile extends rubyio implements encodingcapable
private static final long serialversionuid   1l
public static final int lock_sh   1
public static final int lock_ex   2
public static final int lock_nb   4
public static final int lock_un   8
private static final int fnm_noescape   1
private static final int fnm_pathname   2
private static final int fnm_dotmatch   4
private static final int fnm_casefold   8
private static final int fnm_syscase
static
if  platform is_windows
fnm_syscase   fnm_casefold
else
fnm_syscase   0
public encoding getencoding
return null
private static boolean startswithdriveletteronwindows string path
return  path    null
platform is_windows
path length  >1    path charat 0        ?
path length   > 2
iswindowsdriveletter path charat 1
path charat 2
path length   > 1
iswindowsdriveletter path charat 0
path charat 1
// adjusts paths started with '/' or '\\', on windows.
static string adjustrootpathonwindows ruby runtime  string path  string dir
if  path    null  return path
if  platform is_windows
// mri behavior on windows: it treats '/' as a root of
// a current drive (but only if single slash is present!):
// e.g., if current work directory is
// 'd:/home/directory', then '/' means 'd:/'.
//
// basically, '/path' is treated as a *relative* path,
// relative to the current drive. '//path' is treated
// as absolute one.
if   path startswith         path length  >2    path charat 2            path startswith
if  path length   > 1     path charat 1          path charat 1
return path
// first try to use drive letter from supplied dir value,
// then try current work dir.
if   startswithdriveletteronwindows dir
dir   runtime getcurrentdirectory
if  dir length   >  2
path   dir substring 0  2    path
else if  startswithdriveletteronwindows path     path length      2
// compensate for missing slash after drive letter on windows
path
return path
protected string path
private filelock currentlock
public rubyfile ruby runtime  rubyclass type
super runtime  type
// xxx this constructor is a hack to implement the __end__ syntax.
//     converting a reader back into an inputstream doesn't generally work.
public rubyfile ruby runtime  string path  final reader reader
this runtime  path  new inputstream
public int read   throws ioexception
return reader read
public rubyfile ruby runtime  string path  inputstream in
super runtime  runtime getfile
this path   path
try
this openfile setmainstream new channelstream runtime  new channeldescriptor channels newchannel in   getnewfileno    new filedescriptor
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
this openfile setmode openfile getmainstream   getmodes   getopenfileflags
registerdescriptor openfile getmainstream   getdescriptor
private static objectallocator file_allocator   new objectallocator
public irubyobject allocate ruby runtime  rubyclass klass
rubyfile instance   new rubyfile runtime  klass
instance setmetaclass klass
return instance
public string getpath
return path
@jrubymodule name
public static class constants
public static rubyclass createfileclass ruby runtime
rubyclass fileclass   runtime defineclass    runtime getio    file_allocator
// create constants class
rubymodule constants   fileclass definemoduleunder
runtime setfile fileclass
rubystring separator   runtime newstring
threadcontext context   runtime getcurrentcontext
fileclass kindof   new rubymodule kindof
@override
public boolean iskindof irubyobject obj  rubymodule type
return obj instanceof rubyfile
separator freeze context
fileclass defineconstant    separator
fileclass defineconstant    separator
if  file separatorchar
rubystring altseparator   runtime newstring
altseparator freeze context
fileclass defineconstant    altseparator
else
fileclass defineconstant    runtime getnil
rubystring pathseparator   runtime newstring file pathseparator
pathseparator freeze context
fileclass defineconstant    pathseparator
// todo: why are we duplicating the constants here, and then in
// file::constants below? file::constants is included in io.
// todo: these were missing, so we're not handling them elsewhere?
fileclass fastsetconstant    runtime newfixnum fnm_noescape
fileclass fastsetconstant    runtime newfixnum fnm_casefold
fileclass fastsetconstant    runtime newfixnum fnm_syscase
fileclass fastsetconstant    runtime newfixnum fnm_dotmatch
fileclass fastsetconstant    runtime newfixnum fnm_pathname
// create constants for open flags
for  openflags f   openflags values
// strip off the o_ prefix, so they become file::rdonly, and so on
final string name   f name
if  name startswith
final string cname   name substring 2
// special case for handling accmode, since constantine will generate
// an invalid value if it is not defined by the platform.
final rubyfixnum cvalue   f    openflags o_accmode
? runtime newfixnum modeflags accmode
runtime newfixnum f value
fileclass fastsetconstant cname  cvalue
constants fastsetconstant cname  cvalue
// create constants for flock
fileclass fastsetconstant    runtime newfixnum rubyfile lock_sh
fileclass fastsetconstant    runtime newfixnum rubyfile lock_ex
fileclass fastsetconstant    runtime newfixnum rubyfile lock_nb
fileclass fastsetconstant    runtime newfixnum rubyfile lock_un
constants fastsetconstant    runtime newfixnum fnm_noescape
constants fastsetconstant    runtime newfixnum fnm_casefold
constants fastsetconstant    runtime newfixnum fnm_syscase
constants fastsetconstant    runtime newfixnum fnm_dotmatch
constants fastsetconstant    runtime newfixnum fnm_pathname
// create constants for flock
constants fastsetconstant    runtime newfixnum rubyfile lock_sh
constants fastsetconstant    runtime newfixnum rubyfile lock_ex
constants fastsetconstant    runtime newfixnum rubyfile lock_nb
constants fastsetconstant    runtime newfixnum rubyfile lock_un
// file::constants module is included in io.
runtime getio   includemodule constants
runtime getfiletest   extend_object fileclass
fileclass defineannotatedmethods rubyfile class
return fileclass
@jrubymethod
@override
public irubyobject close
// make sure any existing lock is released before we try and close the file
if  currentlock    null
try
currentlock release
catch  ioexception e
throw getruntime   newioerror e getmessage
return super close
@jrubymethod required   1
public irubyobject flock threadcontext context  irubyobject lockingconstant
// todo: port exact behavior from mri, and move most locking logic into channeldescriptor
// todo: for all lock_nb cases, return false if they would block
channeldescriptor descriptor   openfile getmainstream   getdescriptor
// null channel always succeeds for all locking operations
if  descriptor isnull    return rubyfixnum zero context getruntime
if  descriptor getchannel   instanceof filechannel
filechannel filechannel    filechannel descriptor getchannel
int lockmode   rubynumeric num2int lockingconstant
// exclusive locks in java require the channel to be writable, otherwise
// an exception is thrown (terminating jruby execution).
// but flock behavior of mri is that it allows
// exclusive locks even on non-writable file. so we convert exclusive
// lock to shared lock if the channel is not writable, to better match
// the mri behavior.
if   openfile iswritable       lockmode   lock_ex  > 0
lockmode    lockmode ^ lock_ex    lock_sh
try
switch  lockmode
case lock_un
case lock_un   lock_nb
if  currentlock    null
currentlock release
currentlock   null
return rubyfixnum zero context getruntime
break
case lock_ex
if  currentlock    null
currentlock release
currentlock   null
currentlock   filechannel lock
if  currentlock    null
return rubyfixnum zero context getruntime
break
case lock_ex   lock_nb
if  currentlock    null
currentlock release
currentlock   null
currentlock   filechannel trylock
if  currentlock    null
return rubyfixnum zero context getruntime
break
case lock_sh
if  currentlock    null
currentlock release
currentlock   null
currentlock   filechannel lock 0l  long max_value  true
if  currentlock    null
return rubyfixnum zero context getruntime
break
case lock_sh   lock_nb
if  currentlock    null
currentlock release
currentlock   null
currentlock   filechannel trylock 0l  long max_value  true
if  currentlock    null
return rubyfixnum zero context getruntime
break
default
catch  ioexception ioe
if  context getruntime   getdebug   istrue
ioe printstacktrace system err
// return false here
catch  java nio channels overlappingfilelockexception ioe
if  context getruntime   getdebug   istrue
ioe printstacktrace system err
// return false here
return context getruntime   getfalse
else
// we're not actually a real file, so we can't flock
return context getruntime   getfalse
@jrubymethod required   1  optional   2  frame   true  visibility   visibility private  compat   compatversion ruby1_8
@override
public irubyobject initialize irubyobject args  block block
if  openfile    null
throw getruntime   newruntimeerror
if  args length > 0    args length < 3
irubyobject fd   typeconverter converttotypewithcheck args  getruntime   getfixnum
if   fd isnil
args   fd
return super initialize args  block
return openfile args
@jrubymethod name      required   1  optional   2  frame   true  visibility   visibility private  compat   compatversion ruby1_9
public irubyobject initialize19 threadcontext context  irubyobject args  block block
if  openfile    null
throw context getruntime   newruntimeerror
if  args length > 0    args length <  3
irubyobject fd   typeconverter converttotypewithcheck args  context getruntime   getfixnum
if   fd isnil
args   fd
if  args length    1
return super initialize19 context  args  block
else if  args length    2
return super initialize19 context  args  args  block
return super initialize19 context  args  args  args  block
return openfile19 context  args
private irubyobject openfile19 threadcontext context  irubyobject args
rubystring filename   get_path context  args
context getruntime   checksafestring filename
path   filename getunicodevalue
string modestring
modeflags modes   new modeflags
int perm   0
try
if  args length > 1
modestring   args converttostring   tostring
modes   parsemodes19 context  args
else
modestring
modes   parsemodes19 context  rubystring newstring context getruntime    modestring
if  args length > 2     args isnil
if  args instanceof rubyhash
modes   parseoptions context  args  modes
else
perm   getfilepermissions args
if  perm > 0
sysopeninternal path  modes  perm
else
openinternal path  modestring  modes
catch  invalidvalueexception ex
throw context getruntime   newerrnoeinvalerror
finally
return this
private irubyobject openfile irubyobject args
rubystring filename   get_path getruntime   getcurrentcontext    args
getruntime   checksafestring filename
path   filename getunicodevalue
string modestring
modeflags modes
int perm
try
if   args length > 1    args instanceof rubyfixnum      args length > 2     args isnil
modes   parsemodes args
perm   getfilepermissions args
sysopeninternal path  modes  perm
else
modestring
if  args length > 1     args isnil
modestring   args converttostring   tostring
openinternal path  modestring
catch  invalidvalueexception ex
throw getruntime   newerrnoeinvalerror
finally
return this
private int getfilepermissions irubyobject args
return  args length > 2     args isnil    ? rubynumeric num2int args    438
protected void sysopeninternal string path  modeflags modes  int perm  throws invalidvalueexception
openfile   new openfile
openfile setpath path
openfile setmode modes getopenfileflags
int umask   getruntime   getposix   umask 0
perm   perm    perm   umask
channeldescriptor descriptor   sysopen path  modes  perm
openfile setmainstream fdopen descriptor  modes
registerdescriptor descriptor
protected void openinternal string path  string modestring  modeflags modes  throws invalidvalueexception
openfile   new openfile
openfile setmode modes getopenfileflags
openfile setpath path
openfile setmainstream fopen path  modestring
registerdescriptor openfile getmainstream   getdescriptor
protected void openinternal string path  string modestring  throws invalidvalueexception
openfile   new openfile
openfile setmode getiomodes getruntime    modestring  getopenfileflags
openfile setpath path
openfile setmainstream fopen path  modestring
registerdescriptor openfile getmainstream   getdescriptor
private channeldescriptor sysopen string path  modeflags modes  int perm  throws invalidvalueexception
try
channeldescriptor descriptor   channeldescriptor open
getruntime   getcurrentdirectory
path
modes
perm
getruntime   getposix
// todo: check if too many open files, gc and try again
return descriptor
catch  filenotfoundexception fnfe
throw getruntime   newerrnoenoenterror
catch  directoryasfileexception dafe
throw getruntime   newerrnoeisdirerror
catch  fileexistsexception fee
throw getruntime   newerrnoeexisterror     path
catch  ioexception ioe
throw getruntime   newioerrorfromexception ioe
private stream fopen string path  string modestring
try
stream stream   channelstream fopen
getruntime
path
getiomodes getruntime    modestring
if  stream    null
// todo
//            if (errno == emfile || errno == enfile) {
//                rb_gc();
//                file = fopen(fname, mode);
//            }
//            if (!file) {
//                rb_sys_fail(fname);
//            }
// do we need to be in setvbuf mode for buffering to make sense? this comes up elsewhere.
//    #ifdef use_setvbuf
//        if (setvbuf(file, null, _iofbf, 0) != 0)
//            rb_warn("setvbuf() can't be honoured for %s", fname);
//    #endif
//    #ifdef __human68k__
//        fmode(file, _iotext);
//    #endif
return stream
catch  baddescriptorexception e
throw getruntime   newerrnoebadferror
catch  filenotfoundexception ex
// fnfexception can be thrown in both cases, when the file
// is not found, or when permission is denied.
if  ruby issecurityrestricted      new file path  exists
throw getruntime   newerrnoeacceserror
path
throw getruntime   newerrnoenoenterror
path
catch  directoryasfileexception ex
throw getruntime   newerrnoeisdirerror
catch  fileexistsexception ex
throw getruntime   newerrnoeexisterror path
catch  ioexception ex
throw getruntime   newioerrorfromexception ex
catch  invalidvalueexception ex
throw getruntime   newerrnoeinvalerror
catch  pipeexception ex
throw getruntime   newerrnoepipeerror
catch  securityexception ex
throw getruntime   newerrnoeacceserror     path
@jrubymethod required   1
public irubyobject chmod threadcontext context  irubyobject arg
int mode    int  arg converttointeger   getlongvalue
if   new file path  exists
throw context getruntime   newerrnoenoenterror     path
return context getruntime   newfixnum context getruntime   getposix   chmod path  mode
@jrubymethod required   2
public irubyobject chown threadcontext context  irubyobject arg1  irubyobject arg2
int owner    1
if   arg1 isnil
owner   rubynumeric num2int arg1
int group    1
if   arg2 isnil
group   rubynumeric num2int arg2
if   new file path  exists
throw context getruntime   newerrnoenoenterror     path
return context getruntime   newfixnum context getruntime   getposix   chown path  owner  group
@jrubymethod
public irubyobject atime threadcontext context
return context getruntime   newfilestat path  false  atime
@jrubymethod
public irubyobject ctime threadcontext context
return context getruntime   newfilestat path  false  ctime
@jrubymethod required   1
public irubyobject lchmod threadcontext context  irubyobject arg
int mode    int  arg converttointeger   getlongvalue
if   new file path  exists
throw context getruntime   newerrnoenoenterror     path
return context getruntime   newfixnum context getruntime   getposix   lchmod path  mode
// todo: this method is not present in mri!
@jrubymethod required   2
public irubyobject lchown threadcontext context  irubyobject arg1  irubyobject arg2
int owner    1
if   arg1 isnil
owner   rubynumeric num2int arg1
int group    1
if   arg2 isnil
group   rubynumeric num2int arg2
if   new file path  exists
throw context getruntime   newerrnoenoenterror     path
return context getruntime   newfixnum context getruntime   getposix   lchown path  owner  group
@jrubymethod
public irubyobject lstat threadcontext context
return context getruntime   newfilestat path  true
@jrubymethod
public irubyobject mtime threadcontext context
return getlastmodified context getruntime    path
@jrubymethod meta   true  frame   true  compat   compatversion ruby1_9
public static irubyobject path threadcontext context  irubyobject self  irubyobject str
return get_path context  str
/**
* similar in spirit to rb_get_path from 1.9 source
* @param context
* @param obj
* @return
*/
public static rubystring get_path threadcontext context  irubyobject obj
if  context getruntime   is1_9
irubyobject str   obj checkstringtype
if   str isnil
return  rubystring  str
if  obj respondsto
obj   obj callmethod context
return obj converttostring
@jrubymethod name
public rubystring path threadcontext context
return context getruntime   newstring path
@jrubymethod
@override
public irubyobject stat threadcontext context
openfile checkclosed context getruntime
return context getruntime   newfilestat path  false
@jrubymethod required   1
public irubyobject truncate threadcontext context  irubyobject arg
rubyinteger newlength   arg converttointeger
if  newlength getlongvalue   < 0
throw context getruntime   newerrnoeinvalerror     path
try
openfile checkwritable context getruntime
openfile getmainstream   ftruncate newlength getlongvalue
catch  baddescriptorexception e
throw context getruntime   newerrnoebadferror
catch  pipeexception e
throw context getruntime   newerrnoespipeerror
catch  invalidvalueexception ex
throw context getruntime   newerrnoeinvalerror
catch  ioexception e
// should we do anything?
return rubyfixnum zero context getruntime
@override
public string tostring
return     path       openfile getmode         openfile getmainstream   getdescriptor   getfileno
// todo: this is also defined in the metaclass too...consolidate somewhere.
private static modeflags getmodes ruby runtime  irubyobject object  throws invalidvalueexception
if  object instanceof rubystring
return getiomodes runtime    rubystring  object  tostring
else if  object instanceof rubyfixnum
return new modeflags   rubyfixnum  object  getlongvalue
throw runtime newtypeerror
@jrubymethod
@override
public irubyobject inspect
stringbuilder val   new stringbuilder
val append    append path
if  openfile isopen
val append
val append
return getruntime   newstring val tostring
/* file class methods */
@jrubymethod required   1  optional   1  meta   true
public static irubyobject basename threadcontext context  irubyobject recv  irubyobject args
string name   get_path context args  getunicodevalue
// mri-compatible basename handling for windows drive letter paths
if  platform is_windows
if  name length   > 1    name charat 1          character isletter name charat 0
switch  name length
case 2
return rubystring newemptystring context getruntime    infectby args
case 3
return context getruntime   newstring name substring 2   infectby args
default
switch  name charat 2
case
case
break
default
// strip c: away from relative-pathed name
name   name substring 2
break
break
while  name length   > 1    name charat name length     1
name   name substring 0  name length     1
// paths which end in "/" or "\\" must be stripped off.
int slashcount   0
int length   name length
for  int i   length   1  i >  0  i
char c   name charat i
if  c         c
break
slashcount
if  slashcount > 0    length > 1
name   name substring 0  name length     slashcount
int index   name lastindexof
if  index     1
// xxx actually only on windows...
index   name lastindexof
if   name equals       index     1
name   name substring index   1
if  args length    2
string ext   rubystring stringvalue args  tostring
if    equals ext
index   name lastindexof
if  index > 0         1 no match  0 it is dot file not extension
name   name substring 0  index
else if  name endswith ext
name   name substring 0  name length     ext length
return context getruntime   newstring name  infectby args
@jrubymethod required   2  rest   true  meta   true
public static irubyobject chmod threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int count   0
rubyinteger mode   args converttointeger
for  int i   1  i < args length  i
rubystring filename   get_path context  args
if   rubyfiletest exist_p filename  filename  istrue
throw runtime newerrnoenoenterror     filename
boolean result   0    runtime getposix   chmod filename getunicodevalue     int mode getlongvalue
if  result
count
return runtime newfixnum count
@jrubymethod required   3  rest   true  meta   true
public static irubyobject chown threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int count   0
int owner    1
if   args isnil
owner   rubynumeric num2int args
int group    1
if   args isnil
group   rubynumeric num2int args
for  int i   2  i < args length  i
rubystring filename   get_path context  args
if   rubyfiletest exist_p filename  filename  istrue
throw runtime newerrnoenoenterror     filename
boolean result   0    runtime getposix   chown filename getunicodevalue    owner  group
if  result
count
return runtime newfixnum count
@jrubymethod required   1  meta   true
public static irubyobject dirname threadcontext context  irubyobject recv  irubyobject arg
rubystring filename   get_path context  arg
string jfilename   filename getunicodevalue
string name   jfilename replace
int minpathlength   1
boolean trimmedslashes   false
boolean startswithdriveletteronwindows   startswithdriveletteronwindows name
if  startswithdriveletteronwindows
minpathlength   3
while  name length   > minpathlength    name charat name length     1
trimmedslashes   true
name   name substring 0  name length     1
string result
if  startswithdriveletteronwindows    name length      2
if  trimmedslashes
// c:\ is returned unchanged
result   jfilename substring 0  3
else
result   jfilename substring 0  2
else
//todo deal with unc names
int index   name lastindexof
if  index     1
if  startswithdriveletteronwindows
return context getruntime   newstring jfilename substring 0  2
else
return context getruntime   newstring
if  index    0  return context getruntime   newstring
if  startswithdriveletteronwindows    index    2
// include additional path separator
// (so that dirname of "c:\file.txt" is  "c:\", not "c:")
index
result   jfilename substring 0  index
char endchar
// trim trailing slashes
while  result length   > minpathlength
endchar   result charat result length     1
if  endchar         endchar
result   result substring 0  result length     1
else
break
return context getruntime   newstring result  infectby filename
private static boolean iswindowsdriveletter char c
return  c >       c <         c >       c <
/**
* returns the extension name of the file. an empty string is returned if
* the filename (not the entire path) starts or ends with a dot.
* @param recv
* @param arg path to get extension name of
* @return extension, including the dot, or an empty string
*/
@jrubymethod required   1  meta   true
public static irubyobject extname threadcontext context  irubyobject recv  irubyobject arg
irubyobject basefilename   basename context  recv  new irubyobject arg
string filename   rubystring stringvalue basefilename  getunicodevalue
string result
int dotindex   filename lastindexof
if  dotindex > 0    dotindex     filename length     1
// dot is not at beginning and not at end of filename.
result   filename substring dotindex
return context getruntime   newstring result
/**
* converts a pathname to an absolute pathname. relative paths are
* referenced from the current working directory of the process unless
* a second argument is given, in which case it will be used as the
* starting point. if the second argument is also relative, it will
* first be converted to an absolute pathname.
* @param recv
* @param args
* @return resulting absolute path as a string
*/
@jrubymethod required   1  optional   1  meta   true
public static irubyobject expand_path threadcontext context  irubyobject recv  irubyobject args
return expandpathinternal context  recv  args  true
/**
* ---------------------------------------------------- file::absolute_path
*      file.absolute_path(file_name [, dir_string] ) -> abs_file_name
*
*      from ruby 1.9.1
* ------------------------------------------------------------------------
*      converts a pathname to an absolute pathname. relative paths are
*      referenced from the current working directory of the process unless
*      _dir_string_ is given, in which case it will be used as the
*      starting point. if the given pathname starts with a ``+~+'' it is
*      not expanded, it is treated as a normal directory name.
*
*         file.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"
*
* @param context
* @param recv
* @param args
* @return
*/
@jrubymethod required   1  optional   1  meta   true  compat   compatversion ruby1_9
public static irubyobject absolute_path threadcontext context  irubyobject recv  irubyobject args
return expandpathinternal context  recv  args  false
private static irubyobject expandpathinternal threadcontext context  irubyobject recv  irubyobject args  boolean expanduser
ruby runtime   context getruntime
string relativepath   get_path context  args  getunicodevalue
boolean isabsolutewithfileprefix   relativepath startswith
string cwd   null
// handle ~user paths
if  expanduser
relativepath   expanduserpath context  relativepath
// if there's a second argument, it's the path to which the first
// argument is relative.
if  args length    2     args isnil
cwd   get_path context  args  getunicodevalue
// handle ~user paths.
if  expanduser
cwd   expanduserpath context  cwd
cwd   adjustrootpathonwindows runtime  cwd  null
boolean startswithslashnotonwindows    cwd    null
platform is_windows    cwd length   > 0
cwd charat 0
// todo: better detection when path is absolute or not.
// if the path isn't absolute, then prepend the current working
// directory to the path.
if   startswithslashnotonwindows     startswithdriveletteronwindows cwd
cwd   new file runtime getcurrentdirectory    cwd  getabsolutepath
else
// if there's no second argument, simply use the working directory
// of the runtime.
cwd   runtime getcurrentdirectory
// something wrong we don't know the cwd...
// todo: is this behavior really desirable? /mov
if  cwd    null  return runtime getnil
/* the counting of slashes that follows is simply a way to adhere to
* ruby's unc (or something) compatibility. when ruby's expand_path is
* called with "//foo//bar" it will return "//foo/bar". jruby uses
* java.io.file, and hence returns "/foo/bar". in order to retain
* java.io.file in the lower layers and provide full ruby
* compatibility, the number of extra slashes must be counted and
* prepended to the result.
*/
// todo: special handling on windows for some corner cases
//        if (is_windows) {
//            if (relativepath.startswith("//")) {
//                if (relativepath.length() > 2 && relativepath.charat(2) != '/') {
//                    int nextslash = relativepath.indexof('/', 3);
//                    if (nextslash != -1) {
//                        return runtime.newstring(
//                                relativepath.substring(0, nextslash)
//                                + canonicalize(relativepath.substring(nextslash)));
//                    } else {
//                        return runtime.newstring(relativepath);
//                    }
//                }
//            }
//        }
// find out which string to check.
string padslashes
if   platform is_windows
if  relativepath length   > 0    relativepath charat 0
padslashes   countslashes relativepath
else if  cwd length   > 0    cwd charat 0
padslashes   countslashes cwd
jrubyfile path
if  relativepath length      0
path   jrubyfile create relativepath  cwd
else
relativepath   adjustrootpathonwindows runtime  relativepath  cwd
path   jrubyfile create cwd  relativepath
string tempresult   padslashes   canonicalize path getabsolutepath
if isabsolutewithfileprefix
tempresult   tempresult substring tempresult indexof
return runtime newstring tempresult
/**
* this method checks a path, and if it starts with ~, then it expands
* the path to the absolute path of the user's home directory. if the
* string does not begin with ~, then the string is simply returned.
* unaltered.
* @param recv
* @param path path to check
* @return expanded path
*/
public static string expanduserpath threadcontext context  string path
int pathlength   path length
if  pathlength >  1    path charat 0
// enebo : should ~frogger\\foo work (it doesnt in linux ruby)?
int userend   path indexof
if  userend     1
if  pathlength    1
// single '~' as whole path to expand
path   rubydir gethomedirectorypath context  tostring
else
// no directory delimeter.  rest of string is username
userend   pathlength
if  userend    1
// '~/...' as path to expand
path   rubydir gethomedirectorypath context  tostring
path substring 1
else if  userend > 1
// '~user/...' as path to expand
string user   path substring 1  userend
irubyobject dir   rubydir gethomedirectorypath context  user
if  dir isnil
throw context getruntime   newargumenterror     user
path       dir    pathlength    userend ?     path substring userend
return path
/**
* returns a string consisting of <code>n-1</code> slashes, where
* <code>n</code> is the number of slashes at the beginning of the input
* string.
* @param stringtocheck
* @return
*/
private static string countslashes  string stringtocheck
// count number of extra slashes in the beginning of the string.
int slashcount   0
for  int i   0  i < stringtocheck length    i
if  stringtocheck charat i
slashcount
else
break
// if there are n slashes, then we want n-1.
if  slashcount > 0
slashcount
// prepare a string with the same number of redundant slashes so that
// we easily can prepend it to the result.
byte slashes   new byte
for  int i   0  i < slashcount  i
slashes
return new string slashes
private static string canonicalize string path
return canonicalize null  path
private static string canonicalize string canonicalpath  string remaining
if  remaining    null
if    equals canonicalpath
return
else
// compensate for missing slash after drive letter on windows
if  startswithdriveletteronwindows canonicalpath
canonicalpath length      2
canonicalpath
return canonicalpath
string child
int slash   remaining indexof
if  slash     1
child   remaining
remaining   null
else
child   remaining substring 0  slash
remaining   remaining substring slash   1
if  child equals
// no canonical path yet or length is zero, and we have a / followed by a dot...
if  slash     1
// we don't have another slash after this, so replace /. with /
if  canonicalpath    null    canonicalpath length      0    slash     1  canonicalpath
else
// we do have another slash; omit both / and . (jruby-1606)
else if  child equals
if  canonicalpath    null  throw new illegalargumentexception
int lastdir   canonicalpath lastindexof
if  lastdir     1
if  startswithdriveletteronwindows canonicalpath
// do nothing, we should not delete the drive letter
else
canonicalpath
else
canonicalpath   canonicalpath substring 0  lastdir
else if  canonicalpath    null
canonicalpath   child
else
canonicalpath        child
return canonicalize canonicalpath  remaining
/**
* returns true if path matches against pattern the pattern is not a regular expression;
* instead it follows rules similar to shell filename globbing. it may contain the following
* metacharacters:
*   *:  glob - match any sequence chars (re: .*).  if like begins with '.' then it doesn't.
*   ?:  matches a single char (re: .).
*   [set]:  matches a single char in a set (re: [...]).
*
*/
@jrubymethod name           required   2  optional   1  meta   true
public static irubyobject fnmatch threadcontext context  irubyobject recv  irubyobject args
int flags   args length    3 ? rubynumeric num2int args    0
bytelist pattern   args converttostring   getbytelist
bytelist path   get_path context  args  getbytelist
if  org jruby util dir fnmatch pattern bytes  pattern begin  pattern begin pattern realsize
path bytes  path begin  path begin path realsize  flags     0
return context getruntime   gettrue
return context getruntime   getfalse
@jrubymethod name      required   1  meta   true
public static irubyobject ftype threadcontext context  irubyobject recv  irubyobject filename
return context getruntime   newfilestat get_path context  filename  getunicodevalue    true  ftype
private static string inspectjoin threadcontext context  irubyobject recv  rubyarray parent  rubyarray array
ruby runtime   context getruntime
// if already inspecting, there is no need to register/unregister again.
if  runtime isinspecting parent   return join context  recv  array  tostring
try
runtime registerinspecting parent
return join context  recv  array  tostring
finally
runtime unregisterinspecting parent
private static rubystring join threadcontext context  irubyobject recv  rubyarray ary
irubyobject args   ary tojavaarray
boolean istainted   false
stringbuilder buffer   new stringbuilder
ruby runtime   context getruntime
for  int i   0  i < args length  i
if  args istaint
istainted   true
string element
if  args instanceof rubystring
element   args converttostring   getunicodevalue
else if  args instanceof rubyarray
if  runtime isinspecting args
throw runtime newargumenterror
else
element   inspectjoin context  recv  ary    rubyarray args
else
rubystring path   get_path context  args
element   path getunicodevalue
chomp buffer
if  i > 0     element startswith        element startswith
buffer append
buffer append element
rubystring fixedstr   rubystring newstring runtime  buffer tostring
fixedstr settaint istainted
return fixedstr
/*
* fixme:  this does not have exact same semantics as rubyarray.join, but they
* probably could be consolidated (perhaps as join(args[], sep, dochomp)).
*/
@jrubymethod rest   true  meta   true
public static rubystring join threadcontext context  irubyobject recv  irubyobject args
return join context  recv  rubyarray newarraynocopylight context getruntime    args
private static void chomp stringbuilder buffer
int lastindex   buffer length     1
while  lastindex >  0     buffer lastindexof       lastindex    buffer lastindexof       lastindex
buffer setlength lastindex
lastindex
@jrubymethod name      required   1  meta   true
public static irubyobject lstat threadcontext context  irubyobject recv  irubyobject filename
string f   get_path context  filename  getunicodevalue
if f startswith       f indexof        1
f   f substring 5  f indexof
return context getruntime   newfilestat f  true
@jrubymethod name      required   1  meta   true
public static irubyobject stat threadcontext context  irubyobject recv  irubyobject filename
string f   get_path context  filename  getunicodevalue
if f startswith       f indexof        1
f   f substring 5  f indexof
return context getruntime   newfilestat f  false
@jrubymethod name      required   1  meta   true
public static irubyobject atime threadcontext context  irubyobject recv  irubyobject filename
string f   get_path context  filename  getunicodevalue
if f startswith       f indexof        1
f   f substring 5  f indexof
return context getruntime   newfilestat f  false  atime
@jrubymethod name      required   1  meta   true
public static irubyobject ctime threadcontext context  irubyobject recv  irubyobject filename
string f   get_path context  filename  getunicodevalue
if f startswith       f indexof        1
f   f substring 5  f indexof
return context getruntime   newfilestat f  false  ctime
@jrubymethod required   2  rest   true  meta   true
public static irubyobject lchmod threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int count   0
rubyinteger mode   args converttointeger
for  int i   1  i < args length  i
rubystring filename   get_path context  args
if   rubyfiletest exist_p filename  filename  istrue
throw runtime newerrnoenoenterror     filename
boolean result   0    runtime getposix   lchmod filename getunicodevalue     int mode getlongvalue
if  result
count
return runtime newfixnum count
@jrubymethod required   2  rest   true  meta   true
public static irubyobject lchown threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int owner    args isnil   ? rubynumeric num2int args     1
int group    args isnil   ? rubynumeric num2int args     1
int count   0
for  int i   2  i < args length  i
irubyobject filename   args
if  0    runtime getposix   lchown filename tostring    owner  group
throw runtime newerrnofromlastposixerrno
else
count
return runtime newfixnum count
@jrubymethod required   2  meta   true
public static irubyobject link threadcontext context  irubyobject recv  irubyobject from  irubyobject to
ruby runtime   context getruntime
rubystring fromstr   rubystring stringvalue from
rubystring tostr   rubystring stringvalue to
try
if  runtime getposix   link
fromstr getunicodevalue   tostr getunicodevalue        1
// fixme: when we get jna3 we need to properly write this to errno.
throw runtime newerrnoeexisterror
fromstr       tostr
catch  java lang unsatisfiedlinkerror ule
throw runtime newnotimplementederror
return runtime newfixnum 0
@jrubymethod name      required   1  meta   true
public static irubyobject mtime threadcontext context  irubyobject recv  irubyobject filename
return getlastmodified context getruntime    get_path context  filename  getunicodevalue
@jrubymethod required   2  meta   true
public static irubyobject rename threadcontext context  irubyobject recv  irubyobject oldname  irubyobject newname
ruby runtime   context getruntime
rubystring oldnamestring   rubystring stringvalue oldname
rubystring newnamestring   rubystring stringvalue newname
runtime checksafestring oldnamestring
runtime checksafestring newnamestring
string newnamejavastring   newnamestring getunicodevalue
string oldnamejavastring   oldnamestring getunicodevalue
jrubyfile oldfile   jrubyfile create runtime getcurrentdirectory    oldnamejavastring
jrubyfile newfile   jrubyfile create runtime getcurrentdirectory    newnamejavastring
if   oldfile exists       newfile getparentfile   exists
throw runtime newerrnoenoenterror     oldnamejavastring
newnamejavastring
jrubyfile dest   jrubyfile create runtime getcurrentdirectory    newnamejavastring
if  oldfile renameto dest         rename is successful
return rubyfixnum zero runtime
// rename via java api call wasn't successful, let's try some tricks, similar to mri
if  newfile exists
runtime getposix   chmod newnamejavastring  0666
newfile delete
if  oldfile renameto dest        try to rename one more time
return rubyfixnum zero runtime
throw runtime newerrnoeacceserror     oldnamejavastring
newnamejavastring
@jrubymethod required   1  meta   true
public static rubyarray split threadcontext context  irubyobject recv  irubyobject arg
rubystring filename   get_path context  arg
return context getruntime   newarray dirname context  recv  filename
basename context  recv  new irubyobject   filename
@jrubymethod required   2  meta   true
public static irubyobject symlink threadcontext context  irubyobject recv  irubyobject from  irubyobject to
ruby runtime   context getruntime
rubystring fromstr   get_path context  from
rubystring tostr   get_path context  to
string tovalue   tostr getunicodevalue
tovalue   jrubyfile create runtime getcurrentdirectory    tovalue  getabsolutepath
try
if  runtime getposix   symlink
fromstr getunicodevalue    tovalue      1
// fixme: when we get jna3 we need to properly write this to errno.
throw runtime newerrnoeexisterror
fromstr       tostr
catch  java lang unsatisfiedlinkerror ule
throw runtime newnotimplementederror
return runtime newfixnum 0
@jrubymethod required   1  meta   true
public static irubyobject readlink threadcontext context  irubyobject recv  irubyobject path
ruby runtime   context getruntime
try
string realpath   runtime getposix   readlink path converttostring   getunicodevalue
if   rubyfiletest exist_p recv  path  istrue
throw runtime newerrnoenoenterror     path
if   rubyfiletest symlink_p recv  path  istrue
throw runtime newerrnoeinvalerror     path
if  realpath    null
//fixme: when we get jna3 we need to properly write this to errno.
return runtime newstring realpath
catch  ioexception e
throw runtime newioerror e getmessage
// can we produce ioerror which bypasses a close?
@jrubymethod required   2  meta   true
public static irubyobject truncate threadcontext context  irubyobject recv  irubyobject arg1  irubyobject arg2
ruby runtime   context getruntime
rubystring filename   arg1 converttostring       todo  safestringvalue here
rubyinteger newlength   arg2 converttointeger
file testfile
file childfile   new file filename getunicodevalue
if   childfile isabsolute
testfile   childfile
else
testfile   new file runtime getcurrentdirectory    filename getbytelist   tostring
if   testfile exists
throw runtime newerrnoenoenterror
filename getbytelist   tostring
if  newlength getlongvalue   < 0
throw runtime newerrnoeinvalerror     filename
irubyobject args   new irubyobject   filename  runtime newstring
rubyfile file    rubyfile  open context  recv  args  block null_block
file truncate context  newlength
file close
return rubyfixnum zero runtime
@jrubymethod meta   true  optional   1
public static irubyobject umask threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int oldmask   0
if  args length    0
oldmask   runtime getposix   umask 0
runtime getposix   umask oldmask
else if  args length    1
oldmask   runtime getposix   umask  int  args converttointeger   getlongvalue
else
runtime newargumenterror
return runtime newfixnum oldmask
@jrubymethod required   2  rest   true  meta   true
public static irubyobject utime threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
long atimeval   null
long mtimeval   null
if  args    runtime getnil      args    runtime getnil
atimeval   extracttimeval runtime  args
mtimeval   extracttimeval runtime  args
for  int i   2  j   args length  i < j  i
rubystring filename   get_path context  args
runtime checksafestring filename
jrubyfile filetotouch   jrubyfile create runtime getcurrentdirectory   filename getunicodevalue
if   filetotouch exists
throw runtime newerrnoenoenterror
runtime getposix   utimes filetotouch getabsolutepath    atimeval  mtimeval
return runtime newfixnum args length   2
@jrubymethod name           rest   true  meta   true
public static irubyobject unlink threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
for  int i   0  i < args length  i
rubystring filename   get_path context  args
runtime checksafestring filename
jrubyfile ltodelete   jrubyfile create runtime getcurrentdirectory    filename getunicodevalue
boolean issymlink   rubyfiletest symlink_p recv  filename  istrue
// broken symlinks considered by exists() as non-existing,
// so we need to check for symlinks explicitly.
if   ltodelete exists       issymlink
throw runtime newerrnoenoenterror
if   ltodelete delete
throw runtime newerrnoeacceserror
return runtime newfixnum args length
/**
* extract a timeval (an array of 2 longs: seconds and microseconds from epoch) from
* an irubyobject.
*/
private static long extracttimeval ruby runtime  irubyobject value
long timeval   new long
if  value instanceof rubyfloat
timeval   platform is_32_bit ? rubynumeric num2int value    rubynumeric num2long value
double fraction     rubyfloat  value  getdoublevalue   % 1 0
timeval    long  fraction   1e6   0 5
else if  value instanceof rubynumeric
timeval   platform is_32_bit ? rubynumeric num2int value    rubynumeric num2long value
timeval   0
else
rubytime time
if  value instanceof rubytime
time     rubytime  value
else
time    rubytime  typeconverter converttotype value  runtime gettime       true
timeval   platform is_32_bit ? rubynumeric num2int time to_i      rubynumeric num2long time to_i
timeval   platform is_32_bit ? rubynumeric num2int time usec      rubynumeric num2long time usec
return timeval
// fast path since jna stat is about 10x slower than this
private static irubyobject getlastmodified ruby runtime  string path
jrubyfile file   jrubyfile create runtime getcurrentdirectory    path
if   file exists
throw runtime newerrnoenoenterror     path
return runtime newtime file lastmodified