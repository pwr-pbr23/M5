/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2004 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 miguel covarrubias <mlcovarrubias@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby internal runtime
import java io ioexception
import java lang ref softreference
import java nio channels channel
import java nio channels selectablechannel
import java nio channels selector
import java util concurrent locks reentrantlock
import java util arraylist
import java util collections
import java util list
import java util map
import java util weakhashmap
import java util concurrent future
import org jruby ruby
import org jruby rubyio
import org jruby rubythread
import org jruby runtime builtin irubyobject
import org jruby runtime threadcontext
public class threadservice
private ruby runtime
private threadcontext maincontext
private threadlocal<softreference<threadcontext>> localcontext
private threadgroup rubythreadgroup
private map<object  rubythread> rubythreadmap
private reentrantlock criticallock   new reentrantlock
private map<rubythread threadcontext> threadcontextmap
public threadservice ruby runtime
this runtime   runtime
this maincontext   threadcontext newcontext runtime
this localcontext   new threadlocal<softreference<threadcontext>>
try
this rubythreadgroup   new threadgroup     runtime hashcode
catch securityexception e
this rubythreadgroup   thread currentthread   getthreadgroup
this rubythreadmap   collections synchronizedmap new weakhashmap<object  rubythread>
this threadcontextmap   collections synchronizedmap new weakhashmap<rubythread threadcontext>
// must be called from main thread (it is currently, but this bothers me)
localcontext set new softreference<threadcontext> maincontext
public void disposecurrentthread
localcontext set null
rubythreadmap remove thread currentthread
/**
* in order to provide an appropriate execution context for a given thread,
* we store threadcontext instances in a threadlocal. this method is a utility
* to get at that threadlocal context from anywhere in the program it may
* not be immediately available. this method should be used sparingly, and
* if it is possible to pass threadcontext on the argument list, it is
* preferable.
*
* <b>description of behavior</b>
*
* the threadlocal does not actually contain the threadcontext directly;
* instead, it contains a softreference that holds the threadcontext. this
* is to allow new threads to enter the system and execute ruby code with
* a valid context, but still allow that context to garbage collect if the
* thread stays alive much longer. we use softreference here because
* weakreference is collected too quickly, resulting in very expensive
* threadcontext churn (and this originally lead to jruby-2261's leak of
* adopted rubythread instances).
*
* @return the threadcontext instance for the current thread, or a new one
* if none has previously been created or the old threadcontext has been
* collected.
*/
public threadcontext getcurrentcontext
softreference sr   null
threadcontext context   null
while  context    null
// loop until a context is available, to clean up softrefs that might have been collected
if   sr    softreference localcontext get       null
sr   adoptcurrentthread
context    threadcontext sr get
else
context    threadcontext sr get
// context is null, wipe out the softreference (this could be done with a reference queue)
if  context    null
localcontext set null
return context
private softreference adoptcurrentthread
thread current   thread currentthread
rubythread adopt runtime getthread    current
return  softreference  localcontext get
public rubythread getmainthread
return maincontext getthread
public void setmainthread thread thread  rubythread rubythread
maincontext setthread rubythread
threadcontextmap put rubythread  maincontext
rubythreadmap put thread  rubythread
public synchronized rubythread getactiverubythreads
// all threads in ruby thread group plus main thread
synchronized rubythreadmap
list<rubythread> rtlist   new arraylist<rubythread> rubythreadmap size
for  map entry<object  rubythread> entry   rubythreadmap entryset
object key   entry getkey
if  key instanceof thread
thread t    thread key
// thread is not alive, skip it
if   t isalive    continue
else if  key instanceof future
future f    future key
// future is done or cancelled, skip it
if  f isdone      f iscancelled    continue
rtlist add entry getvalue
rubythread rubythreads   new rubythread
rtlist toarray rubythreads
return rubythreads
public map getrubythreadmap
return rubythreadmap
public threadgroup getrubythreadgroup
return rubythreadgroup
public threadcontext getthreadcontextforthread rubythread thread
return threadcontextmap get thread
public synchronized threadcontext registernewthread rubythread thread
threadcontext context   threadcontext newcontext runtime
localcontext set new softreference context
threadcontextmap put thread  context
context setthread thread
return context
public synchronized void associatethread object threadorfuture  rubythread rubythread
rubythreadmap put threadorfuture  rubythread
public synchronized void dissociatethread object threadorfuture
rubythreadmap remove threadorfuture
public synchronized void unregisterthread rubythread thread
rubythreadmap remove thread currentthread
threadcontextmap remove thread
getcurrentcontext   setthread null
localcontext set null
public void setcritical boolean critical
if  critical     criticallock isheldbycurrentthread
criticallock lock
else if   critical    criticallock isheldbycurrentthread
criticallock unlock
public boolean getcritical
return criticallock isheldbycurrentthread
public static class event
public enum type   kill  raise  wakeup
public final rubythread sender
public final rubythread target
public final type type
public final irubyobject exception
public event rubythread sender  rubythread target  type type
this sender  target  type  null
public event rubythread sender  rubythread target  type type  irubyobject exception
this sender   sender
this target   target
this type   type
this exception   exception
public synchronized void deliverevent event event
// first, check if the sender has unreceived mail
event sender checkmail getcurrentcontext
// then deliver mail to the target
event target receivemail event