/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2006 charles o nutter <headius@headius.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby compiler
import org jruby rubyinstanceconfig
import org jruby ast argsnode
import org jruby ast argspushnode
import org jruby ast arraynode
import org jruby ast iternode
import org jruby ast hashnode
import org jruby ast hash19node
import org jruby ast node
import org jruby ast lambdanode
import org jruby ast listnode
import org jruby ast multipleasgn19node
import org jruby ast multipleasgnnode
import org jruby ast nodetype
import org jruby ast optargnode
import org jruby ast starnode
import org jruby runtime arity
import org jruby runtime blockbody
/**
*
* @author headius
*/
public class astcompiler19 extends astcompiler
@override
public void compile node node  bodycompiler context  boolean expr
if  node    null
context loadnil
return
switch  node getnodetype
case lambdanode
compilelambda node  context  expr
break
case multipleasgn19node
compilemultipleasgn19 node  context  expr
break
default
super compile node  context  expr
@override
public void compileargs node node  bodycompiler context  boolean expr
final argsnode argsnode    argsnode  node
final int required   argsnode getrequiredargscount
final int opt   argsnode getoptionalargscount
final int rest   argsnode getrestarg
context getvariablecompiler   checkmethodarity required  opt  rest
compilemethodargs node  context  expr
public void compilemethodargs node node  bodycompiler context  boolean expr
final argsnode argsnode    argsnode  node
final int required   argsnode getrequiredargscount
final int opt   argsnode getoptionalargscount
final int rest   argsnode getrestarg
arraycallback requiredassignment   null
arraycallback optionalgiven   null
arraycallback optionalnotgiven   null
compilercallback restassignment   null
compilercallback blockassignment   null
if  required > 0
requiredassignment   new arraycallback
public void nextvalue bodycompiler context  object object  int index
// fixme: somehow i'd feel better if this could get the appropriate var index from the argumentnode
context getvariablecompiler   assignlocalvariable index  false
if  opt > 0
optionalgiven   new arraycallback
public void nextvalue bodycompiler context  object object  int index
optargnode optarg    optargnode   listnode  object  get index
compileassignment optarg getvalue    context  false
optionalnotgiven   new arraycallback
public void nextvalue bodycompiler context  object object  int index
optargnode optarg    optargnode   listnode  object  get index
compile optarg getvalue    context  false
if  rest >  1
restassignment   new compilercallback
public void call bodycompiler context
context getvariablecompiler   assignlocalvariable argsnode getrestarg    false
if  argsnode getblock      null
blockassignment   new compilercallback
public void call bodycompiler context
context getvariablecompiler   assignlocalvariable argsnode getblock   getcount    false
context getvariablecompiler   assignmethodarguments19
argsnode getpre
argsnode getprecount
argsnode getpost
argsnode getpostcount
argsnode getpostindex
argsnode getoptargs
argsnode getoptionalargscount
requiredassignment
optionalgiven
optionalnotgiven
restassignment
blockassignment
// todo: don't require pop
if   expr  context consumecurrentvalue
@override
public void compileargspush node node  bodycompiler context  boolean expr
argspushnode argspush    argspushnode  node
compile argspush getfirstnode    context true
compile argspush getsecondnode    context true
context appendtoarray
// todo: don't require pop
if   expr  context consumecurrentvalue
@override
public void compileiter node node  bodycompiler context
final iternode iternode    iternode node
final argsnode argsnode    argsnode iternode getvarnode
// create the closure class and instantiate it
final compilercallback closurebody   new compilercallback
public void call bodycompiler context
if  iternode getbodynode      null
compile iternode getbodynode    context  true
else
context loadnil
// create the closure class and instantiate it
final compilercallback closureargs   new compilercallback
public void call bodycompiler context
// fixme: this is temporary since the variable compilers assume we want
// args already on stack for assignment. we just pop and continue with
// 1.9 args logic.
context consumecurrentvalue
if  iternode getvarnode      null
if  iternode instanceof lambdanode
final int required   argsnode getrequiredargscount
final int opt   argsnode getoptionalargscount
final int rest   argsnode getrestarg
context getvariablecompiler   checkmethodarity required  opt  rest
compilemethodargs argsnode  context  true
else
compilemethodargs argsnode  context  true
boolean hasmultipleargshead   false
if  iternode getvarnode   instanceof multipleasgnnode
hasmultipleargshead     multipleasgnnode  iternode getvarnode    getheadnode      null
nodetype argsnodeid   blockbody getargumenttypewackyhack iternode
astinspector inspector   new astinspector
inspector inspect iternode getbodynode
inspector inspect iternode getvarnode
if  argsnodeid    null
// no args, do not pass args processor
context createnewclosure19 iternode getposition   getstartline    iternode getscope    arity procarityof iternode getvarnode    getvalue
closurebody  null  hasmultipleargshead  argsnodeid  inspector
else
context createnewclosure19 iternode getposition   getstartline    iternode getscope    arity procarityof iternode getvarnode    getvalue
closurebody  closureargs  hasmultipleargshead  argsnodeid  inspector
public void compilelambda node node  bodycompiler context  boolean expr
final lambdanode lambdanode    lambdanode node
boolean doit   expr     rubyinstanceconfig peephole_optz
boolean popit    rubyinstanceconfig peephole_optz     expr
if  doit
context createnewlambda new compilercallback
public void call bodycompiler context
compileiter lambdanode  context
if  popit  context consumecurrentvalue
public void compilemultipleasgn19 node node  bodycompiler context  boolean expr
multipleasgn19node multipleasgn19node    multipleasgn19node  node
if  expr
// need the array, use unoptz version
compileunoptimizedmultipleasgn19 multipleasgn19node  context  expr
else
// try optz version
compileoptimizedmultipleasgn19 multipleasgn19node  context  expr
private void compileoptimizedmultipleasgn19 multipleasgn19node multipleasgn19node  bodycompiler context  boolean expr
// expect value to be an array of nodes
if  multipleasgn19node getvaluenode   instanceof arraynode
// head must not be null and there must be no "args" (like *arg)
if  multipleasgn19node getprecount   > 0    multipleasgn19node getpostcount      0    multipleasgn19node getrest      null
// sizes must match
if  multipleasgn19node getprecount        arraynode multipleasgn19node getvaluenode    size
// "head" must have no non-trivial assigns (array groupings, basically)
boolean normalassigns   true
for  node asgn   multipleasgn19node getpre   childnodes
if  asgn instanceof listnode
normalassigns   false
break
if  normalassigns
// only supports simple parallel assignment of up to 4 values to the same number of assignees
int size   multipleasgn19node getprecount
if  size >  2    size <  10
arraynode values    arraynode multipleasgn19node getvaluenode
for  node value   values childnodes
compile value  context  true
context reversevalues size
for  node asgn   multipleasgn19node getpre   childnodes
compileassignment asgn  context  false
return
// if we get here, no optz cases work; fall back on unoptz.
compileunoptimizedmultipleasgn19 multipleasgn19node  context  expr
private void compileunoptimizedmultipleasgn19 multipleasgn19node multipleasgn19node  bodycompiler context  boolean expr
compile multipleasgn19node getvaluenode    context  true
compilemultipleasgn19assignment multipleasgn19node  context  expr
public void compilemultipleasgn19assignment node node  bodycompiler context  boolean expr
final multipleasgn19node multipleasgn19node    multipleasgn19node  node
// normal items at the front or back of the masgn
arraycallback preassigncallback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray
int index
listnode nodes    listnode  sourcearray
node assignnode   nodes get index
// perform assignment for the next node
compileassignment assignnode  context  false
compilercallback restcallback   new compilercallback
public void call bodycompiler context
node argsnode   multipleasgn19node getrest
if  argsnode instanceof starnode
// done processing args
context consumecurrentvalue
else
// assign to appropriate variable
compileassignment argsnode  context  false
if  multipleasgn19node getprecount      0    multipleasgn19node getpostcount      0
if  multipleasgn19node getrest      null
throw new notcompilableexception     multipleasgn19node getposition
else
if  multipleasgn19node getrest   instanceof starnode
// do nothing
else
context ensuremultipleassignablerubyarray multipleasgn19node getprecount      0    multipleasgn19node getpostcount      0
context foreachinvaluearray 0  0  null  null  restcallback
else
context ensuremultipleassignablerubyarray multipleasgn19node getprecount      0    multipleasgn19node getpostcount      0
if  multipleasgn19node getrest      null
context foreachinvaluearray 0  multipleasgn19node getprecount    multipleasgn19node getpre    multipleasgn19node getpostcount    multipleasgn19node getpost    preassigncallback  null
else
context foreachinvaluearray 0  multipleasgn19node getprecount    multipleasgn19node getpre    multipleasgn19node getpostcount    multipleasgn19node getpost    preassigncallback  restcallback
// todo: don't require pop
if   expr  context consumecurrentvalue
@override
public void compilehash node node  bodycompiler context  boolean expr
compilehashcommon  hash19node  node  context  expr
@override
protected void createnewhash bodycompiler context  hashnode hashnode  arraycallback hashcallback
context createnewhash19 hashnode getlistnode    hashcallback  hashnode getlistnode   size     2