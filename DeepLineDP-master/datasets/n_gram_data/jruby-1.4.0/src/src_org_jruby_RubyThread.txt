/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002 jason voegele <jason@jvoegele.com>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004-2005 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby
import java io ioexception
import java nio channels channel
import java nio channels selectablechannel
import java nio channels selectionkey
import java nio channels selector
import java util weakhashmap
import java util hashmap
import java util map
import java util set
import org jruby common irubywarnings id
import org jruby exceptions raiseexception
import org jruby exceptions threadkill
import org jruby internal runtime futurethread
import org jruby internal runtime nativethread
import org jruby internal runtime rubyrunnable
import org jruby internal runtime threadlike
import org jruby internal runtime threadservice
import org jruby runtime block
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime executioncontext
import org jruby runtime builtin irubyobject
import java util concurrent executionexception
import org jruby anno jrubymethod
import org jruby anno jrubyclass
import org jruby runtime objectmarshal
import org jruby runtime visibility
import org jruby util io blockingio
/**
* implementation of ruby's <code>thread</code> class.  each ruby thread is
* mapped to an underlying java virtual machine thread.
* <p>
* thread encapsulates the behavior of a thread of execution, including the main
* thread of the ruby script.  in the descriptions that follow, the parameter
* <code>asymbol</code> refers to a symbol, which is either a quoted string or a
* <code>symbol</code> (such as <code>:name</code>).
*
* note: for cvs history, see threadclass.java.
*/
@jrubyclass name
public class rubythread extends rubyobject implements executioncontext
private threadlike threadimpl
private rubyfixnum priority
private transient map<irubyobject  irubyobject> threadlocalvariables
private final map<object  irubyobject> contextvariables   new weakhashmap<object  irubyobject>
private boolean abortonexception
private irubyobject finalresult
private raiseexception exitingexception
private rubythreadgroup threadgroup
private final threadservice threadservice
// error info is per-thread
private irubyobject errorinfo
private static final boolean debug   false
public static enum status   run  sleep  aborting  dead
private volatile threadservice event mail
private volatile status status   status run
protected rubythread ruby runtime  rubyclass type
super runtime  type
this threadservice   runtime getthreadservice
finalresult   runtime getnil
// init errorinfo to nil
errorinfo   runtime getnil
public synchronized void receivemail threadservice event event
// if we're already aborting, we can receive no further mail
if  status    status aborting  return
mail   event
switch  event type
case kill
status   status aborting
// if this thread is sleeping or stopped, wake it
notify
// interrupt the target thread in case it's blocking or waiting
// warning: we no longer interrupt the target thread, since this usually means
// interrupting io and with nio that means the channel is no longer usable.
// we either need a new way to handle waking a target thread that's waiting
// on io, or we need to accept that we can't wake such threads and must wait
// for them to complete their operation.
//threadimpl.interrupt();
// new interrupt, to hopefully wake it out of any blocking io
this interrupt
public synchronized void checkmail threadcontext context
threadservice event myevent   mail
mail   null
if  myevent    null
switch  myevent type
case raise
receivedanexception context  myevent exception
case kill
throwthreadkill
public irubyobject geterrorinfo
return errorinfo
public irubyobject seterrorinfo irubyobject errorinfo
this errorinfo   errorinfo
return errorinfo
/**
* dispose of the current thread by removing it from its parent threadgroup.
*/
public void dispose
threadgroup remove this
public static rubyclass createthreadclass ruby runtime
// fixme: in order for thread to play well with the standard 'new' behavior,
// it must provide an allocator that can create empty object instances which
// initialize then fills with appropriate data.
rubyclass threadclass   runtime defineclass    runtime getobject    objectallocator not_allocatable_allocator
runtime setthread threadclass
threadclass defineannotatedmethods rubythread class
rubythread rubythread   new rubythread runtime  threadclass
// todo: need to isolate the "current" thread from class creation
rubythread threadimpl   new nativethread rubythread  thread currentthread
runtime getthreadservice   setmainthread thread currentthread    rubythread
// set to default thread group
runtime getdefaultthreadgroup   adddirectly rubythread
threadclass setmarshal objectmarshal not_marshalable_marshal
return threadclass
/**
* <code>thread.new</code>
* <p>
* thread.new( <i>[ arg ]*</i> ) {| args | block } -> athread
* <p>
* creates a new thread to execute the instructions given in block, and
* begins running it. any arguments passed to thread.new are passed into the
* block.
* <pre>
* x = thread.new { sleep .1; print "x"; print "y"; print "z" }
* a = thread.new { print "a"; print "b"; sleep .2; print "c" }
* x.join # let the threads finish before
* a.join # main thread exits...
* </pre>
* <i>produces:</i> abxyzc
*/
@jrubymethod name           rest   true  frame   true  meta   true
public static irubyobject newinstance irubyobject recv  irubyobject args  block block
return startthread recv  args  true  block
/**
* basically the same as thread.new . however, if class thread is
* subclassed, then calling start in that subclass will not invoke the
* subclass's initialize method.
*/
@jrubymethod name      rest   true  frame   true  meta   true
public static rubythread start irubyobject recv  irubyobject args  block block
return startthread recv  args  false  block
public static rubythread adopt irubyobject recv  thread t
return adoptthread recv  t  block null_block
private static rubythread adoptthread final irubyobject recv  thread t  block block
final ruby runtime   recv getruntime
final rubythread rubythread   new rubythread runtime   rubyclass  recv
rubythread threadimpl   new nativethread rubythread  t
threadcontext context   runtime getthreadservice   registernewthread rubythread
context preadoptthread
// set to default thread group
runtime getdefaultthreadgroup   adddirectly rubythread
return rubythread
@jrubymethod name      rest   true  frame   true  visibility   visibility private
public irubyobject initialize threadcontext context  irubyobject args  block block
ruby runtime   getruntime
if   block isgiven    throw runtime newthreaderror
try
rubyrunnable runnable   new rubyrunnable this  args  context getframes 0   block
if  rubyinstanceconfig pooling_enabled
futurethread futurethread   new futurethread this  runnable
threadimpl   futurethread
addtocorrectthreadgroup context
threadimpl start
// jruby-2380, associate future early so it shows up in thread.list right away, in case it doesn't run immediately
runtime getthreadservice   associatethread futurethread getfuture    this
else
thread thread   new thread runnable
thread setdaemon true
threadimpl   new nativethread this  thread
addtocorrectthreadgroup context
threadimpl start
// jruby-2380, associate thread early so it shows up in thread.list right away, in case it doesn't run immediately
runtime getthreadservice   associatethread thread  this
// we yield here to hopefully permit the target thread to schedule
// mri immediately schedules it, so this is close but not exact
thread yield
return this
catch  securityexception ex
throw runtime newthreaderror ex getmessage
private static rubythread startthread final irubyobject recv  final irubyobject args  boolean callinit  block block
rubythread rubythread   new rubythread recv getruntime     rubyclass  recv
if  callinit
rubythread callinit args  block
else
// for thread::start, which does not call the subclass's initialize
rubythread initialize recv getruntime   getcurrentcontext    args  block
return rubythread
public synchronized void cleanterminate irubyobject result
finalresult   result
public synchronized void bedead
status   status dead
try
if  selector    null  selector close
catch  ioexception ioe
public void pollthreadevents
pollthreadevents getruntime   getcurrentcontext
public void pollthreadevents threadcontext context
if  mail    null  checkmail context
private static void throwthreadkill
throw new threadkill
/**
* returns the status of the global ``abort on exception'' condition. the
* default is false. when set to true, will cause all threads to abort (the
* process will exit(0)) if an exception is raised in any thread. see also
* thread.abort_on_exception= .
*/
@jrubymethod name      meta   true
public static rubyboolean abort_on_exception_x irubyobject recv
ruby runtime   recv getruntime
return runtime isglobalabortonexceptionenabled   ? runtime gettrue     runtime getfalse
@jrubymethod name      required   1  meta   true
public static irubyobject abort_on_exception_set_x irubyobject recv  irubyobject value
recv getruntime   setglobalabortonexceptionenabled value istrue
return value
@jrubymethod name      meta   true
public static rubythread current irubyobject recv
return recv getruntime   getcurrentcontext   getthread
@jrubymethod name      meta   true
public static rubythread main irubyobject recv
return recv getruntime   getthreadservice   getmainthread
@jrubymethod name      meta   true
public static irubyobject pass irubyobject recv
ruby runtime   recv getruntime
threadservice ts   runtime getthreadservice
boolean critical   ts getcritical
ts setcritical false
thread yield
ts setcritical critical
return recv getruntime   getnil
@jrubymethod name      meta   true
public static rubyarray list irubyobject recv
rubythread activethreads   recv getruntime   getthreadservice   getactiverubythreads
return recv getruntime   newarraynocopy activethreads
private void addtocorrectthreadgroup threadcontext context
// jruby-3568, inherit threadgroup or use default
irubyobject group   context getthread   group
if   group isnil
rubythreadgroup  group  adddirectly this
else
context getruntime   getdefaultthreadgroup   adddirectly this
private irubyobject getsymbolkey irubyobject originalkey
if  originalkey instanceof rubysymbol
return originalkey
else if  originalkey instanceof rubystring
return getruntime   newsymbol originalkey asjavastring
else if  originalkey instanceof rubyfixnum
getruntime   getwarnings   warn id fixnums_not_symbols
throw getruntime   newargumenterror originalkey
else
throw getruntime   newtypeerror originalkey
private synchronized map<irubyobject  irubyobject> getthreadlocals
if  threadlocalvariables    null
threadlocalvariables   new hashmap<irubyobject  irubyobject>
return threadlocalvariables
public final map<object  irubyobject> getcontextvariables
return contextvariables
@jrubymethod name      required   1
public irubyobject op_aref irubyobject key
irubyobject value
if   value   getthreadlocals   get getsymbolkey key       null
return value
return getruntime   getnil
@jrubymethod name      required   2
public irubyobject op_aset irubyobject key  irubyobject value
key   getsymbolkey key
getthreadlocals   put key  value
return value
@jrubymethod name
public rubyboolean abort_on_exception
return abortonexception ? getruntime   gettrue     getruntime   getfalse
@jrubymethod name      required   1
public irubyobject abort_on_exception_set irubyobject val
abortonexception   val istrue
return val
@jrubymethod name
public rubyboolean alive_p
return threadimpl isalive      status    status aborting ? getruntime   gettrue     getruntime   getfalse
@jrubymethod name      optional   1  backtrace   true
public irubyobject join irubyobject args
long timeoutmillis   long max_value
if  args length > 0
if  args length > 1
throw getruntime   newargumenterror args length 1
// mri behavior: value given in seconds; converted to float; less
// than or equal to zero returns immediately; returns nil
timeoutmillis    long  1000 0d   args converttofloat   getvalue
if  timeoutmillis <  0
// todo: not sure that we should skip calling join() altogether.
// thread.join() has some implications for java memory model, etc.
if  threadimpl isalive
return getruntime   getnil
else
return this
if  iscurrent
throw getruntime   newthreaderror
try
if  threadservice getcritical
// if the target thread is sleeping or stopped, wake it
synchronized  this
notify
// interrupt the target thread in case it's blocking or waiting
// warning: we no longer interrupt the target thread, since this usually means
// interrupting io and with nio that means the channel is no longer usable.
// we either need a new way to handle waking a target thread that's waiting
// on io, or we need to accept that we can't wake such threads and must wait
// for them to complete their operation.
//threadimpl.interrupt();
rubythread currentthread   getruntime   getcurrentcontext   getthread
final long timetowait   math min timeoutmillis  200
// we need this loop in order to be able to "unblock" the
// join call without actually calling interrupt.
long start   system currenttimemillis
while true
currentthread pollthreadevents
threadimpl join timetowait
if   threadimpl isalive
break
if  system currenttimemillis     start > timeoutmillis
break
catch  interruptedexception ie
ie printstacktrace
assert false   ie
catch  executionexception ie
ie printstacktrace
assert false   ie
if  exitingexception    null
throw exitingexception
if  threadimpl isalive
return getruntime   getnil
else
return this
@jrubymethod name      frame   true
public irubyobject value
join new irubyobject
synchronized  this
return finalresult
@jrubymethod name
public irubyobject group
if  threadgroup    null
return getruntime   getnil
return threadgroup
void setthreadgroup rubythreadgroup rubythreadgroup
threadgroup   rubythreadgroup
@jrubymethod name
@override
public synchronized irubyobject inspect
// fixme: there's some code duplication here with rubyobject#inspect
stringbuilder part   new stringbuilder
string cname   getmetaclass   getrealclass   getname
part append    append cname  append
part append integer tohexstring system identityhashcode this
part append status tostring   tolowercase
part append
return getruntime   newstring part tostring
@jrubymethod name      required   1
public rubyboolean key_p irubyobject key
key   getsymbolkey key
return getruntime   newboolean getthreadlocals   containskey key
@jrubymethod name
public rubyarray keys
irubyobject keys   new irubyobject
return rubyarray newarraynocopy getruntime    getthreadlocals   keyset   toarray keys
@jrubymethod name      required   1  meta   true  compat   compatversion ruby1_8
public static irubyobject critical_set irubyobject receiver  irubyobject value
receiver getruntime   getthreadservice   setcritical value istrue
return value
@jrubymethod name      meta   true  compat   compatversion ruby1_8
public static irubyobject critical irubyobject receiver
return receiver getruntime   newboolean receiver getruntime   getthreadservice   getcritical
@jrubymethod name      meta   true
public static irubyobject stop threadcontext context  irubyobject receiver
rubythread rubythread   context getthread
synchronized  rubythread
rubythread checkmail context
try
// attempt to decriticalize all if we're the critical thread
receiver getruntime   getthreadservice   setcritical false
rubythread status   status sleep
rubythread wait
catch  interruptedexception ie
rubythread checkmail context
rubythread status   status run
return receiver getruntime   getnil
@jrubymethod name      required   1  frame   true  meta   true
public static irubyobject kill irubyobject receiver  irubyobject rubythread  block block
if    rubythread instanceof rubythread   throw receiver getruntime   newtypeerror rubythread  receiver getruntime   getthread
return   rubythread rubythread  kill
@jrubymethod name      frame   true  meta   true
public static irubyobject s_exit irubyobject receiver  block block
rubythread rubythread   receiver getruntime   getthreadservice   getcurrentcontext   getthread
synchronized  rubythread
rubythread status   status aborting
rubythread mail   null
receiver getruntime   getthreadservice   setcritical false
throw new threadkill
@jrubymethod name
public rubyboolean stop_p
// not valid for "dead" state
return getruntime   newboolean status    status sleep    status    status dead
@jrubymethod name
public synchronized rubythread wakeup
if  threadimpl isalive      status    status dead
throw getruntime   newthreaderror
status   status run
notifyall
return this
@jrubymethod name
public rubyfixnum priority
return priority
@jrubymethod name      required   1
public irubyobject priority_set irubyobject priority
// fixme: this should probably do some translation from ruby priority levels to java priority levels (until we have green threads)
int ipriority   rubynumeric fix2int priority
if  ipriority < thread min_priority
ipriority   thread min_priority
else if  ipriority > thread max_priority
ipriority   thread max_priority
this priority   rubyfixnum newfixnum getruntime    ipriority
if  threadimpl isalive
threadimpl setpriority ipriority
return this priority
@jrubymethod name      optional   3  frame   true
public irubyobject raise irubyobject args  block block
ruby runtime   getruntime
threadcontext context   runtime getcurrentcontext
if  this    context getthread
return rubykernel raise context  runtime getkernel    args  block
if  debug  system out println     thread currentthread
rubythread currentthread   getruntime   getcurrentcontext   getthread
if  debug  system out println     thread currentthread
irubyobject exception   prepareraiseexception runtime  args  block
runtime getthreadservice   deliverevent new threadservice event currentthread  this  threadservice event type raise  exception
return this
/**
* this is intended to be used to raise exceptions in ruby threads from non-
* ruby threads like timeout's thread.
*
* @param args same args as for thread#raise
* @param block same as for thread#raise
*/
public void internalraise irubyobject args
ruby runtime   getruntime
irubyobject exception   prepareraiseexception runtime  args  block null_block
receivemail new threadservice event this  this  threadservice event type raise  exception
private irubyobject prepareraiseexception ruby runtime  irubyobject args  block block
if args length    0
irubyobject lastexception   errorinfo
if lastexception isnil
return new raiseexception runtime  runtime getruntimeerror       false  getexception
return lastexception
irubyobject exception
threadcontext context   getruntime   getcurrentcontext
if args length    1
if args instanceof rubystring
return runtime getruntimeerror   newinstance context  args  block
if  args respondsto
return runtime newtypeerror    getexception
exception   args callmethod context
else
if   args respondsto
return runtime newtypeerror    getexception
exception   args callmethod context     args
if   runtime getexception   isinstance exception
return runtime newtypeerror    getexception
if  args length    3
rubyexception  exception  set_backtrace args
return exception
@jrubymethod name
public synchronized irubyobject run
return wakeup
/**
* we can never be sure if a wait will finish because of a java "spurious wakeup".  so if we
* explicitly wakeup and we wait less than requested amount we will return false.  we will
* return true if we sleep right amount or less than right amount via spurious wakeup.
*/
public synchronized boolean sleep long millis  throws interruptedexception
assert this    getruntime   getcurrentcontext   getthread
boolean result   true
synchronized  this
pollthreadevents
try
status   status sleep
wait millis
finally
result    status    status run
pollthreadevents
status   status run
return result
@jrubymethod name
public synchronized irubyobject status
if  threadimpl isalive
// todo: no java stringity
return getruntime   newstring status tostring   tolowercase
else if  exitingexception    null
return getruntime   getnil
else
return getruntime   getfalse
public void entersleep
status   status sleep
public void exitsleep
status   status run
@jrubymethod name
public irubyobject kill
// need to reexamine this
rubythread currentthread   getruntime   getcurrentcontext   getthread
// if the killee thread is the same as the killer thread, just die
if  currentthread    this  throwthreadkill
if  debug  system out println     thread currentthread
currentthread pollthreadevents
getruntime   getthreadservice   deliverevent new threadservice event currentthread  this  threadservice event type kill
if  debug  system out println     thread currentthread
// fixme: is this still necessary?
//        try {
//            threadimpl.join();
//        } catch (interruptedexception ie) {
//            // we were interrupted, check thread events again
//            currentthread.pollthreadevents();
//        } catch (executionexception ie) {
//            // we were interrupted, check thread events again
//            currentthread.pollthreadevents();
//        }
return this
@jrubymethod name
public irubyobject kill_bang
throw getruntime   newnotimplementederror
@jrubymethod name
public irubyobject safe_level
throw getruntime   newnotimplementederror
private boolean iscurrent
return threadimpl iscurrent
public void exceptionraised raiseexception exception
assert iscurrent
rubyexception rubyexception   exception getexception
ruby runtime   rubyexception getruntime
if  runtime getsystemexit   isinstance rubyexception
threadservice getmainthread   raise new irubyobject  rubyexception   block null_block
else if  abortonexception runtime
runtime printerror rubyexception
rubyexception systemexit   rubysystemexit newinstance runtime  1
systemexit message   rubyexception message
systemexit set_backtrace rubyexception backtrace
threadservice getmainthread   raise new irubyobject  systemexit   block null_block
return
else if  runtime getdebug   istrue
runtime printerror exception getexception
exitingexception   exception
private boolean abortonexception ruby runtime
return  runtime isglobalabortonexceptionenabled      abortonexception
public static rubythread mainthread irubyobject receiver
return receiver getruntime   getthreadservice   getmainthread
private volatile selector currentselector
private volatile object currentwaitobject
@deprecated
public boolean selectforaccept rubyio io
return select io  selectionkey op_accept
private volatile selector selector
private synchronized selector getselector selectablechannel channel  throws ioexception
if  selector    null  selector   selector open
return selector
public boolean select rubyio io  int ops
return select io getchannel    io  ops
public boolean select channel channel  rubyio io  int ops
if  channel instanceof selectablechannel
selectablechannel selectable    selectablechannel channel
synchronized  selectable blockinglock
boolean oldblocking   selectable isblocking
selectionkey key   null
try
selectable configureblocking false
if  io    null  io addblockingthread this
currentselector   getselector selectable
key   selectable register currentselector  ops
beforeblockingcall
int result   currentselector select
// check for thread events, in case we've been woken up to die
pollthreadevents
if  result    1
set<selectionkey> keyset   currentselector selectedkeys
if  keyset iterator   next      key
return true
return false
catch  ioexception ioe
throw getruntime   newruntimeerror     ioe
finally
try
if  key    null
key cancel
currentselector selectnow
afterblockingcall
currentselector   null
if  io    null  io removeblockingthread this
selectable configureblocking oldblocking
catch  ioexception ioe
// ignore; i don't like doing it, but it seems like we
// really just need to make all channels non-blocking by
// default and use select when implementing blocking ops,
// so if this remains set non-blocking, perhaps it's not
// such a big deal...
else
// can't select, just have to do a blocking call
return true
public void interrupt
selector selector   currentselector
if  selector    null
selector wakeup
blockingio condition iowait   blockingio
if  iowait    null
iowait cancel
object object   currentwaitobject
if  object    null
synchronized  object
object notify
private volatile blockingio condition blockingio   null
public boolean waitforio threadcontext context  rubyio io  int ops
channel channel   io getchannel
if    channel instanceof selectablechannel
return true
try
io addblockingthread this
blockingio   blockingio newcondition channel  ops
boolean ready   blockingio await
// check for thread events, in case we've been woken up to die
pollthreadevents
return ready
catch  ioexception ioe
throw context getruntime   newruntimeerror     ioe
catch  interruptedexception ex
// fixme: not correct exception
throw context getruntime   newruntimeerror
finally
blockingio   null
io removeblockingthread this
public void beforeblockingcall
entersleep
public void afterblockingcall
exitsleep
private void receivedanexception threadcontext context  irubyobject exception
rubymodule kernelmodule   getruntime   getkernel
if  debug
system out println     thread currentthread         status
kernelmodule callmethod context     exception
public boolean wait_timeout irubyobject o  double timeout  throws interruptedexception
if   timeout    null
long delay_ns    long  timeout   1000000000 0
long start_ns   system nanotime
if  delay_ns > 0
long delay_ms   delay_ns   1000000
int delay_ns_remainder    int   delay_ns % 1000000
try
currentwaitobject   o
status   status sleep
o wait delay_ms  delay_ns_remainder
finally
pollthreadevents
status   status run
currentwaitobject   null
long end_ns   system nanotime
return   end_ns   start_ns   <  delay_ns
else
try
currentwaitobject   o
status   status sleep
o wait
finally
pollthreadevents
status   status run
currentwaitobject   null
return true
@override
public boolean equals object obj
if  obj    null
return false
if  getclass      obj getclass
return false
final rubythread other    rubythread obj
if  this threadimpl    other threadimpl     this threadimpl    null     this threadimpl equals other threadimpl
return false
return true
@override
public int hashcode
int hash   3
hash   97   hash    this threadimpl    null ? this threadimpl hashcode     0
return hash
public string tostring
return threadimpl tostring