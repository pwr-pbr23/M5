/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2001-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2004-2007 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby runtime
import org jruby ruby
import org jruby rubymodule
import org jruby ast iternode
import org jruby ast listnode
import org jruby ast multipleasgnnode
import org jruby ast nilimplicitnode
import org jruby ast node
import org jruby ast nodetype
import org jruby ast zeroargnode
import org jruby exceptions jumpexception
import org jruby parser staticscope
import org jruby runtime assigner assigner
import org jruby runtime assigner pre0rest0post0assigner
import org jruby runtime assigner pre0rest1post0assigner
import org jruby runtime assigner pre1expandedrest0post0assigner
import org jruby runtime assigner pre1rest0post0assigner
import org jruby runtime assigner pre1rest1post0assigner
import org jruby runtime assigner pre2rest0post0assigner
import org jruby runtime assigner pre2rest1post0assigner
import org jruby runtime assigner pre3rest0post0assigner
import org jruby runtime assigner pre3rest1post0assigner
import org jruby runtime assigner premanyrest0post0assigner
import org jruby runtime assigner premanyrest1post0assigner
import org jruby runtime builtin irubyobject
/**
* this branch of the blockbody hierarchy represents an interpreted block that
* passes its ast nodes to the interpreter. it forms the top of the hierarchy
* of interpreted blocks. in a typical application, it is the most heavily
* consumed type of block.
*
* @see sharedscopeblock, compiledblock
*/
public class interpretedblock extends blockbody
/** this block has no arguments at all (simple secondary optimization @see assignerfor for an
* explanation).
*/
private boolean noargblock
/** the body of the block, pulled out of bodynode */
private final node bodynode
/** the static scope for the block body */
private staticscope scope
/** the arity of the block */
private final arity arity
/** logic for assigning the blocks local variables */
protected assigner assigner
public static block newinterpretedclosure threadcontext context  iternode iternode  irubyobject self
binding binding   context currentbinding self
nodetype argsnodeid   getargumenttypewackyhack iternode
blockbody body   new interpretedblock
iternode
arity procarityof iternode getvarnode
asargumenttype argsnodeid
return new block body  binding
public static block newinterpretedclosure threadcontext context  blockbody body  irubyobject self
binding binding   context currentbinding self
return new block body  binding
public static blockbody newblockbody iternode iter  arity arity  int argumenttype
return new interpretedblock iter  arity  argumenttype
/*
* determine what sort of assigner should be used for the provided 'iter' (e.g. block).
* assigner provides just the right logic for assigning values to local parameters of the
* block.
*
* this method also has a second optimization which is to set 'noargblock' in the case that
* the block is a block which accepts no arguments.  the primary reason for this second
* optimization is that in the case of a yield with a rubyarray we will bypass some logic
* processing the rubyarray into a proper form (only to then not do anythign with it).  a
* secondary benefit is that a simple boolean seems to optimize by hotspot much faster
* than the zero arg assigner.
*/
private void assignerfor iternode iter
node varnode   iter getvarnode
if  varnode    null    varnode instanceof zeroargnode       no argument blocks
assigner   new pre0rest0post0assigner
noargblock   true
else if  varnode instanceof multipleasgnnode
multipleasgnnode masgn    multipleasgnnode  varnode
int precount   masgn getprecount
boolean isrest   masgn getrest      null
node rest   masgn getrest
listnode pre   masgn getpre
noargblock   false
switch precount
case 0      not sure if this is actually possible  but better safe than sorry
if  isrest
assigner   new pre0rest1post0assigner rest
else
noargblock   true
assigner   new pre0rest0post0assigner
break
case 1
assigner   isrest ? new pre1rest1post0assigner pre get 0   rest
new pre1rest0post0assigner pre get 0
break
case 2
assigner   isrest ? new pre2rest1post0assigner pre get 0   pre get 1   rest
new pre2rest0post0assigner pre get 0   pre get 1
break
case 3
assigner   isrest ? new pre3rest1post0assigner pre get 0   pre get 1   pre get 2   rest
new pre3rest0post0assigner pre get 0   pre get 1   pre get 2
break
default
assigner   isrest ? new premanyrest1post0assigner pre  precount  rest    new premanyrest0post0assigner pre  precount
break
else
assigner    new pre1expandedrest0post0assigner varnode
public interpretedblock iternode iternode  int argumenttype
this iternode  arity procarityof iternode    null ? null   iternode getvarnode     argumenttype
public interpretedblock iternode iternode  arity arity  int argumenttype
super argumenttype
this arity   arity
this bodynode   iternode getbodynode      null ? nilimplicitnode nil   iternode getbodynode
this scope   iternode getscope
assignerfor iternode
protected frame pre threadcontext context  rubymodule klass  binding binding
return context preyieldspecificblock binding  scope  klass
protected void post threadcontext context  binding binding  visibility vis  frame lastframe
binding getframe   setvisibility vis
context postyield binding  lastframe
@override
public irubyobject yieldspecific threadcontext context  binding binding  block type type
return yield context  binding  type
@override
public irubyobject yieldspecific threadcontext context  irubyobject arg0  binding binding  block type type
visibility oldvis   binding getframe   getvisibility
frame lastframe   pre context  null  binding
irubyobject self   prepareself binding
try
if   noargblock  assigner assign context getruntime    context  self  arg0  block null_block
// this while loop is for restarting the block call in case a 'redo' fires.
return evalblockbody context  self
catch  jumpexception nextjump nj
return handlenextjump context  nj  type
finally
post context  binding  oldvis  lastframe
@override
public irubyobject yieldspecific threadcontext context  irubyobject arg0  irubyobject arg1  binding binding  block type type
visibility oldvis   binding getframe   getvisibility
frame lastframe   pre context  null  binding
irubyobject self   prepareself binding
try
if   noargblock  assigner assign context getruntime    context  self  arg0  arg1  block null_block
// this while loop is for restarting the block call in case a 'redo' fires.
return evalblockbody context  self
catch  jumpexception nextjump nj
return handlenextjump context  nj  type
finally
post context  binding  oldvis  lastframe
@override
public irubyobject yieldspecific threadcontext context  irubyobject arg0  irubyobject arg1  irubyobject arg2  binding binding  block type type
visibility oldvis   binding getframe   getvisibility
frame lastframe   pre context  null  binding
irubyobject self   prepareself binding
try
if   noargblock  assigner assign context getruntime    context  self  arg0  arg1  arg2  block null_block
// this while loop is for restarting the block call in case a 'redo' fires.
return evalblockbody context  self
catch  jumpexception nextjump nj
return handlenextjump context  nj  type
finally
post context  binding  oldvis  lastframe
public irubyobject yield threadcontext context  binding binding  block type type
irubyobject self   prepareself binding
visibility oldvis   binding getframe   getvisibility
frame lastframe   pre context  null  binding
try
if   noargblock  assigner assign context getruntime    context  self  block null_block
return evalblockbody context  self
catch  jumpexception nextjump nj
return handlenextjump context  nj  type
finally
post context  binding  oldvis  lastframe
public irubyobject yield threadcontext context  irubyobject value  binding binding  block type type
irubyobject self   prepareself binding
visibility oldvis   binding getframe   getvisibility
frame lastframe   pre context  null  binding
try
if   noargblock  assigner assignarray context getruntime    context  self
assigner converttoarray context getruntime    value   block null_block
return evalblockbody context  self
catch  jumpexception nextjump nj
return handlenextjump context  nj  type
finally
post context  binding  oldvis  lastframe
/**
* yield to this block, usually passed to the current call.
*
* @param context represents the current thread-specific data
* @param value the value to yield, either a single value or an array of values
* @param self the current self
* @param klass
* @param alreadyarray do we need an array or should we assume it already is one?
* @return result of block invocation
*/
public irubyobject yield threadcontext context  irubyobject value  irubyobject self
rubymodule klass  boolean alreadyarray  binding binding  block type type
if  klass    null
self   prepareself binding
visibility oldvis   binding getframe   getvisibility
frame lastframe   pre context  klass  binding
ruby runtime   context getruntime
try
if   noargblock
value   alreadyarray ? assigner convertifalreadyarray runtime  value
assigner converttoarray runtime  value
assigner assignarray runtime  context  self  value  block null_block
// this while loop is for restarting the block call in case a 'redo' fires.
return evalblockbody context  self
catch  jumpexception nextjump nj
return handlenextjump context  nj  type
finally
post context  binding  oldvis  lastframe
private irubyobject evalblockbody threadcontext context  irubyobject self
// this while loop is for restarting the block call in case a 'redo' fires.
while  true
try
return bodynode interpret context getruntime    context  self  block null_block
catch  jumpexception redojump rj
context pollthreadevents
// do nothing, allow loop to redo
catch  stackoverflowerror soe
throw context getruntime   newsystemstackerror    soe
private irubyobject prepareself binding binding
irubyobject self   binding getself
binding getframe   setself self
return self
private irubyobject handlenextjump threadcontext context  jumpexception nextjump nj  block type type
return nj getvalue      null ? context getruntime   getnil      irubyobject nj getvalue
public staticscope getstaticscope
return scope
public void setstaticscope staticscope newscope
this scope   newscope
public block cloneblock binding binding
// we clone dynamic scope because this will be a new instance of a block.  any previously
// captured instances of this block may still be around and we do not want to start
// overwriting those values when we create a new one.
// enebo: once we make self, lastclass, and lastmethod immutable we can remove duplicate
binding   binding clone
return new block this  binding
public node getbodynode
return bodynode
/**
* what is the arity of this block?
*
* @return the arity
*/
public arity arity
return arity