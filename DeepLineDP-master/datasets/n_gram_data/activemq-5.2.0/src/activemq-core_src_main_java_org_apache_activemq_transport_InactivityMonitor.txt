/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport
import java io ioexception
import java util timer
import java util concurrent synchronousqueue
import java util concurrent threadfactory
import java util concurrent threadpoolexecutor
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import org apache activemq command keepaliveinfo
import org apache activemq command wireformatinfo
import org apache activemq thread schedulertimertask
import org apache commons logging log
import org apache commons logging logfactory
/**
* used to make sure that commands are arriving periodically from the peer of
* the transport.
*
* @version $revision$
*/
public class inactivitymonitor extends transportfilter
private static final log log   logfactory getlog inactivitymonitor class
private static final threadpoolexecutor async_tasks
private static int checker_counter
private static timer  read_check_timer
private static timer  write_check_timer
private wireformatinfo localwireformatinfo
private wireformatinfo remotewireformatinfo
private final atomicboolean monitorstarted   new atomicboolean false
private final atomicboolean commandsent   new atomicboolean false
private final atomicboolean insend   new atomicboolean false
private final atomicboolean failed   new atomicboolean false
private final atomicboolean commandreceived   new atomicboolean true
private final atomicboolean inreceive   new atomicboolean false
private schedulertimertask writecheckertask
private schedulertimertask readcheckertask
private long readchecktime
private long writechecktime
private long initialdelaytime
private final runnable readchecker   new runnable
long lastruntime
public void run
long now   system currenttimemillis
long elapsed    now lastruntime
if  lastruntime    0    log isdebugenabled
log debug   elapsed
// perhaps the timer executed a read check late.. and then executes
// the next read check on time which causes the time elapsed between
// read checks to be small..
// if less than 90% of the read check time elapsed then abort this readcheck.
if   allowreadcheck elapsed         funky qdox bug does not allow me to inline this expression
log debug
return
lastruntime   now
readcheck
private boolean allowreadcheck long elapsed
return elapsed >  readchecktime   9   10
private final runnable writechecker   new runnable
long lastruntime
public void run
long now   system currenttimemillis
if  lastruntime    0    log isdebugenabled
log debug    now lastruntime
lastruntime   now
writecheck
public inactivitymonitor transport next
super next
public void stop   throws exception
stopmonitorthreads
next stop
final void writecheck
if  insend get
if  log istraceenabled
log trace
return
if   commandsent get
if log istraceenabled
log trace
async_tasks execute new runnable
public void run
if  monitorstarted get
try
keepaliveinfo info   new keepaliveinfo
info setresponserequired true
oneway info
catch  ioexception e
onexception e
else
if  log istraceenabled
log trace
commandsent set false
final void readcheck
if  inreceive get
if  log istraceenabled
log trace
return
if   commandreceived get
if  log isdebugenabled
log debug     tostring
async_tasks execute new runnable
public void run
onexception new inactivityioexception   next getremoteaddress
else
if  log istraceenabled
log trace
commandreceived set false
public void oncommand object command
commandreceived set true
inreceive set true
try
if  command getclass      keepaliveinfo class
keepaliveinfo info    keepaliveinfo  command
if  info isresponserequired
try
info setresponserequired false
oneway info
catch  ioexception e
onexception e
else
if  command getclass      wireformatinfo class
synchronized  this
ioexception error   null
remotewireformatinfo    wireformatinfo  command
try
startmonitorthreads
catch  ioexception e
error   e
if  error    null
onexception error
synchronized  readchecker
transportlistener oncommand command
finally
inreceive set false
public void oneway object o  throws ioexception
// disable inactivity monitoring while processing a command.
//synchronize this method - its not synchronized
//further down the transport stack and gets called by more
//than one thread  by this class
synchronized insend
insend set true
try
if  failed get
throw new inactivityioexception   next getremoteaddress
if  o getclass      wireformatinfo class
synchronized  this
localwireformatinfo    wireformatinfo o
startmonitorthreads
next oneway o
finally
commandsent set true
insend set false
public void onexception ioexception error
if  failed compareandset false  true
stopmonitorthreads
transportlistener onexception error
private synchronized void startmonitorthreads   throws ioexception
if  monitorstarted get
return
if  localwireformatinfo    null
return
if  remotewireformatinfo    null
return
readchecktime   math min localwireformatinfo getmaxinactivityduration    remotewireformatinfo getmaxinactivityduration
initialdelaytime    math min localwireformatinfo getmaxinactivitydurationinitaldelay    remotewireformatinfo getmaxinactivitydurationinitaldelay
if  readchecktime > 0
monitorstarted set true
writecheckertask   new schedulertimertask writechecker
readcheckertask   new  schedulertimertask readchecker
writechecktime   readchecktime 3
synchronized  inactivitymonitor class
if  checker_counter    0
read_check_timer   new timer   true
write_check_timer   new timer   true
checker_counter
write_check_timer scheduleatfixedrate writecheckertask  initialdelaytime writechecktime
read_check_timer scheduleatfixedrate readcheckertask  initialdelaytime readchecktime
/**
*
*/
private synchronized void stopmonitorthreads
if  monitorstarted compareandset true  false
readcheckertask cancel
writecheckertask cancel
synchronized  inactivitymonitor class
write_check_timer purge
read_check_timer purge
checker_counter
if checker_counter  0
write_check_timer cancel
read_check_timer cancel
write_check_timer   null
read_check_timer   null
static
async_tasks     new threadpoolexecutor 0  integer max_value  10  timeunit seconds  new synchronousqueue<runnable>    new threadfactory
public thread newthread runnable runnable
thread thread   new thread runnable    runnable
thread setdaemon true
return thread