/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker
import java io ioexception
import java net uri
import java util hashmap
import java util iterator
import java util linkedlist
import java util list
import java util map
import java util properties
import java util concurrent concurrenthashmap
import java util concurrent countdownlatch
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomicinteger
import java util concurrent atomic atomicreference
import java util concurrent locks reentrantreadwritelock
import org apache activemq broker ft masterbroker
import org apache activemq broker region connectionstatistics
import org apache activemq broker region regionbroker
import org apache activemq command brokerinfo
import org apache activemq command command
import org apache activemq command commandtypes
import org apache activemq command connectioncontrol
import org apache activemq command connectionerror
import org apache activemq command connectionid
import org apache activemq command connectioninfo
import org apache activemq command consumercontrol
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command controlcommand
import org apache activemq command dataarrayresponse
import org apache activemq command destinationinfo
import org apache activemq command exceptionresponse
import org apache activemq command flushcommand
import org apache activemq command integerresponse
import org apache activemq command keepaliveinfo
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messagedispatch
import org apache activemq command messagedispatchnotification
import org apache activemq command messagepull
import org apache activemq command producerack
import org apache activemq command producerid
import org apache activemq command producerinfo
import org apache activemq command removesubscriptioninfo
import org apache activemq command response
import org apache activemq command sessionid
import org apache activemq command sessioninfo
import org apache activemq command shutdowninfo
import org apache activemq command transactionid
import org apache activemq command transactioninfo
import org apache activemq command wireformatinfo
import org apache activemq network demandforwardingbridge
import org apache activemq network networkbridgeconfiguration
import org apache activemq network networkbridgefactory
import org apache activemq security messageauthorizationpolicy
import org apache activemq state commandvisitor
import org apache activemq state connectionstate
import org apache activemq state consumerstate
import org apache activemq state producerstate
import org apache activemq state sessionstate
import org apache activemq state transactionstate
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq transaction transaction
import org apache activemq transport defaulttransportlistener
import org apache activemq transport responsecorrelator
import org apache activemq transport transport
import org apache activemq transport transportfactory
import org apache activemq util introspectionsupport
import org apache activemq util marshallingsupport
import org apache activemq util servicesupport
import org apache activemq util urisupport
import org apache commons logging log
import org apache commons logging logfactory
/**
* @version $revision: 1.8 $
*/
public class transportconnection implements connection  task  commandvisitor
private static final log log   logfactory getlog transportconnection class
private static final log transportlog   logfactory getlog transportconnection class getname
private static final log servicelog   logfactory getlog transportconnection class getname
// keeps track of the broker and connector that created this connection.
protected final broker broker
protected final transportconnector connector
// keeps track of the state of the connections.
// protected final concurrenthashmap localconnectionstates=new
// concurrenthashmap();
protected final map<connectionid  connectionstate> brokerconnectionstates
// the broker and wireformat info that was exchanged.
protected brokerinfo brokerinfo
protected final list<command> dispatchqueue   new linkedlist<command>
protected taskrunner taskrunner
protected final atomicreference<ioexception> transportexception   new atomicreference<ioexception>
protected atomicboolean dispatchstopped   new atomicboolean false
private masterbroker masterbroker
private final transport transport
private messageauthorizationpolicy messageauthorizationpolicy
private wireformatinfo wireformatinfo
// used to do async dispatch.. this should perhaps be pushed down into the
// transport layer..
private boolean inserviceexception
private connectionstatistics statistics   new connectionstatistics
private boolean manageable
private boolean slow
private boolean markedcandidate
private boolean blockedcandidate
private boolean blocked
private boolean connected
private boolean active
private boolean starting
private boolean pendingstop
private long timestamp
private final atomicboolean stopping   new atomicboolean false
private countdownlatch stopped   new countdownlatch 1
private final atomicboolean asyncexception   new atomicboolean false
private final map<producerid  producerbrokerexchange> producerexchanges   new hashmap<producerid  producerbrokerexchange>
private final map<consumerid  consumerbrokerexchange> consumerexchanges   new hashmap<consumerid  consumerbrokerexchange>
private countdownlatch dispatchstoppedlatch   new countdownlatch 1
private connectioncontext context
private boolean networkconnection
private boolean faulttolerantconnection
private atomicinteger protocolversion   new atomicinteger commandtypes protocol_version
private demandforwardingbridge duplexbridge
private final taskrunnerfactory taskrunnerfactory
private transportconnectionstateregister connectionstateregister   new singletransportconnectionstateregister
private final reentrantreadwritelock servicelock   new reentrantreadwritelock
/**
* @param connector
* @param transport
* @param broker
* @param taskrunnerfactory - can be null if you want direct dispatch to the
*                transport else commands are sent async.
*/
public transportconnection transportconnector connector  final transport transport  broker broker
taskrunnerfactory taskrunnerfactory
this connector   connector
this broker   broker
this messageauthorizationpolicy   connector getmessageauthorizationpolicy
regionbroker rb    regionbroker broker getadaptor regionbroker class
brokerconnectionstates   rb getconnectionstates
if  connector    null
this statistics setparent connector getstatistics
this taskrunnerfactory   taskrunnerfactory
this transport   transport
this transport settransportlistener new defaulttransportlistener
public void oncommand object o
servicelock readlock   lock
try
command command    command o
response response   service command
if  response    null
dispatchsync response
finally
servicelock readlock   unlock
public void onexception ioexception exception
servicelock readlock   lock
try
servicetransportexception exception
finally
servicelock readlock   unlock
connected   true
/**
* returns the number of messages to be dispatched to this connection
*
* @return size of dispatch queue
*/
public int getdispatchqueuesize
synchronized dispatchqueue
return dispatchqueue size
public void servicetransportexception ioexception e
brokerservice bservice connector getbrokerservice
if bservice isshutdownonslavefailure
if brokerinfo  null
if brokerinfo isslavebroker
log error     e getmessage      e
try
broker stop
bservice stop
catch exception ex
log warn   ex
if   stopping get
transportexception set e
if  transportlog isdebugenabled
transportlog debug     e  e
stopasync
/**
* calls the serviceexception method in an async thread. since handling a
* service exception closes a socket, we should not tie up broker threads
* since client sockets may hang or cause deadlocks.
*
* @param e
*/
public void serviceexceptionasync final ioexception e
if  asyncexception compareandset false  true
new thread
public void run
serviceexception e
start
/**
* closes a clients connection due to a detected error. errors are ignored
* if: the client is closing or broker is closing. otherwise, the connection
* error transmitted to the client before stopping it's transport.
*/
public void serviceexception throwable e
// are we a transport exception such as not being able to dispatch
// synchronously to a transport
if  e instanceof ioexception
servicetransportexception  ioexception e
else if  e getclass      brokerstoppedexception class
// handle the case where the broker is stopped
// but the client is still connected.
if   stopping get
if  servicelog isdebugenabled
servicelog
debug
connectionerror ce   new connectionerror
ce setexception e
dispatchsync ce
// wait a little bit to try to get the output buffer to flush
// the exption notification to the client.
try
thread sleep 500
catch  interruptedexception ie
thread currentthread   interrupt
// worst case is we just kill the connection before the
// notification gets to him.
stopasync
else if   stopping get       inserviceexception
inserviceexception   true
try
servicelog error     e  e
connectionerror ce   new connectionerror
ce setexception e
dispatchasync ce
finally
inserviceexception   false
public response service command command
response response   null
boolean responserequired   command isresponserequired
int commandid   command getcommandid
try
response   command visit this
catch  throwable e
if  responserequired
if  servicelog isdebugenabled      e getclass      brokerstoppedexception class
servicelog debug     e  e
response   new exceptionresponse e
else
serviceexception e
if  responserequired
if  response    null
response   new response
response setcorrelationid commandid
// the context may have been flagged so that the response is not
// sent.
if  context    null
if  context isdontsendreponse
context setdontsendreponse false
response   null
context   null
return response
public response processkeepalive keepaliveinfo info  throws exception
return null
public response processremovesubscription removesubscriptioninfo info  throws exception
broker removesubscription lookupconnectionstate info getconnectionid    getcontext    info
return null
public response processwireformat wireformatinfo info  throws exception
wireformatinfo   info
protocolversion set info getversion
return null
public response processshutdown shutdowninfo info  throws exception
stopasync
return null
public response processflush flushcommand command  throws exception
return null
public response processbegintransaction transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   null
if  cs    null
context   cs getcontext
if  cs    null
throw new nullpointerexception
// avoid replaying dup commands
if  cs gettransactionstate info gettransactionid       null
cs addtransactionstate info gettransactionid
broker begintransaction context  info gettransactionid
return null
public response processendtransaction transactioninfo info  throws exception
// no need to do anything. this packet is just sent by the client
// make sure he is synced with the server as commit command could
// come from a different connection.
return null
public response processpreparetransaction transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   null
if  cs    null
context   cs getcontext
if  cs    null
throw new nullpointerexception
transactionstate transactionstate   cs gettransactionstate info gettransactionid
if  transactionstate    null
throw new illegalstateexception
info gettransactionid
// avoid dups.
if   transactionstate isprepared
transactionstate setprepared true
int result   broker preparetransaction context  info gettransactionid
transactionstate setpreparedresult result
integerresponse response   new integerresponse result
return response
else
integerresponse response   new integerresponse transactionstate getpreparedresult
return response
public response processcommittransactiononephase transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
cs removetransactionstate info gettransactionid
broker committransaction context  info gettransactionid    true
return null
public response processcommittransactiontwophase transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
cs removetransactionstate info gettransactionid
broker committransaction context  info gettransactionid    false
return null
public response processrollbacktransaction transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
cs removetransactionstate info gettransactionid
broker rollbacktransaction context  info gettransactionid
return null
public response processforgettransaction transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
broker forgettransaction context  info gettransactionid
return null
public response processrecovertransactions transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
transactionid preparedtransactions   broker getpreparedtransactions context
return new dataarrayresponse preparedtransactions
public response processmessage message messagesend  throws exception
producerid producerid   messagesend getproducerid
producerbrokerexchange producerexchange   getproducerbrokerexchange producerid
broker send producerexchange  messagesend
return null
public response processmessageack messageack ack  throws exception
consumerbrokerexchange consumerexchange   getconsumerbrokerexchange ack getconsumerid
broker acknowledge consumerexchange  ack
return null
public response processmessagepull messagepull pull  throws exception
return broker messagepull lookupconnectionstate pull getconsumerid    getcontext    pull
public response processmessagedispatchnotification messagedispatchnotification notification
throws exception
broker processdispatchnotification notification
return null
public response processadddestination destinationinfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
broker adddestinationinfo cs getcontext    info
if  info getdestination   istemporary
cs addtempdestination info
return null
public response processremovedestination destinationinfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
broker removedestinationinfo cs getcontext    info
if  info getdestination   istemporary
cs removetempdestination info getdestination
return null
public response processaddproducer producerinfo info  throws exception
sessionid sessionid   info getproducerid   getparentid
connectionid connectionid   sessionid getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
sessionstate ss   cs getsessionstate sessionid
if  ss    null
throw new illegalstateexception
sessionid
// avoid replaying dup commands
if   ss getproducerids   contains info getproducerid
broker addproducer cs getcontext    info
try
ss addproducer info
catch  illegalstateexception e
broker removeproducer cs getcontext    info
return null
public response processremoveproducer producerid id  throws exception
sessionid sessionid   id getparentid
connectionid connectionid   sessionid getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
sessionstate ss   cs getsessionstate sessionid
if  ss    null
throw new illegalstateexception
sessionid
producerstate ps   ss removeproducer id
if  ps    null
throw new illegalstateexception     id
removeproducerbrokerexchange id
broker removeproducer cs getcontext    ps getinfo
return null
public response processaddconsumer consumerinfo info  throws exception
sessionid sessionid   info getconsumerid   getparentid
connectionid connectionid   sessionid getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
sessionstate ss   cs getsessionstate sessionid
if  ss    null
throw new illegalstateexception
broker getbrokername
sessionid
// avoid replaying dup commands
if   ss getconsumerids   contains info getconsumerid
broker addconsumer cs getcontext    info
try
ss addconsumer info
catch  illegalstateexception e
broker removeconsumer cs getcontext    info
return null
public response processremoveconsumer consumerid id  throws exception
sessionid sessionid   id getparentid
connectionid connectionid   sessionid getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
sessionstate ss   cs getsessionstate sessionid
if  ss    null
throw new illegalstateexception
sessionid
consumerstate consumerstate   ss removeconsumer id
if  consumerstate    null
throw new illegalstateexception     id
broker removeconsumer cs getcontext    consumerstate getinfo
removeconsumerbrokerexchange id
return null
public response processaddsession sessioninfo info  throws exception
connectionid connectionid   info getsessionid   getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
// avoid replaying dup commands
if   cs getsessionids   contains info getsessionid
broker addsession cs getcontext    info
try
cs addsession info
catch  illegalstateexception e
e printstacktrace
broker removesession cs getcontext    info
return null
public response processremovesession sessionid id  throws exception
connectionid connectionid   id getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
sessionstate session   cs getsessionstate id
if  session    null
throw new illegalstateexception     id
// don't let new consumers or producers get added while we are closing
// this down.
session shutdown
// cascade the connection stop to the consumers and producers.
for  iterator iter   session getconsumerids   iterator    iter hasnext
consumerid consumerid    consumerid iter next
try
processremoveconsumer consumerid
catch  throwable e
log warn     consumerid       e  e
for  iterator iter   session getproducerids   iterator    iter hasnext
producerid producerid    producerid iter next
try
processremoveproducer producerid
catch  throwable e
log warn     producerid       e  e
cs removesession id
broker removesession cs getcontext    session getinfo
return null
public response processaddconnection connectioninfo info  throws exception
//if the broker service has slave attached, wait for the slave to be attached to allow client connection. slave connection is fine
if  info isbrokermasterconnector    connector getbrokerservice   iswaitforslave    connector getbrokerservice   getslavestartsignal   getcount    1
servicesupport dispose transport
return new exceptionresponse new exception
// older clients should have been defaulting this field to true.. but they were not.
if  wireformatinfo  null    wireformatinfo getversion   <  2
info setclientmaster true
transportconnectionstate state
// make sure 2 concurrent connections by the same id only generate 1
// transportconnectionstate object.
synchronized  brokerconnectionstates
state    transportconnectionstate brokerconnectionstates get info getconnectionid
if  state    null
state   new transportconnectionstate info  this
brokerconnectionstates put info getconnectionid    state
state incrementreference
// if there are 2 concurrent connections for the same connection id,
// then last one in wins, we need to sync here
// to figure out the winner.
synchronized  state getconnectionmutex
if  state getconnection      this
log debug     state getconnection   getremoteaddress
state getconnection   stop
log debug     getremoteaddress
state getconnection   getremoteaddress
state setconnection this
state reset info
registerconnectionstate info getconnectionid    state
log debug     getremoteaddress
// setup the context.
string clientid   info getclientid
context   new connectioncontext
context setbroker broker
context setclientid clientid
context setclientmaster info isclientmaster
context setconnection this
context setconnectionid info getconnectionid
context setconnector connector
context setmessageauthorizationpolicy getmessageauthorizationpolicy
context setnetworkconnection networkconnection
context setfaulttolerant faulttolerantconnection
context settransactions new concurrenthashmap<transactionid  transaction>
context setusername info getusername
context setwireformatinfo wireformatinfo
this manageable   info ismanageable
state setcontext context
state setconnection this
try
broker addconnection context  info
catch exception e
brokerconnectionstates remove info
log warn   e
throw e
if  info ismanageable      broker isfaulttolerantconfiguration
// send connectioncommand
connectioncontrol command   new connectioncontrol
command setfaulttolerant broker isfaulttolerantconfiguration
dispatchasync command
return null
public synchronized response processremoveconnection connectionid id  throws interruptedexception
transportconnectionstate cs   lookupconnectionstate id
if  cs    null
// don't allow things to be added to the connection state while we are
// shutting down.
cs shutdown
// cascade the connection stop to the sessions.
for  iterator iter   cs getsessionids   iterator    iter hasnext
sessionid sessionid    sessionid iter next
try
processremovesession sessionid
catch  throwable e
servicelog warn     sessionid  e
// cascade the connection stop to temp destinations.
for  iterator iter   cs gettempdesinations   iterator    iter hasnext
destinationinfo di    destinationinfo iter next
try
broker removedestination cs getcontext    di getdestination    0
catch  throwable e
servicelog warn     di getdestination    e
iter remove
try
broker removeconnection cs getcontext    cs getinfo    null
catch  throwable e
servicelog warn     cs getinfo    e
transportconnectionstate state   unregisterconnectionstate id
if  state    null
synchronized  brokerconnectionstates
// if we are the last reference, we should remove the state
// from the broker.
if  state decrementreference      0
brokerconnectionstates remove id
return null
public response processproducerack producerack ack  throws exception
// a broker should not get producerack messages.
return null
public connector getconnector
return connector
public void dispatchsync command message
//getstatistics().getenqueues().increment();
try
processdispatch message
catch  ioexception e
serviceexceptionasync e
public void dispatchasync command message
if   stopping get
//getstatistics().getenqueues().increment();
if  taskrunner    null
dispatchsync message
else
synchronized dispatchqueue
dispatchqueue add message
try
taskrunner wakeup
catch  interruptedexception e
thread currentthread   interrupt
else
if  message ismessagedispatch
messagedispatch md    messagedispatch message
runnable sub   md gettransmitcallback
broker postprocessdispatch md
if  sub    null
sub run
protected void processdispatch command command  throws ioexception
final messagedispatch messagedispatch    messagedispatch  command ismessagedispatch
? command   null
try
if   stopping get
if  messagedispatch    null
broker preprocessdispatch messagedispatch
dispatch command
finally
if  messagedispatch    null
runnable sub   messagedispatch gettransmitcallback
broker postprocessdispatch messagedispatch
if  sub    null
sub run
//getstatistics().getdequeues().increment();
public boolean iterate
try
if  stopping get
if  dispatchstopped compareandset false  true
if  transportexception get      null
try
dispatch new shutdowninfo
catch  throwable ignore
dispatchstoppedlatch countdown
return false
if   dispatchstopped get
command command   null
synchronized dispatchqueue
if  dispatchqueue isempty
return false
command   dispatchqueue remove 0
processdispatch command
return true
return false
catch  ioexception e
if  dispatchstopped compareandset false  true
dispatchstoppedlatch countdown
serviceexceptionasync e
return false
/**
* returns the statistics for this connection
*/
public connectionstatistics getstatistics
return statistics
public messageauthorizationpolicy getmessageauthorizationpolicy
return messageauthorizationpolicy
public void setmessageauthorizationpolicy messageauthorizationpolicy messageauthorizationpolicy
this messageauthorizationpolicy   messageauthorizationpolicy
public boolean ismanageable
return manageable
public void start   throws exception
starting   true
try
synchronized this
if  taskrunnerfactory    null
taskrunner   taskrunnerfactory createtaskrunner this
getremoteaddress
else
taskrunner   null
transport start
active   true
dispatchasync connector getbrokerinfo
connector onstarted this
catch  exception e
// force clean up on an error starting up.
stop
throw e
finally
// stop() can be called from within the above block,
// but we want to be sure start() completes before
// stop() runs, so queue the stop until right now:
starting   false
if  pendingstop
log debug
stop
public void stop   throws exception
synchronized  this
pendingstop   true
if  starting
log debug
return
stopasync
while   stopped await 5  timeunit seconds
log info     transport getremoteaddress
public void stopasync
// if we're in the middle of starting
// then go no further... for now.
if  stopping compareandset false  true
// let all the connection contexts know we are shutting down
// so that in progress operations can notice and unblock.
list<transportconnectionstate> connectionstates   listconnectionstates
for  transportconnectionstate cs   connectionstates
cs getcontext   getstopping   set true
new thread    transport getremoteaddress
@override
public void run
servicelock writelock   lock
try
dostop
catch  throwable e
log debug     transport getremoteaddress       e
finally
stopped countdown
servicelock writelock   unlock
start
@override
public string tostring
return    transport getremoteaddress
protected void dostop   throws exception  interruptedexception
log debug     transport getremoteaddress
connector onstopped this
try
synchronized  this
if  masterbroker    null
masterbroker stop
if  duplexbridge    null
duplexbridge stop
catch  exception ignore
log trace    ignore
try
transport stop
log debug     transport getremoteaddress
catch  exception e
log debug     e  e
if  taskrunner    null
taskrunner shutdown 1
active   false
// run the messagedispatch callbacks so that message references get
// cleaned up.
synchronized dispatchqueue
for  iterator<command> iter   dispatchqueue iterator    iter hasnext
command command   iter next
if  command ismessagedispatch
messagedispatch md    messagedispatch command
runnable sub   md gettransmitcallback
broker postprocessdispatch md
if  sub    null
sub run
dispatchqueue clear
//
// remove all logical connection associated with this connection
// from the broker.
if   broker isstopped
list<transportconnectionstate> connectionstates   listconnectionstates
connectionstates   listconnectionstates
for  transportconnectionstate cs   connectionstates
cs getcontext   getstopping   set true
try
log debug     getremoteaddress
processremoveconnection cs getinfo   getconnectionid
catch  throwable ignore
ignore printstacktrace
if  brokerinfo    null
broker removebroker this  brokerinfo
log debug     getremoteaddress
/**
* @return returns the blockedcandidate.
*/
public boolean isblockedcandidate
return blockedcandidate
/**
* @param blockedcandidate the blockedcandidate to set.
*/
public void setblockedcandidate boolean blockedcandidate
this blockedcandidate   blockedcandidate
/**
* @return returns the markedcandidate.
*/
public boolean ismarkedcandidate
return markedcandidate
/**
* @param markedcandidate the markedcandidate to set.
*/
public void setmarkedcandidate boolean markedcandidate
this markedcandidate   markedcandidate
if   markedcandidate
timestamp   0
blockedcandidate   false
/**
* @param slow the slow to set.
*/
public void setslow boolean slow
this slow   slow
/**
* @return true if the connection is slow
*/
public boolean isslow
return slow
/**
* @return true if the connection is potentially blocked
*/
public boolean ismarkedblockedcandidate
return markedcandidate
/**
* mark the connection, so we can deem if it's collectable on the next sweep
*/
public void domark
if  timestamp    0
timestamp   system currenttimemillis
/**
* @return if after being marked, the connection is still writing
*/
public boolean isblocked
return blocked
/**
* @return true if the connection is connected
*/
public boolean isconnected
return connected
/**
* @param blocked the blocked to set.
*/
public void setblocked boolean blocked
this blocked   blocked
/**
* @param connected the connected to set.
*/
public void setconnected boolean connected
this connected   connected
/**
* @return true if the connection is active
*/
public boolean isactive
return active
/**
* @param active the active to set.
*/
public void setactive boolean active
this active   active
/**
* @return true if the connection is starting
*/
public synchronized boolean isstarting
return starting
public synchronized boolean isnetworkconnection
return networkconnection
protected synchronized void setstarting boolean starting
this starting   starting
/**
* @return true if the connection needs to stop
*/
public synchronized boolean ispendingstop
return pendingstop
protected synchronized void setpendingstop boolean pendingstop
this pendingstop   pendingstop
public response processbrokerinfo brokerinfo info
if  info isslavebroker
// stream messages from this broker (the master) to
// the slave
mutablebrokerfilter parent    mutablebrokerfilter broker getadaptor mutablebrokerfilter class
masterbroker   new masterbroker parent  transport
masterbroker startprocessing
log info     info getbrokername
brokerservice bservice connector getbrokerservice
bservice slaveconnectionestablished
else if  info isnetworkconnection      info isduplexconnection
// so this transportconnection is the rear end of a network bridge
// we have been requested to create a two way pipe ...
try
properties properties   marshallingsupport stringtoproperties info getnetworkproperties
map<string  string> props   createmap properties
networkbridgeconfiguration config   new networkbridgeconfiguration
introspectionsupport setproperties config  props
config setbrokername broker getbrokername
uri uri   broker getvmconnectoruri
hashmap<string  string> map   new hashmap<string  string> urisupport parseparamters uri
map put
map put
uri   urisupport createuriwithquery uri  urisupport createquerystring map
transport localtransport   transportfactory connect uri
transport remotebridgetransport   new responsecorrelator transport
duplexbridge   networkbridgefactory createbridge config  localtransport
remotebridgetransport
// now turn duplex off this side
info setduplexconnection false
duplexbridge setcreatedbyduplex true
duplexbridge duplexstart this brokerinfo  info
log info     info getbrokername
return null
catch  exception e
log error    e
// we only expect to get one broker info command per connection
if  this brokerinfo    null
log warn     info
this brokerinfo   info
broker addbroker this  info
networkconnection   true
list<transportconnectionstate> connectionstates   listconnectionstates
for  transportconnectionstate cs   connectionstates
cs getcontext   setnetworkconnection true
return null
@suppresswarnings
private hashmap<string  string> createmap properties properties
return new hashmap properties
protected void dispatch command command  throws ioexception
try
setmarkedcandidate true
transport oneway command
finally
setmarkedcandidate false
public string getremoteaddress
return transport getremoteaddress
public string getconnectionid
list<transportconnectionstate> connectionstates   listconnectionstates
for  transportconnectionstate cs   connectionstates
if  cs getinfo   getclientid      null
return cs getinfo   getclientid
return cs getinfo   getconnectionid   tostring
return null
private producerbrokerexchange getproducerbrokerexchange producerid id
producerbrokerexchange result   producerexchanges get id
if  result    null
synchronized  producerexchanges
result   new producerbrokerexchange
transportconnectionstate state   lookupconnectionstate id
context   state getcontext
result setconnectioncontext context
sessionstate ss   state getsessionstate id getparentid
if  ss    null
result setproducerstate ss getproducerstate id
producerstate producerstate   ss getproducerstate id
if  producerstate    null    producerstate getinfo      null
producerinfo info   producerstate getinfo
result setmutable info getdestination      null
info getdestination   iscomposite
producerexchanges put id  result
else
context   result getconnectioncontext
return result
private void removeproducerbrokerexchange producerid id
synchronized  producerexchanges
producerexchanges remove id
private consumerbrokerexchange getconsumerbrokerexchange consumerid id
consumerbrokerexchange result   consumerexchanges get id
if  result    null
synchronized  consumerexchanges
result   new consumerbrokerexchange
transportconnectionstate state   lookupconnectionstate id
context   state getcontext
result setconnectioncontext context
sessionstate ss   state getsessionstate id getparentid
if  ss    null
consumerstate cs   ss getconsumerstate id
if  cs    null
consumerinfo info   cs getinfo
if  info    null
if  info getdestination      null    info getdestination   ispattern
result setwildcard true
consumerexchanges put id  result
return result
private void removeconsumerbrokerexchange consumerid id
synchronized  consumerexchanges
consumerexchanges remove id
public int getprotocolversion
return protocolversion get
public response processcontrolcommand controlcommand command  throws exception
string control   command getcommand
if  control    null    control equals
system exit 0
return null
public response processmessagedispatch messagedispatch dispatch  throws exception
return null
public response processconnectioncontrol connectioncontrol control  throws exception
if control    null
faulttolerantconnection control isfaulttolerant
return null
public response processconnectionerror connectionerror error  throws exception
return null
public response processconsumercontrol consumercontrol control  throws exception
return null
protected synchronized transportconnectionstate registerconnectionstate connectionid connectionid transportconnectionstate state
transportconnectionstate cs   null
if   connectionstateregister isempty       connectionstateregister doeshandlemultipleconnectionstates
//swap implementations
transportconnectionstateregister newregister   new maptransportconnectionstateregister
newregister intialize connectionstateregister
connectionstateregister   newregister
cs  connectionstateregister registerconnectionstate connectionid  state
return cs
protected synchronized transportconnectionstate unregisterconnectionstate connectionid connectionid
return connectionstateregister unregisterconnectionstate connectionid
protected synchronized list<transportconnectionstate> listconnectionstates
return connectionstateregister listconnectionstates
protected synchronized transportconnectionstate lookupconnectionstate string connectionid
return connectionstateregister lookupconnectionstate connectionid
protected synchronized transportconnectionstate lookupconnectionstate consumerid id
return connectionstateregister lookupconnectionstate id
protected synchronized transportconnectionstate lookupconnectionstate producerid id
return connectionstateregister lookupconnectionstate id
protected synchronized transportconnectionstate lookupconnectionstate sessionid id
return connectionstateregister lookupconnectionstate id
protected synchronized transportconnectionstate lookupconnectionstate connectionid connectionid
return connectionstateregister lookupconnectionstate connectionid