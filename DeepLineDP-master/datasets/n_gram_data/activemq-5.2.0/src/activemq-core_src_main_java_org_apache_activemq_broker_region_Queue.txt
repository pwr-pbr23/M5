/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region
import java io ioexception
import java util arraylist
import java util collections
import java util comparator
import java util hashset
import java util iterator
import java util linkedhashmap
import java util linkedlist
import java util list
import java util set
import java util concurrent copyonwritearrayset
import java util concurrent executorservice
import java util concurrent executors
import java util concurrent threadfactory
import java util concurrent locks reentrantlock
import javax jms invalidselectorexception
import javax jms jmsexception
import org apache activemq broker brokerservice
import org apache activemq broker connectioncontext
import org apache activemq broker producerbrokerexchange
import org apache activemq broker region cursors pendingmessagecursor
import org apache activemq broker region cursors storequeuecursor
import org apache activemq broker region cursors vmpendingmessagecursor
import org apache activemq broker region group messagegrouphashbucketfactory
import org apache activemq broker region group messagegroupmap
import org apache activemq broker region group messagegroupmapfactory
import org apache activemq broker region group messagegroupset
import org apache activemq broker region policy dispatchpolicy
import org apache activemq broker region policy roundrobindispatchpolicy
import org apache activemq command activemqdestination
import org apache activemq command consumerid
import org apache activemq command exceptionresponse
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messageid
import org apache activemq command producerack
import org apache activemq command producerinfo
import org apache activemq command response
import org apache activemq filter booleanexpression
import org apache activemq filter messageevaluationcontext
import org apache activemq filter noncachedmessageevaluationcontext
import org apache activemq selector selectorparser
import org apache activemq store messagerecoverylistener
import org apache activemq store messagestore
import org apache activemq thread deterministictaskrunner
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq transaction synchronization
import org apache activemq util brokersupport
import org apache commons logging log
import org apache commons logging logfactory
/**
* the queue is a list of messageentry objects that are dispatched to matching
* subscriptions.
*
* @version $revision: 1.28 $
*/
public class queue extends basedestination implements task
protected static final log log   logfactory getlog queue class
protected taskrunnerfactory taskfactory
protected taskrunner taskrunner
protected final list<subscription> consumers   new arraylist<subscription> 50
protected pendingmessagecursor messages
private final linkedhashmap<messageid queuemessagereference> pagedinmessages   new linkedhashmap<messageid queuemessagereference>
// messages that are paged in but have not yet been targeted at a subscription
private list<queuemessagereference> pagedinpendingdispatch   new arraylist<queuemessagereference> 100
private messagegroupmap messagegroupowners
private dispatchpolicy dispatchpolicy   new roundrobindispatchpolicy
private messagegroupmapfactory messagegroupmapfactory   new messagegrouphashbucketfactory
private final object sendlock   new object
private executorservice executor
protected final linkedlist<runnable> messageswaitingforspace   new linkedlist<runnable>
private final reentrantlock dispatchlock   new reentrantlock
private boolean useconsumerpriority true
private boolean strictorderdispatch false
private queuedispatchselector  dispatchselector
private boolean optimizeddispatch false
private final runnable sendmessageswaitingforspacetask   new runnable
public void run
wakeup
private final object iteratingmutex   new object
private static final comparator<subscription>orderedcompare   new comparator<subscription>
public int compare subscription s1  subscription s2
//we want the list sorted in descending order
return s2 getconsumerinfo   getpriority     s1 getconsumerinfo   getpriority
public queue brokerservice brokerservice  final activemqdestination destination  messagestore store destinationstatistics parentstats
taskrunnerfactory taskfactory  throws exception
super brokerservice  store  destination  parentstats
this taskfactory taskfactory
this dispatchselector new queuedispatchselector destination
public list<subscription> getconsumers
synchronized  consumers
return new arraylist<subscription> consumers
public void initialize   throws exception
if  this messages    null
if  destination istemporary      broker    null    store    null
this messages   new vmpendingmessagecursor
else
this messages   new storequeuecursor broker  this
// if a vmpendingmessagecursor don't use the default producer system usage
// since it turns into a shared blocking queue which can lead to a network deadlock.
// if we are ccursoring to disk..it's not and issue because it does not block due
// to large disk sizes.
if  messages instanceof vmpendingmessagecursor
this systemusage   brokerservice getsystemusage
memoryusage setparent systemusage getmemoryusage
if  isoptimizeddispatch
this taskrunner   taskfactory createtaskrunner this      destination getphysicalname
else
this executor    executors newsinglethreadexecutor new threadfactory
public thread newthread runnable runnable
thread thread   new thread runnable    destination
thread setdaemon true
thread setpriority thread norm_priority
return thread
this taskrunner   new deterministictaskrunner this executor this
super initialize
if  store    null
// restore the persistent messages.
messages setsystemusage systemusage
messages setenableaudit isenableaudit
messages setmaxauditdepth getmaxauditdepth
messages setmaxproducerstoaudit getmaxproducerstoaudit
messages setusecache isusecache
if  messages isrecoveryrequired
store recover new messagerecoverylistener
public boolean recovermessage message message
// message could have expired while it was being
// loaded..
if  broker isexpired message
messageexpired createconnectioncontext    message
return true
if  hasspace
message setregiondestination queue this
synchronized  messages
try
messages addmessagelast message
catch  exception e
log fatal    e
destinationstatistics getmessages   increment
return true
return false
public boolean recovermessagereference messageid messagereference  throws exception
throw new runtimeexception
public boolean hasspace
return true
else
int messagecount   store getmessagecount
destinationstatistics getmessages   setcount messagecount
class recoverydispatch
public arraylist<queuemessagereference> messages
public subscription subscription
linkedlist<recoverydispatch> recoveries   new linkedlist<recoverydispatch>
public void addsubscription connectioncontext context  subscription sub  throws exception
// synchronize with dispatch method so that no new messages are sent
// while setting up a subscription. avoid out of order messages,
// duplicates, etc.
dispatchlock lock
try
sub add context  this
destinationstatistics getconsumers   increment
// needs to be synchronized - so no contention with dispatching
synchronized  consumers
addtoconsumerlist sub
if  sub getconsumerinfo   isexclusive
subscription exclusiveconsumer   dispatchselector getexclusiveconsumer
if exclusiveconsumer  null
exclusiveconsumer sub
else if  sub getconsumerinfo   getpriority   > exclusiveconsumer getconsumerinfo   getpriority
exclusiveconsumer sub
dispatchselector setexclusiveconsumer exclusiveconsumer
// any newly paged in messages that are not dispatched are added to pagedinpending in iterate()
dopagein false
synchronized  pagedinmessages
recoverydispatch rd   new recoverydispatch
rd messages    new arraylist<queuemessagereference> pagedinmessages values
rd subscription   sub
recoveries addlast rd
if  sub instanceof queuebrowsersubscription
queuebrowsersubscription sub  incrementqueueref
if    this optimizeddispatch    isslave
wakeup
finally
dispatchlock unlock
if  this optimizeddispatch    isslave
// outside of dispatchlock() to maintain the lock hierarchy of
// iteratingmutex -> dispatchlock. - see https://issues.apache.org/activemq/browse/amq-1878
wakeup
public void removesubscription connectioncontext context  subscription sub
throws exception
destinationstatistics getconsumers   decrement
// synchronize with dispatch method so that no new messages are sent
// while removing up a subscription.
dispatchlock lock
try
synchronized  consumers
removefromconsumerlist sub
if  sub getconsumerinfo   isexclusive
subscription exclusiveconsumer   dispatchselector
getexclusiveconsumer
if  exclusiveconsumer    sub
exclusiveconsumer   null
for  subscription s   consumers
if  s getconsumerinfo   isexclusive
exclusiveconsumer    null
s getconsumerinfo   getpriority   > exclusiveconsumer
getconsumerinfo   getpriority
exclusiveconsumer   s
dispatchselector setexclusiveconsumer exclusiveconsumer
consumerid consumerid   sub getconsumerinfo   getconsumerid
messagegroupset ownedgroups   getmessagegroupowners
removeconsumer consumerid
// redeliver inflight messages
list<queuemessagereference> list   new arraylist<queuemessagereference>
for  messagereference ref   sub remove context  this
queuemessagereference qmr    queuemessagereference ref
if  qmr getlockowner    sub
qmr unlock
qmr incrementredeliverycounter
list add qmr
if   list isempty       consumers isempty
dodispatch list
if  consumers isempty
messages gc
if    this optimizeddispatch    isslave
wakeup
finally
dispatchlock unlock
if  this optimizeddispatch    isslave
// outside of dispatchlock() to maintain the lock hierarchy of
// iteratingmutex -> dispatchlock. - see https://issues.apache.org/activemq/browse/amq-1878
wakeup
public void send final producerbrokerexchange producerexchange  final message message  throws exception
final connectioncontext context   producerexchange getconnectioncontext
// there is delay between the client sending it and it arriving at the
// destination.. it may have expired.
message setregiondestination this
final producerinfo producerinfo   producerexchange getproducerstate   getinfo
final boolean sendproducerack    message isresponserequired      producerinfo getwindowsize   > 0     context isinrecoverymode
if  message isexpired
//message not stored - or added to stats yet - so chuck here
broker getroot   messageexpired context  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
return
if memoryusage isfull
isfull context  memoryusage
fastproducer context  producerinfo
if  isproducerflowcontrol      context isproducerflowcontrol
if  systemusage issendfailifnospace
throw new javax jms resourceallocationexception
// we can avoid blocking due to low usage if the producer is sending
// a sync message or
// if it is using a producer window
if  producerinfo getwindowsize   > 0    message isresponserequired
synchronized  messageswaitingforspace
messageswaitingforspace add new runnable
public void run
try
// while waiting for space to free up... the
// message may have expired.
if  message isexpired
broker messageexpired context  message
else
domessagesend producerexchange  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
else
response response   new response
response setcorrelationid message getcommandid
context getconnection   dispatchasync response
catch  exception e
if   sendproducerack     context isinrecoverymode
exceptionresponse response   new exceptionresponse e
response setcorrelationid message getcommandid
context getconnection   dispatchasync response
// if the user manager is not full, then the task will not
// get called..
if   memoryusage notifycallbackwhennotfull sendmessageswaitingforspacetask
// so call it directly here.
sendmessageswaitingforspacetask run
context setdontsendreponse true
return
else
// producer flow control cannot be used, so we have do the flow
// control at the broker
// by blocking this thread until there is space available.
while   memoryusage waitforspace 1000
if  context getstopping   get
throw new ioexception
// the usage manager could have delayed us by the time
// we unblock the message could have expired..
if  message isexpired
if  log isdebugenabled
log debug     message
broker getroot   messageexpired context  message
return
domessagesend producerexchange  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
void domessagesend final producerbrokerexchange producerexchange  final message message  throws ioexception  exception
final connectioncontext context   producerexchange getconnectioncontext
synchronized  sendlock
if  store    null    message ispersistent
if  isproducerflowcontrol      context isproducerflowcontrol
if  systemusage issendfailifnospace      systemusage getstoreusage   isfull
throw new javax jms resourceallocationexception
while   systemusage getstoreusage   waitforspace 1000
if  context getstopping   get
throw new ioexception
message getmessageid   setbrokersequenceid getdestinationsequenceid
store addmessage context  message
if  context isintransaction
// if this is a transacted message.. increase the usage now so that
// a big tx does not blow up
// our memory. this increment is decremented once the tx finishes..
message incrementreferencecount
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
try
// it could take while before we receive the commit
// op, by that time the message could have expired..
if  broker isexpired message
broker messageexpired context  message
//message not added to stats yet
//destinationstatistics.getmessages().decrement();
return
sendmessage context  message
finally
message decrementreferencecount
@override
public void afterrollback   throws exception
message decrementreferencecount
else
// add to the pending list, this takes care of incrementing the
// usage manager.
sendmessage context  message
public void dispose connectioncontext context  throws ioexception
super dispose context
if  store    null
store removeallmessages context
public void gc
public void acknowledge connectioncontext context  subscription sub  messageack ack  messagereference node  throws ioexception
messageconsumed context  node
if  store    null    node ispersistent
// the original ack may be a ranged ack, but we are trying to delete
// a specific
// message store here so we need to convert to a non ranged ack.
if  ack getmessagecount   > 0
// dup the ack
messageack a   new messageack
ack copy a
ack   a
// convert to non-ranged.
ack setfirstmessageid node getmessageid
ack setlastmessageid node getmessageid
ack setmessagecount 1
store removemessage context  ack
message loadmessage messageid messageid  throws ioexception
message msg   store getmessage messageid
if  msg    null
msg setregiondestination this
return msg
public string tostring
int size   0
synchronized  messages
size   messages size
return     destination getphysicalname         consumers size         memoryusage getpercentusage         size
messagegroupowners
public void start   throws exception
if  memoryusage    null
memoryusage start
messages start
dopagein false
public void stop   throws exception
if  taskrunner    null
taskrunner shutdown
if  this executor    null
this executor shutdownnow
if  messages    null
messages stop
if  memoryusage    null
memoryusage stop
// properties
// -------------------------------------------------------------------------
public activemqdestination getactivemqdestination
return destination
public messagegroupmap getmessagegroupowners
if  messagegroupowners    null
messagegroupowners   getmessagegroupmapfactory   createmessagegroupmap
return messagegroupowners
public dispatchpolicy getdispatchpolicy
return dispatchpolicy
public void setdispatchpolicy dispatchpolicy dispatchpolicy
this dispatchpolicy   dispatchpolicy
public messagegroupmapfactory getmessagegroupmapfactory
return messagegroupmapfactory
public void setmessagegroupmapfactory messagegroupmapfactory messagegroupmapfactory
this messagegroupmapfactory   messagegroupmapfactory
public pendingmessagecursor getmessages
return this messages
public void setmessages pendingmessagecursor messages
this messages   messages
public boolean isuseconsumerpriority
return useconsumerpriority
public void setuseconsumerpriority boolean useconsumerpriority
this useconsumerpriority   useconsumerpriority
public boolean isstrictorderdispatch
return strictorderdispatch
public void setstrictorderdispatch boolean strictorderdispatch
this strictorderdispatch   strictorderdispatch
public boolean isoptimizeddispatch
return optimizeddispatch
public void setoptimizeddispatch boolean optimizeddispatch
this optimizeddispatch   optimizeddispatch
// implementation methods
// -------------------------------------------------------------------------
private queuemessagereference createmessagereference message message
queuemessagereference result   new indirectmessagereference message
return result
public message browse
int count   0
list<message> l   new arraylist<message>
try
synchronized  this pagedinpendingdispatch
for  iterator<queuemessagereference> i   this pagedinpendingdispatch
iterator    i hasnext
count < getmaxbrowsepagesize
l add i next   getmessage
count
if  count < getmaxbrowsepagesize
synchronized  pagedinmessages
for  iterator<queuemessagereference> i   this pagedinmessages
values   iterator    i hasnext
count < getmaxbrowsepagesize
message m   i next   getmessage
if  l contains m     false
l add m
count
if  count < getmaxbrowsepagesize
synchronized  messages
try
messages reset
while  messages hasnext
count < getmaxbrowsepagesize
messagereference node   messages next
messages rollback node getmessageid
if  node    null
message m   node getmessage
if  l contains m     false
l add m
count
finally
messages release
catch  ioexception e
log error    e
return l toarray new message
public message getmessage string id
messageid msgid   new messageid id
try
synchronized  pagedinmessages
queuemessagereference r   this pagedinmessages get msgid
if  r    null
return r getmessage
synchronized  messages
try
messages reset
while  messages hasnext
try
messagereference r   messages next
messages rollback r getmessageid
if  msgid equals r getmessageid
message m   r getmessage
if  m    null
return m
break
catch  ioexception e
log error
id
finally
messages release
catch  ioexception e
log error     id
return null
public void purge   throws exception
connectioncontext c   createconnectioncontext
list<messagereference> list   null
do
pageinmessages
synchronized  pagedinmessages
list   new arraylist<messagereference> pagedinmessages values
for  messagereference ref   list
try
queuemessagereference r    queuemessagereference  ref
removemessage c  indirectmessagereference  r
catch  ioexception e
while   pagedinmessages isempty      this destinationstatistics getmessages   getcount   > 0
gc
this destinationstatistics getmessages   setcount 0
getmessages   clear
/**
* removes the message matching the given messageid
*/
public boolean removemessage string messageid  throws exception
return removematchingmessages createmessageidfilter messageid   1  > 0
/**
* removes the messages matching the given selector
*
* @return the number of messages removed
*/
public int removematchingmessages string selector  throws exception
return removematchingmessages selector   1
/**
* removes the messages matching the given selector up to the maximum number
* of matched messages
*
* @return the number of messages removed
*/
public int removematchingmessages string selector  int maximummessages  throws exception
return removematchingmessages createselectorfilter selector   maximummessages
/**
* removes the messages matching the given filter up to the maximum number
* of matched messages
*
* @return the number of messages removed
*/
public int removematchingmessages messagereferencefilter filter  int maximummessages  throws exception
int movedcounter   0
set<messagereference> set   new copyonwritearrayset<messagereference>
connectioncontext context   createconnectioncontext
do
pageinmessages
synchronized  pagedinmessages
set addall pagedinmessages values
list <messagereference>list   new arraylist<messagereference> set
for  messagereference ref   list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
removemessage context  r
set remove r
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
while  set size   < this destinationstatistics getmessages   getcount
return movedcounter
/**
* copies the message matching the given messageid
*/
public boolean copymessageto connectioncontext context  string messageid  activemqdestination dest  throws exception
return copymatchingmessages context  createmessageidfilter messageid   dest  1  > 0
/**
* copies the messages matching the given selector
*
* @return the number of messages copied
*/
public int copymatchingmessagesto connectioncontext context  string selector  activemqdestination dest  throws exception
return copymatchingmessagesto context  selector  dest   1
/**
* copies the messages matching the given selector up to the maximum number
* of matched messages
*
* @return the number of messages copied
*/
public int copymatchingmessagesto connectioncontext context  string selector  activemqdestination dest  int maximummessages  throws exception
return copymatchingmessages context  createselectorfilter selector   dest  maximummessages
/**
* copies the messages matching the given filter up to the maximum number of
* matched messages
*
* @return the number of messages copied
*/
public int copymatchingmessages connectioncontext context  messagereferencefilter filter  activemqdestination dest  int maximummessages  throws exception
int movedcounter   0
int count   0
set<messagereference> set   new copyonwritearrayset<messagereference>
do
int oldmaxsize getmaxpagesize
setmaxpagesize  int  this destinationstatistics getmessages   getcount
pageinmessages
setmaxpagesize oldmaxsize
synchronized  pagedinmessages
set addall pagedinmessages values
list <messagereference>list   new arraylist<messagereference> set
for  messagereference ref   list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
r incrementreferencecount
try
message m   r getmessage
brokersupport resend context  m  dest
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
finally
r decrementreferencecount
count
while  count < this destinationstatistics getmessages   getcount
return movedcounter
/**
* move a message
* @param context
* @param r
* @param dest
* @throws exception
*/
public boolean movemessageto connectioncontext context message m activemqdestination dest  throws exception
queuemessagereference r   createmessagereference m
brokersupport resend context  m  dest
removemessage context  r
return true
/**
* moves the message matching the given messageid
*/
public boolean movemessageto connectioncontext context  string messageid  activemqdestination dest  throws exception
return movematchingmessagesto context  createmessageidfilter messageid   dest  1  > 0
/**
* moves the messages matching the given selector
*
* @return the number of messages removed
*/
public int movematchingmessagesto connectioncontext context  string selector  activemqdestination dest  throws exception
return movematchingmessagesto context  selector  dest integer max_value
/**
* moves the messages matching the given selector up to the maximum number
* of matched messages
*/
public int movematchingmessagesto connectioncontext context  string selector  activemqdestination dest  int maximummessages  throws exception
return movematchingmessagesto context  createselectorfilter selector   dest  maximummessages
/**
* moves the messages matching the given filter up to the maximum number of
* matched messages
*/
public int movematchingmessagesto connectioncontext context
messagereferencefilter filter  activemqdestination dest
int maximummessages  throws exception
int movedcounter   0
set<messagereference> set   new copyonwritearrayset<messagereference>
do
pageinmessages
synchronized  pagedinmessages
set addall pagedinmessages values
list<messagereference> list   new arraylist<messagereference> set
for  messagereference ref   list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
// we should only move messages that can be locked.
message m   r getmessage
brokersupport resend context  m  dest
removemessage context  r
set remove r
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
else
synchronized  messages
messages rollback r getmessageid
while  set size   < this destinationstatistics getmessages   getcount
set size   < maximummessages
return movedcounter
recoverydispatch getnextrecoverydispatch
synchronized  pagedinmessages
if  recoveries isempty
return null
return recoveries removefirst
protected boolean isrecoverydispatchempty
synchronized  pagedinmessages
return recoveries isempty
/**
* @return true if we would like to iterate again
* @see org.apache.activemq.thread.task#iterate()
*/
public boolean iterate
synchronized iteratingmutex
recoverydispatch rd
while   rd   getnextrecoverydispatch       null
try
messageevaluationcontext msgcontext   new noncachedmessageevaluationcontext
msgcontext setdestination destination
for  queuemessagereference node   rd messages
if   node isdropped       node isacked        node isdropped      rd subscription getconsumerinfo   isbrowser
msgcontext setmessagereference node
if  rd subscription matches node  msgcontext
// log showing message dispatching
if  log isdebugenabled
log debug destination getqualifiedname         node hashcode         node       rd subscription
rd subscription add node
else
// make sure it gets queued for dispatched again
dispatchlock lock
try
synchronized pagedinpendingdispatch
if   pagedinpendingdispatch contains node
pagedinpendingdispatch add node
finally
dispatchlock unlock
if  rd subscription instanceof queuebrowsersubscription
queuebrowsersubscription rd subscription  decrementqueueref
catch  exception e
e printstacktrace
boolean pageinmoremessages   false
synchronized  messages
pageinmoremessages    messages isempty
// kinda ugly.. but i think dispatchlock is the only mutex protecting the
// pagedinpendingdispatch variable.
dispatchlock lock
try
pageinmoremessages     pagedinpendingdispatch isempty
finally
dispatchlock unlock
// perhaps we should page always into the pagedinpendingdispatch list is
// !messages.isempty(), and then if !pagedinpendingdispatch.isempty()
// then we do a dispatch.
if  pageinmoremessages
try
pageinmessages false
catch  throwable e
log error    e
synchronized messageswaitingforspace
while   messageswaitingforspace isempty       memoryusage isfull
runnable op   messageswaitingforspace removefirst
op run
return false
protected messagereferencefilter createmessageidfilter final string messageid
return new messagereferencefilter
public boolean evaluate connectioncontext context  messagereference r
return messageid equals r getmessageid   tostring
public string tostring
return   messageid
protected messagereferencefilter createselectorfilter string selector  throws invalidselectorexception
final booleanexpression selectorexpression   new selectorparser   parse selector
return new messagereferencefilter
public boolean evaluate connectioncontext context  messagereference r  throws jmsexception
messageevaluationcontext messageevaluationcontext   context getmessageevaluationcontext
messageevaluationcontext setmessagereference r
if  messageevaluationcontext getdestination      null
messageevaluationcontext setdestination getactivemqdestination
return selectorexpression matches messageevaluationcontext
protected void removemessage connectioncontext c  queuemessagereference r  throws ioexception
removemessage c  null  r
protected void removemessage connectioncontext c  subscription subs queuemessagereference r  throws ioexception
messageack ack   new messageack
ack setacktype messageack standard_ack_type
ack setdestination destination
ack setmessageid r getmessageid
removemessage c  subs  r  ack
protected void removemessage connectioncontext context subscription sub final queuemessagereference reference messageack ack  throws ioexception
reference setacked true
// this sends the ack the the journal..
if   ack isintransaction
acknowledge context  sub  ack  reference
dropmessage reference
wakeup
else
try
acknowledge context  sub  ack  reference
finally
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
dropmessage reference
wakeup
public void afterrollback   throws exception
reference setacked false
private void dropmessage queuemessagereference reference
reference drop
destinationstatistics getmessages   decrement
synchronized pagedinmessages
pagedinmessages remove reference getmessageid
synchronized messages
messages rollback reference getmessageid
public void messageexpired connectioncontext context messagereference reference
messageexpired context null reference
public void messageexpired connectioncontext context subscription subs  messagereference reference
broker messageexpired context  reference
destinationstatistics getdequeues   increment
destinationstatistics getinflight   decrement
try
removemessage context subs  queuemessagereference reference
catch  ioexception e
log error   e
synchronized pagedinmessages
pagedinmessages remove reference getmessageid
wakeup
protected connectioncontext createconnectioncontext
connectioncontext answer   new connectioncontext new noncachedmessageevaluationcontext
answer setbroker this broker
answer getmessageevaluationcontext   setdestination getactivemqdestination
return answer
final void sendmessage final connectioncontext context  message msg  throws exception
if   msg ispersistent      messages getsystemusage      null
messages getsystemusage   gettempusage   waitforspace
synchronized messages
messages addmessagelast msg
destinationstatistics getenqueues   increment
destinationstatistics getmessages   increment
messagedelivered context  msg
wakeup
public void wakeup
if  optimizeddispatch    isslave
iterate
else
try
taskrunner wakeup
catch  interruptedexception e
log warn    e
private boolean isslave
return broker getbrokerservice   isslave
private list<queuemessagereference> dopagein boolean force  throws exception
list<queuemessagereference> result   null
list<queuemessagereference> resultlist   null
dispatchlock lock
try
int topagein   getmaxpagesize     math max 0   int destinationstatistics getinflight   getcount      pagedinmessages size
topagein   math max 0  math min topagein  getmaxpagesize
if  islazydispatch      force
// only page in the minimum number of messages which can be dispatched immediately.
topagein   math min getconsumermessagecountbeforefull    topagein
if   force     consumers isempty       topagein > 0
messages setmaxbatchsize topagein
int count   0
result   new arraylist<queuemessagereference> topagein
synchronized  messages
try
messages reset
while  messages hasnext      count < topagein
messagereference node   messages next
node incrementreferencecount
messages remove
queuemessagereference ref   createmessagereference node getmessage
if   broker isexpired node
result add ref
count
else
messageexpired createconnectioncontext    ref
finally
messages release
// only add new messages, not already pagedin to avoid multiple dispatch attempts
synchronized  pagedinmessages
resultlist   new arraylist<queuemessagereference> result size
for queuemessagereference ref   result
if   pagedinmessages containskey ref getmessageid
pagedinmessages put ref getmessageid    ref
resultlist add ref
else
// avoid return null list, if condition is not validated
resultlist   new arraylist<queuemessagereference>
finally
dispatchlock unlock
return resultlist
private void dodispatch list<queuemessagereference> list  throws exception
dispatchlock lock
try
synchronized  pagedinpendingdispatch
if   pagedinpendingdispatch isempty
// try to first dispatch anything that had not been
// dispatched before.
pagedinpendingdispatch   doactualdispatch pagedinpendingdispatch
// and now see if we can dispatch the new stuff.. and append to
// the pending
// list anything that does not actually get dispatched.
if  list    null     list isempty
if  pagedinpendingdispatch isempty
pagedinpendingdispatch addall doactualdispatch list
else
for  queuemessagereference qmr   list
if   pagedinpendingdispatch contains qmr
pagedinpendingdispatch add qmr
finally
dispatchlock unlock
/**
* @return list of messages that could get dispatched to consumers if they
*         were not full.
*/
private list<queuemessagereference> doactualdispatch list<queuemessagereference> list  throws exception
list<queuemessagereference> rc   new arraylist<queuemessagereference> list size
set<subscription> fullconsumers   new hashset<subscription> this consumers size
list<subscription> consumers
synchronized  this consumers
consumers   new arraylist<subscription> this consumers
for  messagereference node   list
subscription target   null
int interestcount 0
for  subscription s   consumers
if  dispatchselector canselect s  node
if   fullconsumers contains s
if   s isfull
// dispatch it.
s add node
target   s
break
else
// no further dispatch of list to a full consumer to avoid out of order message receipt
fullconsumers add s
interestcount
if  target    null    interestcount>0
// this means all subs were full...
rc add  queuemessagereference node
// if it got dispatched, rotate the consumer list to get round robin distribution.
if  target    null     strictorderdispatch    consumers size   > 1
dispatchselector isexclusiveconsumer target
synchronized  this consumers
if  removefromconsumerlist target
addtoconsumerlist target
consumers   new arraylist<subscription> this consumers
//log.info(getname()+" pending messages:");
//for (messagereference n : rc) {
//     log.info(getname()+"  - " + n.getmessageid());
// }
return rc
private void pageinmessages   throws exception
pageinmessages true
protected void pageinmessages boolean force  throws exception
dodispatch dopagein force
private void addtoconsumerlist subscription sub
if  useconsumerpriority
consumers add sub
collections sort consumers  orderedcompare
else
consumers add sub
private boolean removefromconsumerlist subscription sub
return consumers remove sub
private int getconsumermessagecountbeforefull   throws exception
int total   0
boolean zeroprefetch   false
synchronized  consumers
for  subscription s   consumers
zeroprefetch    s getprefetchsize      0
int countbeforefull   s countbeforefull
total    countbeforefull
if  total  0    zeroprefetch
total 1
return total