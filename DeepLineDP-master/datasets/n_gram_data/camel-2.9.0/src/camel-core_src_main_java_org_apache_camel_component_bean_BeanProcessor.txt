/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component bean
import java lang reflect invocationtargetexception
import java lang reflect method
import java util concurrent atomic atomicboolean
import org apache camel asynccallback
import org apache camel asyncprocessor
import org apache camel camelcontext
import org apache camel exchange
import org apache camel message
import org apache camel processor
import org apache camel support servicesupport
import org apache camel util asyncprocessorhelper
import org apache camel util servicehelper
import org slf4j logger
import org slf4j loggerfactory
/**
* a {@link processor} which converts the inbound exchange to a method
* invocation on a pojo
*
* @version
*/
public class beanprocessor extends servicesupport implements asyncprocessor
private static final transient logger log   loggerfactory getlogger beanprocessor class
private boolean multiparameterarray
private method methodobject
private string method
private beanholder beanholder
private boolean shorthandmethod
public beanprocessor object pojo  beaninfo beaninfo
this new constantbeanholder pojo  beaninfo
public beanprocessor object pojo  camelcontext camelcontext  parametermappingstrategy parametermappingstrategy
this pojo  new beaninfo camelcontext  pojo getclass    parametermappingstrategy
public beanprocessor object pojo  camelcontext camelcontext
this pojo  camelcontext  beaninfo createparametermappingstrategy camelcontext
public beanprocessor beanholder beanholder
this beanholder   beanholder
@override
public string tostring
string description   methodobject    null ?     methodobject
return     beanholder   description
public void process exchange exchange  throws exception
asyncprocessorhelper process this  exchange
public boolean process exchange exchange  asynccallback callback
// do we have an explicit method name we always should invoke (either configured on endpoint or as a header)
string explicitmethodname   exchange getin   getheader exchange bean_method_name  method  string class
object bean
beaninfo beaninfo
try
bean   beanholder getbean
beaninfo   beanholder getbeaninfo
catch  throwable e
exchange setexception e
callback done true
return true
// do we have a custom adapter for this pojo to a processor
// should not be invoked if an explicit method has been set
processor processor   getprocessor
if  explicitmethodname    null    processor    null
log trace    processor
try
processor process exchange
catch  throwable e
exchange setexception e
callback done true
return true
message in   exchange getin
// is the message proxied using a beaninvocation?
beaninvocation beaninvoke   null
if  in getbody      null    in getbody   instanceof beaninvocation
// beaninvocation would be stored directly as the message body
// do not force any type conversion attempts as it would just be unnecessary and cost a bit performance
// so a regular instanceof check is sufficient
beaninvoke    beaninvocation  in getbody
if  beaninvoke    null
// now it gets a bit complicated as proxyhelper can proxy beans which we later
// intend to invoke (for example to proxy and invoke using spring remoting).
// and therefore the message body contains a beaninvocation object.
// however this can causes problem if we in a camel route invokes another bean,
// so we must test whether beanholder and beaninvocation is the same bean or not
log trace    beaninvoke
class<?> clazz   beaninvoke getmethod   getdeclaringclass
boolean samebean   clazz isinstance bean
if  log isdebugenabled
log debug    new object bean getclass    clazz  samebean
if  samebean
beaninvoke invoke bean  exchange
// propagate headers
exchange getout   getheaders   putall exchange getin   getheaders
callback done true
return true
// set temporary header which is a hint for the bean info that introspect the bean
if  in getheader exchange bean_multi_parameter_array     null
in setheader exchange bean_multi_parameter_array  ismultiparameterarray
methodinvocation invocation
if  methodobject    null
invocation   beaninfo createinvocation methodobject  bean  exchange
else
// set explicit method name to invoke as a header, which is how beaninfo can detect it
if  explicitmethodname    null
in setheader exchange bean_method_name  explicitmethodname
try
invocation   beaninfo createinvocation bean  exchange
catch  throwable e
exchange setexception e
callback done true
return true
if  invocation    null
throw new illegalstateexception     bean
// remove headers as they should not be propagated
in removeheader exchange bean_multi_parameter_array
in removeheader exchange bean_method_name
object value   null
try
atomicboolean sync   new atomicboolean true
value   invocation proceed callback  sync
if   sync get
log trace    exchange getexchangeid
// the remainder of the routing will be completed async
// so we break out now, then the callback will be invoked which then continue routing from where we left here
return false
log trace    exchange getexchangeid
catch  invocationtargetexception e
// let's unwrap the exception when it's an invocation target exception
exchange setexception e getcause
callback done true
return true
catch  throwable e
exchange setexception e
callback done true
return true
// if the method returns something then set the value returned on the exchange
if   invocation getmethod   getreturntype   equals void type     value    void type
if  exchange getpattern   isoutcapable
// force out creating if not already created (as its lazy)
log debug    value
exchange getout   setbody value
// propagate headers
exchange getout   getheaders   putall exchange getin   getheaders
else
// if not out then set it on the in
log debug    value
exchange getin   setbody value
callback done true
return true
protected processor getprocessor
return beanholder getprocessor
public object getbean
return beanholder getbean
// properties
// -----------------------------------------------------------------------
public method getmethodobject
return methodobject
public void setmethodobject method methodobject
this methodobject   methodobject
public string getmethod
return method
public boolean ismultiparameterarray
return multiparameterarray
public void setmultiparameterarray boolean mparray
multiparameterarray   mparray
/**
* sets the method name to use
*/
public void setmethod string method
this method   method
public boolean isshorthandmethod
return shorthandmethod
/**
* sets whether to support getter style method name, so you can
* say the method is called 'name' but it will invoke the 'getname' method.
* <p/>
* is by default turned off.
*/
public void setshorthandmethod boolean shorthandmethod
this shorthandmethod   shorthandmethod
// implementation methods
//-------------------------------------------------------------------------
protected void dostart   throws exception
servicehelper startservice getprocessor
protected void dostop   throws exception
servicehelper stopservice getprocessor