/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel language simple
import java util arraylist
import java util list
import org apache camel expression
import org apache camel builder expressionbuilder
import org apache camel language simple ast literalexpression
import org apache camel language simple ast literalnode
import org apache camel language simple ast simplefunctionend
import org apache camel language simple ast simplefunctionstart
import org apache camel language simple ast simplenode
import org apache camel language simple ast unaryexpression
import org apache camel language simple types simpleillegalsyntaxexception
import org apache camel language simple types simpleparserexception
import org apache camel language simple types simpletoken
import org apache camel language simple types tokentype
/**
* a parser to parse simple language as a camel {@link expression}
*/
public class simpleexpressionparser extends basesimpleparser
public simpleexpressionparser string expression
super expression
public expression parseexpression
clear
try
return doparseexpression
catch  simpleparserexception e
// catch parser exception and turn that into a syntax exceptions
throw new simpleillegalsyntaxexception expression  e getindex    e getmessage    e
catch  exception e
// include exception in rethrown exception
throw new simpleillegalsyntaxexception expression   1  e getmessage    e
protected expression doparseexpression
// parse the expression using the following grammar
nexttoken
while   token gettype   iseol
// an expression supports just template (eg text), functions, or unary operator
templatetext
functiontext
unaryoperator
nexttoken
// now after parsing we need a bit of work to do, to make it easier to turn the tokens
// into and ast, and then from the ast, to camel expression(s).
// hence why there is a number of tasks going on below to accomplish this
// turn the tokens into the ast model
parseandcreateastmodel
// compact and stack blocks (eg function start/end)
prepareblocks
// compact and stack unary operators
prepareunaryexpressions
// create and return as a camel expression
list<expression> expressions   createexpressions
if  expressions isempty
return null
else if  expressions size      1
return expressions get 0
else
// concat expressions as evaluating an expression is like a template language
return expressionbuilder concatexpression expressions  expression
protected void parseandcreateastmodel
// we loop the tokens and create a sequence of ast nodes
literalnode imagetoken   null
for  simpletoken token   tokens
// break if eol
if  token gettype   iseol
break
// create a node from the token
simplenode node   createnode token
if  node    null
// a new token was created so the current image token need to be added first
if  imagetoken    null
nodes add imagetoken
imagetoken   null
// and then add the created node
nodes add node
// continue to next
continue
// if no token was created then its a character/whitespace/escaped symbol
// which we need to add together in the same image
if  imagetoken    null
imagetoken   new literalexpression token
imagetoken addtext token gettext
// append any leftover image tokens (when we reached eol)
if  imagetoken    null
nodes add imagetoken
private simplenode createnode simpletoken token
// expression only support functions and unary operators
if  token gettype   isfunctionstart
return new simplefunctionstart token
else if  token gettype   isfunctionend
return new simplefunctionend token
else if  token gettype   isunary
return new unaryexpression token
// by returning null, we will let the parser determine what to do
return null
private list<expression> createexpressions
list<expression> answer   new arraylist<expression>
for  simplenode token   nodes
expression exp   token createexpression expression
if  exp    null
answer add exp
return answer
// --------------------------------------------------------------
// grammar
// --------------------------------------------------------------
// the expression parser only understands
// - template = literal texts with can contain embedded functions
// - function = simple functions such as ${body} etc
// - unary operator = operator attached to the left hand side node
protected void templatetext
// for template we accept anything but functions
while   token gettype   isfunctionstart       token gettype   isfunctionend       token gettype   iseol
nexttoken
protected boolean functiontext
if  accept tokentype functionstart
nexttoken
while   token gettype   isfunctionend       token gettype   iseol
if  token gettype   isfunctionstart
// embedded function
functiontext
// we need to loop until we find the ending function quote, an embedded function, or the eol
nexttoken
// if its not an embedded function then we expect the end token
if   token gettype   isfunctionstart
expect tokentype functionend
return true
return false
protected boolean unaryoperator
if  accept tokentype unaryoperator
nexttoken
// there should be a whitespace after the operator
expect tokentype whitespace
return true
return false