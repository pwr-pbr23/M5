/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component jms
import java util concurrent rejectedexecutionexception
import java util concurrent atomic atomicboolean
import javax jms connection
import javax jms destination
import javax jms jmsexception
import javax jms message
import javax jms session
import org apache camel asynccallback
import org apache camel exchange
import org apache camel failedtocreateproducerexception
import org apache camel runtimeexchangeexception
import org apache camel component jms jmsconfiguration cameljmstemplate
import org apache camel component jms reply replymanager
import org apache camel component jms reply usemessageidascorrelationidmessagesentcallback
import org apache camel impl defaultasyncproducer
import org apache camel spi uuidgenerator
import org apache camel util objecthelper
import org apache camel util valueholder
import org slf4j logger
import org slf4j loggerfactory
import org springframework jms core jmsoperations
import org springframework jms core messagecreator
import org springframework jms support jmsutils
import static org apache camel component jms jmsmessagehelper normalizedestinationname
/**
* @version
*/
public class jmsproducer extends defaultasyncproducer
private static final transient logger log   loggerfactory getlogger jmsproducer class
private final jmsendpoint endpoint
private final atomicboolean started   new atomicboolean false
private jmsoperations inonlytemplate
private jmsoperations inouttemplate
private uuidgenerator uuidgenerator
private replymanager replymanager
public jmsproducer jmsendpoint endpoint
super endpoint
this endpoint   endpoint
protected void initreplymanager
if   started get
synchronized  this
if  started get
return
try
// validate that replytotype and replyto is configured accordingly
if  endpoint getreplytotype      null
// setting temporary with a fixed replyto is not supported
if  endpoint getreplyto      null    endpoint getreplytotype   equals replytotype temporary name
throw new illegalargumentexception     replytotype temporary
endpoint getreplyto
if  endpoint getreplyto      null
replymanager   endpoint getreplymanager endpoint getreplyto
log info     replymanager       endpoint getreplyto
else
replymanager   endpoint getreplymanager
log info     replymanager
catch  exception e
throw new failedtocreateproducerexception endpoint  e
started set true
public boolean process exchange exchange  asynccallback callback
// deny processing if we are not started
if   isrunallowed
if  exchange getexception      null
exchange setexception new rejectedexecutionexception
// we cannot process so invoke callback
callback done true
return true
if   endpoint isdisablereplyto      exchange getpattern   isoutcapable
// in out requires a bit more work than in only
return processinout exchange  callback
else
// in only
return processinonly exchange  callback
protected boolean processinout final exchange exchange  final asynccallback callback
final org apache camel message in   exchange getin
string destinationname   in getheader jmsconstants jms_destination_name  string class
// remove the header so it wont be propagated
in removeheader jmsconstants jms_destination_name
if  destinationname    null
destinationname   endpoint getdestinationname
destination destination   in getheader jmsconstants jms_destination  destination class
// remove the header so it wont be propagated
in removeheader jmsconstants jms_destination
if  destination    null
destination   endpoint getdestination
if  destination    null
// prefer to use destination over destination name
destinationname   null
initreplymanager
// when using message id as correlation id, we need at first to use a provisional correlation id
// which we then update to the real jmsmessageid when the message has been sent
// this is done with the help of the messagesentcallback
final boolean msgidascorrid   endpoint getconfiguration   isusemessageidascorrelationid
final string provisionalcorrelationid   msgidascorrid ? getuuidgenerator   generateuuid     null
messagesentcallback messagesentcallback   null
if  msgidascorrid
messagesentcallback   new usemessageidascorrelationidmessagesentcallback replymanager  provisionalcorrelationid  endpoint getrequesttimeout
final valueholder<messagesentcallback> sentcallback   new valueholder<messagesentcallback> messagesentcallback
final string originalcorrelationid   in getheader    string class
if  originalcorrelationid    null     msgidascorrid
in setheader    getuuidgenerator   generateuuid
messagecreator messagecreator   new messagecreator
public message createmessage session session  throws jmsexception
message message   endpoint getbinding   makejmsmessage exchange  in  session  null
// get the reply to destination to be used from the reply manager
destination replyto   replymanager getreplyto
if  replyto    null
throw new runtimeexchangeexception    exchange
jmsmessagehelper setjmsreplyto message  replyto
replymanager setreplytoselectorheader in  message
string correlationid   determinecorrelationid message  provisionalcorrelationid
replymanager registerreply replymanager  exchange  callback  originalcorrelationid  correlationid  endpoint getrequesttimeout
return message
dosend true  destinationname  destination  messagecreator  sentcallback get
// after sending then set the out message id to the jmsmessageid so its identical
setmessageid exchange
// continue routing asynchronously (reply will be processed async when its received)
return false
/**
* strategy to determine which correlation id to use among <tt>jmsmessageid</tt> and <tt>jmscorrelationid</tt>.
*
* @param message   the jms message
* @param provisionalcorrelationid an optional provisional correlation id, which is preferred to be used
* @return the correlation id to use
* @throws jmsexception can be thrown
*/
protected string determinecorrelationid message message  string provisionalcorrelationid  throws jmsexception
if  provisionalcorrelationid    null
return provisionalcorrelationid
final string messageid   message getjmsmessageid
final string correlationid   message getjmscorrelationid
if  endpoint getconfiguration   isusemessageidascorrelationid
return messageid
else if  objecthelper isempty correlationid
// correlation id is empty so fallback to message id
return messageid
else
return correlationid
protected boolean processinonly final exchange exchange  final asynccallback callback
final org apache camel message in   exchange getin
string destinationname   in getheader jmsconstants jms_destination_name  string class
if  destinationname    null
// remove the header so it wont be propagated
in removeheader jmsconstants jms_destination_name
if  destinationname    null
destinationname   endpoint getdestinationname
destination destination   in getheader jmsconstants jms_destination  destination class
if  destination    null
// remove the header so it wont be propagated
in removeheader jmsconstants jms_destination
if  destination    null
destination   endpoint getdestination
if  destination    null
// prefer to use destination over destination name
destinationname   null
final string to   destinationname    null ? destinationname       destination
messagecreator messagecreator   new messagecreator
public message createmessage session session  throws jmsexception
message answer   endpoint getbinding   makejmsmessage exchange  in  session  null
// when in inonly mode the jmsreplyto is a bit complicated
// we only want to set the jmsreplyto on the answer if
// there is a jmsreplyto from the header/endpoint and
// we have been told to preservemessageqos
object jmsreplyto   jmsmessagehelper getjmsreplyto answer
if  endpoint isdisablereplyto
// honor disable reply to configuration
log debug    endpoint
jmsmessagehelper setjmsreplyto answer  null
else
// if the binding did not create the reply to then we have to try to create it here
if  jmsreplyto    null
// prefer reply to from header over endpoint configured
jmsreplyto   exchange getin   getheader    string class
if  jmsreplyto    null
jmsreplyto   endpoint getreplyto
// we must honor these special flags to preserve qos
// as we are not out capable and thus do not expect a reply, and therefore
// the consumer of this message should not return a reply so we remove it
// unless we use preservemessageqos=true to tell that we still want to use jmsreplyto
if  jmsreplyto    null      endpoint ispreservemessageqos      endpoint isexplicitqosenabled
// log at debug what we are doing, as higher level may cause noise in production logs
// this behavior is also documented at the camel website
if  log isdebugenabled
log debug
new object jmsreplyto  to  endpoint
jmsreplyto   null
// the reply to is a string, so we need to look up its destination instance
// and if needed create the destination using the session if needed to
if  jmsreplyto    null    jmsreplyto instanceof string
// must normalize the destination name
string replyto   normalizedestinationname  string  jmsreplyto
// we need to null it as we use the string to resolve it as a destination instance
jmsreplyto   null
// try using destination resolver to lookup the destination
if  endpoint getdestinationresolver      null
jmsreplyto   endpoint getdestinationresolver   resolvedestinationname session  replyto  endpoint ispubsubdomain
if  jmsreplyto    null
// okay then fallback and create the queue
if  endpoint ispubsubdomain
log debug    replyto
jmsreplyto   session createtopic replyto
else
log debug    replyto
jmsreplyto   session createqueue replyto
// set the jmsreplyto on the answer if we are to use it
destination replyto   null
if  jmsreplyto instanceof destination
replyto    destination  jmsreplyto
if  replyto    null
log debug    replyto
jmsmessagehelper setjmsreplyto answer  replyto
else
// do not use jmsreplyto
jmsmessagehelper setjmsreplyto answer  null
return answer
dosend false  destinationname  destination  messagecreator  null
// after sending then set the out message id to the jmsmessageid so its identical
setmessageid exchange
// we are synchronous so return true
callback done true
return true
/**
* sends the message using the jmstemplate.
*
* @param inout           use inout or inonly template
* @param destinationname the destination name
* @param destination     the destination (if no name provided)
* @param messagecreator  the creator to create the {@link message} to send
* @param callback        optional callback for inout messages
*/
protected void dosend boolean inout  string destinationname  destination destination
messagecreator messagecreator  messagesentcallback callback
cameljmstemplate template    cameljmstemplate   inout ? getinouttemplate     getinonlytemplate
log trace    inout ?
// destination should be preferred
if  destination    null
if  inout
if  template    null
template send destination  messagecreator  callback
else
if  template    null
template send destination  messagecreator
else if  destinationname    null
if  inout
if  template    null
template send destinationname  messagecreator  callback
else
if  template    null
template send destinationname  messagecreator
else
throw new illegalargumentexception     endpoint
protected void setmessageid exchange exchange
if  exchange hasout
jmsmessage out   exchange getout jmsmessage class
try
if  out    null    out getjmsmessage      null
out setmessageid out getjmsmessage   getjmsmessageid
catch  jmsexception e
log warn
e
public jmsoperations getinonlytemplate
if  inonlytemplate    null
inonlytemplate   endpoint createinonlytemplate
return inonlytemplate
public void setinonlytemplate jmsoperations inonlytemplate
this inonlytemplate   inonlytemplate
public jmsoperations getinouttemplate
if  inouttemplate    null
inouttemplate   endpoint createinouttemplate
return inouttemplate
public void setinouttemplate jmsoperations inouttemplate
this inouttemplate   inouttemplate
public uuidgenerator getuuidgenerator
return uuidgenerator
public void setuuidgenerator uuidgenerator uuidgenerator
this uuidgenerator   uuidgenerator
/**
* pre tests the connection before starting the listening.
* <p/>
* in case of connection failure the exception is thrown which prevents camel from starting.
*
* @throws failedtocreateproducerexception is thrown if testing the connection failed
*/
protected void testconnectiononstartup   throws failedtocreateproducerexception
try
cameljmstemplate template    cameljmstemplate  getinonlytemplate
if  log isdebugenabled
log debug     template getdefaultdestinationname
connection conn   template getconnectionfactory   createconnection
jmsutils closeconnection conn
log info     template getdefaultdestinationname
catch  exception e
throw new failedtocreateproducerexception getendpoint    e
protected void dostart   throws exception
super dostart
if  uuidgenerator    null
// use the generator configured on the camel context
uuidgenerator   getendpoint   getcamelcontext   getuuidgenerator
if  endpoint istestconnectiononstartup
testconnectiononstartup
protected void dostop   throws exception
super dostop