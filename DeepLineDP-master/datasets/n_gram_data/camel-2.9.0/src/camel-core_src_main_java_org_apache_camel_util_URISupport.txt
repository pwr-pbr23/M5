/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel util
import java io unsupportedencodingexception
import java net uri
import java net urisyntaxexception
import java net urldecoder
import java net urlencoder
import java util arraylist
import java util collections
import java util iterator
import java util linkedhashmap
import java util list
import java util map
import java util regex pattern
/**
* uri utilities.
*
* @version
*/
public final class urisupport
// match any key-value pair in the uri query string whose key contains
// "passphrase" or "password" or secret key (case-insensitive).
// first capture group is the key, second is the value.
private static final pattern secrets   pattern compile
pattern case_insensitive
// match the user password in the uri as second capture group
// (applies to uri with authority component and userinfo token in the form "user:password").
private static final pattern userinfo_password   pattern compile
private static final string charset
private urisupport
// helper class
/**
* removes detected sensitive information (such as passwords) from the uri and returns the result.
* @param uri the uri to sanitize.
* @see #secrets for the matched pattern
*
* @return returns null if the uri is null, otherwise the uri with the passphrase, password or secretkey sanitized.
*/
public static string sanitizeuri string uri
string sanitized   uri
if  uri    null
sanitized   secrets matcher sanitized  replaceall
sanitized   userinfo_password matcher sanitized  replacefirst
return sanitized
public static map<string  object> parsequery string uri  throws urisyntaxexception
// must check for trailing & as the uri.split("&") will ignore those
if  uri    null    uri endswith
throw new urisyntaxexception uri
try
// use a linked map so the parameters is in the same order
map<string  object> rc   new linkedhashmap<string  object>
if  uri    null
string parameters   uri split
for  string parameter   parameters
int p   parameter indexof
if  p >  0
string name   urldecoder decode parameter substring 0  p   charset
string value   urldecoder decode parameter substring p   1   charset
// does the key already exist?
if  rc containskey name
// yes it does, so make sure we can support multiple values, but using a list
// to hold the multiple values
object existing   rc get name
list<string> list
if  existing instanceof list
list   castutils cast  list<?>  existing
else
// create a new list to hold the multiple values
list   new arraylist<string>
string s   existing    null ? existing tostring     null
if  s    null
list add s
list add value
rc put name  list
else
rc put name  value
else
rc put parameter  null
return rc
catch  unsupportedencodingexception e
urisyntaxexception se   new urisyntaxexception e tostring
se initcause e
throw se
public static map<string  object> parseparameters uri uri  throws urisyntaxexception
string query   uri getquery
if  query    null
string schemespecificpart   uri getschemespecificpart
int idx   schemespecificpart indexof
if  idx < 0
// return an empty map
return new linkedhashmap<string  object> 0
else
query   schemespecificpart substring idx   1
else
query   stripprefix query
return parsequery query
/**
* creates a uri with the given query
*/
public static uri createuriwithquery uri uri  string query  throws urisyntaxexception
objecthelper notnull uri
// assemble string as new uri and replace parameters with the query instead
string s   uri tostring
string before   objecthelper before s
if  before    null
s   before
if  query    null
s   s       query
if    s contains         uri getfragment      null
s   s       uri getfragment
return new uri s
public static string stripprefix string value  string prefix
if  value startswith prefix
return value substring prefix length
return value
@suppresswarnings
public static string createquerystring map<object  object> options  throws urisyntaxexception
try
if  options size   > 0
stringbuilder rc   new stringbuilder
boolean first   true
for  object o   options keyset
if  first
first   false
else
rc append
string key    string  o
object value   options get key
// the value may be a list since the same key has multiple values
if  value instanceof list
list<string> list    list<string>  value
for  iterator<string> it   list iterator    it hasnext
string s   it next
appendquerystringparameter key  s  rc
// append & separator if there is more in the list to append
if  it hasnext
rc append
else
// use the value as a string
string s   value    null ? value tostring     null
appendquerystringparameter key  s  rc
return rc tostring
else
return
catch  unsupportedencodingexception e
urisyntaxexception se   new urisyntaxexception e tostring
se initcause e
throw se
private static void appendquerystringparameter string key  string value  stringbuilder rc  throws unsupportedencodingexception
rc append urlencoder encode key  charset
// only append if value is not null
if  value    null
rc append
rc append urlencoder encode value  charset
/**
* creates a uri from the original uri and the remaining parameters
* <p/>
* used by various camel components
*/
public static uri createremaininguri uri originaluri  map<object  object> params  throws urisyntaxexception
string s   createquerystring params
if  s length      0
s   null
return createuriwithquery originaluri  s
/**
* normalizes the uri by reordering the parameters so they are sorted and thus
* we can use the uris for endpoint matching.
*
* @param uri the uri
* @return the normalized uri
* @throws urisyntaxexception in thrown if the uri syntax is invalid
* @throws unsupportedencodingexception
*/
@suppresswarnings
public static string normalizeuri string uri  throws urisyntaxexception  unsupportedencodingexception
uri u   new uri unsafeuricharactersencoder encode uri
string path   u getschemespecificpart
string scheme   u getscheme
// not possible to normalize
if  scheme    null    path    null
return uri
// lets trim off any query arguments
if  path startswith
path   path substring 2
int idx   path indexof
if  idx > 0
path   path substring 0  idx
path   unsafeuricharactersencoder encode path
// in case there are parameters we should reorder them
map parameters   urisupport parseparameters u
if  parameters isempty
// no parameters then just return
return builduri scheme  path  null
else
// reorder parameters a..z
list<string> keys   new arraylist<string> parameters keyset
collections sort keys
map<object  object> sorted   new linkedhashmap<object  object> parameters size
for  string key   keys
sorted put key  parameters get key
// build uri object with sorted parameters
string query   urisupport createquerystring sorted
return builduri scheme  path  query
private static string builduri string scheme  string path  string query
// must include :// to do a correct uri all components can work with
return scheme       path    query    null ?     query