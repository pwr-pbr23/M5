/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component file
import java util arraylist
import java util collections
import java util linkedlist
import java util list
import java util queue
import org apache camel asynccallback
import org apache camel batchconsumer
import org apache camel exchange
import org apache camel processor
import org apache camel shutdownrunningtask
import org apache camel impl scheduledpollconsumer
import org apache camel spi shutdownaware
import org apache camel util castutils
import org apache camel util objecthelper
import org apache camel util stopwatch
import org apache camel util timeutils
import org slf4j logger
import org slf4j loggerfactory
/**
* base class for file consumers.
*/
public abstract class genericfileconsumer<t> extends scheduledpollconsumer implements batchconsumer  shutdownaware
protected final transient logger log   loggerfactory getlogger getclass
protected genericfileendpoint<t> endpoint
protected genericfileoperations<t> operations
protected boolean loggedin
protected string fileexpressionresult
protected int maxmessagesperpoll
protected volatile shutdownrunningtask shutdownrunningtask
protected volatile int pendingexchanges
protected processor customprocessor
public genericfileconsumer genericfileendpoint<t> endpoint  processor processor  genericfileoperations<t> operations
super endpoint  processor
this endpoint   endpoint
this operations   operations
public processor getcustomprocessor
return customprocessor
/**
* use a custom processor to process the exchange.
* <p/>
* only set this if you need to do custom processing, instead of the regular processing.
* <p/>
* this is for example used to browse file endpoints by leveraging the file consumer to poll
* the directory to gather the list of exchanges. but to avoid processing the files regularly
* we can use a custom processor.
*
* @param processor a custom processor
*/
public void setcustomprocessor processor processor
this customprocessor   processor
/**
* poll for files
*/
protected int poll   throws exception
// must reset for each poll
fileexpressionresult   null
shutdownrunningtask   null
pendingexchanges   0
// before we poll is there anything we need to check?
// such as are we connected to the ftp server still?
if   prepollcheck
log debug
return 0
// gather list of files to process
list<genericfile<t>> files   new arraylist<genericfile<t>>
string name   endpoint getconfiguration   getdirectory
// time how long time it takes to poll
stopwatch stop   new stopwatch
boolean limithit    polldirectory name  files  0
long delta   stop stop
if  log isdebugenabled
log debug    timeutils printduration delta   name
// log if we hit the limit
if  limithit
log debug    maxmessagesperpoll
// sort files using file comparator if provided
if  endpoint getsorter      null
collections sort files  endpoint getsorter
// sort using build in sorters so we can use expressions
linkedlist<exchange> exchanges   new linkedlist<exchange>
for  genericfile<t> file   files
exchange exchange   endpoint createexchange file
endpoint configureexchange exchange
endpoint configuremessage file  exchange getin
exchanges add exchange
// sort files using exchange comparator if provided
if  endpoint getsortby      null
collections sort exchanges  endpoint getsortby
// consume files one by one
int total   exchanges size
if  total > 0
log debug    total
queue<exchange> q   exchanges
int polledmessages   processbatch castutils cast q
postpollcheck
return polledmessages
public void setmaxmessagesperpoll int maxmessagesperpoll
this maxmessagesperpoll   maxmessagesperpoll
@suppresswarnings
public int processbatch queue<object> exchanges
int total   exchanges size
// limit if needed
if  maxmessagesperpoll > 0    total > maxmessagesperpoll
log debug    maxmessagesperpoll  total
total   maxmessagesperpoll
for  int index   0  index < total    isbatchallowed    index
// only loop if we are started (allowed to run)
// use poll to remove the head so it does not consume memory even after we have processed it
exchange exchange    exchange  exchanges poll
// add current index and total as properties
exchange setproperty exchange batch_index  index
exchange setproperty exchange batch_size  total
exchange setproperty exchange batch_complete  index    total   1
// update pending number of exchanges
pendingexchanges   total   index   1
// process the current exchange
if  customprocessor    null
// use a custom processor
customprocessexchange exchange  customprocessor
else
// process the exchange regular
processexchange exchange
// remove the file from the in progress list in case the batch was limited by max messages per poll
while  exchanges size   > 0
exchange exchange    exchange  exchanges poll
genericfile<t> file    genericfile<t>  exchange getproperty filecomponent file_exchange_file
string key   file getabsolutefilepath
endpoint getinprogressrepository   remove key
return total
public boolean defershutdown shutdownrunningtask shutdownrunningtask
// store a reference what to do in case when shutting down and we have pending messages
this shutdownrunningtask   shutdownrunningtask
// do not defer shutdown
return false
public int getpendingexchangessize
int answer
// only return the real pending size in case we are configured to complete all tasks
if  shutdownrunningtask completealltasks    shutdownrunningtask
answer   pendingexchanges
else
answer   0
if  answer    0    ispolling
// force at least one pending exchange if we are polling as there is a little gap
// in the processbatch method and until an exchange gets enlisted as in-flight
// which happens later, so we need to signal back to the shutdown strategy that
// there is a pending exchange. when we are no longer polling, then we will return 0
log trace
answer   1
return answer
public void prepareshutdown
// noop
public boolean isbatchallowed
// stop if we are not running
boolean answer   isrunallowed
if   answer
return false
if  shutdownrunningtask    null
// we are not shutting down so continue to run
return true
// we are shutting down so only continue if we are configured to complete all tasks
return shutdownrunningtask completealltasks    shutdownrunningtask
/**
* whether or not we can continue polling for more files
*
* @param filelist  the current list of gathered files
* @return <tt>true</tt> to continue, <tt>false</tt> to stop due hitting maxmessagesperpoll limit
*/
public boolean canpollmorefiles list<?> filelist
if  maxmessagesperpoll <  0
// no limitation
return true
// then only poll if we haven't reached the max limit
return filelist size   < maxmessagesperpoll
/**
* override if required. perform some checks (and perhaps actions) before we poll.
*
* @return <tt>true</tt> to poll, <tt>false</tt> to skip this poll.
*/
protected boolean prepollcheck   throws exception
return true
/**
* override if required. perform some checks (and perhaps actions) after we have polled.
*/
protected void postpollcheck
// noop
/**
* polls the given directory for files to process
*
* @param filename current directory or file
* @param filelist current list of files gathered
* @param depth the current depth of the directory (will start from 0)
* @return whether or not to continue polling, <tt>false</tt> means the maxmessagesperpoll limit has been hit
*/
protected abstract boolean polldirectory string filename  list<genericfile<t>> filelist  int depth
/**
* sets the operations to be used.
* <p/>
* can be used to set a fresh operations in case of recovery attempts
*
* @param operations the operations
*/
public void setoperations genericfileoperations<t> operations
this operations   operations
/**
* processes the exchange
*
* @param exchange the exchange
*/
protected void processexchange final exchange exchange
genericfile<t> file   getexchangefileproperty exchange
log trace    file
// must extract the absolute name before the begin strategy as the file could potentially be pre moved
// and then the file name would be changed
string absolutefilename   file getabsolutefilepath
// check if we can begin processing the file
try
final genericfileprocessstrategy<t> processstrategy   endpoint getgenericfileprocessstrategy
boolean begin   processstrategy begin operations  endpoint  exchange  file
if   begin
log debug endpoint      file
// begin returned false, so remove file from the in progress list as its no longer in progress
endpoint getinprogressrepository   remove absolutefilename
return
catch  exception e
if  log isdebugenabled
log debug endpoint       file       e getmessage    e
endpoint getinprogressrepository   remove absolutefilename
return
// must use file from exchange as it can be updated due the
// premovenameprefix/premovenamepostfix options
final genericfile<t> target   getexchangefileproperty exchange
// must use full name when downloading so we have the correct path
final string name   target getabsolutefilepath
try
// retrieve the file using the stream
log trace    name  endpoint
// retrieve the file and check it was a success
boolean retrieved   operations retrievefile name  exchange
if   retrieved
// throw exception to handle the problem with retrieving the file
// then if the method return false or throws an exception is handled the same in here
// as in both cases an exception is being thrown
throw new genericfileoperationfailedexception     file       endpoint
log trace    name  endpoint
// register on completion callback that does the completion strategies
// (for instance to move the file after we have processed it)
exchange addoncompletion new genericfileoncompletion<t> endpoint  operations  target  absolutefilename
log debug    target  exchange
// process the exchange using the async consumer to support async routing engine
// which can be supported by this file consumer as all the done work is
// provided in the genericfileoncompletion
getasyncprocessor   process exchange  new asynccallback
public void done boolean donesync
// noop
if  log istraceenabled
log trace    target  donesync ?
catch  exception e
// remove file from the in progress list due to failure
// (cannot be in finally block due to genericfileoncompletion will remove it
// from in progress when it takes over and processes the file, which may happen
// by another thread at a later time. so its only safe to remove it if there was an exception)
endpoint getinprogressrepository   remove absolutefilename
handleexception e
/**
* processes the exchange using a custom processor.
*
* @param exchange the exchange
* @param processor the custom processor
*/
protected void customprocessexchange final exchange exchange  final processor processor
genericfile<t> file   getexchangefileproperty exchange
log trace    file
// must extract the absolute name before the begin strategy as the file could potentially be pre moved
// and then the file name would be changed
string absolutefilename   file getabsolutefilepath
try
// process using the custom processor
processor process exchange
catch  exception e
if  log isdebugenabled
log debug endpoint       file       e getmessage        e
finally
// always remove file from the in progress list as its no longer in progress
// use the original file name that was used to add it to the repository
// as the name can be different when using premove option
endpoint getinprogressrepository   remove absolutefilename
/**
* strategy for validating if the given remote file should be included or not
*
* @param file        the file
* @param isdirectory whether the file is a directory or a file
* @return <tt>true</tt> to include the file, <tt>false</tt> to skip it
*/
protected boolean isvalidfile genericfile<t> file  boolean isdirectory
if   ismatched file  isdirectory
log trace    file
return false
else if  endpoint isidempotent      endpoint getidempotentrepository   contains file getabsolutefilepath
log trace    file
return false
// file matched
return true
/**
* strategy to perform file matching based on endpoint configuration.
* <p/>
* will always return <tt>false</tt> for certain files/folders:
* <ul>
* <li>starting with a dot</li>
* <li>lock files</li>
* </ul>
* and then <tt>true</tt> for directories.
*
* @param file        the file
* @param isdirectory whether the file is a directory or a file
* @return <tt>true</tt> if the file is matched, <tt>false</tt> if not
*/
protected boolean ismatched genericfile<t> file  boolean isdirectory
string name   file getfilenameonly
// folders/names starting with dot is always skipped (eg. ".", ".camel", ".camellock")
if  name startswith
return false
// lock files should be skipped
if  name endswith filecomponent default_lock_file_postfix
return false
// directories so far is always regarded as matched (matching on the name is only for files)
if  isdirectory
return true
if  endpoint getfilter      null
if   endpoint getfilter   accept file
return false
if  objecthelper isnotempty endpoint getexclude
if  name matches endpoint getexclude
return false
if  objecthelper isnotempty endpoint getinclude
if   name matches endpoint getinclude
return false
// use file expression for a simple dynamic file filter
if  endpoint getfilename      null
evaluatefileexpression
if  fileexpressionresult    null
if   name equals fileexpressionresult
return false
// if done file name is enabled, then the file is only valid if a done file exists
if  endpoint getdonefilename      null
// done file must be in same path as the file
string donefilename   endpoint createdonefilename file getabsolutefilepath
objecthelper notempty donefilename     endpoint
// is it a done file name?
if  endpoint isdonefile file getfilenameonly
log trace    file
return false
if   ismatched file  donefilename
return false
return true
/**
* strategy to perform file matching based on endpoint configuration in terms of done file name.
*
* @param file         the file
* @param donefilename the done file name
* @return <tt>true</tt> if the file is matched, <tt>false</tt> if not
*/
protected boolean ismatched genericfile<t> file  string donefilename
// the file is only valid if the done file exist
if   operations existsfile donefilename
log trace    donefilename
return false
// assume matched
return true
/**
* is the given file already in progress.
*
* @param file the file
* @return <tt>true</tt> if the file is already in progress
*/
protected boolean isinprogress genericfile<t> file
string key   file getabsolutefilepath
return  endpoint getinprogressrepository   add key
private void evaluatefileexpression
if  fileexpressionresult    null
// create a dummy exchange as exchange is needed for expression evaluation
exchange dummy   endpoint createexchange
fileexpressionresult   endpoint getfilename   evaluate dummy  string class
@suppresswarnings
private genericfile<t> getexchangefileproperty exchange exchange
return  genericfile<t>  exchange getproperty filecomponent file_exchange_file
@override
protected void dostart   throws exception
super dostart
// prepare on startup
endpoint getgenericfileprocessstrategy   prepareonstartup operations  endpoint