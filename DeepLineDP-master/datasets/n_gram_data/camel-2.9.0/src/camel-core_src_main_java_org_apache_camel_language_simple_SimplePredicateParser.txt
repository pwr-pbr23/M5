/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel language simple
import java util arraylist
import java util iterator
import java util list
import java util stack
import java util concurrent atomic atomicboolean
import org apache camel expression
import org apache camel predicate
import org apache camel builder predicatebuilder
import org apache camel language simple ast binaryexpression
import org apache camel language simple ast doublequoteend
import org apache camel language simple ast doublequotestart
import org apache camel language simple ast literalexpression
import org apache camel language simple ast literalnode
import org apache camel language simple ast logicalexpression
import org apache camel language simple ast nullexpression
import org apache camel language simple ast simplefunctionend
import org apache camel language simple ast simplefunctionstart
import org apache camel language simple ast simplenode
import org apache camel language simple ast singlequoteend
import org apache camel language simple ast singlequotestart
import org apache camel language simple ast unaryexpression
import org apache camel language simple types binaryoperatortype
import org apache camel language simple types logicaloperatortype
import org apache camel language simple types simpleillegalsyntaxexception
import org apache camel language simple types simpleparserexception
import org apache camel language simple types simpletoken
import org apache camel language simple types tokentype
import org apache camel util expressiontopredicateadapter
/**
* a parser to parse simple language as a camel {@link predicate}
*/
public class simplepredicateparser extends basesimpleparser
public simplepredicateparser string expression
super expression
public predicate parsepredicate
clear
try
return doparsepredicate
catch  simpleparserexception e
// catch parser exception and turn that into a syntax exceptions
throw new simpleillegalsyntaxexception expression  e getindex    e getmessage    e
catch  exception e
// include exception in rethrown exception
throw new simpleillegalsyntaxexception expression   1  e getmessage    e
protected predicate doparsepredicate
// parse using the following grammar
nexttoken
while   token gettype   iseol
// predicate supports quotes, functions, operators and whitespaces
//checkstyle:off
if   singlequotedliteralwithfunctionstext
doublequotedliteralwithfunctionstext
functiontext
unaryoperator
binaryoperator
logicaloperator
token gettype   iswhitespace
token gettype   iseol
// okay the symbol was not one of the above, so its not supported
// use the previous index as that is where the problem is
throw new simpleparserexception     token  previousindex
//checkstyle:on
// take the next token
nexttoken
// now after parsing we need a bit of work to do, to make it easier to turn the tokens
// into and ast, and then from the ast, to camel predicate(s).
// hence why there is a number of tasks going on below to accomplish this
// remove any ignorable white space tokens
removeignorablewhitespacetokens
// turn the tokens into the ast model
parsetokensandcreatenodes
// compact and stack blocks (eg function start/end, quotes start/end, etc.)
prepareblocks
// compact and stack unary expressions
prepareunaryexpressions
// compact and stack binary expressions
preparebinaryexpressions
// compact and stack logical expressions
preparelogicalexpressions
// create and return as a camel predicate
list<predicate> predicates   createpredicates
if  predicates isempty
return null
else if  predicates size      1
return predicates get 0
else
return predicatebuilder and predicates
/**
* parses the tokens and crates the ast nodes.
* <p/>
* after the initial parsing of the input (input -> tokens) then we
* parse again (tokens -> ast).
* <p/>
* in this parsing the balance of the blocks is checked, so that each block has a matching
* start and end token. for example a single quote block, or a function block etc.
*/
protected void parsetokensandcreatenodes
// we loop the tokens and create a sequence of ast nodes
// we need to keep a bit of state for keeping track of single and double quotes
// which need to be balanced and have matching start/end pairs
simplenode lastsingle   null
simplenode lastdouble   null
simplenode lastfunction   null
atomicboolean startsingle   new atomicboolean false
atomicboolean startdouble   new atomicboolean false
atomicboolean startfunction   new atomicboolean false
literalnode imagetoken   null
for  simpletoken token   tokens
// break if eol
if  token gettype   iseol
break
// create a node from the token
simplenode node   createnode token  startsingle  startdouble  startfunction
if  node    null
// keep state of last single/double
if  node instanceof singlequotestart
lastsingle   node
else if  node instanceof doublequotestart
lastdouble   node
else if  node instanceof simplefunctionstart
lastfunction   node
// a new token was created so the current image token need to be added first
if  imagetoken    null
nodes add imagetoken
imagetoken   null
// and then add the created node
nodes add node
// continue to next
continue
// if no token was created then its a character/whitespace/escaped symbol
// which we need to add together in the same image
if  imagetoken    null
imagetoken   new literalexpression token
imagetoken addtext token gettext
// append any leftover image tokens (when we reached eol)
if  imagetoken    null
nodes add imagetoken
// validate the single, double quote pairs and functions is in balance
if  startsingle get
int index   lastsingle    null ? lastsingle gettoken   getindex     0
throw new simpleparserexception    index
if  startdouble get
int index   lastdouble    null ? lastdouble gettoken   getindex     0
throw new simpleparserexception    index
if  startfunction get
// we have a start function, but no ending function
int index   lastfunction    null ? lastfunction gettoken   getindex     0
throw new simpleparserexception    index
/**
* creates a node from the given token
*
* @param token         the token
* @param startsingle   state of single quoted blocks
* @param startdouble   state of double quoted blocks
* @param startfunction state of function blocks
* @return the created node, or <tt>null</tt> to let a default node be created instead.
*/
private simplenode createnode simpletoken token  atomicboolean startsingle  atomicboolean startdouble
atomicboolean startfunction
if  token gettype   isfunctionstart
startfunction set true
return new simplefunctionstart token
else if  token gettype   isfunctionend
startfunction set false
return new simplefunctionend token
// if we are inside a function, then we do not support any other kind of tokens
// as we want all the tokens to be literal instead
if  startfunction get
return null
// okay so far we also want to support quotes
if  token gettype   issinglequote
simplenode answer
boolean start   startsingle get
if   start
answer   new singlequotestart token
else
answer   new singlequoteend token
// flip state on start/end flag
startsingle set  start
return answer
else if  token gettype   isdoublequote
simplenode answer
boolean start   startdouble get
if   start
answer   new doublequotestart token
else
answer   new doublequoteend token
// flip state on start/end flag
startdouble set  start
return answer
// if we are inside a quote, then we do not support any further kind of tokens
// as we want to only support embedded functions and all other kinds to be literal tokens
if  startsingle get      startdouble get
return null
// okay we are not inside a function or quote, so we want to support operators
// and the special null value as well
if  token gettype   isunary
return new unaryexpression token
else if  token gettype   isbinary
return new binaryexpression token
else if  token gettype   islogical
return new logicalexpression token
else if  token gettype   isnullvalue
return new nullexpression token
// by returning null, we will let the parser determine what to do
return null
/**
* removes any ignorable whitespace tokens.
* <p/>
* during the initial parsing (input -> tokens), then there may
* be excessive whitespace tokens, which can safely be removed,
* which makes the succeeding parsing easier.
*/
private void removeignorablewhitespacetokens
// white space can be removed if its not part of a quoted text
boolean quote   false
iterator<simpletoken> it   tokens iterator
while  it hasnext
simpletoken token   it next
if  token gettype   issinglequote
quote    quote
else if  token gettype   iswhitespace       quote
it remove
/**
* prepares binary expressions.
* <p/>
* this process prepares the binary expressions in the ast. this is done
* by linking the binary operator with both the right and left hand side
* nodes, to have the ast graph updated and prepared properly.
* <p/>
* so when the ast node is later used to create the {@link predicate}s
* to be used by camel then the ast graph has a linked and prepared
* graph of nodes which represent the input expression.
*/
private void preparebinaryexpressions
stack<simplenode> stack   new stack<simplenode>
simplenode left   null
for  int i   0  i < nodes size    i
if  left    null
left   i > 0 ? nodes get i   1    null
simplenode token   nodes get i
simplenode right   i < nodes size     1 ? nodes get i   1    null
if  token instanceof binaryexpression
binaryexpression binary    binaryexpression  token
// remember the binary operator
string operator   binary getoperator   tostring
if  left    null
throw new simpleparserexception     operator      token gettoken   getindex
if   binary acceptleftnode left
throw new simpleparserexception     operator       left gettoken    token gettoken   getindex
if  right    null
throw new simpleparserexception     operator      token gettoken   getindex
if   binary acceptrightnode right
throw new simpleparserexception     operator       right gettoken    token gettoken   getindex
// pop previous as we need to replace it with this binary operator
stack pop
stack push token
// advantage after the right hand side
i
// this token is now the left for the next loop
left   token
else
// clear left
left   null
stack push token
nodes clear
nodes addall stack
/**
* prepares logical expressions.
* <p/>
* this process prepares the logical expressions in the ast. this is done
* by linking the logical operator with both the right and left hand side
* nodes, to have the ast graph updated and prepared properly.
* <p/>
* so when the ast node is later used to create the {@link predicate}s
* to be used by camel then the ast graph has a linked and prepared
* graph of nodes which represent the input expression.
*/
private void preparelogicalexpressions
stack<simplenode> stack   new stack<simplenode>
simplenode left   null
for  int i   0  i < nodes size    i
if  left    null
left   i > 0 ? nodes get i   1    null
simplenode token   nodes get i
simplenode right   i < nodes size     1 ? nodes get i   1    null
if  token instanceof logicalexpression
logicalexpression logical    logicalexpression  token
// remember the logical operator
string operator   logical getoperator   tostring
if  left    null
throw new simpleparserexception     operator      token gettoken   getindex
if   logical acceptleftnode left
throw new simpleparserexception     operator       left gettoken    token gettoken   getindex
if  right    null
throw new simpleparserexception     operator      token gettoken   getindex
if   logical acceptrightnode right
throw new simpleparserexception     operator       left gettoken    token gettoken   getindex
// pop previous as we need to replace it with this binary operator
stack pop
stack push token
// advantage after the right hand side
i
// this token is now the left for the next loop
left   token
else
// clear left
left   null
stack push token
nodes clear
nodes addall stack
/**
* creates the {@link predicate}s from the ast nodes.
*
* @return the created {@link predicate}s, is never <tt>null</tt>.
*/
private list<predicate> createpredicates
list<predicate> answer   new arraylist<predicate>
for  simplenode node   nodes
expression exp   node createexpression expression
if  exp    null
predicate predicate   expressiontopredicateadapter topredicate exp
answer add predicate
return answer
// --------------------------------------------------------------
// grammar
// --------------------------------------------------------------
// the predicate parser understands a lot more than the expression parser
// - single quoted = block of nodes enclosed by single quotes
// - double quoted = block of nodes enclosed by double quotes
// - single quoted with functions = block of nodes enclosed by single quotes allowing embedded functions
// - double quoted with functions = block of nodes enclosed by double quotes allowing embedded functions
// - function = simple functions such as ${body} etc
// - numeric = numeric value
// - boolean = boolean value
// - null = null value
// - unary operator = operator attached to the left hand side node
// - binary operator = operator attached to both the left and right hand side nodes
// - logical operator = operator attached to both the left and right hand side nodes
protected boolean singlequotedliteralwithfunctionstext
if  accept tokentype singlequote
nexttoken tokentype singlequote  tokentype eol  tokentype functionstart  tokentype functionend
while   token gettype   issinglequote       token gettype   iseol
// we need to loop until we find the ending single quote, or the eol
nexttoken tokentype singlequote  tokentype eol  tokentype functionstart  tokentype functionend
expect tokentype singlequote
return true
return false
protected boolean singlequotedliteraltext
if  accept tokentype singlequote
nexttoken tokentype singlequote  tokentype eol
while   token gettype   issinglequote       token gettype   iseol
// we need to loop until we find the ending single quote, or the eol
nexttoken tokentype singlequote  tokentype eol
expect tokentype singlequote
return true
return false
protected boolean doublequotedliteralwithfunctionstext
if  accept tokentype doublequote
nexttoken tokentype doublequote  tokentype eol  tokentype functionstart  tokentype functionend
while   token gettype   isdoublequote       token gettype   iseol
// we need to loop until we find the ending double quote, or the eol
nexttoken tokentype doublequote  tokentype eol  tokentype functionstart  tokentype functionend
expect tokentype doublequote
return true
return false
protected boolean doublequotedliteraltext
if  accept tokentype doublequote
nexttoken tokentype doublequote  tokentype eol
while   token gettype   isdoublequote       token gettype   iseol
// we need to loop until we find the ending double quote, or the eol
nexttoken tokentype doublequote  tokentype eol
expect tokentype doublequote
return true
return false
protected boolean functiontext
if  accept tokentype functionstart
nexttoken
while   token gettype   isfunctionend       token gettype   iseol
if  token gettype   isfunctionstart
// embedded function
functiontext
// we need to loop until we find the ending function quote, an embedded function, or the eol
nexttoken
// if its not an embedded function then we expect the end token
if   token gettype   isfunctionstart
expect tokentype functionend
return true
return false
protected boolean unaryoperator
if  accept tokentype unaryoperator
nexttoken
// there should be a whitespace after the operator
expect tokentype whitespace
return true
return false
protected boolean binaryoperator
if  accept tokentype binaryoperator
// remember the binary operator
binaryoperatortype operatortype   binaryoperatortype asoperator token gettext
nexttoken
// there should be at least one whitespace after the operator
expectandacceptmore tokentype whitespace
// okay a binary operator may not support all kind if preceding parameters, so we need to limit this
binaryoperatortype parametertype types   binaryoperatortype supportedparametertypes operatortype
// based on the parameter types the binary operator support, we need to set this state into
// the following booleans so we know how to proceed in the grammar
boolean literalwithfunctionssupported   false
boolean literalsupported   false
boolean functionsupported   false
boolean numericsupported   false
boolean booleansupported   false
boolean nullsupported   false
if  types    null    types length    0
literalwithfunctionssupported   true
// favor literal with functions over literals without functions
literalsupported   false
functionsupported   true
numericsupported   true
booleansupported   true
nullsupported   true
else
for  binaryoperatortype parametertype parametertype   types
literalsupported    parametertype isliteralsupported
literalwithfunctionssupported    parametertype isliteralwithfunctionsupport
functionsupported    parametertype isfunctionsupport
nullsupported    parametertype isnumericvaluesupported
booleansupported    parametertype isbooleanvaluesupported
nullsupported    parametertype isnullvaluesupported
// then we proceed in the grammar according to the parameter types supported by the given binary operator
//checkstyle:off
if   literalwithfunctionssupported    singlequotedliteralwithfunctionstext
literalwithfunctionssupported    doublequotedliteralwithfunctionstext
literalsupported    singlequotedliteraltext
literalsupported    doublequotedliteraltext
functionsupported    functiontext
numericsupported    numericvalue
booleansupported    booleanvalue
nullsupported    nullvalue
// then after the right hand side value, there should be a whitespace if there is more tokens
nexttoken
if   token gettype   iseol
expect tokentype whitespace
else
throw new simpleparserexception     operatortype       token  token getindex
//checkstyle:on
return true
return false
protected boolean logicaloperator
if  accept tokentype logicaloperator
// remember the logical operator
logicaloperatortype operatortype   logicaloperatortype asoperator token gettext
nexttoken
// there should be at least one whitespace after the operator
expectandacceptmore tokentype whitespace
// then we expect either some quoted text, another function, or a numeric, boolean or null value
if  singlequotedliteralwithfunctionstext
doublequotedliteralwithfunctionstext
functiontext
numericvalue
booleanvalue
nullvalue
// then after the right hand side value, there should be a whitespace if there is more tokens
nexttoken
if   token gettype   iseol
expect tokentype whitespace
else
throw new simpleparserexception     operatortype       token  token getindex
return true
return false
protected boolean numericvalue
return accept tokentype numericvalue
// no other tokens to check so do not use nexttoken
protected boolean booleanvalue
return accept tokentype booleanvalue
// no other tokens to check so do not use nexttoken
protected boolean nullvalue
return accept tokentype nullvalue
// no other tokens to check so do not use nexttoken