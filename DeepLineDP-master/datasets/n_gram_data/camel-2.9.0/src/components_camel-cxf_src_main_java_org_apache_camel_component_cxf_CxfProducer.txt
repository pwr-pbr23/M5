/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component cxf
import java io inputstream
import java util collection
import java util hashmap
import java util iterator
import java util list
import java util map
import javax xml namespace qname
import javax xml ws holder
import javax xml ws handler messagecontext scope
import org apache camel asynccallback
import org apache camel asyncprocessor
import org apache camel exchange
import org apache camel invalidpayloadexception
import org apache camel runtimecamelexception
import org apache camel component cxf common message cxfconstants
import org apache camel impl defaultproducer
import org apache camel util objecthelper
import org apache cxf bus
import org apache cxf binding soap model soapheaderinfo
import org apache cxf endpoint client
import org apache cxf jaxws context wrappedmessagecontext
import org apache cxf message exchangeimpl
import org apache cxf message message
import org apache cxf service model bindingmessageinfo
import org apache cxf service model bindingoperationinfo
import org slf4j logger
import org slf4j loggerfactory
/**
* cxfproducer binds a camel exchange to a cxf exchange, acts as a cxf
* client, and sends the request to a cxf to a server.  any response will
* be bound to camel exchange.
*
* @version
*/
public class cxfproducer extends defaultproducer implements asyncprocessor
private static final logger log   loggerfactory getlogger cxfproducer class
private client client
private cxfendpoint endpoint
/**
* constructor to create a cxfproducer.  it will create a cxf client
* object.
*
* @param endpoint a cxfendpoint that creates this producer
* @throws exception any exception thrown during the creation of a
* cxf client
*/
public cxfproducer cxfendpoint endpoint  throws exception
super endpoint
this endpoint   endpoint
client   endpoint createclient
// as the cxf client async and sync api is implement different,
// so we don't delegate the sync process call to the async process
public boolean process exchange camelexchange  asynccallback callback
log trace    camelexchange
try
// create cxf exchange
exchangeimpl cxfexchange   new exchangeimpl
// set the bus on the exchange in case the cxf interceptor need to access it from exchange
cxfexchange put bus class  endpoint getbus
// prepare binding operation info
bindingoperationinfo boi   preparebindingoperation camelexchange  cxfexchange
map<string  object> invocationcontext   new hashmap<string  object>
map<string  object> responsecontext   new hashmap<string  object>
invocationcontext put client response_context  responsecontext
invocationcontext put client request_context  preparerequest camelexchange  cxfexchange
cxfclientcallback cxfclientcallback   new cxfclientcallback callback  camelexchange  cxfexchange  boi
endpoint getcxfbinding
// send the cxf async request
client invoke cxfclientcallback  boi  getparams endpoint  camelexchange
invocationcontext  cxfexchange
if  boi getoperationinfo   isoneway
callback done false
catch  throwable ex
// error occurred before we had a chance to go async
// so set exception and invoke callback true
camelexchange setexception ex
callback done true
return true
return false
/**
* this processor binds camel exchange to a cxf exchange and
* invokes the cxf client.
*/
public void process exchange camelexchange  throws exception
log trace    camelexchange
// create cxf exchange
exchangeimpl cxfexchange   new exchangeimpl
// set the bus on the exchange in case the cxf interceptor need to access it from exchange
cxfexchange put bus class  endpoint getbus
// prepare binding operation info
bindingoperationinfo boi   preparebindingoperation camelexchange  cxfexchange
map<string  object> invocationcontext   new hashmap<string  object>
map<string  object> responsecontext   new hashmap<string  object>
invocationcontext put client response_context  responsecontext
invocationcontext put client request_context  preparerequest camelexchange  cxfexchange
try
// send the cxf request
client invoke boi  getparams endpoint  camelexchange
invocationcontext  cxfexchange
catch  exception exception
camelexchange setexception exception
finally
// bind the cxf response to camel exchange
if   boi getoperationinfo   isoneway
// copy the inmessage header to outmessage header
camelexchange getout   getheaders   putall camelexchange getin   getheaders
endpoint getcxfbinding   populateexchangefromcxfresponse camelexchange  cxfexchange
responsecontext
protected map<string  object> preparerequest exchange camelexchange  org apache cxf message exchange cxfexchange  throws exception
// create invocation context
wrappedmessagecontext requestcontext   new wrappedmessagecontext
new hashmap<string  object>    null  scope application
camelexchange setproperty message mtom_enabled  string valueof endpoint ismtomenabled
// set data format mode in exchange
dataformat dataformat   endpoint getdataformat
camelexchange setproperty cxfconstants data_format_property  dataformat
log trace    dataformat class getname    dataformat
// set data format mode in the request context
requestcontext put dataformat class getname    dataformat
// don't let cxf clientimpl close the input stream
if  dataformat    dataformat message
cxfexchange put client keep_conduit_alive  true
log trace    client keep_conduit_alive  true
// bind the request cxf exchange
endpoint getcxfbinding   populatecxfrequestfromexchange cxfexchange  camelexchange
requestcontext
// remove protocol headers from scopes.  otherwise, response headers can be
// overwritten by request headers when soaphandlerinterceptor tries to create
// a wrapped message context by the copyscoped() method.
requestcontext getscopes   remove message protocol_headers
return requestcontext getwrappedmap
private bindingoperationinfo preparebindingoperation exchange camelexchange  org apache cxf message exchange cxfexchange
// get binding operation info
bindingoperationinfo boi   getbindingoperationinfo camelexchange
objecthelper notnull boi
// keep the message wrapper in payload mode
if  endpoint getdataformat      dataformat payload    boi isunwrapped
boi   boi getwrappedoperation
cxfexchange put bindingoperationinfo class  boi
// store the original boi in the exchange
camelexchange setproperty bindingoperationinfo class getname    boi
log trace    boi
// unwrap boi before passing it to make a client call
if  endpoint getdataformat      dataformat payload     endpoint iswrapped      boi    null
if  boi isunwrappedcapable
boi   boi getunwrappedoperation
log trace    boi
return  boi
private void checkparametersize cxfendpoint endpoint  exchange exchange  object parameters
bindingoperationinfo boi   getbindingoperationinfo exchange
if  boi    null
throw new runtimecamelexception
if   endpoint iswrapped
if  boi isunwrappedcapable
boi   boi getunwrappedoperation
int experctmessagepartssize   boi getinput   getmessageparts   size
if  parameters length < experctmessagepartssize
throw new illegalargumentexception
experctmessagepartssize       parameters length
if  parameters length > experctmessagepartssize
// need to check the holder parameters
int holderssize   0
for  object parameter   parameters
if  parameter instanceof holder
holderssize
// need to check the soap header information
int soapheaderssize   0
bindingmessageinfo bmi    boi getinput
if  bmi    null
list<soapheaderinfo> headers   bmi getextensors soapheaderinfo class
if  headers    null
soapheaderssize   headers size
if  holderssize   experctmessagepartssize   soapheaderssize < parameters length
throw new illegalargumentexception
experctmessagepartssize   holderssize   soapheaderssize        parameters length
/**
* get the parameters for the web service operation
*/
private object getparams cxfendpoint endpoint  exchange exchange  throws invalidpayloadexception
object params   null
if  endpoint getdataformat      dataformat pojo
list<?> list   exchange getin   getbody list class
if  list    null
params   list toarray
else
// maybe we can iterate the body and that way create a list for the parameters
// then end users do not need to trouble with list
iterator it   exchange getin   getbody iterator class
if  it    null    it hasnext
list   exchange getcontext   gettypeconverter   convertto list class  it
if  list    null
params   list toarray
if  params    null
// no we could not then use the body as single parameter
params   new object
params   exchange getin   getbody
// make sure we have the right number of parameters
checkparametersize endpoint  exchange  params
else if  endpoint getdataformat      dataformat payload
params   new object
params   exchange getin   getmandatorybody cxfpayload class
else if  endpoint getdataformat      dataformat message
params   new object
params   exchange getin   getmandatorybody inputstream class
if  log istraceenabled
if  params    null
for  int i   0  i < params length  i
log trace    i  params
return params
/**
* get operation name from header and use it to lookup and return a
* {@link bindingoperationinfo}.
*/
private bindingoperationinfo getbindingoperationinfo exchange ex
cxfendpoint endpoint    cxfendpoint this getendpoint
bindingoperationinfo answer   null
string lp   ex getin   getheader cxfconstants operation_name  string class
if  lp    null
lp   endpoint getdefaultoperationname
if  lp    null
log debug    cxfconstants operation_name
collection<bindingoperationinfo> bois
client getendpoint   getendpointinfo   getbinding   getoperations
iterator<bindingoperationinfo> iter   bois iterator
if  iter hasnext
answer   iter next
else
string ns   ex getin   getheader cxfconstants operation_namespace  string class
if  ns    null
ns   endpoint getdefaultoperationnamespace
if  ns    null
ns   client getendpoint   getservice   getname   getnamespaceuri
log trace    ns
qname qname   new qname ns  lp
log trace    qname tostring
answer   client getendpoint   getendpointinfo   getbinding   getoperation qname
if  answer    null
throw new illegalargumentexception     qname
return answer
public client getclient
return client