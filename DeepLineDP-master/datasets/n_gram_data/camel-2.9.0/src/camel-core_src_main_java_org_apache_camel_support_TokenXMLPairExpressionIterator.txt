/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel support
import java io inputstream
import java util iterator
import java util linkedhashmap
import java util map
import java util scanner
import java util regex matcher
import java util regex pattern
import org apache camel util objecthelper
/**
* {@link org.apache.camel.expression} to walk a {@link org.apache.camel.message} xml body
* using an {@link java.util.iterator}, which grabs the content between a xml start and end token.
* <p/>
* the message body must be able to convert to {@link java.io.inputstream} type which is used as stream
* to access the message body.
* <p/>
* can be used to split big xml files.
* <p/>
* this implementation supports inheriting namespaces from a parent/root tag.
*/
public class tokenxmlpairexpressioniterator extends tokenpairexpressioniterator
private static final pattern namespace_pattern   pattern compile     ?
private static final string scan_token_regex
protected final string inheritnamespacetoken
public tokenxmlpairexpressioniterator string starttoken  string endtoken  string inheritnamespacetoken
super starttoken  endtoken  true
// namespace token is optional
this inheritnamespacetoken   inheritnamespacetoken
// must be xml tokens
if   starttoken startswith        starttoken endswith
throw new illegalargumentexception     starttoken
if   endtoken startswith        endtoken endswith
throw new illegalargumentexception     endtoken
if  inheritnamespacetoken    null      inheritnamespacetoken startswith        inheritnamespacetoken endswith
throw new illegalargumentexception     inheritnamespacetoken
@override
protected iterator createiterator inputstream in  string charset
xmltokenpairiterator iterator   new xmltokenpairiterator starttoken  endtoken  inheritnamespacetoken  in  charset
iterator init
return iterator
/**
* iterator to walk the input stream
*/
static class xmltokenpairiterator extends tokenpairiterator
private final pattern starttokenpattern
private final string scanendtoken
private final string inheritnamespacetoken
private pattern inheritnamespacetokenpattern
private string roottokennamespaces
xmltokenpairiterator string starttoken  string endtoken  string inheritnamespacetoken  inputstream in  string charset
super starttoken  endtoken  true  in  charset
// remove any ending > as we need to support attributes on the tags, so we need to use a reg exp pattern
string token   starttoken substring 0  starttoken length     1    scan_token_regex
this starttokenpattern   pattern compile token
this scanendtoken   endtoken substring 0  endtoken length     1    scan_token_regex
this inheritnamespacetoken   inheritnamespacetoken
if  inheritnamespacetoken    null
token   inheritnamespacetoken substring 0  inheritnamespacetoken length     1    scan_token_regex
this inheritnamespacetokenpattern   pattern compile token
@override
void init
// use scan end token as delimiter which supports attributes/namespaces
this scanner   new scanner in  charset  usedelimiter scanendtoken
// this iterator will do look ahead as we may have data
// after the last end token, which the scanner would find
// so we need to be one step ahead of the scanner
this image   scanner hasnext   ?  string  next true    null
@override
string getnext boolean first
string next   scanner next
if  next    null
return null
// initialize inherited namespaces on first
if  first    inheritnamespacetoken    null
roottokennamespaces   getnamespacesfromnamespacetoken next
// make sure next is positioned at start token as we can have leading data
// or we reached eol and there is no more start tags
matcher matcher   starttokenpattern matcher next
if   matcher find
return null
else
int index   matcher start
next   next substring index
// build answer accordingly to whether namespaces should be inherited or not
stringbuilder sb   new stringbuilder
if  inheritnamespacetoken    null    roottokennamespaces    null
// append root namespaces to local start token
string tag   objecthelper before next
// grab the text
string text   objecthelper after next
// build result with inherited namespaces
next   sb append tag  append roottokennamespaces  append    append text  append endtoken  tostring
else
next   sb append next  append endtoken  tostring
return next
private string getnamespacesfromnamespacetoken string text
if  text    null
return null
// grab the namespace tag
matcher mat   inheritnamespacetokenpattern matcher text
if  mat find
text   mat group 0
else
// cannot find namespace tag
return null
// find namespaces (there can be attributes mixed, so we should only grab the namespaces)
map<string  string> namespaces   new linkedhashmap<string  string>
matcher matcher   namespace_pattern matcher text
while  matcher find
string prefix   matcher group 1
string url   matcher group 2
if  objecthelper isempty prefix
prefix
else
// skip leading :
prefix   prefix substring 1
namespaces put prefix  url
// did we find any namespaces
if  namespaces isempty
return null
// build namespace string
stringbuilder sb   new stringbuilder
for  map entry<string  string> entry   namespaces entryset
string key   entry getkey
string value   entry getvalue
if    equals key
sb append
else
sb append    append key  append
return sb tostring