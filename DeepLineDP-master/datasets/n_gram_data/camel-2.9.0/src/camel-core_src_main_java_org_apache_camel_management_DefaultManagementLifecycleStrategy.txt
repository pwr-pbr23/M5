/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel management
import java util arraylist
import java util collection
import java util hashmap
import java util hashset
import java util list
import java util map
import java util set
import java util concurrent scheduledexecutorservice
import java util concurrent threadpoolexecutor
import javax management jmexception
import javax management malformedobjectnameexception
import javax management objectname
import org apache camel camelcontext
import org apache camel camelcontextaware
import org apache camel channel
import org apache camel component
import org apache camel consumer
import org apache camel endpoint
import org apache camel errorhandlerfactory
import org apache camel managementstatisticslevel
import org apache camel processor
import org apache camel producer
import org apache camel route
import org apache camel service
import org apache camel timerlistener
import org apache camel vetocamelcontextstartexception
import org apache camel api management performancecounter
import org apache camel impl consumercache
import org apache camel impl defaultcamelcontextnamestrategy
import org apache camel impl endpointregistry
import org apache camel impl eventdrivenconsumerroute
import org apache camel impl explicitcamelcontextnamestrategy
import org apache camel impl producercache
import org apache camel impl throttlinginflightroutepolicy
import org apache camel management mbean managedconsumercache
import org apache camel management mbean managedendpoint
import org apache camel management mbean managedendpointregistry
import org apache camel management mbean managedproducercache
import org apache camel management mbean managedservice
import org apache camel management mbean managedthrottlinginflightroutepolicy
import org apache camel management mbean managedtracer
import org apache camel model aopdefinition
import org apache camel model interceptdefinition
import org apache camel model oncompletiondefinition
import org apache camel model onexceptiondefinition
import org apache camel model policydefinition
import org apache camel model processordefinition
import org apache camel model routedefinition
import org apache camel processor interceptor tracer
import org apache camel spi camelcontextnamestrategy
import org apache camel spi eventnotifier
import org apache camel spi lifecyclestrategy
import org apache camel spi managementagent
import org apache camel spi managementaware
import org apache camel spi managementobjectstrategy
import org apache camel spi managementstrategy
import org apache camel spi routecontext
import org apache camel spi unitofwork
import org apache camel support servicesupport
import org apache camel support timerlistenermanager
import org apache camel util keyvalueholder
import org apache camel util objecthelper
import org apache camel util servicehelper
import org slf4j logger
import org slf4j loggerfactory
/**
* default jmx managed lifecycle strategy that registered objects using the configured
* {@link org.apache.camel.spi.managementstrategy}.
*
* @see org.apache.camel.spi.managementstrategy
* @version
*/
@suppresswarnings
public class defaultmanagementlifecyclestrategy extends servicesupport implements lifecyclestrategy  camelcontextaware
private static final logger log   loggerfactory getlogger defaultmanagementlifecyclestrategy class
private final map<processor  keyvalueholder<processordefinition  instrumentationprocessor>> wrappedprocessors
new hashmap<processor  keyvalueholder<processordefinition  instrumentationprocessor>>
private final list<preregisterservice> preservices   new arraylist<preregisterservice>
private final timerlistenermanager timerlistenermanager   new timerlistenermanager
private camelcontext camelcontext
private volatile boolean initialized
private final set<string> knowrouteids   new hashset<string>
private map<object  managedtracer> managedtracers   new hashmap<object  managedtracer>
public defaultmanagementlifecyclestrategy
public defaultmanagementlifecyclestrategy camelcontext camelcontext
this camelcontext   camelcontext
public camelcontext getcamelcontext
return camelcontext
public void setcamelcontext camelcontext camelcontext
this camelcontext   camelcontext
public void oncontextstart camelcontext context  throws vetocamelcontextstartexception
object mc   getmanagementobjectstrategy   getmanagedobjectforcamelcontext context
string managementname   context getmanagementname      null ? context getmanagementname     context getname
try
boolean done   false
while   done
objectname on   getmanagementstrategy   getmanagementnamingstrategy   getobjectnameforcamelcontext context
boolean exists   getmanagementstrategy   ismanaged mc  on
if   exists
done   true
else
// okay there exists already a camelcontext with this name, we can try to fix it by finding a free name
boolean fixed   false
// if we use the default name strategy we can find a free name to use
string name   findfreename mc  context getnamestrategy    managementname
if  name    null
// use this as the fixed name
fixed   true
done   true
managementname   name
// we could not fix it so veto starting camel
if   fixed
throw new vetocamelcontextstartexception     context getname         on
context
else
if  context getnamestrategy   instanceof defaultcamelcontextnamestrategy
// use this as the fixed name
log warn     context getname
name
// now set the fixed name we are using onwards
context setnamestrategy new explicitcamelcontextnamestrategy name
else
log warn     context getname         managementname
catch  vetocamelcontextstartexception e
// rethrow veto
throw e
catch  exception e
// must rethrow to allow camelcontext fallback to non jmx agent to allow
// camel to continue to run
throw objecthelper wrapruntimecamelexception e
// set the name we are going to use
context setmanagementname managementname
try
manageobject mc
catch  exception e
// must rethrow to allow camelcontext fallback to non jmx agent to allow
// camel to continue to run
throw objecthelper wrapruntimecamelexception e
// yes we made it and are initialized
initialized   true
// register any pre registered now that we are initialized
enlistpreregisteredservices
private string findfreename object mc  camelcontextnamestrategy strategy  string managementname  throws malformedobjectnameexception
boolean done   false
string name   null
// start from 2 as the existing name is considered the 1st
int counter   2
while   done
// compute the next name
if  strategy instanceof defaultcamelcontextnamestrategy
// prefer to use the default naming strategy to compute the next free name
name     defaultcamelcontextnamestrategy  strategy  getnextname
else
// if explicit name then use a counter prefix
name   managementname       counter
objectname on   getmanagementstrategy   getmanagementnamingstrategy   getobjectnameforcamelcontext name
done    getmanagementstrategy   ismanaged mc  on
if  log istraceenabled
log trace    new object name  on  done
return name
/**
* after {@link camelcontext} has been enlisted in jmx using {@link #oncontextstart(org.apache.camel.camelcontext)}
* then we can enlist any pre registered services as well, as we had to wait for {@link camelcontext} to be
* enlisted first.
* <p/>
* a component/endpoint/service etc. can be pre registered when using dependency injection and annotations such as
* {@link org.apache.camel.produce}, {@link org.apache.camel.endpointinject}. therefore we need to capture those
* registrations up front, and then afterwards enlist in jmx when {@link camelcontext} is being started.
*/
private void enlistpreregisteredservices
if  preservices isempty
return
log debug    preservices size
for  preregisterservice pre   preservices
if  pre getcomponent      null
oncomponentadd pre getname    pre getcomponent
else if  pre getendpoint      null
onendpointadd pre getendpoint
else if  pre getservice      null
onserviceadd pre getcamelcontext    pre getservice    pre getroute
// we are done so clear the list
preservices clear
public void oncontextstop camelcontext context
// the agent hasn't been started
if   initialized
return
try
object mc   getmanagementobjectstrategy   getmanagedobjectforcamelcontext context
// the context could have been removed already
if  getmanagementstrategy   ismanaged mc  null
unmanageobject mc
catch  exception e
log warn    e
public void oncomponentadd string name  component component
// always register components as there are only a few of those
if   initialized
// pre register so we can register later when we have been initialized
preregisterservice pre   new preregisterservice
pre oncomponentadd name  component
preservices add pre
return
try
object mc   getmanagementobjectstrategy   getmanagedobjectforcomponent camelcontext  component  name
manageobject mc
catch  exception e
log warn    e
public void oncomponentremove string name  component component
// the agent hasn't been started
if   initialized
return
try
object mc   getmanagementobjectstrategy   getmanagedobjectforcomponent camelcontext  component  name
unmanageobject mc
catch  exception e
log warn    e
/**
* if the endpoint is an instance of managedresource then register it with the
* mbean server, if it is not then wrap the endpoint in a {@link managedendpoint} and
* register that with the mbean server.
*
* @param endpoint the endpoint attempted to be added
*/
public void onendpointadd endpoint endpoint
if   initialized
// pre register so we can register later when we have been initialized
preregisterservice pre   new preregisterservice
pre onendpointadd endpoint
preservices add pre
return
if   shouldregister endpoint  null
// avoid registering if not needed
return
try
object me   getmanagementobjectstrategy   getmanagedobjectforendpoint camelcontext  endpoint
if  me    null
// endpoint should not be managed
return
manageobject me
catch  exception e
log warn     endpoint getendpointuri    e
public void onendpointremove endpoint endpoint
// the agent hasn't been started
if   initialized
return
try
object me   getmanagementobjectstrategy   getmanagedobjectforendpoint camelcontext  endpoint
unmanageobject me
catch  exception e
log warn     endpoint getendpointuri    e
public void onserviceadd camelcontext context  service service  route route
if   initialized
// pre register so we can register later when we have been initialized
preregisterservice pre   new preregisterservice
pre onserviceadd context  service  route
preservices add pre
return
// services can by any kind of misc type but also processors
// so we have special logic when its a processor
if   shouldregister service  route
// avoid registering if not needed
return
object managedobject   getmanagedobjectforservice context  service  route
if  managedobject    null
// service should not be managed
return
// skip already managed services, for example if a route has been restarted
if  getmanagementstrategy   ismanaged managedobject  null
log trace    service
return
try
manageobject managedobject
catch  exception e
log warn     service      e
public void onserviceremove camelcontext context  service service  route route
// the agent hasn't been started
if   initialized
return
object managedobject   getmanagedobjectforservice context  service  route
if  managedobject    null
try
unmanageobject managedobject
catch  exception e
log warn     service      e
@suppresswarnings
private object getmanagedobjectforservice camelcontext context  service service  route route
// skip channel, uow and dont double wrap instrumentation
if  service instanceof channel    service instanceof unitofwork    service instanceof instrumentationprocessor
return null
object answer   null
if  service instanceof managementaware
return   managementaware  service  getmanagedobject service
else if  service instanceof tracer
// special for tracer
object mo   this managedtracers get service
if  mo    null
managedtracer mt   new managedtracer context   tracer  service
mt init getmanagementstrategy
this managedtracers put service  mt
mo   mt
return mo
else if  service instanceof eventnotifier
answer   getmanagementobjectstrategy   getmanagedobjectforeventnotifier context   eventnotifier  service
else if  service instanceof producer
answer   getmanagementobjectstrategy   getmanagedobjectforproducer context   producer  service
else if  service instanceof consumer
answer   getmanagementobjectstrategy   getmanagedobjectforconsumer context   consumer  service
else if  service instanceof processor
// special for processors as we need to do some extra work
return getmanagedobjectforprocessor context   processor  service  route
else if  service instanceof throttlinginflightroutepolicy
answer   new managedthrottlinginflightroutepolicy context   throttlinginflightroutepolicy  service
else if  service instanceof consumercache
answer   new managedconsumercache context   consumercache  service
else if  service instanceof producercache
answer   new managedproducercache context   producercache  service
else if  service instanceof endpointregistry
answer   new managedendpointregistry context   endpointregistry  service
else if  service    null
// fallback as generic service
answer   getmanagementobjectstrategy   getmanagedobjectforservice context  service
if  answer    null    answer instanceof managedservice
managedservice ms    managedservice  answer
ms setroute route
ms init getmanagementstrategy
return answer
else
return answer
private object getmanagedobjectforprocessor camelcontext context  processor processor  route route
// a bit of magic here as the processors we want to manage have already been registered
// in the wrapped processors map when camel have instrumented the route on route initialization
// so the idea is now to only manage the processors from the map
keyvalueholder<processordefinition  instrumentationprocessor> holder   wrappedprocessors get processor
if  holder    null
// skip as its not an well known processor we want to manage anyway, such as channel/unitofwork/pipeline etc.
return null
// get the managed object as it can be a specialized type such as a delayer/throttler etc.
object managedobject   getmanagementobjectstrategy   getmanagedobjectforprocessor context  processor  holder getkey    route
// only manage if we have a name for it as otherwise we do not want to manage it anyway
if  managedobject    null
// is it a performance counter then we need to set our counter
if  managedobject instanceof performancecounter
instrumentationprocessor counter   holder getvalue
if  counter    null
// change counter to us
counter setcounter managedobject
return managedobject
public void onroutesadd collection<route> routes
for  route route   routes
// if we are starting camelcontext or either of the two options has been
// enabled, then enlist the route as a known route
if  getcamelcontext   getstatus   isstarting
getmanagementstrategy   getmanagementagent   getregisteralways
getmanagementstrategy   getmanagementagent   getregisternewroutes
// register as known route id
knowrouteids add route getid
if   shouldregister route  route
// avoid registering if not needed, skip to next route
continue
object mr   getmanagementobjectstrategy   getmanagedobjectforroute camelcontext  route
// skip already managed routes, for example if the route has been restarted
if  getmanagementstrategy   ismanaged mr  null
log trace    route
continue
// get the wrapped instrumentation processor from this route
// and set me as the counter
if  route instanceof eventdrivenconsumerroute
eventdrivenconsumerroute edcr    eventdrivenconsumerroute  route
processor processor   edcr getprocessor
if  processor instanceof instrumentationprocessor
instrumentationprocessor ip    instrumentationprocessor  processor
ip setcounter mr
try
manageobject mr
catch  jmexception e
log warn    e
catch  exception e
log warn    e
public void onroutesremove collection<route> routes
// the agent hasn't been started
if   initialized
return
for  route route   routes
object mr   getmanagementobjectstrategy   getmanagedobjectforroute camelcontext  route
// skip unmanaged routes
if   getmanagementstrategy   ismanaged mr  null
log trace    route
continue
try
unmanageobject mr
catch  exception e
log warn    e
public void onerrorhandleradd routecontext routecontext  processor errorhandler  errorhandlerfactory errorhandlerbuilder
if   shouldregister errorhandler  null
// avoid registering if not needed
return
object me   getmanagementobjectstrategy   getmanagedobjectforerrorhandler camelcontext  routecontext  errorhandler  errorhandlerbuilder
// skip already managed services, for example if a route has been restarted
if  getmanagementstrategy   ismanaged me  null
log trace    errorhandlerbuilder
return
try
manageobject me
catch  exception e
log warn     errorhandlerbuilder      e
public void onthreadpooladd camelcontext camelcontext  threadpoolexecutor threadpool  string id
string sourceid  string routeid  string threadpoolprofileid
// always register thread pools as there are only a few of those
if   initialized
return
object mtp   getmanagementobjectstrategy   getmanagedobjectforthreadpool camelcontext  threadpool  id  sourceid  routeid  threadpoolprofileid
// skip already managed services, for example if a route has been restarted
if  getmanagementstrategy   ismanaged mtp  null
log trace    threadpool
return
try
manageobject mtp
catch  exception e
log warn     threadpool      e
public void onroutecontextcreate routecontext routecontext
if   initialized
return
// create a map (processortype -> performancecounter)
// to be passed to instrumentationinterceptstrategy.
map<processordefinition  performancecounter> registeredcounters
new hashmap<processordefinition  performancecounter>
// each processor in a route will have its own performance counter.
// these performance counter will be embedded to instrumentationprocessor
// and wrap the appropriate processor by instrumentationinterceptstrategy.
routedefinition route   routecontext getroute
// register performance counters for all processors and its children
for  processordefinition processor   route getoutputs
registerperformancecounters routecontext  processor  registeredcounters
// set this managed intercept strategy that executes the jmx instrumentation for performance metrics
// so our registered counters can be used for fine grained performance instrumentation
routecontext setmanagedinterceptstrategy new instrumentationinterceptstrategy registeredcounters  wrappedprocessors
@suppresswarnings
private void registerperformancecounters routecontext routecontext  processordefinition processor
map<processordefinition  performancecounter> registeredcounters
// traverse children if any exists
list<processordefinition> children   processor getoutputs
for  processordefinition child   children
registerperformancecounters routecontext  child  registeredcounters
// skip processors that should not be registered
if   registerprocessor processor
return
// okay this is a processor we would like to manage so create the
// a delegate performance counter that acts as the placeholder in the interceptor
// that then delegates to the real mbean which we register later in the onserviceadd method
delegateperformancecounter pc   new delegateperformancecounter
// set statistics enabled depending on the option
boolean enabled   camelcontext getmanagementstrategy   getstatisticslevel      managementstatisticslevel all
pc setstatisticsenabled enabled
// and add it as a a registered counter that will be used lazy when camel
// does the instrumentation of the route and adds the instrumentationprocessor
// that does the actual performance metrics gatherings at runtime
registeredcounters put processor  pc
/**
* should the given processor be registered.
*/
protected boolean registerprocessor processordefinition processor
// skip on exception
if  processor instanceof onexceptiondefinition
return false
// skip on completion
if  processor instanceof oncompletiondefinition
return false
// skip intercept
if  processor instanceof interceptdefinition
return false
// skip aop
if  processor instanceof aopdefinition
return false
// skip policy
if  processor instanceof policydefinition
return false
// only if custom id assigned
if  getmanagementstrategy   isonlymanageprocessorwithcustomid
return processor hascustomidassigned
// use customer filter
return getmanagementstrategy   manageprocessor processor
private managementstrategy getmanagementstrategy
objecthelper notnull camelcontext
return camelcontext getmanagementstrategy
private managementobjectstrategy getmanagementobjectstrategy
objecthelper notnull camelcontext
return camelcontext getmanagementstrategy   getmanagementobjectstrategy
/**
* strategy for managing the object
*
* @param me the managed object
* @throws exception is thrown if error registering the object for management
*/
protected void manageobject object me  throws exception
getmanagementstrategy   manageobject me
if  timerlistenermanager    null    me instanceof timerlistener
timerlistener timer    timerlistener  me
timerlistenermanager addtimerlistener timer
/**
* un-manages the object.
*
* @param me the managed object
* @throws exception is thrown if error unregistering the managed object
*/
protected void unmanageobject object me  throws exception
if  timerlistenermanager    null    me instanceof timerlistener
timerlistener timer    timerlistener  me
timerlistenermanager removetimerlistener timer
getmanagementstrategy   unmanageobject me
/**
* whether or not to register the mbean.
* <p/>
* the {@link managementagent} has options which controls when to register.
* this allows us to only register mbeans accordingly. for example by default any
* dynamic endpoints is not registered. this avoids to register excessive mbeans, which
* most often is not desired.
*
* @param service the object to register
* @param route   an optional route the mbean is associated with, can be <tt>null</tt>
* @return <tt>true</tt> to register, <tt>false</tt> to skip registering
*/
protected boolean shouldregister object service  route route
// the agent hasn't been started
if   initialized
return false
log trace    service  route
// always register if we are starting camelcontext
if  getcamelcontext   getstatus   isstarting
return true
// register if always is enabled
managementagent agent   getmanagementstrategy   getmanagementagent
if  agent getregisteralways
return true
// is it a known route then always accept
if  route    null    knowrouteids contains route getid
return true
// only register if we are starting a new route, and current thread is in starting routes mode
if  agent getregisternewroutes
// no specific route, then fallback to see if this thread is starting routes
// which is kept as state on the camel context
return getcamelcontext   isstartingroutes
return false
@override
protected void dostart   throws exception
objecthelper notnull camelcontext
boolean enabled   camelcontext getmanagementstrategy   getstatisticslevel      managementstatisticslevel off
if  enabled
log info    camelcontext getmanagementstrategy   getstatisticslevel
scheduledexecutorservice executorservice   camelcontext getexecutorservicemanager   newsinglethreadscheduledexecutor this
timerlistenermanager setexecutorservice executorservice
// must use 1 sec interval as the load statistics is based on 1 sec calculations
timerlistenermanager setinterval 1000
servicehelper startservice timerlistenermanager
@override
protected void dostop   throws exception
initialized   false
knowrouteids clear
preservices clear
servicehelper stopservice timerlistenermanager
/**
* class which holds any pre registration details.
*
* @see org.apache.camel.management.defaultmanagementlifecyclestrategy#enlistpreregisteredservices()
*/
private static final class preregisterservice
private string name
private component component
private endpoint endpoint
private camelcontext camelcontext
private service service
private route route
public void oncomponentadd string name  component component
this name   name
this component   component
public void onendpointadd endpoint endpoint
this endpoint   endpoint
public void onserviceadd camelcontext camelcontext  service service  route route
this camelcontext   camelcontext
this service   service
this route   route
public string getname
return name
public component getcomponent
return component
public endpoint getendpoint
return endpoint
public camelcontext getcamelcontext
return camelcontext
public service getservice
return service
public route getroute
return route