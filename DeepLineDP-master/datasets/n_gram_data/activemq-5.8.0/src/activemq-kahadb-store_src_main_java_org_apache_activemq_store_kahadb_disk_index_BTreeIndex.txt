/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store kahadb disk index
import java io ioexception
import java io outputstream
import java io printwriter
import java util iterator
import java util map
import java util concurrent atomic atomicboolean
import org slf4j logger
import org slf4j loggerfactory
import org apache activemq store kahadb disk page page
import org apache activemq store kahadb disk page pagefile
import org apache activemq store kahadb disk page transaction
import org apache activemq store kahadb disk util marshaller
/**
* btreeindex represents a variable magnitude b+tree in a page file.
* a btree is a bit flexible in that it can be used for set or
* map-based indexing.  leaf nodes are linked together for faster
* iteration of the values.
*
* <br>
* the variable magnitude attribute means that the btree attempts
* to store as many values and pointers on one page as is possible.
*
* <br>
* the implementation can optionally a be simple-prefix b+tree.
*
* <br>
* for those who don't know how a simple-prefix b+tree works, the primary
* distinction is that instead of promoting actual keys to branch pages,
* when leaves are split, a shortest-possible separator is generated at
* the pivot.  that separator is what is promoted to the parent branch
* (and continuing up the list).  as a result, actual keys and pointers
* can only be found at the leaf level.  this also affords the index the
* ability to ignore costly merging and redistribution of pages when
* deletions occur.  deletions only affect leaf pages in this
* implementation, and so it is entirely possible for a leaf page to be
* completely empty after all of its keys have been removed.
*
* , $date$
*/
public class btreeindex<key value> implements index<key value>
private static final logger log   loggerfactory getlogger btreeindex class
/**
* interface used to determine the simple prefix of two keys.
*
* , $date$
*/
static public interface prefixer<key>
/**
* this methods should return shortest prefix of value2 where the following still holds:<br/>
* value1 <= prefix <= value2.<br/><br/>
*
* when this method is called, the following is guaranteed:<br/>
* value1 < value2<br/><br/>
*
*
* @param value1
* @param value2
* @return
*/
public key getsimpleprefix key value1  key value2
/**
* stringprefixer is a prefixer implementation that works on strings.
*/
static public class stringprefixer implements prefixer<string>
/**
* example:
* if value1 is "hello world"
* and value 2 is "help me"
* then the result will be: "help"
*
* @see  prefixer#getsimpleprefix
*/
public string getsimpleprefix string value1  string value2
char c1   value1 tochararray
char c2   value2 tochararray
int n   math min c1 length  c2 length
int i  0
while  i < n
if  c1    c2
return value2 substring 0 i 1
i
if  n    c2 length
return value2
return value2 substring 0 n
private pagefile pagefile
private long pageid
private atomicboolean loaded   new atomicboolean
private final btreenode marshaller<key  value> marshaller   new btreenode marshaller<key  value> this
private marshaller<key> keymarshaller
private marshaller<value> valuemarshaller
private prefixer<key> prefixer
public btreeindex
public btreeindex long rootpageid
this pageid   rootpageid
@suppresswarnings
public btreeindex page page
this page getpageid
public btreeindex pagefile pagefile  long rootpageid
this pagefile   pagefile
this pageid   rootpageid
@suppresswarnings
public btreeindex pagefile pagefile  page page
this pagefile  page getpageid
synchronized public void load transaction tx  throws ioexception
if  loaded compareandset false  true
log debug
if  keymarshaller    null
throw new illegalargumentexception
if  valuemarshaller    null
throw new illegalargumentexception
final page<btreenode<key value>> p   tx load pageid  null
if  p gettype      page page_free_type
// need to initialize it..
btreenode<key  value> root   createnode p  null
storenode tx  root  true
synchronized public void unload transaction tx
if  loaded compareandset true  false
private btreenode<key value> getroot transaction tx  throws ioexception
return loadnode tx  pageid  null
synchronized public boolean containskey transaction tx  key key  throws ioexception
assertloaded
return getroot tx  contains tx  key
synchronized public value get transaction tx  key key  throws ioexception
assertloaded
return getroot tx  get tx  key
synchronized public value put transaction tx  key key  value value  throws ioexception
assertloaded
return getroot tx  put tx  key  value
synchronized public value remove transaction tx  key key  throws ioexception
assertloaded
return getroot tx  remove tx  key
public boolean istransient
return false
synchronized public void clear transaction tx  throws ioexception
getroot tx  clear tx
synchronized public int getminleafdepth transaction tx  throws ioexception
return getroot tx  getminleafdepth tx  0
synchronized public int getmaxleafdepth transaction tx  throws ioexception
return getroot tx  getmaxleafdepth tx  0
synchronized public void printstructure transaction tx  printwriter out  throws ioexception
getroot tx  printstructure tx  out
synchronized public void printstructure transaction tx  outputstream out  throws ioexception
printwriter pw   new printwriter out false
getroot tx  printstructure tx  pw
pw flush
synchronized public boolean isempty final transaction tx  throws ioexception
return getroot tx  isempty tx
synchronized public iterator<map entry<key value>> iterator final transaction tx  throws ioexception
return getroot tx  iterator tx
synchronized public iterator<map entry<key value>> iterator final transaction tx  key initialkey  throws ioexception
return getroot tx  iterator tx  initialkey
synchronized public void visit transaction tx  btreevisitor<key  value> visitor  throws ioexception
getroot tx  visit tx  visitor
synchronized public map entry<key value> getfirst transaction tx  throws ioexception
return getroot tx  getfirst tx
synchronized public map entry<key value> getlast transaction tx  throws ioexception
return getroot tx  getlast tx
///////////////////////////////////////////////////////////////////
// internal implementation methods
///////////////////////////////////////////////////////////////////
private void assertloaded   throws illegalstateexception
if   loaded get
throw new illegalstateexception
///////////////////////////////////////////////////////////////////
// internal methods made accessible to btreenode
///////////////////////////////////////////////////////////////////
btreenode<key value> loadnode transaction tx  long pageid  btreenode<key value> parent  throws ioexception
page<btreenode<key value>> page   tx load pageid  marshaller
btreenode<key  value> node   page get
node setpage page
node setparent parent
return node
btreenode<key value> createnode transaction tx  btreenode<key value> parent  throws ioexception
page<btreenode<key value>> p   tx allocate
btreenode<key value> node   new btreenode<key value> this
node setpage p
node setparent parent
node setempty
p set node
return node
btreenode<key value> createnode page<btreenode<key value>> p  btreenode<key value> parent  throws ioexception
btreenode<key value> node   new btreenode<key value> this
node setpage p
node setparent parent
node setempty
p set node
return node
void storenode transaction tx  btreenode<key value> node  boolean overflow  throws ioexception
tx store node getpage    marshaller  overflow
///////////////////////////////////////////////////////////////////
// property accessors
///////////////////////////////////////////////////////////////////
public pagefile getpagefile
return pagefile
public long getpageid
return pageid
public marshaller<key> getkeymarshaller
return keymarshaller
public void setkeymarshaller marshaller<key> keymarshaller
this keymarshaller   keymarshaller
public marshaller<value> getvaluemarshaller
return valuemarshaller
public void setvaluemarshaller marshaller<value> valuemarshaller
this valuemarshaller   valuemarshaller
public prefixer<key> getprefixer
return prefixer
public void setprefixer prefixer<key> prefixer
this prefixer   prefixer
public void setpagefile pagefile pagefile
this pagefile   pagefile
public void setpageid long pageid
this pageid   pageid