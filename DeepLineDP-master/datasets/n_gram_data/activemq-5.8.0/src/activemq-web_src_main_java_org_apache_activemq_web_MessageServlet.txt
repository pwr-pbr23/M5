/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq web
import java io ioexception
import java io printwriter
import java util enumeration
import java util hashmap
import javax jms destination
import javax jms jmsexception
import javax jms message
import javax jms messageconsumer
import javax jms objectmessage
import javax jms textmessage
import javax servlet servletconfig
import javax servlet servletexception
import javax servlet http httpservletrequest
import javax servlet http httpservletresponse
import org apache activemq messageavailableconsumer
import org apache activemq messageavailablelistener
import org apache activemq command activemqdestination
import org apache activemq command activemqtextmessage
import org eclipse jetty continuation continuation
import org eclipse jetty continuation continuationsupport
import org slf4j logger
import org slf4j loggerfactory
/**
* a servlet for sending and receiving messages to/from jms destinations using
* http post for sending and http get for receiving. <p/> you can specify the
* destination and whether it is a topic or queue via configuration details on
* the servlet or as request parameters. <p/> for reading messages you can
* specify a readtimeout parameter to determine how long the servlet should
* block for.
*/
public class messageservlet extends messageservletsupport
// its a bit pita that this servlet got intermixed with jetty continuation/rest
// instead of creating a special for that. we should have kept a simple servlet
// for good old fashioned request/response blocked communication.
private static final long serialversionuid   8737914695188481219l
private static final logger log   loggerfactory getlogger messageservlet class
private string readtimeoutparameter
private long defaultreadtimeout    1
private long maximumreadtimeout   20000
private long requesttimeout   1000
private string defaultcontenttype
private hashmap<string  webclient> clients   new hashmap<string  webclient>
public void init   throws servletexception
servletconfig servletconfig   getservletconfig
string name   servletconfig getinitparameter
if  name    null
defaultreadtimeout   aslong name
name   servletconfig getinitparameter
if  name    null
maximumreadtimeout   aslong name
name   servletconfig getinitparameter
if  name    null
requesttimeout   aslong name
name   servletconfig getinitparameter
if  name    null
defaultcontenttype   name
/**
* sends a message to a destination
*
* @param request
* @param response
* @throws servletexception
* @throws ioexception
*/
protected void dopost httpservletrequest request  httpservletresponse response  throws servletexception  ioexception
// lets turn the http post into a jms message
try
string action   request getparameter
string clientid   request getparameter
if  action    null    clientid    null    action equals
log info     clientid
webclient client   getwebclient request
client close
clients remove clientid
return
webclient client   getwebclient request
string text   getpostedmessagebody request
// lets create the destination from the uri?
destination destination   getdestination client  request
if  destination    null
throw new nodestinationsuppliedexception
if  log isdebugenabled
log debug     destination       text
boolean sync   issync request
textmessage message   client getsession   createtextmessage text
if  sync
string point
activemqdestination destination  getphysicalname   replace
requesttimeout
try
string body    string client getproducertemplate   requestbody point  text
activemqtextmessage answer   new activemqtextmessage
answer settext body
writemessageresponse response getwriter    answer
catch  exception e
ioexception ex   new ioexception
ex initcause e
throw ex
else
appendparameterstomessage request  message
boolean persistent   issendpersistent request
int priority   getsendpriority request
long timetolive   getsendtimetolive request
client send destination  message  persistent  priority  timetolive
// lets return a unique uri for reliable messaging
response setheader    message getjmsmessageid
response setstatus httpservletresponse sc_ok
response getwriter   write
catch  jmsexception e
throw new servletexception     e  e
/**
* supports a http delete to be equivlanent of consuming a singe message
* from a queue
*/
protected void dodelete httpservletrequest request  httpservletresponse response  throws servletexception  ioexception
domessages request  response
/**
* supports a http delete to be equivlanent of consuming a singe message
* from a queue
*/
protected void doget httpservletrequest request  httpservletresponse response  throws servletexception  ioexception
domessages request  response
/**
* reads a message from a destination up to some specific timeout period
*
* @param request
* @param response
* @throws servletexception
* @throws ioexception
*/
protected void domessages httpservletrequest request  httpservletresponse response  throws servletexception  ioexception
try
webclient client   getwebclient request
destination destination   getdestination client  request
if  destination    null
throw new nodestinationsuppliedexception
messageavailableconsumer consumer    messageavailableconsumer client getconsumer destination  request getheader webclient selectorname
message message   null
message    message request getattribute
if  message    null
// we're resuming continuation,
// so just write the message and return
writeresponse request  response  message
return
long timeout   getreadtimeout request
if  log isdebugenabled
log debug     destination       timeout
continuation continuation   null
listener listener   null
// look for any available messages
message   consumer receive 10
// get an existing continuation or create a new one if there are
// no events.
if  message    null
continuation   continuationsupport getcontinuation request
if  continuation isexpired
response setstatus httpservletresponse sc_no_content
return
continuation settimeout timeout
continuation suspend
// fetch the listeners
listener    listener consumer getavailablelistener
if  listener    null
listener   new listener consumer
consumer setavailablelistener listener
// register this continuation with our listener.
listener setcontinuation continuation
writeresponse request  response  message
catch  jmsexception e
throw new servletexception     e  e
protected void writeresponse httpservletrequest request  httpservletresponse response  message message  throws ioexception  jmsexception
int messages   0
try
// write a responds
printwriter writer   response getwriter
// handle any message(s)
if  message    null
// no messages so ok response of for ajax else no content.
response setstatus httpservletresponse sc_no_content
//                response.setcontenttype("text/plain");
//                writer.write("no message received");
//                writer.flush();
else
// we have at least one message so set up the response
messages   1
string type   getcontenttype request
if  type    null
response setcontenttype type
else
if  isxmlcontent message
response setcontenttype defaultcontenttype
else
response setcontenttype
response setstatus httpservletresponse sc_ok
setresponseheaders response  message
writemessageresponse writer  message
writer flush
finally
if  log isdebugenabled
log debug     messages
protected void writemessageresponse printwriter writer  message message  throws jmsexception  ioexception
if  message instanceof textmessage
textmessage textmsg    textmessage message
string txt   textmsg gettext
if  txt    null
if  txt startswith
txt   txt substring txt indexof      2
writer print txt
else if  message instanceof objectmessage
objectmessage objectmsg    objectmessage message
object object   objectmsg getobject
if  object    null
writer print object tostring
protected boolean isxmlcontent message message  throws jmsexception
if  message instanceof textmessage
textmessage textmsg    textmessage message
string txt   textmsg gettext
if  txt    null
// assume its xml when it starts with <
if  txt startswith
return true
// for any other kind of messages we dont assume xml
return false
public webclient getwebclient httpservletrequest request
string clientid   request getparameter
if  clientid    null
synchronized this
log debug     clientid
webclient client   clients get clientid
if  client    null
log debug     clientid
client   new webclient
clients put clientid  client
return client
else
return webclient getwebclient request
protected string getcontenttype httpservletrequest request
string value   request getparameter
if  value    null      equalsignorecase value
return
value   request getparameter
if  value    null      equalsignorecase value
return
return null
@suppresswarnings
protected void setresponseheaders httpservletresponse response  message message  throws jmsexception
response setheader    message getjmsdestination   tostring
response setheader    message getjmsmessageid
// return jms properties as header values.
for enumeration names   message getpropertynames    names hasmoreelements
string name    string  names nextelement
response setheader name   message getobjectproperty name  tostring
/**
* @return the timeout value for read requests which is always >= 0 and <=
*         maximumreadtimeout to avoid dos attacks
*/
protected long getreadtimeout httpservletrequest request
long answer   defaultreadtimeout
string name   request getparameter readtimeoutparameter
if  name    null
answer   aslong name
if  answer < 0    answer > maximumreadtimeout
answer   maximumreadtimeout
return answer
/*
* listen for available messages and wakeup any continuations.
*/
private static class listener implements messageavailablelistener
messageconsumer consumer
continuation continuation
listener messageconsumer consumer
this consumer   consumer
public void setcontinuation continuation continuation
synchronized  consumer
this continuation   continuation
public void onmessageavailable messageconsumer consumer
assert this consumer    consumer
synchronized  this consumer
if  continuation    null
try
message message   consumer receivenowait
continuation setattribute    message
catch  exception e
log error     e  e
continuation resume