/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker util
import java io ioexception
import org apache activemq redeliverypolicy
import org apache activemq scheduledmessage
import org apache activemq broker broker
import org apache activemq broker brokerpluginsupport
import org apache activemq broker connectioncontext
import org apache activemq broker producerbrokerexchange
import org apache activemq broker region destination
import org apache activemq broker region messagereference
import org apache activemq broker region subscription
import org apache activemq broker region policy redeliverypolicymap
import org apache activemq command activemqdestination
import org apache activemq command activemqqueue
import org apache activemq command activemqtopic
import org apache activemq command message
import org apache activemq command producerinfo
import org apache activemq filter anydestination
import org apache activemq state producerstate
import org slf4j logger
import org slf4j loggerfactory
/**
* replace regular dlq handling with redelivery via a resend to the original destination
* after a delay
* a destination matching redeliverypolicy controls the quantity and delay for re-sends
* if there is no matching policy or an existing policy limit is exceeded by default
* regular dlq processing resumes. this is controlled via sendtodlqifmaxretriesexceeded
* and fallbacktodeadletter
*
* @org.apache.xbean.xbean element="redeliveryplugin"
*/
public class redeliveryplugin extends brokerpluginsupport
private static final logger log   loggerfactory getlogger redeliveryplugin class
public static final string redelivery_delay
redeliverypolicymap redeliverypolicymap   new redeliverypolicymap
boolean sendtodlqifmaxretriesexceeded   true
private boolean fallbacktodeadletter   true
@override
public broker installplugin broker broker  throws exception
if   broker getbrokerservice   isschedulersupport
throw new illegalstateexception
validatepolicydelay 1000
return super installplugin broker
/*
* sending to dlq is called as part of a poison ack processing, before the message is acknowledged  and removed
* by the destination so a delay is vital to avoid resending before it has been consumed
*/
private void validatepolicydelay long limit
final activemqdestination matchall   new anydestination new activemqdestination new activemqqueue     new activemqtopic
for  object entry   redeliverypolicymap get matchall
redeliverypolicy redeliverypolicy    redeliverypolicy  entry
validatelimit limit  redeliverypolicy
redeliverypolicy defaultentry   redeliverypolicymap getdefaultentry
if  defaultentry    null
validatelimit limit  defaultentry
private void validatelimit long limit  redeliverypolicy redeliverypolicy
if  redeliverypolicy getinitialredeliverydelay   < limit
throw new illegalstateexception     limit       redeliverypolicy
if  redeliverypolicy getredeliverydelay   < limit
throw new illegalstateexception     limit       redeliverypolicy
public redeliverypolicymap getredeliverypolicymap
return redeliverypolicymap
public void setredeliverypolicymap redeliverypolicymap redeliverypolicymap
this redeliverypolicymap   redeliverypolicymap
public boolean issendtodlqifmaxretriesexceeded
return sendtodlqifmaxretriesexceeded
/**
* what to do if the maxretries on a matching redelivery policy is exceeded.
* when true, the region broker dlq processing will be used via sendtodeadletterqueue
* when false, there is no action
* @param sendtodlqifmaxretriesexceeded
*/
public void setsendtodlqifmaxretriesexceeded boolean sendtodlqifmaxretriesexceeded
this sendtodlqifmaxretriesexceeded   sendtodlqifmaxretriesexceeded
public boolean isfallbacktodeadletter
return fallbacktodeadletter
/**
* what to do if there is no matching redelivery policy for a destination.
* when true, the region broker dlq processing will be used via sendtodeadletterqueue
* when false, there is no action
* @param fallbacktodeadletter
*/
public void setfallbacktodeadletter boolean fallbacktodeadletter
this fallbacktodeadletter   fallbacktodeadletter
@override
public void sendtodeadletterqueue connectioncontext context  messagereference messagereference  subscription subscription
if  messagereference isexpired
// there are two uses of  sendtodeadletterqueue, we are only interested in valid messages
super sendtodeadletterqueue context  messagereference  subscription
else
try
destination regiondestination    destination  messagereference getregiondestination
final redeliverypolicy redeliverypolicy   redeliverypolicymap getentryfor regiondestination getactivemqdestination
if  redeliverypolicy    null
int redeliverycount   messagereference getredeliverycounter
if  redeliverycount < redeliverypolicy getmaximumredeliveries
long delay     redeliverycount    0 ?
redeliverypolicy getinitialredeliverydelay
redeliverypolicy getnextredeliverydelay getexistingdelay messagereference
scheduleredelivery context  messagereference  delay    redeliverycount
else if  issendtodlqifmaxretriesexceeded
super sendtodeadletterqueue context  messagereference  subscription
else
log debug     messagereference getmessageid
else if  isfallbacktodeadletter
super sendtodeadletterqueue context  messagereference  subscription
else
log debug     messagereference getmessageid         regiondestination getactivemqdestination
catch  exception exception
// abort the ack, will be effective if client use transactions or individual ack with sync send
runtimeexception tothrow    new runtimeexception     messagereference getmessageid    exception
log error tothrow tostring    exception
throw tothrow
private void scheduleredelivery connectioncontext context  messagereference messagereference  long delay  int redeliverycount  throws exception
if  log istraceenabled
destination regiondestination    destination  messagereference getregiondestination
log trace     redeliverycount       messagereference getmessageid
delay       regiondestination getactivemqdestination
final message old   messagereference getmessage
message message   old copy
message settransactionid null
message setmemoryusage null
message setmarshalledproperties null
message removeproperty scheduledmessage amq_scheduled_id
message setproperty redelivery_delay  delay
message setproperty scheduledmessage amq_scheduled_delay  delay
message setredeliverycounter redeliverycount
boolean originalflowcontrol   context isproducerflowcontrol
try
context setproducerflowcontrol false
producerinfo info   new producerinfo
producerstate state   new producerstate info
producerbrokerexchange producerexchange   new producerbrokerexchange
producerexchange setproducerstate state
producerexchange setmutable true
producerexchange setconnectioncontext context
context getbroker   send producerexchange  message
finally
context setproducerflowcontrol originalflowcontrol
private int getexistingdelay messagereference messagereference  throws ioexception
object val   messagereference getmessage   getproperty redelivery_delay
if  val instanceof long
return   long val  intvalue
return 0