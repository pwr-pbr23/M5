/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region cursors
import java io ioexception
import java util linkedlist
import java util list
import org apache activemq activemqmessageaudit
import org apache activemq service
import org apache activemq broker connectioncontext
import org apache activemq broker region destination
import org apache activemq broker region messagereference
import org apache activemq command messageid
import org apache activemq usage systemusage
/**
* interface to pending message (messages awaiting disptach to a consumer)
* cursor
*
*
*/
public interface pendingmessagecursor extends service
/**
* add a destination
*
* @param context
* @param destination
* @throws exception
*/
void add connectioncontext context  destination destination  throws exception
/**
* remove a destination
*
* @param context
* @param destination
* @throws exception
*/
list<messagereference> remove connectioncontext context  destination destination  throws exception
/**
* @return true if there are no pending messages
*/
boolean isempty
/**
* check if a destination is empty for this cursor
*
* @param destination
* @return true id the destination is empty
*/
boolean isempty destination destination
/**
* reset the cursor
*/
void reset
/**
* hint to the cursor to release any locks it might have grabbed after a
* reset
*/
void release
/**
* add message to await dispatch
*
* @param node
* @throws ioexception
* @throws exception
*/
void addmessagelast messagereference node  throws exception
/**
* add message to await dispatch - if it can
*
* @param node
* @param maxwaittime
* @return true if successful
* @throws ioexception
* @throws exception
*/
boolean tryaddmessagelast messagereference node  long maxwaittime  throws exception
/**
* add message to await dispatch
*
* @param node
* @throws exception
*/
void addmessagefirst messagereference node  throws exception
/**
* add a message recovered from a retroactive policy
*
* @param node
* @throws exception
*/
void addrecoveredmessage messagereference node  throws exception
/**
* @return true if there pending messages to dispatch
*/
boolean hasnext
/**
* @return the next pending message with its reference count increment
*/
messagereference next
/**
* remove the message at the cursor position
*/
void remove
/**
* @return the number of pending messages
*/
int size
/**
* clear all pending messages
*/
void clear
/**
* informs the broker if the subscription needs to intervention to recover
* it's state e.g. durabletopicsubscriber may do
*
* @return true if recovery required
*/
boolean isrecoveryrequired
/**
* @return the maximum batch size
*/
int getmaxbatchsize
/**
* set the max batch size
*
* @param maxbatchsize
*/
void setmaxbatchsize int maxbatchsize
/**
* give the cursor a hint that we are about to remove messages from memory
* only
*/
void resetforgc
/**
* remove a node
*
* @param node
*/
void remove messagereference node
/**
* free up any internal buffers
*/
void gc
/**
* set the usagemanager
*
* @param systemusage
* @see org.apache.activemq.usage.systemusage
*/
void setsystemusage systemusage systemusage
/**
* @return the usagemanager
*/
systemusage getsystemusage
/**
* @return the memoryusagehighwatermark
*/
int getmemoryusagehighwatermark
/**
* @param memoryusagehighwatermark the memoryusagehighwatermark to set
*/
void setmemoryusagehighwatermark int memoryusagehighwatermark
/**
* @return true if the cursor is full
*/
boolean isfull
/**
* @return true if the cursor has space to page messages into
*/
public boolean hasspace
/**
* @return true if the cursor has buffered messages ready to deliver
*/
boolean hasmessagesbufferedtodeliver
/**
* destroy the cursor
*
* @throws exception
*/
void destroy   throws exception
/**
* page in a restricted number of messages and increment the reference count
*
* @param maxitems
* @return a list of paged in messages
*/
linkedlist<messagereference> pageinlist int maxitems
/**
* set the maximum number of producers to track at one time
* @param value
*/
void setmaxproducerstoaudit int value
/**
* @return the maximum number of producers to audit
*/
int getmaxproducerstoaudit
/**
* set the maximum depth of message ids to track
* @param depth
*/
void setmaxauditdepth int depth
/**
* @return the audit depth
*/
int getmaxauditdepth
/**
* @return the enableaudit
*/
public boolean isenableaudit
/**
* @param enableaudit the enableaudit to set
*/
public void setenableaudit boolean enableaudit
/**
* @return true if the underlying state of this cursor
* disappears when the broker shuts down
*/
public boolean istransient
/**
* set the audit
* @param audit
*/
public void setmessageaudit activemqmessageaudit audit
/**
* @return the audit - could be null
*/
public activemqmessageaudit getmessageaudit
/**
* use a cache to improve performance
* @param usecache
*/
public void setusecache boolean usecache
/**
* @return true if a cache may be used
*/
public boolean isusecache
/**
* remove from auditing the message id
* @param id
*/
public void rollback messageid id
/**
* @return true if cache is being used
*/
public boolean iscacheenabled