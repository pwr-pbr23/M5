/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store jdbc
import java io file
import java io ioexception
import java sql connection
import java sql sqlexception
import java util collections
import java util locale
import java util set
import java util concurrent scheduledfuture
import java util concurrent scheduledthreadpoolexecutor
import java util concurrent threadfactory
import java util concurrent timeunit
import javax sql datasource
import org apache activemq activemqmessageaudit
import org apache activemq broker brokerservice
import org apache activemq broker brokerserviceaware
import org apache activemq broker connectioncontext
import org apache activemq command activemqdestination
import org apache activemq command activemqqueue
import org apache activemq command activemqtopic
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messageid
import org apache activemq command producerid
import org apache activemq openwire openwireformat
import org apache activemq broker locker
import org apache activemq store messagestore
import org apache activemq store persistenceadapter
import org apache activemq store topicmessagestore
import org apache activemq store transactionstore
import org apache activemq store jdbc adapter defaultjdbcadapter
import org apache activemq store memory memorytransactionstore
import org apache activemq usage systemusage
import org apache activemq util bytesequence
import org apache activemq util factoryfinder
import org apache activemq util ioexceptionsupport
import org apache activemq util longsequencegenerator
import org apache activemq util servicestopper
import org apache activemq wireformat wireformat
import org slf4j logger
import org slf4j loggerfactory
/**
* a {@link persistenceadapter} implementation using jdbc for persistence
* storage.
*
* this persistence adapter will correctly remember prepared xa transactions,
* but it will not keep track of local transaction commits so that operations
* performed against the message store are done as a single uow.
*
* @org.apache.xbean.xbean element="jdbcpersistenceadapter"
*
*
*/
public class jdbcpersistenceadapter extends datasourceservicesupport implements persistenceadapter
private static final logger log   loggerfactory getlogger jdbcpersistenceadapter class
private static factoryfinder adapterfactoryfinder   new factoryfinder
private static factoryfinder lockfactoryfinder   new factoryfinder
public static final long default_lock_keep_alive_period   30   1000
private wireformat wireformat   new openwireformat
private statements statements
private jdbcadapter adapter
private memorytransactionstore transactionstore
private scheduledthreadpoolexecutor clockdaemon
private scheduledfuture<?> cleanupticket
private int cleanupperiod   1000   60   5
private boolean useexternalmessagereferences
private boolean createtablesonstartup   true
private datasource lockdatasource
private int transactionisolation
private file directory
private boolean changeautocommitallowed   true
protected int maxproducerstoaudit 1024
protected int maxauditdepth 1000
protected boolean enableaudit false
protected int auditrecoverydepth   1024
protected activemqmessageaudit audit
protected longsequencegenerator sequencegenerator   new longsequencegenerator
protected int maxrows   defaultjdbcadapter max_rows
setlockkeepaliveperiod default_lock_keep_alive_period
public jdbcpersistenceadapter
public jdbcpersistenceadapter datasource ds  wireformat wireformat
super ds
this wireformat   wireformat
public set<activemqdestination> getdestinations
transactioncontext c   null
try
c   gettransactioncontext
return getadapter   dogetdestinations c
catch  ioexception e
return emptydestinationset
catch  sqlexception e
jdbcpersistenceadapter log    e
return emptydestinationset
finally
if  c    null
try
c close
catch  throwable e
@suppresswarnings
private set<activemqdestination> emptydestinationset
return collections empty_set
protected void createmessageaudit
if  enableaudit    audit    null
audit   new activemqmessageaudit maxauditdepth maxproducerstoaudit
transactioncontext c   null
try
c   gettransactioncontext
getadapter   domessageidscan c  auditrecoverydepth  new jdbcmessageidscanlistener
public void messageid messageid id
audit isduplicate id
catch  exception e
log error    e
finally
if  c    null
try
c close
catch  throwable e
public void initsequenceidgenerator
transactioncontext c   null
try
c   gettransactioncontext
getadapter   domessageidscan c  auditrecoverydepth  new jdbcmessageidscanlistener
public void messageid messageid id
audit isduplicate id
catch  exception e
log error    e
finally
if  c    null
try
c close
catch  throwable e
public messagestore createqueuemessagestore activemqqueue destination  throws ioexception
messagestore rc   new jdbcmessagestore this  getadapter    wireformat  destination  audit
if  transactionstore    null
rc   transactionstore proxy rc
return rc
public topicmessagestore createtopicmessagestore activemqtopic destination  throws ioexception
topicmessagestore rc   new jdbctopicmessagestore this  getadapter    wireformat  destination  audit
if  transactionstore    null
rc   transactionstore proxy rc
return rc
/**
* cleanup method to remove any state associated with the given destination
* @param destination destination to forget
*/
public void removequeuemessagestore activemqqueue destination
if  destination isqueue      getbrokerservice   shouldrecordvirtualdestination destination
try
removeconsumerdestination destination
catch  ioexception ioe
log error     destination  ioe
private void removeconsumerdestination activemqqueue destination  throws ioexception
transactioncontext c   gettransactioncontext
try
string id   destination getqualifiedname
getadapter   dodeletesubscription c  destination  id  id
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     destination  e
finally
c close
/**
* cleanup method to remove any state associated with the given destination
* no state retained.... nothing to do
*
* @param destination destination to forget
*/
public void removetopicmessagestore activemqtopic destination
public transactionstore createtransactionstore   throws ioexception
if  transactionstore    null
transactionstore   new jdbcmemorytransactionstore this
return this transactionstore
public long getlastmessagebrokersequenceid   throws ioexception
transactioncontext c   gettransactioncontext
try
long seq    getadapter   dogetlastmessagestoresequenceid c
sequencegenerator setlastsequenceid seq
long brokerseq   0
if  seq    0
byte msg   getadapter   dogetmessagebyid c  seq
if  msg    null
message last    message wireformat unmarshal new bytesequence msg
brokerseq   last getmessageid   getbrokersequenceid
else
log warn
return brokerseq
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     e  e
finally
c close
public long getlastproducersequenceid producerid id  throws ioexception
transactioncontext c   gettransactioncontext
try
return getadapter   dogetlastproducersequenceid c  id
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     e  e
finally
c close
@override
public void init   throws exception
getadapter   setuseexternalmessagereferences isuseexternalmessagereferences
if  iscreatetablesonstartup
transactioncontext transactioncontext   gettransactioncontext
transactioncontext begin
try
try
getadapter   docreatetables transactioncontext
catch  sqlexception e
log warn     e
jdbcpersistenceadapter log    e
finally
transactioncontext commit
public void dostart   throws exception
// cleanup the db periodically.
if  cleanupperiod > 0
cleanupticket   getscheduledthreadpoolexecutor   schedulewithfixeddelay new runnable
public void run
cleanup
0  cleanupperiod  timeunit milliseconds
createmessageaudit
public synchronized void dostop servicestopper stopper  throws exception
if  cleanupticket    null
cleanupticket cancel true
cleanupticket   null
public void cleanup
transactioncontext c   null
try
log debug
c   gettransactioncontext
getadapter   dodeleteoldmessages c
catch  ioexception e
log warn     e  e
catch  sqlexception e
log warn     e
jdbcpersistenceadapter log    e
finally
if  c    null
try
c close
catch  throwable e
log debug
public void setscheduledthreadpoolexecutor scheduledthreadpoolexecutor clockdaemon
this clockdaemon   clockdaemon
public scheduledthreadpoolexecutor getscheduledthreadpoolexecutor
if  clockdaemon    null
clockdaemon   new scheduledthreadpoolexecutor 5  new threadfactory
public thread newthread runnable runnable
thread thread   new thread runnable
thread setdaemon true
return thread
return clockdaemon
public jdbcadapter getadapter   throws ioexception
if  adapter    null
setadapter createadapter
return adapter
/**
*
* @deprecated as of 5.7.0, replaced by {@link #getlocker()}
*/
@deprecated
public locker getdatabaselocker   throws ioexception
return getlocker
/**
* sets the database locker strategy to use to lock the database on startup
* @throws ioexception
*
* @deprecated as of 5.7.0, replaced by {@link #setlocker(org.apache.activemq.broker.locker)}
*/
public void setdatabaselocker locker locker  throws ioexception
setlocker locker
public datasource getlockdatasource   throws ioexception
if  lockdatasource    null
lockdatasource   getdatasource
if  lockdatasource    null
throw new illegalargumentexception
else
log info
lockdatasource
return lockdatasource
public void setlockdatasource datasource datasource
this lockdatasource   datasource
public brokerservice getbrokerservice
return brokerservice
/**
* @throws ioexception
*/
protected jdbcadapter createadapter   throws ioexception
adapter    jdbcadapter  loadadapter adapterfactoryfinder
// use the default jdbc adapter if the
// database type is not recognized.
if  adapter    null
adapter   new defaultjdbcadapter
log debug     adapter
return adapter
private object loadadapter factoryfinder finder  string kind  throws ioexception
object adapter   null
transactioncontext c   gettransactioncontext
try
try
// make the filename file system safe.
string dirvername   c getconnection   getmetadata   getdrivername
dirvername   dirvername replaceall       tolowercase locale english
try
adapter   finder newinstance dirvername
log info     kind       dirvername       adapter getclass
catch  throwable e
log info     kind       dirvername
catch  sqlexception e
log warn
e getmessage
jdbcpersistenceadapter log    e
finally
c close
return adapter
public void setadapter jdbcadapter adapter
this adapter   adapter
this adapter setstatements getstatements
this adapter setmaxrows getmaxrows
public wireformat getwireformat
return wireformat
public void setwireformat wireformat wireformat
this wireformat   wireformat
public transactioncontext gettransactioncontext connectioncontext context  throws ioexception
if  context    null
return gettransactioncontext
else
transactioncontext answer    transactioncontext context getlongtermstorecontext
if  answer    null
answer   gettransactioncontext
context setlongtermstorecontext answer
return answer
public transactioncontext gettransactioncontext   throws ioexception
transactioncontext answer   new transactioncontext this
if  transactionisolation > 0
answer settransactionisolation transactionisolation
return answer
public void begintransaction connectioncontext context  throws ioexception
transactioncontext transactioncontext   gettransactioncontext context
transactioncontext begin
public void committransaction connectioncontext context  throws ioexception
transactioncontext transactioncontext   gettransactioncontext context
transactioncontext commit
public void rollbacktransaction connectioncontext context  throws ioexception
transactioncontext transactioncontext   gettransactioncontext context
transactioncontext rollback
public int getcleanupperiod
return cleanupperiod
/**
* sets the number of milliseconds until the database is attempted to be
* cleaned up for durable topics
*/
public void setcleanupperiod int cleanupperiod
this cleanupperiod   cleanupperiod
public boolean ischangeautocommitallowed
return changeautocommitallowed
/**
* whether the jdbc driver allows to set the auto commit.
* some drivers does not allow changing the auto commit. the default value is true.
*
* @param changeautocommitallowed true to change, false to not change.
*/
public void setchangeautocommitallowed boolean changeautocommitallowed
this changeautocommitallowed   changeautocommitallowed
public void deleteallmessages   throws ioexception
transactioncontext c   gettransactioncontext
try
getadapter   dodroptables c
getadapter   setuseexternalmessagereferences isuseexternalmessagereferences
getadapter   docreatetables c
log info
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create e
finally
c close
public boolean isuseexternalmessagereferences
return useexternalmessagereferences
public void setuseexternalmessagereferences boolean useexternalmessagereferences
this useexternalmessagereferences   useexternalmessagereferences
public boolean iscreatetablesonstartup
return createtablesonstartup
/**
* sets whether or not tables are created on startup
*/
public void setcreatetablesonstartup boolean createtablesonstartup
this createtablesonstartup   createtablesonstartup
/**
* @deprecated use {@link #setuselock(boolean)} instead
*
* sets whether or not an exclusive database lock should be used to enable
* jdbc master/slave. enabled by default.
*/
@deprecated
public void setusedatabaselock boolean usedatabaselock
setuselock usedatabaselock
public static void log string msg  sqlexception e
string s   msg   e getmessage
while  e getnextexception      null
e   e getnextexception
s        e getmessage
log warn s  e
public statements getstatements
if  statements    null
statements   new statements
return statements
public void setstatements statements statements
this statements   statements
/**
* @param usagemanager the usagemanager that is controlling the
*                destination's memory usage.
*/
public void setusagemanager systemusage usagemanager
public locker createdefaultlocker   throws ioexception
locker locker    locker  loadadapter lockfactoryfinder
if  locker    null
locker   new defaultdatabaselocker
log debug     locker
locker configure this
return locker
public void setbrokername string brokername
public string tostring
return     super tostring
public void setdirectory file dir
this directory dir
public file getdirectory
if  this directory  null    brokerservice    null
this directory brokerservice getbrokerdatadirectory
return this directory
// interesting bit here is proof that db is ok
public void checkpoint boolean sync  throws ioexception
// by pass transactioncontext to avoid io exception handler
connection connection   null
try
connection   getdatasource   getconnection
catch  sqlexception e
log debug     e
throw ioexceptionsupport create e
finally
if  connection    null
try
connection close
catch  throwable ignored
public long size
return 0
/**
* @deprecated use {@link locker#setlockacquiresleepinterval(long)} instead
*
* millisecond interval between lock acquire attempts, applied to newly created defaultdatabaselocker
* not applied if databaselocker is injected.
*
*/
public void setlockacquiresleepinterval long lockacquiresleepinterval  throws ioexception
getlocker   setlockacquiresleepinterval lockacquiresleepinterval
/**
* set the transaction isolation level to something other that transaction_read_uncommitted
* this allowable dirty isolation level may not be achievable in clustered db environments
* so a more restrictive and expensive option may be needed like transaction_repeatable_read
* see isolation level constants in {@link java.sql.connection}
* @param transactionisolation the isolation level to use
*/
public void settransactionisolation int transactionisolation
this transactionisolation   transactionisolation
public int getmaxproducerstoaudit
return maxproducerstoaudit
public void setmaxproducerstoaudit int maxproducerstoaudit
this maxproducerstoaudit   maxproducerstoaudit
public int getmaxauditdepth
return maxauditdepth
public void setmaxauditdepth int maxauditdepth
this maxauditdepth   maxauditdepth
public boolean isenableaudit
return enableaudit
public void setenableaudit boolean enableaudit
this enableaudit   enableaudit
public int getauditrecoverydepth
return auditrecoverydepth
public void setauditrecoverydepth int auditrecoverydepth
this auditrecoverydepth   auditrecoverydepth
public long getnextsequenceid
synchronized sequencegenerator
return sequencegenerator getnextsequenceid
public int getmaxrows
return maxrows
/*
* the max rows return from queries, with sparse selectors this may need to be increased
*/
public void setmaxrows int maxrows
this maxrows   maxrows
public void recover jdbcmemorytransactionstore jdbcmemorytransactionstore  throws ioexception
transactioncontext c   gettransactioncontext
try
getadapter   dorecoverpreparedops c  jdbcmemorytransactionstore
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     jdbcmemorytransactionstore       e e
finally
c close
public void commitadd connectioncontext context  messageid messageid  throws ioexception
transactioncontext c   gettransactioncontext context
try
long sequence    long messageid getdatalocator
getadapter   docommitaddop c  sequence
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     messageid       e  e
finally
c close
public void commitremove connectioncontext context  messageack ack  throws ioexception
transactioncontext c   gettransactioncontext context
try
getadapter   doremovemessage c   long ack getlastmessageid   getdatalocator    null
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     ack       e e
finally
c close
public void commitlastack connectioncontext context  long xidlastack  long priority  activemqdestination destination  string subname  string clientid  throws ioexception
transactioncontext c   gettransactioncontext context
try
getadapter   dosetlastack c  destination  null  clientid  subname  xidlastack  priority
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     priority       destination       subname       clientid       e e
finally
c close
public void rollbacklastack connectioncontext context  jdbctopicmessagestore store  messageack ack  string subname  string clientid  throws ioexception
transactioncontext c   gettransactioncontext context
try
byte priority    byte  store getcachedstoresequenceid c  store getdestination    ack getlastmessageid
getadapter   doclearlastack c  store getdestination    priority  clientid  subname
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     ack        store getdestination         subname       clientid       e e
finally
c close
// after recovery there is no record of the original messageid for the ack
public void rollbacklastack connectioncontext context  byte priority  activemqdestination destination  string subname  string clientid  throws ioexception
transactioncontext c   gettransactioncontext context
try
getadapter   doclearlastack c  destination  priority  clientid  subname
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     priority       destination       subname       clientid       e  e
finally
c close
long getstoresequenceidformessageid messageid messageid  activemqdestination destination  throws ioexception
long result   new long  1  byte max_value  1
transactioncontext c   gettransactioncontext
try
result   adapter getstoresequenceid c  destination  messageid
catch  sqlexception e
jdbcpersistenceadapter log    e
throw ioexceptionsupport create     messageid      destination       e  e
finally
c close
return result