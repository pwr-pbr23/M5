/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq pool
import java util concurrent atomic atomicboolean
import javax jms connection
import javax jms connectionfactory
import javax jms jmsexception
import org apache activemq activemqconnection
import org apache activemq activemqconnectionfactory
import org apache activemq service
import org apache activemq util jmsexceptionsupport
import org apache commons pool keyedobjectpool
import org apache commons pool keyedpoolableobjectfactory
import org apache commons pool objectpoolfactory
import org apache commons pool impl generickeyedobjectpool
import org slf4j logger
import org slf4j loggerfactory
/**
* a jms provider which pools connection, session and messageproducer instances
* so it can be used with tools like <a href="http://camel.apache.org/activemq.html">camel</a> and spring's
* <a href="http://activemq.apache.org/spring-support.html">jmstemplate and messaglistenercontainer</a>.
* connections, sessions and producers are returned to a pool after use so that they can be reused later
* without having to undergo the cost of creating them again.
*
* b>note:</b> while this implementation does allow the creation of a collection of active consumers,
* it does not 'pool' consumers. pooling makes sense for connections, sessions and producers, which
* are expensive to create and can remain idle a minimal cost. consumers, on the other hand, are usually
* just created at startup and left active, handling incoming messages as they come. when a consumer is
* complete, it is best to close it rather than return it to a pool for later reuse: this is because,
* even if a consumer is idle, activemq will keep delivering messages to the consumer's prefetch buffer,
* where they'll get held until the consumer is active again.
*
* if you are creating a collection of consumers (for example, for multi-threaded message consumption), you
* might want to consider using a lower prefetch value for each consumer (e.g. 10 or 20), to ensure that
* all messages don't end up going to just one of the consumers. see this faq entry for more detail:
* http://activemq.apache.org/i-do-not-receive-messages-in-my-second-consumer.html
*
* optionally, one may configure the pool to examine and possibly evict objects as they sit idle in the
* pool. this is performed by an "idle object eviction" thread, which runs asynchronously. caution should
* be used when configuring this optional feature. eviction runs contend with client threads for access
* to objects in the pool, so if they run too frequently performance issues may result. the idle object
* eviction thread may be configured using the {@link settimebetweenexpirationcheckmillis} method.  by
* default the value is -1 which means no eviction thread will be run.  set to a non-negative value to
* configure the idle eviction thread to run.
*
* @org.apache.xbean.xbean element="pooledconnectionfactory"
*/
public class pooledconnectionfactory implements connectionfactory  service
private static final transient logger log   loggerfactory getlogger pooledconnectionfactory class
private final atomicboolean stopped   new atomicboolean false
private final generickeyedobjectpool<connectionkey  connectionpool> connectionspool
private connectionfactory connectionfactory
private int maximumactivesessionperconnection   500
private int idletimeout   30   1000
private boolean blockifsessionpoolisfull   true
private long expirytimeout   0l
private boolean createconnectiononstartup   true
/**
* creates new pooledconnectionfactory with a default activemqconnectionfactory instance.
* <p/>
* the uri used to connect to activemq comes from the default value of activemqconnectionfactory.
*/
public pooledconnectionfactory
this new activemqconnectionfactory
/**
* creates a new pooledconnectionfactory that will use the given broker uri to connect to
* activemq.
*
* @param brokerurl
*      the uri to use to configure the internal activemqconnectionfactory.
*/
public pooledconnectionfactory string brokerurl
this new activemqconnectionfactory brokerurl
/**
* creates a new pooledconnectionfactory that will use the given activemqconnectionfactory to
* create new activemqconnection instances that will be pooled.
*
* @param connectionfactory
*      the activemqconnectionfactory to create new connections for this pool.
*/
public pooledconnectionfactory activemqconnectionfactory connectionfactory
this connectionfactory   connectionfactory
this connectionspool   new generickeyedobjectpool<connectionkey  connectionpool>
new keyedpoolableobjectfactory<connectionkey  connectionpool>
@override
public void activateobject connectionkey key  connectionpool connection  throws exception
@override
public void destroyobject connectionkey key  connectionpool connection  throws exception
try
if  log istraceenabled
log trace    connection
connection close
catch  exception e
log warn     connection     e
@override
public connectionpool makeobject connectionkey key  throws exception
activemqconnection delegate   createconnection key
connectionpool connection   createconnectionpool delegate
connection setidletimeout getidletimeout
connection setexpirytimeout getexpirytimeout
connection setmaximumactivesessionperconnection getmaximumactivesessionperconnection
connection setblockifsessionpoolisfull isblockifsessionpoolisfull
if  log istraceenabled
log trace    connection
return connection
@override
public void passivateobject connectionkey key  connectionpool connection  throws exception
@override
public boolean validateobject connectionkey key  connectionpool connection
if  connection    null    connection expiredcheck
if  log istraceenabled
log trace    connection
return false
return true
// set max idle (not max active) since our connections always idle in the pool.
this connectionspool setmaxidle 1
// we always want our validate method to control when idle objects are evicted.
this connectionspool settestonborrow true
this connectionspool settestwhileidle true
/**
* @return the currently configured connectionfactory used to create the pooled connections.
*/
public connectionfactory getconnectionfactory
return connectionfactory
/**
* sets the connectionfactory used to create new pooled connections.
* <p/>
* updates to this value do not affect connections that were previously created and placed
* into the pool.  in order to allocate new connections based off this new connectionfactory
* it is first necessary to {@link clear} the pooled connections.
*
* @param connectionfactory
*      the factory to use to create pooled connections.
*/
public void setconnectionfactory connectionfactory connectionfactory
this connectionfactory   connectionfactory
@override
public connection createconnection   throws jmsexception
return createconnection null  null
@override
public synchronized connection createconnection string username  string password  throws jmsexception
if  stopped get
log debug
return null
connectionpool connection   null
connectionkey key   new connectionkey username  password
// this will either return an existing non-expired connectionpool or it
// will create a new one to meet the demand.
if  connectionspool getnumidle key  < getmaxconnections
try
// we want borrowobject to return the one we added.
connectionspool setlifo true
connectionspool addobject key
catch  exception e
throw jmsexceptionsupport create    e
else
// now we want the oldest one in the pool.
connectionspool setlifo false
try
connection   connectionspool borrowobject key
catch  exception e
throw jmsexceptionsupport create    e
try
connectionspool returnobject key  connection
catch  exception e
throw jmsexceptionsupport create    e
return new pooledconnection connection
/**
* @deprecated
*/
public objectpoolfactory<?> getpoolfactory
return null
protected activemqconnection createconnection connectionkey key  throws jmsexception
if  key getusername      null    key getpassword      null
return  activemqconnection connectionfactory createconnection
else
return  activemqconnection connectionfactory createconnection key getusername    key getpassword
@override
public void start
log debug    iscreateconnectiononstartup
stopped set false
if  iscreateconnectiononstartup
try
// warm the pool by creating a connection during startup
createconnection
catch  jmsexception e
log warn    e
@override
public void stop
log debug
connectionspool getnumactive
if  stopped compareandset false  true
try
connectionspool close
catch  exception e
/**
* clears all connections from the pool.  each connection that is currently in the pool is
* closed and removed from the pool.  a new connection will be created on the next call to
* {@link createconnection}.  care should be taken when using this method as connections that
* are in use be client's will be closed.
*/
public void clear
if  stopped get
return
this connectionspool clear
/**
* @deprecated use {@link #getmaximumactivesessionperconnection()}
*/
@deprecated
public int getmaximumactive
return getmaximumactivesessionperconnection
/**
* @deprecated use {@link #setmaximumactivesessionperconnection(int)}
*/
@deprecated
public void setmaximumactive int maximumactive
setmaximumactivesessionperconnection maximumactive
/**
* returns the currently configured maximum number of sessions a pooled connection will
* create before it either blocks or throws an exception when a new session is requested,
* depending on configuration.
*
* @return the number of session instances that can be taken from a pooled connection.
*/
public int getmaximumactivesessionperconnection
return maximumactivesessionperconnection
/**
* sets the maximum number of active sessions per connection
*
* @param maximumactivesessionperconnection
*      the maximum number of active session per connection in the pool.
*/
public void setmaximumactivesessionperconnection int maximumactivesessionperconnection
this maximumactivesessionperconnection   maximumactivesessionperconnection
/**
* controls the behavior of the internal session pool. by default the call to
* connection.getsession() will block if the session pool is full.  if the
* argument false is given, it will change the default behavior and instead the
* call to getsession() will throw a jmsexception.
*
* the size of the session pool is controlled by the @see #maximumactive
* property.
*
* @param block - if true, the call to getsession() blocks if the pool is full
* until a session object is available.  defaults to true.
*/
public void setblockifsessionpoolisfull boolean block
this blockifsessionpoolisfull   block
/**
* returns whether a pooled connection will enter a blocked state or will throw an exception
* once the maximum number of sessions has been borrowed from the the session pool.
*
* @return true if the pooled connection createsession method will block when the limit is hit.
* @see setblockifsessionpoolisfull
*/
public boolean isblockifsessionpoolisfull
return this blockifsessionpoolisfull
/**
* returns the maximum number to pooled connections that this factory will allow before it
* begins to return connections from the pool on calls to ({@link createconnection}.
*
* @return the maxconnections that will be created for this pool.
*/
public int getmaxconnections
return connectionspool getmaxidle
/**
* sets the maximum number of pooled connections (defaults to one).  each call to
* {@link createconnection} will result in a new connection being create up to the max
* connections value.
*
* @param maxconnections the maxconnections to set
*/
public void setmaxconnections int maxconnections
this connectionspool setmaxidle maxconnections
/**
* gets the idle timeout value applied to new connection's that are created by this pool.
* <p/>
* the idle timeout is used determine if a connection instance has sat to long in the pool unused
* and if so is closed and removed from the pool.  the default value is 30 seconds.
*
* @return
*/
public int getidletimeout
return idletimeout
/**
* sets the idle timeout value for connection's that are created by this pool, defaults to 30 seconds.
* <p/>
* for a connection that is in the pool but has no current users the idle timeout determines how
* long the connection can live before it is eligible for removal from the pool.  normally the
* connections are tested when an attempt to check one out occurs so a connection instance can sit
* in the pool much longer than its idle timeout if connections are used infrequently.
*
*
* @param idletimeout
*      the maximum time a pooled connection can sit unused before it is eligible for removal.
*/
public void setidletimeout int idletimeout
this idletimeout   idletimeout
/**
* allow connections to expire, irrespective of load or idle time. this is useful with failover
* to force a reconnect from the pool, to reestablish load balancing or use of the master post recovery
*
* @param expirytimeout non zero in milliseconds
*/
public void setexpirytimeout long expirytimeout
this expirytimeout   expirytimeout
/**
* @return the configured expiration timeout for connections in the pool.
*/
public long getexpirytimeout
return expirytimeout
/**
* @return true if a connection is created immediately on a call to {@link start}.
*/
public boolean iscreateconnectiononstartup
return createconnectiononstartup
/**
* whether to create a connection on starting this {@link pooledconnectionfactory}.
* <p/>
* this can be used to warm-up the pool on startup. notice that any kind of exception
* happens during startup is logged at warn level and ignored.
*
* @param createconnectiononstartup <tt>true</tt> to create a connection on startup
*/
public void setcreateconnectiononstartup boolean createconnectiononstartup
this createconnectiononstartup   createconnectiononstartup
/**
* gets the pool of connectionpool instances which are keyed by different connectionkeys.
*
* @return this factories pool of connectionpool instances.
*/
keyedobjectpool<connectionkey  connectionpool> getconnectionspool
return this connectionspool
/**
* sets the number of milliseconds to sleep between runs of the idle connection eviction thread.
* when non-positive, no idle object eviction thread will be run, and connections will only be
* checked on borrow to determine if they have sat idle for too long or have failed for some
* other reason.
* <p/>
* by default this value is set to -1 and no expiration thread ever runs.
*
* @param timebetweenexpirationcheckmillis
*      the time to wait between runs of the idle connection eviction thread.
*/
public void settimebetweenexpirationcheckmillis long timebetweenexpirationcheckmillis
this connectionspool settimebetweenevictionrunsmillis timebetweenexpirationcheckmillis
/**
* @return the number of milliseconds to sleep between runs of the idle connection eviction thread.
*/
public long settimebetweenexpirationcheckmillis
return this connectionspool gettimebetweenevictionrunsmillis
/**
* @return the number of connections currently in the pool
*/
public int getnumconnections
return this connectionspool getnumidle
/**
* @deprecated
*/
public void setpoolfactory objectpoolfactory<?> factory
/**
* delegate that creates each instance of an connectionpool object.  subclasses can override
* this method to customize the type of connection pool returned.
*
* @param connection
*
* @return instance of a new connectionpool.
*/
protected connectionpool createconnectionpool activemqconnection connection
return new connectionpool connection