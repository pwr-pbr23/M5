/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region
import org apache activemq broker broker
import org apache activemq broker brokerservice
import org apache activemq broker connection
import org apache activemq broker connectioncontext
import org apache activemq broker consumerbrokerexchange
import org apache activemq broker emptybroker
import org apache activemq broker producerbrokerexchange
import org apache activemq broker transportconnector
import org apache activemq broker region policy deadletterstrategy
import org apache activemq broker region policy policymap
import org apache activemq command
import org apache activemq state connectionstate
import org apache activemq store pliststore
import org apache activemq thread scheduler
import org apache activemq thread taskrunnerfactory
import org apache activemq usage systemusage
import org apache activemq util brokersupport
import org apache activemq util idgenerator
import org apache activemq util inetaddressutil
import org apache activemq util longsequencegenerator
import org apache activemq util servicestopper
import org slf4j logger
import org slf4j loggerfactory
import javax jms invalidclientidexception
import javax jms jmsexception
import java io ioexception
import java net uri
import java util arraylist
import java util collections
import java util hashmap
import java util list
import java util locale
import java util map
import java util set
import java util concurrent concurrenthashmap
import java util concurrent copyonwritearraylist
import java util concurrent threadpoolexecutor
import java util concurrent locks reentrantreadwritelock
/**
* routes broker operations to the correct messaging regions for processing.
*
*
*/
public class regionbroker extends emptybroker
public static final string original_expiration
private static final logger log   loggerfactory getlogger regionbroker class
private static final idgenerator broker_id_generator   new idgenerator
protected final destinationstatistics destinationstatistics   new destinationstatistics
protected destinationfactory destinationfactory
protected final map<connectionid  connectionstate> connectionstates   collections synchronizedmap new hashmap<connectionid  connectionstate>
private final region queueregion
private final region topicregion
private final region tempqueueregion
private final region temptopicregion
protected final brokerservice brokerservice
private boolean started
private boolean keepdurablesubsactive
private final copyonwritearraylist<connection> connections   new copyonwritearraylist<connection>
private final map<activemqdestination  destination> destinations   new concurrenthashmap<activemqdestination  destination>
private final map<brokerid  brokerinfo> brokerinfos   new hashmap<brokerid  brokerinfo>
private final longsequencegenerator sequencegenerator   new longsequencegenerator
private brokerid brokerid
private string brokername
private final map<string  connectioncontext> clientidset   new hashmap<string  connectioncontext>
private final destinationinterceptor destinationinterceptor
private connectioncontext adminconnectioncontext
private final scheduler scheduler
private final threadpoolexecutor executor
private boolean allowtempautocreationonsend
private final reentrantreadwritelock inactivedestinationspurgelock   new reentrantreadwritelock
private final runnable purgeinactivedestinationstask   new runnable
public void run
purgeinactivedestinations
public regionbroker brokerservice brokerservice  taskrunnerfactory taskrunnerfactory  systemusage memorymanager  destinationfactory destinationfactory
destinationinterceptor destinationinterceptor scheduler scheduler threadpoolexecutor executor  throws ioexception
this brokerservice   brokerservice
this executor executor
this scheduler   scheduler
if  destinationfactory    null
throw new illegalargumentexception
this sequencegenerator setlastsequenceid destinationfactory getlastmessagebrokersequenceid
this destinationfactory   destinationfactory
queueregion   createqueueregion memorymanager  taskrunnerfactory  destinationfactory
topicregion   createtopicregion memorymanager  taskrunnerfactory  destinationfactory
this destinationinterceptor   destinationinterceptor
tempqueueregion   createtempqueueregion memorymanager  taskrunnerfactory  destinationfactory
temptopicregion   createtemptopicregion memorymanager  taskrunnerfactory  destinationfactory
@override
public map<activemqdestination  destination> getdestinationmap
map<activemqdestination  destination> answer   new hashmap<activemqdestination  destination> getqueueregion   getdestinationmap
answer putall gettopicregion   getdestinationmap
return answer
@override
public set <destination> getdestinations activemqdestination destination
try
return getregion destination  getdestinations destination
catch  jmsexception jmse
return collections emptyset
@override
@suppresswarnings
public broker getadaptor class type
if  type isinstance this
return this
return null
public region getqueueregion
return queueregion
public region gettempqueueregion
return tempqueueregion
public region gettemptopicregion
return temptopicregion
public region gettopicregion
return topicregion
protected region createtemptopicregion systemusage memorymanager  taskrunnerfactory taskrunnerfactory  destinationfactory destinationfactory
return new temptopicregion this  destinationstatistics  memorymanager  taskrunnerfactory  destinationfactory
protected region createtempqueueregion systemusage memorymanager  taskrunnerfactory taskrunnerfactory  destinationfactory destinationfactory
return new tempqueueregion this  destinationstatistics  memorymanager  taskrunnerfactory  destinationfactory
protected region createtopicregion systemusage memorymanager  taskrunnerfactory taskrunnerfactory  destinationfactory destinationfactory
return new topicregion this  destinationstatistics  memorymanager  taskrunnerfactory  destinationfactory
protected region createqueueregion systemusage memorymanager  taskrunnerfactory taskrunnerfactory  destinationfactory destinationfactory
return new queueregion this  destinationstatistics  memorymanager  taskrunnerfactory  destinationfactory
@override
public void start   throws exception
started   true
queueregion start
topicregion start
tempqueueregion start
temptopicregion start
int period   this brokerservice getscheduleperiodfordestinationpurge
if  period > 0
this scheduler executeperiodically purgeinactivedestinationstask  period
@override
public void stop   throws exception
started   false
this scheduler cancel purgeinactivedestinationstask
servicestopper ss   new servicestopper
dostop ss
ss throwfirstexception
// clear the state
clientidset clear
connections clear
destinations clear
brokerinfos clear
public policymap getdestinationpolicy
return brokerservice    null ? brokerservice getdestinationpolicy     null
@override
public void addconnection connectioncontext context  connectioninfo info  throws exception
string clientid   info getclientid
if  clientid    null
throw new invalidclientidexception
synchronized  clientidset
connectioncontext oldcontext   clientidset get clientid
if  oldcontext    null
throw new invalidclientidexception     getbrokername         clientid
oldcontext getconnection   getremoteaddress
else
clientidset put clientid  context
connections add context getconnection
@override
public void removeconnection connectioncontext context  connectioninfo info  throwable error  throws exception
string clientid   info getclientid
if  clientid    null
throw new invalidclientidexception
synchronized  clientidset
connectioncontext oldvalue   clientidset get clientid
// we may be removing the duplicate connection, not the first
// connection to be created
// so lets check that their connection ids are the same
if  oldvalue    context
if  isequal oldvalue getconnectionid    info getconnectionid
clientidset remove clientid
connections remove context getconnection
protected boolean isequal connectionid connectionid  connectionid connectionid2
return connectionid    connectionid2     connectionid    null    connectionid equals connectionid2
@override
public connection getclients   throws exception
arraylist<connection> l   new arraylist<connection> connections
connection rc   new connection
l toarray rc
return rc
@override
public destination adddestination connectioncontext context  activemqdestination destination  boolean createiftemp  throws exception
destination answer
answer   destinations get destination
if  answer    null
return answer
synchronized  destinations
answer   destinations get destination
if  answer    null
return answer
boolean create   true
if  destination istemporary
create   createiftemp
answer   getregion destination  adddestination context  destination  create
destinations put destination  answer
return answer
@override
public void removedestination connectioncontext context  activemqdestination destination  long timeout  throws exception
if  destinations containskey destination
getregion destination  removedestination context  destination  timeout
destinations remove destination
@override
public void adddestinationinfo connectioncontext context  destinationinfo info  throws exception
adddestination context  info getdestination   true
@override
public void removedestinationinfo connectioncontext context  destinationinfo info  throws exception
removedestination context  info getdestination    info gettimeout
@override
public activemqdestination getdestinations   throws exception
arraylist<activemqdestination> l
l   new arraylist<activemqdestination> getdestinationmap   keyset
activemqdestination rc   new activemqdestination
l toarray rc
return rc
@override
public void addproducer connectioncontext context  producerinfo info  throws exception
activemqdestination destination   info getdestination
if  destination    null
inactivedestinationspurgelock readlock   lock
try
// this seems to cause the destination to be added but without
// advisories firing...
context getbroker   adddestination context  destination  isallowtempautocreationonsend
getregion destination  addproducer context  info
finally
inactivedestinationspurgelock readlock   unlock
@override
public void removeproducer connectioncontext context  producerinfo info  throws exception
activemqdestination destination   info getdestination
if  destination    null
inactivedestinationspurgelock readlock   lock
try
getregion destination  removeproducer context  info
finally
inactivedestinationspurgelock readlock   unlock
@override
public subscription addconsumer connectioncontext context  consumerinfo info  throws exception
activemqdestination destination   info getdestination
if  destinationinterceptor    null
destinationinterceptor create this  context  destination
inactivedestinationspurgelock readlock   lock
try
return getregion destination  addconsumer context  info
finally
inactivedestinationspurgelock readlock   unlock
@override
public void removeconsumer connectioncontext context  consumerinfo info  throws exception
activemqdestination destination   info getdestination
inactivedestinationspurgelock readlock   lock
try
getregion destination  removeconsumer context  info
finally
inactivedestinationspurgelock readlock   unlock
@override
public void removesubscription connectioncontext context  removesubscriptioninfo info  throws exception
inactivedestinationspurgelock readlock   lock
try
topicregion removesubscription context  info
finally
inactivedestinationspurgelock readlock   unlock
@override
public void send producerbrokerexchange producerexchange  message message  throws exception
activemqdestination destination   message getdestination
message setbrokerintime system currenttimemillis
if  producerexchange ismutable      producerexchange getregion      null
producerexchange getregiondestination      null    producerexchange getregiondestination   isdisposed
// ensure the destination is registered with the regionbroker
producerexchange getconnectioncontext   getbroker   adddestination producerexchange getconnectioncontext    destination  isallowtempautocreationonsend
producerexchange setregion getregion destination
producerexchange setregiondestination null
producerexchange getregion   send producerexchange  message
// clean up so these references aren't kept (possible leak) in the producer exchange
// especially since temps are transitory
if  producerexchange ismutable
producerexchange setregiondestination null
producerexchange setregion null
@override
public void acknowledge consumerbrokerexchange consumerexchange  messageack ack  throws exception
if  consumerexchange iswildcard      consumerexchange getregion      null
activemqdestination destination   ack getdestination
consumerexchange setregion getregion destination
consumerexchange getregion   acknowledge consumerexchange  ack
protected region getregion activemqdestination destination  throws jmsexception
switch  destination getdestinationtype
case activemqdestination queue_type
return queueregion
case activemqdestination topic_type
return topicregion
case activemqdestination temp_queue_type
return tempqueueregion
case activemqdestination temp_topic_type
return temptopicregion
default
throw createunknowndestinationtypeexception destination
@override
public response messagepull connectioncontext context  messagepull pull  throws exception
activemqdestination destination   pull getdestination
return getregion destination  messagepull context  pull
@override
public transactionid getpreparedtransactions connectioncontext context  throws exception
throw new illegalaccessexception
@override
public void begintransaction connectioncontext context  transactionid xid  throws exception
throw new illegalaccessexception
@override
public int preparetransaction connectioncontext context  transactionid xid  throws exception
throw new illegalaccessexception
@override
public void rollbacktransaction connectioncontext context  transactionid xid  throws exception
throw new illegalaccessexception
@override
public void committransaction connectioncontext context  transactionid xid  boolean onephase  throws exception
throw new illegalaccessexception
@override
public void forgettransaction connectioncontext context  transactionid transactionid  throws exception
throw new illegalaccessexception
@override
public void gc
queueregion gc
topicregion gc
@override
public brokerid getbrokerid
if  brokerid    null
brokerid   new brokerid broker_id_generator generateid
return brokerid
public void setbrokerid brokerid brokerid
this brokerid   brokerid
@override
public string getbrokername
if  brokername    null
try
brokername   inetaddressutil getlocalhostname   tolowercase locale english
catch  exception e
brokername
return brokername
public void setbrokername string brokername
this brokername   brokername
public destinationstatistics getdestinationstatistics
return destinationstatistics
protected jmsexception createunknowndestinationtypeexception activemqdestination destination
return new jmsexception     destination getdestinationtype
@override
public synchronized void addbroker connection connection  brokerinfo info
brokerinfo existing   brokerinfos get info getbrokerid
if  existing    null
existing   info copy
existing setpeerbrokerinfos null
brokerinfos put info getbrokerid    existing
existing incrementrefcount
if  log isdebugenabled
log debug getbrokername         info getbrokername         brokerinfos size
addbrokerinclusterupdate info
@override
public synchronized void removebroker connection connection  brokerinfo info
if  info    null
brokerinfo existing   brokerinfos get info getbrokerid
if  existing    null    existing decrementrefcount      0
brokerinfos remove info getbrokerid
if  log isdebugenabled
log debug getbrokername         info getbrokername         brokerinfos size
removebrokerinclusterupdate info
@override
public synchronized brokerinfo getpeerbrokerinfos
brokerinfo result   new brokerinfo
result   brokerinfos values   toarray result
return result
@override
public void preprocessdispatch messagedispatch messagedispatch
message message   messagedispatch getmessage
if  message    null
long endtime   system currenttimemillis
message setbrokerouttime endtime
if  getbrokerservice   isenablestatistics
long totaltime   endtime   message getbrokerintime
destination message getregiondestination    getdestinationstatistics   getprocesstime   addtime totaltime
@override
public void postprocessdispatch messagedispatch messagedispatch
@override
public void processdispatchnotification messagedispatchnotification messagedispatchnotification  throws exception
activemqdestination destination   messagedispatchnotification getdestination
getregion destination  processdispatchnotification messagedispatchnotification
@override
public boolean isstopped
return  started
@override
public set<activemqdestination> getdurabledestinations
return destinationfactory getdestinations
protected void dostop servicestopper ss
ss stop queueregion
ss stop topicregion
ss stop tempqueueregion
ss stop temptopicregion
public boolean iskeepdurablesubsactive
return keepdurablesubsactive
public void setkeepdurablesubsactive boolean keepdurablesubsactive
this keepdurablesubsactive   keepdurablesubsactive
topicregion topicregion  setkeepdurablesubsactive keepdurablesubsactive
public destinationinterceptor getdestinationinterceptor
return destinationinterceptor
@override
public connectioncontext getadminconnectioncontext
return adminconnectioncontext
@override
public void setadminconnectioncontext connectioncontext adminconnectioncontext
this adminconnectioncontext   adminconnectioncontext
public map<connectionid  connectionstate> getconnectionstates
return connectionstates
@override
public pliststore gettempdatastore
return brokerservice gettempdatastore
@override
public uri getvmconnectoruri
return brokerservice getvmconnectoruri
@override
public void brokerservicestarted
@override
public brokerservice getbrokerservice
return brokerservice
@override
public boolean isexpired messagereference messagereference
boolean expired   false
if  messagereference isexpired
try
// prevent duplicate expiry processing
message message   messagereference getmessage
synchronized  message
expired   stampasexpired message
catch  ioexception e
log warn     messagereference  e
return expired
private boolean stampasexpired message message  throws ioexception
boolean stamped false
if  message getproperty original_expiration     null
long expiration message getexpiration
message setproperty original_expiration new long expiration
stamped   true
return stamped
@override
public void messageexpired connectioncontext context  messagereference node  subscription subscription
if  log isdebugenabled
log debug     node
getroot   sendtodeadletterqueue context  node  subscription
@override
public void sendtodeadletterqueue connectioncontext context
messagereference node  subscription subscription
try
if node  null
message message node getmessage
if message  null    node getregiondestination    null
deadletterstrategy deadletterstrategy   destination node
getregiondestination    getdeadletterstrategy
if deadletterstrategy  null
if deadletterstrategy issendtodeadletterqueue message
// message may be inflight to other subscriptions so do not modify
message   message copy
stampasexpired message
message setexpiration 0
if  message ispersistent
message setpersistent true
message setproperty
// the original destination and transaction id do
// not get filled when the message is first sent,
// it is only populated if the message is routed to
// another destination like the dlq
activemqdestination deadletterdestination deadletterstrategy
getdeadletterqueuefor message  subscription
if  context getbroker    null
context setbroker getroot
brokersupport resendnocopy context message
deadletterdestination
else
if  log isdebugenabled
log debug
message getmessageid         message getdestination
catch exception e
log warn   node e
@override
public broker getroot
try
return getbrokerservice   getbroker
catch  exception e
log error     e
throw new runtimeexception
/**
* @return the broker sequence id
*/
@override
public long getbrokersequenceid
synchronized sequencegenerator
return sequencegenerator getnextsequenceid
@override
public scheduler getscheduler
return this scheduler
public threadpoolexecutor getexecutor
return this executor
@override
public void processconsumercontrol consumerbrokerexchange consumerexchange  consumercontrol control
activemqdestination destination   control getdestination
try
getregion destination  processconsumercontrol consumerexchange  control
catch  jmsexception jmse
log warn     destination        control
protected void addbrokerinclusterupdate brokerinfo info
list<transportconnector> connectors   this brokerservice gettransportconnectors
for  transportconnector connector   connectors
if  connector isupdateclusterclients
connector addpeerbroker info
connector updateclientclusterinfo
protected void removebrokerinclusterupdate brokerinfo info
list<transportconnector> connectors   this brokerservice gettransportconnectors
for  transportconnector connector   connectors
if  connector isupdateclusterclients      connector isupdateclusterclientsonremove
connector removepeerbroker info
connector updateclientclusterinfo
protected void purgeinactivedestinations
inactivedestinationspurgelock writelock   lock
try
list<destination> list   new arraylist<destination>
map<activemqdestination  destination> map   getdestinationmap
if  isallowtempautocreationonsend
map putall tempqueueregion getdestinationmap
map putall temptopicregion getdestinationmap
long maxpurgeddests   this brokerservice getmaxpurgeddestinationspersweep
long timestamp   system currenttimemillis
for  destination d   map values
d markforgc timestamp
if  d cangc
list add d
if  maxpurgeddests > 0    list size      maxpurgeddests
break
if   list isempty
connectioncontext context   brokersupport getconnectioncontext this
context setbroker this
for  destination dest   list
logger log   log
if  dest instanceof basedestination
log     basedestination  dest  getlog
log info dest getname
dest getinactivetimoutbeforegc
try
getroot   removedestination context  dest getactivemqdestination    isallowtempautocreationonsend   ? 1   0
catch  exception e
log error     dest  e
finally
inactivedestinationspurgelock writelock   unlock
public boolean isallowtempautocreationonsend
return allowtempautocreationonsend
public void setallowtempautocreationonsend boolean allowtempautocreationonsend
this allowtempautocreationonsend   allowtempautocreationonsend