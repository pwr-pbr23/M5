/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport amqp
import org apache activemq broker brokercontext
import org apache activemq command
import org apache activemq command connectionerror
import org apache activemq selector selectorparser
import org apache activemq util ioexceptionsupport
import org apache activemq util idgenerator
import org apache activemq util longsequencegenerator
import org apache qpid proton amqp
import org apache qpid proton amqp messaging
import org apache qpid proton amqp messaging modified
import org apache qpid proton amqp messaging rejected
import org apache qpid proton amqp messaging released
import org apache qpid proton amqp messaging target
import org apache qpid proton amqp transaction
import org apache qpid proton amqp transport
import org apache qpid proton engine
import org apache qpid proton engine impl connectionimpl
import org apache qpid proton engine impl linkimpl
import org apache qpid proton engine impl protocoltracer
import org apache qpid proton engine impl transportimpl
import org apache qpid proton framing transportframe
import org apache qpid proton jms
import org apache qpid proton message impl messageimpl
import org fusesource hawtbuf buffer
import org fusesource hawtbuf bytearrayoutputstream
import org slf4j logger
import org slf4j loggerfactory
import javax jms invalidselectorexception
import java io ioexception
import java io unsupportedencodingexception
import java util
import java util concurrent concurrenthashmap
import java util concurrent locks reentrantlock
class amqpprotocolconverter
public static final enumset<endpointstate> uninitialized_set   enumset of endpointstate uninitialized
public static final enumset<endpointstate> initialized_set   enumset complementof uninitialized_set
public static final enumset<endpointstate> active_state   enumset of endpointstate active
public static final enumset<endpointstate> closed_state   enumset of endpointstate closed
public static final enumset<endpointstate> all_states   enumset of endpointstate closed  endpointstate active  endpointstate uninitialized
private static final logger log   loggerfactory getlogger amqpprotocolconverter class
static final public byte empty_byte_array   new byte
private final amqptransport amqptransport
private static final symbol copy   symbol getsymbol
private static final symbol jms_selector   symbol valueof
private static final symbol no_local   symbol valueof
private static final unsignedinteger durable   new unsignedinteger 2
private static final symbol durable_subscription_ended   symbol getsymbol
int prefetch   100
reentrantlock lock   new reentrantlock
transportimpl protontransport   new transportimpl
connectionimpl protonconnection   new connectionimpl
public amqpprotocolconverter amqptransport transport  brokercontext brokercontext
this amqptransport   transport
this protontransport bind this protonconnection
if  transport istrace
this protontransport setprotocoltracer new protocoltracer
@override
public void receivedframe transportframe transportframe
system out println string format    amqptransport getremoteaddress    transportframe getbody
@override
public void sentframe transportframe transportframe
system out println string format    amqptransport getremoteaddress    transportframe getbody
void pumpprotontosocket
try
int size   1024   64
byte data   new byte
boolean done   false
while   done
int count   protontransport output data  0  size
if  count > 0
final buffer buffer
buffer   new buffer data  0  count
//                    system.out.println("writing: " + buffer.tostring().substring(5).replaceall("(..)", "$1 "));
amqptransport sendtoamqp buffer
else
done   true
//            system.out.println("write done");
catch  ioexception e
amqptransport onexception e
static class amqpsessioncontext
private final sessionid sessionid
long nextproducerid   0
long nextconsumerid   0
public amqpsessioncontext connectionid connectionid  long id
sessionid   new sessionid connectionid  id
sasl sasl
/**
* convert a amqp command
*/
public void onamqpdata object command  throws exception
buffer frame
if  command getclass      amqpheader class
amqpheader header    amqpheader command
switch  header getprotocolid
case 0
// amqptransport.sendtoamqp(new amqpheader());
break     nothing to do
case 3     client will be using sasl for auth
sasl   protontransport sasl
sasl setmechanisms new string
sasl server
break
default
frame   header getbuffer
else
frame    buffer command
onframe frame
public void onframe buffer frame  throws exception
//        system.out.println("read: " + frame.tostring().substring(5).replaceall("(..)", "$1 "));
while  frame length > 0
try
int count   protontransport input frame data  frame offset  frame length
frame movehead count
catch  throwable e
handleexception new amqpprotocolexception     frame  true  e
return
try
if  sasl  null
// lets try to complete the sasl handshake.
if  sasl getremotemechanisms   length > 0
if    equals sasl getremotemechanisms
byte data   new byte
sasl recv data  0  data length
buffer parts   new buffer data  split  byte  0
if  parts length > 0
connectioninfo setusername parts utf8   tostring
if  parts length > 1
connectioninfo setpassword parts utf8   tostring
// we can't really auth at this point since we don't know the client id yet.. :(
sasl done sasl sasloutcome pn_sasl_ok
amqptransport getwireformat   magicread   false
sasl   null
else if    equals sasl getremotemechanisms
sasl done sasl sasloutcome pn_sasl_ok
amqptransport getwireformat   magicread   false
sasl   null
// handle the amqp open..
if  protonconnection getlocalstate      endpointstate uninitialized    protonconnection getremotestate      endpointstate uninitialized
onconnectionopen
// lets map amqp sessions to openwire sessions..
session session   protonconnection sessionhead uninitialized_set  initialized_set
while  session    null
onsessionopen session
session   protonconnection sessionhead uninitialized_set  initialized_set
link link   protonconnection linkhead uninitialized_set  initialized_set
while  link    null
onlinkopen link
link   protonconnection linkhead uninitialized_set  initialized_set
delivery delivery   protonconnection getworkhead
while  delivery    null
amqpdeliverylistener listener    amqpdeliverylistener  delivery getlink   getcontext
if  listener    null
listener ondelivery delivery
delivery   delivery getworknext
link   protonconnection linkhead active_state  closed_state
while  link    null
amqpdeliverylistener link getcontext    onclose
link close
link   link next active_state  closed_state
link   protonconnection linkhead active_state  all_states
while  link    null
amqpdeliverylistener link getcontext    draincheck
link   link next active_state  all_states
session   protonconnection sessionhead active_state  closed_state
while  session    null
//todo - close links?
onsessionclose session
session   session next active_state  closed_state
if  protonconnection getlocalstate      endpointstate active    protonconnection getremotestate      endpointstate closed
doclose
catch  throwable e
handleexception new amqpprotocolexception    true  e
pumpprotontosocket
boolean closing   false
boolean closedsocket   false
private void doclose
if   closing
closing   true
sendtoactivemq new removeinfo connectionid   new responsehandler
@override
public void onresponse amqpprotocolconverter converter  response response  throws ioexception
protonconnection close
if   closedsocket
pumpprotontosocket
public void onamqpexception ioexception error
closedsocket   true
if   closing
amqptransport sendtoactivemq error
else
try
amqptransport stop
catch  exception ignore
public void onactivemqcommand command command  throws exception
if  command isresponse
response response    response  command
responsehandler rh   resposehandlers remove integer valueof response getcorrelationid
if  rh    null
rh onresponse this  response
else
// pass down any unexpected errors. should this close the connection?
if  response isexception
throwable exception     exceptionresponse  response  getexception
handleexception exception
else if  command ismessagedispatch
messagedispatch md    messagedispatch  command
consumercontext consumercontext   subscriptionsbyconsumerid get md getconsumerid
if  consumercontext    null
consumercontext onmessagedispatch md
else if  command getdatastructuretype      connectionerror data_structure_type
// pass down any unexpected async errors. should this close the connection?
throwable exception     connectionerror  command  getexception
handleexception exception
else if  command isbrokerinfo
//ignore
else
log debug     command
private static final idgenerator connection_id_generator   new idgenerator
private final connectionid connectionid   new connectionid connection_id_generator generateid
private connectioninfo connectioninfo   new connectioninfo
private long nextsessionid   0
private long nexttempdestinationid   0
static abstract class amqpdeliverylistener
abstract public void ondelivery delivery delivery  throws exception
public void onclose   throws exception
public void draincheck
private void onconnectionopen   throws amqpprotocolexception
connectioninfo setresponserequired true
connectioninfo setconnectionid connectionid
//        configureinactivitymonitor(connect.keepalive());
string clientid   protonconnection getremotecontainer
if  clientid    null     clientid isempty
connectioninfo setclientid clientid
connectioninfo settransportcontext amqptransport getpeercertificates
sendtoactivemq connectioninfo  new responsehandler
public void onresponse amqpprotocolconverter converter  response response  throws ioexception
protonconnection open
pumpprotontosocket
if  response isexception
throwable exception     exceptionresponse  response  getexception
// todo: figure out how to close /w an error.
//                    protonconnection.setlocalerror(new endpointerror(exception.getclass().getname(), exception.getmessage()));
protonconnection close
pumpprotontosocket
amqptransport onexception ioexceptionsupport create exception
return
private void onsessionopen session session
amqpsessioncontext sessioncontext   new amqpsessioncontext connectionid  nextsessionid
session setcontext sessioncontext
sendtoactivemq new sessioninfo sessioncontext sessionid   null
session open
private void onsessionclose session session
amqpsessioncontext sessioncontext    amqpsessioncontext session getcontext
if  sessioncontext  null
system out println sessioncontext sessionid
sendtoactivemq new removeinfo sessioncontext sessionid   null
session setcontext null
session close
private void onlinkopen link link
link setsource link getremotesource
link settarget link getremotetarget
amqpsessioncontext sessioncontext    amqpsessioncontext  link getsession   getcontext
if  link instanceof receiver
onreceiveropen  receiver  link  sessioncontext
else
onsenderopen  sender  link  sessioncontext
inboundtransformer inboundtransformer
protected inboundtransformer getinboundtransformer
if  inboundtransformer    null
string transformer   amqptransport gettransformer
if  transformer equals inboundtransformer transformer_jms
inboundtransformer   new jmsmappinginboundtransformer activemqjmsvendor instance
else if  transformer equals inboundtransformer transformer_native
inboundtransformer   new amqpnativeinboundtransformer activemqjmsvendor instance
else if  transformer equals inboundtransformer transformer_raw
inboundtransformer   new amqprawinboundtransformer activemqjmsvendor instance
else
log warn     transformer
inboundtransformer   new amqpnativeinboundtransformer activemqjmsvendor instance
return inboundtransformer
abstract class baseproducercontext extends amqpdeliverylistener
bytearrayoutputstream current   new bytearrayoutputstream
@override
public void ondelivery delivery delivery  throws exception
receiver receiver     receiver delivery getlink
if   delivery isreadable
system out println
return
if  current  null
current   new bytearrayoutputstream
int count
byte data   new byte
while   count   receiver recv data  0  data length   > 0
current write data  0  count
// expecting more deliveries..
if  count    0
return
receiver advance
buffer buffer   current tobuffer
current   null
onmessage receiver  delivery  buffer
abstract protected void onmessage receiver receiver  delivery delivery  buffer buffer  throws exception
class producercontext extends baseproducercontext
private final producerid producerid
private final longsequencegenerator messageidgenerator   new longsequencegenerator
private final activemqdestination destination
public producercontext producerid producerid  activemqdestination destination
this producerid   producerid
this destination   destination
@override
protected void onmessage final receiver receiver  final delivery delivery  buffer buffer  throws exception
encodedmessage em   new encodedmessage delivery getmessageformat    buffer data  buffer offset  buffer length
final activemqmessage message    activemqmessage  getinboundtransformer   transform em
current   null
if  destination  null
message setjmsdestination destination
message setproducerid producerid
if  message getmessageid    null
message setmessageid new messageid producerid  messageidgenerator getnextsequenceid
deliverystate remotestate   delivery getremotestate
if  remotestate  null    remotestate instanceof transactionalstate
transactionalstate s    transactionalstate  remotestate
long txid   tolong s gettxnid
message settransactionid new localtransactionid connectionid  txid
message onsend
sendtoactivemq message  new responsehandler
@override
public void onresponse amqpprotocolconverter converter  response response  throws ioexception
if   delivery remotelysettled
if  response isexception
exceptionresponse er    exceptionresponse response
rejected rejected   new rejected
errorcondition condition   new errorcondition
condition setcondition symbol valueof
condition setdescription er getexception   getmessage
rejected seterror condition
delivery disposition rejected
receiver flow 1
delivery settle
pumpprotontosocket
long nexttransactionid   0
class transaction
hashmap<long  transaction> transactions   new hashmap<long  transaction>
public byte tobytes long value
buffer buffer   new buffer 8
buffer bigendianeditor   writelong value
return buffer data
private long tolong binary value
buffer buffer   new buffer value getarray    value getarrayoffset    value getlength
return buffer bigendianeditor   readlong
amqpdeliverylistener coordinatorcontext   new baseproducercontext
@override
protected void onmessage receiver receiver  final delivery delivery  buffer buffer  throws exception
messageimpl msg   new messageimpl
int offset   buffer offset
int len   buffer length
while  len > 0
final int decoded   msg decode buffer data  offset  len
assert decoded > 0
offset    decoded
len    decoded
object action     amqpvalue msg getbody    getvalue
system out println   action   buffer
if  action instanceof declare
declare declare    declare  action
if  declare getglobalid    null
throw new exception
long txid   nexttransactionid
transactioninfo txinfo   new transactioninfo connectionid  new localtransactionid connectionid  txid   transactioninfo begin
sendtoactivemq txinfo  null
system out println   txid
declared declared   new declared
declared settxnid new binary tobytes txid
delivery disposition declared
delivery settle
else if  action instanceof discharge
discharge discharge    discharge  action
long txid   tolong discharge gettxnid
byte operation
if  discharge getfail
system out println   txid
operation   transactioninfo rollback
else
system out println   txid
operation   transactioninfo commit_one_phase
transactioninfo txinfo   new transactioninfo connectionid  new localtransactionid connectionid  txid   operation
sendtoactivemq txinfo  new responsehandler
@override
public void onresponse amqpprotocolconverter converter  response response  throws ioexception
if  response isexception
exceptionresponse er    exceptionresponse response
rejected rejected   new rejected
rejected seterror createerrorcondition    er getexception   getmessage
delivery disposition rejected
delivery settle
pumpprotontosocket
else
throw new exception   action getclass
void onreceiveropen final receiver receiver  amqpsessioncontext sessioncontext
// client is producing to this receiver object
org apache qpid proton amqp transport target remotetarget   receiver getremotetarget
try
if  remotetarget instanceof coordinator
pumpprotontosocket
receiver setcontext coordinatorcontext
receiver flow prefetch
receiver open
pumpprotontosocket
else
target target    target  remotetarget
producerid producerid   new producerid sessioncontext sessionid  sessioncontext nextproducerid
activemqdestination dest
if  target getdynamic
dest   createtempqueue
target actualtarget   new target
actualtarget setaddress dest getqualifiedname
actualtarget setdynamic true
receiver settarget actualtarget
else
dest   createdestination remotetarget
producercontext producercontext   new producercontext producerid  dest
receiver setcontext producercontext
receiver flow prefetch
producerinfo producerinfo   new producerinfo producerid
producerinfo setdestination dest
sendtoactivemq producerinfo  new responsehandler
public void onresponse amqpprotocolconverter converter  response response  throws ioexception
if  response isexception
receiver settarget null
throwable exception     exceptionresponse  response  getexception
linkimpl receiver  setlocalerror new endpointerror exception getclass   getname    exception getmessage
receiver close
else
receiver open
pumpprotontosocket
catch  amqpprotocolexception exception
receiver settarget null
linkimpl receiver  setlocalerror new endpointerror exception getsymbolicname    exception getmessage
receiver close
private activemqdestination createdestination object terminus  throws amqpprotocolexception
if  terminus    null
return null
else if  terminus instanceof org apache qpid proton amqp messaging source
org apache qpid proton amqp messaging source source    org apache qpid proton amqp messaging source terminus
if  source getaddress      null    source getaddress   length    0
throw new amqpprotocolexception
return activemqdestination createdestination source getaddress    activemqdestination queue_type
else if  terminus instanceof org apache qpid proton amqp messaging target
org apache qpid proton amqp messaging target target    org apache qpid proton amqp messaging target terminus
if  target getaddress      null    target getaddress   length    0
throw new amqpprotocolexception
return activemqdestination createdestination target getaddress    activemqdestination queue_type
else if  terminus instanceof coordinator
coordinator target    coordinator terminus
return null
else
throw new runtimeexception   terminus
outboundtransformer outboundtransformer   new autooutboundtransformer activemqjmsvendor instance
class consumercontext extends amqpdeliverylistener
private final consumerid consumerid
private final sender sender
private boolean presettle
private boolean closed
public consumercontext consumerid consumerid  sender sender
this consumerid   consumerid
this sender   sender
this presettle   sender getremotesendersettlemode      sendersettlemode settled
long nexttagid   0
hashset<byte> tagcache   new hashset<byte>
byte nexttag
byte rc
if  tagcache    null     tagcache isempty
final iterator<byte> iterator   tagcache iterator
rc   iterator next
iterator remove
else
try
rc   long tohexstring nexttagid    getbytes
catch  unsupportedencodingexception e
throw new runtimeexception e
return rc
void checkintag byte data
if  tagcache size   < 1024
tagcache add data
@override
public void onclose   throws exception
if   closed
closed   true
sendtoactivemq new removeinfo consumerid   null
linkedlist<messagedispatch> outbound   new linkedlist<messagedispatch>
// called when the connection receives a jms message from activemq
public void onmessagedispatch messagedispatch md  throws exception
if   closed
outbound addlast md
pumpoutbound
pumpprotontosocket
buffer currentbuffer
delivery currentdelivery
public void pumpoutbound   throws exception
while  closed
while  currentbuffer   null
int sent   sender send currentbuffer data  currentbuffer offset  currentbuffer length
if  sent > 0
currentbuffer movehead sent
if  currentbuffer length    0
if  presettle
settle currentdelivery  messageack individual_ack_type
else
sender advance
currentbuffer   null
currentdelivery   null
else
return
if  outbound isempty
return
final messagedispatch md   outbound removefirst
try
final activemqmessage jms    activemqmessage  md getmessage
if  jms  null
// it's the end of browse signal.
sender drained
else
jms setredeliverycounter md getredeliverycounter
final encodedmessage amqp   outboundtransformer transform jms
if  amqp  null    amqp getlength   > 0
currentbuffer   new buffer amqp getarray    amqp getarrayoffset    amqp getlength
if  presettle
currentdelivery   sender delivery empty_byte_array  0  0
else
final byte tag   nexttag
currentdelivery   sender delivery tag  0  tag length
currentdelivery setcontext md
else
// todo: message could not be generated what now?
catch  exception e
e printstacktrace
private void settle final delivery delivery  int acktype  throws exception
byte tag   delivery gettag
if  tag   null    tag length>0
checkintag tag
if  acktype     1
// we are going to settle, but redeliver.. we we won't yet ack to activemq
delivery settle
onmessagedispatch  messagedispatch  delivery getcontext
else
messagedispatch md    messagedispatch  delivery getcontext
messageack ack   new messageack
ack setconsumerid consumerid
ack setfirstmessageid md getmessage   getmessageid
ack setlastmessageid md getmessage   getmessageid
ack setmessagecount 1
ack setacktype  byte acktype
ack setdestination md getdestination
deliverystate remotestate   delivery getremotestate
if  remotestate  null    remotestate instanceof transactionalstate
transactionalstate s    transactionalstate  remotestate
long txid   tolong s gettxnid
ack settransactionid new localtransactionid connectionid  txid
sendtoactivemq ack  new responsehandler
@override
public void onresponse amqpprotocolconverter converter  response response  throws ioexception
if  response isexception
if  response isexception
throwable exception     exceptionresponse  response  getexception
exception printstacktrace
sender close
else
delivery settle
pumpprotontosocket
@override
public void draincheck
if  outbound isempty
sender drained
@override
public void ondelivery delivery delivery  throws exception
messagedispatch md    messagedispatch  delivery getcontext
final deliverystate state   delivery getremotestate
if  state instanceof accepted
if   delivery remotelysettled
delivery disposition new accepted
settle delivery  messageack individual_ack_type
else if  state instanceof rejected
// re-deliver /w incremented delivery counter.
md setredeliverycounter md getredeliverycounter     1
settle delivery   1
else if  state instanceof released
// re-deliver && don't increment the counter.
settle delivery   1
else if  state instanceof modified
modified modified    modified  state
if   modified getdeliveryfailed
// increment delivery counter..
md setredeliverycounter md getredeliverycounter     1
byte acktype    1
boolean undeliverablehere   modified getundeliverablehere
if  undeliverablehere   null    undeliverablehere
// receiver does not want the message..
// perhaps we should dlq it?
acktype   messageack posion_ack_type
settle delivery  acktype
pumpoutbound
private final concurrenthashmap<consumerid  consumercontext> subscriptionsbyconsumerid   new concurrenthashmap<consumerid  consumercontext>
void onsenderopen final sender sender  amqpsessioncontext sessioncontext
org apache qpid proton amqp messaging source source    org apache qpid proton amqp messaging source sender getremotesource
try
final consumerid id   new consumerid sessioncontext sessionid  sessioncontext nextconsumerid
consumercontext consumercontext   new consumercontext id  sender
sender setcontext consumercontext
string selector   null
if  source  null
map filter   source getfilter
if  filter    null
describedtype value    describedtype filter get jms_selector
if  value  null
selector   value getdescribed   tostring
// validate the selector.
try
selectorparser parse selector
catch  invalidselectorexception e
sender setsource null
linkimpl sender  setlocalerror new endpointerror    e getmessage
sender close
consumercontext closed   true
return
activemqdestination dest
if  source    null
source   new org apache qpid proton amqp messaging source
source setaddress
source setcapabilities durable_subscription_ended
sender setsource source
// looks like durable sub removal.
removesubscriptioninfo rsi   new removesubscriptioninfo
rsi setconnectionid connectionid
rsi setsubscriptionname sender getname
rsi setclientid connectioninfo getclientid
consumercontext closed true
sendtoactivemq rsi  new responsehandler
public void onresponse amqpprotocolconverter converter  response response  throws ioexception
if  response isexception
sender setsource null
throwable exception     exceptionresponse  response  getexception
string name   exception getclass   getname
linkimpl sender  setlocalerror new endpointerror name  exception getmessage
sender open
pumpprotontosocket
return
else if  contains source getcapabilities    durable_subscription_ended
consumercontext closed true
sender close
pumpprotontosocket
return
else if  source getdynamic
// lets create a temp dest.
dest   createtempqueue
source   new org apache qpid proton amqp messaging source
source setaddress dest getqualifiedname
source setdynamic true
sender setsource source
else
dest   createdestination source
subscriptionsbyconsumerid put id  consumercontext
consumerinfo consumerinfo   new consumerinfo id
consumerinfo setselector selector
consumerinfo setnorangeacks true
consumerinfo setdestination dest
consumerinfo setprefetchsize 100
consumerinfo setdispatchasync true
if  source getdistributionmode      copy    dest isqueue
consumerinfo setbrowser true
if  durable equals source getdurable       dest istopic
consumerinfo setsubscriptionname sender getname
map filter   source getfilter
if  filter    null
describedtype value    describedtype filter get no_local
if  value  null
consumerinfo setnolocal true
sendtoactivemq consumerinfo  new responsehandler
public void onresponse amqpprotocolconverter converter  response response  throws ioexception
if  response isexception
sender setsource null
throwable exception     exceptionresponse  response  getexception
string name   exception getclass   getname
if  exception instanceof invalidselectorexception
name
linkimpl sender  setlocalerror new endpointerror name  exception getmessage
subscriptionsbyconsumerid remove id
sender close
else
sender open
pumpprotontosocket
catch  amqpprotocolexception e
sender setsource null
linkimpl sender  setlocalerror new endpointerror e getsymbolicname    e getmessage
sender close
static private boolean contains symbol haystack  symbol needle
if  haystack  null
for  symbol capability   haystack
if  capability    needle
return true
return false
private activemqdestination createtempqueue
activemqdestination rc
rc   new activemqtempqueue connectionid  nexttempdestinationid
destinationinfo info   new destinationinfo
info setconnectionid connectionid
info setoperationtype destinationinfo add_operation_type
info setdestination rc
sendtoactivemq info  null
return rc
////////////////////////////////////////////////////////////////////////////
//
// implementation methods
//
////////////////////////////////////////////////////////////////////////////
private final object commnadidmutex   new object
private int lastcommandid
int generatecommandid
synchronized  commnadidmutex
return lastcommandid
private final concurrenthashmap<integer  responsehandler> resposehandlers   new concurrenthashmap<integer  responsehandler>
void sendtoactivemq command command  responsehandler handler
command setcommandid generatecommandid
if  handler    null
command setresponserequired true
resposehandlers put integer valueof command getcommandid     handler
amqptransport sendtoactivemq command
void handleexception throwable exception
exception printstacktrace
if  log isdebugenabled
log debug    exception
try
amqptransport stop
catch  throwable e
log error    e
errorcondition createerrorcondition string name
return createerrorcondition name
errorcondition createerrorcondition string name  string description
errorcondition condition   new errorcondition
condition setcondition symbol valueof name
condition setdescription description
return condition