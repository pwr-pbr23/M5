/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport nio
import java io datainputstream
import java io dataoutputstream
import java io eofexception
import java io ioexception
import java net socket
import java net uri
import java net unknownhostexception
import java nio bytebuffer
import java security cert x509certificate
import javax net socketfactory
import javax net ssl sslcontext
import javax net ssl sslengine
import javax net ssl sslengineresult
import javax net ssl sslpeerunverifiedexception
import javax net ssl sslsession
import org apache activemq command command
import org apache activemq command connectioninfo
import org apache activemq openwire openwireformat
import org apache activemq thread taskrunnerfactory
import org apache activemq util ioexceptionsupport
import org apache activemq util servicestopper
import org apache activemq wireformat wireformat
import org slf4j logger
import org slf4j loggerfactory
public class niossltransport extends niotransport
private static final logger log   loggerfactory getlogger niossltransport class
protected boolean needclientauth
protected boolean wantclientauth
protected string enabledciphersuites
protected sslcontext sslcontext
protected sslengine sslengine
protected sslsession sslsession
protected volatile boolean handshakeinprogress   false
protected sslengineresult status status   null
protected sslengineresult handshakestatus handshakestatus   null
protected taskrunnerfactory taskrunnerfactory
public niossltransport wireformat wireformat  socketfactory socketfactory  uri remotelocation  uri locallocation  throws unknownhostexception  ioexception
super wireformat  socketfactory  remotelocation  locallocation
public niossltransport wireformat wireformat  socket socket  throws ioexception
super wireformat  socket
public void setsslcontext sslcontext sslcontext
this sslcontext   sslcontext
@override
protected void initializestreams   throws ioexception
try
channel   socket getchannel
channel configureblocking false
if  sslcontext    null
sslcontext   sslcontext getdefault
string remotehost   null
int remoteport    1
try
uri remoteaddress   new uri this getremoteaddress
remotehost   remoteaddress gethost
remoteport   remoteaddress getport
catch  exception e
// initialize engine, the initial sslsession we get will need to be
// updated once the ssl handshake process is completed.
if  remotehost    null    remoteport     1
sslengine   sslcontext createsslengine remotehost  remoteport
else
sslengine   sslcontext createsslengine
sslengine setuseclientmode false
if  enabledciphersuites    null
sslengine setenabledciphersuites enabledciphersuites
if  wantclientauth
sslengine setwantclientauth wantclientauth
if  needclientauth
sslengine setneedclientauth needclientauth
sslsession   sslengine getsession
inputbuffer   bytebuffer allocate sslsession getpacketbuffersize
inputbuffer clear
niooutputstream outputstream   new niooutputstream channel
outputstream setengine sslengine
this dataout   new dataoutputstream outputstream
this buffout   outputstream
sslengine beginhandshake
handshakestatus   sslengine gethandshakestatus
dohandshake
catch  exception e
throw new ioexception e
protected void finishhandshake   throws exception
if  handshakeinprogress
handshakeinprogress   false
nextframesize    1
// once handshake completes we need to ask for the now real sslsession
// otherwise the session would return 'ssl_null_with_null_null' for the
// cipher suite.
sslsession   sslengine getsession
// listen for events telling us when the socket is readable.
selection   selectormanager getinstance   register channel  new selectormanager listener
public void onselect selectorselection selection
serviceread
public void onerror selectorselection selection  throwable error
if  error instanceof ioexception
onexception  ioexception  error
else
onexception ioexceptionsupport create error
protected void serviceread
try
if  handshakeinprogress
dohandshake
bytebuffer plain   bytebuffer allocate sslsession getapplicationbuffersize
plain position plain limit
while  true
if   plain hasremaining
int readcount   secureread plain
if  readcount    0
break
// channel is closed, cleanup
if  readcount     1
onexception new eofexception
selection close
break
receivecounter    readcount
if  status    sslengineresult status ok    handshakestatus    sslengineresult handshakestatus need_unwrap
processcommand plain
catch  ioexception e
onexception e
catch  throwable e
onexception ioexceptionsupport create e
protected void processcommand bytebuffer plain  throws exception
// are we waiting for the next command or are we building on the current one
if  nextframesize     1
// we can get small packets that don't give us enough for the frame size
// so allocate enough for the initial size value and
if  plain remaining   < integer size
if  currentbuffer    null
currentbuffer   bytebuffer allocate 4
// go until we fill the integer sized current buffer.
while  currentbuffer hasremaining      plain hasremaining
currentbuffer put plain get
// didn't we get enough yet to figure out next frame size.
if  currentbuffer hasremaining
return
else
currentbuffer flip
nextframesize   currentbuffer getint
else
// either we are completing a previous read of the next frame size or its
// fully contained in plain already.
if  currentbuffer    null
// finish the frame size integer read and get from the current buffer.
while  currentbuffer hasremaining
currentbuffer put plain get
currentbuffer flip
nextframesize   currentbuffer getint
else
nextframesize   plain getint
if  wireformat instanceof openwireformat
long maxframesize     openwireformat  wireformat  getmaxframesize
if  nextframesize > maxframesize
throw new ioexception      nextframesize    1024   1024
maxframesize    1024   1024
// now we got the data, lets reallocate and store the size for the marshaler.
// if there's more data in plain, then the next call will start processing it.
currentbuffer   bytebuffer allocate nextframesize   4
currentbuffer putint nextframesize
else
// if its all in one read then we can just take it all, otherwise take only
// the current frame size and the next iteration starts a new command.
if  currentbuffer remaining   >  plain remaining
currentbuffer put plain
else
byte fill   new byte
plain get fill
currentbuffer put fill
// either we have enough data for a new command or we have to wait for some more.
if  currentbuffer hasremaining
return
else
currentbuffer flip
object command   wireformat unmarshal new datainputstream new nioinputstream currentbuffer
doconsume  command  command
nextframesize    1
currentbuffer   null
protected int secureread bytebuffer plain  throws exception
if    inputbuffer position      0    inputbuffer hasremaining       status    sslengineresult status buffer_underflow
int bytesread   channel read inputbuffer
if  bytesread    0
return 0
if  bytesread     1
sslengine closeinbound
if  inputbuffer position      0    status    sslengineresult status buffer_underflow
return  1
plain clear
inputbuffer flip
sslengineresult res
do
res   sslengine unwrap inputbuffer  plain
while  res getstatus      sslengineresult status ok    res gethandshakestatus      sslengineresult handshakestatus need_unwrap
res bytesproduced      0
if  res gethandshakestatus      sslengineresult handshakestatus finished
finishhandshake
status   res getstatus
handshakestatus   res gethandshakestatus
// todo deal with buffer_overflow
if  status    sslengineresult status closed
sslengine closeinbound
return  1
inputbuffer compact
plain flip
return plain remaining
protected void dohandshake   throws exception
handshakeinprogress   true
while  true
switch  sslengine gethandshakestatus
case need_unwrap
secureread bytebuffer allocate sslsession getapplicationbuffersize
break
case need_task
runnable task
while   task   sslengine getdelegatedtask       null
taskrunnerfactory execute task
break
case need_wrap
niooutputstream  buffout  write bytebuffer allocate 0
break
case finished
case not_handshaking
finishhandshake
return
@override
protected void dostart   throws exception
taskrunnerfactory   new taskrunnerfactory
// no need to init as we can delay that until demand (eg in dohandshake)
super dostart
@override
protected void dostop servicestopper stopper  throws exception
if  taskrunnerfactory    null
taskrunnerfactory shutdownnow
taskrunnerfactory   null
if  channel    null
channel close
channel   null
super dostop stopper
/**
* overriding in order to add the client's certificates to connectioninfo commands.
*
* @param command
*            the command coming in.
*/
@override
public void doconsume object command
if  command instanceof connectioninfo
connectioninfo connectioninfo    connectioninfo  command
connectioninfo settransportcontext getpeercertificates
super doconsume command
/**
* @return peer certificate chain associated with the ssl socket
*/
public x509certificate getpeercertificates
x509certificate clientcertchain   null
try
if  sslengine getsession      null
clientcertchain    x509certificate  sslengine getsession   getpeercertificates
catch  sslpeerunverifiedexception e
if  log istraceenabled
log trace    e
return clientcertchain
public boolean isneedclientauth
return needclientauth
public void setneedclientauth boolean needclientauth
this needclientauth   needclientauth
public boolean iswantclientauth
return wantclientauth
public void setwantclientauth boolean wantclientauth
this wantclientauth   wantclientauth
public string getenabledciphersuites
return enabledciphersuites
public void setenabledciphersuites string enabledciphersuites
this enabledciphersuites   enabledciphersuites