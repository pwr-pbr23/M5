/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq network
import java io ioexception
import java security generalsecurityexception
import java security cert x509certificate
import java util arrays
import java util collection
import java util list
import java util properties
import java util concurrent concurrenthashmap
import java util concurrent countdownlatch
import java util concurrent executionexception
import java util concurrent executorservice
import java util concurrent executors
import java util concurrent future
import java util concurrent timeunit
import java util concurrent timeoutexception
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomiclong
import javax management objectname
import org apache activemq destinationdoesnotexistexception
import org apache activemq service
import org apache activemq advisory advisorybroker
import org apache activemq advisory advisorysupport
import org apache activemq broker brokerservice
import org apache activemq broker brokerserviceaware
import org apache activemq broker connectioncontext
import org apache activemq broker transportconnection
import org apache activemq broker region abstractregion
import org apache activemq broker region durabletopicsubscription
import org apache activemq broker region region
import org apache activemq broker region regionbroker
import org apache activemq broker region subscription
import org apache activemq broker region policy policyentry
import org apache activemq command activemqdestination
import org apache activemq command activemqmessage
import org apache activemq command activemqtempdestination
import org apache activemq command activemqtopic
import org apache activemq command brokerid
import org apache activemq command brokerinfo
import org apache activemq command command
import org apache activemq command connectionerror
import org apache activemq command connectionid
import org apache activemq command connectioninfo
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command datastructure
import org apache activemq command destinationinfo
import org apache activemq command exceptionresponse
import org apache activemq command keepaliveinfo
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messagedispatch
import org apache activemq command networkbridgefilter
import org apache activemq command producerinfo
import org apache activemq command removeinfo
import org apache activemq command response
import org apache activemq command sessioninfo
import org apache activemq command shutdowninfo
import org apache activemq command wireformatinfo
import org apache activemq filter destinationfilter
import org apache activemq filter messageevaluationcontext
import org apache activemq security securitycontext
import org apache activemq transport defaulttransportlistener
import org apache activemq transport futureresponse
import org apache activemq transport responsecallback
import org apache activemq transport transport
import org apache activemq transport transportdisposedioexception
import org apache activemq transport transportfilter
import org apache activemq transport tcp ssltransport
import org apache activemq util idgenerator
import org apache activemq util introspectionsupport
import org apache activemq util longsequencegenerator
import org apache activemq util marshallingsupport
import org apache activemq util servicestopper
import org apache activemq util servicesupport
import org slf4j logger
import org slf4j loggerfactory
/**
* a useful base class for implementing demand forwarding bridges.
*/
public abstract class demandforwardingbridgesupport implements networkbridge  brokerserviceaware
private static final logger log   loggerfactory getlogger demandforwardingbridgesupport class
protected static final string durable_sub_prefix
protected final transport localbroker
protected final transport remotebroker
protected final idgenerator idgenerator   new idgenerator
protected final longsequencegenerator consumeridgenerator   new longsequencegenerator
protected connectioninfo localconnectioninfo
protected connectioninfo remoteconnectioninfo
protected sessioninfo localsessioninfo
protected producerinfo producerinfo
protected string remotebrokername
protected string localclientid
protected consumerinfo demandconsumerinfo
protected int demandconsumerdispatched
protected final atomicboolean localbridgestarted   new atomicboolean false
protected final atomicboolean remotebridgestarted   new atomicboolean false
protected final atomicboolean bridgefailed   new atomicboolean
protected final atomicboolean disposed   new atomicboolean
protected brokerid localbrokerid
protected activemqdestination excludeddestinations
protected activemqdestination dynamicallyincludeddestinations
protected activemqdestination staticallyincludeddestinations
protected activemqdestination durabledestinations
protected final concurrenthashmap<consumerid  demandsubscription> subscriptionmapbylocalid   new concurrenthashmap<consumerid  demandsubscription>
protected final concurrenthashmap<consumerid  demandsubscription> subscriptionmapbyremoteid   new concurrenthashmap<consumerid  demandsubscription>
protected final brokerid localbrokerpath   new brokerid   null
protected final countdownlatch startedlatch   new countdownlatch 2
protected final countdownlatch localstartedlatch   new countdownlatch 1
protected final atomicboolean lastconnectsucceeded   new atomicboolean false
protected networkbridgeconfiguration configuration
protected final networkbridgefilterfactory defaultfilterfactory   new defaultnetworkbridgefilterfactory
protected final brokerid remotebrokerpath   new brokerid   null
protected brokerid remotebrokerid
final atomiclong enqueuecounter   new atomiclong
final atomiclong dequeuecounter   new atomiclong
private networkbridgelistener networkbridgelistener
private boolean createdbyduplex
private brokerinfo localbrokerinfo
private brokerinfo remotebrokerinfo
private final futurebrokerinfo futureremotebrokerinfo   new futurebrokerinfo remotebrokerinfo  disposed
private final futurebrokerinfo futurelocalbrokerinfo   new futurebrokerinfo localbrokerinfo  disposed
private final atomicboolean started   new atomicboolean
private transportconnection duplexinitiatingconnection
private brokerservice brokerservice   null
private objectname mbeanobjectname
private final executorservice serialexecutor   executors newsinglethreadexecutor
private transport duplexinboundlocalbroker   null
private producerinfo duplexinboundlocalproducerinfo
public demandforwardingbridgesupport networkbridgeconfiguration configuration  transport localbroker  transport remotebroker
this configuration   configuration
this localbroker   localbroker
this remotebroker   remotebroker
public void duplexstart transportconnection connection  brokerinfo localbrokerinfo  brokerinfo remotebrokerinfo  throws exception
this localbrokerinfo   localbrokerinfo
this remotebrokerinfo   remotebrokerinfo
this duplexinitiatingconnection   connection
start
serviceremotecommand remotebrokerinfo
@override
public void start   throws exception
if  started compareandset false  true
if  brokerservice    null
throw new illegalargumentexception     this
if  isduplex
duplexinboundlocalbroker   networkbridgefactory createlocaltransport brokerservice getbroker
duplexinboundlocalbroker settransportlistener new defaulttransportlistener
@override
public void oncommand object o
command command    command  o
servicelocalcommand command
@override
public void onexception ioexception error
servicelocalexception error
duplexinboundlocalbroker start
localbroker settransportlistener new defaulttransportlistener
@override
public void oncommand object o
command command    command  o
servicelocalcommand command
@override
public void onexception ioexception error
if   futurelocalbrokerinfo isdone
futurelocalbrokerinfo cancel true
return
servicelocalexception error
remotebroker settransportlistener new defaulttransportlistener
@override
public void oncommand object o
command command    command  o
serviceremotecommand command
@override
public void onexception ioexception error
if   futureremotebrokerinfo isdone
futureremotebrokerinfo cancel true
return
serviceremoteexception error
remotebroker start
localbroker start
if   disposed get
try
triggerstartasyncnetworkbridgecreation
catch  ioexception e
log warn    e
else
log warn
throw new transportdisposedioexception
@override
public void stop   throws exception
if  started compareandset true  false
if  disposed compareandset false  true
if  log isdebugenabled
log debug     configuration getbrokername         remotebrokername
futureremotebrokerinfo cancel true
futurelocalbrokerinfo cancel true
networkbridgelistener l   this networkbridgelistener
if  l    null
l onstop this
try
// local start complete
if  startedlatch getcount   < 2
if  log istraceenabled
log trace configuration getbrokername         this       remotebrokername
brokerservice getbroker   removebroker null  remotebrokerinfo
brokerservice getbroker   networkbridgestopped remotebrokerinfo
remotebridgestarted set false
final countdownlatch sendshutdown   new countdownlatch 1
brokerservice gettaskrunnerfactory   execute new runnable
@override
public void run
try
serialexecutor shutdown
if   serialexecutor awaittermination 5  timeunit seconds
list<runnable> pendingtasks   serialexecutor shutdownnow
if  log isinfoenabled
log info     pendingtasks
localbroker oneway new shutdowninfo
remotebroker oneway new shutdowninfo
catch  throwable e
if  log isdebugenabled
log debug    e
finally
sendshutdown countdown
if   sendshutdown await 10  timeunit seconds
log info
finally
servicestopper ss   new servicestopper
ss stop remotebroker
ss stop localbroker
ss stop duplexinboundlocalbroker
// release the started latch since another thread could be
// stuck waiting for it to start up.
startedlatch countdown
startedlatch countdown
localstartedlatch countdown
ss throwfirstexception
if  log isinfoenabled
log info configuration getbrokername         remotebrokername
protected void triggerstartasyncnetworkbridgecreation   throws ioexception
brokerservice gettaskrunnerfactory   execute new runnable
@override
public void run
final string originalname   thread currentthread   getname
thread currentthread   setname
remotebroker       localbroker
try
// first we collect the info data from both the local and remote ends
collectbrokerinfos
// once we have all required broker info we can attempt to start
// the local and then remote sides of the bridge.
dostartlocalandremotebridges
finally
thread currentthread   setname originalname
private void collectbrokerinfos
// first wait for the remote to feed us its brokerinfo, then we can check on
// the localbrokerinfo and decide is this is a loop.
try
remotebrokerinfo   futureremotebrokerinfo get
if  remotebrokerinfo    null
firebridgefailed
catch  exception e
serviceremoteexception e
return
try
localbrokerinfo   futurelocalbrokerinfo get
if  localbrokerinfo    null
firebridgefailed
// before we try and build the bridge lets check if we are in a loop
// and if so just stop now before registering anything.
if  localbrokerid equals remotebrokerid
if  log istraceenabled
log trace configuration getbrokername
remotebrokername       remotebrokerid
servicesupport dispose localbroker
servicesupport dispose remotebroker
return
// fill in the remote broker's information now.
remotebrokerid   remotebrokerinfo getbrokerid
remotebrokerpath   remotebrokerid
remotebrokername   remotebrokerinfo getbrokername
catch  throwable e
servicelocalexception e
private void dostartlocalandremotebridges
if  disposed get
return
if  iscreatedbyduplex
// apply remote (propagated) configuration to local duplex bridge before start
properties props   null
try
props   marshallingsupport stringtoproperties remotebrokerinfo getnetworkproperties
introspectionsupport getproperties configuration  props  null
if  configuration getexcludeddestinations      null
excludeddestinations   configuration getexcludeddestinations   toarray
new activemqdestination
if  configuration getstaticallyincludeddestinations      null
staticallyincludeddestinations   configuration getstaticallyincludeddestinations   toarray
new activemqdestination
if  configuration getdynamicallyincludeddestinations      null
dynamicallyincludeddestinations   configuration getdynamicallyincludeddestinations   toarray
new activemqdestination
catch  throwable t
log error     props  t
try
startlocalbridge
catch  throwable e
servicelocalexception e
return
try
startremotebridge
catch  throwable e
serviceremoteexception e
private void startlocalbridge   throws throwable
if  localbridgestarted compareandset false  true
synchronized  this
if  log istraceenabled
log trace configuration getbrokername         localbroker
if   disposed get
localconnectioninfo   new connectioninfo
localconnectioninfo setconnectionid new connectionid idgenerator generateid
localclientid   configuration getname         remotebrokername       configuration getbrokername
localconnectioninfo setclientid localclientid
localconnectioninfo setusername configuration getusername
localconnectioninfo setpassword configuration getpassword
transport originaltransport   remotebroker
while  originaltransport instanceof transportfilter
originaltransport     transportfilter  originaltransport  getnext
if  originaltransport instanceof ssltransport
x509certificate peercerts     ssltransport  originaltransport  getpeercertificates
localconnectioninfo settransportcontext peercerts
// sync requests that may fail
object resp   localbroker request localconnectioninfo
if  resp instanceof exceptionresponse
throw   exceptionresponse  resp  getexception
localsessioninfo   new sessioninfo localconnectioninfo  1
localbroker oneway localsessioninfo
if  configuration isduplex
// separate in-bound channel for forwards so we don't
// contend with out-bound dispatch on same connection
connectioninfo duplexlocalconnectioninfo   new connectioninfo
duplexlocalconnectioninfo setconnectionid new connectionid idgenerator generateid
duplexlocalconnectioninfo setclientid configuration getname         remotebrokername
configuration getbrokername
duplexlocalconnectioninfo setusername configuration getusername
duplexlocalconnectioninfo setpassword configuration getpassword
if  originaltransport instanceof ssltransport
x509certificate peercerts     ssltransport  originaltransport  getpeercertificates
duplexlocalconnectioninfo settransportcontext peercerts
// sync requests that may fail
resp   duplexinboundlocalbroker request duplexlocalconnectioninfo
if  resp instanceof exceptionresponse
throw   exceptionresponse  resp  getexception
sessioninfo duplexinboundsession   new sessioninfo duplexlocalconnectioninfo  1
duplexinboundlocalproducerinfo   new producerinfo duplexinboundsession  1
duplexinboundlocalbroker oneway duplexinboundsession
duplexinboundlocalbroker oneway duplexinboundlocalproducerinfo
brokerservice getbroker   networkbridgestarted remotebrokerinfo  this createdbyduplex  remotebroker tostring
networkbridgelistener l   this networkbridgelistener
if  l    null
l onstart this
// let the local broker know the remote broker's id.
localbroker oneway remotebrokerinfo
// new peer broker (a consumer can work with remote broker also)
brokerservice getbroker   addbroker null  remotebrokerinfo
if  log isinfoenabled
log info     localbroker       remotebroker       remotebrokername
if  log istraceenabled
log trace configuration getbrokername         this       remotebrokername
else
log warn
startedlatch countdown
localstartedlatch countdown
if   disposed get
setupstaticdestinations
else
log warn     localbroker       remotebroker       remotebrokername
protected void startremotebridge   throws exception
if  remotebridgestarted compareandset false  true
if  log istraceenabled
log trace configuration getbrokername         remotebroker
synchronized  this
if   iscreatedbyduplex
brokerinfo brokerinfo   new brokerinfo
brokerinfo setbrokername configuration getbrokername
brokerinfo setbrokerurl configuration getbrokerurl
brokerinfo setnetworkconnection true
brokerinfo setduplexconnection configuration isduplex
// set our properties
properties props   new properties
introspectionsupport getproperties configuration  props  null
string str   marshallingsupport propertiestostring props
brokerinfo setnetworkproperties str
brokerinfo setbrokerid this localbrokerid
remotebroker oneway brokerinfo
if  remoteconnectioninfo    null
remotebroker oneway remoteconnectioninfo createremovecommand
remoteconnectioninfo   new connectioninfo
remoteconnectioninfo setconnectionid new connectionid idgenerator generateid
remoteconnectioninfo setclientid configuration getname         configuration getbrokername
remoteconnectioninfo setusername configuration getusername
remoteconnectioninfo setpassword configuration getpassword
remotebroker oneway remoteconnectioninfo
sessioninfo remotesessioninfo   new sessioninfo remoteconnectioninfo  1
remotebroker oneway remotesessioninfo
producerinfo   new producerinfo remotesessioninfo  1
producerinfo setresponserequired false
remotebroker oneway producerinfo
// listen to consumer advisory messages on the remote broker to determine demand.
if   configuration isstaticbridge
demandconsumerinfo   new consumerinfo remotesessioninfo  1
// always dispatch advisory message asynchronously so that
// we never block the producer broker if we are slow
demandconsumerinfo setdispatchasync true
string advisorytopic   configuration getdestinationfilter
if  configuration isbridgetempdestinations
advisorytopic        advisorysupport temp_destination_composite_advisory_topic
demandconsumerinfo setdestination new activemqtopic advisorytopic
demandconsumerinfo setprefetchsize configuration getprefetchsize
remotebroker oneway demandconsumerinfo
startedlatch countdown
@override
public void serviceremoteexception throwable error
if   disposed get
if  error instanceof securityexception    error instanceof generalsecurityexception
log error     localbroker       remotebroker       error
else
log warn     localbroker       remotebroker       error
log debug     error  error
brokerservice gettaskrunnerfactory   execute new runnable
@override
public void run
servicesupport dispose getcontrollingservice
firebridgefailed
protected void serviceremotecommand command command
if   disposed get
try
if  command ismessagedispatch
safewaituntilstarted
messagedispatch md    messagedispatch  command
serviceremoteconsumeradvisory md getmessage   getdatastructure
ackadvisory md getmessage
else if  command isbrokerinfo
futureremotebrokerinfo set  brokerinfo  command
else if  command getclass      connectionerror class
connectionerror ce    connectionerror  command
serviceremoteexception ce getexception
else
if  isduplex
if  log istraceenabled
log trace configuration getbrokername         command getdatastructuretype
if  command ismessage
final activemqmessage message    activemqmessage  command
if  advisorysupport isconsumeradvisorytopic message getdestination
advisorysupport isdestinationadvisorytopic message getdestination
serviceremoteconsumeradvisory message getdatastructure
ackadvisory message
else
if   ispermissabledestination message getdestination    true
return
// message being forwarded - we need to
// propagate the response to our local send
message setproducerid duplexinboundlocalproducerinfo getproducerid
if  message isresponserequired      configuration isalwayssyncsend
duplexinboundlocalbroker asyncrequest message  new responsecallback
final int correlationid   message getcommandid
@override
public void oncompletion futureresponse resp
try
response reply   resp getresult
reply setcorrelationid correlationid
remotebroker oneway reply
catch  ioexception error
log error     error       message
serviceremoteexception error
else
duplexinboundlocalbroker oneway message
else
switch  command getdatastructuretype
case connectioninfo data_structure_type
case sessioninfo data_structure_type
localbroker oneway command
break
case producerinfo data_structure_type
// using duplexinboundlocalproducerinfo
break
case messageack data_structure_type
messageack ack    messageack  command
demandsubscription localsub   subscriptionmapbyremoteid get ack getconsumerid
if  localsub    null
ack setconsumerid localsub getlocalinfo   getconsumerid
localbroker oneway ack
else
log warn     ack
break
case consumerinfo data_structure_type
localstartedlatch await
if  started get
if   addconsumerinfo  consumerinfo  command
if  log isdebugenabled
log debug     command
else
if  log istraceenabled
log trace     command
else
// received a subscription whilst stopping
log warn     command
break
case shutdowninfo data_structure_type
// initiator is shutting down, controlled case
// abortive close dealt with by inactivity monitor
log info
serviceremoteexception new ioexception command tostring
break
default
if  log isdebugenabled
log debug     command
else
switch  command getdatastructuretype
case keepaliveinfo data_structure_type
case wireformatinfo data_structure_type
case shutdowninfo data_structure_type
break
default
log warn     command
catch  throwable e
if  log isdebugenabled
log debug     command  e
serviceremoteexception e
private void ackadvisory message message  throws ioexception
demandconsumerdispatched
if  demandconsumerdispatched >  demandconsumerinfo getprefetchsize      75
messageack ack   new messageack message  messageack standard_ack_type  demandconsumerdispatched
ack setconsumerid demandconsumerinfo getconsumerid
remotebroker oneway ack
demandconsumerdispatched   0
private void serviceremoteconsumeradvisory datastructure data  throws ioexception
final int networkttl   configuration getnetworkttl
if  data getclass      consumerinfo class
// create a new local subscription
consumerinfo info    consumerinfo  data
brokerid path   info getbrokerpath
if  info isbrowser
if  log isdebugenabled
log info configuration getbrokername         remotebrokername
return
if  path    null    path length >  networkttl
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername       networkttl
info
return
if  contains path  localbrokerpath
// ignore this consumer as it's a consumer we locally sent to the broker.
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername       info
return
if   ispermissabledestination info getdestination
// ignore if not in the permitted or in the excluded list
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername       info getdestination
info
return
// in a cyclic network there can be multiple bridges per broker that can propagate
// a network subscription so there is a need to synchronize on a shared entity
synchronized  brokerservice getvmconnectoruri
if  addconsumerinfo info
if  log isdebugenabled
log debug configuration getbrokername         localbroker       remotebrokername       info
else
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername
info
else if  data getclass      destinationinfo class
// it's a destination info - we want to pass up information about temporary destinations
final destinationinfo destinfo    destinationinfo  data
brokerid path   destinfo getbrokerpath
if  path    null    path length >  networkttl
if  log isdebugenabled
log debug configuration getbrokername         destinfo       networkttl
return
if  contains destinfo getbrokerpath    localbrokerpath
// ignore this consumer as it's a consumer we locally sent to the broker.
if  log isdebugenabled
log debug configuration getbrokername         destinfo
return
destinfo setconnectionid localconnectioninfo getconnectionid
if  destinfo getdestination   instanceof activemqtempdestination
// re-set connection id so comes from here
activemqtempdestination tempdest    activemqtempdestination  destinfo getdestination
tempdest setconnectionid localsessioninfo getsessionid   getconnectionid
destinfo setbrokerpath appendtobrokerpath destinfo getbrokerpath    getremotebrokerpath
if  log istraceenabled
log trace configuration getbrokername          destinfo isaddoperation   ?              localbroker
remotebrokername       destinfo
if  destinfo isremoveoperation
// serialize with removesub operations such that all removesub advisories
// are generated
serialexecutor execute new runnable
@override
public void run
try
localbroker oneway destinfo
catch  ioexception e
log warn     destinfo getdestination    e
else
localbroker oneway destinfo
else if  data getclass      removeinfo class
consumerid id    consumerid    removeinfo  data  getobjectid
removedemandsubscription id
@override
public void servicelocalexception throwable error
servicelocalexception null  error
public void servicelocalexception messagedispatch messagedispatch  throwable error
if   disposed get
if  error instanceof destinationdoesnotexistexception      destinationdoesnotexistexception  error  istemporary
// not a reason to terminate the bridge - temps can disappear with
// pending sends as the demand sub may outlive the remote dest
if  messagedispatch    null
log warn     messagedispatch getmessage   getmessageid         error
try
messageack poisonack   new messageack messagedispatch  messageack posion_ack_type  1
poisonack setpoisoncause error
localbroker oneway poisonack
catch  ioexception ioe
log error     ioe  ioe
firefailedforwardadvisory messagedispatch  error
else
log warn     error  error
return
if  log isinfoenabled
log info     localbroker       remotebroker       error
if  log isdebugenabled
log debug     error  error
brokerservice gettaskrunnerfactory   execute new runnable
@override
public void run
servicesupport dispose getcontrollingservice
firebridgefailed
private void firefailedforwardadvisory messagedispatch messagedispatch  throwable error
if  configuration isadvisoryforfailedforward
advisorybroker advisorybroker   null
try
advisorybroker    advisorybroker  brokerservice getbroker   getadaptor advisorybroker class
if  advisorybroker    null
connectioncontext context   new connectioncontext
context setsecuritycontext securitycontext broker_security_context
context setbroker brokerservice getbroker
activemqmessage advisorymessage   new activemqmessage
advisorymessage setstringproperty    error getlocalizedmessage
advisorybroker fireadvisory context  advisorysupport getnetworkbridgeforwardfailureadvisorytopic    messagedispatch getmessage    null
advisorymessage
catch  exception e
log warn     e
if  log isdebugenabled
log debug    e
protected service getcontrollingservice
return duplexinitiatingconnection    null ? duplexinitiatingconnection   demandforwardingbridgesupport this
protected void addsubscription demandsubscription sub  throws ioexception
if  sub    null
localbroker oneway sub getlocalinfo
protected void removesubscription final demandsubscription sub  throws ioexception
if  sub    null
if  log istraceenabled
log trace configuration getbrokername         sub getlocalinfo   getconsumerid
sub getremoteinfo   getconsumerid
// ensure not available for conduit subs pending removal
subscriptionmapbylocalid remove sub getlocalinfo   getconsumerid
subscriptionmapbyremoteid remove sub getremoteinfo   getconsumerid
// continue removal in separate thread to free up this thread for outstanding responses
// serialize with removedestination operations so that removesubs are serialized with
// removedestinations such that all removesub advisories are generated
serialexecutor execute new runnable
@override
public void run
sub waitforcompletion
try
localbroker oneway sub getlocalinfo   createremovecommand
catch  ioexception e
log warn     sub getremoteinfo   getconsumerid    e
protected message configuremessage messagedispatch md  throws ioexception
message message   md getmessage   copy
// update the packet to show where it came from.
message setbrokerpath appendtobrokerpath message getbrokerpath    localbrokerpath
message setproducerid producerinfo getproducerid
message setdestination md getdestination
message setmemoryusage null
if  message getoriginaltransactionid      null
message setoriginaltransactionid message gettransactionid
message settransactionid null
if  configuration isusecompression
message compress
return message
protected void servicelocalcommand command command
if   disposed get
try
if  command ismessagedispatch
safewaituntilstarted
enqueuecounter incrementandget
final messagedispatch md    messagedispatch  command
final demandsubscription sub   subscriptionmapbylocalid get md getconsumerid
if  sub    null    md getmessage      null    sub incrementoutstandingresponses
if  suppressmessagedispatch md  sub
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername
arrays tostring md getmessage   getbrokerpath
md getmessage
// still ack as it may be durable
try
localbroker oneway new messageack md  messageack individual_ack_type  1
finally
sub decrementoutstandingresponses
return
message message   configuremessage md
if  log isdebugenabled
log debug     configuration getbrokername         remotebrokername
log istraceenabled   ? message   message getmessageid          md getconsumerid
message getdestination         arrays tostring message getbrokerpath          message
if  isduplex      advisorysupport adivsory_message_type equals message gettype
try
// never request b/c they are eventually acked async
remotebroker oneway message
finally
sub decrementoutstandingresponses
return
if  message ispersistent      configuration isalwayssyncsend
// the message was not sent using async send, so we should only
// ack the local broker when we get confirmation that the remote
// broker has received the message.
remotebroker asyncrequest message  new responsecallback
@override
public void oncompletion futureresponse future
try
response response   future getresult
if  response isexception
exceptionresponse er    exceptionresponse  response
servicelocalexception md  er getexception
else
localbroker oneway new messageack md  messageack individual_ack_type  1
dequeuecounter incrementandget
catch  ioexception e
servicelocalexception md  e
finally
sub decrementoutstandingresponses
else
// if the message was originally sent using async send, we will
// preserve that qos by bridging it using an async send (small chance
// of message loss).
try
remotebroker oneway message
localbroker oneway new messageack md  messageack individual_ack_type  1
dequeuecounter incrementandget
finally
sub decrementoutstandingresponses
else
if  log isdebugenabled
log debug     md getconsumerid
md getmessage
else if  command isbrokerinfo
futurelocalbrokerinfo set  brokerinfo  command
else if  command isshutdowninfo
log info configuration getbrokername
stop
else if  command getclass      connectionerror class
connectionerror ce    connectionerror  command
servicelocalexception ce getexception
else
switch  command getdatastructuretype
case wireformatinfo data_structure_type
break
default
log warn     command
catch  throwable e
log warn    e
servicelocalexception e
private boolean suppressmessagedispatch messagedispatch md  demandsubscription sub  throws exception
boolean suppress   false
// for durable subs, suppression via filter leaves dangling acks so we
// need to check here and allow the ack irrespective
if  sub getlocalinfo   isdurable
messageevaluationcontext messageevalcontext   new messageevaluationcontext
messageevalcontext setmessagereference md getmessage
messageevalcontext setdestination md getdestination
suppress    sub getnetworkbridgefilter   matches messageevalcontext
return suppress
public static boolean contains brokerid brokerpath  brokerid brokerid
if  brokerpath    null
for  brokerid id   brokerpath
if  brokerid equals id
return true
return false
protected brokerid appendtobrokerpath brokerid brokerpath  brokerid pathstoappend
if  brokerpath    null    brokerpath length    0
return pathstoappend
brokerid rc   new brokerid
system arraycopy brokerpath  0  rc  0  brokerpath length
system arraycopy pathstoappend  0  rc  brokerpath length  pathstoappend length
return rc
protected brokerid appendtobrokerpath brokerid brokerpath  brokerid idtoappend
if  brokerpath    null    brokerpath length    0
return new brokerid   idtoappend
brokerid rc   new brokerid
system arraycopy brokerpath  0  rc  0  brokerpath length
rc   idtoappend
return rc
protected boolean ispermissabledestination activemqdestination destination
return ispermissabledestination destination  false
protected boolean ispermissabledestination activemqdestination destination  boolean allowtemporary
// are we not bridging temporary destinations?
if  destination istemporary
if  allowtemporary
return true
else
return configuration isbridgetempdestinations
activemqdestination dests   staticallyincludeddestinations
if  dests    null    dests length > 0
for  activemqdestination dest   dests
destinationfilter inclusionfilter   destinationfilter parsefilter dest
if  dest    null    inclusionfilter matches destination     dest getdestinationtype      destination getdestinationtype
return true
dests   excludeddestinations
if  dests    null    dests length > 0
for  activemqdestination dest   dests
destinationfilter exclusionfilter   destinationfilter parsefilter dest
if  dest    null    exclusionfilter matches destination     dest getdestinationtype      destination getdestinationtype
return false
dests   dynamicallyincludeddestinations
if  dests    null    dests length > 0
for  activemqdestination dest   dests
destinationfilter inclusionfilter   destinationfilter parsefilter dest
if  dest    null    inclusionfilter matches destination     dest getdestinationtype      destination getdestinationtype
return true
return false
return true
/**
* subscriptions for these destinations are always created
*/
protected void setupstaticdestinations
activemqdestination dests   staticallyincludeddestinations
if  dests    null
for  activemqdestination dest   dests
demandsubscription sub   createdemandsubscription dest
try
addsubscription sub
catch  ioexception e
log error     dest  e
if  log istraceenabled
log trace configuration getbrokername         dest
protected boolean addconsumerinfo final consumerinfo consumerinfo  throws ioexception
boolean consumeradded   false
consumerinfo info   consumerinfo copy
addremotebrokertobrokerpath info
demandsubscription sub   createdemandsubscription info
if  sub    null
if  duplicatesuppressionisrequired sub
undomapregistration sub
else
addsubscription sub
consumeradded   true
return consumeradded
private void undomapregistration demandsubscription sub
subscriptionmapbylocalid remove sub getlocalinfo   getconsumerid
subscriptionmapbyremoteid remove sub getremoteinfo   getconsumerid
/*
* check our existing subs networkconsumerids against the list of network
* ids in this subscription a match means a duplicate which we suppress for
* topics and maybe for queues
*/
private boolean duplicatesuppressionisrequired demandsubscription candidate
final consumerinfo consumerinfo   candidate getremoteinfo
boolean suppress   false
if  consumerinfo getdestination   isqueue       configuration issuppressduplicatequeuesubscriptions      consumerinfo getdestination   istopic
configuration issuppressduplicatetopicsubscriptions
return suppress
list<consumerid> candidateconsumers   consumerinfo getnetworkconsumerids
collection<subscription> currentsubs   getregionsubscriptions consumerinfo getdestination
for  subscription sub   currentsubs
list<consumerid> networkconsumers   sub getconsumerinfo   getnetworkconsumerids
if   networkconsumers isempty
if  matchfound candidateconsumers  networkconsumers
if  isinactivedurablesub sub
suppress   false
else
suppress   haslowerpriority sub  candidate getlocalinfo
break
return suppress
private boolean isinactivedurablesub subscription sub
return  sub getconsumerinfo   isdurable      sub instanceof durabletopicsubscription       durabletopicsubscription  sub  isactive
private boolean haslowerpriority subscription existingsub  consumerinfo candidateinfo
boolean suppress   false
if  existingsub getconsumerinfo   getpriority   >  candidateinfo getpriority
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername       candidateinfo
existingsub
existingsub getconsumerinfo   getnetworkconsumerids
suppress   true
else
// remove the existing lower priority duplicate and allow this candidate
try
removeduplicatesubscription existingsub
if  log isdebugenabled
log debug configuration getbrokername         existingsub getconsumerinfo
remotebrokername       candidateinfo
candidateinfo getnetworkconsumerids
catch  ioexception e
log error     existingsub  e
return suppress
private void removeduplicatesubscription subscription existingsub  throws ioexception
for  networkconnector connector   brokerservice getnetworkconnectors
if  connector removedemandsubscription existingsub getconsumerinfo   getconsumerid
break
private boolean matchfound list<consumerid> candidateconsumers  list<consumerid> networkconsumers
boolean found   false
for  consumerid aliasconsumer   networkconsumers
if  candidateconsumers contains aliasconsumer
found   true
break
return found
private final collection<subscription> getregionsubscriptions activemqdestination dest
regionbroker region_broker    regionbroker  brokerservice getregionbroker
region region
collection<subscription> subs
region   null
switch  dest getdestinationtype
case activemqdestination queue_type
region   region_broker getqueueregion
break
case activemqdestination topic_type
region   region_broker gettopicregion
break
case activemqdestination temp_queue_type
region   region_broker gettempqueueregion
break
case activemqdestination temp_topic_type
region   region_broker gettemptopicregion
break
if  region instanceof abstractregion
subs     abstractregion  region  getsubscriptions   values
else
subs   null
return subs
protected demandsubscription createdemandsubscription consumerinfo info  throws ioexception
// add our original id to ourselves
info addnetworkconsumerid info getconsumerid
return docreatedemandsubscription info
protected demandsubscription docreatedemandsubscription consumerinfo info  throws ioexception
demandsubscription result   new demandsubscription info
result getlocalinfo   setconsumerid new consumerid localsessioninfo getsessionid    consumeridgenerator getnextsequenceid
if  info getdestination   istemporary
// reset the local connection id
activemqtempdestination dest    activemqtempdestination  result getlocalinfo   getdestination
dest setconnectionid localconnectioninfo getconnectionid   tostring
if  configuration isdecreasenetworkconsumerpriority
byte priority    byte  configuration getconsumerprioritybase
if  info getbrokerpath      null    info getbrokerpath   length > 1
// the longer the path to the consumer, the less it's consumer priority.
priority    info getbrokerpath   length   1
result getlocalinfo   setpriority priority
if  log isdebugenabled
log debug configuration getbrokername         priority       info
configuredemandsubscription info  result
return result
final protected demandsubscription createdemandsubscription activemqdestination destination
consumerinfo info   new consumerinfo
info setnetworksubscription true
info setdestination destination
// indicate that this subscription is being made on behalf of the remote broker.
info setbrokerpath new brokerid   remotebrokerid
// the remote info held by the demandsubscription holds the original
// consumerid, the local info get's overwritten
info setconsumerid new consumerid localsessioninfo getsessionid    consumeridgenerator getnextsequenceid
demandsubscription result   null
try
result   createdemandsubscription info
catch  ioexception e
log error    e
return result
protected void configuredemandsubscription consumerinfo info  demandsubscription sub  throws ioexception
if  advisorysupport isconsumeradvisorytopic info getdestination
sub getlocalinfo   setdispatchasync true
else
sub getlocalinfo   setdispatchasync configuration isdispatchasync
sub getlocalinfo   setprefetchsize configuration getprefetchsize
subscriptionmapbylocalid put sub getlocalinfo   getconsumerid    sub
subscriptionmapbyremoteid put sub getremoteinfo   getconsumerid    sub
sub setnetworkbridgefilter createnetworkbridgefilter info
if   info isdurable
// this works for now since we use a vm connection to the local broker.
// may need to change if we ever subscribe to a remote broker.
sub getlocalinfo   setadditionalpredicate sub getnetworkbridgefilter
else
// need to ack this message if it is ignored as it is durable so
// we check before we send. see: suppressmessagedispatch()
protected void removedemandsubscription consumerid id  throws ioexception
demandsubscription sub   subscriptionmapbyremoteid remove id
if  log isdebugenabled
log debug configuration getbrokername         localbroker       remotebrokername       id
sub
if  sub    null
removesubscription sub
if  log isdebugenabled
log debug configuration getbrokername         localbroker       remotebrokername       sub getremoteinfo
protected boolean removedemandsubscriptionbylocalid consumerid consumerid
boolean removedone   false
demandsubscription sub   subscriptionmapbylocalid get consumerid
if  sub    null
try
removedemandsubscription sub getremoteinfo   getconsumerid
removedone   true
catch  ioexception e
log debug     consumerid  e
return removedone
/**
* performs a timed wait on the started latch and then checks for disposed
* before performing another wait each time the the started wait times out.
*
* @throws interruptedexception
*/
protected void safewaituntilstarted   throws interruptedexception
while   disposed get
if  startedlatch await 1  timeunit seconds
return
protected networkbridgefilter createnetworkbridgefilter consumerinfo info  throws ioexception
networkbridgefilterfactory filterfactory   defaultfilterfactory
if  brokerservice    null    brokerservice getdestinationpolicy      null
policyentry entry   brokerservice getdestinationpolicy   getentryfor info getdestination
if  entry    null    entry getnetworkbridgefilterfactory      null
filterfactory   entry getnetworkbridgefilterfactory
return filterfactory create info  getremotebrokerpath    configuration getnetworkttl
protected void addremotebrokertobrokerpath consumerinfo info  throws ioexception
info setbrokerpath appendtobrokerpath info getbrokerpath    getremotebrokerpath
protected brokerid getremotebrokerpath
return remotebrokerpath
@override
public void setnetworkbridgelistener networkbridgelistener listener
this networkbridgelistener   listener
private void firebridgefailed
networkbridgelistener l   this networkbridgelistener
if  l    null    this bridgefailed compareandset false  true
l bridgefailed
/**
* @return returns the dynamicallyincludeddestinations.
*/
public activemqdestination getdynamicallyincludeddestinations
return dynamicallyincludeddestinations
/**
* @param dynamicallyincludeddestinations
*            the dynamicallyincludeddestinations to set.
*/
public void setdynamicallyincludeddestinations activemqdestination dynamicallyincludeddestinations
this dynamicallyincludeddestinations   dynamicallyincludeddestinations
/**
* @return returns the excludeddestinations.
*/
public activemqdestination getexcludeddestinations
return excludeddestinations
/**
* @param excludeddestinations
*            the excludeddestinations to set.
*/
public void setexcludeddestinations activemqdestination excludeddestinations
this excludeddestinations   excludeddestinations
/**
* @return returns the staticallyincludeddestinations.
*/
public activemqdestination getstaticallyincludeddestinations
return staticallyincludeddestinations
/**
* @param staticallyincludeddestinations
*            the staticallyincludeddestinations to set.
*/
public void setstaticallyincludeddestinations activemqdestination staticallyincludeddestinations
this staticallyincludeddestinations   staticallyincludeddestinations
/**
* @return returns the durabledestinations.
*/
public activemqdestination getdurabledestinations
return durabledestinations
/**
* @param durabledestinations
*            the durabledestinations to set.
*/
public void setdurabledestinations activemqdestination durabledestinations
this durabledestinations   durabledestinations
/**
* @return returns the localbroker.
*/
public transport getlocalbroker
return localbroker
/**
* @return returns the remotebroker.
*/
public transport getremotebroker
return remotebroker
/**
* @return the createdbyduplex
*/
public boolean iscreatedbyduplex
return this createdbyduplex
/**
* @param createdbyduplex
*            the createdbyduplex to set
*/
public void setcreatedbyduplex boolean createdbyduplex
this createdbyduplex   createdbyduplex
@override
public string getremoteaddress
return remotebroker getremoteaddress
@override
public string getlocaladdress
return localbroker getremoteaddress
@override
public string getremotebrokername
return remotebrokerinfo    null ? null   remotebrokerinfo getbrokername
@override
public string getlocalbrokername
return localbrokerinfo    null ? null   localbrokerinfo getbrokername
@override
public long getdequeuecounter
return dequeuecounter get
@override
public long getenqueuecounter
return enqueuecounter get
protected boolean isduplex
return configuration isduplex      createdbyduplex
public concurrenthashmap<consumerid  demandsubscription> getlocalsubscriptionmap
return subscriptionmapbyremoteid
@override
public void setbrokerservice brokerservice brokerservice
this brokerservice   brokerservice
this localbrokerid   brokerservice getregionbroker   getbrokerid
localbrokerpath   localbrokerid
@override
public void setmbeanobjectname objectname objectname
this mbeanobjectname   objectname
@override
public objectname getmbeanobjectname
return mbeanobjectname
/*
* used to allow for async tasks to await receipt of the brokerinfo from the local and
* remote sides of the network bridge.
*/
private static class futurebrokerinfo implements future<brokerinfo>
private final countdownlatch slot   new countdownlatch 1
private final atomicboolean disposed
private brokerinfo info   null
public futurebrokerinfo brokerinfo info  atomicboolean disposed
this info   info
this disposed   disposed
@override
public boolean cancel boolean mayinterruptifrunning
slot countdown
return true
@override
public boolean iscancelled
return slot getcount      0    info    null
@override
public boolean isdone
return info    null
@override
public brokerinfo get   throws interruptedexception  executionexception
try
if  info    null
while   disposed get
if  slot await 1  timeunit seconds
break
return info
catch  interruptedexception e
thread currentthread   interrupt
if  log isdebugenabled
log debug     e  e
throw new interruptedexception
@override
public brokerinfo get long timeout  timeunit unit  throws interruptedexception  executionexception  timeoutexception
try
if  info    null
long deadline   system currenttimemillis     unit tomillis timeout
while   disposed get      system currenttimemillis   < deadline
if  slot await 1  timeunit milliseconds
break
if  info    null
throw new timeoutexception
return info
catch  interruptedexception e
throw new interruptedexception
public void set brokerinfo info
this info   info
this slot countdown