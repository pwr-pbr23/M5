/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq
import java io ioexception
import java util arraylist
import java util hashmap
import java util iterator
import java util linkedlist
import java util list
import java util map
import java util map entry
import java util concurrent executorservice
import java util concurrent executors
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomicinteger
import java util concurrent atomic atomicreference
import javax jms illegalstateexception
import javax jms invaliddestinationexception
import javax jms jmsexception
import javax jms message
import javax jms messageconsumer
import javax jms messagelistener
import javax jms transactionrolledbackexception
import org apache activemq blob blobdownloader
import org apache activemq command activemqblobmessage
import org apache activemq command activemqdestination
import org apache activemq command activemqmessage
import org apache activemq command activemqtempdestination
import org apache activemq command commandtypes
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command messageack
import org apache activemq command messagedispatch
import org apache activemq command messageid
import org apache activemq command messagepull
import org apache activemq command removeinfo
import org apache activemq command transactionid
import org apache activemq management jmsconsumerstatsimpl
import org apache activemq management statscapable
import org apache activemq management statsimpl
import org apache activemq selector selectorparser
import org apache activemq transaction synchronization
import org apache activemq util callback
import org apache activemq util introspectionsupport
import org apache activemq util jmsexceptionsupport
import org apache activemq util threadpoolutils
import org slf4j logger
import org slf4j loggerfactory
/**
* a client uses a <code>messageconsumer</code> object to receive messages
* from a destination. a <code> messageconsumer</code> object is created by
* passing a <code>destination</code> object to a message-consumer creation
* method supplied by a session.
* <p>
* <code>messageconsumer</code> is the parent interface for all message
* consumers.
* <p>
* a message consumer can be created with a message selector. a message selector
* allows the client to restrict the messages delivered to the message consumer
* to those that match the selector.
* <p>
* a client may either synchronously receive a message consumer's messages or
* have the consumer asynchronously deliver them as they arrive.
* <p>
* for synchronous receipt, a client can request the next message from a message
* consumer using one of its <code> receive</code> methods. there are several
* variations of <code>receive</code> that allow a client to poll or wait for
* the next message.
* <p>
* for asynchronous delivery, a client can register a
* <code>messagelistener</code> object with a message consumer. as messages
* arrive at the message consumer, it delivers them by calling the
* <code>messagelistener</code>'s<code>
* onmessage</code> method.
* <p>
* it is a client programming error for a <code>messagelistener</code> to
* throw an exception.
*
*
* @see javax.jms.messageconsumer
* @see javax.jms.queuereceiver
* @see javax.jms.topicsubscriber
* @see javax.jms.session
*/
public class activemqmessageconsumer implements messageavailableconsumer  statscapable  activemqdispatcher
@suppresswarnings
class previouslydeliveredmap<k  v> extends hashmap<k  v>
final transactionid transactionid
public previouslydeliveredmap transactionid transactionid
this transactionid   transactionid
private static final logger log   loggerfactory getlogger activemqmessageconsumer class
protected final activemqsession session
protected final consumerinfo info
// these are the messages waiting to be delivered to the client
protected final messagedispatchchannel unconsumedmessages
// the are the messages that were delivered to the consumer but that have
// not been acknowledged. it's kept in reverse order since we
// always walk list in reverse order.
private final linkedlist<messagedispatch> deliveredmessages   new linkedlist<messagedispatch>
// track duplicate deliveries in a transaction such that the tx integrity can be validated
private previouslydeliveredmap<messageid  boolean> previouslydeliveredmessages
private int deliveredcounter
private int additionalwindowsize
private long redeliverydelay
private int ackcounter
private int dispatchedcount
private final atomicreference<messagelistener> messagelistener   new atomicreference<messagelistener>
private final jmsconsumerstatsimpl stats
private final string selector
private boolean synchronizationregistered
private final atomicboolean started   new atomicboolean false
private messageavailablelistener availablelistener
private redeliverypolicy redeliverypolicy
private boolean optimizeacknowledge
private final atomicboolean deliveryingacknowledgements   new atomicboolean
private executorservice executorservice
private messagetransformer transformer
private boolean cleardispatchlist
atomicinteger inprogressclearrequiredflag   new atomicinteger 0
private messageack pendingack
private long lastdeliveredsequenceid
private ioexception failureerror
private long optimizeacktimestamp   system currenttimemillis
private long optimizeacknowledgetimeout   0
private long optimizedackscheduledackinterval   0
private runnable optimizedacktask
private long failoverredeliverywaitperiod   0
private boolean transactedindividualack   false
private boolean nonblockingredelivery   false
/**
* create a messageconsumer
*
* @param session
* @param dest
* @param name
* @param selector
* @param prefetch
* @param maximumpendingmessagecount
* @param nolocal
* @param browser
* @param dispatchasync
* @param messagelistener
* @throws jmsexception
*/
public activemqmessageconsumer activemqsession session  consumerid consumerid  activemqdestination dest
string name  string selector  int prefetch
int maximumpendingmessagecount  boolean nolocal  boolean browser
boolean dispatchasync  messagelistener messagelistener  throws jmsexception
if  dest    null
throw new invaliddestinationexception
else if  dest getphysicalname      null
throw new invaliddestinationexception
else if  dest istemporary
string physicalname   dest getphysicalname
if  physicalname    null
throw new illegalargumentexception     dest
string connectionid   session connection getconnectioninfo   getconnectionid   getvalue
if  physicalname indexof connectionid  < 0
throw new invaliddestinationexception
if  session connection isdeleted dest
throw new invaliddestinationexception
if  prefetch < 0
throw new jmsexception
if  session connection ismessageprioritysupported
this unconsumedmessages   new simpleprioritymessagedispatchchannel
else
this unconsumedmessages   new fifomessagedispatchchannel
this session   session
this redeliverypolicy   session connection getredeliverypolicymap   getentryfor dest
settransformer session gettransformer
this info   new consumerinfo consumerid
this info setexclusive this session connection isexclusiveconsumer
this info setsubscriptionname name
this info setprefetchsize prefetch
this info setcurrentprefetchsize prefetch
this info setmaximumpendingmessagelimit maximumpendingmessagecount
this info setnolocal nolocal
this info setdispatchasync dispatchasync
this info setretroactive this session connection isuseretroactiveconsumer
this info setselector null
// allows the options on the destination to configure the consumerinfo
if  dest getoptions      null
map<string  object> options   introspectionsupport extractproperties
new hashmap<string  object> dest getoptions
introspectionsupport setproperties this info  options
if  options size   > 0
string msg       options size
options
log warn msg
throw new configurationexception msg
this info setdestination dest
this info setbrowser browser
if  selector    null    selector trim   length      0
// validate the selector
selectorparser parse selector
this info setselector selector
this selector   selector
else if  info getselector      null
// validate the selector
selectorparser parse this info getselector
this selector   this info getselector
else
this selector   null
this stats   new jmsconsumerstatsimpl session getsessionstats    dest
this optimizeacknowledge   session connection isoptimizeacknowledge      session isautoacknowledge
info isbrowser
if  this optimizeacknowledge
this optimizeacknowledgetimeout   session connection getoptimizeacknowledgetimeout
setoptimizedackscheduledackinterval session connection getoptimizedackscheduledackinterval
this info setoptimizedacknowledge this optimizeacknowledge
this failoverredeliverywaitperiod   session connection getconsumerfailoverredeliverywaitperiod
this nonblockingredelivery   session connection isnonblockingredelivery
this transactedindividualack   session connection istransactedindividualack      this nonblockingredelivery
if  messagelistener    null
setmessagelistener messagelistener
try
this session addconsumer this
this session syncsendpacket info
catch  jmsexception e
this session removeconsumer this
throw e
if  session connection isstarted
start
private boolean isautoacknowledgeeach
return session isautoacknowledge        session isdupsokacknowledge      getdestination   isqueue
private boolean isautoacknowledgebatch
return session isdupsokacknowledge       getdestination   isqueue
public statsimpl getstats
return stats
public jmsconsumerstatsimpl getconsumerstats
return stats
public redeliverypolicy getredeliverypolicy
return redeliverypolicy
/**
* sets the redelivery policy used when messages are redelivered
*/
public void setredeliverypolicy redeliverypolicy redeliverypolicy
this redeliverypolicy   redeliverypolicy
public messagetransformer gettransformer
return transformer
/**
* sets the transformer used to transform messages before they are sent on
* to the jms bus
*/
public void settransformer messagetransformer transformer
this transformer   transformer
/**
* @return returns the value.
*/
public consumerid getconsumerid
return info getconsumerid
/**
* @return the consumer name - used for durable consumers
*/
public string getconsumername
return this info getsubscriptionname
/**
* @return true if this consumer does not accept locally produced messages
*/
protected boolean isnolocal
return info isnolocal
/**
* retrieve is a browser
*
* @return true if a browser
*/
protected boolean isbrowser
return info isbrowser
/**
* @return activemqdestination
*/
protected activemqdestination getdestination
return info getdestination
/**
* @return returns the prefetchnumber.
*/
public int getprefetchnumber
return info getprefetchsize
/**
* @return true if this is a durable topic subscriber
*/
public boolean isdurablesubscriber
return info getsubscriptionname      null    info getdestination   istopic
/**
* gets this message consumer's message selector expression.
*
* @return this message consumer's message selector, or null if no message
*         selector exists for the message consumer (that is, if the message
*         selector was not set or was set to null or the empty string)
* @throws jmsexception if the jms provider fails to receive the next
*                 message due to some internal error.
*/
public string getmessageselector   throws jmsexception
checkclosed
return selector
/**
* gets the message consumer's <code>messagelistener</code>.
*
* @return the listener for the message consumer, or null if no listener is
*         set
* @throws jmsexception if the jms provider fails to get the message
*                 listener due to some internal error.
* @see javax.jms.messageconsumer#setmessagelistener(javax.jms.messagelistener)
*/
public messagelistener getmessagelistener   throws jmsexception
checkclosed
return this messagelistener get
/**
* sets the message consumer's <code>messagelistener</code>.
* <p>
* setting the message listener to null is the equivalent of unsetting the
* message listener for the message consumer.
* <p>
* the effect of calling <code>messageconsumer.setmessagelistener</code>
* while messages are being consumed by an existing listener or the consumer
* is being used to consume messages synchronously is undefined.
*
* @param listener the listener to which the messages are to be delivered
* @throws jmsexception if the jms provider fails to receive the next
*                 message due to some internal error.
* @see javax.jms.messageconsumer#getmessagelistener
*/
public void setmessagelistener messagelistener listener  throws jmsexception
checkclosed
if  info getprefetchsize      0
throw new jmsexception
if  listener    null
boolean wasrunning   session isrunning
if  wasrunning
session stop
this messagelistener set listener
session redispatch this  unconsumedmessages
if  wasrunning
session start
else
this messagelistener set null
public messageavailablelistener getavailablelistener
return availablelistener
/**
* sets the listener used to notify synchronous consumers that there is a
* message available so that the {@link messageconsumer#receivenowait()} can
* be called.
*/
public void setavailablelistener messageavailablelistener availablelistener
this availablelistener   availablelistener
/**
* used to get an enqueued message from the unconsumedmessages list. the
* amount of time this method blocks is based on the timeout value. - if
* timeout==-1 then it blocks until a message is received. - if timeout==0
* then it it tries to not block at all, it returns a message if it is
* available - if timeout>0 then it blocks up to timeout amount of time.
* expired messages will consumed by this method.
*
* @throws jmsexception
* @return null if we timeout or if the consumer is closed.
*/
private messagedispatch dequeue long timeout  throws jmsexception
try
long deadline   0
if  timeout > 0
deadline   system currenttimemillis     timeout
while  true
messagedispatch md   unconsumedmessages dequeue timeout
if  md    null
if  timeout > 0     unconsumedmessages isclosed
timeout   math max deadline   system currenttimemillis    0
else
if  failureerror    null
throw jmsexceptionsupport create failureerror
else
return null
else if  md getmessage      null
return null
else if  md getmessage   isexpired
if  log isdebugenabled
log debug getconsumerid         md
beforemessageisconsumed md
aftermessageisconsumed md  true
if  timeout > 0
timeout   math max deadline   system currenttimemillis    0
else
if  log istraceenabled
log trace getconsumerid         md
return md
catch  interruptedexception e
thread currentthread   interrupt
throw jmsexceptionsupport create e
/**
* receives the next message produced for this message consumer.
* <p>
* this call blocks indefinitely until a message is produced or until this
* message consumer is closed.
* <p>
* if this <code>receive</code> is done within a transaction, the consumer
* retains the message until the transaction commits.
*
* @return the next message produced for this message consumer, or null if
*         this message consumer is concurrently closed
*/
public message receive   throws jmsexception
checkclosed
checkmessagelistener
sendpullcommand 0
messagedispatch md   dequeue  1
if  md    null
return null
beforemessageisconsumed md
aftermessageisconsumed md  false
return createactivemqmessage md
/**
* @param md
* @return
*/
private activemqmessage createactivemqmessage final messagedispatch md  throws jmsexception
activemqmessage m    activemqmessage md getmessage   copy
if  m getdatastructuretype    commandtypes activemq_blob_message
activemqblobmessage m  setblobdownloader new blobdownloader session getblobtransferpolicy
if  transformer    null
message transformedmessage   transformer consumertransform session  this  m
if  transformedmessage    null
m   activemqmessagetransformation transformmessage transformedmessage  session connection
if  session isclientacknowledge
m setacknowledgecallback new callback
public void execute   throws exception
session checkclosed
session acknowledge
else if  session isindividualacknowledge
m setacknowledgecallback new callback
public void execute   throws exception
session checkclosed
acknowledge md
return m
/**
* receives the next message that arrives within the specified timeout
* interval.
* <p>
* this call blocks until a message arrives, the timeout expires, or this
* message consumer is closed. a <code>timeout</code> of zero never
* expires, and the call blocks indefinitely.
*
* @param timeout the timeout value (in milliseconds), a time out of zero
*                never expires.
* @return the next message produced for this message consumer, or null if
*         the timeout expires or this message consumer is concurrently
*         closed
*/
public message receive long timeout  throws jmsexception
checkclosed
checkmessagelistener
if  timeout    0
return this receive
sendpullcommand timeout
while  timeout > 0
messagedispatch md
if  info getprefetchsize      0
md   dequeue  1      we let the broker let us know when we timeout
else
md   dequeue timeout
if  md    null
return null
beforemessageisconsumed md
aftermessageisconsumed md  false
return createactivemqmessage md
return null
/**
* receives the next message if one is immediately available.
*
* @return the next message produced for this message consumer, or null if
*         one is not available
* @throws jmsexception if the jms provider fails to receive the next
*                 message due to some internal error.
*/
public message receivenowait   throws jmsexception
checkclosed
checkmessagelistener
sendpullcommand  1
messagedispatch md
if  info getprefetchsize      0
md   dequeue  1      we let the broker let us know when we
// timeout.
else
md   dequeue 0
if  md    null
return null
beforemessageisconsumed md
aftermessageisconsumed md  false
return createactivemqmessage md
/**
* closes the message consumer.
* <p>
* since a provider may allocate some resources on behalf of a <code>
* messageconsumer</code>
* outside the java virtual machine, clients should close them when they are
* not needed. relying on garbage collection to eventually reclaim these
* resources may not be timely enough.
* <p>
* this call blocks until a <code>receive</code> or message listener in
* progress has completed. a blocked message consumer <code>receive </code>
* call returns null when this message consumer is closed.
*
* @throws jmsexception if the jms provider fails to close the consumer due
*                 to some internal error.
*/
public void close   throws jmsexception
if   unconsumedmessages isclosed
if  session gettransactioncontext   isintransaction
session gettransactioncontext   addsynchronization new synchronization
@override
public void aftercommit   throws exception
doclose
@override
public void afterrollback   throws exception
doclose
else
doclose
void doclose   throws jmsexception
// store interrupted state and clear so that transport operations don't
// throw interruptedexception and we ensure that resources are clened up.
boolean interrupted   thread interrupted
dispose
removeinfo removecommand   info createremovecommand
if  log isdebugenabled
log debug     this getconsumerid         lastdeliveredsequenceid
removecommand setlastdeliveredsequenceid lastdeliveredsequenceid
this session asyncsendpacket removecommand
if  interrupted
thread currentthread   interrupt
void inprogressclearrequired
inprogressclearrequiredflag incrementandget
// deal with delivered messages async to avoid lock contention with in progress acks
cleardispatchlist   true
void clearmessagesinprogress
if  inprogressclearrequiredflag get   > 0
synchronized  unconsumedmessages getmutex
if  inprogressclearrequiredflag get   > 0
if  log isdebugenabled
log debug getconsumerid         unconsumedmessages size
// ensure unconsumed are rolledback up front as they may get redelivered to another consumer
list<messagedispatch> list   unconsumedmessages removeall
if   this info isbrowser
for  messagedispatch old   list
session connection rollbackduplicate this  old getmessage
// allow dispatch on this connection to resume
session connection transportinterruptionprocessingcomplete
inprogressclearrequiredflag decrementandget
// wake up any blockers and allow them to recheck state.
unconsumedmessages getmutex   notifyall
void deliveracks
messageack ack   null
if  deliveryingacknowledgements compareandset false  true
if  isautoacknowledgeeach
synchronized deliveredmessages
ack   makeackforalldeliveredmessages messageack standard_ack_type
if  ack    null
deliveredmessages clear
ackcounter   0
else
ack   pendingack
pendingack   null
else if  pendingack    null    pendingack isstandardack
ack   pendingack
pendingack   null
if  ack    null
final messageack acktosend   ack
if  executorservice    null
executorservice   executors newsinglethreadexecutor
executorservice submit new runnable
public void run
try
session sendack acktosend true
catch  jmsexception e
log error getconsumerid        e
finally
deliveryingacknowledgements set false
else
deliveryingacknowledgements set false
public void dispose   throws jmsexception
if   unconsumedmessages isclosed
// do we have any acks we need to send out before closing?
// ack any delivered messages now.
if   session gettransacted
deliveracks
if  isautoacknowledgebatch
acknowledge
if  executorservice    null
threadpoolutils shutdowngraceful executorservice  60000l
executorservice   null
if  optimizedacktask    null
this session connection getscheduler   cancel optimizedacktask
optimizedacktask   null
if  session isclientacknowledge
if   this info isbrowser
// rollback duplicates that aren't acknowledged
list<messagedispatch> tmp   null
synchronized  this deliveredmessages
tmp   new arraylist<messagedispatch> this deliveredmessages
for  messagedispatch old   tmp
this session connection rollbackduplicate this  old getmessage
tmp clear
if   session istransacted
synchronized deliveredmessages
deliveredmessages clear
unconsumedmessages close
this session removeconsumer this
list<messagedispatch> list   unconsumedmessages removeall
if   this info isbrowser
for  messagedispatch old   list
// ensure we don't filter this as a duplicate
session connection rollbackduplicate this  old getmessage
/**
* @throws illegalstateexception
*/
protected void checkclosed   throws illegalstateexception
if  unconsumedmessages isclosed
throw new illegalstateexception
/**
* if we have a zero prefetch specified then send a pull command to the
* broker to pull a message we are about to receive
*/
protected void sendpullcommand long timeout  throws jmsexception
cleardispatchlist
if  info getcurrentprefetchsize      0    unconsumedmessages isempty
messagepull messagepull   new messagepull
messagepull configure info
messagepull settimeout timeout
session asyncsendpacket messagepull
protected void checkmessagelistener   throws jmsexception
session checkmessagelistener
protected void setoptimizeacknowledge boolean value
if  optimizeacknowledge     value
deliveracks
optimizeacknowledge   value
protected void setprefetchsize int prefetch
deliveracks
this info setcurrentprefetchsize prefetch
private void beforemessageisconsumed messagedispatch md  throws jmsexception
md setdeliverysequenceid session getnextdeliveryid
lastdeliveredsequenceid   md getmessage   getmessageid   getbrokersequenceid
if   isautoacknowledgebatch
synchronized deliveredmessages
deliveredmessages addfirst md
if  session gettransacted
if  transactedindividualack
immediateindividualtransactedack md
else
acklater md  messageack delivered_ack_type
private void immediateindividualtransactedack messagedispatch md  throws jmsexception
// acks accumulate on the broker pending transaction completion to indicate
// delivery status
registersync
messageack ack   new messageack md  messageack individual_ack_type  1
ack settransactionid session gettransactioncontext   gettransactionid
session syncsendpacket ack
private void aftermessageisconsumed messagedispatch md  boolean messageexpired  throws jmsexception
if  unconsumedmessages isclosed
return
if  messageexpired
acknowledge md  messageack delivered_ack_type
stats getexpiredmessagecount   increment
else
stats onmessage
if  session gettransacted
// do nothing.
else if  isautoacknowledgeeach
if  deliveryingacknowledgements compareandset false  true
synchronized  deliveredmessages
if   deliveredmessages isempty
if  optimizeacknowledge
ackcounter
// amq-3956 evaluate both expired and normal msgs as
// otherwise consumer may get stalled
if  ackcounter   deliveredcounter >   info getprefetchsize      65      optimizeacknowledgetimeout > 0    system currenttimemillis   >   optimizeacktimestamp   optimizeacknowledgetimeout
messageack ack   makeackforalldeliveredmessages messageack standard_ack_type
if  ack    null
deliveredmessages clear
ackcounter   0
session sendack ack
optimizeacktimestamp   system currenttimemillis
// amq-3956 - as further optimization send
// ack for expired msgs when there are any.
// this resets the deliveredcounter to 0 so that
// we won't sent standard acks with every msg just
// because the deliveredcounter just below
// 0.5 * prefetch as used in acklater()
if  pendingack    null    deliveredcounter > 0
session sendack pendingack
pendingack   null
deliveredcounter   0
else
messageack ack   makeackforalldeliveredmessages messageack standard_ack_type
if  ack  null
deliveredmessages clear
session sendack ack
deliveryingacknowledgements set false
else if  isautoacknowledgebatch
acklater md  messageack standard_ack_type
else if  session isclientacknowledge    session isindividualacknowledge
boolean messageunackedbyconsumer   false
synchronized  deliveredmessages
messageunackedbyconsumer   deliveredmessages contains md
if  messageunackedbyconsumer
acklater md  messageack delivered_ack_type
else
throw new illegalstateexception
/**
* creates a messageack for all messages contained in deliveredmessages.
* caller should hold the lock for deliveredmessages.
*
* @param type ack-type (i.e. messageack.standard_ack_type)
* @return <code>null</code> if nothing to ack.
*/
private messageack makeackforalldeliveredmessages byte type
synchronized  deliveredmessages
if  deliveredmessages isempty
return null
messagedispatch md   deliveredmessages getfirst
messageack ack   new messageack md  type  deliveredmessages size
ack setfirstmessageid deliveredmessages getlast   getmessage   getmessageid
return ack
private void acklater messagedispatch md  byte acktype  throws jmsexception
// don't acknowledge now, but we may need to let the broker know the
// consumer got the message to expand the pre-fetch window
if  session gettransacted
registersync
deliveredcounter
messageack oldpendingack   pendingack
pendingack   new messageack md  acktype  deliveredcounter
pendingack settransactionid session gettransactioncontext   gettransactionid
if  oldpendingack  null
pendingack setfirstmessageid pendingack getlastmessageid
else if   oldpendingack getacktype      pendingack getacktype
pendingack setfirstmessageid oldpendingack getfirstmessageid
else
// old pending ack being superseded by ack of another type, if is is not a delivered
// ack and hence important, send it now so it is not lost.
if    oldpendingack isdeliveredack
if  log isdebugenabled
log debug     oldpendingack       pendingack
session sendack oldpendingack
else
if  log isdebugenabled
log debug     oldpendingack       pendingack
// amq-3956 evaluate both expired and normal msgs as
// otherwise consumer may get stalled
if   0 5   info getprefetchsize    <   deliveredcounter   ackcounter   additionalwindowsize
session sendack pendingack
pendingack null
deliveredcounter   0
additionalwindowsize   0
private void registersync   throws jmsexception
session dostarttransaction
if   synchronizationregistered
synchronizationregistered   true
session gettransactioncontext   addsynchronization new synchronization
@override
public void beforeend   throws exception
if  transactedindividualack
cleardispatchlist
waitforredeliveries
synchronized deliveredmessages
rollbackonfailedrecoveryredelivery
else
acknowledge
synchronizationregistered   false
@override
public void aftercommit   throws exception
commit
synchronizationregistered   false
@override
public void afterrollback   throws exception
rollback
synchronizationregistered   false
/**
* acknowledge all the messages that have been delivered to the client up to
* this point.
*
* @throws jmsexception
*/
public void acknowledge   throws jmsexception
cleardispatchlist
waitforredeliveries
synchronized deliveredmessages
// acknowledge all messages so far.
messageack ack   makeackforalldeliveredmessages messageack standard_ack_type
if  ack    null
return     no msgs
if  session gettransacted
rollbackonfailedrecoveryredelivery
session dostarttransaction
ack settransactionid session gettransactioncontext   gettransactionid
pendingack   null
session sendack ack
// adjust the counters
deliveredcounter   math max 0  deliveredcounter   deliveredmessages size
additionalwindowsize   math max 0  additionalwindowsize   deliveredmessages size
if   session gettransacted
deliveredmessages clear
private void waitforredeliveries
if  failoverredeliverywaitperiod > 0    previouslydeliveredmessages    null
long expiry   system currenttimemillis     failoverredeliverywaitperiod
int numbernotreplayed
do
numbernotreplayed   0
synchronized deliveredmessages
if  previouslydeliveredmessages    null
for  entry<messageid  boolean> entry  previouslydeliveredmessages entryset
if   entry getvalue
numbernotreplayed
if  numbernotreplayed > 0
log info     numbernotreplayed
previouslydeliveredmessages transactionid        this getconsumerid
try
thread sleep math max 500  failoverredeliverywaitperiod 4
catch  interruptedexception outofhere
break
while  numbernotreplayed > 0    expiry < system currenttimemillis
/*
* called with deliveredmessages locked
*/
private void rollbackonfailedrecoveryredelivery   throws jmsexception
if  previouslydeliveredmessages    null
// if any previously delivered messages was not re-delivered, transaction is invalid and must rollback
// as messages have been dispatched else where.
int numbernotreplayed   0
for  entry<messageid  boolean> entry  previouslydeliveredmessages entryset
if   entry getvalue
numbernotreplayed
if  log isdebugenabled
log debug
previouslydeliveredmessages transactionid
entry getkey
if  numbernotreplayed > 0
string message
previouslydeliveredmessages transactionid       numbernotreplayed
this getconsumerid
log warn message
throw new transactionrolledbackexception message
void acknowledge messagedispatch md  throws jmsexception
acknowledge md  messageack individual_ack_type
void acknowledge messagedispatch md  byte acktype  throws jmsexception
messageack ack   new messageack md  acktype  1
session sendack ack
synchronized deliveredmessages
deliveredmessages remove md
public void commit   throws jmsexception
synchronized  deliveredmessages
deliveredmessages clear
clearpreviouslydelivered
redeliverydelay   0
public void rollback   throws jmsexception
synchronized  unconsumedmessages getmutex
if  optimizeacknowledge
// remove messages read but not acked at the broker yet through
// optimizeacknowledge
if   this info isbrowser
synchronized deliveredmessages
for  int i   0   i < deliveredmessages size        i < ackcounter   i
// ensure we don't filter this as a duplicate
messagedispatch md   deliveredmessages removelast
session connection rollbackduplicate this  md getmessage
synchronized deliveredmessages
rollbackpreviouslydeliveredandnotredelivered
if  deliveredmessages isempty
return
// use initial delay for first redelivery
messagedispatch lastmd   deliveredmessages getfirst
final int currentredeliverycount   lastmd getmessage   getredeliverycounter
if  currentredeliverycount > 0
redeliverydelay   redeliverypolicy getnextredeliverydelay redeliverydelay
else
redeliverydelay   redeliverypolicy getinitialredeliverydelay
messageid firstmsgid   deliveredmessages getlast   getmessage   getmessageid
for  iterator<messagedispatch> iter   deliveredmessages iterator    iter hasnext
messagedispatch md   iter next
md getmessage   onmessagerolledback
// ensure we don't filter this as a duplicate
session connection rollbackduplicate this  md getmessage
if  redeliverypolicy getmaximumredeliveries      redeliverypolicy no_maximum_redeliveries
lastmd getmessage   getredeliverycounter   > redeliverypolicy getmaximumredeliveries
// we need to nack the messages so that they get sent to the
// dlq.
// acknowledge the last message.
messageack ack   new messageack lastmd  messageack posion_ack_type  deliveredmessages size
ack setpoisoncause lastmd getrollbackcause
ack setfirstmessageid firstmsgid
session sendack ack true
// adjust the window size.
additionalwindowsize   math max 0  additionalwindowsize   deliveredmessages size
redeliverydelay   0
else
// only redelivery_ack after first delivery
if  currentredeliverycount > 0
messageack ack   new messageack lastmd  messageack redelivered_ack_type  deliveredmessages size
ack setfirstmessageid firstmsgid
session sendack ack true
// stop the delivery of messages.
if  nonblockingredelivery
if   unconsumedmessages isclosed
final linkedlist<messagedispatch> pendingredeliveries
new linkedlist<messagedispatch> deliveredmessages
// start up the delivery again a little later.
session getscheduler   executeafterdelay new runnable
public void run
try
if   unconsumedmessages isclosed
for messagedispatch dispatch   pendingredeliveries
session dispatch dispatch
catch  exception e
session connection onasyncexception e
redeliverydelay
else
unconsumedmessages stop
for  messagedispatch md   deliveredmessages
unconsumedmessages enqueuefirst md
if  redeliverydelay > 0     unconsumedmessages isclosed
// start up the delivery again a little later.
session getscheduler   executeafterdelay new runnable
public void run
try
if  started get
start
catch  jmsexception e
session connection onasyncexception e
redeliverydelay
else
start
deliveredcounter    deliveredmessages size
deliveredmessages clear
if  messagelistener get      null
session redispatch this  unconsumedmessages
/*
* called with unconsumedmessages && deliveredmessages locked
* remove any message not re-delivered as they can't be replayed to this
* consumer on rollback
*/
private void rollbackpreviouslydeliveredandnotredelivered
if  previouslydeliveredmessages    null
for  entry<messageid  boolean> entry  previouslydeliveredmessages entryset
if   entry getvalue
removefromdeliveredmessages entry getkey
clearpreviouslydelivered
/*
* called with deliveredmessages locked
*/
private void removefromdeliveredmessages messageid key
iterator<messagedispatch> iterator   deliveredmessages iterator
while  iterator hasnext
messagedispatch candidate   iterator next
if  key equals candidate getmessage   getmessageid
session connection rollbackduplicate this  candidate getmessage
iterator remove
break
/*
* called with deliveredmessages locked
*/
private void clearpreviouslydelivered
if  previouslydeliveredmessages    null
previouslydeliveredmessages clear
previouslydeliveredmessages   null
public void dispatch messagedispatch md
messagelistener listener   this messagelistener get
try
clearmessagesinprogress
cleardispatchlist
synchronized  unconsumedmessages getmutex
if   unconsumedmessages isclosed
if  this info isbrowser       session connection isduplicate this  md getmessage
if  listener    null    unconsumedmessages isrunning
activemqmessage message   createactivemqmessage md
beforemessageisconsumed md
try
boolean expired   message isexpired
if   expired
listener onmessage message
aftermessageisconsumed md  expired
catch  runtimeexception e
log error getconsumerid         md getmessage   getmessageid    e
if  isautoacknowledgebatch      isautoacknowledgeeach      session isindividualacknowledge
// schedual redelivery and possible dlq processing
md setrollbackcause e
rollback
else
// transacted or client ack: deliver the
// next message.
aftermessageisconsumed md  false
else
if   unconsumedmessages isrunning
// delayed redelivery, ensure it can be re delivered
session connection rollbackduplicate this  md getmessage
unconsumedmessages enqueue md
if  availablelistener    null
availablelistener onmessageavailable this
else
if   session istransacted
log warn     session getconnection   getconnectioninfo   getconnectionid
getconsumerid         md
messageack ack   new messageack md  messageack individual_ack_type  1
session sendack ack
else
if  log isdebugenabled
log debug getconsumerid         md getmessage
boolean needspoisonack   false
synchronized  deliveredmessages
if  previouslydeliveredmessages    null
previouslydeliveredmessages put md getmessage   getmessageid    true
else
// delivery while pending redelivery to another consumer on the same connection
// not waiting for redelivery will help here
needspoisonack   true
if  needspoisonack
messageack poisonack   new messageack md  messageack posion_ack_type  1
poisonack setfirstmessageid md getmessage   getmessageid
poisonack setpoisoncause new jmsexception
session getconnection   getconnectioninfo   getconnectionid
log warn
failoverredeliverywaitperiod       md       poisonack
session sendack poisonack
else
if  transactedindividualack
immediateindividualtransactedack md
else
session sendack new messageack md  messageack delivered_ack_type  1
if    dispatchedcount % 1000    0
dispatchedcount   0
thread yield
catch  exception e
session connection onclientinternalexception e
// async (on next call) clear or track delivered as they may be flagged as duplicates if they arrive again
private void cleardispatchlist
if  cleardispatchlist
synchronized  deliveredmessages
if  cleardispatchlist
if   deliveredmessages isempty
if  session istransacted
if  log isdebugenabled
log debug getconsumerid         deliveredmessages size
if  previouslydeliveredmessages    null
previouslydeliveredmessages   new previouslydeliveredmap<messageid  boolean> session gettransactioncontext   gettransactionid
for  messagedispatch delivered   deliveredmessages
previouslydeliveredmessages put delivered getmessage   getmessageid    false
else
if  log isdebugenabled
log debug getconsumerid         deliveredmessages size
deliveredmessages clear
pendingack   null
cleardispatchlist   false
public int getmessagesize
return unconsumedmessages size
public void start   throws jmsexception
if  unconsumedmessages isclosed
return
started set true
unconsumedmessages start
session executor wakeup
public void stop
started set false
unconsumedmessages stop
@override
public string tostring
return     info getconsumerid         started get
/**
* delivers a message to the message listener.
*
* @return
* @throws jmsexception
*/
public boolean iterate
messagelistener listener   this messagelistener get
if  listener    null
messagedispatch md   unconsumedmessages dequeuenowait
if  md    null
dispatch md
return true
return false
public boolean isinuse activemqtempdestination destination
return info getdestination   equals destination
public long getlastdeliveredsequenceid
return lastdeliveredsequenceid
public ioexception getfailureerror
return failureerror
public void setfailureerror ioexception failureerror
this failureerror   failureerror
/**
* @return the optimizedackscheduledackinterval
*/
public long getoptimizedackscheduledackinterval
return optimizedackscheduledackinterval
/**
* @param optimizedackscheduledackinterval the optimizedackscheduledackinterval to set
*/
public void setoptimizedackscheduledackinterval long optimizedackscheduledackinterval  throws jmsexception
this optimizedackscheduledackinterval   optimizedackscheduledackinterval
if  this optimizedacktask    null
try
this session connection getscheduler   cancel optimizedacktask
catch  jmsexception e
log debug    e
throw e
this optimizedacktask   null
// should we periodically send out all outstanding acks.
if  this optimizeacknowledge    this optimizedackscheduledackinterval > 0
this optimizedacktask   new runnable
@override
public void run
try
if  optimizeacknowledge     unconsumedmessages isclosed
if  log isinfoenabled
log info    info getconsumerid
deliveracks
catch  exception e
log debug    e
try
this session connection getscheduler   executeperiodically optimizedacktask  optimizedackscheduledackinterval
catch  jmsexception e
log debug    e
throw e