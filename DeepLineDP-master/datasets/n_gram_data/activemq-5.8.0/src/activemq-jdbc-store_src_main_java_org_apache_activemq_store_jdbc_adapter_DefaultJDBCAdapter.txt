/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store jdbc adapter
import java io ioexception
import java sql connection
import java sql preparedstatement
import java sql resultset
import java sql sqlexception
import java sql statement
import java util arraylist
import java util hashset
import java util linkedlist
import java util set
import java util concurrent locks readwritelock
import java util concurrent locks reentrantreadwritelock
import org apache activemq broker region basedestination
import org apache activemq command activemqdestination
import org apache activemq command messageid
import org apache activemq command producerid
import org apache activemq command subscriptioninfo
import org apache activemq command xatransactionid
import org apache activemq store jdbc jdbcadapter
import org apache activemq store jdbc jdbcmessageidscanlistener
import org apache activemq store jdbc jdbcmessagerecoverylistener
import org apache activemq store jdbc jdbcpersistenceadapter
import org apache activemq store jdbc jdbcmemorytransactionstore
import org apache activemq store jdbc statements
import org apache activemq store jdbc transactioncontext
import org apache activemq util databytearrayoutputstream
import org slf4j logger
import org slf4j loggerfactory
/**
* implements all the default jdbc operations that are used by the jdbcpersistenceadapter. <p/> sub-classing is
* encouraged to override the default implementation of methods to account for differences in jdbc driver
* implementations. <p/> the jdbcadapter inserts and extracts blob data using the getbytes()/setbytes() operations. <p/>
* the databases/jdbc drivers that use this adapter are:
* <ul>
* <li></li>
* </ul>
*
* @org.apache.xbean.xbean element="defaultjdbcadapter"
*
*
*/
public class defaultjdbcadapter implements jdbcadapter
private static final logger log   loggerfactory getlogger defaultjdbcadapter class
public static final int max_rows   org apache activemq activemqprefetchpolicy max_prefetch_size
protected statements statements
protected boolean batchstatments   true
protected boolean prioritizedmessages
protected readwritelock cleanupexclusivelock   new reentrantreadwritelock
protected int maxrows   max_rows
protected void setbinarydata preparedstatement s  int index  byte data  throws sqlexception
s setbytes index  data
protected byte getbinarydata resultset rs  int index  throws sqlexception
return rs getbytes index
public void docreatetables transactioncontext c  throws sqlexception  ioexception
statement s   null
cleanupexclusivelock writelock   lock
try
// check to see if the table already exists. if it does, then don't
// log warnings during startup.
// need to run the scripts anyways since they may contain alter
// statements that upgrade a previous version
// of the table
boolean alreadyexists   false
resultset rs   null
try
rs   c getconnection   getmetadata   gettables null  null  this statements getfullmessagetablename
new string
alreadyexists   rs next
catch  throwable ignore
finally
close rs
s   c getconnection   createstatement
string createstatments   this statements getcreateschemastatements
for  int i   0  i < createstatments length  i
// this will fail usually since the tables will be
// created already.
try
log debug     createstatments
s execute createstatments
catch  sqlexception e
if  alreadyexists
log debug
createstatments       e getmessage         e getsqlstate
e geterrorcode
else
log warn
createstatments       e getmessage         e getsqlstate
e geterrorcode
jdbcpersistenceadapter log    e
c getconnection   commit
finally
cleanupexclusivelock writelock   unlock
try
s close
catch  throwable e
public void dodroptables transactioncontext c  throws sqlexception  ioexception
statement s   null
cleanupexclusivelock writelock   lock
try
s   c getconnection   createstatement
string dropstatments   this statements getdropschemastatements
for  int i   0  i < dropstatments length  i
// this will fail usually since the tables will be
// created already.
try
log debug     dropstatments
s execute dropstatments
catch  sqlexception e
log warn         dropstatments
e getmessage         e getsqlstate
e geterrorcode
jdbcpersistenceadapter log    e
c getconnection   commit
finally
cleanupexclusivelock writelock   unlock
try
s close
catch  throwable e
public long dogetlastmessagestoresequenceid transactioncontext c  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindlastsequenceidinmsgsstatement
rs   s executequery
long seq1   0
if  rs next
seq1   rs getlong 1
rs close
s close
s   c getconnection   preparestatement this statements getfindlastsequenceidinacksstatement
rs   s executequery
long seq2   0
if  rs next
seq2   rs getlong 1
long seq   math max seq1  seq2
return seq
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public byte dogetmessagebyid transactioncontext c  long storesequenceid  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement
this statements getfindmessagebyidstatement
s setlong 1  storesequenceid
rs   s executequery
if   rs next
return null
return getbinarydata rs  1
finally
cleanupexclusivelock readlock   unlock
close rs
close s
/**
* a non null xid indicated the op is part of 2pc prepare, so ops are flagged pending outcome
*/
public void doaddmessage transactioncontext c  long sequence  messageid messageid  activemqdestination destination  byte data
long expiration  byte priority  xatransactionid xid  throws sqlexception  ioexception
preparedstatement s   c getaddmessagestatement
cleanupexclusivelock readlock   lock
try
if  s    null
s   c getconnection   preparestatement this statements getaddmessagestatement
if  this batchstatments
c setaddmessagestatement s
s setlong 1  sequence
s setstring 2  messageid getproducerid   tostring
s setlong 3  messageid getproducersequenceid
s setstring 4  destination getqualifiedname
s setlong 5  expiration
s setlong 6  priority
setbinarydata s  7  data
if  xid    null
byte xidval   xid getencodedxidbytes
xidval
setbinarydata s  8  xidval
else
setbinarydata s  8  null
if  this batchstatments
s addbatch
else if  s executeupdate      1
throw new sqlexception
finally
cleanupexclusivelock readlock   unlock
if   this batchstatments
if  s    null
s close
public void doaddmessagereference transactioncontext c  long sequence  messageid messageid  activemqdestination destination
long expirationtime  string messageref  throws sqlexception  ioexception
preparedstatement s   c getaddmessagestatement
cleanupexclusivelock readlock   lock
try
if  s    null
s   c getconnection   preparestatement this statements getaddmessagestatement
if  this batchstatments
c setaddmessagestatement s
s setlong 1  messageid getbrokersequenceid
s setstring 2  messageid getproducerid   tostring
s setlong 3  messageid getproducersequenceid
s setstring 4  destination getqualifiedname
s setlong 5  expirationtime
s setstring 6  messageref
if  this batchstatments
s addbatch
else if  s executeupdate      1
throw new sqlexception
finally
cleanupexclusivelock readlock   unlock
if   this batchstatments
s close
public long getstoresequenceid transactioncontext c  activemqdestination destination  messageid messageid  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindmessagesequenceidstatement
s setstring 1  messageid getproducerid   tostring
s setlong 2  messageid getproducersequenceid
s setstring 3  destination getqualifiedname
rs   s executequery
if   rs next
return new long 0 0
return new long rs getlong 1   rs getlong 2
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public byte dogetmessage transactioncontext c  messageid id  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindmessagestatement
s setstring 1  id getproducerid   tostring
s setlong 2  id getproducersequenceid
rs   s executequery
if   rs next
return null
return getbinarydata rs  1
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public string dogetmessagereference transactioncontext c  long seq  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindmessagestatement
s setlong 1  seq
rs   s executequery
if   rs next
return null
return rs getstring 1
finally
cleanupexclusivelock readlock   unlock
close rs
close s
/**
* a non null xid indicated the op is part of 2pc prepare, so ops are flagged pending outcome
*/
public void doremovemessage transactioncontext c  long seq  xatransactionid xid  throws sqlexception  ioexception
preparedstatement s   c getremovedmessagestatement
cleanupexclusivelock readlock   lock
try
if  s    null
s   c getconnection   preparestatement xid    null ?
this statements getremovemessagestatement     this statements getupdatexidflagstatement
if  this batchstatments
c setremovedmessagestatement s
if  xid    null
s setlong 1  seq
else
byte xidval   xid getencodedxidbytes
xidval
setbinarydata s  1  xidval
s setlong 2  seq
if  this batchstatments
s addbatch
else if  s executeupdate      1
throw new sqlexception
finally
cleanupexclusivelock readlock   unlock
if   this batchstatments    s    null
s close
public void dorecover transactioncontext c  activemqdestination destination  jdbcmessagerecoverylistener listener
throws exception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindallmessagesstatement
s setstring 1  destination getqualifiedname
rs   s executequery
if  this statements isuseexternalmessagereferences
while  rs next
if   listener recovermessagereference rs getstring 2
break
else
while  rs next
if   listener recovermessage rs getlong 1   getbinarydata rs  2
break
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public void domessageidscan transactioncontext c  int limit
jdbcmessageidscanlistener listener  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindallmessageidsstatement
s setmaxrows limit
rs   s executequery
// jdbc scrollable cursor requires jdbc ver > 1.0 and is often implemented locally so avoid
linkedlist<messageid> reverseorderids   new linkedlist<messageid>
while  rs next
reverseorderids addfirst new messageid rs getstring 2   rs getlong 3
if  log isdebugenabled
log debug     limit       reverseorderids size
for  messageid id   reverseorderids
listener messageid id
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public void dosetlastackwithpriority transactioncontext c  activemqdestination destination  xatransactionid xid  string clientid
string subscriptionname  long seq  long priority  throws sqlexception  ioexception
preparedstatement s   c getupdatelastackstatement
cleanupexclusivelock readlock   lock
try
if  s    null
s   c getconnection   preparestatement xid    null ?
this statements getupdatedurablelastackwithprioritystatement
this statements getupdatedurablelastackwithpriorityintxstatement
if  this batchstatments
c setupdatelastackstatement s
if  xid    null
byte xidval   encodexid xid  seq  priority
setbinarydata s  1  xidval
else
s setlong 1  seq
s setstring 2  destination getqualifiedname
s setstring 3  clientid
s setstring 4  subscriptionname
s setlong 5  priority
if  this batchstatments
s addbatch
else if  s executeupdate      1
throw new sqlexception     priority       subscriptionname
finally
cleanupexclusivelock readlock   unlock
if   this batchstatments
close s
public void dosetlastack transactioncontext c  activemqdestination destination  xatransactionid xid  string clientid
string subscriptionname  long seq  long priority  throws sqlexception  ioexception
preparedstatement s   c getupdatelastackstatement
cleanupexclusivelock readlock   lock
try
if  s    null
s   c getconnection   preparestatement xid    null ?
this statements getupdatedurablelastackstatement
this statements getupdatedurablelastackintxstatement
if  this batchstatments
c setupdatelastackstatement s
if  xid    null
byte xidval   encodexid xid  seq  priority
setbinarydata s  1  xidval
else
s setlong 1  seq
s setstring 2  destination getqualifiedname
s setstring 3  clientid
s setstring 4  subscriptionname
if  this batchstatments
s addbatch
else if  s executeupdate      1
throw new ioexception
seq       subscriptionname
finally
cleanupexclusivelock readlock   unlock
if   this batchstatments
close s
private byte encodexid xatransactionid xid  long seq  long priority
byte xidval   xid getencodedxidbytes
// encode the update
databytearrayoutputstream outputstream   xid internaloutputstream
outputstream position 1
outputstream writelong seq
outputstream writebyte long valueof priority  bytevalue
return xidval
@override
public void doclearlastack transactioncontext c  activemqdestination destination  byte priority  string clientid  string subname  throws sqlexception  ioexception
preparedstatement s   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getcleardurablelastackintxstatement
s setstring 1  destination getqualifiedname
s setstring 2  clientid
s setstring 3  subname
s setlong 4  priority
if  s executeupdate      1
throw new ioexception     clientid       subname
finally
cleanupexclusivelock readlock   unlock
close s
public void dorecoversubscription transactioncontext c  activemqdestination destination  string clientid
string subscriptionname  jdbcmessagerecoverylistener listener  throws exception
// dumptables(c,
// destination.getqualifiedname(),clientid,subscriptionname);
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindalldurablesubmessagesstatement
s setstring 1  destination getqualifiedname
s setstring 2  clientid
s setstring 3  subscriptionname
rs   s executequery
if  this statements isuseexternalmessagereferences
while  rs next
if   listener recovermessagereference rs getstring 2
break
else
while  rs next
if   listener recovermessage rs getlong 1   getbinarydata rs  2
break
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public void dorecovernextmessages transactioncontext c  activemqdestination destination  string clientid
string subscriptionname  long seq  long priority  int maxreturned  jdbcmessagerecoverylistener listener  throws exception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfinddurablesubmessagesstatement
s setmaxrows math min maxreturned   2  maxrows
s setstring 1  destination getqualifiedname
s setstring 2  clientid
s setstring 3  subscriptionname
s setlong 4  seq
rs   s executequery
int count   0
if  this statements isuseexternalmessagereferences
while  rs next      count < maxreturned
if  listener recovermessagereference rs getstring 1
count
else
while  rs next      count < maxreturned
if  listener recovermessage rs getlong 1   getbinarydata rs  2
count
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public void dorecovernextmessageswithpriority transactioncontext c  activemqdestination destination  string clientid
string subscriptionname  long seq  long priority  int maxreturned  jdbcmessagerecoverylistener listener  throws exception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfinddurablesubmessagesbyprioritystatement
s setmaxrows math min maxreturned   2  maxrows
s setstring 1  destination getqualifiedname
s setstring 2  clientid
s setstring 3  subscriptionname
s setlong 4  seq
s setlong 5  priority
rs   s executequery
int count   0
if  this statements isuseexternalmessagereferences
while  rs next      count < maxreturned
if  listener recovermessagereference rs getstring 1
count
else
while  rs next      count < maxreturned
if  listener recovermessage rs getlong 1   getbinarydata rs  2
count
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public int dogetdurablesubscribermessagecount transactioncontext c  activemqdestination destination
string clientid  string subscriptionname  boolean isprioritizedmessages  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
int result   0
cleanupexclusivelock readlock   lock
try
if  isprioritizedmessages
s   c getconnection   preparestatement this statements getdurablesubscribermessagecountstatementwithpriority
else
s   c getconnection   preparestatement this statements getdurablesubscribermessagecountstatement
s setstring 1  destination getqualifiedname
s setstring 2  clientid
s setstring 3  subscriptionname
rs   s executequery
if  rs next
result   rs getint 1
finally
cleanupexclusivelock readlock   unlock
close rs
close s
return result
/**
* @param c
* @param info
* @param retroactive
* @throws sqlexception
* @throws ioexception
*/
public void dosetsubscriberentry transactioncontext c  subscriptioninfo info  boolean retroactive  boolean isprioritizedmessages
throws sqlexception  ioexception
// dumptables(c, destination.getqualifiedname(), clientid,
// subscriptionname);
preparedstatement s   null
cleanupexclusivelock readlock   lock
try
long lastmessageid    1
if   retroactive
s   c getconnection   preparestatement this statements getfindlastsequenceidinmsgsstatement
resultset rs   null
try
rs   s executequery
if  rs next
lastmessageid   rs getlong 1
finally
close rs
close s
s   c getconnection   preparestatement this statements getcreatedurablesubstatement
int maxpriority   1
if  isprioritizedmessages
maxpriority   10
for  int priority   0  priority < maxpriority  priority
s setstring 1  info getdestination   getqualifiedname
s setstring 2  info getclientid
s setstring 3  info getsubscriptionname
s setstring 4  info getselector
s setlong 5  lastmessageid
s setstring 6  info getsubscribeddestination   getqualifiedname
s setlong 7  priority
if  s executeupdate      1
throw new ioexception     info getclientid
finally
cleanupexclusivelock readlock   unlock
close s
public subscriptioninfo dogetsubscriberentry transactioncontext c  activemqdestination destination
string clientid  string subscriptionname  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfinddurablesubstatement
s setstring 1  destination getqualifiedname
s setstring 2  clientid
s setstring 3  subscriptionname
rs   s executequery
if   rs next
return null
subscriptioninfo subscription   new subscriptioninfo
subscription setdestination destination
subscription setclientid clientid
subscription setsubscriptionname subscriptionname
subscription setselector rs getstring 1
subscription setsubscribeddestination activemqdestination createdestination rs getstring 2
activemqdestination queue_type
return subscription
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public subscriptioninfo dogetallsubscriptions transactioncontext c  activemqdestination destination
throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindalldurablesubsstatement
s setstring 1  destination getqualifiedname
rs   s executequery
arraylist<subscriptioninfo> rc   new arraylist<subscriptioninfo>
while  rs next
subscriptioninfo subscription   new subscriptioninfo
subscription setdestination destination
subscription setselector rs getstring 1
subscription setsubscriptionname rs getstring 2
subscription setclientid rs getstring 3
subscription setsubscribeddestination activemqdestination createdestination rs getstring 4
activemqdestination queue_type
rc add subscription
return rc toarray new subscriptioninfo
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public void doremoveallmessages transactioncontext c  activemqdestination destinationname  throws sqlexception
ioexception
preparedstatement s   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getremoveallmessagesstatement
s setstring 1  destinationname getqualifiedname
s executeupdate
s close
s   c getconnection   preparestatement this statements getremoveallsubscriptionsstatement
s setstring 1  destinationname getqualifiedname
s executeupdate
finally
cleanupexclusivelock readlock   unlock
close s
public void dodeletesubscription transactioncontext c  activemqdestination destination  string clientid
string subscriptionname  throws sqlexception  ioexception
preparedstatement s   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getdeletesubscriptionstatement
s setstring 1  destination getqualifiedname
s setstring 2  clientid
s setstring 3  subscriptionname
s executeupdate
finally
cleanupexclusivelock readlock   unlock
close s
char priorityiterator   0     unsigned
public void dodeleteoldmessages transactioncontext c  throws sqlexception  ioexception
preparedstatement s   null
cleanupexclusivelock writelock   lock
try
log debug     this statements getdeleteoldmessagesstatementwithpriority
s   c getconnection   preparestatement this statements getdeleteoldmessagesstatementwithpriority
int priority   priorityiterator  %10
s setint 1  priority
s setint 2  priority
int i   s executeupdate
log debug     i       priority
finally
cleanupexclusivelock writelock   unlock
close s
public long dogetlastackeddurablesubscribermessageid transactioncontext c  activemqdestination destination
string clientid  string subscribername  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
long result    1
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getlastackeddurablesubscribermessagestatement
s setstring 1  destination getqualifiedname
s setstring 2  clientid
s setstring 3  subscribername
rs   s executequery
if  rs next
result   rs getlong 1
if  result    0    rs wasnull
result    1
finally
cleanupexclusivelock readlock   unlock
close rs
close s
return result
protected static void close preparedstatement s
try
s close
catch  throwable e
protected static void close resultset rs
try
rs close
catch  throwable e
public set<activemqdestination> dogetdestinations transactioncontext c  throws sqlexception  ioexception
hashset<activemqdestination> rc   new hashset<activemqdestination>
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindalldestinationsstatement
rs   s executequery
while  rs next
rc add activemqdestination createdestination rs getstring 1   activemqdestination queue_type
finally
cleanupexclusivelock readlock   unlock
close rs
close s
return rc
/**
* @return true if batchstements
*/
public boolean isbatchstatments
return this batchstatments
/**
* @param batchstatments
*/
public void setbatchstatments boolean batchstatments
this batchstatments   batchstatments
public void setuseexternalmessagereferences boolean useexternalmessagereferences
this statements setuseexternalmessagereferences useexternalmessagereferences
/**
* @return the statements
*/
public statements getstatements
return this statements
public void setstatements statements statements
this statements   statements
public int getmaxrows
return maxrows
/**
* the max value for statement maxrows, used to limit jdbc queries
*/
public void setmaxrows int maxrows
this maxrows   maxrows
@override
public void dorecorddestination transactioncontext c  activemqdestination destination  throws sqlexception  ioexception
preparedstatement s   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getcreatedurablesubstatement
s setstring 1  destination getqualifiedname
s setstring 2  destination getqualifiedname
s setstring 3  destination getqualifiedname
s setstring 4  null
s setlong 5  0
s setstring 6  destination getqualifiedname
s setlong 7  11       entry out of priority range
if  s executeupdate      1
throw new ioexception     destination
finally
cleanupexclusivelock readlock   unlock
close s
@override
public void dorecoverpreparedops transactioncontext c  jdbcmemorytransactionstore jdbcmemorytransactionstore  throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getfindopspendingoutcomestatement
rs   s executequery
while  rs next
long id   rs getlong 1
byte encodedxid   getbinarydata rs  2
if  encodedxid
jdbcmemorytransactionstore recoveradd id  getbinarydata rs  3
else
jdbcmemorytransactionstore recoverack id  encodedxid  getbinarydata rs  3
close rs
close s
s   c getconnection   preparestatement this statements getfindackspendingoutcomestatement
rs   s executequery
while  rs next
byte encodedxid   getbinarydata rs  1
string destination   rs getstring 2
string subname   rs getstring 3
string subid   rs getstring 4
jdbcmemorytransactionstore recoverlastack encodedxid
activemqdestination createdestination destination  activemqdestination topic_type
subname  subid
finally
close rs
cleanupexclusivelock readlock   unlock
close s
@override
public void docommitaddop transactioncontext c  long sequence  throws sqlexception  ioexception
preparedstatement s   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getclearxidflagstatement
s setlong 1  sequence
if  s executeupdate      1
throw new ioexception     sequence
finally
cleanupexclusivelock readlock   unlock
close s
public int dogetmessagecount transactioncontext c  activemqdestination destination  throws sqlexception
ioexception
preparedstatement s   null
resultset rs   null
int result   0
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getdestinationmessagecountstatement
s setstring 1  destination getqualifiedname
rs   s executequery
if  rs next
result   rs getint 1
finally
cleanupexclusivelock readlock   unlock
close rs
close s
return result
public void dorecovernextmessages transactioncontext c  activemqdestination destination  long nextseq
long priority  int maxreturned  boolean isprioritizedmessages  jdbcmessagerecoverylistener listener  throws exception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
if  isprioritizedmessages
s   c getconnection   preparestatement this statements getfindnextmessagesbyprioritystatement
else
s   c getconnection   preparestatement this statements getfindnextmessagesstatement
s setmaxrows math max maxreturned   2  maxrows
s setstring 1  destination getqualifiedname
s setlong 2  nextseq
if  isprioritizedmessages
s setlong 3  priority
s setlong 4  priority
rs   s executequery
int count   0
if  this statements isuseexternalmessagereferences
while  rs next      count < maxreturned
if  listener recovermessagereference rs getstring 1
count
else
log debug
break
else
while  rs next      count < maxreturned
if  listener recovermessage rs getlong 1   getbinarydata rs  2
count
else
log debug
break
catch  exception e
e printstacktrace
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public long dogetlastproducersequenceid transactioncontext c  producerid id
throws sqlexception  ioexception
preparedstatement s   null
resultset rs   null
cleanupexclusivelock readlock   lock
try
s   c getconnection   preparestatement this statements getlastproducersequenceidstatement
s setstring 1  id tostring
rs   s executequery
long seq    1
if  rs next
seq   rs getlong 1
return seq
finally
cleanupexclusivelock readlock   unlock
close rs
close s
public static void dumptables connection c  string destinationname  string clientid  string
subscriptionname  throws sqlexception
printquery c     system out
printquery c     system out
preparedstatement s   c preparestatement
s setstring 1 destinationname   s setstring 2 clientid   s setstring 3 subscriptionname
printquery s system out
public static void dumptables java sql connection c  throws sqlexception
printquery c     system out
printquery c     system out
public static void printquery java sql connection c  string query  java io printstream out
throws sqlexception
printquery c preparestatement query   out
public static void printquery java sql preparedstatement s  java io printstream out
throws sqlexception
resultset set   null
try
set   s executequery
java sql resultsetmetadata metadata   set getmetadata
for  int i   1  i <  metadata getcolumncount    i
if  i    1
out print
out print metadata getcolumnname i
out println
while  set next
for  int i   1  i <  metadata getcolumncount    i
if  i    1
out print
out print set getstring i
out println
finally
try
set close
catch  throwable ignore
try
s close
catch  throwable ignore