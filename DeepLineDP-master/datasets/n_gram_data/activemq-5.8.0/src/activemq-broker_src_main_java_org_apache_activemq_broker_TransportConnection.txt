/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker
import java io eofexception
import java io ioexception
import java net socketexception
import java net uri
import java util hashmap
import java util iterator
import java util linkedlist
import java util list
import java util map
import java util properties
import java util concurrent concurrenthashmap
import java util concurrent copyonwritearraylist
import java util concurrent countdownlatch
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomicinteger
import java util concurrent atomic atomicreference
import java util concurrent locks reentrantreadwritelock
import javax transaction xa xaresource
import org apache activemq advisory advisorysupport
import org apache activemq broker region connectionstatistics
import org apache activemq broker region regionbroker
import org apache activemq command activemqdestination
import org apache activemq command brokerinfo
import org apache activemq command command
import org apache activemq command commandtypes
import org apache activemq command connectioncontrol
import org apache activemq command connectionerror
import org apache activemq command connectionid
import org apache activemq command connectioninfo
import org apache activemq command consumercontrol
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command controlcommand
import org apache activemq command dataarrayresponse
import org apache activemq command destinationinfo
import org apache activemq command exceptionresponse
import org apache activemq command flushcommand
import org apache activemq command integerresponse
import org apache activemq command keepaliveinfo
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messagedispatch
import org apache activemq command messagedispatchnotification
import org apache activemq command messagepull
import org apache activemq command producerack
import org apache activemq command producerid
import org apache activemq command producerinfo
import org apache activemq command removesubscriptioninfo
import org apache activemq command response
import org apache activemq command sessionid
import org apache activemq command sessioninfo
import org apache activemq command shutdowninfo
import org apache activemq command transactionid
import org apache activemq command transactioninfo
import org apache activemq command wireformatinfo
import org apache activemq network demandforwardingbridge
import org apache activemq network mbeannetworklistener
import org apache activemq network networkbridgeconfiguration
import org apache activemq network networkbridgefactory
import org apache activemq security messageauthorizationpolicy
import org apache activemq state commandvisitor
import org apache activemq state connectionstate
import org apache activemq state consumerstate
import org apache activemq state producerstate
import org apache activemq state sessionstate
import org apache activemq state transactionstate
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq transaction transaction
import org apache activemq transport defaulttransportlistener
import org apache activemq transport responsecorrelator
import org apache activemq transport transmitcallback
import org apache activemq transport transport
import org apache activemq transport transportdisposedioexception
import org apache activemq transport transportfactory
import org apache activemq util introspectionsupport
import org apache activemq util marshallingsupport
import org apache activemq util urisupport
import org slf4j logger
import org slf4j loggerfactory
import org slf4j mdc
public class transportconnection implements connection  task  commandvisitor
private static final logger log   loggerfactory getlogger transportconnection class
private static final logger transportlog   loggerfactory getlogger transportconnection class getname
private static final logger servicelog   loggerfactory getlogger transportconnection class getname
// keeps track of the broker and connector that created this connection.
protected final broker broker
protected final transportconnector connector
// keeps track of the state of the connections.
// protected final concurrenthashmap localconnectionstates=new
// concurrenthashmap();
protected final map<connectionid  connectionstate> brokerconnectionstates
// the broker and wireformat info that was exchanged.
protected brokerinfo brokerinfo
protected final list<command> dispatchqueue   new linkedlist<command>
protected taskrunner taskrunner
protected final atomicreference<ioexception> transportexception   new atomicreference<ioexception>
protected atomicboolean dispatchstopped   new atomicboolean false
private final transport transport
private messageauthorizationpolicy messageauthorizationpolicy
private wireformatinfo wireformatinfo
// used to do async dispatch.. this should perhaps be pushed down into the
// transport layer..
private boolean inserviceexception
private final connectionstatistics statistics   new connectionstatistics
private boolean manageable
private boolean slow
private boolean markedcandidate
private boolean blockedcandidate
private boolean blocked
private boolean connected
private boolean active
private boolean starting
private boolean pendingstop
private long timestamp
private final atomicboolean stopping   new atomicboolean false
private final countdownlatch stopped   new countdownlatch 1
private final atomicboolean asyncexception   new atomicboolean false
private final map<producerid  producerbrokerexchange> producerexchanges   new hashmap<producerid  producerbrokerexchange>
private final map<consumerid  consumerbrokerexchange> consumerexchanges   new hashmap<consumerid  consumerbrokerexchange>
private final countdownlatch dispatchstoppedlatch   new countdownlatch 1
private connectioncontext context
private boolean networkconnection
private boolean faulttolerantconnection
private final atomicinteger protocolversion   new atomicinteger commandtypes protocol_version
private demandforwardingbridge duplexbridge
private final taskrunnerfactory taskrunnerfactory
private final taskrunnerfactory stoptaskrunnerfactory
private transportconnectionstateregister connectionstateregister   new singletransportconnectionstateregister
private final reentrantreadwritelock servicelock   new reentrantreadwritelock
private string duplexnetworkconnectorid
private throwable stoperror   null
/**
* @param taskrunnerfactory - can be null if you want direct dispatch to the transport
*                          else commands are sent async.
* @param stoptaskrunnerfactory - can <b>not</b> be null, used for stopping this connection.
*/
public transportconnection transportconnector connector  final transport transport  broker broker
taskrunnerfactory taskrunnerfactory  taskrunnerfactory stoptaskrunnerfactory
this connector   connector
this broker   broker
regionbroker rb    regionbroker  broker getadaptor regionbroker class
brokerconnectionstates   rb getconnectionstates
if  connector    null
this statistics setparent connector getstatistics
this messageauthorizationpolicy   connector getmessageauthorizationpolicy
this taskrunnerfactory   taskrunnerfactory
this stoptaskrunnerfactory   stoptaskrunnerfactory
this transport   transport
this transport settransportlistener new defaulttransportlistener
@override
public void oncommand object o
servicelock readlock   lock
try
if    o instanceof command
throw new runtimeexception     o tostring
command command    command  o
response response   service command
if  response    null
dispatchsync response
finally
servicelock readlock   unlock
@override
public void onexception ioexception exception
servicelock readlock   lock
try
servicetransportexception exception
finally
servicelock readlock   unlock
connected   true
/**
* returns the number of messages to be dispatched to this connection
*
* @return size of dispatch queue
*/
@override
public int getdispatchqueuesize
synchronized  dispatchqueue
return dispatchqueue size
public void servicetransportexception ioexception e
brokerservice bservice   connector getbrokerservice
if  bservice isshutdownonslavefailure
if  brokerinfo    null
if  brokerinfo isslavebroker
log error     e getmessage        e
try
dostop
bservice stop
catch  exception ex
log warn    ex
if   stopping get
transportexception set e
if  transportlog isdebugenabled
transportlog debug this       e  e
else if  transportlog iswarnenabled       expected e
transportlog warn this       e
stopasync
private boolean expected ioexception e
return isstomp        e instanceof socketexception    e getmessage   indexof        1     e instanceof eofexception
private boolean isstomp
uri uri   connector geturi
return uri    null    uri getscheme      null    uri getscheme   indexof        1
/**
* calls the serviceexception method in an async thread. since handling a
* service exception closes a socket, we should not tie up broker threads
* since client sockets may hang or cause deadlocks.
*/
@override
public void serviceexceptionasync final ioexception e
if  asyncexception compareandset false  true
new thread
@override
public void run
serviceexception e
start
/**
* closes a clients connection due to a detected error. errors are ignored
* if: the client is closing or broker is closing. otherwise, the connection
* error transmitted to the client before stopping it's transport.
*/
@override
public void serviceexception throwable e
// are we a transport exception such as not being able to dispatch
// synchronously to a transport
if  e instanceof ioexception
servicetransportexception  ioexception  e
else if  e getclass      brokerstoppedexception class
// handle the case where the broker is stopped
// but the client is still connected.
if   stopping get
if  servicelog isdebugenabled
servicelog debug
connectionerror ce   new connectionerror
ce setexception e
dispatchsync ce
// record the error that caused the transport to stop
this stoperror   e
// wait a little bit to try to get the output buffer to flush
// the exception notification to the client.
try
thread sleep 500
catch  interruptedexception ie
thread currentthread   interrupt
// worst case is we just kill the connection before the
// notification gets to him.
stopasync
else if   stopping get       inserviceexception
inserviceexception   true
try
servicelog warn     e  e
connectionerror ce   new connectionerror
ce setexception e
if  pendingstop
dispatchsync ce
else
dispatchasync ce
finally
inserviceexception   false
@override
public response service command command
mdc put    connector geturi   tostring
response response   null
boolean responserequired   command isresponserequired
int commandid   command getcommandid
try
if   pendingstop
response   command visit this
else
response   new exceptionresponse this stoperror
catch  throwable e
if  servicelog isdebugenabled      e getclass      brokerstoppedexception class
servicelog debug      responserequired ?
command       e  e
if  responserequired
response   new exceptionresponse e
else
serviceexception e
if  responserequired
if  response    null
response   new response
response setcorrelationid commandid
// the context may have been flagged so that the response is not
// sent.
if  context    null
if  context isdontsendreponse
context setdontsendreponse false
response   null
context   null
mdc remove
return response
@override
public response processkeepalive keepaliveinfo info  throws exception
return null
@override
public response processremovesubscription removesubscriptioninfo info  throws exception
broker removesubscription lookupconnectionstate info getconnectionid    getcontext    info
return null
@override
public response processwireformat wireformatinfo info  throws exception
wireformatinfo   info
protocolversion set info getversion
return null
@override
public response processshutdown shutdowninfo info  throws exception
stopasync
return null
@override
public response processflush flushcommand command  throws exception
return null
@override
public response processbegintransaction transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   null
if  cs    null
context   cs getcontext
if  cs    null
throw new nullpointerexception
// avoid replaying dup commands
if  cs gettransactionstate info gettransactionid       null
cs addtransactionstate info gettransactionid
broker begintransaction context  info gettransactionid
return null
@override
public response processendtransaction transactioninfo info  throws exception
// no need to do anything. this packet is just sent by the client
// make sure he is synced with the server as commit command could
// come from a different connection.
return null
@override
public response processpreparetransaction transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   null
if  cs    null
context   cs getcontext
if  cs    null
throw new nullpointerexception
transactionstate transactionstate   cs gettransactionstate info gettransactionid
if  transactionstate    null
throw new illegalstateexception
info gettransactionid
// avoid dups.
if   transactionstate isprepared
transactionstate setprepared true
int result   broker preparetransaction context  info gettransactionid
transactionstate setpreparedresult result
if  result    xaresource xa_rdonly
// we are done, no further rollback or commit from tm
cs removetransactionstate info gettransactionid
integerresponse response   new integerresponse result
return response
else
integerresponse response   new integerresponse transactionstate getpreparedresult
return response
@override
public response processcommittransactiononephase transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
cs removetransactionstate info gettransactionid
broker committransaction context  info gettransactionid    true
return null
@override
public response processcommittransactiontwophase transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
cs removetransactionstate info gettransactionid
broker committransaction context  info gettransactionid    false
return null
@override
public response processrollbacktransaction transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
cs removetransactionstate info gettransactionid
broker rollbacktransaction context  info gettransactionid
return null
@override
public response processforgettransaction transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
broker forgettransaction context  info gettransactionid
return null
@override
public response processrecovertransactions transactioninfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
context   cs getcontext
transactionid preparedtransactions   broker getpreparedtransactions context
return new dataarrayresponse preparedtransactions
@override
public response processmessage message messagesend  throws exception
producerid producerid   messagesend getproducerid
producerbrokerexchange producerexchange   getproducerbrokerexchange producerid
if  producerexchange candispatch messagesend
broker send producerexchange  messagesend
return null
@override
public response processmessageack messageack ack  throws exception
consumerbrokerexchange consumerexchange   getconsumerbrokerexchange ack getconsumerid
if  consumerexchange    null
broker acknowledge consumerexchange  ack
return null
@override
public response processmessagepull messagepull pull  throws exception
return broker messagepull lookupconnectionstate pull getconsumerid    getcontext    pull
@override
public response processmessagedispatchnotification messagedispatchnotification notification  throws exception
broker processdispatchnotification notification
return null
@override
public response processadddestination destinationinfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
broker adddestinationinfo cs getcontext    info
if  info getdestination   istemporary
cs addtempdestination info
return null
@override
public response processremovedestination destinationinfo info  throws exception
transportconnectionstate cs   lookupconnectionstate info getconnectionid
broker removedestinationinfo cs getcontext    info
if  info getdestination   istemporary
cs removetempdestination info getdestination
return null
@override
public response processaddproducer producerinfo info  throws exception
sessionid sessionid   info getproducerid   getparentid
connectionid connectionid   sessionid getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
if  cs    null
throw new illegalstateexception
connectionid
sessionstate ss   cs getsessionstate sessionid
if  ss    null
throw new illegalstateexception
sessionid
// avoid replaying dup commands
if   ss getproducerids   contains info getproducerid
activemqdestination destination   info getdestination
if  destination    null     advisorysupport isadvisorytopic destination
if  getproducercount connectionid  >  connector getmaximumproducersallowedperconnection
throw new illegalstateexception     connectionid       connector getmaximumproducersallowedperconnection
broker addproducer cs getcontext    info
try
ss addproducer info
catch  illegalstateexception e
broker removeproducer cs getcontext    info
return null
@override
public response processremoveproducer producerid id  throws exception
sessionid sessionid   id getparentid
connectionid connectionid   sessionid getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
sessionstate ss   cs getsessionstate sessionid
if  ss    null
throw new illegalstateexception
sessionid
producerstate ps   ss removeproducer id
if  ps    null
throw new illegalstateexception     id
removeproducerbrokerexchange id
broker removeproducer cs getcontext    ps getinfo
return null
@override
public response processaddconsumer consumerinfo info  throws exception
sessionid sessionid   info getconsumerid   getparentid
connectionid connectionid   sessionid getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
if  cs    null
throw new illegalstateexception
connectionid
sessionstate ss   cs getsessionstate sessionid
if  ss    null
throw new illegalstateexception broker getbrokername
sessionid
// avoid replaying dup commands
if   ss getconsumerids   contains info getconsumerid
activemqdestination destination   info getdestination
if  destination    null     advisorysupport isadvisorytopic destination
if  getconsumercount connectionid  >  connector getmaximumconsumersallowedperconnection
throw new illegalstateexception     connectionid       connector getmaximumconsumersallowedperconnection
broker addconsumer cs getcontext    info
try
ss addconsumer info
addconsumerbrokerexchange info getconsumerid
catch  illegalstateexception e
broker removeconsumer cs getcontext    info
return null
@override
public response processremoveconsumer consumerid id  long lastdeliveredsequenceid  throws exception
sessionid sessionid   id getparentid
connectionid connectionid   sessionid getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
if  cs    null
throw new illegalstateexception
connectionid
sessionstate ss   cs getsessionstate sessionid
if  ss    null
throw new illegalstateexception
sessionid
consumerstate consumerstate   ss removeconsumer id
if  consumerstate    null
throw new illegalstateexception     id
consumerinfo info   consumerstate getinfo
info setlastdeliveredsequenceid lastdeliveredsequenceid
broker removeconsumer cs getcontext    consumerstate getinfo
removeconsumerbrokerexchange id
return null
@override
public response processaddsession sessioninfo info  throws exception
connectionid connectionid   info getsessionid   getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
// avoid replaying dup commands
if  cs    null     cs getsessionids   contains info getsessionid
broker addsession cs getcontext    info
try
cs addsession info
catch  illegalstateexception e
e printstacktrace
broker removesession cs getcontext    info
return null
@override
public response processremovesession sessionid id  long lastdeliveredsequenceid  throws exception
connectionid connectionid   id getparentid
transportconnectionstate cs   lookupconnectionstate connectionid
if  cs    null
throw new illegalstateexception     connectionid
sessionstate session   cs getsessionstate id
if  session    null
throw new illegalstateexception     id
// don't let new consumers or producers get added while we are closing
// this down.
session shutdown
// cascade the connection stop to the consumers and producers.
for  consumerid consumerid   session getconsumerids
try
processremoveconsumer consumerid  lastdeliveredsequenceid
catch  throwable e
log warn     consumerid       e  e
for  producerid producerid   session getproducerids
try
processremoveproducer producerid
catch  throwable e
log warn     producerid       e  e
cs removesession id
broker removesession cs getcontext    session getinfo
return null
@override
public response processaddconnection connectioninfo info  throws exception
// older clients should have been defaulting this field to true.. but
// they were not.
if  wireformatinfo    null    wireformatinfo getversion   <  2
info setclientmaster true
transportconnectionstate state
// make sure 2 concurrent connections by the same id only generate 1
// transportconnectionstate object.
synchronized  brokerconnectionstates
state    transportconnectionstate  brokerconnectionstates get info getconnectionid
if  state    null
state   new transportconnectionstate info  this
brokerconnectionstates put info getconnectionid    state
state incrementreference
// if there are 2 concurrent connections for the same connection id,
// then last one in wins, we need to sync here
// to figure out the winner.
synchronized  state getconnectionmutex
if  state getconnection      this
log debug     state getconnection   getremoteaddress
state getconnection   stop
log debug     getremoteaddress
state getconnection   getremoteaddress
state setconnection this
state reset info
registerconnectionstate info getconnectionid    state
log debug     info getconnectionid         getremoteaddress         info
this faulttolerantconnection   info isfaulttolerant
// setup the context.
string clientid   info getclientid
context   new connectioncontext
context setbroker broker
context setclientid clientid
context setclientmaster info isclientmaster
context setconnection this
context setconnectionid info getconnectionid
context setconnector connector
context setmessageauthorizationpolicy getmessageauthorizationpolicy
context setnetworkconnection networkconnection
context setfaulttolerant faulttolerantconnection
context settransactions new concurrenthashmap<transactionid  transaction>
context setusername info getusername
context setwireformatinfo wireformatinfo
context setreconnect info isfailoverreconnect
this manageable   info ismanageable
context setconnectionstate state
state setcontext context
state setconnection this
if  info getclientip      null
info setclientip getremoteaddress
try
broker addconnection context  info
catch  exception e
synchronized  brokerconnectionstates
brokerconnectionstates remove info getconnectionid
unregisterconnectionstate info getconnectionid
log warn     info getconnectionid         e tostring
if  log isdebugenabled
log debug    e
if  e instanceof securityexception
// close this down - in case the peer of this transport doesn't play nice
delayedstop 2000      e getlocalizedmessage    e
throw e
if  info ismanageable
// send connectioncommand
connectioncontrol command   this connector getconnectioncontrol
command setfaulttolerant broker isfaulttolerantconfiguration
if  info isfailoverreconnect
command setrebalanceconnection false
dispatchasync command
return null
@override
public synchronized response processremoveconnection connectionid id  long lastdeliveredsequenceid
throws interruptedexception
log debug     id
transportconnectionstate cs   lookupconnectionstate id
if  cs    null
// don't allow things to be added to the connection state while we
// are shutting down.
cs shutdown
// cascade the connection stop to the sessions.
for  sessionid sessionid   cs getsessionids
try
processremovesession sessionid  lastdeliveredsequenceid
catch  throwable e
servicelog warn     sessionid  e
// cascade the connection stop to temp destinations.
for  iterator<destinationinfo> iter   cs gettempdestinations   iterator    iter hasnext
destinationinfo di   iter next
try
broker removedestination cs getcontext    di getdestination    0
catch  throwable e
servicelog warn     di getdestination    e
iter remove
try
broker removeconnection cs getcontext    cs getinfo    null
catch  throwable e
servicelog warn     cs getinfo         e tostring
if  log isdebugenabled
servicelog debug    e
transportconnectionstate state   unregisterconnectionstate id
if  state    null
synchronized  brokerconnectionstates
// if we are the last reference, we should remove the state
// from the broker.
if  state decrementreference      0
brokerconnectionstates remove id
return null
@override
public response processproducerack producerack ack  throws exception
// a broker should not get producerack messages.
return null
@override
public connector getconnector
return connector
@override
public void dispatchsync command message
try
processdispatch message
catch  ioexception e
serviceexceptionasync e
@override
public void dispatchasync command message
if   stopping get
if  taskrunner    null
dispatchsync message
else
synchronized  dispatchqueue
dispatchqueue add message
try
taskrunner wakeup
catch  interruptedexception e
thread currentthread   interrupt
else
if  message ismessagedispatch
messagedispatch md    messagedispatch  message
transmitcallback sub   md gettransmitcallback
broker postprocessdispatch md
if  sub    null
sub onfailure
protected void processdispatch command command  throws ioexception
messagedispatch messagedispatch    messagedispatch   command ismessagedispatch   ? command   null
try
if   stopping get
if  messagedispatch    null
broker preprocessdispatch messagedispatch
dispatch command
catch  ioexception e
if  messagedispatch    null
transmitcallback sub   messagedispatch gettransmitcallback
broker postprocessdispatch messagedispatch
if  sub    null
sub onfailure
messagedispatch   null
throw e
finally
if  messagedispatch    null
transmitcallback sub   messagedispatch gettransmitcallback
broker postprocessdispatch messagedispatch
if  sub    null
sub onsuccess
@override
public boolean iterate
try
if  pendingstop    stopping get
if  dispatchstopped compareandset false  true
if  transportexception get      null
try
dispatch new shutdowninfo
catch  throwable ignore
dispatchstoppedlatch countdown
return false
if   dispatchstopped get
command command   null
synchronized  dispatchqueue
if  dispatchqueue isempty
return false
command   dispatchqueue remove 0
processdispatch command
return true
return false
catch  ioexception e
if  dispatchstopped compareandset false  true
dispatchstoppedlatch countdown
serviceexceptionasync e
return false
/**
* returns the statistics for this connection
*/
@override
public connectionstatistics getstatistics
return statistics
public messageauthorizationpolicy getmessageauthorizationpolicy
return messageauthorizationpolicy
public void setmessageauthorizationpolicy messageauthorizationpolicy messageauthorizationpolicy
this messageauthorizationpolicy   messageauthorizationpolicy
@override
public boolean ismanageable
return manageable
@override
public void start   throws exception
try
synchronized  this
starting   true
if  taskrunnerfactory    null
taskrunner   taskrunnerfactory createtaskrunner this
getremoteaddress
else
taskrunner   null
transport start
active   true
brokerinfo info   connector getbrokerinfo   copy
if  connector isupdateclusterclients
info setpeerbrokerinfos this broker getpeerbrokerinfos
else
info setpeerbrokerinfos null
dispatchasync info
connector onstarted this
catch  exception e
// force clean up on an error starting up.
pendingstop   true
throw e
finally
// stop() can be called from within the above block,
// but we want to be sure start() completes before
// stop() runs, so queue the stop until right now:
setstarting false
if  ispendingstop
log debug     this
stop
@override
public void stop   throws exception
// do not stop task the task runner factories (taskrunnerfactory, stoptaskrunnerfactory)
// as their lifecycle is handled elsewhere
stopasync
while   stopped await 5  timeunit seconds
log info     transport getremoteaddress
public void delayedstop final int waittime  final string reason  throwable cause
if  waittime > 0
synchronized  this
pendingstop   true
stoperror   cause
try
stoptaskrunnerfactory execute new runnable
@override
public void run
try
thread sleep waittime
stopasync
log info     transport getremoteaddress         reason
catch  interruptedexception e
catch  throwable t
log warn    t
public void stopasync
// if we're in the middle of starting then go no further... for now.
synchronized  this
pendingstop   true
if  starting
log debug
return
if  stopping compareandset false  true
// let all the connection contexts know we are shutting down
// so that in progress operations can notice and unblock.
list<transportconnectionstate> connectionstates   listconnectionstates
for  transportconnectionstate cs   connectionstates
connectioncontext connectioncontext   cs getcontext
if  connectioncontext    null
connectioncontext getstopping   set true
try
stoptaskrunnerfactory execute new runnable
@override
public void run
servicelock writelock   lock
try
dostop
catch  throwable e
log debug     this  e
finally
stopped countdown
servicelock writelock   unlock
catch  throwable t
log warn    t
stopped countdown
@override
public string tostring
return     transport getremoteaddress
protected void dostop   throws exception
log debug    transport getremoteaddress
connector onstopped this
try
synchronized  this
if  duplexbridge    null
duplexbridge stop
catch  exception ignore
log trace    ignore
try
transport stop
log debug     transport getremoteaddress
catch  exception e
log debug     transport getremoteaddress        e
if  taskrunner    null
taskrunner shutdown 1
taskrunner   null
active   false
// run the messagedispatch callbacks so that message references get
// cleaned up.
synchronized  dispatchqueue
for  iterator<command> iter   dispatchqueue iterator    iter hasnext
command command   iter next
if  command ismessagedispatch
messagedispatch md    messagedispatch  command
transmitcallback sub   md gettransmitcallback
broker postprocessdispatch md
if  sub    null
sub onfailure
dispatchqueue clear
//
// remove all logical connection associated with this connection
// from the broker.
if   broker isstopped
list<transportconnectionstate> connectionstates   listconnectionstates
connectionstates   listconnectionstates
for  transportconnectionstate cs   connectionstates
cs getcontext   getstopping   set true
try
log debug    getremoteaddress
processremoveconnection cs getinfo   getconnectionid    0l
catch  throwable ignore
ignore printstacktrace
log debug    getremoteaddress
/**
* @return returns the blockedcandidate.
*/
public boolean isblockedcandidate
return blockedcandidate
/**
* @param blockedcandidate the blockedcandidate to set.
*/
public void setblockedcandidate boolean blockedcandidate
this blockedcandidate   blockedcandidate
/**
* @return returns the markedcandidate.
*/
public boolean ismarkedcandidate
return markedcandidate
/**
* @param markedcandidate the markedcandidate to set.
*/
public void setmarkedcandidate boolean markedcandidate
this markedcandidate   markedcandidate
if   markedcandidate
timestamp   0
blockedcandidate   false
/**
* @param slow the slow to set.
*/
public void setslow boolean slow
this slow   slow
/**
* @return true if the connection is slow
*/
@override
public boolean isslow
return slow
/**
* @return true if the connection is potentially blocked
*/
public boolean ismarkedblockedcandidate
return markedcandidate
/**
* mark the connection, so we can deem if it's collectable on the next sweep
*/
public void domark
if  timestamp    0
timestamp   system currenttimemillis
/**
* @return if after being marked, the connection is still writing
*/
@override
public boolean isblocked
return blocked
/**
* @return true if the connection is connected
*/
@override
public boolean isconnected
return connected
/**
* @param blocked the blocked to set.
*/
public void setblocked boolean blocked
this blocked   blocked
/**
* @param connected the connected to set.
*/
public void setconnected boolean connected
this connected   connected
/**
* @return true if the connection is active
*/
@override
public boolean isactive
return active
/**
* @param active the active to set.
*/
public void setactive boolean active
this active   active
/**
* @return true if the connection is starting
*/
public synchronized boolean isstarting
return starting
@override
public synchronized boolean isnetworkconnection
return networkconnection
@override
public boolean isfaulttolerantconnection
return this faulttolerantconnection
protected synchronized void setstarting boolean starting
this starting   starting
/**
* @return true if the connection needs to stop
*/
public synchronized boolean ispendingstop
return pendingstop
protected synchronized void setpendingstop boolean pendingstop
this pendingstop   pendingstop
@override
public response processbrokerinfo brokerinfo info
if  info isslavebroker
log error     info getbrokername
else if  info isnetworkconnection      info isduplexconnection
// so this transportconnection is the rear end of a network bridge
// we have been requested to create a two way pipe ...
try
properties properties   marshallingsupport stringtoproperties info getnetworkproperties
map<string  string> props   createmap properties
networkbridgeconfiguration config   new networkbridgeconfiguration
introspectionsupport setproperties config  props
config setbrokername broker getbrokername
// check for existing duplex connection hanging about
// we first look if existing network connection already exists for the same broker id and network connector name
// it's possible in case of brief network fault to have this transport connector side of the connection always active
// and the duplex network connector side wanting to open a new one
// in this case, the old connection must be broken
string duplexnetworkconnectorid   config getname         info getbrokerid
copyonwritearraylist<transportconnection> connections   this connector getconnections
synchronized  connections
for  iterator<transportconnection> iter   connections iterator    iter hasnext
transportconnection c   iter next
if   c    this      duplexnetworkconnectorid equals c getduplexnetworkconnectorid
log warn     c       duplexnetworkconnectorid
c stopasync
// better to wait for a bit rather than get connection id already in use and failure to start new bridge
c getstopped   await 1  timeunit seconds
setduplexnetworkconnectorid duplexnetworkconnectorid
transport localtransport   networkbridgefactory createlocaltransport broker
transport remotebridgetransport   transport
if     remotebridgetransport instanceof responsecorrelator
// the vm transport case is already wrapped
remotebridgetransport   new responsecorrelator remotebridgetransport
string duplexname   localtransport tostring
if  duplexname contains
duplexname   duplexname substring duplexname lastindexof
mbeannetworklistener listener   new mbeannetworklistener broker getbrokerservice    broker getbrokerservice   createduplexnetworkconnectorobjectname duplexname
listener setcreatedbyduplex true
duplexbridge   networkbridgefactory createbridge config  localtransport  remotebridgetransport  listener
duplexbridge setbrokerservice broker getbrokerservice
// now turn duplex off this side
info setduplexconnection false
duplexbridge setcreatedbyduplex true
duplexbridge duplexstart this  brokerinfo  info
log info     duplexnetworkconnectorid
return null
catch  transportdisposedioexception e
log warn     duplexnetworkconnectorid
return null
catch  exception e
log error     duplexnetworkconnectorid  e
return null
// we only expect to get one broker info command per connection
if  this brokerinfo    null
log warn     info
this brokerinfo   info
networkconnection   true
list<transportconnectionstate> connectionstates   listconnectionstates
for  transportconnectionstate cs   connectionstates
cs getcontext   setnetworkconnection true
return null
@suppresswarnings
private hashmap<string  string> createmap properties properties
return new hashmap properties
protected void dispatch command command  throws ioexception
try
setmarkedcandidate true
transport oneway command
finally
setmarkedcandidate false
@override
public string getremoteaddress
return transport getremoteaddress
@override
public string getconnectionid
list<transportconnectionstate> connectionstates   listconnectionstates
for  transportconnectionstate cs   connectionstates
if  cs getinfo   getclientid      null
return cs getinfo   getclientid
return cs getinfo   getconnectionid   tostring
return null
@override
public void updateclient connectioncontrol control
if  isactive      isblocked      false    isfaulttolerantconnection      this wireformatinfo    null
this wireformatinfo getversion   >  6
dispatchasync control
private producerbrokerexchange getproducerbrokerexchange producerid id  throws ioexception
producerbrokerexchange result   producerexchanges get id
if  result    null
synchronized  producerexchanges
result   new producerbrokerexchange
transportconnectionstate state   lookupconnectionstate id
context   state getcontext
result setconnectioncontext context
if  context isreconnect       context isnetworkconnection      connector isauditnetworkproducers
result setlaststoredsequenceid broker getbrokerservice   getpersistenceadapter   getlastproducersequenceid id
sessionstate ss   state getsessionstate id getparentid
if  ss    null
result setproducerstate ss getproducerstate id
producerstate producerstate   ss getproducerstate id
if  producerstate    null    producerstate getinfo      null
producerinfo info   producerstate getinfo
result setmutable info getdestination      null    info getdestination   iscomposite
producerexchanges put id  result
else
context   result getconnectioncontext
return result
private void removeproducerbrokerexchange producerid id
synchronized  producerexchanges
producerexchanges remove id
private consumerbrokerexchange getconsumerbrokerexchange consumerid id
consumerbrokerexchange result   consumerexchanges get id
return result
private consumerbrokerexchange addconsumerbrokerexchange consumerid id
consumerbrokerexchange result   consumerexchanges get id
if  result    null
synchronized  consumerexchanges
result   new consumerbrokerexchange
transportconnectionstate state   lookupconnectionstate id
context   state getcontext
result setconnectioncontext context
sessionstate ss   state getsessionstate id getparentid
if  ss    null
consumerstate cs   ss getconsumerstate id
if  cs    null
consumerinfo info   cs getinfo
if  info    null
if  info getdestination      null    info getdestination   ispattern
result setwildcard true
consumerexchanges put id  result
return result
private void removeconsumerbrokerexchange consumerid id
synchronized  consumerexchanges
consumerexchanges remove id
public int getprotocolversion
return protocolversion get
@override
public response processcontrolcommand controlcommand command  throws exception
string control   command getcommand
if  control    null    control equals
system exit 0
return null
@override
public response processmessagedispatch messagedispatch dispatch  throws exception
return null
@override
public response processconnectioncontrol connectioncontrol control  throws exception
if  control    null
faulttolerantconnection   control isfaulttolerant
return null
@override
public response processconnectionerror connectionerror error  throws exception
return null
@override
public response processconsumercontrol consumercontrol control  throws exception
consumerbrokerexchange consumerexchange   getconsumerbrokerexchange control getconsumerid
broker processconsumercontrol consumerexchange  control
return null
protected synchronized transportconnectionstate registerconnectionstate connectionid connectionid
transportconnectionstate state
transportconnectionstate cs   null
if   connectionstateregister isempty       connectionstateregister doeshandlemultipleconnectionstates
// swap implementations
transportconnectionstateregister newregister   new maptransportconnectionstateregister
newregister intialize connectionstateregister
connectionstateregister   newregister
cs   connectionstateregister registerconnectionstate connectionid  state
return cs
protected synchronized transportconnectionstate unregisterconnectionstate connectionid connectionid
return connectionstateregister unregisterconnectionstate connectionid
protected synchronized list<transportconnectionstate> listconnectionstates
return connectionstateregister listconnectionstates
protected synchronized transportconnectionstate lookupconnectionstate string connectionid
return connectionstateregister lookupconnectionstate connectionid
protected synchronized transportconnectionstate lookupconnectionstate consumerid id
return connectionstateregister lookupconnectionstate id
protected synchronized transportconnectionstate lookupconnectionstate producerid id
return connectionstateregister lookupconnectionstate id
protected synchronized transportconnectionstate lookupconnectionstate sessionid id
return connectionstateregister lookupconnectionstate id
protected synchronized transportconnectionstate lookupconnectionstate connectionid connectionid
return connectionstateregister lookupconnectionstate connectionid
protected synchronized void setduplexnetworkconnectorid string duplexnetworkconnectorid
this duplexnetworkconnectorid   duplexnetworkconnectorid
protected synchronized string getduplexnetworkconnectorid
return this duplexnetworkconnectorid
public boolean isstopping
return stopping get
protected countdownlatch getstopped
return stopped
private int getproducercount connectionid connectionid
int result   0
transportconnectionstate cs   lookupconnectionstate connectionid
if  cs    null
for  sessionid sessionid   cs getsessionids
sessionstate sessionstate   cs getsessionstate sessionid
if  sessionstate    null
result    sessionstate getproducerids   size
return result
private int getconsumercount connectionid connectionid
int result   0
transportconnectionstate cs   lookupconnectionstate connectionid
if  cs    null
for  sessionid sessionid   cs getsessionids
sessionstate sessionstate   cs getsessionstate sessionid
if  sessionstate    null
result    sessionstate getconsumerids   size
return result