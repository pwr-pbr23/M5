/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store kahadb
import java io datainputstream
import java io ioexception
import java util arraylist
import java util hashset
import java util iterator
import java util map
import java util set
import java util map entry
import org apache activemq broker connectioncontext
import org apache activemq command activemqdestination
import org apache activemq command activemqqueue
import org apache activemq command activemqtempqueue
import org apache activemq command activemqtemptopic
import org apache activemq command activemqtopic
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messageid
import org apache activemq command producerid
import org apache activemq command subscriptioninfo
import org apache activemq command transactionid
import org apache activemq command xatransactionid
import org apache activemq openwire openwireformat
import org apache activemq protobuf buffer
import org apache activemq store abstractmessagestore
import org apache activemq store messagerecoverylistener
import org apache activemq store messagestore
import org apache activemq store persistenceadapter
import org apache activemq store topicmessagestore
import org apache activemq store transactionrecoverylistener
import org apache activemq store transactionstore
import org apache activemq store kahadb data kahaaddmessagecommand
import org apache activemq store kahadb data kahadestination
import org apache activemq store kahadb data kahalocation
import org apache activemq store kahadb data kaharemovedestinationcommand
import org apache activemq store kahadb data kaharemovemessagecommand
import org apache activemq store kahadb data kahasubscriptioncommand
import org apache activemq store kahadb data kahadestination destinationtype
import org apache activemq usage memoryusage
import org apache activemq usage systemusage
import org apache activemq util bytesequence
import org apache activemq wireformat wireformat
import org apache activemq store kahadb disk journal location
import org apache activemq store kahadb disk page transaction
public class tempkahadbstore extends tempmessagedatabase implements persistenceadapter
private final wireformat wireformat   new openwireformat
public void setbrokername string brokername
public void setusagemanager systemusage usagemanager
public transactionstore createtransactionstore   throws ioexception
return new transactionstore
public void commit transactionid txid  boolean wasprepared  runnable precommit runnable postcommit  throws ioexception
if  precommit    null
precommit run
processcommit txid
if  postcommit    null
postcommit run
public void prepare transactionid txid  throws ioexception
processprepare txid
public void rollback transactionid txid  throws ioexception
processrollback txid
public void recover transactionrecoverylistener listener  throws ioexception
for  map entry<transactionid  arraylist<operation>> entry   preparedtransactions entryset
xatransactionid xid    xatransactionid entry getkey
arraylist<message> messagelist   new arraylist<message>
arraylist<messageack> acklist   new arraylist<messageack>
for  operation op   entry getvalue
if  op getclass      addopperation class
addopperation addop    addopperation op
message msg    message wireformat unmarshal  new datainputstream addop getcommand   getmessage   newinput
messagelist add msg
else
removeopperation rmop    removeopperation op
messageack ack    messageack wireformat unmarshal  new datainputstream rmop getcommand   getack   newinput
acklist add ack
message addedmessages   new message
messageack acks   new messageack
messagelist toarray addedmessages
acklist toarray acks
listener recover xid  addedmessages  acks
public void start   throws exception
public void stop   throws exception
public class kahadbmessagestore extends abstractmessagestore
protected kahadestination dest
public kahadbmessagestore activemqdestination destination
super destination
this dest   convert  destination
@override
public activemqdestination getdestination
return destination
public void addmessage connectioncontext context  message message  throws ioexception
kahaaddmessagecommand command   new kahaaddmessagecommand
command setdestination dest
command setmessageid message getmessageid   tostring
processadd command  message gettransactionid    wireformat marshal message
public void removemessage connectioncontext context  messageack ack  throws ioexception
kaharemovemessagecommand command   new kaharemovemessagecommand
command setdestination dest
command setmessageid ack getlastmessageid   tostring
processremove command  ack gettransactionid
public void removeallmessages connectioncontext context  throws ioexception
kaharemovedestinationcommand command   new kaharemovedestinationcommand
command setdestination dest
process command
public message getmessage messageid identity  throws ioexception
final string key   identity tostring
// hopefully one day the page file supports concurrent read operations... but for now we must
// externally synchronize...
bytesequence data
synchronized indexmutex
data   pagefile tx   execute new transaction callableclosure<bytesequence  ioexception>
public bytesequence execute transaction tx  throws ioexception
storeddestination sd   getstoreddestination dest  tx
long sequence   sd messageidindex get tx  key
if  sequence   null
return null
return sd orderindex get tx  sequence  data
if  data    null
return null
message msg    message wireformat unmarshal  data
return msg
public int getmessagecount   throws ioexception
synchronized indexmutex
return pagefile tx   execute new transaction callableclosure<integer  ioexception>
public integer execute transaction tx  throws ioexception
// iterate through all index entries to get a count of messages in the destination.
storeddestination sd   getstoreddestination dest  tx
int rc 0
for  iterator<entry<string  long>> iterator   sd messageidindex iterator tx   iterator hasnext
iterator next
rc
return rc
public void recover final messagerecoverylistener listener  throws exception
synchronized indexmutex
pagefile tx   execute new transaction closure<exception>
public void execute transaction tx  throws exception
storeddestination sd   getstoreddestination dest  tx
for  iterator<entry<long  messagerecord>> iterator   sd orderindex iterator tx   iterator hasnext
entry<long  messagerecord> entry   iterator next
listener recovermessage   message  wireformat unmarshal entry getvalue   data
long cursorpos 0
public void recovernextmessages final int maxreturned  final messagerecoverylistener listener  throws exception
synchronized indexmutex
pagefile tx   execute new transaction closure<exception>
public void execute transaction tx  throws exception
storeddestination sd   getstoreddestination dest  tx
entry<long  messagerecord> entry null
int counter   0
for  iterator<entry<long  messagerecord>> iterator   sd orderindex iterator tx  cursorpos   iterator hasnext
entry   iterator next
listener recovermessage   message  wireformat unmarshal entry getvalue   data
counter
if  counter >  maxreturned
break
if  entry  null
cursorpos   entry getkey   1
public void resetbatching
cursorpos 0
@override
public void setbatch messageid identity  throws ioexception
final string key   identity tostring
// hopefully one day the page file supports concurrent read operations... but for now we must
// externally synchronize...
long location
synchronized indexmutex
location   pagefile tx   execute new transaction callableclosure<long  ioexception>
public long execute transaction tx  throws ioexception
storeddestination sd   getstoreddestination dest  tx
return sd messageidindex get tx  key
if  location  null
cursorpos location 1
@override
public void setmemoryusage memoryusage memoeyusage
@override
public void start   throws exception
@override
public void stop   throws exception
class kahadbtopicmessagestore extends kahadbmessagestore implements topicmessagestore
public kahadbtopicmessagestore activemqtopic destination
super destination
public void acknowledge connectioncontext context  string clientid  string subscriptionname
messageid messageid  messageack ack  throws ioexception
kaharemovemessagecommand command   new kaharemovemessagecommand
command setdestination dest
command setsubscriptionkey subscriptionkey clientid  subscriptionname
command setmessageid messageid tostring
// we are not passed a transaction info.. so we can't participate in a transaction.
// looks like a design issue with the topicmessagestore interface.  also we can't recover the original ack
// to pass back to the xa recover method.
// command.settransactioninfo();
processremove command  null
public void addsubsciption subscriptioninfo subscriptioninfo  boolean retroactive  throws ioexception
string subscriptionkey   subscriptionkey subscriptioninfo getclientid    subscriptioninfo getsubscriptionname
kahasubscriptioncommand command   new kahasubscriptioncommand
command setdestination dest
command setsubscriptionkey subscriptionkey
command setretroactive retroactive
org apache activemq util bytesequence packet   wireformat marshal subscriptioninfo
command setsubscriptioninfo new buffer packet getdata    packet getoffset    packet getlength
process command
public void deletesubscription string clientid  string subscriptionname  throws ioexception
kahasubscriptioncommand command   new kahasubscriptioncommand
command setdestination dest
command setsubscriptionkey subscriptionkey clientid  subscriptionname
process command
public subscriptioninfo getallsubscriptions   throws ioexception
final arraylist<subscriptioninfo> subscriptions   new arraylist<subscriptioninfo>
synchronized indexmutex
pagefile tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
storeddestination sd   getstoreddestination dest  tx
for  iterator<entry<string  kahasubscriptioncommand>> iterator   sd subscriptions iterator tx   iterator hasnext
entry<string  kahasubscriptioncommand> entry   iterator next
subscriptioninfo info    subscriptioninfo wireformat unmarshal  new datainputstream entry getvalue   getsubscriptioninfo   newinput
subscriptions add info
subscriptioninforc new subscriptioninfo
subscriptions toarray rc
return rc
public subscriptioninfo lookupsubscription string clientid  string subscriptionname  throws ioexception
final string subscriptionkey   subscriptionkey clientid  subscriptionname
synchronized indexmutex
return pagefile tx   execute new transaction callableclosure<subscriptioninfo  ioexception>
public subscriptioninfo execute transaction tx  throws ioexception
storeddestination sd   getstoreddestination dest  tx
kahasubscriptioncommand command   sd subscriptions get tx  subscriptionkey
if  command   null
return null
return  subscriptioninfo wireformat unmarshal  new datainputstream command getsubscriptioninfo   newinput
public int getmessagecount string clientid  string subscriptionname  throws ioexception
final string subscriptionkey   subscriptionkey clientid  subscriptionname
synchronized indexmutex
return pagefile tx   execute new transaction callableclosure<integer  ioexception>
public integer execute transaction tx  throws ioexception
storeddestination sd   getstoreddestination dest  tx
long cursorpos   sd subscriptionacks get tx  subscriptionkey
if   cursorpos  null
// the subscription might not exist.
return 0
cursorpos    1
int counter   0
for  iterator<entry<long  messagerecord>> iterator   sd orderindex iterator tx  cursorpos   iterator hasnext
iterator next
counter
return counter
public void recoversubscription string clientid  string subscriptionname  final messagerecoverylistener listener  throws exception
final string subscriptionkey   subscriptionkey clientid  subscriptionname
synchronized indexmutex
pagefile tx   execute new transaction closure<exception>
public void execute transaction tx  throws exception
storeddestination sd   getstoreddestination dest  tx
long cursorpos   sd subscriptionacks get tx  subscriptionkey
cursorpos    1
for  iterator<entry<long  messagerecord>> iterator   sd orderindex iterator tx  cursorpos   iterator hasnext
entry<long  messagerecord> entry   iterator next
listener recovermessage   message  wireformat unmarshal entry getvalue   data
public void recovernextmessages string clientid  string subscriptionname  final int maxreturned  final messagerecoverylistener listener  throws exception
final string subscriptionkey   subscriptionkey clientid  subscriptionname
synchronized indexmutex
pagefile tx   execute new transaction closure<exception>
public void execute transaction tx  throws exception
storeddestination sd   getstoreddestination dest  tx
long cursorpos   sd subscriptioncursors get subscriptionkey
if  cursorpos    null
cursorpos   sd subscriptionacks get tx  subscriptionkey
cursorpos    1
entry<long  messagerecord> entry null
int counter   0
for  iterator<entry<long  messagerecord>> iterator   sd orderindex iterator tx  cursorpos   iterator hasnext
entry   iterator next
listener recovermessage   message  wireformat unmarshal entry getvalue   data
counter
if  counter >  maxreturned
break
if  entry  null
sd subscriptioncursors put subscriptionkey  entry getkey     1
public void resetbatching string clientid  string subscriptionname
try
final string subscriptionkey   subscriptionkey clientid  subscriptionname
synchronized indexmutex
pagefile tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
storeddestination sd   getstoreddestination dest  tx
sd subscriptioncursors remove subscriptionkey
catch  ioexception e
throw new runtimeexception e
string subscriptionkey string clientid  string subscriptionname
return clientid   subscriptionname
public messagestore createqueuemessagestore activemqqueue destination  throws ioexception
return new kahadbmessagestore destination
public topicmessagestore createtopicmessagestore activemqtopic destination  throws ioexception
return new kahadbtopicmessagestore destination
/**
* cleanup method to remove any state associated with the given destination.
* this method does not stop the message store (it might not be cached).
*
* @param destination destination to forget
*/
public void removequeuemessagestore activemqqueue destination
/**
* cleanup method to remove any state associated with the given destination
* this method does not stop the message store (it might not be cached).
*
* @param destination destination to forget
*/
public void removetopicmessagestore activemqtopic destination
public void deleteallmessages   throws ioexception
public set<activemqdestination> getdestinations
try
final hashset<activemqdestination> rc   new hashset<activemqdestination>
synchronized indexmutex
pagefile tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
for  iterator<entry<string  storeddestination>> iterator   destinations iterator tx   iterator hasnext
entry<string  storeddestination> entry   iterator next
rc add convert entry getkey
return rc
catch  ioexception e
throw new runtimeexception e
public long getlastmessagebrokersequenceid   throws ioexception
return 0
public long size
if    started get
return 0
try
return pagefile getdisksize
catch  ioexception e
throw new runtimeexception e
public void begintransaction connectioncontext context  throws ioexception
throw new ioexception
public void committransaction connectioncontext context  throws ioexception
throw new ioexception
public void rollbacktransaction connectioncontext context  throws ioexception
throw new ioexception
public void checkpoint boolean sync  throws ioexception
///////////////////////////////////////////////////////////////////
// internal conversion methods.
///////////////////////////////////////////////////////////////////
kahalocation convert location location
kahalocation rc   new kahalocation
rc setlogid location getdatafileid
rc setoffset location getoffset
return rc
kahadestination convert activemqdestination dest
kahadestination rc   new kahadestination
rc setname dest getphysicalname
switch  dest getdestinationtype
case activemqdestination queue_type
rc settype destinationtype queue
return rc
case activemqdestination topic_type
rc settype destinationtype topic
return rc
case activemqdestination temp_queue_type
rc settype destinationtype temp_queue
return rc
case activemqdestination temp_topic_type
rc settype destinationtype temp_topic
return rc
default
return null
activemqdestination convert string dest
int p   dest indexof
if  p<0
throw new illegalargumentexception
int type   integer parseint dest substring 0  p
string name   dest substring p 1
switch  kahadestination destinationtype valueof type
case queue
return new activemqqueue name
case topic
return new activemqtopic name
case temp_queue
return new activemqtempqueue name
case temp_topic
return new activemqtemptopic name
default
throw new illegalargumentexception
public long getlastproducersequenceid producerid id
return  1