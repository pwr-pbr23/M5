/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store kahadb scheduler
import java io datainput
import java io dataoutput
import java io ioexception
import java util arraylist
import java util iterator
import java util list
import java util map
import java util concurrent copyonwritearraylist
import java util concurrent atomic atomicboolean
import javax jms messageformatexception
import org apache activemq broker scheduler cronparser
import org apache activemq broker scheduler job
import org apache activemq broker scheduler joblistener
import org apache activemq broker scheduler jobscheduler
import org apache activemq util idgenerator
import org apache activemq util servicestopper
import org apache activemq util servicesupport
import org slf4j logger
import org slf4j loggerfactory
import org apache activemq store kahadb disk index btreeindex
import org apache activemq store kahadb disk journal location
import org apache activemq store kahadb disk page transaction
import org apache activemq util bytesequence
import org apache activemq store kahadb disk util longmarshaller
import org apache activemq store kahadb disk util variablemarshaller
class jobschedulerimpl extends servicesupport implements runnable  jobscheduler
private static final logger log   loggerfactory getlogger jobschedulerimpl class
final jobschedulerstoreimpl store
private final atomicboolean running   new atomicboolean
private string name
btreeindex<long  list<joblocation>> index
private thread thread
private final list<joblistener> joblisteners   new copyonwritearraylist<joblistener>
private static final idgenerator id_generator   new idgenerator
private final scheduletime scheduletime   new scheduletime
jobschedulerimpl jobschedulerstoreimpl store
this store   store
public void setname string name
this name   name
/*
* (non-javadoc)
* @see org.apache.activemq.beanstalk.jobscheduler#getname()
*/
public string getname
return this name
/*
* (non-javadoc)
* @see
* org.apache.activemq.beanstalk.jobscheduler#addlistener(org.apache.activemq
* .beanstalk.joblistener)
*/
public void addlistener joblistener l
this joblisteners add l
/*
* (non-javadoc)
* @see
* org.apache.activemq.beanstalk.jobscheduler#removelistener(org.apache.
* activemq.beanstalk.joblistener)
*/
public void removelistener joblistener l
this joblisteners remove l
public synchronized void schedule final string jobid  final bytesequence payload  final long delay  throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
schedule tx  jobid  payload     0  delay  0
public synchronized void schedule final string jobid  final bytesequence payload  final string cronentry  throws exception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
schedule tx  jobid  payload  cronentry  0  0  0
public synchronized void schedule final string jobid  final bytesequence payload  final string cronentry  final long delay
final long period  final int repeat  throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
schedule tx  jobid  payload  cronentry  delay  period  repeat
/*
* (non-javadoc)
* @see org.apache.activemq.beanstalk.jobscheduler#remove(long)
*/
public synchronized void remove final long time  throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
remove tx  time
synchronized void removefromindex final long time  final string jobid  throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
removefromindex tx  time  jobid
/*
* (non-javadoc)
* @see org.apache.activemq.beanstalk.jobscheduler#remove(long,
* java.lang.string)
*/
public synchronized void remove final long time  final string jobid  throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
remove tx  time  jobid
/*
* (non-javadoc)
* @see org.apache.activemq.beanstalk.jobscheduler#remove(java.lang.string)
*/
public synchronized void remove final string jobid  throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
remove tx  jobid
public synchronized long getnextscheduletime   throws ioexception
map entry<long  list<joblocation>> first   this index getfirst this store getpagefile   tx
return first    null ? first getkey      1l
/*
* (non-javadoc)
* @see org.apache.activemq.beanstalk.jobscheduler#getnextschedulejobs()
*/
public synchronized list<job> getnextschedulejobs   throws ioexception
final list<job> result   new arraylist<job>
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
map entry<long  list<joblocation>> first   index getfirst store getpagefile   tx
if  first    null
for  joblocation jl   first getvalue
bytesequence bs   getpayload jl getlocation
job job   new jobimpl jl  bs
result add job
return result
public synchronized list<job> getalljobs   throws ioexception
final list<job> result   new arraylist<job>
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
iterator<map entry<long  list<joblocation>>> iter   index iterator store getpagefile   tx
while  iter hasnext
map entry<long  list<joblocation>> next   iter next
if  next    null
for  joblocation jl   next getvalue
bytesequence bs   getpayload jl getlocation
job job   new jobimpl jl  bs
result add job
else
break
return result
public synchronized list<job> getalljobs final long start  final long finish  throws ioexception
final list<job> result   new arraylist<job>
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
iterator<map entry<long  list<joblocation>>> iter   index iterator store getpagefile   tx    start
while  iter hasnext
map entry<long  list<joblocation>> next   iter next
if  next    null    next getkey   longvalue   <  finish
for  joblocation jl   next getvalue
bytesequence bs   getpayload jl getlocation
job job   new jobimpl jl  bs
result add job
else
break
return result
public synchronized void removealljobs   throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
destroy tx
public synchronized void removealljobs final long start  final long finish  throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
destroy tx  start  finish
bytesequence getpayload location location  throws illegalstateexception  ioexception
return this store getpayload location
void schedule transaction tx  string jobid  bytesequence payload  string cronentry  long delay  long period
int repeat  throws ioexception
long starttime   system currenttimemillis
// round starttime - so we can schedule more jobs
// at the same time
starttime    starttime   1000    1000
long time   0
if  cronentry    null    cronentry length   > 0
try
time   cronparser getnextscheduledtime cronentry  starttime
catch  messageformatexception e
throw new ioexception e getmessage
if  time    0
// start time not set by cron - so it it to the current time
time   starttime
if  delay > 0
time    delay
else
time    period
location location   this store write payload  false
joblocation joblocation   new joblocation location
this store incrementjournalcount tx  location
joblocation setjobid jobid
joblocation setstarttime starttime
joblocation setcronentry cronentry
joblocation setdelay delay
joblocation setperiod period
joblocation setrepeat repeat
if  log isdebugenabled
log debug     joblocation
storejob tx  joblocation  time
this scheduletime newjob
synchronized void storejob final joblocation joblocation  final long nextexecutiontime  throws ioexception
this store getpagefile   tx   execute new transaction closure<ioexception>
public void execute transaction tx  throws ioexception
storejob tx  joblocation  nextexecutiontime
void storejob final transaction tx  final joblocation joblocation  final long nextexecutiontime  throws ioexception
list<joblocation> values   null
joblocation setnexttime nextexecutiontime
if  this index containskey tx  nextexecutiontime
values   this index remove tx  nextexecutiontime
if  values    null
values   new arraylist<joblocation>
values add joblocation
this index put tx  nextexecutiontime  values
void remove transaction tx  long time  string jobid  throws ioexception
joblocation result   removefromindex tx  time  jobid
if  result    null
this store decrementjournalcount tx  result getlocation
joblocation removefromindex transaction tx  long time  string jobid  throws ioexception
joblocation result   null
list<joblocation> values   this index remove tx  time
if  values    null
for  int i   0  i < values size    i
joblocation jl   values get i
if  jl getjobid   equals jobid
values remove i
if   values isempty
this index put tx  time  values
result   jl
break
return result
void remove transaction tx  long time  throws ioexception
list<joblocation> values   this index remove tx  time
if  values    null
for  joblocation jl   values
this store decrementjournalcount tx  jl getlocation
void remove transaction tx  string id  throws ioexception
for  iterator<map entry<long  list<joblocation>>> i   this index iterator tx   i hasnext
map entry<long  list<joblocation>> entry   i next
list<joblocation> values   entry getvalue
if  values    null
for  joblocation jl   values
if  jl getjobid   equals id
remove tx  entry getkey    id
return
synchronized void destroy transaction tx  throws ioexception
list<long> keys   new arraylist<long>
for  iterator<map entry<long  list<joblocation>>> i   this index iterator tx   i hasnext
map entry<long  list<joblocation>> entry   i next
keys add entry getkey
list<joblocation> values   entry getvalue
if  values    null
for  joblocation jl   values
this store decrementjournalcount tx  jl getlocation
for  long l   keys
this index remove tx  l
synchronized void destroy transaction tx  long start  long finish  throws ioexception
list<long> keys   new arraylist<long>
for  iterator<map entry<long  list<joblocation>>> i   this index iterator tx  start   i hasnext
map entry<long  list<joblocation>> entry   i next
if  entry getkey   longvalue   <  finish
keys add entry getkey
list<joblocation> values   entry getvalue
if  values    null
for  joblocation jl   values
this store decrementjournalcount tx  jl getlocation
else
break
for  long l   keys
this index remove tx  l
private synchronized map entry<long  list<joblocation>> getnexttoschedule   throws ioexception
if   this store isstopped       this store isstopping
map entry<long  list<joblocation>> first   this index getfirst this store getpagefile   tx
return first
return null
void firejob joblocation job  throws illegalstateexception  ioexception
if  log isdebugenabled
log debug     job
bytesequence bs   this store getpayload job getlocation
for  joblistener l   joblisteners
l scheduledjob job getjobid    bs
public void run
try
mainloop
catch  throwable e
if  this running get      isstarted
log error this      e
finally
if  running get
try
stop
catch  exception e
log error     this
@override
public string tostring
return     this name
protected void mainloop
while  this running get
this scheduletime clearnewjob
try
// peek the next job
long currenttime   system currenttimemillis
// reads the list of the next entries and removes them from the store in one atomic step.
// prevents race conditions on short delays, when storejob() tries to append new items to the
// existing list during this read operation (see amq-3141).
synchronized  this
map entry<long  list<joblocation>> first   getnexttoschedule
if  first    null
list<joblocation> list   new arraylist<joblocation> first getvalue
final long executiontime   first getkey
long nextexecutiontime   0
if  executiontime <  currenttime
for  final joblocation job   list
int repeat   job getrepeat
nextexecutiontime   calculatenextexecutiontime job  currenttime  repeat
long waittime   nextexecutiontime   currenttime
this scheduletime setwaittime waittime
if  job iscron      false
firejob job
if  repeat    0
repeat
job setrepeat repeat
// remove this job from the index - so it
// doesn't get destroyed
removefromindex executiontime  job getjobid
// and re-store it
storejob job  nextexecutiontime
else
// cron job
if  repeat    0
// we haven't got a separate scheduler to
// execute at
// this time - just a cron job - so fire it
firejob job
//this.scheduletime.setwaittime(this.scheduletime.default_wait);
if  nextexecutiontime > currenttime
// we will run again ...
// remove this job from the index - so it
// doesn't get destroyed
removefromindex executiontime  job getjobid
// and re-store it
storejob job  nextexecutiontime
if  repeat    0
// we have a separate schedule to run at
// this time
// so the cron job is used to set of a
// seperate scheule
// hence we won't fire the original cron
// job to the listeners
// but we do need to start a separate
// schedule
string jobid   id_generator generateid
bytesequence payload   getpayload job getlocation
schedule jobid  payload     job getdelay    job getperiod    job getrepeat
waittime   job getdelay      0 ? job getdelay     job getperiod
this scheduletime setwaittime waittime
// now remove all jobs that have not been
// rescheduled from this execution time
remove executiontime
// if there is a job that should fire before the currently set wait time
// we need to reset wait time otherwise we'll miss it.
map entry<long  list<joblocation>> nextup   getnexttoschedule
if  nextup    null
final long timeuntilnextscheduled   nextup getkey     currenttime
if  timeuntilnextscheduled < this scheduletime getwaittime
this scheduletime setwaittime timeuntilnextscheduled
else
if  log isdebugenabled
log debug      executiontime   currenttime
this scheduletime setwaittime executiontime   currenttime
this scheduletime pause
catch  exception ioe
log error this name      ioe
try
this store stop
catch  exception e
log error this name      e
@override
protected void dostart   throws exception
this running set true
this thread   new thread this      this name
this thread setdaemon true
this thread start
@override
protected void dostop servicestopper stopper  throws exception
this running set false
this scheduletime wakeup
thread t   this thread
if  t    null
t join 1000
long calculatenextexecutiontime final joblocation job  long currenttime  int repeat  throws messageformatexception
long result   currenttime
string cron   job getcronentry
if  cron    null    cron length   > 0
result   cronparser getnextscheduledtime cron  result
else if  job getrepeat      0
result    job getperiod
return result
void createindexes transaction tx  throws ioexception
this index   new btreeindex<long  list<joblocation>> this store getpagefile    tx allocate   getpageid
void load transaction tx  throws ioexception
this index setkeymarshaller longmarshaller instance
this index setvaluemarshaller valuemarshaller instance
this index load tx
void read datainput in  throws ioexception
this name   in readutf
this index   new btreeindex<long  list<joblocation>> this store getpagefile    in readlong
this index setkeymarshaller longmarshaller instance
this index setvaluemarshaller valuemarshaller instance
public void write dataoutput out  throws ioexception
out writeutf name
out writelong this index getpageid
static class valuemarshaller extends variablemarshaller<list<joblocation>>
static valuemarshaller instance   new valuemarshaller
public list<joblocation> readpayload datainput datain  throws ioexception
list<joblocation> result   new arraylist<joblocation>
int size   datain readint
for  int i   0  i < size  i
joblocation joblocation   new joblocation
joblocation readexternal datain
result add joblocation
return result
public void writepayload list<joblocation> value  dataoutput dataout  throws ioexception
dataout writeint value size
for  joblocation joblocation   value
joblocation writeexternal dataout
static class scheduletime
private final int default_wait   500
private final int default_new_job_wait   100
private boolean newjob
private long waittime   default_wait
private final object mutex   new object
/**
* @return the waittime
*/
long getwaittime
return this waittime
/**
* @param waittime
*            the waittime to set
*/
void setwaittime long waittime
if   this newjob
this waittime   waittime > 0 ? waittime   default_wait
void pause
synchronized  mutex
try
mutex wait this waittime
catch  interruptedexception e
void newjob
this newjob   true
this waittime   default_new_job_wait
wakeup
void clearnewjob
this newjob   false
void wakeup
synchronized  this mutex
mutex notifyall