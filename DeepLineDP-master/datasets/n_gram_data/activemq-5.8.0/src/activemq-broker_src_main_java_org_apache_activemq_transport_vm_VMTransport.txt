/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport vm
import java io ioexception
import java io interruptedioexception
import java net uri
import java util concurrent blockingqueue
import java util concurrent linkedblockingqueue
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomiclong
import org apache activemq command shutdowninfo
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq transport futureresponse
import org apache activemq transport responsecallback
import org apache activemq transport transport
import org apache activemq transport transportdisposedioexception
import org apache activemq transport transportlistener
/**
* a transport implementation that uses direct method invocations.
*/
public class vmtransport implements transport  task
private static final object disconnect   new object
private static final atomiclong next_id   new atomiclong 0
// transport configuration
protected vmtransport peer
protected transportlistener transportlistener
protected boolean marshal
protected boolean network
protected boolean async   true
protected int asyncqueuedepth   2000
protected final uri location
protected final long id
// implementation
private linkedblockingqueue<object> messagequeue
private taskrunnerfactory taskrunnerfactory
private taskrunner taskrunner
// transport state
protected final atomicboolean started   new atomicboolean
protected final atomicboolean disposed   new atomicboolean
private volatile int receivecounter
public vmtransport uri location
this location   location
this id   next_id getandincrement
public void setpeer vmtransport peer
this peer   peer
public void oneway object command  throws ioexception
if  disposed get
throw new transportdisposedioexception
if  peer    null
throw new ioexception
try
if  peer disposed get
throw new transportdisposedioexception     peer tostring
if  peer async     peer started get
peer getmessagequeue   put command
peer wakeup
return
catch  interruptedexception e
interruptedioexception iioe   new interruptedioexception e getmessage
iioe initcause e
throw iioe
dispatch peer  peer messagequeue  command
public void dispatch vmtransport transport  blockingqueue<object> pending  object command
transportlistener transportlistener   transport gettransportlistener
if  transportlistener    null
// lock here on the target transport's started since we want to wait for its start()
// method to finish dispatching out of the queue before we do our own.
synchronized  transport started
// ensure that no additional commands entered the queue in the small time window
// before the start method locks the dispatch lock and the oneway method was in
// an put operation.
while pending    null     pending isempty       transport isdisposed
dodispatch transport  transportlistener  pending poll
// we are now in sync mode and won't enqueue any more commands to the target
// transport so lets clean up its resources.
transport messagequeue   null
// don't dispatch if either end was disposed already.
if  command    null     this disposed get       transport isdisposed
dodispatch transport  transportlistener  command
public void dodispatch vmtransport transport  transportlistener transportlistener  object command
if  command    disconnect
transportlistener onexception new transportdisposedioexception     peer tostring
else
transport receivecounter
transportlistener oncommand command
public void start   throws exception
if  transportlistener    null
throw new ioexception
// if we are not in async mode we lock the dispatch lock here and then start to
// prevent any sync dispatches from occurring until we dispatch the pending messages
// to maintain delivery order.  when async this happens automatically so just set
// started and wakeup the task runner.
if   async
synchronized  started
if  started compareandset false  true
linkedblockingqueue<object> mq   getmessagequeue
object command
while   command   mq poll       null     disposed get
receivecounter
dodispatch this  transportlistener  command
else
if  started compareandset false  true
wakeup
public void stop   throws exception
// only need to do this once, all future oneway calls will now
// fail as will any asnyc jobs in the task runner.
if  disposed compareandset false  true
taskrunner tr   taskrunner
linkedblockingqueue<object> mq   this messagequeue
taskrunner   null
messagequeue   null
if  mq    null
mq clear
// allow pending deliveries to finish up, but don't wait
// forever in case of an stalled oncommand.
if  tr    null
try
tr shutdown timeunit seconds tomillis 1
catch exception e
taskrunner   null
// let the peer know that we are disconnecting after attempting
// to cleanly shutdown the async tasks so that this is the last
// command it see's.
try
peer transportlistener oncommand new shutdowninfo
catch  exception ignore
// shutdown task runner factory
if  taskrunnerfactory    null
taskrunnerfactory shutdownnow
taskrunnerfactory   null
protected void wakeup
if  async    started get
try
gettaskrunner   wakeup
catch  interruptedexception e
thread currentthread   interrupt
catch  transportdisposedioexception e
/**
* @see org.apache.activemq.thread.task#iterate()
*/
public boolean iterate
final transportlistener tl   transportlistener
linkedblockingqueue<object> mq
try
mq   getmessagequeue
catch  transportdisposedioexception e
return false
object command   mq poll
if  command    null     disposed get
if  command    disconnect
tl onexception new transportdisposedioexception     peer tostring
else
tl oncommand command
return  mq isempty       disposed get
else
if disposed get
mq clear
return false
public void settransportlistener transportlistener commandlistener
this transportlistener   commandlistener
public void setmessagequeue linkedblockingqueue<object> asyncqueue
synchronized  this
if  messagequeue    null
messagequeue   asyncqueue
public linkedblockingqueue<object> getmessagequeue   throws transportdisposedioexception
linkedblockingqueue<object> result   messagequeue
if  result    null
synchronized  this
result   messagequeue
if  result    null
if  disposed get
throw new transportdisposedioexception
messagequeue   result   new linkedblockingqueue<object> this asyncqueuedepth
return result
protected taskrunner gettaskrunner   throws transportdisposedioexception
taskrunner result   taskrunner
if  result    null
synchronized  this
result   taskrunner
if  result    null
if  disposed get
throw new transportdisposedioexception
string name       tostring
if  taskrunnerfactory    null
taskrunnerfactory   new taskrunnerfactory name
taskrunnerfactory init
taskrunner   result   taskrunnerfactory createtaskrunner this  name
return result
public futureresponse asyncrequest object command  responsecallback responsecallback  throws ioexception
throw new assertionerror
public object request object command  throws ioexception
throw new assertionerror
public object request object command  int timeout  throws ioexception
throw new assertionerror
public transportlistener gettransportlistener
return transportlistener
public <t> t narrow class<t> target
if  target isassignablefrom getclass
return target cast this
return null
public boolean ismarshal
return marshal
public void setmarshal boolean marshal
this marshal   marshal
public boolean isnetwork
return network
public void setnetwork boolean network
this network   network
@override
public string tostring
return location       id
public string getremoteaddress
if  peer    null
return peer tostring
return null
/**
* @return the async
*/
public boolean isasync
return async
/**
* @param async the async to set
*/
public void setasync boolean async
this async   async
/**
* @return the asyncqueuedepth
*/
public int getasyncqueuedepth
return asyncqueuedepth
/**
* @param asyncqueuedepth the asyncqueuedepth to set
*/
public void setasyncqueuedepth int asyncqueuedepth
this asyncqueuedepth   asyncqueuedepth
public boolean isfaulttolerant
return false
public boolean isdisposed
return disposed get
public boolean isconnected
return  disposed get
public void reconnect uri uri  throws ioexception
throw new ioexception
public boolean isreconnectsupported
return false
public boolean isupdateurissupported
return false
public void updateuris boolean reblance uri uris  throws ioexception
throw new ioexception
public int getreceivecounter
return receivecounter