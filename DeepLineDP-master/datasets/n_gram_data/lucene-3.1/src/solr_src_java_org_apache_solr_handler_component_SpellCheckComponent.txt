/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache solr handler component
import java io ioexception
import java io stringreader
import java util
import java util concurrent concurrenthashmap
import org apache lucene search spell levensteindistance
import org apache lucene search spell stringdistance
import org apache lucene search spell suggestword
import org apache lucene search spell suggestwordqueue
import org apache solr client solrj response spellcheckresponse
import org apache solr common params modifiablesolrparams
import org slf4j logger
import org slf4j loggerfactory
import org apache lucene analysis analyzer
import org apache lucene analysis token
import org apache lucene analysis tokenstream
import org apache lucene analysis whitespaceanalyzer
import org apache lucene analysis tokenattributes flagsattribute
import org apache lucene analysis tokenattributes offsetattribute
import org apache lucene analysis tokenattributes payloadattribute
import org apache lucene analysis tokenattributes positionincrementattribute
import org apache lucene analysis tokenattributes chartermattribute
import org apache lucene analysis tokenattributes typeattribute
import org apache lucene index indexreader
import org apache solr common solrexception
import org apache solr common params commonparams
import org apache solr common params shardparams
import org apache solr common params solrparams
import org apache solr common params spellingparams
import org apache solr common util namedlist
import org apache solr common util simpleorderedmap
import org apache solr core solrcore
import org apache solr core solreventlistener
import org apache solr core solrresourceloader
import org apache solr schema fieldtype
import org apache solr schema indexschema
import org apache solr search solrindexsearcher
import org apache solr spelling
import org apache solr util plugin solrcoreaware
/**
* a searchcomponent implementation which provides support for spell checking
* and suggestions using the lucene contributed spellchecker.
*
* <p>
* refer to http://wiki.apache.org/solr/spellcheckcomponent for more details
* </p>
*
* @since solr 1.3
*/
public class spellcheckcomponent extends searchcomponent implements solrcoreaware  spellingparams
private static final logger log   loggerfactory getlogger spellcheckcomponent class
public static final boolean default_only_more_popular   false
/**
* base name for all spell checker query parameters. this name is also used to
* register this component with searchhandler.
*/
public static final string component_name
@suppresswarnings
protected namedlist initparams
/**
* key is the dictionary, value is the spellchecker for that dictionary name
*/
protected map<string  solrspellchecker> spellcheckers   new concurrenthashmap<string  solrspellchecker>
protected queryconverter queryconverter
@override
@suppresswarnings
public void init namedlist args
super init args
this initparams   args
@override
@suppresswarnings
public void prepare responsebuilder rb  throws ioexception
solrparams params   rb req getparams
if   params getbool component_name  false
return
solrspellchecker spellchecker   getspellchecker params
if  params getbool spellcheck_build  false
spellchecker build rb req getcore    rb req getsearcher
rb rsp add
else if  params getbool spellcheck_reload  false
spellchecker reload rb req getcore    rb req getsearcher
rb rsp add
@override
@suppresswarnings
public void process responsebuilder rb  throws ioexception
solrparams params   rb req getparams
if   params getbool component_name  false     spellcheckers isempty
return
boolean shardrequest     equals params get shardparams is_shard
string q   params get spellcheck_q
solrspellchecker spellchecker   getspellchecker params
collection<token> tokens   null
if  q    null
//we have a spell check param, tokenize it with the query analyzer applicable for this spellchecker
tokens   gettokens q  spellchecker getqueryanalyzer
else
q   rb getquerystring
if  q    null
q   params get commonparams q
tokens   queryconverter convert q
if  tokens    null    tokens isempty      false
if  spellchecker    null
int count   params getint spellcheck_count  1
boolean onlymorepopular   params getbool spellcheck_only_more_popular
default_only_more_popular
boolean extendedresults   params getbool spellcheck_extended_results
false
namedlist response   new simpleorderedmap
indexreader reader   rb req getsearcher   getreader
boolean collate   params getbool spellcheck_collate  false
float accuracy   params getfloat spellcheck_accuracy  float min_value
solrparams customparams   getcustomparams getdictionaryname params   params  shardrequest
spellingoptions options   new spellingoptions tokens  reader  count  onlymorepopular  extendedresults
accuracy  customparams
spellingresult spellingresult   spellchecker getsuggestions options
if  spellingresult    null
namedlist suggestions   tonamedlist shardrequest  spellingresult  q  extendedresults  collate
if  collate
addcollationstoresponse params  spellingresult  rb  q  suggestions
response add    suggestions
rb rsp add    response
else
throw new solrexception solrexception errorcode not_found
@suppresswarnings
protected void addcollationstoresponse solrparams params  spellingresult spellingresult  responsebuilder rb  string q
namedlist response
int maxcollations   params getint spellcheck_max_collations  1
int maxcollationtries   params getint spellcheck_max_collation_tries  0
boolean collationextendedresults   params getbool spellcheck_collate_extended_results  false
boolean shard   params getbool shardparams is_shard  false
spellcheckcollator collator   new spellcheckcollator
list<spellcheckcollation> collations   collator collate spellingresult  q  rb  maxcollations  maxcollationtries
//by sorting here we guarantee a non-distributed request returns all
//results in the same order as a distributed request would,
//even in cases when the internal rank is the same.
collections sort collations
for  spellcheckcollation collation   collations
if  collationextendedresults
namedlist extendedresult   new namedlist
extendedresult add    collation getcollationquery
extendedresult add    collation gethits
extendedresult add    collation getmisspellingsandcorrections
if maxcollationtries>0    shard
extendedresult add    collation getinternalrank
response add    extendedresult
else
response add    collation getcollationquery
if maxcollationtries>0    shard
response add    collation getinternalrank
/**
* for every param that is of the form "spellcheck.[dictionary name].xxxx=yyyy, add
* xxxx=yyyy as a param to the custom param list
* @param params the original solrparams
* @return the new params
*/
protected solrparams getcustomparams string dictionary  solrparams params  boolean shardrequest
modifiablesolrparams result   new modifiablesolrparams
iterator<string> iter   params getparameternamesiterator
string prefix   spellingparams spellcheck_prefix       dictionary
while  iter hasnext
string nxt   iter next
if  nxt startswith prefix
result add nxt substring prefix length     params getparams nxt
if shardrequest
result add shardparams is_shard
return result
@override
public void modifyrequest responsebuilder rb  searchcomponent who  shardrequest sreq
solrparams params   rb req getparams
// turn on spellcheck only only when retrieving fields
if   params getbool component_name  false   return
if   sreq purpose   shardrequest purpose_get_top_ids     0
// fetch at least 5 suggestions from each shard
int count   sreq params getint spellcheck_count  1
if  count < 5   count   5
sreq params set spellcheck_count  count
sreq params set
else
sreq params set
@override
@suppresswarnings
public void finishstage responsebuilder rb
solrparams params   rb req getparams
if   params getbool component_name  false     rb stage    responsebuilder stage_get_fields
return
boolean extendedresults   params getbool spellcheck_extended_results  false
boolean collate   params getbool spellcheck_collate  false
boolean collationextendedresults   params getbool spellcheck_collate_extended_results  false
int maxcollationtries   params getint spellcheck_max_collation_tries  0
int maxcollations   params getint spellcheck_max_collations  1
string origquery   params get spellcheck_q
if  origquery    null
origquery   rb getquerystring
if  origquery    null
origquery   params get commonparams q
int count   rb req getparams   getint spellcheck_count  1
float min   0 5f
stringdistance sd   null
int numsug   math max count  abstractlucenespellchecker default_suggestion_count
solrspellchecker checker   getspellchecker rb req getparams
if  checker instanceof abstractlucenespellchecker
abstractlucenespellchecker spellchecker    abstractlucenespellchecker  checker
min   spellchecker getaccuracy
sd   spellchecker getstringdistance
if  sd    null
sd   new levensteindistance
collection<token> tokens   null
try
tokens   gettokens origquery  checker getqueryanalyzer
catch  ioexception e
log error    e
// original token -> corresponding suggestion object (keep track of start,end)
map<string  spellcheckresponse suggestion> origvssuggestion   new hashmap<string  spellcheckresponse suggestion>
// original token string -> summed up frequency
map<string  integer> origvsfreq   new hashmap<string  integer>
// original token string -> # of shards reporting it as misspelled
map<string  integer> origvsshards   new hashmap<string  integer>
// original token string -> set of alternatives
// must preserve order because collation algorithm can only work in-order
map<string  hashset<string>> origvssuggested   new linkedhashmap<string  hashset<string>>
// alternative string -> corresponding suggestword object
map<string  suggestword> suggestedvsword   new hashmap<string  suggestword>
map<string  spellcheckcollation> collations   new hashmap<string  spellcheckcollation>
int totalnumbershardresponses   0
for  shardrequest sreq   rb finished
for  shardresponse srsp   sreq responses
namedlist nl    namedlist  srsp getsolrresponse   getresponse   get
log info srsp getshard         nl
if  nl    null
totalnumbershardresponses
spellcheckresponse spellcheckresp   new spellcheckresponse nl
for  spellcheckresponse suggestion suggestion   spellcheckresp getsuggestions
origvssuggestion put suggestion gettoken    suggestion
hashset<string> suggested   origvssuggested get suggestion gettoken
if  suggested    null
suggested   new hashset<string>
origvssuggested put suggestion gettoken    suggested
// sum up original frequency
int origfreq   0
integer o   origvsfreq get suggestion gettoken
if  o    null   origfreq    o
origfreq    suggestion getoriginalfrequency
origvsfreq put suggestion gettoken    origfreq
//# shards reporting
integer origshards   origvsshards get suggestion gettoken
if origshards  null
origvsshards put suggestion gettoken    1
else
origvsshards put suggestion gettoken      origshards
// find best suggestions
for  int i   0  i < suggestion getnumfound    i
string alternative   suggestion getalternatives   get i
suggested add alternative
suggestword sug   suggestedvsword get alternative
if  sug    null
sug   new suggestword
suggestedvsword put alternative  sug
sug string   alternative
// alternative frequency is present only for extendedresults=true
if  suggestion getalternativefrequencies      null    suggestion getalternativefrequencies   size   > 0
integer freq   suggestion getalternativefrequencies   get i
if  freq    null  sug freq    freq
namedlist suggestions    namedlist  nl get
if suggestions    null
list<object> collationlist   suggestions getall
list<object> collationranklist   suggestions getall
int i 0
if collationlist    null
for object o   collationlist
if o instanceof string
spellcheckcollation coll   new spellcheckcollation
coll setcollationquery  string  o
if collationranklist   null    collationranklist size  >0
coll setinternalrank  integer  collationranklist get i
i
spellcheckcollation priorcoll   collations get coll getcollationquery
if priorcoll    null
coll setinternalrank math max coll getinternalrank   priorcoll getinternalrank
collations put coll getcollationquery    coll
else
namedlist expandedcollation    namedlist  o
spellcheckcollation coll   new spellcheckcollation
coll setcollationquery  string  expandedcollation get
coll sethits  integer  expandedcollation get
if maxcollationtries>0
coll setinternalrank  integer  expandedcollation get
coll setmisspellingsandcorrections  namedlist  expandedcollation get
spellcheckcollation priorcoll   collations get coll getcollationquery
if priorcoll    null
coll sethits coll gethits     priorcoll gethits
coll setinternalrank math max coll getinternalrank   priorcoll getinternalrank
collations put coll getcollationquery    coll
// all shard responses have been collected
// create token and get top suggestions
spellingresult result   new spellingresult tokens     todo  investigate  why does it need tokens beforehand?
for  map entry<string  hashset<string>> entry   origvssuggested entryset
string original   entry getkey
//only use this suggestion if all shards reported it as misspelled.
integer numshards   origvsshards get original
if numshards<totalnumbershardresponses
continue
hashset<string> suggested   entry getvalue
suggestwordqueue sugqueue   new suggestwordqueue numsug
for  string suggestion   suggested
suggestword sug   suggestedvsword get suggestion
sug score   sd getdistance original  sug string
if  sug score < min  continue
sugqueue insertwithoverflow sug
if  sugqueue size      numsug
// if queue full, maintain the minscore score
min   sugqueue top   score
// create token
spellcheckresponse suggestion suggestion   origvssuggestion get original
token token   new token original  suggestion getstartoffset    suggestion getendoffset
// get top 'count' suggestions out of 'sugqueue.size()' candidates
suggestword suggestions   new suggestword
// skip the first sugqueue.size() - count elements
for  int k 0  k < sugqueue size     count  k    sugqueue pop
// now collect the top 'count' responses
for  int k   math min count  sugqueue size      1  k >  0  k
suggestions   sugqueue pop
if  extendedresults
integer o   origvsfreq get original
if  o    null  result add token  o
for  suggestword word   suggestions
result add token  word string  word freq
else
list<string> words   new arraylist<string> sugqueue size
for  suggestword word   suggestions  words add word string
result add token  words
namedlist response   new simpleorderedmap
namedlist suggestions   tonamedlist false  result  origquery  extendedresults  collate
if  collate
spellcheckcollation sortedcollations   collations values   toarray new spellcheckcollation
arrays sort sortedcollations
int i   0
while  i < maxcollations    i < sortedcollations length
spellcheckcollation collation   sortedcollations
i
if  collationextendedresults
namedlist extendedresult   new namedlist
extendedresult add    collation getcollationquery
extendedresult add    collation gethits
extendedresult add    collation
getmisspellingsandcorrections
suggestions add    extendedresult
else
suggestions add    collation getcollationquery
response add    suggestions
rb rsp add    response
private collection<token> gettokens string q  analyzer analyzer  throws ioexception
collection<token> result   new arraylist<token>
tokenstream ts   analyzer reusabletokenstream    new stringreader q
ts reset
// todo: support custom attributes
chartermattribute termatt   ts addattribute chartermattribute class
offsetattribute offsetatt   ts addattribute offsetattribute class
typeattribute typeatt   ts addattribute typeattribute class
flagsattribute flagsatt   ts addattribute flagsattribute class
payloadattribute payloadatt   ts addattribute payloadattribute class
positionincrementattribute posincatt   ts addattribute positionincrementattribute class
while  ts incrementtoken
token token   new token
token copybuffer termatt buffer    0  termatt length
token setoffset offsetatt startoffset    offsetatt endoffset
token settype typeatt type
token setflags flagsatt getflags
token setpayload payloadatt getpayload
token setpositionincrement posincatt getpositionincrement
result add token
return result
protected solrspellchecker getspellchecker solrparams params
return spellcheckers get getdictionaryname params
private string getdictionaryname solrparams params
string dictname   params get spellcheck_dict
if  dictname    null
dictname   solrspellchecker default_dictionary_name
return dictname
/**
* @return the spellchecker registered to a given name
*/
public solrspellchecker getspellchecker string name
return spellcheckers get name
protected namedlist tonamedlist boolean shardrequest  spellingresult spellingresult  string origquery  boolean extendedresults  boolean collate
namedlist result   new namedlist
map<token  linkedhashmap<string  integer>> suggestions   spellingresult getsuggestions
boolean hasfreqinfo   spellingresult hastokenfrequencyinfo
boolean iscorrectlyspelled   false
int numsuggestions   0
for linkedhashmap<string  integer> thesuggestion   suggestions values
if thesuggestion size  >0
numsuggestions
// will be flipped to false if any of the suggestions are not in the index and hasfreqinfo is true
if numsuggestions > 0
iscorrectlyspelled   true
for  map entry<token  linkedhashmap<string  integer>> entry   suggestions entryset
token inputtoken   entry getkey
map<string  integer> thesuggestions   entry getvalue
if  thesuggestions    null     thesuggestions size  >0    shardrequest
simpleorderedmap suggestionlist   new simpleorderedmap
suggestionlist add    thesuggestions size
suggestionlist add    inputtoken startoffset
suggestionlist add    inputtoken endoffset
// logical structure of normal (non-extended) results:
// "suggestion":["alt1","alt2"]
//
// logical structure of the extended results:
// "suggestion":[
//     {"word":"alt1","freq":7},
//     {"word":"alt2","freq":4}
// ]
if  extendedresults    hasfreqinfo
suggestionlist add    spellingresult gettokenfrequency inputtoken
arraylist<simpleorderedmap> sugs   new arraylist<simpleorderedmap>
suggestionlist add    sugs
for  map entry<string  integer> suggentry   thesuggestions entryset
simpleorderedmap sugentry   new simpleorderedmap
sugentry add   suggentry getkey
sugentry add   suggentry getvalue
sugs add sugentry
else
suggestionlist add    thesuggestions keyset
if  hasfreqinfo
iscorrectlyspelled   iscorrectlyspelled    spellingresult gettokenfrequency inputtoken  > 0
result add new string inputtoken buffer    0  inputtoken length     suggestionlist
if  hasfreqinfo
result add    iscorrectlyspelled
else if extendedresults    suggestions size      0       if the word is misspelled  its added to suggestions with freqinfo
result add    true
return result
public void inform solrcore core
if  initparams    null
log info
boolean hasdefault   false
for  int i   0  i < initparams size    i
if  initparams getname i  equals
namedlist spellchecker    namedlist  initparams getval i
string classname    string  spellchecker get
if  classname    null
classname   indexbasedspellchecker class getname
solrresourceloader loader   core getresourceloader
solrspellchecker checker    solrspellchecker  loader newinstance classname
if  checker    null
string dictionary   checker init spellchecker  core
if  dictionary    null
boolean isdefault   dictionary equals solrspellchecker default_dictionary_name
if  isdefault    true    hasdefault    false
hasdefault   true
else if  isdefault    true    hasdefault    true
throw new runtimeexception
spellcheckers put dictionary  checker
else
if  hasdefault    false
spellcheckers put solrspellchecker default_dictionary_name  checker
hasdefault   true
else
throw new runtimeexception
// register event listeners for this spellchecker
core registerfirstsearcherlistener new spellcheckerlistener core  checker  false  false
boolean buildoncommit   boolean parseboolean  string  spellchecker get
boolean buildonoptimize   boolean parseboolean  string  spellchecker get
if  buildoncommit    buildonoptimize
log info     checker getdictionaryname
core registernewsearcherlistener new spellcheckerlistener core  checker  buildoncommit  buildonoptimize
else
throw new runtimeexception     classname
map<string  queryconverter> queryconverters   new hashmap<string  queryconverter>
core initplugins queryconverters queryconverter class
//ensure that there is at least one query converter defined
if  queryconverters size      0
log warn
queryconverters put    new spellingqueryconverter
//there should only be one
if  queryconverters size      1
queryconverter   queryconverters values   iterator   next
indexschema schema   core getschema
string fieldtypename    string  initparams get
fieldtype fieldtype   schema getfieldtypes   get fieldtypename
analyzer analyzer   fieldtype    null ? new whitespaceanalyzer core getsolrconfig   lucenematchversion
fieldtype getqueryanalyzer
//todo: there's got to be a better way!  where's spring when you need it?
queryconverter setanalyzer analyzer
private static class spellcheckerlistener implements solreventlistener
private final solrcore core
private final solrspellchecker checker
private final boolean buildoncommit
private final boolean buildonoptimize
public spellcheckerlistener solrcore core  solrspellchecker checker  boolean buildoncommit  boolean buildonoptimize
this core   core
this checker   checker
this buildoncommit   buildoncommit
this buildonoptimize   buildonoptimize
public void init namedlist args
public void newsearcher solrindexsearcher newsearcher
solrindexsearcher currentsearcher
if  currentsearcher    null
// firstsearcher event
try
log info
checker getdictionaryname
checker reload core  newsearcher
catch  ioexception e
log error      checker getdictionaryname    e
else
// newsearcher event
if  buildoncommit
buildspellindex newsearcher
else if  buildonoptimize
if  newsearcher getreader   isoptimized
buildspellindex newsearcher
else
log info     checker getdictionaryname
private void buildspellindex solrindexsearcher newsearcher
try
log info     checker getdictionaryname
checker build core  newsearcher
catch  exception e
log error
checker getdictionaryname    e
public void postcommit
public map<string  solrspellchecker> getspellcheckers
return collections unmodifiablemap spellcheckers
// ///////////////////////////////////////////
// / solrinfombean
// //////////////////////////////////////////
@override
public string getdescription
return
@override
public string getversion
return
@override
public string getsourceid
return
@override
public string getsource
return