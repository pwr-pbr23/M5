package org apache lucene util
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java lang ref weakreference
import java util collections
import java util nosuchelementexception
import java util iterator
import java util linkedhashmap
import java util weakhashmap
import java util linkedlist
import java util map
import java util map entry
import org apache lucene analysis tokenstream     for javadocs
import org apache lucene analysis tokenattributes termattribute
import org apache lucene analysis tokenattributes chartermattributeimpl
/**
* an attributesource contains a list of different {@link attributeimpl}s,
* and methods to add and get them. there can only be a single instance
* of an attribute in the same attributesource instance. this is ensured
* by passing in the actual type of the attribute (class&lt;attribute&gt;) to
* the {@link #addattribute(class)}, which then checks if an instance of
* that type is already present. if yes, it returns the instance, otherwise
* it creates a new instance and returns it.
*/
public class attributesource
/**
* an attributefactory creates instances of {@link attributeimpl}s.
*/
public static abstract class attributefactory
/**
* returns an {@link attributeimpl} for the supplied {@link attribute} interface class.
*/
public abstract attributeimpl createattributeinstance class<? extends attribute> attclass
/**
* this is the default factory that creates {@link attributeimpl}s using the
* class name of the supplied {@link attribute} interface class by appending <code>impl</code> to it.
*/
public static final attributefactory default_attribute_factory   new defaultattributefactory
private static final class defaultattributefactory extends attributefactory
private static final weakhashmap<class<? extends attribute>  weakreference<class<? extends attributeimpl>>> attclassimplmap
new weakhashmap<class<? extends attribute>  weakreference<class<? extends attributeimpl>>>
private defaultattributefactory
@override
public attributeimpl createattributeinstance class<? extends attribute> attclass
try
return getclassforinterface attclass  newinstance
catch  instantiationexception e
throw new illegalargumentexception     attclass getname
catch  illegalaccessexception e
throw new illegalargumentexception     attclass getname
private static class<? extends attributeimpl> getclassforinterface class<? extends attribute> attclass
synchronized attclassimplmap
final weakreference<class<? extends attributeimpl>> ref   attclassimplmap get attclass
class<? extends attributeimpl> clazz    ref    null  ? null   ref get
if  clazz    null
try
// todo: remove when termattribute is removed!
// this is a "sophisticated backwards compatibility hack"
// (enforce new impl for this deprecated att):
if  termattribute class equals attclass
clazz   chartermattributeimpl class
else
clazz   class forname attclass getname        true  attclass getclassloader
assubclass attributeimpl class
attclassimplmap put attclass
new weakreference<class<? extends attributeimpl>> clazz
catch  classnotfoundexception e
throw new illegalargumentexception     attclass getname
return clazz
// these two maps must always be in sync!!!
// so they are private, final and read-only from the outside (read-only iterators)
private final map<class<? extends attribute>  attributeimpl> attributes
private final map<class<? extends attributeimpl>  attributeimpl> attributeimpls
private attributefactory factory
/**
* an attributesource using the default attribute factory {@link attributesource.attributefactory#default_attribute_factory}.
*/
public attributesource
this attributefactory default_attribute_factory
/**
* an attributesource that uses the same attributes as the supplied one.
*/
public attributesource attributesource input
if  input    null
throw new illegalargumentexception
this attributes   input attributes
this attributeimpls   input attributeimpls
this factory   input factory
/**
* an attributesource using the supplied {@link attributefactory} for creating new {@link attribute} instances.
*/
public attributesource attributefactory factory
this attributes   new linkedhashmap<class<? extends attribute>  attributeimpl>
this attributeimpls   new linkedhashmap<class<? extends attributeimpl>  attributeimpl>
this factory   factory
/**
* returns the used attributefactory.
*/
public attributefactory getattributefactory
return this factory
/** returns a new iterator that iterates the attribute classes
* in the same order they were added in.
*/
public iterator<class<? extends attribute>> getattributeclassesiterator
return collections unmodifiableset attributes keyset    iterator
/** returns a new iterator that iterates all unique attribute implementations.
* this iterator may contain less entries that {@link #getattributeclassesiterator},
* if one instance implements more than one attribute interface.
*/
public iterator<attributeimpl> getattributeimplsiterator
if  hasattributes
if  currentstate    null
computecurrentstate
final state initstate   currentstate
return new iterator<attributeimpl>
private state state   initstate
public void remove
throw new unsupportedoperationexception
public attributeimpl next
if  state    null
throw new nosuchelementexception
final attributeimpl att   state attribute
state   state next
return att
public boolean hasnext
return state    null
else
return collections <attributeimpl>emptyset   iterator
/** a cache that stores all interfaces for known implementation classes for performance (slow reflection) */
private static final weakhashmap<class<? extends attributeimpl> linkedlist<weakreference<class<? extends attribute>>>> knownimplclasses
new weakhashmap<class<? extends attributeimpl> linkedlist<weakreference<class<? extends attribute>>>>
static linkedlist<weakreference<class<? extends attribute>>> getattributeinterfaces final class<? extends attributeimpl> clazz
synchronized knownimplclasses
linkedlist<weakreference<class<? extends attribute>>> foundinterfaces   knownimplclasses get clazz
if  foundinterfaces    null
// we have a strong reference to the class instance holding all interfaces in the list (parameter "att"),
// so all weakreferences are never evicted by gc
knownimplclasses put clazz  foundinterfaces   new linkedlist<weakreference<class<? extends attribute>>>
// find all interfaces that this attribute instance implements
// and that extend the attribute interface
class<?> actclazz   clazz
do
for  class<?> curinterface   actclazz getinterfaces
if  curinterface    attribute class    attribute class isassignablefrom curinterface
foundinterfaces add new weakreference<class<? extends attribute>> curinterface assubclass attribute class
actclazz   actclazz getsuperclass
while  actclazz    null
return foundinterfaces
/** <b>expert:</b> adds a custom attributeimpl instance with one or more attribute interfaces.
* <p><font color="red"><b>please note:</b> it is not guaranteed, that <code>att</code> is added to
* the <code>attributesource</code>, because the provided attributes may already exist.
* you should always retrieve the wanted attributes using {@link #getattribute} after adding
* with this method and cast to your class.
* the recommended way to use custom implementations is using an {@link attributefactory}.
* </font></p>
*/
public void addattributeimpl final attributeimpl att
final class<? extends attributeimpl> clazz   att getclass
if  attributeimpls containskey clazz   return
final linkedlist<weakreference<class<? extends attribute>>> foundinterfaces
getattributeinterfaces clazz
// add all interfaces of this attributeimpl to the maps
for  weakreference<class<? extends attribute>> curinterfaceref   foundinterfaces
final class<? extends attribute> curinterface   curinterfaceref get
assert  curinterface    null
// attribute is a superclass of this interface
if   attributes containskey curinterface
// invalidate state to force recomputation in capturestate()
this currentstate   null
attributes put curinterface  att
attributeimpls put clazz  att
/**
* the caller must pass in a class&lt;? extends attribute&gt; value.
* this method first checks if an instance of that class is
* already in this attributesource and returns it. otherwise a
* new instance is created, added to this attributesource and returned.
*/
public <a extends attribute> a addattribute class<a> attclass
attributeimpl attimpl   attributes get attclass
if  attimpl    null
if    attclass isinterface      attribute class isassignablefrom attclass
throw new illegalargumentexception
attclass getname
addattributeimpl attimpl   this factory createattributeinstance attclass
return attclass cast attimpl
/** returns true, iff this attributesource has any attributes */
public boolean hasattributes
return  this attributes isempty
/**
* the caller must pass in a class&lt;? extends attribute&gt; value.
* returns true, iff this attributesource contains the passed-in attribute.
*/
public boolean hasattribute class<? extends attribute> attclass
return this attributes containskey attclass
/**
* the caller must pass in a class&lt;? extends attribute&gt; value.
* returns the instance of the passed in attribute contained in this attributesource
*
* @throws illegalargumentexception if this attributesource does not contain the
*         attribute. it is recommended to always use {@link #addattribute} even in consumers
*         of tokenstreams, because you cannot know if a specific tokenstream really uses
*         a specific attribute. {@link #addattribute} will automatically make the attribute
*         available. if you want to only use the attribute, if it is available (to optimize
*         consuming), use {@link #hasattribute}.
*/
public <a extends attribute> a getattribute class<a> attclass
attributeimpl attimpl   attributes get attclass
if  attimpl    null
throw new illegalargumentexception     attclass getname
return attclass cast attimpl
/**
* this class holds the state of an attributesource.
* @see #capturestate
* @see #restorestate
*/
public static final class state implements cloneable
attributeimpl attribute
state next
@override
public object clone
state clone   new state
clone attribute    attributeimpl  attribute clone
if  next    null
clone next    state  next clone
return clone
private state currentstate   null
private void computecurrentstate
currentstate   new state
state c   currentstate
final iterator<attributeimpl> it   attributeimpls values   iterator
c attribute   it next
while  it hasnext
c next   new state
c   c next
c attribute   it next
/**
* resets all attributes in this attributesource by calling
* {@link attributeimpl#clear()} on each attribute implementation.
*/
public void clearattributes
if  hasattributes
if  currentstate    null
computecurrentstate
for  state state   currentstate  state    null  state   state next
state attribute clear
/**
* captures the state of all attributes. the return value can be passed to
* {@link #restorestate} to restore the state of this or another attributesource.
*/
public state capturestate
if   hasattributes
return null
if  currentstate    null
computecurrentstate
return  state  this currentstate clone
/**
* restores this state by copying the values of all attribute implementations
* that this state contains into the attributes implementations of the targetstream.
* the targetstream must contain a corresponding instance for each argument
* contained in this state (e.g. it is not possible to restore the state of
* an attributesource containing a termattribute into a attributesource using
* a token instance as implementation).
* <p>
* note that this method does not affect attributes of the targetstream
* that are not contained in this state. in other words, if for example
* the targetstream contains an offsetattribute, but this state doesn't, then
* the value of the offsetattribute remains unchanged. it might be desirable to
* reset its value to the default, in which case the caller should first
* call {@link tokenstream#clearattributes()} on the targetstream.
*/
public void restorestate state state
if  state    null   return
do
attributeimpl targetimpl   attributeimpls get state attribute getclass
if  targetimpl    null
throw new illegalargumentexception
state attribute getclass   getname
state attribute copyto targetimpl
state   state next
while  state    null
@override
public int hashcode
int code   0
if  hasattributes
if  currentstate    null
computecurrentstate
for  state state   currentstate  state    null  state   state next
code   code   31   state attribute hashcode
return code
@override
public boolean equals object obj
if  obj    this
return true
if  obj instanceof attributesource
attributesource other    attributesource  obj
if  hasattributes
if   other hasattributes
return false
if  this attributeimpls size      other attributeimpls size
return false
// it is only equal if all attribute impls are the same in the same order
if  this currentstate    null
this computecurrentstate
state thisstate   this currentstate
if  other currentstate    null
other computecurrentstate
state otherstate   other currentstate
while  thisstate    null    otherstate    null
if  otherstate attribute getclass      thisstate attribute getclass       otherstate attribute equals thisstate attribute
return false
thisstate   thisstate next
otherstate   otherstate next
return true
else
return  other hasattributes
else
return false
/**
* returns a string representation of the object. in general, the {@code tostring} method
* returns a string that &quot;textually represents&quot; this object.
*
* <p><b>warning:</b> for backwards compatibility this method is implemented as
* in lucene 2.9/3.0. in lucene 4.0 this default implementation
* will be removed.
*
* <p>it is recommeneded to use {@link #reflectasstring} or {@link #reflectwith}
* to get a well-defined output of attributesource's internals.
*/
// todo: @deprecated remove this method in 4.0
@override
public string tostring
final stringbuilder sb   new stringbuilder   append
if  hasattributes
if  currentstate    null
computecurrentstate
for  state state   currentstate  state    null  state   state next
if  state    currentstate  sb append
sb append state attribute tostring
return sb append    tostring
/**
* this method returns the current attribute values as a string in the following format
* by calling the {@link #reflectwith(attributereflector)} method:
*
* <ul>
* <li><em>iff {@code prependattclass=true}:</em> {@code "attributeclass#key=value,attributeclass#key=value"}
* <li><em>iff {@code prependattclass=false}:</em> {@code "key=value,key=value"}
* </ul>
*
* @see #reflectwith(attributereflector)
*/
public final string reflectasstring final boolean prependattclass
final stringbuilder buffer   new stringbuilder
reflectwith new attributereflector
public void reflect class<? extends attribute> attclass  string key  object value
if  buffer length   > 0
buffer append
if  prependattclass
buffer append attclass getname    append
buffer append key  append    append  value    null  ?     value
return buffer tostring
/**
* this method is for introspection of attributes, it should simply
* add the key/values this attributesource holds to the given {@link attributereflector}.
*
* <p>this method iterates over all attribute implementations and calls the
* corresponding {@link attributeimpl#reflectwith} method.</p>
*
* @see attributeimpl#reflectwith
*/
public final void reflectwith attributereflector reflector
if  hasattributes
if  currentstate    null
computecurrentstate
for  state state   currentstate  state    null  state   state next
state attribute reflectwith reflector
/**
* performs a clone of all {@link attributeimpl} instances returned in a new
* {@code attributesource} instance. this method can be used to e.g. create another tokenstream
* with exactly the same attributes (using {@link #attributesource(attributesource)}).
* you can also use it as a (non-performant) replacement for {@link #capturestate}, if you need to look
* into / modify the captured state.
*/
public attributesource cloneattributes
final attributesource clone   new attributesource this factory
if  hasattributes
// first clone the impls
if  currentstate    null
computecurrentstate
for  state state   currentstate  state    null  state   state next
clone attributeimpls put state attribute getclass     attributeimpl  state attribute clone
// now the interfaces
for  entry<class<? extends attribute>  attributeimpl> entry   this attributes entryset
clone attributes put entry getkey    clone attributeimpls get entry getvalue   getclass
return clone
/**
* copies the contents of this {@code attributesource} to the given target {@code attributesource}.
* the given instance has to provide all {@link attribute}s this instance contains.
* the actual attribute implementations must be identical in both {@code attributesource} instances;
* ideally both attributesource instances should use the same {@link attributefactory}.
* you can use this method as a replacement for {@link #restorestate}, if you use
* {@link #cloneattributes} instead of {@link #capturestate}.
*/
public final void copyto attributesource target
if  hasattributes
if  currentstate    null
computecurrentstate
for  state state   currentstate  state    null  state   state next
final attributeimpl targetimpl   target attributeimpls get state attribute getclass
if  targetimpl    null
throw new illegalargumentexception
state attribute getclass   getname
state attribute copyto targetimpl