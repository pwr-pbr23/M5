/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache solr search function
import org apache lucene index indexreader
import org apache lucene index termdocs
import org apache lucene index termenum
import org apache lucene index term
import org apache lucene util stringhelper
import org apache solr core solrcore
import org apache solr schema schemafield
import org apache solr schema fieldtype
import org apache solr search qparser
import org apache solr search solrindexreader
import org apache solr util versionedfile
import java io
import java util
/**
* obtains float field values from an external file.
* @version $id$
*/
public class filefloatsource extends valuesource
private schemafield field
private final schemafield keyfield
private final float defval
private final string datadir
public filefloatsource schemafield field  schemafield keyfield  float defval  qparser parser
this field   field
this keyfield   keyfield
this defval   defval
this datadir   parser getreq   getcore   getdatadir
}
@override
public string description
return     field
}
@override
public docvalues getvalues map context  indexreader reader  throws ioexception
int offset   0
if  reader instanceof solrindexreader
solrindexreader r    solrindexreader reader
while  r getparent      null
offset    r getbase
r   r getparent
}
reader   r
}
final int off   offset
final float arr   getcachedfloats reader
return new docvalues
@override
public float floatval int doc
return arr
}
@override
public int intval int doc
return  int arr
}
@override
public long longval int doc
return  long arr
}
@override
public double doubleval int doc
return  double arr
}
@override
public string strval int doc
return float tostring arr
}
@override
public string tostring int doc
return description         floatval doc
}
}
@override
public boolean equals object o
if  o getclass       filefloatsource class  return false
filefloatsource other    filefloatsource o
return this field getname   equals other field getname
this keyfield getname   equals other keyfield getname
this defval    other defval
this datadir equals other datadir
}
@override
public int hashcode
return filefloatsource class hashcode     field getname   hashcode
@override
public string tostring
return   field getname     keyfield getname
defval   datadir
}
private final float getcachedfloats indexreader reader
return  float floatcache get reader  new entry this
}
static cache floatcache   new cache
@override
protected object createvalue indexreader reader  object key
return getfloats   entry key  ffs  reader
}
/** internal cache. (from lucene fieldcache) */
abstract static class cache
private final map readercache   new weakhashmap
protected abstract object createvalue indexreader reader  object key
public object get indexreader reader  object key
map innercache
object value
synchronized  readercache
innercache    map  readercache get reader
if  innercache    null
innercache   new hashmap
readercache put reader  innercache
value   null
else
value   innercache get key
}
if  value    null
value   new creationplaceholder
innercache put key  value
}
}
if  value instanceof creationplaceholder
synchronized  value
creationplaceholder progress    creationplaceholder  value
if  progress value    null
progress value   createvalue reader  key
synchronized  readercache
innercache put key  progress value
onlyfortesting   progress value
}
}
return progress value
}
}
return value
}
}
static object onlyfortesting     set to the last value
static final class creationplaceholder
object value
}
/** expert: every composite-key in the internal cache is of this type. */
private static class entry
final filefloatsource ffs
public entry filefloatsource ffs
this ffs   ffs
}
@override
public boolean equals object o
if    o instanceof entry   return false
entry other    entry o
return ffs equals other ffs
}
@override
public int hashcode
return ffs hashcode
}
}
private static float getfloats filefloatsource ffs  indexreader reader
float vals   new float
if  ffs defval    0
arrays fill vals  ffs defval
}
inputstream is
string fname       ffs field getname
try
is   versionedfile getlatestfile ffs datadir  fname
catch  ioexception e
// log, use defaults
solrcore log error    e
return vals
}
bufferedreader r   new bufferedreader new inputstreamreader is
string idname   stringhelper intern ffs keyfield getname
fieldtype idtype   ffs keyfield gettype
boolean sorted true       assume sorted until we discover it's not
// warning: lucene's termenum.skipto() is not optimized... it simply does a next()
// because of this, simply ask the reader for a new termenum rather than
// trying to use skipto()
list<string> notfound   new arraylist<string>
int notfoundcount 0
int othererrors 0
termdocs termdocs   null
term prototerm   new term idname
termenum termenum   null
// number of times to try termenum.next() before resorting to skip
int numtimesnext   10
char delimiter
string termval
boolean hasnext true
string prevkey
string lastval
try
termdocs   reader termdocs
termenum   reader terms prototerm
term t   termenum term
if  t    null    t field      idname       intern'd comparison
termval   t text
else
termval   lastval
}
for  string line   line r readline     null
int delimindex   line indexof delimiter
if  delimindex < 0  continue
int endindex   line length
/* eols should already be removed for bufferedreader.readline()
for(int endindex = line.length();endindex>delimindex+1; endindex--) {
char ch = line.charat(endindex-1);
if (ch!='\n' && ch!='\r') break;
}
*/
string key   line substring 0  delimindex
string val   line substring delimindex 1  endindex
string internalkey   idtype tointernal key
float fval
try
fval float parsefloat val
catch  exception e
if    othererrors< 10
solrcore log error      e
othererrors<10 ?
}
continue      go to next line in file   leave values as default
}
if  sorted
// make sure this key is greater than the previous key
sorted   internalkey compareto prevkey  >  0
prevkey   internalkey
if  sorted
int countnext   0
for
int cmp   internalkey compareto termval
if  cmp    0
termdocs seek termenum
while  termdocs next
vals   fval
}
break
else if  cmp < 0
// term enum has already advanced past current key... we didn't find it.
if  notfoundcount<10        collect first 10 not found for logging
notfound add key
}
notfoundcount
break
else
// termenum is less than our current key, so skip ahead
// try next() a few times to see if we hit or pass the target.
// lucene's termenum.skipto() is currently unoptimized (it just does next())
// so the best thing is to simply ask the reader for a new termenum(target)
// if we really need to skip.
if    countnext > numtimesnext
termenum   reader terms prototerm createterm internalkey
t   termenum term
else
hasnext   termenum next
t   hasnext ? termenum term     null
}
if  t    null    t field      idname       intern'd comparison
termval   t text
else
termval   lastval
}
}
end for
}
}
if   sorted
termenum   reader terms prototerm createterm internalkey
t   termenum term
if  t    null    t field      idname     intern'd comparison
internalkey equals t text
termdocs seek  termenum
while  termdocs next
vals   fval
}
else
if  notfoundcount<10        collect first 10 not found for logging
notfound add key
}
notfoundcount
}
}
}
catch  ioexception e
// log, use defaults
solrcore log error    e
finally
// swallow exceptions on close so we don't override any
// exceptions that happened in the loop
if  termdocs  null  try termdocs close    catch exception e
if  termenum  null  try termenum close    catch exception e
try r close    catch exception e
}
solrcore log info     fname
notfoundcount  0 ?       notfoundcount   notfound
return vals
}
}