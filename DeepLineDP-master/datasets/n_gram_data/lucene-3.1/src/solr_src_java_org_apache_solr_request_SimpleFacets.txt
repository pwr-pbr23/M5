/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache solr request
import org apache lucene index term
import org apache lucene index termenum
import org apache lucene index indexreader
import org apache lucene index termdocs
import org apache lucene queryparser parseexception
import org apache lucene search
import org apache solr common solrexception
import org apache solr common params facetparams
import org apache solr common params requiredsolrparams
import org apache solr common params solrparams
import org apache solr common params commonparams
import org apache solr common params facetparams facetrangeother
import org apache solr common params facetparams facetrangeinclude
import org apache solr common util namedlist
import org apache solr common util simpleorderedmap
import org apache solr common util strutils
import org apache solr core solrcore
import org apache solr schema
import org apache solr search
import org apache solr util boundedtreeset
import org apache solr util datemathparser
import org apache solr handler component responsebuilder
import java io ioexception
import java util
/**
* a class that generates simple facet information for a request.
*
* more advanced facet implementations may compose or subclass this class
* to leverage any of it's functionality.
*/
public class simplefacets
/** the main set of documents all facet counts should be relative to */
protected docset docs
/** configuration params behavior should be driven by */
protected solrparams params
protected solrparams required
/** searcher to use for all calculations */
protected solrindexsearcher searcher
protected solrqueryrequest req
protected responsebuilder rb
protected simpleorderedmap facetresponse
public final date now   new date
// per-facet values
solrparams localparams     localparams on this particular facet command
string facetvalue          the field to or query to facet on  minus local params
docset base                the base docset for this particular facet
string key                 what name should the results be stored under
public simplefacets solrqueryrequest req
docset docs
solrparams params
this req docs params null
public simplefacets solrqueryrequest req
docset docs
solrparams params
responsebuilder rb
this req   req
this searcher   req getsearcher
this base   this docs   docs
this params   params
this required   new requiredsolrparams params
this rb   rb
void parseparams string type  string param  throws parseexception  ioexception
localparams   queryparsing getlocalparams param  req getparams
base   docs
facetvalue   param
key   param
if  localparams    null  return
// remove local params unless it's a query
if  type    facetparams facet_query
facetvalue   localparams get commonparams value
// reset set the default key now that localparams have been removed
key   facetvalue
// allow explicit set of the key
key   localparams get commonparams output_key  key
// figure out if we need a new base docset
string excludestr   localparams get commonparams exclude
if  excludestr    null  return
map tagmap    map req getcontext   get
if  tagmap    null    rb    null
list<string> excludetaglist   strutils splitsmart excludestr
identityhashmap<query boolean> excludeset   new identityhashmap<query boolean>
for  string excludetag   excludetaglist
object olst   tagmap get excludetag
// tagmap has entries of list<string,list<qparser>>, but subject to change in the future
if    olst instanceof collection   continue
for  object o    collection olst
if    o instanceof qparser   continue
qparser qp    qparser o
excludeset put qp getquery    boolean true
if  excludeset size      0  return
list<query> qlist   new arraylist<query>
// add the base query
if   excludeset containskey rb getquery
qlist add rb getquery
// add the filters
if  rb getfilters      null
for  query q   rb getfilters
if   excludeset containskey q
qlist add q
// get the new base docset for this facet
base   searcher getdocset qlist
/**
* looks at various params to determing if any simple facet constraint count
* computations are desired.
*
* @see #getfacetquerycounts
* @see #getfacetfieldcounts
* @see #getfacetdatecounts
* @see #getfacetrangecounts
* @see facetparams#facet
* @return a namedlist of facet count info or null
*/
public namedlist getfacetcounts
// if someone called this method, benefit of the doubt: assume true
if   params getbool facetparams facet true
return null
facetresponse   new simpleorderedmap
try
facetresponse add    getfacetquerycounts
facetresponse add    getfacetfieldcounts
facetresponse add    getfacetdatecounts
facetresponse add    getfacetrangecounts
catch  exception e
solrexception logonce solrcore log     e
addexception    e
return facetresponse
public void addexception string msg  exception e
list exceptions    list facetresponse get
if  exceptions    null
exceptions   new arraylist
facetresponse add    exceptions
string entry   msg       solrexception tostr e
exceptions add entry
/**
* returns a list of facet counts for each of the facet queries
* specified in the params
*
* @see facetparams#facet_query
*/
public namedlist getfacetquerycounts   throws ioexception parseexception
namedlist res   new simpleorderedmap
/* ignore commonparams.df - could have init param facet.query assuming
* the schema default with query param df intented to only affect q.
* if user doesn't want schema default for facet.query, they should be
* explicit.
*/
// solrqueryparser qp = searcher.getschema().getsolrqueryparser(null);
string facetqs   params getparams facetparams facet_query
if  null    facetqs    0    facetqs length
for  string q   facetqs
try
parseparams facetparams facet_query  q
// todo: slight optimization would prevent double-parsing of any localparams
query qobj   qparser getparser q  null  req  getquery
res add key  searcher numdocs qobj  base
catch  exception e
string msg       q
solrexception logonce solrcore log  msg  e
addexception msg   e
return res
public namedlist gettermcounts string field  throws ioexception
int offset   params getfieldint field  facetparams facet_offset  0
int limit   params getfieldint field  facetparams facet_limit  100
if  limit    0  return new namedlist
integer mincount   params getfieldint field  facetparams facet_mincount
if  mincount  null
boolean zeros   params getfieldbool field  facetparams facet_zeros
// mincount = (zeros!=null && zeros) ? 0 : 1;
mincount    zeros  null     zeros  ? 1   0
// current default is to include zeros.
boolean missing   params getfieldbool field  facetparams facet_missing  false
// default to sorting if there is a limit.
string sort   params getfieldparam field  facetparams facet_sort  limit>0 ? facetparams facet_sort_count   facetparams facet_sort_index
string prefix   params getfieldparam field facetparams facet_prefix
namedlist counts
schemafield sf   searcher getschema   getfield field
fieldtype ft   sf gettype
// determine what type of faceting method to use
string method   params getfieldparam field  facetparams facet_method
boolean enummethod   facetparams facet_method_enum equals method
if  method    null    ft instanceof boolfield
// always use filters for booleans... we know the number of values is very small.
enummethod   true
boolean multitoken   sf multivalued      ft multivaluedfieldcache
if  triefield getmainvalueprefix ft     null
// a triefield with multiple parts indexed per value... currently only
// uninvertedfield can handle this case, so force it's use.
enummethod   false
multitoken   true
// unless the enum method is explicitly specified, use a counting method.
if  enummethod
counts   getfacettermenumcounts searcher  base  field  offset  limit  mincount missing sort prefix
else
if  multitoken
uninvertedfield uif   uninvertedfield getuninvertedfield field  searcher
counts   uif getcounts searcher  base  offset  limit  mincount missing sort prefix
else
// todo: future logic could use filters instead of the fieldcache if
// the number of terms in the field is small enough.
counts   getfieldcachecounts searcher  base  field  offset limit  mincount  missing  sort  prefix
return counts
/**
* returns a list of value constraints and the associated facet counts
* for each facet field specified in the params.
*
* @see facetparams#facet_field
* @see #getfieldmissingcount
* @see #getfacettermenumcounts
*/
public namedlist getfacetfieldcounts
throws ioexception  parseexception
namedlist res   new simpleorderedmap
string facetfs   params getparams facetparams facet_field
if  null    facetfs
for  string f   facetfs
try
parseparams facetparams facet_field  f
string termlist   localparams    null ? null   localparams get commonparams terms
if  termlist    null
res add key  getlistedtermcounts facetvalue  termlist
else
res add key  gettermcounts facetvalue
catch  exception e
string msg       f
solrexception logonce solrcore log  msg  e
addexception msg   e
return res
private namedlist getlistedtermcounts string field  string termlist  throws ioexception
fieldtype ft   searcher getschema   getfieldtype field
list<string> terms   strutils splitsmart termlist     true
namedlist res   new namedlist
term t   new term field
for  string term   terms
string internal   ft tointernal term
int count   searcher numdocs new termquery t createterm internal    base
res add term  count
return res
/**
* returns a count of the documents in the set which do not have any
* terms for for the specified field.
*
* @see facetparams#facet_missing
*/
public static int getfieldmissingcount solrindexsearcher searcher  docset docs  string fieldname
throws ioexception
docset hasval   searcher getdocset
new termrangequery fieldname  null  null  false  false
return docs andnotsize hasval
// first element of the fieldcache is null, so we need this comparator.
private static final comparator nullstrcomparator   new comparator
public int compare object o1  object o2
if  o1  null  return  o2  null  ? 0    1
else if  o2  null  return 1
return   string o1  compareto  string o2
/**
* use the lucene fieldcache to get counts for each unique field value in <code>docs</code>.
* the field must have at most one indexed token per document.
*/
public static namedlist getfieldcachecounts solrindexsearcher searcher  docset docs  string fieldname  int offset  int limit  int mincount  boolean missing  string sort  string prefix  throws ioexception
// todo: if the number of terms is high compared to docs.size(), and zeros==false,
//  we should use an alternate strategy to avoid
//  1) creating another huge int[] for the counts
//  2) looping over that huge int[] looking for the rare non-zeros.
//
// yet another variation: if docs.size() is small and termvectors are stored,
// then use them instead of the fieldcache.
//
// todo: this function is too big and could use some refactoring, but
// we also need a facet cache, and refactoring of simplefacets instead of
// trying to pass all the various params around.
fieldtype ft   searcher getschema   getfieldtype fieldname
namedlist res   new namedlist
fieldcache stringindex si   fieldcache default getstringindex searcher getreader    fieldname
final string terms   si lookup
final int termnum   si order
if  prefix  null    prefix length    0  prefix null
int starttermindex  endtermindex
if  prefix  null
starttermindex   arrays binarysearch terms prefix nullstrcomparator
if  starttermindex<0  starttermindex  starttermindex 1
// find the end term.  \uffff isn't a legal unicode char, but only compareto
// is used, so it should be fine, and is guaranteed to be bigger than legal chars.
endtermindex   arrays binarysearch terms prefix   nullstrcomparator
endtermindex    endtermindex 1
else
starttermindex 1
endtermindex terms length
final int nterms endtermindex starttermindex
if  nterms>0    docs size   >  mincount
// count collection array only needs to be as big as the number of terms we are
// going to collect counts for.
final int counts   new int
dociterator iter   docs iterator
while  iter hasnext
int term   termnum
int arridx   term starttermindex
if  arridx> 0    arridx<nterms  counts
// idea: we could also maintain a count of "other"... everything that fell outside
// of the top 'n'
int off offset
int lim limit> 0 ? limit   integer max_value
if  sort equals facetparams facet_sort_count     sort equals facetparams facet_sort_count_legacy
int maxsize   limit>0 ? offset limit   integer max_value 1
maxsize   math min maxsize  nterms
final boundedtreeset<countpair<string integer>> queue   new boundedtreeset<countpair<string integer>> maxsize
int min mincount 1      the smallest value in the top   values
for  int i 0  i<nterms  i
int c   counts
if  c>min
// note: we use c>min rather than c>=min as an optimization because we are going in
// index order, so we already know that the keys are ordered.  this can be very
// important if a lot of the counts are repeated (like zero counts would be).
queue add new countpair<string integer> terms  c
if  queue size  > maxsize  min queue last   val
// now select the right page from the results
for  countpair<string integer> p   queue
if    off> 0  continue
if    lim<0  break
res add ft indexedtoreadable p key   p val
else
// add results in index order
int i 0
if  mincount< 0
// if mincount<=0, then we won't discard any terms and we know exactly
// where to start.
i off
off 0
for    i<nterms  i
int c   counts
if  c<mincount      off> 0  continue
if    lim<0  break
res add ft indexedtoreadable terms   c
if  missing
res add null  getfieldmissingcount searcher docs fieldname
return res
/**
* returns a list of terms in the specified field along with the
* corresponding count of documents in the set that match that constraint.
* this method uses the filtercache to get the intersection count between <code>docs</code>
* and the docset for each term in the filter.
*
* @see facetparams#facet_limit
* @see facetparams#facet_zeros
* @see facetparams#facet_missing
*/
public namedlist getfacettermenumcounts solrindexsearcher searcher  docset docs  string field  int offset  int limit  int mincount  boolean missing  string sort  string prefix
throws ioexception
/* :todo: potential optimization...
* cache the terms with the highest docfreq and try them first
* don't enum if we get our max from them
*/
// minimum term docfreq in order to use the filtercache for that term.
int mindffiltercache   params getfieldint field  facetparams facet_enum_cache_mindf  0
indexschema schema   searcher getschema
indexreader r   searcher getreader
fieldtype ft   schema getfieldtype field
final int maxsize   limit> 0 ? offset limit   integer max_value 1
final boundedtreeset<countpair<string integer>> queue    sort equals       sort equals     ? new boundedtreeset<countpair<string integer>> maxsize    null
final namedlist res   new namedlist
int min mincount 1      the smallest value in the top   values
int off offset
int lim limit> 0 ? limit   integer max_value
string startterm   prefix  null ?     ft tointernal prefix
termenum te   r terms new term field startterm
termdocs td   r termdocs
solrindexsearcher termdocsstate tdstate   new solrindexsearcher termdocsstate
tdstate tenum   te
tdstate tdocs   td
if  docs size   >  mincount
do
term t   te term
if  null    t      t field   equals field
break
if  prefix  null     t text   startswith prefix   break
int df   te docfreq
// if we are sorting, we can use df>min (rather than >=) since we
// are going in index order.  for certain term distributions this can
// make a large difference (for example, many terms with df=1).
if  df>0    df>min
int c
if  df >  mindffiltercache
// use the filter cache
c   docs intersectionsize  searcher getpositivedocset new termquery t   tdstate
else
// iterate over termdocs to calculate the intersection
td seek te
c 0
while  td next
if  docs exists td doc     c
if  sort equals       sort equals
if  c>min
queue add new countpair<string integer> t text    c
if  queue size  > maxsize  min queue last   val
else
if  c >  mincount      off<0
if    lim<0  break
res add ft indexedtoreadable t text     c
while  te next
if  sort equals       sort equals
for  countpair<string integer> p   queue
if    off> 0  continue
if    lim<0  break
res add ft indexedtoreadable p key   p val
if  missing
res add null  getfieldmissingcount searcher docs field
te close
td close
return res
/**
* returns a list of value constraints and the associated facet counts
* for each facet date field, range, and interval specified in the
* solrparams
*
* @see facetparams#facet_date
* @deprecated use getfacetrangecounts which is more generalized
*/
@deprecated
public namedlist getfacetdatecounts
throws ioexception  parseexception
final namedlist resouter   new simpleorderedmap
final string fields   params getparams facetparams facet_date
if  null    fields    0    fields length  return resouter
for  string f   fields
try
getfacetdatecounts f  resouter
catch  exception e
string msg       f
solrexception logonce solrcore log  msg  e
addexception msg   e
return resouter
/**
* @deprecated use getfacetrangecounts which is more generalized
*/
@deprecated
public void getfacetdatecounts string datefacet  namedlist resouter
throws ioexception  parseexception
final indexschema schema   searcher getschema
parseparams facetparams facet_date  datefacet
string f   facetvalue
final namedlist resinner   new simpleorderedmap
resouter add key  resinner
final schemafield sf   schema getfield f
if     sf gettype   instanceof datefield
throw new solrexception
solrexception errorcode bad_request
f
final datefield ft    datefield  sf gettype
final string starts
required getfieldparam f facetparams facet_date_start
final date start
try
start   ft parsemath now  starts
catch  solrexception e
throw new solrexception
solrexception errorcode bad_request
starts  e
final string ends
required getfieldparam f facetparams facet_date_end
date end     not final  hardend may change this
try
end   ft parsemath now  ends
catch  solrexception e
throw new solrexception
solrexception errorcode bad_request
ends  e
if  end before start
throw new solrexception
solrexception errorcode bad_request
ends   starts
final string gap   required getfieldparam f facetparams facet_date_gap
final datemathparser dmp   new datemathparser ft utc  locale us
dmp setnow now
final int mincount   params getfieldint f facetparams facet_mincount  0
string istrs   params getfieldparams f facetparams facet_date_include
// legacy support for default of [lower,upper,edge] for date faceting
// this is not handled by facetrangeinclude.parseparam because
// range faceting has differnet defaults
final enumset<facetrangeinclude> include
null    istrs    0    istrs length   ?
enumset of facetrangeinclude lower
facetrangeinclude upper
facetrangeinclude edge
facetrangeinclude parseparam istrs
try
date low   start
while  low before end
dmp setnow low
string label   ft toexternal low
date high   dmp parsemath gap
if  end before high
if  params getfieldbool f facetparams facet_date_hard_end false
high   end
else
end   high
if  high before low
throw new solrexception
solrexception errorcode bad_request
final boolean includelower
include contains facetrangeinclude lower
include contains facetrangeinclude edge     low equals start
final boolean includeupper
include contains facetrangeinclude upper
include contains facetrangeinclude edge     high equals end
final int count   rangecount sf low high includelower includeupper
if  count >  mincount
resinner add label  count
low   high
catch  java text parseexception e
throw new solrexception
solrexception errorcode bad_request
gap  e
// explicitly return the gap and end so all the counts
// (including before/after/between) are meaningful - even if mincount
// has removed the neighboring ranges
resinner add    gap
resinner add    start
resinner add    end
final string othersp
params getfieldparams f facetparams facet_date_other
if  null    othersp    0 < othersp length
final set<facetrangeother> others   enumset noneof facetrangeother class
for  final string o   othersp
others add facetrangeother get o
// no matter what other values are listed, we don't do
// anything if "none" is specified.
if    others contains facetrangeother none
boolean all   others contains facetrangeother all
if  all    others contains facetrangeother before
// include upper bound if "outer" or if first gap doesn't already include it
resinner add facetrangeother before tostring
rangecount sf null start
false
include contains facetrangeinclude outer
include contains facetrangeinclude lower
include contains facetrangeinclude edge
if  all    others contains facetrangeother after
// include lower bound if "outer" or if last gap doesn't already include it
resinner add facetrangeother after tostring
rangecount sf end null
include contains facetrangeinclude outer
include contains facetrangeinclude upper
include contains facetrangeinclude edge
false
if  all    others contains facetrangeother between
resinner add facetrangeother between tostring
rangecount sf start end
include contains facetrangeinclude lower
include contains facetrangeinclude edge
include contains facetrangeinclude upper
include contains facetrangeinclude edge
/**
* returns a list of value constraints and the associated facet
* counts for each facet numerical field, range, and interval
* specified in the solrparams
*
* @see facetparams#facet_range
*/
public namedlist getfacetrangecounts
final namedlist resouter   new simpleorderedmap
final string fields   params getparams facetparams facet_range
if  null    fields    0    fields length  return resouter
for  string f   fields
try
getfacetrangecounts f  resouter
catch  exception e
string msg       f
solrexception logonce solrcore log  msg  e
addexception msg   e
return resouter
void getfacetrangecounts string facetrange  namedlist resouter
throws ioexception  parseexception
final indexschema schema   searcher getschema
parseparams facetparams facet_range  facetrange
string f   facetvalue
final schemafield sf   schema getfield f
final fieldtype ft   sf gettype
rangeendpointcalculator calc   null
if  ft instanceof triefield
final triefield trie    triefield ft
switch  trie gettype
case float
calc   new floatrangeendpointcalculator sf
break
case double
calc   new doublerangeendpointcalculator sf
break
case integer
calc   new integerrangeendpointcalculator sf
break
case long
calc   new longrangeendpointcalculator sf
break
default
throw new solrexception
solrexception errorcode bad_request
f
else if  ft instanceof datefield
calc   new daterangeendpointcalculator sf  now
else if  ft instanceof sortableintfield
calc   new integerrangeendpointcalculator sf
else if  ft instanceof sortablelongfield
calc   new longrangeendpointcalculator sf
else if  ft instanceof sortablefloatfield
calc   new floatrangeendpointcalculator sf
else if  ft instanceof sortabledoublefield
calc   new doublerangeendpointcalculator sf
else
throw new solrexception
solrexception errorcode bad_request
sf
resouter add key  getfacetrangecounts sf  calc
private <t extends comparable<t>> namedlist getfacetrangecounts
final schemafield sf
final rangeendpointcalculator<t> calc  throws ioexception
final string f   sf getname
final namedlist res   new simpleorderedmap
final namedlist counts   new namedlist
res add    counts
final t start   calc getvalue required getfieldparam f facetparams facet_range_start
// not final, hardend may change this
t end   calc getvalue required getfieldparam f facetparams facet_range_end
if  end compareto start  < 0
throw new solrexception
solrexception errorcode bad_request
end   start
final string gap   required getfieldparam f  facetparams facet_range_gap
// explicitly return the gap.  compute this early so we are more
// likely to catch parse errors before attempting math
res add    calc getgap gap
final int mincount   params getfieldint f facetparams facet_mincount  0
final enumset<facetrangeinclude> include   facetrangeinclude parseparam
params getfieldparams f facetparams facet_range_include
t low   start
while  low compareto end  < 0
t high   calc addgap low  gap
if  end compareto high  < 0
if  params getfieldbool f facetparams facet_range_hard_end false
high   end
else
end   high
if  high compareto low  < 0
throw new solrexception
solrexception errorcode bad_request
final boolean includelower
include contains facetrangeinclude lower
include contains facetrangeinclude edge
0    low compareto start
final boolean includeupper
include contains facetrangeinclude upper
include contains facetrangeinclude edge
0    high compareto end
final string lows   calc formatvalue low
final string highs   calc formatvalue high
final int count   rangecount sf  lows  highs
includelower includeupper
if  count >  mincount
counts add lows  count
low   high
// explicitly return the start and end so all the counts
// (including before/after/between) are meaningful - even if mincount
// has removed the neighboring ranges
res add    start
res add    end
final string othersp
params getfieldparams f facetparams facet_range_other
if  null    othersp    0 < othersp length
set<facetrangeother> others   enumset noneof facetrangeother class
for  final string o   othersp
others add facetrangeother get o
// no matter what other values are listed, we don't do
// anything if "none" is specified.
if    others contains facetrangeother none
boolean all   others contains facetrangeother all
final string starts   calc formatvalue start
final string ends   calc formatvalue end
if  all    others contains facetrangeother before
// include upper bound if "outer" or if first gap doesn't already include it
res add facetrangeother before tostring
rangecount sf null starts
false
include contains facetrangeinclude outer
include contains facetrangeinclude lower
include contains facetrangeinclude edge
if  all    others contains facetrangeother after
// include lower bound if "outer" or if last gap doesn't already include it
res add facetrangeother after tostring
rangecount sf ends null
include contains facetrangeinclude outer
include contains facetrangeinclude upper
include contains facetrangeinclude edge
false
if  all    others contains facetrangeother between
res add facetrangeother between tostring
rangecount sf starts ends
include contains facetrangeinclude lower
include contains facetrangeinclude edge
include contains facetrangeinclude upper
include contains facetrangeinclude edge
return res
/**
* macro for getting the numdocs of range over docs
* @see solrindexsearcher#numdocs
* @see termrangequery
*/
protected int rangecount schemafield sf  string low  string high
boolean ilow  boolean ihigh  throws ioexception
query rangeq   sf gettype   getrangequery null  sf low high ilow ihigh
return searcher numdocs rangeq  base
/**
* @deprecated use rangecount(schemafield,string,string,boolean,boolean) which is more generalized
*/
@deprecated
protected int rangecount schemafield sf  date low  date high
boolean ilow  boolean ihigh  throws ioexception
query rangeq     datefield  sf gettype     getrangequery null  sf low high ilow ihigh
return searcher numdocs rangeq  base
/**
* a simple key=>val pair whose natural order is such that
* <b>higher</b> vals come before lower vals.
* in case of tie vals, then <b>lower</b> keys come before higher keys.
*/
public static class countpair<k extends comparable<? super k>  v extends comparable<? super v>>
implements comparable<countpair<k v>>
public countpair k k  v v
key   k  val   v
public k key
public v val
@override
public int hashcode
return key hashcode   ^ val hashcode
@override
public boolean equals object o
return  o instanceof countpair
0    this compareto  countpair<k v>  o
public int compareto countpair<k v> o
int vc   o val compareto val
return  0    vc ? vc   key compareto o key
/**
* perhaps someday instead of having a giant "instanceof" case
* statement to pick an impl, we can add a "rangefacetable" marker
* interface to fieldtypes and they can return instances of these
* directly from some method -- but until then, keep this locked down
* and private.
*/
private static abstract class rangeendpointcalculator<t extends comparable<t>>
protected final schemafield field
public rangeendpointcalculator final schemafield field
this field   field
/**
* formats a range endpoint for use as a range label name in the response.
* default impl just uses tostring()
*/
public string formatvalue final t val
return val tostring
/**
* parses a string param into an range endpoint value throwing
* a useful exception if not possible
*/
public final t getvalue final string rawval
try
return parseval rawval
catch  exception e
throw new solrexception solrexception errorcode bad_request
rawval
field getname    e
/**
* parses a string param into an range endpoint.
* can throw a low level format exception as needed.
*/
protected abstract t parseval final string rawval
throws java text parseexception
/**
* parses a string param into a value that represents the gap and
* can be included in the response, throwing
* a useful exception if not possible.
*
* note: uses object as the return type instead of t for things like
* date where gap is just a datemathparser string
*/
public final object getgap final string gap
try
return parsegap gap
catch  exception e
throw new solrexception solrexception errorcode bad_request
gap
field getname    e
/**
* parses a string param into a value that represents the gap and
* can be included in the response.
* can throw a low level format exception as needed.
*
* default impl calls parseval
*/
protected object parsegap final string rawval
throws java text parseexception
return parseval rawval
/**
* adds the string gap param to a low range endpoint value to determine
* the corrisponding high range endpoint value, throwing
* a useful exception if not possible.
*/
public final t addgap t value  string gap
try
return parseandaddgap value  gap
catch  exception e
throw new solrexception solrexception errorcode bad_request
gap     value
field getname    e
/**
* adds the string gap param to a low range endpoint value to determine
* the corrisponding high range endpoint value.
* can throw a low level format exception as needed.
*/
protected abstract t parseandaddgap t value  string gap
throws java text parseexception
private static class floatrangeendpointcalculator
extends rangeendpointcalculator<float>
public floatrangeendpointcalculator final schemafield f    super f
@override
protected float parseval string rawval
return float valueof rawval
@override
public float parseandaddgap float value  string gap
return new float value floatvalue     float valueof gap  floatvalue
private static class doublerangeendpointcalculator
extends rangeendpointcalculator<double>
public doublerangeendpointcalculator final schemafield f    super f
@override
protected double parseval string rawval
return double valueof rawval
@override
public double parseandaddgap double value  string gap
return new double value floatvalue     double valueof gap  floatvalue
private static class integerrangeendpointcalculator
extends rangeendpointcalculator<integer>
public integerrangeendpointcalculator final schemafield f    super f
@override
protected integer parseval string rawval
return integer valueof rawval
@override
public integer parseandaddgap integer value  string gap
return new integer value intvalue     integer valueof gap  intvalue
private static class longrangeendpointcalculator
extends rangeendpointcalculator<long>
public longrangeendpointcalculator final schemafield f    super f
@override
protected long parseval string rawval
return long valueof rawval
@override
public long parseandaddgap long value  string gap
return new long value intvalue     long valueof gap  intvalue
private static class daterangeendpointcalculator
extends rangeendpointcalculator<date>
private final date now
public daterangeendpointcalculator final schemafield f
final date now
super f
this now   now
if     field gettype   instanceof datefield
throw new illegalargumentexception
@override
public string formatvalue date val
return   datefield field gettype    toexternal val
@override
protected date parseval string rawval
return   datefield field gettype    parsemath now  rawval
@override
protected object parsegap final string rawval
return rawval
@override
public date parseandaddgap date value  string gap  throws java text parseexception
final datemathparser dmp   new datemathparser datefield utc  locale us
dmp setnow value
return dmp parsemath gap