/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache solr search
import org apache lucene index term
import org apache lucene queryparser parseexception
import org apache lucene queryparser queryparser
import org apache lucene search booleanclause
import org apache lucene search booleanquery
import org apache lucene search constantscorequery
import org apache lucene search fuzzyquery
import org apache lucene search numericrangequery
import org apache lucene search prefixquery
import org apache lucene search query
import org apache lucene search sort
import org apache lucene search sortfield
import org apache lucene search termquery
import org apache lucene search termrangequery
import org apache lucene search wildcardquery
import org apache solr common solrexception
import org apache solr common params mapsolrparams
import org apache solr common params solrparams
import org apache solr core solrcore
import org apache solr request localsolrqueryrequest
import org apache solr request solrqueryrequest
import org apache solr schema fieldtype
import org apache solr schema indexschema
import org apache solr schema schemafield
import org apache solr search function functionquery
import org apache solr search function queryvaluesource
import java io ioexception
import java util arraylist
import java util hashmap
import java util list
import java util map
/**
* collection of static utilities useful for query parsing.
*
* @version $id$
*/
public class queryparsing
public static final string op          the solrparam used to override the queryparser
public static final string v              value of this parameter
public static final string f              field that a query or command pertains to
public static final string type        type of this query or command
public static final string deftype         default type for any direct subqueries
public static final string localparam_start
public static final char localparam_end
public static final string docid
public static final string score
// true if the value was specified by the "v" param (i.e. v=myval, or v=$param)
public static final string val_explicit
/**
* helper utility for parsing a query using the lucene queryparser syntax.
*
* @param qs     query expression in standard lucene syntax
* @param schema used for default operator (overridden by params) and passed to the query parser for field format analysis information
*/
public static query parsequery string qs  indexschema schema
return parsequery qs  null  schema
}
/**
* helper utility for parsing a query using the lucene queryparser syntax.
*
* @param qs           query expression in standard lucene syntax
* @param defaultfield default field used for unqualified search terms in the query expression
* @param schema       used for default operator (overridden by params) and passed to the query parser for field format analysis information
*/
public static query parsequery string qs  string defaultfield  indexschema schema
try
query query   schema getsolrqueryparser defaultfield  parse qs
if  solrcore log istraceenabled
solrcore log trace     query
}
return query
catch  parseexception e
solrcore log e
throw new solrexception solrexception errorcode bad_request     e
}
}
/**
* helper utility for parsing a query using the lucene queryparser syntax.
*
* @param qs           query expression in standard lucene syntax
* @param defaultfield default field used for unqualified search terms in the query expression
* @param params       used to determine the default operator, overriding the schema specified operator
* @param schema       used for default operator (overridden by params) and passed to the query parser for field format analysis information
*/
public static query parsequery string qs  string defaultfield  solrparams params  indexschema schema
try
solrqueryparser parser   schema getsolrqueryparser defaultfield
string opparam   params get op
if  opparam    null
parser setdefaultoperator   equals opparam  ? queryparser operator and   queryparser operator or
}
query query   parser parse qs
if  solrcore log istraceenabled
solrcore log trace     query
}
return query
catch  parseexception e
solrcore log e
throw new solrexception solrexception errorcode bad_request      e getmessage    e
}
}
// note to self: something needs to detect infinite recursion when parsing queries
static int parselocalparams string txt  int start  map<string  string> target  solrparams params  throws parseexception
int off   start
if   txt startswith localparam_start  off   return start
strparser p   new strparser txt  start  txt length
p pos    2     skip over
for
/*
if (p.pos>=txt.length()) {
throw new parseexception("missing '}' parsing local params '" + txt + '"');
}
*/
char ch   p peek
if  ch    localparam_end
return p pos   1
}
string id   p getid
if  id length      0
throw new parseexception     txt
}
string val   null
ch   p peek
if  ch
// single word... treat {!func} as type=func for easy lookup
val   id
id   type
else
// saw equals, so read value
p pos
ch   p peek
boolean deref   false
if  ch
p pos
ch   p peek
deref   true      dereference whatever value is read by treating it as a variable name
}
if  ch         ch
val   p getquotedstring
else
// read unquoted literal ended by whitespace or '}'
// there is no escaping.
int valstart   p pos
for
if  p pos >  p end
throw new parseexception     valstart       txt
}
char c   p val charat p pos
if  c    localparam_end    character iswhitespace c
val   p val substring valstart  p pos
break
}
p pos
}
}
if  deref        dereference parameter
if  params    null
val   params get val
}
}
}
if  target    null  target put id  val
}
}
public static string encodelocalparamval string val
int len   val length
int i   0
if  len > 0    val charat 0
for   i<len  i
char ch   val charat i
if  character iswhitespace ch     ch     break
}
}
if  i> len  return val
// we need to enclose in quotes... but now we need to escape
stringbuilder sb   new stringbuilder val length     4
sb append
for  i 0  i<len  i
char ch   val charat i
if  ch
sb append
}
sb append ch
}
sb append
return sb tostring
}
/**
* "foo" returns null
* "{!prefix f=myfield}yes" returns type="prefix",f="myfield",v="yes"
* "{!prefix f=myfield v=$p}" returns type="prefix",f="myfield",v=params.get("p")
*/
public static solrparams getlocalparams string txt  solrparams params  throws parseexception
if  txt    null     txt startswith localparam_start
return null
}
map<string  string> localparams   new hashmap<string  string>
int start   queryparsing parselocalparams txt  0  localparams  params
string val   localparams get v
if  val    null
val   txt substring start
localparams put v  val
else
// localparams.put(val_explicit, "true");
}
return new mapsolrparams localparams
}
/**
* returns null if the sortspec is the standard sort desc.
* <p/>
* <p>
* the form of the sort specification string currently parsed is:
* </p>
* <pre>>
* sortspec ::= singlesort [, singlesort]*
* singlesort ::= <fieldname> sortdirection
* sortdirection ::= top | desc | bottom | asc
* </pre>
* examples:
* <pre>
*   score desc               #normal sort by score (will return null)
*   weight bottom            #sort by weight ascending
*   weight desc              #sort by weight descending
*   height desc,weight desc  #sort by height descending, and use weight descending to break any ties
*   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker
* </pre>
*/
public static sort parsesort string sortspec  solrqueryrequest req
if  sortspec    null    sortspec length      0  return null
list<sortfield> lst   new arraylist<sortfield> 4
try
strparser sp   new strparser sortspec
while  sp pos < sp end
sp eatws
final int start   sp pos
// short circuit test for a really simple field name
string field   sp getid null
parseexception qparserexception   null
if  field    null    sp ch
// let's try it as a function instead
string funcstr   sp val substring start
qparser parser   qparser getparser funcstr  functionqparserplugin name  req
query q   null
try
if  parser instanceof functionqparser
functionqparser fparser    functionqparser parser
fparser setparsemultiplesources false
fparser setparsetoend false
q   fparser getquery
if  fparser localparams    null
if  fparser valfollowedparams
// need to find the end of the function query via the string parser
int leftover   fparser sp end   fparser sp pos
sp pos   sp end   leftover       reset our parser to the same amount of leftover
else
// the value was via the "v" param in localparams, so we need to find
// the end of the local params themselves to pick up where we left off
sp pos   start   fparser localparamsend
}
else
// need to find the end of the function query via the string parser
int leftover   fparser sp end   fparser sp pos
sp pos   sp end   leftover       reset our parser to the same amount of leftover
}
else
// a qparser that's not for function queries.
// it must have been specified via local params.
q   parser getquery
assert parser getlocalparams      null
sp pos   start   parser localparamsend
}
boolean top   sp getsortdirection
if  null    top
// we have a query and a valid direction
if  q instanceof functionquery
lst add   functionquery q  getvaluesource   getsortfield top
else
lst add  new queryvaluesource q  0 0f   getsortfield top
}
continue
}
catch  parseexception e
// hang onto this in case the string isn't a full field name either
qparserexception   e
}
}
// if we made it here, we either have a "simple" field name,
// or there was a problem parsing the string as a complex func/quer
if  field    null
// try again, simple rules for a field name with no whitespace
sp pos   start
field   sp getsimplestring
}
boolean top   sp getsortdirection
if  null    top
throw new solrexception solrexception errorcode bad_request
sp
}
if  score equals field
if  top
lst add sortfield field_score
else
lst add new sortfield null  sortfield score  true
}
else if  docid equals field
lst add new sortfield null  sortfield doc  top
else
// try to find the field
schemafield sf   req getschema   getfieldornull field
if  null    sf
if  null    qparserexception
throw new solrexception
solrexception errorcode bad_request
field
qparserexception
}
throw new solrexception
solrexception errorcode bad_request
field
}
lst add sf getsortfield top
}
}
catch  parseexception e
throw new solrexception solrexception errorcode bad_request      sortspec  e
catch  ioexception e
throw new solrexception solrexception errorcode bad_request      sortspec  e
}
// normalize a sort on score desc to null
if  lst size    1    lst get 0     sortfield field_score
return null
}
return new sort lst toarray new sortfield
}
///////////////////////////
///////////////////////////
///////////////////////////
static fieldtype writefieldname string name  indexschema schema  appendable out  int flags  throws ioexception
fieldtype ft   null
ft   schema getfieldtypenoex name
out append name
if  ft    null
out append     name
}
out append
return ft
}
static void writefieldval string val  fieldtype ft  appendable out  int flags  throws ioexception
if  ft    null
try
out append ft indexedtoreadable val
catch  exception e
out append
out append val
out append
}
else
out append val
}
}
/**
* @see #tostring(query,indexschema)
*/
public static void tostring query query  indexschema schema  appendable out  int flags  throws ioexception
boolean writeboost   true
if  query instanceof termquery
termquery q    termquery  query
term t   q getterm
fieldtype ft   writefieldname t field    schema  out  flags
writefieldval t text    ft  out  flags
else if  query instanceof termrangequery
termrangequery q    termrangequery  query
string fname   q getfield
fieldtype ft   writefieldname fname  schema  out  flags
out append q includeslower   ?
string lt   q getlowerterm
string ut   q getupperterm
if  lt    null
out append
else
writefieldval lt  ft  out  flags
}
out append
if  ut    null
out append
else
writefieldval ut  ft  out  flags
}
out append q includesupper   ?
else if  query instanceof numericrangequery
numericrangequery q    numericrangequery  query
string fname   q getfield
fieldtype ft   writefieldname fname  schema  out  flags
out append q includesmin   ?
number lt   q getmin
number ut   q getmax
if  lt    null
out append
else
out append lt tostring
}
out append
if  ut    null
out append
else
out append ut tostring
}
out append q includesmax   ?
else if  query instanceof booleanquery
booleanquery q    booleanquery  query
boolean needparens   false
if  q getboost      1 0    q getminimumnumbershouldmatch      0
needparens   true
}
if  needparens
out append
}
boolean first   true
for  booleanclause c   q clauses
if   first
out append
else
first   false
}
if  c isprohibited
out append
else if  c isrequired
out append
}
query subquery   c getquery
boolean wrapquery   false
// todo: may need to put parens around other types
// of queries too, depending on future syntax.
if  subquery instanceof booleanquery
wrapquery   true
}
if  wrapquery
out append
}
tostring subquery  schema  out  flags
if  wrapquery
out append
}
}
if  needparens
out append
}
if  q getminimumnumbershouldmatch   > 0
out append
out append integer tostring q getminimumnumbershouldmatch
}
else if  query instanceof prefixquery
prefixquery q    prefixquery  query
term prefix   q getprefix
fieldtype ft   writefieldname prefix field    schema  out  flags
out append prefix text
out append
else if  query instanceof constantscoreprefixquery
constantscoreprefixquery q    constantscoreprefixquery  query
term prefix   q getprefix
fieldtype ft   writefieldname prefix field    schema  out  flags
out append prefix text
out append
else if  query instanceof wildcardquery
out append query tostring
writeboost   false
else if  query instanceof fuzzyquery
out append query tostring
writeboost   false
else if  query instanceof constantscorequery
out append query tostring
writeboost   false
else
out append query getclass   getsimplename
query tostring
writeboost   false
}
if  writeboost    query getboost      1 0f
out append
out append float tostring query getboost
}
}
/**
* formats a query for debugging, using the indexschema to make
* complex field types readable.
* <p/>
* <p>
* the benefit of using this method instead of calling
* <code>query.tostring</code> directly is that it knows about the data
* types of each field, so any field which is encoded in a particularly
* complex way is still readable. the downside is that it only knows
* about built in query types, and will not be able to format custom
* query classes.
* </p>
*/
public static string tostring query query  indexschema schema
try
stringbuilder sb   new stringbuilder
tostring query  schema  sb  0
return sb tostring
catch  exception e
throw new runtimeexception e
}
}
/**
* simple class to help with parsing a string
* <b>note: this api is experimental and may change in non backward-compatible ways in the future</b>
*/
public static class strparser
string val
int pos
int end
public strparser string val
this val  0  val length
}
public strparser string val  int start  int end
this val   val
this pos   start
this end   end
}
void eatws
while  pos < end    character iswhitespace val charat pos    pos
}
char ch
return pos < end ? val charat pos    0
}
void skip int nchars
pos   math max pos   nchars  end
}
boolean opt string s
eatws
int slen   s length
if  val regionmatches pos  s  0  slen
pos    slen
return true
}
return false
}
boolean opt char ch
eatws
if  val charat pos     ch
pos
return true
}
return false
}
void expect string s  throws parseexception
eatws
int slen   s length
if  val regionmatches pos  s  0  slen
pos    slen
else
throw new parseexception     s       pos       val
}
}
float getfloat   throws parseexception
eatws
char arr   new char
int i
for  i   0  i < arr length  i
char ch   val charat pos
if   ch >       ch <
ch         ch
ch         ch         ch
pos
arr   ch
else
break
}
}
return float parsefloat new string arr  0  i
}
number getnumber   throws parseexception
eatws
int start   pos
boolean flt   false
while  pos < end
char ch   val charat pos
if   ch >       ch <        ch         ch
pos
else if  ch         ch        ch
flt   true
pos
else
break
}
}
string v   val substring start pos
return flt ? double parsedouble v    long parselong v
}
double getdouble   throws parseexception
eatws
char arr   new char
int i
for  i   0  i < arr length  i
char ch   val charat pos
if   ch >       ch <
ch         ch
ch         ch         ch
pos
arr   ch
else
break
}
}
return double parsedouble new string arr  0  i
}
int getint   throws parseexception
eatws
char arr   new char
int i
for  i   0  i < arr length  i
char ch   val charat pos
if   ch >       ch <
ch         ch
pos
arr   ch
else
break
}
}
return integer parseint new string arr  0  i
}
string getid   throws parseexception
return getid
}
string getid string errmessage  throws parseexception
eatws
int id_start   pos
char ch
if  pos < end     ch   val charat pos           character isjavaidentifierstart ch
pos
while  pos < end
ch   val charat pos
if   character isjavaidentifierpart ch     ch
break
}
pos
}
return val substring id_start  pos
}
if  errmessage    null
throw new parseexception errmessage       pos       val
}
return null
}
/**
* skips leading whitespace and returns whatever sequence of non
* whitespace it can find (or hte empty string)
*/
string getsimplestring
eatws
int startpos   pos
char ch
while  pos < end
ch   val charat pos
if  character iswhitespace ch   break
pos
}
return val substring startpos  pos
}
/**
* sort direction or null if current position does not inidcate a
* sort direction. (true is desc, false is asc).
* position is advanced to after the comma (or end) when result is non null
*/
boolean getsortdirection   throws parseexception
final int startpos   pos
final string order   getid null
boolean top   null
if  null    order
if    equals order       equals order
top   true
else if    equals order       equals order
top   false
}
// it's not a legal direction if more stuff comes after it
eatws
final char c   ch
if  0    c
// :noop
else if       c
pos
else
top   null
}
}
if  null    top  pos   startpos     no direction  reset
return top
}
// return null if not a string
string getquotedstring   throws parseexception
eatws
char delim   peekchar
if    delim         delim
return null
}
int val_start     pos
stringbuilder sb   new stringbuilder       needed for escaping
for
if  pos >  end
throw new parseexception      val_start   1        val
}
char ch   val charat pos
if  ch
pos
if  pos >  end  break
ch   val charat pos
switch  ch
case
ch
break
case
ch
break
case
ch
break
case
ch
break
case
ch
break
case
if  pos   4 >  end
throw new parseexception      val_start   1        val
}
ch    char  integer parseint val substring pos   1  pos   5   16
pos    4
break
}
else if  ch    delim
pos        skip over the quote
break
}
sb append ch
pos
}
return sb tostring
}
// next non-whitespace char
char peek
eatws
return pos < end ? val charat pos    0
}
// next char
char peekchar
return pos < end ? val charat pos    0
}
@override
public string tostring
return     val           pos
}
}
/**
* builds a list of string which are stringified versions of a list of queries
*/
public static list<string> tostring list<query> queries  indexschema schema
list<string> out   new arraylist<string> queries size
for  query q   queries
out add queryparsing tostring q  schema
}
return out
}
/**
* parse a function, returning a functionquery
* <p/>
* <p>
* syntax examples....
* </p>
* <p/>
* <pre>
* // numeric fields default to correct type
* // (ie: intfieldsource or floatfieldsource)
* // others use explicit ord(...) to generate numeric field value
* myfield
* <p/>
* // ordfieldsource
* ord(myfield)
* <p/>
* // reverseordfieldsource
* rord(myfield)
* <p/>
* // linearfloatfunction on numeric field value
* linear(myfield,1,2)
* <p/>
* // maxfloatfunction of linearfloatfunction on numeric field value or constant
* max(linear(myfield,1,2),100)
* <p/>
* // reciprocalfloatfunction on numeric field value
* recip(myfield,1,2,3)
* <p/>
* // reciprocalfloatfunction on reverseordfieldsource
* recip(rord(myfield),1,2,3)
* <p/>
* // reciprocalfloatfunction on linearfloatfunction on reverseordfieldsource
* recip(linear(rord(myfield),1,2),3,4,5)
* </pre>
*/
public static functionquery parsefunction string func  indexschema schema  throws parseexception
solrcore core   solrcore getsolrcore
return  functionquery   qparser getparser func     new localsolrqueryrequest core  new hashmap     parse
// return new functionquery(parsevalsource(new strparser(func), schema));
}
}