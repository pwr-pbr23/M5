package org apache lucene search
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io ioexception
import java util hashmap
final class sloppyphrasescorer extends phrasescorer
private int slop
private phrasepositions repeats
private phrasepositions tmppos     for flipping repeating pps
private boolean checkedrepeats
sloppyphrasescorer weight weight  phrasequery postingsandfreq postings  similarity similarity
int slop  byte norms
super weight  postings  similarity  norms
this slop   slop
/**
* score a candidate doc for all slop-valid position-combinations (matches)
* encountered while traversing/hopping the phrasepositions.
* <br> the score contribution of a match depends on the distance:
* <br> - highest score for distance=0 (exact match).
* <br> - score gets lower as distance gets higher.
* <br>example: for query "a b"~2, a document "x a b a y" can be scored twice:
* once for "a b" (distance=0), and once for "b a" (distance=2).
* <br>possibly not all valid combinations are encountered, because for efficiency
* we always propagate the least phraseposition. this allows to base on
* priorityqueue and move forward faster.
* as result, for example, document "a b c b a"
* would score differently for queries "a b c"~4 and "c b a"~4, although
* they really are equivalent.
* similarly, for doc "a b c b a f g", query "c b"~2
* would get same score as "g f"~2, although "c b"~2 could be matched twice.
* we may want to fix this in the future (currently not, for performance reasons).
*/
@override
protected float phrasefreq   throws ioexception
int end   initphrasepositions
float freq   0 0f
boolean done    end<0
while   done
phrasepositions pp   pq pop
int start   pp position
int next   pq top   position
boolean tpsdiffer   true
for  int pos   start  pos <  next     tpsdiffer  pos   pp position
if  pos< next    tpsdiffer
start   pos                      advance pp to min window
if   pp nextposition
done   true              ran out of a term    done
break
phrasepositions pp2   null
tpsdiffer    pp repeats     pp2   termpositionsdiffer pp    null
if  pp2  null    pp2  pp
pp   flip pp pp2      flip pp to pp2
int matchlength   end   start
if  matchlength <  slop
freq    getsimilarity   sloppyfreq matchlength      score match
if  pp position > end
end   pp position
pq add pp                    restore pq
return freq
// flip pp2 and pp in the queue: pop until finding pp2, insert back all but pp2, insert pp back.
// assumes: pp!=pp2, pp2 in pq, pp not in pq.
// called only when there are repeating pps.
private phrasepositions flip phrasepositions pp  phrasepositions pp2
int n 0
phrasepositions pp3
//pop until finding pp2
while   pp3 pq pop       pp2
tmppos   pp3
//insert back all but pp2
for  n    n> 0  n
pq insertwithoverflow tmppos
//insert pp back
pq add pp
return pp2
/**
* init phrasepositions in place.
* there is a one time initialization for this scorer:
* <br>- put in repeats[] each pp that has another pp with same position in the doc.
* <br>- also mark each such pp by pp.repeats = true.
* <br>later can consult with repeats[] in termpositionsdiffer(pp), making that check efficient.
* in particular, this allows to score queries with no repetitions with no overhead due to this computation.
* <br>- example 1 - query with no repetitions: "ho my"~2
* <br>- example 2 - query with repetitions: "ho my my"~2
* <br>- example 3 - query with repetitions: "my ho my"~2
* <br>init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.
* @return end (max position), or -1 if any term ran out (i.e. done)
* @throws ioexception
*/
private int initphrasepositions   throws ioexception
int end   0
// no repeats at all (most common case is also the simplest one)
if  checkedrepeats    repeats  null
// build queue from list
pq clear
for  phrasepositions pp   first  pp    null  pp   pp next
pp firstposition
if  pp position > end
end   pp position
pq add pp              build pq from list
return end
// position the pp's
for  phrasepositions pp   first  pp    null  pp   pp next
pp firstposition
// one time initializatin for this scorer
if   checkedrepeats
checkedrepeats   true
// check for repeats
hashmap<phrasepositions  object> m   null
for  phrasepositions pp   first  pp    null  pp   pp next
int tppos   pp position   pp offset
for  phrasepositions pp2   pp next  pp2    null  pp2   pp2 next
int tppos2   pp2 position   pp2 offset
if  tppos2    tppos
if  m    null
m   new hashmap<phrasepositions  object>
pp repeats   true
pp2 repeats   true
m put pp null
m put pp2 null
if  m  null
repeats   m keyset   toarray new phrasepositions
// with repeats must advance some repeating pp's so they all start with differing tp's
if  repeats  null
for  int i   0  i < repeats length  i
phrasepositions pp   repeats
phrasepositions pp2
while   pp2   termpositionsdiffer pp      null
if   pp2 nextposition        out of pps that do not differ  advance the pp with higher offset
return  1               ran out of a term    done
// build queue from list
pq clear
for  phrasepositions pp   first  pp    null  pp   pp next
if  pp position > end
end   pp position
pq add pp              build pq from list
if  repeats  null
tmppos   new phrasepositions
return end
/**
* we disallow two pp's to have the same termposition, thereby verifying multiple occurrences
* in the query of the same word would go elsewhere in the matched doc.
* @return null if differ (i.e. valid) otherwise return the higher offset phrasepositions
* out of the first two pps found to not differ.
*/
private phrasepositions termpositionsdiffer phrasepositions pp
// efficiency note: a more efficient implementation could keep a map between repeating
// pp's, so that if pp1a, pp1b, pp1c are repeats term1, and pp2a, pp2b are repeats
// of term2, pp2a would only be checked against pp2b but not against pp1a, pp1b, pp1c.
// however this would complicate code, for a rather rare case, so choice is to compromise here.
int tppos   pp position   pp offset
for  int i   0  i < repeats length  i
phrasepositions pp2   repeats
if  pp2    pp
continue
int tppos2   pp2 position   pp2 offset
if  tppos2    tppos
return pp offset > pp2 offset ? pp   pp2     do not differ  return the one with higher offset
return null