/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache solr schema
import org apache lucene analysis analyzer
import org apache lucene analysis tokenstream
import org apache lucene document fieldable
import org apache lucene search similarity
import org apache lucene queryparser queryparser
import org apache lucene util version
import org apache solr common resourceloader
import org apache solr common solrexception
import org apache solr common params solrparams
import org apache solr common util domutil
import org apache solr common util systemidresolver
import org apache solr core solrconfig
import org apache solr core config
import org apache solr core solrresourceloader
import org apache solr analysis charfilterfactory
import org apache solr analysis tokenfilterfactory
import org apache solr analysis tokenizerchain
import org apache solr analysis tokenizerfactory
import org apache solr search solrqueryparser
import org apache solr util plugin abstractpluginloader
import org apache solr util plugin solrcoreaware
import org w3c dom
import org xml sax inputsource
import javax xml xpath xpath
import javax xml xpath xpathconstants
import javax xml xpath xpathexpressionexception
import javax xml xpath xpathfactory
import java io inputstream
import java io reader
import java io ioexception
import java util
import java lang reflect constructor
import org slf4j logger
import org slf4j loggerfactory
/**
* <code>indexschema</code> contains information about the valid fields in an index
* and the types of those fields.
*
* @version $id$
*/
public final class indexschema
public static final string default_schema_file
public static final string lucene_match_version_param
final static logger log   loggerfactory getlogger indexschema class
private final solrconfig solrconfig
private final string resourcename
private string name
private float version
private final solrresourceloader loader
private final hashmap<string  schemafield> fields   new hashmap<string schemafield>
private final hashmap<string  fieldtype> fieldtypes   new hashmap<string fieldtype>
private final list<schemafield> fieldswithdefaultvalue   new arraylist<schemafield>
private final collection<schemafield> requiredfields   new hashset<schemafield>
private dynamicfield dynamicfields
private analyzer analyzer
private analyzer queryanalyzer
private string defaultsearchfieldname null
private string queryparserdefaultoperator
private final map<string  list<copyfield>> copyfieldsmap   new hashmap<string  list<copyfield>>
private dynamiccopy dynamiccopyfields
/**
* keys are all fields copied to, count is num of copyfield
* directives that target them.
*/
private map<schemafield  integer> copyfieldtargetcounts
new hashmap<schemafield  integer>
/**
* constructs a schema using the specified file name using the normal
* config path directory searching rules.
*
* @see config#openresource
* @deprecated use {@link #indexschema(solrconfig, string, inputsource)} instead.
*/
@deprecated
public indexschema solrconfig solrconfig  string name
this solrconfig  name  null
/**
* constructs a schema using the specified resource name and stream.
* if the is stream is null, the resource loader will load the schema resource by name.
* @see solrresourceloader#openschema
* by default, this follows the normal config path directory searching rules.
* @see solrresourceloader#openresource
*/
public indexschema solrconfig solrconfig  string name  inputsource is
this solrconfig   solrconfig
if  name    null
name   default_schema_file
this resourcename   name
loader   solrconfig getresourceloader
if  is    null
is   new inputsource loader openschema name
is setsystemid systemidresolver createsystemidfromresourcename name
readschema is
loader inform  loader
/**
* @deprecated -- get access to solrconfig some other way...
*/
@deprecated
public solrconfig getsolrconfig
return solrconfig
/**
* @since solr 1.4
*/
public solrresourceloader getresourceloader
return loader
/** gets the name of the resource used to instantiate this schema. */
public string getresourcename
return resourcename
/** gets the name of the schema as specified in the schema resource. */
public string getschemaname
return name
float getversion
return version
/**
* direct access to the inputstream for the schemafile used by this instance.
* @see config#openresource
* @deprecated use {@link #getsolrconfig()} and open a resource input stream
*             for {@link #getresourcename()} instead.
*/
@deprecated
public inputstream getinputstream
return loader openresource resourcename
/** gets the name of the schema file.
* @deprecated use {@link #getresourcename()} instead.
*/
@deprecated
public string getschemafile
return resourcename
/** the name of this schema (as specified in the schema file)
* @deprecated use {@link #getschemaname()} instead.
*/
@deprecated
public string getname     return name
/**
* provides direct access to the map containing all explicit
* (ie: non-dynamic) fields in the index, keyed on field name.
*
* <p>
* modifying this map (or any item in it) will affect the real schema
* </p>
*
* <p>
* note: this function is not thread safe.  however, it is safe to use within the standard
* <code>inform( solrcore core )</code> function for <code>solrcoreaware</code> classes.
* outside <code>inform</code>, this could potentially throw a concurrentmodificationexception
* </p>
*/
public map<string schemafield> getfields     return fields
/**
* provides direct access to the map containing all field types
* in the index, keyed on field type name.
*
* <p>
* modifying this map (or any item in it) will affect the real schema.  however if you
* make any modifications, be sure to call {@link indexschema#refreshanalyzers()} to
* update the analyzers for the registered fields.
* </p>
*
* <p>
* note: this function is not thread safe.  however, it is safe to use within the standard
* <code>inform( solrcore core )</code> function for <code>solrcoreaware</code> classes.
* outside <code>inform</code>, this could potentially throw a concurrentmodificationexception
* </p>
*/
public map<string fieldtype> getfieldtypes     return fieldtypes
/**
* provides direct access to the list containing all fields with a default value
*/
public list<schemafield> getfieldswithdefaultvalue     return fieldswithdefaultvalue
/**
* provides direct access to the list containing all required fields.  this
* list contains all fields with default values.
*/
public collection<schemafield> getrequiredfields     return requiredfields
private similarityfactory similarityfactory
/**
* returns the similarity used for this index
*/
public similarity getsimilarity     return similarityfactory getsimilarity
/**
* returns the similarityfactory used for this index
*/
public similarityfactory getsimilarityfactory     return similarityfactory
/**
* returns the analyzer used when indexing documents for this index
*
* <p>
* this analyzer is field (and dynamic field) name aware, and delegates to
* a field specific analyzer based on the field type.
* </p>
*/
public analyzer getanalyzer     return analyzer
/**
* returns the analyzer used when searching this index
*
* <p>
* this analyzer is field (and dynamic field) name aware, and delegates to
* a field specific analyzer based on the field type.
* </p>
*/
public analyzer getqueryanalyzer     return queryanalyzer
/**
* a solrqueryparser linked to this indexschema for field datatype
* information, and populated with default options from the
* &lt;solrqueryparser&gt; configuration for this indexschema.
*
* @param defaultfield if non-null overrides the schema default
* @deprecated
*/
@deprecated
public solrqueryparser getsolrqueryparser string defaultfield
solrqueryparser qp   new solrqueryparser this defaultfield
string operator   getqueryparserdefaultoperator
qp setdefaultoperator   equals operator  ?
queryparser operator and   queryparser operator or
return qp
/**
* name of the default search field specified in the schema file
*/
public string getdefaultsearchfieldname
return defaultsearchfieldname
/**
* default operator ("and" or "or") for queryparser
* @deprecated use getsolrqueryparser().getdefaultoperator()
*/
@deprecated
public string getqueryparserdefaultoperator
return queryparserdefaultoperator
private schemafield uniquekeyfield
/**
* unique key field specified in the schema file
* @return null if this schema has no unique key field
*/
public schemafield getuniquekeyfield     return uniquekeyfield
private string uniquekeyfieldname
private fieldtype uniquekeyfieldtype
/**
* the raw (field type encoded) value of the unique key field for
* the specified document
* @return null if this schema has no unique key field
* @see #printableuniquekey
*/
public fieldable getuniquekeyfield org apache lucene document document doc
return doc getfieldable uniquekeyfieldname       this should return null if name is null
/**
* the printable value of the unique key field for
* the specified document
* @return null if this schema has no unique key field
*/
public string printableuniquekey org apache lucene document document doc
fieldable f   doc getfieldable uniquekeyfieldname
return f  null ? null   uniquekeyfieldtype toexternal f
private schemafield getindexedfield string fname
schemafield f   getfields   get fname
if  f  null
throw new runtimeexception     fname
if   f indexed
throw new runtimeexception   fname     f
return f
/**
* this will re-create the analyzers.  if you make any modifications to
* the field map ({@link indexschema#getfields()}, this function is required
* to synch the internally cached field analyzers.
*
* @since solr 1.3
*/
public void refreshanalyzers
analyzer   new solrindexanalyzer
queryanalyzer   new solrqueryanalyzer
private class solrindexanalyzer extends analyzer
protected final hashmap<string analyzer> analyzers
solrindexanalyzer
analyzers   analyzercache
protected hashmap<string analyzer> analyzercache
hashmap<string analyzer> cache   new hashmap<string analyzer>
for  schemafield f   getfields   values
analyzer analyzer   f gettype   getanalyzer
cache put f getname    analyzer
return cache
protected analyzer getanalyzer string fieldname
analyzer analyzer   analyzers get fieldname
return analyzer  null ? analyzer   getdynamicfieldtype fieldname  getanalyzer
@override
public tokenstream tokenstream string fieldname  reader reader
return getanalyzer fieldname  tokenstream fieldname reader
@override
public tokenstream reusabletokenstream string fieldname  reader reader  throws ioexception
return getanalyzer fieldname  reusabletokenstream fieldname reader
@override
public int getpositionincrementgap string fieldname
return getanalyzer fieldname  getpositionincrementgap fieldname
private class solrqueryanalyzer extends solrindexanalyzer
@override
protected hashmap<string analyzer> analyzercache
hashmap<string analyzer> cache   new hashmap<string analyzer>
for  schemafield f   getfields   values
analyzer analyzer   f gettype   getqueryanalyzer
cache put f getname    analyzer
return cache
@override
protected analyzer getanalyzer string fieldname
analyzer analyzer   analyzers get fieldname
return analyzer  null ? analyzer   getdynamicfieldtype fieldname  getqueryanalyzer
private void readschema inputsource is
log info
try
// pass the config resource loader to avoid building an empty one for no reason:
// in the current case though, the stream is valid so we wont load the resource by name
config schemaconf   new config loader     is
document document   schemaconf getdocument
final xpath xpath   schemaconf getxpath
final list<schemaaware> schemaaware   new arraylist<schemaaware>
node nd    node  xpath evaluate    document  xpathconstants node
if  nd  null
log warn
else
name   nd getnodevalue
log info     name
version   schemaconf getfloat    1 0f
final indexschema schema   this
abstractpluginloader<fieldtype> fieldloader   new abstractpluginloader<fieldtype>     true  true
@override
protected fieldtype create  resourceloader loader  string name  string classname  node node   throws exception
fieldtype ft    fieldtype loader newinstance classname
ft settypename name
string expression
node anode    node xpath evaluate expression  node  xpathconstants node
analyzer queryanalyzer   readanalyzer anode
// an analyzer without a type specified, or with type="index"
expression
anode    node xpath evaluate expression  node  xpathconstants node
analyzer analyzer   readanalyzer anode
if  queryanalyzer  null  queryanalyzer analyzer
if  analyzer  null  analyzer queryanalyzer
if  analyzer  null
ft setanalyzer analyzer
ft setqueryanalyzer queryanalyzer
if  ft instanceof schemaaware
schemaaware add  schemaaware  ft
return ft
@override
protected void init fieldtype plugin  node node  throws exception
map<string string> params   domutil tomapexcept  node getattributes
plugin setargs schema  params
@override
protected fieldtype register string name  fieldtype plugin  throws exception
log trace     plugin
return fieldtypes put  name  plugin
string expression
nodelist nodes    nodelist  xpath evaluate expression  document  xpathconstants nodeset
fieldloader load  loader  nodes
// hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key
map<string boolean> explicitrequiredprop   new hashmap<string  boolean>
arraylist<dynamicfield> dfields   new arraylist<dynamicfield>
expression
nodes    nodelist  xpath evaluate expression  document  xpathconstants nodeset
for  int i 0  i<nodes getlength    i
node node   nodes item i
namednodemap attrs   node getattributes
string name   domutil getattr attrs
log trace   name
string type   domutil getattr attrs       name
fieldtype ft   fieldtypes get type
if  ft  null
throw new solrexception  solrexception errorcode bad_request     type       name false
map<string string> args   domutil tomapexcept attrs
if  args get         null
explicitrequiredprop put  name  boolean valueof  args get
schemafield f   schemafield create name ft args
if  node getnodename   equals
schemafield old   fields put f getname   f
if  old    null
string msg
f getname       old tostring
throwable t   new solrexception  solrexception errorcode server_error  msg
solrexception logonce log null t
solrconfig severeerrors add  t
log debug     f
if  f getdefaultvalue      null
log debug name     f getdefaultvalue
fieldswithdefaultvalue add  f
if  f isrequired
log debug name
requiredfields add f
else if  node getnodename   equals
// make sure nothing else has the same path
adddynamicfield dfields  f
else
// we should never get here
throw new runtimeexception
//fields with default values are by definition required
//add them to required fields, and we only have to loop once
// in documentbuilder.getdoc()
requiredfields addall getfieldswithdefaultvalue
// ok, now sort the dynamic fields largest to smallest size so we don't get
// any false matches.  we want to act like a compiler tool and try and match
// the largest string possible.
collections sort dfields
log trace     dfields
// stuff it in a normal array for faster access
dynamicfields   dfields toarray new dynamicfield
node node    node  xpath evaluate    document  xpathconstants node
if  node  null
similarityfactory   new similarityfactory
@override
public similarity getsimilarity
return similarity getdefault
log debug
else
final object obj   loader newinstance   element  node  getattribute
if  obj instanceof similarityfactory
// configure a factory, get a similarity back
solrparams params   solrparams tosolrparams domutil childnodestonamedlist node
similarityfactory    similarityfactory obj
similarityfactory init params
else
// just like always, assume it's a similarlity and get a classcastexception - reasonable error handling
similarityfactory   new similarityfactory
@override
public similarity getsimilarity
return  similarity  obj
if  similarityfactory instanceof schemaaware
schemaaware add  schemaaware  similarityfactory
log debug     similarityfactory getclass   getname
node    node  xpath evaluate    document  xpathconstants node
if  node  null
log warn
else
defaultsearchfieldname node getnodevalue   trim
// throw exception if specified, but not found or not indexed
if  defaultsearchfieldname  null
schemafield defaultsearchfield   getfields   get defaultsearchfieldname
if   defaultsearchfield    null      defaultsearchfield indexed
string msg        defaultsearchfieldname
throw new solrexception  solrexception errorcode server_error  msg
log info   defaultsearchfieldname
node    node  xpath evaluate    document  xpathconstants node
if  node  null
log debug
else
queryparserdefaultoperator node getnodevalue   trim
log info   queryparserdefaultoperator
node    node  xpath evaluate    document  xpathconstants node
if  node  null
log warn
else
uniquekeyfield getindexedfield node getnodevalue   trim
if   uniquekeyfield stored
log error
if  uniquekeyfield multivalued
log error
uniquekeyfieldname uniquekeyfield getname
uniquekeyfieldtype uniquekeyfield gettype
log info   uniquekeyfieldname
// unless the uniquekeyfield is marked 'required=false' then make sure it exists
if  boolean false    explicitrequiredprop get  uniquekeyfieldname
uniquekeyfield required   true
requiredfields add uniquekeyfield
/////////////// parse out copyfield commands ///////////////
// map<string,arraylist<schemafield>> cfields = new hashmap<string,arraylist<schemafield>>();
// expression = "/schema/copyfield";
dynamiccopyfields   new dynamiccopy
expression
nodes    nodelist  xpath evaluate expression  document  xpathconstants nodeset
for  int i 0  i<nodes getlength    i
node   nodes item i
namednodemap attrs   node getattributes
string source   domutil getattr attrs
string dest     domutil getattr attrs
string maxchars   domutil getattr attrs
int maxcharsint   copyfield unlimited
if  maxchars    null
try
maxcharsint   integer parseint maxchars
catch  numberformatexception e
log warn
source       dest
registercopyfield source  dest  maxcharsint
for  map entry<schemafield  integer> entry   copyfieldtargetcounts entryset
if  entry getvalue   > 1     entry getkey   multivalued
log warn     entry getkey   name
entry getvalue
//run the callbacks on schemaaware now that everything else is done
for  schemaaware aware   schemaaware
aware inform this
catch  solrexception e
solrconfig severeerrors add  e
throw e
catch exception e
// unexpected exception...
solrconfig severeerrors add  e
throw new solrexception  solrexception errorcode server_error   e false
// create the field analyzers
refreshanalyzers
private void adddynamicfield list<dynamicfield> dfields  schemafield f
boolean dup   isduplicatedynfield dfields  f
if   dup
adddynamicfieldnodupcheck dfields  f
else
string msg
f getname         f tostring
throwable t   new solrexception solrexception errorcode server_error  msg
solrexception logonce log  null  t
solrconfig severeerrors add t
/**
* register one or more new dynamic field with the schema.
* @param f the {@link org.apache.solr.schema.schemafield}
*/
public void registerdynamicfield schemafield     f
list<dynamicfield> dynfields   new arraylist<dynamicfield> arrays aslist dynamicfields
for  schemafield field   f
if  isduplicatedynfield dynfields  field     false
log debug     field getname
adddynamicfieldnodupcheck dynfields  field
else
log debug     field getname
collections sort dynfields
dynamicfields   dynfields toarray new dynamicfield
private void adddynamicfieldnodupcheck list<dynamicfield> dfields  schemafield f
dfields add new dynamicfield f
log debug     f
private boolean isduplicatedynfield list<dynamicfield> dfields  schemafield f
for  dynamicfield df   dfields
if  df regex equals  f name     return true
return false
public void registercopyfield  string source  string dest
registercopyfield source  dest  copyfield unlimited
/**
* <p>
* note: this function is not thread safe.  however, it is safe to use within the standard
* <code>inform( solrcore core )</code> function for <code>solrcoreaware</code> classes.
* outside <code>inform</code>, this could potentially throw a concurrentmodificationexception
* </p>
*
* @see solrcoreaware
*/
public void registercopyfield  string source  string dest  int maxchars
boolean sourceispattern   iswildcard source
boolean destispattern     iswildcard dest
log debug   source   dest   maxchars
schemafield d   getfieldornull dest
if d    null
throw new solrexception  solrexception errorcode server_error    dest
if sourceispattern
if  destispattern
dynamicfield df   null
for  dynamicfield dd   dynamicfields
if  dd regex equals  dest
df   dd
break
if  df    null
throw new solrexception  solrexception errorcode server_error
registerdynamiccopyfield new dynamicdestcopy source  df  maxchars
else
registerdynamiccopyfield new dynamiccopy source  d  maxchars
else if  destispattern
string msg
throw new solrexception  solrexception errorcode server_error  msg
else
// retrieve the field to force an exception if it doesn't exist
schemafield f   getfield source
list<copyfield> copyfieldlist   copyfieldsmap get source
if  copyfieldlist    null
copyfieldlist   new arraylist<copyfield>
copyfieldsmap put source  copyfieldlist
copyfieldlist add new copyfield f  d  maxchars
copyfieldtargetcounts put d   copyfieldtargetcounts containskey d  ? copyfieldtargetcounts get d    1   1
private void registerdynamiccopyfield  dynamiccopy dcopy
if  dynamiccopyfields    null
dynamiccopyfields   new dynamiccopy  dcopy
else
dynamiccopy temp   new dynamiccopy
system arraycopy dynamiccopyfields 0 temp 0 dynamiccopyfields length
temp   dcopy
dynamiccopyfields   temp
log trace     dcopy
private static object append object orig  object item
object newarr    object java lang reflect array newinstance orig getclass   getcomponenttype    orig length 1
system arraycopy orig  0  newarr  0  orig length
newarr   item
return newarr
//
// <analyzer><tokenizer class="...."/><tokenizer class="...." arg="....">
//
//
private analyzer readanalyzer node node  throws xpathexpressionexception
// parent node used to be passed in as "fieldtype"
// if (!fieldtype.haschildnodes()) return null;
// node node = domutil.getchild(fieldtype,"analyzer");
if  node    null  return null
namednodemap attrs   node getattributes
string analyzername   domutil getattr attrs
if  analyzername    null
// no need to be core-aware as analyzers are not in the core-aware list
final class<? extends analyzer> clazz   loader findclass analyzername  assubclass analyzer class
try
try
// first try to use a ctor with version parameter (needed for many new analyzers that have no default one anymore)
constructor<? extends analyzer> cnstr   clazz getconstructor version class
final string matchversionstr   domutil getattr attrs  lucene_match_version_param
final version lucenematchversion    matchversionstr    null  ?
solrconfig lucenematchversion   config parseluceneversionstring matchversionstr
if  lucenematchversion    null
throw new solrexception  solrexception errorcode server_error
clazz getname
return cnstr newinstance lucenematchversion
catch  nosuchmethodexception nsme
// otherwise use default ctor
return clazz newinstance
catch  exception e
throw new solrexception  solrexception errorcode server_error
analyzername
xpath xpath   xpathfactory newinstance   newxpath
// load the charfilters
// --------------------------------------------------------------------------------
final arraylist<charfilterfactory> charfilters   new arraylist<charfilterfactory>
abstractpluginloader<charfilterfactory> charfilterloader
new abstractpluginloader<charfilterfactory>     false  false
@override
protected void init charfilterfactory plugin  node node  throws exception
if  plugin    null
final map<string string> params   domutil tomapexcept node getattributes
// copy the lucenematchversion from config, if not set
if   params containskey lucene_match_version_param
params put lucene_match_version_param  solrconfig lucenematchversion tostring
plugin init  params
charfilters add  plugin
@override
protected charfilterfactory register string name  charfilterfactory plugin  throws exception
return null     used for map registration
charfilterloader load  solrconfig getresourceloader     nodelist xpath evaluate    node  xpathconstants nodeset
// load the tokenizer
// although an analyzer only allows a single tokenizer, we load a list to make sure
// the configuration is ok
// --------------------------------------------------------------------------------
final arraylist<tokenizerfactory> tokenizers   new arraylist<tokenizerfactory> 1
abstractpluginloader<tokenizerfactory> tokenizerloader
new abstractpluginloader<tokenizerfactory>     false  false
@override
protected void init tokenizerfactory plugin  node node  throws exception
if   tokenizers isempty
throw new solrexception  solrexception errorcode server_error
node
final map<string string> params   domutil tomapexcept node getattributes
// copy the lucenematchversion from config, if not set
if   params containskey lucene_match_version_param
params put lucene_match_version_param  solrconfig lucenematchversion tostring
plugin init  params
tokenizers add  plugin
@override
protected tokenizerfactory register string name  tokenizerfactory plugin  throws exception
return null     used for map registration
tokenizerloader load  loader   nodelist xpath evaluate    node  xpathconstants nodeset
// make sure something was loaded
if  tokenizers isempty
throw new solrexception solrexception errorcode server_error
// load the filters
// --------------------------------------------------------------------------------
final arraylist<tokenfilterfactory> filters   new arraylist<tokenfilterfactory>
abstractpluginloader<tokenfilterfactory> filterloader
new abstractpluginloader<tokenfilterfactory>     false  false
@override
protected void init tokenfilterfactory plugin  node node  throws exception
if  plugin    null
final map<string string> params   domutil tomapexcept node getattributes
// copy the lucenematchversion from config, if not set
if   params containskey lucene_match_version_param
params put lucene_match_version_param  solrconfig lucenematchversion tostring
plugin init  params
filters add  plugin
@override
protected tokenfilterfactory register string name  tokenfilterfactory plugin  throws exception
return null     used for map registration
filterloader load  loader   nodelist xpath evaluate    node  xpathconstants nodeset
return new tokenizerchain charfilters toarray new charfilterfactory
tokenizers get 0   filters toarray new tokenfilterfactory
static abstract class dynamicreplacement implements comparable<dynamicreplacement>
final static int starts_with 1
final static int ends_with 2
final string regex
final int type
final string str
protected dynamicreplacement string regex
this regex   regex
if  regex startswith
type ends_with
str regex substring 1
else if  regex endswith
type starts_with
str regex substring 0 regex length   1
else
throw new runtimeexception
public boolean matches string name
if  type  starts_with    name startswith str   return true
else if  type  ends_with    name endswith str   return true
else return false
/**
* sort order is based on length of regex.  longest comes first.
* @param other the object to compare to.
* @return a negative integer, zero, or a positive integer
* as this object is less than, equal to, or greater than
* the specified object.
*/
public int compareto dynamicreplacement other
return other regex length     regex length
//
// instead of storing a type, this could be implemented as a hierarchy
// with a virtual matches().
// given how often a search will be done, however, speed is the overriding
// concern and i'm not sure which is faster.
//
final static class dynamicfield extends dynamicreplacement
final schemafield prototype
dynamicfield schemafield prototype
super prototype name
this prototype prototype
schemafield makeschemafield string name
// could have a cache instead of returning a new one each time, but it might
// not be worth it.
// actually, a higher level cache could be worth it to avoid too many
// .startswith() and .endswith() comparisons.  it depends on how many
// dynamic fields there are.
return new schemafield prototype  name
@override
public string tostring
return prototype tostring
static class dynamiccopy extends dynamicreplacement
final schemafield targetfield
final int maxchars
dynamiccopy string regex  schemafield targetfield
this regex  targetfield  copyfield unlimited
dynamiccopy string regex  schemafield targetfield  int maxchars
super regex
this targetfield   targetfield
this maxchars   maxchars
public schemafield gettargetfield  string sourcefield
return targetfield
@override
public string tostring
return targetfield tostring
static class dynamicdestcopy extends dynamiccopy
final dynamicfield dynamic
final int dtype
final string dstr
dynamicdestcopy string source  dynamicfield dynamic
this source  dynamic  copyfield unlimited
dynamicdestcopy string source  dynamicfield dynamic  int maxchars
super source  dynamic prototype  maxchars
this dynamic   dynamic
string dest   dynamic regex
if  dest startswith
dtype ends_with
dstr dest substring 1
else if  dest endswith
dtype starts_with
dstr dest substring 0 dest length   1
else
throw new runtimeexception
@override
public schemafield gettargetfield  string sourcefield
string dyn     type  starts_with
? sourcefield substring  str length
sourcefield substring  0  sourcefield length   str length
string name    dtype  starts_with  ?  dstr dyn     dyn dstr
return dynamic makeschemafield  name
@override
public string tostring
return targetfield tostring
public schemafield getdynamicfieldprototypes
schemafield df   new schemafield
for  int i 0 i<dynamicfields length i
df   dynamicfields prototype
return df
public string getdynamicpattern string fieldname
for  dynamicfield df   dynamicfields
if  df matches fieldname   return df regex
return  null
/**
* does the schema have the specified field defined explicitly, i.e.
* not as a result of a copyfield declaration with a wildcard?  we
* consider it explicitly defined if it matches a field or dynamicfield
* declaration.
* @param fieldname
* @return true if explicitly declared in the schema.
*/
public boolean hasexplicitfield string fieldname
if fields containskey fieldname
return true
for  dynamicfield df   dynamicfields
if  df matches fieldname   return true
return false
/**
* is the specified field dynamic or not.
* @param fieldname
* @return true if the specified field is dynamic
*/
public boolean isdynamicfield string fieldname
if fields containskey fieldname
return false
for  dynamicfield df   dynamicfields
if  df matches fieldname   return true
return false
/**
* returns the schemafield that should be used for the specified field name, or
* null if none exists.
*
* @param fieldname may be an explicitly defined field or a name that
* matches a dynamic field.
* @see #getfieldtype
* @see #getfield(string)
* @return the {@link org.apache.solr.schema.schemafield}
*/
public schemafield getfieldornull string fieldname
schemafield f   fields get fieldname
if  f    null  return f
for  dynamicfield df   dynamicfields
if  df matches fieldname   return df makeschemafield fieldname
return f
/**
* returns the schemafield that should be used for the specified field name
*
* @param fieldname may be an explicitly defined field or a name that
* matches a dynamic field.
* @throws solrexception if no such field exists
* @see #getfieldtype
* @see #getfieldornull(string)
* @return the {@link schemafield}
*/
public schemafield getfield string fieldname
schemafield f   getfieldornull fieldname
if  f    null  return f
// hmmm, default field could also be implemented with a dynamic field of "*".
// it would have to be special-cased and only used if nothing else matched.
/***  removed -ycs
if (defaultfieldtype != null) return new schemafield(fieldname,defaultfieldtype);
***/
throw new solrexception  solrexception errorcode bad_request   fieldname
/**
* returns the fieldtype for the specified field name.
*
* <p>
* this method exists because it can be more efficient then
* {@link #getfield} for dynamic fields if a full schemafield isn't needed.
* </p>
*
* @param fieldname may be an explicitly created field, or a name that
* excercies a dynamic field.
* @throws solrexception if no such field exists
* @see #getfield(string)
* @see #getfieldtypenoex
*/
public fieldtype getfieldtype string fieldname
schemafield f   fields get fieldname
if  f    null  return f gettype
return getdynamicfieldtype fieldname
/**
* given the name of a {@link org.apache.solr.schema.fieldtype} (not to be confused with {@link #getfieldtype(string)} which
* takes in the name of a field), return the {@link org.apache.solr.schema.fieldtype}.
* @param fieldtypename the name of the {@link org.apache.solr.schema.fieldtype}
* @return the {@link org.apache.solr.schema.fieldtype} or null.
*/
public fieldtype getfieldtypebyname string fieldtypename
return fieldtypes get fieldtypename
/**
* returns the fieldtype for the specified field name.
*
* <p>
* this method exists because it can be more efficient then
* {@link #getfield} for dynamic fields if a full schemafield isn't needed.
* </p>
*
* @param fieldname may be an explicitly created field, or a name that
* excercies a dynamic field.
* @return null if field is not defined.
* @see #getfield(string)
* @see #getfieldtypenoex
*/
public fieldtype getfieldtypenoex string fieldname
schemafield f   fields get fieldname
if  f    null  return f gettype
return dynfieldtype fieldname
/**
* returns the fieldtype of the best matching dynamic field for
* the specified field name
*
* @param fieldname may be an explicitly created field, or a name that
* excercies a dynamic field.
* @throws solrexception if no such field exists
* @see #getfield(string)
* @see #getfieldtypenoex
*/
public fieldtype getdynamicfieldtype string fieldname
for  dynamicfield df   dynamicfields
if  df matches fieldname   return df prototype gettype
throw new solrexception  solrexception errorcode bad_request   fieldname
private fieldtype dynfieldtype string fieldname
for  dynamicfield df   dynamicfields
if  df matches fieldname   return df prototype gettype
return null
/**
* get all copy fields, both the static and the dynamic ones.
* @param destfield
* @return array of fields copied into this field
*/
public schemafield getcopysources string destfield
schemafield f   getfield destfield
if   iscopyfieldtarget f
return new schemafield
list<schemafield> sf   new arraylist<schemafield>
for  map entry<string  list<copyfield>> cfs   copyfieldsmap entryset
for  copyfield copyfield   cfs getvalue
if  copyfield getdestination   getname   equals destfield
sf add copyfield getsource
return sf toarray new schemafield
/**
* get all copy fields, both the static and the dynamic ones.
*
* @param sourcefield
* @return array of fields to copy to.
* @deprecated use {@link #getcopyfieldslist(string)} instead.
*/
@deprecated
public schemafield getcopyfields string sourcefield
// this is the list that holds all the results, dynamic or not.
list<schemafield> matchcopyfields   new arraylist<schemafield>
// get the dynamic results into the list.
for dynamiccopy dynamiccopy   dynamiccopyfields
if dynamiccopy matches sourcefield
matchcopyfields add dynamiccopy gettargetfield sourcefield
// get the fixed ones, if there are any and add them.
final list<copyfield> copyfields   copyfieldsmap get sourcefield
if  copyfields  null
final iterator<copyfield> it   copyfields iterator
while  it hasnext
matchcopyfields add it next   getdestination
// construct the results by transforming the list into an array.
return matchcopyfields toarray new schemafield
/**
* get all copy fields for a specified source field, both static
* and dynamic ones.
* @param sourcefield
* @return list of copyfields to copy to.
* @since solr 1.4
*/
// this is useful when we need the maxsize param of each copyfield
public list<copyfield> getcopyfieldslist final string sourcefield
final list<copyfield> result   new arraylist<copyfield>
for  dynamiccopy dynamiccopy   dynamiccopyfields
if  dynamiccopy matches sourcefield
result add new copyfield getfield sourcefield   dynamiccopy gettargetfield sourcefield   dynamiccopy maxchars
list<copyfield> fixedcopyfields   copyfieldsmap get sourcefield
if  fixedcopyfields    null
result addall fixedcopyfields
return result
/**
* check if a field is used as the destination of a copyfield operation
*
* @since solr 1.3
*/
public boolean iscopyfieldtarget  schemafield f
return copyfieldtargetcounts containskey  f
/**
* is the given field name a wildcard?  i.e. does it begin or end with *?
* @param name
* @return true/false
*/
private static boolean iswildcard string name
return  name startswith       name endswith