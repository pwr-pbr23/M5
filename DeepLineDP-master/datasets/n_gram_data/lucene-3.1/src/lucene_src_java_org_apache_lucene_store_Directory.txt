package org apache lucene store
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java io filenotfoundexception
import java io ioexception
import java io closeable
import java util collection
import org apache lucene index indexfilenamefilter
import org apache lucene util ioutils
/** a directory is a flat list of files.  files may be written once, when they
* are created.  once a file is created it may only be opened for read, or
* deleted.  random access is permitted both when reading and writing.
*
* <p> java's i/o apis not used directly, but rather all i/o is
* through this api.  this permits things such as: <ul>
* <li> implementation of ram-based indices;
* <li> implementation indices stored in a database, via jdbc;
* <li> implementation of an index as a single file;
* </ul>
*
* directory locking is implemented by an instance of {@link
* lockfactory}, and can be changed for each directory
* instance using {@link #setlockfactory}.
*
*/
public abstract class directory implements closeable
volatile protected boolean isopen   true
/** holds the lockfactory instance (implements locking for
* this directory instance). */
protected lockfactory lockfactory
/**
* returns an array of strings, one for each file in the directory.
*
* @throws nosuchdirectoryexception if the directory is not prepared for any
*         write operations (such as {@link #createoutput(string)}).
* @throws ioexception in case of other io errors
*/
public abstract string listall   throws ioexception
/** returns true iff a file with the given name exists. */
public abstract boolean fileexists string name
throws ioexception
/** returns the time the named file was last modified. */
public abstract long filemodified string name
throws ioexception
/** set the modified time of an existing file to now. */
public abstract void touchfile string name
throws ioexception
/** removes an existing file in the directory. */
public abstract void deletefile string name
throws ioexception
/**
* returns the length of a file in the directory. this method follows the
* following contract:
* <ul>
* <li>throws {@link filenotfoundexception} if the file does not exist
* <li>returns a value &ge;0 if the file exists, which specifies its length.
* </ul>
*
* @param name the name of the file for which to return the length.
* @throws filenotfoundexception if the file does not exist.
* @throws ioexception if there was an io error while retrieving the file's
*         length.
*/
public abstract long filelength string name  throws ioexception
/** creates a new, empty file in the directory with the given name.
returns a stream writing this file. */
public abstract indexoutput createoutput string name
throws ioexception
/**
* ensure that any writes to this file are moved to
* stable storage.  lucene uses this to properly commit
* changes to the index, to prevent a machine/os crash
* from corrupting the index.
* @deprecated use {@link #sync(collection)} instead.
* for easy migration you can change your code to call
* sync(collections.singleton(name))
*/
@deprecated
public void sync string name  throws ioexception      todo 4 0 kill me
/**
* ensure that any writes to these files are moved to
* stable storage.  lucene uses this to properly commit
* changes to the index, to prevent a machine/os crash
* from corrupting the index.<br/>
* <br/>
* note: clients may call this method for same files over
* and over again, so some impls might optimize for that.
* for other impls the operation can be a noop, for various
* reasons.
*/
public void sync collection<string> names  throws ioexception      todo 4 0 make me abstract
for  string name   names
sync name
/** returns a stream reading an existing file. */
public abstract indexinput openinput string name
throws ioexception
/** returns a stream reading an existing file, with the
* specified read buffer size.  the particular directory
* implementation may ignore the buffer size.  currently
* the only directory implementations that respect this
* parameter are {@link fsdirectory} and {@link
* org.apache.lucene.index.compoundfilereader}.
*/
public indexinput openinput string name  int buffersize  throws ioexception
return openinput name
/** construct a {@link lock}.
* @param name the name of the lock file
*/
public lock makelock string name
return lockfactory makelock name
/**
* attempt to clear (forcefully unlock and remove) the
* specified lock.  only call this at a time when you are
* certain this lock is no longer in use.
* @param name name of the lock to be cleared.
*/
public void clearlock string name  throws ioexception
if  lockfactory    null
lockfactory clearlock name
/** closes the store. */
public abstract void close
throws ioexception
/**
* set the lockfactory that this directory instance should
* use for its locking implementation.  each * instance of
* lockfactory should only be used for one directory (ie,
* do not share a single instance across multiple
* directories).
*
* @param lockfactory instance of {@link lockfactory}.
*/
public void setlockfactory lockfactory lockfactory  throws ioexception
assert lockfactory    null
this lockfactory   lockfactory
lockfactory setlockprefix this getlockid
/**
* get the lockfactory that this directory instance is
* using for its locking implementation.  note that this
* may be null for directory implementations that provide
* their own locking implementation.
*/
public lockfactory getlockfactory
return this lockfactory
/**
* return a string identifier that uniquely differentiates
* this directory instance from other directory instances.
* this id should be the same if two directory instances
* (even in different jvms and/or on different machines)
* are considered "the same index".  this is how locking
* "scopes" to the right index.
*/
public string getlockid
return this tostring
@override
public string tostring
return super tostring         getlockfactory
/**
* copies the file <i>src</i> to {@link directory} <i>to</i> under the new
* file name <i>dest</i>.
* <p>
* if you want to copy the entire source directory to the destination one, you
* can do so like this:
*
* <pre>
* directory to; // the directory to copy to
* for (string file : dir.listall()) {
*   dir.copy(to, file, newfile); // newfile can be either file, or a new name
* }
* </pre>
* <p>
* <b>note:</b> this method does not check whether <i>dest<i> exist and will
* overwrite it if it does.
*/
public void copy directory to  string src  string dest  throws ioexception
indexoutput os   to createoutput dest
indexinput is   openinput src
ioexception priorexception   null
try
is copybytes os  is length
catch  ioexception ioe
priorexception   ioe
finally
ioutils closesafely priorexception  os  is
/**
* copy contents of a directory src to a directory dest. if a file in src
* already exists in dest then the one in dest will be blindly overwritten.
* <p>
* <b>note:</b> the source directory cannot change while this method is
* running. otherwise the results are undefined and you could easily hit a
* filenotfoundexception.
* <p>
* <b>note:</b> this method only copies files that look like index files (ie,
* have extensions matching the known extensions of index files).
*
* @param src source directory
* @param dest destination directory
* @param closedirsrc if <code>true</code>, call {@link #close()} method on
*        source directory
* @deprecated should be replaced with calls to
*             {@link #copy(directory, string, string)} for every file that
*             needs copying. you can use the following code:
*
* <pre>
* indexfilenamefilter filter = indexfilenamefilter.getfilter();
* for (string file : src.listall()) {
*   if (filter.accept(null, file)) {
*     src.copy(dest, file, file);
*   }
* }
* </pre>
*/
@deprecated
public static void copy directory src  directory dest  boolean closedirsrc  throws ioexception
indexfilenamefilter filter   indexfilenamefilter getfilter
for  string file   src listall
if  filter accept null  file
src copy dest  file  file
if  closedirsrc
src close
/**
* @throws alreadyclosedexception if this directory is closed
*/
protected final void ensureopen   throws alreadyclosedexception
if   isopen
throw new alreadyclosedexception