package org apache solr spelling
/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
import java util arraylist
import java util collections
import java util iterator
import java util linkedhashmap
import java util list
import java util map
import java util nosuchelementexception
import org apache lucene analysis token
/**
* <p>
* given a list of possible spelling corrections for multiple mis-spelled words
* in a query, this iterator returns possible correction combinations ordered by
* reasonable probability that such a combination will return actual hits if
* re-queried. this implementation simply ranks the possible combinations by the
* sum of their component ranks.
* </p>
*
*/
public class possibilityiterator implements iterator<rankedspellpossibility>
private list<list<spellcheckcorrection>> possibilitylist   new arraylist<list<spellcheckcorrection>>
private list<rankedspellpossibility> rankedpossibilitylist   new arraylist<rankedspellpossibility>
private iterator<rankedspellpossibility> rankedpossibilityiterator
private int correctionindex
private boolean done   false
@suppresswarnings
private possibilityiterator
throw new assertionerror
/**
* <p>
* we assume here that the passed-in inner linkedhashmaps are already sorted
* in order of "best possible correction".
* </p>
*
* @param suggestions
*/
public possibilityiterator map<token  linkedhashmap<string  integer>> suggestions
for  map entry<token  linkedhashmap<string  integer>> entry   suggestions entryset
token token   entry getkey
list<spellcheckcorrection> possiblecorrections   new arraylist<spellcheckcorrection>
for  map entry<string  integer> entry1   entry getvalue   entryset
spellcheckcorrection correction   new spellcheckcorrection
correction setoriginal token
correction setcorrection entry1 getkey
correction setnumberofoccurences entry1 getvalue
possiblecorrections add correction
possibilitylist add possiblecorrections
int wrapsize   possibilitylist size
if  wrapsize    0
done   true
else
correctionindex   new int
for  int i   0  i < wrapsize  i
int suggestsize   possibilitylist get i  size
if  suggestsize    0
done   true
break
correctionindex   0
while  internalhasnext
rankedpossibilitylist add internalnext
collections sort rankedpossibilitylist
rankedpossibilityiterator   rankedpossibilitylist iterator
private boolean internalhasnext
return  done
/**
* <p>
* this method is converting the independent linkhashmaps containing various
* (silo'ed) suggestions for each mis-spelled word into individual
* "holistic query corrections", aka. "spell check possibility"
* </p>
* <p>
* rank here is the sum of each selected term's position in its respective
* linkedhashmap.
* </p>
*
* @return
*/
private rankedspellpossibility internalnext
if  done
throw new nosuchelementexception
list<spellcheckcorrection> possiblecorrection   new arraylist<spellcheckcorrection>
int rank   0
for  int i   0  i < correctionindex length  i
list<spellcheckcorrection> singlewordpossibilities   possibilitylist get i
spellcheckcorrection singlewordpossibility   singlewordpossibilities get correctionindex
rank    correctionindex
if  i    correctionindex length   1
correctionindex
if  correctionindex    singlewordpossibilities size
correctionindex   0
if  correctionindex length    1
done   true
for  int ii   i   1  ii >  0  ii
correctionindex
if  correctionindex >  possibilitylist get ii  size      ii > 0
correctionindex   0
else
break
possiblecorrection add singlewordpossibility
if correctionindex    possibilitylist get 0  size
done   true
rankedspellpossibility rsl   new rankedspellpossibility
rsl setcorrections possiblecorrection
rsl setrank rank
return rsl
public boolean hasnext
return rankedpossibilityiterator hasnext
public rankedspellpossibility next
return rankedpossibilityiterator next
public void remove
throw new unsupportedoperationexception