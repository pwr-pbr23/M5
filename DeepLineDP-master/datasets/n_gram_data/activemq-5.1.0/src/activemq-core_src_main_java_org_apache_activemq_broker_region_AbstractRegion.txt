/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region
import java util arraylist
import java util hashmap
import java util iterator
import java util list
import java util map
import java util set
import java util concurrent concurrenthashmap
import javax jms jmsexception
import org apache activemq broker connectioncontext
import org apache activemq broker consumerbrokerexchange
import org apache activemq broker destinationalreadyexistsexception
import org apache activemq broker producerbrokerexchange
import org apache activemq command activemqdestination
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messagedispatchnotification
import org apache activemq command messagepull
import org apache activemq command producerinfo
import org apache activemq command removesubscriptioninfo
import org apache activemq command response
import org apache activemq filter destinationfilter
import org apache activemq filter destinationmap
import org apache activemq security securitycontext
import org apache activemq thread taskrunnerfactory
import org apache activemq usage systemusage
import org apache commons logging log
import org apache commons logging logfactory
/**
* @version $revision: 1.14 $
*/
public abstract class abstractregion implements region
private static final log log   logfactory getlog abstractregion class
protected final map<activemqdestination  destination> destinations   new concurrenthashmap<activemqdestination  destination>
protected final destinationmap destinationmap   new destinationmap
protected final map<consumerid  subscription> subscriptions   new concurrenthashmap<consumerid  subscription>
protected final systemusage usagemanager
protected final destinationfactory destinationfactory
protected final destinationstatistics destinationstatistics
protected final regionbroker broker
protected boolean autocreatedestinations   true
protected final taskrunnerfactory taskrunnerfactory
protected final object destinationsmutex   new object
protected final map<consumerid  object> consumerchangemutexmap   new hashmap<consumerid  object>
protected boolean started
public abstractregion regionbroker broker  destinationstatistics destinationstatistics  systemusage memorymanager  taskrunnerfactory taskrunnerfactory
destinationfactory destinationfactory
if  broker    null
throw new illegalargumentexception
this broker   broker
this destinationstatistics   destinationstatistics
this usagemanager   memorymanager
this taskrunnerfactory   taskrunnerfactory
if  broker    null
throw new illegalargumentexception
this destinationfactory   destinationfactory
public final  void start   throws exception
started   true
set<activemqdestination> inactivedests   getinactivedestinations
for  iterator<activemqdestination> iter   inactivedests iterator    iter hasnext
activemqdestination dest   iter next
connectioncontext context   new connectioncontext
context setbroker broker getbrokerservice   getbroker
context setsecuritycontext securitycontext broker_security_context
context getbroker   adddestination context  dest
synchronized  destinationsmutex
for  iterator<destination> i   destinations values   iterator    i hasnext
destination dest   i next
dest start
public void stop   throws exception
started   false
synchronized  destinationsmutex
for  iterator<destination> i   destinations values   iterator    i hasnext
destination dest   i next
dest stop
destinations clear
public destination adddestination connectioncontext context  activemqdestination destination  throws exception
log debug     destination
synchronized  destinationsmutex
destination dest   destinations get destination
if  dest    null
dest   createdestination context  destination
// intercept if there is a valid interceptor defined
destinationinterceptor destinationinterceptor   broker getdestinationinterceptor
if  destinationinterceptor    null
dest   destinationinterceptor intercept dest
dest start
destinations put destination  dest
destinationmap put destination  dest
addsubscriptionsfordestination context  dest
return dest
protected list<subscription> addsubscriptionsfordestination connectioncontext context  destination dest  throws exception
list<subscription> rc   new arraylist<subscription>
// add all consumers that are interested in the destination.
for  iterator<subscription> iter   subscriptions values   iterator    iter hasnext
subscription sub   iter next
if  sub matches dest getactivemqdestination
dest addsubscription context  sub
rc add sub
return rc
public void removedestination connectioncontext context  activemqdestination destination  long timeout  throws exception
// no timeout.. then try to shut down right way, fails if there are
// current subscribers.
if  timeout    0
for  iterator<subscription> iter   subscriptions values   iterator    iter hasnext
subscription sub   iter next
if  sub matches destination
throw new jmsexception     destination
if  timeout > 0
// todo: implement a way to notify the subscribers that we want to
// take the down
// the destination and that they should un-subscribe.. then wait up
// to timeout time before
// dropping the subscription.
log debug     destination
synchronized  destinationsmutex
destination dest   destinations remove destination
if  dest    null
// timeout<0 or we timed out, we now force any remaining
// subscriptions to un-subscribe.
for  iterator<subscription> iter   subscriptions values   iterator    iter hasnext
subscription sub   iter next
if  sub matches destination
dest removesubscription context  sub
destinationmap removeall destination
dispose context dest
destinationinterceptor destinationinterceptor   broker getdestinationinterceptor
if  destinationinterceptor    null
destinationinterceptor remove dest
else
log debug     dest
/**
* provide an exact or wildcard lookup of destinations in the region
*
* @return a set of matching destination objects.
*/
public set getdestinations activemqdestination destination
synchronized  destinationsmutex
return destinationmap get destination
public map<activemqdestination  destination> getdestinationmap
synchronized  destinationsmutex
return new hashmap<activemqdestination  destination> destinations
public subscription addconsumer connectioncontext context  consumerinfo info  throws exception
log debug     info getconsumerid
activemqdestination destination   info getdestination
if  destination    null     destination ispattern       destination iscomposite
// lets auto-create the destination
lookup context  destination
object addguard
synchronized  consumerchangemutexmap
addguard   consumerchangemutexmap get info getconsumerid
if  addguard    null
addguard   new object
consumerchangemutexmap put info getconsumerid    addguard
synchronized  addguard
subscription o   subscriptions get info getconsumerid
if  o    null
log warn
return o
// we may need to add some destinations that are in persistent store
// but not active
// in the broker.
//
// todo: think about this a little more. this is good cause
// destinations are not loaded into
// memory until a client needs to use the queue, but a management
// agent viewing the
// broker will not see a destination that exists in persistent
// store. we may want to
// eagerly load all destinations into the broker but have an
// inactive state for the
// destination which has reduced memory usage.
//
destinationfilter parsefilter info getdestination
subscription sub   createsubscription context  info
subscriptions put info getconsumerid    sub
// at this point we're done directly manipulating subscriptions,
// but we need to retain the synchronized block here. consider
// otherwise what would happen if at this point a second
// thread added, then removed, as would be allowed with
// no mutex held. remove is only essentially run once
// so everything after this point would be leaked.
// add the subscription to all the matching queues.
// but copy the matches first - to prevent deadlocks
list<destination>addlist   new arraylist<destination>
synchronized destinationsmutex
for  iterator iter   destinationmap get info getdestination    iterator    iter hasnext
destination dest    destination iter next
addlist add dest
for  destination dest addlist
dest addsubscription context  sub
if  info isbrowser
queuebrowsersubscription sub  destinationsadded
return sub
/**
* get all the destinations that are in storage
*
* @return set of all stored destinations
*/
public set getdurabledestinations
return destinationfactory getdestinations
/**
* @return all destinations that don't have active consumers
*/
protected set<activemqdestination> getinactivedestinations
set<activemqdestination> inactivedests   destinationfactory getdestinations
synchronized  destinationsmutex
inactivedests removeall destinations keyset
return inactivedests
public void removeconsumer connectioncontext context  consumerinfo info  throws exception
log debug     info getconsumerid
subscription sub   subscriptions remove info getconsumerid
//the sub could be removed elsewhere - see connectionsplitbroker
if  sub    null
// remove the subscription from all the matching queues.
synchronized  destinationsmutex
for  iterator iter   destinationmap get info getdestination
iterator    iter hasnext
destination dest    destination  iter next
dest removesubscription context  sub
destroysubscription sub
synchronized  consumerchangemutexmap
consumerchangemutexmap remove info getconsumerid
protected void destroysubscription subscription sub
sub destroy
public void removesubscription connectioncontext context  removesubscriptioninfo info  throws exception
throw new jmsexception
public void send final producerbrokerexchange producerexchange  message messagesend  throws exception
final connectioncontext context   producerexchange getconnectioncontext
if  producerexchange ismutable      producerexchange getregiondestination      null
final destination regiondestination   lookup context  messagesend getdestination
producerexchange setregiondestination regiondestination
producerexchange getregiondestination   send producerexchange  messagesend
public void acknowledge consumerbrokerexchange consumerexchange  messageack ack  throws exception
subscription sub   consumerexchange getsubscription
if  sub    null
sub   subscriptions get ack getconsumerid
if  sub    null
//networked subscriptions are going to acknowledge in flight messages
//on behalf a subscription that is no more ...
if   consumerexchange getconnectioncontext   isnetworkconnection
throw new illegalargumentexception     ack getconsumerid
else
return
consumerexchange setsubscription sub
sub acknowledge consumerexchange getconnectioncontext    ack
public response messagepull connectioncontext context  messagepull pull  throws exception
subscription sub   subscriptions get pull getconsumerid
if  sub    null
throw new illegalargumentexception     pull getconsumerid
return sub pullmessage context  pull
protected destination lookup connectioncontext context  activemqdestination destination  throws exception
synchronized  destinationsmutex
destination dest   destinations get destination
if  dest    null
if  autocreatedestinations
// try to auto create the destination... re-invoke broker
// from the
// top so that the proper security checks are performed.
try
context getbroker   adddestination context  destination
// dest = adddestination(context, destination);
catch  destinationalreadyexistsexception e
// if the destination already exists then lets ignore
// this error
// we should now have the dest created.
dest   destinations get destination
if  dest    null
throw new jmsexception     destination
return dest
public void processdispatchnotification messagedispatchnotification messagedispatchnotification  throws exception
subscription sub   subscriptions get messagedispatchnotification getconsumerid
if  sub    null
sub processmessagedispatchnotification messagedispatchnotification
public void gc
for  iterator<subscription> iter   subscriptions values   iterator    iter hasnext
subscription sub   iter next
sub gc
synchronized  destinationsmutex
for  iterator<destination> iter   destinations values   iterator    iter hasnext
destination dest   iter next
dest gc
protected abstract subscription createsubscription connectioncontext context  consumerinfo info  throws exception
protected destination createdestination connectioncontext context  activemqdestination destination  throws exception
return destinationfactory createdestination context  destination  destinationstatistics
public boolean isautocreatedestinations
return autocreatedestinations
public void setautocreatedestinations boolean autocreatedestinations
this autocreatedestinations   autocreatedestinations
public void addproducer connectioncontext context  producerinfo info  throws exception
synchronized  destinationsmutex
for  iterator iter   destinationmap get info getdestination    iterator    iter hasnext
destination dest    destination  iter next
dest addproducer context  info
/**
* removes a producer.
* @param context the environment the operation is being executed under.
* @throws exception todo
*/
public void removeproducer connectioncontext context  producerinfo info  throws exception
synchronized  destinationsmutex
for  iterator iter   destinationmap get info getdestination    iterator    iter hasnext
destination dest    destination iter next
dest removeproducer context  info
protected void dispose connectioncontext context destination dest  throws exception
dest dispose context
dest stop