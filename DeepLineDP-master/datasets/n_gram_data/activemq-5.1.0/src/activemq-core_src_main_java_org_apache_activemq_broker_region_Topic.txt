/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region
import java io ioexception
import java util linkedlist
import java util set
import java util concurrent concurrenthashmap
import java util concurrent copyonwritearraylist
import java util concurrent copyonwritearrayset
import org apache activemq advisory advisorysupport
import org apache activemq broker brokerservice
import org apache activemq broker connectioncontext
import org apache activemq broker producerbrokerexchange
import org apache activemq broker region policy deadletterstrategy
import org apache activemq broker region policy dispatchpolicy
import org apache activemq broker region policy fixedsizedsubscriptionrecoverypolicy
import org apache activemq broker region policy nosubscriptionrecoverypolicy
import org apache activemq broker region policy shareddeadletterstrategy
import org apache activemq broker region policy simpledispatchpolicy
import org apache activemq broker region policy subscriptionrecoverypolicy
import org apache activemq command activemqdestination
import org apache activemq command activemqtopic
import org apache activemq command exceptionresponse
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messageid
import org apache activemq command producerack
import org apache activemq command producerinfo
import org apache activemq command response
import org apache activemq command subscriptioninfo
import org apache activemq filter messageevaluationcontext
import org apache activemq filter noncachedmessageevaluationcontext
import org apache activemq state producerstate
import org apache activemq store messagerecoverylistener
import org apache activemq store topicmessagestore
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq thread valve
import org apache activemq transaction synchronization
import org apache activemq util subscriptionkey
import org apache commons logging log
import org apache commons logging logfactory
/**
* the topic is a destination that sends a copy of a message to every active
* subscription registered.
*
* @version $revision: 1.21 $
*/
public class topic  extends basedestination  implements task
protected static final log log   logfactory getlog topic class
private final topicmessagestore topicstore
protected final copyonwritearraylist<subscription> consumers   new copyonwritearraylist<subscription>
protected final valve dispatchvalve   new valve true
private dispatchpolicy dispatchpolicy   new simpledispatchpolicy
private subscriptionrecoverypolicy subscriptionrecoverypolicy
private boolean sendadvisoryifnoconsumers
private deadletterstrategy deadletterstrategy   new shareddeadletterstrategy
private final concurrenthashmap<subscriptionkey  durabletopicsubscription> durablesubcribers   new concurrenthashmap<subscriptionkey  durabletopicsubscription>
private final taskrunner taskrunner
private final linkedlist<runnable> messageswaitingforspace   new linkedlist<runnable>
private final runnable sendmessageswaitingforspacetask   new runnable
public void run
try
topic this taskrunner wakeup
catch  interruptedexception e
public topic brokerservice brokerservice  activemqdestination destination  topicmessagestore store  destinationstatistics parentstats
taskrunnerfactory taskfactory  throws exception
super brokerservice  store  destination  parentstats
this topicstore store
//set default subscription recovery policy
if  destination istemporary      advisorysupport isadvisorytopic destination
subscriptionrecoverypolicy  new nosubscriptionrecoverypolicy
else
//set the default
subscriptionrecoverypolicy  new fixedsizedsubscriptionrecoverypolicy
this taskrunner   taskfactory createtaskrunner this      destination getphysicalname
public void initialize   throws exception
super initialize
if  store    null
int messagecount   store getmessagecount
destinationstatistics getmessages   setcount messagecount
public boolean lock messagereference node  lockowner sub
return true
public void addsubscription connectioncontext context  final subscription sub  throws exception
sub add context  this
destinationstatistics getconsumers   increment
if   sub getconsumerinfo   isdurable
// do a retroactive recovery if needed.
if  sub getconsumerinfo   isretroactive
// synchronize with dispatch method so that no new messages are
// sent
// while we are recovering a subscription to avoid out of order
// messages.
dispatchvalve turnoff
try
synchronized  consumers
consumers add sub
subscriptionrecoverypolicy recover context  this  sub
finally
dispatchvalve turnon
else
synchronized  consumers
consumers add sub
else
durabletopicsubscription dsub    durabletopicsubscription sub
durablesubcribers put dsub getsubscriptionkey    dsub
public void removesubscription connectioncontext context  subscription sub  throws exception
if   sub getconsumerinfo   isdurable
destinationstatistics getconsumers   decrement
synchronized  consumers
consumers remove sub
sub remove context  this
public void deletesubscription connectioncontext context  subscriptionkey key  throws ioexception
if  topicstore    null
topicstore deletesubscription key clientid  key subscriptionname
object removed   durablesubcribers remove key
if  removed    null
destinationstatistics getconsumers   decrement
public void activate connectioncontext context  final durabletopicsubscription subscription  throws exception
// synchronize with dispatch method so that no new messages are sent
// while
// we are recovering a subscription to avoid out of order messages.
dispatchvalve turnoff
try
synchronized  consumers
consumers add subscription
if  topicstore    null
return
// recover the durable subscription.
string clientid   subscription getsubscriptionkey   getclientid
string subscriptionname   subscription getsubscriptionkey   getsubscriptionname
string selector   subscription getconsumerinfo   getselector
subscriptioninfo info   topicstore lookupsubscription clientid  subscriptionname
if  info    null
// check to see if selector changed.
string s1   info getselector
if  s1    null ^ selector    null     s1    null     s1 equals selector
// need to delete the subscription
topicstore deletesubscription clientid  subscriptionname
info   null
// do we need to create the subscription?
if info  null
info new subscriptioninfo
info setclientid clientid
info setselector selector
info setsubscriptionname subscriptionname
info setdestination getactivemqdestination
// thi destination is an actual destination id.
info setsubscribeddestination subscription getconsumerinfo   getdestination
// this destination might be a pattern
topicstore addsubsciption info subscription getconsumerinfo   isretroactive
final messageevaluationcontext msgcontext   new noncachedmessageevaluationcontext
msgcontext setdestination destination
if  subscription isrecoveryrequired
topicstore recoversubscription clientid  subscriptionname  new messagerecoverylistener
public boolean recovermessage message message  throws exception
message setregiondestination topic this
try
msgcontext setmessagereference message
if  subscription matches message  msgcontext
subscription add message
catch  interruptedexception e
thread currentthread   interrupt
catch  ioexception e
// todo: need to handle this better.
e printstacktrace
return true
public boolean recovermessagereference messageid messagereference  throws exception
throw new runtimeexception
public boolean hasspace
return true
finally
dispatchvalve turnon
public void deactivate connectioncontext context  durabletopicsubscription sub  throws exception
synchronized  consumers
consumers remove sub
sub remove context  this
protected void recoverretroactivemessages connectioncontext context  subscription subscription  throws exception
if  subscription getconsumerinfo   isretroactive
subscriptionrecoverypolicy recover context  this  subscription
public void send final producerbrokerexchange producerexchange  final message message  throws exception
final connectioncontext context   producerexchange getconnectioncontext
final producerinfo producerinfo   producerexchange getproducerstate   getinfo
final boolean sendproducerack    message isresponserequired      producerinfo getwindowsize   > 0     context isinrecoverymode
// there is delay between the client sending it and it arriving at the
// destination.. it may have expired.
if  broker isexpired message
broker messageexpired context  message
destinationstatistics getmessages   decrement
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
return
if  isproducerflowcontrol      context isproducerflowcontrol      memoryusage isfull
if  systemusage issendfailifnospace
throw new javax jms resourceallocationexception
// we can avoid blocking due to low usage if the producer is sending
// a sync message or
// if it is using a producer window
if  producerinfo getwindowsize   > 0    message isresponserequired
synchronized  messageswaitingforspace
messageswaitingforspace add new runnable
public void run
try
// while waiting for space to free up... the
// message may have expired.
if  broker isexpired message
broker messageexpired context  message
//destinationstatistics.getenqueues().increment();
//destinationstatistics.getmessages().decrement();
else
domessagesend producerexchange  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
else
response response   new response
response setcorrelationid message getcommandid
context getconnection   dispatchasync response
catch  exception e
if   sendproducerack     context isinrecoverymode
exceptionresponse response   new exceptionresponse e
response setcorrelationid message getcommandid
context getconnection   dispatchasync response
// if the user manager is not full, then the task will not
// get called..
if   memoryusage notifycallbackwhennotfull sendmessageswaitingforspacetask
// so call it directly here.
sendmessageswaitingforspacetask run
context setdontsendreponse true
return
else
// producer flow control cannot be used, so we have do the flow
// control at the broker
// by blocking this thread until there is space available.
int count   0
while   memoryusage waitforspace 1000
if  context getstopping   get
throw new ioexception
if  count > 2    context isintransaction
count  0
int size   context gettransaction   size
log warn     size       message
// the usage manager could have delayed us by the time
// we unblock the message could have expired..
if  message isexpired
if  log isdebugenabled
log debug     message
return
domessagesend producerexchange  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
/**
* do send the message - this needs to be synchronized to ensure messages are stored and dispatched in
* the right order
* @param producerexchange
* @param message
* @throws ioexception
* @throws exception
*/
synchronized void domessagesend
final producerbrokerexchange producerexchange  final message message
throws ioexception  exception
final connectioncontext context   producerexchange
getconnectioncontext
message setregiondestination this
message getmessageid   setbrokersequenceid getdestinationsequenceid
if  topicstore    null    message ispersistent
canoptimizeoutpersistence
while   systemusage getstoreusage   waitforspace 1000
if  context getstopping   get
throw new ioexception
topicstore addmessage context  message
message incrementreferencecount
if  context isintransaction
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
// it could take while before we receive the commit
// operration.. by that time the message could have
// expired..
if  broker isexpired message
broker messageexpired context  message
message decrementreferencecount
//destinationstatistics.getenqueues().increment();
//destinationstatistics.getmessages().decrement();
return
try
dispatch context  message
finally
message decrementreferencecount
else
try
dispatch context  message
finally
message decrementreferencecount
private boolean canoptimizeoutpersistence
return durablesubcribers size      0
public string tostring
return     destination getphysicalname         consumers size
public void acknowledge connectioncontext context  subscription sub  final messageack ack  final messagereference node  throws ioexception
if  topicstore    null    node ispersistent
durabletopicsubscription dsub    durabletopicsubscription sub
subscriptionkey key   dsub getsubscriptionkey
topicstore acknowledge context  key getclientid    key getsubscriptionname    node getmessageid
public void dispose connectioncontext context  throws ioexception
if  topicstore    null
topicstore removeallmessages context
destinationstatistics setparent null
public void gc
public message loadmessage messageid messageid  throws ioexception
return topicstore    null ? topicstore getmessage messageid    null
public void start   throws exception
this subscriptionrecoverypolicy start
if  memoryusage    null
memoryusage start
public void stop   throws exception
if  taskrunner    null
taskrunner shutdown
this subscriptionrecoverypolicy stop
if  memoryusage    null
memoryusage stop
public message browse
final set<message> result   new copyonwritearrayset<message>
try
if  topicstore    null
topicstore recover new messagerecoverylistener
public boolean recovermessage message message  throws exception
result add message
return true
public boolean recovermessagereference messageid messagereference  throws exception
return true
public boolean hasspace
return true
message msgs   subscriptionrecoverypolicy browse getactivemqdestination
if  msgs    null
for  int i   0  i < msgs length  i
result add msgs
catch  throwable e
log warn     getactivemqdestination   getphysicalname    e
return result toarray new message
public boolean iterate
synchronized messageswaitingforspace
while   memoryusage isfull       messageswaitingforspace isempty
runnable op   messageswaitingforspace removefirst
op run
return false
// properties
// -------------------------------------------------------------------------
public dispatchpolicy getdispatchpolicy
return dispatchpolicy
public void setdispatchpolicy dispatchpolicy dispatchpolicy
this dispatchpolicy   dispatchpolicy
public subscriptionrecoverypolicy getsubscriptionrecoverypolicy
return subscriptionrecoverypolicy
public void setsubscriptionrecoverypolicy subscriptionrecoverypolicy subscriptionrecoverypolicy
this subscriptionrecoverypolicy   subscriptionrecoverypolicy
public boolean issendadvisoryifnoconsumers
return sendadvisoryifnoconsumers
public void setsendadvisoryifnoconsumers boolean sendadvisoryifnoconsumers
this sendadvisoryifnoconsumers   sendadvisoryifnoconsumers
public deadletterstrategy getdeadletterstrategy
return deadletterstrategy
public void setdeadletterstrategy deadletterstrategy deadletterstrategy
this deadletterstrategy   deadletterstrategy
// implementation methods
// -------------------------------------------------------------------------
public final void wakeup
protected void dispatch final connectioncontext context  message message  throws exception
destinationstatistics getmessages   increment
destinationstatistics getenqueues   increment
dispatchvalve increment
try
if   subscriptionrecoverypolicy add context  message
return
synchronized  consumers
if  consumers isempty
onmessagewithnoconsumers context  message
return
messageevaluationcontext msgcontext   context getmessageevaluationcontext
msgcontext setdestination destination
msgcontext setmessagereference message
if   dispatchpolicy dispatch message  msgcontext  consumers
onmessagewithnoconsumers context  message
finally
dispatchvalve decrement
/**
* provides a hook to allow messages with no consumer to be processed in
* some way - such as to send to a dead letter queue or something..
*/
protected void onmessagewithnoconsumers connectioncontext context  message message  throws exception
if   message ispersistent
if  sendadvisoryifnoconsumers
// allow messages with no consumers to be dispatched to a dead
// letter queue
if   advisorysupport isadvisorytopic destination
// the original destination and transaction id do not get
// filled when the message is first sent,
// it is only populated if the message is routed to another
// destination like the dlq
if  message getoriginaldestination      null
message setoriginaldestination message getdestination
if  message getoriginaltransactionid      null
message setoriginaltransactionid message gettransactionid
activemqtopic advisorytopic   advisorysupport getnotopicconsumersadvisorytopic destination
message setdestination advisorytopic
message settransactionid null
// disable flow control for this since since we don't want
// to block.
boolean originalflowcontrol   context isproducerflowcontrol
try
context setproducerflowcontrol false
producerbrokerexchange producerexchange   new producerbrokerexchange
producerexchange setmutable false
producerexchange setconnectioncontext context
producerexchange setproducerstate new producerstate new producerinfo
context getbroker   send producerexchange  message
finally
context setproducerflowcontrol originalflowcontrol
public void messageexpired connectioncontext context  prefetchsubscription prefetchsubscription  messagereference node
// todo auto-generated method stub