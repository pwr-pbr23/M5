/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq
import java util hashmap
import java util iterator
import java util linkedlist
import java util list
import java util map
import java util concurrent executorservice
import java util concurrent executors
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomicreference
import javax jms illegalstateexception
import javax jms invaliddestinationexception
import javax jms jmsexception
import javax jms message
import javax jms messagelistener
import org apache activemq command activemqdestination
import org apache activemq command activemqmessage
import org apache activemq command activemqtempdestination
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command messageack
import org apache activemq command messagedispatch
import org apache activemq command messagepull
import org apache activemq management jmsconsumerstatsimpl
import org apache activemq management statscapable
import org apache activemq management statsimpl
import org apache activemq selector selectorparser
import org apache activemq thread scheduler
import org apache activemq transaction synchronization
import org apache activemq util callback
import org apache activemq util introspectionsupport
import org apache activemq util jmsexceptionsupport
import org apache commons logging log
import org apache commons logging logfactory
/**
* a client uses a <code>messageconsumer</code> object to receive messages
* from a destination. a <code> messageconsumer</code> object is created by
* passing a <code>destination</code> object to a message-consumer creation
* method supplied by a session.
* <p>
* <code>messageconsumer</code> is the parent interface for all message
* consumers.
* <p>
* a message consumer can be created with a message selector. a message selector
* allows the client to restrict the messages delivered to the message consumer
* to those that match the selector.
* <p>
* a client may either synchronously receive a message consumer's messages or
* have the consumer asynchronously deliver them as they arrive.
* <p>
* for synchronous receipt, a client can request the next message from a message
* consumer using one of its <code> receive</code> methods. there are several
* variations of <code>receive</code> that allow a client to poll or wait for
* the next message.
* <p>
* for asynchronous delivery, a client can register a
* <code>messagelistener</code> object with a message consumer. as messages
* arrive at the message consumer, it delivers them by calling the
* <code>messagelistener</code>'s<code>
* onmessage</code> method.
* <p>
* it is a client programming error for a <code>messagelistener</code> to
* throw an exception.
*
* @version $revision: 1.22 $
* @see javax.jms.messageconsumer
* @see javax.jms.queuereceiver
* @see javax.jms.topicsubscriber
* @see javax.jms.session
*/
public class activemqmessageconsumer implements messageavailableconsumer  statscapable  activemqdispatcher
private static final log log   logfactory getlog activemqmessageconsumer class
protected final activemqsession session
protected final consumerinfo info
// these are the messages waiting to be delivered to the client
private final messagedispatchchannel unconsumedmessages   new messagedispatchchannel
// the are the messages that were delivered to the consumer but that have
// not been acknowledged. it's kept in reverse order since we
// always walk list in reverse order. only used when session is client ack.
private final linkedlist<messagedispatch> deliveredmessages   new linkedlist<messagedispatch>
private int deliveredcounter
private int additionalwindowsize
private long redeliverydelay
private int ackcounter
private int dispatchedcount
private final atomicreference<messagelistener> messagelistener   new atomicreference<messagelistener>
private jmsconsumerstatsimpl stats
private final string selector
private boolean synchronizationregistered
private atomicboolean started   new atomicboolean false
private messageavailablelistener availablelistener
private redeliverypolicy redeliverypolicy
private boolean optimizeacknowledge
private atomicboolean deliveryingacknowledgements   new atomicboolean
private executorservice executorservice
private messagetransformer transformer
private boolean cleardispatchlist
/**
* create a messageconsumer
*
* @param session
* @param dest
* @param name
* @param selector
* @param prefetch
* @param maximumpendingmessagecount todo
* @param nolocal
* @param browser
* @param dispatchasync
* @param messagelistener
* @throws jmsexception
*/
public activemqmessageconsumer activemqsession session  consumerid consumerid  activemqdestination dest
string name  string selector  int prefetch
int maximumpendingmessagecount  boolean nolocal  boolean browser
boolean dispatchasync  messagelistener messagelistener  throws jmsexception
if  dest    null
throw new invaliddestinationexception
else if  dest getphysicalname      null
throw new invaliddestinationexception
else if  dest istemporary
string physicalname   dest getphysicalname
if  physicalname    null
throw new illegalargumentexception     dest
string connectionid   session connection getconnectioninfo   getconnectionid   getvalue
if  physicalname indexof connectionid  < 0
throw new invaliddestinationexception
if  session connection isdeleted dest
throw new invaliddestinationexception
if  prefetch < 0
throw new jmsexception
this session   session
this redeliverypolicy   session connection getredeliverypolicy
settransformer session gettransformer
this info   new consumerinfo consumerid
this info setexclusive this session connection isexclusiveconsumer
this info setsubscriptionname name
this info setprefetchsize prefetch
this info setcurrentprefetchsize prefetch
this info setmaximumpendingmessagelimit maximumpendingmessagecount
this info setnolocal nolocal
this info setdispatchasync dispatchasync
this info setretroactive this session connection isuseretroactiveconsumer
this info setselector null
// allows the options on the destination to configure the consumerinfo
if  dest getoptions      null
map<string  string> options   new hashmap<string  string> dest getoptions
introspectionsupport setproperties this info  options
this info setdestination dest
this info setbrowser browser
if  selector    null    selector trim   length      0
// validate the selector
new selectorparser   parse selector
this info setselector selector
this selector   selector
else if  info getselector      null
// validate the selector
new selectorparser   parse this info getselector
this selector   this info getselector
else
this selector   null
this stats   new jmsconsumerstatsimpl session getsessionstats    dest
this optimizeacknowledge   session connection isoptimizeacknowledge      session isautoacknowledge
info isbrowser
this info setoptimizedacknowledge this optimizeacknowledge
if  messagelistener    null
setmessagelistener messagelistener
try
this session addconsumer this
this session syncsendpacket info
catch  jmsexception e
this session removeconsumer this
throw e
if  session connection isstarted
start
public statsimpl getstats
return stats
public jmsconsumerstatsimpl getconsumerstats
return stats
public redeliverypolicy getredeliverypolicy
return redeliverypolicy
/**
* sets the redelivery policy used when messages are redelivered
*/
public void setredeliverypolicy redeliverypolicy redeliverypolicy
this redeliverypolicy   redeliverypolicy
public messagetransformer gettransformer
return transformer
/**
* sets the transformer used to transform messages before they are sent on
* to the jms bus
*/
public void settransformer messagetransformer transformer
this transformer   transformer
/**
* @return returns the value.
*/
protected consumerid getconsumerid
return info getconsumerid
/**
* @return the consumer name - used for durable consumers
*/
protected string getconsumername
return this info getsubscriptionname
/**
* @return true if this consumer does not accept locally produced messages
*/
protected boolean isnolocal
return info isnolocal
/**
* retrieve is a browser
*
* @return true if a browser
*/
protected boolean isbrowser
return info isbrowser
/**
* @return activemqdestination
*/
protected activemqdestination getdestination
return info getdestination
/**
* @return returns the prefetchnumber.
*/
public int getprefetchnumber
return info getprefetchsize
/**
* @return true if this is a durable topic subscriber
*/
public boolean isdurablesubscriber
return info getsubscriptionname      null    info getdestination   istopic
/**
* gets this message consumer's message selector expression.
*
* @return this message consumer's message selector, or null if no message
*         selector exists for the message consumer (that is, if the message
*         selector was not set or was set to null or the empty string)
* @throws jmsexception if the jms provider fails to receive the next
*                 message due to some internal error.
*/
public string getmessageselector   throws jmsexception
checkclosed
return selector
/**
* gets the message consumer's <code>messagelistener</code>.
*
* @return the listener for the message consumer, or null if no listener is
*         set
* @throws jmsexception if the jms provider fails to get the message
*                 listener due to some internal error.
* @see javax.jms.messageconsumer#setmessagelistener(javax.jms.messagelistener)
*/
public messagelistener getmessagelistener   throws jmsexception
checkclosed
return this messagelistener get
/**
* sets the message consumer's <code>messagelistener</code>.
* <p>
* setting the message listener to null is the equivalent of unsetting the
* message listener for the message consumer.
* <p>
* the effect of calling <code>messageconsumer.setmessagelistener</code>
* while messages are being consumed by an existing listener or the consumer
* is being used to consume messages synchronously is undefined.
*
* @param listener the listener to which the messages are to be delivered
* @throws jmsexception if the jms provider fails to receive the next
*                 message due to some internal error.
* @see javax.jms.messageconsumer#getmessagelistener
*/
public void setmessagelistener messagelistener listener  throws jmsexception
checkclosed
if  info getprefetchsize      0
throw new jmsexception
if  listener    null
boolean wasrunning   session isrunning
if  wasrunning
session stop
this messagelistener set listener
session redispatch this  unconsumedmessages
if  wasrunning
session start
else
this messagelistener set null
public messageavailablelistener getavailablelistener
return availablelistener
/**
* sets the listener used to notify synchronous consumers that there is a
* message available so that the {@link messageconsumer#receivenowait()} can
* be called.
*/
public void setavailablelistener messageavailablelistener availablelistener
this availablelistener   availablelistener
/**
* used to get an enqueued message from the unconsumedmessages list. the
* amount of time this method blocks is based on the timeout value. - if
* timeout==-1 then it blocks until a message is received. - if timeout==0
* then it it tries to not block at all, it returns a message if it is
* available - if timeout>0 then it blocks up to timeout amount of time.
* expired messages will consumed by this method.
*
* @throws jmsexception
* @return null if we timeout or if the consumer is closed.
*/
private messagedispatch dequeue long timeout  throws jmsexception
try
long deadline   0
if  timeout > 0
deadline   system currenttimemillis     timeout
while  true
messagedispatch md   unconsumedmessages dequeue timeout
if  md    null
if  timeout > 0     unconsumedmessages isclosed
timeout   math max deadline   system currenttimemillis    0
else
return null
else if  md getmessage      null
return null
else if  md getmessage   isexpired
if  log isdebugenabled
log debug getconsumerid         md
beforemessageisconsumed md
aftermessageisconsumed md  true
if  timeout > 0
timeout   math max deadline   system currenttimemillis    0
else
if  log isdebugenabled
log debug getconsumerid         md
return md
catch  interruptedexception e
thread currentthread   interrupt
throw jmsexceptionsupport create e
/**
* receives the next message produced for this message consumer.
* <p>
* this call blocks indefinitely until a message is produced or until this
* message consumer is closed.
* <p>
* if this <code>receive</code> is done within a transaction, the consumer
* retains the message until the transaction commits.
*
* @return the next message produced for this message consumer, or null if
*         this message consumer is concurrently closed
*/
public message receive   throws jmsexception
checkclosed
checkmessagelistener
sendpullcommand 0
messagedispatch md   dequeue  1
if  md    null
return null
beforemessageisconsumed md
aftermessageisconsumed md  false
return createactivemqmessage md
/**
* @param md
* @return
*/
private activemqmessage createactivemqmessage final messagedispatch md  throws jmsexception
activemqmessage m    activemqmessage md getmessage   copy
if  transformer    null
message transformedmessage   transformer consumertransform session  this  m
if  transformedmessage    null
m   activemqmessagetransformation transformmessage transformedmessage  session connection
if  session isclientacknowledge
m setacknowledgecallback new callback
public void execute   throws exception
session checkclosed
session acknowledge
return m
/**
* receives the next message that arrives within the specified timeout
* interval.
* <p>
* this call blocks until a message arrives, the timeout expires, or this
* message consumer is closed. a <code>timeout</code> of zero never
* expires, and the call blocks indefinitely.
*
* @param timeout the timeout value (in milliseconds), a time out of zero
*                never expires.
* @return the next message produced for this message consumer, or null if
*         the timeout expires or this message consumer is concurrently
*         closed
*/
public message receive long timeout  throws jmsexception
checkclosed
checkmessagelistener
if  timeout    0
return this receive
sendpullcommand timeout
while  timeout > 0
messagedispatch md
if  info getprefetchsize      0
md   dequeue  1      we let the broker let us know when we
// timeout.
else
md   dequeue timeout
if  md    null
return null
beforemessageisconsumed md
aftermessageisconsumed md  false
return createactivemqmessage md
return null
/**
* receives the next message if one is immediately available.
*
* @return the next message produced for this message consumer, or null if
*         one is not available
* @throws jmsexception if the jms provider fails to receive the next
*                 message due to some internal error.
*/
public message receivenowait   throws jmsexception
checkclosed
checkmessagelistener
sendpullcommand  1
messagedispatch md
if  info getprefetchsize      0
md   dequeue  1      we let the broker let us know when we
// timeout.
else
md   dequeue 0
if  md    null
return null
beforemessageisconsumed md
aftermessageisconsumed md  false
return createactivemqmessage md
/**
* closes the message consumer.
* <p>
* since a provider may allocate some resources on behalf of a <code>
* messageconsumer</code>
* outside the java virtual machine, clients should close them when they are
* not needed. relying on garbage collection to eventually reclaim these
* resources may not be timely enough.
* <p>
* this call blocks until a <code>receive</code> or message listener in
* progress has completed. a blocked message consumer <code>receive </code>
* call returns null when this message consumer is closed.
*
* @throws jmsexception if the jms provider fails to close the consumer due
*                 to some internal error.
*/
public void close   throws jmsexception
if   unconsumedmessages isclosed
dispose
this session asyncsendpacket info createremovecommand
void clearmessagesinprogress
// we are called from inside the transport reconnection logic
// which involves us clearing all the connections' consumers
// dispatch lists and clearing them
// so rather than trying to grab a mutex (which could be already
// owned by the message listener calling the send) we will just set
// a flag so that the list can be cleared as soon as the
// dispatch thread is ready to flush the dispatch list
cleardispatchlist   true
void deliveracks
messageack ack   null
if  deliveryingacknowledgements compareandset false  true
if  this optimizeacknowledge
synchronized deliveredmessages
if   deliveredmessages isempty
messagedispatch md   deliveredmessages getfirst
ack   new messageack md  messageack standard_ack_type  deliveredmessages size
deliveredmessages clear
ackcounter   0
if  ack    null
final messageack acktosend   ack
if  executorservice    null
executorservice   executors newsinglethreadexecutor
executorservice submit new runnable
public void run
try
session asyncsendpacket acktosend
catch  jmsexception e
log error getconsumerid        e
finally
deliveryingacknowledgements set false
else
deliveryingacknowledgements set false
public void dispose   throws jmsexception
if   unconsumedmessages isclosed
//            if ( !deliveredmessages.isempty() ) {
//                // we need to let the broker know how many times that message
//                // was rolled back.
//                rollbackcounter++;
//                messagedispatch lastmd = deliveredmessages.get(0);
//            }
// do we have any acks we need to send out before closing?
// ack any delivered messages now. (session may still
// commit/rollback the acks).
// only processes optimized acknowledgements
deliveracks
if  executorservice    null
executorservice shutdown
try
executorservice awaittermination 60  timeunit seconds
catch  interruptedexception e
thread currentthread   interrupt
if  session istransacted      session isdupsokacknowledge
acknowledge
if  session isclientacknowledge
if   this info isbrowser
// rollback duplicates that aren't acknowledged
for  messagedispatch old   deliveredmessages
session connection rollbackduplicate this  old getmessage
synchronized deliveredmessages
deliveredmessages clear
list<messagedispatch> list   unconsumedmessages removeall
if   this info isbrowser
for  messagedispatch old   list
// ensure we don't filter this as a duplicate
session connection rollbackduplicate this  old getmessage
unconsumedmessages close
this session removeconsumer this
/**
* @throws illegalstateexception
*/
protected void checkclosed   throws illegalstateexception
if  unconsumedmessages isclosed
throw new illegalstateexception
/**
* if we have a zero prefetch specified then send a pull command to the
* broker to pull a message we are about to receive
*/
protected void sendpullcommand long timeout  throws jmsexception
if  info getprefetchsize      0    unconsumedmessages isempty
messagepull messagepull   new messagepull
messagepull configure info
messagepull settimeout timeout
session asyncsendpacket messagepull
protected void checkmessagelistener   throws jmsexception
session checkmessagelistener
protected void setoptimizeacknowledge boolean value
if  optimizeacknowledge     value
deliveracks
optimizeacknowledge   value
protected void setprefetchsize int prefetch
deliveracks
this info setcurrentprefetchsize prefetch
private void beforemessageisconsumed messagedispatch md  throws jmsexception
md setdeliverysequenceid session getnextdeliveryid
if   session isdupsokacknowledge
synchronized deliveredmessages
deliveredmessages addfirst md
if  session istransacted
acklater md  messageack delivered_ack_type
private void aftermessageisconsumed messagedispatch md  boolean messageexpired  throws jmsexception
if  unconsumedmessages isclosed
return
if  messageexpired
acklater md  messageack delivered_ack_type
else
stats onmessage
if  session istransacted
// do nothing.
else if  session isautoacknowledge
synchronized  deliveredmessages
if   deliveredmessages isempty
if  optimizeacknowledge
if  deliveryingacknowledgements compareandset
false  true
ackcounter
if  ackcounter >   info
getcurrentprefetchsize      65
messageack ack   new messageack md messageack standard_ack_type deliveredmessages size
session asyncsendpacket ack
ackcounter   0
deliveredmessages clear
deliveryingacknowledgements set false
else
messageack ack   new messageack md messageack standard_ack_type deliveredmessages size
session asyncsendpacket ack
deliveredmessages clear
else if  session isdupsokacknowledge
acklater md  messageack standard_ack_type
else if  session isclientacknowledge
acklater md  messageack delivered_ack_type
else
throw new illegalstateexception
private void acklater messagedispatch md  byte acktype  throws jmsexception
// don't acknowledge now, but we may need to let the broker know the
// consumer got the message
// to expand the pre-fetch window
if  session istransacted
session dostarttransaction
if   synchronizationregistered
synchronizationregistered   true
session gettransactioncontext   addsynchronization new synchronization
public void beforeend   throws exception
acknowledge
synchronizationregistered   false
public void aftercommit   throws exception
commit
synchronizationregistered   false
public void afterrollback   throws exception
rollback
synchronizationregistered   false
// the delivered message list is only needed for the recover method
// which is only used with client ack.
deliveredcounter
if   0 5   info getprefetchsize    <   deliveredcounter   additionalwindowsize
messageack ack   new messageack md  acktype  deliveredcounter
ack settransactionid session gettransactioncontext   gettransactionid
session asyncsendpacket ack
additionalwindowsize   deliveredcounter
// when using dups ok, we do a real ack.
if  acktype    messageack standard_ack_type
deliveredcounter   0
additionalwindowsize   0
/**
* acknowledge all the messages that have been delivered to the client upto
* this point.
*
* @throws jmsexception
*/
public void acknowledge   throws jmsexception
synchronized deliveredmessages
if  deliveredmessages isempty
return
// acknowledge the last message.
messagedispatch lastmd   deliveredmessages get 0
messageack ack   new messageack lastmd  messageack standard_ack_type  deliveredmessages size
if  session istransacted
session dostarttransaction
ack settransactionid session gettransactioncontext   gettransactionid
session asyncsendpacket ack
// adjust the counters
deliveredcounter    deliveredmessages size
additionalwindowsize   math max 0  additionalwindowsize   deliveredmessages size
if   session istransacted
deliveredmessages clear
public void commit   throws jmsexception
synchronized  deliveredmessages
deliveredmessages clear
redeliverydelay   0
public void rollback   throws jmsexception
synchronized  unconsumedmessages getmutex
if  optimizeacknowledge
// remove messages read but not acked at the broker yet through
// optimizeacknowledge
if   this info isbrowser
synchronized deliveredmessages
for  int i   0   i < deliveredmessages size        i < ackcounter   i
// ensure we don't filter this as a duplicate
messagedispatch md   deliveredmessages removelast
session connection rollbackduplicate this  md getmessage
synchronized deliveredmessages
if  deliveredmessages isempty
return
// only increase the redlivery delay after the first redelivery..
messagedispatch lastmd   deliveredmessages getfirst
if  lastmd getmessage   getredeliverycounter   > 0
redeliverydelay   redeliverypolicy getredeliverydelay redeliverydelay
for  iterator iter   deliveredmessages iterator    iter hasnext
messagedispatch md    messagedispatch iter next
md getmessage   onmessagerolledback
if  redeliverypolicy getmaximumredeliveries      redeliverypolicy no_maximum_redeliveries
lastmd getmessage   getredeliverycounter   > redeliverypolicy getmaximumredeliveries
// we need to nack the messages so that they get sent to the
// dlq.
// acknowledge the last message.
messageack ack   new messageack lastmd  messageack posion_ack_type  deliveredmessages size
session asyncsendpacket ack
// ensure we don't filter this as a duplicate
session connection rollbackduplicate this  lastmd getmessage
// adjust the window size.
additionalwindowsize   math max 0  additionalwindowsize   deliveredmessages size
redeliverydelay   0
else
messageack ack   new messageack lastmd  messageack redelivered_ack_type  deliveredmessages size
session asyncsendpacket ack
// stop the delivery of messages.
unconsumedmessages stop
for  iterator iter   deliveredmessages iterator    iter hasnext
messagedispatch md    messagedispatch iter next
unconsumedmessages enqueuefirst md
if  redeliverydelay > 0
// start up the delivery again a little later.
scheduler executeafterdelay new runnable
public void run
try
if  started get
start
catch  jmsexception e
session connection onasyncexception e
redeliverydelay
else
start
deliveredcounter    deliveredmessages size
deliveredmessages clear
if  messagelistener get      null
session redispatch this  unconsumedmessages
public void dispatch messagedispatch md
messagelistener listener   this messagelistener get
try
synchronized  unconsumedmessages getmutex
if  cleardispatchlist
// we are reconnecting so lets flush the in progress
// messages
cleardispatchlist   false
list<messagedispatch> list   unconsumedmessages removeall
if   this info isbrowser
for  messagedispatch old   list
// ensure we don't filter this as a duplicate
session connection rollbackduplicate this  old getmessage
if   unconsumedmessages isclosed
if  this info isbrowser       session connection isduplicate this  md getmessage
if  listener    null    unconsumedmessages isrunning
activemqmessage message   createactivemqmessage md
beforemessageisconsumed md
try
boolean expired   message isexpired
if   expired
listener onmessage message
aftermessageisconsumed md  expired
catch  runtimeexception e
if  session isdupsokacknowledge      session isautoacknowledge
// redeliver the message
else
// transacted or client ack: deliver the
// next message.
aftermessageisconsumed md  false
log error getconsumerid         e  e
else
unconsumedmessages enqueue md
if  availablelistener    null
availablelistener onmessageavailable this
else
// ignore duplicate
if  log isdebugenabled
log debug getconsumerid         md getmessage
acklater md  messageack standard_ack_type
if    dispatchedcount % 1000    0
dispatchedcount   0
thread yield
catch  exception e
session connection onasyncexception e
public int getmessagesize
return unconsumedmessages size
public void start   throws jmsexception
if  unconsumedmessages isclosed
return
started set true
unconsumedmessages start
session executor wakeup
public void stop
started set false
unconsumedmessages stop
public string tostring
return     info getconsumerid         started get
/**
* delivers a message to the message listener.
*
* @return
* @throws jmsexception
*/
public boolean iterate
messagelistener listener   this messagelistener get
if  listener    null
messagedispatch md   unconsumedmessages dequeuenowait
if  md    null
try
activemqmessage message   createactivemqmessage md
beforemessageisconsumed md
listener onmessage message
aftermessageisconsumed md  false
catch  jmsexception e
session connection onasyncexception e
return true
return false
public boolean isinuse activemqtempdestination destination
return info getdestination   equals destination