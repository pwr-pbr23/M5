/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region cursors
import java io ioexception
import java util iterator
import java util linkedlist
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomiclong
import org apache activemq broker broker
import org apache activemq broker connectioncontext
import org apache activemq broker region destination
import org apache activemq broker region messagereference
import org apache activemq broker region queuemessagereference
import org apache activemq command message
import org apache activemq filter noncachedmessageevaluationcontext
import org apache activemq kaha commandmarshaller
import org apache activemq kaha listcontainer
import org apache activemq kaha store
import org apache activemq openwire openwireformat
import org apache activemq usage systemusage
import org apache activemq usage usage
import org apache activemq usage usagelistener
import org apache commons logging log
import org apache commons logging logfactory
/**
* persist pending messages pending message (messages awaiting dispatch to a
* consumer) cursor
*
* @version $revision$
*/
public class filependingmessagecursor extends abstractpendingmessagecursor implements usagelistener
private static final log log   logfactory getlog filependingmessagecursor class
private static final atomiclong name_count   new atomiclong
protected broker broker
private store store
private string name
private linkedlist<messagereference> memorylist   new linkedlist<messagereference>
private listcontainer<messagereference> disklist
private iterator<messagereference> iter
private destination regiondestination
private boolean iterating
private boolean flushrequired
private atomicboolean started   new atomicboolean
private messagereference last   null
/**
* @param name
* @param store
*/
public filependingmessagecursor broker broker string name
this broker   broker
//the store can be null if the brokerservice has persistence
//turned off
this store  broker gettempdatastore
this name   name_count incrementandget         name
public void start   throws exception
if  started compareandset false  true
super start
if  systemusage    null
systemusage getmemoryusage   addusagelistener this
public void stop   throws exception
if  started compareandset true  false
super stop
if  systemusage    null
systemusage getmemoryusage   removeusagelistener this
/**
* @return true if there are no pending messages
*/
public synchronized boolean isempty
if memorylist isempty      isdisklistempty
return true
for  iterator<messagereference> iterator   memorylist iterator    iterator hasnext
messagereference node   iterator next
if  node   queuemessagereference null_message
continue
if   node isdropped
return false
// we can remove dropped references.
iterator remove
return isdisklistempty
/**
* reset the cursor
*/
public synchronized void reset
iterating   true
last   null
iter   isdisklistempty   ? memorylist iterator     getdisklist   listiterator
public synchronized void release
iterating   false
if  flushrequired
flushrequired   false
flushtodisk
public synchronized void destroy   throws exception
stop
for  iterator<messagereference> i   memorylist iterator    i hasnext
message node    message i next
node decrementreferencecount
memorylist clear
if   isdisklistempty
getdisklist   clear
public synchronized linkedlist<messagereference> pageinlist int maxitems
linkedlist<messagereference> result   new linkedlist<messagereference>
int count   0
for  iterator<messagereference> i   memorylist iterator    i hasnext      count < maxitems
result add i next
count
if  count < maxitems     isdisklistempty
for  iterator<messagereference> i   getdisklist   iterator    i hasnext      count < maxitems
message message    message i next
message setregiondestination regiondestination
message setmemoryusage this getsystemusage   getmemoryusage
message incrementreferencecount
result add message
count
return result
/**
* add message to await dispatch
*
* @param node
*/
public synchronized void addmessagelast messagereference node
if   node isexpired
try
regiondestination   node getmessage   getregiondestination
if  isdisklistempty
if  hasspace      this store  null
memorylist add node
node incrementreferencecount
return
if   hasspace
if  isdisklistempty
expireoldmessages
if  hasspace
memorylist add node
node incrementreferencecount
return
else
flushtodisk
systemusage gettempusage   waitforspace
getdisklist   add node
catch  exception e
log error     node
e
throw new runtimeexception e
else
discard node
/**
* add message to await dispatch
*
* @param node
*/
public synchronized void addmessagefirst messagereference node
if   node isexpired
try
regiondestination   node getmessage   getregiondestination
if  isdisklistempty
if  hasspace
memorylist addfirst node
node incrementreferencecount
return
if   hasspace
if  isdisklistempty
expireoldmessages
if  hasspace
memorylist addfirst node
node incrementreferencecount
return
else
flushtodisk
systemusage gettempusage   waitforspace
node decrementreferencecount
getdisklist   addfirst node
catch  exception e
log error     node
e
throw new runtimeexception e
else
discard node
/**
* @return true if there pending messages to dispatch
*/
public synchronized boolean hasnext
return iter hasnext
/**
* @return the next pending message
*/
public synchronized messagereference next
message message    message iter next
last   message
if   isdisklistempty
// got from disk
message setregiondestination regiondestination
message setmemoryusage this getsystemusage   getmemoryusage
message incrementreferencecount
return message
/**
* remove the message at the cursor position
*/
public synchronized void remove
iter remove
if  last    null
last decrementreferencecount
/**
* @param node
* @see org.apache.activemq.broker.region.cursors.abstractpendingmessagecursor#remove(org.apache.activemq.broker.region.messagereference)
*/
public synchronized void remove messagereference node
if  memorylist remove node
node decrementreferencecount
if   isdisklistempty
getdisklist   remove node
/**
* @return the number of pending messages
*/
public synchronized int size
return memorylist size      isdisklistempty   ? 0   getdisklist   size
/**
* clear all pending messages
*/
public synchronized void clear
memorylist clear
if   isdisklistempty
getdisklist   clear
last null
public synchronized boolean isfull
// we always have space - as we can persist to disk
return false
public boolean hasmessagesbufferedtodeliver
return  isempty
public void setsystemusage systemusage usagemanager
super setsystemusage usagemanager
public void onusagechanged usage usage  int oldpercentusage
int newpercentusage
if  newpercentusage >  getmemoryusagehighwatermark
synchronized  this
flushrequired   true
if   iterating
expireoldmessages
if   hasspace
flushtodisk
flushrequired   false
public boolean istransient
return true
protected boolean isspaceinmemorylist
return hasspace      isdisklistempty
protected synchronized void expireoldmessages
if   memorylist isempty
linkedlist<messagereference> tmplist   new linkedlist<messagereference> this memorylist
this memorylist   new linkedlist<messagereference>
while   tmplist isempty
messagereference node   tmplist removefirst
if  node isexpired
discard node
else
memorylist add node
protected synchronized void flushtodisk
if   memorylist isempty
while   memorylist isempty
messagereference node   memorylist removefirst
node decrementreferencecount
getdisklist   addlast node
memorylist clear
protected boolean isdisklistempty
return disklist    null    disklist isempty
protected listcontainer<messagereference> getdisklist
if  disklist    null
try
disklist   store getlistcontainer name     true
disklist setmarshaller new commandmarshaller new openwireformat
catch  ioexception e
log error   e
throw new runtimeexception e
return disklist
protected void discard messagereference message
message decrementreferencecount
if  log isdebugenabled
log debug     message
broker getroot   sendtodeadletterqueue new connectioncontext new noncachedmessageevaluationcontext     message