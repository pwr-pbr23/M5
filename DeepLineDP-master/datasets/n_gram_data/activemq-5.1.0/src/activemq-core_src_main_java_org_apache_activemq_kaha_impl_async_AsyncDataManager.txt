/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq kaha impl async
import java io bytearrayinputstream
import java io bytearrayoutputstream
import java io datainputstream
import java io dataoutputstream
import java io file
import java io filenamefilter
import java io ioexception
import java util arraylist
import java util collections
import java util hashmap
import java util hashset
import java util iterator
import java util linkedhashmap
import java util list
import java util map
import java util set
import java util concurrent concurrenthashmap
import java util concurrent atomic atomiclong
import java util concurrent atomic atomicreference
import org apache activemq kaha impl async datafileappender writecommand
import org apache activemq kaha impl async datafileappender writekey
import org apache activemq thread scheduler
import org apache activemq util bytesequence
import org apache commons logging log
import org apache commons logging logfactory
/**
* manages datafiles
*
* @version $revision: 1.1.1.1 $
*/
public class asyncdatamanager
public static final int control_record_max_length   1024
public static final int item_head_reserved_space   21
// item_head_space = length + type+ reserved space + sor
public static final int item_head_space   4   1   item_head_reserved_space   3
public static final int item_head_offset_to_sor   item_head_space   3
public static final int item_foot_space   3     eor
public static final int item_head_foot_space   item_head_space   item_foot_space
public static final byte item_head_sor   new byte
public static final byte item_head_eor   new byte
public static final byte data_item_type   1
public static final byte redo_item_type   2
public static final string default_directory
public static final string default_archive_directory
public static final string default_file_prefix
public static final int default_max_file_length   1024   1024   32
private static final log log   logfactory getlog asyncdatamanager class
protected final map<writekey  writecommand> inflightwrites   new concurrenthashmap<writekey  writecommand>
protected file directory   new file default_directory
protected file directoryarchive   new file  default_archive_directory
protected string fileprefix   default_file_prefix
protected controlfile controlfile
protected boolean started
protected boolean usenio   true
protected int maxfilelength   default_max_file_length
protected int preferedfilelength   default_max_file_length   1024   512
protected datafileappender appender
protected datafileaccessorpool accessorpool   new datafileaccessorpool this
protected map<integer  datafile> filemap   new hashmap<integer  datafile>
protected map<file  datafile> filebyfilemap   new linkedhashmap<file  datafile>
protected datafile currentwritefile
protected location mark
protected final atomicreference<location> lastappendlocation   new atomicreference<location>
protected runnable cleanuptask
protected final atomiclong storesize
protected boolean archivedatalogs
public asyncdatamanager atomiclong storesize
this storesize storesize
public asyncdatamanager
this new atomiclong
@suppresswarnings
public synchronized void start   throws ioexception
if  started
return
started   true
lock
bytesequence sequence   controlfile load
if  sequence    null    sequence getlength   > 0
unmarshallstate sequence
if  usenio
appender   new niodatafileappender this
else
appender   new datafileappender this
file files   directory listfiles new filenamefilter
public boolean accept file dir  string n
return dir equals directory     n startswith fileprefix
if  files    null
for  int i   0  i < files length  i
try
file file   files
string n   file getname
string numstr   n substring fileprefix length    n length
int num   integer parseint numstr
datafile datafile   new datafile file  num  preferedfilelength
filemap put datafile getdatafileid    datafile
storesize addandget datafile getlength
catch  numberformatexception e
// ignore file that do not match the pattern.
// sort the list so that we can link the datafiles together in the
// right order.
list<datafile> l   new arraylist<datafile> filemap values
collections sort l
currentwritefile   null
for  datafile df   l
if  currentwritefile    null
currentwritefile linkafter df
currentwritefile   df
filebyfilemap put df getfile    df
// need to check the current write file to see if there was a partial
// write to it.
if  currentwritefile    null
// see if the lastsyncedlocation is valid..
location l   lastappendlocation get
if  l    null    l getdatafileid      currentwritefile getdatafileid   intvalue
l   null
// if we know the last location that was ok.. then we can skip lots
// of checking
try
l   recoverycheck currentwritefile  l
lastappendlocation set l
catch ioexception e
log warn    e
storestate false
cleanuptask   new runnable
public void run
cleanup
scheduler executeperiodically cleanuptask  1000   30
public void lock   throws ioexception
synchronized  this
if  controlfile    null
directory mkdirs
controlfile   new controlfile new file directory  fileprefix       control_record_max_length
controlfile lock
protected location recoverycheck datafile datafile  location location  throws ioexception
if  location    null
location   new location
location setdatafileid datafile getdatafileid
location setoffset 0
datafileaccessor reader   accessorpool opendatafileaccessor datafile
try
reader readlocationdetails location
while  reader readlocationdetailsandvalidate location
location setoffset location getoffset     location getsize
finally
accessorpool closedatafileaccessor reader
datafile setlength location getoffset
return location
protected void unmarshallstate bytesequence sequence  throws ioexception
bytearrayinputstream bais   new bytearrayinputstream sequence getdata    sequence getoffset    sequence getlength
datainputstream dis   new datainputstream bais
if  dis readboolean
mark   new location
mark readexternal dis
else
mark   null
if  dis readboolean
location l   new location
l readexternal dis
lastappendlocation set l
else
lastappendlocation set null
private synchronized bytesequence marshallstate   throws ioexception
bytearrayoutputstream baos   new bytearrayoutputstream
dataoutputstream dos   new dataoutputstream baos
if  mark    null
dos writeboolean true
mark writeexternal dos
else
dos writeboolean false
location l   lastappendlocation get
if  l    null
dos writeboolean true
l writeexternal dos
else
dos writeboolean false
byte bs   baos tobytearray
return new bytesequence bs  0  bs length
synchronized datafile allocatelocation location location  throws ioexception
if  currentwritefile    null      currentwritefile getlength     location getsize    > maxfilelength
int nextnum   currentwritefile    null ? currentwritefile getdatafileid   intvalue     1   1
string filename   fileprefix   nextnum
file file   new file directory  filename
datafile nextwritefile   new datafile file  nextnum  preferedfilelength
filemap put nextwritefile getdatafileid    nextwritefile
filebyfilemap put file  nextwritefile
if  currentwritefile    null
currentwritefile linkafter nextwritefile
if  currentwritefile isunused
removedatafile currentwritefile
currentwritefile   nextwritefile
location setoffset currentwritefile getlength
location setdatafileid currentwritefile getdatafileid   intvalue
int size   location getsize
currentwritefile incrementlength size
currentwritefile increment
storesize addandget size
return currentwritefile
public synchronized void removelocation location location  throws ioexception
datafile datafile   getdatafile location
datafile decrement
synchronized datafile getdatafile location item  throws ioexception
integer key   integer valueof item getdatafileid
datafile datafile   filemap get key
if  datafile    null
log error     key       filemap
throw new ioexception     fileprefix       item getdatafileid
return datafile
synchronized file getfile location item  throws ioexception
integer key   integer valueof item getdatafileid
datafile datafile   filemap get key
if  datafile    null
log error     key       filemap
throw new ioexception     fileprefix       item getdatafileid
return datafile getfile
private datafile getnextdatafile datafile datafile
return  datafile datafile getnext
public synchronized void close   throws ioexception
if   started
return
scheduler cancel cleanuptask
accessorpool close
storestate false
appender close
filemap clear
filebyfilemap clear
controlfile unlock
controlfile dispose
started   false
synchronized void cleanup
if  accessorpool    null
accessorpool disposeunused
public synchronized boolean delete   throws ioexception
// close all open file handles...
appender close
accessorpool close
boolean result   true
for  iterator i   filemap values   iterator    i hasnext
datafile datafile    datafile i next
storesize addandget  datafile getlength
result    datafile delete
filemap clear
filebyfilemap clear
lastappendlocation set null
mark   null
currentwritefile   null
// reopen open file handles...
accessorpool   new datafileaccessorpool this
if  usenio
appender   new niodatafileappender this
else
appender   new datafileappender this
return result
public synchronized void addinterestinfile int file  throws ioexception
if  file >  0
integer key   integer valueof file
datafile datafile    datafile filemap get key
if  datafile    null
throw new ioexception
addinterestinfile datafile
synchronized void addinterestinfile datafile datafile
if  datafile    null
datafile increment
public synchronized void removeinterestinfile int file  throws ioexception
if  file >  0
integer key   integer valueof file
datafile datafile    datafile filemap get key
removeinterestinfile datafile
synchronized void removeinterestinfile datafile datafile  throws ioexception
if  datafile    null
if  datafile decrement   <  0
removedatafile datafile
public synchronized void consolidatedatafilesnotin set<integer> inuse  set<integer>inprogress  throws ioexception
set<integer> unused   new hashset<integer> filemap keyset
unused removeall inuse
unused removeall inprogress
list<datafile> purgelist   new arraylist<datafile>
for  integer key   unused
datafile datafile    datafile filemap get key
purgelist add datafile
for  datafile datafile   purgelist
forceremovedatafile datafile
public synchronized void consolidatedatafilesnotin set<integer> inuse  integer lastfile  throws ioexception
set<integer> unused   new hashset<integer> filemap keyset
unused removeall inuse
list<datafile> purgelist   new arraylist<datafile>
for  integer key   unused
// only add files less than the lastfile..
if  key intvalue   < lastfile intvalue
datafile datafile    datafile filemap get key
purgelist add datafile
for  datafile datafile   purgelist
forceremovedatafile datafile
public synchronized void consolidatedatafiles   throws ioexception
list<datafile> purgelist   new arraylist<datafile>
for  datafile datafile   filemap values
if  datafile isunused
purgelist add datafile
for  datafile datafile   purgelist
removedatafile datafile
private synchronized void removedatafile datafile datafile  throws ioexception
// make sure we don't delete too much data.
if  datafile    currentwritefile    mark    null    datafile getdatafileid   >  mark getdatafileid
log debug     datafile
return
forceremovedatafile datafile
private synchronized void forceremovedatafile datafile datafile
throws ioexception
accessorpool disposedatafileaccessors datafile
filebyfilemap remove datafile getfile
datafile removed   filemap remove datafile getdatafileid
storesize addandget  datafile getlength
datafile unlink
if  archivedatalogs
datafile move getdirectoryarchive
log debug     datafile
getdirectoryarchive
else
boolean result   datafile delete
log debug     datafile
result ?
/**
* @return the maxfilelength
*/
public int getmaxfilelength
return maxfilelength
/**
* @param maxfilelength the maxfilelength to set
*/
public void setmaxfilelength int maxfilelength
this maxfilelength   maxfilelength
public string tostring
return     fileprefix
public synchronized location getmark   throws illegalstateexception
return mark
public synchronized location getnextlocation location location  throws ioexception  illegalstateexception
location cur   null
while  true
if  cur    null
if  location    null
datafile head    datafile currentwritefile getheadnode
cur   new location
cur setdatafileid head getdatafileid
cur setoffset 0
else
// set to the next offset..
if  location getsize       1
cur   new location location
else
cur   new location location
cur setoffset location getoffset   location getsize
else
cur setoffset cur getoffset     cur getsize
datafile datafile   getdatafile cur
// did it go into the next file??
if  datafile getlength   <  cur getoffset
datafile   getnextdatafile datafile
if  datafile    null
return null
else
cur setdatafileid datafile getdatafileid   intvalue
cur setoffset 0
// load in location size and type.
datafileaccessor reader   accessorpool opendatafileaccessor datafile
try
reader readlocationdetails cur
finally
accessorpool closedatafileaccessor reader
if  cur gettype      0
return null
else if  cur gettype   > 0
// only return user records.
return cur
public synchronized location getnextlocation file file  location lastlocation boolean thisfileonly  throws illegalstateexception  ioexception
datafile df   filebyfilemap get file
return getnextlocation df  lastlocation thisfileonly
public synchronized location getnextlocation datafile datafile
location lastlocation boolean thisfileonly  throws ioexception  illegalstateexception
location cur   null
while  true
if  cur    null
if  lastlocation    null
datafile head    datafile datafile getheadnode
cur   new location
cur setdatafileid head getdatafileid
cur setoffset 0
else
// set to the next offset..
cur   new location lastlocation
cur setoffset cur getoffset     cur getsize
else
cur setoffset cur getoffset     cur getsize
// did it go into the next file??
if  datafile getlength   <  cur getoffset
if  thisfileonly
return null
else
datafile   getnextdatafile datafile
if  datafile    null
return null
else
cur setdatafileid datafile getdatafileid   intvalue
cur setoffset 0
// load in location size and type.
datafileaccessor reader   accessorpool opendatafileaccessor datafile
try
reader readlocationdetails cur
finally
accessorpool closedatafileaccessor reader
if  cur gettype      0
return null
else if  cur gettype   > 0
// only return user records.
return cur
public synchronized bytesequence read location location  throws ioexception  illegalstateexception
datafile datafile   getdatafile location
datafileaccessor reader   accessorpool opendatafileaccessor datafile
bytesequence rc   null
try
rc   reader readrecord location
finally
accessorpool closedatafileaccessor reader
return rc
public void setmark location location  boolean sync  throws ioexception  illegalstateexception
synchronized  this
mark   location
storestate sync
protected synchronized void storestate boolean sync  throws ioexception
bytesequence state   marshallstate
appender storeitem state  location mark_type  sync
controlfile store state  sync
public synchronized location write bytesequence data  boolean sync  throws ioexception  illegalstateexception
location loc   appender storeitem data  location user_type  sync
return loc
public synchronized location write bytesequence data  runnable oncomplete  throws ioexception  illegalstateexception
location loc   appender storeitem data  location user_type  oncomplete
return loc
public synchronized location write bytesequence data  byte type  boolean sync  throws ioexception  illegalstateexception
return appender storeitem data  type  sync
public void update location location  bytesequence data  boolean sync  throws ioexception
datafile datafile   getdatafile location
datafileaccessor updater   accessorpool opendatafileaccessor datafile
try
updater updaterecord location  data  sync
finally
accessorpool closedatafileaccessor updater
public file getdirectory
return directory
public void setdirectory file directory
this directory   directory
public string getfileprefix
return fileprefix
public void setfileprefix string fileprefix
this fileprefix   fileprefix
public map<writekey  writecommand> getinflightwrites
return inflightwrites
public location getlastappendlocation
return lastappendlocation get
public void setlastappendlocation location lastsyncedlocation
this lastappendlocation set lastsyncedlocation
public boolean isusenio
return usenio
public void setusenio boolean usenio
this usenio   usenio
public file getdirectoryarchive
return directoryarchive
public void setdirectoryarchive file directoryarchive
this directoryarchive   directoryarchive
public boolean isarchivedatalogs
return archivedatalogs
public void setarchivedatalogs boolean archivedatalogs
this archivedatalogs   archivedatalogs
synchronized public integer getcurrentdatafileid
if  currentwritefile  null
return null
return currentwritefile getdatafileid
/**
* get a set of files - only valid after start()
* @return files currently being used
*/
public set<file> getfiles
return filebyfilemap keyset
synchronized public long getdisksize
long rc 0
datafile cur    datafile currentwritefile getheadnode
while  cur   null
rc    cur getlength
cur    datafile  cur getnext
return rc
synchronized public long getdisksizeuntil location startposition
long rc 0
datafile cur    datafile currentwritefile getheadnode
while  cur   null
if  cur getdatafileid   intvalue   >  startposition getdatafileid
return rc   startposition getoffset
rc    cur getlength
cur    datafile  cur getnext
return rc