/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region
import java io ioexception
import java util arraylist
import java util collections
import java util comparator
import java util linkedhashmap
import java util linkedlist
import java util list
import java util set
import java util concurrent copyonwritearrayset
import java util concurrent executorservice
import java util concurrent executors
import java util concurrent threadfactory
import java util concurrent locks reentrantlock
import javax jms invalidselectorexception
import javax jms jmsexception
import org apache activemq broker brokerservice
import org apache activemq broker connectioncontext
import org apache activemq broker producerbrokerexchange
import org apache activemq broker region cursors pendingmessagecursor
import org apache activemq broker region cursors storequeuecursor
import org apache activemq broker region cursors vmpendingmessagecursor
import org apache activemq broker region group messagegrouphashbucketfactory
import org apache activemq broker region group messagegroupmap
import org apache activemq broker region group messagegroupmapfactory
import org apache activemq broker region group messagegroupset
import org apache activemq broker region policy deadletterstrategy
import org apache activemq broker region policy dispatchpolicy
import org apache activemq broker region policy roundrobindispatchpolicy
import org apache activemq broker region policy shareddeadletterstrategy
import org apache activemq command activemqdestination
import org apache activemq command consumerid
import org apache activemq command exceptionresponse
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messageid
import org apache activemq command producerack
import org apache activemq command producerinfo
import org apache activemq command response
import org apache activemq filter booleanexpression
import org apache activemq filter messageevaluationcontext
import org apache activemq filter noncachedmessageevaluationcontext
import org apache activemq selector selectorparser
import org apache activemq store messagerecoverylistener
import org apache activemq store messagestore
import org apache activemq thread deterministictaskrunner
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq transaction synchronization
import org apache activemq util brokersupport
import org apache commons logging log
import org apache commons logging logfactory
/**
* the queue is a list of messageentry objects that are dispatched to matching
* subscriptions.
*
* @version $revision: 1.28 $
*/
public class queue extends basedestination implements task
protected static final log log   logfactory getlog queue class
protected taskrunnerfactory taskfactory
protected taskrunner taskrunner
protected final list<subscription> consumers   new arraylist<subscription> 50
protected pendingmessagecursor messages
private final linkedhashmap<messageid queuemessagereference> pagedinmessages   new linkedhashmap<messageid queuemessagereference>
private messagegroupmap messagegroupowners
private dispatchpolicy dispatchpolicy   new roundrobindispatchpolicy
private deadletterstrategy deadletterstrategy   new shareddeadletterstrategy
private messagegroupmapfactory messagegroupmapfactory   new messagegrouphashbucketfactory
private final object sendlock   new object
private executorservice executor
protected final linkedlist<runnable> messageswaitingforspace   new linkedlist<runnable>
private final reentrantlock dispatchlock   new reentrantlock
private boolean useconsumerpriority true
private boolean strictorderdispatch false
private queuedispatchselector  dispatchselector
private boolean optimizeddispatch false
private final runnable sendmessageswaitingforspacetask   new runnable
public void run
wakeup
private final object iteratingmutex   new object
private static final comparator<subscription>orderedcompare   new comparator<subscription>
public int compare subscription s1  subscription s2
//we want the list sorted in descending order
return s2 getconsumerinfo   getpriority     s1 getconsumerinfo   getpriority
public queue brokerservice brokerservice  final activemqdestination destination  messagestore store destinationstatistics parentstats
taskrunnerfactory taskfactory  throws exception
super brokerservice  store  destination  parentstats
this taskfactory taskfactory
this dispatchselector new queuedispatchselector destination
public void initialize   throws exception
if  this messages    null
if  destination istemporary      broker    null    store    null
this messages   new vmpendingmessagecursor
else
this messages   new storequeuecursor broker  this
// if a vmpendingmessagecursor don't use the default producer system usage
// since it turns into a shared blocking queue which can lead to a network deadlock.
// if we are ccursoring to disk..it's not and issue because it does not block due
// to large disk sizes.
if  messages instanceof vmpendingmessagecursor
this systemusage   brokerservice getsystemusage
memoryusage setparent systemusage getmemoryusage
if  isoptimizeddispatch
this taskrunner   taskfactory createtaskrunner this      destination getphysicalname
else
this executor    executors newsinglethreadexecutor new threadfactory
public thread newthread runnable runnable
thread thread   new thread runnable    destination
thread setdaemon true
thread setpriority thread norm_priority
return thread
this taskrunner   new deterministictaskrunner this executor this
super initialize
if  store    null
// restore the persistent messages.
messages setsystemusage systemusage
messages setenableaudit isenableaudit
messages setmaxauditdepth getmaxauditdepth
messages setmaxproducerstoaudit getmaxproducerstoaudit
messages setusecache isusecache
if  messages isrecoveryrequired
store recover new messagerecoverylistener
public boolean recovermessage message message
// message could have expired while it was being
// loaded..
if  broker isexpired message
broker messageexpired createconnectioncontext    message
destinationstatistics getmessages   decrement
return true
if  hasspace
message setregiondestination queue this
synchronized  messages
try
messages addmessagelast message
catch  exception e
log fatal    e
destinationstatistics getmessages   increment
return true
return false
public boolean recovermessagereference messageid messagereference  throws exception
throw new runtimeexception
public boolean hasspace
return true
else
int messagecount   store getmessagecount
destinationstatistics getmessages   setcount messagecount
class recoverydispatch
public arraylist<queuemessagereference> messages
public subscription subscription
linkedlist<recoverydispatch> recoveries   new linkedlist<recoverydispatch>
public void addsubscription connectioncontext context  subscription sub  throws exception
dispatchlock lock
try
sub add context  this
destinationstatistics getconsumers   increment
//            messageevaluationcontext msgcontext = new noncachedmessageevaluationcontext();
// needs to be synchronized - so no contention with dispatching
synchronized  consumers
addtoconsumerlist sub
if  sub getconsumerinfo   isexclusive
subscription exclusiveconsumer   dispatchselector getexclusiveconsumer
if exclusiveconsumer  null
exclusiveconsumer sub
else if  sub getconsumerinfo   getpriority   > exclusiveconsumer getconsumerinfo   getpriority
exclusiveconsumer sub
dispatchselector setexclusiveconsumer exclusiveconsumer
// synchronize with dispatch method so that no new messages are sent
// while
// setting up a subscription. avoid out of order messages,
// duplicates
// etc.
dopagein false
//            msgcontext.setdestination(destination);
synchronized  pagedinmessages
recoverydispatch rd   new recoverydispatch
rd messages    new arraylist<queuemessagereference> pagedinmessages values
rd subscription   sub
recoveries addlast rd
if  sub instanceof queuebrowsersubscription
queuebrowsersubscription sub  incrementqueueref
//                system.out.println(new date()+": locked pagedinmessages: "+sub.getconsumerinfo().getconsumerid());
//                // add all the matching messages in the queue to the
//                // subscription.
//
//                for (queuemessagereference node:pagedinmessages.values()){
//                    if (!node.isdropped() && !node.isacked() && (!node.isdropped() ||sub.getconsumerinfo().isbrowser())) {
//                        msgcontext.setmessagereference(node);
//                        if (sub.matches(node, msgcontext)) {
//                            sub.add(node);
//                        }
//                    }
//                }
//
//            }
wakeup
finally
dispatchlock unlock
public void removesubscription connectioncontext context  subscription sub
throws exception
destinationstatistics getconsumers   decrement
dispatchlock lock
try
// synchronize with dispatch method so that no new messages are sent
// while
// removing up a subscription.
synchronized  consumers
removefromconsumerlist sub
if  sub getconsumerinfo   isexclusive
subscription exclusiveconsumer   dispatchselector
getexclusiveconsumer
if  exclusiveconsumer    sub
exclusiveconsumer   null
for  subscription s   consumers
if  s getconsumerinfo   isexclusive
exclusiveconsumer    null
s getconsumerinfo   getpriority   > exclusiveconsumer
getconsumerinfo   getpriority
exclusiveconsumer   s
dispatchselector setexclusiveconsumer exclusiveconsumer
consumerid consumerid   sub getconsumerinfo   getconsumerid
messagegroupset ownedgroups   getmessagegroupowners
removeconsumer consumerid
// redeliver inflight messages
list<queuemessagereference> list   new arraylist<queuemessagereference>
for  messagereference ref   sub remove context  this
queuemessagereference qmr    queuemessagereference ref
qmr incrementredeliverycounter
if  qmr getlockowner    sub
qmr unlock
qmr incrementredeliverycounter
list add qmr
if   list isempty       consumers isempty
dodispatch list
if  consumers isempty
messages gc
wakeup
finally
dispatchlock unlock
public void send final producerbrokerexchange producerexchange  final message message  throws exception
final connectioncontext context   producerexchange getconnectioncontext
// there is delay between the client sending it and it arriving at the
// destination.. it may have expired.
message setregiondestination this
final producerinfo producerinfo   producerexchange getproducerstate   getinfo
final boolean sendproducerack    message isresponserequired      producerinfo getwindowsize   > 0     context isinrecoverymode
if  message isexpired
broker getroot   messageexpired context  message
//message not added to stats yet
//destinationstatistics.getmessages().decrement();
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
return
if  isproducerflowcontrol      context isproducerflowcontrol      memoryusage isfull
if  systemusage issendfailifnospace
throw new javax jms resourceallocationexception
// we can avoid blocking due to low usage if the producer is sending
// a sync message or
// if it is using a producer window
if  producerinfo getwindowsize   > 0    message isresponserequired
synchronized  messageswaitingforspace
messageswaitingforspace add new runnable
public void run
try
// while waiting for space to free up... the
// message may have expired.
if  broker isexpired message
broker messageexpired context  message
//message not added to stats yet
//destinationstatistics.getmessages().decrement();
else
domessagesend producerexchange  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
else
response response   new response
response setcorrelationid message getcommandid
context getconnection   dispatchasync response
catch  exception e
if   sendproducerack     context isinrecoverymode
exceptionresponse response   new exceptionresponse e
response setcorrelationid message getcommandid
context getconnection   dispatchasync response
// if the user manager is not full, then the task will not
// get called..
if   memoryusage notifycallbackwhennotfull sendmessageswaitingforspacetask
// so call it directly here.
sendmessageswaitingforspacetask run
context setdontsendreponse true
return
else
// producer flow control cannot be used, so we have do the flow
// control at the broker
// by blocking this thread until there is space available.
while   memoryusage waitforspace 1000
if  context getstopping   get
throw new ioexception
// the usage manager could have delayed us by the time
// we unblock the message could have expired..
if  message isexpired
if  log isdebugenabled
log debug     message
broker getroot   messageexpired context  message
return
domessagesend producerexchange  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
void domessagesend final producerbrokerexchange producerexchange  final message message  throws ioexception  exception
final connectioncontext context   producerexchange getconnectioncontext
synchronized  sendlock
if  store    null    message ispersistent
while   systemusage getstoreusage   waitforspace 1000
if  context getstopping   get
throw new ioexception
message getmessageid   setbrokersequenceid getdestinationsequenceid
store addmessage context  message
if  context isintransaction
// if this is a transacted message.. increase the usage now so that
// a big tx does not blow up
// our memory. this increment is decremented once the tx finishes..
message incrementreferencecount
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
try
// it could take while before we receive the commit
// op, by that time the message could have expired..
if  broker isexpired message
broker messageexpired context  message
//message not added to stats yet
//destinationstatistics.getmessages().decrement();
return
sendmessage context  message
finally
message decrementreferencecount
@override
public void afterrollback   throws exception
message decrementreferencecount
else
// add to the pending list, this takes care of incrementing the
// usage manager.
sendmessage context  message
public void dispose connectioncontext context  throws ioexception
if  store    null
store removeallmessages context
destinationstatistics setparent null
public void gc
public void acknowledge connectioncontext context  subscription sub  messageack ack  messagereference node  throws ioexception
if  store    null    node ispersistent
// the original ack may be a ranged ack, but we are trying to delete
// a specific
// message store here so we need to convert to a non ranged ack.
if  ack getmessagecount   > 0
// dup the ack
messageack a   new messageack
ack copy a
ack   a
// convert to non-ranged.
ack setfirstmessageid node getmessageid
ack setlastmessageid node getmessageid
ack setmessagecount 1
store removemessage context  ack
message loadmessage messageid messageid  throws ioexception
message msg   store getmessage messageid
if  msg    null
msg setregiondestination this
return msg
public string tostring
int size   0
synchronized  messages
size   messages size
return     destination getphysicalname         consumers size         memoryusage getpercentusage         size
messagegroupowners
public void start   throws exception
if  memoryusage    null
memoryusage start
messages start
dopagein false
public void stop   throws exception
if  taskrunner    null
taskrunner shutdown
if  this executor    null
this executor shutdownnow
if  messages    null
messages stop
if  memoryusage    null
memoryusage stop
// properties
// -------------------------------------------------------------------------
public activemqdestination getactivemqdestination
return destination
public messagegroupmap getmessagegroupowners
if  messagegroupowners    null
messagegroupowners   getmessagegroupmapfactory   createmessagegroupmap
return messagegroupowners
public dispatchpolicy getdispatchpolicy
return dispatchpolicy
public void setdispatchpolicy dispatchpolicy dispatchpolicy
this dispatchpolicy   dispatchpolicy
public deadletterstrategy getdeadletterstrategy
return deadletterstrategy
public void setdeadletterstrategy deadletterstrategy deadletterstrategy
this deadletterstrategy   deadletterstrategy
public messagegroupmapfactory getmessagegroupmapfactory
return messagegroupmapfactory
public void setmessagegroupmapfactory messagegroupmapfactory messagegroupmapfactory
this messagegroupmapfactory   messagegroupmapfactory
public pendingmessagecursor getmessages
return this messages
public void setmessages pendingmessagecursor messages
this messages   messages
public boolean isuseconsumerpriority
return useconsumerpriority
public void setuseconsumerpriority boolean useconsumerpriority
this useconsumerpriority   useconsumerpriority
public boolean isstrictorderdispatch
return strictorderdispatch
public void setstrictorderdispatch boolean strictorderdispatch
this strictorderdispatch   strictorderdispatch
public boolean isoptimizeddispatch
return optimizeddispatch
public void setoptimizeddispatch boolean optimizeddispatch
this optimizeddispatch   optimizeddispatch
// implementation methods
// -------------------------------------------------------------------------
private queuemessagereference createmessagereference message message
queuemessagereference result   new indirectmessagereference message
return result
public message browse
list<message> l   new arraylist<message>
try
dopagein true
catch  exception e
log error     this  e
synchronized  pagedinmessages
for  queuemessagereference node pagedinmessages values
node incrementreferencecount
try
message m   node getmessage
if  m    null
l add m
catch  ioexception e
log error     this  e
finally
node decrementreferencecount
synchronized  messages
try
messages reset
while  messages hasnext
try
messagereference r   messages next
r incrementreferencecount
try
message m   r getmessage
if  m    null
l add m
finally
r decrementreferencecount
catch  ioexception e
log error     this  e
finally
messages release
return l toarray new message
public message getmessage string messageid
synchronized  messages
try
messages reset
while  messages hasnext
try
messagereference r   messages next
if  messageid equals r getmessageid   tostring
r incrementreferencecount
try
message m   r getmessage
if  m    null
return m
finally
r decrementreferencecount
break
catch  ioexception e
log error     messageid
finally
messages release
return null
public void purge   throws exception
connectioncontext c   createconnectioncontext
list<messagereference> list   null
do
pageinmessages
synchronized  pagedinmessages
list   new arraylist<messagereference> pagedinmessages values
for  messagereference ref   list
try
queuemessagereference r    queuemessagereference  ref
removemessage c  indirectmessagereference  r
catch  ioexception e
while   pagedinmessages isempty      this destinationstatistics getmessages   getcount   > 0
gc
/**
* removes the message matching the given messageid
*/
public boolean removemessage string messageid  throws exception
return removematchingmessages createmessageidfilter messageid   1  > 0
/**
* removes the messages matching the given selector
*
* @return the number of messages removed
*/
public int removematchingmessages string selector  throws exception
return removematchingmessages selector   1
/**
* removes the messages matching the given selector up to the maximum number
* of matched messages
*
* @return the number of messages removed
*/
public int removematchingmessages string selector  int maximummessages  throws exception
return removematchingmessages createselectorfilter selector   maximummessages
/**
* removes the messages matching the given filter up to the maximum number
* of matched messages
*
* @return the number of messages removed
*/
public int removematchingmessages messagereferencefilter filter  int maximummessages  throws exception
int movedcounter   0
set<messagereference> set   new copyonwritearrayset<messagereference>
connectioncontext context   createconnectioncontext
do
pageinmessages
synchronized  pagedinmessages
set addall pagedinmessages values
list <messagereference>list   new arraylist<messagereference> set
for  messagereference ref   list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
removemessage context  r
set remove r
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
while  set size   < this destinationstatistics getmessages   getcount
return movedcounter
/**
* copies the message matching the given messageid
*/
public boolean copymessageto connectioncontext context  string messageid  activemqdestination dest  throws exception
return copymatchingmessages context  createmessageidfilter messageid   dest  1  > 0
/**
* copies the messages matching the given selector
*
* @return the number of messages copied
*/
public int copymatchingmessagesto connectioncontext context  string selector  activemqdestination dest  throws exception
return copymatchingmessagesto context  selector  dest   1
/**
* copies the messages matching the given selector up to the maximum number
* of matched messages
*
* @return the number of messages copied
*/
public int copymatchingmessagesto connectioncontext context  string selector  activemqdestination dest  int maximummessages  throws exception
return copymatchingmessages context  createselectorfilter selector   dest  maximummessages
/**
* copies the messages matching the given filter up to the maximum number of
* matched messages
*
* @return the number of messages copied
*/
public int copymatchingmessages connectioncontext context  messagereferencefilter filter  activemqdestination dest  int maximummessages  throws exception
int movedcounter   0
int count   0
set<messagereference> set   new copyonwritearrayset<messagereference>
do
int oldmaxsize getmaxpagesize
setmaxpagesize  int  this destinationstatistics getmessages   getcount
pageinmessages
setmaxpagesize oldmaxsize
synchronized  pagedinmessages
set addall pagedinmessages values
list <messagereference>list   new arraylist<messagereference> set
for  messagereference ref   list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
r incrementreferencecount
try
message m   r getmessage
brokersupport resend context  m  dest
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
finally
r decrementreferencecount
count
while  count < this destinationstatistics getmessages   getcount
return movedcounter
/**
* moves the message matching the given messageid
*/
public boolean movemessageto connectioncontext context  string messageid  activemqdestination dest  throws exception
return movematchingmessagesto context  createmessageidfilter messageid   dest  1  > 0
/**
* moves the messages matching the given selector
*
* @return the number of messages removed
*/
public int movematchingmessagesto connectioncontext context  string selector  activemqdestination dest  throws exception
return movematchingmessagesto context  selector  dest   1
/**
* moves the messages matching the given selector up to the maximum number
* of matched messages
*/
public int movematchingmessagesto connectioncontext context  string selector  activemqdestination dest  int maximummessages  throws exception
return movematchingmessagesto context  createselectorfilter selector   dest  maximummessages
/**
* moves the messages matching the given filter up to the maximum number of
* matched messages
*/
public int movematchingmessagesto connectioncontext context messagereferencefilter filter  activemqdestination dest int maximummessages  throws exception
int movedcounter   0
set<messagereference> set   new copyonwritearrayset<messagereference>
do
pageinmessages
synchronized  pagedinmessages
set addall pagedinmessages values
list <messagereference>list   new arraylist<messagereference> set
for  messagereference ref list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
// we should only move messages that can be locked.
r incrementreferencecount
try
message m   r getmessage
brokersupport resend context  m  dest
removemessage context  r
set remove r
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
finally
r decrementreferencecount
while  set size   < this destinationstatistics getmessages   getcount
return movedcounter
recoverydispatch getnextrecoverydispatch
synchronized  pagedinmessages
if  recoveries isempty
return null
return recoveries removefirst
protected boolean isrecoverydispatchempty
synchronized  pagedinmessages
return recoveries isempty
/**
* @return true if we would like to iterate again
* @see org.apache.activemq.thread.task#iterate()
*/
public boolean iterate
synchronized iteratingmutex
recoverydispatch rd
while   rd   getnextrecoverydispatch       null
try
messageevaluationcontext msgcontext   new noncachedmessageevaluationcontext
msgcontext setdestination destination
for  queuemessagereference node   rd messages
if   node isdropped       node isacked        node isdropped      rd subscription getconsumerinfo   isbrowser
msgcontext setmessagereference node
if  rd subscription matches node  msgcontext
rd subscription add node
if  rd subscription instanceof queuebrowsersubscription
queuebrowsersubscription rd subscription  decrementqueueref
catch  exception e
e printstacktrace
boolean result   false
synchronized  messages
result    messages isempty
if  result
try
pageinmessages false
catch  throwable e
log error    e
synchronized messageswaitingforspace
while   messageswaitingforspace isempty       memoryusage isfull
runnable op   messageswaitingforspace removefirst
op run
return false
protected messagereferencefilter createmessageidfilter final string messageid
return new messagereferencefilter
public boolean evaluate connectioncontext context  messagereference r
return messageid equals r getmessageid   tostring
protected messagereferencefilter createselectorfilter string selector  throws invalidselectorexception
final booleanexpression selectorexpression   new selectorparser   parse selector
return new messagereferencefilter
public boolean evaluate connectioncontext context  messagereference r  throws jmsexception
messageevaluationcontext messageevaluationcontext   context getmessageevaluationcontext
messageevaluationcontext setmessagereference r
if  messageevaluationcontext getdestination      null
messageevaluationcontext setdestination getactivemqdestination
return selectorexpression matches messageevaluationcontext
protected void removemessage connectioncontext c  queuemessagereference r  throws ioexception
messageack ack   new messageack
ack setacktype messageack standard_ack_type
ack setdestination destination
ack setmessageid r getmessageid
removemessage c  null  r  ack
protected void removemessage connectioncontext context subscription sub final queuemessagereference reference messageack ack  throws ioexception
reference setacked true
// this sends the ack the the journal..
acknowledge context  sub  ack  reference
if   ack isintransaction
reference drop
destinationstatistics getmessages   decrement
synchronized pagedinmessages
pagedinmessages remove reference getmessageid
wakeup
else
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
reference drop
destinationstatistics getmessages   decrement
synchronized pagedinmessages
pagedinmessages remove reference getmessageid
wakeup
public void afterrollback   throws exception
reference setacked false
public void messageexpired connectioncontext context  prefetchsubscription prefetchsubscription  messagereference reference
queuemessagereference reference  drop
// not sure.. perhaps we should forge an ack to remove the message from the store.
// acknowledge(context, sub, ack, reference);
destinationstatistics getmessages   decrement
synchronized pagedinmessages
pagedinmessages remove reference getmessageid
wakeup
protected connectioncontext createconnectioncontext
connectioncontext answer   new connectioncontext new noncachedmessageevaluationcontext
answer getmessageevaluationcontext   setdestination getactivemqdestination
return answer
final void sendmessage final connectioncontext context  message msg  throws exception
synchronized  messages
messages addmessagelast msg
destinationstatistics getenqueues   increment
destinationstatistics getmessages   increment
wakeup
public void wakeup
if  optimizeddispatch
iterate
else
try
taskrunner wakeup
catch  interruptedexception e
log warn    e
private list<queuemessagereference> dopagein boolean force  throws exception
list<queuemessagereference> result   null
dispatchlock lock
try
int topagein    getmaxpagesize    int destinationstatistics getinflight   getcount      pagedinmessages size
if  islazydispatch      force
// only page in the minimum number of messages which can be dispatched immediately.
topagein   math min getconsumermessagecountbeforefull    topagein
if   force     consumers isempty       topagein > 0
messages setmaxbatchsize topagein
int count   0
result   new arraylist<queuemessagereference> topagein
synchronized  messages
try
messages reset
while  messages hasnext      count < topagein
messagereference node   messages next
node incrementreferencecount
messages remove
if   broker isexpired node
queuemessagereference ref   createmessagereference node getmessage
result add ref
count
else
broker messageexpired createconnectioncontext
node
destinationstatistics getmessages   decrement
finally
messages release
synchronized  pagedinmessages
for queuemessagereference ref result
pagedinmessages put ref getmessageid    ref
finally
dispatchlock unlock
return result
private void dodispatch list<queuemessagereference> list  throws exception
if  list    null
list<subscription> consumers
synchronized  this consumers
consumers   new arraylist<subscription> this consumers
for  messagereference node   list
subscription target   null
list<subscription> targets   null
for  subscription s   consumers
if  dispatchselector canselect s  node
if   s isfull
s add node
target   s
break
else
if  targets    null
targets   new arraylist<subscription>
targets add s
if  target    null    targets    null
// pick the least loaded to add the message too
for  subscription s   targets
if  target    null
target getinflightusage   > s
getinflightusage
target   s
if  target    null
target add node
if  target    null     strictorderdispatch    consumers size   > 1
dispatchselector isexclusiveconsumer target
synchronized  this consumers
if  removefromconsumerlist target
addtoconsumerlist target
consumers   new arraylist<subscription> this consumers
private void pageinmessages   throws exception
pageinmessages true
protected void pageinmessages boolean force  throws exception
dodispatch dopagein force
private void addtoconsumerlist subscription sub
if  useconsumerpriority
consumers add sub
collections sort consumers  orderedcompare
else
consumers add sub
private boolean removefromconsumerlist subscription sub
return consumers remove sub
private int getconsumermessagecountbeforefull   throws exception
int total   0
boolean zeroprefetch   false
synchronized  consumers
for  subscription s   consumers
prefetchsubscription ps    prefetchsubscription  s
zeroprefetch    ps getprefetchsize      0
int countbeforefull   ps countbeforefull
total    countbeforefull
if  total  0    zeroprefetch
total 1
return total