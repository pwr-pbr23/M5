/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq ra
import java io printwriter
import java util arraylist
import java util iterator
import javax jms connection
import javax jms exceptionlistener
import javax jms jmsexception
import javax resource resourceexception
import javax resource spi connectionevent
import javax resource spi connectioneventlistener
import javax resource spi connectionrequestinfo
import javax resource spi localtransaction
import javax resource spi managedconnection
import javax resource spi managedconnectionmetadata
import javax security auth subject
import javax transaction xa xaresource
import org apache activemq activemqconnection
import org apache activemq localtransactioneventlistener
import org apache activemq transactioncontext
import org apache commons logging log
import org apache commons logging logfactory
/**
* activemqmanagedconnection maps to real physical connection to the server.
* since a managedconnection has to provide a transaction managment interface to
* the physical connection, and sessions are the objects implement transaction
* managment interfaces in the jms api, this object also maps to a singe
* physical jms session. <p/> the side-effect is that jms connection the
* application gets will allways create the same session object. this is good if
* running in an app server since the sessions are elisted in the context
* transaction. this is bad if used outside of an app server since the user may
* be trying to create 2 different sessions to coordinate 2 different uow.
*
* @version $revision$
*/
public class activemqmanagedconnection implements managedconnection  exceptionlistener      todo
// ,
// dissociatablemanagedconnection
// {
private static final log log   logfactory getlog activemqmanagedconnection class
private printwriter logwriter
private final activemqconnection physicalconnection
private final transactioncontext transactioncontext
private final arraylist<managedconnectionproxy> proxyconnections   new arraylist<managedconnectionproxy>
private final arraylist<connectioneventlistener> listeners   new arraylist<connectioneventlistener>
private final localandxatransaction localandxatransaction
private subject subject
private activemqconnectionrequestinfo info
private boolean destoryed
public activemqmanagedconnection subject subject  activemqconnection physicalconnection  activemqconnectionrequestinfo info  throws resourceexception
try
this subject   subject
this info   info
this physicalconnection   physicalconnection
this transactioncontext   new transactioncontext physicalconnection
this localandxatransaction   new localandxatransaction transactioncontext
public void setinmanagedtx boolean inmanagedtx  throws jmsexception
super setinmanagedtx inmanagedtx
iterator<managedconnectionproxy> iterator   proxyconnections iterator
while  iterator hasnext
managedconnectionproxy proxy   iterator next
proxy setusesharedtxcontext inmanagedtx
this transactioncontext setlocaltransactioneventlistener new localtransactioneventlistener
public void beginevent
firebeginevent
public void commitevent
firecommitevent
public void rollbackevent
firerollbackevent
physicalconnection setexceptionlistener this
catch  jmsexception e
throw new resourceexception     e getmessage    e
public boolean isinmanagedtx
return localandxatransaction isinmanagedtx
public static boolean matches object x  object y
if  x    null ^ y    null
return false
if  x    null     x equals y
return false
return true
public void associate subject subject  activemqconnectionrequestinfo info  throws jmsexception
// do we need to change the associated userid/password
if   matches info getusername    this info getusername        matches info getpassword    this info getpassword
activemqconnection physicalconnection  changeuserinfo info getusername    info getpassword
// do we need to set the clientid?
if  info getclientid      null    info getclientid   length   > 0
physicalconnection setclientid info getclientid
this subject   subject
this info   info
public connection getphysicalconnection
return physicalconnection
private void firebeginevent
connectionevent event   new connectionevent activemqmanagedconnection this  connectionevent local_transaction_started
iterator<connectioneventlistener> iterator   listeners iterator
while  iterator hasnext
connectioneventlistener l   iterator next
l localtransactionstarted event
private void firecommitevent
connectionevent event   new connectionevent activemqmanagedconnection this  connectionevent local_transaction_committed
iterator<connectioneventlistener> iterator   listeners iterator
while  iterator hasnext
connectioneventlistener l   iterator next
l localtransactioncommitted event
private void firerollbackevent
connectionevent event   new connectionevent activemqmanagedconnection this  connectionevent local_transaction_rolledback
iterator<connectioneventlistener> iterator   listeners iterator
while  iterator hasnext
connectioneventlistener l   iterator next
l localtransactionrolledback event
private void firecloseevent managedconnectionproxy proxy
connectionevent event   new connectionevent activemqmanagedconnection this  connectionevent connection_closed
event setconnectionhandle proxy
iterator<connectioneventlistener> iterator   listeners iterator
while  iterator hasnext
connectioneventlistener l   iterator next
l connectionclosed event
private void fireerroroccurredevent exception error
connectionevent event   new connectionevent activemqmanagedconnection this  connectionevent connection_error_occurred  error
iterator<connectioneventlistener> iterator   listeners iterator
while  iterator hasnext
connectioneventlistener l   iterator next
l connectionerroroccurred event
/**
* @see javax.resource.spi.managedconnection#getconnection(javax.security.auth.subject,
*      javax.resource.spi.connectionrequestinfo)
*/
public object getconnection subject subject  connectionrequestinfo info  throws resourceexception
managedconnectionproxy proxy   new managedconnectionproxy this
proxyconnections add proxy
return proxy
private boolean isdestroyed
return destoryed
/**
* close down the physical connection to the server.
*
* @see javax.resource.spi.managedconnection#destroy()
*/
public void destroy   throws resourceexception
// have we allready been destroyed??
if  isdestroyed
return
cleanup
try
physicalconnection close
destoryed   true
catch  jmsexception e
log info    e
/**
* cleans up all proxy handles attached to this physical connection so that
* they cannot be used anymore.
*
* @see javax.resource.spi.managedconnection#cleanup()
*/
public void cleanup   throws resourceexception
// have we allready been destroyed??
if  isdestroyed
return
iterator<managedconnectionproxy> iterator   proxyconnections iterator
while  iterator hasnext
managedconnectionproxy proxy   iterator next
proxy cleanup
proxyconnections clear
localandxatransaction cleanup
try
activemqconnection physicalconnection  cleanup
catch  jmsexception e
throw new resourceexception     e  e
/**
* @see javax.resource.spi.managedconnection#associateconnection(java.lang.object)
*/
public void associateconnection object connection  throws resourceexception
if  connection instanceof managedconnectionproxy
managedconnectionproxy proxy    managedconnectionproxy connection
proxyconnections add proxy
else
throw new resourceexception     connection getclass   getname
/**
* @see javax.resource.spi.managedconnection#addconnectioneventlistener(javax.resource.spi.connectioneventlistener)
*/
public void addconnectioneventlistener connectioneventlistener listener
listeners add listener
/**
* @see javax.resource.spi.managedconnection#removeconnectioneventlistener(javax.resource.spi.connectioneventlistener)
*/
public void removeconnectioneventlistener connectioneventlistener listener
listeners remove listener
/**
* @see javax.resource.spi.managedconnection#getxaresource()
*/
public xaresource getxaresource   throws resourceexception
return localandxatransaction
/**
* @see javax.resource.spi.managedconnection#getlocaltransaction()
*/
public localtransaction getlocaltransaction   throws resourceexception
return localandxatransaction
/**
* @see javax.resource.spi.managedconnection#getmetadata()
*/
public managedconnectionmetadata getmetadata   throws resourceexception
return new managedconnectionmetadata
public string geteisproductname   throws resourceexception
if  physicalconnection    null
throw new resourceexception
try
return physicalconnection getmetadata   getjmsprovidername
catch  jmsexception e
throw new resourceexception    e
public string geteisproductversion   throws resourceexception
if  physicalconnection    null
throw new resourceexception
try
return physicalconnection getmetadata   getproviderversion
catch  jmsexception e
throw new resourceexception    e
public int getmaxconnections   throws resourceexception
if  physicalconnection    null
throw new resourceexception
return integer max_value
public string getusername   throws resourceexception
if  physicalconnection    null
throw new resourceexception
try
return physicalconnection getclientid
catch  jmsexception e
throw new resourceexception    e
/**
* @see javax.resource.spi.managedconnection#setlogwriter(java.io.printwriter)
*/
public void setlogwriter printwriter logwriter  throws resourceexception
this logwriter   logwriter
/**
* @see javax.resource.spi.managedconnection#getlogwriter()
*/
public printwriter getlogwriter   throws resourceexception
return logwriter
/**
* @param subject
* @param info
* @return
*/
public boolean matches subject subject  connectionrequestinfo info
// check to see if it is our info class
if  info    null
return false
if  info getclass      activemqconnectionrequestinfo class
return false
// do the subjects match?
if  subject    null ^ this subject    null
return false
if  subject    null     subject equals this subject
return false
// does the info match?
return info equals this info
/**
* when a proxy is closed this cleans up the proxy and notifys the
* connectioneventlisteners that a connection closed.
*
* @param proxy
*/
public void proxyclosedevent managedconnectionproxy proxy
proxyconnections remove proxy
proxy cleanup
firecloseevent proxy
public void onexception jmsexception e
log warn     e
log debug    e
// let any active proxy connections know that exception occured.
for  iterator<managedconnectionproxy> iter   proxyconnections iterator    iter hasnext
managedconnectionproxy proxy   iter next
proxy onexception e
// let the container know that the error occured.
fireerroroccurredevent e
/**
* @return returns the transactioncontext.
*/
public transactioncontext gettransactioncontext
return transactioncontext