/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2006 thomas e enebo <enebo@acm.org>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby ast
import java util list
import org jruby ast visitor nodevisitor
import org jruby evaluator instruction
import org jruby lexer yacc isourceposition
import org jruby parser staticscope
import org jruby runtime dynamicscope
/**
* represents the top of the ast.  this is a node not present in mri.  it was created to
* hold the top-most static scope in an easy to grab way and it also exists to hold begin
* and end nodes.  these can then be interpreted/compiled in the same places as the rest
* of the code.
*
*/
// todo: store begin and end information into this node
public class rootnode extends node
private transient dynamicscope scope
private staticscope staticscope
private node bodynode
public rootnode isourceposition position  dynamicscope scope  node bodynode
super position  nodetype rootnode
this scope   scope
this staticscope   scope getstaticscope
this bodynode   bodynode
/**
* return the dynamic scope for this ast.  the variable backed by this is transient so
* for serialization this is null.  in that case we use staticscope to rebuild the dynamic
* scope.  the real reason for this method is supporting bindings+eval.  we need to pass
* our live dynamic scope in so when we eval we can use that dynamic scope.
*
* @return dynamic scope of this ast
*/
public dynamicscope getscope
return scope
/**
* the static scoping relationships that should get set first thing before interpretation
* of the code represented by this ast.  actually, we use getscope first since that also
* can contain a live dynamic scope.  we rely on this method only for interpreting a root
* node from a serialized format.
*
* @return the top static scope for the ast
*/
public staticscope getstaticscope
return staticscope
/**
* first real ast node to be interpreted
*
* @return real top ast node
*/
public node getbodynode
return bodynode
public instruction accept nodevisitor ivisitor
return ivisitor visitrootnode this
public list<node> childnodes
return createlist bodynode