/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004-2006 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2004-2005 david corbin <dcorbin@users.sourceforge.net>
* copyright (c) 2005 zach dennis <zdennis@mktec.com>
* copyright (c) 2006 thomas corbat <tcorbat@hsr.ch>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby lexer yacc
import java io ioexception
import java math biginteger
import java util hashmap
import org jruby ast backrefnode
import org jruby ast bignumnode
import org jruby ast commentnode
import org jruby ast fixnumnode
import org jruby ast floatnode
import org jruby ast nthrefnode
import org jruby common irubywarnings
import org jruby common irubywarnings id
import org jruby lexer yacc syntaxexception pid
import org jruby parser parsersupport
import org jruby parser tokens
import org jruby util bytelist
/** this is a port of the mri lexer to java it is compatible to ruby 1.8.1.
*/
public class rubyyacclexer
private static bytelist end_marker   new bytelist new byte
private static bytelist begin_doc_marker   new bytelist new byte
private static bytelist end_doc_marker   new bytelist new byte
private static hashmap<string  keyword> map
static
map   new hashmap<string  keyword>
map put    keyword end
map put    keyword else
map put    keyword case
map put    keyword ensure
map put    keyword module
map put    keyword elsif
map put    keyword def
map put    keyword rescue
map put    keyword not
map put    keyword then
map put    keyword yield
map put    keyword for
map put    keyword self
map put    keyword false
map put    keyword retry
map put    keyword return
map put    keyword true
map put    keyword if
map put    keyword defined_p
map put    keyword super
map put    keyword undef
map put    keyword break
map put    keyword in
map put    keyword do
map put    keyword nil
map put    keyword until
map put    keyword unless
map put    keyword or
map put    keyword next
map put    keyword when
map put    keyword redo
map put    keyword and
map put    keyword begin
map put    keyword __line__
map put    keyword class
map put    keyword __file__
map put    keyword lend
map put    keyword lbegin
map put    keyword while
map put    keyword alias
}
public enum keyword
end     tokens kend  tokens kend  lexstate expr_end
else     tokens kelse  tokens kelse  lexstate expr_beg
case     tokens kcase  tokens kcase  lexstate expr_beg
ensure     tokens kensure  tokens kensure  lexstate expr_beg
module     tokens kmodule  tokens kmodule  lexstate expr_beg
elsif     tokens kelsif  tokens kelsif  lexstate expr_beg
def     tokens kdef  tokens kdef  lexstate expr_fname
rescue     tokens krescue  tokens krescue_mod  lexstate expr_mid
not     tokens knot  tokens knot  lexstate expr_beg
then     tokens kthen  tokens kthen  lexstate expr_beg
yield     tokens kyield  tokens kyield  lexstate expr_arg
for     tokens kfor  tokens kfor  lexstate expr_beg
self     tokens kself  tokens kself  lexstate expr_end
false     tokens kfalse  tokens kfalse  lexstate expr_end
retry     tokens kretry  tokens kretry  lexstate expr_end
return     tokens kreturn  tokens kreturn  lexstate expr_mid
true     tokens ktrue  tokens ktrue  lexstate expr_end
if     tokens kif  tokens kif_mod  lexstate expr_beg
defined_p     tokens kdefined  tokens kdefined  lexstate expr_arg
super     tokens ksuper  tokens ksuper  lexstate expr_arg
undef     tokens kundef  tokens kundef  lexstate expr_fname
break     tokens kbreak  tokens kbreak  lexstate expr_mid
in     tokens kin  tokens kin  lexstate expr_beg
do     tokens kdo  tokens kdo  lexstate expr_beg
nil     tokens knil  tokens knil  lexstate expr_end
until     tokens kuntil  tokens kuntil_mod  lexstate expr_beg
unless     tokens kunless  tokens kunless_mod  lexstate expr_beg
or     tokens kor  tokens kor  lexstate expr_beg
next     tokens knext  tokens knext  lexstate expr_mid
when     tokens kwhen  tokens kwhen  lexstate expr_beg
redo     tokens kredo  tokens kredo  lexstate expr_end
and     tokens kand  tokens kand  lexstate expr_beg
begin     tokens kbegin  tokens kbegin  lexstate expr_beg
__line__     tokens k__line__  tokens k__line__  lexstate expr_end
class     tokens kclass  tokens kclass  lexstate expr_class
__file__    tokens k__file__  tokens k__file__  lexstate expr_end
lend     tokens klend  tokens klend  lexstate expr_end
lbegin     tokens klbegin  tokens klbegin  lexstate expr_end
while     tokens kwhile  tokens kwhile_mod  lexstate expr_beg
alias     tokens kalias  tokens kalias  lexstate expr_fname
public final string name
public final int id0
public final int id1
public final lexstate state
keyword string name  int id0  int id1  lexstate state
this name   name
this id0   id0
this id1   id1
this state   state
}
}
public enum lexstate
expr_beg  expr_end  expr_arg  expr_cmdarg  expr_endarg  expr_mid
expr_fname  expr_dot  expr_class
}
public static keyword getkeyword string str
return  keyword  map get str
}
// last token read via yylex().
private int token
// value of last token which had a value associated with it.
object yaccvalue
// stream of data that yylex() examines.
private lexersource src
// used for tiny smidgen of grammar in lexer (see setparsersupport())
private parsersupport parsersupport   null
// what handles warnings
private irubywarnings warnings
// additional context surrounding tokens that both the lexer and
// grammar use.
private lexstate lex_state
// tempory buffer to build up a potential token.  consumer takes responsibility to reset
// this before use.
private stringbuilder tokenbuffer   new stringbuilder 60
private stackstate conditionstate   new stackstate
private stackstate cmdargumentstate   new stackstate
private strterm lex_strterm
private boolean commandstart
// give a name to a value.  enebo: this should be used more.
static final int eof    1
// ruby constants for strings (should this be moved somewhere else?)
static final int str_func_escape 0x01
static final int str_func_expand 0x02
static final int str_func_regexp 0x04
static final int str_func_qwords 0x08
static final int str_func_symbol 0x10
// when the heredoc identifier specifies <<-eof that indents before ident. are ok (the '-').
static final int str_func_indent 0x20
private static final int str_squote   0
private static final int str_dquote   str_func_expand
private static final int str_xquote   str_func_expand
private static final int str_regexp   str_func_regexp   str_func_escape   str_func_expand
private static final int str_ssym     str_func_symbol
private static final int str_dsym     str_func_symbol   str_func_expand
public rubyyacclexer
reset
}
public void reset
token   0
yaccvalue   null
src   null
lex_state   null
resetstacks
lex_strterm   null
commandstart   true
}
/**
* how the parser advances to the next token.
*
* @return true if not at end of file (eof).
*/
public boolean advance   throws ioexception
return  token   yylex       eof
}
/**
* last token read from the lexer at the end of a call to yylex()
*
* @return last token read
*/
public int token
return token;
}
public stringbuilder gettokenbuffer
return tokenbuffer
}
/**
* value of last token (if it is a token which has a value).
*
* @return value of last value-laden token
*/
public object value
return yaccvalue
}
public isourcepositionfactory getpositionfactory
return src getpositionfactory
}
/**
* get position information for token/node that follows node represented by startposition
* and current lexer location.
*
* @param startposition previous node/token
* @param inclusive include previous node into position information of current node
* @return a new position
*/
public isourceposition getposition isourceposition startposition  boolean inclusive
return src getposition startposition  inclusive
}
public isourceposition getposition
return src getposition null  false
}
/**
* parse must pass its support object for some check at bottom of
* yylex().  ruby does it this way as well (i.e. a little parsing
* logic in the lexer).
*
* @param parsersupport
*/
public void setparsersupport parsersupport parsersupport
this parsersupport   parsersupport
}
/**
* allow the parser to set the source for its lexer.
*
* @param source where the lexer gets raw data
*/
public void setsource lexersource source
this src   source
}
public strterm getstrterm
return lex_strterm
}
public void setstrterm strterm strterm
this lex_strterm   strterm
}
public void resetstacks
conditionstate reset
cmdargumentstate reset
}
public void setwarnings irubywarnings warnings
this warnings   warnings
}
public void setstate lexstate state
this lex_state   state
}
public stackstate getcmdargumentstate
return cmdargumentstate
}
public stackstate getconditionstate
return conditionstate
}
public void setvalue object yaccvalue
this yaccvalue   yaccvalue
}
private boolean isnext_identchar   throws ioexception
int c   src read
src unread c
return c    eof     character isletterordigit c     c
}
private void determineexpressionstate
switch  lex_state
case expr_fname  case expr_dot
lex_state   lexstate expr_arg
break;
default
lex_state   lexstate expr_beg
break;
}
}
private object getinteger string value  int radix
try
return new fixnumnode getposition    long parselong value  radix
catch  numberformatexception e
return new bignumnode getposition    new biginteger value  radix
}
}
/**
* @param c the character to test
* @return true if character is a hex value (0-9a-f)
*/
static final boolean ishexchar int c
return character isdigit c        <  c    c <           <  c    c <
}
/**
* @param c the character to test
* @return true if character is an octal value (0-7)
*/
static final boolean isoctchar int c
return   <  c    c <
}
/**
* @param c is character to be compared
* @return whether c is an identifier or not
*/
public static final boolean isidentifierchar int c
return character isletterordigit c     c
}
/**
* what type/kind of quote are we dealing with?
*
* @param c first character the the quote construct
* @return a token that specifies the quote type
*/
private int parsequote int c  throws ioexception
int begin  end
boolean shorthand
// short-hand (e.g. %{,%.,%!,... versus %q{).
if   character isletterordigit c
begin   c
c
shorthand   true
// long-hand (e.g. %q{}).
else
shorthand   false
begin   src read
if  character isletterordigit begin     no mb    ismbchar term
throw new syntaxexception pid string_unknown_type  getposition
}
}
if  c    eof    begin    eof
throw new syntaxexception pid string_hits_eof  getposition
}
// figure end-char.  '\0' is special to indicate begin=end and that no nesting?
switch begin
case    end      break
case    end      break
case    end      break
case    end      break
default
end   begin
begin
}
switch  c
case
lex_strterm   new stringterm str_dquote  begin  end
yaccvalue   new token     shorthand ?    end         c   begin    getposition
return tokens tstring_beg
case
lex_strterm   new stringterm str_squote  begin  end
yaccvalue   new token   c begin  getposition
return tokens tstring_beg
case
lex_strterm   new stringterm str_dquote   str_func_qwords  begin  end
do  c   src read     while  character iswhitespace c
src unread c
yaccvalue   new token   c begin  getposition
return tokens twords_beg
case
lex_strterm   new stringterm str_squote   str_func_qwords  begin  end
do  c   src read     while  character iswhitespace c
src unread c
yaccvalue   new token   c begin  getposition
return tokens tqwords_beg
case
lex_strterm   new stringterm str_xquote  begin  end
yaccvalue   new token   c begin  getposition
return tokens txstring_beg
case
lex_strterm   new stringterm str_regexp  begin  end
yaccvalue   new token   c begin  getposition
return tokens tregexp_beg
case
lex_strterm   new stringterm str_ssym  begin  end
lex_state   lexstate expr_fname
yaccvalue   new token   c begin  getposition
return tokens tsymbeg
default
throw new syntaxexception pid string_unknown_type  getposition
c
}
}
private int heredocumentidentifier   throws ioexception
int c   src read
int term
int func   0
if  c
c = src.read();
func   str_func_indent
}
bytelist markervalue
if  c         c         c
if  c
func    str_squote
else if  c
func    str_dquote
else
func    str_xquote
}
markervalue   new bytelist
term   c
while   c   src read       eof    c    term
markervalue append c
}
if  c    eof
throw new syntaxexception pid string_marker_missing  getposition
}
else
if   isidentifierchar c
src unread c
if   func   str_func_indent     0
src unread
}
return 0
}
markervalue   new bytelist
term
func    str_dquote
do
markervalue append c
while   c   src read       eof    isidentifierchar c
src unread c
}
bytelist lastline   src readlinebytes
lastline append
lex_strterm   new heredocterm markervalue  func  lastline
if  term
yaccvalue   new token    getposition
return tokens txstring_beg
}
yaccvalue   new token  "  getposition
// hacky: advance position to eat newline here....
getposition
return tokens tstring_beg
}
private void arg_ambiguous
warnings warning id ambiguous_argument  getposition
}
/**
* read a comment up to end of line.  when found each comment will get stored away into
* the parser result so that any interested party can use them as they seem fit.  one idea
* is that ide authors can do distance based heuristics to associate these comments to the
* ast node they think they belong to.
*
* @param c last character read from lexer source
* @return newline or eof value
*/
protected int readcomment int c  throws ioexception
if   parsersupport getconfiguration   hasextrapositioninformation
return src skipuntil
}
isourceposition startposition   src getposition
tokenbuffer setlength 0
tokenbuffer append  char  c
// fixme: consider making a better lexersource.readline
while   c   src read
if  c    eof  break
tokenbuffer append  char  c
}
src unread c
// store away each comment to parser result so ides can do whatever they want with them.
isourceposition position   startposition union getposition
parsersupport getresult   addcomment new commentnode position  tokenbuffer tostring
return c
}
/*
* not normally used, but is left in here since it can be useful in debugging
* grammar and lexing problems.
*
*
private void printtoken(int token) {
//system.out.print("loc: " + support.getposition() + " ~ ");
switch (token) {
case tokens.yyerrorcode: system.err.print("yyerrorcode,"); break;
case tokens.kclass: system.err.print("kclass,"); break;
case tokens.kmodule: system.err.print("kmodule,"); break;
case tokens.kdef: system.err.print("kdef,"); break;
case tokens.kundef: system.err.print("kundef,"); break;
case tokens.kbegin: system.err.print("kbegin,"); break;
case tokens.krescue: system.err.print("krescue,"); break;
case tokens.kensure: system.err.print("kensure,"); break;
case tokens.kend: system.err.print("kend,"); break;
case tokens.kif: system.err.print("kif,"); break;
case tokens.kunless: system.err.print("kunless,"); break;
case tokens.kthen: system.err.print("kthen,"); break;
case tokens.kelsif: system.err.print("kelsif,"); break;
case tokens.kelse: system.err.print("kelse,"); break;
case tokens.kcase: system.err.print("kcase,"); break;
case tokens.kwhen: system.err.print("kwhen,"); break;
case tokens.kwhile: system.err.print("kwhile,"); break;
case tokens.kuntil: system.err.print("kuntil,"); break;
case tokens.kfor: system.err.print("kfor,"); break;
case tokens.kbreak: system.err.print("kbreak,"); break;
case tokens.knext: system.err.print("knext,"); break;
case tokens.kredo: system.err.print("kredo,"); break;
case tokens.kretry: system.err.print("kretry,"); break;
case tokens.kin: system.err.print("kin,"); break;
case tokens.kdo: system.err.print("kdo,"); break;
case tokens.kdo_cond: system.err.print("kdo_cond,"); break;
case tokens.kdo_block: system.err.print("kdo_block,"); break;
case tokens.kreturn: system.err.print("kreturn,"); break;
case tokens.kyield: system.err.print("kyield,"); break;
case tokens.ksuper: system.err.print("ksuper,"); break;
case tokens.kself: system.err.print("kself,"); break;
case tokens.knil: system.err.print("knil,"); break;
case tokens.ktrue: system.err.print("ktrue,"); break;
case tokens.kfalse: system.err.print("kfalse,"); break;
case tokens.kand: system.err.print("kand,"); break;
case tokens.kor: system.err.print("kor,"); break;
case tokens.knot: system.err.print("knot,"); break;
case tokens.kif_mod: system.err.print("kif_mod,"); break;
case tokens.kunless_mod: system.err.print("kunless_mod,"); break;
case tokens.kwhile_mod: system.err.print("kwhile_mod,"); break;
case tokens.kuntil_mod: system.err.print("kuntil_mod,"); break;
case tokens.krescue_mod: system.err.print("krescue_mod,"); break;
case tokens.kalias: system.err.print("kalias,"); break;
case tokens.kdefined: system.err.print("kdefined,"); break;
case tokens.klbegin: system.err.print("klbegin,"); break;
case tokens.klend: system.err.print("klend,"); break;
case tokens.k__line__: system.err.print("k__line__,"); break;
case tokens.k__file__: system.err.print("k__file__,"); break;
case tokens.tidentifier: system.err.print("tidentifier["+ value() + "],"); break;
case tokens.tfid: system.err.print("tfid[" + value() + "],"); break;
case tokens.tgvar: system.err.print("tgvar[" + value() + "],"); break;
case tokens.tivar: system.err.print("tivar[" + value() +"],"); break;
case tokens.tconstant: system.err.print("tconstant["+ value() +"],"); break;
case tokens.tcvar: system.err.print("tcvar,"); break;
case tokens.tinteger: system.err.print("tinteger,"); break;
case tokens.tfloat: system.err.print("tfloat,"); break;
case tokens.tstring_content: system.err.print("tstring_content[" + ((strnode) value()).getvalue().tostring() + "],"); break;
case tokens.tstring_beg: system.err.print("tstring_beg,"); break;
case tokens.tstring_end: system.err.print("tstring_end,"); break;
case tokens.tstring_dbeg: system.err.print("string_dbeg,"); break;
case tokens.tstring_dvar: system.err.print("tstring_dvar,"); break;
case tokens.txstring_beg: system.err.print("txstring_beg,"); break;
case tokens.tregexp_beg: system.err.print("tregexp_beg,"); break;
case tokens.tregexp_end: system.err.print("tregexp_end,"); break;
case tokens.twords_beg: system.err.print("twords_beg,"); break;
case tokens.tqwords_beg: system.err.print("tqwords_beg,"); break;
case tokens.tback_ref: system.err.print("tback_ref,"); break;
case tokens.tnth_ref: system.err.print("tnth_ref,"); break;
case tokens.tuplus: system.err.print("tuplus"); break;
case tokens.tuminus: system.err.print("tuminus,"); break;
case tokens.tpow: system.err.print("tpow,"); break;
case tokens.tcmp: system.err.print("tcmp,"); break;
case tokens.teq: system.err.print("teq,"); break;
case tokens.teqq: system.err.print("teqq,"); break;
case tokens.tneq: system.err.print("tneq,"); break;
case tokens.tgeq: system.err.print("tgeq,"); break;
case tokens.tleq: system.err.print("tleq,"); break;
case tokens.tandop: system.err.print("tandop,"); break;
case tokens.torop: system.err.print("torop,"); break;
case tokens.tmatch: system.err.print("tmatch,"); break;
case tokens.tnmatch: system.err.print("tnmatch,"); break;
case tokens.tdot2: system.err.print("tdot2,"); break;
case tokens.tdot3: system.err.print("tdot3,"); break;
case tokens.taref: system.err.print("taref,"); break;
case tokens.taset: system.err.print("taset,"); break;
case tokens.tlshft: system.err.print("tlshft,"); break;
case tokens.trshft: system.err.print("trshft,"); break;
case tokens.tcolon2: system.err.print("tcolon2,"); break;
case tokens.tcolon3: system.err.print("tcolon3,"); break;
case tokens.top_asgn: system.err.print("top_asgn,"); break;
case tokens.tassoc: system.err.print("tassoc,"); break;
case tokens.tlparen: system.err.print("tlparen,"); break;
case tokens.tlparen_arg: system.err.print("tlparen_arg,"); break;
case tokens.tlbrack: system.err.print("tlbrack,"); break;
case tokens.tlbrace: system.err.print("tlbrace,"); break;
case tokens.tstar: system.err.print("tstar,"); break;
case tokens.tstar2: system.err.print("tstar2,"); break;
case tokens.tamper: system.err.print("tamper,"); break;
case tokens.tsymbeg: system.err.print("tsymbeg,"); break;
case '\n': system.err.println("nl"); break;
default: system.err.print("'" + (char)token + "',"); break;
}
}
// debugging help
private int yylex2() throws ioexception {
int token = yylex();
printtoken(token);
return token;
}*/
/**
*  returns the next token. also sets yyval is needed.
*
*@return    description of the returned value
*/
private int yylex   throws ioexception
int c
boolean spaceseen   false
boolean commandstate
if  lex_strterm    null
int tok   lex_strterm parsestring this  src
if  tok    tokens tstring_end    tok    tokens tregexp_end
lex_strterm   null
lex_state   lexstate expr_end
}
return tok
}
commandstate   commandstart
commandstart   false
loop  for
c = src.read();
switch c
case   		   ^d
case   		   ^z
case eof 			   end of script
return eof
/* white spaces */
case    case    case    case
case
getposition
spaceseen   true
continue
case   		   it's a comment
if  readcomment c     eof  return eof
/* fall through */
case
// replace a string of newlines with a single one
while  c   src read
src unread c
getposition
switch  lex_state
case expr_beg  case expr_fname  case expr_dot  case expr_class
continue loop
}
commandstart   true
lex_state   lexstate expr_beg
return
case
return star spaceseen
case
return bang
case
// documentation nodes
if  src wasbeginofline
boolean docomments   parsersupport getconfiguration   hasextrapositioninformation
if  src matchmarker begin_doc_marker  false  false
if  docomments
tokenbuffer setlength 0
tokenbuffer append begin_doc_marker
}
c = src.read();
if  character iswhitespace c
// in case last next was the newline.
src unread c
for
c = src.read();
if  docomments  tokenbuffer append  char  c
// if a line is followed by a blank line put
// it back.
while  c
c = src.read();
if  docomments  tokenbuffer append  char  c
}
if  c    eof
throw new syntaxexception pid string_hits_eof  getposition
}
if  c       continue
if  src wasbeginofline      src matchmarker end_doc_marker  false  false
if  docomments  tokenbuffer append end_doc_marker
bytelist list   src readlinebytes
if  docomments  tokenbuffer append list
src unread
break;
}
}
if  docomments
parsersupport getresult   addcomment new commentnode getposition    tokenbuffer tostring
}
continue
}
src unread c
}
}
determineexpressionstate
c = src.read();
if  c
c = src.read();
if  c
yaccvalue   new token    getposition
return tokens teqq
}
src unread c
yaccvalue   new token    getposition
return tokens teq
}
if  c
yaccvalue   new token    getposition
return tokens tmatch
else if  c
yaccvalue   new token    getposition
return tokens tassoc
}
src unread c
yaccvalue   new token    getposition
return
case
return lessthan spaceseen
case
return greaterthan
case
return doublequote
case
return backtick commandstate
case
return singlequote
case
return questionmark
case
return ampersand spaceseen
case
return pipe
case
return plus spaceseen
case
return minus spaceseen
case
return dot
case     case     case     case     case
case     case     case     case     case
return parsenumber c
case
return rightparen
case
return rightbracket
case
return rightcurly
case
return colon spaceseen
case
return slash spaceseen
case
return caret
case
commandstart   true
case
return comma c
case
return tilde
case
return leftparen spaceseen
case
return leftbracket spaceseen
case
return leftcurly
case
c = src.read();
if  c
spaceseen   true
continue
}
src unread c
yaccvalue   new token    getposition
return
case
return percent spaceseen
case
return dollar
case
return at
case
if  src wasbeginofline      src matchmarker end_marker  false  true
parsersupport getresult   setendoffset src getoffset
return eof
}
return identifier c  commandstate
default
return identifier c  commandstate
}
}
}
private int identifiertoken lexstate last_state  int result  string value
if  result    tokens tidentifier    last_state    lexstate expr_dot
parsersupport getcurrentscope   isdefined value  >  0
lex_state   lexstate expr_end
}
yaccvalue   new token value  result  getposition
return result
}
private int getidentifier int c  throws ioexception
do
tokenbuffer append  char  c
/* no special multibyte character handling is needed in java
* if (ismbchar(c)) {
int i, len = mbclen(c)-1;
for (i = 0; i < len; i++) {
c = src.read();
tokenbuffer.append(c);
}
}*/
c = src.read();
while  isidentifierchar c
return c
}
private int ampersand boolean spaceseen  throws ioexception
int c   src read
switch  c
case
lex_state   lexstate expr_beg
if   c   src read
yaccvalue   new token    getposition
lex_state   lexstate expr_beg
return tokens top_asgn
}
src unread c
yaccvalue   new token    getposition
return tokens tandop
case
yaccvalue   new token    getposition
lex_state   lexstate expr_beg
return tokens top_asgn
}
src unread c
//tmpposition is required because getposition()'s side effects.
//if the warning is generated, the getposition() on line 954 (this line + 18) will create
//a wrong position if the "inclusive" flag is not set.
isourceposition tmpposition   getposition
if   lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg
spaceseen     character iswhitespace c
warnings warning id argument_as_prefix  tmpposition
c   tokens tamper
else if  lex_state    lexstate expr_beg
lex_state    lexstate expr_mid
c   tokens tamper
else
c   tokens tamper2
}
determineexpressionstate
yaccvalue   new token    tmpposition
return c
}
private int at   throws ioexception
int c   src read
int result
tokenbuffer setlength 0
tokenbuffer append
if  c
tokenbuffer append
c = src.read();
result   tokens tcvar
else
result   tokens tivar
}
if  character isdigit c
if  tokenbuffer length      1
throw new syntaxexception pid ivar_bad_name  getposition        c
}
throw new syntaxexception pid cvar_bad_name  getposition        c
}
if   isidentifierchar c
src unread c
yaccvalue   new token    getposition
return
}
c   getidentifier c
src unread c
lexstate last_state   lex_state
lex_state   lexstate expr_end
return identifiertoken last_state  result  tokenbuffer tostring   intern
}
private int backtick boolean commandstate  throws ioexception
yaccvalue   new token    getposition
switch  lex_state
case expr_fname
lex_state   lexstate expr_end
return tokens tback_ref2
case expr_dot
lex_state   commandstate ? lexstate expr_cmdarg   lexstate expr_arg
return tokens tback_ref2
default
lex_strterm   new stringterm str_xquote
return tokens txstring_beg
}
}
private int bang   throws ioexception
int c   src read
lex_state   lexstate expr_beg
switch  c
case
yaccvalue   new token   getposition
return tokens tneq
case
yaccvalue   new token   getposition
return tokens tnmatch
default     just a plain bang
src unread c
yaccvalue   new token   getposition
return tokens tbang
}
}
private int caret   throws ioexception
int c   src read
if  c
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
}
determineexpressionstate
src unread c
yaccvalue   new token    getposition
return tokens tcaret
}
private int colon boolean spaceseen  throws ioexception
int c   src read
if  c
if  lex_state    lexstate expr_beg
lex_state    lexstate expr_mid
lex_state    lexstate expr_class
lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg     spaceseen
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens tcolon3
}
lex_state   lexstate expr_dot
yaccvalue   new token   getposition
return tokens tcolon2
}
if  lex_state    lexstate expr_end
lex_state    lexstate expr_endarg    character iswhitespace c
src unread c
lex_state   lexstate expr_beg
yaccvalue   new token   getposition
return
}
switch  c
case
lex_strterm   new stringterm str_ssym     c
break;
case
lex_strterm   new stringterm str_dsym     c
break;
default
src unread c
break;
}
lex_state   lexstate expr_fname
yaccvalue   new token    getposition
return tokens tsymbeg
}
private int comma int c  throws ioexception
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return c
}
private int dollar   throws ioexception
lexstate last_state   lex_state
lex_state   lexstate expr_end
int c   src read
switch  c
case             $_  last read line string
c = src.read();
if  isidentifierchar c
tokenbuffer setlength 0
tokenbuffer append
c   getidentifier c
src unread c
last_state   lex_state
lex_state   lexstate expr_end
return identifiertoken last_state  tokens tgvar  tokenbuffer tostring   intern
}
src unread c
c
// fall through
case             $~  match data
case             $   argv
case             $$  pid
case             $?  last status
case             $   error string
case             $@  error position
case             $   input record separator
case            $   output record separator
case             $   field separator
case             $   output field separator
case             $   last read line number
case             $   ignorecase
case             $   load path
case             $<  reading filename
case             $>  default output handle
case '    already loaded files
yaccvalue   new token      char  c  tokens tgvar  getposition
return tokens tgvar
case
tokenbuffer setlength 0
tokenbuffer append
tokenbuffer append  char  c
c = src.read();
if  isidentifierchar c
tokenbuffer append  char  c
else
src unread c
}
yaccvalue   new token tokenbuffer tostring    tokens tgvar  getposition
/* xxx shouldn't check if valid option variable */
return tokens tgvar
case             $   last match
case             $`  string before last match
case            $'  string after last match
case             $   string matches last paren
// explicit reference to these vars as symbols...
if  last_state    lexstate expr_fname
yaccvalue   new token      char  c  tokens tgvar  getposition
return tokens tgvar
}
yaccvalue   new backrefnode getposition    c
return tokens tback_ref
case    case    case    case    case    case
case    case    case
tokenbuffer setlength 0
tokenbuffer append
do
tokenbuffer append  char  c
c = src.read();
while  character isdigit c
src unread c
if  last_state    lexstate expr_fname
yaccvalue   new token tokenbuffer tostring    tokens tgvar  getposition
return tokens tgvar
}
yaccvalue   new nthrefnode getposition    integer parseint tokenbuffer substring 1
return tokens tnth_ref
case
lex_state   lexstate expr_end
return identifiertoken last_state  tokens tgvar        char  c  intern
default
if   isidentifierchar c
src unread c
yaccvalue   new token    getposition
return
}
// $blah
tokenbuffer setlength 0
tokenbuffer append
int d   getidentifier c
src unread d
last_state   lex_state
lex_state   lexstate expr_end
return identifiertoken last_state  tokens tgvar  tokenbuffer tostring   intern
}
}
private int dot   throws ioexception
int c
lex_state   lexstate expr_beg
if   c   src read
if   c   src read
yaccvalue   new token    getposition
return tokens tdot3
}
src unread c
yaccvalue   new token    getposition
return tokens tdot2
}
src unread c
if  character isdigit c
throw new syntaxexception pid float_missing_zero  getposition
}
lex_state   lexstate expr_dot
yaccvalue   new token    getposition
return tokens tdot
}
private int doublequote   throws ioexception
lex_strterm   new stringterm str_dquote
yaccvalue   new token  "  getposition
return tokens tstring_beg
}
private int greaterthan   throws ioexception
determineexpressionstate
int c   src read
switch  c
case
yaccvalue   new token    getposition
return tokens tgeq
case
if   c   src read
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
}
src unread c
yaccvalue   new token    getposition
return tokens trshft
default
src unread c
yaccvalue   new token    getposition
return tokens tgt
}
}
private int identifier int c  boolean commandstate  throws ioexception
if   isidentifierchar c
string badchar       integer tooctalstring c   0xff
throw new syntaxexception pid character_bad  getposition        badchar
char  c      badchar
}
tokenbuffer setlength 0
int first   c
c   getidentifier c
boolean lastbangorpredicate   false
// methods 'foo!' and 'foo?' are possible but if followed by '=' it is relop
if  c         c
if   src peek
lastbangorpredicate   true
tokenbuffer append  char  c
else
src unread c
}
else
src unread c
}
int result   0
lexstate last_state   lex_state
if  lastbangorpredicate
result   tokens tfid
else
if  lex_state    lexstate expr_fname
if   c   src read
int c2   src read
if  c2         c2
c2          c2         src peek
result   tokens tidentifier
tokenbuffer append  char  c
src unread c2
else
src unread c2
src unread c
}
else
src unread c
}
}
if  result    0    character isuppercase first
result   tokens tconstant
else
result   tokens tidentifier
}
}
string tempval   tokenbuffer tostring   intern
if  lex_state    lexstate expr_dot
/* see if it is a reserved word.  */
//keyword keyword = keyword.getkeyword(tempval, tempval.length());
keyword keyword   getkeyword tempval
if  keyword    null
// enum lex_state
lexstate state   lex_state
lex_state   keyword state
if  lex_state    lexstate expr_fname
yaccvalue   new token keyword name  getposition
else
yaccvalue   new token tempval  getposition
}
if  keyword id0    tokens kdo
if  conditionstate isinstate    return tokens kdo_cond
if  state    lexstate expr_cmdarg    cmdargumentstate isinstate
return tokens kdo_block
}
if  state    lexstate expr_endarg  return tokens kdo_block
return tokens kdo
}
if  state    lexstate expr_beg  return keyword id0
if  keyword id0    keyword id1  lex_state   lexstate expr_beg
return keyword id1
}
}
switch  lex_state
case expr_beg  case expr_mid  case expr_dot  case expr_arg  case expr_cmdarg
lex_state   commandstate ? lexstate expr_cmdarg   lexstate expr_arg
break;
default
lex_state   lexstate expr_end
break;
}
return identifiertoken last_state  result  tempval
}
private int leftbracket boolean spaceseen  throws ioexception
int c
switch  lex_state
case expr_fname  case expr_dot
lex_state   lexstate expr_arg
if   c   src read
if  src peek
c = src.read();
yaccvalue   new token    getposition
return tokens taset
}
yaccvalue   new token    getposition
return tokens taref
}
src unread c
yaccvalue   new token    getposition
return
case expr_beg  case expr_mid
c   tokens tlbrack
break;
case expr_arg  case expr_cmdarg
if  spaceseen  c   tokens tlbrack
}
lex_state   lexstate expr_beg
conditionstate stop
cmdargumentstate stop
yaccvalue   new token    getposition
return c
}
private int leftcurly
char c
switch  lex_state
case expr_arg  case expr_cmdarg  case expr_end     block  primary
c   tokens tlcurly
break;
case expr_endarg     block  expr
c   tokens tlbrace_arg
break;
default     hash
c   tokens tlbrace
}
conditionstate stop
cmdargumentstate stop
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return c
}
private int leftparen boolean spaceseen  throws ioexception
commandstart   true
int result
switch  lex_state
case expr_beg  case expr_mid
result   tokens tlparen
break;
case expr_cmdarg
result   spaceseen ? tokens tlparen_arg   tokens tlparen2
break;
case expr_arg
if  spaceseen
warnings warn id argument_extra_space  getposition
}
default
result   tokens tlparen2
}
conditionstate stop
cmdargumentstate stop
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return result
}
private int lessthan boolean spaceseen  throws ioexception
int c   src read
if  c         lex_state    lexstate expr_end    lex_state    lexstate expr_dot
lex_state    lexstate expr_endarg    lex_state    lexstate expr_class
lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg     spaceseen
int tok   heredocumentidentifier
if  tok    0  return tok
}
determineexpressionstate
switch  c
case
if   c   src read
yaccvalue   new token    getposition
return tokens tcmp
}
src unread c
yaccvalue   new token    getposition
return tokens tleq
case
if   c   src read
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
}
src unread c
yaccvalue   new token    getposition
return tokens tlshft
default
yaccvalue   new token    getposition
src unread c
return tokens tlt
}
}
private int minus boolean spaceseen  throws ioexception
int c   src read
if  lex_state    lexstate expr_fname    lex_state    lexstate expr_dot
lex_state   lexstate expr_arg
if  c
yaccvalue   new token    getposition
return tokens tuminus
}
src unread c
yaccvalue   new token    getposition
return tokens tminus
}
if  c
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
}
if  lex_state    lexstate expr_beg    lex_state    lexstate expr_mid
lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg     spaceseen     character iswhitespace c
if  lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg  arg_ambiguous
lex_state   lexstate expr_beg
src unread c
yaccvalue   new token    getposition
if  character isdigit c
return tokens tuminus_num
}
return tokens tuminus
}
lex_state   lexstate expr_beg
src unread c
yaccvalue   new token    getposition
return tokens tminus
}
private int percent boolean spaceseen  throws ioexception
if  lex_state    lexstate expr_beg    lex_state    lexstate expr_mid
return parsequote src read
}
int c   src read
if  c
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
}
if   lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg     spaceseen
character iswhitespace c
return parsequote c
}
determineexpressionstate
src unread c
yaccvalue   new token    getposition
return tokens tpercent
}
private int pipe   throws ioexception
int c   src read
switch  c
case
lex_state   lexstate expr_beg
if   c   src read
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
}
src unread c
yaccvalue   new token    getposition
return tokens torop
case
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
default
determineexpressionstate
src unread c
yaccvalue   new token    getposition
return tokens tpipe
}
}
private int plus boolean spaceseen  throws ioexception
int c   src read
if  lex_state    lexstate expr_fname    lex_state    lexstate expr_dot
lex_state   lexstate expr_arg
if  c
yaccvalue   new token    getposition
return tokens tuplus
}
src unread c
yaccvalue   new token    getposition
return tokens tplus
}
if  c
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
}
if  lex_state    lexstate expr_beg    lex_state    lexstate expr_mid
lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg
spaceseen     character iswhitespace c
if  lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg  arg_ambiguous
lex_state   lexstate expr_beg
src unread c
if  character isdigit c
c
return parsenumber c
}
yaccvalue   new token    getposition
return tokens tuplus
}
lex_state   lexstate expr_beg
src unread c
yaccvalue   new token    getposition
return tokens tplus
}
private int questionmark   throws ioexception
int c
if  lex_state    lexstate expr_end    lex_state    lexstate expr_endarg
lex_state   lexstate expr_beg
yaccvalue   new token   getposition
return
}
c = src.read();
if  c    eof  throw new syntaxexception pid incomplete_char_syntax  getposition
if  character iswhitespace c
if  lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg
int c2   0
switch  c
case
c2
break;
case
c2
break;
case
c2
break;
/* what is \v in c?
case '\v':
c2 = 'v';
break;
*/
case
c2
break;
case
c2
break;
}
if  c2    0
warnings warn id invalid_char_sequence  getposition        c2
}
}
src unread c
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return
/*} else if (ismbchar(c)) { // ruby - we don't support them either?
rb_warn("multibyte character literal not supported yet; use ?\\" + c);
support.unread(c);
lexstate = lexstate.expr_beg;
return '?';*/
else if  isidentifierchar c      src peek       isnext_identchar
src unread c
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return
else if  c
c   readescape
}
c    0xff
lex_state   lexstate expr_end
yaccvalue   new fixnumnode getposition    c
return tokens tinteger
}
private int rightbracket
conditionstate restart
cmdargumentstate restart
lex_state   lexstate expr_end
yaccvalue   new token    getposition
return tokens trbrack
}
private int rightcurly
conditionstate restart
cmdargumentstate restart
lex_state   lexstate expr_end
yaccvalue   new token   getposition
return tokens trcurly
}
private int rightparen
conditionstate restart
cmdargumentstate restart
lex_state   lexstate expr_end
yaccvalue   new token    getposition
return tokens trparen
}
private int singlequote   throws ioexception
lex_strterm   new stringterm str_squote
yaccvalue   new token    getposition
return tokens tstring_beg
}
private int slash boolean spaceseen  throws ioexception
if  lex_state    lexstate expr_beg    lex_state    lexstate expr_mid
lex_strterm   new stringterm str_regexp
yaccvalue   new token   getposition
return tokens tregexp_beg
}
int c   src read
if  c
yaccvalue   new token    getposition
lex_state   lexstate expr_beg
return tokens top_asgn
}
src unread c
if   lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg     spaceseen
if   character iswhitespace c
arg_ambiguous
lex_strterm   new stringterm str_regexp
yaccvalue   new token   getposition
return tokens tregexp_beg
}
}
determineexpressionstate
yaccvalue   new token    getposition
return tokens tdivide
}
private int star boolean spaceseen  throws ioexception
int c   src read
switch  c
case
if   c   src read
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
}
src unread c
yaccvalue   new token    getposition
c   tokens tpow
break;
case
lex_state   lexstate expr_beg
yaccvalue   new token    getposition
return tokens top_asgn
default
src unread c
if   lex_state    lexstate expr_arg    lex_state    lexstate expr_cmdarg
spaceseen     character iswhitespace c
warnings warning id argument_as_prefix  getposition
c   tokens tstar
else if  lex_state    lexstate expr_beg    lex_state    lexstate expr_mid
c   tokens tstar
else
c   tokens tstar2
}
yaccvalue   new token    getposition
}
determineexpressionstate
return c
}
private int tilde   throws ioexception
int c
if  lex_state    lexstate expr_fname    lex_state    lexstate expr_dot
if   c   src read          src unread c
}
determineexpressionstate
yaccvalue   new token    getposition
return tokens ttilde
}
/**
*  parse a number from the input stream.
*
*@param c the first character of the number.
*@return a int constant wich represents a token.
*/
private int parsenumber int c  throws ioexception
lex_state   lexstate expr_end
tokenbuffer setlength 0
if  c
tokenbuffer append  char  c
c = src.read();
else if  c
// we don't append '+' since java number parser gets confused
c = src.read();
}
int nondigit   0
if  c
int startlen   tokenbuffer length
switch  c   src read
case
case         hexadecimal
c = src.read();
if  ishexchar c
for     c   src read
if  c
if  nondigit       break
nondigit   c
else if  ishexchar c
nondigit
tokenbuffer append  char  c
else
break;
}
}
}
src unread c
if  tokenbuffer length      startlen
throw new syntaxexception pid bad_hex_number  getposition
else if  nondigit
throw new syntaxexception pid trailing_underscore_in_number  getposition
}
yaccvalue   getinteger tokenbuffer tostring    16
return tokens tinteger
case
case        binary
c = src.read();
if  c         c
for     c   src read
if  c
if  nondigit       break
nondigit   c
else if  c         c
nondigit
tokenbuffer append  char  c
else
break;
}
}
}
src unread c
if  tokenbuffer length      startlen
throw new syntaxexception pid empty_binary_number  getposition
else if  nondigit
throw new syntaxexception pid trailing_underscore_in_number  getposition
}
yaccvalue   getinteger tokenbuffer tostring    2
return tokens tinteger
case
case        decimal
c = src.read();
if  character isdigit c
for     c   src read
if  c
if  nondigit       break
nondigit   c
else if  character isdigit c
nondigit
tokenbuffer append  char  c
else
break;
}
}
}
src unread c
if  tokenbuffer length      startlen
throw new syntaxexception pid empty_binary_number  getposition
else if  nondigit
throw new syntaxexception pid trailing_underscore_in_number  getposition
}
yaccvalue   getinteger tokenbuffer tostring    10
return tokens tinteger
case
c = src.read();
case    case    case    case    case      octal
case    case    case    case
for     c   src read
if  c
if  nondigit       break
nondigit   c
else if  c >       c <
nondigit
tokenbuffer append  char  c
else
break;
}
}
if  tokenbuffer length   > startlen
src unread c
if  nondigit
throw new syntaxexception pid trailing_underscore_in_number  getposition
}
yaccvalue   getinteger tokenbuffer tostring    8
return tokens tinteger
}
case
case
throw new syntaxexception pid bad_octal_digit  getposition
case
case
case
tokenbuffer append
break;
default
src unread c
yaccvalue   new fixnumnode getposition    0
return tokens tinteger
}
}
boolean seen_point   false
boolean seen_e   false
for     c   src read
switch  c
case
case
case
case
case
case
case
case
case
case
nondigit
tokenbuffer append  char  c
break;
case
if  nondigit
src unread c
throw new syntaxexception pid trailing_underscore_in_number  getposition
else if  seen_point    seen_e
src unread c
return getnumbertoken tokenbuffer tostring    true  nondigit
else
int c2
if   character isdigit c2   src read
src unread c2
src unread
if  c
// enebo:  c can never be antrhign but '.'
// why did i put this here?
else
yaccvalue   getinteger tokenbuffer tostring    10
return tokens tinteger
}
else
tokenbuffer append
tokenbuffer append  char  c2
seen_point   true
nondigit
}
}
break;
case
case
if  nondigit
throw new syntaxexception pid trailing_underscore_in_number  getposition
else if  seen_e
src unread c
return getnumbertoken tokenbuffer tostring    true  nondigit
else
tokenbuffer append  char  c
seen_e   true
nondigit   c
c = src.read();
if  c         c
tokenbuffer append  char  c
nondigit   c
else
src unread c
}
}
break;
case           in number just ignored
if  nondigit
throw new syntaxexception pid trailing_underscore_in_number  getposition
}
nondigit   c
break;
default
src unread c
return getnumbertoken tokenbuffer tostring    seen_e    seen_point  nondigit
}
}
}
private int getnumbertoken string number  boolean isfloat  int nondigit
if  nondigit
throw new syntaxexception pid trailing_underscore_in_number  getposition
}
if  isfloat
double d
try
d   double parsedouble number
catch  numberformatexception e
warnings warn id float_out_of_range  getposition        number      number
d   number startswith    ? double negative_infinity   double positive_infinity
}
yaccvalue   new floatnode getposition    d
return tokens tfloat
}
yaccvalue   getinteger number  10
return tokens tinteger
}
public int readescape   throws ioexception
int c   src read
switch  c
case        backslash
return c
case        newline
return
case        horizontal tab
return
case        carriage return
return
case        form feed
return
case        vertical tab
return
case        alarm bell
return
case        escape
return
case     case     case     case        octal constant
case     case     case     case
src unread c
return scanoct 3
case        hex constant
int i   0
//char hexvalue = scanhex(2);
char hexvalue
for    i < 2  i
int h1   src read
if   rubyyacclexer ishexchar h1
src unread h1
break;
}
hexvalue <<  4
hexvalue    integer parseint    char h1  16    15
}
// no hex value after the 'x'.
if  i    0
throw new syntaxexception pid invalid_escape_syntax  getposition
}
return hexvalue
case        backspace
return
case        space
return
case
if   c   src read
throw new syntaxexception pid invalid_escape_syntax  getposition
else if   c   src read
return  char   readescape     0x80
else if  c    eof
throw new syntaxexception pid invalid_escape_syntax  getposition
}
return  char    c   0xff    0x80
case
if   c   src read
throw new syntaxexception pid invalid_escape_syntax  getposition
}
case
if   c   src read
c   readescape
else if  c
return
else if  c    eof
throw new syntaxexception pid invalid_escape_syntax  getposition
}
return  char   c   0x9f
case eof
throw new syntaxexception pid invalid_escape_syntax  getposition
default
return c
}
}
private char scanoct int count  throws ioexception
char value
for  int i   0  i < count  i
int c   src read
if   rubyyacclexer isoctchar c
src unread c
break;
}
value <<  3
value    integer parseint      char  c  8
}
return value
}
}