package org jruby lexer yacc
import java io ioexception
import java util list
import org jruby parser parserconfiguration
import org jruby util bytelist
public class bytelistlexersource extends lexersource
private int begin
private int realsize
private int index
private byte bytes
public bytelistlexersource string sourcename  bytelist bytelist  list<string> list  int line
boolean extrapositioninformation
super sourcename  list  line  extrapositioninformation
/* consider thread aspects of this */
bytes   bytelist bytes
index   bytelist begin
begin   index
realsize   bytelist realsize
@override
public boolean matchmarker bytelist marker  boolean indent  boolean checknewline  throws ioexception
// where we started this marker match
int start   index
if  indent
int c
while   c   read       rubyyacclexer eof
if   character iswhitespace c     c
index
break
for  int i   0  i < marker length    i
if  marker charat i     read
index   start
return false
if   checknewline  return true
char c    char  internalread
if  c    rubyyacclexer eof    c       return true
index   start
return false
@override
public boolean peek int c  throws ioexception
if  index >  realsize  return c    rubyyacclexer eof
return bytes    c
private byte internalread
return index >  realsize ? rubyyacclexer eof   bytes
@override
public int read   throws ioexception
byte c   internalread
// if \r\n then just pass along \n (windows).
// if \r[^\n] then pass along \n (mac).
switch  c
case
if   c   internalread
unread  char  c
c
line
else
// position within source must reflect the actual offset and column.  since
// we ate an extra character here (this accounting is normally done in read
// ), we should update position info.
offset
// we use offset here to keep track of extra newlines for windows
break
case
line
break
return c
@override
public bytelist readlinebytes   throws ioexception
int count   0
for  int c   read    c         c    rubyyacclexer eof  c   read
count
return new bytelist bytes  index   count   1  count  false
@override
public int skipuntil int c  throws ioexception
for  c   read    c         c    rubyyacclexer eof  c   read
return c
@override
public void unread int c
if  c    rubyyacclexer eof  return
index
if  c       line
// fixme: \r logic needed
@override
public void unreadmany charsequence line
int length   line length
index    length
@override
public boolean wasbeginofline
// fixme: old mac format strings?
return index    0    bytes
@override
public boolean lastwasbeginofline
// fixme: old mac format strings?
return index    0    bytes
public static lexersource getsource string file  bytelist content  list<string> list
parserconfiguration configuration
if  list    null
return new capturingbytelistlexersource file  content  list  configuration getlinenumber
configuration hasextrapositioninformation
return new bytelistlexersource file  content  list  configuration getlinenumber
configuration hasextrapositioninformation
@override
public int getoffset
return index   begin   offset
@override
public bytelist readuntil char marker  throws ioexception
int begin   index
int i   begin
for     i < realsize    bytes    marker  i
if  i >  realsize  return null
index   i
return new bytelist bytes  begin  i   begin  false
@override
public string tostring
try
bytelist buffer   new bytelist 20
buffer append bytes
buffer append bytes
buffer append new byte
for  int i   index   1  i < index   20  i
if  index > realsize  break
buffer append bytes
buffer append new byte
return buffer tostring
catch exception e
return null