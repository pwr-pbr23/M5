/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 charles o nutter <headius@headius.com>
* copyright (c) 2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006-2007 mirko stocker <me@misto.ch>
* copyright (c) 2006 thomas corbat <tcorbat@hsr.ch>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby parser
import org jruby ast andnode
import org jruby ast argscatnode
import org jruby ast argspushnode
import org jruby ast argumentnode
import org jruby ast arraynode
import org jruby ast assignablenode
import org jruby ast attrassignnode
import org jruby ast backrefnode
import org jruby ast beginnode
import org jruby ast bignumnode
import org jruby ast blocknode
import org jruby ast blockpassnode
import org jruby ast breaknode
import org jruby ast callnode
import org jruby ast classvarasgnnode
import org jruby ast classvardeclnode
import org jruby ast classvarnode
import org jruby ast constdeclnode
import org jruby ast constnode
import org jruby ast dasgnnode
import org jruby ast dregexpnode
import org jruby ast dstrnode
import org jruby ast dotnode
import org jruby ast evstrnode
import org jruby ast fcallnode
import org jruby ast falsenode
import org jruby ast fixnumnode
import org jruby ast flipnode
import org jruby ast floatnode
import org jruby ast globalasgnnode
import org jruby ast globalvarnode
import org jruby ast iargumentnode
import org jruby ast ifnode
import org jruby ast instasgnnode
import org jruby ast instvarnode
import org jruby ast listnode
import org jruby ast localasgnnode
import org jruby ast match2node
import org jruby ast match3node
import org jruby ast matchnode
import org jruby ast multipleasgnnode
import org jruby ast newlinenode
import org jruby ast nilnode
import org jruby ast node
import org jruby ast nthrefnode
import org jruby ast ornode
import org jruby ast regexpnode
import org jruby ast rootnode
import org jruby ast svaluenode
import org jruby ast selfnode
import org jruby ast splatnode
import org jruby ast strnode
import org jruby ast supernode
import org jruby ast symbolnode
import org jruby ast truenode
import org jruby ast yieldnode
import org jruby ast types iliteralnode
import org jruby ast types inamenode
import org jruby common irubywarnings
import org jruby common irubywarnings id
import org jruby lexer yacc isourceposition
import org jruby lexer yacc isourcepositionholder
import org jruby lexer yacc idesourceposition
import org jruby lexer yacc syntaxexception
import org jruby lexer yacc token
import org jruby lexer yacc syntaxexception pid
import org jruby runtime dynamicscope
import org jruby util bytelist
/**
*
*/
public class parsersupport
// parser states:
private staticscope currentscope
// is the parser current within a singleton (value is number of nested singletons)
private int insingleton
// is the parser currently within a method definition
private boolean indefinition
private irubywarnings warnings
private parserconfiguration configuration
private rubyparserresult result
public void reset
insingleton   0
indefinition   false
public staticscope getcurrentscope
return currentscope
public parserconfiguration getconfiguration
return configuration
public void popcurrentscope
currentscope   currentscope getenclosingscope
public void pushblockscope
currentscope   new blockstaticscope currentscope
public void pushlocalscope
currentscope   new localstaticscope currentscope
public node arg_concat isourceposition position  node node1  node node2
return node2    null ? node1   new argscatnode position  node1  node2
public node arg_blk_pass node firstnode  blockpassnode secondnode
if  secondnode    null
secondnode setargsnode firstnode
return secondnode
return firstnode
/**
* we know for callers of this that it cannot be any of the specials checked in gettable.
*
* @param node to check its variable type
* @return an ast node representing this new variable
*/
public node gettable2 node node
switch  node nodeid
case dasgnnode     localvar
case localasgnnode
return currentscope declare node getposition      inamenode  node  getname
case constdeclnode     constant
return currentscope declare node getposition      inamenode  node  getname
case instasgnnode     instance variable
return new instvarnode node getposition      inamenode  node  getname
case classvardeclnode
case classvarasgnnode
return new classvarnode node getposition      inamenode  node  getname
case globalasgnnode
return new globalvarnode node getposition      inamenode  node  getname
throw new syntaxexception pid bad_identifier  node getposition
inamenode  node  getname          inamenode  node  getname
/**
* create ast node representing variable type it represents.
*
* @param token to check its variable type
* @return an ast node representing this new variable
*/
public node gettable token token
switch  token gettype
case tokens kself
return new selfnode token getposition
case tokens knil
return new nilnode token getposition
case tokens ktrue
return new truenode token getposition
case tokens kfalse
return new falsenode token getposition
case tokens k__file__
return new strnode token getposition    bytelist create token getposition   getfile
case tokens k__line__
return new fixnumnode token getposition    token getposition   getendline   1
case tokens tidentifier
return currentscope declare token getposition     string  token getvalue
case tokens tconstant
return new constnode token getposition     string  token getvalue
case tokens tivar
return new instvarnode token getposition     string  token getvalue
case tokens tcvar
return new classvarnode token getposition     string  token getvalue
case tokens tgvar
return new globalvarnode token getposition     string  token getvalue
throw new syntaxexception pid bad_identifier  token getposition
string  token getvalue        token getvalue
public assignablenode assignable token lhs  node value
checkexpression value
switch  lhs gettype
case tokens kself
throw new syntaxexception pid cannot_change_self  lhs getposition
case tokens knil
throw new syntaxexception pid invalid_assignment  lhs getposition
case tokens ktrue
throw new syntaxexception pid invalid_assignment  lhs getposition
case tokens kfalse
throw new syntaxexception pid invalid_assignment  lhs getposition
case tokens k__file__
throw new syntaxexception pid invalid_assignment  lhs getposition
case tokens k__line__
throw new syntaxexception pid invalid_assignment  lhs getposition
case tokens tidentifier
return currentscope assign value    null ? union lhs  value    lhs getposition     string  lhs getvalue    value
case tokens tconstant
if  isindef      isinsingle
throw new syntaxexception pid dynamic_constant_assignment  lhs getposition
return new constdeclnode lhs getposition     string  lhs getvalue    null  value
case tokens tivar
return new instasgnnode lhs getposition     string  lhs getvalue    value
case tokens tcvar
if  isindef      isinsingle
return new classvarasgnnode lhs getposition     string  lhs getvalue    value
return new classvardeclnode lhs getposition     string  lhs getvalue    value
case tokens tgvar
return new globalasgnnode lhs getposition     string  lhs getvalue    value
throw new syntaxexception pid bad_identifier  lhs getposition
string  lhs getvalue        lhs getvalue
/**
*  wraps node with newline node.
*
*@param node
*@return a newlinenode or null if node is null.
*/
public node newline_node node node  isourceposition position
if  node    null  return null
return node instanceof newlinenode ? node   new newlinenode position  node
public isourceposition union isourcepositionholder first  isourcepositionholder second
while  first instanceof newlinenode
first     newlinenode  first  getnextnode
while  second instanceof newlinenode
second     newlinenode  second  getnextnode
if  second    null 	return first getposition
if  first    null  return second getposition
return first getposition   union second getposition
public isourceposition union isourceposition first  isourceposition second
if  first getstartoffset   < second getstartoffset    return first union second
return second union first
public node addrootnode node topofast  isourceposition position
position   topofast    null ? topofast getposition     position
if  result getbeginnodes   size      0  return new rootnode position  result getscope    topofast
blocknode newtopofast   new blocknode position
for  node beginnode  result getbeginnodes
appendtoblock newtopofast  beginnode
// add real top to new top (unless this top is empty [only begin/end nodes or truly empty])
if  topofast    null  newtopofast add topofast
return new rootnode position  result getscope    newtopofast
/* mri: block_append */
public node appendtoblock node head  node tail
if  tail    null  return head
if  head    null  return tail
// reduces overhead in interp by not set position every single line we encounter.
if   configuration hasextrapositioninformation
while  head instanceof newlinenode
node nextnode     newlinenode  head  getnextnode
if    nextnode instanceof newlinenode   break
head   nextnode
if    head instanceof blocknode
head   new blocknode head getposition    add head
if  warnings isverbose      isbreakstatement   listnode  head  getlast
warnings warning id statement_not_reached  tail getposition
// assumption: tail is never a list node
listnode  head  addall tail
head setposition union head  tail
return head
public node getoperatorcallnode node firstnode  string operator
checkexpression firstnode
return new callnode firstnode getposition    firstnode  operator  null
public node getoperatorcallnode node firstnode  string operator  node secondnode
return getoperatorcallnode firstnode  operator  secondnode  null
public node getoperatorcallnode node firstnode  string operator  node secondnode  isourceposition defaultposition
if  defaultposition    null
firstnode   checkfornilnode firstnode  defaultposition
secondnode   checkfornilnode secondnode  defaultposition
checkexpression firstnode
checkexpression secondnode
return new callnode union firstnode getposition    secondnode getposition     firstnode  operator  new arraynode secondnode getposition    secondnode
public node getmatchnode node firstnode  node secondnode
if  firstnode instanceof dregexpnode    firstnode instanceof regexpnode
return new match2node firstnode getposition    firstnode  secondnode
else if  secondnode instanceof dregexpnode    secondnode instanceof regexpnode
return new match3node firstnode getposition    secondnode  firstnode
return getoperatorcallnode firstnode     secondnode
/**
* define an array set condition so we can return lhs
*
* @param receiver array being set
* @param index node which should evalute to index of array set
* @return an attrassignnode
*/
public node aryset node receiver  node index
checkexpression receiver
return new attrassignnode receiver getposition    receiver     index
/**
* define an attribute set condition so we can return lhs
*
* @param receiver object which contains attribute
* @param name of the attribute being set
* @return an attrassignnode
*/
public node attrset node receiver  string name
checkexpression receiver
return new attrassignnode receiver getposition    receiver  name      null
public void backrefassignerror node node
if  node instanceof nthrefnode
string varname         nthrefnode  node  getmatchnumber
throw new syntaxexception pid invalid_assignment  node getposition
varname      varname
else if  node instanceof backrefnode
string varname         backrefnode  node  gettype
throw new syntaxexception pid invalid_assignment  node getposition        varname      varname
public node arg_add isourceposition position  node node1  node node2
if  node1    null  return new arraynode node2    null ? position   node2 getposition    node2
if  node1 instanceof arraynode  return   arraynode  node1  add node2
return new argspushnode position  node1  node2
/**
* @fixme position
**/
public node node_assign node lhs  node rhs
if  lhs    null  return null
node newnode   lhs
checkexpression rhs
if  lhs instanceof assignablenode
assignablenode  lhs  setvaluenode rhs
lhs setposition union lhs  rhs
else if  lhs instanceof iargumentnode
iargumentnode invokablenode    iargumentnode  lhs
invokablenode setargsnode arg_add lhs getposition    invokablenode getargsnode    rhs
return newnode
public node ret_args node node  isourceposition position
if  node    null
if  node instanceof blockpassnode
throw new syntaxexception pid dynamic_constant_assignment  position
else if  node instanceof arraynode      arraynode node  size      1
node     arraynode node  get 0
else if  node instanceof splatnode
node   new svaluenode position  node
return node
/**
* is the supplied node a break/control statement?
*
* @param node to be checked
* @return true if a control node, false otherwise
*/
public boolean isbreakstatement node node
breakloop  do
if  node    null  return false
switch  node nodeid
case newlinenode
node     newlinenode  node  getnextnode
continue breakloop
case breaknode  case nextnode  case redonode
case retrynode  case returnnode
return true
default
return false
while  true
public void warnunlesseoption id id  node node  string message
if   configuration isinlinesource
warnings warn id  node getposition    message
public void warningunlesseoption id id  node node  string message
if   configuration isinlinesource
warnings warning id  node getposition    message
/**
* does this node represent an expression?
* @param node to be checked
* @return true if an expression, false otherwise
*/
public void checkexpression node node
if   isexpression node
warnings warning id void_value_expression  node getposition
private boolean isexpression node node
do
if  node    null  return true
switch  node nodeid
case beginnode
node     beginnode  node  getbodynode
break
case blocknode
node     blocknode  node  getlast
break
case breaknode
node     breaknode  node  getvaluenode
break
case classnode  case defnnode  case defsnode  case modulenode  case nextnode
case redonode  case retrynode  case returnnode  case untilnode  case whilenode
return false
case ifnode
return isexpression   ifnode  node  getthenbody
isexpression   ifnode  node  getelsebody
case newlinenode
node     newlinenode  node  getnextnode
break
default     node
return true
while  true
/**
* is this a literal in the sense that mri has a node_lit for.  this is different than
* iliteralnode.  we should pick a different name since iliteralnode is something we created
* which is similiar but used for a slightly different condition (can i do singleton things).
*
* @param node to be tested
* @return true if it is a literal
*/
public boolean isliteral node node
return node    null     node instanceof fixnumnode    node instanceof bignumnode
node instanceof floatnode    node instanceof symbolnode
node instanceof regexpnode
regexpnode  node  getoptions     ~reoptions re_option_once     0
private void handleuselesswarn node node  string useless
warnings warn id useless_expression  node getposition        useless      useless
/**
* check to see if current node is an useless statement.  if useless a warning if printed.
*
* @param node to be checked.
*/
public void checkuselessstatement node node
if   warnings isverbose    return
uselessloop  do
if  node    null  return
switch  node nodeid
case newlinenode
node     newlinenode  node  getnextnode
continue uselessloop
case callnode
string name     callnode  node  getname
if  name         name         name         name         name
name         name         name         name         name
name         name         name         name         name
name         name         name
handleuselesswarn node  name
return
case backrefnode  case dvarnode  case globalvarnode
case localvarnode  case nthrefnode  case classvarnode
case instvarnode
handleuselesswarn node      return
// fixme: temporarily disabling because this fires way too much running rails tests. jruby-518
/*case constnode:
handleuselesswarn(node, "a constant"); return;*/
case bignumnode  case dregexpnode  case dstrnode  case dsymbolnode
case fixnumnode  case floatnode  case regexpnode
case strnode  case symbolnode
handleuselesswarn node      return
// fixme: temporarily disabling because this fires way too much running rails tests. jruby-518
/*case classnode: case colon2node:
handleuselesswarn(node, "::"); return;*/
case dotnode
handleuselesswarn node    dotnode  node  isexclusive   ?         return
case definednode
handleuselesswarn node      return
case falsenode
handleuselesswarn node      return
case nilnode
handleuselesswarn node      return
// fixme: temporarily disabling because this fires way too much running rails tests. jruby-518
/*case selfnode:
handleuselesswarn(node, "self"); return;*/
case truenode
handleuselesswarn node      return
default  return
while  true
/**
* check all nodes but the last one in a blocknode for useless (void context) statements.
*
* @param blocknode to be checked.
*/
public void checkuselessstatements blocknode blocknode
if  warnings isverbose
node lastnode   blocknode getlast
for  int i   0  i < blocknode size    i
node currentnode   blocknode get i
if  lastnode    currentnode
checkuselessstatement currentnode
/**
* @fixme error handling
**/
private boolean checkassignmentincondition node node
if  node instanceof multipleasgnnode
throw new syntaxexception pid multiple_assignment_in_conditional  node getposition
else if  node instanceof localasgnnode    node instanceof dasgnnode    node instanceof globalasgnnode    node instanceof instasgnnode
node valuenode     assignablenode  node  getvaluenode
if  valuenode instanceof iliteralnode    valuenode instanceof nilnode    valuenode instanceof truenode    valuenode instanceof falsenode
warnings warn id assignment_in_conditional  node getposition
return true
return false
private node cond0 node node
checkassignmentincondition node
switch node nodeid
case dregexpnode
isourceposition position   node getposition
return new match2node position  node  new globalvarnode position
case andnode
return new andnode node getposition    cond0   andnode  node  getfirstnode
cond0   andnode  node  getsecondnode
case ornode
return new ornode node getposition    cond0   ornode  node  getfirstnode
cond0   ornode  node  getsecondnode
case dotnode
dotnode dotnode    dotnode  node
if  dotnode isliteral    return node
string label   string valueof     node hashcode
currentscope getlocalscope   addvariable label
int slot   currentscope isdefined label
return new flipnode node getposition
getflipconditionnode   dotnode  node  getbeginnode
getflipconditionnode   dotnode  node  getendnode
dotnode isexclusive    slot
case regexpnode
warningunlesseoption id regexp_literal_in_condition  node
return new matchnode node getposition    node
return node
public node getconditionnode node node
if  node    null  return null
if  node instanceof newlinenode
return new newlinenode node getposition    cond0   newlinenode  node  getnextnode
return cond0 node
/* mri: range_op */
private node getflipconditionnode node node
if   configuration isinlinesource    return node
node   getconditionnode node
if  node instanceof newlinenode  return   newlinenode  node  getnextnode
if  node instanceof fixnumnode
warnunlesseoption id literal_in_conditional_range  node
return getoperatorcallnode node     new globalvarnode node getposition
return node
public andnode newandnode node left  node right
checkexpression left
return new andnode union left  right   left  right
public ornode newornode node left  node right
checkexpression left
return new ornode union left  right   left  right
public node getreturnargsnode node node
if  node instanceof arraynode      arraynode  node  size      1
return   listnode  node  get 0
else if  node instanceof blockpassnode
throw new syntaxexception pid block_arg_unexpected  node getposition
return node
public node new_call node receiver  token name  node args  node iter
if  args    null
return new callnode union receiver  name   receiver  string  name getvalue    null  iter
if  args instanceof blockpassnode
// block and block pass passed in at same time....uh oh
if  iter    null
throw new syntaxexception pid block_arg_and_block_given  iter getposition
return new callnode union receiver  args   receiver   string  name getvalue
blockpassnode  args  getargsnode    args
return new callnode union receiver  args   receiver  string  name getvalue    args  iter
public node new_fcall token operation  node args  node iter
string name    string  operation getvalue
if  args    null  return new fcallnode operation getposition    name  args  iter
if  args instanceof blockpassnode
if  iter    null
throw new syntaxexception pid block_arg_and_block_given  iter getposition
return new fcallnode union operation  args   name    blockpassnode  args  getargsnode    args
return new fcallnode union operation  args   name  args  iter
public node new_super node args  token operation
if  args    null    args instanceof blockpassnode
return new supernode union operation  args     blockpassnode  args  getargsnode    args
return new supernode operation getposition    args
/**
*  description of the rubymethod
*/
public void inittoplocalvariables
dynamicscope scope   configuration getscope
currentscope   scope getstaticscope
result setscope scope
/** getter for property insingle.
* @return value of property insingle.
*/
public boolean isinsingle
return insingleton    0
/** setter for property insingle.
* @param insingle new value of property insingle.
*/
public void setinsingle int insingle
this insingleton   insingle
public boolean isindef
return indefinition
public void setindef boolean indef
this indefinition   indef
/** getter for property insingle.
* @return value of property insingle.
*/
public int getinsingle
return insingleton
/**
* gets the result.
* @return returns a rubyparserresult
*/
public rubyparserresult getresult
return result
/**
* sets the result.
* @param result the result to set
*/
public void setresult rubyparserresult result
this result   result
/**
* sets the configuration.
* @param configuration the configuration to set
*/
public void setconfiguration parserconfiguration configuration
this configuration   configuration
public void setwarnings irubywarnings warnings
this warnings   warnings
public node literal_concat isourceposition position  node head  node tail
if  head    null  return tail
if  tail    null  return head
if  head instanceof evstrnode
head   new dstrnode union head getposition    position   add head
if  tail instanceof strnode
if  head instanceof strnode
return new strnode union head  tail    strnode  head   strnode  tail
head setposition union head  tail
return   listnode  head  add tail
else if  tail instanceof dstrnode
if  head instanceof strnode
dstrnode tail  prepend head
return tail
return   listnode  head  addall tail
// tail must be evstrnode at this point
if  head instanceof strnode
//do not add an empty string node
if   strnode  head  getvalue   length      0
head   new dstrnode head getposition
else
// all first element strnode's do not include syntacical sugar.
head getposition   adjuststartoffset  1
head   new dstrnode head getposition    add head
return   dstrnode  head  add tail
public node newevstrnode isourceposition position  node node
node head   node
while  true
if  node    null  break
if  node instanceof strnode    node instanceof dstrnode    node instanceof evstrnode
return node
if    node instanceof newlinenode   break
node     newlinenode  node  getnextnode
return new evstrnode position  head
public node new_yield isourceposition position  node node
boolean state   true
if  node    null
if  node instanceof blockpassnode
throw new syntaxexception pid block_arg_unexpected  node getposition
if  node instanceof arraynode      arraynode node  size      1
node     arraynode node  get 0
state   false
if  node    null    node instanceof splatnode
state   true
else
state   false
return new yieldnode position  node  state
public node negateinteger node integernode
if  integernode instanceof fixnumnode
fixnumnode fixnumnode    fixnumnode  integernode
fixnumnode setvalue  fixnumnode getvalue
return fixnumnode
else if  integernode instanceof bignumnode
bignumnode bignumnode    bignumnode  integernode
bignumnode setvalue bignumnode getvalue   negate
return integernode
public floatnode negatefloat floatnode floatnode
floatnode setvalue  floatnode getvalue
return floatnode
public isourceposition createemptyargsnodeposition isourceposition pos
return new idesourceposition pos getfile    pos getstartline    pos getendline    pos getendoffset     1  pos getendoffset     1
public node unwrapnewlinenode node node
if node instanceof newlinenode
return   newlinenode  node  getnextnode
return node
private node checkfornilnode node node  isourceposition defaultposition
return  node    null  ? new nilnode defaultposition    node
public argumentnode getrestargnode token token
int index     integer  token getvalue    intvalue
if index < 0
return null
string name   getcurrentscope   getlocalscope   getvariables
isourceposition position   new idesourceposition token getposition   getfile    token getposition   getstartline    token getposition   getendline    token getposition   getstartoffset    token getposition   getendoffset     name length
return new argumentnode position  name