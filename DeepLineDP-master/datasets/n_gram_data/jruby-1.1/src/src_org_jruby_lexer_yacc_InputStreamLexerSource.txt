package org jruby lexer yacc
import java io ioexception
import java io inputstream
import java util list
import org jruby parser parserconfiguration
import org jruby util bytelist
public class inputstreamlexersource extends lexersource
private static final int initial_pushback_size   100
// where we get our newest char's
private final inputstream in
// our readback/pushback buffer.
private char buf   new char
// index of last character in pushback buffer
private int buflength    1
// character read before previous read
private int oneago
private int twoago   0
/**
* create our food-source for the lexer
*
* @param sourcename is the file we are reading
* @param reader is what represents the contents of file sourcename
* @param line starting line number for source (used by eval)
* @param extrapositioninformation will gives us extra information that an ide may want
*/
public inputstreamlexersource string sourcename  inputstream in  list<string> list  int line
boolean extrapositioninformation
super sourcename  list  line  extrapositioninformation
this in   in
/**
* read next character from this source
*
* @return next character to viewed by the source
*/
public int read   throws ioexception
int c
if  buflength >  0
c   buf
else
c   wrappedread
if  c     1  return rubyyacclexer eof
twoago   oneago
oneago   c
offset
if  c       line
return c
/**
* pushes char back onto this source.  note, this also
* allows us to push whatever is passes back into the source.
*
* @param  to be put back onto the source
*/
public void unread int c
if  c    rubyyacclexer eof  return
offset
oneago   twoago
twoago   0
if  c       line
buf    char  c
// if we outgrow our pushback stack then grow it (this should only happen in pretty
// pathological cases).
if  buflength   1    buf length
char newbuf   new char
system arraycopy buf  0  newbuf  0  buf length
buf   newbuf
/**
* is the next character equal to 'to'
* @param to character to compare against
* @return true if the same
* @throws ioexception
*/
public boolean peek int to  throws ioexception
// keep value of twoago around so we can restore after we unread
int capturetwoago   twoago
int c   read
unread c
twoago   capturetwoago
return c    to
/**
* convenience method to hide exception.  if we do hit an exception
* we will pretend we eof'd.
*
* @return the current char or eof (at eof or on error)
*/
private int wrappedread   throws ioexception
int c   in read
// if \r\n then just pass along \n (windows).
// if \r[^\n] then pass along \n (mac).
if  c
if   c   in read
unread  char  c
c
else
// position within source must reflect the actual offset and column.  since
// we ate an extra character here (this accounting is normally done in read
// ), we should update position info.
offset
capturefeature c
return c
/**
* create a source.
*
* @param name the name of the source (e.g a filename: foo.rb)
* @param content the data of the source
* @return the new source
*/
public static lexersource getsource string name  inputstream content  list<string> list
parserconfiguration configuration
return new inputstreamlexersource name  content  list  configuration getlinenumber
configuration hasextrapositioninformation
@override
public bytelist readlinebytes   throws ioexception
bytelist bytelist   new bytelist 80
for  int c   read    c         c    rubyyacclexer eof  c   read
bytelist append c
return bytelist
@override
public int skipuntil int c  throws ioexception
for  c   read    c         c    rubyyacclexer eof  c   read
return c
public void unreadmany charsequence buffer
int length   buffer length
for  int i   length   1  i >  0  i
unread buffer charat i
@override
public boolean matchmarker bytelist match  boolean indent  boolean checknewline  throws ioexception
int length   match length
bytelist buffer   new bytelist length   1
if  indent
int c
while   c   read       rubyyacclexer eof
if   character iswhitespace c     c
unread c
break
buffer append c
int c
for  int i   0  i < length  i
c   read
buffer append c
if  match charat i     c
unreadmany buffer
return false
if   checknewline  return true
c   read
if  c    rubyyacclexer eof    c       return true
buffer append c
unreadmany buffer
return false
/**
* was the last character read from the stream the first character on a line
*
* @return true if so
*/
public boolean wasbeginofline
return twoago
public boolean lastwasbeginofline
return oneago
public string tostring
try
bytelist buffer   new bytelist 20
buffer append twoago
buffer append oneago
buffer append new byte
int i   0
for    i < 20  i
int c   read
if  c    0
i
break
buffer append c
for    i >  0  i
unread buffer charat i
buffer append new byte
return buffer tostring
catch exception e
return null
@override
public bytelist readuntil char marker  throws ioexception
bytelist list   new bytelist 20
int c
for  c   read    c    marker    c    rubyyacclexer eof  c   read
list append c
if  c    rubyyacclexer eof  return null
unread c
return list