/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007 ola bini <ola@ologix.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jvyamlb
import java util arraylist
import java util iterator
import java util list
import java util linkedlist
import java util hashmap
import java util map
import org jvyamlb nodes mappingnode
import org jvyamlb nodes node
import org jvyamlb nodes scalarnode
import org jvyamlb nodes sequencenode
import org jruby util bytelist
/**
* @author <a href="mailto:ola.bini@ki.se">ola bini</a>
*/
public class resolverimpl implements resolver
private final static map yamlpathresolvers   new hashmap
private final static resolverscanner scanner   new resolverscanner
private list resolverexactpaths   new linkedlist
private list resolverprefixpaths   new linkedlist
public static void addpathresolver final string tag  final list path  final class kind
final list newpath   new linkedlist
object nodecheck null
object indexcheck null
for final iterator iter   path iterator   iter hasnext
final object element   iter next
if element instanceof list
final list elist    list element
if elist size      2
nodecheck   elist get 0
indexcheck   elist get 1
else if elist size      1
nodecheck   elist get 0
indexcheck   boolean true
else
throw new resolverexception     element
else
nodecheck   null
indexcheck   element
if nodecheck instanceof string    nodecheck instanceof bytelist
nodecheck   scalarnode class
else if nodecheck instanceof list
nodecheck   sequencenode class
else if nodecheck instanceof map
nodecheck   mappingnode class
else if null    nodecheck     scalarnode class equals nodecheck      sequencenode class equals nodecheck      mappingnode class equals nodecheck
throw new resolverexception     nodecheck
if   indexcheck instanceof string    nodecheck instanceof bytelist    indexcheck instanceof integer     null    indexcheck
throw new resolverexception     indexcheck
newpath add new object nodecheck indexcheck
class newkind   null
if string class equals kind     bytelist class equals kind
newkind   scalarnode class
else if list class equals kind
newkind   sequencenode class
else if map class equals kind
newkind   mappingnode class
else if kind    null     scalarnode class equals kind      sequencenode class equals kind      mappingnode class equals kind
throw new resolverexception     kind
else
newkind   kind
final list x   new arraylist 1
x add newpath
final list y   new arraylist 2
y add x
y add kind
yamlpathresolvers put y tag
public void descendresolver final node currentnode  final object currentindex
final map exactpaths   new hashmap
final list prefixpaths   new linkedlist
if null    currentnode
final int depth   resolverprefixpaths size
for final iterator iter     list resolverprefixpaths get 0   iterator   iter hasnext
final object obj    object iter next
final list path    list obj
if checkresolverprefix depth path  class obj currentnode currentindex
if path size   > depth
prefixpaths add new object  path obj
else
final list respath   new arraylist 2
respath add path
respath add obj
exactpaths put obj yamlpathresolvers get respath
else
for final iterator iter   yamlpathresolvers keyset   iterator   iter hasnext
final list key    list iter next
final list path    list key get 0
final class kind    class key get 1
if null    path
exactpaths put kind yamlpathresolvers get key
else
prefixpaths add key
resolverexactpaths add 0 exactpaths
resolverprefixpaths add 0 prefixpaths
public void ascendresolver
resolverexactpaths remove 0
resolverprefixpaths remove 0
public boolean checkresolverprefix final int depth  final list path  final class kind  final node currentnode  final object currentindex
final object check    object path get depth 1
final object nodecheck   check
final object indexcheck   check
if nodecheck instanceof string
if  currentnode gettag   equals nodecheck
return false
else if null    nodecheck
if    class nodecheck  isinstance currentnode
return false
if indexcheck    boolean true    currentindex    null
return false
if indexcheck    boolean false    currentindex    null
return false
if indexcheck instanceof string
if   currentindex instanceof scalarnode    indexcheck equals   scalarnode currentindex  getvalue
return false
else if indexcheck instanceof bytelist
if   currentindex instanceof scalarnode    indexcheck equals   scalarnode currentindex  getvalue
return false
else if indexcheck instanceof integer
if  currentindex equals indexcheck
return false
return true
public string resolve final class kind  final bytelist value  final boolean implicit
list resolvers   null
if kind equals scalarnode class     implicit
string resolv   scanner recognize value
if resolv    null
return resolv
final map exactpaths    map resolverexactpaths get 0
if exactpaths containskey kind
return  string exactpaths get kind
if exactpaths containskey null
return  string exactpaths get null
if kind equals scalarnode class
return yaml default_scalar_tag
else if kind equals sequencenode class
return yaml default_sequence_tag
else if kind equals mappingnode class
return yaml default_mapping_tag
return null
private static bytelist s string se
return new bytelist se getbytes
public static void main string args
bytelist strings    s     s     s     s    s     s    s
s     s     s     s     s     s     s
s     s     s     s     s     s
s     s     s     s
boolean implicit   new boolean true true
resolver res   new resolverimpl
res descendresolver null null
class s   scalarnode class
final long before   system currenttimemillis
final int num   100000
for int j 0 j<num j
for int i 0 i<strings length i
res resolve s strings implicit
final long after   system currenttimemillis
final long time   after before
final double times    after before  1000 0
system out println     num strings length       time       times
resolverimpl