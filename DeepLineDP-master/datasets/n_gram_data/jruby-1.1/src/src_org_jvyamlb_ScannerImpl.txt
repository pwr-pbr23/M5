/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007 ola bini <ola@ologix.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jvyamlb
import java io fileinputstream
import java io ioexception
import java io inputstream
import java util arrays
import java util hashmap
import java util iterator
import java util linkedlist
import java util list
import java util map
import org jruby util bytelist
import org jvyamlb tokens aliastoken
import org jvyamlb tokens anchortoken
import org jvyamlb tokens directivetoken
import org jvyamlb tokens scalartoken
import org jvyamlb tokens tagtoken
import org jvyamlb tokens token
/**
* <p>a java implementation of the rbyaml scanner.</p>
*
* @author <a href="mailto:ola.bini@ki.se">ola bini</a>
*/
public class scannerimpl implements scanner
private final static byte empty   new byte
private final static byte nn   new byte
private final static bytelist bang   new bytelist new byte    false
private final static bytelist space   new bytelist new byte    false
private final static boolean all_false   new boolean
private final static boolean all_true   new boolean
private final static boolean linebr   new boolean
private final static boolean null_bl_linebr   new boolean
private final static boolean null_bl_t_linebr   new boolean
private final static boolean null_or_linebr   new boolean
private final static boolean full_linebr   new boolean
private final static boolean blank_or_linebr   new boolean
private final static boolean s4   new boolean
private final static boolean alpha   new boolean
private final static boolean digit   new boolean
private final static boolean hexa   new boolean
private final static boolean strange_char   new boolean
private final static int rn   new int
private final static boolean blank_t   new boolean
private final static boolean spaces_and_stuff   new boolean
private final static boolean double_esc   new boolean
private final static boolean non_alpha_or_num   new boolean
private final static boolean non_printable   new boolean
private final static boolean stupid_char   new boolean
private final static boolean r_flowzero   null_bl_t_linebr
private final static boolean r_flowzero1   new boolean
private final static boolean r_flownonzero   new boolean
private final static byte escape_replacements   new byte
private final static boolean is_escape_replacement   new boolean
private final static map escape_codes   new hashmap
private final static boolean chomping   new boolean
static
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
chomping   true
arrays fill all_true true
linebr   true
null_bl_linebr   true
null_bl_linebr   true
null_bl_linebr   true
null_bl_linebr   true
null_bl_t_linebr   true
null_bl_t_linebr   true
null_bl_t_linebr   true
null_bl_t_linebr   true
null_bl_t_linebr   true
null_or_linebr   true
null_or_linebr   true
null_or_linebr   true
full_linebr   true
full_linebr   true
blank_or_linebr   true
blank_or_linebr   true
blank_or_linebr   true
s4   true
s4   true
s4   true
s4   true
s4   true
s4   true
s4   true
s4   true
s4   true
for char c      c<    c
alpha   true
strange_char   true
}
for char c      c<    c
alpha   true
strange_char   true
}
for char c      c<    c
alpha   true
strange_char   true
hexa   true
digit   true
}
for char c      c<    c
hexa   true
}
for char c      c<    c
hexa   true
}
alpha   true
alpha   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
strange_char   true
blank_t   true
blank_t   true
spaces_and_stuff   true
spaces_and_stuff   true
spaces_and_stuff   true
spaces_and_stuff   true
spaces_and_stuff   true
spaces_and_stuff   true
spaces_and_stuff   true
spaces_and_stuff   true
double_esc   true
double_esc   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
non_alpha_or_num   true
arrays fill escape_replacements  byte 0
escape_replacements   0
escape_replacements   7
escape_replacements   8
escape_replacements   9
escape_replacements   9
escape_replacements   10
escape_replacements   11
escape_replacements   12
escape_replacements   13
escape_replacements   27
//        escape_replacements[' '] = 32;
escape_replacements[
escape_replacements    byte
escape_replacements    byte 133
escape_replacements    byte 160
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
//        is_escape_replacement[' '] = true;
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
is_escape_replacement   true
escape_codes put new character    new integer 2
escape_codes put new character    new integer 4
escape_codes put new character    new integer 8
arrays fill stupid_char true
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
stupid_char   false
r_flowzero1   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
r_flownonzero   true
}
private boolean done   false
private int flowlevel   0
private int tokenstaken   0
private int indent    1
private boolean allowsimplekey   true
private boolean eof   true
private int column   0
private int pointer   0
private bytelist buffer
private inputstream stream
private list tokens
private list indents
private map possiblesimplekeys
private boolean docstart   false
public scannerimpl final inputstream stream
this stream   stream
this eof   false
this buffer   new bytelist 100
this tokens   new linkedlist
this indents   new linkedlist
this possiblesimplekeys   new hashmap
fetchstreamstart
}
public scannerimpl final bytelist stream
this buffer   new bytelist stream bytes stream begin stream realsize
this stream   null
this tokens   new linkedlist
this indents   new linkedlist
this possiblesimplekeys   new hashmap
fetchstreamstart
}
public scannerimpl final string stream
try
this buffer   new bytelist bytelist plain stream  false
catch exception e
throw new runtimeexception e getmessage
}
this stream   null
this tokens   new linkedlist
this indents   new linkedlist
this possiblesimplekeys   new hashmap
fetchstreamstart
}
private void update final int length  final boolean reset
if  eof    reset
this buffer delete 0 this pointer
this pointer   0
}
while this buffer realsize <  this pointer length
byte rawdata   bytelist null_array
int converted    2
if  this eof
byte data   new byte
try
converted   this stream read data
catch final ioexception ioe
throw new yamlexception ioe
}
if converted     1
this eof   true
else
rawdata   data
}
}
if this eof
this buffer append
break;
else
checkprintable rawdata converted
this buffer append rawdata 0 converted
}
}
}
private void checkprintable final byte b  final int len
for int i 0 i<len i
if non_printable   0xff ]
final int position   this buffer length     this pointer   i
throw new yamlexception     position        char   int b   0xff
}
}
}
private boolean ensure final int len  final boolean reset
if this pointer   len >  this buffer realsize
update len  reset
}
return true
}
private char peek
ensure 1 false
return  char   char  buffer bytes    0xff
}
private char peek final int index
ensure index 1 false
return  char   char this buffer bytes   0xff
}
private void forward
ensure 2 true
final char ch1    char   int this buffer bytes   0xff
if ch1          ch1            int this buffer bytes   0xff
this possiblesimplekeys clear
this column   0
else
this column
}
}
private void forward final int length
ensure length 1 true
int ch   0
for int i 0 i<length i
ch   this buffer bytes   0xff
this pointer
if linebr     ch          this buffer bytes   0xff
this possiblesimplekeys clear
this column   0
else
this column
}
}
}
public boolean checktoken final class choices
while needmoretokens
fetchmoretokens
}
if  this tokens isempty
if choices length    0
return true
}
final object first   this tokens get 0
for int i 0 j choices length i<j i
if choices isinstance first
return true
}
}
}
return false
}
public token peektoken int index
while needmoretokens index 1
fetchmoretokens
}
return  token  this tokens size   <  index 1  ? null   this tokens get index
}
public token peektoken
return peektoken 0
}
public token gettoken
while needmoretokens
fetchmoretokens
}
if  this tokens isempty
this tokenstaken
return  token this tokens remove 0
}
return null
}
private class tokeniterator implements iterator
public boolean hasnext
return null    peektoken
}
public object next
return gettoken
}
public void remove
}
}
public iterator eachtoken
return new tokeniterator
}
public iterator iterator
return eachtoken
}
private boolean needmoretokens
return needmoretokens 1
}
private boolean needmoretokens int size
if this done
return false
}
return this tokens size   < size    nextpossiblesimplekey      this tokenstaken
}
private boolean isending
ensure 4 false
return  this buffer bytes   0xff
this buffer bytes   0xff
this buffer bytes   0xff
this buffer bytes    0
this buffer realsize<  this pointer 4
this buffer bytes
this buffer bytes    0
null_bl_t_linebr]
}
private boolean isstart
ensure 4 false
return  this buffer bytes   0xff
this buffer bytes   0xff
this buffer bytes   0xff
null_bl_t_linebr]
}
private boolean isendorstart
ensure 4 false
return    this buffer bytes   0xff
this buffer bytes   0xff
this buffer bytes   0xff
this buffer bytes   0xff
this buffer bytes   0xff
this buffer bytes   0xff
null_bl_t_linebr]
}
private token fetchmoretokens
scantonexttoken
unwindindent this column
final char ch    peek
final boolean colz   this column    0
switch ch
case    return fetchstreamend
case    return fetchsingle
case    return fetchdouble
case    if this flowlevel    0    null_bl_t_linebr    return fetchkey      break
case    if this flowlevel    0    null_bl_t_linebr    return fetchvalue      break
case    if colz   return fetchdirective      break
case
if  colz    docstart     isending
return fetchdocumentstart
else if null_bl_t_linebr
return fetchblockentry
}
break;
case
if colz    isstart
return fetchdocumentend
}
break;
case    return fetchflowsequencestart
case    return fetchflowmappingstart
case    return fetchflowsequenceend
case    return fetchflowmappingend
case    if this flowlevel    0
return fetchflowentry
}
break;
case    return fetchalias
case    return fetchanchor
case    return fetchtag
case    if this flowlevel    0    chomping    return fetchliteral      break
case    if this flowlevel    0    chomping    return fetchfolded      break
}
//todo: this is probably incorrect...
if stupid_char 0xff]
ensure 1 false      this buffer bytes
this buffer bytes
this buffer bytes
null_bl_t_linebr 0xff]
return fetchplain
}
throw new scannerexception       ch        int ch     null
}
private token fetchstreamstart
this docstart   true
this tokens add token stream_start
return token stream_start
}
private token fetchstreamend
unwindindent  1
this allowsimplekey   false
this possiblesimplekeys   new hashmap
this tokens add token stream_end
this done   true
this docstart   false
return token stream_end
}
private void scantonexttoken
for
char ch
while  ch peek            ch
forward
}
if ch
forward
while  null_or_linebr
forward
}
}
if scanlinebreak   length    0
if this flowlevel    0
this allowsimplekey   true
}
else
break;
}
}
}
private byte scanlinebreak
// transforms:
//   '\r\n'      :   '\n'
//   '\r'        :   '\n'
//   '\n'        :   '\n'
//   '\x85'      :   '\n'
//   default     :   ''
final int val   peek
if full_linebr
ensure 2 false
if rn    buffer bytes    rn    buffer bytes
forward 2
else
forward
}
return nn
else
return empty
}
}
private void unwindindent final int col
if this flowlevel    0
return
}
while this indent > col
this indent     integer  this indents remove 0    intvalue
this tokens add token block_end
}
}
private token fetchdocumentstart
this docstart   false
return fetchdocumentindicator token document_start
}
private token fetchdocumentindicator final token tok
unwindindent  1
removepossiblesimplekey
this allowsimplekey   false
forward 3
this tokens add tok
return tok
}
private token fetchblockentry
this docstart   false
if this flowlevel    0
if  this allowsimplekey
throw new scannerexception null   null
}
if addindent this column
this tokens add token block_sequence_start
}
}
this allowsimplekey   true
removepossiblesimplekey
forward
this tokens add token block_entry
return token block_entry
}
private boolean addindent final int col
if this indent < col
this indents add 0 new integer this indent
this indent   col
return true
}
return false
}
private token fetchtag
this docstart   false
savepossiblesimplekey
this allowsimplekey   false
final token tok   scantag
this tokens add tok
return tok
}
private void removepossiblesimplekey
simplekey key    simplekey this possiblesimplekeys remove new integer this flowlevel
if key    null
if key isrequired
throw new scannerexception     null
}
}
}
private void savepossiblesimplekey
if this allowsimplekey
this removepossiblesimplekey
this possiblesimplekeys put new integer this flowlevel  new simplekey this tokenstaken this tokens size    this flowlevel    0     this indent    this column  1  1 this column
}
}
private token scantag
char ch   peek 1
bytelist handle   null
bytelist suffix   null
if ch
forward 2
suffix   scantaguri
if peek
throw new scannerexception      peek          int peek       null
}
forward
else if null_bl_t_linebr
suffix   bang
forward
else
int length   1
boolean usehandle   false
while  null_bl_t_linebr
if ch
usehandle   true
break;
}
length
ch   peek length
}
handle   bang
if usehandle
handle   scantaghandle
else
handle   bang
forward
}
suffix   scantaguri
}
if  null_bl_linebr
throw new scannerexception       peek          int peek       null
}
return new tagtoken new bytelist  handle suffix
}
private bytelist scantaguri final string name
final bytelist chunks   new bytelist 10
int length   0
char ch   peek length
while strange_char
if      ch
ensure length false
chunks append this buffer bytes this pointer length
length   0
chunks append scanuriescapes name
else
length
}
ch   peek length
}
if length    0
ensure length false
chunks append this buffer bytes this pointer length
forward length
}
if chunks length      0
throw new scannerexception     name     ch        int ch     null
}
return chunks
}
private bytelist scantaghandle final string name
char ch    peek
if ch
throw new scannerexception     name     ch        int ch     null
}
int length   1
ch   peek length
if ch
while alpha
length
ch   peek length
}
if      ch
forward length
throw new scannerexception     name     ch         int ch      null
}
length
}
ensure length false
final bytelist value   new bytelist this buffer bytes this pointer length false
forward length
return value
}
private bytelist scanuriescapes final string name
final bytelist bytes   new bytelist
while peek
forward
try
ensure 2 false
bytes append integer parseint new string bytelist plain this buffer bytes this pointer 2   16
catch final numberformatexception nfe
throw new scannerexception     name     peek 1          int peek 1        peek 2          int peek 2       null
}
forward 2
}
return bytes
}
private token fetchplain
this docstart   false
savepossiblesimplekey
this allowsimplekey   false
final token tok   scanplain
this tokens add tok
return tok
}
private token scanplain
final bytelist chunks   new bytelist 7
final int ind   this indent 1
bytelist spaces   new bytelist 0
boolean f_nzero   true
boolean r_check   r_flownonzero
boolean r_check2   all_false
boolean r_check3   all_false
if this flowlevel    0
f_nzero   false
r_check   r_flowzero
r_check2   r_flowzero1
r_check3   r_flowzero
}
while peek
int length   0
int i   0
for   i
ensure i 2 false
if r_check 0xff]     r_check2 0xff]    r_check3 0xff]
length   i
final char ch   peek length
if   f_nzero    ch          s4
break;
}
}
}
if length    0
break;
}
this allowsimplekey   false
chunks append spaces
ensure length false
chunks append this buffer bytes this pointer length
forward length
spaces   scanplainspaces ind
if spaces    null     this flowlevel    0    this column < ind
break;
}
}
return new scalartoken chunks true
}
private int nextpossiblesimplekey
for final iterator iter   this possiblesimplekeys values   iterator   iter hasnext
final simplekey key    simplekey iter next
if key gettokennumber   > 0
return key gettokennumber
}
}
return  1
}
private bytelist scanplainspaces final int indent
final bytelist chunks   new bytelist
int length   0
while peek length
length
}
final byte whitespaces   new byte
arrays fill whitespaces  byte
forward length
char ch    peek
if full_linebr
final byte linebreak   scanlinebreak
this allowsimplekey   true
if isendorstart
return new bytelist 0
}
final bytelist breaks   new bytelist
while blank_or_linebr
if      peek
forward
else
breaks append scanlinebreak
if isendorstart
return new bytelist 0
}
}
}
if   linebreak length    1    linebreak
chunks append linebreak
else if breaks    null    breaks realsize    0
chunks append space
}
chunks append breaks
else
chunks append whitespaces
}
return chunks
}
private token fetchsingle
return fetchflowscalar
}
private token fetchdouble
return fetchflowscalar
}
private token fetchflowscalar final char style
this docstart   false
savepossiblesimplekey
this allowsimplekey   false
final token tok   scanflowscalar style
this tokens add tok
return tok
}
private token scanflowscalar final char style
final boolean dbl   style
final bytelist chunks   new bytelist
final char quote   peek
forward
chunks append scanflowscalarnonspaces dbl
while peek      quote
chunks append scanflowscalarspaces
chunks append scanflowscalarnonspaces dbl
}
forward
return new scalartoken chunks false style
}
private final static byte hexa_values   new byte
static
arrays fill hexa_values  byte  1
hexa_values   0
hexa_values   1
hexa_values   2
hexa_values   3
hexa_values   4
hexa_values   5
hexa_values   6
hexa_values   7
hexa_values   8
hexa_values   9
hexa_values   10
hexa_values   11
hexa_values   12
hexa_values   13
hexa_values   14
hexa_values   15
hexa_values   10
hexa_values   11
hexa_values   12
hexa_values   13
hexa_values   14
hexa_values   15
}
private bytelist parsehexa int length
ensure length false
bytelist chunks   new bytelist length 2
for int i 0 i<length i  2
byte val   hexa_values   0xff]
if val     1
throw new scannerexception       length        char  this buffer bytes   0xff  null
}
if i 1 < length
val    byte  val << 4
byte v2   hexa_values   0xff]
if v2     1
throw new scannerexception       length        char  this buffer bytes   0xff  null
}
val  v2
}
chunks append val
}
forward length
return chunks
}
private bytelist scanflowscalarnonspaces final boolean dbl
final bytelist chunks   new bytelist
for
int length   0
while  spaces_and_stuff
length
}
if length    0
ensure length false
chunks append this buffer bytes this pointer length
forward length
}
char ch   peek
if  dbl    ch         peek 1
chunks append
forward 2
else if  dbl    ch            dbl    double_esc
chunks append ch
forward
else if dbl    ch
forward
ch   peek
if is_escape_replacement
chunks append escape_replacements
forward
else if escape_codes containskey new character ch
length     integer escape_codes get new character ch    intvalue
forward
chunks append parsehexa length
else if full_linebr
scanlinebreak
bytelist ss   scanflowscalarbreaks
chunks append ss
else
chunks append
}
else
return chunks
}
}
}
private bytelist scanflowscalarspaces
final bytelist chunks   new bytelist
int length   0
while blank_t
length
}
ensure length false
bytelist whitespaces   new bytelist this buffer this pointer length
forward length
char ch   peek
if ch
throw new scannerexception     null
else if full_linebr
final byte linebreak   scanlinebreak
final bytelist breaks   scanflowscalarbreaks
if   linebreak length    1    linebreak
chunks append linebreak
else if breaks length      0
chunks append space
}
chunks append breaks
else
chunks append whitespaces
}
return chunks
}
private bytelist scanflowscalarbreaks
final bytelist chunks   new bytelist
boolean colz true
for
if colz    isendorstart
throw new scannerexception     null
}
while blank_t
forward
}
if full_linebr
chunks append scanlinebreak
colz   true
else if      peek      blank_t
forward
chunks append scanflowscalarspaces
colz   false
else
return chunks
}
}
}
private token fetchvalue
this docstart   false
final simplekey key    simplekey this possiblesimplekeys get new integer this flowlevel
if null    key
if this flowlevel    0     this allowsimplekey
throw new scannerexception null   null
}
this allowsimplekey   this flowlevel    0
removepossiblesimplekey
else
this possiblesimplekeys remove new integer this flowlevel
this tokens add key gettokennumber   this tokenstaken token key
if this flowlevel    0    addindent key getcolumn
this tokens add key gettokennumber   this tokenstaken token block_mapping_start
}
this allowsimplekey   false
}
forward
this tokens add token value
return token value
}
private token fetchflowsequencestart
return fetchflowcollectionstart token flow_sequence_start
}
private token fetchflowmappingstart
return fetchflowcollectionstart token flow_mapping_start
}
private token fetchflowcollectionstart final token tok
this docstart   false
savepossiblesimplekey
this flowlevel
this allowsimplekey   true
forward 1
this tokens add tok
return tok
}
private token fetchdocumentend
return fetchdocumentindicator token document_end
}
private token fetchflowsequenceend
return fetchflowcollectionend token flow_sequence_end
}
private token fetchflowmappingend
return fetchflowcollectionend token flow_mapping_end
}
private token fetchflowcollectionend final token tok
removepossiblesimplekey
this flowlevel
this allowsimplekey   false
forward 1
this tokens add tok
return tok
}
private token fetchflowentry
this allowsimplekey   true
removepossiblesimplekey
forward 1
this tokens add token flow_entry
return token flow_entry
}
private token fetchliteral
return fetchblockscalar
}
private token fetchfolded
return fetchblockscalar
}
private token fetchblockscalar final char style
this docstart   false
this allowsimplekey   true
this removepossiblesimplekey
final token tok   scanblockscalar style
this tokens add tok
return tok
}
private token scanblockscalar final char style
final boolean folded   style
final bytelist chunks   new bytelist
forward
final object chompi   scanblockscalarindicators
final boolean chomping    boolean chompi
final int increment     integer chompi  intvalue
boolean sameline   scanblockscalarignoredline
int minindent   this indent 1
if minindent < 0
minindent   0
}
bytelist breaks   null
int maxindent   0
int ind   0
if sameline
final boolean leadingnonspace    blank_t
int length   0
while  null_or_linebr
length
}
ensure length false
chunks append this buffer bytes this pointer length
forward length
}
if increment     1
final object brme   scanblockscalarindentation
breaks    bytelist brme
maxindent     integer brme  intvalue
if minindent > maxindent
ind   minindent
else
ind   maxindent
}
else
ind   minindent   increment   1
breaks   scanblockscalarbreaks ind
}
byte linebreak   bytelist null_array
while this column    ind    peek
chunks append breaks
final boolean leadingnonspace    blank_t
int length   0
while  null_or_linebr
length
}
ensure length false
chunks append this buffer bytes this pointer length
forward length
linebreak   scanlinebreak
breaks   scanblockscalarbreaks ind
if this column    ind    peek
if folded    linebreak length    1    linebreak         leadingnonspace     blank_t
if breaks length      0
chunks append space
}
else
chunks append linebreak
}
else
break;
}
}
if chomping    boolean false
chunks append linebreak
}
if chomping    boolean true
chunks append breaks
}
return new scalartoken chunks false style
}
private bytelist scanblockscalarbreaks final int indent
final bytelist chunks   new bytelist
while this column < indent    peek
forward
}
while full_linebr
chunks append scanlinebreak
while this column < indent    peek
forward
}
}
return chunks
}
private object scanblockscalarindentation
final bytelist chunks   new bytelist
int maxindent   0
while blank_or_linebr
if peek
chunks append scanlinebreak
else
forward
if this column > maxindent
maxindent   column
}
}
}
return new object  chunks new integer maxindent
}
private object scanblockscalarindicators
boolean chomping   null
int increment    1
char ch   peek
if ch         ch
chomping   ch      ? boolean true   boolean false
forward
ch   peek
if digit
increment   ch
if increment    0
throw new scannerexception     null
}
forward
}
else if digit
increment   ch
if increment    0
throw new scannerexception     null
}
forward
ch   peek
if ch         ch
chomping   ch      ? boolean true   boolean false
forward
}
}
if  null_bl_linebr
throw new scannerexception       peek           int peek        null
}
return new object  chomping new integer increment
}
private boolean scanblockscalarignoredline
boolean same   true
while peek
forward
}
if peek
while  null_or_linebr
forward
}
same   false
}
if null_or_linebr
scanlinebreak
return false
}
return same
}
private token fetchdirective
unwindindent  1
removepossiblesimplekey
this allowsimplekey   false
final token tok   scandirective
this tokens add tok
return tok
}
private token fetchkey
if this flowlevel    0
if  this allowsimplekey
throw new scannerexception null   null
}
if addindent this column
this tokens add token block_mapping_start
}
}
this allowsimplekey   this flowlevel    0
removepossiblesimplekey
forward
this tokens add token key
return token key
}
private token fetchalias
savepossiblesimplekey
this allowsimplekey   false
final token tok   scananchor new aliastoken
this tokens add tok
return tok
}
private token fetchanchor
savepossiblesimplekey
this allowsimplekey   false
final token tok   scananchor new anchortoken
this tokens add tok
return tok
}
private token scandirective
forward
final string name   scandirectivename
string value   null
if name equals
value   scanyamldirectivevalue
else if name equals
value   scantagdirectivevalue
else
while  null_or_linebr
forward
}
}
scandirectiveignoredline
return new directivetoken name value
}
private string scandirectivename
int length   0
char ch   peek length
boolean zlen   true
while alpha
zlen   false
length
ch   peek length
}
if zlen
throw new scannerexception       ch         int ch      null
}
string value   null
try
ensure length false
value   new string this buffer bytes this pointer length
catch exception e
}
forward length
if  null_bl_linebr
throw new scannerexception       ch         int ch      null
}
return value
}
private byte scandirectiveignoredline
while peek
forward
}
if peek
while  null_or_linebr
forward
}
}
final char ch   peek
if  null_or_linebr
throw new scannerexception       peek           int peek        null
}
return scanlinebreak
}
private token scananchor final token tok
final char indicator   peek
final string name   indicator      ?
forward
int length   0
while alpha
length
}
if length    0
throw new scannerexception     name   null
}
string value   null
try
ensure length false
value   new string this buffer bytes this pointer length
catch exception e
}
forward length
if  non_alpha_or_num
throw new scannerexception     name    peek           int peek        null
}
tok setvalue value
return tok
}
private string scanyamldirectivevalue
while peek
forward
}
final string major   scanyamldirectivenumber
if peek
throw new scannerexception       peek           int peek        null
}
forward
final string minor   scanyamldirectivenumber
if  null_bl_linebr
throw new scannerexception       peek           int peek        null
}
return new string  major minor
}
private string scanyamldirectivenumber
final char ch   peek
if  character isdigit ch
throw new scannerexception       ch         int ch      null
}
int length   0
stringbuffer sb   new stringbuffer
while character isdigit peek length
sb append peek length
length
}
forward length
return sb tostring
}
public static string into bytelist b
try
return new string b bytes 0 b realsize
catch exception e
return null     shouldn't happen
}
}
private string scantagdirectivevalue
while peek
forward
}
final string handle   into scantagdirectivehandle
while peek
forward
}
final string prefix   into scantagdirectiveprefix
return new string  handle prefix
}
private bytelist scantagdirectivehandle
final bytelist value   scantaghandle
if peek
throw new scannerexception       peek           int peek        null
}
return value
}
private bytelist scantagdirectiveprefix
final bytelist value   scantaguri
if  null_bl_linebr
throw new scannerexception       peek           int peek        null
}
return value
}
/*
private final static pattern non_printable = pattern.compile("[^\u0009\n\r\u0020-\u007e\u0085\u00a0-\u00ff]");
private final static pattern r_flowzero = pattern.compile("[\0 \t\r\n\u0085]|(:[\0 \t\r\n\u0085])");
private final static pattern r_flownonzero = pattern.compile("[\0 \t\r\n\u0085\\[\\]{},:?]");
private final static pattern line_br_reg = pattern.compile("[\n\u0085]|(?:\r[^\n])");
private final static pattern end_or_start = pattern.compile("^(---|\\.\\.\\.)[\0 \t\r\n\u0085]$");
private final static pattern ending = pattern.compile("^---[\0 \t\r\n\u0085]$");
private final static pattern start = pattern.compile("^\\.\\.\\.[\0 \t\r\n\u0085]$");
private final static pattern beg = pattern.compile("^([^\0 \t\r\n\u0085\\-?:,\\[\\]{}#&*!|>'\"%@]|([\\-?:][^\0 \t\r\n\u0085]))");
public static void main(final string[] args) throws exception {
//        final string test1 = "--- \na: b\nc: 3.14\n";
final string filename = args[0];
system.out.println("reading of file: \"" + filename + "\"");
final stringbuffer input = new stringbuffer();
final reader reader = new filereader(filename);
char[] buff = new char[1024];
int read = 0;
while(true) {
read = reader.read(buff);
input.append(buff,0,read);
if(read < 1024) {
break;
}
}
reader.close();
final string str = input.tostring();
final long before = system.currenttimemillis();
int tokens = 0;
for(int i=0;i<1;i++) {
final scanner sce2 = new scannerimpl(str);
for(final iterator iter = sce2.eachtoken();iter.hasnext();) {
tokens++;iter.next();
//                system.out.println(iter.next());
}
}
final long after = system.currenttimemillis();
final long time = after-before;
final double times = (after-before)/1000.0;
system.out.println("walking through the " + tokens + " tokens took " + time + "ms, or " + times + " seconds");
}
*/
public static void main(final string[] args) throws exception {
final string filename = args[0];
system.out.println("reading of file: \"" + filename + "\"");
final bytelist input   new bytelist 1024
final inputstream reader   new fileinputstream filename
byte buff   new byte
int read = 0;
while(true) {
read = reader.read(buff);
input.append(buff,0,read);
if(read < 1024) {
break;
}
}
reader.close();
final long before = system.currenttimemillis();
int tokens = 0;
for(int i=0;i<1;i++) {
final scanner sce2   new scannerimpl input
for(final iterator iter = sce2.eachtoken();iter.hasnext();) {
tokens     iter next
system out println iter next
}
}
final long after = system.currenttimemillis();
final long time = after-before;
final double times = (after-before)/1000.0;
system.out.println("walking through the " + tokens + " tokens took " + time + "ms, or " + times + " seconds");
}
public static void tmain final string args  throws exception
final string filename = args[0];
system.out.println("reading of file: \"" + filename + "\"");
final inputstream reader   new fileinputstream filename
final long before = system.currenttimemillis();
int tokens = 0;
for(int i=0;i<1;i++) {
final scanner sce2   new scannerimpl reader
for(final iterator iter = sce2.eachtoken();iter.hasnext();) {
tokens++;iter.next();
//system.out.println(iter.next());
}
}
reader.close();
final long after = system.currenttimemillis();
final long time = after-before;
final double times = (after-before)/1000.0;
system.out.println("walking through the " + tokens + " tokens took " + time + "ms, or " + times + " seconds");
}
scanner