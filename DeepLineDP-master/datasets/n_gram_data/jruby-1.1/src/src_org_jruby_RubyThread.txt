/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002 jason voegele <jason@jvoegele.com>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004-2005 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby
import java io ioexception
import java nio channels channel
import java nio channels selectablechannel
import java nio channels selectionkey
import java nio channels selector
import java util hashmap
import java util map
import java util set
import org jruby common irubywarnings id
import org jruby exceptions raiseexception
import org jruby exceptions threadkill
import org jruby internal runtime futurethread
import org jruby internal runtime nativethread
import org jruby internal runtime rubynativethread
import org jruby internal runtime rubyrunnable
import org jruby internal runtime threadlike
import org jruby internal runtime threadservice
import org jruby runtime block
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime builtin irubyobject
import java util concurrent executionexception
import java util concurrent timeoutexception
import java util concurrent locks reentrantlock
import org jruby anno jrubymethod
import org jruby runtime objectmarshal
import org jruby runtime visibility
/**
* implementation of ruby's <code>thread</code> class.  each ruby thread is
* mapped to an underlying java virtual machine thread.
* <p>
* thread encapsulates the behavior of a thread of execution, including the main
* thread of the ruby script.  in the descriptions that follow, the parameter
* <code>asymbol</code> refers to a symbol, which is either a quoted string or a
* <code>symbol</code> (such as <code>:name</code>).
*
* note: for cvs history, see threadclass.java.
*/
public class rubythread extends rubyobject
private threadlike threadimpl
private rubyfixnum priority
private final map<irubyobject  irubyobject> threadlocalvariables   new hashmap<irubyobject  irubyobject>
private boolean abortonexception
private irubyobject finalresult
private raiseexception exitingexception
private irubyobject receivedexception
private rubythreadgroup threadgroup
private final threadservice threadservice
private volatile boolean isstopped   false
public object stoplock   new object
private volatile boolean killed   false
public object killlock   new object
public final reentrantlock lock   new reentrantlock
private static final boolean debug   false
protected rubythread ruby runtime  rubyclass type
super runtime  type
this threadservice   runtime getthreadservice
// set to default thread group
rubythreadgroup defaultthreadgroup    rubythreadgroup runtime getthreadgroup   fastgetconstant
defaultthreadgroup add this  block null_block
finalresult   runtime getnil
/**
* dispose of the current thread by removing it from its parent threadgroup.
*/
public void dispose
threadgroup remove this
public static rubyclass createthreadclass ruby runtime
// fixme: in order for thread to play well with the standard 'new' behavior,
// it must provide an allocator that can create empty object instances which
// initialize then fills with appropriate data.
rubyclass threadclass   runtime defineclass    runtime getobject    objectallocator not_allocatable_allocator
runtime setthread threadclass
threadclass defineannotatedmethods rubythread class
rubythread rubythread   new rubythread runtime  threadclass
// todo: need to isolate the "current" thread from class creation
rubythread threadimpl   new nativethread rubythread  thread currentthread
runtime getthreadservice   setmainthread rubythread
threadclass setmarshal objectmarshal not_marshalable_marshal
return threadclass
/**
* <code>thread.new</code>
* <p>
* thread.new( <i>[ arg ]*</i> ) {| args | block } -> athread
* <p>
* creates a new thread to execute the instructions given in block, and
* begins running it. any arguments passed to thread.new are passed into the
* block.
* <pre>
* x = thread.new { sleep .1; print "x"; print "y"; print "z" }
* a = thread.new { print "a"; print "b"; sleep .2; print "c" }
* x.join # let the threads finish before
* a.join # main thread exits...
* </pre>
* <i>produces:</i> abxyzc
*/
@jrubymethod name           rest   true  frame   true  meta   true
public static irubyobject newinstance irubyobject recv  irubyobject args  block block
return startthread recv  args  true  block
/**
* basically the same as thread.new . however, if class thread is
* subclassed, then calling start in that subclass will not invoke the
* subclass's initialize method.
*/
@jrubymethod name      rest   true  frame   true  meta   true
public static rubythread start irubyobject recv  irubyobject args  block block
return startthread recv  args  false  block
public static rubythread adopt irubyobject recv  thread t
return adoptthread recv  t  block null_block
private static rubythread adoptthread final irubyobject recv  thread t  block block
final ruby runtime   recv getruntime
final rubythread rubythread   new rubythread runtime   rubyclass  recv
rubythread threadimpl   new nativethread rubythread  t
threadcontext context   runtime getthreadservice   registernewthread rubythread
context preadoptthread
return rubythread
@jrubymethod name      rest   true  frame   true  visibility   visibility private
public irubyobject initialize irubyobject args  block block
if   block isgiven    throw getruntime   newthreaderror
if  rubyinstanceconfig pooling_enabled
threadimpl   new futurethread this  new rubyrunnable this  args  block
else
threadimpl   new nativethread this  new rubynativethread this  args  block
threadimpl start
return this
private static rubythread startthread final irubyobject recv  final irubyobject args  boolean callinit  block block
rubythread rubythread   new rubythread recv getruntime     rubyclass  recv
if  callinit
rubythread callinit args  block
else
// for thread::start, which does not call the subclass's initialize
rubythread initialize args  block
return rubythread
private void ensurecurrent threadcontext context
if  this    context getthread
throw new runtimeexception
private void ensurenotcurrent
if  this    getruntime   getcurrentcontext   getthread
throw new runtimeexception
public synchronized void cleanterminate irubyobject result
finalresult   result
isstopped   true
public void pollthreadevents
pollthreadevents getruntime   getcurrentcontext
public void pollthreadevents threadcontext context
// check for criticalization *before* locking ourselves
threadservice waitforcritical
ensurecurrent context
if  debug  system out println     thread currentthread
if  killed  throw new threadkill
if  debug  system out println     thread currentthread
if  receivedexception    null
// clear this so we don't keep re-throwing
irubyobject raiseexception   receivedexception
receivedexception   null
rubymodule kernelmodule   getruntime   getkernel
if  debug  system out println     thread currentthread         killed
kernelmodule callmethod context     raiseexception
/**
* returns the status of the global ``abort on exception'' condition. the
* default is false. when set to true, will cause all threads to abort (the
* process will exit(0)) if an exception is raised in any thread. see also
* thread.abort_on_exception= .
*/
@jrubymethod name      meta   true
public static rubyboolean abort_on_exception_x irubyobject recv
ruby runtime   recv getruntime
return runtime isglobalabortonexceptionenabled   ? runtime gettrue     runtime getfalse
@jrubymethod name      required   1  meta   true
public static irubyobject abort_on_exception_set_x irubyobject recv  irubyobject value
recv getruntime   setglobalabortonexceptionenabled value istrue
return value
@jrubymethod name      meta   true
public static rubythread current irubyobject recv
return recv getruntime   getcurrentcontext   getthread
@jrubymethod name      meta   true
public static rubythread main irubyobject recv
return recv getruntime   getthreadservice   getmainthread
@jrubymethod name      meta   true
public static irubyobject pass irubyobject recv
ruby runtime   recv getruntime
threadservice ts   runtime getthreadservice
boolean critical   ts getcritical
ts setcritical false
thread yield
ts setcritical critical
return recv getruntime   getnil
@jrubymethod name      meta   true
public static rubyarray list irubyobject recv
rubythread activethreads   recv getruntime   getthreadservice   getactiverubythreads
return recv getruntime   newarraynocopy activethreads
private irubyobject getsymbolkey irubyobject originalkey
if  originalkey instanceof rubysymbol
return originalkey
else if  originalkey instanceof rubystring
return getruntime   newsymbol originalkey asjavastring
else if  originalkey instanceof rubyfixnum
getruntime   getwarnings   warn id fixnums_not_symbols
throw getruntime   newargumenterror originalkey
else
throw getruntime   newtypeerror originalkey
@jrubymethod name      required   1
public irubyobject op_aref irubyobject key
irubyobject value
if   value   threadlocalvariables get getsymbolkey key       null
return value
return getruntime   getnil
@jrubymethod name      required   2
public irubyobject op_aset irubyobject key  irubyobject value
key   getsymbolkey key
threadlocalvariables put key  value
return value
@jrubymethod name
public rubyboolean abort_on_exception
return abortonexception ? getruntime   gettrue     getruntime   getfalse
@jrubymethod name      required   1
public irubyobject abort_on_exception_set irubyobject val
abortonexception   val istrue
return val
@jrubymethod name
public rubyboolean alive_p
return threadimpl isalive   ? getruntime   gettrue     getruntime   getfalse
@jrubymethod name      optional   1
public irubyobject join irubyobject args
long timeoutmillis   long max_value
if  args length > 0
if  args length > 1
throw getruntime   newargumenterror args length 1
// mri behavior: value given in seconds; converted to float; less
// than or equal to zero returns immediately; returns nil
timeoutmillis    long  1000 0d   args converttofloat   getvalue
if  timeoutmillis <  0
// todo: not sure that we should skip caling join() altogether.
// thread.join() has some implications for java memory model, etc.
if  threadimpl isalive
return getruntime   getnil
else
return this
if  iscurrent
throw getruntime   newthreaderror
try
if  threadservice getcritical
// if the target thread is sleeping or stopped, wake it
synchronized  stoplock
stoplock notify
// interrupt the target thread in case it's blocking or waiting
// warning: we no longer interrupt the target thread, since this usually means
// interrupting io and with nio that means the channel is no longer usable.
// we either need a new way to handle waking a target thread that's waiting
// on io, or we need to accept that we can't wake such threads and must wait
// for them to complete their operation.
//threadimpl.interrupt();
rubythread currentthread   getruntime   getcurrentcontext   getthread
final long timetowait   math min timeoutmillis  200
// we need this loop in order to be able to "unblock" the
// join call without actually calling interrupt.
long start   system currenttimemillis
while true
currentthread pollthreadevents
threadimpl join timetowait
if   threadimpl isalive
break
if  system currenttimemillis     start > timeoutmillis
break
catch  interruptedexception ie
ie printstacktrace
assert false   ie
catch  executionexception ie
ie printstacktrace
assert false   ie
if  exitingexception    null
throw exitingexception
if  threadimpl isalive
return getruntime   getnil
else
return this
@jrubymethod name
public irubyobject value
join new irubyobject
synchronized  this
return finalresult
@jrubymethod name
public irubyobject group
if  threadgroup    null
return getruntime   getnil
return threadgroup
void setthreadgroup rubythreadgroup rubythreadgroup
threadgroup   rubythreadgroup
@jrubymethod name
public irubyobject inspect
// fixme: there's some code duplication here with rubyobject#inspect
stringbuffer part   new stringbuffer
string cname   getmetaclass   getrealclass   getname
part append    append cname  append
part append integer tohexstring system identityhashcode this
if  threadimpl isalive
if  isstopped
part append getruntime   newstring
else if  killed
part append getruntime   newstring
else
part append getruntime   newstring
else
part append
part append
return getruntime   newstring part tostring
@jrubymethod name      required   1
public rubyboolean key_p irubyobject key
key   getsymbolkey key
return getruntime   newboolean threadlocalvariables containskey key
@jrubymethod name
public rubyarray keys
irubyobject keys   new irubyobject
return rubyarray newarraynocopy getruntime     irubyobject threadlocalvariables keyset   toarray keys
@jrubymethod name      required   1  meta   true
public static irubyobject critical_set irubyobject receiver  irubyobject value
receiver getruntime   getthreadservice   setcritical value istrue
return value
@jrubymethod name      meta   true
public static irubyobject critical irubyobject receiver
return receiver getruntime   newboolean receiver getruntime   getthreadservice   getcritical
@jrubymethod name      meta   true
public static irubyobject stop irubyobject receiver
rubythread rubythread   receiver getruntime   getthreadservice   getcurrentcontext   getthread
object stoplock   rubythread stoplock
synchronized  stoplock
rubythread pollthreadevents
try
rubythread isstopped   true
// attempt to decriticalize all if we're the critical thread
receiver getruntime   getthreadservice   setcritical false
stoplock wait
catch  interruptedexception ie
rubythread pollthreadevents
rubythread isstopped   false
return receiver getruntime   getnil
@jrubymethod name      required   1  frame   true  meta   true
public static irubyobject kill irubyobject receiver  irubyobject rubythread  block block
if    rubythread instanceof rubythread   throw receiver getruntime   newtypeerror rubythread  receiver getruntime   getthread
return   rubythread rubythread  kill
@jrubymethod name      frame   true  meta   true
public static irubyobject s_exit irubyobject receiver  block block
rubythread rubythread   receiver getruntime   getthreadservice   getcurrentcontext   getthread
rubythread killed   true
// attempt to decriticalize all if we're the critical thread
receiver getruntime   getthreadservice   setcritical false
throw new threadkill
@jrubymethod name
public rubyboolean stop_p
// not valid for "dead" state
return getruntime   newboolean isstopped
@jrubymethod name
public rubythread wakeup
synchronized  stoplock
stoplock notifyall
return this
@jrubymethod name
public rubyfixnum priority
return priority
@jrubymethod name      required   1
public irubyobject priority_set irubyobject priority
// fixme: this should probably do some translation from ruby priority levels to java priority levels (until we have green threads)
int ipriority   rubynumeric fix2int priority
if  ipriority < thread min_priority
ipriority   thread min_priority
else if  ipriority > thread max_priority
ipriority   thread max_priority
this priority   rubyfixnum newfixnum getruntime    ipriority
if  threadimpl isalive
threadimpl setpriority ipriority
return this priority
@jrubymethod name      optional   2  frame   true
public irubyobject raise irubyobject args  block block
ensurenotcurrent
ruby runtime   getruntime
if  debug  system out println     thread currentthread
rubythread currentthread   getruntime   getcurrentcontext   getthread
try
while    currentthread lock trylock      this lock trylock
if  currentthread lock isheldbycurrentthread    currentthread lock unlock
currentthread pollthreadevents
if  debug  system out println     thread currentthread
receivedexception   prepareraiseexception runtime  args  block
// if the target thread is sleeping or stopped, wake it
synchronized  stoplock
stoplock notify
// interrupt the target thread in case it's blocking or waiting
// warning: we no longer interrupt the target thread, since this usually means
// interrupting io and with nio that means the channel is no longer usable.
// we either need a new way to handle waking a target thread that's waiting
// on io, or we need to accept that we can't wake such threads and must wait
// for them to complete their operation.
//threadimpl.interrupt();
// new interrupt, to hopefully wake it out of any blocking io
this interrupt
finally
if  currentthread lock isheldbycurrentthread    currentthread lock unlock
if  this lock isheldbycurrentthread    this lock unlock
return this
private irubyobject prepareraiseexception ruby runtime  irubyobject args  block block
if args length    0
irubyobject lastexception   runtime getglobalvariables   get
if lastexception isnil
return new raiseexception runtime  runtime fastgetclass        false  getexception
return lastexception
irubyobject exception
threadcontext context   getruntime   getcurrentcontext
if args length    1
if args instanceof rubystring
return runtime fastgetclass    newinstance context  args  block
if  args respondsto
return runtime newtypeerror    getexception
exception   args callmethod context
else
if   args respondsto
return runtime newtypeerror    getexception
exception   args callmethod context     args
if   runtime getexception   isinstance exception
return runtime newtypeerror    getexception
if  args length    3
rubyexception  exception  set_backtrace args
return exception
@jrubymethod name
public irubyobject run
// if stopped, unstop
synchronized  stoplock
if  isstopped
isstopped   false
stoplock notifyall
return this
public void sleep long millis  throws interruptedexception
ensurecurrent getruntime   getcurrentcontext
synchronized  stoplock
pollthreadevents
try
isstopped   true
stoplock wait millis
finally
isstopped   false
pollthreadevents
@jrubymethod name
public irubyobject status
if  threadimpl isalive
if  isstopped    currentselector    null    currentselector isopen
return getruntime   newstring
else if  killed
return getruntime   newstring
return getruntime   newstring
else if  exitingexception    null
return getruntime   getnil
else
return getruntime   newboolean false
@jrubymethod name
public irubyobject kill
// need to reexamine this
rubythread currentthread   getruntime   getcurrentcontext   getthread
try
if  debug  system out println     thread currentthread
while    currentthread lock trylock      this lock trylock
if  currentthread lock isheldbycurrentthread    currentthread lock unlock
currentthread pollthreadevents
if  debug  system out println     thread currentthread
killed   true
// if the target thread is sleeping or stopped, wake it
synchronized  stoplock
stoplock notify
// interrupt the target thread in case it's blocking or waiting
// warning: we no longer interrupt the target thread, since this usually means
// interrupting io and with nio that means the channel is no longer usable.
// we either need a new way to handle waking a target thread that's waiting
// on io, or we need to accept that we can't wake such threads and must wait
// for them to complete their operation.
//threadimpl.interrupt();
// new interrupt, to hopefully wake it out of any blocking io
this interrupt
finally
if  currentthread lock isheldbycurrentthread    currentthread lock unlock
if  this lock isheldbycurrentthread    this lock unlock
try
threadimpl join
catch  interruptedexception ie
// we were interrupted, check thread events again
currentthread pollthreadevents
catch  executionexception ie
// we were interrupted, check thread events again
currentthread pollthreadevents
return this
@jrubymethod name
public irubyobject kill_bang
throw getruntime   newnotimplementederror
@jrubymethod name
public irubyobject safe_level
throw getruntime   newnotimplementederror
private boolean iscurrent
return threadimpl iscurrent
public void exceptionraised raiseexception exception
assert iscurrent
rubyexception rubyexception   exception getexception
ruby runtime   rubyexception getruntime
if  runtime fastgetclass    isinstance rubyexception
threadservice getmainthread   raise new irubyobject  rubyexception   block null_block
else if  abortonexception runtime
// fixme: printerror explodes on some nullpointer
//getruntime().getruntime().printerror(exception.getexception());
rubyexception systemexit   rubysystemexit newinstance runtime  1
systemexit message   rubyexception message
threadservice getmainthread   raise new irubyobject  systemexit   block null_block
return
else if  runtime getdebug   istrue
runtime printerror exception getexception
exitingexception   exception
private boolean abortonexception ruby runtime
return  runtime isglobalabortonexceptionenabled      abortonexception
public static rubythread mainthread irubyobject receiver
return receiver getruntime   getthreadservice   getmainthread
private selector currentselector
public boolean selectforaccept rubyio io
channel channel   io getchannel
if  channel instanceof selectablechannel
selectablechannel selectable    selectablechannel channel
try
currentselector   selectable provider   openselector
selectionkey key   selectable register currentselector  selectionkey op_accept
int result   currentselector select
if  result    1
set<selectionkey> keyset   currentselector selectedkeys
if  keyset iterator   next      key
return true
return false
catch  ioexception ioe
throw io getruntime   newruntimeerror     ioe
finally
if  currentselector    null
try
currentselector close
catch  ioexception ioe
throw io getruntime   newruntimeerror
currentselector   null
else
// can't select, just have to do a blocking call
return true
public void interrupt
if  currentselector    null
currentselector wakeup
public void beforeblockingcall
isstopped   true
public void afterblockingcall
isstopped   false