/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004-2005 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2005 charles o nutter <headius@headius.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby runtime callback
import java lang reflect invocationtargetexception
import java lang reflect method
import java lang reflect modifier
import org jruby anno jrubymethod
import org jruby exceptions jumpexception
import org jruby exceptions raiseexception
import org jruby exceptions mainexitexception
import org jruby exceptions threadkill
import org jruby runtime arity
import org jruby runtime block
import org jruby runtime builtin irubyobject
/**
* a wrapper for <code>java.lang.reflect.method</code> objects which implement ruby methods.
*/
public class reflectioncallback implements callback
private method method
private class type
private string methodname
private class argumenttypes
private boolean isrestargs
private arity arity
private boolean isstaticmethod
private boolean fast
public reflectioncallback class type  string methodname  class argumenttypes
boolean isrestargs  boolean isstaticmethod  arity arity  boolean fast
this type   type
this methodname   methodname
this argumenttypes   argumenttypes
this isrestargs   isrestargs
this isstaticmethod   isstaticmethod
this arity   arity
this fast   fast
assert type    null
assert methodname    null
assert arity    null
loadmethod fast
}
private void loadmethod boolean fast
class args
if  isstaticmethod
class types   new class
system arraycopy argumenttypes  0  types  1  argumenttypes length
types   irubyobject class
args   types
else
args   argumenttypes
}
// enebo: perhaps slow but simple for now
if   fast
class types   new class
system arraycopy args  0  types  0  args length
types   block class
args   types
}
try
method   type getmethod methodname  args
catch  nosuchmethodexception e
throw new runtimeexception  "   methodname
in class      type getname       by reflection "
catch  securityexception e
throw new runtimeexception  "   methodname
in class      type getname       by reflection "
}
}
/**
* returns an object array that collects all rest arguments in its own object array which
* is then put into the last slot of the first object array.  that is, assuming that this
* callback expects one required argument and any number of rest arguments, an input of
* <code>[1, 2, 3]</code> is transformed into <code>[1, [2, 3]]</code>.
*/
protected final object packagerestargumentsforreflection final object originalargs
irubyobject restarray   new irubyobject
object result   new object
try
system arraycopy originalargs  argumenttypes length   1  restarray  0  originalargs length    argumenttypes length   1
catch  arrayindexoutofboundsexception e
assert false   e
return null
}
system arraycopy originalargs  0  result  0  argumenttypes length   1
result   restarray
return result
}
/**
* invokes the ruby method. actually, this methods delegates to an internal version
* that may throw the usual java reflection exceptions.  ruby exceptions are rethrown,
* other exceptions throw an asserterror and abort the execution of the ruby program.
* they should never happen.
*/
/**
* calls a wrapped ruby method for the specified receiver with the specified arguments.
*/
public irubyobject execute irubyobject recv  irubyobject oargs  block block
arity checkarity recv getruntime    oargs
object methodargs   oargs
if  isrestargs
methodargs   packagerestargumentsforreflection methodargs
}
try
irubyobject receiver   recv
if  isstaticmethod
object args   new object
system arraycopy methodargs  0  args  1  methodargs length
args   recv
if   fast  args   block
receiver   null
methodargs   args
else
object args   new object
system arraycopy methodargs  0  args  0  methodargs length
if   fast  args   block
methodargs   args
}
return  irubyobject  method invoke receiver  methodargs
catch  invocationtargetexception e
if  e gettargetexception   instanceof raiseexception
throw  raiseexception  e gettargetexception
else if  e gettargetexception   instanceof jumpexception
throw  jumpexception  e gettargetexception
else if  e gettargetexception   instanceof threadkill
// allow it to bubble up
throw  threadkill  e gettargetexception
else if  e gettargetexception   instanceof exception
if e gettargetexception   instanceof mainexitexception
throw  runtimeexception e gettargetexception
}
recv getruntime   getjavasupport   handlenativeexception e gettargetexception
return recv getruntime   getnil
else
throw  error  e gettargetexception
}
catch  illegalaccessexception e
stringbuffer message   new stringbuffer
message.append(e.getmessage());
message.append(':');
message.append(" methodname=").append(methodname);
message.append(" recv=").append(recv.tostring());
message.append(" type=").append(type.getname());
message.append(" methodargs=[");
for (int i = 0; i < methodargs.length; i++) {
message.append(methodargs[i]);
message.append(' ');
}
message append
assert false   message tostring
return null
catch  final illegalargumentexception e
/*            stringbuffer message = new stringbuffer();
message.append(e.getmessage());
message.append(':');
message.append(" methodname=").append(methodname);
message.append(" recv=").append(recv.tostring());
message.append(" type=").append(type.getname());
message.append(" methodargs=[");
for (int i = 0; i < methodargs.length; i++) {
message.append(methodargs[i]);
message.append(' ');
}
message.append(']');*/
assert false   e
return null
}
}
/**
* returns the arity of the wrapped ruby method.
*/
public arity getarity
return arity
}
}