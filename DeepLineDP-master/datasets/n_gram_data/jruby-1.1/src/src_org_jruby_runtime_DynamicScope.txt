package org jruby runtime
import org jruby runtime scope manyvarsdynamicscope
import org jruby runtime scope novarsdynamicscope
import org jruby runtime scope onevardynamicscope
import org jruby parser blockstaticscope
import org jruby parser staticscope
import org jruby runtime builtin irubyobject
public abstract class dynamicscope
// static scoping information for this scope
protected staticscope staticscope
// captured dyanmic scopes
protected dynamicscope parent
// a place to store that special hiding space that bindings need to implement things like:
// eval("a = 1", binding); eval("p a").  all binding instances must get access to this
// hidden shared scope.  we store it here.  this will be null if no binding has yet
// been called.
protected dynamicscope evalscope
protected dynamicscope staticscope staticscope  dynamicscope parent
this staticscope
this parent   parent
protected dynamicscope staticscope staticscope
this staticscope   staticscope
public static dynamicscope newdynamicscope staticscope staticscope  dynamicscope parent
// dynamic scopes with local static scopes must always
// be manyvarsdynamicscopes, since local scopes might grow
// (e.g., when evaling the flip). see jruby-2046.
if  staticscope getlocalscope      staticscope
return new manyvarsdynamicscope staticscope  parent
switch  staticscope getnumberofvariables
case 0
return new novarsdynamicscope staticscope  parent
case 1
return new onevardynamicscope staticscope  parent
default
return new manyvarsdynamicscope staticscope  parent
/**
* returns the n-th parent scope of this scope.
* may return <code>null</code>.
* @param n - number of levels above to look.
* @return the n-th parent scope or <code>null</code>.
*/
public dynamicscope getnthparentscope int n
dynamicscope scope   this
for  int i   0  i < n  i
if  scope    null
scope   scope getnextcapturedscope
else
break
return scope
public static dynamicscope newdynamicscope staticscope staticscope
return newdynamicscope staticscope  null
public final dynamicscope getevalscope
// we create one extra dynamicscope on a binding so that when we 'eval "b=1", binding' the
// 'b' will get put into this new dynamic scope.  the original scope does not see the new
// 'b' and successive evals with this binding will.  i take it having the ability to have
// succesive binding evals be able to share same scope makes sense from a programmers
// perspective.   one crappy outcome of this design is it requires dynamic and static
// scopes to be mutable for this one case.
// note: in ruby 1.9 all of this logic can go away since they will require explicit
// bindings for evals.
// we only define one special dynamic scope per 'logical' binding.  so all bindings for
// the same scope should share the same dynamic scope.  this allows multiple evals with
// different different bindings in the same scope to see the same stuff.
// no binding scope so we should create one
if  evalscope    null
// if the next scope out has the same binding scope as this scope it means
// we are evaling within an eval and in that case we should be sharing the same
// binding scope.
dynamicscope parent   getnextcapturedscope
if  parent    null    parent getevalscope      this
evalscope   this
else
// bindings scopes must always be manyvars scopes since evals can grow them
evalscope   new manyvarsdynamicscope new blockstaticscope getstaticscope     this
return evalscope
/**
* get next 'captured' scope.
*
* @return the scope captured by this scope for implementing closures
*
*/
public final dynamicscope getnextcapturedscope
return parent
/**
* get the static scope associated with this dynamicscope.
*
* @return static complement to this scope
*/
public final staticscope getstaticscope
return staticscope
/**
* get all variable names captured (visible) by this scope (sans $~ and $_).
*
* @return a list of variable names
*/
public final string getallnamesinscope
return staticscope getallnamesinscope
public string tostring
return tostring new stringbuffer
public abstract void growifneeded
// helper function to give a good view of current dynamic scope with captured scopes
public abstract string tostring stringbuffer buf  string indent
public abstract dynamicscope clonescope
public abstract irubyobject getvalues
/**
* get value from current scope or one of its captured scopes.
*
* fixme: block variables are not getting primed to nil so we need to null check those
*  until we prime them properly.  also add assert back in.
*
* @param offset zero-indexed value that represents where variable lives
* @param depth how many captured scopes down this variable should be set
* @return the value here
*/
public abstract irubyobject getvalue int offset  int depth
/**
* variation of getvalue that checks for nulls, returning and setting the given value (presumably nil)
*/
public abstract irubyobject getvalueornil int offset  int depth  irubyobject nil
/**
* getvalueornil for depth 0
*/
public abstract irubyobject getvaluedepthzeroornil int offset  irubyobject nil
/**
* getvalueornil for index 0, depth 0
*/
public abstract irubyobject getvaluezerodepthzeroornil irubyobject nil
/**
* getvalueornil for index 1, depth 0
*/
public abstract irubyobject getvalueonedepthzeroornil irubyobject nil
/**
* set value in current dynamic scope or one of its captured scopes.
*
* @param offset zero-indexed value that represents where variable lives
* @param value to set
* @param depth how many captured scopes down this variable should be set
*/
public abstract void setvalue int offset  irubyobject value  int depth
/**
* setvalue for depth zero
*
* @param offset zero-indexed value that represents where variable lives
* @param value to set
* @param depth how many captured scopes down this variable should be set
*/
public abstract void setvaluedepthzero irubyobject value  int offset
/**
* set value in current dynamic scope or one of its captured scopes.
*
* @param offset zero-indexed value that represents where variable lives
* @param value to set
* @param depth how many captured scopes down this variable should be set
*/
public abstract void setvaluezerodepthzero irubyobject value
/**
* set value in current dynamic scope or one of its captured scopes.
*
* @param offset zero-indexed value that represents where variable lives
* @param value to set
* @param depth how many captured scopes down this variable should be set
*/
public abstract void setvalueonedepthzero irubyobject value
/**
* set all values which represent 'normal' parameters in a call list to this dynamic
* scope.  function calls bind to local scopes by assuming that the indexes or the
* arg list correspond to that of the local scope (plus 2 since $_ and $~ always take
* the first two slots).  we pass in a second argument because we sometimes get more
* values than we are expecting.  the rest get compacted by original caller into
* rest args.
*
* @param values up to size specified to be mapped as ordinary parm values
* @param size is the number of values to assign as ordinary parm values
*/
public abstract void setargvalues irubyobject values  int size
/**
* copy variable values back for zsuper call.
*/
public abstract irubyobject getargvalues