/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2004 jan arne petersen <jpetersen@uni-bonn.de>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby lexer yacc
import org jruby ast regexpnode
import org jruby ast strnode
import org jruby lexer yacc syntaxexception pid
import org jruby parser reoptions
import org jruby parser tokens
import org jruby util bytelist
public class stringterm extends strterm
// expand variables, indentation of final marker
private int flags
// start of string ([, (, {, <, ', ", \n)
private final char begin
// end of string (], ), }, >, ', ", \0)
private final char end
// how many strings are nested in the current string term
private int nest
public stringterm int flags  int begin  int end
this flags   flags
this begin    char  begin
this end      char  end
this nest    0
}
public int parsestring rubyyacclexer lexer  lexersource src  throws java io ioexception
boolean spaceseen   false
int c
// fixme: how much more obtuse can this be?
// heredoc already parsed this and saved string...do not parse..just return
if  flags     1
lexer setvalue new token  "  lexer getposition
return tokens tstring_end
}
c   src read
if   flags   rubyyacclexer str_func_qwords     0    character iswhitespace c
do
c   src read
while  character iswhitespace c
spaceseen   true
}
if  c    end    nest    0
if   flags   rubyyacclexer str_func_qwords     0
flags    1
lexer getposition
return
}
if   flags   rubyyacclexer str_func_regexp     0
lexer setvalue new regexpnode src getposition    bytelist create     parseregexpflags src
return tokens tregexp_end
}
lexer setvalue new token  "  lexer getposition
return tokens tstring_end
}
if  spaceseen
src.unread(c);
lexer getposition
return
}
// single-quote fast path
if  begin         flags    0
bytelist buffer   new bytelist
src.unread(c);
if  parsesimplestringintobuffer src  buffer     rubyyacclexer eof
throw new syntaxexception pid string_hits_eof  src getposition
}
/*
bytelist buffer;
src.unread(c);
if ((buffer = src.readuntil(end)) == null) {
throw new syntaxexception(src.getposition(), "unterminated string meets end of file");
}
*/
lexer setvalue new strnode lexer getposition    buffer
return tokens tstring_content
}
bytelist buffer   new bytelist
if   flags   rubyyacclexer str_func_expand     0    c
c   src read
switch  c
case
case
src.unread(c);
lexer setvalue new token     c  lexer getposition
return tokens tstring_dvar
case
lexer setvalue new token     c  lexer getposition
return tokens tstring_dbeg
}
buffer append  byte
}
src.unread(c);
if  parsestringintobuffer lexer  src  buffer     rubyyacclexer eof
throw new syntaxexception pid string_hits_eof  src getposition
}
lexer setvalue new strnode lexer getposition    buffer
return tokens tstring_content
}
private int parseregexpflags final lexersource src  throws java io ioexception
char kcode   0
int options   0
int c
stringbuilder unknownflags   new stringbuilder 10
for  c   src read    c    rubyyacclexer eof
character isletter c   c   src read
switch  c
case
options    reoptions re_option_ignorecase
break
case
options    reoptions re_option_extended
break
case
options    reoptions re_option_multiline
break
case
options    reoptions re_option_once
break
case
kcode   16
break
case
kcode   32
break
case
kcode   48
break
case
kcode   64
break
case
options    256     regexp engine
break
default
unknownflags append  char  c
break
}
}
src.unread(c);
if  unknownflags length      0
throw new syntaxexception pid regexp_unknown_option  src getposition
unknownflags length   > 1 ?
unknownflags tostring    unknownflags tostring
}
return options   kcode
}
public int parsesimplestringintobuffer lexersource src  bytelist buffer  throws java io ioexception
int c
while   c   src read       rubyyacclexer eof
if  c    end
src.unread(c);
break
else if  c
c   src read
if   c         c    end     c       buffer append
}
buffer append c
}
return c
}
public int parsestringintobuffer rubyyacclexer lexer  lexersource src  bytelist buffer  throws java io ioexception
boolean qwords    flags   rubyyacclexer str_func_qwords     0
boolean expand    flags   rubyyacclexer str_func_expand     0
boolean escape    flags   rubyyacclexer str_func_escape     0
boolean regexp    flags   rubyyacclexer str_func_regexp     0
int c
while   c   src read       rubyyacclexer eof
if  begin         c    begin
nest
else if  c    end
if  nest    0
src.unread(c);
break
}
nest
else if  c         expand     src peek
int c2   src read
if  c2         c2         c2
src unread c2
src.unread(c);
break
}
src unread c2
else if  c
c   src read
switch  c
case
if  qwords  break
if  expand  continue
buffer append
break
case
if  escape  buffer append c
break
default
if  regexp
src.unread(c);
parseescapeintobuffer src  buffer
continue
else if  expand
src.unread(c);
if  escape  buffer append
c   lexer readescape
else if  qwords    character iswhitespace c
/* ignore backslashed spaces in %w */
else if  c    end      begin         c    begin
buffer append
}
}
else if  qwords    character iswhitespace c
src.unread(c);
break
}
buffer append c
}
return c
}
// was a goto in original ruby lexer
private void escaped lexersource src  bytelist buffer  throws java io ioexception
int c
switch  c   src read
case
parseescapeintobuffer src  buffer
break
case rubyyacclexer eof
throw new syntaxexception pid invalid_escape_syntax  src getposition
default
buffer append c
}
}
private void parseescapeintobuffer lexersource src  bytelist buffer  throws java io ioexception
int c
switch  c   src read
case
break     just ignore
case
case
case
case       octal constant
case
case
case
case
buffer append
buffer append c
for  int i   0  i < 2  i
c   src read
if  c    rubyyacclexer eof
throw new syntaxexception pid invalid_escape_syntax  src getposition
}
if   rubyyacclexer isoctchar c
src.unread(c);
break
}
buffer append c
}
break
case       hex constant
buffer append
buffer append c
c   src read
if   rubyyacclexer ishexchar c
throw new syntaxexception pid invalid_escape_syntax  src getposition
}
buffer append c
c   src read
if  rubyyacclexer ishexchar c
buffer append c
else
src.unread(c);
}
break
case
if   c   src read
throw new syntaxexception pid invalid_escape_syntax  src getposition
}
buffer append new byte
escaped src  buffer
break
case
if   c   src read
throw new syntaxexception pid invalid_escape_syntax  src getposition
}
buffer append new byte
escaped src  buffer
break
case
buffer append new byte
escaped src  buffer
break
case rubyyacclexer eof
throw new syntaxexception pid invalid_escape_syntax  src getposition
default
if  c         c    end
buffer append
}
buffer append c
}
}
}