/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2004-2006 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2005 zach dennis <zdennis@mktec.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby lexer yacc
import java io ioexception
import java io inputstream
import java util list
import org jruby parser parserconfiguration
import org jruby util bytelist
/**
* this class is what feeds the lexer.  it is primarily a wrapper around a
* reader that can unread() data back onto the source.  originally, i thought
* about using the pushbackreader to handle read/unread, but i realized that
* some extremely pathological case could overflow the pushback buffer.  better
* safe than sorry.  i could have combined this implementation with a
* pushbackbuffer, but the added complexity did not seem worth it.
*
*/
public abstract class lexersource
// where we get new positions from.
private isourcepositionfactory positionfactory
// the name of this source (e.g. a filename: foo.rb)
private final string sourcename
// number of newlines read from the reader
protected int line   0
// how many bytes into the source are we?
protected int offset   0
// store each line into this list if not null.
private list<string> list
// for 'list' and only populated if list is not null.
private stringbuilder linebuffer
/**
* create our food-source for the lexer
*
* @param sourcename is the file we are reading
* @param reader is what represents the contents of file sourcename
* @param line starting line number for source (used by eval)
* @param extrapositioninformation will gives us extra information that an ide may want
*/
protected lexersource string sourcename  list<string> list  int line  boolean extrapositioninformation
this sourcename   sourcename
this line   line
if  extrapositioninformation
positionfactory   new idesourcepositionfactory this  line
else
positionfactory   new simplepositionfactory this  line
this list   list
linebuffer   new stringbuilder
/**
* what file are we lexing?
* @return the files name
*/
public string getfilename
return sourcename
/**
* what line are we at?
* @return the line number 0...line_size-1
*/
public int getline
return line
/**
* the location of the last byte we read from the source.
*
* @return current location of source
*/
public int getoffset
return  offset <  0 ? 0   offset
/**
* where is the reader within the source {filename,row}
*
* @return the current position
*/
public isourceposition getposition isourceposition startposition  boolean inclusive
return positionfactory getposition startposition  inclusive
/**
* where is the reader within the source {filename,row}
*
* @return the current position
*/
public isourceposition getposition
return positionfactory getposition null  false
public isourcepositionfactory getpositionfactory
return positionfactory
/**
* create a source.
*
* @param name the name of the source (e.g a filename: foo.rb)
* @param content the data of the source
* @return the new source
*/
public static lexersource getsource string name  inputstream content  list<string> list
parserconfiguration configuration
return new inputstreamlexersource name  content  list  configuration getlinenumber
configuration hasextrapositioninformation
protected void capturefeature int c
// ruby's omg capture all source in a hash feature
if  list    null
// only append real characters (eof does not count).
if  c     1  linebuffer append  char  c
if  c         c     1
list add linebuffer tostring
linebuffer setlength 0
/**
* match marker against input consumering lexer source as it goes...unless it does not match
* then it reverts lexer source back to point when this method was invoked.
*
* @param marker to match against
* @param indent eat any leading whitespace
* @param withnewline includes a check that marker is followed by newline or eof
* @return true if marker matches...false otherwise
* @throws ioexception if an error occurred reading from underlying io source
*/
public abstract boolean matchmarker bytelist marker  boolean indent  boolean withnewline  throws ioexception
public abstract int read   throws ioexception
public abstract bytelist readuntil char c  throws ioexception
public abstract bytelist readlinebytes   throws ioexception
public abstract int skipuntil int c  throws ioexception
public abstract void unread int c
public abstract void unreadmany charsequence line
public abstract boolean peek int c  throws ioexception
public abstract boolean lastwasbeginofline
public abstract boolean wasbeginofline