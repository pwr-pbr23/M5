/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2001 chad fowler <chadfowler@chadfowler.com>
* copyright (c) 2001 alan moore <alan_moore@gmx.net>
* copyright (c) 2001-2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2001-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2004-2006 thomas e enebo <enebo@acm.org>
* copyright (c) 2004-2005 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 ola bini <ola.bini@ki.se>
* copyright (c) 2006 miguel covarrubias <mlcovarrubias@gmail.com>
* copyright (c) 2007 mentalguy <mental@rydia.net>
* copyright (c) 2007 william n dortch <bill.dortch@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby
import java io ioexception
import java io objectinputstream
import java io objectoutputstream
import java io serializable
import java util concurrent atomic atomicboolean
import org jruby common irubywarnings id
import org jruby evaluator astinterpreter
import org jruby exceptions jumpexception
import org jruby internal runtime methods dynamicmethod
import org jruby runtime arity
import org jruby runtime block
import org jruby runtime calltype
import org jruby runtime callbackfactory
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
import org jruby runtime builtin variable
import org jruby runtime callback callback
import org jruby runtime component variableentry
import org jruby util idutil
import java util arraylist
import java util hashmap
import java util list
import java util map
import org jruby anno jrubymethod
import org jruby javasupport util runtimehelpers
import org jruby runtime classindex
import org jruby runtime methodindex
import org jruby runtime builtin instancevariables
import org jruby runtime builtin internalvariables
import org jruby runtime marshal coreobjecttype
import org jruby util typeconverter
/**
*
* @author  jpetersen
*/
public class rubyobject implements cloneable  irubyobject  serializable  coreobjecttype  instancevariables  internalvariables
private rubyobject
// an instance that never equals any other instance
public static final irubyobject never   new rubyobject
// the class of this object
protected transient rubyclass metaclass
protected string metaclassname
/**
* the variabletable contains variables for an object, defined as:
* <ul>
* <li> instance variables
* <li> class variables (for classes/modules)
* <li> internal variables (such as those used when marshaling rubyrange and rubyexception)
* </ul>
*
* constants are stored separately, see {@link rubymodule}.
*
*/
protected transient volatile variabletableentry variabletable
protected transient int variabletablesize
protected transient int variabletablethreshold
private transient object datastruct
protected int flags     zeroed by jvm
public static final int all_f    1
public static final int false_f   1 << 0
public static final int nil_f   1 << 1
public static final int frozen_f   1 << 2
public static final int tainted_f   1 << 3
public static final int fl_ushift   4
public static final int user0_f    1<< fl_ushift 0
public static final int user1_f    1<< fl_ushift 1
public static final int user2_f    1<< fl_ushift 2
public static final int user3_f    1<< fl_ushift 3
public static final int user4_f    1<< fl_ushift 4
public static final int user5_f    1<< fl_ushift 5
public static final int user6_f    1<< fl_ushift 6
public static final int user7_f    1<< fl_ushift 7
public final void setflag int flag  boolean set
if  set
flags    flag
} else {
flags    ~flag
}
}
public final boolean getflag int flag
return  flags   flag     0
}
private transient finalizer finalizer
public class finalizer implements finalizable
private long id
private list<irubyobject> finalizers
private atomicboolean finalized
public finalizer long id
this id   id
this finalized   new atomicboolean false
}
public void addfinalizer irubyobject finalizer
if  finalizers    null
finalizers   new arraylist<irubyobject>
}
finalizers add finalizer
}
public void removefinalizers
finalizers   null
}
public void finalize
if  finalized compareandset false  true
if  finalizers    null
for  int i   0  i < finalizers size    i
irubyobject finalizer   finalizers get i
runtimehelpers invoke
finalizer getruntime   getcurrentcontext
finalizer     rubyobject this id
}
}
}
}
}
/** standard path for object creation
*
*/
public rubyobject ruby runtime  rubyclass metaclass
this runtime  metaclass  runtime isobjectspaceenabled
}
/** path for objects who want to decide whether they want to be in objectspace
*  regardless of it being turned on or off
*  (notably used by objects being considered immediate, they'll always pass false here)
*/
protected rubyobject ruby runtime  rubyclass metaclass  boolean useobjectspace
this metaclass   metaclass
if  ruby runtime_threadlocal    metaclass    null
metaclassname   metaclass classid
}
if  useobjectspace
assert runtime isobjectspaceenabled
runtime getobjectspace   add this
}
// fixme are there objects who shouldn't be tainted?
// (mri: objsetup)
if  runtime getsafelevel   >  3  flags    tainted_f
}
public static rubyclass createobjectclass ruby runtime  rubyclass objectclass
objectclass index   classindex object
callbackfactory callbackfactory   runtime callbackfactory rubyobject class
objectclass definefastprivatemethod    callbackfactory getfastmethod
return objectclass
}
public static final objectallocator object_allocator   new objectallocator
public irubyobject allocate ruby runtime  rubyclass klass
return new rubyobject runtime  klass
}
public void attachtoobjectspace
getruntime   getobjectspace   add this
}
/**
* this is overridden in the other concrete java builtins to provide a fast way
* to determine what type they are.
*/
public int getnativetypeindex
return classindex object
}
public boolean ismodule
return false
}
public boolean isclass
return false
}
/*
*  is object immediate (def: fixnum, symbol, true, false, nil?).
*/
public boolean isimmediate
return false
}
/** rb_make_metaclass
*
*/
public rubyclass makemetaclass rubyclass superclass
metaclass klass   new metaclass getruntime    superclass      rb_class_boot
setmetaclass klass
klass setattached this
klass setmetaclass superclass getrealclass   getmetaclass
return klass
}
public class getjavaclass
return irubyobject class
}
public static void puts object obj
system out println obj tostring
}
/**
* this method is just a wrapper around the ruby "==" method,
* provided so that rubyobjects can be used as keys in the java
* hashmap object underlying rubyhash.
*/
public boolean equals object other
return other    this
other instanceof irubyobject
callmethod getruntime   getcurrentcontext    methodindex equalequal      irubyobject  other  istrue
}
public string tostring
return runtimehelpers invoke getruntime   getcurrentcontext    this  methodindex to_s     irubyobject null_array  tostring
}
/** getter for property ruby.
* @return value of property ruby.
*/
public final ruby getruntime
return getmetaclass   getclassruntime
}
/**
* if exist return the meta-class else return the type of the object.
*
*/
public final rubyclass getmetaclass
rubyclass mc
if   mc   metaclass     null  return mc
if  ruby runtime_threadlocal    metaclassname    null
// this should only happen when we're persisting objects, so go after getcurrentinstance directly
metaclass   ruby getcurrentinstance   getclass metaclassname
}
return metaclass
}
public void setmetaclass rubyclass metaclass
this metaclass   metaclass
if  ruby runtime_threadlocal    metaclass    null
metaclassname   metaclass classid
}
}
/**
* gets the frozen.
* @return returns a boolean
*/
public boolean isfrozen
return  flags   frozen_f     0
}
/**
* sets the frozen.
* @param frozen the frozen to set
*/
public void setfrozen boolean frozen
if  frozen
flags    frozen_f
} else {
flags    ~frozen_f
}
}
/** rb_frozen_class_p
*
*/
protected void testfrozen string message
if  isfrozen
throw getruntime   newfrozenerror message       getmetaclass   getname
}
}
protected void checkfrozen
testfrozen
}
/**
* gets the taint.
* @return returns a boolean
*/
public boolean istaint
return  flags   tainted_f     0
}
/**
* sets the taint.
* @param taint the taint to set
*/
public void settaint boolean taint
if  taint
flags    tainted_f
} else {
flags    ~tainted_f
}
}
public final boolean isnil
return  flags   nil_f     0
}
public final boolean istrue
return  flags   false_f     0
}
public final boolean isfalse
return  flags   false_f     0
}
public boolean respondsto string name
if getmetaclass   searchmethod       getruntime   getrespondtomethod
return getmetaclass   ismethodbound name  false
} else {
return callmethod getruntime   getcurrentcontext     getruntime   newsymbol name   istrue
}
}
/** rb_singleton_class
*  note: this method is specialized for rubyfixnum, rubysymbol, rubynil and rubyboolean
*/
public rubyclass getsingletonclass
rubyclass klass
if  getmetaclass   issingleton        metaclass getmetaclass    getattached      this
klass   getmetaclass
} else {
klass   makemetaclass getmetaclass
}
klass settaint istaint
if  isfrozen    klass setfrozen true
return klass
}
/** rb_singleton_class_clone
*
*/
protected rubyclass getsingletonclassclone
rubyclass klass   getmetaclass
if   klass issingleton    return klass
metaclass clone   new metaclass getruntime
clone flags   flags
if  this instanceof rubyclass
clone setmetaclass clone
} else {
clone setmetaclass klass getsingletonclassclone
}
clone setsuperclass klass getsuperclass
if  klass hasvariables
clone syncvariables klass getvariablelist
}
klass clonemethods clone
metaclass clone getmetaclass    setattached clone
metaclass clone  setattached   metaclass klass  getattached
return clone
}
/** init_copy
*
*/
private static void initcopy irubyobject clone  rubyobject original
assert  clone isfrozen         clone getmetaclass   getname
original copyspecialinstancevariables clone
if  original hasvariables
clone syncvariables original getvariablelist
}
/* fixme: finalizer should be dupped here */
clone callmethod clone getruntime   getcurrentcontext       original
}
/** obj_infect
*
*/
public irubyobject infectby irubyobject obj
if  obj istaint    settaint true
return this
}
public irubyobject callsuper threadcontext context  irubyobject args  block block
rubymodule klazz   context getframeklazz
rubyclass superclass   runtimehelpers findimplementerifnecessary getmetaclass    klazz  getsuperclass
assert superclass    null       klazz getbasename
return runtimehelpers invokeas context  superclass  this  context getframename    args  calltype super  block
}
public irubyobject callmethod threadcontext context  string name
return runtimehelpers invoke context  this  name  irubyobject null_array  null  block null_block
}
public irubyobject callmethod threadcontext context  string name  irubyobject arg
return runtimehelpers invoke context  this  name  arg  calltype functional  block null_block
}
public irubyobject callmethod threadcontext context  string name  irubyobject args
return runtimehelpers invoke context  this  name  args  calltype functional  block null_block
}
public irubyobject callmethod threadcontext context  string name  irubyobject args  block block
return runtimehelpers invoke context  this  name  args  calltype functional  block
}
public irubyobject callmethod threadcontext context  int methodindex  string name
return runtimehelpers invoke context  this  methodindex  name  irubyobject null_array  null  block null_block
}
public irubyobject callmethod threadcontext context  int methodindex  string name  irubyobject arg
return runtimehelpers invoke context  this  methodindex name new irubyobject arg  calltype functional  block null_block
}
public void callinit irubyobject args  block block
callmethod getruntime   getcurrentcontext       args  block
}
/** rb_to_id
*
*/
public string asjavastring
irubyobject asstring   checkstringtype
if  asstring isnil    return   rubystring asstring  asjavastring
throw getruntime   newtypeerror inspect   tostring
}
public rubyarray converttoarray
return  rubyarray  typeconverter converttotype this  getruntime   getarray    methodindex to_ary
}
public rubyhash converttohash
return  rubyhash typeconverter converttotype this  getruntime   gethash    methodindex to_hash
}
public rubyfloat converttofloat
return  rubyfloat  typeconverter converttotype this  getruntime   getfloat    methodindex to_f
}
public rubyinteger converttointeger
return converttointeger methodindex to_int
}
public rubyinteger converttointeger int convertmethodindex  string convertmethod
irubyobject val   typeconverter converttotype this  getruntime   getinteger    convertmethodindex  convertmethod  true
if    val instanceof rubyinteger   throw getruntime   newtypeerror getmetaclass   getname         convertmethod
return  rubyinteger val
}
public rubystring converttostring
return  rubystring  typeconverter converttotype this  getruntime   getstring    methodindex to_str
}
public final irubyobject converttotype rubyclass target  int convertmethodindex
return typeconverter converttotype this  target  convertmethodindex   string methodindex names get convertmethodindex
}
/** rb_obj_as_string
*/
public rubystring asstring
irubyobject str   runtimehelpers invoke getruntime   getcurrentcontext    this  methodindex to_s     irubyobject null_array
if    str instanceof rubystring   return  rubystring anytostring
if  istaint    str settaint true
return  rubystring  str
}
/** rb_check_string_type
*
*/
public irubyobject checkstringtype
irubyobject str   typeconverter converttotypewithcheck this  getruntime   getstring    methodindex to_str
if  str isnil        str instanceof rubystring
str   getruntime   newstring
}
return str
}
/** rb_check_array_type
*
*/
public irubyobject checkarraytype
return typeconverter converttotypewithcheck this  getruntime   getarray    methodindex to_ary
}
/** specific_eval
*
*/
public irubyobject specificeval threadcontext context  rubymodule mod  irubyobject args  block block
if  block isgiven
if  args length > 0  throw getruntime   newargumenterror args length  0
return yieldunder context  mod  new irubyobject   this    block
}
if  args length    0
throw getruntime   newargumenterror
else if  args length > 3
string lastfuncname   context getframename
throw getruntime   newargumenterror
lastfuncname       lastfuncname
}
/*
if (ruby.getsecuritylevel() >= 4) {
check_type(argv[0], t_string);
} else {
check_safestr(argv[0]);
}
*/
// we just want the typeerror if the argument doesn't convert to a string (jruby-386)
args   args converttostring
irubyobject file   args length > 1 ? args   getruntime   newstring
irubyobject line   args length > 2 ? args   rubyfixnum one getruntime
visibility savedvisibility   context getcurrentvisibility
context setcurrentvisibility visibility public
try
return evalunder context  mod  args  file  line
finally
context setcurrentvisibility savedvisibility
}
}
public irubyobject evalunder final threadcontext context  rubymodule under  irubyobject src  irubyobject file  irubyobject line
return under executeunder context  new callback
public irubyobject execute irubyobject self  irubyobject args  block block
irubyobject source   args
irubyobject filename   args
// line numbers are zero-based so we subtract one
int linenumber    int   args converttointeger   getlongvalue     1
return astinterpreter evalsimple context  args  source
filename converttostring   tostring    linenumber
}
public arity getarity
return arity optional
}
new irubyobject   this  src  file  line    block null_block
}
private irubyobject yieldunder final threadcontext context  rubymodule under  irubyobject args  block block
return under executeunder context  new callback
public irubyobject execute irubyobject self  irubyobject args  block block
visibility savedvisibility   block getbinding   getvisibility
block getbinding   setvisibility visibility public
try
irubyobject valueinyield
boolean avalue
if  args length    1
valueinyield   args
avalue   false
} else {
valueinyield   rubyarray newarray getruntime    args
avalue   true
}
// fixme: this is an ugly hack to resolve jruby-1381; i'm not proud of it
block   block cloneblock
block getbinding   setself rubyobject this
block getbinding   getframe   setself rubyobject this
// end hack
return block yield context  valueinyield  rubyobject this  context getrubyclass    avalue
//todo: should next and return also catch here?
catch  jumpexception breakjump bj
return  irubyobject  bj getvalue
finally
block getbinding   setvisibility savedvisibility
}
}
public arity getarity
return arity optional
}
args  block
}
// methods of the object class (rb_obj_*):
/** rb_obj_equal
*
*/
@jrubymethod name      required   1
public irubyobject op_equal threadcontext context  irubyobject obj
return this    obj ? getruntime   gettrue     getruntime   getfalse
}
@jrubymethod name      required   1
public irubyobject equal_p irubyobject obj
return this    obj ? getruntime   gettrue     getruntime   getfalse
}
/** method used for hash key comparison (specialized for string, symbol and fixnum)
*
*/
public boolean eql irubyobject other
return callmethod getruntime   getcurrentcontext    methodindex eql_p     other  istrue
}
@jrubymethod name      required   1
public irubyobject eql_p irubyobject obj
return this    obj ? getruntime   gettrue     getruntime   getfalse
}
/** rb_equal
*
*/
@jrubymethod name      required   1
public irubyobject op_eqq threadcontext context  irubyobject other
return getruntime   newboolean this    other    callmethod context  methodindex equalequal    other  istrue
}
protected static irubyobject equalinternal final threadcontext context  final irubyobject that  final irubyobject other
if  that    other  return that getruntime   gettrue
return that callmethod context  methodindex equalequal     other
}
protected static boolean eqlinternal final threadcontext context  final irubyobject that  final irubyobject other
if  that    other  return true
return that callmethod context  methodindex eql_p     other  istrue
}
/** rb_obj_init_copy
*
*/
@jrubymethod name      required   1  visibility   visibility private
public irubyobject initialize_copy irubyobject original
if  this    original  return this
checkfrozen
if  getmetaclass   getrealclass      original getmetaclass   getrealclass
throw getruntime   newtypeerror
}
return this
}
/**
* respond_to?( asymbol, includepriv=false ) -> true or false
*
* returns true if this object responds to the given method. private
* methods are included in the search only if the optional second
* parameter evaluates to true.
*
* @return true if this responds to the given method
* fixme: !!! for some reason mri shows the arity of respond_to? as -1, when it should be -2; that's why this is rest instead of required, optional = 1
*/
@jrubymethod name      rest   true
public rubyboolean respond_to_p irubyobject args
string name   args asjavastring
boolean includeprivate   args length > 1 ? args istrue     false
return getruntime   newboolean getmetaclass   ismethodbound name   includeprivate
}
/** return the internal id of an object.
*
* <i>cruby function: rb_obj_id</i>
* fixme: should this be renamed to match its ruby name?
*/
@jrubymethod name
public synchronized irubyobject id
return getruntime   newfixnum getruntime   getobjectspace   idof this
}
/** rb_obj_id_obsolete
*
*/
@jrubymethod name
public synchronized irubyobject id_deprecated
getruntime   getwarnings   warn id deprecated_method
return id
}
@jrubymethod name
public rubyfixnum hash
return getruntime   newfixnum super hashcode
}
public int hashcode
irubyobject hashvalue   callmethod getruntime   getcurrentcontext    methodindex hash
if  hashvalue instanceof rubyfixnum  return  int  rubynumeric fix2long hashvalue
return super hashcode
}
/** rb_obj_type
*
*/
@jrubymethod name
public rubyclass type
return getmetaclass   getrealclass
}
@jrubymethod name
public rubyclass type_deprecated
getruntime   getwarnings   warn id deprecated_method
return type
}
/** rb_obj_clone
*  should be overriden only by: proc, method, unboundedmethod, binding
*/
@jrubymethod name      frame   true
public irubyobject rbclone
if  isimmediate    throw getruntime   newtypeerror     getmetaclass   getname
// we're cloning ourselves, so we know the result should be a rubyobject
rubyobject clone    rubyobject getmetaclass   getrealclass   allocate
clone setmetaclass getsingletonclassclone
if  istaint    clone settaint true
initcopy clone  this
if  isfrozen    clone setfrozen true
return clone
}
/** rb_obj_dup
*  should be overriden only by: proc
*/
@jrubymethod name
public irubyobject dup
if  isimmediate    throw getruntime   newtypeerror     getmetaclass   getname
irubyobject dup   getmetaclass   getrealclass   allocate
if  istaint    dup settaint true
initcopy dup  this
return dup
}
/** lots of mri objects keep their state in non-lookupable ivars (e:g. range, struct, etc)
*  this method is responsible for dupping our java field equivalents
*
*/
protected void copyspecialinstancevariables irubyobject clone
}
@jrubymethod name      optional   1
public irubyobject display threadcontext context  irubyobject args
irubyobject port   args length    0
? getruntime   getglobalvariables   get      args
port callmethod context     this
return getruntime   getnil
}
/** rb_obj_tainted
*
*/
@jrubymethod name
public rubyboolean tainted_p
return getruntime   newboolean istaint
}
/** rb_obj_taint
*
*/
@jrubymethod name
public irubyobject taint
getruntime   secure 4
if   istaint
testfrozen
settaint true
}
return this
}
/** rb_obj_untaint
*
*/
@jrubymethod name
public irubyobject untaint
getruntime   secure 3
if  istaint
testfrozen
settaint false
}
return this
}
/** freeze an object.
*
* rb_obj_freeze
*
*/
@jrubymethod name
public irubyobject freeze
if   flags   frozen_f     0
if  getruntime   getsafelevel   >  4    istaint
throw getruntime   newsecurityerror
}
flags    frozen_f
}
return this
}
/** rb_obj_frozen_p
*
*/
@jrubymethod name
public rubyboolean frozen_p
return getruntime   newboolean isfrozen
}
/** inspect_obj
*
*/
private stringbuffer inspectobj stringbuffer part
string sep
for  variable<irubyobject> ivar   getinstancevariablelist
part append sep
part append
part append ivar getname
part append
part append ivar getvalue   callmethod getruntime   getcurrentcontext
sep
}
part append
return part
}
/** rb_obj_inspect
*
*/
@jrubymethod name
public irubyobject inspect
ruby runtime   getruntime
if    isimmediate
// type(obj) == t_object
this instanceof rubyclass
this    runtime getobject
this    runtime getmodule
this instanceof rubymodule
// todo: should have #hasinstancevariables method, though
// this will work here:
hasvariables
stringbuffer part   new stringbuffer
string cname   getmetaclass   getrealclass   getname
part append    append cname  append
part append integer tohexstring system identityhashcode this
if  runtime isinspecting this
/* 6:tags 16:addr 1:eos */
part append
return runtime newstring part tostring
}
try
runtime registerinspecting this
return runtime newstring inspectobj part  tostring
finally
runtime unregisterinspecting this
}
}
if  isnil    return rubynil inspect this
return runtimehelpers invoke runtime getcurrentcontext    this  methodindex to_s     irubyobject null_array
}
/** rb_obj_is_instance_of
*
*/
@jrubymethod name      required   1
public rubyboolean instance_of_p irubyobject type
if  type      type
return getruntime   gettrue
} else {
if    type instanceof rubymodule
throw getruntime   newtypeerror
}
return getruntime   getfalse
}
}
/** rb_obj_is_kind_of
*
*/
@jrubymethod name           required   1
public rubyboolean kind_of_p irubyobject type
// todo: generalize this type-checking code into irubyobject helper.
if    type instanceof rubymodule
// todo: newtypeerror does not offer enough for ruby error string...
throw getruntime   newtypeerror
}
return getruntime   newboolean   rubymodule type  isinstance this
}
/** rb_obj_methods
*
*/
@jrubymethod name      optional   1
public irubyobject methods irubyobject args
boolean all   true
if  args length    1
all   args istrue
}
rubyarray singletonmethods   null
if  getmetaclass   issingleton
singletonmethods
getmetaclass   instance_methods new irubyobject  getruntime   getfalse
if  all
singletonmethods concat getmetaclass   getsuperclass   instance_methods new irubyobject  getruntime   gettrue
}
} else {
if  all
singletonmethods   getmetaclass   instance_methods new irubyobject  getruntime   gettrue
} else {
singletonmethods   getruntime   newemptyarray
}
}
return singletonmethods
}
@jrubymethod name      optional   1
public irubyobject public_methods irubyobject args
if  args length    0
args   new irubyobject   getruntime   gettrue
}
return getmetaclass   public_instance_methods args
}
/** rb_obj_protected_methods
*
*/
@jrubymethod name      optional   1
public irubyobject protected_methods irubyobject args
if  args length    0
args   new irubyobject   getruntime   gettrue
}
return getmetaclass   protected_instance_methods args
}
/** rb_obj_private_methods
*
*/
@jrubymethod name      optional   1
public irubyobject private_methods irubyobject args
if  args length    0
args   new irubyobject   getruntime   gettrue
}
return getmetaclass   private_instance_methods args
}
/** rb_obj_singleton_methods
*
*/
// todo: this is almost rubymodule#instance_methods on the metaclass.  perhaps refactor.
@jrubymethod name      optional   1
public rubyarray singleton_methods irubyobject args
boolean all   true
if args length    1
all   args istrue
}
rubyarray singletonmethods   null
if  getmetaclass   issingleton
singletonmethods
getmetaclass   instance_methods new irubyobject  getruntime   getfalse
if  all
rubyclass superclass   getmetaclass   getsuperclass
while  superclass isincluded
singletonmethods concat superclass instance_methods new irubyobject  getruntime   getfalse
superclass   superclass getsuperclass
}
}
} else {
singletonmethods   getruntime   newemptyarray
}
return singletonmethods
}
@jrubymethod name      required   1
public irubyobject method irubyobject symbol
return getmetaclass   newmethod this  symbol asjavastring    true
}
public irubyobject anytostring
string cname   getmetaclass   getrealclass   getname
/* 6:tags 16:addr 1:eos */
rubystring str   getruntime   newstring     cname       integer tohexstring system identityhashcode this
str settaint istaint
return str
}
@jrubymethod name
public irubyobject to_s
return anytostring
}
@jrubymethod name      visibility   visibility public
public rubyarray to_a
getruntime   getwarnings   warn id deprecated_method
return getruntime   newarray this
}
@jrubymethod name      optional   3  frame   true
public irubyobject instance_eval threadcontext context  irubyobject args  block block
rubymodule klazz
if  isimmediate
klazz   context getpreviousframe   getklazz
if  klazz    null  klazz   getruntime   getobject
} else {
klazz   getsingletonclass
}
return specificeval context  klazz  args  block
}
@jrubymethod name      optional   3  frame   true
public irubyobject instance_exec threadcontext context  irubyobject args  block block
if   block isgiven
throw getruntime   newargumenterror
}
rubymodule klazz
if  isimmediate
klazz   context getpreviousframe   getklazz
if  klazz    null  klazz   getruntime   getobject
} else {
klazz   getsingletonclass
}
return yieldunder context  klazz  args  block
}
@jrubymethod name      required   1  rest   true
public irubyobject extend irubyobject args
// make sure all arguments are modules before calling the callbacks
for  int i   0  i < args length  i
if   args ismodule    throw getruntime   newtypeerror args  getruntime   getmodule
}
// mri extends in order from last to first
for  int i   args length   1  i >  0  i
args callmethod getruntime   getcurrentcontext       this
args callmethod getruntime   getcurrentcontext       this
}
return this
}
@jrubymethod name      visibility   visibility private
public irubyobject initialize
return getruntime   getnil
}
/**
* send( asymbol  [, args  ]*   ) -> anobject
*
* invokes the method identified by asymbol, passing it any arguments
* specified. you can use __send__ if the name send clashes with an
* existing method in this object.
*
* <pre>
* class klass
*   def hello(*args)
*     "hello " + args.join(' ')
*   end
* end
*
* k = klass.new
* k.send :hello, "gentle", "readers"
* </pre>
*
* @return the result of invoking the method identified by asymbol.
*/
@jrubymethod name           required   1  rest   true
public irubyobject send threadcontext context  irubyobject args  block block
string name   args asjavastring
int newargslength   args length   1
irubyobject newargs
if  newargslength    0
newargs   irubyobject null_array
} else {
newargs   new irubyobject
system arraycopy args  1  newargs  0  newargs length
}
rubymodule rubyclass   getmetaclass
dynamicmethod method   rubyclass searchmethod name
// send doesn't check visibility
if  method isundefined
return runtimehelpers callmethodmissing context  this  method  name  newargs  context getframeself    calltype functional  block
}
return method call context  this  rubyclass  name  newargs  block
}
@jrubymethod name
public irubyobject nil_p
return getruntime   getfalse
}
@jrubymethod name      required   1
public irubyobject op_match threadcontext context  irubyobject arg
return getruntime   getfalse
}
/**
* @see org.jruby.runtime.builtin.irubyobject#gettype()
*/
public rubyclass gettype
return type
}
/**
* @see org.jruby.runtime.builtin.irubyobject#datawrapstruct()
*/
public synchronized void datawrapstruct object obj
this datastruct   obj
}
/**
* @see org.jruby.runtime.builtin.irubyobject#datagetstruct()
*/
public synchronized object datagetstruct
return datastruct
}
public void addfinalizer irubyobject finalizer
if  this finalizer    null
this finalizer   new finalizer getruntime   getobjectspace   idof this
getruntime   addfinalizer this finalizer
}
this finalizer addfinalizer finalizer
}
public void removefinalizers
if  finalizer    null
finalizer removefinalizers
finalizer   null
getruntime   removefinalizer this finalizer
}
}
//
// instance variable ruby methods
//
@jrubymethod name      required   1
public irubyobject instance_variable_defined_p irubyobject name
if  variabletablecontains validateinstancevariable name asjavastring
return getruntime   gettrue
}
return getruntime   getfalse
}
@jrubymethod name      required   1
public irubyobject instance_variable_get irubyobject name
irubyobject value
if   value   variabletablefetch validateinstancevariable name asjavastring         null
return value
}
return getruntime   getnil
}
@jrubymethod name      required   2
public irubyobject instance_variable_set irubyobject name  irubyobject value
ensureinstancevariablessettable
return variabletablestore validateinstancevariable name asjavastring     value
}
@jrubymethod name      required   1  frame   true  visibility   visibility private
public irubyobject remove_instance_variable irubyobject name  block block
ensureinstancevariablessettable
irubyobject value
if   value   variabletableremove validateinstancevariable name asjavastring         null
return value
}
throw getruntime   newnameerror     name asjavastring        name asjavastring
}
@jrubymethod name
public rubyarray instance_variables
ruby runtime   getruntime
list<string> namelist   getinstancevariablenamelist
rubyarray array   runtime newarray namelist size
for  string name   namelist
array append runtime newstring name
}
return array
}
//
// instance variable api methods
//
public instancevariables getinstancevariables
return this
}
public boolean hasinstancevariable string name
assert idutil isinstancevariable name
return variabletablecontains name
}
public boolean fasthasinstancevariable string internedname
assert idutil isinstancevariable internedname
return variabletablefastcontains internedname
}
public irubyobject getinstancevariable string name
assert idutil isinstancevariable name
return variabletablefetch name
}
public irubyobject fastgetinstancevariable string internedname
assert idutil isinstancevariable internedname
return variabletablefastfetch internedname
}
/** rb_iv_set / rb_ivar_set
*
*/
public irubyobject setinstancevariable string name  irubyobject value
assert idutil isinstancevariable name     value    null
ensureinstancevariablessettable
return variabletablestore name  value
}
public irubyobject fastsetinstancevariable string internedname  irubyobject value
assert idutil isinstancevariable internedname     value    null
ensureinstancevariablessettable
return variabletablefaststore internedname  value
}
public irubyobject removeinstancevariable string name
assert idutil isinstancevariable name
ensureinstancevariablessettable
return variabletableremove name
}
public list<variable<irubyobject>> getinstancevariablelist
variabletableentry table   variabletablegettable
arraylist<variable<irubyobject>> list   new arraylist<variable<irubyobject>>
irubyobject readvalue
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
if  idutil isinstancevariable e name
if   readvalue   e value     null  readvalue   variabletablereadlocked e
list add new variableentry<irubyobject> e name  readvalue
}
}
}
return list
}
public list<string> getinstancevariablenamelist
variabletableentry table   variabletablegettable
arraylist<string> list   new arraylist<string>
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
if  idutil isinstancevariable e name
list add e name
}
}
}
return list
}
protected static final string err_insecure_set_inst_var
protected string validateinstancevariable string name
if  idutil isvalidinstancevariablename name
return name
}
throw getruntime   newnameerror     name      name
}
protected void ensureinstancevariablessettable
if   isfrozen       getruntime   getsafelevel   < 4    istaint
return
}
if  getruntime   getsafelevel   >  4     istaint
throw getruntime   newsecurityerror err_insecure_set_inst_var
}
if  isfrozen
if  this instanceof rubymodule
throw getruntime   newfrozenerror
} else {
throw getruntime   newfrozenerror
}
}
}
//
// internal variable methods
//
public internalvariables getinternalvariables
return this
}
public boolean hasinternalvariable string name
assert  isrubyvariable name
return variabletablecontains name
}
public boolean fasthasinternalvariable string internedname
assert  isrubyvariable internedname
return variabletablefastcontains internedname
}
public irubyobject getinternalvariable string name
assert  isrubyvariable name
return variabletablefetch name
}
public irubyobject fastgetinternalvariable string internedname
assert  isrubyvariable internedname
return variabletablefastfetch internedname
}
public void setinternalvariable string name  irubyobject value
assert  isrubyvariable name
variabletablestore name  value
}
public void fastsetinternalvariable string internedname  irubyobject value
assert  isrubyvariable internedname
variabletablefaststore internedname  value
}
public irubyobject removeinternalvariable string name
assert  isrubyvariable name
return variabletableremove name
}
public void syncvariables list<variable<irubyobject>> variables
variabletablesync variables
}
public list<variable<irubyobject>> getinternalvariablelist
variabletableentry table   variabletablegettable
arraylist<variable<irubyobject>> list   new arraylist<variable<irubyobject>>
irubyobject readvalue
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
if   isrubyvariable e name
if   readvalue   e value     null  readvalue   variabletablereadlocked e
list add new variableentry<irubyobject> e name  readvalue
}
}
}
return list
}
//
// common variable methods
//
/**
* returns true if object has any variables, defined as:
* <ul>
* <li> instance variables
* <li> class variables
* <li> constants
* <li> internal variables, such as those used when marshaling ranges and exceptions
* </ul>
* @return true if object has any variables, else false
*/
public boolean hasvariables
return variabletablegetsize   > 0
}
public int getvariablecount
return variabletablegetsize
}
// todo: must override in rubymodule to pick up constants
public list<variable<irubyobject>> getvariablelist
variabletableentry table   variabletablegettable
arraylist<variable<irubyobject>> list   new arraylist<variable<irubyobject>>
irubyobject readvalue
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
if   readvalue   e value     null  readvalue   variabletablereadlocked e
list add new variableentry<irubyobject> e name  readvalue
}
}
return list
}
// todo: must override in rubymodule to pick up constants
public list<string> getvariablenamelist
variabletableentry table   variabletablegettable
arraylist<string> list   new arraylist<string>
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
list add e name
}
}
return list
}
@suppresswarnings
@deprecated    born deprecated
public map getvariablemap
return variabletablegetmap
}
// fixme: this should go somewhere more generic -- maybe idutil
protected static final boolean isrubyvariable string name
char c
return name length   > 0      c   name charat 0            c <       c >
}
//
// variable table methods, etc.
//
protected static final int variable_table_default_capacity   8     must be power of 2
protected static final int variable_table_maximum_capacity   1 << 30
protected static final float variable_table_load_factor   0 75f
protected static final variabletableentry variable_table_empty_table   new variabletableentry
protected static final class variabletableentry
final int hash
final string name
volatile irubyobject value
final variabletableentry next
variabletableentry int hash  string name  irubyobject value  variabletableentry next
assert name    name intern     name
this hash   hash
this name   name
this value   value
this next   next
}
}
protected synchronized irubyobject variabletablereadlocked variabletableentry entry
return entry value
}
protected boolean variabletablecontains string name
variabletableentry table
if   table   variabletable     null
int hash   name hashcode
for  variabletableentry e   table  e    null  e   e next
if  hash    e hash    name equals e name
return true
}
}
}
return false
}
protected boolean variabletablefastcontains string internedname
assert internedname    internedname intern     internedname
variabletableentry table
if   table   variabletable     null
for  variabletableentry e   table  e    null  e   e next
if  internedname    e name
return true
}
}
}
return false
}
protected irubyobject variabletablefetch string name
variabletableentry table
irubyobject readvalue
if   table   variabletable     null
int hash   name hashcode
for  variabletableentry e   table  e    null  e   e next
if  hash    e hash    name equals e name
if   readvalue   e value     null  return readvalue
return variabletablereadlocked e
}
}
}
return null
}
protected irubyobject variabletablefastfetch string internedname
assert internedname    internedname intern     internedname
variabletableentry table
irubyobject readvalue
if   table   variabletable     null
for  variabletableentry e   table  e    null  e   e next
if  internedname    e name
if   readvalue   e value     null  return readvalue
return variabletablereadlocked e
}
}
}
return null
}
protected irubyobject variabletablestore string name  irubyobject value
int hash   name hashcode
synchronized this
variabletableentry table
variabletableentry e
if   table   variabletable     null
table    new variabletableentry
e   new variabletableentry hash  name intern    value  null
table   e
variabletablethreshold    int  variable_table_default_capacity   variable_table_load_factor
variabletablesize   1
variabletable   table
return value
}
int potentialnewsize
if   potentialnewsize   variabletablesize   1  > variabletablethreshold
table   variabletablerehash
}
int index
for  e   table  e    null  e   e next
if  hash    e hash    name equals e name
e value   value
return value
}
}
e   new variabletableentry hash  name intern    value  table
table   e
variabletablesize   potentialnewsize
variabletable   table     write volatile
}
return value
}
protected irubyobject variabletablefaststore string internedname  irubyobject value
assert internedname    internedname intern     internedname
int hash   internedname hashcode
synchronized this
variabletableentry table
variabletableentry e
if   table   variabletable     null
table    new variabletableentry
e   new variabletableentry hash  internedname  value  null
table   e
variabletablethreshold    int  variable_table_default_capacity   variable_table_load_factor
variabletablesize   1
variabletable   table
return value
}
int potentialnewsize
if   potentialnewsize   variabletablesize   1  > variabletablethreshold
table   variabletablerehash
}
int index
for  e   table  e    null  e   e next
if  internedname    e name
e value   value
return value
}
}
e   new variabletableentry hash  internedname  value  table
table   e
variabletablesize   potentialnewsize
variabletable   table     write volatile
}
return value
}
protected irubyobject variabletableremove string name
synchronized this
variabletableentry table
if   table   variabletable     null
int hash   name hashcode
int index   hash    table length   1
variabletableentry first   table
variabletableentry e
for  e   first  e    null  e   e next
if  hash    e hash    name equals e name
irubyobject oldvalue   e value
// all entries following removed node can stay
// in list, but all preceding ones need to be
// cloned.
variabletableentry newfirst   e next
for  variabletableentry p   first  p    e  p   p next
newfirst   new variabletableentry p hash  p name  p value  newfirst
}
table   newfirst
variabletablesize
variabletable   table     write volatile
return oldvalue
}
}
}
}
return null
}
protected variabletableentry variabletablegettable
variabletableentry table
if   table   variabletable     null
return table
}
return variable_table_empty_table
}
protected int variabletablegetsize
if  variabletable    null
return variabletablesize
}
return 0
}
protected void variabletablesync list<variable<irubyobject>> vars
synchronized this
variabletablesize   0
variabletablethreshold    int  variable_table_default_capacity   variable_table_load_factor
variabletable    new variabletableentry
for  variable<irubyobject> var   vars
variabletablestore var getname    var getvalue
}
}
}
// must be called from synchronized/locked block!
// should only be called by variabletablestore/variabletablefaststore
protected final variabletableentry variabletablerehash
variabletableentry oldtable   variabletable
int oldcapacity
if   oldcapacity   oldtable length  >  variable_table_maximum_capacity
return oldtable
}
int newcapacity   oldcapacity << 1
variabletableentry newtable   new variabletableentry
variabletablethreshold    int  newcapacity   variable_table_load_factor
int sizemask   newcapacity   1
variabletableentry e
for  int i   oldcapacity    i >  0
// we need to guarantee that any existing reads of old map can
//  proceed. so we cannot yet null out each bin.
e   oldtable
if  e    null
variabletableentry next   e next
int idx   e hash   sizemask
//  single node on list
if  next    null
newtable   e
else
// reuse trailing consecutive sequence at same slot
variabletableentry lastrun   e
int lastidx   idx
for  variabletableentry last   next
last    null
last   last next
int k   last hash   sizemask
if  k    lastidx
lastidx   k
lastrun   last
}
}
newtable   lastrun
// clone all remaining nodes
for  variabletableentry p   e  p    lastrun  p   p next
int k   p hash   sizemask
variabletableentry m   new variabletableentry p hash  p name  p value  newtable
newtable   m
}
}
}
}
variabletable   newtable
return newtable
}
/**
* method to help ease transition to new variables implementation.
* will likely be deprecated in the near future.
*/
@suppresswarnings
protected map variabletablegetmap
hashmap map   new hashmap
variabletableentry table
irubyobject readvalue
if   table   variabletable     null
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
if   readvalue   e value     null  readvalue   variabletablereadlocked e
map put e name  readvalue
}
}
}
return map
}
/**
* method to help ease transition to new variables implementation.
* will likely be deprecated in the near future.
*/
@suppresswarnings
protected map variabletablegetmap map map
variabletableentry table
irubyobject readvalue
if   table   variabletable     null
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
if   readvalue   e value     null  readvalue   variabletablereadlocked e
map put e name  readvalue
}
}
}
return map
}
// note: serialization is primarily supported for testing purposes, and there is no general
// guarantee that serialization will work correctly. specifically, instance variables pointing
// at symbols, threads, modules, classes, and other unserializable types are not detected.
private void writeobject objectoutputstream out  throws ioexception
out defaultwriteobject
// write out ivar count followed by name/value pairs
list<string> names   getinstancevariablenamelist
out writeint names size
for  string name   names
out writeobject name
out writeobject getinstancevariables   getinstancevariable name
}
}
private void readobject objectinputstream in  throws ioexception  classnotfoundexception
in defaultreadobject
// rest in ivar count followed by name/value pairs
int ivarcount   in readint
for  int i   0  i < ivarcount  i
setinstancevariable  string in readobject     irubyobject in readobject
}
}
}