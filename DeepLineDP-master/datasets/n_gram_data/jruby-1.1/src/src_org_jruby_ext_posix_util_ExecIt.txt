/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2008 jruby community
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby ext posix util
import java io file
import java io ioexception
import java io inputstream
import java io outputstream
import org jruby ext posix posixhandler
public class execit
posixhandler handler
/** creates a new instance of shelllauncher */
public execit posixhandler handler
this handler   handler
public int runandwait string    args  throws ioexception  interruptedexception
return runandwait handler getoutputstream    args
public int runandwait outputstream output  string    args  throws ioexception  interruptedexception
process process   run args
handlestreams process  handler getinputstream    output  handler geterrorstream
return process waitfor
public process run string    args  throws ioexception
file cwd   handler getcurrentworkingdirectory
return runtime getruntime   exec args  handler getenv    cwd
private static class streampumper extends thread
private inputstream in
private outputstream out
private boolean onlyifavailable
private volatile boolean quit
private final object waitlock   new object
streampumper inputstream in  outputstream out  boolean avail
this in   in
this out   out
this onlyifavailable   avail
public void run
byte buf   new byte
int numread
boolean hasreadsomething   false
try
while   quit
// the problem we trying to solve below: stdin in java is blocked and
// non-interruptible, so if we invoke read on it, we might never be able to
// interrupt such thread.  so, we use in.available() to see if there is any
// input ready, and only then read it. but this approach can't tell whether
// the end of stream reached or not, so we might end up looping right at the
// end of the stream.  well, at least, we can improve the situation by checking
// if some input was ever available, and if so, not checking for available
// anymore, and just go to read.
if  onlyifavailable     hasreadsomething
if  in available      0
synchronized  waitlock
waitlock wait 10
continue
else
hasreadsomething   true
if   numread   in read buf       1
break
out write buf  0  numread
catch  exception e
finally
if  onlyifavailable
// we need to close the out, since some
// processes would just wait for the stream
// to be closed before they process its content,
// and produce the output. e.g.: "cat".
try   out close      catch  ioexception ioe
public void quit
this quit   true
synchronized  waitlock
waitlock notify
private void handlestreams process p  inputstream in  outputstream out  outputstream err  throws ioexception
inputstream pout   p getinputstream
inputstream perr   p geterrorstream
outputstream pin   p getoutputstream
streampumper t1   new streampumper pout  out  false
streampumper t2   new streampumper perr  err  false
streampumper t3   new streampumper in  pin  true
t1 start
t2 start
t3 start
try   t1 join      catch  interruptedexception ie
try   t2 join      catch  interruptedexception ie
t3 quit
try   err flush      catch  ioexception io
try   out flush      catch  ioexception io
try   pin close      catch  ioexception io
try   pout close      catch  ioexception io
try   perr close      catch  ioexception io