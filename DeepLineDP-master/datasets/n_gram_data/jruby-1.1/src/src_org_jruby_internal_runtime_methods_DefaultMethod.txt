/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004-2005 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 miguel covarrubias <mlcovarrubias@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby internal runtime methods
import org jruby ruby
import org jruby rubyarray
import org jruby rubymodule
import org jruby ast argsnode
import org jruby ast listnode
import org jruby ast node
import org jruby ast executable script
import org jruby compiler jitcompiler
import org jruby evaluator assignmentvisitor
import org jruby evaluator astinterpreter
import org jruby exceptions jumpexception
import org jruby internal runtime jumptarget
import org jruby javasupport util runtimehelpers
import org jruby lexer yacc isourceposition
import org jruby parser staticscope
import org jruby runtime arity
import org jruby runtime block
import org jruby runtime eventhook
import org jruby runtime frame
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
/**
*
*/
public final class defaultmethod extends dynamicmethod implements jumptarget
private staticscope staticscope
private node body
private argsnode argsnode
private int callcount   0
private script jitcompiledscript
private int requiredargscount
private int restarg
private boolean hasoptargs
private callconfiguration jitcallconfig
private isourceposition position
public defaultmethod rubymodule implementationclass  staticscope staticscope  node body
argsnode argsnode  visibility visibility  isourceposition position
super implementationclass  visibility  callconfiguration frame_and_scope
this body   body
this staticscope   staticscope
this argsnode   argsnode
this requiredargscount   argsnode getrequiredargscount
this restarg   argsnode getrestarg
this hasoptargs   argsnode getoptargs      null
this position   position
assert argsnode    null
public int getcallcount
return callcount
public void setcallcount int callcount
this callcount   callcount
public script getjitcompilerscript
return jitcompiledscript
public void setjitcompiledscript script jitcompiledscript
this jitcompiledscript   jitcompiledscript
public callconfiguration getjitcallconfig
return jitcallconfig
public void setjitcallconfig callconfiguration jitcallconfig
this jitcallconfig   jitcallconfig
public node getbodynode
return body
public argsnode getargsnode
return argsnode
public staticscope getstaticscope
return staticscope
/**
* @see abstractcallable#call(ruby, irubyobject, string, irubyobject[], boolean)
*/
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject args  block block
assert args    null
rubymodule implementer   getimplementationclass
ruby runtime   context getruntime
if  runtime getinstanceconfig   getcompilemode   shouldjit
jitcompiler runjit this  runtime  context  name
if  jitcompiledscript    null     runtime haseventhooks
try
// fixme: for some reason this wants (and works with) clazz instead of implementer,
// and needed it for compiled module method_function's called from outside the module. why?
jitcallconfig pre context  self  implementer  getarity    name  args  block  staticscope  this
return jitcompiledscript __file__ context  self  args  block
catch  jumpexception returnjump rj
if  rj gettarget      this
return  irubyobject  rj getvalue
throw rj
catch  jumpexception redojump rj
throw runtime newlocaljumperror    runtime getnil
finally
if  runtime haseventhooks
tracereturn context  runtime  name
jitcallconfig post context
else
try
callconfig pre context  self  implementer  getarity    name  args  block  staticscope  this
if  argsnode getblockargnode      null
context getcurrentscope   setvalue
argsnode getblockargnode   getcount
runtimehelpers processblockargument runtime  block
0
getarity   checkarity runtime  args
preparearguments context  runtime  args
if  runtime haseventhooks
tracecall context  runtime  name
return astinterpreter eval runtime  context  body  self  block
catch  jumpexception returnjump rj
if  rj gettarget      this
return  irubyobject  rj getvalue
throw rj
catch  jumpexception redojump rj
throw runtime newlocaljumperror    runtime getnil
finally
if  runtime haseventhooks
tracereturn context  runtime  name
callconfig post context
private void preparearguments threadcontext context  ruby runtime  irubyobject args
if  requiredargscount > args length
throw runtime newargumenterror     args length       requiredargscount
// bind 'normal' parameter values to the local scope for this method.
if  requiredargscount > 0
context getcurrentscope   setargvalues args  requiredargscount
// optargs and restargs require more work, so isolate them and arraylist creation here
if  hasoptargs    restarg     1
prepareoptorrestargs context  runtime  args
private void prepareoptorrestargs threadcontext context  ruby runtime  irubyobject args
// we know we've at least got the required count at this point, so start with that
int givenargscount   requiredargscount
// determine the maximum number of arguments
int maximumargs   requiredargscount
if  argsnode getoptargs      null
maximumargs    argsnode getoptargs   size
if  restarg     1    maximumargs < args length
throw runtime newargumenterror     args length       maximumargs
if  hasoptargs
listnode optargs   argsnode getoptargs
// assign given optional arguments to their variables
int j   0
for  int i   requiredargscount  i < args length    j < optargs size    i    j
// in-frame evalstate should already have receiver set as self, continue to use it
assignmentvisitor assign runtime  context  context getframeself    optargs get j   args  block null_block  true
givenargscount
// assign the default values, adding to the end of allargs
for  int i   0  j < optargs size    i    j
astinterpreter eval runtime  context  optargs get j   context getframeself    block null_block
// build an array from *rest type args, also adding to allargs
// enebo: does this next comment still need to be done since i killed haslocalvars:
// move this out of the scope.haslocalvariables() condition to deal
// with anonymous restargs (* versus *rest)
// none present ==> -1
// named restarg ==> >=0
// anonymous restarg ==> -2
if  restarg     1
// only set in scope if named
if  restarg >  0
rubyarray array   runtime newarray args length   givenargscount
for  int i   givenargscount  i < args length  i
array append args
context getcurrentscope   setvalue restarg  array  0
public isourceposition getposition
return position
private void tracereturn threadcontext context  ruby runtime  string name
frame frame   context getpreviousframe
runtime calleventhooks context  eventhook ruby_event_return  frame getfile    frame getline    name  getimplementationclass
private void tracecall threadcontext context  ruby runtime  string name
runtime calleventhooks context  eventhook ruby_event_call  position getfile    position getstartline    name  getimplementationclass
public arity getarity
return argsnode getarity
public dynamicmethod dup
return new defaultmethod getimplementationclass    staticscope  body  argsnode  getvisibility    position