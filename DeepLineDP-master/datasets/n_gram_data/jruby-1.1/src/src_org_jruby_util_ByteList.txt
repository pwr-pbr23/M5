/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007 charles o nutter <headius@headius.com>
* copyright (c) 2007 nick sieger <nicksieger@gmail.com>
* copyright (c) 2007 ola bini <ola@ologix.com>
* copyright (c) 2007 william n dortch <bill.dortch@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util
import java io ioexception
import java io inputstream
import java io serializable
import java io unsupportedencodingexception
import java nio bytebuffer
/**
*
* @author headius
*/
public final class bytelist implements comparable  charsequence  serializable
private static final long serialversionuid    1286166947275543731l
public static final byte null_array   new byte
public static final bytelist empty_bytelist   new bytelist 0
public byte bytes
public int begin
public int realsize
int hash
boolean validhash   false
string stringvalue
private static final int default_size   4
private static final double factor   1 5
/** creates a new instance of bytelist */
public bytelist
this default_size
public bytelist int size
bytes   new byte
realsize   0
public bytelist byte wrap
this wrap true
public bytelist byte wrap  boolean copy
if  wrap    null  throw new nullpointerexception
if copy
bytes   wrap clone
else
bytes   wrap
realsize   wrap length
public bytelist bytelist wrap
this wrap bytes  wrap begin  wrap realsize
public bytelist bytelist wrap  boolean copy
this wrap bytes  wrap begin  wrap realsize  false
public bytelist byte wrap  int index  int len
this wrap index len true
public bytelist byte wrap  int index  int len  boolean copy
if  wrap    null  throw new nullpointerexception
if copy    index    0
bytes   new byte
system arraycopy wrap  index  bytes  0  len
else
bytes   wrap
realsize   len
public bytelist bytelist wrap  int index  int len
this wrap bytes  wrap begin   index  len
private bytelist boolean flag
public void delete int start  int len
realsize  len
system arraycopy bytes start len bytes start realsize
public bytelist append byte b
grow 1
bytes   b
return this
public bytelist append int b
append  byte b
return this
public bytelist append inputstream input  int length  throws ioexception
grow length
int read   0
int n
while  read < length
n   input read bytes  begin   read  length   read
if  n     1
if read    0  throw new java io eofexception
break
read    n
realsize    read
return this
public void append bytebuffer buffer  int len
grow len
buffer get bytes  realsize  len
realsize    len
@override
public object clone
return dup
public bytelist dup
bytelist dup   dup realsize
dup validhash   validhash
dup hash   hash
dup stringvalue   stringvalue
return dup
/**
* @param length is the value of how big the buffer is going to be, not the actual length to copy
*
* it is used by rubystring.modify(int) to prevent cow pathological situations
* (namely to cow with having <code>length - realsize</code> bytes ahead)
*/
public bytelist dup int length
bytelist dup   new bytelist false
dup bytes   new byte
// use the smaller of the two sizes for the new real size, to allow truncating
int newrealsize   math min length  realsize
system arraycopy bytes  begin  dup bytes  0  newrealsize
dup realsize   newrealsize
dup begin   0
return dup
public void ensure int length
if  length >  bytes length
bytetmp   new byte
system arraycopy bytes  begin  tmp  0  realsize
bytes   tmp
public bytelist makeshared int index  int len
bytelist shared   new bytelist false
shared bytes   bytes
shared realsize   len
shared begin   begin   index
return shared
public void view int index  int len
realsize   len
begin   begin   index
public void unshare
unshare realsize
/**
* @param length is the value of how big the buffer is going to be, not the actual length to copy
*
* it is used by rubystring.modify(int) to prevent cow pathological situations
* (namely to cow with having <code>length - realsize</code> bytes ahead)
*/
public void unshare int length
byte tmp   new byte
system arraycopy bytes  begin  tmp  0  realsize
bytes   tmp
begin   0
public void invalidate
validhash   false
stringvalue   null
public void prepend byte b
grow 1
system arraycopy bytes  0  bytes  1  realsize
bytes   b
realsize
public void append byte morebytes
grow morebytes length
system arraycopy morebytes  0  bytes  realsize  morebytes length
realsize    morebytes length
public void append bytelist morebytes
append morebytes bytes  morebytes begin  morebytes realsize
public void append bytelist morebytes  int index  int len
append morebytes bytes  morebytes begin   index  len
public void append byte morebytes  int start  int len
grow len
system arraycopy morebytes  start  bytes  realsize  len
realsize    len
public void realloc int length
byte tmp   new byte
system arraycopy bytes  0  tmp  0  realsize
bytes   tmp
public int length
return realsize
public void length int newlength
grow newlength   realsize
realsize   newlength
public int get int index
if  index >  realsize  throw new indexoutofboundsexception
return bytes
public void set int index  int b
if  index >  realsize  throw new indexoutofboundsexception
bytes    byte b
public void replace byte newbytes
if  newbytes    null  throw new nullpointerexception
this bytes   newbytes
realsize   newbytes length
/**
* unsafe version of replace(int,int,bytelist). the contract is that these
* unsafe versions will not make sure thet beg and len indices are correct.
*/
public void unsafereplace int beg  int len  bytelist nbytes
unsafereplace beg  len  nbytes bytes  nbytes begin  nbytes realsize
/**
* unsafe version of replace(int,int,byte[]). the contract is that these
* unsafe versions will not make sure thet beg and len indices are correct.
*/
public void unsafereplace int beg  int len  byte buf
unsafereplace beg  len  buf  0  buf length
/**
* unsafe version of replace(int,int,byte[],int,int). the contract is that these
* unsafe versions will not make sure thet beg and len indices are correct.
*/
public void unsafereplace int beg  int len  byte nbytes  int index  int count
grow count   len
int newsize   realsize   count   len
system arraycopy bytes beg len bytes beg count realsize    len beg
system arraycopy nbytes index bytes beg count
realsize   newsize
public void replace int beg  int len  bytelist nbytes
replace beg  len  nbytes bytes  nbytes begin  nbytes realsize
public void replace int beg  int len  byte buf
replace beg  len  buf  0  buf length
public void replace int beg  int len  byte nbytes  int index  int count
if  len   beg > realsize  throw new indexoutofboundsexception
unsafereplace beg len nbytes index count
public void insert int index  int b
if  index >  realsize  throw new indexoutofboundsexception
grow 1
system arraycopy bytes index bytes index 1 realsize index
bytes    byte b
realsize
public int indexof int c
return indexof c  0
public int indexof final int c  int pos
// not sure if this is checked elsewhere,
// didn't see it in rubystring. rubystring does
// cast to char, so c will be >= 0.
if  c > 255
return  1
final byte b    byte  c 0xff
final int size   begin   realsize
final byte buf   bytes
pos    begin
for     pos < size    buf    b   pos
return pos < size ? pos   begin    1
public int indexof bytelist find
return indexof find  0
public int indexof bytelist find  int i
return indexof bytes  begin  realsize  find bytes  find begin  find realsize  i
static int indexof byte source  int sourceoffset  int sourcecount  byte target  int targetoffset  int targetcount  int fromindex
if  fromindex >  sourcecount  return  targetcount    0 ? sourcecount    1
if  fromindex < 0  fromindex   0
if  targetcount    0  return fromindex
byte first    target
int max   sourceoffset    sourcecount   targetcount
for  int i   sourceoffset   fromindex  i <  max  i
if  source    first  while    i <  max    source    first
if  i <  max
int j   i   1
int end   j   targetcount   1
for  int k   targetoffset   1  j < end    source    target  j    k
if  j    end  return i   sourceoffset
return  1
public int lastindexof int c
return lastindexof c  realsize   1
public int lastindexof final int c  int pos
// not sure if this is checked elsewhere,
// didn't see it in rubystring. rubystring does
// cast to char, so c will be >= 0.
if  c > 255
return  1
final byte b    byte  c 0xff
final int size   begin   realsize
pos    begin
final byte buf   bytes
if  pos >  size
pos   size
else
pos
for       pos >  begin    buf    b
return pos   begin
public int lastindexof bytelist find
return lastindexof find  realsize
public int lastindexof bytelist find  int pos
return lastindexof bytes  begin  realsize  find bytes  find begin  find realsize  pos
static int lastindexof byte source  int sourceoffset  int sourcecount  byte target  int targetoffset  int targetcount  int fromindex
int rightindex   sourcecount   targetcount
if  fromindex < 0  return  1
if  fromindex > rightindex  fromindex   rightindex
if  targetcount    0  return fromindex
int strlastindex   targetoffset   targetcount   1
byte strlastchar   target
int min   sourceoffset   targetcount   1
int i   min   fromindex
startsearchforlastchar
while  true
while  i >  min    source    strlastchar  i
if  i < min  return  1
int j   i   1
int start   j    targetcount   1
int k   strlastindex   1
while  j > start
if  source    target
i
continue startsearchforlastchar
return start   sourceoffset   1
public boolean startswith bytelist other  int toffset
byteta   bytes
int to   begin   toffset
bytepa   other bytes
int po   other begin
int pc   other realsize
while    pc >  0  if  ta    pa  return false
return true
public boolean startswith bytelist other
return startswith other  0
public boolean endswith bytelist other
return startswith other  realsize   other realsize
public boolean equals object other
if  other instanceof bytelist  return equal  bytelist other
return false
public boolean equal bytelist other
if  other    this  return true
if  validhash    other validhash    hash    other hash  return false
int first
int last
byte buf
if   last   realsize     other realsize
// scanning from front and back simultaneously, meeting in
// the middle. the object is to get a mismatch as quickly as
// possible. alternatives might be: scan from the middle outward
// (not great because it won't pick up common variations at the
// ends until late) or sample odd bytes forward and even bytes
// backward (i like this one, but it's more expensive for
// strings that are equal; see sample_equals below).
for  buf   bytes  first    1
last > first    buf    other bytes
first < last    buf    other bytes
return first >  last
return false
// an alternative to the new version of equals, should
// detect inequality faster (in many cases), but is slow
// in the case of equal values (all bytes visited), due to
// using n+=2, n-=2 vs. ++n, --n while iterating over the array.
public boolean sample_equals object other
if  other    this  return true
if  other instanceof bytelist
bytelist b    bytelist  other
int first
int last
int size
byte buf
if   size   realsize     b realsize
// scanning from front and back simultaneously, sampling odd
// bytes on the forward iteration and even bytes on the
// reverse iteration. the object is to get a mismatch as quickly
// as possible.
for  buf   bytes  first    1  last    size   1    ~1
last    2  >  0    buf    b bytes
first    2  < size    buf    b bytes
return last < 0    first    size
return false
/**
* this comparison matches mri comparison of strings (rb_str_cmp).
* i wish we had memcmp right now...
*/
public int compareto object other
return cmp  bytelist other
public int cmp final bytelist other
if  other    this  return 0
final int size   realsize
final int len    math min size  other realsize
int offset    1
// a bit of vm/jit weirdness here: though in most cases
// performance is improved if array references are kept in
// a local variable (saves an instruction per access, as i
// [slightly] understand it), in some cases, when two (or more?)
// arrays are being accessed, the member reference is actually
// faster.  this is one of those cases...
for        offset < len    bytes    other bytes
if  offset < len
return  bytes 0xff  >  other bytes 0xff  ? 1    1
return size    other realsize ? 0   size    len ?  1   1
private static final char casetable
/* ' '     '!'     '"'     '#'     '$'     '%'     '&'     ''' */
/* '('     ')'     '*'     '+'     ','     '-'     '.'     '/' */
/* '0'     '1'     '2'     '3'     '4'     '5'     '6'     '7' */
/* '8'     '9'     ':'     ';'     '<'     '='     '>'     '?' */
/* '@'     'a'     'b'     'c'     'd'     'e'     'f'     'g' */
/* 'h'     'i'     'j'     'k'     'l'     'm'     'n'     'o' */
/* 'p'     'q'     'r'     's'     't'     'u'     'v'     'w' */
/* 'x'     'y'     'z'     '['     '\'     ']'     '^'     '_' */
/* '`'     'a'     'b'     'c'     'd'     'e'     'f'     'g' */
/* 'h'     'i'     'j'     'k'     'l'     'm'     'n'     'o' */
/* 'p'     'q'     'r'     's'     't'     'u'     'v'     'w' */
/* 'x'     'y'     'z'     '{'     '|'     '}'     '~' */
public int caseinsensitivecmp final bytelist other
if  other    this  return 0
final int size   realsize
final int len    math min size  other realsize
final int other_begin   other begin
final byte other_bytes   other bytes
for  int offset    1    offset < len
char mycharignorecase   casetable 0xff]
char othercharignorecase   casetable 0xff]
if  mycharignorecase < othercharignorecase
return  1
else if  mycharignorecase > othercharignorecase
return 1
return size    other realsize ? 0   size    len ?  1   1
/**
* returns the internal byte array. this is unsafe unless you know what you're
* doing. but it can improve performance for byte-array operations that
* won't change the array.
*
* @return the internal byte array
*/
public byte unsafebytes
return bytes
public byte bytes
byte newbytes   new byte
system arraycopy bytes  begin  newbytes  0  realsize
return newbytes
public int begin
return begin
private void grow int increaserequested
if  increaserequested < 0
return
int newsize   realsize   increaserequested
if  bytes length < newsize
byte newbytes   new byte
if  bytes length    0  system arraycopy bytes  0  newbytes  0  realsize
bytes   newbytes
@override
public int hashcode
if  validhash  return hash
int key   0
int index   begin
final int end   begin   realsize
while  index < end
// equivalent of: key = key * 65599 + byte;
key     key << 16     key << 6    key     int  bytes        0xff ?
key   key    key >> 5
validhash   true
return hash   key
/**
* remembers tostring value, which is expensive for stringbuffer.
*
* @return an iso-8859-1 representation of the byte list
*/
@override
public string tostring
try
if  stringvalue    null  stringvalue   new string bytes  begin  realsize
return stringvalue
catch  unsupportedencodingexception uee
throw new runtimeexception
public static bytelist create charsequence s
return new bytelist plain s  false
public static byte plain charsequence s
if s instanceof string
try
return   string s  getbytes
catch exception e
//fallthrough
byte bytes   new byte
for  int i   0  i < bytes length  i
bytes    byte  s charat i
return bytes
public static byte plain char s
byte bytes   new byte
for  int i   0  i < s length  i
bytes    byte  s
return bytes
public static char plain byte b  int start  int length
char chars   new char
for  int i   0  i < length  i
chars    char   b   0xff
return chars
public static char plain byte b
char chars   new char
for  int i   0  i < b length  i
chars    char   b   0xff
return chars
public char charat int ix
return  char  this bytes   0xff
public charsequence subsequence int start  int end
return new bytelist this  start  end   start
public static int memcmp final byte first  final int firststart  final int firstlen  final byte second  final int secondstart  final int secondlen
if  first    second  return 0
final int len    math min firstlen secondlen
int offset    1
for        offset < len    first    second
if  offset < len
return  first 0xff  >  second 0xff  ? 1    1
return firstlen    secondlen ? 0   firstlen    len ?  1   1
public static int memcmp final byte first  final int firststart  final byte second  final int secondstart  final int len
if  first    second  return 0
int offset    1
for        offset < len    first    second
if  offset < len
return  first 0xff  >  second 0xff  ? 1    1
return 0