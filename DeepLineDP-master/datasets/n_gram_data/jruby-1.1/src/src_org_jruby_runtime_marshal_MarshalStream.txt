/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 ola bini <ola.bini@ki.se>
* copyright (c) 2007 william n dortch <bill.dortch@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby runtime marshal
import java io filteroutputstream
import java io ioexception
import java io outputstream
import java util iterator
import java util list
import java util map
import org jruby ruby
import org jruby rubyarray
import org jruby rubybignum
import org jruby rubyboolean
import org jruby rubyclass
import org jruby rubyfixnum
import org jruby rubyfloat
import org jruby rubyhash
import org jruby rubymodule
import org jruby rubyregexp
import org jruby rubystring
import org jruby rubystruct
import org jruby rubysymbol
import org jruby includedmodulewrapper
import org jruby runtime classindex
import org jruby runtime constants
import org jruby runtime builtin irubyobject
import org jruby runtime builtin variable
import org jruby util bytelist
import org jruby common irubywarnings id
import org jruby internal runtime methods dynamicmethod
/**
* marshals objects into ruby's binary marshal format.
*
* @author anders
*/
public class marshalstream extends filteroutputstream
private final ruby runtime
private final int depthlimit
private int depth   0
private marshalcache cache
private final static char type_ivar
private final static char type_usrmarshal
private final static char type_userdef
private final static char type_uclass
public marshalstream ruby runtime  outputstream out  int depthlimit  throws ioexception
super out
this runtime   runtime
this depthlimit   depthlimit >  0 ? depthlimit   integer max_value
this cache   new marshalcache
out write constants marshal_major
out write constants marshal_minor
public void dumpobject irubyobject value  throws ioexception
depth
if  depth > depthlimit
throw runtime newargumenterror
writeandregister value
depth
if  depth    0
out flush       flush afer whole dump is complete
public void registerlinktarget irubyobject newobject
if  shouldberegistered newobject
cache register newobject
static boolean shouldberegistered irubyobject value
if  value isnil
return false
else if  value instanceof rubyboolean
return false
else if  value instanceof rubyfixnum
return   ismarshalfixnum  rubyfixnum value
return true
private static boolean ismarshalfixnum rubyfixnum fixnum
return fixnum getlongvalue   <  rubyfixnum max_marshal_fixnum    fixnum getlongvalue   >  rubyfixnum min_marshal_fixnum
private void writeandregister irubyobject value  throws ioexception
if  cache isregistered value
cache writelink this  value
else
if  hasnewuserdefinedmarshaling value
usernewmarshal value
else if  hasuserdefinedmarshaling value
usermarshal value
else
writedirectly value
private list<variable<irubyobject>> getvariables irubyobject value  throws ioexception
list<variable<irubyobject>> variables   null
if  value instanceof coreobjecttype
int nativetypeindex     coreobjecttype value  getnativetypeindex
if  nativetypeindex    classindex object
if   value isimmediate      value hasvariables      nativetypeindex    classindex class
// object has instance vars and isn't a class, get a snapshot to be marshalled
// and output the ivar header here
variables   value getvariablelist
// write `i' instance var signet if class is not a direct subclass of object
write type_ivar
rubyclass type   value getmetaclass
switch nativetypeindex
case classindex string
case classindex regexp
case classindex array
case classindex hash
type   dumpextended type
break
if  nativetypeindex    value getmetaclass   index    nativetypeindex    classindex struct
// object is a custom class that extended one of the native types other than object
writeuserclass value  type
return variables
private void writedirectly irubyobject value  throws ioexception
list<variable<irubyobject>> variables   getvariables value
writeobjectdata value
if  variables    null
dumpvariables variables
public static string getpathfromclass rubymodule clazz
string path   clazz getname
if  path charat 0
string classormodule   clazz isclass   ?
throw clazz getruntime   newtypeerror     classormodule       path
rubymodule real   clazz ismodule   ? clazz     rubyclass clazz  getrealclass
if  clazz getruntime   getclassfrompath path     real
throw clazz getruntime   newtypeerror path
return path
private void writeobjectdata irubyobject value  throws ioexception
// switch on the object's *native type*. this allows use-defined
// classes that have extended core native types to piggyback on their
// marshalling logic.
if  value instanceof coreobjecttype
int nativetypeindex     coreobjecttype value  getnativetypeindex
switch  nativetypeindex
case classindex array
write
rubyarray marshalto  rubyarray value  this
return
case classindex false
write
return
case classindex fixnum
rubyfixnum fixnum    rubyfixnum value
if  ismarshalfixnum fixnum
write
writeint  int  fixnum getlongvalue
return
// fixme: inefficient; constructing a bignum just for dumping?
value   rubybignum newbignum value getruntime    fixnum getlongvalue
// fall through
case classindex bignum
write
rubybignum marshalto  rubybignum value  this
return
case classindex class
if    rubyclass value  issingleton    throw runtime newtypeerror
write
rubyclass marshalto  rubyclass value  this
return
case classindex float
write
rubyfloat marshalto  rubyfloat value  this
return
case classindex hash
rubyhash hash    rubyhash value
if hash getifnone   isnil
write
else if  hash hasdefaultproc
throw hash getruntime   newtypeerror
else
write
rubyhash marshalto hash  this
return
case classindex module
write
rubymodule marshalto  rubymodule value  this
return
case classindex nil
write
return
case classindex object
dumpdefaultobjectheader value getmetaclass
value getmetaclass   getrealclass   marshal value  this
return
case classindex regexp
write
rubyregexp marshalto  rubyregexp value  this
return
case classindex string
registerlinktarget value
write
writestring value converttostring   getbytelist
return
case classindex struct
//            write('s');
rubystruct marshalto  rubystruct value  this
return
case classindex symbol
registerlinktarget value
write
writestring value tostring
return
case classindex true
write
return
else
dumpdefaultobjectheader value getmetaclass
value getmetaclass   getrealclass   marshal value  this
private boolean hasnewuserdefinedmarshaling irubyobject value
return value respondsto
private void usernewmarshal irubyobject value  throws ioexception
registerlinktarget value
write type_usrmarshal
rubyclass metaclass   value getmetaclass   getrealclass
dumpobject rubysymbol newsymbol runtime  metaclass getname
irubyobject marshaled   value callmethod runtime getcurrentcontext
dumpobject marshaled
private boolean hasuserdefinedmarshaling irubyobject value
return value respondsto
private void usermarshal irubyobject value  throws ioexception
registerlinktarget value
irubyobject dumpresult   value callmethod runtime getcurrentcontext       runtime newfixnum depthlimit
if    dumpresult instanceof rubystring
throw runtime newtypeerror dumpresult  runtime getstring
rubystring marshaled    rubystring dumpresult
boolean hasvars
if  hasvars   marshaled hasvariables
write type_ivar
write type_userdef
rubyclass metaclass   value getmetaclass   getrealclass
dumpobject rubysymbol newsymbol runtime  metaclass getname
writestring marshaled getbytelist
if  hasvars
dumpvariables marshaled getvariablelist
public void writeuserclass irubyobject obj  rubyclass type  throws ioexception
write type_uclass
// w_unique
if  type getname   charat 0
throw obj getruntime   newtypeerror     type getname
// w_symbol
dumpobject runtime newsymbol type getname
/**
* @deprecated superseded by {@link #dumpvariables()}
*/
public void dumpinstancevars map instancevars  throws ioexception
runtime getwarnings   warn id deprecated_method
writeint instancevars size
for  iterator iter   instancevars keyset   iterator    iter hasnext
string name    string  iter next
irubyobject value    irubyobject instancevars get name
writeandregister runtime newsymbol name
dumpobject value
public void dumpvariables list<variable<irubyobject>> vars  throws ioexception
writeint vars size
for  variable<irubyobject> var   vars
writeandregister runtime newsymbol var getname
dumpobject var getvalue
private boolean hassingletonmethods rubyclass type
for iterator iter   type getmethods   entryset   iterator    iter hasnext
map entry entry    map entry  iter next
dynamicmethod method    dynamicmethod  entry getvalue
// we do not want to capture cached methods
if method getimplementationclass      type
return true
return false
/** w_extended
*
*/
private rubyclass dumpextended rubyclass type  throws ioexception
if type issingleton
if  hassingletonmethods type     type hasvariables         any ivars  since we don't have __attached__ ivar now
throw type getruntime   newtypeerror
type   type getsuperclass
while type isincluded
write
dumpobject rubysymbol newsymbol runtime    includedmodulewrapper type  getnonincludedclass   getname
type   type getsuperclass
return type
public void dumpdefaultobjectheader rubyclass type  throws ioexception
dumpdefaultobjectheader   type
public void dumpdefaultobjectheader char tp  rubyclass type  throws ioexception
dumpextended type
write tp
rubysymbol classname   rubysymbol newsymbol runtime  getpathfromclass type getrealclass
dumpobject classname
public void writestring string value  throws ioexception
writeint value length
out write rubystring stringtobytes value
public void writestring bytelist value  throws ioexception
int len   value length
writeint len
out write value unsafebytes    value begin    len
public void dumpsymbol string value  throws ioexception
write
writeint value length
out write rubystring stringtobytes value
public void writeint int value  throws ioexception
if  value    0
out write 0
else if  0 < value    value < 123
out write value   5
else if   124 < value    value < 0
out write  value   5    0xff
else
byte buf   new byte
int i   0
for    i < buf length  i
buf    byte  value   0xff
value   value >> 8
if  value    0    value     1
break
int len   i   1
out write value < 0 ?  len   len
out write buf  0  i   1