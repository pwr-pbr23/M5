package org jruby runtime scope
import org jruby parser blockstaticscope
import org jruby parser staticscope
import org jruby runtime dynamicscope
import org jruby runtime builtin irubyobject
/**
* represents the the dynamic portion of scoping information.  the variablevalues are the
* values of assigned local or block variables.  the staticscope identifies which sort of
* scope this is (block or local).
*
* properties of dynamic scopes:
* 1. static and dynamic scopes have the same number of names to values
* 2. size of variables (and thus names) is determined during parsing.  so those structured do
*    not need to change
*
* fixme: when creating dynamic scopes we sometimes accidentally pass in extra parents.  this
* is harmless (other than wasting memory), but we should not do that.  we can fix this in two
* ways:
* 1. fix all callers
* 2. check parent that is passed in and make if new instance is local, then its parent is not local
*/
public class novarsdynamicscope extends dynamicscope
public novarsdynamicscope staticscope staticscope  dynamicscope parent
super staticscope  parent
public novarsdynamicscope staticscope staticscope
super staticscope
public void growifneeded
assert staticscope getnumberofvariables      0
public dynamicscope clonescope
return new novarsdynamicscope staticscope  parent
public irubyobject getvalues
return irubyobject null_array
/**
* get value from current scope or one of its captured scopes.
*
* fixme: block variables are not getting primed to nil so we need to null check those
*  until we prime them properly.  also add assert back in.
*
* @param offset zero-indexed value that represents where variable lives
* @param depth how many captured scopes down this variable should be set
* @return the value here
*/
public irubyobject getvalue int offset  int depth
return parent getvalue offset  depth   1
/**
* variation of getvalue that checks for nulls, returning and setting the given value (presumably nil)
*/
public irubyobject getvalueornil int offset  int depth  irubyobject nil
return parent getvalueornil offset  depth   1  nil
public irubyobject getvaluedepthzeroornil int offset  irubyobject nil
assert false
return null
public irubyobject getvaluezerodepthzeroornil irubyobject nil
assert false
return null
public irubyobject getvalueonedepthzeroornil irubyobject nil
assert false
return null
/**
* set value in current dynamic scope or one of its captured scopes.
*
* @param offset zero-indexed value that represents where variable lives
* @param value to set
* @param depth how many captured scopes down this variable should be set
*/
public void setvalue int offset  irubyobject value  int depth
parent setvalue offset  value  depth   1
public void setvaluedepthzero irubyobject value  int offset
throw new runtimeexception
public void setvaluezerodepthzero irubyobject value
assert false
public void setvalueonedepthzero irubyobject value
assert false
/**
* set all values which represent 'normal' parameters in a call list to this dynamic
* scope.  function calls bind to local scopes by assuming that the indexes or the
* arg list correspond to that of the local scope (plus 2 since $_ and $~ always take
* the first two slots).  we pass in a second argument because we sometimes get more
* values than we are expecting.  the rest get compacted by original caller into
* rest args.
*
* @param values up to size specified to be mapped as ordinary parm values
* @param size is the number of values to assign as ordinary parm values
*/
public void setargvalues irubyobject values  int size
assert size    0
@override
public irubyobject getargvalues
// if we're not the "argument scope" for zsuper, try our parent
if   staticscope isargumentscope
return parent getargvalues
int totalargs   staticscope getrequiredargs     staticscope getoptionalargs
assert totalargs    0
return irubyobject null_array
@override
public string tostring stringbuffer buf  string indent
buf append indent  append     hashcode
staticscope instanceof blockstaticscope ?
if  parent    null
buf append
parent tostring buf  indent
return buf tostring