package org jruby ast executable
import org jruby ruby
import org jruby rubybignum
import org jruby rubyfixnum
import org jruby rubyhash
import org jruby rubymodule
import org jruby rubystring
import org jruby metaclass
import org jruby rubysymbol
import org jruby parser staticscope
import org jruby parser localstaticscope
import org jruby runtime callsite
import org jruby runtime calltype
import org jruby runtime dynamicscope
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
import org jruby common irubywarnings id
import org jruby internal runtime methods yarvmethod
import org jruby internal runtime methods wrappermethod
import org jruby javasupport util runtimehelpers
import org jruby runtime methodindex
public class yarvmachine
private static final boolean tailcall_opt   boolean getboolean
public static final yarvmachine instance   new yarvmachine
public static int instruction string name
return yarvinstructions instruction name
}
public static class instructionsequence
public string magic
public int major
public int minor
public int format_type
public object misc
public string name
public string filename
public object line
public string type
public string locals
public int args_argc
public int args_arg_opts
public string args_opt_labels
public int args_rest
public int args_block
public object exception
public instruction body
public instructionsequence ruby runtime  string name  string file  string type
magic
major   1
minor   1
format_type   1
misc   runtime getnil
this name   name
this filename   file
this line   new object
this type   type
this locals   new string
this args_argc   0
this args_arg_opts   0
this exception   new object
}
}
public static class instruction
public int bytecode
public int line_no
public string s_op0
public irubyobject o_op0
public object _tmp
public long l_op0
public long l_op1
public int i_op1
public instructionsequence iseq_op
public instruction ins_op
public int i_op3
public int index
public int methodindex    1
public callsite calladapter
public instruction int bytecode
this bytecode   bytecode
}
public instruction int bytecode  string op
this bytecode   bytecode
this s_op0   op intern
}
public instruction int bytecode  string op  instructionsequence op1
this bytecode   bytecode
this s_op0   op intern
this iseq_op   op1
}
public instruction int bytecode  long op
this bytecode   bytecode
this l_op0   op
}
public instruction int bytecode  irubyobject op
this bytecode   bytecode
this o_op0   op
}
public instruction int bytecode  string op  int op1  instruction op2  int op3
this bytecode   bytecode
this s_op0   op
this i_op1   op1
this ins_op   op2
this i_op3   op3
}
public string tostring
return     yarvinstructions name bytecode
s_op0    null ? s_op0    o_op0    null ? o_op0 tostring          l_op0
}
}
irubyobject stack   new irubyobject
int stacktop   0
/*
private void printstack(string message, int fromindex) {
system.out.println("(" + message + ") stack:");
for (int i = fromindex; i < stacktop; i++) {
system.out.println("" + i + ": " + (stack[i] == null ? "null" : stack[i].inspect().tostring()));
}
}*/
/**
* push a value onto the stack
*
* @param value to be pushed
*/
private void push irubyobject value
//system.out.println("push(" + value.inspect() + ")");
stack   value
stacktop
}
/**
* swap top two values in the stack
*/
private void swap
stack   stack
stack   stack
stack   stack
}
/**
* duplicate top 'n' values in the stack
*
* @param length
*/
private void dupn int length
system arraycopy stack  stacktop   length  stack  stacktop  length
stacktop    length
}
/**
* peek at top value in the stack
*
* @return the top value
*/
private irubyobject peek
return stack
}
/**
* pop top value in the stack
*
* @return the top value
*/
private irubyobject pop
//system.out.println("pop(" + stack[stacktop-1].inspect() + ")");
return stack
}
/**
* pop top arr.length values into supplied arr.
*
* @param arr to be populated from the stack
* @return the array passed in
*/
private irubyobject poparray irubyobject arr
stacktop    arr length
system arraycopy stack  stacktop  arr  0  arr length
/*
system.out.print("poparray:");
for (int i = 0; i < arr.length; i++) {
system.out.print(" " + arr[0].inspect());
}
system.out.println("");
*/
return arr
}
/**
* set the nth stack value to value
* @param depth nth index of stack
* @param value to be set
*/
private void setn int depth  irubyobject value
stack   value
}
/**
* push nth stack value
*
* @param depth which element to push
*/
private void topn int depth
push stack
}
/**
* set/replace top stack value with value
*
* @param value to replace current stack value
*/
public void set irubyobject value
stack   value
}
public void unimplemented int bytecode
system err println     yarvinstructions name bytecode
}
/**
* top-level exec into yarv machine.
*
* @param context thread that is executing this machine (note: we need to make n machines with
*   each belonging to an individual context)
* @param scope of exec (evals will sometimes pass in something interesting)
* @param bytecodes to be executed
* @return last value pop'd of machine stack
*/
public irubyobject exec threadcontext context  staticscope scope  instruction bytecodes
try
irubyobject self   context getruntime   getobject
context prescopedbody dynamicscope newdynamicscope scope
return exec context  self  bytecodes
finally
context postscopedbody
}
}
public irubyobject exec threadcontext context  irubyobject self  instruction bytecodes
ruby runtime   context getruntime
// where this frames stack begins.
int stackstart   stacktop
int ip   0
irubyobject other
yarvloop  while  ip < bytecodes length
//system.err.println("executing: " + yarvinstructions.name(bytecodes[ip].bytecode));
switch  bytecodes bytecode
case yarvinstructions nop
break
case yarvinstructions getglobal
push runtime getglobalvariables   get bytecodes s_op0
break
case yarvinstructions setglobal
runtime getglobalvariables   set bytecodes s_op0  pop
break
case yarvinstructions getlocal
push context getcurrentscope   getvalue  int  bytecodes l_op0  0
break
case yarvinstructions setlocal
context getcurrentscope   setvalue  int  bytecodes l_op0  pop    0
break
case yarvinstructions getinstancevariable
push self getinstancevariables   fastgetinstancevariable bytecodes s_op0
break
case yarvinstructions setinstancevariable
self getinstancevariables   fastsetinstancevariable bytecodes s_op0  pop
break
case yarvinstructions getclassvariable
rubymodule rubyclass   context getrubyclass
string name   bytecodes s_op0
if  rubyclass    null
push self getmetaclass   fastgetclassvar name
else if   rubyclass issingleton
push rubyclass fastgetclassvar name
else
rubymodule module    rubymodule    metaclass rubyclass  getattached
if  module    null
push module fastgetclassvar name
else
push runtime getnil
}
}
break
}
case yarvinstructions setclassvariable
rubymodule rubyclass   context getcurrentscope   getstaticscope   getmodule
if  rubyclass    null
rubyclass   self getmetaclass
else if  rubyclass issingleton
rubyclass    rubymodule    metaclass rubyclass  getattached
}
rubyclass fastsetclassvar bytecodes s_op0  pop
break
}
case yarvinstructions getconstant
push context getconstant bytecodes s_op0
break
case yarvinstructions setconstant
rubymodule module   context getcurrentscope   getstaticscope   getmodule
module fastsetconstant bytecodes s_op0  pop
runtime incglobalstate
break
case yarvinstructions putnil
push context getruntime   getnil
break
case yarvinstructions putself
push self
break
case yarvinstructions putobject
//system.out.println("putobject: " + bytecodes[ip].o_op0);
push bytecodes o_op0
break
case yarvinstructions putstring
push context getruntime   newstring bytecodes s_op0
break
case yarvinstructions concatstrings
stringbuffer concatter   new stringbuffer
for  int i   0  i < bytecodes l_op0  i
concatter append pop   tostring
}
push runtime newstring concatter tostring
break
}
case yarvinstructions tostring
irubyobject top   peek
if    top instanceof rubystring
set top callmethod context  methodindex to_s
}
break
case yarvinstructions newarray
push runtime newarraynocopy poparray new irubyobject l_op0]
break
case yarvinstructions duparray
push bytecodes o_op0 dup
break
case yarvinstructions newhash
int hsize    int bytecodes l_op0
rubyhash h   rubyhash newhash runtime
irubyobject v k
for int i   hsize  i>0  i    2
v   pop
k   pop
h op_aset context  k  v
}
push h
break
case yarvinstructions putnot
push peek   istrue   ? runtime getfalse     runtime gettrue
break
case yarvinstructions pop
pop
break
case yarvinstructions dup
push peek
break
case yarvinstructions dupn
dupn  int  bytecodes l_op0
break
case yarvinstructions swap
swap
break
case yarvinstructions topn
topn  int  bytecodes l_op0
break
case yarvinstructions setn
setn  int  bytecodes l_op0  peek
break
case yarvinstructions emptstack
stacktop   stackstart
break
case yarvinstructions definemethod
rubymodule containingclass   context getrubyclass
if  containingclass    null
throw runtime newtypeerror
}
string mname   bytecodes iseq_op name
if  containingclass    runtime getobject      mname
runtime getwarnings   warn id redefining_dangerous
}
visibility visibility   context getcurrentvisibility
if  mname         visibility    visibility module_function
visibility   visibility private
}
if  containingclass issingleton
irubyobject attachedobject     metaclass  containingclass  getattached
if  attachedobject instanceof rubyfixnum    attachedobject instanceof rubysymbol
throw runtime newtypeerror  "
mname     for "   attachedobject gettype
}
}
staticscope sco   new localstaticscope null
sco setvariables bytecodes iseq_op locals
yarvmethod newmethod   new yarvmethod containingclass  bytecodes iseq_op  sco  visibility
containingclass addmethod mname  newmethod
if  context getcurrentvisibility      visibility module_function
rubymodule singleton   containingclass getsingletonclass
singleton addmethod mname  new wrappermethod singleton  newmethod  visibility public
containingclass callmethod context     runtime fastnewsymbol mname
}
// 'class << state.self' and 'class << obj' uses defn as opposed to defs
if  containingclass issingleton
metaclass  containingclass  getattached   callmethod context
runtime fastnewsymbol mname
else
containingclass callmethod context     runtime fastnewsymbol mname
}
push runtime getnil
runtime incglobalstate
break
case yarvinstructions send
ip   send runtime  context  self  bytecodes  stackstart  ip
break
}
case yarvinstructions leave
break yarvloop
case yarvinstructions jump
ip    int  bytecodes l_op0
continue yarvloop
case yarvinstructions branchif
ip   pop   istrue   ?  int  bytecodes l_op0   ip   1
continue yarvloop
case yarvinstructions branchunless
ip    pop   istrue   ?  int  bytecodes l_op0   ip   1
continue yarvloop
}
case yarvinstructions getinlinecache
if bytecodes l_op1    runtime getglobalstate
push bytecodes o_op0
ip    int  bytecodes l_op0
continue yarvloop
}
break
case yarvinstructions onceinlinecache
if bytecodes l_op1 > 0
push bytecodes o_op0
ip    int  bytecodes l_op0
continue yarvloop
}
break
case yarvinstructions setinlinecache
int we    int bytecodes l_op0
bytecodes o_op0   peek
bytecodes l_op1   runtime getglobalstate
break
case yarvinstructions opt_plus
op_plus runtime  context  pop    pop
break
case yarvinstructions opt_minus
op_minus runtime  context  pop    pop
break
case yarvinstructions opt_mult
other   pop
push pop   callmethod context methodindex op_times     other
break
case yarvinstructions opt_div
other   pop
push pop   callmethod context     other
break
case yarvinstructions opt_mod
other   pop
push pop   callmethod context   other
break
case yarvinstructions opt_eq
other   pop
push pop   callmethod context methodindex equalequal     other
break
case yarvinstructions opt_lt
op_lt runtime  context  pop    pop
break
case yarvinstructions opt_le
other   pop
push pop   callmethod context methodindex op_le     other
break
case yarvinstructions opt_ltlt
other   pop
push pop   callmethod context methodindex op_lshift     other
break
case yarvinstructions opt_aref
other   pop
push pop   callmethod context methodindex aref    other
break
case yarvinstructions opt_aset
//yarv will never emit this, for some reason.
irubyobject value   pop
other   pop
push runtimehelpers invoke context  pop    methodindex aset    new irubyobject other value
break
}
case yarvinstructions opt_length
push pop   callmethod context
break
case yarvinstructions opt_succ
push pop   callmethod context
break
case yarvinstructions opt_regexpmatch1
push bytecodes o_op0 callmethod context     peek
break
case yarvinstructions opt_regexpmatch2
other   pop
push pop   callmethod context     other
break
case yarvinstructions answer
push runtime newfixnum 42
break
case yarvinstructions getspecial
case yarvinstructions setspecial
case yarvinstructions getdynamic
case yarvinstructions setdynamic
case yarvinstructions putundef
// ko1 said this is going away
case yarvinstructions toregexp
case yarvinstructions newrange
case yarvinstructions reput
case yarvinstructions opt_case_dispatch
case yarvinstructions opt_checkenv
case yarvinstructions expandarray
// masgn array to values
case yarvinstructions concatarray
case yarvinstructions splatarray
case yarvinstructions checkincludearray
case yarvinstructions alias
case yarvinstructions undef
case yarvinstructions defined
case yarvinstructions postexe
case yarvinstructions trace
case yarvinstructions defineclass
case yarvinstructions invokesuper
case yarvinstructions invokeblock
case yarvinstructions finish
case yarvinstructions throw
case yarvinstructions opt_call_native_compiled
case yarvinstructions bitblt
case yarvinstructions getlocal_op_2  case yarvinstructions getlocal_op_3
case yarvinstructions getlocal_op_4  case yarvinstructions setlocal_op_2
case yarvinstructions setlocal_op_3  case yarvinstructions setlocal_op_4
case yarvinstructions getdynamic_op__wc__0
case yarvinstructions getdynamic_op_1_0  case yarvinstructions getdynamic_op_2_0
case yarvinstructions getdynamic_op_3_0  case yarvinstructions getdynamic_op_4_0
case yarvinstructions setdynamic_op__wc__0
case yarvinstructions setdynamic_op_1_0  case yarvinstructions setdynamic_op_2_0
case yarvinstructions setdynamic_op_3_0  case yarvinstructions setdynamic_op_4_0
case yarvinstructions putobject_op_int2fix_0_0_c_
case yarvinstructions putobject_op_int2fix_0_1_c_
case yarvinstructions putobject_op_qtrue  case yarvinstructions putobject_op_qfalse
case yarvinstructions send_op__wc___wc__qfalse_0__wc_
case yarvinstructions send_op__wc__0_qfalse_0__wc_
case yarvinstructions send_op__wc__1_qfalse_0__wc_
case yarvinstructions send_op__wc__2_qfalse_0__wc_
case yarvinstructions send_op__wc__3_qfalse_0__wc_
case yarvinstructions send_op__wc___wc__qfalse_0x04__wc_
case yarvinstructions send_op__wc__0_qfalse_0x04__wc_
case yarvinstructions send_op__wc__1_qfalse_0x04__wc_
case yarvinstructions send_op__wc__2_qfalse_0x04__wc_
case yarvinstructions send_op__wc__3_qfalse_0x04__wc_
case yarvinstructions send_op__wc__0_qfalse_0x0c__wc_
case yarvinstructions unified_putobject_putobject
case yarvinstructions unified_putobject_putstring
case yarvinstructions unified_putobject_setlocal
case yarvinstructions unified_putobject_setdynamic
case yarvinstructions unified_putstring_putstring
case yarvinstructions unified_putstring_putobject
case yarvinstructions unified_putstring_setlocal
case yarvinstructions unified_putstring_setdynamic
case yarvinstructions unified_dup_setlocal
case yarvinstructions unified_getlocal_getlocal
case yarvinstructions unified_getlocal_putobject
unimplemented bytecodes bytecode
break
}
ip
}
return pop
}
private void op_plus ruby runtime  threadcontext context  irubyobject other  irubyobject receiver
if  other instanceof rubyfixnum    receiver instanceof rubyfixnum
long receivervalue     rubyfixnum  receiver  getlongvalue
long othervalue     rubyfixnum  other  getlongvalue
long result   receivervalue   othervalue
if   ~ receivervalue ^ othervalue     receivervalue ^ result    rubyfixnum sign_bit     0
push rubybignum newbignum runtime  receivervalue  op_plus context  other
}
push runtime newfixnum result
else
push receiver callmethod context  methodindex op_plus     other
}
}
private void op_minus ruby runtime  threadcontext context  irubyobject other  irubyobject receiver
if  other instanceof rubyfixnum    receiver instanceof rubyfixnum
long receivervalue     rubyfixnum  receiver  getlongvalue
long othervalue     rubyfixnum  other  getlongvalue
long result   receivervalue   othervalue
if   ~ receivervalue ^ othervalue     receivervalue ^ result    rubyfixnum sign_bit     0
push rubybignum newbignum runtime  receivervalue  op_minus context  other
}
push runtime newfixnum result
else
push receiver callmethod context  methodindex op_minus     other
}
}
private void op_lt ruby runtime  threadcontext context  irubyobject other  irubyobject receiver
if  other instanceof rubyfixnum    receiver instanceof rubyfixnum
long receivervalue     rubyfixnum  receiver  getlongvalue
long othervalue     rubyfixnum  other  getlongvalue
push runtime newboolean receivervalue < othervalue
else
push receiver callmethod context  methodindex op_lt     other
}
}
private int send ruby runtime  threadcontext context  irubyobject self  instruction bytecodes  int stackstart  int ip
instruction instruction   bytecodes
string name   instruction s_op0
int size   instruction i_op1
int flags   instruction i_op3
// enebo: we need to define a yarvblock
//instruction[] blockbytecodes = bytecodes[ip].ins_op;
// todo: block stuff
irubyobject args
if  size    0
args   irubyobject null_array
else
args   new irubyobject
poparray args
}
// fcalls and vcalls use a nil as a place holder, but this is just extra stack
// traffic.  also extra flag activity (tiny perf-wise).  i would think three
// send instructions makes more sense...
irubyobject recv
calltype calltype
if   flags   yarvinstructions vcall_flag     0
if   flags   yarvinstructions fcall_flag     0
recv   pop
calltype   calltype normal
else
pop
recv   self
calltype   calltype functional
}
else
pop
recv   self
calltype   calltype variable
}
if  instruction calladapter    null
instruction calladapter   new callsite inlinecachingcallsite name intern    calltype
}
if  tailcall_opt     bytecodes bytecode    yarvinstructions leave
flags   yarvinstructions tailcall_flag     yarvinstructions tailcall_flag
recv    self    name equals context getframename
stacktop   stackstart
ip    1
for int i 0 i<args length i
context getcurrentscope   getvalues     args
}
else
push instruction calladapter call context  recv  args
//push(recv.callmethod(context, name, args, calltype));
}
return ip
}
}