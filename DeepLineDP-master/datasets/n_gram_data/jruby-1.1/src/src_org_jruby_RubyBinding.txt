/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2001 chad fowler <chadfowler@chadfowler.com>
* copyright (c) 2001 alan moore <alan_moore@gmx.net>
* copyright (c) 2001-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2005 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2005 charles o nutter <headius@headius.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby
import org jruby anno jrubymethod
import org jruby runtime binding
import org jruby runtime frame
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
/**
* @author  jpetersen
*/
public class rubybinding extends rubyobject
private binding binding
public rubybinding ruby runtime  rubyclass rubyclass  binding binding
super runtime  rubyclass
this binding   binding
private rubybinding ruby runtime  rubyclass rubyclass
super runtime  rubyclass
private static objectallocator binding_allocator   new objectallocator
public irubyobject allocate ruby runtime  rubyclass klass
rubybinding instance   new rubybinding runtime  klass
return instance
public static rubyclass createbindingclass ruby runtime
rubyclass bindingclass   runtime defineclass    runtime getobject    binding_allocator
runtime setbinding bindingclass
return bindingclass
public binding getbinding
return binding
// proc class
public static rubybinding newbinding ruby runtime  binding binding
return new rubybinding runtime  runtime getbinding    binding
public static rubybinding newbinding ruby runtime
threadcontext context   runtime getcurrentcontext
// fixme: we should be cloning, not reusing: frame, scope, dynvars, and potentially iter/block info
frame frame   context getcurrentframe
binding binding   new binding frame  context getbindingrubyclass    context getcurrentscope
return new rubybinding runtime  runtime getbinding    binding
/**
* create a binding appropriate for a bare "eval", by using the previous (caller's) frame and current
* scope.
*/
public static rubybinding newbindingforeval ruby runtime
threadcontext context   runtime getcurrentcontext
// this requires some explaining.  we use frame values when executing blocks to fill in
// various values in threadcontext and evalstate.eval like rubyclass, cref, and self.
// largely, for an eval that is using the logical binding at a place where the eval is
// called we mostly want to use the current frames value for this.  most importantly,
// we need that self (jruby-858) at this point.  we also need to make sure that returns
// jump to the right place (which happens to be the previous frame).  lastly, we do not
// want the current frames klazz since that will be the klazz represented of self.  we
// want the class right before the eval (well we could use cref class for this too i think).
// once we end up having frames created earlier i think the logic of stuff like this will
// be better since we won't be worried about setting frame to setup other variables/stacks
// but just making sure frame itself is correct...
frame previousframe   context getpreviousframe
frame currentframe   context getcurrentframe
currentframe setklazz previousframe getklazz
// set jump target to whatever the previoustarget thinks is good.
currentframe setjumptarget previousframe getjumptarget      null ? previousframe getjumptarget     previousframe
binding binding   new binding previousframe  context getbindingrubyclass    context getcurrentscope
//binding.createbinding(previousframe, context.getcurrentscope());
return new rubybinding runtime  runtime getbinding    binding
@jrubymethod name      visibility   visibility private
public irubyobject initialize threadcontext context
// fixme: we should be cloning, not reusing: frame, scope, dynvars, and potentially iter/block info
frame frame   context getcurrentframe
binding   new binding frame  context getbindingrubyclass    context getcurrentscope
return this
@jrubymethod name      required   1  visibility   visibility private
@override
public irubyobject initialize_copy irubyobject other
rubybinding otherbinding    rubybinding other
binding   otherbinding binding
return this