package org jruby runtime scope
import org jruby rubyarray
import org jruby evaluator astinterpreter
import org jruby parser blockstaticscope
import org jruby parser staticscope
import org jruby runtime dynamicscope
import org jruby runtime builtin irubyobject
/**
* represents the the dynamic portion of scoping information.  the variablevalues are the
* values of assigned local or block variables.  the staticscope identifies which sort of
* scope this is (block or local).
*
* properties of dynamic scopes:
* 1. static and dynamic scopes have the same number of names to values
* 2. size of variables (and thus names) is determined during parsing.  so those structured do
*    not need to change
*
* fixme: when creating dynamic scopes we sometimes accidentally pass in extra parents.  this
* is harmless (other than wasting memory), but we should not do that.  we can fix this in two
* ways:
* 1. fix all callers
* 2. check parent that is passed in and make if new instance is local, then its parent is not local
*/
public class twovardynamicscope extends dynamicscope
private irubyobject variablevaluezero
private irubyobject variablevalueone
public twovardynamicscope staticscope staticscope  dynamicscope parent
super staticscope  parent
public twovardynamicscope staticscope staticscope
super staticscope
public void growifneeded
if  staticscope getnumberofvariables      2
throw new runtimeexception
public dynamicscope clonescope
return new twovardynamicscope staticscope  parent
public irubyobject getvalues
return new irubyobject  variablevaluezero  variablevalueone
/**
* get value from current scope or one of its captured scopes.
*
* fixme: block variables are not getting primed to nil so we need to null check those
*  until we prime them properly.  also add assert back in.
*
* @param offset zero-indexed value that represents where variable lives
* @param depth how many captured scopes down this variable should be set
* @return the value here
*/
public irubyobject getvalue int offset  int depth
if  depth > 0
return parent getvalue offset  depth   1
assert offset < 2
switch  offset
case 0
return variablevaluezero
case 1
return variablevalueone
default
throw new runtimeexception
/**
* variation of getvalue that checks for nulls, returning and setting the given value (presumably nil)
*/
public irubyobject getvalueornil int offset  int depth  irubyobject nil
if  depth > 0
return parent getvalueornil offset  depth   1  nil
else
return getvaluedepthzeroornil offset  nil
public irubyobject getvaluedepthzeroornil int offset  irubyobject nil
assert offset < 2
switch  offset
case 0
if  variablevaluezero    null  return variablevaluezero   nil
return variablevaluezero
case 1
if  variablevalueone    null  return variablevalueone   nil
return variablevalueone
default
throw new runtimeexception
public irubyobject getvaluezerodepthzeroornil irubyobject nil
if  variablevaluezero    null  return variablevaluezero   nil
return variablevaluezero
public irubyobject getvalueonedepthzeroornil irubyobject nil
if  variablevalueone    null  return variablevalueone   nil
return variablevalueone
/**
* set value in current dynamic scope or one of its captured scopes.
*
* @param offset zero-indexed value that represents where variable lives
* @param value to set
* @param depth how many captured scopes down this variable should be set
*/
public void setvalue int offset  irubyobject value  int depth
if  depth > 0
assert parent    null
parent setvalue offset  value  depth   1
else
assert offset < 2
switch  offset
case 0
variablevaluezero   value
case 1
variablevalueone   value
default
throw new runtimeexception
public void setvaluedepthzero irubyobject value  int offset
assert offset < 2
switch  offset
case 0
variablevaluezero   value
case 1
variablevalueone   value
default
throw new runtimeexception
public void setvaluezerodepthzero irubyobject value
variablevaluezero   value
public void setvalueonedepthzero irubyobject value
variablevalueone   value
/**
* set all values which represent 'normal' parameters in a call list to this dynamic
* scope.  function calls bind to local scopes by assuming that the indexes or the
* arg list correspond to that of the local scope (plus 2 since $_ and $~ always take
* the first two slots).  we pass in a second argument because we sometimes get more
* values than we are expecting.  the rest get compacted by original caller into
* rest args.
*
* @param values up to size specified to be mapped as ordinary parm values
* @param size is the number of values to assign as ordinary parm values
*/
public void setargvalues irubyobject values  int size
assert values length    2
variablevaluezero   values
variablevaluezero   values
@override
public irubyobject getargvalues
// if we're not the "argument scope" for zsuper, try our parent
if   staticscope isargumentscope
return parent getargvalues
int totalargs   staticscope getrequiredargs     staticscope getoptionalargs
assert totalargs <  2
// copy and splat arguments out of the scope to use for zsuper call
if  staticscope getrestarg   < 0
if  totalargs    1
return new irubyobject  variablevaluezero  variablevalueone
else
return irubyobject null_array
else
// rest arg must be splatted
irubyobject restarg   getvalue staticscope getrestarg    0
assert restarg    null
// fixme: not very efficient
rubyarray splattedargs   astinterpreter splatvalue restarg getruntime    restarg
irubyobject argvalues   new irubyobject
system arraycopy splattedargs tojavaarray    0  argvalues  totalargs  splattedargs size
return argvalues
@override
public string tostring stringbuffer buf  string indent
buf append indent  append     hashcode
staticscope instanceof blockstaticscope ?
string names   staticscope getvariables
buf append names  append
if  variablevaluezero    null
buf append
else
buf append variablevaluezero
buf append
if  variablevalueone    null
buf append
else
buf append variablevalueone
buf append
if  parent    null
buf append
parent tostring buf  indent
return buf tostring