/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2008 the jruby community <www.jruby.org>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util io
import java io eofexception
import java io ioexception
import java io inputstream
import java io outputstream
import org jruby util bytelist
/**
*/
public interface stream
public static final int seek_set   0
public static final int seek_cur   1
public static final int seek_end   2
// we use a highly uncommon string to represent the paragraph delimiter (100% soln not worth it)
public static final bytelist paragraph_delimeter   bytelist create
public static final bytelist paragraph_separator   bytelist create
public channeldescriptor getdescriptor
public void clearerr
public modeflags getmodes
public boolean issync
public void setsync boolean sync
public abstract bytelist fgets bytelist separatorstring  throws ioexception  baddescriptorexception  eofexception
public abstract bytelist readall   throws ioexception  baddescriptorexception  eofexception
// todo: we overflow on large files...we could increase to long to limit
// this, but then the impl gets more involved since java io apis based on
// int (means we have to chunk up a long into a series of int ops).
public abstract bytelist fread int number  throws ioexception  baddescriptorexception  eofexception
public abstract int fwrite bytelist string  throws ioexception  baddescriptorexception
public abstract int fgetc   throws ioexception  baddescriptorexception  eofexception
public abstract int ungetc int c
public abstract void fputc int c  throws ioexception  baddescriptorexception
public abstract bytelist read int number  throws ioexception  baddescriptorexception  eofexception
public abstract void fclose   throws ioexception  baddescriptorexception
public abstract int fflush   throws ioexception  baddescriptorexception
/**
* <p>flush and sync all writes to the filesystem.</p>
*
* @throws ioexception if the sync does not work
*/
public void sync   throws ioexception  baddescriptorexception
/**
* <p>return true when at end of file (eof).</p>
*
* @return true if at eof; false otherwise
* @throws ioexception
* @throws baddescriptorexception
*/
public boolean feof   throws ioexception  baddescriptorexception
/**
* <p>get the current position within the file associated with this
* handler.</p>
*
* @return the current position in the file.
* @throws ioexception
* @throws pipeexception espipe (illegal seek) when not a file
*
*/
public long fgetpos   throws ioexception  pipeexception  baddescriptorexception  invalidvalueexception
/**
* <p>perform a seek based on pos().  </p>
* @throws ioexception
* @throws pipeexception
* @throws invalidvalueexception
*/
public void lseek long offset  int type  throws ioexception  invalidvalueexception  pipeexception  baddescriptorexception
public void ftruncate long newlength  throws ioexception  pipeexception  baddescriptorexception
/**
* implement io#ready? as per io/wait in mri.
* returns non-nil if input available without blocking, or nil.
*/
public int ready   throws ioexception
/**
* implement io#wait as per io/wait in mri.
* waits until input available or timed out and returns self, or nil when eof reached.
*
* the default implementation loops while ready returns 0.
*/
public void waituntilready   throws ioexception  interruptedexception
public boolean readdatabuffered
public boolean writedatabuffered
public inputstream newinputstream
public outputstream newoutputstream
public boolean isblocking
public void setblocking boolean blocking  throws ioexception
public void freopen string path  modeflags modes  throws directoryasfileexception  ioexception  invalidvalueexception  pipeexception  baddescriptorexception