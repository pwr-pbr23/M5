/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2003-2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2005 derek berner <derek.berner@state.nm.us>
* copyright (c) 2006 evan buswell <ebuswell@gmail.com>
* copyright (c) 2007 nick sieger <nicksieger@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util
import java math biginteger
import java nio bytebuffer
import java nio byteorder
import org joni encoding specific utf8encoding
import org joni encoding unicode unicodeencoding
import org jruby ruby
import org jruby rubyarray
import org jruby rubybignum
import org jruby rubyfloat
import org jruby rubykernel
import org jruby rubynumeric
import org jruby rubystring
import org jruby runtime builtin irubyobject
public class pack
private static final string ssp10
private static final string snil10
private static final int is_star    1
/** native pack type.
**/
private static final string native_codes
private static final string stoofew
private static final byte hex_table
private static final byte uu_table
private static final byte b64_table
private static final byte shexdigits
private static final int b64_xtable   new int
private static final converter converters   new converter
private static final biginteger quad_min   biginteger valueof long min_value
private static final biginteger quad_max   new biginteger    16
/*
* convert into longs, returning unsigned 64-bit values as signed longs
* ( num2long raises a rangeerror on values > long.max_value )
*/
private static long num2quad irubyobject arg
if  arg    arg getruntime   getnil
return 0l
else if  arg instanceof rubybignum
biginteger big     rubybignum arg  getvalue
if  big compareto quad_min  < 0    big compareto quad_max  > 0
throw arg getruntime   newrangeerror
return big longvalue
return rubynumeric num2long arg
static
hex_table   bytelist plain
uu_table
bytelist plain  #$% '        0123456789  < >?@abcdefghijklmnopqrstuvwxyz^_"
b64_table
bytelist plain
shexdigits   bytelist plain
// b64_xtable for decoding base 64
for  int i   0  i < 256  i
b64_xtable    1
for  int i   0  i < 64  i
b64_xtable]   i
// short, little-endian (network)
converters   new converter 2
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum
decodeshortunsignedlittleendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
int s   o    runtime getnil   ? 0    int   rubynumeric num2long o    0xffff
encodeshortlittleendian result  s
// single precision, little-endian
converters   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return rubyfloat newfloat runtime  decodefloatlittleendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
float f   o    runtime getnil   ? 0    float  rubykernel new_float o o  converttofloat   getdoublevalue
encodefloatlittleendian result  f
converter tmp   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return rubyfloat newfloat runtime  decodefloatbigendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
float f   o    runtime getnil   ? 0    float  rubykernel new_float o o  converttofloat   getdoublevalue
encodefloatbigendian result  f
converters   tmp     single precision  native
converters   tmp     single precision  native
converters   tmp     single precision  native
// double precision, little-endian
converters   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
return rubyfloat newfloat runtime  decodedoublelittleendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
double d   o    runtime getnil   ? 0   rubykernel new_float o o  converttofloat   getdoublevalue
encodedoublelittleendian result  d
tmp   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
return rubyfloat newfloat runtime  decodedoublebigendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
double d   o    runtime getnil   ? 0   rubykernel new_float o o  converttofloat   getdoublevalue
encodedoublebigendian result  d
converters   tmp     double precision native
converters   tmp     double precision native
converters   tmp     double precision bigendian
converters   new converter 2       signed short
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum decodeshortbigendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
int s
if  o    runtime getnil
s   0
else
long l   rubynumeric num2long o
// mri 1.8 behavior:
if  l    long min_value    math abs l  > 0xffffffffl
throw runtime newrangeerror
s    int  l   0xffff
encodeshortbigendian result  s
tmp   new converter 2
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum
decodeshortunsignedbigendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
int s   o    runtime getnil   ? 0    int   rubynumeric num2long o    0xffff
encodeshortbigendian result  s
converters   tmp     unsigned short
converters   tmp     short network
converters   new converter 1       signed char
public irubyobject decode ruby runtime  bytebuffer enc
int c   enc get
return runtime newfixnum c >  char  127 ? c 256   c
public void encode ruby runtime  irubyobject o  stringbuffer result
char c   o    runtime getnil   ? 0    char   rubynumeric num2long o    0xff
result append c
converters   new converter 1       unsigned char
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum enc get     0xff
public void encode ruby runtime  irubyobject o  stringbuffer result
char c   o    runtime getnil   ? 0    char   rubynumeric num2long o    0xff
result append c
// long, little-endian
converters   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum
decodeintunsignedlittleendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
int s   o    runtime getnil   ? 0    int  rubynumeric num2long o
encodeintlittleendian result  s
tmp   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum
decodeintunsignedbigendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
int s   o    runtime getnil   ? 0    int  rubynumeric num2long o
encodeintbigendian result  s
converters   tmp     unsigned int  native
converters   tmp     unsigned long  bugs?
converters   tmp     long  network
tmp   new converter 4
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum decodeintbigendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
int s
if  o    runtime getnil
s   0
else
long l   rubynumeric num2long o
// mri 1.8 behavior:
if  l    long min_value    math abs l  > 0xffffffffl
throw runtime newrangeerror
s    int l
encodeintbigendian result  s
converters   tmp     long  native
converters   tmp     int  native
tmp   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
long l   decodelongbigendian enc
return rubybignum bignorm runtime biginteger valueof l  and
new biginteger    16
public void encode ruby runtime  irubyobject o  stringbuffer result
long l   num2quad o
encodelongbigendian result  l
converters   tmp
tmp   new converter 8
public irubyobject decode ruby runtime  bytebuffer enc
return runtime newfixnum decodelongbigendian enc
public void encode ruby runtime  irubyobject o  stringbuffer result
long l   num2quad o
encodelongbigendian result  l
converters   tmp
/**
* encodes a string in base64 or its uuencode variant.
* appends the result of the encoding in a stringbuffer
* @param io2append the stringbuffer which should receive the result
* @param i2encode the string to encode
* @param ilength the max number of characters to encode
* @param itype the type of encoding required (this is the same type as used by the pack method)
* @return the io2append buffer
**/
private static stringbuffer encodes ruby runtime  stringbuffer io2append char charstoencode int startindex int charcount char encodingtype
charcount   charcount <  charstoencode length startindex  ? charcount
charstoencode length startindex
io2append ensurecapacity charcount   4   3   6
int i   startindex
byte ltranslationtable   encodingtype      ? uu_table   b64_table
char lpadding
if  encodingtype
if  charcount >  ltranslationtable length
throw runtime newargumenterror
charcount
ltranslationtable length
io2append append  char ltranslationtable
lpadding
else
lpadding
while  charcount >  3
char lcurchar   charstoencode
char lnextchar   charstoencode
char lnextnextchar   charstoencode
io2append append  char ltranslationtable
io2append append  char ltranslationtable
io2append append  char ltranslationtable
io2append append  char ltranslationtable
charcount    3
if  charcount    2
char lcurchar   charstoencode
char lnextchar   charstoencode
io2append append  char ltranslationtable
io2append append  char ltranslationtable
io2append append  char ltranslationtable
io2append append lpadding
else if  charcount    1
char lcurchar   charstoencode
io2append append  char ltranslationtable
io2append append  char ltranslationtable
io2append append lpadding
io2append append lpadding
io2append append
return io2append
/**
* encodes a string with the quoted printable, mime encoding (see rfc2045).
* appends the result of the encoding in a stringbuffer
* @param io2append the stringbuffer which should receive the result
* @param i2encode the string to encode
* @param ilength the max number of characters to encode
* @return the io2append buffer
**/
private static stringbuffer qpencode stringbuffer io2append  string i2encode  int ilength
io2append ensurecapacity 1024
int lcurlinelength   0
int lprevchar    1
char l2encode   i2encode tochararray
try
for  int i   0   i
char lcurchar   l2encode
if  lcurchar > 126     lcurchar < 32    lcurchar         lcurchar          lcurchar
io2append append
io2append append  char hex_table
io2append append  char hex_table
lcurlinelength    3
lprevchar    1
else if  lcurchar
if  lprevchar         lprevchar
io2append append
io2append append lcurchar
io2append append lcurchar
lcurlinelength   0
lprevchar   lcurchar
else
io2append append lcurchar
lcurlinelength
lprevchar   lcurchar
if  lcurlinelength > ilength
io2append append
io2append append
lcurlinelength   0
lprevchar
catch  arrayindexoutofboundsexception e
//normal exit, this should be faster than a test at each iterations for string with more than
//about 40 char
if  lcurlinelength > 0
io2append append
io2append append
return io2append
/**
*    decodes <i>str</i> (which may contain binary data) according to the format
*       string, returning an array of each value extracted.
*       the format string consists of a sequence of single-character directives.<br/>
*       each directive may be followed by a number, indicating the number of times to repeat with this directive.  an asterisk (``<code>*</code>'') will use up all
*       remaining elements.  <br/>
*       the directives <code>ssiill</code> may each be followed by an underscore (``<code>_</code>'') to use the underlying platform's native size for the specified type; otherwise, it uses a platform-independent consistent size.  <br/>
*       spaces are ignored in the format string.
*           @see rubyarray#pack
*       <table border="2" width="500" bgcolor="#ffe0e0">
*           <tr>
*             <td>
* <p></p>
*         <b>directives for <a href="ref_c_string.html#string.unpack">
*                   <code>string#unpack</code>
*                 </a>
*               </b>        <table class="codebox" cellspacing="0" border="0" cellpadding="3">
* <tr bgcolor="#ff9999">
*   <td valign="top">
*                     <b>format</b>
*                   </td>
*   <td valign="top">
*                     <b>function</b>
*                   </td>
*   <td valign="top">
*                     <b>returns</b>
*                   </td>
* </tr>
* <tr>
*   <td valign="top">a</td>
*   <td valign="top">string with trailing nulls and spaces removed.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">a</td>
*   <td valign="top">string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">b</td>
*   <td valign="top">extract bits from each character (msb first).</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">b</td>
*   <td valign="top">extract bits from each character (lsb first).</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">c</td>
*   <td valign="top">extract a character as an unsigned integer.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">c</td>
*   <td valign="top">extract a character as an integer.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">d</td>
*   <td valign="top">treat <em>sizeof(double)</em> characters as a native
*           double.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">e</td>
*   <td valign="top">treat <em>sizeof(double)</em> characters as a double in
*           little-endian byte order.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">e</td>
*   <td valign="top">treat <em>sizeof(float)</em> characters as a float in
*           little-endian byte order.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">f</td>
*   <td valign="top">treat <em>sizeof(float)</em> characters as a native float.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">g</td>
*   <td valign="top">treat <em>sizeof(double)</em> characters as a double in
*           network byte order.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">g</td>
*   <td valign="top">treat <em>sizeof(float)</em> characters as a float in
*           network byte order.</td>
*   <td valign="top">float</td>
* </tr>
* <tr>
*   <td valign="top">h</td>
*   <td valign="top">extract hex nibbles from each character (most
*           significant first).</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">h</td>
*   <td valign="top">extract hex nibbles from each character (least
*           significant first).</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">i</td>
*   <td valign="top">treat <em>sizeof(int)</em>
*                     <sup>1</sup> successive
*           characters as an unsigned native integer.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">i</td>
*   <td valign="top">treat <em>sizeof(int)</em>
*                     <sup>1</sup> successive
*           characters as a signed native integer.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">l</td>
*   <td valign="top">treat four<sup>1</sup> successive
*           characters as an unsigned native
*           long integer.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">l</td>
*   <td valign="top">treat four<sup>1</sup> successive
*           characters as a signed native
*           long integer.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">m</td>
*   <td valign="top">extract a quoted-printable string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">m</td>
*   <td valign="top">extract a base64 encoded string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">n</td>
*   <td valign="top">treat four characters as an unsigned long in network
*           byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">n</td>
*   <td valign="top">treat two characters as an unsigned short in network
*           byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">p</td>
*   <td valign="top">treat <em>sizeof(char *)</em> characters as a pointer, and
*           return <em>len</em> characters from the referenced location.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">p</td>
*   <td valign="top">treat <em>sizeof(char *)</em> characters as a pointer to a
*           null-terminated string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">s</td>
*   <td valign="top">treat two<sup>1</sup> successive characters as an unsigned
*           short in
*           native byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">s</td>
*   <td valign="top">treat two<sup>1</sup> successive
*           characters as a signed short in
*           native byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">u</td>
*   <td valign="top">extract utf-8 characters as unsigned integers.</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">u</td>
*   <td valign="top">extract a uu-encoded string.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">v</td>
*   <td valign="top">treat four characters as an unsigned long in little-endian
*           byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">v</td>
*   <td valign="top">treat two characters as an unsigned short in little-endian
*           byte order.</td>
*   <td valign="top">fixnum</td>
* </tr>
* <tr>
*   <td valign="top">x</td>
*   <td valign="top">skip backward one character.</td>
*   <td valign="top">---</td>
* </tr>
* <tr>
*   <td valign="top">x</td>
*   <td valign="top">skip forward one character.</td>
*   <td valign="top">---</td>
* </tr>
* <tr>
*   <td valign="top">z</td>
*   <td valign="top">string with trailing nulls removed.</td>
*   <td valign="top">string</td>
* </tr>
* <tr>
*   <td valign="top">@</td>
*   <td valign="top">skip to the offset given by the length argument.</td>
*   <td valign="top">---</td>
* </tr>
* <tr>
*                   <td colspan="9" bgcolor="#ff9999" height="2"><img src="dot.gif" width="1" height="1"></td>
*                 </tr>
*               </table>
* <p></p>
*         <sup>1</sup>&nbsp;may be modified by appending ``_'' to the directive.
* <p></p>
*       </td>
*           </tr>
*         </table>
*
**/
public static rubyarray unpack ruby runtime  bytelist encodedstring
bytelist formatstring
rubyarray result   runtime newarray
// fixme: potentially could just use bytelist here?
bytebuffer format   bytebuffer wrap formatstring unsafebytes    formatstring begin    formatstring length
bytebuffer encode   bytebuffer wrap encodedstring unsafebytes    encodedstring begin    encodedstring length
int type   0
int next   safeget format
while  next    0
type   next
next   safeget format
// next indicates to decode using native encoding format
if  next         next
if  native_codes indexof type      1
throw runtime newargumenterror     next
native_codes
next   safeget format
// how many occurrences of 'type' we want
int occurrences   0
if  next    0
occurrences   1
else
if  next
occurrences   is_star
next   safeget format
else if  character isdigit  char  next   0xff
occurrences   0
do
occurrences   occurrences   10   character digit  char  next   0xff   10
next   safeget format
while  next    0    character isdigit  char  next   0xff
else
occurrences   type      ? 0   1
// see if we have a converter for the job...
converter converter   converters
if  converter    null
decode runtime  encode  occurrences  result  converter
type   next
continue
// otherwise the unpack should be here...
switch  type
case
try
if  occurrences    is_star
encode position encode remaining
else
encode position occurrences
catch  illegalargumentexception iae
throw runtime newargumenterror
break
case
throw runtime newargumenterror
case
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
byte potential   new byte
encode get potential
for  int t   occurrences   1  occurrences > 0  occurrences    t
byte c   potential
if  c         c
break
result append rubystring newstring runtime  new bytelist potential  0  occurrences false
break
case
boolean isstar    occurrences    is_star
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
byte potential   new byte
int t   0
while  t < occurrences
byte b   encode get
if  b    0
break
potential   b
t
result append rubystring newstring runtime
new bytelist potential  0  t   false
// in case when the number of occurences is
// explicitly specified, we have to read up
// the remaining garbage after the '\0' to
// satisfy the requested pattern.
if   isstar
if  t < occurrences
// we encountered '\0' when
// were reading the buffer above,
// increment the number of read bytes.
t
while  t < occurrences
encode get
t
break
case
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
byte potential   new byte
encode get potential
result append rubystring newstring runtime  new bytelist potential false
break
case
if  occurrences    is_star    occurrences > encode remaining     8
occurrences   encode remaining     8
int bits   0
byte lelem   new byte
for  int lcurbyte   0  lcurbyte < occurrences  lcurbyte
if   lcurbyte   7     0
bits >>>  1
else
bits   encode get
lelem    bits   1     0 ?  byte      byte
result append rubystring newstring runtime  new bytelist lelem false
break
case
if  occurrences    is_star    occurrences > encode remaining     8
occurrences   encode remaining     8
int bits   0
byte lelem   new byte
for  int lcurbyte   0  lcurbyte < occurrences  lcurbyte
if   lcurbyte   7     0
bits <<  1
else
bits   encode get
lelem    bits   128     0 ?  byte      byte
result append rubystring newstring runtime  new bytelist lelem false
break
case
if  occurrences    is_star    occurrences > encode remaining     2
occurrences   encode remaining     2
int bits   0
byte lelem   new byte
for  int lcurbyte   0  lcurbyte < occurrences  lcurbyte
if   lcurbyte   1     0
bits >>>  4
else
bits   encode get
lelem   shexdigits
result append rubystring newstring runtime  new bytelist lelem false
break
case
if  occurrences    is_star    occurrences > encode remaining     2
occurrences   encode remaining     2
int bits   0
byte lelem   new byte
for  int lcurbyte   0  lcurbyte < occurrences  lcurbyte
if   lcurbyte   1     0
bits <<  4
else
bits   encode get
lelem   shexdigits
result append rubystring newstring runtime  new bytelist lelem false
break
case
int length   encode remaining     3   4
byte lelem   new byte
int index   0
int s
int total   0
s   encode get
while  encode hasremaining      s >      s <
int a  b  c  d
byte hunk   new byte
int len    s        077
s   safeget encode
total    len
if  total > length
len    total   length
total   length
while  len > 0
int mlen   len > 3 ? 3   len
if  encode hasremaining      s >
a    s        077
s   safeget encode
else
a   0
if  encode hasremaining      s >
b    s        077
s   safeget encode
else
b   0
if  encode hasremaining      s >
c    s        077
s   safeget encode
else
c   0
if  encode hasremaining      s >
d    s        077
s   safeget encode
else
d   0
hunk    byte   a << 2   b >> 4    255
hunk    byte   b << 4   c >> 2    255
hunk    byte   c << 6   d    255
for  int i   0  i < mlen  i    lelem   hunk
len    mlen
if  s
s   safeget encode
if  s
s   safeget encode
else if  encode hasremaining
if  safeget encode
safeget encode      possible checksum byte
else if  encode hasremaining
encode position encode position     1
result append rubystring newstring runtime  new bytelist lelem  0  index false
break
case
int length   encode remaining   3 4
byte lelem   new byte
int a    1  b    1  c   0  d
int index   0
int s    1
while  encode hasremaining
a   b   c   d    1
// obtain a
s   safeget encode
while    a   b64_xtable      1     encode hasremaining
s   safeget encode
if  a     1  break
// obtain b
s   safeget encode
while    b   b64_xtable      1     encode hasremaining
s   safeget encode
if  b     1  break
// obtain c
s   safeget encode
while    c   b64_xtable      1     encode hasremaining
if  s       break
s   safeget encode
if   s          c     1
if  s
encode position encode position     1
break
// obtain d
s   safeget encode
while    d   b64_xtable      1     encode hasremaining
if  s       break
s   safeget encode
if   s          d     1
if  s
encode position encode position     1
break
// calculate based on a, b, c and d
lelem    byte   a << 2   b >> 4    255
lelem    byte   b << 4   c >> 2    255
lelem    byte   c << 6   d    255
if  a     1    b     1
if  c     1    s
lelem    byte   a << 2   b >> 4    255
else if c     1    s
lelem    byte   a << 2   b >> 4    255
lelem    byte   b << 4   c >> 2    255
result append rubystring newstring runtime  new bytelist lelem  0  index false
break
case
byte lelem   new byte
int index   0
for
if   encode hasremaining    break
byte c   safeget encode
if  c
lelem   c
else
if   encode hasremaining    break
encode mark
byte c1   safeget encode
if  c1       continue
int d1   character digit  char  c1   0xff   16
if  d1     1
encode reset
break
encode mark
if   encode hasremaining    break
byte c2   safeget encode
int d2   character digit  char  c2   0xff   16
if  d2     1
encode reset
break
byte value    byte  d1 << 4   d2
lelem   value
result append rubystring newstring runtime  new bytelist lelem  0  index false
break
case
if  occurrences    is_star    occurrences > encode remaining
occurrences   encode remaining
while  occurrences   > 0    encode remaining   > 0
try
// todo: for now, we use a faithful
// reimplementation of mri's algorithm,
// but should use utf8encoding facilities
// from joni, once it starts prefroming
// utf-8 content validation.
result append
runtime newfixnum utf8decode encode
catch  illegalargumentexception e
throw runtime newargumenterror e getmessage
break
case
if  occurrences    is_star
// mri behavior: contrary to what seems to be logical,
// when '*' is given, mri calculates the distance
// to the end, in order to go backwards.
occurrences     encode limit       encode remaining
try
encode position encode position     occurrences
catch  illegalargumentexception e
throw runtime newargumenterror
break
case
if  occurrences    is_star
occurrences   encode remaining
try
encode position encode position     occurrences
catch  illegalargumentexception e
throw runtime newargumenterror
break
return result
/** utf8_to_uv
*/
private static int utf8decode bytebuffer buffer
int c   buffer get     0xff
int uv   c
int n
if   c   0x80     0
return c
if   c   0x40     0
throw new illegalargumentexception
if        uv   0x20     0    n   2  uv    0x1f
else if   uv   0x10     0    n   3  uv    0x0f
else if   uv   0x08     0    n   4  uv    0x07
else if   uv   0x04     0    n   5  uv    0x03
else if   uv   0x02     0    n   6  uv    0x01
else
throw new illegalargumentexception
if  n > buffer remaining     1
throw new illegalargumentexception
n
buffer remaining     1
int limit   n   1
n
if  n    0
while  n      0
c   buffer get     0xff
if   c   0xc0     0x80
throw new illegalargumentexception
else
c    0x3f
uv   uv << 6   c
if  uv < utf8_limits
throw new illegalargumentexception
return uv
private static final long utf8_limits
0x0                            1
0x80                           2
0x800                          3
0x10000                        4
0x200000                       5
0x4000000                      6
0x80000000                     7
private static byte safeget bytebuffer encode
return encode hasremaining   ? encode get     0
public static void decode ruby runtime  bytebuffer encode  int occurrences
rubyarray result  converter converter
int lpadlength   0
if  occurrences    is_star
occurrences   encode remaining     converter size
else if  occurrences > encode remaining     converter size
lpadlength   occurrences   encode remaining     converter size
occurrences   encode remaining     converter size
for    occurrences   > 0
result append converter decode runtime  encode
// mri behavior:  for 'q', do not add trailing nils
if  converter    converters
for    lpadlength   > 0
result append runtime getnil
public static int encode ruby runtime  int occurrences  stringbuffer result
rubyarray list  int index  converter converter
int listsize   list size
while  occurrences   > 0
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal index
converter encode runtime  from  result
return index
public abstract static class converter
public int size
public converter int size
this size   size
public abstract irubyobject decode ruby runtime  bytebuffer format
public abstract void encode ruby runtime  irubyobject from
stringbuffer result
static class ptrlist
private byte buffer     list to be managed
private int index     pointer location in list
public ptrlist byte bufferstring
buffer   bufferstring
index   0
/**
* @return the number of elements between pointer and end of list
*/
public int remaining
return buffer length   index
/**
* <p>get substring from current point of desired length and advance
* pointer.</p>
*
* @param length of substring
* @return the substring
*/
public string nextsubstring int length
// cannot get substring off end of buffer
if  index   length > buffer length
throw new illegalargumentexception
string substring   null
substring   new string bytelist plain buffer  index  length
index    length
return substring
public void setposition int position
if  position < buffer length
index   position
/**
* @return numerical representation of ascii number at ptr
*/
public int nextasciinumber
int i   index
for    i < buffer length  i
if   character isdigit  char  buffer   0xff
break
// an exception will occur if no number is at ptr....
int number   0
integer parseint new string bytelist plain buffer  index  i   index
// an exception may occur here if an int can't hold this but ...
index   i
return number
/**
* @return length of list
*/
public int getlength
return buffer length
/**
* @return char at the pointer (advancing the pointer) or '\0' if at end.
*
* note: the pointer gets advanced one past last character to indicate
* that the whole buffer has been read.
*/
public int nextbyte
byte next   0
if  index < buffer length
next   buffer
else if  index    buffer length
index
return next   0xff
/**
* <p>backup the pointer occurrences times.</p>
*
* @throws illegalargumentexception if it backs up past beginning
* of buffer
*/
public void backup int occurrences
index    occurrences
if  index < 0
throw new illegalargumentexception
/**
* @return true if index is at end of the buffer
*/
public boolean isatend
return index > buffer length
/**
* @return the current pointer location in buffer
*/
public int getindex
return index
/**
* shrinks a stringbuffer.
* shrinks a stringbuffer by a number of characters.
* @param i2shrink the stringbuffer
* @param ilength how much to shrink
* @return the stringbuffer
**/
private static final stringbuffer shrink stringbuffer i2shrink  int ilength
ilength   i2shrink length     ilength
if  ilength < 0
throw new illegalargumentexception
i2shrink setlength ilength
return i2shrink
/**
* grows a stringbuffer.
* uses the strings to pad the buffer for a certain length
* @param i2grow the buffer to grow
* @param ipads the string used as padding
* @param ilength how much padding is needed
* @return the padded buffer
**/
private static final stringbuffer grow stringbuffer i2grow  string ipads  int ilength
int lpadlength   ipads length
while  ilength >  lpadlength
i2grow append ipads
ilength    lpadlength
i2grow append ipads substring 0  ilength
return i2grow
/**
* pack_pack
*
* template characters for array#pack directive  meaning
*              <table class="codebox" cellspacing="0" border="0" cellpadding="3">
* <tr bgcolor="#ff9999">
*   <td valign="top">
*                     <b>directive</b>
*                   </td>
*   <td valign="top">
*                     <b>meaning</b>
*                   </td>
* </tr>
* <tr>
*   <td valign="top">@</td>
*   <td valign="top">moves to absolute position</td>
* </tr>
* <tr>
*   <td valign="top">a</td>
*   <td valign="top">ascii string (space padded, count is width)</td>
* </tr>
* <tr>
*   <td valign="top">a</td>
*   <td valign="top">ascii string (null padded, count is width)</td>
* </tr>
* <tr>
*   <td valign="top">b</td>
*   <td valign="top">bit string (descending bit order)</td>
* </tr>
* <tr>
*   <td valign="top">b</td>
*   <td valign="top">bit string (ascending bit order)</td>
* </tr>
* <tr>
*   <td valign="top">c</td>
*   <td valign="top">unsigned char</td>
* </tr>
* <tr>
*   <td valign="top">c</td>
*   <td valign="top">char</td>
* </tr>
* <tr>
*   <td valign="top">d</td>
*   <td valign="top">double-precision float, native format</td>
* </tr>
* <tr>
*   <td valign="top">e</td>
*   <td valign="top">double-precision float, little-endian byte order</td>
* </tr>
* <tr>
*   <td valign="top">e</td>
*   <td valign="top">single-precision float, little-endian byte order</td>
* </tr>
* <tr>
*   <td valign="top">f</td>
*   <td valign="top">single-precision float, native format</td>
* </tr>
* <tr>
*   <td valign="top">g</td>
*   <td valign="top">double-precision float, network (big-endian) byte order</td>
* </tr>
* <tr>
*   <td valign="top">g</td>
*   <td valign="top">single-precision float, network (big-endian) byte order</td>
* </tr>
* <tr>
*   <td valign="top">h</td>
*   <td valign="top">hex string (high nibble first)</td>
* </tr>
* <tr>
*   <td valign="top">h</td>
*   <td valign="top">hex string (low nibble first)</td>
* </tr>
* <tr>
*   <td valign="top">i</td>
*   <td valign="top">unsigned integer</td>
* </tr>
* <tr>
*   <td valign="top">i</td>
*   <td valign="top">integer</td>
* </tr>
* <tr>
*   <td valign="top">l</td>
*   <td valign="top">unsigned long</td>
* </tr>
* <tr>
*   <td valign="top">l</td>
*   <td valign="top">long</td>
* </tr>
* <tr>
*   <td valign="top">m</td>
*   <td valign="top">quoted printable, mime encoding (see rfc2045)</td>
* </tr>
* <tr>
*   <td valign="top">m</td>
*   <td valign="top">base64 encoded string</td>
* </tr>
* <tr>
*   <td valign="top">n</td>
*   <td valign="top">long, network (big-endian) byte order</td>
* </tr>
* <tr>
*   <td valign="top">n</td>
*   <td valign="top">short, network (big-endian) byte-order</td>
* </tr>
* <tr>
*   <td valign="top">p</td>
*   <td valign="top">pointer to a structure (fixed-length string)</td>
* </tr>
* <tr>
*   <td valign="top">p</td>
*   <td valign="top">pointer to a null-terminated string</td>
* </tr>
* <tr>
*   <td valign="top">q</td>
*   <td valign="top">unsigned 64-bit number</td>
* </tr>
* <tr>
*   <td valign="top">q</td>
*   <td valign="top">64-bit number</td>
* </tr>
* <tr>
*   <td valign="top">s</td>
*   <td valign="top">unsigned short</td>
* </tr>
* <tr>
*   <td valign="top">s</td>
*   <td valign="top">short</td>
* </tr>
* <tr>
*   <td valign="top">u</td>
*   <td valign="top">utf-8</td>
* </tr>
* <tr>
*   <td valign="top">u</td>
*   <td valign="top">uu-encoded string</td>
* </tr>
* <tr>
*   <td valign="top">v</td>
*   <td valign="top">long, little-endian byte order</td>
* </tr>
* <tr>
*   <td valign="top">v</td>
*   <td valign="top">short, little-endian byte order</td>
* </tr>
* <tr>
*   <td valign="top">x</td>
*   <td valign="top">back up a byte</td>
* </tr>
* <tr>
*   <td valign="top">x</td>
*   <td valign="top">null byte</td>
* </tr>
* <tr>
*   <td valign="top">z</td>
*   <td valign="top">same as ``a''</td>
* </tr>
* <tr>
*                   <td colspan="9" bgcolor="#ff9999" height="2"><img src="dot.gif" width="1" height="1"></td>
*                 </tr>
*               </table>
*
*
* packs the contents of arr into a binary sequence according to the directives in
* atemplatestring (see preceding table).
* directives ``a,'' ``a,'' and ``z'' may be followed by a count, which gives the
* width of the resulting field.
* the remaining directives also may take a count, indicating the number of array
* elements to convert.
* if the count is an asterisk (``*''] = all remaining array elements will be
* converted.
* any of the directives ``ssiill'' may be followed by an underscore (``_'') to use
* the underlying platform's native size for the specified type; otherwise, they
* use a platform-independent size. spaces are ignored in the template string.
* @see rubystring#unpack
**/
@suppresswarnings
public static rubystring pack ruby runtime  rubyarray list  bytelist formatstring
bytebuffer format   bytebuffer wrap formatstring unsafebytes    formatstring begin    formatstring length
stringbuffer result   new stringbuffer
int listsize   list size
int type   0
int next   safeget format
int idx   0
string lcurelemstring
mainloop  while  next    0
type   next
next   safeget format
// skip all whitespace in pack format string
while  character iswhitespace  char  type 0xff
if  next    0  break mainloop
type   next
next   safeget format
// skip embedded comments in pack format string
if  type
while  type
if  next    0  break mainloop
type   next
next   safeget format
if  next         next
if  native_codes indexof type      1
throw runtime newargumenterror     next
native_codes
next   safeget format
// determine how many of type are needed (default: 1)
int occurrences   1
boolean isstar   false
if  next    0
if  next
if    indexof type      1
occurrences   0
else
occurrences   listsize
isstar   true
next   safeget format
else if  character isdigit  char  next   0xff
occurrences   0
do
occurrences   occurrences   10   character digit  char  next   0xff   10
next   safeget format
while  next    0    character isdigit  char  next   0xff
converter converter   converters
if  converter    null
idx   encode runtime  occurrences  result  list  idx  converter
continue
switch  type
case
throw runtime newargumenterror
case
case
case
case
case
case
case
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
lcurelemstring   from    runtime getnil   ?     from converttostring   tostring
if  isstar
occurrences   lcurelemstring length
// 'z' adds extra null pad (versus 'a')
if  type       occurrences
switch  type
case
case
case
if  lcurelemstring length   >  occurrences
result append lcurelemstring tochararray    0  occurrences
else    need padding
//i'm fairly sure there is a library call to create a
//string filled with a given char with a given length but i couldn't find it
result append lcurelemstring
occurrences    lcurelemstring length
switch  type
case
case
grow result  snil10  occurrences
break
default
grow result  ssp10  occurrences
break
break
case
int currentbyte   0
int padlength   0
if  occurrences > lcurelemstring length
padlength    occurrences   lcurelemstring length      2   occurrences % 2
occurrences   lcurelemstring length
for  int i   0  i < occurrences
if   lcurelemstring charat i      1     0     if the low bit is set
currentbyte    128    set the high bit of the result
if   i   7     0
result append  char   currentbyte   0xff
currentbyte   0
continue
//if the index is not a multiple of 8, we are not on a byte boundary
currentbyte >>  1    shift the byte
if   occurrences   7     0      if the length is not a multiple of 8
currentbyte >>  7    occurrences   7     we need to pad the last byte
result append  char   currentbyte   0xff
//do some padding, i don't understand the padding strategy
result setlength result length     padlength
break
case
int currentbyte   0
int padlength   0
if  occurrences > lcurelemstring length
padlength    occurrences   lcurelemstring length      2   occurrences % 2
occurrences   lcurelemstring length
for  int i   0  i < occurrences
currentbyte    lcurelemstring charat i      1
// we filled up current byte; append it and create next one
if   i   7     0
result append  char   currentbyte   0xff
currentbyte   0
continue
//if the index is not a multiple of 8, we are not on a byte boundary
currentbyte <<  1
if   occurrences   7     0      if the length is not a multiple of 8
currentbyte <<  7    occurrences   7     we need to pad the last byte
result append  char   currentbyte   0xff
result setlength result length     padlength
break
case
int currentbyte   0
int padlength   0
if  occurrences > lcurelemstring length
padlength   occurrences   lcurelemstring length
occurrences   lcurelemstring length
for  int i   0  i < occurrences
char currentchar   lcurelemstring charat i
if  character isjavaidentifierstart currentchar
//this test may be too lax but it is the same as in mri
currentbyte       currentchar   15    9    15  << 4
else
currentbyte     currentchar   15  << 4
if   i   1     0
currentbyte >>  4
else
result append  char   currentbyte   0xff
currentbyte   0
if   occurrences   1     0
result append  char   currentbyte   0xff
result setlength result length     padlength
break
case
int currentbyte   0
int padlength   0
if  occurrences > lcurelemstring length
padlength   occurrences   lcurelemstring length
occurrences   lcurelemstring length
for  int i   0  i < occurrences
char currentchar   lcurelemstring charat i
if  character isjavaidentifierstart currentchar
//this test may be too lax but it is the same as in mri
currentbyte      currentchar   15    9    15
else
currentbyte    currentchar   15
if   i   1     0
currentbyte <<  4
else
result append  char   currentbyte   0xff
currentbyte   0
if   occurrences   1     0
result append  char   currentbyte   0xff
result setlength result length     padlength
break
break
case
grow result  snil10  occurrences
break
case
try
shrink result  occurrences
catch  illegalargumentexception e
throw runtime newargumenterror
break
case
occurrences    result length
if  occurrences > 0
grow result  snil10  occurrences
occurrences    occurrences
if  occurrences > 0
shrink result  occurrences
break
case
case
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
lcurelemstring   from    runtime getnil   ?     from converttostring   tostring
occurrences   occurrences <  2 ? 45   occurrences   3   3
if    equals lcurelemstring   break
char charstoencode   lcurelemstring tochararray
for  int i   0  i < lcurelemstring length    i    occurrences
encodes runtime  result  charstoencode  i  occurrences   char type
break
case
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
lcurelemstring   from    runtime getnil   ?     from asstring   tostring
if  occurrences <  1
occurrences   72
qpencode result  lcurelemstring  occurrences
break
case
unicodeencoding enc   utf8encoding instance
byte packedbytes   new byte
int index   0
while  occurrences   > 0
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
int code   from    runtime getnil   ? 0   rubynumeric num2int from
if  code < 0
throw runtime newrangeerror
int length   enc codetombc code  packedbytes  index
result append rubystring bytestostring packedbytes  index  length
index    length
break
case
if  listsize   <  0
throw runtime newargumenterror stoofew
irubyobject from   list eltinternal idx
string stringval   from    runtime getnil   ?     from asstring   tostring
biginteger bigint   new biginteger stringval
// we don't deal with negatives.
if bigint compareto new biginteger     >  0
int bitlength   bigint tostring 2  length
byte bytes   bigint tobytearray
byte buf   new byte
int b   0
int destbit   0
int destbyte   0
for int srcbyte   bytes length   1  srcbyte >  0  srcbyte
for int srcbit   0  srcbit < 8  srcbit    destbit
if destbit    7
buf    byte   b   0xff
b   0x80
destbit   0
int val   bytes    1 << srcbit
if destbit > srcbit
val   0xff    val << destbit   srcbit
else if destbit < srcbit
val   0xff    val >> srcbit   destbit
b    0xff   val
if b    0x80
buf    byte   b   0xff
result append rubystring bytestostring buf
else
throw runtime newargumenterror
break
return runtime newstring result tostring
/**
* retrieve an encoded int in little endian starting at index in the
* string value.
*
* @param encode string to get int from
* @return the decoded integer
*/
private static int decodeintlittleendian bytebuffer encode
encode order byteorder little_endian
int value   encode getint
encode order byteorder big_endian
return value
/**
* retrieve an encoded int in little endian starting at index in the
* string value.
*
* @param encode string to get int from
* @return the decoded integer
*/
private static int decodeintbigendian bytebuffer encode
return encode getint
/**
* retrieve an encoded int in big endian starting at index in the string
* value.
*
* @param encode string to get int from
* @return the decoded integer
*/
private static long decodeintunsignedbigendian bytebuffer encode
return  long encode getint     0xffffffffl
/**
* retrieve an encoded int in little endian starting at index in the
* string value.
*
* @param encode the encoded string
* @return the decoded integer
*/
private static long decodeintunsignedlittleendian bytebuffer encode
encode order byteorder little_endian
long value   encode getint     0xffffffffl
encode order byteorder big_endian
return value
/**
* encode an int in little endian format into a packed representation.
*
* @param result to be appended to
* @param s the integer to encode
*/
private static void encodeintlittleendian stringbuffer result  int s
result append  char   s   0xff   append  char    s >> 8    0xff
result append  char    s>>16    0xff   append  char    s>>24   0xff
/**
* encode an int in big-endian format into a packed representation.
*
* @param result to be appended to
* @param s the integer to encode
*/
private static void encodeintbigendian stringbuffer result  int s
result append  char    s>>24   0xff   append  char    s>>16   0xff
result append  char    s >> 8    0xff   append  char   s   0xff
/**
* decode a long in big-endian format from a packed value
*
* @param encode string to get int from
* @return the long value
*/
private static long decodelongbigendian bytebuffer encode
int c1   decodeintbigendian encode
int c2   decodeintbigendian encode
return   long  c1 << 32     c2   0xffffffffl
/**
* decode a long in little-endian format from a packed value
*
* @param encode string to get int from
* @return the long value
*/
private static long decodelonglittleendian bytebuffer encode
int c1   decodeintlittleendian encode
int c2   decodeintlittleendian encode
return   long  c2 << 32     c1   0xffffffffl
/**
* encode a long in little-endian format into a packed value
*
* @param result to pack long into
* @param l is the long to encode
*/
private static void encodelonglittleendian stringbuffer result  long l
encodeintlittleendian result   int   l   0xffffffff
encodeintlittleendian result   int   l >>> 32
/**
* encode a long in big-endian format into a packed value
*
* @param result to pack long into
* @param l is the long to encode
*/
private static void encodelongbigendian stringbuffer result  long l
encodeintbigendian result   int   l >>> 32
encodeintbigendian result   int   l   0xffffffff
/**
* decode a double from a packed value
*
* @param encode string to get int from
* @return the double value
*/
private static double decodedoublelittleendian bytebuffer encode
return double longbitstodouble decodelonglittleendian encode
/**
* decode a double in big-endian from a packed value
*
* @param encode string to get int from
* @return the double value
*/
private static double decodedoublebigendian bytebuffer encode
return double longbitstodouble decodelongbigendian encode
/**
* encode a double in little endian format into a packed value
*
* @param result to pack double into
* @param d is the double to encode
*/
private static void encodedoublelittleendian stringbuffer result  double d
encodelonglittleendian result  double doubletolongbits d
/**
* encode a double in big-endian format into a packed value
*
* @param result to pack double into
* @param d is the double to encode
*/
private static void encodedoublebigendian stringbuffer result  double d
encodelongbigendian result  double doubletolongbits d
/**
* decode a float in big-endian from a packed value
*
* @param encode string to get int from
* @return the double value
*/
private static float decodefloatbigendian bytebuffer encode
return float intbitstofloat decodeintbigendian encode
/**
* decode a float in little-endian from a packed value
*
* @param encode string to get int from
* @return the double value
*/
private static float decodefloatlittleendian bytebuffer encode
return float intbitstofloat decodeintlittleendian encode
/**
* encode a float in little endian format into a packed value
* @param result to pack float into
* @param f is the float to encode
*/
private static void encodefloatlittleendian stringbuffer result  float f
encodeintlittleendian result  float floattointbits f
/**
* encode a float in big-endian format into a packed value
* @param result to pack float into
* @param f is the float to encode
*/
private static void encodefloatbigendian stringbuffer result  float f
encodeintbigendian result  float floattointbits f
/**
* decode a short in big-endian from a packed value
*
* @param encode string to get int from
* @return the short value
*/
private static int decodeshortunsignedlittleendian bytebuffer encode
encode order byteorder little_endian
int value   encode getshort     0xffff
encode order byteorder big_endian
return value
/**
* decode a short in big-endian from a packed value
*
* @param encode string to get int from
* @return the short value
*/
private static int decodeshortunsignedbigendian bytebuffer encode
int value   encode getshort     0xffff
return value
/**
* decode a short in big-endian from a packed value
*
* @param encode string to get int from
* @return the short value
*/
private static short decodeshortbigendian bytebuffer encode
return encode getshort
/**
* encode an short in little endian format into a packed representation.
*
* @param result to be appended to
* @param s the short to encode
*/
private static void encodeshortlittleendian stringbuffer result  int s
result append  char   s   0xff   append  char    s   0xff00  >> 8
/**
* encode an shortin big-endian format into a packed representation.
*
* @param result to be appended to
* @param s the short to encode
*/
private static void encodeshortbigendian stringbuffer result  int s
result append  char    s   0xff00  >> 8   append  char   s   0xff