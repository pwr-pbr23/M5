/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007 william n dortch <bill.dortch@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util
import java math biginteger
import java text decimalformatsymbols
import java util list
import java util locale
import org jruby ruby
import org jruby rubyarray
import org jruby rubybignum
import org jruby rubyfixnum
import org jruby rubyfloat
import org jruby rubyinteger
import org jruby rubykernel
import org jruby rubynumeric
import org jruby rubystring
import org jruby common irubywarnings id
import org jruby runtime classindex
import org jruby runtime methodindex
import org jruby runtime builtin irubyobject
/**
* @author bill dortch
*
*/
public class sprintf
private static final int flag_none          0
private static final int flag_space         1 << 0
private static final int flag_zero          1 << 1
private static final int flag_plus          1 << 2
private static final int flag_minus         1 << 3
private static final int flag_sharp         1 << 4
private static final int flag_width         1 << 5
private static final int flag_precision     1 << 6
private static final byte prefix_octal
private static final byte prefix_hex_lc
private static final byte prefix_hex_uc
private static final byte prefix_binary_lc
private static final byte prefix_binary_uc
private static final byte prefix_negative
private static final byte nan_value
private static final byte infinity_value
private static final biginteger big_32   biginteger valueof   long integer max_value   1l  << 1
private static final biginteger big_64   big_32 shiftleft 32
private static final biginteger big_minus_32   biginteger valueof  long integer min_value << 1
private static final biginteger big_minus_64   big_minus_32 shiftleft 32
private static final int initial_buffer_size   32
private static final string err_malformed_format
private static final string err_malformed_num
private static final string err_malformed_dot_num
private static final string err_malformed_star_num
private static final string err_illegal_format_char
private static class args
ruby runtime
locale locale
irubyobject rubyobject
list rubyarray
int length
int unnumbered     last index   1  accessed by next
int numbered       last index   1  accessed by get
args locale locale  irubyobject rubyobject
if  rubyobject    null
throw new illegalargumentexception
}
this locale   locale    null ? locale getdefault     locale
this rubyobject   rubyobject
if  rubyobject instanceof rubyarray
this rubyarray     rubyarray rubyobject  getlist
this length   rubyarray size
} else {
this length   1
}
this runtime   rubyobject getruntime
}
args irubyobject rubyobject
this locale getdefault   rubyobject
}
// temporary hack to handle non-ruby values
// will come up with better solution shortly
args ruby runtime  long value
this rubyfixnum newfixnum runtime value
}
final void raiseargumenterror string message
throw runtime newargumenterror message
}
final void warn id id  string message
runtime getwarnings   warn id  message
}
final void warning id id  string message
runtime getwarnings   warning id  message
}
final irubyobject next
// this is the order in which mri does these two tests
if  numbered > 0
raiseargumenterror      unnumbered   1
}
if  unnumbered >  length
raiseargumenterror
}
irubyobject object   rubyarray    null ? rubyobject
irubyobject rubyarray get unnumbered
unnumbered
return object
}
final irubyobject get int index
// this is the order in which mri does these tests
if  unnumbered > 0
raiseargumenterror   numbered   unnumbered
}
if  index < 0
raiseargumenterror      index   1
}
if  index >  length
raiseargumenterror
}
numbered   index   1
return  rubyarray    null ? rubyobject    irubyobject rubyarray get index
}
final irubyobject getnth int formatindex
return get formatindex   1
}
final int nextint
return intvalue next
}
final int getint int index
return intvalue get index
}
final int getnthint int formatindex
return intvalue get formatindex   1
}
final int intvalue irubyobject obj
if  obj instanceof rubynumeric
return  int   rubynumeric obj  getlongvalue
}
// basically just forcing a typeerror here to match mri
obj   typeconverter converttotype obj  obj getruntime   getfixnum    methodindex to_int     true
return  int   rubyfixnum obj  getlongvalue
}
final byte getdecimalseparator
// not saving dfs instance, as it will only be used once (at most) per call
return  byte new decimalformatsymbols locale  getdecimalseparator
}
args
/*
* using this class to buffer output during formatting, rather than
* the eventual bytelist itself. that way this buffer can be initialized
* to a size large enough to prevent reallocations (in most cases), while
* the resultant bytelist will only be as large as necessary.
*
* (also, the buffer class's buffer grows by a factor of 2, as opposed
* to bytelist's 1.5, which i felt might result in a lot of reallocs.)
*/
private static class buffer
byte buf
int size
private boolean tainted   false
buffer
buf   new byte
}
buffer int initialsize
buf   new byte
}
final void write int b
int newsize   size   1
if  newsize > buf length
byte newbuf   new byte
system arraycopy buf 0 newbuf 0 size
buf   newbuf
}
buf    byte  b   0xff
size   newsize
}
final void write byte b  int off  int len
if  len < 0    off < 0  return
int newsize   size   len
if  newsize > buf length
byte newbuf   new byte
system arraycopy buf 0 newbuf 0 size
buf   newbuf
}
system arraycopy b off buf size len
size   newsize
}
final void write byte b
write b 0 b length
}
final void fill int b  int len
if  len <  0  return
int newsize   size   len
if  newsize > buf length
byte newbuf   new byte
system arraycopy buf 0 newbuf 0 size
buf   newbuf
}
byte fillval    byte  b   0xff
for       len >  0
buf   fillval
}
size   newsize
}
final void set int b  int pos
if  pos < 0  pos    size
if  pos >  0    pos < size  buf    byte  b   0xff
}
// sets last char
final void set int b
if  size > 0  buf    byte  b   0xff
}
final bytelist tobytelist
return new bytelist buf 0 size
}
public final string tostring
return new string buf 0 size
}
buffer
// static methods only
private sprintf
public static charsequence sprintf locale locale  charsequence format  irubyobject args
return rubysprintf format  new args locale args
}
// special form of sprintf that returns a rubystring and handles
// tainted strings correctly.
public static rubystring sprintf ruby runtime  locale locale  charsequence format  irubyobject args
buffer b   rubysprintftobuffer format  new args locale args
rubystring s   runtime newstring b tobytelist
if  b tainted
s settaint true
}
return s
}
public static charsequence sprintf charsequence format  irubyobject args
return rubysprintf format  new args args
}
public static charsequence sprintf ruby runtime  charsequence format  int arg
return rubysprintf format  new args runtime  long arg
}
public static charsequence sprintf ruby runtime  charsequence format  long arg
return rubysprintf format  new args runtime arg
}
public static charsequence sprintf locale locale  rubystring format  irubyobject args
return rubysprintf format getbytelist    new args locale args
}
public static charsequence sprintf rubystring format  irubyobject args
return rubysprintf format getbytelist    new args args
}
private static charsequence rubysprintf charsequence charformat  args args
return rubysprintftobuffer charformat  args  tobytelist
}
private static buffer rubysprintftobuffer charsequence charformat  args args
byte format
buffer buf   new buffer
int offset
int length
int start
int mark
if  charformat instanceof bytelist
bytelist list    bytelist charformat
format   list unsafebytes
int begin   list begin
offset   begin
length   begin   list length
start   begin
mark   begin
} else {
format   stringtobytes charformat  false
offset   0
length   charformat length
start   0
mark   0
}
while  offset < length
start   offset
for     offset < length    format       offset
if  offset > start
buf write format start offset start
start   offset
}
if  offset   >  length
break
irubyobject arg   null
int flags   0
int width   0
int precision   0
int number   0
byte fchar   0
boolean incomplete   true
for     incomplete    offset < length
switch fchar   format
default
if  fchar         flags    flag_none
// mri 1.8.6 behavior: null byte after '%'
// leads to "%" string. null byte in
// other places, like "%5\0", leads to error.
buf write
buf write fchar
incomplete   false
offset
break
else if  isprintable fchar
raiseargumenterror args      char fchar
} else {
raiseargumenterror args err_malformed_format
}
break
case
flags    flag_space
offset
break
case
flags    flag_zero
offset
break
case
flags    flag_plus
offset
break
case
flags    flag_minus
offset
break
case
flags    flag_sharp
offset
break
case
case
case
case
case
case
case
case
case
// mri doesn't flag it as an error if width is given multiple
// times as a number (but it does for *)
number   0
for     offset < length    isdigit fchar   format   offset
number   extendwidth args  number  fchar
}
checkoffset args offset length err_malformed_num
if  fchar
if  arg    null
raiseargumenterror args     number
}
arg   args getnth number
offset
} else {
width   number
flags    flag_width
}
break
case
if   flags   flag_width     0
raiseargumenterror args
}
flags    flag_width
// todo: factor this chunk as in mri/yarv getaster
checkoffset args   offset length err_malformed_star_num
mark   offset
number   0
for     offset < length    isdigit fchar   format   offset
number   extendwidth args number fchar
}
checkoffset args offset length err_malformed_star_num
if  fchar
width   args getnthint number
if  width < 0
flags    flag_minus
width    width
}
offset
} else {
width   args nextint
if  width < 0
flags    flag_minus
width    width
}
// let the width (if any), get processed in the next loop,
// so any leading 0 gets treated correctly
offset   mark
}
break
case
if   flags   flag_precision     0
raiseargumenterror args
}
flags    flag_precision
checkoffset args   offset length err_malformed_dot_num
fchar   format
if  fchar
// todo: factor this chunk as in mri/yarv getaster
checkoffset args   offset length err_malformed_star_num
mark   offset
number   0
for     offset < length    isdigit fchar   format   offset
number   extendwidth args number fchar
}
checkoffset args offset length err_malformed_star_num
if  fchar
precision   args getnthint number
if  precision < 0
flags    ~flag_precision
}
offset
} else {
precision   args nextint
if  precision < 0
flags    ~flag_precision
}
// let the width (if any), get processed in the next loop,
// so any leading 0 gets treated correctly
offset   mark
}
} else {
number   0
for     offset < length    isdigit fchar   format   offset
number   extendwidth args number fchar
}
checkoffset args offset length err_malformed_dot_num
precision   number
}
break
case
offset
case
if  flags    flag_none
raiseargumenterror args err_illegal_format_char
}
buf write
offset
incomplete   false
break
case
if  arg    null  arg   args next
int c   0
// mri 1.8.5-p12 doesn't support 1-char strings, but
// yarv 0.4.1 does. i don't think it hurts to include
// this; sprintf('%c','a') is nicer than sprintf('%c','a'[0])
if  arg instanceof rubystring
bytelist bytes     rubystring arg  getbytelist
if  bytes length      1
c   bytes unsafebytes
} else {
raiseargumenterror args
}
} else {
c   args intvalue arg
}
if   flags   flag_width     0    width > 1
if   flags   flag_minus     0
buf write c
buf fill    width 1
} else {
buf fill   width 1
buf write c
}
} else {
buf write c
}
offset
incomplete   false
break
}
case
case
if  arg    null  arg   args next
if  fchar
arg   arg callmethod arg getruntime   getcurrentcontext
}
bytelist bytes   arg asstring   getbytelist
int len   bytes length
if  arg istaint
buf tainted   true
}
if   flags   flag_precision     0    precision < len
len   precision
}
// todo: adjust length so it won't fall in the middle
// of a multi-byte character. mri's sprintf.c uses tables
// in a modified version of regex.c, which assume some
// particular  encoding for a given installation/application.
// (see regex.c#re_mbcinit in ruby-1.8.5-p12)
//
// this is only an issue if the user specifies a precision
// that causes the string to be truncated. the same issue
// would arise taking a substring of a bytelist-backed rubystring.
if   flags   flag_width     0    width > len
width    len
if   flags   flag_minus     0
buf write bytes unsafebytes   bytes begin   len
buf fill   width
} else {
buf fill   width
buf write bytes unsafebytes   bytes begin   len
}
} else {
buf write bytes unsafebytes   bytes begin   len
}
offset
incomplete   false
break
}
case
case
case
case
case
case
case
case
if  arg    null  arg   args next
int type   arg getmetaclass   index
if  type    classindex fixnum    type    classindex bignum
switch type
case classindex float
arg   rubynumeric dbl2num arg getruntime     rubyfloat arg  getvalue
break
case classindex string
arg   rubynumeric str2inum arg getruntime    rubystring arg 0 true
break
default
if  arg respondsto
arg   typeconverter converttotype arg  arg getruntime   getinteger    methodindex to_int     true
} else {
arg   typeconverter converttotype arg  arg getruntime   getinteger    methodindex to_i     true
}
break
}
type   arg getmetaclass   index
}
byte bytes   null
int first   0
byte prefix   null
boolean sign
boolean negative
byte signchar   0
byte leadchar   0
int base
// 'd' and 'i' are the same
if  fchar       fchar
// 'u' with space or plus flags is same as 'd'
if  fchar          flags    flag_space   flag_plus      0
fchar
}
sign    fchar          flags    flag_space   flag_plus      0
switch  fchar
case
base   8  break
case
case
base   16  break
case
case
base   2  break
case
case
default
base   10  break
}
if   flags   flag_sharp     0
switch fchar
case    prefix   prefix_octal  break
case    prefix   prefix_hex_lc  break
case    prefix   prefix_hex_uc  break
case    prefix   prefix_binary_lc  break
case    prefix   prefix_binary_uc  break
}
if  prefix    null  width    prefix length
}
// we depart here from strict adherence to mri code, as mri
// uses c-sprintf, in part, to format numeric output, while
// we'll use java's numeric formatting code (and our own).
if  type    classindex fixnum
negative     rubyfixnum arg  getlongvalue   < 0
if  negative    fchar
bytes   getunsignednegativebytes  rubyfixnum arg
} else {
bytes   getfixnumbytes  rubyfixnum arg base sign fchar
}
} else {
negative     rubybignum arg  getvalue   signum   < 0
if  negative    fchar
bytes   getunsignednegativebytes  rubybignum arg
} else {
bytes   getbignumbytes  rubybignum arg base sign fchar
}
}
int len   0
if  sign
if  negative
signchar
width
first   1     skip   in bytes  will add where appropriate
else if   flags   flag_plus     0
signchar
width
else if   flags   flag_space     0
signchar
width
}
else if  negative
if  base    10
warning id negative_number_for_u  args
leadchar
len    2
} else {
if   flags    flag_precision   flag_zero      0  len    2
first   skipsignbits bytes base
switch fchar
case
case
leadchar
break
case
leadchar
break
case
leadchar
break
case
leadchar
break
}
if  leadchar    0  len
}
}
int numlen   bytes length   first
len    numlen
if   flags    flag_zero flag_precision      flag_zero
precision   width
width   0
} else {
if  precision < len  precision   len
width    precision
}
if   flags   flag_minus     0
buf fill   width
width   0
}
if  signchar    0  buf write signchar
if  prefix    null  buf write prefix
if  len < precision
if  leadchar    0
buf fill    precision   len
else if  leadchar
buf fill leadchar precision len
buf write prefix_negative
} else {
buf fill leadchar precision len 1      the 1 is for the stripped sign char
}
else if  leadchar    0
if   flags    flag_precision   flag_zero      0
buf write prefix_negative
}
if  leadchar       buf write leadchar
}
buf write bytes first numlen
if  width > 0  buf fill   width
offset
incomplete   false
break
}
case
case
case
case
case
if  arg    null  arg   args next
if    arg instanceof rubyfloat
// fixme: what is correct 'recv' argument?
// (this does produce the desired behavior)
arg   rubykernel new_float arg arg
}
double dval     rubyfloat arg  getdoublevalue
boolean nan   dval    dval
boolean inf   dval    double positive_infinity    dval    double negative_infinity
boolean negative   dval < 0 0d
byte digits
int ndigits   0
int exponent   0
int len   0
byte signchar
if  nan    inf
if  nan
digits   nan_value
len   nan_value length
} else {
digits   infinity_value
len   infinity_value length
}
if  negative
signchar
width
else if   flags   flag_plus     0
signchar
width
else if   flags   flag_space     0
signchar
width
} else {
signchar   0
}
width    len
if  width > 0     flags    flag_zero flag_minus      0
buf fill   width
width   0
}
if  signchar    0  buf write signchar
if  width > 0     flags   flag_minus     0
buf fill   width
width   0
}
buf write digits
if  width > 0  buf fill    width
offset
incomplete   false
break
}
string str   double tostring dval
// grrr, arghh, want to subclass sun.misc.floatingdecimal, but can't,
// so we must do all this (the next 70 lines of code), which has already
// been done by floatingdecimal.
int strlen   str length
digits   new byte
int ntrailingzeroes   0
int i   negative ? 1   0
int decpos   0
byte ival
int_loop
for     i < strlen
switch ival    byte str charat i
case
if  ndigits > 0  ntrailingzeroes
break     switch
case    case    case    case
case    case    case    case    case
if  ntrailingzeroes > 0
for     ntrailingzeroes > 0   ntrailingzeroes
digits
}
}
digits   ival
break     switch
case
break int_loop
}
}
decpos   ndigits   ntrailingzeroes
dec_loop
for     i < strlen
switch ival    byte str charat i
case
if  ndigits > 0
ntrailingzeroes
} else {
exponent
}
break     switch
case    case    case    case
case    case    case    case    case
if  ntrailingzeroes > 0
for     ntrailingzeroes > 0   ntrailingzeroes
digits
}
}
digits   ival
break     switch
case
break dec_loop
}
}
if   i < strlen
int expsign
int expval   0
if  str charat i
expsign    1
i
} else {
expsign   1
}
for     i < strlen
expval   expval   10     int str charat i     int
}
exponent    expval   expsign
}
exponent    decpos   ndigits
// gotta have at least a zero...
if  ndigits    0
digits
ndigits   1
exponent   0
}
// ok, we now have the significand in digits[0...ndigits]
// and the exponent in exponent.  we're ready to format.
int intdigits  intzeroes  intlength
int decdigits  deczeroes  declength
byte expchar
if  negative
signchar
width
else if   flags   flag_plus     0
signchar
width
else if   flags   flag_space     0
signchar
width
} else {
signchar   0
}
if   flags   flag_precision     0
precision   6
}
switch fchar
case
case
expchar
break
case
case
expchar
break
default
expchar   0
}
switch fchar
case
case
// an empirically derived rule: precision applies to
// significand length, irrespective of exponent
// an official rule, clarified: if the exponent
// <clarif>after adjusting for exponent form</clarif>
// is < -4,  or the exponent <clarif>after adjusting
// for exponent form</clarif> is greater than the
// precision, use exponent form
boolean expform    exponent   ndigits   1 <  4
exponent   ndigits >  precision    0 ? 1   precision
// it would be nice (and logical!) if exponent form
// behaved like e/e, and decimal form behaved like f,
// but no such luck. hence:
if  expform
// intdigits isn't used here, but if it were, it would be 1
/* intdigits = 1; */
decdigits   ndigits   1
// precision for g/g includes integer digits
precision   math max 0 precision   1
if  precision < decdigits
int n   round digits ndigits precision precision  0
if  n > ndigits
ndigits   n
}
decdigits   math min ndigits   1 precision
}
exponent    ndigits   1
boolean issharp    flags   flag_sharp     0
// deal with length/width
len       first digit is always printed
// mri behavior: be default, 2 digits
// in the exponent. use 3 digits
// only when necessary.
// see comment for writeexp method for more details.
if  exponent > 99
len    5     5  > e nnn   e nnn
else
len    4     4  > e nn   e nn
if  issharp
// in this mode, '.' is always printed
len
}
if  precision > 0
if   issharp
// mri behavior: in this mode
// trailing zeroes are removed:
// 1.500e+05 -> 1.5e+05
int j   decdigits
for    j >  1  j
if  digits
decdigits
} else {
break
}
}
if  decdigits > 0
len    1       is printed
len    decdigits
}
else
// all precision numebers printed
len    precision
}
}
width    len
if  width > 0     flags    flag_zero flag_minus      0
buf fill   width
width   0
}
if  signchar    0
buf write signchar
}
if  width > 0     flags   flag_minus     0
buf fill   width
width   0
}
// now some data...
buf write digits
boolean dottoprint   issharp
precision > 0    decdigits > 0
if  dottoprint
buf write args getdecimalseparator
}
if  precision > 0    decdigits > 0
buf write digits  1  decdigits
precision    decdigits
}
if  precision > 0    issharp
buf fill    precision
}
writeexp buf  exponent  expchar
if  width > 0
buf fill    width
}
else      decimal form  like  but not  just  like
intdigits   math max 0 math min ndigits   exponent ndigits
intzeroes   math max 0 exponent
intlength   intdigits   intzeroes
decdigits   ndigits   intdigits
deczeroes   math max 0   decdigits   exponent
declength   deczeroes   decdigits
precision   math max 0 precision   intlength
if  precision < decdigits
int n   round digits ndigits intdigits precision 1 precision  0
if  n > ndigits
// digits array shifted, update all
ndigits   n
intdigits   math max 0 math min ndigits   exponent ndigits
intlength   intdigits   intzeroes
decdigits   ndigits   intdigits
deczeroes   math max 0   decdigits   exponent
precision   math max 0 precision 1
}
decdigits   precision
declength   deczeroes   decdigits
}
len    intlength
if  declength > 0
len    declength   1
} else {
if   flags   flag_sharp     0
len       will have a trailing
if  precision > 0       g fills trailing zeroes if #
len    precision
}
}
}
width    len
if  width > 0     flags    flag_zero flag_minus      0
buf fill   width
width   0
}
if  signchar    0
buf write signchar
}
if  width > 0     flags   flag_minus     0
buf fill   width
width   0
}
// now some data...
if  intlength > 0
if  intdigits > 0       s b true  since intlength > 0
buf write digits 0 intdigits
}
if  intzeroes > 0
buf fill   intzeroes
}
} else {
// always need at least a 0
buf write
}
if  declength > 0     flags   flag_sharp     0
buf write args getdecimalseparator
}
if  declength > 0
if  deczeroes > 0
buf fill   deczeroes
precision    deczeroes
}
if  decdigits > 0
buf write digits intdigits decdigits
precision    decdigits
}
if   flags   flag_sharp     0    precision > 0
buf fill   precision
}
}
if   flags   flag_sharp     0    precision > 0
buf fill   precision
}
if  width > 0
buf fill    width
}
}
break
case
intdigits   math max 0 math min ndigits   exponent ndigits
intzeroes   math max 0 exponent
intlength   intdigits   intzeroes
decdigits   ndigits   intdigits
deczeroes   math max 0   decdigits   exponent
declength   deczeroes   decdigits
if  precision < declength
if  precision < deczeroes
decdigits   0
deczeroes   precision
} else {
int n   round digits ndigits intdigits precision deczeroes 1 precision  0
if  n > ndigits
// digits arr shifted, update all
ndigits   n
intdigits   math max 0 math min ndigits   exponent ndigits
intlength   intdigits   intzeroes
decdigits   ndigits   intdigits
deczeroes   math max 0   decdigits   exponent
declength   deczeroes   decdigits
}
decdigits   precision   deczeroes
}
declength   deczeroes   decdigits
}
if  precision > 0
len    math max 1 intlength    1   precision
// (1|intlen).prec
} else {
len    math max 1 intlength
// (1|intlen)
if   flags   flag_sharp     0
len       will have a trailing
}
}
width    len
if  width > 0     flags    flag_zero flag_minus      0
buf fill   width
width   0
}
if  signchar    0
buf write signchar
}
if  width > 0     flags   flag_minus     0
buf fill   width
width   0
}
// now some data...
if  intlength > 0
if  intdigits > 0       s b true  since intlength > 0
buf write digits 0 intdigits
}
if  intzeroes > 0
buf fill   intzeroes
}
} else {
// always need at least a 0
buf write
}
if  precision > 0     flags   flag_sharp     0
buf write args getdecimalseparator
}
if  precision > 0
if  deczeroes > 0
buf fill   deczeroes
precision    deczeroes
}
if  decdigits > 0
buf write digits intdigits decdigits
precision    decdigits
}
// fill up the rest with zeroes
if  precision > 0
buf fill   precision
}
}
if  width > 0
buf fill    width
}
break
case
case
// intdigits isn't used here, but if it were, it would be 1
/* intdigits = 1; */
decdigits   ndigits   1
if  precision < decdigits
int n   round digits ndigits precision precision  0
if  n > ndigits
ndigits   n
}
decdigits   math min ndigits   1 precision
}
exponent    ndigits   1
boolean issharp    flags   flag_sharp     0
// deal with length/width
len       first digit is always printed
// mri behavior: be default, 2 digits
// in the exponent. use 3 digits
// only when necessary.
// see comment for writeexp method for more details.
if  exponent > 99
len    5     5  > e nnn   e nnn
else
len    4     4  > e nn   e nn
if  precision > 0
// '.' and all precision digits printed
len    1   precision
else  if  issharp
len        in this mode    is always printed
}
width    len
if  width > 0     flags    flag_zero flag_minus      0
buf fill   width
width   0
}
if  signchar    0
buf write signchar
}
if  width > 0     flags   flag_minus     0
buf fill   width
width   0
}
// now some data...
buf write digits
if  precision > 0
buf write args getdecimalseparator
if  decdigits > 0
buf write digits 1 decdigits
precision    decdigits
}
if  precision > 0
buf fill   precision
}
else if   flags   flag_sharp     0
buf write args getdecimalseparator
}
writeexp buf  exponent  expchar
if  width > 0
buf fill    width
}
break
switch  format char e e f g g
offset
incomplete   false
break
block  case e e f g g
switch  each format char in spec
for  each format spec
// equivalent to mri case '\0':
if  incomplete
if  flags    flag_none
// dangling '%' char
buf write
} else {
raiseargumenterror args err_illegal_format_char
}
}
main while loop  offset < length
// mri behavior: validate only the unnumbered arguments
if   args numbered    0     args unnumbered < args length
if  args runtime getdebug   istrue
args raiseargumenterror
else if  args runtime getverbose   istrue
args warn id too_many_arguments
}
}
return buf
}
private static void writeexp buffer buf  int exponent  byte expchar
// unfortunately, the number of digits in the exponent is
// not clearly defined in ruby documentation. this is a
// platform/version-dependent behavior. on linux/mac/cygwin/*nix,
// two digits are used. on windows, 3 digits are used.
// it is desirable for jruby to have consistent behavior, and
// the two digits behavior was selected. this is also in sync
// with "java-native" sprintf behavior (java.util.formatter).
buf.write(expchar); // e or e
buf.write(exponent >= 0 ? '+' : '-');
if (exponent < 0) {
exponent = -exponent;
}
if (exponent > 99) {
buf.write(exponent / 100 + '0');
buf.write(exponent % 100 / 10 + '0');
} else {
buf.write(exponent / 10 + '0');
}
buf.write(exponent % 10 + '0');
}
// debugging code, keeping for now
/*
private static final void showliteral(byte[] format, int start, int offset) {
system.out.println("literal: ["+ new string(format,start,offset-start)+ "], " +
" s="+ start + " o="+ offset);
}
// debugging code, keeping for now
private static final void showvals(byte[] format,int start,int offset, byte fchar,
int flags, int width, int precision, object arg) {
system.out.println(new stringbuffer()
.append("value: ").append(new string(format,start,offset-start+1)).append('\n')
.append("type: ").append((char)fchar).append('\n')
.append("start: ").append(start).append('\n')
.append("length: ").append(offset-start).append('\n')
.append("flags: ").append(integer.tobinarystring(flags)).append('\n')
.append("width: ").append(width).append('\n')
.append("precision: ").append(precision).append('\n')
.append("arg: ").append(arg).append('\n')
.tostring());
}
*/
private static final void raiseargumenterror args args  string message
args raiseargumenterror message
}
private static final void warning id id  args args  string message
args warning id  message
}
private static final void checkoffset args args  int offset  int length  string message
if  offset >  length
raiseargumenterror args message
}
}
private static final int extendwidth args args  int oldwidth  byte newchar
int newwidth   oldwidth   10    newchar
if  newwidth   10    oldwidth
raiseargumenterror args
}
return newwidth
}
private static final boolean isdigit byte achar
return  achar >       achar <
}
private static final boolean isprintable byte achar
return  achar > 32    achar < 127
}
private static final int skipsignbits byte bytes  int base
int skip   0
int length   bytes length
byte b
switch base
case 2
for     skip < length    bytes       skip
break
case 8
if  length > 0    bytes
skip
}
for     skip < length    bytes       skip
break
case 10
if  length > 0    bytes
skip
}
break
case 16
for     skip < length      b   bytes          b        skip
}
return skip
}
private static final int round byte bytes  int ndigits  int roundpos  boolean rounddown
int next   roundpos   1
if  next >  ndigits    bytes <
// mri rounds up on nnn5nnn, but not nnn5 --
// except for when they do
rounddown    bytes         next    ndigits   1
return ndigits
}
if  roundpos < 0         % 0 99
system arraycopy bytes 0 bytes 1 ndigits
bytes
return ndigits   1
}
bytes    1
while  bytes >
bytes
roundpos
if  roundpos >  0
bytes    1
} else {
system arraycopy bytes 0 bytes 1 ndigits
bytes
return ndigits   1
}
}
return ndigits
}
private static final byte getfixnumbytes rubyfixnum arg  int base  boolean sign  boolean upper
long val   arg getlongvalue
// limit the length of negatives if possible (also faster)
if  val >  integer min_value    val <  integer max_value
if  sign
return convert inttobytearray  int val base upper
} else {
switch base
case 2   return convert inttobinarybytes  int val
case 8   return convert inttooctalbytes  int val
case 10
default  return convert inttocharbytes  int val
case 16  return convert inttohexbytes  int val upper
}
}
} else {
if  sign
return convert longtobytearray val base upper
} else {
switch base
case 2   return convert longtobinarybytes val
case 8   return convert longtooctalbytes val
case 10
default  return convert longtocharbytes val
case 16  return convert longtohexbytes val upper
}
}
}
}
private static final byte getbignumbytes rubybignum arg  int base  boolean sign  boolean upper
biginteger val   arg getvalue
if  sign    base    10    val signum   >  0
return stringtobytes val tostring base  upper
}
// negative values
byte bytes   val tobytearray
switch base
case 2   return convert twoscomplementtobinarybytes bytes
case 8   return convert twoscomplementtooctalbytes bytes
case 16  return convert twoscomplementtohexbytes bytes upper
default  return stringtobytes val tostring base  upper
}
}
private static final byte getunsignednegativebytes rubyinteger arg
// calculation for negatives when %u specified
// for values >= integer.min_value * 2, mri uses (the equivalent of)
//   long neg_u = (((long)integer.max_value + 1) << 1) + val
// for smaller values, biginteger math is required to conform to mri's
// result.
long longval
biginteger bigval
if  arg instanceof rubyfixnum
// relatively cheap test for 32-bit values
longval     rubyfixnum arg  getlongvalue
if  longval >   long integer min_value << 1
return convert longtocharbytes    long integer max_value   1l  << 1    longval
}
// no such luck...
bigval   biginteger valueof longval
} else {
bigval     rubybignum arg  getvalue
}
// ok, now it gets expensive...
int shift   0
// go through negated powers of 32 until we find one small enough
for  biginteger minus   big_minus_64
bigval compareto minus  < 0
minus   minus shiftleft 32   shift
// add to the corresponding positive power of 32 for the result.
// meaningful? no. conformant? yes. i just write the code...
biginteger npower32   shift > 0 ? big_64 shiftleft 32   shift    big_64
return stringtobytes npower32 add bigval  tostring   false
}
private static final byte stringtobytes charsequence s  boolean upper
int len   s length
byte bytes   new byte
if  upper
for  int i   len    i >  0
int b    byte   int s charat i     int 0xff
if  b >       b <
bytes    byte  b   ~0x20
} else {
bytes    byte b
}
}
} else {
for  int i   len    i >  0
bytes    byte   int s charat i     int 0xff
}
}
return bytes
}
}