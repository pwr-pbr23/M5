/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004-2007 thomas e enebo <enebo@acm.org>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby lexer yacc
import org jruby ast strnode
import org jruby lexer yacc syntaxexception pid
import org jruby parser tokens
import org jruby util bytelist
/**
* a lexing unit for scanning a heredoc element.
* example:
* <pre>
* foo(<<eos, bar)
* this is heredoc country!
* eof
*
* where:
* eos = marker
* ',bar)\n' = lastline
* </pre>
*
*/
public class heredocterm extends strterm
// marker delimiting heredoc boundary
private final bytelist marker
// expand variables, indentation of final marker
private final int flags
// portion of line right after beginning marker
private final bytelist lastline
public heredocterm bytelist marker  int func  bytelist lastline
this marker   marker
this flags   func
this lastline   lastline
public int parsestring rubyyacclexer lexer  lexersource src  throws java io ioexception
boolean indent    flags   rubyyacclexer str_func_indent     0
if  src peek rubyyacclexer eof   syntaxerror src
// found end marker for this heredoc
if  src lastwasbeginofline      src matchmarker marker  indent  true
// put back lastline for any elements past start of heredoc marker
src unreadmany lastline
lexer yaccvalue   new token marker  lexer getposition
return tokens tstring_end
bytelist str   new bytelist
if   flags   rubyyacclexer str_func_expand     0
do
str append src readlinebytes
str append
if  src peek rubyyacclexer eof   syntaxerror src
while   src matchmarker marker  indent  true
else
int c   src read
if  c
switch  c   src read
case
case
src unread c
lexer setvalue new token     c  lexer getposition
return tokens tstring_dvar
case
lexer setvalue new token     c  lexer getposition
return tokens tstring_dbeg
str append
src unread c
// mri has extra pointer which makes our code look a little bit
// more strange in
// comparison
do
if   c   new stringterm flags        parsestringintobuffer lexer  src  str      rubyyacclexer eof
syntaxerror src
if  c
lexer yaccvalue   new strnode lexer getposition    str
return tokens tstring_content
str append src read
if  src peek rubyyacclexer eof   syntaxerror src
while   src matchmarker marker  indent  true
src unreadmany lastline
lexer setstrterm new stringterm  1
lexer yaccvalue   new strnode lexer getposition    str
return tokens tstring_content
private void syntaxerror lexersource src
throw new syntaxexception pid string_marker_missing  src getposition     "   marker
anywhere before eof"  marker