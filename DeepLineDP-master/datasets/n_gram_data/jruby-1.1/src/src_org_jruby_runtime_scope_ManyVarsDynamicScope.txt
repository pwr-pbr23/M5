package org jruby runtime scope
import org jruby rubyarray
import org jruby evaluator astinterpreter
import org jruby parser blockstaticscope
import org jruby parser staticscope
import org jruby runtime dynamicscope
import org jruby runtime builtin irubyobject
/**
* represents the the dynamic portion of scoping information.  the variablevalues are the
* values of assigned local or block variables.  the staticscope identifies which sort of
* scope this is (block or local).
*
* properties of dynamic scopes:
* 1. static and dynamic scopes have the same number of names to values
* 2. size of variables (and thus names) is determined during parsing.  so those structured do
*    not need to change
*
* fixme: when creating dynamic scopes we sometimes accidentally pass in extra parents.  this
* is harmless (other than wasting memory), but we should not do that.  we can fix this in two
* ways:
* 1. fix all callers
* 2. check parent that is passed in and make if new instance is local, then its parent is not local
*/
public class manyvarsdynamicscope extends dynamicscope
// our values holder (name of variables are kept in staticscope)
private irubyobject variablevalues
public manyvarsdynamicscope staticscope staticscope  dynamicscope parent
super staticscope  parent
public manyvarsdynamicscope staticscope staticscope
super staticscope
private void lazy
if variablevalues    null
int size   staticscope getnumberofvariables
variablevalues   new irubyobject
public dynamicscope clonescope
return new manyvarsdynamicscope staticscope  parent
public irubyobject getvalues
lazy
return variablevalues
/**
* get value from current scope or one of its captured scopes.
*
* fixme: block variables are not getting primed to nil so we need to null check those
*  until we prime them properly.  also add assert back in.
*
* @param offset zero-indexed value that represents where variable lives
* @param depth how many captured scopes down this variable should be set
* @return the value here
*/
public irubyobject getvalue int offset  int depth
if  depth > 0
return parent getvalue offset  depth   1
lazy
assert variablevalues    null       offset       depth
assert offset < variablevalues length       offset       depth       this
// &foo are not getting set from somewhere...i want the following assert to be true though
//assert variablevalues[offset] != null : "getting unassigned: " + staticscope.getvariables()[offset];
return variablevalues
/**
* variation of getvalue that checks for nulls, returning and setting the given value (presumably nil)
*/
public irubyobject getvalueornil int offset  int depth  irubyobject nil
if  depth > 0
return parent getvalueornil offset  depth   1  nil
else
return getvaluedepthzeroornil offset  nil
public irubyobject getvaluedepthzeroornil int offset  irubyobject nil
lazy
assert variablevalues    null       offset       0
assert offset < variablevalues length       offset       0       this
// &foo are not getting set from somewhere...i want the following assert to be true though
//assert variablevalues[offset] != null : "getting unassigned: " + staticscope.getvariables()[offset];
irubyobject value   variablevalues
if  value    null
variablevalues   nil
value   nil
return value
public irubyobject getvaluezerodepthzeroornil irubyobject nil
lazy
assert variablevalues    null       0       0
assert 0 < variablevalues length       0       0       this
// &foo are not getting set from somewhere...i want the following assert to be true though
//assert variablevalues[offset] != null : "getting unassigned: " + staticscope.getvariables()[offset];
irubyobject value   variablevalues
if  value    null
variablevalues   nil
value   nil
return value
public irubyobject getvalueonedepthzeroornil irubyobject nil
lazy
assert variablevalues    null       1       0
assert 1 < variablevalues length       1       0       this
// &foo are not getting set from somewhere...i want the following assert to be true though
//assert variablevalues[offset] != null : "getting unassigned: " + staticscope.getvariables()[offset];
irubyobject value   variablevalues
if  value    null
variablevalues   nil
value   nil
return value
/**
* set value in current dynamic scope or one of its captured scopes.
*
* @param offset zero-indexed value that represents where variable lives
* @param value to set
* @param depth how many captured scopes down this variable should be set
*/
public void setvalue int offset  irubyobject value  int depth
if  depth > 0
assert parent    null
parent setvalue offset  value  depth   1
else
lazy
assert offset < variablevalues length       offset       value       this
variablevalues   value
public void setvaluedepthzero irubyobject value  int offset
lazy
assert offset < variablevalues length       offset       value       this
variablevalues   value
public void setvaluezerodepthzero irubyobject value
lazy
assert 0 < variablevalues length       0       value       this
variablevalues   value
public void setvalueonedepthzero irubyobject value
lazy
assert 1 < variablevalues length       1       value       this
variablevalues   value
/**
* set all values which represent 'normal' parameters in a call list to this dynamic
* scope.  function calls bind to local scopes by assuming that the indexes or the
* arg list correspond to that of the local scope (plus 2 since $_ and $~ always take
* the first two slots).  we pass in a second argument because we sometimes get more
* values than we are expecting.  the rest get compacted by original caller into
* rest args.
*
* @param values up to size specified to be mapped as ordinary parm values
* @param size is the number of values to assign as ordinary parm values
*/
public void setargvalues irubyobject values  int size
lazy
system arraycopy values  0  variablevalues  0  size
/**
* copy variable values back for zsuper call.
*/
public irubyobject getargvalues
// if we're not the "argument scope" for zsuper, try our parent
if   staticscope isargumentscope
return parent getargvalues
lazy
int totalargs   staticscope getrequiredargs     staticscope getoptionalargs
// copy and splat arguments out of the scope to use for zsuper call
if  staticscope getrestarg   < 0
// required and optional only
irubyobject argvalues   new irubyobject
system arraycopy variablevalues  0  argvalues  0  totalargs
return argvalues
else
// rest arg must be splatted
irubyobject restarg   getvalue staticscope getrestarg    0
assert restarg    null
// fixme: not very efficient
rubyarray splattedargs   astinterpreter splatvalue restarg getruntime    restarg
irubyobject argvalues   new irubyobject
system arraycopy variablevalues  0  argvalues  0  totalargs
system arraycopy splattedargs tojavaarray    0  argvalues  totalargs  splattedargs size
return argvalues
/**
*
* make a larger dynamic scope if the static scope grew.
*
* eval's with bindings require us to possibly change the size of the dynamic scope if
* things like 'eval "b = 2", binding' happens.
*
*/
public void growifneeded
lazy
int dynamicsize   variablevalues    null ? 0  variablevalues length
if  staticscope getnumberofvariables   > dynamicsize
irubyobject values   new irubyobject
if  dynamicsize > 0
system arraycopy variablevalues  0  values  0  dynamicsize
variablevalues   values
// helper function to give a good view of current dynamic scope with captured scopes
public string tostring stringbuffer buf  string indent
lazy
buf append indent  append     hashcode
staticscope instanceof blockstaticscope ?
int size   staticscope getnumberofvariables
if  size    0
string names   staticscope getvariables
for  int i   0  i < size 1  i
buf append names  append
if  variablevalues    null
buf append
else
buf append variablevalues
buf append
buf append names  append
assert variablevalues length    names length       variablevalues length
names length       buf
if  variablevalues    null
buf append
else
buf append variablevalues
buf append
if  parent    null
buf append
parent tostring buf  indent
return buf tostring