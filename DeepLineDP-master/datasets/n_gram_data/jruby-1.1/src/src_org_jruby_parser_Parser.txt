/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby parser
import java io bytearrayinputstream
import java io inputstream
import org jruby ruby
import org jruby rubyarray
import org jruby rubyfile
import org jruby rubyhash
import org jruby rubystring
import org jruby ast node
import org jruby common nullwarnings
//import org.jruby.lexer.yacc.bytelistlexersource;
import org jruby lexer yacc lexersource
import org jruby lexer yacc syntaxexception
import org jruby runtime dynamicscope
import org jruby runtime threadcontext
import org jruby runtime builtin irubyobject
import org jruby util bytelist
/**
* serves as a simple facade for all the parsing magic.
*/
public class parser
private final ruby runtime
public parser ruby runtime
this runtime   runtime
}
public node parserewriter string file  inputstream content
parserconfiguration configuration  throws syntaxexception
defaultrubyparser parser   rubyparserpool getinstance   borrowparser
try {
parser setwarnings new nullwarnings
lexersource lexersource   lexersource getsource file  content  null  configuration
return parser parse configuration  lexersource  getast
} finally {
rubyparserpool.getinstance().returnparser(parser);
}
}
@suppresswarnings
public node parse string file  bytelist content  dynamicscope blockscope
parserconfiguration configuration
return parse file  new bytearrayinputstream content bytes     blockscope  configuration
/*
// make a shared copy in case someone modifies this bytelist while we are parsing
content = new bytelist(content, false);
irubyobject scriptlines = runtime.getobject().getconstantat("script_lines__");
rubyarray list = null;
if (!configuration.isevalparse() && scriptlines != null) {
if (scriptlines instanceof rubyhash) {
rubystring filename = runtime.newstring(file);
irubyobject object = ((rubyhash) scriptlines).op_aref(filename);
list = (rubyarray) (object instanceof rubyarray ? object : runtime.newarray());
((rubyhash) scriptlines).op_aset(filename, list);
}
}
// we only need to pass in current scope if we are evaluating as a block (which
// is only done for evals).  we need to pass this in so that we can appropriately scope
// down to captured scopes when we are parsing.
if (blockscope != null) {
configuration.parseasblock(blockscope);
}
defaultrubyparser parser = null;
rubyparserresult result = null;
try {
parser = rubyparserpool.getinstance().borrowparser();
parser.setwarnings(runtime.getwarnings());
lexersource lexersource = bytelistlexersource.getsource(file, content, list, configuration);
result = parser.parse(configuration, lexersource);
if (result.getendoffset() >= 0) {
org.jruby.runtime.builtin.irubyobject verbose = runtime.getverbose();
runtime.setverbose(runtime.getnil());
content.begin = content.begin +  result.getendoffset();
runtime.defineglobalconstant("data", new rubyfile(runtime, file, new bytearrayinputstream(content.bytes())));
runtime.setverbose(verbose);
result.setendoffset(-1);
}
} catch (syntaxexception e) {
stringbuffer buffer = new stringbuffer(100);
buffer.append(e.getposition().getfile()).append(':');
buffer.append(e.getposition().getendline() + 1).append(": ");
buffer.append(e.getmessage());
throw runtime.newsyntaxerror(buffer.tostring());
} finally {
rubyparserpool.getinstance().returnparser(parser);
}
// if variables were added then we may need to grow the dynamic scope to match the static
// one.
// fixme: make this so we only need to check this for blockscope != null.  we cannot
// currently since we create the dynamicscope for a localstaticscope before parse begins.
// refactoring should make this fixable.
if (result.getscope() != null) {
result.getscope().growifneeded();
}
return result.getast();
*/
}
@suppresswarnings
public node parse string file  inputstream content  dynamicscope blockscope
parserconfiguration configuration
irubyobject scriptlines   runtime getobject   fastgetconstantat
rubyarray list = null;
if (!configuration.isevalparse() && scriptlines != null) {
if (scriptlines instanceof rubyhash) {
rubystring filename = runtime.newstring(file);
threadcontext context   runtime getcurrentcontext
irubyobject object     rubyhash  scriptlines  op_aref context  filename
list = (rubyarray) (object instanceof rubyarray ? object : runtime.newarray());
rubyhash  scriptlines  op_aset context  filename  list
}
}
// we only need to pass in current scope if we are evaluating as a block (which
// is only done for evals).  we need to pass this in so that we can appropriately scope
// down to captured scopes when we are parsing.
if (blockscope != null) {
configuration.parseasblock(blockscope);
}
defaultrubyparser parser = null;
rubyparserresult result = null;
try {
parser = rubyparserpool.getinstance().borrowparser();
parser.setwarnings(runtime.getwarnings());
lexersource lexersource   lexersource getsource file  content  list  configuration
result = parser.parse(configuration, lexersource);
if (result.getendoffset() >= 0) {
irubyobject verbose   runtime getverbose
runtime.setverbose(runtime.getnil());
runtime defineglobalconstant    new rubyfile runtime  file  content
runtime.setverbose(verbose);
result.setendoffset(-1);
}
} catch (syntaxexception e) {
stringbuffer buffer = new stringbuffer(100);
buffer.append(e.getposition().getfile()).append(':');
buffer.append(e.getposition().getendline() + 1).append(": ");
buffer.append(e.getmessage());
throw runtime.newsyntaxerror(buffer.tostring());
} finally {
rubyparserpool.getinstance().returnparser(parser);
}
// if variables were added then we may need to grow the dynamic scope to match the static
// one.
// fixme: make this so we only need to check this for blockscope != null.  we cannot
// currently since we create the dynamicscope for a localstaticscope before parse begins.
// refactoring should make this fixable.
if (result.getscope() != null) {
result.getscope().growifneeded();
}
return result.getast();
}
}