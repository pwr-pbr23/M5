/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2004 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 miguel covarrubias <mlcovarrubias@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby internal runtime
import java lang ref softreference
import java util concurrent locks reentrantlock
import java util arraylist
import java util collections
import java util iterator
import java util list
import java util set
import org jruby ruby
import org jruby rubythread
import org jruby runtime threadcontext
import org jruby util collections weakhashset
public class threadservice
private ruby runtime
private threadcontext maincontext
private threadlocal<softreference> localcontext
private threadgroup rubythreadgroup
private set rubythreadlist
private thread mainthread
private reentrantlock criticallock   new reentrantlock
public threadservice ruby runtime
this runtime   runtime
this maincontext   threadcontext newcontext runtime
this localcontext   new threadlocal
this rubythreadgroup   new threadgroup     runtime hashcode
this rubythreadlist   collections synchronizedset new weakhashset
// must be called from main thread (it is currently, but this bothers me)
mainthread   thread currentthread
localcontext set new softreference maincontext
rubythreadlist add mainthread
public void disposecurrentthread
localcontext set null
/**
* in order to provide an appropriate execution context for a given thread,
* we store threadcontext instances in a threadlocal. this method is a utility
* to get at that threadlocal context from anywhere in the program it may
* not be immediately available. this method should be used sparingly, and
* if it is possible to pass threadcontext on the argument list, it is
* preferable.
*
* <b>description of behavior</b>
*
* the threadlocal does not actually contain the threadcontext directly;
* instead, it contains a softreference that holds the threadcontext. this
* is to allow new threads to enter the system and execute ruby code with
* a valid context, but still allow that context to garbage collect if the
* thread stays alive much longer. we use softreference here because
* weakreference is collected too quickly, resulting in very expensive
* threadcontext churn (and this originally lead to jruby-2261's leak of
* adopted rubythread instances).
*
* @return the threadcontext instance for the current thread, or a new one
* if none has previously been created or the old threadcontext has been
* collected.
*/
public threadcontext getcurrentcontext
softreference sr   null
threadcontext context   null
while  context    null
// loop until a context is available, to clean up softrefs that might have been collected
if   sr    softreference localcontext get       null
sr   adoptcurrentthread
context    threadcontext sr get
else
context    threadcontext sr get
// context is null, wipe out the softreference (this could be done with a reference queue)
if  context    null
localcontext set null
return context
private softreference adoptcurrentthread
thread current   thread currentthread
rubythread adopt runtime getthread    current
return  softreference  localcontext get
public rubythread getmainthread
return maincontext getthread
public void setmainthread rubythread thread
maincontext setthread thread
public synchronized rubythread getactiverubythreads
// all threads in ruby thread group plus main thread
synchronized rubythreadlist
list rtlist   new arraylist rubythreadlist size
for  iterator iter   rubythreadlist iterator    iter hasnext
thread t    thread iter next
if   t isalive    continue
rubythread rt   getrubythreadfromthread t
rtlist add rt
rubythread rubythreads   new rubythread
rtlist toarray rubythreads
return rubythreads
public threadgroup getrubythreadgroup
return rubythreadgroup
public synchronized threadcontext registernewthread rubythread thread
threadcontext context   threadcontext newcontext runtime
localcontext set new softreference context
getcurrentcontext   setthread thread
// this requires register to be called from within the registree thread
rubythreadlist add thread currentthread
return context
public synchronized void unregisterthread rubythread thread
rubythreadlist remove thread currentthread
getcurrentcontext   setthread null
localcontext set null
private rubythread getrubythreadfromthread thread activethread
rubythread rubythread
if  activethread instanceof rubynativethread
rubynativethread rubynativethread    rubynativethread activethread
rubythread   rubynativethread getrubythread
else
// main thread
rubythread   maincontext getthread
return rubythread
public void setcritical boolean critical
if  criticallock isheldbycurrentthread
if  critical
// do nothing
else
criticallock unlock
else
if  critical
criticallock lock
else
// do nothing
public boolean getcritical
return criticallock isheldbycurrentthread
public void waitforcritical
if  criticallock islocked
criticallock lock
criticallock unlock