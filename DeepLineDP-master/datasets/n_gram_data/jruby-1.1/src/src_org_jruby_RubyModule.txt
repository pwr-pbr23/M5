/*
**** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2001 chad fowler <chadfowler@chadfowler.com>
* copyright (c) 2001 alan moore <alan_moore@gmx.net>
* copyright (c) 2001-2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2001-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004-2005 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006-2007 miguel covarrubias <mlcovarrubias@gmail.com>
* copyright (c) 2007 william n dortch <bill.dortch@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby
import java lang reflect method
import java util arraylist
import java util collections
import java util hashmap
import java util iterator
import java util hashset
import java util list
import java util map
import java util set
import java util concurrent concurrenthashmap
import java util concurrent locks reentrantlock
import org jruby anno jrubymethod
import org jruby common irubywarnings id
import org jruby compiler astinspector
import org jruby internal runtime methods aliasmethod
import org jruby internal runtime methods dynamicmethod
import org jruby internal runtime methods fullfunctioncallbackmethod
import org jruby internal runtime methods simplecallbackmethod
import org jruby internal runtime methods methodmethod
import org jruby internal runtime methods procmethod
import org jruby internal runtime methods undefinedmethod
import org jruby internal runtime methods wrappermethod
import org jruby parser staticscope
import org jruby runtime arity
import org jruby runtime block
import org jruby runtime cachemap
import org jruby runtime callbackfactory
import org jruby runtime dispatcher
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
import org jruby runtime builtin variable
import org jruby runtime callback callback
import org jruby runtime component variableentry
import org jruby runtime marshal marshalstream
import org jruby runtime marshal unmarshalstream
import org jruby util classprovider
import org jruby util idutil
import org jruby exceptions raiseexception
import org jruby internal runtime methods javamethod
import org jruby runtime classindex
import org jruby runtime methodfactory
import org jruby runtime methodindex
/**
*
* @author  jpetersen
*/
public class rubymodule extends rubyobject
public static rubyclass createmoduleclass ruby runtime  rubyclass moduleclass
moduleclass index   classindex module
moduleclass kindof   new rubymodule kindof
public boolean iskindof irubyobject obj  rubymodule type
return obj instanceof rubymodule
callbackfactory callbackfactory   runtime callbackfactory rubymodule class
moduleclass defineannotatedmethods rubymodule class
moduleclass dispatcher   callbackfactory createdispatcher moduleclass
callbackfactory   runtime callbackfactory rubykernel class
moduleclass definefastmethod    callbackfactory getfastsingletonmethod    rubykernel iruby_object  rubykernel iruby_object
moduleclass definefastmethod    callbackfactory getfastsingletonmethod    rubykernel iruby_object
return moduleclass
static objectallocator module_allocator   new objectallocator
public irubyobject allocate ruby runtime  rubyclass klass
return new rubymodule runtime  klass
public int getnativetypeindex
return classindex module
public boolean ismodule
return true
public boolean isclass
return false
public boolean issingleton
return false
// superclass may be null.
protected rubyclass superclass
public int index
public dispatcher dispatcher   dispatcher default_dispatcher
public static class kindof
public static final kindof default_kind_of   new kindof
public boolean iskindof irubyobject obj  rubymodule type
return obj getmetaclass   hasmoduleinhierarchy type
public boolean isinstance irubyobject object
return kindof iskindof object  this
public kindof kindof   kindof default_kind_of
public final int id
// containing class...the parent of object is null. object should always be last in chain.
public rubymodule parent
// classid is the name of the class/module sans where it is located.
// if it is null, then it an anonymous class.
protected string classid
// constant table
// lock used for variabletable/constanttable writes. the rubyobject variabletable
// write methods are overridden here to use this lock rather than java
// synchronization for faster concurrent writes for modules/classes.
protected final reentrantlock variablewritelock   new reentrantlock
protected transient volatile constanttableentry constanttable
new constanttableentry
protected transient int constanttablesize
protected transient int constanttablethreshold
int  constant_table_default_capacity   constant_table_load_factor
private final map<string  dynamicmethod> methods   new concurrenthashmap<string  dynamicmethod> 12  0 75f  1
// classproviders return java class/module (in #defineorgetclassunder and
// #defineorgetmoduleunder) when class/module is opened using colon syntax.
private transient list<classprovider> classproviders
/** separate path for metaclass construction
*
*/
protected rubymodule ruby runtime  rubyclass metaclass  boolean objectspace
super runtime  metaclass  objectspace
id   runtime allocmoduleid
// if (parent == null) parent = runtime.getobject();
setflag user7_f   isclass
/** used by module_allocator and rubyclass constructors
*
*/
protected rubymodule ruby runtime  rubyclass metaclass
this runtime  metaclass  runtime isobjectspaceenabled
/** standard path for module construction
*
*/
protected rubymodule ruby runtime
this runtime  runtime getmodule
public boolean needsimplementer
return getflag user7_f
/** rb_module_new
*
*/
public static rubymodule newmodule ruby runtime
return new rubymodule runtime
/** rb_module_new/rb_define_module_id/rb_name_class/rb_set_class_path
*
*/
public static rubymodule newmodule ruby runtime  string name  rubymodule parent  boolean setparent
rubymodule module   newmodule runtime
module setbasename name
if  setparent  module setparent parent
parent setconstant name  module
return module
// synchronized method per jruby-1173 (unsafe double-checked locking)
// fixme: synchronization is still wrong in cp code
public synchronized void addclassprovider classprovider provider
if  classproviders    null
list<classprovider> cp   collections synchronizedlist new arraylist<classprovider>
cp add provider
classproviders   cp
else
synchronized classproviders
if   classproviders contains provider
classproviders add provider
public void removeclassprovider classprovider provider
if  classproviders    null
classproviders remove provider
private rubyclass searchprovidersforclass string name  rubyclass superclazz
if  classproviders    null
synchronized classproviders
rubyclass clazz
for  classprovider classprovider  classproviders
if   clazz   classprovider defineclassunder this  name  superclazz      null
return clazz
return null
private rubymodule searchprovidersformodule string name
if  classproviders    null
synchronized classproviders
rubymodule module
for  classprovider classprovider  classproviders
if   module   classprovider definemoduleunder this  name      null
return module
return null
public dispatcher getdispatcher
return dispatcher
/** getter for property superclass.
* @return value of property superclass.
*/
public rubyclass getsuperclass
return superclass
protected void setsuperclass rubyclass superclass
this superclass   superclass
public rubymodule getparent
return parent
public void setparent rubymodule parent
this parent   parent
public map<string  dynamicmethod> getmethods
return methods
// note that addmethod now does its own put, so any change made to
// functionality here should be made there as well
private void putmethod string name  dynamicmethod method
// fixme: kinda hacky...flush sti here
dispatcher clearindex methodindex getindex name
getmethods   put name  method
/**
* is this module one that in an included one (e.g. an includedmodulewrapper).
*/
public boolean isincluded
return false
public rubymodule getnonincludedclass
return this
public string getbasename
return classid
public void setbasename string name
classid   name
/**
* generate a fully-qualified class name or a #-style name for anonymous and singleton classes.
*
* ruby c equivalent = "classname"
*
* @return the generated class name
*/
public string getname
if  getbasename      null
if  isclass
return             integer tohexstring system identityhashcode this
else
return             integer tohexstring system identityhashcode this
stringbuffer result   new stringbuffer getbasename
rubyclass objectclass   getruntime   getobject
for  rubymodule p   this getparent    p    null    p    objectclass  p   p getparent
string pname   p getbasename
// this is needed when the enclosing class or module is a singleton.
// in that case, we generated a name such as null::foo, which broke
// marshalling, among others. the correct thing to do in this situation
// is to insert the generate the name of form #<class:01xasdfasd> if
// it's a singleton module/class, which this code accomplishes.
if pname    null
pname   p getname
result insert 0     insert 0  pname
return result tostring
/**
* create a wrapper to use for including the specified module into this one.
*
* ruby c equivalent = "include_class_new"
*
* @return the module wrapper
*/
public includedmodulewrapper newincludeclass rubyclass superclazz
includedmodulewrapper includedmodule   new includedmodulewrapper getruntime    superclazz  this
// include its parent (and in turn that module's parents)
if  getsuperclass      null
includedmodule includemodule getsuperclass
return includedmodule
/**
* finds a class that is within the current module (or class).
*
* @param name to be found in this module (or class)
* @return the class or null if no such class
*/
public rubyclass getclass string name
irubyobject module
if   module   getconstantat name   instanceof rubyclass
return  rubyclass module
return null
public rubyclass fastgetclass string internedname
irubyobject module
if   module   fastgetconstantat internedname   instanceof rubyclass
return  rubyclass module
return null
/**
* include a new module in this module or class.
*
* @param arg the module to include
*/
public synchronized void includemodule irubyobject arg
assert arg    null
testfrozen
if   istaint
getruntime   secure 4
if    arg instanceof rubymodule
throw getruntime   newtypeerror     arg getmetaclass   getname
rubymodule module    rubymodule  arg
// make sure the module we include does not already exist
if  issame module
return
infectby module
doincludemodule module
public void definemethod string name  callback method
visibility visibility   name equals    ?
visibility private   visibility public
addmethod name  new fullfunctioncallbackmethod this  method  visibility
public void defineannotatedmethod class clazz  string name
// fixme: this is probably not very efficient, since it loads all methods for each call
boolean foundmethod   false
for  method method   clazz getdeclaredmethods
if  method getname   equals name     defineannotatedmethod method  methodfactory createfactory getruntime   getjrubyclassloader
foundmethod   true
if   foundmethod
throw new runtimeexception     name       clazz getname
public void defineannotatedmethods class clazz
if  rubyinstanceconfig indexed_methods
defineannotatedmethodsindexed clazz
else
defineannotatedmethodsindividually clazz
public void defineannotatedmethodsindividually class clazz
method declaredmethods   clazz getdeclaredmethods
methodfactory methodfactory   methodfactory createfactory getruntime   getjrubyclassloader
for  method method  declaredmethods
defineannotatedmethod method  methodfactory
private void defineannotatedmethodsindexed class clazz
methodfactory methodfactory   methodfactory createfactory getruntime   getjrubyclassloader
methodfactory defineindexedannotatedmethods this  clazz  methoddefiningcallback
private static methodfactory methoddefiningcallback methoddefiningcallback   new methodfactory methoddefiningcallback
public void define rubymodule module  method method  dynamicmethod dynamicmethod
jrubymethod jrubymethod   method getannotation jrubymethod class
if  jrubymethod frame
for  string name   jrubymethod name
astinspector frame_aware_methods add name
if jrubymethod compat      compatversion both
module getruntime   getinstanceconfig   getcompatversion      jrubymethod compat
rubymodule metaclass   module metaclass
if  jrubymethod meta
string basename
if  jrubymethod name   length    0
basename   method getname
metaclass addmethod basename  dynamicmethod
else
basename   jrubymethod name
for  string name   jrubymethod name
metaclass addmethod name  dynamicmethod
if  jrubymethod alias   length > 0
for  string alias   jrubymethod alias
metaclass definealias alias  basename
else
string basename
if  jrubymethod name   length    0
basename   method getname
module addmethod method getname    dynamicmethod
else
basename   jrubymethod name
for  string name   jrubymethod name
module addmethod name  dynamicmethod
if  jrubymethod alias   length > 0
for  string alias   jrubymethod alias
module definealias alias  basename
if  jrubymethod module
// module/singleton methods are all defined public
dynamicmethod modulemethod   dynamicmethod dup
modulemethod setvisibility visibility public
rubymodule singletonclass   module getsingletonclass
if  jrubymethod name   length    0
basename   method getname
singletonclass addmethod method getname    modulemethod
else
basename   jrubymethod name
for  string name   jrubymethod name
singletonclass addmethod name  modulemethod
if  jrubymethod alias   length > 0
for  string alias   jrubymethod alias
singletonclass definealias alias  basename
public boolean defineannotatedmethod method method  methodfactory methodfactory
jrubymethod jrubymethod   method getannotation jrubymethod class
if  jrubymethod    null  return false
if jrubymethod compat      compatversion both
getruntime   getinstanceconfig   getcompatversion      jrubymethod compat
dynamicmethod dynamicmethod   methodfactory getannotatedmethod this  method
methoddefiningcallback define this  method  dynamicmethod
return true
return false
public void definefastmethod string name  callback method
visibility visibility   name equals    ?
visibility private   visibility public
addmethod name  new simplecallbackmethod this  method  visibility
public void definefastmethod string name  callback method  visibility visibility
addmethod name  new simplecallbackmethod this  method  visibility
public void defineprivatemethod string name  callback method
addmethod name  new fullfunctioncallbackmethod this  method  visibility private
public void definefastprivatemethod string name  callback method
addmethod name  new simplecallbackmethod this  method  visibility private
public void definefastprotectedmethod string name  callback method
addmethod name  new simplecallbackmethod this  method  visibility protected
public void undefinemethod string name
addmethod name  undefinedmethod getinstance
/** rb_undef
*
*/
public void undef threadcontext context  string name
ruby runtime   getruntime
if  this    runtime getobject
runtime secure 4
if  runtime getsafelevel   >  4     istaint
throw new securityexception
testfrozen
if  name equals       name equals
getruntime   getwarnings   warn id undefining_bad     name
dynamicmethod method   searchmethod name
if  method isundefined
string s0
rubymodule c   this
if  c issingleton
irubyobject obj     metaclass c  getattached
if  obj    null    obj instanceof rubymodule
c    rubymodule  obj
s0
else if  c ismodule
s0
throw getruntime   newnameerror     name       s0       c getname        name
addmethod name  undefinedmethod getinstance
if  issingleton
irubyobject singleton     metaclass this  getattached
singleton callmethod context     getruntime   newsymbol name
else
callmethod context     getruntime   newsymbol name
@jrubymethod name      required   1
public irubyobject include_p irubyobject arg
if   arg ismodule
throw getruntime   newtypeerror arg  getruntime   getmodule
for  rubymodule p   this  p    null  p   p getsuperclass
if   p instanceof includedmodulewrapper       includedmodulewrapper  p  getnonincludedclass      arg
return getruntime   newboolean true
return getruntime   newboolean false
// todo: consider a better way of synchronizing
public void addmethod string name  dynamicmethod method
if  this    getruntime   getobject
getruntime   secure 4
if  getruntime   getsafelevel   >  4     istaint
throw getruntime   newsecurityerror
testfrozen
// we can safely reference methods here instead of doing getmethods() since if we
// are adding we are not using a includedmodulewrapper.
synchronized getmethods
// if we add a method which already is cached in this class, then we should update the
// cachemap so it stays up to date.
dynamicmethod existingmethod   getmethods   put name  method
if  existingmethod    null
getruntime   getcachemap   remove existingmethod
// note: duplicating functionality from putmethod, since we
// remove/put atomically here
dispatcher clearindex methodindex getindex name
public void removemethod threadcontext context  string name
if  this    getruntime   getobject
getruntime   secure 4
if  getruntime   getsafelevel   >  4     istaint
throw getruntime   newsecurityerror
testfrozen
// we can safely reference methods here instead of doing getmethods() since if we
// are adding we are not using a includedmodulewrapper.
synchronized getmethods
dynamicmethod method    dynamicmethod  getmethods   remove name
if  method    null
throw getruntime   newnameerror     name       getname    name
getruntime   getcachemap   remove method
if issingleton
irubyobject singleton     metaclass this  getattached
singleton callmethod context     getruntime   newsymbol name
else
callmethod context     getruntime   newsymbol name
/**
* search through this module and supermodules for method definitions. cache superclass definitions in this class.
*
* @param name the name of the method to search for
* @return the method, or undefinedmethod if not found
*/
public dynamicmethod searchmethod string name
for  rubymodule searchmodule   this  searchmodule    null  searchmodule   searchmodule getsuperclass
// see if current class has method or if it has been cached here already
dynamicmethod method    dynamicmethod  searchmodule getmethods   get name
if  method    null
return method
return undefinedmethod getinstance
/**
* search through this module and supermodules for method definitions. cache superclass definitions in this class.
*
* @param name the name of the method to search for
* @return the method, or undefinedmethod if not found
*/
public dynamicmethod retrievemethod string name
return  dynamicmethod getmethods   get name
/**
* search through this module and supermodules for method definitions. cache superclass definitions in this class.
*
* @param name the name of the method to search for
* @return the method, or undefinedmethod if not found
*/
public rubymodule findimplementer rubymodule clazz
for  rubymodule searchmodule   this  searchmodule    null  searchmodule   searchmodule getsuperclass
if  searchmodule issame clazz
return searchmodule
return null
public void addmodulefunction string name  dynamicmethod method
addmethod name  method
getsingletonclass   addmethod name  method
/** rb_define_module_function
*
*/
public void definemodulefunction string name  callback method
defineprivatemethod name  method
getsingletonclass   definemethod name  method
/** rb_define_module_function
*
*/
public void definepublicmodulefunction string name  callback method
definemethod name  method
getsingletonclass   definemethod name  method
/** rb_define_module_function
*
*/
public void definefastmodulefunction string name  callback method
definefastprivatemethod name  method
getsingletonclass   definefastmethod name  method
/** rb_define_module_function
*
*/
public void definefastpublicmodulefunction string name  callback method
definefastmethod name  method
getsingletonclass   definefastmethod name  method
/** rb_alias
*
*/
public synchronized void definealias string name  string oldname
testfrozen
if  oldname equals name
return
ruby runtime   getruntime
if  this    runtime getobject
runtime secure 4
dynamicmethod method   searchmethod oldname
dynamicmethod oldmethod   searchmethod name
if  method isundefined
if  ismodule
method   runtime getobject   searchmethod oldname
if  method isundefined
throw runtime newnameerror     oldname
ismodule   ?              getname        oldname
cachemap cachemap   runtime getcachemap
cachemap remove method
cachemap remove oldmethod
if  oldmethod    oldmethod getrealmethod
cachemap remove oldmethod getrealmethod
putmethod name  new aliasmethod this  method  oldname
public synchronized void definealiases list<string> aliases  string oldname
testfrozen
ruby runtime   getruntime
if  this    runtime getobject
runtime secure 4
dynamicmethod method   searchmethod oldname
if  method isundefined
if  ismodule
method   runtime getobject   searchmethod oldname
if  method isundefined
throw runtime newnameerror     oldname
ismodule   ?              getname        oldname
cachemap cachemap   runtime getcachemap
cachemap remove method
for  string name  aliases
if  oldname equals name   continue
dynamicmethod oldmethod   searchmethod name
cachemap remove oldmethod
if  oldmethod    oldmethod getrealmethod
cachemap remove oldmethod getrealmethod
putmethod name  new aliasmethod this  method  oldname
/** this method should be used only by interpreter or compiler
*
*/
public rubyclass defineorgetclassunder string name  rubyclass superclazz
// this method is intended only for defining new classes in ruby code,
// so it uses the allocator of the specified superclass or default to
// the object allocator. it should not be used to define classes that require a native allocator.
ruby runtime   getruntime
irubyobject classobj   getconstantat name
rubyclass clazz
if  classobj    null
if    classobj instanceof rubyclass   throw runtime newtypeerror name
clazz    rubyclass classobj
if  superclazz    null
rubyclass tmp   clazz getsuperclass
while  tmp    null    tmp isincluded    tmp   tmp getsuperclass       need to skip includedmodulewrappers
if  tmp    null  tmp   tmp getrealclass
if  tmp    superclazz  throw runtime newtypeerror     name
// superclazz = null;
if  runtime getsafelevel   >  4  throw runtime newtypeerror
else if  classproviders    null     clazz   searchprovidersforclass name  superclazz      null
// reopen a java class
else
if  superclazz    null  superclazz   runtime getobject
clazz   rubyclass newclass runtime  superclazz  name  superclazz getallocator    this  true
return clazz
/** this method should be used only by interpreter or compiler
*
*/
public rubymodule defineorgetmoduleunder string name
// this method is intended only for defining new modules in ruby code
ruby runtime   getruntime
irubyobject moduleobj   getconstantat name
rubymodule module
if  moduleobj    null
if   moduleobj ismodule    throw runtime newtypeerror name
if  runtime getsafelevel   >  4  throw runtime newsecurityerror
module    rubymodule moduleobj
else if  classproviders    null     module   searchprovidersformodule name      null
// reopen a java module
else
module   rubymodule newmodule runtime  name  this  true
return module
/** rb_define_class_under
*  this method should be used only as an api to define/open nested classes
*/
public rubyclass defineclassunder string name  rubyclass superclass  objectallocator allocator
return getruntime   defineclassunder name  superclass  allocator  this
/** rb_define_module_under
*  this method should be used only as an api to define/open nested module
*/
public rubymodule definemoduleunder string name
return getruntime   definemoduleunder name  this
// fixme: create attrreadermethod, attrwritermethod, for faster attr access
private void addaccessor threadcontext context  string internedname  boolean readable  boolean writeable
assert internedname    internedname intern     internedname
final ruby runtime   getruntime
// check the visibility of the previous frame, which will be the frame in which the class is being eval'ed
visibility attributescope   context getcurrentvisibility
if  attributescope    visibility private
//fixme warning
else if  attributescope    visibility module_function
attributescope   visibility private
// fixme warning
final string variablename        internedname  intern
if  readable
// fixme: should visibility be set to current visibility?
addmethod internedname  new javamethod this  visibility public
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject args  block block
if  args length    0  arity raiseargumenterror runtime  args length  0  0
irubyobject variable   self getinstancevariables   fastgetinstancevariable variablename
return variable    null ? runtime getnil     variable
public arity getarity
return arity noarguments
callmethod context     runtime fastnewsymbol internedname
if  writeable
internedname    internedname      intern
// fixme: should visibility be set to current visibility?
addmethod internedname  new javamethod this  visibility public
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject args  block block
// enebo: can anyone get args to be anything but length 1?
if  args length    1  arity raiseargumenterror runtime  args length  1  1
return self getinstancevariables   fastsetinstancevariable variablename  args
public arity getarity
return arity singleargument
callmethod context     runtime fastnewsymbol internedname
/** set_method_visibility
*
*/
public void setmethodvisibility irubyobject methods  visibility visibility
if  getruntime   getsafelevel   >  4     istaint
throw getruntime   newsecurityerror
for  int i   0  i < methods length  i
exportmethod methods asjavastring    visibility
/** rb_export_method
*
*/
public void exportmethod string name  visibility visibility
if  this    getruntime   getobject
getruntime   secure 4
dynamicmethod method   searchmethod name
if  method isundefined
throw getruntime   newnameerror     name
ismodule   ?              getname        name
if  method getvisibility      visibility
if  this    method getimplementationclass
method setvisibility visibility
else
// fixme: why was this using a fullfunctioncallbackmethod before that did callsuper?
addmethod name  new wrappermethod this  method  visibility
/**
* mri: rb_method_boundp
*
*/
public boolean ismethodbound string name  boolean checkvisibility
dynamicmethod method   searchmethod name
if   method isundefined
return   checkvisibility    method getvisibility      visibility private
return false
public irubyobject newmethod irubyobject receiver  string name  boolean bound
dynamicmethod method   searchmethod name
if  method isundefined
throw getruntime   newnameerror     name
this getname        name
rubymodule implementationmodule   method getimplementationclass
rubymodule originmodule   this
while  originmodule    implementationmodule    originmodule issingleton
originmodule     metaclass originmodule  getrealclass
rubymethod newmethod   null
if  bound
newmethod   rubymethod newmethod implementationmodule  name  originmodule  name  method  receiver
else
newmethod   rubyunboundmethod newunboundmethod implementationmodule  name  originmodule  name  method
newmethod infectby this
return newmethod
// what is argument 1 for in this method? a method or proc object /ob
@jrubymethod name      required   1  optional   1  frame   true  visibility   visibility private
public irubyobject define_method threadcontext context  irubyobject args  block block
if  args length < 1    args length > 2
throw getruntime   newargumenterror     args length
irubyobject body
string name   args asjavastring   intern
dynamicmethod newmethod   null
visibility visibility   context getcurrentvisibility
if  visibility    visibility module_function  visibility   visibility private
if  args length    1
// double-testing args.length here, but it avoids duplicating the proc-setup code in two places
rubyproc proc   getruntime   newproc block type lambda  block
body   proc
// a normal block passed to define_method changes to do arity checking; make it a lambda
proc getblock   type   block type lambda
newmethod   createprocmethod name  visibility  proc
else if  args length    2
if  getruntime   getproc   isinstance args
// double-testing args.length here, but it avoids duplicating the proc-setup code in two places
rubyproc proc    rubyproc args
body   proc
newmethod   createprocmethod name  visibility  proc
else if  getruntime   getmethod   isinstance args
rubymethod method    rubymethod args
body   method
newmethod   new methodmethod this  method unbind null   visibility
else
throw getruntime   newtypeerror     args gettype   getname
else
throw getruntime   newargumenterror     args length
addmethod name  newmethod
rubysymbol symbol   getruntime   fastnewsymbol name
if  context getpreviousvisibility      visibility module_function
getsingletonclass   addmethod name  new wrappermethod getsingletonclass    newmethod  visibility public
if issingleton
irubyobject singleton     metaclass this  getattached
singleton callmethod context     symbol
else
callmethod context     symbol
return body
private dynamicmethod createprocmethod string name  visibility visibility  rubyproc proc
proc getblock   getbinding   getframe   setklazz this
proc getblock   getbinding   getframe   setname name
// for zsupers in define_method (blech!) we tell the proc scope to act as the "argument" scope
proc getblock   getbody   getstaticscope   setargumentscope true
// just using required is broken...but no more broken than before zsuper refactoring
proc getblock   getbody   getstaticscope   setrequiredargs proc getblock   arity   required
return new procmethod this  proc  visibility
public irubyobject executeunder threadcontext context  callback method  irubyobject args  block block
context preexecuteunder this  block
try
return method execute this  args  block
finally
context postexecuteunder
@jrubymethod name
public rubystring name
return getruntime   newstring getbasename      null ?     getname
protected irubyobject clonemethods rubymodule clone
rubymodule realtype   this getnonincludedclass
for  map entry<string  dynamicmethod> entry   getmethods   entryset
dynamicmethod method   entry getvalue
// do not clone cached methods
// fixme: mri copies all methods here
if  method getimplementationclass      realtype    method instanceof undefinedmethod
// a cloned method now belongs to a new class.  set it.
// todo: make dynamicmethod immutable
dynamicmethod clonedmethod   method dup
clonedmethod setimplementationclass clone
clone putmethod entry getkey    clonedmethod
return clone
/** rb_mod_init_copy
*
*/
@jrubymethod name      required   1
public irubyobject initialize_copy irubyobject original
super initialize_copy original
rubymodule originalmodule    rubymodule original
if   getmetaclass   issingleton    setmetaclass originalmodule getsingletonclassclone
setsuperclass originalmodule getsuperclass
if  originalmodule hasvariables
syncvariables originalmodule getvariablelist
originalmodule clonemethods this
return this
/** rb_mod_included_modules
*
*/
@jrubymethod name
public rubyarray included_modules
rubyarray ary   getruntime   newarray
for  rubymodule p   getsuperclass    p    null  p   p getsuperclass
if  p isincluded
ary append p getnonincludedclass
return ary
/** rb_mod_ancestors
*
*/
@jrubymethod name
public rubyarray ancestors
rubyarray ary   getruntime   newarray getancestorlist
return ary
public list<irubyobject> getancestorlist
arraylist<irubyobject> list   new arraylist<irubyobject>
for  rubymodule p   this  p    null  p   p getsuperclass
if  p issingleton
list add p getnonincludedclass
return list
public boolean hasmoduleinhierarchy rubymodule type
// xxx: this check previously used callmethod("==") to check for equality between classes
// when scanning the hierarchy. however the == check may be safe; we should only ever have
// one instance bound to a given type/constant. if it's found to be unsafe, examine ways
// to avoid the == call.
for  rubymodule p   this  p    null  p   p getsuperclass
if  p getnonincludedclass      type  return true
return false
public int hashcode
return id
@jrubymethod name
public rubyfixnum hash
return getruntime   newfixnum id
/** rb_mod_to_s
*
*/
@jrubymethod name
public irubyobject to_s
if issingleton
irubyobject attached     metaclass this  getattached
stringbuffer buffer   new stringbuffer
if attached instanceof rubyclass    attached instanceof rubymodule
buffer append attached inspect
else
buffer append attached anytostring
buffer append
return getruntime   newstring buffer tostring
return getruntime   newstring getname
/** rb_mod_eqq
*
*/
@jrubymethod name      required   1
public rubyboolean op_eqq irubyobject obj
return getruntime   newboolean isinstance obj
@jrubymethod name      required   1
public irubyobject op_equal threadcontext context  irubyobject other
return super op_equal context  other
/** rb_mod_freeze
*
*/
@jrubymethod name
public irubyobject freeze
to_s
return super freeze
/** rb_mod_le
*
*/
@jrubymethod name      required   1
public irubyobject op_le irubyobject obj
if    obj instanceof rubymodule
throw getruntime   newtypeerror
if  iskindofmodule  rubymodule  obj
return getruntime   gettrue
else if    rubymodule  obj  iskindofmodule this
return getruntime   getfalse
return getruntime   getnil
/** rb_mod_lt
*
*/
@jrubymethod name      required   1
public irubyobject op_lt irubyobject obj
return obj    this ? getruntime   getfalse     op_le obj
/** rb_mod_ge
*
*/
@jrubymethod name      required   1
public irubyobject op_ge irubyobject obj
if    obj instanceof rubymodule
throw getruntime   newtypeerror
return   rubymodule  obj  op_le this
/** rb_mod_gt
*
*/
@jrubymethod name      required   1
public irubyobject op_gt irubyobject obj
return this    obj ? getruntime   getfalse     op_ge obj
/** rb_mod_cmp
*
*/
@jrubymethod name      required   1
public irubyobject op_cmp irubyobject obj
if  this    obj  return getruntime   newfixnum 0
if    obj instanceof rubymodule   return getruntime   getnil
rubymodule module    rubymodule  obj
if  module iskindofmodule this
return getruntime   newfixnum 1
else if  this iskindofmodule module
return getruntime   newfixnum  1
return getruntime   getnil
public boolean iskindofmodule rubymodule type
for  rubymodule p   this  p    null  p   p getsuperclass
if  p issame type
return true
return false
protected boolean issame rubymodule module
return this    module
/** rb_mod_initialize
*
*/
@jrubymethod name      frame   true  visibility   visibility private
public irubyobject initialize block block
if  block isgiven
// class and module bodies default to public, so make the block's visibility public. jruby-1185.
block getbinding   setvisibility visibility public
block yield getruntime   getcurrentcontext    null  this  this  false
return getruntime   getnil
/** rb_mod_attr
*
*/
@jrubymethod name      required   1  optional   1  visibility   visibility private
public irubyobject attr threadcontext context  irubyobject args
boolean writeable   args length > 1 ? args istrue     false
addaccessor context  args asjavastring   intern    true  writeable
return getruntime   getnil
/**
* @deprecated
*/
public irubyobject attr_reader irubyobject args
return attr_reader getruntime   getcurrentcontext    args
/** rb_mod_attr_reader
*
*/
@jrubymethod name      rest   true  visibility   visibility private
public irubyobject attr_reader threadcontext context  irubyobject args
for  int i   0  i < args length  i
addaccessor context  args asjavastring   intern    true  false
return getruntime   getnil
/** rb_mod_attr_writer
*
*/
@jrubymethod name      rest   true  visibility   visibility private
public irubyobject attr_writer threadcontext context  irubyobject args
for  int i   0  i < args length  i
addaccessor context  args asjavastring   intern    false  true
return getruntime   getnil
/**
* @deprecated
*/
public irubyobject attr_accessor irubyobject args
return attr_accessor getruntime   getcurrentcontext    args
/** rb_mod_attr_accessor
*
*/
@jrubymethod name      rest   true  visibility   visibility private
public irubyobject attr_accessor threadcontext context  irubyobject args
for  int i   0  i < args length  i
// this is almost always already interned, since it will be called with a symbol in most cases
// but when created from java code, we might get an argument that needs to be interned.
// addaccessor has as a precondition that the string must be interned
addaccessor context  args asjavastring   intern    true  true
return getruntime   getnil
/**
* get a list of all instance methods names of the provided visibility unless not is true, then
* get all methods which are not the provided visibility.
*
* @param args passed into one of the ruby instance_method methods
* @param visibility to find matching instance methods against
* @param not if true only find methods not matching supplied visibility
* @return a rubyarray of instance method names
*/
private rubyarray instance_methods irubyobject args  final visibility visibility  boolean not
boolean includesuper   args length > 0 ? args istrue     true
rubyarray ary   getruntime   newarray
set<string> seen   new hashset<string>
for  rubymodule type   this  type    null  type   type getsuperclass
rubymodule realtype   type getnonincludedclass
for  iterator iter   type getmethods   entryset   iterator    iter hasnext
map entry entry    map entry  iter next
dynamicmethod method    dynamicmethod  entry getvalue
string methodname    string  entry getkey
if    seen contains methodname
seen add methodname
if  method getimplementationclass      realtype
not    method getvisibility      visibility     not    method getvisibility      visibility
method isundefined
ary append getruntime   newstring methodname
if   includesuper
break
return ary
@jrubymethod name      optional   1
public rubyarray instance_methods irubyobject args
return instance_methods args  visibility private  true
@jrubymethod name      optional   1
public rubyarray public_instance_methods irubyobject args
return instance_methods args  visibility public  false
@jrubymethod name      required   1
public irubyobject instance_method irubyobject symbol
return newmethod null  symbol asjavastring    false
/** rb_class_protected_instance_methods
*
*/
@jrubymethod name      optional   1
public rubyarray protected_instance_methods irubyobject args
return instance_methods args  visibility protected  false
/** rb_class_private_instance_methods
*
*/
@jrubymethod name      optional   1
public rubyarray private_instance_methods irubyobject args
return instance_methods args  visibility private  false
/** rb_mod_append_features
*
*/
@jrubymethod name      required   1  visibility   visibility private
public rubymodule append_features irubyobject module
if    module instanceof rubymodule
// mri error message says class, even though module is ok
throw getruntime   newtypeerror module getruntime   getclassclass
rubymodule  module  includemodule this
return this
/** rb_mod_extend_object
*
*/
@jrubymethod name      required   1  visibility   visibility private
public irubyobject extend_object irubyobject obj
obj getsingletonclass   includemodule this
return obj
/** rb_mod_include
*
*/
@jrubymethod name      required   1  rest   true  visibility   visibility private
public rubymodule include irubyobject modules
threadcontext context   getruntime   getcurrentcontext
// mri checks all types first:
for  int i   modules length    i >  0
irubyobject obj   modules
if   obj ismodule    throw getruntime   newtypeerror obj getruntime   getmodule
for  int i   modules length   1  i >  0  i
modules callmethod context     this
modules callmethod context     this
return this
@jrubymethod name      required   1
public irubyobject included irubyobject other
return getruntime   getnil
@jrubymethod name      required   1  frame   true
public irubyobject extended irubyobject other  block block
return getruntime   getnil
private void setvisibility threadcontext context  irubyobject args  visibility visibility
if  getruntime   getsafelevel   >  4     istaint
throw getruntime   newsecurityerror
if  args length    0
// note: we change current frames visibility here because the methods which call
// this method are all "fast" (e.g. they do not created their own frame).
context setcurrentvisibility visibility
else
setmethodvisibility args  visibility
/** rb_mod_public
*
*/
@jrubymethod name      rest   true  visibility   visibility private
public rubymodule rbpublic threadcontext context  irubyobject args
setvisibility context  args  visibility public
return this
/** rb_mod_protected
*
*/
@jrubymethod name      rest   true  visibility   visibility private
public rubymodule rbprotected threadcontext context  irubyobject args
setvisibility context  args  visibility protected
return this
/** rb_mod_private
*
*/
@jrubymethod name      rest   true  visibility   visibility private
public rubymodule rbprivate threadcontext context  irubyobject args
setvisibility context  args  visibility private
return this
/** rb_mod_modfunc
*
*/
@jrubymethod name      rest   true  visibility   visibility private
public rubymodule module_function irubyobject args
if  getruntime   getsafelevel   >  4     istaint
throw getruntime   newsecurityerror
threadcontext context   getruntime   getcurrentcontext
if  args length    0
context setcurrentvisibility visibility module_function
else
setmethodvisibility args  visibility private
for  int i   0  i < args length  i
string name   args asjavastring   intern
dynamicmethod method   searchmethod name
assert  method isundefined         name
getsingletonclass   addmethod name  new wrappermethod getsingletonclass    method  visibility public
callmethod context     getruntime   fastnewsymbol name
return this
@jrubymethod name      required   1  visibility   visibility private
public irubyobject method_added irubyobject nothing
return getruntime   getnil
@jrubymethod name      required   1  visibility   visibility private
public irubyobject method_removed irubyobject nothing
return getruntime   getnil
@jrubymethod name      required   1  visibility   visibility private
public irubyobject method_undefined irubyobject nothing
return getruntime   getnil
@jrubymethod name      required   1
public rubyboolean method_defined_p irubyobject symbol
return ismethodbound symbol asjavastring    true  ? getruntime   gettrue     getruntime   getfalse
@jrubymethod name      required   1
public irubyobject public_method_defined irubyobject symbol
dynamicmethod method   searchmethod symbol asjavastring
return getruntime   newboolean  method isundefined      method getvisibility      visibility public
@jrubymethod name      required   1
public irubyobject protected_method_defined irubyobject symbol
dynamicmethod method   searchmethod symbol asjavastring
return getruntime   newboolean  method isundefined      method getvisibility      visibility protected
@jrubymethod name      required   1
public irubyobject private_method_defined irubyobject symbol
dynamicmethod method   searchmethod symbol asjavastring
return getruntime   newboolean  method isundefined      method getvisibility      visibility private
@jrubymethod name      rest   true
public rubymodule public_class_method irubyobject args
getmetaclass   setmethodvisibility args  visibility public
return this
@jrubymethod name      rest   true
public rubymodule private_class_method irubyobject args
getmetaclass   setmethodvisibility args  visibility private
return this
@jrubymethod name      required   2  visibility   visibility private
public rubymodule alias_method threadcontext context  irubyobject newid  irubyobject oldid
string newname   newid asjavastring
definealias newname  oldid asjavastring
rubysymbol newsym   newid instanceof rubysymbol ?  rubysymbol newid
context getruntime   newsymbol newname
if  issingleton
metaclass this  getattached   callmethod context     newsym
else
callmethod context     newsym
return this
@jrubymethod name      required   1  rest   true  visibility   visibility private
public rubymodule undef_method threadcontext context  irubyobject args
for  int i 0  i<args length  i
undef context  args asjavastring
return this
@jrubymethod name           optional   3  frame   true
public irubyobject module_eval threadcontext context  irubyobject args  block block
return specificeval context  this  args  block
@jrubymethod name      required   1  rest   true  visibility   visibility private
public rubymodule remove_method threadcontext context  irubyobject args
for int i 0 i<args length i
removemethod context  args asjavastring
return this
public static void marshalto rubymodule module  marshalstream output  throws java io ioexception
output registerlinktarget module
output writestring marshalstream getpathfromclass module
public static rubymodule unmarshalfrom unmarshalstream input  throws java io ioexception
string name   rubystring bytelisttostring input unmarshalstring
rubymodule result   unmarshalstream getmodulefrompath input getruntime    name
input registerlinktarget result
return result
/* module class methods */
/**
* return an array of nested modules or classes.
*/
@jrubymethod name      frame   true  meta   true
public static rubyarray nesting threadcontext context  irubyobject recv  block block
ruby runtime   recv getruntime
rubymodule object   runtime getobject
staticscope scope   context getcurrentscope   getstaticscope
rubyarray result   runtime newarray
for  staticscope current   scope  current getmodule      object  current   current getpreviouscrefscope
result append current getmodule
return result
private void doincludemodule rubymodule includedmodule
boolean skip   false
rubymodule currentmodule   this
while  includedmodule    null
if  getnonincludedclass      includedmodule getnonincludedclass
throw getruntime   newargumenterror
boolean superclassseen   false
// scan class hierarchy for module
for  rubymodule superclass   this getsuperclass    superclass    null  superclass   superclass getsuperclass
if  superclass instanceof includedmodulewrapper
if  superclass getnonincludedclass      includedmodule getnonincludedclass
if   superclassseen
currentmodule   superclass
skip   true
break
else
superclassseen   true
if   skip
// blow away caches for any methods that are redefined by module
getruntime   getcachemap   moduleincluded currentmodule  includedmodule
// in the current logic, if we get here we know that module is not an
// includedmodulewrapper, so there's no need to fish out the delegate. but just
// in case the logic should change later, let's do it anyway:
currentmodule setsuperclass new includedmodulewrapper getruntime    currentmodule getsuperclass
includedmodule getnonincludedclass
currentmodule   currentmodule getsuperclass
includedmodule   includedmodule getsuperclass
skip   false
//
////////////////// class variable ruby methods ////////////////
//
@jrubymethod name      required   1
public irubyobject class_variable_defined_p irubyobject var
string internedname   validateclassvariable var asjavastring   intern
rubymodule module   this
do
if  module fasthasclassvariable internedname
return getruntime   gettrue
while   module   module getsuperclass       null
return getruntime   getfalse
/** rb_mod_cvar_get
*
*/
@jrubymethod name      required   1  visibility   visibility private
public irubyobject class_variable_get irubyobject var
return fastgetclassvar validateclassvariable var asjavastring    intern
/** rb_mod_cvar_set
*
*/
@jrubymethod name      required   2  visibility   visibility private
public irubyobject class_variable_set irubyobject var  irubyobject value
return fastsetclassvar validateclassvariable var asjavastring    intern    value
/** rb_mod_remove_cvar
*
*/
@jrubymethod name      required   1  visibility   visibility private
public irubyobject remove_class_variable irubyobject name
string javaname   validateclassvariable name asjavastring
irubyobject value
if   value   deleteclassvariable javaname      null
return value
if  fastisclassvardefined javaname
throw cannotremoveerror javaname
throw getruntime   newnameerror     javaname       getname    javaname
/** rb_mod_class_variables
*
*/
@jrubymethod name
public rubyarray class_variables
set<string> names   new hashset<string>
for  rubymodule p   this  p    null  p   p getsuperclass
for  string name   p getclassvariablenamelist
names add name
ruby runtime   getruntime
rubyarray ary   runtime newarray
for  string name   names
ary add runtime newstring name
return ary
//
////////////////// constant ruby methods ////////////////
//
/** rb_mod_const_defined
*
*/
@jrubymethod name      required   1
public rubyboolean const_defined_p irubyobject symbol
// note: includes part of fix for jruby-1339
return getruntime   newboolean fastisconstantdefined validateconstant symbol asjavastring    intern
/** rb_mod_const_get
*
*/
@jrubymethod name      required   1
public irubyobject const_get irubyobject symbol
return fastgetconstant validateconstant symbol asjavastring    intern
/** rb_mod_const_set
*
*/
@jrubymethod name      required   2
public irubyobject const_set irubyobject symbol  irubyobject value
return fastsetconstant validateconstant symbol asjavastring    intern    value
@jrubymethod name      required   1  visibility   visibility private
public irubyobject remove_const irubyobject name
string id   validateconstant name asjavastring
irubyobject value
if   value   deleteconstant id      null
if  value    getruntime   getundef
return value
getruntime   getloadservice   removeautoloadfor getname         id
// fixme: i'm not sure this is right, but the old code returned
// the undef, which definitely isn't right...
return getruntime   getnil
if  hasconstantinhierarchy id
throw cannotremoveerror id
throw getruntime   newnameerror     id       getname    id
private boolean hasconstantinhierarchy final string name
for  rubymodule p   this  p    null  p   p getsuperclass
if  p hasconstant name
return true
return false
/**
* base implementation of module#const_missing, throws nameerror for specific missing constant.
*
* @param name the constant name which was found to be missing
* @return nothing! absolutely nothing! (though subclasses might choose to return something)
*/
@jrubymethod name      required   1  frame   true
public irubyobject const_missing irubyobject name  block block
/* uninitialized constant */
if  this    getruntime   getobject
throw getruntime   newnameerror     getname         name asjavastring        getname         name asjavastring
throw getruntime   newnameerror     name asjavastring    name asjavastring
/** rb_mod_constants
*
*/
@jrubymethod name
public rubyarray constants
ruby runtime   getruntime
rubyarray array   runtime newarray
rubymodule objectclass   runtime getobject
if  getruntime   getmodule      this
for  string name   objectclass getstoredconstantnamelist
array add runtime newstring name
else if  objectclass    this
for  string name   getstoredconstantnamelist
array add runtime newstring name
else
set<string> names   new hashset<string>
for  rubymodule p   this  p    null  p   p getsuperclass
if  objectclass    p
for  string name   p getstoredconstantnamelist
names add name
for  string name   names
array add runtime newstring name
return array
//
////////////////// class variable api methods ////////////////
//
/**
* set the named class variable to the given value, provided taint and freeze allow setting it.
*
* ruby c equivalent = "rb_cvar_set"
*
* @param name the variable name to set
* @param value the value to set it to
*/
public irubyobject setclassvar string name  irubyobject value
rubymodule module   this
do
if  module hasclassvariable name
return module storeclassvariable name  value
while   module   module getsuperclass       null
return storeclassvariable name  value
public irubyobject fastsetclassvar final string internedname  final irubyobject value
assert internedname    internedname intern     internedname
rubymodule module   this
do
if  module fasthasclassvariable internedname
return module faststoreclassvariable internedname  value
while   module   module getsuperclass       null
return faststoreclassvariable internedname  value
/**
* retrieve the specified class variable, searching through this module, included modules, and supermodules.
*
* ruby c equivalent = "rb_cvar_get"
*
* @param name the name of the variable to retrieve
* @return the variable's value, or throws nameerror if not found
*/
public irubyobject getclassvar string name
assert idutil isclassvariable name
irubyobject value
rubymodule module   this
do
if   value   module variabletablefetch name      null  return value
while   module   module getsuperclass       null
throw getruntime   newnameerror     name       getname    name
public irubyobject fastgetclassvar string internedname
assert internedname    internedname intern     internedname
assert idutil isclassvariable internedname
irubyobject value
rubymodule module   this
do
if   value   module variabletablefastfetch internedname      null  return value
while   module   module getsuperclass       null
throw getruntime   newnameerror     internedname       getname    internedname
/**
* is class var defined?
*
* ruby c equivalent = "rb_cvar_defined"
*
* @param name the class var to determine "is defined?"
* @return true if true, false if false
*/
public boolean isclassvardefined string name
rubymodule module   this
do
if  module hasclassvariable name   return true
while   module   module getsuperclass       null
return false
public boolean fastisclassvardefined string internedname
assert internedname    internedname intern     internedname
rubymodule module   this
do
if  module fasthasclassvariable internedname   return true
while   module   module getsuperclass       null
return false
/** rb_mod_remove_cvar
*
* fixme: any good reason to have two identical methods? (same as remove_class_variable)
*/
public irubyobject removecvar irubyobject name       wrong parameter ?
string internedname   validateclassvariable name asjavastring
irubyobject value
if   value   deleteclassvariable internedname      null
return value
if  fastisclassvardefined internedname
throw cannotremoveerror internedname
throw getruntime   newnameerror     internedname       getname    internedname
//
////////////////// constant api methods ////////////////
//
public irubyobject getconstantat string name
irubyobject value
if   value   fetchconstant name      getruntime   getundef
return value
deleteconstant name
return getruntime   getloadservice   autoload getname         name
public irubyobject fastgetconstantat string internedname
assert internedname    internedname intern     internedname
irubyobject value
if   value   fastfetchconstant internedname      getruntime   getundef
return value
deleteconstant internedname
return getruntime   getloadservice   autoload getname         internedname
/**
* retrieve the named constant, invoking 'const_missing' should that be appropriate.
*
* @param name the constant to retrieve
* @return the value for the constant, or null if not found
*/
public irubyobject getconstant string name
assert idutil isconstant name
irubyobject undef   getruntime   getundef
boolean retryformodule   false
irubyobject value
rubymodule p   this
retry  while  true
while  p    null
if   value   p constanttablefetch name      null
if  value    undef
return value
p deleteconstant name
if  getruntime   getloadservice   autoload
p getname         name     null
break
continue
p   p getsuperclass
if   retryformodule     isclass
retryformodule   true
p   getruntime   getobject
continue retry
break
return callmethod getruntime   getcurrentcontext
getruntime   newsymbol name
public irubyobject fastgetconstant string internedname
assert internedname    internedname intern     internedname
assert idutil isconstant internedname
irubyobject undef   getruntime   getundef
boolean retryformodule   false
irubyobject value
rubymodule p   this
retry  while  true
while  p    null
if   value   p constanttablefastfetch internedname      null
if  value    undef
return value
p deleteconstant internedname
if  getruntime   getloadservice   autoload
p getname         internedname     null
break
continue
p   p getsuperclass
if   retryformodule     isclass
retryformodule   true
p   getruntime   getobject
continue retry
break
return callmethod getruntime   getcurrentcontext
getruntime   fastnewsymbol internedname
// not actually called anywhere (all known uses call the fast version)
public irubyobject getconstantfrom string name
return fastgetconstantfrom name intern
public irubyobject fastgetconstantfrom string internedname
assert internedname    internedname intern     internedname
assert idutil isconstant internedname
rubyclass objectclass   getruntime   getobject
irubyobject undef   getruntime   getundef
irubyobject value
rubymodule p   this
while  p    null
if   value   p constanttablefastfetch internedname      null
if  value    undef
if  p    objectclass    this    objectclass
string badcname   getname         internedname
getruntime   getwarnings   warn id constant_bad_reference
internedname       badcname  badcname
return value
p deleteconstant internedname
if  getruntime   getloadservice   autoload
p getname         internedname     null
break
continue
p   p getsuperclass
return callmethod getruntime   getcurrentcontext
getruntime   fastnewsymbol internedname
/**
* set the named constant on this module. also, if the value provided is another module and
* that module has not yet been named, assign it the specified name.
*
* @param name the name to assign
* @param value the value to assign to it; if an unnamed module, also set its basename to name
* @return the result of setting the variable.
*/
public irubyobject setconstant string name  irubyobject value
irubyobject oldvalue
if   oldvalue   fetchconstant name      null
if  oldvalue    getruntime   getundef
getruntime   getloadservice   removeautoloadfor getname         name
else
getruntime   getwarnings   warn id constant_already_initialized      name  name
storeconstant name  value
// if adding a module under a constant name, set that module's basename to the constant name
if  value instanceof rubymodule
rubymodule module    rubymodule value
if  module getbasename      null
module setbasename name
module.setparent(this);
/*
module.setparent(this);
*/
return value
public irubyobject fastsetconstant string internedname  irubyobject value
assert internedname    internedname intern     internedname
irubyobject oldvalue
if   oldvalue   fastfetchconstant internedname      null
if  oldvalue    getruntime   getundef
getruntime   getloadservice   removeautoloadfor getname         internedname
else
getruntime   getwarnings   warn id constant_already_initialized      internedname  internedname
faststoreconstant internedname  value
// if adding a module under a constant name, set that module's basename to the constant name
if  value instanceof rubymodule
rubymodule module    rubymodule value
if  module getbasename      null
module setbasename internedname
module.setparent(this);
/*
module.setparent(this);
*/
return value
/** rb_define_const
*
*/
public void defineconstant string name  irubyobject value
assert value    null
if  this    getruntime   getclassclass
getruntime   secure 4
if   idutil isvalidconstantname name
throw getruntime   newnameerror     name  name
setconstant name  value
// fix for jruby-1339 - search hierarchy for constant
/** rb_const_defined_at
*
*/
public boolean isconstantdefined string name
assert idutil isconstant name
boolean isobject   this    getruntime   getobject
object undef   getruntime   getundef
rubymodule module   this
do
object value
if   value   module constanttablefetch name      null
if  value    undef  return true
return getruntime   getloadservice   autoloadfor
module getname         name     null
while  isobject     module   module getsuperclass       null
return false
public boolean fastisconstantdefined string internedname
assert internedname    internedname intern     internedname
assert idutil isconstant internedname
boolean isobject   this    getruntime   getobject
object undef   getruntime   getundef
rubymodule module   this
do
object value
if   value   module constanttablefastfetch internedname      null
if  value    undef  return true
return getruntime   getloadservice   autoloadfor
module getname         internedname     null
while  isobject     module   module getsuperclass       null
return false
//
////////////////// common constant / cvar methods ////////////////
//
private raiseexception cannotremoveerror string id
return getruntime   newnameerror     id       getname    id
//
////////////////// internal module variable api methods ////////////////
//
/**
* behaves similarly to {@link #getclassvar(string)}. searches this
* class/module <em>and its ancestors</em> for the specified internal
* variable.
*
* @param name the internal variable name
* @return the value of the specified internal variable if found, else null
* @see #setinternalmodulevariable(string, irubyobject)
*/
public boolean hasinternalmodulevariable final string name
rubymodule module   this
do
if  module hasinternalvariable name
return true
while   module   module getsuperclass       null
return false
/**
* behaves similarly to {@link #getclassvar(string)}. searches this
* class/module <em>and its ancestors</em> for the specified internal
* variable.
*
* @param name the internal variable name
* @return the value of the specified internal variable if found, else null
* @see #setinternalmodulevariable(string, irubyobject)
*/
public irubyobject searchinternalmodulevariable final string name
rubymodule module   this
irubyobject value
do
if   value   module getinternalvariable name      null
return value
while   module   module getsuperclass       null
return null
/**
* behaves similarly to {@link #setclassvar(string, irubyobject)}. if the
* specified internal variable is found in this class/module <em>or an ancestor</em>,
* it is set where found.  otherwise it is set in this module.
*
* @param name the internal variable name
* @param value the internal variable value
* @see #searchinternalmodulevariable(string)
*/
public void setinternalmodulevariable final string name  final irubyobject value
rubymodule module   this
do
if  module hasinternalvariable name
module setinternalvariable name  value
return
while   module   module getsuperclass       null
setinternalvariable name  value
//
////////////////// low-level class variable interface ////////////////
//
// fetch/store/list class variables for this module
//
public boolean hasclassvariable string name
assert idutil isclassvariable name
return variabletablecontains name
public boolean fasthasclassvariable string internedname
assert idutil isclassvariable internedname
return variabletablefastcontains internedname
public irubyobject fetchclassvariable string name
assert idutil isclassvariable name
return variabletablefetch name
public irubyobject fastfetchclassvariable string internedname
assert idutil isclassvariable internedname
return variabletablefastfetch internedname
public irubyobject storeclassvariable string name  irubyobject value
assert idutil isclassvariable name     value    null
ensureclassvariablessettable
return variabletablestore name  value
public irubyobject faststoreclassvariable string internedname  irubyobject value
assert idutil isclassvariable internedname     value    null
ensureclassvariablessettable
return variabletablefaststore internedname  value
public irubyobject deleteclassvariable string name
assert idutil isclassvariable name
ensureclassvariablessettable
return variabletableremove name
public list<variable<irubyobject>> getclassvariablelist
arraylist<variable<irubyobject>> list   new arraylist<variable<irubyobject>>
variabletableentry table   variabletablegettable
irubyobject readvalue
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
if  idutil isclassvariable e name
if   readvalue   e value     null  readvalue   variabletablereadlocked e
list add new variableentry<irubyobject> e name  readvalue
return list
public list<string> getclassvariablenamelist
arraylist<string> list   new arraylist<string>
variabletableentry table   variabletablegettable
for  int i   table length    i >  0
for  variabletableentry e   table  e    null  e   e next
if  idutil isclassvariable e name
list add e name
return list
protected static final string err_insecure_set_class_var
protected static final string err_frozen_cvar_type
protected final string validateclassvariable string name
if  idutil isvalidclassvariablename name
return name
throw getruntime   newnameerror     name      name
protected final void ensureclassvariablessettable
if   isfrozen       getruntime   getsafelevel   < 4    istaint
return
if  getruntime   getsafelevel   >  4     istaint
throw getruntime   newsecurityerror err_insecure_set_constant
if  isfrozen
if  this instanceof rubymodule
throw getruntime   newfrozenerror err_frozen_const_type
else
throw getruntime   newfrozenerror
//
////////////////// low-level constant interface ////////////////
//
// fetch/store/list constants for this module
//
public boolean hasconstant string name
assert idutil isconstant name
return constanttablecontains name
public boolean fasthasconstant string internedname
assert idutil isconstant internedname
return constanttablefastcontains internedname
// returns the stored value without processing undefs (autoloads)
public irubyobject fetchconstant string name
assert idutil isconstant name
return constanttablefetch name
// returns the stored value without processing undefs (autoloads)
public irubyobject fastfetchconstant string internedname
assert idutil isconstant internedname
return constanttablefastfetch internedname
public irubyobject storeconstant string name  irubyobject value
assert idutil isconstant name     value    null
ensureconstantssettable
return constanttablestore name  value
public irubyobject faststoreconstant string internedname  irubyobject value
assert idutil isconstant internedname     value    null
ensureconstantssettable
return constanttablefaststore internedname  value
// removes and returns the stored value without processing undefs (autoloads)
public irubyobject deleteconstant string name
assert idutil isconstant name
ensureconstantssettable
return constanttableremove name
public list<variable<irubyobject>> getstoredconstantlist
arraylist<variable<irubyobject>> list   new arraylist<variable<irubyobject>>
constanttableentry table   constanttablegettable
for  int i   table length    i >  0
for  constanttableentry e   table  e    null  e   e next
list add e
return list
public list<string> getstoredconstantnamelist
arraylist<string> list   new arraylist<string>
constanttableentry table   constanttablegettable
for  int i   table length    i >  0
for  constanttableentry e   table  e    null  e   e next
list add e name
return list
protected static final string err_insecure_set_constant
protected static final string err_frozen_const_type
protected final string validateconstant string name
if  idutil isvalidconstantname name
return name
throw getruntime   newnameerror     name  name
protected final void ensureconstantssettable
if   isfrozen       getruntime   getsafelevel   < 4    istaint
return
if  getruntime   getsafelevel   >  4     istaint
throw getruntime   newsecurityerror err_insecure_set_constant
if  isfrozen
if  this instanceof rubymodule
throw getruntime   newfrozenerror err_frozen_const_type
else
throw getruntime   newfrozenerror
//
////////////////// variable table methods ////////////////
//
// overridden to use variablewritelock in place of synchronization
//
@override
protected irubyobject variabletablestore string name  irubyobject value
int hash   name hashcode
reentrantlock lock
lock   variablewritelock  lock
try
variabletableentry table
variabletableentry e
if   table   variabletable     null
table    new variabletableentry
e   new variabletableentry hash  name intern    value  null
table   e
variabletablethreshold    int  variable_table_default_capacity   variable_table_load_factor
variabletablesize   1
variabletable   table
return value
int potentialnewsize
if   potentialnewsize   variabletablesize   1  > variabletablethreshold
table   variabletablerehash
int index
for  e   table  e    null  e   e next
if  hash    e hash    name equals e name
e value   value
return value
// external volatile value initialization intended to obviate the need for
// readvalueunderlock technique used in concurrenthashmap. may be a little
// slower, but better to pay a price on first write rather than all reads.
e   new variabletableentry hash  name intern    value  table
table   e
variabletablesize   potentialnewsize
variabletable   table     write volatile
finally
lock unlock
return value
@override
protected irubyobject variabletablefaststore string internedname  irubyobject value
assert internedname    internedname intern     internedname
int hash   internedname hashcode
reentrantlock lock
lock   variablewritelock  lock
try
variabletableentry table
variabletableentry e
if   table   variabletable     null
table    new variabletableentry
e   new variabletableentry hash  internedname  value  null
table   e
variabletablethreshold    int  variable_table_default_capacity   variable_table_load_factor
variabletablesize   1
variabletable   table
return value
int potentialnewsize
if   potentialnewsize   variabletablesize   1  > variabletablethreshold
table   variabletablerehash
int index
for  e   table  e    null  e   e next
if  internedname    e name
e value   value
return value
// external volatile value initialization intended to obviate the need for
// readvalueunderlock technique used in concurrenthashmap. may be a little
// slower, but better to pay a price on first write rather than all reads.
e   new variabletableentry hash  internedname  value  table
table   e
variabletablesize   potentialnewsize
variabletable   table     write volatile
finally
lock unlock
return value
@override
protected irubyobject variabletableremove string name
reentrantlock lock
lock   variablewritelock  lock
try
variabletableentry table
if   table   variabletable     null
int hash   name hashcode
int index   hash    table length   1
variabletableentry first   table
variabletableentry e
for  e   first  e    null  e   e next
if  hash    e hash    name equals e name
irubyobject oldvalue   e value
// all entries following removed node can stay
// in list, but all preceding ones need to be
// cloned.
variabletableentry newfirst   e next
for  variabletableentry p   first  p    e  p   p next
newfirst   new variabletableentry p hash  p name  p value  newfirst
table   newfirst
variabletablesize
variabletable   table     write volatile
return oldvalue
finally
lock unlock
return null
@override
protected irubyobject variabletablereadlocked variabletableentry entry
reentrantlock lock
lock   variablewritelock  lock
try
return entry value
finally
lock unlock
@override
protected void variabletablesync list<variable<irubyobject>> vars
reentrantlock lock
lock   variablewritelock  lock
try
variabletablesize   0
variabletablethreshold    int  variable_table_default_capacity   variable_table_load_factor
variabletable    new variabletableentry
for  variable<irubyobject> var   vars
assert  var isconstant      var getvalue      null
variabletablestore var getname    var getvalue
finally
lock unlock
@override
public void syncvariables list<variable<irubyobject>> variables
arraylist<variable<irubyobject>> constants   new arraylist<variable<irubyobject>> variables size
variable<irubyobject> var
for  iterator<variable<irubyobject>> iter   variables iterator    iter hasnext
if   var   iter next    isconstant
constants add var
iter remove
reentrantlock lock
lock   variablewritelock  lock
try
variabletablesync variables
constanttablesync constants
finally
lock unlock
@override
@suppresswarnings
@deprecated    born deprecated
public map getvariablemap
map map   variabletablegetmap
constanttablegetmap map
return map
@override
public boolean hasvariables
return variabletablegetsize   > 0    constanttablegetsize   > 0
@override
public int getvariablecount
return variabletablegetsize     constanttablegetsize
@override
public list<variable<irubyobject>> getvariablelist
variabletableentry vtable   variabletablegettable
constanttableentry ctable   constanttablegettable
arraylist<variable<irubyobject>> list   new arraylist<variable<irubyobject>>
irubyobject readvalue
for  int i   vtable length    i >  0
for  variabletableentry e   vtable  e    null  e   e next
if   readvalue   e value     null  readvalue   variabletablereadlocked e
list add new variableentry<irubyobject> e name  readvalue
for  int i   ctable length    i >  0
for  constanttableentry e   ctable  e    null  e   e next
list add e
return list
@override
public list<string> getvariablenamelist
variabletableentry vtable   variabletablegettable
constanttableentry ctable   constanttablegettable
arraylist<string> list   new arraylist<string>
for  int i   vtable length    i >  0
for  variabletableentry e   vtable  e    null  e   e next
list add e name
for  int i   ctable length    i >  0
for  constanttableentry e   ctable  e    null  e   e next
list add e name
return list
//
////////////////// constant table methods, etc. ////////////////
//
protected static final int constant_table_default_capacity   8     must be power of 2
protected static final int constant_table_maximum_capacity   1 << 30
protected static final float constant_table_load_factor   0 75f
protected static final class constanttableentry implements variable<irubyobject>
final int hash
final string name
final irubyobject value
final constanttableentry next
// constant table entry values are final; if a constant is redefined, the
// entry will be removed and replaced with a new entry.
constanttableentry
int hash
string name
irubyobject value
constanttableentry next
this hash   hash
this name   name
this value   value
this next   next
public string getname
return name
public irubyobject getvalue
return value
public final boolean isclassvariable
return false
public final boolean isconstant
return true
public final boolean isinstancevariable
return false
public final boolean isrubyvariable
return true
protected boolean constanttablecontains string name
int hash   name hashcode
constanttableentry table
for  constanttableentry e    table   constanttable   e    null  e   e next
if  hash    e hash    name equals e name
return true
return false
protected boolean constanttablefastcontains string internedname
constanttableentry table
for  constanttableentry e    table   constanttable   e    null  e   e next
if  internedname    e name
return true
return false
protected irubyobject constanttablefetch string name
int hash   name hashcode
constanttableentry table
for  constanttableentry e    table   constanttable   e    null  e   e next
if  hash    e hash    name equals e name
return e value
return null
protected irubyobject constanttablefastfetch string internedname
constanttableentry table
for  constanttableentry e    table   constanttable   e    null  e   e next
if  internedname    e name
return e value
return null
protected irubyobject constanttablestore string name  irubyobject value
int hash   name hashcode
reentrantlock lock
lock   variablewritelock  lock
try
constanttableentry table
constanttableentry e
constanttableentry first
int potentialnewsize
if   potentialnewsize   constanttablesize   1  > constanttablethreshold
table   constanttablerehash
else
table   constanttable
int index
for  e   first   table  e    null  e   e next
if  hash    e hash    name equals e name
// if value is unchanged, do nothing
if  value    e value
return value
// create new entry, prepend to any trailing entries
constanttableentry newfirst   new constanttableentry e hash  e name  value  e next
// all entries before this one must be cloned
for  constanttableentry n   first  n    e  n   n next
newfirst   new constanttableentry n hash  n name  n value  newfirst
table   newfirst
constanttable   table     write volatile
return value
table   new constanttableentry hash  name intern    value  table
constanttablesize   potentialnewsize
constanttable   table     write volatile
finally
lock unlock
return value
protected irubyobject constanttablefaststore string internedname  irubyobject value
assert internedname    internedname intern     internedname
int hash   internedname hashcode
reentrantlock lock
lock   variablewritelock  lock
try
constanttableentry table
constanttableentry e
constanttableentry first
int potentialnewsize
if   potentialnewsize   constanttablesize   1  > constanttablethreshold
table   constanttablerehash
else
table   constanttable
int index
for  e   first   table  e    null  e   e next
if  internedname    e name
// if value is unchanged, do nothing
if  value    e value
return value
// create new entry, prepend to any trailing entries
constanttableentry newfirst   new constanttableentry e hash  e name  value  e next
// all entries before this one must be cloned
for  constanttableentry n   first  n    e  n   n next
newfirst   new constanttableentry n hash  n name  n value  newfirst
table   newfirst
constanttable   table     write volatile
return value
table   new constanttableentry hash  internedname  value  table
constanttablesize   potentialnewsize
constanttable   table     write volatile
finally
lock unlock
return value
protected irubyobject constanttableremove string name
reentrantlock lock
lock   variablewritelock  lock
try
constanttableentry table
if   table   constanttable     null
int hash   name hashcode
int index   hash    table length   1
constanttableentry first   table
constanttableentry e
for  e   first  e    null  e   e next
if  hash    e hash    name equals e name
irubyobject oldvalue   e value
// all entries following removed node can stay
// in list, but all preceding ones need to be
// cloned.
constanttableentry newfirst   e next
for  constanttableentry p   first  p    e  p   p next
newfirst   new constanttableentry p hash  p name  p value  newfirst
table   newfirst
constanttablesize
constanttable   table     write volatile
return oldvalue
finally
lock unlock
return null
protected constanttableentry constanttablegettable
return constanttable
protected int constanttablegetsize
if  constanttable    null
return constanttablesize
return 0
protected void constanttablesync list<variable<irubyobject>> vars
reentrantlock lock
lock   variablewritelock  lock
try
constanttablesize   0
constanttablethreshold    int  constant_table_default_capacity   constant_table_load_factor
constanttable    new constanttableentry
for  variable<irubyobject> var   vars
assert var isconstant      var getvalue      null
constanttablestore var getname    var getvalue
finally
lock unlock
// must be called from synchronized/locked block!
// should only be called by constanttablestore/constanttablefaststore
private final constanttableentry constanttablerehash
constanttableentry oldtable   constanttable
int oldcapacity
if   oldcapacity   oldtable length  >  constant_table_maximum_capacity
return oldtable
int newcapacity   oldcapacity << 1
constanttableentry newtable   new constanttableentry
constanttablethreshold    int  newcapacity   constant_table_load_factor
int sizemask   newcapacity   1
constanttableentry e
for  int i   oldcapacity    i >  0
// we need to guarantee that any existing reads of old map can
//  proceed. so we cannot yet null out each bin.
e   oldtable
if  e    null
constanttableentry next   e next
int idx   e hash   sizemask
//  single node on list
if  next    null
newtable   e
else
// reuse trailing consecutive sequence at same slot
constanttableentry lastrun   e
int lastidx   idx
for  constanttableentry last   next
last    null
last   last next
int k   last hash   sizemask
if  k    lastidx
lastidx   k
lastrun   last
newtable   lastrun
// clone all remaining nodes
for  constanttableentry p   e  p    lastrun  p   p next
int k   p hash   sizemask
constanttableentry m   new constanttableentry p hash  p name  p value  newtable
newtable   m
constanttable   newtable
return newtable
/**
* method to help ease transition to new variables implementation.
* will likely be deprecated in the near future.
*/
@suppresswarnings
protected map constanttablegetmap
hashmap map   new hashmap
constanttableentry table
if   table   constanttable     null
for  int i   table length    i >  0
for  constanttableentry e   table  e    null  e   e next
map put e name  e value
return map
/**
* method to help ease transition to new variables implementation.
* will likely be deprecated in the near future.
*/
@suppresswarnings
protected map constanttablegetmap map map
constanttableentry table
if   table   constanttable     null
for  int i   table length    i >  0
for  constanttableentry e   table  e    null  e   e next
map put e name  e value
return map