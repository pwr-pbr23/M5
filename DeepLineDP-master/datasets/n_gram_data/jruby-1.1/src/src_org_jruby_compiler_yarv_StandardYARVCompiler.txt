/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007 ola bini <ola@ologix.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby compiler yarv
import java util list
import java util arraylist
import java util iterator
import java util map
import java util identityhashmap
import org jruby ruby
import org jruby runtime builtin irubyobject
import org jruby ast andnode
import org jruby ast argumentnode
import org jruby ast arraynode
import org jruby ast blocknode
import org jruby ast blockpassnode
import org jruby ast callnode
import org jruby ast constnode
import org jruby ast defnnode
import org jruby ast newlinenode
import org jruby ast notnode
import org jruby ast fixnumnode
import org jruby ast ifnode
import org jruby ast listnode
import org jruby ast localasgnnode
import org jruby ast localvarnode
import org jruby ast ornode
import org jruby ast vcallnode
import org jruby ast iargumentnode
import org jruby ast hashnode
import org jruby ast node
import org jruby ast nodetype
import org jruby ast rootnode
import org jruby ast strnode
import org jruby ast untilnode
import org jruby ast whilenode
import org jruby ast executable yarvinstructions
import org jruby ast executable yarvmachine
import org jruby ast types iliteralnode
import org jruby ast types inamenode
/**
* @author <a href="mailto:ola.bini@ki.se">ola bini</a>
*/
public class standardyarvcompiler
private yarvmachine instructionsequence iseq
private ruby runtime
private int last_line    1
private linkanchor current_iseq
private string locals   new string
private static final int compile_ok 1
//private static final int compile_ng=0;
// counter for label
private int label_no   0
private static abstract class linkelement
public linkelement next
public linkelement prev
public void insert linkelement other
other prev   prev
other next   this
prev   other
if  other prev    null  other prev next   other
}
public void remove
prev next   next
if  next    null  next prev   prev
}
public void replace linkelement other
other prev   prev
other next   next
if  prev    null  prev next   other
if  next    null  next prev   other
}
}
private static class linkanchor extends linkelement
linkelement last
public linkanchor
last   this
}
public void add linkelement element
element prev   last
last next   element
last   element
verify_list
}
public void append linkanchor other
if  other next    null
last next   other next
other next prev   last
last   other last
}
verify_list
}
public void insert linkanchor other
if  other next    null
linkelement first   next
next   other next
next prev   this
other last next   first
if  first    null
first prev   other last
else
last   other last
}
}
verify_list
}
public boolean isempty
return next    null
}
public linkelement pop
linkelement element   last
last   last prev
last next   null
verify_list
return element
}
public linkelement shift
linkelement elem   next
if  null    elem  next   elem next
return elem
}
public int size
int size   0
for  linkelement elem   next  elem    null  elem   elem next
size
}
return size
}
private void verify_list string info
int flag   0
linkelement plist   this
for  linkelement list   next  list    null  list   list next
if  plist    list prev  flag
plist   list
}
if  last    plist    last    null  flag    0x70000
if  flag    0
throw new runtimeexception     integer tostring flag  16
info
}
}
public linkelement first
// todo auto-generated method stub
return null
}
}
private static class label extends linkelement
/* label number (identifier) */
int id
// int position; unused
// int sc_state;
// int set; unused
// int sp;
public label int line  int id
next   null
this id   id
//sc_state = 0;
//labelobj.sp = -1;
}
}
private static class insn extends linkelement
yarvmachine instruction i
}
/*
private static class ensurerange {
label begin;
label end;
ensurerange next;
}
*/
private label new_label int l    label label   new label l  label_no   label_no    return label
private static void add_label linkanchor anchor  linkelement elem    anchor add elem
private static void add_elem linkanchor anchor  linkelement elem    anchor add elem
//private static void insert_elem_prev(linkelement elem1, linkelement elem2) { elem1.insert(elem2); }
//private static void replace_elem(linkelement elem1, linkelement elem2) { elem1.replace(elem2); }
//private static void remove_elem(linkelement element) { element.remove(); }
//private static linkelement first_element(linkanchor anchor) { return anchor.first(); }
private static linkelement pop_element linkanchor anchor    return anchor pop
//private static linkelement shift_element(linkanchor anchor) { return anchor.shift(); }
//private static int list_size(linkanchor anchor) { return anchor.size(); }
private static boolean list_size_zero linkanchor anchor    return anchor isempty
private static void append_list linkanchor anc1  linkanchor anc2    anc1 append anc2
//private static void insert_list(linkanchor anc1, linkanchor anc2) { anc1.insert(anc2); }
private static void add_seq linkanchor seq1  linkanchor seq2    seq1 append seq2
private int debug_compile string msg  int v
debugs msg
return v
}
private int compile linkanchor anchor  string desc  node node
return debug_compile     desc  iseq_compile_each anchor  node  false
}
private int compile linkanchor anchor  string desc  node node  boolean poped
return debug_compile     desc  iseq_compile_each anchor  node  poped
}
private int compile_poped linkanchor anchor  string desc  node node
return debug_compile     desc  iseq_compile_each anchor  node  true
}
private linkanchor decl_anchor
return new linkanchor
}
public standardyarvcompiler ruby runtime
this runtime   runtime
}
private void debugs string s
system err println s
}
public void compile node node
iseq_compile null node
}
public void compile node node  compiler context
compile node
}
public void iseq_compile irubyobject self  node node
linkanchor list_anchor   decl_anchor
debugs
/* kri switched to making newline a flag of a node rather than a whole node */
while  node nodeid    nodetype newlinenode
node     newlinenode  node  getnextnode
}
compile list_anchor     node
add_insn list_anchor  last_line  yarvinstructions leave
current_iseq   list_anchor
}
private int nd_line node node
if node getposition      null
return node getposition   getendline
}
return last_line
}
private string nd_file node node
if node getposition      null
return node getposition   getfile
}
return null
}
private int iseq_compile_each linkanchor ret  node node  boolean poped
if node    null
if  poped
debugs
add_insn ret  0  yarvinstructions putnil
return compile_ok
}
return compile_ok
}
last_line   nd_line node
linkanchor recv   null
linkanchor args   null
compileloop  while true
switch node nodeid
case blocknode
list l     blocknode node  childnodes
int sz   l size
for int i 0 i<sz i
boolean p     i 1    sz     poped
compile ret      node l get i  p
}
break compileloop
case newlinenode
node     newlinenode node  getnextnode
continue compileloop
case rootnode
// getallnamesinscope now gets all names in scope that have been seen at the current point
// of von.  this may or may not work in this case....?
locals     rootnode node  getstaticscope   getallnamesinscope
node     rootnode node  getbodynode
continue compileloop
case defnnode
standardyarvcompiler c   new standardyarvcompiler runtime
c compile   defnnode node  getbodynode
yarvmachine instructionsequence iseqval    c getinstructionsequence   defnnode node  getname    nd_file node
list argnames   new arraylist
listnode argsnode     defnnode node  getargsnode   getargs
if  argsnode    null
for  int i   0  i < argsnode size    i
argumentnode argumentnode    argumentnode argsnode get i
argnames add argumentnode getname
}
}
iseqval args_argc   argnames size
string l1   iseqval locals
string l2   new string
system arraycopy l1 0 l2 argnames size   l1 length
for int i 0 i<argnames size   i
l2    string argnames get i
}
iseqval locals   l2
add_insn ret  nd_line node   yarvinstructions putnil
add_insn3 ret  nd_line node   yarvinstructions definemethod    defnnode node  getname    iseqval  0
if  poped
add_insn ret  nd_line node   yarvinstructions putnil
}
break compileloop
case strnode
if  poped
add_insn1 ret  nd_line node   yarvinstructions putstring    strnode node  getvalue   tostring
}
break compileloop
case constnode
// check for inline const cache here
add_insn ret  nd_line node   yarvinstructions putnil
add_insn1 ret  nd_line node   yarvinstructions getconstant    constnode node  getname
if poped
add_insn ret  nd_line node   yarvinstructions pop
}
break compileloop
case localasgnnode
int idx     localasgnnode node  getindex   2
debugs     idx
compile ret       localasgnnode node  getvaluenode
if  poped
add_insn ret  nd_line node   yarvinstructions dup
}
add_insn1 ret  nd_line node   yarvinstructions setlocal  idx
break compileloop
case localvarnode
if  poped
int idx2     localvarnode node  getindex   2
debugs   idx2
add_insn1 ret  nd_line node   yarvinstructions getlocal  idx2
}
break compileloop
case ifnode
linkanchor cond_seq   decl_anchor
linkanchor then_seq   decl_anchor
linkanchor else_seq   decl_anchor
label then_label   new_label nd_line node
label else_label   new_label nd_line node
label end_label   new_label nd_line node
compile_branch_condition cond_seq    ifnode node  getcondition    then_label  else_label
compile then_seq       ifnode node  getthenbody    poped
compile else_seq       ifnode node  getelsebody    poped
add_seq ret  cond_seq
add_label ret  then_label
add_seq ret  then_seq
add_insnl ret  nd_line node   yarvinstructions jump  end_label
add_label ret  else_label
add_seq ret  else_seq
add_label ret  end_label
break compileloop
}
case callnode
case fcallnode
case vcallnode
recv   decl_anchor
args   decl_anchor
if  node nodeid    nodetype callnode
compile recv       callnode node  getreceivernode
else
add_call_receiver recv  nd_line node
}
int argc   0
int flags   0
if   node instanceof vcallnode
int argc_flags   setup_arg args   iargumentnode node
argc   argc_flags
flags   argc_flags
else
argc   0
}
add_seq ret  recv
add_seq ret  args
switch node nodeid
case vcallnode
flags    yarvinstructions vcall_flag
/* vcall is funcall, so fall through */
case fcallnode
flags    yarvinstructions fcall_flag
}
yarvmachine instruction inst   add_send_r ret  nd_line node     inamenode node  getname    argc  null  flags
if   flags   yarvinstructions fcall_flag     0
if    inamenode  node  getname   equals
insn_set_specialized_instruction inst  yarvinstructions opt_lt
else if    inamenode  node  getname   equals
insn_set_specialized_instruction inst  yarvinstructions opt_plus
else if    inamenode  node  getname   equals
insn_set_specialized_instruction inst  yarvinstructions opt_minus
}
}
if poped
add_insn ret  nd_line node   yarvinstructions pop
}
break compileloop
case arraynode
compile_array ret  node  true
if poped
add_insn ret  nd_line node   yarvinstructions pop
}
break compileloop
case zarraynode
if  poped
add_insn1 ret  nd_line node   yarvinstructions newarray  0
}
break compileloop
case hashnode
linkanchor list   decl_anchor
long size   0
node lnode     hashnode node  getlistnode
if lnode childnodes   size  >0
compile_array list  lnode  false
size     insn pop_element list   i l_op0
add_seq ret  list
}
add_insn1 ret  nd_line node   yarvinstructions newhash  size
if poped
add_insn ret  nd_line node   yarvinstructions pop
}
break compileloop
case fixnumnode
fixnumnode ivisited    fixnumnode  node
if  poped
add_insn1 ret  nd_line node   yarvinstructions putobject  ivisited getfixnum runtime
}
break compileloop
case whilenode
case untilnode
label next_label   new_label nd_line node   	   next
label redo_label   new_label nd_line node   	   redo
label break_label   new_label nd_line node   	   break
label end_label   new_label nd_line node
add_label ret  redo_label
node body   null
if node instanceof whilenode
body     whilenode node  getbodynode
else if node instanceof untilnode
body     untilnode node  getbodynode
}
compile_poped ret     body
add_label ret  next_label  	   next
if node instanceof whilenode
compile_branch_condition ret    whilenode node  getconditionnode    redo_label  end_label
else if node instanceof untilnode
/* untile */
compile_branch_condition ret    untilnode node  getconditionnode   end_label  redo_label
else
add_call_receiver ret  nd_line node
//todo:                    add_call(ret, nd_line(node), id2sym(idgets), int2fix(0));
add_insnl ret  nd_line node   yarvinstructions branchif  redo_label
/* opt_n */
}
add_label ret  end_label
add_insn ret  nd_line node   yarvinstructions putnil
add_label ret  break_label  	   braek
if  poped
add_insn ret  nd_line node   yarvinstructions pop
}
break compileloop
}
case selfnode
if   poped  add_insn ret  nd_line node   yarvinstructions putself
break compileloop
case nilnode
if   poped  add_insn ret  nd_line node   yarvinstructions putnil
break compileloop
case truenode
if   poped  add_insn1 ret  nd_line node   yarvinstructions putobject  runtime gettrue
break compileloop
case falsenode
if   poped  add_insn1 ret  nd_line node   yarvinstructions putobject  runtime getfalse
break compileloop
default
debugs     node
break compileloop
}
}
return compile_ok
}
private int compile_branch_condition linkanchor ret  node cond  label then_label  label else_label
switch cond nodeid
case notnode
compile_branch_condition ret    notnode cond  getconditionnode    else_label  then_label
break
case andnode
label label   new_label nd_line cond
compile_branch_condition ret    andnode cond  getfirstnode    label  else_label
add_label ret  label
compile_branch_condition ret    andnode cond  getsecondnode    then_label  else_label
break
}
case ornode
label label   new_label nd_line cond
compile_branch_condition ret    ornode cond  getfirstnode    then_label  label
add_label ret  label
compile_branch_condition ret    ornode cond  getsecondnode    then_label  else_label
break
}
case truenode
case strnode
add_insnl ret  nd_line cond   yarvinstructions jump  then_label
break
case falsenode
case nilnode
add_insnl ret  nd_line cond   yarvinstructions jump  else_label
break
default
compile ret     cond
add_insnl ret  nd_line cond   yarvinstructions branchunless  else_label
add_insnl ret  nd_line cond   yarvinstructions jump  then_label
break
}
return compile_ok
}
private int compile_array linkanchor ret  node node_root  boolean opt_p
node node   node_root
int len     arraynode node  size
int line   nd_line node
linkanchor anchor   decl_anchor
list c   node childnodes
for iterator iter   c iterator    iter hasnext
node    node iter next
if opt_p      node instanceof iliteralnode
opt_p   false
}
compile anchor     node
}
if opt_p
list l   new arraylist
for iterator iter   c iterator    iter hasnext
node    node iter next
switch node nodeid
case fixnumnode
l add   fixnumnode node  getfixnum runtime
break
default
debugs     node
break
}
}
add_insn1 ret  nd_line node_root   yarvinstructions duparray  runtime newarray l
else
add_insn1 anchor  line  yarvinstructions newarray  len
append_list ret  anchor
}
return len
}
private int setup_arg linkanchor args  iargumentnode node
int n   new int  0 0
node argn   node getargsnode
linkanchor arg_block   decl_anchor
linkanchor args_push   decl_anchor
boolean blockargs   false
if  argn    null
if  argn instanceof blockpassnode
blockpassnode blockpassnode    blockpassnode  argn
compile arg_block     blockpassnode getbodynode
blockargs   true
argn   blockpassnode getargsnode
}
switch argn nodeid
case splatnode
break
case argscatnode
break
case argspushnode
break
default
n   compile_array args argn false
pop_element args
break
}
}
if   list_size_zero args_push   add_seq args  args_push
if  blockargs  add_seq args  arg_block
return n
}
private insn new_insn yarvmachine instruction i
insn n   new insn
n i   i
n next   null
return n
}
private void insn_set_specialized_instruction yarvmachine instruction instruction  int insn_id
instruction bytecode   insn_id
//iobj->operand_size = 0;
//return compile_ok;
}
private void add_call_receiver linkanchor seq  int line
add_insn seq  line  yarvinstructions putnil
}
private void add_insn linkanchor seq  int line  int insn
yarvmachine instruction i   new yarvmachine instruction insn
i line_no   line
debugs     line       yarvinstructions name insn
add_elem seq  new_insn i
}
private yarvmachine instruction add_send_r linkanchor seq  int line  string name  int argc  object block  int flags
yarvmachine instruction i   new yarvmachine instruction yarvinstructions send
i line_no   line
i s_op0   name
i i_op1   argc
i i_op3   flags
debugs     line       yarvinstructions name yarvinstructions send        name       argc       flags
add_elem seq  new_insn i
return i
}
private void add_insn1 linkanchor seq  int line  int insn  irubyobject obj
yarvmachine instruction i   new yarvmachine instruction insn
i line_no   line
i o_op0   obj
debugs     line       yarvinstructions name insn        obj
add_elem seq  new_insn i
}
private void add_insn1 linkanchor seq  int line  int insn  long op
yarvmachine instruction i   new yarvmachine instruction insn
i line_no   line
i l_op0   op
debugs     line       yarvinstructions name insn        op
add_elem seq  new_insn i
}
private void add_insnl linkanchor seq  int line  int insn  label l
yarvmachine instruction i   new yarvmachine instruction insn
i line_no   line
i _tmp   l
debugs     line       yarvinstructions name insn        l
add_elem seq  new_insn i
}
private void add_insn1 linkanchor seq  int line  int insn  string obj
yarvmachine instruction i   new yarvmachine instruction insn
i line_no   line
i s_op0   obj
debugs     line       yarvinstructions name insn        obj
add_elem seq  new_insn i
}
private void add_insn3 linkanchor seq  int line  int insn  string name  yarvmachine instructionsequence iseq  long n
yarvmachine instruction i   new yarvmachine instruction insn
i line_no   line
i s_op0   name
i iseq_op   iseq
i l_op0   n
debugs     line       yarvinstructions name insn        name       iseq       n
add_elem seq  new_insn i
}
public yarvmachine instructionsequence getinstructionsequence string name  string filename  string level
iseq   new yarvmachine instructionsequence runtime  name  filename  level
list l   new arraylist
map jumps   new identityhashmap
map labels   new identityhashmap
int real 0
for  linkelement elm   current_iseq  elm    null  elm   elm next
if  elm instanceof insn
insn i    insn elm
if  isjump i i bytecode   jumps put i  i i _tmp
l add i i
real
else if  elm instanceof label
labels put elm  new integer real 1
}
}
for iterator iter   jumps keyset   iterator   iter hasnext
insn k    insn iter next
k i l_op0     integer labels get jumps get k    intvalue     1
k i _tmp   null
}
debugs     l
iseq body    yarvmachine instruction l toarray new yarvmachine instruction
iseq locals   locals
return iseq
}
private boolean isjump int i
return i    yarvinstructions jump    i    yarvinstructions branchif
i    yarvinstructions branchunless    i    yarvinstructions getinlinecache
i    yarvinstructions setinlinecache
}
}