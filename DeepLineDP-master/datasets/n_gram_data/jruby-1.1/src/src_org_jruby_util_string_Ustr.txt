package org jruby util string
import java io serializable
import java util hashtable
/**
* ustr - rhymes with wooster.
* implements a string, with three design goals:
*
* <ol>
* <li>correct implementation of unicode semantics.</li>
* <li>support for as many of java's string and stringbuffer methods as
*    is reasonable.</li>
* <li>support for the familiar null-terminated-string primitives
*    of the c programming language: strcpy() and friends.</li></ol>
*
* <p>a ustr is a fairly thin wrapper around a byte[] array, which
* contains null-terminated utf8-encoded text.</p>
*
* <p><b>note</b> that in the context of a ustr, "index" always means how
* many unicode characters you are into the ustr's text, while "offset"
* always mean how many bytes you are into its utf8 encoded form.</p>
*
* <p>similarly, "char" and "string" always refer to the java constructs,
* while "character" always means a unicode character, always identified
* by a java int.</p>
*
* <p>if any of the ustr methods are passed an integer alleged to represent
* a unicode character whose value is not a valid code point, i.e. is either
* negative or greater than 0x10ffff, the method will throw a ustrexception,
* which extends runtimeexception and is thus not checked at compile-time.</p>
*
* <p>for any method that copies characters and might overrun a buffer, a
* "safe" version is provided, starting with an extra <code>s</code>, e.g.
* <code>sstrcopy</code> and <code>sstrcat</code>. these versions always
* arrange that the copied string not overrun the provided buffer, which
* will be properly null-terminated.</p>
*
* @see org.jruby.util.string.ustrexception
*/
public class ustr
implements comparable  serializable
private static final long serialversionuid    7263880042540200296l
// the number of bytes of utf8, indexed by the value of the first byte
private static final byte enclength
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2
2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2
3   3   3   3   3   3   3   3   3   3   3   3   3   3   3   3
4   4   4   4   4   4   4   4   1   1   1   1   1   1   1   1
private static hashtable interns   new hashtable
/**
* a null-terminated byte array containing the string in utf-8 form.  all
* ustr operations count on null-termination.  the byte array may
* be much bigger than the contained string
*/
public byte s           utf encoded text
/**
* where in the array <code>s</code> the string starts.  you can
*  have lots of different ustrs co-existing in a single byte array.
*/
public int base   0       of the start of the string
/**
* to keep track of a single character position within the string;
* this is used by the <code>nextchar</code> and <code>appendchar</code>
* methods.
*/
public int offset   0     for iterating  relative to base
/**
* creates an empty ustr with no buffer
*/
public ustr
base   offset   0
}
/**
* creates an empty ustr, with a null termination at the front.
*
* @param length length of the buffer, in bytes
*/
public ustr int length
s   new byte
base   offset   0
s   0
}
/**
* wraps a ustr around a buffer.  does not do null termination, so you
* can pass in a buffer already containing a string.
*
* @param bytes the buffer
*/
public ustr byte bytes
s   bytes
base   offset   0
}
/**
* wraps a ustr around a position in a buffer.   does not do null
* termination, so you can pass in a buffer already containing a string.
*
* @param bytes the buffer
* @param start where in the buffer the strings starts
*/
public ustr byte bytes  int start
s   bytes
base   offset   start
}
/**
* makes a ustr which is a copy of another ustr
*
* @param from the ustr to copy
*/
public ustr ustr from
s   new byte
base   offset   0
strcpy from
}
/**
* makes a ustr from a char[] array.  the ustr is null-terminated, but
* no space is allocated beyond what's needed.
*
* @param chars the char array
*/
public ustr char  chars
int size   0
for  int i   0  i < chars length  i
char utf16   chars
// this works because surrogate characters will be counted as 2
//  each, and anything in the astral planes takes 4 bytes.
size    bytesinchar utf16
}
s   new byte
base   0
prepareappend
int i   0
while  i < chars length
int val   chars
if  val < 0xd800    val > 0xdfff
no op
// argh, surrogates.
else
if  val > 0xdbff
throw new ustrexception
i
if  i    chars length
throw new ustrexception
int val2   chars
if  val2 < 0xdc00    val2 > 0xdfff
throw new ustrexception
val    0x3ff
val <<  10
val2    0x3ff
val    val2
val    0x10000
}
i
appendchar val
}
s   0
}
/**
* makes a ustr from an int[] array, where each int is the value of
* a unicode character.  throws a ustrexception if one of the ints
* is not a unicode codepoint (negative or >0x10ffff).
*
* @param ints the int array
* @throws ustrexception
*
*/
public ustr int  ints
int bufsiz   0
for  int j   0  j < ints length  j
int i   ints
if  i < 0
throw new ustrexception
if  i > 0x10ffff
throw new ustrexception
bufsiz    bytesinchar i
}
s   new byte
base   offset   0
for  int j   0  j < ints length  j
int i   ints
appendchar i
}
}
/**
* makes a ustr from an object, based on its <code>tostring()</code>.
* most commonly used with a string argument.  the ustr is null-terminated,
* but no space is allocated beyond what's needed.  throws a ustrexception
* if the environment doesn't support the utf8 encoding.
*
* @param o the object
* @throws ustrexception
*/
public ustr object o
byte inbytes
base   offset   0
try
inbytes   o tostring   getbytes
catch  java io unsupportedencodingexception e
throw new ustrexception
}
// because we need one more byte than getbytes provides
s   new byte
for  int i   0  i < inbytes length  i
s   inbytes
s   0
}
/**
* makes a ustr from an object, based on its <code>tostring()</code>,
* leaving room for growth. most commonly used with a string argument.
* the ustr is null-terminated.
*
* @param space how large a buffer to allocate
* @param o     the object
*/
public ustr int space  object o
s   new byte
base   offset   0
byte  b
try
b   o tostring   getbytes
catch  java io unsupportedencodingexception e
throw new runtimeexception
}
for  int i   0  i < b length  i
s   b
s   0
}
/**
* empty a ustr by setting its first byte to 0.
*/
public void init
s   0
offset   base
}
/**
* supports the <code>comparable</code> interface.  the ordering is that of
* native unicode code points and probably not culturally appropriate
* anywhere.
*
* @param other the object compared
* @return -1, 0, or 1 as you'd expect.
*/
public int compareto object other
ustr o    other instanceof ustr  ?  ustr  other   new ustr other
return strcmp s  base  o s  o base
}
/**
* generates a java string representing the ustr.  throws a ustrexception
* if the java environment doesn't support the utf8 encoding.
*
* @return the string.
* @throws ustrexception
*/
public string tostring
try
return new string s  base  strlen
catch  java io unsupportedencodingexception e
throw new ustrexception
}
}
// per-unicode-character operations
//
/**
* length of a ustr in unicode characters (not bytes).
*
* @return the number of unicode characters.
*/
public int length
int saveoffset   offset
int l   0
for  preparenext    nextchar      0  l
empty
offset   saveoffset
return l
}
/**
* number of unicode characters stored starting at some offset in a byte
* array.  assumes utf-8 encoding and null termination.
*
* @param b      the byte array
* @param offset where to start counting
* @return       the number of unicode characters.
*/
public static int length byte  b  int offset
return  new ustr b  offset   length
}
/**
* number of unicode characters stored in a byte array.  assumes utf-8
* encoding and null termination.
*
* @param b the byte array
* @return  the number of unicode characters.
*/
public static int length byte  b
return length b  0
}
/**
* number of unicode characters stored in a java string.
* if <code>s</code> is a string, <code>s.length()</code> and
* <code>ustr.length(s)</code> will be the same except when <code>s</code>
* contains non-bmp characters.
*
* @param str the string
* @return    the number of unicode characters
*/
public static int length string str
return  new ustr str   length
}
/**
* set up for <code>appendchar</code>.  points the <code>offset</code>
* field at the buffer's null terminator.
*/
public void prepareappend
offset   strlen
}
/**
* append one unicode character to a ustr.  assumes that the
* <code>offset</code> points to the null-termination,
* where the character ought to go, updates that field and applies
* another null termination.  you could change the value of
* <code>offset</code> and start "appending" into the middle of a ustr
* if that's what you wanted.  this generates the utf-8 bytes from
* the input characters.
* <p>if the character is less than 128, one byte of buffer is used.
* if less than 0x8000, two bytes.  if less than 2**16, three bytes.
* if less than 0x10ffff, four bytes.  if greater than 0x10ffff, or
* negative, you get an exception.</p>
*
* @param c the character to be appended.
*/
public void appendchar int c
offset   appendchar c  s  offset
}
/**
* writes one unicode character into a utf-8 encoded byte array at
* a given offset, and null-terminates it.  throws a ustrexception if
* the 'c' argument is not a unicode codepoint (negative or >0x10ffff)
*
* @param        c the unicode character
* @param        s the array
* @param offset the offset to write at
* @return       the offset of the null byte after the encoded character
* @throws       ustrexception
*/
public static int appendchar int c  byte  s  int offset
if  c < 0
throw new ustrexception
if  c < 128
s    byte  c
else if  c <  0x7ff
s    byte      c >> 6    0xc0
s    byte    c   0x3f    0x80
else if  c <  0xffff
s    byte            c >> 12    0xe0
s    byte     c >> 6    0x3f    0x80
s    byte           c   0x3f    0x80
else if  c <  0x10ffff
s    byte             c >> 18    0xf0
s    byte     c >> 12    0x3f    0x80
s    byte      c >> 6    0x3f    0x80
s    byte            c   0x3f    0x80
else
throw new ustrexception
s   0
return offset
}
/**
* set up for <code>nextchar()</code>.  points the <code>offset</code>
* field at the start of the buffer.
*/
public void preparenext
offset   base
}
/**
* retrieve one unicode character from a ustr and advance the working
* offset.  assumes the working offset is sanely located.
*
* @return the unicode character, 0 signaling the end of the string
*/
public int nextchar
if  s    0
return 0
if   s   0x80     0
return  int  s
if   s   0xe0     0xc0
// 110w wwww 10zz zzzz
// xxxx xwww wwzz zzzz
int c    s   0x1f  << 6
c    s   0x3f
return c
}
if   s   0xf0     0xe0
// 1110 wwww 10zz zzzz 10xx xxxx
// wwww zzzz zzxx xxxx
int c    s   0xf  << 12
c     s   0x3f  << 6
c    s   0x3f
return c
}
// 1111 0www 10zz zzzz 10xx xxxx 10yy yyyy
// wwwwzz zzzzxxxx xxyyyyyy
int c    s   0x7  << 18
c     s   0x3f  << 12
c     s   0x3f  << 6
c    s   0x3f
return c
}
// strlen variants
//
/**
* the length in bytes of a ustr's utf representation.  assumes
* null-termination.
*
* @return the number of bytes
*/
public int strlen
return strlen s  base
}
/**
* the length in bytes of a null-terminated byte array
*
* @param b the array
* @return  the number of bytes
*/
public static int strlen byte  b
int i   0
while  b    0
i
return i
}
/**
* the length in bytes of a null-terminated sequence starting at some
* offset in a byte array.
*
* @param b    the byte array
* @param base the byte offset to start counting at
* @return     the number of bytes
*/
public static int strlen byte  b  int base
int i   base
while  b    0
i
return i   base
}
// strcpy variants
//
/**
* copy a null-terminated byte array.
*
* @param to   destination array
* @param from source array
* @return     the destination array
*/
public static byte  strcpy byte  to  byte  from
return strcpy to  0  from  0
}
/**
* copy null-terminated byte arrays with control over offsets.
*
* @param to    destination array
* @param tbase starting offset in destination array
* @param from  source array
* @param fbase starting offset in source array
* @return      the destination array
*/
public static byte  strcpy byte  to  int tbase  byte  from  int fbase
while  from    0
to   from
to   0
return to
}
/**
* copy in the contents of another ustr.  does not change the offset.
*
* @param from source ustr
* @return     this ustr
*/
public ustr strcpy ustr from
strcpy s  base  from s  from base
return this
}
/**
* copy in the string representation of an object.  does not change the
* offset.
*
* @param o the source object
* @return  this ustr
*/
public ustr strcpy object o
strcpy new ustr o
return this
}
/**
* copy in the contents of a null-terminated byte array.  does not change
* the offset.
*
* @param from the byte array
* @return     this ustr
*/
public ustr strcpy byte from
strcpy s  from
return this
}
/**
* copy in the contents at some offset in a null-terminated byte array.
* does not change the offset.
*
* @param from    the source byte array
* @param boffset where to start copying in the source array
* @return        this ustr
*/
public ustr strcpy byte from  int boffset
strcpy s  0  from  boffset
return this
}
/**
*
* load a null-terminated utf-8 encoding of a string into a byte array at
* the front.
*
* @param b      the byte array
* @param s      the string
*
* @return the byte array
*/
public static byte  strcpy byte  b  string s
return strcpy b  0  s
}
/**
* load a null-terminated utf-8 encoding of a string into a byte array.
*
* @param b      the byte array
* @param offset where in the byte array to load
* @param s      the string
*
* @return the byte array
*/
public static byte  strcpy byte  b  int offset  string s
byte  sbytes
try   sbytes   s getbytes       catch  java io unsupportedencodingexception e
throw new runtimeexception
for  int i   0  i < sbytes length  i
b   sbytes
b   0
return b
}
// safe versions
// could check for to.length myself, but since java is necessarily
//  doing this for me each time around the loop, why bother?
//
/**
* safely append one ustr to another.
*
* @param from the ustr to be appended
* @return     this
*/
public ustr sstrcat ustr from
sstrcat s  base  from s  from base
return this
}
/**
* safely append one null-terminated byte array to another.  destination
* buffer will not be overrun.
*
* @param to   dest array
* @param from source array
* @return     dest array
*/
public byte  sstrcat byte  to  byte from
return sstrcat to  0  from  0
}
/**
* safely append one null-terminated byte array to another with control
* over offsets.  destination buffer will not be overrun.
*
* @param to    dest array
* @param tbase base of dest array
* @param from  source array
* @param fbase base of source array
* @return to
*/
public static byte  sstrcat byte  to  int tbase  byte  from  int fbase
// don't want to catch if the dest string is malformed
while  to    0
tbase
try
while  from    0
to   from
to   0
return to
catch  java lang arrayindexoutofboundsexception e
if  tbase >  to length
to   0
else
throw e
}
return to
}
/**
* safely copy null-terminated byte arrays with control over offsets.
* destination buffer will not be overrun.
*
* @param to    destination array
* @param tbase starting offset in destination array
* @param from  source array
* @param fbase starting offset in source array`
* @return      the destination array
*/
public static byte  sstrcpy byte  to  int tbase  byte  from  int fbase
try
while  from    0
to   from
to   0
}
catch  java lang arrayindexoutofboundsexception e
// if the buffer's too short
if  tbase >  to length
to   0
// otherwise there's some problem with the source string, we
//  shouldn't catch it
else
throw e
}
return to
}
/**
* safely copy a null-terminated byte array.  the destination buffer will not
* be overrun.
*
* @param to   destination array
* @param from source array
* @return     the destination array
*/
public static byte  sstrcpy byte  to  byte  from
return sstrcpy to  0  from  0
}
/**
* safely copy in the contents of another ustr.  does not change the offset.
* the destination buffer will not be overrun.
*
* @param from source ustr
* @return     this ustr
*/
public ustr sstrcpy ustr from
sstrcpy s  base  from s  from base
return this
}
/**
* copy one null-terminated array to the end of another, with
* starting offsets for each
*
* @param to    destination array
* @param tbase  base pos of destination
* @param from  source array
* @param fbase base pos of source
* @return      destination
*/
public static byte  strcat byte  to  int tbase  byte  from  int fbase
while  to    0
tbase
while  from    0
to   from
to   0
return to
}
/**
* copy one null-terminated byte array to the end of another.
*
* @param to   destination array
* @param from source array
* @return     the destionation array
*/
public static byte  strcat byte  to  byte  from
return strcat to  0  from  0
}
/**
* append the contents of another ustr to the end of this one
*
* @param  other the other ustr
* @return       this ustr
*/
public ustr strcat ustr other
strcat s  other s
return this
}
/**
* compare two null-terminated byte arrays.  the ordering is that of
* native unicode code points and probably not culturally appropriate
* anywhere.
*
* @param s1 first byte array
* @param s2 second byte array
* @return   a negative number, zero, or a positive number depending
* on whether s1 is lexically less than, equal to, or greater than s2.   */
public static int strcmp byte  s1  byte  s2
return strcmp s1  0  s2  0
}
/**
* compare sections of two null-terminated byte arrays.  the ordering is
* that of
* native unicode code points and probably not culturally appropriate
* anywhere.
*
* @param s1     first byte array
* @param s1base byte offset in first array to start comparing
* @param s2     second byte array
* @param s2base byte offset in second array to start comparing
* @return       a negative number, zero, or a positive number depending on
* whether s1 is lexically less than, equal to, or greater than s2.
*/
public static int strcmp byte  s1  int s1base  byte  s2  int s2base
ustr u1   new ustr s1  s1base
ustr u2   new ustr s2  s2base
int c1   u1 nextchar
int c2   u2 nextchar
while  c1    0    c2    0    c1    c2
c1   u1 nextchar
c2   u2 nextchar
}
return c1   c2
}
/**
* compare two ustrs.  the ordering is that of
* native unicode code points and probably not culturally appropriate
* anywhere.
*
* @param other the other ustr
* @return   a negative number, zero, or a positive number depending on
* whether the other is lexically less than, equal to, or greater than this.
*/
public int strcmp ustr other
return strcmp s  base  other s  other base
}
/**
* compare a ustr to an object's string representation.  the ordering
* is that of native unicode code points and probably not culturally
* appropriate anywhere.
*
* @param other the other object
* @return   a negative number, zero, or a positive number depending on
* whether the other is lexically less than, equal to, or greater than this.
*/
public int strcmp object other
return strcmp new ustr other
}
/**
* locate a unicode character in a ustr.  returns null if not
* found; if the character is zero, finds the offset of the null termination.
*
* @param c the character, as an integer
* @return  a ustr with the same buffer, starting at the matching character,
* or null if it's not found.
*/
public ustr strchr int c
int where   strchr s  c
return  where     1  ? null   new ustr s  where
}
/**
* find the offset where a unicode character starts in a null-terminated
* utf-encoded byte array.
* returns -1 if not found; if the character is zero, finds the index of
* the null termination.
*
* @param b utf-encoded null-terminated byte array
* @return  the offset in the string, or -1
*/
public static int strchr byte  b  int c
byte  cbytes   new byte
appendchar c  cbytes  0
return strstr b  cbytes
}
/**
* locate the last occurrence of a unicode character in a ustr.
* if found, returns a ustr built around the same buffer as
* this, with the base set to the matching location.  if not found, null
*
* @param c the character, as an integer
* @return  a ustr with the base set to the match, or null
*/
public ustr strrchr int c
int where   strrchr s  c
return  where     1  ? null   new ustr s  where
}
/**
* find the index of the last appearance of a unicode character in a
* null-terminated utf-encoded byte array.
* returns -1 if not found.
*
* @param b the byte array
* @param c the integer
* @return  the offset where the last occurence of c starts, or -1
*/
public static int strrchr byte  b  int c
byte  cbytes   new byte
appendchar c  cbytes  0
int where   b length   strlen cbytes
while  where >  0
int i
for  i   0  cbytes    0  i
if  b    cbytes
break
if  cbytes    0
return where
where
}
return  1
}
/**
* locate a substring in a string.  returns a ustr built around the same
* buffer, but starting at the matching position, or null if no match
* is found.
*
* @param little the substring to be located
* @return       matching ustr, or null
*/
public ustr strstr ustr little
int where   strstr s  little s
return  where     1  ? null   new ustr s  where
}
/**
* locate a substring in a byte array.  returns the offset of the substring
* if it matches, otherwise -1.
*
* @param big    the array to search in
* @param little the array to search for
* @return       the index of the match, or -1
*/
public static int strstr byte  big  byte  little
// should boyermooreify this...
for  int bi   0  big    0  bi
int li
for  li   0  little    0  li
if  big    little
break
if  little    0
return bi
}
return  1
}
/////////////////////////////////////////////////////////////////
// from here on down the methods are those from java.lang.string
/////////////////////////////////////////////////////////////////
/**
* returns a ustr generated from the char array.
*
* @param data the char array
* @return     a new ustr
*/
static ustr copyvalueof char  data
return new ustr data
}
/**
* returns a ustr generated from a piece of the char array.
*
* @param data   the char array
* @param offset where to start generating from
* @param count  how many java chars to use
* @return       a new ustr
*/
static ustr copyvalueof char  data  int offset  int count
char  chunk   new char
for  int i   0  i < count  i
chunk   data
return new ustr chunk
}
/**
* find the unicode character at some index in a ustr.  throws an
* indexoutofbounds exception if appropriate.
*
* @param at the index
* @return   the unicode character, as an integer
*/
public int charat int at
throws indexoutofboundsexception
if  at < 0
throw new indexoutofboundsexception
int c   0
offset   0
preparenext();
do
c   nextchar
at
while  c    0    at >  0
if  at > 0
throw new indexoutofboundsexception
return c
}
/**
* append a string to the end of this.
*
* @param str the string
* @return a  a new ustr which contains the concatenation
*/
public ustr concat string str
ustr us   new ustr str
return concat us
}
/**
* append a ustr to the end of this.
*
* @param us the ustr to append
* @return   a new ustr
*/
public ustr concat ustr us
ustr ret   new ustr strlen     us strlen     1
ret strcpy this
ret strcat us
return ret
}
/**
* test if this ustr ends with the specified suffix (a ustr).
*
* @param suffix the possible suffix.
* @return       true or false.
*/
public boolean endswith ustr suffix
int start   strlen     suffix strlen
if  start < 0
return false
//      can't use strcmp because we're just seeing if the byte encodings end the same
// irrespective of the unicode chars they encode
int i   0
while  s    0    suffix s    0
s    suffix s
i
return  s    suffix s
}
/**
* test if this ustr ends with specified suffix (a string).
*
* @param suffix the possible suffix
* @return       true or false
*/
public boolean endswith string suffix
return endswith new ustr suffix
}
/**
* compares this ustr to another object.
*
* @param anobject the other object
* @return         true or false
*/
public boolean equals object anobject
return  compareto anobject     0
}
/**
* convert this ustr into bytes according to the platform's default
* character encoding, storing the result in a new byte array.
*
* @return a new byte array
*/
public byte  getbytes
return tostring   getbytes
}
/**
* convert this ustr into bytes according to the specified
* character encoding, storing the result into a new byte array.
*
* @param enc the encoding to use in generating bytes
* @return    the new byte array
*/
public byte  getbytes string enc
throws java io unsupportedencodingexception
return tostring   getbytes enc
}
/**
* copies unicode characters from this string into the destination
* char array.  note that if the string contains utf-16 surrogate
* pairs, each pair counts as a single character.
*
* @param str      the string
* @param srcbegin where to start copying
* @param srcend   index after last char to copy
* @param dst      start of destination array
* @param dstbegin where in the destination array to start copying
*/
public static void getchars string str  int srcbegin  int srcend
char  dst  int dstbegin
ustr us   new ustr str
us getchars srcbegin  srcend  dst  dstbegin
}
/**
* copies unicode characters from this ustr into the destination
* char array.  we can't just dispatch to the string implementation
* because we do unicode characters, it does utf-16 code points
*
* @param srcbegin where to start copying
* @param srcend   index after last char to copy
* @param dst      start of destination array
* @param dstbegin where in the destination array to start copying
*/
public void getchars int srcbegin  int srcend  char  dst  int dstbegin
if  srcbegin < 0    srcbegin > srcend    dstbegin < 0
throw new indexoutofboundsexception
if  dst    null
throw new nullpointerexception
preparenext();
while  srcbegin > 0
srcbegin
nextchar();
}
int c
int howmany   srcend   srcbegin
int i  j
for  i   j   0  i < howmany  i    j
c   nextchar
if  c    0    i < howmany   1
throw new indexoutofboundsexception
if  c < 0x10000
dst    char  c
else
// two utf-16 codepoints
// 10346 => d800/df46
// 000uuuuuxxxxxxxxxxxxxxxx 110110wwwwxxxxxx 110111xxxxxxxxxx
// where wwww = uuuuu - 1
c    0x10000
int uhi    c >> 10    0x3ff
dst    char   0xd800   uhi
j
int ulo   c   0x3ff
dst    char   0xdc00   ulo
}
}
}
/**
* returns a hashcode for this ustr.  the algorithm is that documented
* for string, only that documentation says 'int'
* arithmetic, which is clearly wrong, but this produces the same result
* as string's hashcode() for the strings "1" and "2", and thus by
* induction must be correct.
*
* @return an integer hashcode
*/
public int hashcode
long h   0
long c
long n   length     1
preparenext();
while   c   nextchar       0
h    c   pow 31  n
n
}
return  int   h   0xffffffff
}
// er blush i'm on a plane and can't find long exponentiation in java
private static long pow long a  long b
long p   1
while  b   > 0
p    a
return p
}
/**
* returns the first index within this ustr of the specified
* unicode character.
*
* @param ch    the character
* @return      index (usable by charat) in the string of the char, or -1
*/
public int indexof int ch
return indexof ch  0
}
/**
* returns the first index within this ustr of the specified
* character, starting at the specified index.
*
* @param ch    the character
* @param start where to start looking
* @return      index (usable by charat) in the string of the char, or -1
*/
public int indexof int ch  int start
int i   0
preparenext();
while  start   > 0
nextchar();
i
}
int c
while   c   nextchar       0
if  c    ch
return i
i
}
if  ch    0
return i
return  1
}
/**
* returns the index within this ustr of the first occurrence of the
* specified other ustr, or -1.
*
* @param us the other ustr
* @return   the index of the match, or -1
*/
public int indexof ustr us
return indexof us  0
}
/**
* returns the index within this ustr of the first occurrence of the
* specified other ustr starting at the given offset, or -1.
*
* @param us    the other ustr
* @param start the index to start looking
* @return      the index of the match, or -1
*/
public int indexof ustr us  int start
int i   0
preparenext();
while  start   > 0
nextchar();
i
}
// we'll work at the utf level, but this should be boyermoore-ized
do
int j
for  j   0  s    0    us s    0  j
if  s    us s
break
if  us s    0
return i
i
while  nextchar      0
return  1
}
/**
* returns a canonical version of the ustr, which should be treated as
* read-only.  differs from the intern function
* of string in that it never returns the input string; if a new hashtable
* entry is required, it makes a new ustr and returns that.  if a programmer
* updates the contents of a ustr returned from intern(), grave disorder
* will ensue.
*
* @return the canonical version of the ustr.
*/
public ustr intern
ustr u    ustr interns get this
if  u    null
return u
u   new ustr strlen     1
u strcpy this
interns put u  u
return u
}
/**
* returns the index within this ustr of the last occurrence of the
* specified unicode character.
*
* @param ch   the character
* @return     the last index of the character, or -1
*/
public int lastindexof int ch
return lastindexof ch  length
}
/**
* returns the index within this ustr of the last occurrence of the
* specified unicode character before the specified stop index.
*
* @param ch   the character
* @param stop last index to consider
* @return     the last index of the character, or -1
*/
public int lastindexof int ch  int stop
int i   0
preparenext();
int foundat    1
do
if  ch    nextchar
foundat   i
i
while  i <  stop
return foundat
}
/**
* finds the last substring match.
*
* @param us   the subtring to search for
* @return     the match index, or =1
*/
public int lastindexof ustr us
return lastindexof us  length
}
/**
* finds the last substring match before the given index.
*
* @param us   the subtring to search for
* @param stop where to stop searching
* @return     the match index, or =1
*/
public int lastindexof ustr us  int stop
int i   0
int foundat    1
// we'll work at the utf level, but this should be boyermoore-ized
preparenext();
do
int j
for  j   0  s    0    us s    0  j
if  s    us s
break
if  us s    0
foundat   i
i
while  nextchar      0    i <  stop
return foundat
}
private static int bytesinchar int c
if  c < 128
return 1
else if  c < 0x800
return 2
else if  c < 0x10000
return 3
else
return 4
}
/**
* returns a new ustr with all instances of one unicode character replaced
* by another.  throws a ustrexception if newchar
* is not a unicode codepoint (negative or >0x10ffff).
*
* @param oldchar the unicode character to be replaced
* @param newchar the unicode character to replace it with
* @return        the new ustr
* @throws        ustrexception
*/
public ustr replace int oldchar  int newchar
if  newchar < 0
throw new ustrexception
else if  newchar > 0x10ffff
throw new ustrexception
// figure out how much space we need
int space   strlen     1
int delta   bytesinchar newchar    bytesinchar newchar
if  delta    0
int c
while   c   nextchar       0
if  c    oldchar
space    delta
}
ustr us   new ustr space
preparenext    us prepareappend
int c
while   c   nextchar       0
us appendchar  c    oldchar  ? newchar   c
return us
}
/**
* tests if other ustr is prefix of this.
*
* @param us    the other ustr
* @return      true/false
*/
public boolean startswith ustr us
return startswith us  0
}
/**
* tests if other ustr is prefix at given index.
*
* @param us    the other ustr
* @param start where to test
* @return      true/false
*/
public boolean startswith ustr us  int start
preparenext();
while (start-- > 0)
nextchar();
for  int i   0  us s    0  i
if  s    us s
return false
return true
}
/**
* makes a new substring of a ustr given a start index.
*
* @param start index of start of substr
* @return      new ustr containing substr
*/
public ustr substring int start
return substring start  length
}
/**
* makes a new substring of a ustr identified by start and end
*  indices.
*
* @param start index of start of substr
* @param end   index of end of substr
* @return      new ustr containing substr
*/
public ustr substring int start  int end
if  start < 0    end < start    end > length
throw new indexoutofboundsexception
int howmany   end   start
offset   0
// move up to the start
while  start   > 0
int c   s   0xff
if (c == 0)
throw new indexoutofboundsexception("substring too long");
offset    enclength
}
int startat   offset
for (int i = 0; i < howmany; i++) {
int c   s   0xff
if (c == 0)
throw new indexoutofboundsexception("substring too long");
offset    enclength
}
int bytestomove   offset   startat
ustr us   new ustr bytestomove   1
system arraycopy s  startat  us s  0  bytestomove
us s   0
/*
int to = 0;
while (startat < offset)
us.s[to++] = s[startat++];
us.s[to] = 0;
*/
/*
preparenext();
while (start-- > 0)
nextchar();
ustr us = new ustr(strlen(s, offset) + 1);
us.prepareappend();
for (int i = 0; i < howmany; i++) {
int c = nextchar();
if (c == 0)
throw new indexoutofboundsexception("substring too long");
us.appendchar(c);
}
*/
return us
}
/**
* converts a ustr to a char array.
*
* @return the new char array
*/
public char  tochararray
return tostring   tochararray
}
}