/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2006-2007 thomas e enebo <enebo@acm.org>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby parser
import java io serializable
import org jruby rubymodule
import org jruby ast assignablenode
import org jruby ast node
import org jruby lexer yacc isourceposition
import org jruby runtime arity
/**
* staticscope represents lexical scoping of variables and module/class constants.
*
* at a very high level every scopes enclosing scope contains variables in the next outer
* lexical layer.  the enclosing scopes variables may or may not be reachable depending
* on the scoping rules for variables (governed by blockstaticscope and localstaticscope).
*
* staticscope also keeps track of current module/class that is in scope.  previouscrefscope
* will point to the previous scope of the enclosing module/class (cref).
*
*/
public abstract class staticscope implements serializable
private static final long serialversionuid   4843861446986961013l
// next immediate scope.  variable and constant scoping rules make use of this variable
// in different ways.
final protected staticscope enclosingscope
// live reference to module
private transient rubymodule cref   null
// next cref down the lexical structure
private staticscope previouscrefscope   null
// our name holder (offsets are assigned as variables are added
private string variablenames
private boolean variablecaptured
// number of variables in this scope representing required arguments
private int requiredargs   0
// number of variables in this scope representing optional arguments
private int optionalargs   0
// index of variable that represents a "rest" arg
private int restarg    1
// whether this scope is used as the "argument scope" for e.g. zsuper
private boolean isargumentscope   false
protected staticscope staticscope enclosingscope
this enclosingscope   enclosingscope
protected staticscope staticscope enclosingscope  string names
this enclosingscope   enclosingscope
this variablenames   names
this variablecaptured   new boolean
public int addvariable string name
int slot   isdefined name
if  slot >  0  return slot
// this is perhaps innefficient timewise?  optimal spacewise
if  variablenames    null
variablenames   new string
variablecaptured   new boolean
variablenames   name
else
string newvariablenames   new string
system arraycopy variablenames  0  newvariablenames  0  variablenames length
variablenames   newvariablenames
variablenames   name
boolean newvariablecaptured   new boolean
system arraycopy variablecaptured  0  newvariablecaptured  0  variablecaptured length
variablecaptured   newvariablecaptured
// returns slot of variable
return variablenames length   1
public string getvariables
return variablenames
public int getnumberofvariables
return variablenames    null ? 0   variablenames length
public void setvariables string names
if  names    null  return
variablenames   new string
system arraycopy names  0  variablenames  0  names length
variablecaptured   new boolean
/**
* next outer most scope in list of scopes.  an enclosing scope may have no direct scoping
* relationship to its child.  if i am in a localscope and then i enter something which
* creates another localscope the enclosing scope will be the first scope, but there are
* no valid scoping relationships between the two.  methods which walk the enclosing scopes
* are responsible for enforcing appropriate scoping relationships.
*
* @return the parent scope
*/
public staticscope getenclosingscope
return enclosingscope
/**
* does the variable exist?
*
* @param name of the variable to find
* @return index of variable or -1 if it does not exist
*/
public int exists string name
if  variablenames    null
for  int i   0  i < variablenames length  i
if  name    variablenames  return i
return  1
/**
* is this name in the visible to the current scope
*
* @param name to be looked for
* @return a location where the left-most 16 bits of number of scopes down it is and the
*   right-most 16 bits represents its index in that scope
*/
public int isdefined string name
return isdefined name  0
/**
* make a dasgn or localasgn node based on scope logic
*
* @param position
* @param name
* @param value
* @return
*/
public assignablenode assign isourceposition position  string name  node value
return assign position  name  value  this  0
/**
* get all visible variables that we can see from this scope that have been assigned
* (e.g. seen so far)
*
* @return a list of all names (sans $~ and $_ which are special names)
*/
public abstract string getallnamesinscope
protected abstract int isdefined string name  int depth
protected abstract assignablenode assign isourceposition position  string name  node value
staticscope topscope  int depth
protected abstract node declare isourceposition position  string name  int depth
/**
* make a dvar or localvar node based on scoping logic
*
* @param position the location that in the source that the new node will come from
* @param name of the variable to be created is named
* @return a dvarnode or localvarnode
*/
public node declare isourceposition position  string name
return declare position  name  0
public void capture int index
variablecaptured   true
public boolean iscaptured int index
return variablecaptured
/**
* gets the local scope relative to the current scope.  for localscopes this will be itself.
* blocks will contain the localscope it contains.
*
* @return localscope
*/
public abstract staticscope getlocalscope
/**
* get the live cref module associated with this scope.
*
* @return the live module
*/
public rubymodule getmodule
return cref
public staticscope getpreviouscrefscope
return previouscrefscope
public void setmodule rubymodule module
this cref   module
if  previouscrefscope    null
for  staticscope scope   getenclosingscope    scope    null  scope   scope getenclosingscope
if  scope cref    null
previouscrefscope   scope
return
/**
* update current scoping structure to populate with proper cref scoping values.  this should
* be called at any point when you reference a scope for the first time.  for the interpreter
* this is done in a small number of places (defnnode, defsnode, and getblock).  the compiler
* does this in the same places.
*
* @return the current cref, though this is largely an implementation detail
*/
public rubymodule determinemodule
if  cref    null
cref   getenclosingscope   determinemodule
assert cref    null
previouscrefscope   getenclosingscope   previouscrefscope
return cref
public int getoptionalargs
return optionalargs
public void setoptionalargs int optionalargs
this optionalargs   optionalargs
public int getrequiredargs
return requiredargs
public void setrequiredargs int requiredargs
this requiredargs   requiredargs
public int getrestarg
return restarg
public void setrestarg int restarg
this restarg   restarg
public boolean isargumentscope
return isargumentscope
public void setargumentscope boolean isargumentscope
this isargumentscope   isargumentscope
public arity getarity
if  optionalargs > 0
if  restarg >  0
return arity optional
return arity required requiredargs
else
if  restarg >  0
return arity optional
return arity fixed requiredargs
public void setarities int required  int optional  int rest
this requiredargs   required
this optionalargs   optional
this restarg   rest