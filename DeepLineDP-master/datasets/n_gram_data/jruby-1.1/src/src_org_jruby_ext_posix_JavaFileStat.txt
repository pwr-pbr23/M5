package org jruby ext posix
import java io file
import java io ioexception
import org jruby ext posix posixhandler warning_id
public class javafilestat implements filestat
private posixhandler handler
short st_mode
int st_blksize
long st_size
int st_ctime
int st_mtime
posix posix
public javafilestat posix posix  posixhandler handler
this handler   handler
this posix   posix
public void setup string path
// enebo: this was originally jrubyfile, but i believe we use jruby file for normalization
// of paths.  so we should be safe.
file file   new file path
// limitation: we cannot determine, so always return 4096 (better than blowing up)
st_blksize   4096
st_mode   calculatemode file  st_mode
st_size   file length
// parent file last modified will only represent when something was added or removed.
// this is not correct, but it is better than nothing and does work in one common use
// case.
st_mtime    int   file lastmodified     1000
if  file getparentfile      null
st_ctime    int   file getparentfile   lastmodified     1000
else
st_ctime   st_mtime
private short calculatemode file file  short st_mode
// implementation to lowest common denominator...
// windows has no file mode, but c ruby returns either 0100444 or 0100666
if  file canread    st_mode    all_read
if  file canwrite    st_mode    all_write
if  file isdirectory
st_mode    s_ifdir
else if  file isfile
st_mode    s_ifreg
try
st_mode   calculatesymlink file  st_mode
catch  ioexception e
// not sure we can do much in this case...
return st_mode
private short calculatesymlink file file  short st_mode  throws ioexception
if  file getabsolutefile   getparentfile      null
return st_mode
file absoluteparent   file getabsolutefile   getparentfile
file canonicalparent   absoluteparent getcanonicalfile
if  canonicalparent getabsolutepath   equals absoluteparent getabsolutepath
// parent doesn't change when canonicalized, compare absolute and canonical file directly
if   file getabsolutepath   equalsignorecase file getcanonicalpath
st_mode    s_iflnk
return st_mode
// directory itself has symlinks (canonical != absolute), so build new path with canonical parent and compare
file   new file canonicalparent getabsolutepath         file getname
if   file getabsolutepath   equalsignorecase file getcanonicalpath
st_mode    s_iflnk
return st_mode
/**
* limitation: java has no access time support, so we return mtime as the next best thing.
*/
public long atime
return st_mtime
public long blocks
handler unimplementederror
return  1
public long blocksize
return st_blksize
public long ctime
return st_ctime
public long dev
handler unimplementederror
return  1
public string ftype
if  isfile
return
else if  isdirectory
return
return
public int gid
handler unimplementederror
return  1
public boolean groupmember int gid
return posix getgid      gid    posix getegid      gid
/**
*  limitation: we have no pure-java way of getting inode.  webrick needs this defined to work.
*/
public int ino
return 0
public boolean isblockdev
handler unimplementederror
return false
/**
* limitation: [see jruby-1516] we just pick more likely value.  this is a little scary.
*/
public boolean ischardev
return false
public boolean isdirectory
return  mode     s_ifdir     0
public boolean isempty
return st_size      0
// at least one major library depends on this method existing.
public boolean isexecutable
handler warn warning_id dummy_value_used
return true
// at least one major library depends on this method existing.
public boolean isexecutablereal
handler warn warning_id dummy_value_used
return true
public boolean isfifo
handler unimplementederror
return false
public boolean isfile
return  mode     s_ifreg     0
public boolean isgroupowned
return groupmember gid
public boolean isidentical filestat other
handler unimplementederror
return false
public boolean isnamedpipe
handler unimplementederror
return false
public boolean isowned
return posix geteuid      uid
public boolean isrowned
return posix getuid      uid
public boolean isreadable
int mode   mode
if   mode   s_irusr     0  return true
if   mode   s_irgrp     0  return true
if   mode   s_iroth     0  return true
return false
// we do both readable and readable_real through the same method because
public boolean isreadablereal
return isreadable
public boolean issymlink
return  mode     s_iflnk     s_iflnk
public boolean iswritable
int mode   mode
if   mode   s_iwusr     0  return true
if   mode   s_iwgrp     0  return true
if   mode   s_iwoth     0  return true
return false
// we do both readable and readable_real through the same method because
// in our java process effective and real userid will always be the same.
public boolean iswritablereal
return iswritable
public boolean issetgid
handler unimplementederror
return false
public boolean issetuid
handler unimplementederror
return false
public boolean issocket
handler unimplementederror
return false
public boolean issticky
handler unimplementederror
return false
public int major long dev
handler unimplementederror
return  1
public int minor long dev
handler unimplementederror
return  1
public int mode
return st_mode   0xffff
public long mtime
return st_mtime
public int nlink
handler unimplementederror
return  1
public long rdev
handler unimplementederror
return  1
public long st_size
return st_size
// limitation: we have no pure-java way of getting uid. rubyzip needs this defined to work.
public int uid
return  1