/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2007 ola bini <ola.bini@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby ast executable
import org jruby metaclass
import org jruby ruby
import org jruby rubyarray
import org jruby rubyfixnum
import org jruby rubymodule
import org jruby rubystring
import org jruby parser staticscope
import org jruby parser localstaticscope
import org jruby runtime block
import org jruby runtime calltype
import org jruby runtime methodindex
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
import org jruby internal runtime methods wrappermethod
import org jruby internal runtime methods rubiniusmethod
import org jruby javasupport util runtimehelpers
/**
* @author <a href="mailto:ola.bini@ki.se">ola bini</a>
*/
public class rubiniusmachine
public final static rubiniusmachine instance   new rubiniusmachine
public final static int getint char bytecodes  int ix
int val   0
val     bytecodes<<24
val     bytecodes<<16
val     bytecodes<<8
val     bytecodes
return val
}
public irubyobject exec threadcontext context  irubyobject self  char bytecodes  irubyobject literals  irubyobject args
irubyobject stack   new irubyobject
int stacktop   0
stack   context getruntime   getnil
for int i 0 i<args length i
stack   args
}
int ip   0
int call_flags    1
int cache_index    1
ruby runtime   context getruntime
irubyobject recv
irubyobject other
loop  while  ip < bytecodes length
int ix   ip
int code   bytecodes
/*
system.err.print(rubiniusinstructions.names[code] + " (" + code + ") ");
if(rubiniusinstructions.one_int[code]) {
system.err.print("[" + getint(bytecodes, ip) + "] ");
} else if(rubiniusinstructions.two_int[code]) {
system.err.print("[" + getint(bytecodes, ip) + ", " + getint(bytecodes, ip+4) + "] ");
}
system.err.println("{" + ix + "}");
for(int i=stacktop; i>=0; i--) {
system.err.println(" [" + i + "]=" + stack[i].callmethod(context, "inspect"));
}*/
switch code
case rubiniusinstructions noop
break
}
case rubiniusinstructions add_method
int val   getint bytecodes  ip
ip    4
string name   literals tostring
rubymodule clzz    rubymodule stack
rubyarray method    rubyarray stack
visibility visibility   context getcurrentvisibility
if  name         visibility    visibility module_function
visibility   visibility private
}
rubiniuscmethod cmethod   new rubiniuscmethod method
staticscope staticscope   new localstaticscope context getcurrentscope   getstaticscope
staticscope setvariables new string
staticscope determinemodule
rubiniusmethod newmethod   new rubiniusmethod clzz  cmethod  staticscope  visibility
clzz addmethod name  newmethod
if  context getcurrentvisibility      visibility module_function
clzz getsingletonclass   addmethod
name
new wrappermethod clzz getsingletonclass    newmethod
visibility public
clzz callmethod context     literals
}
if  clzz issingleton
metaclass  clzz  getattached   callmethod
context     literals
else
clzz callmethod context     literals
}
stack   method
break
}
case rubiniusinstructions meta_push_neg_1
stack   rubyfixnum minus_one runtime
break
}
case rubiniusinstructions check_argcount
int min   getint bytecodes  ip
ip    4
int max   getint bytecodes  ip
ip    4
if args length < min
throw runtime newargumenterror     args length       min
else if max>0    args length>max
throw runtime newargumenterror     args length       max
}
break
}
case rubiniusinstructions meta_push_0
stack   rubyfixnum zero runtime
break
}
case rubiniusinstructions meta_push_1
stack   rubyfixnum one runtime
break
}
case rubiniusinstructions meta_push_2
stack   runtime newfixnum 2
break
}
case rubiniusinstructions set_local
int local   getint bytecodes  ip
ip    4
context getcurrentscope   setvalue local stack 0
break
}
case rubiniusinstructions push_local
int local   getint bytecodes  ip
ip    4
stack   context getcurrentscope   getvalue local 0
break
}
case rubiniusinstructions push_nil
stack   runtime getnil
break
}
case rubiniusinstructions push_true
stack   runtime gettrue
break
}
case rubiniusinstructions push_false
stack   runtime getfalse
break
}
case rubiniusinstructions push_self
stack   self
break
}
case rubiniusinstructions string_dup
stack     rubystring stack  strdup
break
}
case rubiniusinstructions push_literal
int val   getint bytecodes  ip
ip    4
stack   literals
break
}
case rubiniusinstructions meta_send_op_lt
irubyobject t1   stack
irubyobject t2   stack
if  t1 instanceof rubyfixnum      t1 instanceof rubyfixnum
stack      rubyfixnum t1  getlongvalue   <   rubyfixnum t2  getlongvalue    ? runtime gettrue     runtime getfalse
else
stack   t1 callmethod context  methodindex op_lt     t2
}
break
}
case rubiniusinstructions meta_send_op_gt
irubyobject t1   stack
irubyobject t2   stack
if  t1 instanceof rubyfixnum      t1 instanceof rubyfixnum
stack      rubyfixnum t1  getlongvalue   >   rubyfixnum t1  getlongvalue    ? runtime gettrue     runtime getfalse
else
stack   t1 callmethod context  methodindex op_gt     t2
}
break
}
case rubiniusinstructions meta_send_op_plus
irubyobject t1   stack
irubyobject t2   stack
if  t1 instanceof rubyfixnum      t2 instanceof rubyfixnum
stack     rubyfixnum t1  op_plus context  t2
else
stack   t1 callmethod context  methodindex op_plus     t2
}
break
}
case rubiniusinstructions meta_send_op_minus
irubyobject t1   stack
irubyobject t2   stack
if  t1 instanceof rubyfixnum      t2 instanceof rubyfixnum
stack     rubyfixnum t1  op_minus context  t2
else
stack   t1 callmethod context  methodindex op_minus     t2
}
break
}
case rubiniusinstructions pop
stacktop
break
}
case rubiniusinstructions set_call_flags
int val   getint bytecodes  ip
ip    4
call_flags   val
break
}
case rubiniusinstructions set_cache_index
int val   getint bytecodes  ip
ip    4
cache_index   val
break
}
case rubiniusinstructions send_stack
int index   getint bytecodes  ip
ip    4
int num_args   getint bytecodes  ip
ip    4
string name   literals tostring
int ixi   methodindex getindex name
recv   stack
irubyobject argu   new irubyobject
for int i 0 i<num_args i
argu   stack
}
if  call_flags   0x01     0x01      functional
stack   runtimehelpers invoke context  recv  ixi  name  argu  calltype functional  block null_block
else
stack   runtimehelpers invoke context  recv  ixi  name  argu  calltype normal  block null_block
}
break
}
case rubiniusinstructions goto_if_false
int val   getint bytecodes  ip
ip    4
if  stack istrue
ip   val
}
break
}
case rubiniusinstructions goto_if_true
int val   getint bytecodes  ip
ip    4
if stack istrue
ip   val
}
break
}
case rubiniusinstructions swap_stack
irubyobject swap   stack
stack   stack
stack   swap
break
}
case rubiniusinstructions dup_top
stack   stack
stacktop
break
}
case rubiniusinstructions goto
int val   getint bytecodes  ip
ip    4
ip   val
break
}
case rubiniusinstructions ret
return stack
}
case rubiniusinstructions push_int
int val   getint bytecodes  ip
ip    4
stack   runtime newfixnum val
break
}
case rubiniusinstructions push_const
int index   getint bytecodes  ip
ip    4
string name   literals tostring
stack   context getconstant name
break
}
default
system err println
if(rubiniusinstructions.one_int[code]) {
ip  4
} else if(rubiniusinstructions.two_int[code]) {
ip  8
}
break
}
}
return null
}
rubiniusmachine