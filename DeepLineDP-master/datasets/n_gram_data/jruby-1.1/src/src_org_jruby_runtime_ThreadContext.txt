/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2004 thomas e enebo <enebo@acm.org>
* copyright (c) 2004-2005 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 michael studman <codehaus@michaelstudman.com>
* copyright (c) 2006 miguel covarrubias <mlcovarrubias@gmail.com>
* copyright (c) 2007 william n dortch <bill.dortch@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby runtime
import org jruby runtime scope manyvarsdynamicscope
import org jruby ruby
import org jruby rubyarray
import org jruby rubyclass
import org jruby rubykernel catchtarget
import org jruby rubymodule
import org jruby rubythread
import org jruby internal runtime jumptarget
import org jruby libraries fiberlibrary fiber
import org jruby parser blockstaticscope
import org jruby parser localstaticscope
import org jruby parser staticscope
import org jruby runtime builtin irubyobject
/**
* @author jpetersen
*/
public final class threadcontext
public static synchronized threadcontext newcontext ruby runtime
threadcontext context   new threadcontext runtime
//        if(runtime.getinstanceconfig().issamplingenabled()) {
//    org.jruby.util.simplesampler.registerthreadcontext(context);
//}
return context
private final static int initial_size   50
private final ruby runtime
// is this thread currently with in a function trace?
private boolean iswithintrace
// is this thread currently doing an defined? defined should set things like $!
private boolean iswithindefined
private rubythread thread
private fiber fiber
// error info is per-thread
private irubyobject errorinfo
//private unsynchronizedstack parentstack;
private rubymodule parentstack   new rubymodule
private int parentindex    1
//private unsynchronizedstack framestack;
private frame framestack   new frame
private int frameindex    1
// list of active dynamic scopes.  each of these may have captured other dynamic scopes
// to implement closures.
private dynamicscope scopestack   new dynamicscope
private int scopeindex    1
private catchtarget catchstack   new catchtarget
private int catchindex    1
// file where current executing unit is being evaluated
private string file
// line where current executing unit is being evaluated
private int line   0
/**
* constructor for context.
*/
private threadcontext ruby runtime
this runtime   runtime
// init errorinfo to nil
errorinfo   runtime getnil
// toplevel self and a few others want a top-level scope.  we create this one right
// away and then pass it into top-level parse so it ends up being the top level.
staticscope topstaticscope   new localstaticscope null
pushscope new manyvarsdynamicscope topstaticscope  null
for  int i   0  i < framestack length  i
framestack   new frame
@override
protected void finalize   throws throwable
thread dispose
calltype lastcalltype
visibility lastvisibility
irubyobject lastexitstatus
public ruby getruntime
return runtime
public irubyobject geterrorinfo
return errorinfo
public irubyobject seterrorinfo irubyobject errorinfo
this errorinfo   errorinfo
return errorinfo
/**
* returns the lastcallstatus.
* @return lastcallstatus
*/
public void setlastcallstatus calltype calltype
lastcalltype   calltype
public calltype getlastcalltype
return lastcalltype
public void setlastvisibility visibility visibility
lastvisibility   visibility
public visibility getlastvisibility
return lastvisibility
public irubyobject getlastexitstatus
return lastexitstatus
public void setlastexitstatus irubyobject lastexitstatus
this lastexitstatus   lastexitstatus
public void printscope
system out println
for  int i   0  i <  scopeindex  i
system out println scopestack
public dynamicscope getcurrentscope
return scopestack
public dynamicscope getpreviousscope
return scopestack
private void expandframesifnecessary int newmax
if  newmax    framestack length
int newsize   framestack length   2
frame newframestack   new frame
system arraycopy framestack  0  newframestack  0  framestack length
for  int i   framestack length  i < newsize  i
newframestack   new frame
framestack   newframestack
private void expandparentsifnecessary
if  parentindex   1    parentstack length
int newsize   parentstack length   2
rubymodule newparentstack   new rubymodule
system arraycopy parentstack  0  newparentstack  0  parentstack length
parentstack   newparentstack
public void pushscope dynamicscope scope
scopestack   scope
expandscopesifnecessary
public void popscope
scopestack   null
private void expandscopesifnecessary
if  scopeindex   1    scopestack length
int newsize   scopestack length   2
dynamicscope newscopestack   new dynamicscope
system arraycopy scopestack  0  newscopestack  0  scopestack length
scopestack   newscopestack
public rubythread getthread
return thread
public void setthread rubythread thread
this thread   thread
public fiber getfiber
return fiber
public void setfiber fiber fiber
this fiber   fiber
//    public irubyobject getlastline() {
//        irubyobject value = getcurrentscope().getlastline();
//
//        // dynamicscope does not preinitialize these values since they are virtually never used.
//        return value == null ? runtime.getnil() : value;
//    }
//
//    public void setlastline(irubyobject value) {
//        getcurrentscope().setlastline(value);
//    }
//////////////////// catch management ////////////////////////
private void expandcatchifnecessary
if  catchindex   1    catchstack length
int newsize   catchstack length   2
catchtarget newcatchstack   new catchtarget
system arraycopy catchstack  0  newcatchstack  0  catchstack length
catchstack   newcatchstack
public void pushcatch catchtarget catchtarget
catchstack   catchtarget
expandcatchifnecessary
public void popcatch
catchindex
public catchtarget getactivecatches
if  catchindex < 0  return new catchtarget
catchtarget activecatches   new catchtarget
system arraycopy catchstack  0  activecatches  0  catchindex   1
return activecatches
//////////////////// frame management ////////////////////////
private void pushframecopy
frame currentframe   getcurrentframe
framestack updateframe currentframe
expandframesifnecessary frameindex   1
private frame pushframecopy frame frame
framestack updateframe frame
expandframesifnecessary frameindex   1
return framestack
private void pushframe frame frame
framestack   frame
expandframesifnecessary frameindex   1
private void pushcallframe rubymodule clazz  string name
irubyobject self  block block  jumptarget jumptarget
pushframe clazz  name  self  block  jumptarget
private void pushbacktraceframe string name
pushframe name
private void pushframe string name
framestack updateframe name  file  line
expandframesifnecessary frameindex   1
private void pushframe rubymodule clazz  string name
irubyobject self  block block  jumptarget jumptarget
framestack updateframe clazz  self  name  block  file  line  jumptarget
expandframesifnecessary frameindex   1
private void pushframe
framestack updateframe file  line
expandframesifnecessary frameindex   1
private void popframe
frame frame   framestack
frameindex
setfile frame getfile
setline frame getline
private void popframereal
frame frame   framestack
framestack   new frame
frameindex
setfile frame getfile
setline frame getline
public frame getcurrentframe
return framestack
public frame getnextframe
expandframesifnecessary frameindex   1
return framestack
public frame getpreviousframe
int size   frameindex   1
return size <  1 ? null   framestack
public int getframecount
return frameindex   1
public string getframename
return getcurrentframe   getname
public irubyobject getframeself
return getcurrentframe   getself
public jumptarget getframejumptarget
return getcurrentframe   getjumptarget
public void setframejumptarget jumptarget target
getcurrentframe   setjumptarget target
public rubymodule getframeklazz
return getcurrentframe   getklazz
public block getframeblock
return getcurrentframe   getblock
public string getfile
return file
public int getline
return line
public void setfile string file
this file   file
public void setline int line
this line   line
public visibility getcurrentvisibility
return getcurrentframe   getvisibility
public visibility getpreviousvisibility
return getpreviousframe   getvisibility
public void setcurrentvisibility visibility visibility
getcurrentframe   setvisibility visibility
public void pollthreadevents
getthread   pollthreadevents this
public void pushrubyclass rubymodule currentmodule
// fixme: this seems like a good assertion, but it breaks compiled code and the code seems
// to run without it...
//assert currentmodule != null : "can't push null rubyclass";
parentstack   currentmodule
expandparentsifnecessary
public rubymodule poprubyclass
rubymodule ret   parentstack
parentstack   null
return ret
public rubymodule getrubyclass
assert   parentindex     1
rubymodule parentmodule   parentstack
return parentmodule getnonincludedclass
public rubymodule getbindingrubyclass
rubymodule parentmodule   null
if parentindex    0
parentmodule   parentstack
else
parentmodule   parentstack
return parentmodule getnonincludedclass
public boolean getconstantdefined string internedname
irubyobject result
irubyobject undef   runtime getundef
// flipped from while to do to search current class first
for  staticscope scope   getcurrentscope   getstaticscope    scope    null  scope   scope getpreviouscrefscope
rubymodule module   scope getmodule
if   result   module fastfetchconstant internedname      null
if  result    undef  return true
return runtime getloadservice   autoloadfor module getname         internedname     null
return getcurrentscope   getstaticscope   getmodule   fastisconstantdefined internedname
/**
* used by the evaluator and the compiler to look up a constant by name
*/
public irubyobject getconstant string internedname
staticscope scope   getcurrentscope   getstaticscope
rubyclass object   runtime getobject
irubyobject undef   runtime getundef
irubyobject result
// flipped from while to do to search current class first
do
rubymodule klass   scope getmodule
// not sure how this can happen
//if (nil_p(klass)) return rb_const_get(class_of(self), id);
if   result   klass fastfetchconstant internedname      null
if  result    undef
return result
klass deleteconstant internedname
if  runtime getloadservice   autoload klass getname         internedname     null  break
continue
scope   scope getpreviouscrefscope
while  scope    null    scope getmodule      object
return getcurrentscope   getstaticscope   getmodule   fastgetconstant internedname
/**
* used by the evaluator and the compiler to set a constant by name
* this is for a null const decl
*/
public irubyobject setconstantincurrent string internedname  irubyobject result
rubymodule module
if   module   getcurrentscope   getstaticscope   getmodule       null
module fastsetconstant internedname  result
return result
// todo: wire into new exception handling mechanism
throw runtime newtypeerror
/**
* used by the evaluator and the compiler to set a constant by name.
* this is for a colon2 const decl
*/
public irubyobject setconstantinmodule string internedname  irubyobject target  irubyobject result
if    target instanceof rubymodule
throw runtime newtypeerror target tostring
rubymodule module    rubymodule target
module fastsetconstant internedname  result
return result
/**
* used by the evaluator and the compiler to set a constant by name
* this is for a colon2 const decl
*/
public irubyobject setconstantinobject string internedname  irubyobject result
runtime getobject   fastsetconstant internedname  result
return result
private static void addbacktraceelement rubyarray backtrace  frame frame  frame previousframe
if  frame    previousframe       happens with native exceptions  should not filter those out
frame getname      null
frame getname   equals previousframe getname
frame getfile   equals previousframe getfile
frame getline      previousframe getline
return
stringbuffer buf   new stringbuffer 60
buf append frame getfile    append    append frame getline     1
if  previousframe getname      null
buf append    append previousframe getname    append
backtrace append backtrace getruntime   newstring buf tostring
/**
* create an array with backtrace information.
* @param runtime
* @param level
* @param nativeexception
* @return an array with the backtrace
*/
public static irubyobject createbacktracefromframes ruby runtime  frame backtraceframes
rubyarray backtrace   runtime newarray
if  backtraceframes    null    backtraceframes length <  0  return backtrace
int tracesize   backtraceframes length
for  int i   tracesize   1  i > 0  i
frame frame   backtraceframes
// we are in eval with binding break out early
if  frame isbindingframe    break
addbacktraceelement backtrace  frame  backtraceframes
return backtrace
/**
* create an array with backtrace information.
* @param runtime
* @param level
* @param nativeexception
* @return an array with the backtrace
*/
public frame createbacktrace int level  boolean nativeexception
int tracesize   frameindex   level   1
frame traceframes
if  tracesize <  0  return null
if  nativeexception
// assert level == 0;
traceframes   new frame
traceframes   framestack
else
traceframes   new frame
system arraycopy framestack  0  traceframes  0  tracesize
return traceframes
public void preadoptthread
pushframe
pushrubyclass runtime getobject
getcurrentframe   setself runtime gettopself
public void precompiledclass rubymodule type  string scopenames
pushrubyclass type
pushframecopy
getcurrentframe   setself type
getcurrentframe   setvisibility visibility public
staticscope staticscope   new localstaticscope getcurrentscope   getstaticscope    scopenames
staticscope setmodule type
pushscope new manyvarsdynamicscope staticscope  null
public void postcompiledclass
popscope
poprubyclass
popframe
public void prescopenode staticscope staticscope
pushscope dynamicscope newdynamicscope staticscope  getcurrentscope
public void postscopenode
popscope
public void preclasseval staticscope staticscope  rubymodule type
pushrubyclass type
pushframecopy
getcurrentframe   setself type
getcurrentframe   setvisibility visibility public
pushscope dynamicscope newdynamicscope staticscope  null
public void postclasseval
popscope
poprubyclass
popframe
public void prebsfapply string names
// fixme: i think we need these pushed somewhere?
localstaticscope staticscope   new localstaticscope null
staticscope setvariables names
pushframe
public void postbsfapply
popframe
public void premethodframeandscope rubymodule clazz  string name  irubyobject self  irubyobject args  int req  block block
staticscope staticscope  jumptarget jumptarget
rubymodule implementationclass   staticscope getmodule
// fixme: this is currently only here because of some problems with iooutputstream writing to a "bare" runtime without a proper scope
if  implementationclass    null
implementationclass   clazz
pushcallframe clazz  name  self  block  jumptarget
pushscope dynamicscope newdynamicscope staticscope
pushrubyclass implementationclass
public void postmethodframeandscope
poprubyclass
popscope
popframe
public void premethodframeonly rubymodule clazz  string name  irubyobject self  irubyobject args  int req  block block
jumptarget jumptarget
pushrubyclass clazz
pushcallframe clazz  name  self  block  jumptarget
getcurrentframe   setvisibility getpreviousframe   getvisibility
public void postmethodframeonly
popframe
poprubyclass
public void premethodscopeonly rubymodule clazz  staticscope staticscope
rubymodule implementationclass   staticscope getmodule
// fixme: this is currently only here because of some problems with iooutputstream writing to a "bare" runtime without a proper scope
if  implementationclass    null
implementationclass   clazz
pushscope dynamicscope newdynamicscope staticscope
pushrubyclass implementationclass
public void postmethodscopeonly
poprubyclass
popscope
public void premethodbacktraceandscope string name  rubymodule clazz  staticscope staticscope
premethodscopeonly clazz  staticscope
pushbacktraceframe name
public void postmethodbacktraceandscope
postmethodscopeonly
popframe
public void premethodbacktraceonly string name
pushbacktraceframe name
public void postmethodbacktraceonly
popframe
public void preparetoplevel rubyclass objectclass  irubyobject topself
pushframe
setcurrentvisibility visibility private
pushrubyclass objectclass
frame frame   getcurrentframe
frame setself topself
getcurrentscope   getstaticscope   setmodule objectclass
public void prenodeeval rubymodule rubyclass  irubyobject self
pushrubyclass rubyclass
pushcallframe null  null  self  block null_block  null
// set visibility to private, since toplevel of scripts always started out private
setcurrentvisibility visibility private
public void postnodeeval
popframe
poprubyclass
// xxx: again, screwy evaling under previous frame's scope
public void preexecuteunder rubymodule executeunderclass  block block
frame frame   getcurrentframe
pushrubyclass executeunderclass
dynamicscope scope   getcurrentscope
staticscope sscope   new blockstaticscope scope getstaticscope
sscope setmodule executeunderclass
pushscope dynamicscope newdynamicscope sscope  scope
pushcallframe frame getklazz    frame getname    frame getself    block  frame getjumptarget
getcurrentframe   setvisibility getpreviousframe   getvisibility
public void postexecuteunder
popframe
popscope
poprubyclass
public void premproc
pushframe
public void postmproc
popframe
public void prerunthread frame currentframe
pushframe currentframe
public void pretrace
setwithintrace true
pushframe
public void posttrace
popframe
setwithintrace false
public void preforblock binding binding  rubymodule klass
frame f   binding getframe
f setfile file
f setline line
pushframe f
getcurrentframe   setvisibility binding getvisibility
pushscope binding getdynamicscope
pushrubyclass  klass    null  ? klass   binding getklass
public void preyieldspecificblock binding binding  staticscope scope  rubymodule klass
frame f   pushframecopy binding getframe
f setfile file
f setline line
f setvisibility binding getvisibility
// new scope for this invocation of the block, based on parent scope
pushscope dynamicscope newdynamicscope scope  binding getdynamicscope
pushrubyclass  klass    null  ? klass   binding getklass
public void preyieldlightblock binding binding  dynamicscope emptyscope  rubymodule klass
frame f   pushframecopy binding getframe
f setfile file
f setline line
f setvisibility binding getvisibility
// just push the same empty scope, since we won't use one
pushscope emptyscope
pushrubyclass  klass    null  ? klass   binding getklass
public void preyieldnoscope binding binding  rubymodule klass
frame f   pushframecopy binding getframe
f setfile file
f setline line
f setvisibility binding getvisibility
pushrubyclass  klass    null  ? klass   binding getklass
public void preevalwithbinding binding binding
frame frame   binding getframe
frame setisbindingframe true
pushframe frame
getcurrentframe   setvisibility binding getvisibility
pushrubyclass binding getklass
public void postevalwithbinding binding binding
binding getframe   setisbindingframe false
popframereal
poprubyclass
public void postyield binding binding
popscope
popframereal
poprubyclass
public void postyieldlight binding binding
popscope
popframereal
poprubyclass
public void postyieldnoscope
popframereal
poprubyclass
public void prescopedbody dynamicscope scope
pushscope scope
public void postscopedbody
popscope
/**
* is this thread actively tracing at this moment.
*
* @return true if so
* @see org.jruby.ruby#calltracefunction(string, isourceposition, irubyobject, string, irubyobject)
*/
public boolean iswithintrace
return iswithintrace
/**
* set whether we are actively tracing or not on this thread.
*
* @param iswithintrace true is so
* @see org.jruby.ruby#calltracefunction(string, isourceposition, irubyobject, string, irubyobject)
*/
public void setwithintrace boolean iswithintrace
this iswithintrace   iswithintrace
/**
* is this thread actively in defined? at the moment.
*
* @return true if within defined?
*/
public boolean iswithindefined
return iswithindefined
/**
* set whether we are actively within defined? or not.
*
* @param iswithindefined true if so
*/
public void setwithindefined boolean iswithindefined
this iswithindefined   iswithindefined