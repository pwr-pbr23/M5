/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby compiler
import org jruby ast nodetype
import org jruby lexer yacc isourceposition
import org jruby parser staticscope
import org jruby util bytelist
/**
*
* @author headius
*/
public interface methodcompiler
/**
* end compilation for the method associated with the specified token. this should
* close out all structures created for compilation of the method.
*
* @param token a token identifying the method to be terminated.
*/
public void endmethod
/**
* as code executes, values are assumed to be "generated", often by being pushed
* on to some execution stack. generally, these values are consumed by other
* methods on the context, but occasionally a value must be "thrown out". this method
* provides a way to discard the previous value generated by some other call(s).
*/
public void consumecurrentvalue
/**
* push a copy the topmost value on the stack.
*/
public void duplicatecurrentvalue
/**
* swap the top and second values on the stack.
*/
public void swapvalues
/**
* this method provides a way to specify a line number for the current piece of code
* being compiled. the compiler may use this information to create debugging
* information in a bytecode-format-dependent way.
*
* @param position the isourceposition information to use.
*/
public void linenumber isourceposition position
public variablecompiler getvariablecompiler
public invocationcompiler getinvocationcompiler
/**
* retrieve the current "self" and put a reference on top of the stack.
*/
public void retrieveself
/**
* retrieve the current "self" object's metaclass and put a reference on top of the stack
*/
public void retrieveselfclass
public void retrieveclassvariable string name
public void assignclassvariable string name
public void declareclassvariable string name
/**
* generate a new "fixnum" value.
*/
public void createnewfixnum long value
/**
* generate a new "float" value.
*/
public void createnewfloat double value
/**
* generate a new "bignum" value.
*/
public void createnewbignum java math biginteger value
/**
* generate a new "string" value.
*/
public void createnewstring bytelist value
/**
* generate a new dynamic "string" value.
*/
public void createnewstring arraycallback callback  int count
public void createnewsymbol arraycallback callback  int count
/**
* generate a new "symbol" value (or fetch the existing one).
*/
public void createnewsymbol string name
public void createobjectarray object elementarray  arraycallback callback
/**
* combine the top <pre>elementcount</pre> elements into a single element, generally
* an array or similar construct. the specified number of elements are consumed and
* an aggregate element remains.
*
* @param elementcount the number of elements to consume
*/
public void createobjectarray int elementcount
/**
* given an aggregated set of objects (likely created through a call to createobjectarray)
* create a ruby array object.
*/
public void createnewarray boolean lightweight
/**
* create an empty ruby array
*/
public void createemptyarray
/**
* create an empty ruby hash object and put a reference on top of the stack.
*/
public void createemptyhash
/**
* create a new hash by calling back to the specified arraycallback. it is expected that the keycount
* will be the actual count of key/value pairs, and the caller will handle passing an appropriate elements
* collection in and dealing with the sequential indices passed to the callback.
*
* @param elements an object holding the elements from which to create the hash.
* @param callback an arraycallback implementation to which the elements array and iteration counts
* are passed in sequence.
* @param keycount the total count of key-value pairs to be constructed from the elements collection.
*/
public void createnewhash object elements  arraycallback callback  int keycount
/**
* create a new range. it is expected that the stack will contain the end and begin values for the range as
* its topmost and second topmost elements.
*
* @param isexclusive whether the range is exclusive or not (inclusive)
*/
public void createnewrange boolean isexclusive
/**
* perform a boolean branch operation based on the ruby "true" value of the top value
* on the stack. if ruby "true", invoke the true branch callback. otherwise, invoke the false branch callback.
*
* @param truebranch the callback for generating code for the "true" condition
* @param falsebranch the callback for generating code for the "false" condition
*/
public void performbooleanbranch branchcallback truebranch  branchcallback falsebranch
/**
* perform a logical short-circuited ruby "and" operation, using ruby notions of true and false.
* if the value on top of the stack is false, it remains and the branch is not executed. if it is true,
* the top of the stack is replaced with the result of the branch.
*
* @param longbranch the branch to execute if the "and" operation does not short-circuit.
*/
public void performlogicaland branchcallback longbranch
/**
* perform a logical short-circuited ruby "or" operation, using ruby notions of true and false.
* if the value on top of the stack is true, it remains and the branch is not executed. if it is false,
* the top of the stack is replaced with the result of the branch.
*
* @param longbranch the branch to execute if the "or" operation does not short-circuit.
*/
public void performlogicalor branchcallback longbranch
/**
* perform a boolean loop using the given condition-calculating branch and body branch. for
* while loops, pass true for checkfirst. for statement-modifier while loops, pass false. for
* unless loops, reverse the result of the condition after calculating it.
*
* @param condition the code to execute for calculating the loop condition. a ruby true result will
* cause the body to be executed again.
* @param body the body to executed for the loop.
* @param checkfirst whether to check the condition the first time through or not.
*/
public void performbooleanloop branchcallback condition  branchcallback body  boolean checkfirst
/**
* return the current value on the top of the stack, taking into consideration surrounding blocks.
*/
public void performreturn
/**
* create a new closure (block) using the given lexical scope information, call arity, and
* body generated by the body callback. the closure will capture containing scopes and related information.
*
* @param scope the static scoping information
* @param arity the arity of the block's argument list
* @param body the callback which will generate the closure's body
*/
public void createnewclosure int line  staticscope scope  int arity  compilercallback body  compilercallback args  boolean hasmultipleargshead  nodetype argsnodeid  astinspector inspector
/**
* create a new closure (block) for a for loop with the given call arity and
* body generated by the body callback.
*
* @param scope the static scoping information
* @param arity the arity of the block's argument list
* @param body the callback which will generate the closure's body
*/
public void createnewforloop int arity  compilercallback body  compilercallback args  boolean hasmultipleargshead  nodetype argsnodeid
/**
* define a new method with the given name, arity, local variable count, and body callback.
* this will create a new compiled method and bind it to the given name at this point in
* the program's execution.
*
* @param name the name to which to bind the resulting method.
* @param arity the arity of the method's argument list
* @param localvarcount the number of local variables within the method
* @param body the callback which will generate the method's body.
*/
public void definenewmethod string name  int methodarity  staticscope scope
compilercallback body  compilercallback args
compilercallback receiver  astinspector inspector  boolean root
/**
* define an alias for a new name to an existing oldname'd method.
*
* @param newname the new alias to create
* @param oldname the name of the existing method or alias
*/
public void definealias string newname  string oldname
public void assignconstantincurrent string name
public void assignconstantinmodule string name
public void assignconstantinobject string name
/**
* retrieve the constant with the specified name available at the current point in the
* program's execution.
*
* @param name the name of the constant
*/
public void retrieveconstant string name
/**
* retreive a named constant from the rubymodule/rubyclass that's just been pushed.
*
* @param name the name of the constant
*/
public void retrieveconstantfrommodule string name
/**
* load a ruby "false" value on top of the stack.
*/
public void loadfalse
/**
* load a ruby "true" value on top of the stack.
*/
public void loadtrue
/**
* load a ruby "nil" value on top of the stack.
*/
public void loadnil
public void loadnull
/**
* load the given string as a symbol on to the top of the stack.
*
* @param symbol the symbol to load.
*/
public void loadsymbol string symbol
/**
* load the object class
*/
public void loadobject
/**
* retrieve the instance variable with the given name, based on the current "self".
*
* @param name the name of the instance variable to retrieve.
*/
public void retrieveinstancevariable string name
/**
* assign the value on top of the stack to the instance variable with the specified name
* on the current "self". the value is consumed.
*
* @param name the name of the value to assign.
*/
public void assigninstancevariable string name
/**
* assign the top of the stack to the global variable with the specified name.
*
* @param name the name of the global variable.
*/
public void assignglobalvariable string name
/**
* retrieve the global variable with the specified name to the top of the stack.
*
* @param name the name of the global variable.
*/
public void retrieveglobalvariable string name
/**
* perform a logical ruby "not" operation on the value on top of the stack, leaving the
* negated result.
*/
public void negatecurrentvalue
/**
* convert the current value into a "splatted value" suitable for passing as
* method arguments or disassembling into multiple variables.
*/
public void splatcurrentvalue
/**
* given a splatted value, extract a single value. if no splat or length is
* zero, use nil
*/
public void singlifysplattedvalue
/**
* given an irubyobject[] on the stack (or otherwise available as the present object)
* call back to the provided arraycallback 'callback' for 'count' elements, starting with 'start'.
* each call to callback will have a value from the input array on the stack; once the items are exhausted,
* the code in nilcallback will be invoked *with no value on the stack*.
*/
public void foreachinvaluearray int count  int start  object source  arraycallback callback  arraycallback nilcallback  compilercallback argscallback
/**
* ensures that the present value is an irubyobject[] by wrapping it with one if it is not.
*/
public void ensurerubyarray
/**
* ensures that the present value is an irubyobject[] by wrapping it with one or coercing it if it is not.
*/
public void ensuremultipleassignablerubyarray boolean masgnhashead
public void issuebreakevent compilercallback value
public void issuenextevent compilercallback value
public void issueredoevent
public void issueretryevent
public void asstring
public void nthref int match
public void match
public void match2
public void match3
public void createnewregexp bytelist value  int options
public void createnewregexp compilercallback createstringcallback  int options
public void pollthreadevents
public void branchifmodule compilercallback receivercallback  branchcallback modulecallback  branchcallback notmodulecallback
/**
* push the current back reference
*/
public void backref
/**
* call a static helper method on rubyregexp with the current backref
*/
public void backrefmethod string methodname
public void nulltonil
/**
* makes sure that the code in protectedcode will always run after regularcode.
*/
public void protect branchcallback regularcode  branchcallback protectedcode  class ret
public void rescue branchcallback regularcode  class exception  branchcallback protectedcode  class ret
public void indefined
public void outdefined
public void stringornil
public void pushnull
public void pushstring string strval
public void ismethodbound string name  branchcallback truebranch  branchcallback falsebranch
public void hasblock branchcallback truebranch  branchcallback falsebranch
public void isglobaldefined string name  branchcallback truebranch  branchcallback falsebranch
public void isconstantdefined string name  branchcallback truebranch  branchcallback falsebranch
public void isinstancevariabledefined string name  branchcallback truebranch  branchcallback falsebranch
public void isclassvardefined string name  branchcallback truebranch  branchcallback falsebranch
public object getnewending
public void ifnull object gototoken
public void isnil branchcallback truebranch  branchcallback falsebranch
public void isnull branchcallback truebranch  branchcallback falsebranch
public void ifnotnull object gototoken
public void setending object endingtoken
public void go object gototoken
public void isconstantbranch branchcallback setup  branchcallback isconstant  branchcallback ismethod  branchcallback none  string name
public void metaclass
public void getvisibilityfor string name
public void isprivate object gototoken  int toconsume
public void isnotprotected object gototoken  int toconsume
public void selfiskindof object gototoken
public void loadcurrentmodule
public void notismoduleandclassvardefined string name  object gototoken
public void loadself
public void ifsingleton object gototoken
public void getinstancevariable string name
public void getframename
public void getframeklazz
public void superclass
public void attached
public void ifnotsupermethodbound object token
public void isinstanceof class clazz  branchcallback truebranch  branchcallback falsebranch
public void iscaptured int number  branchcallback truebranch  branchcallback falsebranch
public void concatarrays
public void appendtoarray
public void converttojavaarray
public void arytoary
public void tojavastring
public void aliasglobal string newname  string oldname
public void undefmethod string name
public void defineclass string name  staticscope staticscope  compilercallback supercallback  compilercallback pathcallback  compilercallback bodycallback  compilercallback receivercallback
public void definemodule string name  staticscope staticscope  compilercallback pathcallback  compilercallback bodycallback
public void unwrappassedblock
public void performbackref char type
public void callzsuper compilercallback closure
public void appendtoobjectarray
public void checkisexceptionhandled
public void rethrowexception
public void loadclass string name
public void unwrapraiseexception
public void loadexception
public void setfileposition isourceposition position
public void setlineposition isourceposition position
public void checkwhenwithsplat
public void createnewendblock compilercallback body
public void runbeginblock staticscope scope  compilercallback body
public void rethrowifsystemexit
public methodcompiler chaintomethod string name  astinspector inspector