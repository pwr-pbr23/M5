package org jruby javasupport util
import java lang ref referencequeue
import java lang ref softreference
import java lang ref weakreference
import java util concurrent locks reentrantlock
/**
* maps java objects to their proxies.  combines elements of weakhashmap and
* concurrenthashmap to permit unsynchronized reads.  may be configured to
* use either weak (the default) or soft references.<p>
*
* note that both java objects and their proxies are held by weak/soft
* references; because proxies (currently) keep strong references to their
* java objects, if we kept strong references to them the java objects would
* never be gc'ed.  this presents a problem in the case where a user passes
* a rubified java object out to java but keeps no reference in ruby to the
* proxy; if the object is returned to ruby after its proxy has been gc'ed,
* a new (and possibly very wrong, in the case of jruby-defined subclasses)
* proxy will be created.  use of soft references may help reduce the
* likelihood of this occurring; users may be advised to keep ruby-side
* references to prevent it occurring altogether.
*
* @author <a href="mailto:bill.dortch@gmail.com">bill dortch</a>
*
*/
public abstract class objectproxycache<t a>
public static enum referencetype   weak  soft
private static final int default_segments   16     must be power of 2
private static final int default_segment_size   8     must be power of 2
private static final float default_load_factor   0 75f
private static final int max_capacity   1 << 30
private static final int max_segments   1 << 16
private static final int vulture_run_freq_seconds   5
private static int _nextid   0
private static synchronized int nextid
return   _nextid
private final referencetype referencetype
private final segment<t a> segments
private final int segmentshift
private final int segmentmask
private final thread vulture
private final int id
public objectproxycache
this default_segments  default_segment_size  referencetype weak
public objectproxycache referencetype reftype
this default_segments  default_segment_size  reftype
public objectproxycache int numsegments  int initialsegcapacity  referencetype reftype
if  numsegments <  0    initialsegcapacity <  0    reftype    null
throw new illegalargumentexception
this id   nextid
this referencetype   reftype
if  numsegments > max_segments  numsegments   max_segments
// find power-of-two sizes best matching arguments
int sshift   0
int ssize   1
while  ssize < numsegments
sshift
ssize <<  1
// note segmentshift differs from concurrenthashmap's calculation due to
// issues with system.identityhashcode (upper n bits always 0, at least
// under java 1.6 / winxp)
this segmentshift   24   sshift
this segmentmask   ssize   1
this segments   segment newarray ssize
if  initialsegcapacity > max_capacity
initialsegcapacity   max_capacity
int cap   1
while  cap < initialsegcapacity  cap <<  1
for  int i   ssize    i >  0
segments   new segment<t a> cap  this
// vulture thread will periodically expunge dead
// entries.  entries are also expunged during 'put'
// operations; this is designed to cover the case where
// many objects are created initially, followed by limited
// put activity.
//
// fixme: disabled (below) pending resolution of finalization issue
//
this vulture   new thread   id
public void run
for
try
sleep vulture_run_freq_seconds   1000
catch  interruptedexception e
boolean dump   size   > 200
if  dump
system err println   id
system err println stats
for  int i   segments length    i >  0
segment<t a> seg   segments
seg lock
try
seg expunge
finally
seg unlock
yield
if  dump
system err println   id
system err println stats
try
vulture setdaemon true
catch  securityexception e
// fixme: vulture daemon thread prevents finalization,
// find alternative approach.
// vulture.start();
//      system.err.println("***objectproxycache " + id + " started at "+ new java.util.date());
//    protected void finalize() throws throwable {
//        system.err.println("***objectproxycache " + id + " finalized at "+ new java.util.date());
//    }
public abstract t allocateproxy object javaobject  a allocator
public t get object javaobject
if  javaobject    null  return null
int hash   hash javaobject
return segmentfor hash  get javaobject  hash
public t getorcreate object javaobject  a allocator
if  javaobject    null    allocator    null  return null
int hash   hash javaobject
return segmentfor hash  getorcreate javaobject  hash  allocator
public void put object javaobject  t proxy
if  javaobject    null    proxy    null  return
int hash   hash javaobject
segmentfor hash  put javaobject  hash  proxy
private static int hash object javaobject
int h   system identityhashcode javaobject
h ^   h >>> 20  ^  h >>> 12
return h ^  h >>> 7  ^  h >>> 4
private segment<t a> segmentfor int hash
return segments
/**
* returns the approximate size (elements in use) of the cache. the
* sizes of the segments are summed. no effort is made to synchronize
* across segments, so the value returned may differ from the actual
* size at any point in time.
*
* @return
*/
public int size
int size   0
for  segment<t a> seg   segments
size    seg tablesize
return size
public string stats
stringbuilder b   new stringbuilder
int n   0
int size   0
int alloc   0
b append    append segments length  append
for  segment<t a> seg   segments
int ssize   0
int salloc   0
seg lock
try
ssize   seg count
salloc   seg entrytable length
finally
seg unlock
size    ssize
alloc    salloc
b append    append n    append    append ssize
append    append salloc  append
b append    append size
append    append alloc  append
return b tostring
// entryrefs include hash with key to facilitate lookup by segment#expunge
// after ref is removed from referencequeue
private static interface entryref<t>
t get
int hash
private static final class weakentryref<t> extends weakreference<t> implements entryref<t>
final int hash
weakentryref int hash  t rawobject  referencequeue<object> queue
super rawobject  queue
this hash   hash
public int hash
return hash
private static final class softentryref<t> extends softreference<t> implements entryref<t>
final int hash
softentryref int hash  t rawobject  referencequeue<object> queue
super rawobject  queue
this hash   hash
public int hash
return hash
// unlike weakhashmap, our entry does not subclass weakreference, but rather
// makes it a final field.  the theory is that doing so should force a happens-before
// relationship wrt the weakreference constructor, guaranteeing that the key will be
// visibile to other threads (unless it's been gc'ed).  see jls 17.5 (final fields) and
// 17.4.5 (happens-before order) to confirm or refute my reasoning here.
static class entry<t>
final entryref<object> objectref
final int hash
final entryref<t> proxyref
final entry<t> next
entry object object  int hash  t proxy  referencetype type  entry<t> next  referencequeue<object> queue
this hash   hash
this next   next
// references to the java object and its proxy will either both be
// weak or both be soft, since the proxy contains a strong reference
// to the object, so it wouldn't make sense for the reference types
// to differ.
if  type    referencetype weak
this objectref   new weakentryref<object> hash  object  queue
this proxyref   new weakentryref<t> hash  proxy  queue
else
this objectref   new softentryref<object> hash  object  queue
this proxyref   new softentryref<t> hash  proxy  queue
// ctor used by remove/rehash
entry entryref<object> objectref  int hash  entryref<t> proxyref  entry<t> next
this objectref   objectref
this hash   hash
this proxyref   proxyref
this next   next
@suppresswarnings
static final <t> entry<t> newarray int size
return new entry
// lame generics issues: making segment class static and manually
// inserting cache reference to work around various problems generically
// referencing methods/vars across classes.
static class segment<t a> extends reentrantlock
final objectproxycache<t a> cache
final referencequeue<object> referencequeue   new referencequeue<object>
volatile entry<t> entrytable
int tablesize
int threshold
segment int capacity  objectproxycache<t a> cache
threshold    int  capacity   default_load_factor
entrytable   entry newarray capacity
this cache   cache
// must be called under lock
private void expunge
entry<t> table   entrytable
referencequeue<object> queue   referencequeue
entryref ref
// note that we'll potentially see the refs for both the java object and
// proxy -- whichever we see first will cause the entry to be removed;
// the other will not match an entry and will be ignored.
while   ref    entryref queue poll       null
int hash
for  entry<t> e   table  e    null  e   e next
if  hash    e hash     ref    e objectref    ref    e proxyref
remove table  hash  e
break
// must be called under lock
private void remove entry<t> table  int hash  entry<t> e
int index   hash    table length   1
entry<t> first   table
for  entry<t> n   first  n    null  n   n next
if  n    e
entry<t> newfirst   n next
for  entry<t> p   first  p    n  p   p next
newfirst   new entry<t> p objectref  p hash  p proxyref  newfirst
table   newfirst
tablesize
entrytable   table     write volatile
return
// temp method to verify tablesize value
// must be called under lock
private int count
int count   0
for  entry<t> e   entrytable
while  e    null
count
e   e next
return count
// must be called under lock
private entry<t> rehash
assert tablesize    count       tablesize   count
entry<t> oldtable   entrytable     read volatile
int oldcapacity
if   oldcapacity   oldtable length  >  max_capacity
return oldtable
int newcapacity   oldcapacity << 1
int sizemask   newcapacity   1
threshold    int  newcapacity   default_load_factor
entry<t> newtable   entry newarray newcapacity
entry<t> e
for  int i   oldcapacity    i >  0
if   e   oldtable     null
int idx   e hash   sizemask
entry<t> next
if   next   e next     null
// single node in list
newtable   e
else
// reuse trailing consecutive sequence at same slot
int lastidx   idx
entry<t> lastrun   e
for  entry<t> last   next  last    null  last   last next
int k
if   k   last hash   sizemask     lastidx
lastidx   k
lastrun   last
newtable   lastrun
// clone all remaining nodes
for  entry<t> p   e  p    lastrun  p   p next
int k   p hash   sizemask
entry<t> m   new entry<t> p objectref  p hash  p proxyref  newtable
newtable   m
entrytable   newtable     write volatile
return newtable
void put object object  int hash  t proxy
lock
try
expunge
entry<t> table
int potentialnewsize
if   potentialnewsize   tablesize   1  > threshold
table   rehash       indirect read  write  volatile
else
table   entrytable     read volatile
int index
entry<t> e
for  e   table  e    null  e   e next
if  hash    e hash    object    e objectref get
if  proxy    e proxyref get    return
// entry exists, proxy doesn't match. replace.
// this could happen if old proxy was gc'ed
// todo: raise exception if stored proxy is non-null? (not gc'ed)
remove table  hash  e
potentialnewsize
break
e   new entry<t> object  hash  proxy  cache referencetype  table  referencequeue
table   e
tablesize   potentialnewsize
entrytable   table     write volatile
finally
unlock
t getorcreate object object  int hash  a allocator
entry<t> table
t proxy
for  entry<t> e    table   entrytable   e    null  e   e next
if  hash    e hash    object    e objectref get
if   proxy   e proxyref get       null  return proxy
break
lock
try
expunge
int potentialnewsize
if   potentialnewsize   tablesize   1  > threshold
table   rehash       indirect read  write  volatile
else
table   entrytable     read volatile
int index
entry<t> e
for  e   table  e    null  e   e next
if  hash    e hash    object    e objectref get
if   proxy   e proxyref get       null  return proxy
// entry exists, proxy has been gc'ed. replace entry.
remove table  hash  e
potentialnewsize
break
proxy   cache allocateproxy object  allocator
e   new entry<t> object  hash  proxy  cache referencetype  table  referencequeue
table   e
tablesize   potentialnewsize
entrytable   table     write volatile
return proxy
finally
unlock
t get object object  int hash
entry<t> table
for  entry<t> e    table   entrytable   e    null  e   e next
if  hash    e hash    object    e objectref get
return e proxyref get
return null
@suppresswarnings
static final <t a> segment<t a> newarray int size
return new segment