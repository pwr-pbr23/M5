/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel util
import java io file
import java io fileinputstream
import java io ioexception
import java lang annotation annotation
import java lang reflect method
import java net url
import java net urldecoder
import java util arrays
import java util enumeration
import java util hashset
import java util set
import java util jar jarentry
import java util jar jarinputstream
import org apache commons logging log
import org apache commons logging logfactory
/**
* <p>
* resolverutil is used to locate classes that are available in the/a class path
* and meet arbitrary conditions. the two most common conditions are that a
* class implements/extends another class, or that is it annotated with a
* specific annotation. however, through the use of the {@link test} class it is
* possible to search using arbitrary conditions.
* </p>
* <p/>
* <p>
* a classloader is used to locate all locations (directories and jar files) in
* the class path that contain classes within certain packages, and then to load
* those classes and check them. by default the classloader returned by
* {@code thread.currentthread().getcontextclassloader()} is used, but this can
* be overridden by calling {@link #setclassloaders(set)} prior to
* invoking any of the {@code find()} methods.
* </p>
* <p/>
* <p>
* general searches are initiated by calling the
* {@link #find(resolverutil.test, string)} ()} method and supplying a package
* name and a test instance. this will cause the named package <b>and all
* sub-packages</b> to be scanned for classes that meet the test. there are
* also utility methods for the common use cases of scanning multiple packages
* for extensions of particular classes, or classes annotated with a specific
* annotation.
* </p>
* <p/>
* <p>
* the standard usage pattern for the resolverutil class is as follows:
* </p>
* <p/>
* <pre>
* esolverutil&lt;actionbean&gt; resolver = new resolverutil&lt;actionbean&gt;();
* esolver.findimplementation(actionbean.class, pkg1, pkg2);
* esolver.find(new customtest(), pkg1);
* esolver.find(new customtest(), pkg2);
* ollection&lt;actionbean&gt; beans = resolver.getclasses();
* </pre>
*
* @author tim fennell
*/
public class resolverutil<t>
protected static final transient log log   logfactory getlog resolverutil class
/**
* a simple interface that specifies how to test classes to determine if
* they are to be included in the results produced by the resolverutil.
*/
public static interface test
/**
* will be called repeatedly with candidate classes. must return true if
* a class is to be included in the results, false otherwise.
*/
boolean matches class type
/**
* a test that checks to see if each class is assignable to the provided
* class. note that this test will match the parent type itself if it is
* presented for matching.
*/
public static class isa implements test
private class parent
/**
* constructs an isa test using the supplied class as the parent
* class/interface.
*/
public isa class parenttype
this parent   parenttype
/**
* returns true if type is assignable to the parent type supplied in the
* constructor.
*/
public boolean matches class type
return type    null    parent isassignablefrom type
@override
public string tostring
return     parent getsimplename
/**
* a test that checks to see if each class is annotated with a specific
* annotation. if it is, then the test returns true, otherwise false.
*/
public static class annotatedwith implements test
private class<? extends annotation> annotation
/**
* constructs an annotatedwith test for the specified annotation type.
*/
public annotatedwith class<? extends annotation> annotation
this annotation   annotation
/**
* returns true if the type is annotated with the class provided to the
* constructor.
*/
public boolean matches class type
return type    null    type isannotationpresent annotation
@override
public string tostring
return     annotation getsimplename
/**
* the set of matches being accumulated.
*/
private set<class<? extends t>> matches   new hashset<class<? extends t>>
/**
* the classloader to use when looking for classes. if null then the
* classloader returned by thread.currentthread().getcontextclassloader()
* will be used.
*/
private set<classloader> classloaders
/**
* provides access to the classes discovered so far. if no calls have been
* made to any of the {@code find()} methods, this set will be empty.
*
* @return the set of classes that have been discovered.
*/
public set<class<? extends t>> getclasses
return matches
/**
* returns the classloaders that will be used for scanning for classes. if no
* explicit classloader has been set by the calling, the context class
* loader will and the one that has loaded this class resolverutil be used.
*
* @return the classloader instances that will be used to scan for classes
*/
public set<classloader> getclassloaders
if  classloaders    null
classloaders   new hashset<classloader>
classloaders add thread currentthread   getcontextclassloader
classloaders add resolverutil class getclassloader
return classloaders
/**
* sets the classloader instances that should be used when scanning for
* classes. if none is set then the context classloader will be used.
*
* @param classloaders a classloader to use when scanning for classes
*/
public void setclassloaders set<classloader> classloaders
this classloaders   classloaders
/**
* attempts to discover classes that are assignable to the type provided. in
* the case that an interface is provided this method will collect
* implementations. in the case of a non-interface class, subclasses will be
* collected. accumulated classes can be accessed by calling
* {@link #getclasses()}.
*
* @param parent       the class of interface to find subclasses or
*                     implementations of
* @param packagenames one or more package names to scan (including
*                     subpackages) for classes
*/
public void findimplementations class parent  string    packagenames
if  packagenames    null
return
if  log isdebugenabled
log debug     parent getname         arrays
aslist packagenames
test test   new isa parent
for  string pkg   packagenames
find test  pkg
if  log isdebugenabled
log debug     getclasses
/**
* attempts to discover classes that are annotated with to the annotation.
* accumulated classes can be accessed by calling {@link #getclasses()}.
*
* @param annotation   the annotation that should be present on matching
*                     classes
* @param packagenames one or more package names to scan (including
*                     subpackages) for classes
*/
public void findannotated class<? extends annotation> annotation  string    packagenames
if  packagenames    null
return
if  log isdebugenabled
log debug     annotation getname         arrays
aslist packagenames
test test   new annotatedwith annotation
for  string pkg   packagenames
find test  pkg
if  log isdebugenabled
log debug     getclasses
/**
* scans for classes starting at the package provided and descending into
* subpackages. each class is offered up to the test as it is discovered,
* and if the test returns true the class is retained. accumulated classes
* can be fetched by calling {@link #getclasses()}.
*
* @param test        an instance of {@link test} that will be used to filter
*                    classes
* @param packagename the name of the package from which to start scanning
*                    for classes, e.g. {@code net.sourceforge.stripes}
*/
public void find test test  string packagename
packagename   packagename replace
set<classloader> set   getclassloaders
for  classloader classloader   set
find test  packagename  classloader
protected void find test test  string packagename  classloader loader
if  log istraceenabled
log trace     test       packagename
loader getclass   getname
if  loader getclass   getname   endswith
log trace
//this classloader is in osgi env which is not urlclassloader, we should resort to the
//bundledelegatingclassloader in osgi, so just return
return
try
method mth   loader getclass   getmethod    new class
if  mth    null
// it's osgi bundle class loader, so we need to load implementation in bundles
if  log isdebugenabled
log debug     loader
loadimplementationsinbundle test  packagename  loader  mth
return
catch  nosuchmethodexception e
log trace
enumeration<url> urls
try
urls   getresources loader  packagename
if   urls hasmoreelements
log trace
catch  ioexception ioe
log warn     packagename  ioe
return
while  urls hasmoreelements
url url   null
try
url   urls nextelement
if  log istraceenabled
log trace     url
string urlpath   url getfile
urlpath   urldecoder decode urlpath
if  log istraceenabled
log trace     urlpath
// if it's a file in a directory, trim the stupid file: spec
if  urlpath startswith
urlpath   urlpath substring 5
// osgi bundles should be skipped
if  urlpath startswith
log trace
continue
// else it's in a jar, grab the path to the jar
if  urlpath indexof    > 0
urlpath   urlpath substring 0  urlpath indexof
if  log istraceenabled
log trace     urlpath       test
file file   new file urlpath
if  file isdirectory
if  log isdebugenabled
log debug     file
loadimplementationsindirectory test  packagename  file
else
if  log isdebugenabled
log debug     file
loadimplementationsinjar test  packagename  file
catch  ioexception ioe
log warn     url  ioe
/**
* strategy to get the resources by the given classloader.
* <p/>
* notice that in websphere platforms there is a {@link org.apache.camel.util.websphereresolverutil}
* to take care of websphere's odditiy of resource loading.
*
* @param loader  the classloader
* @param packagename   the packagename for the package to load
* @return  url's for the given package
* @throws ioexception is thrown by the classloader
*/
protected enumeration<url> getresources classloader loader  string packagename  throws ioexception
if  log istraceenabled
log trace     packagename       loader
return loader getresources packagename
private void loadimplementationsinbundle test test  string packagename  classloader loader  method mth
// use an inner class to avoid a noclassdeffounderror when used in a non-osgi env
set<string> urls   osgiutil getimplementationsinbundle test  packagename  loader  mth
if  urls    null
for  string url   urls
// substring to avoid leading slashes
addifmatching test  url
private static final class osgiutil
private osgiutil
// helper class
static set<string> getimplementationsinbundle test test  string packagename  classloader loader  method mth
try
org osgi framework bundle bundle    org osgi framework bundle  mth invoke loader
org osgi framework bundle bundles   bundle getbundlecontext   getbundles
set<string> urls   new hashset<string>
for  org osgi framework bundle bd   bundles
if  log istraceenabled
log trace     bd
enumeration<url> paths   bd findentries     packagename     true
while  paths    null    paths hasmoreelements
url path   paths nextelement
urls add path getpath   substring 1
return urls
catch  throwable t
log error     test
t getmessage
return null
/**
* finds matches in a physical directory on a filesystem. examines all files
* within a directory - if the file object is not a directory, and ends with
* <i>.class</i> the file is loaded and tested to see if it is acceptable
* according to the test. operates recursively to find classes within a
* folder structure matching the package structure.
*
* @param test     a test used to filter the classes that are discovered
* @param parent   the package name up to this directory in the package
*                 hierarchy. e.g. if /classes is in the classpath and we wish to
*                 examine files in /classes/org/apache then the values of
*                 <i>parent</i> would be <i>org/apache</i>
* @param location a file object representing a directory
*/
private void loadimplementationsindirectory test test  string parent  file location
file files   location listfiles
stringbuilder builder   null
for  file file   files
builder   new stringbuilder 100
string name   file getname
if  name    null
name   name trim
builder append parent  append    append name
string packageorclass   parent    null ? name   builder tostring
if  file isdirectory
loadimplementationsindirectory test  packageorclass  file
else if  name endswith
addifmatching test  packageorclass
/**
* finds matching classes within a jar files that contains a folder
* structure matching the package structure. if the file is not a jarfile or
* does not exist a warning will be logged, but no error will be raised.
*
* @param test    a test used to filter the classes that are discovered
* @param parent  the parent package under which classes must be in order to
*                be considered
* @param jarfile the jar file to be examined for classes
*/
private void loadimplementationsinjar test test  string parent  file jarfile
jarinputstream jarstream   null
try
jarstream   new jarinputstream new fileinputstream jarfile
jarentry entry
while   entry   jarstream getnextjarentry       null
string name   entry getname
if  name    null
name   name trim
if   entry isdirectory      name startswith parent     name endswith
addifmatching test  name
catch  ioexception ioe
log error     jarfile       test
ioe getmessage    ioe
finally
objecthelper close jarstream  jarfile getpath    log
/**
* add the class designated by the fully qualified class name provided to
* the set of resolved classes if and only if it is approved by the test
* supplied.
*
* @param test the test used to determine if the class matches
* @param fqn  the fully qualified name of a class
*/
protected void addifmatching test test  string fqn
try
string externalname   fqn substring 0  fqn indexof     replace
set<classloader> set   getclassloaders
boolean found   false
for  classloader classloader   set
if  log istraceenabled
log trace     externalname       test
try
class type   classloader loadclass externalname
if  test matches type
if  log istraceenabled
log trace     type       classloader
matches add  class<t> type
found   true
break
catch  classnotfoundexception e
log debug     fqn       classloader
e  e
catch  noclassdeffounderror e
log debug     fqn       classloader
e  e
if   found
log warn     fqn       set
catch  throwable t
log warn     fqn       t getclass   getname
t getmessage    t