/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component jms
import javax jms connectionfactory
import javax jms destination
import javax jms exceptionlistener
import javax jms jmsexception
import javax jms message
import javax jms messageproducer
import javax jms queuesender
import javax jms session
import javax jms topicpublisher
import org apache camel runtimecamelexception
import org apache camel util objecthelper
import org apache camel util packagehelper
import org apache commons logging log
import org apache commons logging logfactory
import org springframework core task taskexecutor
import org springframework jms jmsexception
import org springframework jms core jmsoperations
import org springframework jms core jmstemplate
import org springframework jms core jmstemplate102
import org springframework jms core messagecreator
import org springframework jms core sessioncallback
import org springframework jms listener abstractmessagelistenercontainer
import org springframework jms listener defaultmessagelistenercontainer
import org springframework jms listener defaultmessagelistenercontainer102
import org springframework jms listener simplemessagelistenercontainer
import org springframework jms listener simplemessagelistenercontainer102
import org springframework jms listener serversession serversessionfactory
import org springframework jms listener serversession serversessionmessagelistenercontainer
import org springframework jms listener serversession serversessionmessagelistenercontainer102
import org springframework jms support jmsutils
import org springframework jms support converter messageconverter
import org springframework jms support destination destinationresolver
import org springframework transaction platformtransactionmanager
import org springframework util assert
import static org apache camel util objecthelper removestartingcharacters
/**
* @version $revision$
*/
public class jmsconfiguration implements cloneable
public static final string queue_prefix
public static final string topic_prefix
public static final string temp_queue_prefix
public static final string temp_topic_prefix
protected static final string transacted
protected static final string client_acknowledge
protected static final string auto_acknowledge
protected static final string dups_ok_acknowledge
protected static final string replyto_temp_dest_affinity_per_component
protected static final string replyto_temp_dest_affinity_per_endpoint
protected static final string replyto_temp_dest_affinity_per_producer
private static final transient log log   logfactory getlog jmsconfiguration class
private jmsoperations jmsoperations
private destinationresolver destinationresolver
private connectionfactory connectionfactory
private connectionfactory templateconnectionfactory
private connectionfactory listenerconnectionfactory
private int acknowledgementmode    1
private string acknowledgementmodename
// used to configure the spring container
private exceptionlistener exceptionlistener
private consumertype consumertype   consumertype default
private boolean autostartup   true
private boolean acceptmessageswhilestopping
private string clientid
private string durablesubscriptionname
private boolean subscriptiondurable
private boolean exposelistenersession   true
private taskexecutor taskexecutor
private boolean pubsubnolocal
private int concurrentconsumers   1
private int maxmessagespertask   1
private serversessionfactory serversessionfactory
private int cachelevel    1
private string cachelevelname
private long recoveryinterval    1
private long receivetimeout    1
private long requesttimeout   20000l
private int idletaskexecutionlimit   1
private int maxconcurrentconsumers   1
// jmstemplate only
private boolean useversion102
private boolean explicitqosenabled
private boolean deliverypersistent   true
private boolean replytodeliverypersistent   true
private long timetolive    1
private messageconverter messageconverter
private boolean messageidenabled   true
private boolean messagetimestampenabled   true
private int priority    1
// transaction related configuration
private boolean transacted
private platformtransactionmanager transactionmanager
private string transactionname
private int transactiontimeout    1
private boolean preservemessageqos
private long requestmappurgepolltimemillis   1000l
private boolean disablereplyto
private boolean eagerloadingofproperties
// always make a jms message copy when it's passed to producer
private boolean alwayscopymessage
private boolean usemessageidascorrelationid
private jmsprovidermetadata providermetadata   new jmsprovidermetadata
private jmsoperations metadatajmsoperations
// defines the component created temporary replyto destination sharing strategy:
// possible values are: "component", "endpoint", "producer"
// component - a single temp queue is shared among all producers for a given component instance
// endpoint - a single temp queue is shared among all producers for a given endpoint instance
// producer - a single temp queue is created per producer
private string replytotempdestinationaffinity   replyto_temp_dest_affinity_per_endpoint
private string replytodestination
private string replytodestinationselectorname
public jmsconfiguration
public jmsconfiguration connectionfactory connectionfactory
this connectionfactory   connectionfactory
/**
* returns a copy of this configuration
*/
public jmsconfiguration copy
try
return  jmsconfiguration clone
catch  clonenotsupportedexception e
throw new runtimecamelexception e
public static interface messagesentcallback
void sent message message
public static class cameljmstemplate extends jmstemplate
private jmsconfiguration config
public cameljmstemplate jmsconfiguration config  connectionfactory connectionfactory
super connectionfactory
this config   config
public void send final string destinationname
final messagecreator messagecreator
final messagesentcallback callback  throws jmsexception
execute new sessioncallback
public object doinjms session session  throws jmsexception
destination destination   resolvedestinationname session  destinationname
assert notnull messagecreator
messageproducer producer   createproducer session  destination
message message   null
try
message   messagecreator createmessage session
if  logger isdebugenabled
logger debug     message
dosend producer  message
// check commit - avoid commit call within a jta transaction.
if  session gettransacted      issessionlocallytransacted session
// transacted session created by this template -> commit.
jmsutils commitifnecessary session
finally
jmsutils closemessageproducer producer
if  message    null    callback    null
callback sent message
return null
false
/**
* override so we can support preserving the qos settings that have
* been set on the message.
*/
@override
protected void dosend messageproducer producer  message message  throws jmsexception
if  config ispreservemessageqos
long ttl   message getjmsexpiration
if  ttl    0
ttl   ttl   system currenttimemillis
// message had expired.. so set the ttl as small as
// possible
if  ttl <  0
ttl   1
producer send message  message getjmsdeliverymode    message getjmspriority    ttl
else
super dosend producer  message
public static class cameljmsteemplate102 extends jmstemplate102
private jmsconfiguration config
public cameljmsteemplate102 jmsconfiguration config  connectionfactory connectionfactory  boolean pubsubdomain
super connectionfactory  pubsubdomain
this config   config
public void send final string destinationname
final messagecreator messagecreator
final messagesentcallback callback  throws jmsexception
execute new sessioncallback
public object doinjms session session  throws jmsexception
destination destination   resolvedestinationname session  destinationname
assert notnull messagecreator
messageproducer producer   createproducer session  destination
message message   null
try
message   messagecreator createmessage session
if  logger isdebugenabled
logger debug     message
dosend producer  message
// check commit - avoid commit call within a jta
// transaction.
if  session gettransacted      issessionlocallytransacted session
// transacted session created by this template ->
// commit.
jmsutils commitifnecessary session
finally
jmsutils closemessageproducer producer
if  message    null    callback    null
callback sent message
return null
false
/**
* override so we can support preserving the qos settings that have
* been set on the message.
*/
@override
protected void dosend messageproducer producer  message message  throws jmsexception
if  config ispreservemessageqos
long ttl   message getjmsexpiration
if  ttl    0
ttl   ttl   system currenttimemillis
// message had expired.. so set the ttl as small as
// possible
if  ttl <  0
ttl   1
if  ispubsubdomain
topicpublisher  producer  publish message  message getjmsdeliverymode
message getjmspriority    ttl
else
queuesender  producer  send message  message getjmsdeliverymode
message getjmspriority    ttl
else
super dosend producer  message
/**
* creates a {@link jmsoperations} object used for request/response using a request
* timeout value
*/
public jmsoperations createinouttemplate jmsendpoint endpoint  boolean pubsubdomain  string destination  long requesttimeout
jmsoperations answer   createinonlytemplate endpoint  pubsubdomain  destination
if  answer instanceof jmstemplate    requesttimeout > 0
jmstemplate jmstemplate    jmstemplate answer
jmstemplate setexplicitqosenabled true
jmstemplate settimetolive requesttimeout
return answer
/**
* creates a {@link jmsoperations} object used for one way messaging
*/
public jmsoperations createinonlytemplate jmsendpoint endpoint  boolean pubsubdomain  string destination
if  jmsoperations    null
return jmsoperations
connectionfactory factory   gettemplateconnectionfactory
jmstemplate template   useversion102
? new cameljmsteemplate102 this  factory  pubsubdomain
new cameljmstemplate this  factory
template setpubsubdomain pubsubdomain
if  destinationresolver    null
template setdestinationresolver destinationresolver
if  endpoint instanceof destinationendpoint
log debug
else if  endpoint instanceof destinationendpoint
destinationendpoint destinationendpoint    destinationendpoint  endpoint
template setdestinationresolver createdestinationresolver destinationendpoint
template setdefaultdestinationname destination
template setexplicitqosenabled isexplicitqosenabled
template setdeliverypersistent deliverypersistent
if  messageconverter    null
template setmessageconverter messageconverter
template setmessageidenabled messageidenabled
template setmessagetimestampenabled messagetimestampenabled
if  priority >  0
template setpriority priority
template setpubsubnolocal pubsubnolocal
if  receivetimeout >  0
template setreceivetimeout receivetimeout
if  timetolive >  0
template settimetolive timetolive
template setsessiontransacted transacted
if  transacted
template setsessionacknowledgemode session session_transacted
else
// this is here for completeness, but the template should not get
// used
// for receiving messages.
if  acknowledgementmode >  0
template setsessionacknowledgemode acknowledgementmode
else if  acknowledgementmodename    null
template setsessionacknowledgemodename acknowledgementmodename
return template
public abstractmessagelistenercontainer createmessagelistenercontainer jmsendpoint endpoint
abstractmessagelistenercontainer container   choosemessagelistenercontainerimplementation
configuremessagelistenercontainer container  endpoint
return container
// properties
// -------------------------------------------------------------------------
public connectionfactory getconnectionfactory
if  connectionfactory    null
connectionfactory   createconnectionfactory
return connectionfactory
/**
* sets the default connection factory to be used if a connection factory is
* not specified for either
* {@link #settemplateconnectionfactory(connectionfactory)} or
* {@link #setlistenerconnectionfactory(connectionfactory)}
*
* @param connectionfactory the default connection factory to use
*/
public void setconnectionfactory connectionfactory connectionfactory
this connectionfactory   connectionfactory
public connectionfactory getlistenerconnectionfactory
if  listenerconnectionfactory    null
listenerconnectionfactory   createlistenerconnectionfactory
return listenerconnectionfactory
/**
* sets the connection factory to be used for consuming messages via the
* {@link #createmessagelistenercontainer(jmsendpoint)}
*
* @param listenerconnectionfactory the connection factory to use for
*                consuming messages
*/
public void setlistenerconnectionfactory connectionfactory listenerconnectionfactory
this listenerconnectionfactory   listenerconnectionfactory
public connectionfactory gettemplateconnectionfactory
if  templateconnectionfactory    null
templateconnectionfactory   createtemplateconnectionfactory
return templateconnectionfactory
/**
* sets the connection factory to be used for sending messages via the
* {@link jmstemplate} via {@link #createinonlytemplate(jmsendpoint,boolean, string)}
*
* @param templateconnectionfactory the connection factory for sending
*                messages
*/
public void settemplateconnectionfactory connectionfactory templateconnectionfactory
this templateconnectionfactory   templateconnectionfactory
public boolean isuseversion102
return useversion102
public void setuseversion102 boolean useversion102
this useversion102   useversion102
public boolean isautostartup
return autostartup
public void setautostartup boolean autostartup
this autostartup   autostartup
public boolean isacceptmessageswhilestopping
return acceptmessageswhilestopping
public void setacceptmessageswhilestopping boolean acceptmessageswhilestopping
this acceptmessageswhilestopping   acceptmessageswhilestopping
public string getclientid
return clientid
public void setclientid string consumerclientid
this clientid   consumerclientid
public string getdurablesubscriptionname
return durablesubscriptionname
public void setdurablesubscriptionname string durablesubscriptionname
this durablesubscriptionname   durablesubscriptionname
public exceptionlistener getexceptionlistener
return exceptionlistener
public void setexceptionlistener exceptionlistener exceptionlistener
this exceptionlistener   exceptionlistener
public boolean issubscriptiondurable
return subscriptiondurable
public void setsubscriptiondurable boolean subscriptiondurable
this subscriptiondurable   subscriptiondurable
public string getacknowledgementmodename
return acknowledgementmodename
public void setacknowledgementmodename string consumeracknowledgementmode
this acknowledgementmodename   consumeracknowledgementmode
this acknowledgementmode    1
public boolean isexposelistenersession
return exposelistenersession
public void setexposelistenersession boolean exposelistenersession
this exposelistenersession   exposelistenersession
public taskexecutor gettaskexecutor
return taskexecutor
public void settaskexecutor taskexecutor taskexecutor
this taskexecutor   taskexecutor
public boolean ispubsubnolocal
return pubsubnolocal
public void setpubsubnolocal boolean pubsubnolocal
this pubsubnolocal   pubsubnolocal
public int getconcurrentconsumers
return concurrentconsumers
public void setconcurrentconsumers int concurrentconsumers
this concurrentconsumers   concurrentconsumers
public int getmaxmessagespertask
return maxmessagespertask
public void setmaxmessagespertask int maxmessagespertask
this maxmessagespertask   maxmessagespertask
public serversessionfactory getserversessionfactory
return serversessionfactory
public void setserversessionfactory serversessionfactory serversessionfactory
this serversessionfactory   serversessionfactory
public int getcachelevel
return cachelevel
public void setcachelevel int cachelevel
this cachelevel   cachelevel
public string getcachelevelname
return cachelevelname
public void setcachelevelname string cachename
this cachelevelname   cachename
public long getrecoveryinterval
return recoveryinterval
public void setrecoveryinterval long recoveryinterval
this recoveryinterval   recoveryinterval
public long getreceivetimeout
return receivetimeout
public void setreceivetimeout long receivetimeout
this receivetimeout   receivetimeout
public platformtransactionmanager gettransactionmanager
return transactionmanager
public void settransactionmanager platformtransactionmanager transactionmanager
this transactionmanager   transactionmanager
public string gettransactionname
return transactionname
public void settransactionname string transactionname
this transactionname   transactionname
public int gettransactiontimeout
return transactiontimeout
public void settransactiontimeout int transactiontimeout
this transactiontimeout   transactiontimeout
public int getidletaskexecutionlimit
return idletaskexecutionlimit
public void setidletaskexecutionlimit int idletaskexecutionlimit
this idletaskexecutionlimit   idletaskexecutionlimit
public int getmaxconcurrentconsumers
return maxconcurrentconsumers
public void setmaxconcurrentconsumers int maxconcurrentconsumers
this maxconcurrentconsumers   maxconcurrentconsumers
public boolean isexplicitqosenabled
return explicitqosenabled    null ? explicitqosenabled   false
public void setexplicitqosenabled boolean explicitqosenabled
this explicitqosenabled   explicitqosenabled
public boolean isdeliverypersistent
return deliverypersistent
public void setdeliverypersistent boolean deliverypersistent
this deliverypersistent   deliverypersistent
configuredqos
public boolean isreplytodeliverypersistent
return replytodeliverypersistent
public void setreplytodeliverypersistent boolean replytodeliverypersistent
this replytodeliverypersistent   replytodeliverypersistent
public long gettimetolive
return timetolive
public void settimetolive long timetolive
this timetolive   timetolive
configuredqos
public messageconverter getmessageconverter
return messageconverter
public void setmessageconverter messageconverter messageconverter
this messageconverter   messageconverter
public boolean ismessageidenabled
return messageidenabled
public void setmessageidenabled boolean messageidenabled
this messageidenabled   messageidenabled
public boolean ismessagetimestampenabled
return messagetimestampenabled
public void setmessagetimestampenabled boolean messagetimestampenabled
this messagetimestampenabled   messagetimestampenabled
public int getpriority
return priority
public void setpriority int priority
this priority   priority
configuredqos
public consumertype getconsumertype
return consumertype
public void setconsumertype consumertype consumertype
this consumertype   consumertype
public int getacknowledgementmode
return acknowledgementmode
public void setacknowledgementmode int consumeracknowledgementmode
this acknowledgementmode   consumeracknowledgementmode
this acknowledgementmodename   null
public boolean istransacted
return transacted
public void settransacted boolean consumertransacted
this transacted   consumertransacted
public boolean iseagerloadingofproperties
return eagerloadingofproperties
/**
* enables eager loading of jms properties as soon as a message is loaded
* which generally is inefficient as the jms properties may not be required
* but sometimes can catch early any issues with the underlying jms provider
* and the use of jms properties
*
* @param eagerloadingofproperties whether or not to enable eager loading of
*                jms properties on inbound messages
*/
public void seteagerloadingofproperties boolean eagerloadingofproperties
this eagerloadingofproperties   eagerloadingofproperties
public boolean isdisablereplyto
return disablereplyto
/**
* disables the use of the jmsreplyto header for consumers so that inbound
* messages are treated as inonly rather than inout requests.
*
* @param disablereplyto whether or not to disable the use of jmsreplyto
*                header indicating an inout
*/
public void setdisablereplyto boolean disablereplyto
this disablereplyto   disablereplyto
/**
* set to true if you want to send message using the qos settings specified
* on the message. normally the qos settings used are the one configured on
* this object.
*
* @param preservemessageqos
*/
public void setpreservemessageqos boolean preservemessageqos
this preservemessageqos   preservemessageqos
public jmsoperations getjmsoperations
return jmsoperations
public void setjmsoperations jmsoperations jmsoperations
this jmsoperations   jmsoperations
public destinationresolver getdestinationresolver
return destinationresolver
public void setdestinationresolver destinationresolver destinationresolver
this destinationresolver   destinationresolver
public long getrequestmappurgepolltimemillis
return requestmappurgepolltimemillis
/**
* sets the frequency that the requestmap for inout exchanges is purged for
* timed out message exchanges
*
* @param requestmappurgepolltimemillis
*/
public void setrequestmappurgepolltimemillis long requestmappurgepolltimemillis
this requestmappurgepolltimemillis   requestmappurgepolltimemillis
public jmsprovidermetadata getprovidermetadata
return providermetadata
/**
* allows the provider metadata to be explicitly configured. typically this is not required
* and camel will auto-detect the provider metadata from the underlying provider.
*/
public void setprovidermetadata jmsprovidermetadata providermetadata
this providermetadata   providermetadata
public jmsoperations getmetadatajmsoperations jmsendpoint endpoint
if  metadatajmsoperations    null
metadatajmsoperations   getjmsoperations
if  metadatajmsoperations    null
metadatajmsoperations   createinonlytemplate endpoint  false  null
return metadatajmsoperations
/**
* sets the {@link jmsoperations} used to deduce the {@link jmsprovidermetadata} details which if none
* is customized one is lazily created on demand
*
* @param metadatajmsoperations
*/
public void setmetadatajmsoperations jmsoperations metadatajmsoperations
this metadatajmsoperations   metadatajmsoperations
// implementation methods
// -------------------------------------------------------------------------
public static destinationresolver createdestinationresolver final destinationendpoint destinationendpoint
return new destinationresolver
public destination resolvedestinationname session session  string destinationname  boolean pubsubdomain  throws jmsexception
return destinationendpoint getjmsdestination session
protected void configuremessagelistenercontainer abstractmessagelistenercontainer container
jmsendpoint endpoint
container setconnectionfactory getlistenerconnectionfactory
if  endpoint instanceof destinationendpoint
container setdestinationresolver createdestinationresolver  destinationendpoint  endpoint
else if  destinationresolver    null
container setdestinationresolver destinationresolver
if  autostartup
container setautostartup true
if  clientid    null
container setclientid clientid
container setsubscriptiondurable subscriptiondurable
if  durablesubscriptionname    null
container setdurablesubscriptionname durablesubscriptionname
// lets default to durable subscription if the subscriber name and
// client id are specified (as there's
// no reason to specify them if not! :)
if  durablesubscriptionname    null    clientid    null
container setsubscriptiondurable true
if  exceptionlistener    null
container setexceptionlistener exceptionlistener
container setacceptmessageswhilestopping acceptmessageswhilestopping
container setexposelistenersession exposelistenersession
container setsessiontransacted transacted
if  transacted
container setsessionacknowledgemode session session_transacted
else
if  acknowledgementmode >  0
container setsessionacknowledgemode acknowledgementmode
else if  acknowledgementmodename    null
container setsessionacknowledgemodename acknowledgementmodename
if  endpoint getselector      null    endpoint getselector   length      0
container setmessageselector endpoint getselector
if  container instanceof defaultmessagelistenercontainer
// this includes defaultmessagelistenercontainer102
defaultmessagelistenercontainer listenercontainer    defaultmessagelistenercontainer container
if  concurrentconsumers >  0
listenercontainer setconcurrentconsumers concurrentconsumers
if  cachelevel >  0
listenercontainer setcachelevel cachelevel
else if  cachelevelname    null
listenercontainer setcachelevelname cachelevelname
else
listenercontainer setcachelevel defaultcachelevel endpoint
if  idletaskexecutionlimit >  0
listenercontainer setidletaskexecutionlimit idletaskexecutionlimit
if  maxconcurrentconsumers >  0
listenercontainer setmaxconcurrentconsumers maxconcurrentconsumers
if  maxmessagespertask >  0
listenercontainer setmaxmessagespertask maxmessagespertask
listenercontainer setpubsubnolocal pubsubnolocal
if  receivetimeout >  0
listenercontainer setreceivetimeout receivetimeout
if  recoveryinterval >  0
listenercontainer setrecoveryinterval recoveryinterval
if  taskexecutor    null
listenercontainer settaskexecutor taskexecutor
platformtransactionmanager tm   gettransactionmanager
if  tm    null
listenercontainer settransactionmanager tm
else if  transacted
throw new illegalargumentexception
if  transactionname    null
listenercontainer settransactionname transactionname
if  transactiontimeout >  0
listenercontainer settransactiontimeout transactiontimeout
else if  container instanceof serversessionmessagelistenercontainer
// this includes serversessionmessagelistenercontainer102
serversessionmessagelistenercontainer listenercontainer    serversessionmessagelistenercontainer container
if  maxmessagespertask >  0
listenercontainer setmaxmessagespertask maxmessagespertask
if  serversessionfactory    null
listenercontainer setserversessionfactory serversessionfactory
else if  container instanceof simplemessagelistenercontainer
// this includes simplemessagelistenercontainer102
simplemessagelistenercontainer listenercontainer    simplemessagelistenercontainer container
if  concurrentconsumers >  0
listenercontainer setconcurrentconsumers concurrentconsumers
listenercontainer setpubsubnolocal pubsubnolocal
if  taskexecutor    null
listenercontainer settaskexecutor taskexecutor
public void configure endpointmessagelistener listener
if  isdisablereplyto
listener setdisablereplyto true
if  iseagerloadingofproperties
listener seteagerloadingofproperties true
// revisit: we really ought to change the model and let jmsproducer
// and jmsconsumer have their own jmsconfiguration instance
// this way producer's and consumer's qos can differ and be
// independently configured
jmsoperations operations   listener gettemplate
if  operations instanceof jmstemplate
jmstemplate template    jmstemplate operations
template setdeliverypersistent isreplytodeliverypersistent
public abstractmessagelistenercontainer choosemessagelistenercontainerimplementation
// todo we could allow a spring container to auto-inject these objects?
switch  consumertype
case simple
return isuseversion102
? new simplemessagelistenercontainer102     new simplemessagelistenercontainer
case serversessionpool
return isuseversion102
? new serversessionmessagelistenercontainer102
new serversessionmessagelistenercontainer
case default
return isuseversion102
? new defaultmessagelistenercontainer102     new defaultmessagelistenercontainer
default
throw new illegalargumentexception     consumertype
/**
* defaults the jms cache level if none is explicitly specified. note that
* due to this <a
* href="http://opensource.atlassian.com/projects/spring/browse/spr-3890">spring
* bug</a> we cannot use cache_consumer by default (which we should do as
* its most efficient) unless the spring version is 2.5.1 or later. instead
* we use cache_connection - part from for non-durable topics which must use
* cache_consumer to avoid missing messages (due to the consumer being
* created and destroyed per message).
*
* @param endpoint the endpoint
* @return the cacne level
*/
protected int defaultcachelevel jmsendpoint endpoint
// if we are on a new enough spring version we can assume cache_consumer
if  packagehelper isvalidversion    2 51d
return defaultmessagelistenercontainer cache_consumer
else
if  endpoint ispubsubdomain       issubscriptiondurable
// we must cache the consumer or we will miss messages
// see https://issues.apache.org/activemq/browse/camel-253
return defaultmessagelistenercontainer cache_consumer
else
// to enable consuming and sending with a single jms session (to
// avoid xa) we can only use cache_connection
// due to this bug :
// http://opensource.atlassian.com/projects/spring/browse/spr-3890
return defaultmessagelistenercontainer cache_connection
/**
* factory method which allows derived classes to customize the lazy
* creation
*/
protected connectionfactory createconnectionfactory
objecthelper notnull connectionfactory
return null
/**
* factory method which allows derived classes to customize the lazy
* creation
*/
protected connectionfactory createlistenerconnectionfactory
return getconnectionfactory
/**
* factory method which allows derived classes to customize the lazy
* creation
*/
protected connectionfactory createtemplateconnectionfactory
return getconnectionfactory
public boolean ispreservemessageqos
return preservemessageqos
/**
* when one of the qos properties are configured such as {@link #setdeliverypersistent(boolean)},
* {@link #setpriority(int)} or {@link #settimetolive(long)} then we should auto default the
* setting of {@link #setexplicitqosenabled(boolean)} if its not been configured yet
*/
protected void configuredqos
if  explicitqosenabled    null
explicitqosenabled   true
public boolean isalwayscopymessage
return alwayscopymessage
public void setalwayscopymessage boolean alwayscopymessage
this alwayscopymessage   alwayscopymessage
public boolean isusemessageidascorrelationid
return usemessageidascorrelationid
public void setusemessageidascorrelationid boolean usemessageidascorrelationid
this usemessageidascorrelationid   usemessageidascorrelationid
public string getreplytotempdestinationaffinity
return replytotempdestinationaffinity
public void setreplytotempdestinationaffinity
string replytotempdestinationaffinity
this replytotempdestinationaffinity   replytotempdestinationaffinity
public long getrequesttimeout
return requesttimeout
public void setrequesttimeout long requesttimeout
this requesttimeout   requesttimeout
public string getreplyto
return replytodestination
public void setreplyto string replytodestination
if   replytodestination startswith queue_prefix
throw new illegalargumentexception
queue replyqueue
this replytodestination
removestartingcharacters replytodestination substring queue_prefix length
public string getreplytodestinationselectorname
return replytodestinationselectorname
public void setreplytodestinationselectorname string replytodestinationselectorname
this replytodestinationselectorname   replytodestinationselectorname
// in case of consumer -> producer and a named replyto correlation selector
// message passthough is impossible as we need to set the value of selector into
// outgoing message, which would be read-only if passthough were to remain enabled
if  replytodestinationselectorname    null
setalwayscopymessage true