/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel bam rules
import java util arraylist
import java util date
import org apache camel exchange
import org apache camel processor
import org apache camel route
import org apache camel bam timeexpression
import org apache camel bam model activitystate
import org apache camel bam model processinstance
import org apache camel impl defaultexchange
import org apache camel impl defaultroutecontext
import org apache camel impl servicesupport
import org apache camel model outputtype
import org apache camel model routetype
import org apache camel spi routecontext
import org apache camel util time
import org apache commons logging log
import org apache commons logging logfactory
import static org apache camel util servicehelper startservices
import static org apache camel util servicehelper stopservices
/**
* a temporal rule for use within bam
*
* @version $revision$
*/
public class temporalrule extends servicesupport
private static final transient log log   logfactory getlog temporalrule class
private timeexpression first
private timeexpression second
private long expectedmillis
private long overduemillis
private processor overdueaction
private outputtype overdueprocessors   new outputtype
public temporalrule timeexpression first  timeexpression second
this first   first
this second   second
}
public temporalrule expectwithin time builder
return expectwithin builder tomillis
}
public temporalrule expectwithin long millis
expectedmillis   millis
return this
}
public outputtype errorifover time builder
return errorifover builder tomillis
}
public outputtype errorifover long millis
overduemillis   millis
if  overdueprocessors    null
overdueprocessors   new outputtype
}
return overdueprocessors
}
public timeexpression getfirst
return first
}
public timeexpression getsecond
return second
}
public processor getoverdueaction   throws exception
if  overdueaction    null    overdueprocessors    null
// tood refactor to avoid this messyness...
arraylist<route> list   new arraylist<route>
routetype route   new routetype
route setcamelcontext first getbuilder   getprocessbuilder   getcontext
routecontext routecontext   new defaultroutecontext route  null  list
overdueaction   overdueprocessors createoutputsprocessor routecontext
}
return overdueaction
}
public void processexchange exchange exchange  processinstance instance
date firsttime   first evaluate instance
if  firsttime    null
// ignore as first event has not accurred yet
return
}
// todo now we might need to set the second activity state
// to 'grey' to indicate it now could happen?
// lets force the lazy creation of the second state
activitystate secondstate   second getorcreateactivitystate instance
if  expectedmillis > 0l
date expected   secondstate gettimeexpected
if  expected    null
expected   add firsttime  expectedmillis
secondstate settimeexpected expected
}
}
if  overduemillis > 0l
date overdue   secondstate gettimeoverdue
if  overdue    null
overdue   add firsttime  overduemillis
secondstate settimeoverdue overdue
}
}
}
public void processexpired activitystate activitystate  throws exception
processor processor   getoverdueaction
if  processor    null
date now   new date
/*
todo this doesn't work and returns null for some strange reason
processinstance instance = activitystate.getprocessinstance();
activitystate secondstate = second.getactivitystate(instance);
if (secondstate == null) {
log.error("could not find the second state! process is: "
+ instance + " with first state: " + first.getactivitystate(instance)
+ " and the state i was called with was: " + activitystate);
}
*/
activitystate secondstate   activitystate
date overdue   secondstate gettimeoverdue
if  now compareto overdue  >  0
exchange exchange   createexchange
exchange getin   setbody activitystate
processor process exchange
else
log warn     now       overdue
}
}
}
protected exchange createexchange
return new defaultexchange second getbuilder   getprocessbuilder   getcontext
}
/**
* returns the date in the future adding the given number of millis
*
* @param date
* @param millis
* @return the date in the future
*/
protected date add date date  long millis
return new date date gettime     millis
}
protected void dostart   throws exception
startservices getoverdueaction
}
protected void dostop   throws exception
stopservices getoverdueaction
}
}