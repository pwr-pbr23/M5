/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel model
import java util arraylist
import java util arrays
import java util collection
import java util collections
import java util hashset
import java util linkedlist
import java util list
import java util set
import java util concurrent threadpoolexecutor
import javax xml bind annotation xmlaccesstype
import javax xml bind annotation xmlaccessortype
import javax xml bind annotation xmlattribute
import javax xml bind annotation xmltransient
import org apache camel camelcontext
import org apache camel camelexception
import org apache camel endpoint
import org apache camel exchange
import org apache camel expression
import org apache camel predicate
import org apache camel processor
import org apache camel route
import org apache camel runtimecamelexception
import org apache camel builder dataformatclause
import org apache camel builder deadletterchannelbuilder
import org apache camel builder errorhandlerbuilder
import org apache camel builder errorhandlerbuilderref
import org apache camel builder expressionclause
import org apache camel builder noerrorhandlerbuilder
import org apache camel builder processorbuilder
import org apache camel impl defaultcamelcontext
import org apache camel model dataformat dataformattype
import org apache camel model language expressiontype
import org apache camel model language languageexpression
import org apache camel processor convertbodyprocessor
import org apache camel processor delegateprocessor
import org apache camel processor pipeline
import org apache camel processor aggregate aggregationcollection
import org apache camel processor aggregate aggregationstrategy
import org apache camel processor idempotent messageidrepository
import org apache camel spi dataformat
import org apache camel spi errorhandlerwrappingstrategy
import org apache camel spi interceptstrategy
import org apache camel spi policy
import org apache camel spi routecontext
import org apache commons logging log
import org apache commons logging logfactory
/**
* base class for processor types that most xml types extend.
*
* @version $revision$
*/
@xmlaccessortype xmlaccesstype property
public abstract class processortype<type extends processortype> extends optionalidentifiedtype<type> implements block
public static final string default_trace_category
private static final transient log log   logfactory getlog processortype class
private errorhandlerbuilder errorhandlerbuilder
private boolean inheriterrorhandlerflag
private nodefactory nodefactory
private linkedlist<block> blocks   new linkedlist<block>
private processortype<? extends processortype> parent
private list<interceptortype> interceptors   new arraylist<interceptortype>
private string errorhandlerref
// else to use an optional attribute in jaxb2
public abstract list<processortype<?>> getoutputs
public processor createprocessor routecontext routecontext  throws exception
throw new unsupportedoperationexception     getclass   getname
public processor createoutputsprocessor routecontext routecontext  throws exception
collection<processortype<?>> outputs   getoutputs
return createoutputsprocessor routecontext  outputs
public void addroutes routecontext routecontext  collection<route> routes  throws exception
processor processor   makeprocessor routecontext
if   routecontext isrouteadded
routecontext addeventdrivenprocessor processor
/**
* wraps the child processor in whatever necessary interceptors and error
* handlers
*/
public processor wrapprocessor routecontext routecontext  processor processor  throws exception
processor   wrapprocessorininterceptors routecontext  processor
return wrapinerrorhandler routecontext  processor
// fluent api
// -------------------------------------------------------------------------
/**
* sends the exchange to the given endpoint uri
*/
public type to string uri
addoutput new totype uri
return  type  this
/**
* sends the exchange to the given endpoint
*/
public type to endpoint endpoint
addoutput new totype endpoint
return  type  this
/**
* sends the exchange to a list of endpoints using the
* {@link multicastprocessor} pattern
*/
public type to string    uris
for  string uri   uris
addoutput new totype uri
return  type  this
/**
* sends the exchange to a list of endpoints using the
* {@link multicastprocessor} pattern
*/
public type to endpoint    endpoints
for  endpoint endpoint   endpoints
addoutput new totype endpoint
return  type  this
/**
* sends the exchange to a list of endpoint using the
* {@link multicastprocessor} pattern
*/
public type to collection<endpoint> endpoints
for  endpoint endpoint   endpoints
addoutput new totype endpoint
return  type  this
/**
* multicasts messages to all its child outputs; so that each processor and
* destination gets a copy of the original message to avoid the processors
* interfering with each other.
*/
public multicasttype multicast
multicasttype answer   new multicasttype
addoutput answer
return answer
/**
* multicasts messages to all its child outputs; so that each processor and
* destination gets a copy of the original message to avoid the processors
* interfering with each other.
* @param aggregationstrategy the strategy used to aggregate responses for
*          every part
* @param parallelprocessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
* @return the multicast type
*/
public multicasttype multicast aggregationstrategy aggregationstrategy  boolean parallelprocessing
multicasttype answer   new multicasttype
addoutput answer
answer setaggregationstrategy aggregationstrategy
answer setparallelprocessing parallelprocessing
return answer
/**
* multicasts messages to all its child outputs; so that each processor and
* destination gets a copy of the original message to avoid the processors
* interfering with each other.
* @param aggregationstrategy the strategy used to aggregate responses for
*          every part
* @return the multicast type
*/
public multicasttype multicast aggregationstrategy aggregationstrategy
multicasttype answer   new multicasttype
addoutput answer
answer setaggregationstrategy aggregationstrategy
return answer
/**
* creates a {@link pipeline} of the list of endpoints so that the message
* will get processed by each endpoint in turn and for request/response the
* output of one endpoint will be the input of the next endpoint
*/
public type pipeline string    uris
// todo pipeline v mulicast
return to uris
/**
* creates a {@link pipeline} of the list of endpoints so that the message
* will get processed by each endpoint in turn and for request/response the
* output of one endpoint will be the input of the next endpoint
*/
public type pipeline endpoint    endpoints
// todo pipeline v mulicast
return to endpoints
/**
* creates a {@link pipeline} of the list of endpoints so that the message
* will get processed by each endpoint in turn and for request/response the
* output of one endpoint will be the input of the next endpoint
*/
public type pipeline collection<endpoint> endpoints
// todo pipeline v mulicast
return to endpoints
/**
* ends the current block
*/
public processortype<? extends processortype> end
if  blocks isempty
if  parent    null
throw new illegalargumentexception
return parent
popblock
return this
/**
* causes subsequent processors to be called asynchronously
*
* @param coresize the number of threads that will be used to process
*                 messages in subsequent processors.
* @return a threadtype builder that can be used to further configure the
*         the thread pool.
*/
public threadtype thread int coresize
threadtype answer   new threadtype coresize
addoutput answer
return answer
/**
* causes subsequent processors to be called asynchronously
*
* @param executor the executor that will be used to process
*                 messages in subsequent processors.
* @return a threadtype builder that can be used to further configure the
*         the thread pool.
*/
public processortype<type> thread threadpoolexecutor executor
threadtype answer   new threadtype executor
addoutput answer
return this
/**
* creates an {@link idempotentconsumer} to avoid duplicate messages
*/
public idempotentconsumertype idempotentconsumer expression messageidexpression
messageidrepository messageidrepository
idempotentconsumertype answer   new idempotentconsumertype messageidexpression  messageidrepository
addoutput answer
return answer
/**
* creates an {@link idempotentconsumer} to avoid duplicate messages
*
* @return the builder used to create the expression
*/
public expressionclause<idempotentconsumertype> idempotentconsumer messageidrepository messageidrepository
idempotentconsumertype answer   new idempotentconsumertype
answer setmessageidrepository messageidrepository
addoutput answer
return expressionclause createandsetexpression answer
/**
* creates a predicate expression which only if it is true then the
* exchange is forwarded to the destination
*
* @return the clause used to create the filter expression
*/
public expressionclause<filtertype> filter
filtertype filter   new filtertype
addoutput filter
return expressionclause createandsetexpression filter
/**
* creates a predicate which is applied and only if it is true then the
* exchange is forwarded to the destination
*
* @return the builder for a predicate
*/
public filtertype filter predicate predicate
filtertype filter   new filtertype predicate
addoutput filter
return filter
public filtertype filter expressiontype expression
filtertype filter   getnodefactory   createfilter
filter setexpression expression
addoutput filter
return filter
public filtertype filter string language  string expression
return filter new languageexpression language  expression
public loadbalancetype loadbalance
loadbalancetype answer   new loadbalancetype
addoutput answer
return answer
/**
* creates a choice of one or more predicates with an otherwise clause
*
* @return the builder for a choice expression
*/
public choicetype choice
choicetype answer   new choicetype
addoutput answer
return answer
/**
* creates a try/catch block
*
* @return the builder for a tryblock expression
*/
public trytype tryblock
trytype answer   new trytype
addoutput answer
return answer
/**
* creates a dynamic <a
* href="http://activemq.apache.org/camel/recipient-list.html">recipient
* list</a> pattern.
*
* @param receipients is the builder of the expression used in the
*                    {@link recipientlist} to decide the destinations
*/
public type recipientlist expression receipients
recipientlisttype answer   new recipientlisttype receipients
addoutput answer
return  type  this
/**
* creates a dynamic <a
* href="http://activemq.apache.org/camel/recipient-list.html">recipient
* list</a> pattern.
*
* @return the expression clause for the expression used in the
*                    {@link recipientlist} to decide the destinations
*/
public expressionclause<processortype<type>> recipientlist
recipientlisttype answer   new recipientlisttype
addoutput answer
expressionclause<processortype<type>> clause   new expressionclause<processortype<type>>  type  this
answer setexpression clause
return clause
/**
* creates a <a
* href="http://activemq.apache.org/camel/routing-slip.html">routing
* slip</a> pattern.
*
* @param header is the header that the {@link org.apache.camel.processor.routingslip routingslip}
* class will look in for the list of uris to route the message to.
* @param uridelimiter is the delimiter that will be used to split up
* the list of uris in the routing slip.
*/
public type routingslip string header  string uridelimiter
routingsliptype answer   new routingsliptype header  uridelimiter
addoutput answer
return  type  this
/**
* creates a <a
* href="http://activemq.apache.org/camel/routing-slip.html">routing
* slip</a> pattern.
*
* @param header is the header that the {@link org.apache.camel.processor.routingslip routingslip}
* class will look in for the list of uris to route the message to. the list of uris
* will be split based on the default delimiter
* {@link routingsliptype#default_delimiter}.
*/
public type routingslip string header
routingsliptype answer   new routingsliptype header
addoutput answer
return  type  this
/**
* creates a <a
* href="http://activemq.apache.org/camel/routing-slip.html">routing
* slip</a> pattern with the default header {@link routingsliptype#routing_slip_header}.
* the list of uris in the header will be split based on the default delimiter
* {@link routingsliptype#default_delimiter}.
*/
public type routingslip
routingsliptype answer   new routingsliptype
addoutput answer
return  type  this
/**
* creates the <a
* href="http://activemq.apache.org/camel/splitter.html">splitter</a>
* pattern where an expression is evaluated to iterate through each of the
* parts of a message and then each part is then send to some endpoint.
* this splitter responds with the latest message returned from destination
* endpoint.
*
* @param receipients the expression on which to split
* @return the builder
*/
public splittertype splitter expression receipients
splittertype answer   new splittertype receipients
addoutput answer
return answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/splitter.html">splitter</a>
* pattern where an expression is evaluated to iterate through each of the
* parts of a message and then each part is then send to some endpoint.
* this splitter responds with the latest message returned from destination
* endpoint.
*
* @return the expression clause for the expression on which to split
*/
public expressionclause<splittertype> splitter
splittertype answer   new splittertype
addoutput answer
return expressionclause createandsetexpression answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/splitter.html">splitter</a>
* pattern where an expression is evaluated to iterate through each of the
* parts of a message and then each part is then send to some endpoint.
* answer from the splitter is produced using given {@link aggregationstrategy}
* @param partsexpression the expression on which to split
* @param aggregationstrategy the strategy used to aggregate responses for
*          every part
* @return the builder
*/
public splittertype splitter expression partsexpression  aggregationstrategy aggregationstrategy
splittertype answer   new splittertype partsexpression
addoutput answer
answer setaggregationstrategy aggregationstrategy
return answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/splitter.html">splitter</a>
* pattern where an expression is evaluated to iterate through each of the
* parts of a message and then each part is then send to some endpoint.
* answer from the splitter is produced using given {@link aggregationstrategy}
* @param aggregationstrategy the strategy used to aggregate responses for
*          every part
* @return the expression clause for the expression on which to split
*/
public expressionclause<splittertype> splitter aggregationstrategy aggregationstrategy
splittertype answer   new splittertype
addoutput answer
answer setaggregationstrategy aggregationstrategy
return expressionclause createandsetexpression answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/splitter.html">splitter</a>
* pattern where an expression is evaluated to iterate through each of the
* parts of a message and then each part is then send to some endpoint.
* this splitter responds with the latest message returned from destination
* endpoint.
*
* @param receipients the expression on which to split
* @param parallelprocessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
* @return the builder
*/
public splittertype splitter expression receipients  boolean parallelprocessing
splittertype answer   new splittertype receipients
addoutput answer
answer setparallelprocessing parallelprocessing
return answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/splitter.html">splitter</a>
* pattern where an expression is evaluated to iterate through each of the
* parts of a message and then each part is then send to some endpoint.
* this splitter responds with the latest message returned from destination
* endpoint.
*
* @param parallelprocessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
* @return the expression clause for the expression on which to split
*/
public expressionclause<splittertype> splitter boolean parallelprocessing
splittertype answer   new splittertype
addoutput answer
answer setparallelprocessing parallelprocessing
return expressionclause createandsetexpression answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/splitter.html">splitter</a>
* pattern where an expression is evaluated to iterate through each of the
* parts of a message and then each part is then send to some endpoint.
* answer from the splitter is produced using given {@link aggregationstrategy}
* @param partsexpression the expression on which to split
* @param aggregationstrategy the strategy used to aggregate responses for
*          every part
* @param parallelprocessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
* @return the builder
*/
public splittertype splitter expression partsexpression
aggregationstrategy aggregationstrategy  boolean parallelprocessing
splittertype answer   new splittertype partsexpression
addoutput answer
answer setaggregationstrategy aggregationstrategy
answer setparallelprocessing parallelprocessing
return answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/splitter.html">splitter</a>
* pattern where an expression is evaluated to iterate through each of the
* parts of a message and then each part is then send to some endpoint.
* answer from the splitter is produced using given {@link aggregationstrategy}
* @param aggregationstrategy the strategy used to aggregate responses for
*          every part
* @param parallelprocessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
* @return the expression clause for the expression on which to split
*/
public expressionclause<splittertype> splitter aggregationstrategy aggregationstrategy  boolean parallelprocessing
splittertype answer   new splittertype
addoutput answer
answer setaggregationstrategy aggregationstrategy
answer setparallelprocessing parallelprocessing
return expressionclause createandsetexpression answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/resequencer.html">resequencer</a>
* pattern where a list of expressions are evaluated to be able to compare
* the message exchanges to reorder them. e.g. you may wish to sort by some
* headers
*
* @return the expression clause for the expressions on which to compare messages in order
*/
public expressionclause<resequencertype> resequencer
resequencertype answer   new resequencertype
addoutput answer
expressionclause<resequencertype> clause   new expressionclause<resequencertype> answer
answer expression clause
return clause
/**
* creates the <a
* href="http://activemq.apache.org/camel/resequencer.html">resequencer</a>
* pattern where an expression is evaluated to be able to compare the
* message exchanges to reorder them. e.g. you may wish to sort by some
* header
*
* @param expression the expression on which to compare messages in order
* @return the builder
*/
public resequencertype resequencer expression<exchange> expression
return resequencer collections <expression>singletonlist expression
/**
* creates the <a
* href="http://activemq.apache.org/camel/resequencer.html">resequencer</a>
* pattern where a list of expressions are evaluated to be able to compare
* the message exchanges to reorder them. e.g. you may wish to sort by some
* headers
*
* @param expressions the expressions on which to compare messages in order
* @return the builder
*/
public resequencertype resequencer list<expression> expressions
resequencertype answer   new resequencertype expressions
addoutput answer
return answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/resequencer.html">resequencer</a>
* pattern where a list of expressions are evaluated to be able to compare
* the message exchanges to reorder them. e.g. you may wish to sort by some
* headers
*
* @param expressions the expressions on which to compare messages in order
* @return the builder
*/
public resequencertype resequencer expression    expressions
list<expression> list   new arraylist<expression>
list addall arrays aslist expressions
return resequencer list
/**
* creates an <a
* href="http://activemq.apache.org/camel/aggregator.html">aggregator</a>
* pattern where a batch of messages are processed (up to a maximum amount
* or until some timeout is reached) and messages for the same correlation
* key are combined together using some kind of {@link aggregationstrategy}
* (by default the latest message is used) to compress many message exchanges
* into a smaller number of exchanges.
* <p/>
* a good example of this is stock market data; you may be receiving 30,000
* messages/second and you may want to throttle it right down so that multiple
* messages for the same stock are combined (or just the latest message is used
* and older prices are discarded). another idea is to combine line item messages
* together into a single invoice message.
*/
public expressionclause<aggregatortype> aggregator
aggregatortype answer   new aggregatortype
addoutput answer
return expressionclause createandsetexpression answer
/**
* creates an <a
* href="http://activemq.apache.org/camel/aggregator.html">aggregator</a>
* pattern where a batch of messages are processed (up to a maximum amount
* or until some timeout is reached) and messages for the same correlation
* key are combined together using some kind of {@link aggregationstrategy}
* (by default the latest message is used) to compress many message exchanges
* into a smaller number of exchanges.
* <p/>
* a good example of this is stock market data; you may be receiving 30,000
* messages/second and you may want to throttle it right down so that multiple
* messages for the same stock are combined (or just the latest message is used
* and older prices are discarded). another idea is to combine line item messages
* together into a single invoice message.
*
* @param aggregationstrategy the strategy used for the aggregation
*/
public expressionclause<aggregatortype> aggregator aggregationstrategy aggregationstrategy
aggregatortype answer   new aggregatortype
answer setaggregationstrategy aggregationstrategy
addoutput answer
return expressionclause createandsetexpression answer
/**
* creates an <a
* href="http://activemq.apache.org/camel/aggregator.html">aggregator</a>
* pattern using a custom aggregation collection implementation.
*
* @param aggregationcollection the collection used to perform the aggregation
*/
public expressionclause<aggregatortype> aggregator aggregationcollection aggregationcollection
aggregatortype answer   new aggregatortype
answer setaggregationcollection aggregationcollection
addoutput answer
return expressionclause createandsetexpression answer
/**
* creates an <a
* href="http://activemq.apache.org/camel/aggregator.html">aggregator</a>
* pattern where a batch of messages are processed (up to a maximum amount
* or until some timeout is reached) and messages for the same correlation
* key are combined together using some kind of {@link aggregationstrategy}
* (by default the latest message is used) to compress many message exchanges
* into a smaller number of exchanges.
* <p/>
* a good example of this is stock market data; you may be receiving 30,000
* messages/second and you may want to throttle it right down so that multiple
* messages for the same stock are combined (or just the latest message is used
* and older prices are discarded). another idea is to combine line item messages
* together into a single invoice message.
*
* @param correlationexpression the expression used to calculate the
*                              correlation key. for a jms message this could be the
*                              expression <code>header("jmsdestination")</code> or
*                              <code>header("jmscorrelationid")</code>
*/
public aggregatortype aggregator expression correlationexpression
aggregatortype answer   new aggregatortype correlationexpression
addoutput answer
return answer
/**
* creates an <a
* href="http://activemq.apache.org/camel/aggregator.html">aggregator</a>
* pattern where a batch of messages are processed (up to a maximum amount
* or until some timeout is reached) and messages for the same correlation
* key are combined together using some kind of {@link aggregationstrategy}
* (by default the latest message is used) to compress many message exchanges
* into a smaller number of exchanges.
* <p/>
* a good example of this is stock market data; you may be receiving 30,000
* messages/second and you may want to throttle it right down so that multiple
* messages for the same stock are combined (or just the latest message is used
* and older prices are discarded). another idea is to combine line item messages
* together into a single invoice message.
*
* @param correlationexpression the expression used to calculate the
*                              correlation key. for a jms message this could be the
*                              expression <code>header("jmsdestination")</code> or
*                              <code>header("jmscorrelationid")</code>
*/
public aggregatortype aggregator expression correlationexpression  aggregationstrategy aggregationstrategy
aggregatortype answer   new aggregatortype correlationexpression  aggregationstrategy
addoutput answer
return answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/delayer.html">delayer</a> pattern
* where an expression is used to calculate the time which the message will
* be dispatched on
*
* @param processatexpression an expression to calculate the time at which
*                            the messages should be processed
* @return the builder
*/
public delayertype delayer expression<exchange> processatexpression
return delayer processatexpression  0l
/**
* creates the <a
* href="http://activemq.apache.org/camel/delayer.html">delayer</a> pattern
* where an expression is used to calculate the time which the message will
* be dispatched on
*
* @param processatexpression an expression to calculate the time at which
*                            the messages should be processed
* @param delay               the delay in milliseconds which is added to the
*                            processatexpression to determine the time the message
*                            should be processed
* @return the builder
*/
public delayertype delayer expression<exchange> processatexpression  long delay
delayertype answer   new delayertype processatexpression  delay
addoutput answer
return answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/delayer.html">delayer</a> pattern
* where an expression is used to calculate the time which the message will
* be dispatched on
* @return the expression clause to create the expression
*/
public expressionclause<delayertype> delayer
delayertype answer   new delayertype
addoutput answer
return expressionclause createandsetexpression answer
/**
* creates the <a
* href="http://activemq.apache.org/camel/delayer.html">delayer</a> pattern
* where a fixed amount of milliseconds are used to delay processing of a
* message exchange
*
* @param delay the default delay in milliseconds
* @return the builder
*/
public delayertype delayer long delay
return delayer null  delay
/**
* creates the <a
* href="http://activemq.apache.org/camel/delayer.html">delayer</a> pattern
* where an expression is used to calculate the time which the message will
* be dispatched on
*
* @return the builder
*/
public throttlertype throttler long maximumrequestcount
throttlertype answer   new throttlertype maximumrequestcount
addoutput answer
return answer
public type throwfault throwable fault
throwfaulttype answer   new throwfaulttype
answer setfault fault
addoutput answer
return  type  this
public type throwfault string message
return throwfault new camelexception message
/**
* intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
*/
public type interceptor string ref
interceptorref interceptor   new interceptorref ref
intercept interceptor
return  type  this
/**
* intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
*/
public type intercept delegateprocessor interceptor
intercept new interceptorref interceptor
//lastinterceptor = interceptor;
return  type  this
/**
* intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
*/
public intercepttype intercept
intercepttype answer   new intercepttype
addoutput answer
return answer
/**
* intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
*/
public void intercept interceptortype interceptor
addoutput interceptor
pushblock interceptor
/**
* adds an interceptor around the whole of this nodes processing
*
* @param interceptor
*/
public void addinterceptor interceptortype interceptor
interceptors add interceptor
/**
* adds an interceptor around the whole of this nodes processing
*
* @param interceptor
*/
public void addinterceptor delegateprocessor interceptor
addinterceptor new interceptorref interceptor
protected void pushblock block block
blocks add block
protected block popblock
return blocks isempty   ? null   blocks removelast
public type proceed
proceedtype proceed   null
processortype currentprocessor   this
if  currentprocessor instanceof intercepttype
proceed     intercepttype  currentprocessor  getproceed
log info
if  proceed    null
for  processortype node   parent  node    null  node   node getparent
if  node instanceof intercepttype
intercepttype intercept    intercepttype node
proceed   intercept getproceed
break
if  proceed    null
throw new illegalargumentexception
addoutput proceed
return  type  this
public type stop
processortype currentprocessor   this
if  currentprocessor instanceof intercepttype
intercepttype  currentprocessor  stopintercept
else
processortype node
for  node   parent  node    null  node   node getparent
if  node instanceof intercepttype
intercepttype  node  stopintercept
break
if  node    null
throw new illegalargumentexception
return  type  this
public exceptiontype exception class exceptiontype
exceptiontype answer   new exceptiontype exceptiontype
addoutput answer
return answer
/**
* apply an interceptor route if the predicate is true
*/
public choicetype intercept predicate predicate
intercepttype answer   new intercepttype
addoutput answer
return answer when predicate
public type interceptors string    refs
for  string ref   refs
interceptor ref
return  type  this
/**
* trace logs the exchange before it goes to the next processing step using
* the {@link #default_trace_category} logging category.
*/
public type trace
return trace default_trace_category
/**
* trace logs the exchange before it goes to the next processing step using
* the specified logging category.
*
* @param category the logging category trace messages will sent to.
*/
public type trace string category
final log log   logfactory getlog category
return intercept new delegateprocessor
@override
public void process exchange exchange  throws exception
log trace exchange
processnext exchange
public policyref policies
policyref answer   new policyref
addoutput answer
return answer
public policyref policy policy policy
policyref answer   new policyref policy
addoutput answer
return answer
/**
* forces handling of faults as exceptions
*
* @return the current builder with the fault handler configured
*/
public type handlefault
intercept new handlefaulttype
return  type  this
/**
* installs the given error handler builder
*
* @param errorhandlerbuilder the error handler to be used by default for
*                            all child routes
* @return the current builder with the error handler configured
*/
public type errorhandler errorhandlerbuilder errorhandlerbuilder
seterrorhandlerbuilder errorhandlerbuilder
return  type  this
/**
* configures whether or not the error handler is inherited by every
* processing node (or just the top most one)
*
* @param condition the flag as to whether error handlers should be
*                  inherited or not
* @return the current builder
*/
public type inheriterrorhandler boolean condition
setinheriterrorhandlerflag condition
return  type  this
// transformers
// -------------------------------------------------------------------------
/**
* adds the custom processor to this destination which could be a final
* destination, or could be a transformation in a pipeline
*/
public type process processor processor
processorref answer   new processorref processor
addoutput answer
return  type  this
/**
* adds the custom processor reference to this destination which could be a final
* destination, or could be a transformation in a pipeline
*/
public type processref string ref
processorref answer   new processorref
answer setref ref
addoutput answer
return  type  this
/**
* adds a bean which is invoked which could be a final destination, or could
* be a transformation in a pipeline
*/
public type bean object bean
beanref answer   new beanref
answer setbean bean
addoutput answer
return  type  this
/**
* adds a bean and method which is invoked which could be a final
* destination, or could be a transformation in a pipeline
*/
public type bean object bean  string method
beanref answer   new beanref
answer setbean bean
answer setmethod method
addoutput answer
return  type  this
/**
* adds a bean by type which is invoked which could be a final destination, or could
* be a transformation in a pipeline
*/
public type bean class beantype
beanref answer   new beanref
answer setbeantype beantype
addoutput answer
return  type  this
/**
* adds a bean type and method which is invoked which could be a final
* destination, or could be a transformation in a pipeline
*/
public type bean class beantype  string method
beanref answer   new beanref
answer setbeantype beantype
answer setmethod method
addoutput answer
return  type  this
/**
* adds a bean which is invoked which could be a final destination, or could
* be a transformation in a pipeline
*/
public type beanref string ref
beanref answer   new beanref ref
addoutput answer
return  type  this
/**
* adds a bean and method which is invoked which could be a final
* destination, or could be a transformation in a pipeline
*/
public type beanref string ref  string method
beanref answer   new beanref ref  method
addoutput answer
return  type  this
/**
* adds a processor which sets the body on the in message
*/
public expressionclause<processortype<type>> setbody
expressionclause<processortype<type>> clause   new expressionclause<processortype<type>>  type  this
setbodytype answer   new setbodytype clause
addoutput answer
return clause
/**
* adds a processor which sets the body on the in message
*/
public type setbody expression expression
setbodytype answer   new setbodytype expression
addoutput answer
return  type  this
/**
* adds a processor which sets the body on the out message
*
* @deprecated please use {@link #transform(expression)} instead. will be removed in camel 2.0.
*/
@deprecated
public type setoutbody expression expression
return transform expression
/**
* adds a processor which sets the body on the out message
*
* @deprecated please use {@link #transform()} instead. will be removed in camel 2.0.
*/
@deprecated
public expressionclause<processortype<type>> setoutbody
return transform
/**
* adds a processor which sets the body on the out message
*/
public type transform expression expression
transformtype answer   new transformtype expression
addoutput answer
return  type  this
/**
* adds a processor which sets the body on the out message
*/
public expressionclause<processortype<type>> transform
expressionclause<processortype<type>> clause   new expressionclause<processortype<type>>  type  this
transformtype answer   new transformtype clause
addoutput answer
return clause
/**
* adds a processor which sets the body on the fault message
*/
public type setfaultbody expression expression
return process processorbuilder setfaultbody expression
/**
* adds a processor which sets the header on the in message
*/
public expressionclause<processortype<type>> setheader string name
expressionclause<processortype<type>> clause   new expressionclause<processortype<type>>  type  this
setheadertype answer   new setheadertype name  clause
addoutput answer
return clause
/**
* adds a processor which sets the header on the in message
*/
public type setheader string name  expression expression
setheadertype answer   new setheadertype name  expression
addoutput answer
return  type  this
/**
* adds a processor which sets the header on the in message to the given value
*/
public type setheader string name  string value
setheadertype answer   new setheadertype name  value
addoutput answer
return  type  this
/**
* adds a processor which sets the header on the out message
*/
public expressionclause<processortype<type>> setoutheader string name
expressionclause<processortype<type>> clause   new expressionclause<processortype<type>>  type  this
process processorbuilder setoutheader name  clause
return clause
/**
* adds a processor which sets the header on the out message
*/
public type setoutheader string name  expression expression
return process processorbuilder setoutheader name  expression
/**
* adds a processor which sets the header on the out message
*/
public type setoutheader string name  string value
return  type  setoutheader name  constant value
/**
* adds a processor which sets the header on the fault message
*/
public type setfaultheader string name  expression expression
return process processorbuilder setfaultheader name  expression
/**
* adds a processor which sets the exchange property
*/
public type setproperty string name  expression expression
return process processorbuilder setproperty name  expression
/**
* adds a processor which sets the exchange property
*/
public expressionclause<processortype<type>> setproperty string name
expressionclause<processortype<type>> clause   new expressionclause<processortype<type>>  type  this
process processorbuilder setproperty name  clause
return clause
/**
* adds a processor which removes the header on the in message
*/
public type removeheader string name
return process processorbuilder removeheader name
/**
* adds a processor which removes the header on the out message
*/
public type removeoutheader string name
return process processorbuilder removeoutheader name
/**
* adds a processor which removes the header on the fault message
*/
public type removefaultheader string name
return process processorbuilder removefaultheader name
/**
* adds a processor which removes the exchange property
*/
public type removeproperty string name
return process processorbuilder removeproperty name
/**
* converts the in message body to the specified type
*/
public type convertbodyto class type
addoutput new convertbodytype type
return  type  this
/**
* converts the out message body to the specified type
*
* @deprecated please use {@link #convertbodyto(class)} instead. will be removed in camel 2.0.
*/
@deprecated
public type convertoutbodyto class type
return process new convertbodyprocessor type
/**
* converts the fault message body to the specified type
*
* @deprecated please use {@link #convertbodyto(class)} instead. will be removed in camel 2.0.
*/
@deprecated
public type convertfaultbodyto class type
return process new convertbodyprocessor type
// dataformat support
// -------------------------------------------------------------------------
/**
* unmarshals the in body using a {@link dataformat} expression to define
* the format of the input message and the output will be set on the out message body.
*
* @return the expression to create the {@link dataformat}
*/
public dataformatclause<processortype<type>> unmarshal
return new dataformatclause<processortype<type>> this  dataformatclause operation unmarshal
/**
* unmarshals the in body using the specified {@link dataformat}
* and sets the output on the out message body.
*
* @return this object
*/
public type unmarshal dataformattype dataformattype
addoutput new unmarshaltype dataformattype
return  type  this
/**
* unmarshals the in body using the specified {@link dataformat}
* and sets the output on the out message body.
*
* @return this object
*/
public type unmarshal dataformat dataformat
return unmarshal new dataformattype dataformat
/**
* unmarshals the in body using the specified {@link dataformat}
* reference in the {@link registry} and sets the output on the out message body.
*
* @return this object
*/
public type unmarshal string datatyperef
addoutput new unmarshaltype datatyperef
return  type  this
/**
* marshals the in body using a {@link dataformat} expression to define
* the format of the output which will be added to the out body.
*
* @return the expression to create the {@link dataformat}
*/
public dataformatclause<processortype<type>> marshal
return new dataformatclause<processortype<type>> this  dataformatclause operation marshal
/**
* marshals the in body using the specified {@link dataformat}
* and sets the output on the out message body.
*
* @return this object
*/
public type marshal dataformattype dataformattype
addoutput new marshaltype dataformattype
return  type  this
/**
* marshals the in body using the specified {@link dataformat}
* and sets the output on the out message body.
*
* @return this object
*/
public type marshal dataformat dataformat
return marshal new dataformattype dataformat
/**
* marshals the in body the specified {@link dataformat}
* reference in the {@link registry} and sets the output on the out message body.
*
* @return this object
*/
public type marshal string datatyperef
addoutput new marshaltype datatyperef
return  type  this
// properties
// -------------------------------------------------------------------------
@xmltransient
public processortype<? extends processortype> getparent
return parent
public void setparent processortype<? extends processortype> parent
this parent   parent
@xmltransient
public errorhandlerbuilder geterrorhandlerbuilder
if  errorhandlerbuilder    null
errorhandlerbuilder   createerrorhandlerbuilder
return errorhandlerbuilder
/**
* sets the error handler to use with processors created by this builder
*/
public void seterrorhandlerbuilder errorhandlerbuilder errorhandlerbuilder
this errorhandlerbuilder   errorhandlerbuilder
/**
* sets the error handler if one is not already set
*/
protected void seterrorhandlerbuilderifnull errorhandlerbuilder errorhandlerbuilder
if  this errorhandlerbuilder    null
seterrorhandlerbuilder errorhandlerbuilder
public string geterrorhandlerref
return errorhandlerref
/**
* sets the bean ref name of the error handler builder to use on this route
*/
@xmlattribute required   false
public void seterrorhandlerref string errorhandlerref
this errorhandlerref   errorhandlerref
seterrorhandlerbuilder new errorhandlerbuilderref errorhandlerref
@xmltransient
public boolean isinheriterrorhandler
return isinheriterrorhandler getinheriterrorhandlerflag
/**
* lets default the inherit value to be true if there is none specified
*/
public static boolean isinheriterrorhandler boolean value
return value    null    value booleanvalue
@xmlattribute name      required   false
public boolean getinheriterrorhandlerflag
return inheriterrorhandlerflag
public void setinheriterrorhandlerflag boolean inheriterrorhandlerflag
this inheriterrorhandlerflag   inheriterrorhandlerflag
@xmltransient
public nodefactory getnodefactory
if  nodefactory    null
nodefactory   new nodefactory
return nodefactory
public void setnodefactory nodefactory nodefactory
this nodefactory   nodefactory
/**
* returns a label to describe this node such as the expression if some kind of expression node
*/
public string getlabel
return
// implementation methods
// -------------------------------------------------------------------------
/**
* creates the processor and wraps it in any necessary interceptors and
* error handlers
*/
protected processor makeprocessor routecontext routecontext  throws exception
processor processor   createprocessor routecontext
return wrapprocessor routecontext  processor
/**
* a strategy method which allows derived classes to wrap the child
* processor in some kind of interceptor
*
* @param routecontext
* @param target       the processor which can be wrapped
* @return the original processor or a new wrapped interceptor
*/
protected processor wrapprocessorininterceptors routecontext routecontext  processor target  throws exception
// the target is required.
if  target    null
throw new runtimecamelexception
list<interceptstrategy> strategies   new arraylist<interceptstrategy>
camelcontext camelcontext   routecontext getcamelcontext
if  camelcontext instanceof defaultcamelcontext
defaultcamelcontext defaultcamelcontext    defaultcamelcontext  camelcontext
strategies addall defaultcamelcontext getinterceptstrategies
strategies addall routecontext getinterceptstrategies
for  interceptstrategy strategy   strategies
if  strategy    null
target   strategy wrapprocessorininterceptors this  target
list<interceptortype> list   routecontext getroute   getinterceptors
if  interceptors    null
list addall interceptors
// lets reverse the list so we apply the inner interceptors first
collections reverse list
set<processor> interceptors   new hashset<processor>
interceptors add target
for  interceptortype interceptortype   list
delegateprocessor interceptor   interceptortype createinterceptor routecontext
if   interceptors contains interceptor
interceptors add interceptor
if  interceptor getprocessor      null
log warn     interceptor
interceptor getprocessor
target
else
interceptor setprocessor target
target   interceptor
return target
/**
* a strategy method to allow newly created processors to be wrapped in an
* error handler.
*/
protected processor wrapinerrorhandler routecontext routecontext  processor target  throws exception
// the target is required.
if  target    null
throw new runtimecamelexception
errorhandlerwrappingstrategy strategy   routecontext geterrorhandlerwrappingstrategy
if  strategy    null
return strategy wrapprocessorinerrorhandler routecontext  this  target
return geterrorhandlerbuilder   createerrorhandler routecontext  target
protected errorhandlerbuilder createerrorhandlerbuilder
if  errorhandlerref    null
return new errorhandlerbuilderref errorhandlerref
if  isinheriterrorhandler
return new deadletterchannelbuilder
else
return new noerrorhandlerbuilder
protected void configurechild processortype output
output setnodefactory getnodefactory
public void addoutput processortype processortype
processortype setparent this
configurechild processortype
if  blocks isempty
getoutputs   add processortype
else
block block   blocks getlast
block addoutput processortype
/**
* creates a new instance of some kind of composite processor which defaults
* to using a {@link pipeline} but derived classes could change the
* behaviour
*/
protected processor createcompositeprocessor list<processor> list
// return new multicastprocessor(list);
return new pipeline list
protected processor createoutputsprocessor routecontext routecontext  collection<processortype<?>> outputs
throws exception
list<processor> list   new arraylist<processor>
for  processortype output   outputs
processor processor   output createprocessor routecontext
processor   output wrapprocessorininterceptors routecontext  processor
processortype currentprocessor   this
if    currentprocessor instanceof exceptiontype    currentprocessor instanceof trytype
processor   output wrapinerrorhandler routecontext  processor
list add processor
processor processor   null
if   list isempty
if  list size      1
processor   list get 0
else
processor   createcompositeprocessor list
return processor
public void clearoutput
getoutputs   clear
blocks clear