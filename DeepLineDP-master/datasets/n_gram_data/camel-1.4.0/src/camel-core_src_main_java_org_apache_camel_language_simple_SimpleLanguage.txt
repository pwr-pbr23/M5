/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel language simple
import java util arraylist
import java util list
import org apache camel exchange
import org apache camel expression
import org apache camel predicate
import org apache camel builder expressionbuilder
import org apache camel builder predicatebuilder
import org apache camel language illegalsyntaxexception
import org apache camel spi language
import org apache camel util objecthelper
/**
* a <a href="http://activemq.apache.org/camel/simple.html">simple language</a>
* which maps simple property style notations to access headers and bodies.
* examples of supported expressions are <p/>
* <ul>
* <li>in.header.foo or header.foo to access an inbound header called 'foo'</li>
* <li>in.body or body to access the inbound body</li>
* <li>out.header.foo to access an outbound header called 'foo'</li>
* <li>out.body to access the inbound body</li>
* <li>property.foo to access the exchange property called 'foo'</li>
* <li>sys.foo to access the system property called 'foo'</li>
* </ul>
*
* @version $revision$
*/
public class simplelanguage implements language
public static expression simple string expression
simplelanguage language   new simplelanguage
return language createexpression expression
public predicate<exchange> createpredicate string expression
return predicatebuilder topredicate createexpression expression
public expression<exchange> createexpression string expression
if  expression indexof    >  0
return createcomplexexpression expression
return createsimpleexpression expression
protected expression<exchange> createcomplexexpression string expression
list<expression> results   new arraylist<expression>
int pivot   0
int size   expression length
while  pivot < size
int idx   expression indexof    pivot
if  idx < 0
results add createconstantexpression expression  pivot  size
break
else
if  pivot < idx
results add createconstantexpression expression  pivot  idx
pivot   idx   2
int endidx   expression indexof    pivot
if  endidx < 0
throw new illegalargumentexception     expression
string simpletext   expression substring pivot  endidx
expression simpleexpression   createsimpleexpression simpletext
results add simpleexpression
pivot   endidx   1
return expressionbuilder concatexpression results  expression
protected expression createconstantexpression string expression  int start  int end
return expressionbuilder constantexpression expression substring start  end
protected expression<exchange> createsimpleexpression string expression
if  objecthelper isequaltoany expression
return expressionbuilder bodyexpression
else if  objecthelper equal expression
return expressionbuilder outbodyexpression
// in header expression
string remainder   ifstartswithreturnremainder    expression
if  remainder    null
remainder   ifstartswithreturnremainder    expression
if  remainder    null
remainder   ifstartswithreturnremainder    expression
if  remainder    null
remainder   ifstartswithreturnremainder    expression
if  remainder    null
return expressionbuilder headerexpression remainder
// out header expression
remainder   ifstartswithreturnremainder    expression
if  remainder    null
remainder   ifstartswithreturnremainder    expression
if  remainder    null
return expressionbuilder outheaderexpression remainder
// property
remainder   ifstartswithreturnremainder    expression
if  remainder    null
return expressionbuilder propertyexpression remainder
// system property
remainder   ifstartswithreturnremainder    expression
if  remainder    null
return expressionbuilder propertyexpression remainder
throw new illegalsyntaxexception this  expression
protected string ifstartswithreturnremainder string prefix  string text
if  text startswith prefix
string remainder   text substring prefix length
if  remainder length   > 0
return remainder
return null