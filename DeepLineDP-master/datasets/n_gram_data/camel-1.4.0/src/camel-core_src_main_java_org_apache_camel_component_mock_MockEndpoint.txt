/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component mock
import java beans propertychangelistener
import java beans propertychangesupport
import java util arraylist
import java util arrays
import java util collection
import java util hashmap
import java util list
import java util map
import java util concurrent copyonwritearraylist
import java util concurrent countdownlatch
import java util concurrent timeunit
import org apache camel camelcontext
import org apache camel component
import org apache camel consumer
import org apache camel endpoint
import org apache camel exchange
import org apache camel expression
import org apache camel message
import org apache camel processor
import org apache camel producer
import org apache camel impl defaultendpoint
import org apache camel impl defaultproducer
import org apache camel spi browsableendpoint
import org apache camel util camelcontexthelper
import org apache camel util expressioncomparator
import org apache camel util objecthelper
import org apache commons logging log
import org apache commons logging logfactory
/**
* a mock endpoint which provides a literate, fluent api for testing routes
* using a <a href="http://jmock.org/">jmock style</a> api.
*
* @version $revision$
*/
public class mockendpoint extends defaultendpoint<exchange> implements browsableendpoint<exchange>
private static final transient log log   logfactory getlog mockendpoint class
private int expectedcount
private int counter
private processor defaultprocessor
private map<integer  processor> processors
private list<exchange> receivedexchanges
private list<throwable> failures
private list<runnable> tests
private countdownlatch latch
private long sleepforemptytest
private long resultwaittime
private int expectedminimumcount
private list expectedbodyvalues
private list actualbodyvalues
private propertychangesupport propertychangesupport   new propertychangesupport this
private string headername
private string headervalue
private object actualheader
private processor reporter
public mockendpoint string endpointuri  component component
super endpointuri  component
init
public mockendpoint string endpointuri
super endpointuri
init
/**
* a helper method to resolve the mock endpoint of the given uri on the given context
*
* @param context the camel context to try resolve the mock endpoint from
* @param uri the uri of the endpoint to resolve
* @return the endpoint
*/
public static mockendpoint resolve camelcontext context  string uri
return camelcontexthelper getmandatoryendpoint context  uri  mockendpoint class
public static void assertwait long timeout  timeunit unit  mockendpoint    endpoints  throws interruptedexception
long start   system currenttimemillis
long left   unit tomillis timeout
long end   start   left
for  mockendpoint endpoint   endpoints
if   endpoint await left  timeunit milliseconds
throw new assertionerror     endpoint getendpointuri
left   end   system currenttimemillis
if  left <  0
left   0
public static void assertissatisfied long timeout  timeunit unit  mockendpoint    endpoints  throws interruptedexception
assertwait timeout  unit  endpoints
for  mockendpoint endpoint   endpoints
endpoint assertissatisfied
public static void assertissatisfied mockendpoint    endpoints  throws interruptedexception
for  mockendpoint endpoint   endpoints
endpoint assertissatisfied
/**
* asserts that all the expectations on any {@link mockendpoint} instances registered
* in the given context are valid
*
* @param context the camel context used to find all the available endpoints to be asserted
*/
public static void assertissatisfied camelcontext context  throws interruptedexception
objecthelper notnull context
collection<endpoint> endpoints   context getsingletonendpoints
for  endpoint endpoint   endpoints
if  endpoint instanceof mockendpoint
mockendpoint mockendpoint    mockendpoint  endpoint
mockendpoint assertissatisfied
public static void expectsmessagecount int count  mockendpoint    endpoints  throws interruptedexception
for  mockendpoint endpoint   endpoints
mockendpoint expectsmessagecount count
public list<exchange> getexchanges
return getreceivedexchanges
public void addpropertychangelistener propertychangelistener listener
propertychangesupport addpropertychangelistener listener
public void removepropertychangelistener propertychangelistener listener
propertychangesupport removepropertychangelistener listener
public consumer<exchange> createconsumer processor processor  throws exception
throw new unsupportedoperationexception
public producer<exchange> createproducer   throws exception
return new defaultproducer<exchange> this
public void process exchange exchange
onexchange exchange
public void reset
init
// testing api
// -------------------------------------------------------------------------
/**
* set the processor that will be invoked when the index
* message is received.
*
* @param index
* @param processor
*/
public void whenexchangereceived int index  processor processor
this processors put index  processor
/**
* set the processor that will be invoked when the some message
* is received.
*
* this processor could be overwritten by
* {@link #whenexchangereceived(int, processor)} method.
*
* @param processor
*/
public void whenanyexchangereceived processor processor
this defaultprocessor   processor
/**
* validates that all the available expectations on this endpoint are
* satisfied; or throw an exception
*/
public void assertissatisfied   throws interruptedexception
assertissatisfied sleepforemptytest
/**
* validates that all the available expectations on this endpoint are
* satisfied; or throw an exception
*
* @param timeoutforemptyendpoints the timeout in milliseconds that we
*                should wait for the test to be true
*/
public void assertissatisfied long timeoutforemptyendpoints  throws interruptedexception
log info     this
if  expectedcount >  0
if  expectedcount    getreceivedcounter
if  expectedcount    0
// lets wait a little bit just in case
if  timeoutforemptyendpoints > 0
log debug     timeoutforemptyendpoints
thread sleep timeoutforemptyendpoints
else
waitforcompletelatch
assertequals    expectedcount  getreceivedcounter
else if  expectedminimumcount > 0    getreceivedcounter   < expectedminimumcount
waitforcompletelatch
if  expectedminimumcount >  0
int receivedcounter   getreceivedcounter
asserttrue     receivedcounter       expectedcount  expectedcount <  receivedcounter
for  runnable test   tests
test run
for  throwable failure   failures
if  failure    null
log error     getendpointuri         failure  failure
fail     failure
/**
* validates that the assertions fail on this endpoint
*/
public void assertisnotsatisfied   throws interruptedexception
try
assertissatisfied
fail
catch  assertionerror e
log info     e
/**
* specifies the expected number of message exchanges that should be
* received by this endpoint
*
* @param expectedcount the number of message exchanges that should be
*                expected by this endpoint
*/
public void expectedmessagecount int expectedcount
setexpectedmessagecount expectedcount
/**
* specifies the minimum number of expected message exchanges that should be
* received by this endpoint
*
* @param expectedcount the number of message exchanges that should be
*                expected by this endpoint
*/
public void expectedminimummessagecount int expectedcount
setminimumexpectedmessagecount expectedcount
/**
* adds an expectation that the given header name & value are received by this
* endpoint
*/
public void expectedheaderreceived string name  string value
this headername   name
this headervalue   value
expects new runnable
public void run
asserttrue     headername      actualheader    null
assertequals    headervalue  actualheader
/**
* adds an expectation that the given body values are received by this
* endpoint
*/
public void expectedbodiesreceived final list bodies
expectedmessagecount bodies size
this expectedbodyvalues   bodies
this actualbodyvalues   new arraylist
expects new runnable
public void run
for  int i   0  i < expectedbodyvalues size    i
exchange exchange   getreceivedexchanges   get i
asserttrue     i  exchange    null
object expectedbody   expectedbodyvalues get i
object actualbody   actualbodyvalues get i
assertequals     i  expectedbody  actualbody
/**
* adds an expectation that the given body values are received by this
* endpoint
*/
public void expectedbodiesreceived object    bodies
list bodylist   new arraylist
bodylist addall arrays aslist bodies
expectedbodiesreceived bodylist
/**
* adds an expectation that messages received should have ascending values
* of the given expression such as a user generated counter value
*
* @param expression
*/
public void expectsascending final expression<exchange> expression
expects new runnable
public void run
assertmessagesascending expression
/**
* adds an expectation that messages received should have descending values
* of the given expression such as a user generated counter value
*
* @param expression
*/
public void expectsdescending final expression<exchange> expression
expects new runnable
public void run
assertmessagesdescending expression
/**
* adds an expectation that no duplicate messages should be received using
* the expression to determine the message id
*
* @param expression the expression used to create a unique message id for
*                message comparison (which could just be the message
*                payload if the payload can be tested for uniqueness using
*                {@link object#equals(object)} and
*                {@link object#hashcode()}
*/
public void expectsnoduplicates final expression<exchange> expression
expects new runnable
public void run
assertnoduplicates expression
/**
* asserts that the messages have ascending values of the given expression
*/
public void assertmessagesascending expression<exchange> expression
assertmessagessorted expression  true
/**
* asserts that the messages have descending values of the given expression
*/
public void assertmessagesdescending expression<exchange> expression
assertmessagessorted expression  false
protected void assertmessagessorted expression<exchange> expression  boolean ascending
string type   ascending ?
expressioncomparator comparator   new expressioncomparator expression
list<exchange> list   getreceivedexchanges
for  int i   1  i < list size    i
int j   i   1
exchange e1   list get j
exchange e2   list get i
int result   comparator compare e1  e2
if  result    0
fail     type       j       i       expression evaluate e1        expression       e1
e2
else
if   ascending
result   result    1
if  result > 0
fail     type       j       expression evaluate e1        i       expression evaluate e2
expression       e1       e2
public void assertnoduplicates expression<exchange> expression
map<object  exchange> map   new hashmap<object  exchange>
list<exchange> list   getreceivedexchanges
for  int i   0  i < list size    i
exchange e2   list get i
object key   expression evaluate e2
exchange e1   map get key
if  e1    null
fail     i       key       expression       e1       e2
else
map put key  e2
/**
* adds the expection which will be invoked when enough messages are
* received
*/
public void expects runnable runnable
tests add runnable
/**
* adds an assertion to the given message index
*
* @param messageindex the number of the message
* @return the assertion clause
*/
public assertionclause message final int messageindex
assertionclause clause   new assertionclause
public void run
applyassertionon mockendpoint this  messageindex  assertexchangereceived messageindex
expects clause
return clause
/**
* adds an assertion to all the received messages
*
* @return the assertion clause
*/
public assertionclause allmessages
assertionclause clause   new assertionclause
public void run
list<exchange> list   getreceivedexchanges
int index   0
for  exchange exchange   list
applyassertionon mockendpoint this  index    exchange
expects clause
return clause
/**
* asserts that the given index of message is received (starting at zero)
*/
public exchange assertexchangereceived int index
int count   getreceivedcounter
asserttrue     count  count > index
return getreceivedexchanges   get index
// properties
// -------------------------------------------------------------------------
public list<throwable> getfailures
return failures
public int getreceivedcounter
return getreceivedexchanges   size
public list<exchange> getreceivedexchanges
return receivedexchanges
public int getexpectedcount
return expectedcount
public long getsleepforemptytest
return sleepforemptytest
/**
* allows a sleep to be specified to wait to check that this endpoint really
* is empty when {@link #expectedmessagecount(int)} is called with zero
*
* @param sleepforemptytest the milliseconds to sleep for to determine that
*                this endpoint really is empty
*/
public void setsleepforemptytest long sleepforemptytest
this sleepforemptytest   sleepforemptytest
public long getresultwaittime
return resultwaittime
/**
* sets the maximum amount of time (in millis) the {@link #assertissatisfied()} will
* wait on a latch until it is satisfied
*/
public void setresultwaittime long resultwaittime
this resultwaittime   resultwaittime
/**
* specifies the expected number of message exchanges that should be
* received by this endpoint
*
* @param expectedcount the number of message exchanges that should be
*                expected by this endpoint
*/
public void setexpectedmessagecount int expectedcount
this expectedcount   expectedcount
if  expectedcount <  0
latch   null
else
latch   new countdownlatch expectedcount
/**
* specifies the minimum number of expected message exchanges that should be
* received by this endpoint
*
* @param expectedcount the number of message exchanges that should be
*                expected by this endpoint
*/
public void setminimumexpectedmessagecount int expectedcount
this expectedminimumcount   expectedcount
if  expectedcount <  0
latch   null
else
latch   new countdownlatch expectedminimumcount
public processor getreporter
return reporter
/**
* allows a processor to added to the endpoint to report on progress of the test
*/
public void setreporter processor reporter
this reporter   reporter
// implementation methods
// -------------------------------------------------------------------------
private void init
expectedcount    1
counter   0
processors   new hashmap<integer  processor>
receivedexchanges   new copyonwritearraylist<exchange>
failures   new copyonwritearraylist<throwable>
tests   new copyonwritearraylist<runnable>
latch   null
sleepforemptytest   1000l
resultwaittime   20000l
expectedminimumcount    1
expectedbodyvalues   null
actualbodyvalues   new arraylist
protected synchronized void onexchange exchange exchange
try
if  reporter    null
reporter process exchange
performassertions exchange
catch  throwable e
failures add e
if  latch    null
latch countdown
protected void performassertions exchange exchange  throws exception
message in   exchange getin
object actualbody   in getbody
if  headername    null
actualheader   in getheader headername
if  expectedbodyvalues    null
int index   actualbodyvalues size
if  expectedbodyvalues size   > index
object expectedbody   expectedbodyvalues get index
if  expectedbody    null
actualbody   in getbody expectedbody getclass
actualbodyvalues add actualbody
log debug getendpointuri            counter        exchange       actualbody
receivedexchanges add exchange
processor processor   processors get getreceivedcounter       null
? processors get getreceivedcounter      defaultprocessor
if  processor    null
processor process exchange
protected void waitforcompletelatch   throws interruptedexception
if  latch    null
fail
// now lets wait for the results
log debug     resultwaittime
latch await resultwaittime  timeunit milliseconds
protected void assertequals string message  object expectedvalue  object actualvalue
if   objecthelper equal expectedvalue  actualvalue
fail message       expectedvalue       actualvalue
protected void asserttrue string message  boolean predicate
if   predicate
fail message
protected void fail object message
if  log isdebugenabled
list<exchange> list   getreceivedexchanges
int index   0
for  exchange exchange   list
log debug        index        exchange
throw new assertionerror getendpointuri         message
public int getexpectedminimumcount
return expectedminimumcount
public void await   throws interruptedexception
if  latch    null
latch await
public boolean await long timeout  timeunit unit  throws interruptedexception
if  latch    null
return latch await timeout  unit
return true
public boolean issingleton
return true