/*
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase hserveraddress
import org apache hadoop hbase util bytes
import org apache hadoop io writable
import java io datainput
import java io dataoutput
import java io ioexception
import java util arraylist
import java util collection
import java util hashmap
import java util iterator
import java util list
import java util map
import java util set
import java util treemap
import java util treeset
/**
* @deprecated use multiaction instead
* data type class for putting multiple regions worth of puts in one rpc.
*/
public class multiput extends operation implements writable
public hserveraddress address     client code only
// todo make this configurable
public static final int default_max_put_output   10
// map of regions to lists of puts for that region.
public map<byte  list<put> > puts   new treemap<byte  list<put>> bytes bytes_comparator
/**
* writable constructor only.
*/
public multiput
/**
* multiput for putting multiple regions worth of puts in one rpc.
* @param a address
*/
public multiput hserveraddress a
address   a
public int size
int size   0
for  list<put> l   puts values
size    l size
return size
public void add byte regionname  put aput
list<put> rsput   puts get regionname
if  rsput    null
rsput   new arraylist<put>
puts put regionname  rsput
rsput add aput
public collection<put> allputs
list<put> res   new arraylist<put>
for   list<put> pp   puts values
res addall pp
return res
/**
* compile the table and column family (i.e. schema) information
* into a string. useful for parsing and aggregation by debugging,
* logging, and administration tools.
* @return map
*/
@override
public map<string  object> getfingerprint
map<string  object> map   new hashmap<string  object>
// for extensibility, we have a map of table information that we will
// populate with only family information for each table
map<string  map> tableinfo
new hashmap<string  map>
map put    tableinfo
for  map entry<byte  list<put>> entry   puts entryset
// our fingerprint only concerns itself with which families are touched,
// not how many puts touch them, so we use this set to do just that.
set<string> familyset
try
// since the puts are stored by region, we may have already
// recorded families for this region. if that is the case,
// we want to add to the existing set. if not, we make a new set.
string tablename   bytes tostringbinary
hregioninfo parseregionname entry getkey
if  tableinfo get tablename     null
map<string  object> table   new hashmap<string  object>
familyset   new treeset<string>
table put    familyset
tableinfo put tablename  table
else
familyset    set<string>  tableinfo get tablename  get
catch  ioexception ioe
// in the case of parse error, default to labeling by region
map<string  object> table   new hashmap<string  object>
familyset   new treeset<string>
table put    familyset
tableinfo put bytes tostringbinary entry getkey     table
// we now iterate through each put and keep track of which families
// are affected in this table.
for  put p   entry getvalue
for  byte fam   p getfamilymap   keyset
familyset add bytes tostringbinary fam
return map
/**
* compile the details beyond the scope of getfingerprint (mostly
* tomap from the puts) into a map along with the fingerprinted
* information. useful for debugging, logging, and administration tools.
* @param maxcols a limit on the number of columns output prior to truncation
* @return map
*/
@override
public map<string  object> tomap int maxcols
map<string  object> map   getfingerprint
map<string  object> tableinfo    map<string  object>  map get
int putcount   0
for  map entry<byte  list<put>> entry   puts entryset
// if the limit has been hit for put output, just adjust our counter
if  putcount >  default_max_put_output
putcount    entry getvalue   size
continue
list<put> regionputs   entry getvalue
list<map<string  object>> putsummaries
new arraylist<map<string  object>>
// find out how many of this region's puts we can add without busting
// the maximum
int regionputstoadd   regionputs size
putcount    regionputstoadd
if  putcount > default_max_put_output
regionputstoadd    putcount   default_max_put_output
for  iterator<put> iter   regionputs iterator    regionputstoadd   > 0
putsummaries add iter next   tomap maxcols
// attempt to extract the table name from the region name
string tablename
try
tablename   bytes tostringbinary
hregioninfo parseregionname entry getkey
catch  ioexception ioe
// in the case of parse error, default to labeling by region
tablename   bytes tostringbinary entry getkey
// since the puts are stored by region, we may have already
// recorded puts for this table. if that is the case,
// we want to add to the existing list. if not, we place a new list
// in the map
map<string  object> table
map<string  object>  tableinfo get tablename
if  table    null
// in case the put has changed since getfingerprint's map was built
table   new hashmap<string  object>
tableinfo put tablename  table
table put    putsummaries
else if  table get       null
table put    putsummaries
else
list<map<string  object>>  table get     addall putsummaries
map put    putcount
return map
@override
public void write dataoutput out  throws ioexception
out writeint puts size
for  map entry<byte list<put>> e   puts entryset
bytes writebytearray out  e getkey
list<put> ps   e getvalue
out writeint ps size
for  put p   ps
p write out
@override
public void readfields datainput in  throws ioexception
puts clear
int mapsize   in readint
for  int i   0   i < mapsize  i
byte key   bytes readbytearray in
int listsize   in readint
list<put> ps   new arraylist<put> listsize
for   int j   0   j < listsize  j
put put   new put
put readfields in
ps add put
puts put key  ps