/**
* copyright 2009 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase
import java io datainput
import java io dataoutput
import java io ioexception
import java util arraylist
import java util arrays
import java util collection
import java util collections
import java util hashmap
import java util map
import java util treemap
import org apache hadoop hbase master assignmentmanager regionstate
import org apache hadoop hbase util bytes
import org apache hadoop io versionmismatchexception
import org apache hadoop io versionedwritable
/**
* status information on the hbase cluster.
* <p>
* <tt>clusterstatus</tt> provides clients with information such as:
* <ul>
* <li>the count and names of region servers in the cluster.</li>
* <li>the count and names of dead region servers in the cluster.</li>
* <li>the name of the active master for the cluster.</li>
* <li>the name(s) of the backup master(s) for the cluster, if they exist.</li>
* <li>the average cluster load.</li>
* <li>the number of regions deployed on the cluster.</li>
* <li>the number of requests since last report.</li>
* <li>detailed region server loading and resource usage information,
*  per server and per region.</li>
* <li>regions in transition at master</li>
* <li>the unique cluster id</li>
* </ul>
*/
public class clusterstatus extends versionedwritable
/**
* version for object serialization.  incremented for changes in serialized
* representation.
* <dl>
*   <dt>0</dt> <dd>initial version</dd>
*   <dt>1</dt> <dd>added cluster id</dd>
*   <dt>2</dt> <dd>added map of servername to serverload</dd>
*   <dt>3</dt> <dd>added master and backupmasters</dd>
* </dl>
*/
private static final byte version_master_backupmasters   2
private static final byte version   2
private string hbaseversion
private map<servername  hserverload> liveservers
private collection<servername> deadservers
private servername master
private collection<servername> backupmasters
private map<string  regionstate> intransition
private string clusterid
private string mastercoprocessors
/**
* constructor, for writable
*/
public clusterstatus
super
public clusterstatus final string hbaseversion  final string clusterid
final map<servername  hserverload> servers
final collection<servername> deadservers
final servername master
final collection<servername> backupmasters
final map<string  regionstate> rit
final string mastercoprocessors
this hbaseversion   hbaseversion
this liveservers   servers
this deadservers   deadservers
this master   master
this backupmasters   backupmasters
this intransition   rit
this clusterid   clusterid
this mastercoprocessors   mastercoprocessors
/**
* @return the names of region servers on the dead list
*/
public collection<servername> getdeadservernames
return collections unmodifiablecollection deadservers
/**
* @return the number of region servers in the cluster
*/
public int getserverssize
return liveservers size
/**
* @return the number of dead region servers in the cluster
*/
public int getdeadservers
return deadservers size
/**
* @return the average cluster load
*/
public double getaverageload
int load   getregionscount
return  double load    double getserverssize
/**
* @return the number of regions deployed on the cluster
*/
public int getregionscount
int count   0
for  map entry<servername  hserverload> e  this liveservers entryset
count    e getvalue   getnumberofregions
return count
/**
* @return the number of requests since last report
*/
public int getrequestscount
int count   0
for  map entry<servername  hserverload> e  this liveservers entryset
count    e getvalue   getnumberofrequests
return count
/**
* @return the hbase version string as reported by the hmaster
*/
public string gethbaseversion
return hbaseversion
/**
* @see java.lang.object#equals(java.lang.object)
*/
public boolean equals object o
if  this    o
return true
if    o instanceof clusterstatus
return false
return  getversion        clusterstatus o  getversion
gethbaseversion   equals   clusterstatus o  gethbaseversion
this liveservers equals   clusterstatus o  liveservers
this deadservers containsall   clusterstatus o  deadservers
arrays equals this mastercoprocessors
clusterstatus o  mastercoprocessors
this master equals   clusterstatus o  master
this backupmasters containsall   clusterstatus o  backupmasters
/**
* @see java.lang.object#hashcode()
*/
public int hashcode
return version   hbaseversion hashcode     this liveservers hashcode
this deadservers hashcode     this master hashcode
this backupmasters hashcode
/** @return the object version number */
public byte getversion
return version
//
// getters
//
/**
* returns detailed region server information: a list of
* {@link servername}.
* @return region server information
* @deprecated use {@link #getservers()}
*/
public collection<servername> getserverinfo
return getservers
public collection<servername> getservers
return collections unmodifiablecollection this liveservers keyset
/**
* returns detailed information about the current master {@link servername}.
* @return current master information if it exists
*/
public servername getmaster
return this master
/**
* @return the number of backup masters in the cluster
*/
public int getbackupmasterssize
return this backupmasters size
/**
* @return the names of backup masters
*/
public collection<servername> getbackupmasters
return collections unmodifiablecollection this backupmasters
/**
* @param sn
* @return server's load or null if not found.
*/
public hserverload getload final servername sn
return this liveservers get sn
public map<string  regionstate> getregionsintransition
return this intransition
public string getclusterid
return clusterid
public string getmastercoprocessors
return mastercoprocessors
//
// writable
//
public void write dataoutput out  throws ioexception
super write out
out writeutf hbaseversion
out writeint getserverssize
for  map entry<servername  hserverload> e  this liveservers entryset
bytes writebytearray out  e getkey   getversionedbytes
e getvalue   write out
out writeint deadservers size
for  servername server  deadservers
bytes writebytearray out  server getversionedbytes
out writeint this intransition size
for  map entry<string  regionstate> e  this intransition entryset
out writeutf e getkey
e getvalue   write out
out writeutf clusterid
out writeint mastercoprocessors length
for string mastercoprocessor  mastercoprocessors
out writeutf mastercoprocessor
bytes writebytearray out  this master getversionedbytes
out writeint this backupmasters size
for  servername backupmaster  this backupmasters
bytes writebytearray out  backupmaster getversionedbytes
public void readfields datainput in  throws ioexception
int version   getversion
try
super readfields in
catch  versionmismatchexception e
/*
* no api in versionmismatchexception to get the expected and found
* versions.  we use the only tool available to us: tostring(), whose
* output has a dependency on hadoop-common.  boo.
*/
int startindex   e tostring   lastindexof      1
version   integer parseint e tostring   substring startindex
hbaseversion   in readutf
int count   in readint
this liveservers   new hashmap<servername  hserverload> count
for  int i   0  i < count  i
byte  versionedbytes   bytes readbytearray in
hserverload hsl   new hserverload
hsl readfields in
this liveservers put servername parseversionedservername versionedbytes   hsl
count   in readint
deadservers   new arraylist<servername> count
for  int i   0  i < count  i
deadservers add servername parseversionedservername bytes readbytearray in
count   in readint
this intransition   new treemap<string  regionstate>
for  int i   0  i < count  i
string key   in readutf
regionstate regionstate   new regionstate
regionstate readfields in
this intransition put key  regionstate
this clusterid   in readutf
int mastercoprocessorslength   in readint
mastercoprocessors   new string
for int i   0  i < mastercoprocessorslength  i
mastercoprocessors   in readutf
// only read extra fields for master and backup masters if
// version indicates that we should do so, else use defaults
if  version >  version_master_backupmasters
this master   servername parseversionedservername
bytes readbytearray in
count   in readint
this backupmasters   new arraylist<servername> count
for  int i   0  i < count  i
this backupmasters add servername parseversionedservername
bytes readbytearray in
else
this master   new servername servername unknown_servername   1
servername non_startcode
this backupmasters   new arraylist<servername> 0