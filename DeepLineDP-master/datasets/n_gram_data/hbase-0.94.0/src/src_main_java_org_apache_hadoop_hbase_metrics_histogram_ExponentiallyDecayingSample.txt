/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase metrics histogram
import java util arraylist
import java util random
import java util concurrent concurrentskiplistmap
import java util concurrent executors
import java util concurrent scheduledexecutorservice
import java util concurrent threadfactory
import java util concurrent timeunit
import java util concurrent atomic atomicinteger
import java util concurrent atomic atomiclong
import java util concurrent locks reentrantreadwritelock
/**
* an exponentially-decaying random sample of {@code long}s.
* uses cormode et al's forward-decaying priority reservoir sampling method
* to produce a statistically representative sample, exponentially biased
* towards newer entries.
*
* see cormode et al.
* forward decay: a practical time decay model for streaming systems. icde '09
*/
public class exponentiallydecayingsample implements sample
private static final random random   new random
private static final long rescale_threshold   timeunit hours tonanos 1
private static final scheduledexecutorservice tick_service
executors newscheduledthreadpool 1
getnameddaemonthreadfactory thread currentthread   getname
private static volatile long current_tick
timeunit milliseconds toseconds system currenttimemillis
static
// sample at twice our signal's frequency (1hz) per the nyquist theorem
tick_service scheduleatfixedrate new runnable
@override
public void run
current_tick
timeunit milliseconds toseconds system currenttimemillis
0  500  timeunit milliseconds
private final concurrentskiplistmap<double  long> values
new concurrentskiplistmap<double  long>
private final reentrantreadwritelock lock   new reentrantreadwritelock
private final atomiclong count   new atomiclong 0
private final atomiclong nextscaletime   new atomiclong 0
private final double alpha
private final int reservoirsize
private volatile long starttime
/**
* constructor for an exponentiallydecayingsample.
*
* @param reservoirsize the number of samples to keep in the reservoir
* @param alpha         the exponential decay factor; the higher this is,
*                      the more biased the sample will be towards newer
*                      values
*/
public exponentiallydecayingsample int reservoirsize  double alpha
this alpha   alpha
this reservoirsize   reservoirsize
clear
@override
public void clear
lockforrescale
try
values clear
count set 0
this starttime   current_tick
nextscaletime set system nanotime     rescale_threshold
finally
unlockforrescale
@override
public int size
return  int  math min reservoirsize  count get
@override
public void update long value
update value  current_tick
/**
* adds an old value with a fixed timestamp to the sample.
*
* @param value     the value to be added
* @param timestamp the epoch timestamp of {@code value} in seconds
*/
public void update long value  long timestamp
lockforregularusage
try
final double priority   weight timestamp   starttime
random nextdouble
final long newcount   count incrementandget
if  newcount <  reservoirsize
values put priority  value
else
double first   values firstkey
if  first < priority
if  values putifabsent priority  value     null
// ensure we always remove an item
while  values remove first     null
first   values firstkey
finally
unlockforregularusage
final long now   system nanotime
final long next   nextscaletime get
if  now >  next
rescale now  next
@override
public snapshot getsnapshot
lockforregularusage
try
return new snapshot values values
finally
unlockforregularusage
private double weight long t
return math exp alpha   t
/* "a common feature of the above techniquesã¢ââindeed, the key technique that
* allows us to track the decayed weights efficientlyã¢ââis that they maintain
* counts and other quantities based on g(ti ã¢ââ l), and only scale by g(t ã¢ââ l)
* at query time. but while g(ti ã¢ââl)/g(tã¢ââl) is guaranteed to lie between zero
* and one, the intermediate values of g(ti ã¢ââ l) could become very large. for
* polynomial functions, these values should not grow too large, and should
* be effectively represented in practice by floating point values without
* loss of precision. for exponential functions, these values could grow
* quite large as new values of (ti ã¢ââ l) become large, and potentially
* exceed the capacity of common floating point types. however, since the
* values stored by the algorithms are linear combinations of g values
* (scaled sums), they can be rescaled relative to a new landmark. that is,
* by the analysis of exponential decay in section iii-a, the choice of l
* does not affect the final result. we can therefore multiply each value
* based on l by a factor of exp(ã¢ââãâ±(lã¢ââ² ã¢ââ l)), and obtain the correct value
* as if we had instead computed relative to a new landmark lã¢ââ² (and then use
* this new lã¢ââ² at query time). this can be done with a linear pass over
* whatever data structure is being used."
*/
private void rescale long now  long next
if  nextscaletime compareandset next  now   rescale_threshold
lockforrescale
try
final long oldstarttime   starttime
this starttime   current_tick
final arraylist<double> keys   new arraylist<double> values keyset
for  double key   keys
final long value   values remove key
values put key   math exp  alpha    starttime   oldstarttime
value
finally
unlockforrescale
private void unlockforrescale
lock writelock   unlock
private void lockforrescale
lock writelock   lock
private void lockforregularusage
lock readlock   lock
private void unlockforregularusage
lock readlock   unlock
private static threadfactory getnameddaemonthreadfactory final string prefix
return new threadfactory
private final atomicinteger threadnumber   new atomicinteger 1
@override
public thread newthread runnable r
thread t  new thread r  prefix   threadnumber getandincrement
t setdaemon true
return t