/**
* copyright 2009 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase
import java io datainput
import java io dataoutput
import java io ioexception
import java util collection
import java util collections
import java util hashmap
import java util iterator
import java util map
import java util set
import java util treemap
import java util regex matcher
import org apache hadoop fs path
import org apache hadoop hbase io immutablebyteswritable
import org apache hadoop hbase io hfile compression
import org apache hadoop hbase regionserver storefile
import org apache hadoop hbase security user
import org apache hadoop hbase util bytes
import org apache hadoop io writablecomparable
/**
* htabledescriptor contains the details about an hbase table  such as the descriptors of
* all the column families, is the table a catalog table, <code> -root- </code> or
* <code> .meta. </code>, is the table is read only, the maximum size of the memstore,
* when the region split should occur, coprocessors associated with it etc...
*/
public class htabledescriptor implements writablecomparable<htabledescriptor>
/**
*  changes prior to version 3 were not recorded here.
*  version 3 adds metadata as a map where keys and values are byte[].
*  version 4 adds indexes
*  version 5 removed transactional pollution -- e.g. indexes
*/
private static final byte table_descriptor_version   5
private byte  name   hconstants empty_byte_array
private string nameasstring
/**
* a map which holds the metadata information of the table. this metadata
* includes values like is_root, is_meta, deferred_log_flush, split_policy,
* max_file_size, readonly, memstore_flushsize etc...
*/
protected map<immutablebyteswritable  immutablebyteswritable> values
new hashmap<immutablebyteswritable  immutablebyteswritable>
private static final string families
public static final string split_policy
/**
* <em>internal</em> used by hbase shell interface to access this metadata
* attribute which denotes the maximum size of the store file after which
* a region split occurs
*
* @see #getmaxfilesize()
*/
public static final string max_filesize
private static final immutablebyteswritable max_filesize_key
new immutablebyteswritable bytes tobytes max_filesize
public static final string owner
public static final immutablebyteswritable owner_key
new immutablebyteswritable bytes tobytes owner
/**
* <em>internal</em> used by rest interface to access this metadata
* attribute which denotes if the table is read only
*
* @see #isreadonly()
*/
public static final string readonly
private static final immutablebyteswritable readonly_key
new immutablebyteswritable bytes tobytes readonly
/**
* <em>internal</em> used by hbase shell interface to access this metadata
* attribute which represents the maximum size of the memstore after which
* its contents are flushed onto the disk
*
* @see #getmemstoreflushsize()
*/
public static final string memstore_flushsize
private static final immutablebyteswritable memstore_flushsize_key
new immutablebyteswritable bytes tobytes memstore_flushsize
/**
* <em>internal</em> used by rest interface to access this metadata
* attribute which denotes if the table is a -root- region or not
*
* @see #isrootregion()
*/
public static final string is_root
private static final immutablebyteswritable is_root_key
new immutablebyteswritable bytes tobytes is_root
/**
* <em>internal</em> used by rest interface to access this metadata
* attribute which denotes if it is a catalog table, either
* <code> .meta. </code> or <code> -root- </code>
*
* @see #ismetaregion()
*/
public static final string is_meta
private static final immutablebyteswritable is_meta_key
new immutablebyteswritable bytes tobytes is_meta
/**
* <em>internal</em> used by hbase shell interface to access this metadata
* attribute which denotes if the deferred log flush option is enabled
*/
public static final string deferred_log_flush
private static final immutablebyteswritable deferred_log_flush_key
new immutablebyteswritable bytes tobytes deferred_log_flush
/*
*  the below are ugly but better than creating them each time till we
*  replace booleans being saved as strings with plain booleans.  need a
*  migration script to do this.  todo.
*/
private static final immutablebyteswritable false
new immutablebyteswritable bytes tobytes boolean false tostring
private static final immutablebyteswritable true
new immutablebyteswritable bytes tobytes boolean true tostring
private static final boolean default_deferred_log_flush   false
/**
* constant that denotes whether the table is readonly by default and is false
*/
public static final boolean default_readonly   false
/**
* constant that denotes the maximum default size of the memstore after which
* the contents are flushed to the store files
*/
public static final long default_memstore_flush_size   1024 1024 128l
private volatile boolean meta   null
private volatile boolean root   null
private boolean isdeferredlog   null
/**
* maps column family name to the respective hcolumndescriptors
*/
private final map<byte   hcolumndescriptor> families
new treemap<byte   hcolumndescriptor> bytes bytes_rawcomparator
/**
* <em> internal </em> private constructor used internally creating table descriptors for
* catalog tables, <code>.meta.</code> and <code>-root-</code>.
*/
protected htabledescriptor final byte  name  hcolumndescriptor families
this name   name clone
this nameasstring   bytes tostring this name
setmetaflags name
for hcolumndescriptor descriptor   families
this families put descriptor getname    descriptor
/**
* <em> internal </em>private constructor used internally creating table descriptors for
* catalog tables, <code>.meta.</code> and <code>-root-</code>.
*/
protected htabledescriptor final byte  name  hcolumndescriptor families
map<immutablebyteswritable immutablebyteswritable> values
this name   name clone
this nameasstring   bytes tostring this name
setmetaflags name
for hcolumndescriptor descriptor   families
this families put descriptor getname    descriptor
for  map entry<immutablebyteswritable  immutablebyteswritable> entry
values entryset
this values put entry getkey    entry getvalue
/**
* default constructor which constructs an empty object.
* for deserializing an htabledescriptor instance only.
* @see #htabledescriptor(byte[])
*/
public htabledescriptor
super
/**
* construct a table descriptor specifying table name.
* @param name table name.
* @throws illegalargumentexception if passed a table name
* that is made of other than 'word' characters, underscore or period: i.e.
* <code>[a-za-z_0-9.].
* @see <a href="hadoop-1581">hadoop-1581 hbase: un-openable tablename bug</a>
*/
public htabledescriptor final string name
this bytes tobytes name
/**
* construct a table descriptor specifying a byte array table name
* @param name - table name as a byte array.
* @throws illegalargumentexception if passed a table name
* that is made of other than 'word' characters, underscore or period: i.e.
* <code>[a-za-z_0-9-.].
* @see <a href="hadoop-1581">hadoop-1581 hbase: un-openable tablename bug</a>
*/
public htabledescriptor final byte  name
super
setmetaflags this name
this name   this ismetaregion  ? name  islegaltablename name
this nameasstring   bytes tostring this name
/**
* construct a table descriptor by cloning the descriptor passed as a parameter.
* <p>
* makes a deep copy of the supplied descriptor.
* can make a modifiable descriptor from an unmodifyablehtabledescriptor.
* @param desc the descriptor.
*/
public htabledescriptor final htabledescriptor desc
super
this name   desc name clone
this nameasstring   bytes tostring this name
setmetaflags this name
for  hcolumndescriptor c  desc families values
this families put c getname    new hcolumndescriptor c
for  map entry<immutablebyteswritable  immutablebyteswritable> e
desc values entryset
this values put e getkey    e getvalue
/*
* set meta flags on this table.
* is_root_key is set if its a -root- table
* is_meta_key is set either if its a -root- or a .meta. table
* called by constructors.
* @param name
*/
private void setmetaflags final byte  name
setrootregion bytes equals name  hconstants root_table_name
setmetaregion isrootregion
bytes equals name  hconstants meta_table_name
/**
* check if the descriptor represents a <code> -root- </code> region.
*
* @return true if this is a <code> -root- </code> region
*/
public boolean isrootregion
if  this root    null
this root   issomething is_root_key  false ? boolean true  boolean false
return this root booleanvalue
/**
* <em> internal </em> used to denote if the current table represents
* <code> -root- </code> region. this is used internally by the
* htabledescriptor constructors
*
* @param isroot true if this is the <code> -root- </code> region
*/
protected void setrootregion boolean isroot
// todo: make the value a boolean rather than string of boolean.
values put is_root_key  isroot? true  false
/**
* checks if this table is either <code> -root- </code> or <code> .meta. </code>
* region.
*
* @return true if this is either a <code> -root- </code> or <code> .meta. </code>
* region
*/
public boolean ismetaregion
if  this meta    null
this meta   calculateismetaregion
return this meta booleanvalue
private synchronized boolean calculateismetaregion
byte  value   getvalue is_meta_key
return  value    null ? boolean valueof bytes tostring value    boolean false
private boolean issomething final immutablebyteswritable key
final boolean valueifnull
byte  value   getvalue key
if  value    null
// todo: make value be a boolean rather than string of boolean.
return boolean valueof bytes tostring value   booleanvalue
return valueifnull
/**
* <em> internal </em> used to denote if the current table represents
* <code> -root- </code> or <code> .meta. </code> region. this is used
* internally by the htabledescriptor constructors
*
* @param ismeta true if its either <code> -root- </code> or
* <code> .meta. </code> region
*/
protected void setmetaregion boolean ismeta
values put is_meta_key  ismeta? true  false
/**
* checks if the table is a <code>.meta.</code> table
*
* @return true if table is <code> .meta. </code> region.
*/
public boolean ismetatable
return ismetaregion       isrootregion
/**
* checks of the tablename being passed represents either
* <code > -root- </code> or <code> .meta. </code>
*
* @return true if a tablesname is either <code> -root- </code>
* or <code> .meta. </code>
*/
public static boolean ismetatable final byte  tablename
return bytes equals tablename  hconstants root_table_name
bytes equals tablename  hconstants meta_table_name
/**
* check passed byte buffer, "tablename", is legal user-space table name.
* @return returns passed <code>tablename</code> param
* @throws nullpointerexception if passed <code>tablename</code> is null
* @throws illegalargumentexception if passed a tablename
* that is made of other than 'word' characters or underscores: i.e.
* <code>[a-za-z_0-9].
*/
public static byte  islegaltablename final byte  tablename
if  tablename    null    tablename length <  0
throw new illegalargumentexception
if  tablename         tablename
throw new illegalargumentexception     tablename
bytes tostring tablename
for  int i   0  i < tablename length  i
if  character isletterordigit tablename     tablename
tablename         tablename
continue
throw new illegalargumentexception     tablename
i
bytes tostring tablename
return tablename
/**
* getter for accessing the metadata associated with the key
*
* @param key the key.
* @return the value.
* @see #values
*/
public byte getvalue byte key
return getvalue new immutablebyteswritable key
private byte getvalue final immutablebyteswritable key
immutablebyteswritable ibw   values get key
if  ibw    null
return null
return ibw get
/**
* getter for accessing the metadata associated with the key
*
* @param key the key.
* @return the value.
* @see #values
*/
public string getvalue string key
byte value   getvalue bytes tobytes key
if  value    null
return null
return bytes tostring value
/**
* getter for fetching an unmodifiable {@link #values} map.
*
* @return unmodifiable map {@link #values}.
* @see #values
*/
public map<immutablebyteswritable immutablebyteswritable> getvalues
return collections unmodifiablemap values
/**
* setter for storing metadata as a (key, value) pair in {@link #values} map
*
* @param key the key.
* @param value the value.
* @see #values
*/
public void setvalue byte key  byte value
setvalue new immutablebyteswritable key   value
/*
* @param key the key.
* @param value the value.
*/
private void setvalue final immutablebyteswritable key
final byte value
values put key  new immutablebyteswritable value
/*
* @param key the key.
* @param value the value.
*/
private void setvalue final immutablebyteswritable key
final immutablebyteswritable value
values put key  value
/**
* setter for storing metadata as a (key, value) pair in {@link #values} map
*
* @param key the key.
* @param value the value.
* @see #values
*/
public void setvalue string key  string value
setvalue bytes tobytes key   bytes tobytes value
/**
* remove metadata represented by the key from the {@link #values} map
*
* @param key key whose key and value we're to remove from htabledescriptor
* parameters.
*/
public void remove final byte  key
values remove new immutablebyteswritable key
/**
* remove metadata represented by the key from the {@link #values} map
*
* @param key key whose key and value we're to remove from htabledescriptor
* parameters.
*/
public void remove final string key
remove bytes tobytes key
/**
* check if the readonly flag of the table is set. if the readonly flag is
* set then the contents of the table can only be read from but not modified.
*
* @return true if all columns in the table should be read only
*/
public boolean isreadonly
return issomething readonly_key  default_readonly
/**
* setting the table as read only sets all the columns in the table as read
* only. by default all tables are modifiable, but if the readonly flag is
* set to true then the contents of the table can only be read but not modified.
*
* @param readonly true if all of the columns in the table should be read
* only.
*/
public void setreadonly final boolean readonly
setvalue readonly_key  readonly? true  false
/**
* check if deferred log edits are enabled on the table.
*
* @return true if that deferred log flush is enabled on the table
*
* @see #setdeferredlogflush(boolean)
*/
public synchronized boolean isdeferredlogflush
if this isdeferredlog    null
this isdeferredlog
issomething deferred_log_flush_key  default_deferred_log_flush
return this isdeferredlog
/**
* this is used to defer the log edits syncing to the file system. everytime
* an edit is sent to the server it is first sync'd to the file system by the
* log writer. this sync is an expensive operation and thus can be deferred so
* that the edits are kept in memory for a specified period of time as represented
* by <code> hbase.regionserver.optionallogflushinterval </code> and not flushed
* for every edit.
* <p>
* note:- this option might result in data loss if the region server crashes
* before these deferred edits in memory are flushed onto the filesystem.
* </p>
*
* @param isdeferredlogflush
*/
public void setdeferredlogflush final boolean isdeferredlogflush
setvalue deferred_log_flush_key  isdeferredlogflush? true  false
this isdeferredlog   isdeferredlogflush
/**
* get the name of the table as a byte array.
*
* @return name of table
*/
public byte  getname
return name
/**
* get the name of the table as a string
*
* @return name of table as a string
*/
public string getnameasstring
return this nameasstring
/**
* this get the class associated with the region split policy which
* determines when a region split should occur.  the class used by
* default is {@link org.apache.hadoop.hbase.regionserver.constantsizeregionsplitpolicy}
* which split the region base on a constant {@link #getmaxfilesize()}
*
* @return the class name of the region split policy for this table.
* if this returns null, the default constant size based split policy
* is used.
*/
public string getregionsplitpolicyclassname
return getvalue split_policy
/**
* set the name of the table.
*
* @param name name of table
*/
public void setname byte name
this name   name
this nameasstring   bytes tostring this name
setmetaflags this name
/**
* returns the maximum size upto which a region can grow to after which a region
* split is triggered. the region size is represented by the size of the biggest
* store file in that region.
*
* @return max hregion size for table
*
* @see #setmaxfilesize(long)
*/
public long getmaxfilesize
byte  value   getvalue max_filesize_key
if  value    null
return long valueof bytes tostring value   longvalue
return hconstants default_max_file_size
/**
* sets the maximum size upto which a region can grow to after which a region
* split is triggered. the region size is represented by the size of the biggest
* store file in that region, i.e. if the biggest store file grows beyond the
* maxfilesize, then the region split is triggered. this defaults to a value of
* 256 mb.
* <p>
* this is not an absolute value and might vary. assume that a single row exceeds
* the maxfilesize then the storefilesize will be greater than maxfilesize since
* a single row cannot be split across multiple regions
* </p>
*
* @param maxfilesize the maximum file size that a store file can grow to
* before a split is triggered.
*/
public void setmaxfilesize long maxfilesize
setvalue max_filesize_key  bytes tobytes long tostring maxfilesize
/**
* returns the size of the memstore after which a flush to filesystem is triggered.
*
* @return memory cache flush size for each hregion
*
* @see #setmemstoreflushsize(long)
*/
public long getmemstoreflushsize
byte  value   getvalue memstore_flushsize_key
if  value    null
return long valueof bytes tostring value   longvalue
return default_memstore_flush_size
/**
* represents the maximum size of the memstore after which the contents of the
* memstore are flushed to the filesystem. this defaults to a size of 64 mb.
*
* @param memstoreflushsize memory cache flush size for each hregion
*/
public void setmemstoreflushsize long memstoreflushsize
setvalue memstore_flushsize_key
bytes tobytes long tostring memstoreflushsize
/**
* adds a column family.
* @param family hcolumndescriptor of family to add.
*/
public void addfamily final hcolumndescriptor family
if  family getname      null    family getname   length <  0
throw new nullpointerexception
this families put family getname    family
/**
* checks to see if this table contains the given column family
* @param familyname family name or column name.
* @return true if the table contains the specified family name
*/
public boolean hasfamily final byte  familyname
return families containskey familyname
/**
* @return name of this table and then a map of all of the column family
* descriptors.
* @see #getnameasstring()
*/
@override
public string tostring
stringbuilder s   new stringbuilder
s append
s append hconstants name
s append
s append bytes tostring name
s append
for  map entry<immutablebyteswritable  immutablebyteswritable> e
values entryset
string key   bytes tostring e getkey   get
string value   bytes tostring e getvalue   get
if  key    null
continue
string uppercase   key touppercase
if  uppercase equals is_root     uppercase equals is_meta
// skip. don't bother printing out read-only values if false.
if  value tolowercase   equals boolean false tostring
continue
s append
s append bytes tostring e getkey   get
s append
s append bytes tostring e getvalue   get
s append
s append
s append families
s append
s append families values
s append
return s tostring
/**
* @return name of this table and then a map of all of the column family
* descriptors (with only the non-default column family attributes)
*/
public string tostringcustomizedvalues
stringbuilder s   new stringbuilder
s append
s append hconstants name
s append
s append bytes tostring name
s append
for  map entry<immutablebyteswritable  immutablebyteswritable> e
values entryset
string key   bytes tostring e getkey   get
string value   bytes tostring e getvalue   get
if  key    null
continue
string uppercase   key touppercase
if  uppercase equals is_root     uppercase equals is_meta
// skip. don't bother printing out read-only values if false.
if  value tolowercase   equals boolean false tostring
continue
s append
s append bytes tostring e getkey   get
s append
s append bytes tostring e getvalue   get
s append
s append
s append families
s append
int size   families values   size
int i   0
for hcolumndescriptor hcd   families values
s append hcd tostringcustomizedvalues
i
if  i    size
s append
s append
return s tostring
/**
* compare the contents of the descriptor with another one passed as a parameter.
* checks if the obj passed is an instance of htabledescriptor, if yes then the
* contents of the descriptors are compared.
*
* @return true if the contents of the the two descriptors exactly match
*
* @see java.lang.object#equals(java.lang.object)
*/
@override
public boolean equals object obj
if  this    obj
return true
if  obj    null
return false
if    obj instanceof htabledescriptor
return false
return compareto  htabledescriptor obj     0
/**
* @see java.lang.object#hashcode()
*/
@override
public int hashcode
int result   bytes hashcode this name
result ^  byte valueof table_descriptor_version  hashcode
if  this families    null    this families size   > 0
for  hcolumndescriptor e  this families values
result ^  e hashcode
result ^  values hashcode
return result
// writable
/**
* <em> internal </em> this method is a part of {@link writablecomparable} interface
* and is used for de-serialization of the htabledescriptor over rpc
*/
@override
public void readfields datainput in  throws ioexception
int version   in readint
if  version < 3
throw new ioexception
// version 3+
name   bytes readbytearray in
nameasstring   bytes tostring this name
setrootregion in readboolean
setmetaregion in readboolean
values clear
int numvals   in readint
for  int i   0  i < numvals  i
immutablebyteswritable key   new immutablebyteswritable
immutablebyteswritable value   new immutablebyteswritable
key readfields in
value readfields in
values put key  value
families clear
int numfamilies   in readint
for  int i   0  i < numfamilies  i
hcolumndescriptor c   new hcolumndescriptor
c readfields in
families put c getname    c
if  version < 4
return
/**
* <em> internal </em> this method is a part of {@link writablecomparable} interface
* and is used for serialization of the htabledescriptor over rpc
*/
@override
public void write dataoutput out  throws ioexception
out writeint table_descriptor_version
bytes writebytearray out  name
out writeboolean isrootregion
out writeboolean ismetaregion
out writeint values size
for  map entry<immutablebyteswritable  immutablebyteswritable> e
values entryset
e getkey   write out
e getvalue   write out
out writeint families size
for iterator<hcolumndescriptor> it   families values   iterator
it hasnext
hcolumndescriptor family   it next
family write out
// comparable
/**
* compares the descriptor with another descriptor which is passed as a parameter.
* this compares the content of the two descriptors and not the reference.
*
* @return 0 if the contents of the descriptors are exactly matching,
* 		 1 if there is a mismatch in the contents
*/
@override
public int compareto final htabledescriptor other
int result   bytes compareto this name  other name
if  result    0
result   families size     other families size
if  result    0    families size      other families size
result   integer valueof families size    compareto
integer valueof other families size
if  result    0
for  iterator<hcolumndescriptor> it   families values   iterator
it2   other families values   iterator    it hasnext
result   it next   compareto it2 next
if  result    0
break
if  result    0
// punt on comparison for ordering, just calculate difference
result   this values hashcode     other values hashcode
if  result < 0
result    1
else if  result > 0
result   1
return result
/**
* returns an unmodifiable collection of all the {@link hcolumndescriptor}
* of all the column families of the table.
*
* @return immutable collection of {@link hcolumndescriptor} of all the
* column families.
*/
public collection<hcolumndescriptor> getfamilies
return collections unmodifiablecollection this families values
/**
* returns all the column family names of the current table. the map of
* htabledescriptor contains mapping of family name to hcolumndescriptors.
* this returns all the keys of the family map which represents the column
* family names of the table.
*
* @return immutable sorted set of the keys of the families.
*/
public set<byte> getfamilieskeys
return collections unmodifiableset this families keyset
/**
* returns an array all the {@link hcolumndescriptor} of the column families
* of the table.
*
* @return array of all the hcolumndescriptors of the current table
*
* @see #getfamilies()
*/
public hcolumndescriptor getcolumnfamilies
return getfamilies   toarray new hcolumndescriptor
/**
* returns the hcolumndescriptor for a specific column family with name as
* specified by the parameter column.
*
* @param column column family name
* @return column descriptor for the passed family name or the family on
* passed in column.
*/
public hcolumndescriptor getfamily final byte  column
return this families get column
/**
* removes the hcolumndescriptor with name specified by the parameter column
* from the table descriptor
*
* @param column name of the column family to be removed.
* @return column descriptor for the passed family name or the family on
* passed in column.
*/
public hcolumndescriptor removefamily final byte  column
return this families remove column
/**
* add a table coprocessor to this table. the coprocessor
* type must be {@link org.apache.hadoop.hbase.coprocessor.regionobserver}
* or endpoint.
* it won't check if the class can be loaded or not.
* whether a coprocessor is loadable or not will be determined when
* a region is opened.
* @param classname full class name.
* @throws ioexception
*/
public void addcoprocessor string classname  throws ioexception
addcoprocessor classname  null  coprocessor priority_user  null
/**
* add a table coprocessor to this table. the coprocessor
* type must be {@link org.apache.hadoop.hbase.coprocessor.regionobserver}
* or endpoint.
* it won't check if the class can be loaded or not.
* whether a coprocessor is loadable or not will be determined when
* a region is opened.
* @param jarfilepath path of the jar file. if it's null, the class will be
* loaded from default classloader.
* @param classname full class name.
* @param priority priority
* @param kvs arbitrary key-value parameter pairs passed into the coprocessor.
* @throws ioexception
*/
public void addcoprocessor string classname  path jarfilepath
int priority  final map<string  string> kvs
throws ioexception
if  hascoprocessor classname
throw new ioexception     classname
// validate parameter kvs
stringbuilder kvstring   new stringbuilder
if  kvs    null
for  map entry<string  string> e  kvs entryset
if   e getkey   matches hconstants cp_htd_attr_value_param_key_pattern
throw new ioexception     e getkey
if   e getvalue   matches hconstants cp_htd_attr_value_param_value_pattern
throw new ioexception     e getkey
e getvalue
if  kvstring length      0
kvstring append
kvstring append e getkey
kvstring append
kvstring append e getvalue
// generate a coprocessor key
int maxcoprocessornumber   0
matcher keymatcher
for  map entry<immutablebyteswritable  immutablebyteswritable> e
this values entryset
keymatcher
hconstants cp_htd_attr_key_pattern matcher
bytes tostring e getkey   get
if   keymatcher matches
continue
maxcoprocessornumber   math max integer parseint keymatcher group 1
maxcoprocessornumber
maxcoprocessornumber
string key       integer tostring maxcoprocessornumber
string value     jarfilepath    null ?     jarfilepath tostring
classname       integer tostring priority
kvstring tostring
setvalue key  value
/**
* check if the table has an attached co-processor represented by the name classname
*
* @param classname - class name of the co-processor
* @return true of the table has a co-processor classname
*/
public boolean hascoprocessor string classname
matcher keymatcher
matcher valuematcher
for  map entry<immutablebyteswritable  immutablebyteswritable> e
this values entryset
keymatcher
hconstants cp_htd_attr_key_pattern matcher
bytes tostring e getkey   get
if   keymatcher matches
continue
valuematcher
hconstants cp_htd_attr_value_pattern matcher
bytes tostring e getvalue   get
if   valuematcher matches
continue
// get classname and compare
string clazz   valuematcher group 2  trim       classname is the 2nd field
if  clazz equals classname trim
return true
return false
/**
* remove a coprocessor from those set on the table
* @param classname class name of the co-processor
*/
public void removecoprocessor string classname
immutablebyteswritable match   null
matcher keymatcher
matcher valuematcher
for  map entry<immutablebyteswritable  immutablebyteswritable> e   this values
entryset
keymatcher   hconstants cp_htd_attr_key_pattern matcher bytes tostring e
getkey   get
if   keymatcher matches
continue
valuematcher   hconstants cp_htd_attr_value_pattern matcher bytes
tostring e getvalue   get
if   valuematcher matches
continue
// get classname and compare
string clazz   valuematcher group 2  trim       classname is the 2nd field
// remove the cp if it is present
if  clazz equals classname trim
match   e getkey
break
// if we found a match, remove it
if  match    null
this values remove match
/**
* returns the {@link path} object representing the table directory under
* path rootdir
*
* @param rootdir qualified path of hbase root directory
* @param tablename name of table
* @return {@link path} for table
*/
public static path gettabledir path rootdir  final byte  tablename
return new path rootdir  bytes tostring tablename
/** table descriptor for <core>-root-</code> catalog table */
public static final htabledescriptor root_tabledesc   new htabledescriptor
hconstants root_table_name
new hcolumndescriptor
new hcolumndescriptor hconstants catalog_family
// ten is arbitrary number.  keep versions to help debugging.
setmaxversions 10
setinmemory true
setblocksize 8   1024
settimetolive hconstants forever
setscope hconstants replication_scope_local
/** table descriptor for <code>.meta.</code> catalog table */
public static final htabledescriptor meta_tabledesc   new htabledescriptor
hconstants meta_table_name  new hcolumndescriptor
new hcolumndescriptor hconstants catalog_family
// ten is arbitrary number.  keep versions to help debugging.
setmaxversions 10
setinmemory true
setblocksize 8   1024
setscope hconstants replication_scope_local
public void setowner user owner
setownerstring owner    null ? owner getshortname     null
// used by admin.rb:alter(table_name,*args) to update owner.
public void setownerstring string ownerstring
if  ownerstring    null
setvalue owner_key  bytes tobytes ownerstring
else
values remove owner_key
public string getownerstring
if  getvalue owner_key     null
return bytes tostring getvalue owner_key
// note that every table should have an owner (i.e. should have owner_key set).
// .meta. and -root- should return system user as owner, not null (see masterfilesystem.java:bootstrap()).
return null