/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase ipc
import java io ioexception
import java net connectexception
import java util list
import org apache hadoop hbase abortable
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase hserverinfo
import org apache hadoop hbase notservingregionexception
import org apache hadoop hbase stoppable
import org apache hadoop hbase client append
import org apache hadoop hbase client rowmutations
import org apache hadoop hbase client delete
import org apache hadoop hbase client get
import org apache hadoop hbase client increment
import org apache hadoop hbase client multiaction
import org apache hadoop hbase client multiresponse
import org apache hadoop hbase client put
import org apache hadoop hbase client result
import org apache hadoop hbase client scan
import org apache hadoop hbase client coprocessor exec
import org apache hadoop hbase client coprocessor execresult
import org apache hadoop hbase filter comparefilter compareop
import org apache hadoop hbase filter writablebytearraycomparable
import org apache hadoop hbase io hfile blockcachecolumnfamilysummary
import org apache hadoop hbase regionserver regionopeningstate
import org apache hadoop hbase regionserver wal failedlogcloseexception
import org apache hadoop hbase regionserver wal hlog
import org apache hadoop hbase security tokeninfo
import org apache hadoop hbase security kerberosinfo
import org apache hadoop hbase util pair
import org apache hadoop ipc remoteexception
import org apache hadoop hbase ipc versionedprotocol
/**
* clients interact with hregionservers using a handle to the hregioninterface.
*
* <p>note: if you change the interface, you must change the rpc version
* number in hbaserpcprotocolversion
*/
@kerberosinfo
serverprincipal
@tokeninfo
public interface hregioninterface extends versionedprotocol  stoppable  abortable
/**
* this interfaces' version. version changes when the interface changes.
*/
// all hbase interfaces used derive from hbaserpcprotocolversion.  it
// maintained a single global version number on all hbase interfaces.  this
// meant all hbase rpc was broke though only one of the three rpc interfaces
// had changed.  this has since been undone.
public static final long version   29l
/**
* get metainfo about an hregion
*
* @param regionname name of the region
* @return hregioninfo object for region
* @throws notservingregionexception
* @throws connectexception
* @throws ioexception this can manifest as an hadoop ipc {@link remoteexception}
*/
public hregioninfo getregioninfo final byte  regionname
throws notservingregionexception  connectexception  ioexception
/**
* flush the given region
* @param region name
*/
public void flushregion byte regionname
throws illegalargumentexception  ioexception
/**
* flush the given region if lastflushtime < ifolderthants
* @param region name
* @param timestamp
*/
public void flushregion byte regionname  long ifolderthants
throws illegalargumentexception  ioexception
/**
* gets last flush time for the given region
* @return the last flush time for a region
*/
public long getlastflushtime byte regionname
/**
* get a list of store files for a particular cf in a particular region
* @param region name
* @param cf name
* @return the list of store files
*/
public list<string> getstorefilelist byte regionname  byte columnfamily
throws illegalargumentexception
/**
* get a list of store files for a set of cfs in a particular region
* @param region name
* @param cf names
* @return the list of store files
*/
public list<string> getstorefilelist byte regionname  byte columnfamilies
throws illegalargumentexception
/**
* get a list of store files for all cfs in a particular region
* @param region name
* @return the list of store files
*/
public list<string> getstorefilelist byte regionname
throws illegalargumentexception
/**
* return all the data for the row that matches <i>row</i> exactly,
* or the one that immediately preceeds it.
*
* @param regionname region name
* @param row row key
* @param family column family to look for row in.
* @return map of values
* @throws ioexception e
*/
public result getclosestrowbefore final byte  regionname
final byte  row  final byte  family
throws ioexception
/**
* perform get operation.
* @param regionname name of region to get from
* @param get get operation
* @return result
* @throws ioexception e
*/
public result get byte  regionname  get get  throws ioexception
/**
* perform exists operation.
* @param regionname name of region to get from
* @param get get operation describing cell to test
* @return true if exists
* @throws ioexception e
*/
public boolean exists byte  regionname  get get  throws ioexception
/**
* put data into the specified region
* @param regionname region name
* @param put the data to be put
* @throws ioexception e
*/
public void put final byte  regionname  final put put
throws ioexception
/**
* put an array of puts into the specified region
*
* @param regionname region name
* @param puts list of puts to execute
* @return the number of processed put's.  returns -1 if all puts
* processed successfully.
* @throws ioexception e
*/
public int put final byte regionname  final list<put> puts
throws ioexception
/**
* deletes all the keyvalues that match those found in the delete object,
* if their ts <= to the delete. in case of a delete with a specific ts it
* only deletes that specific keyvalue.
* @param regionname region name
* @param delete delete object
* @throws ioexception e
*/
public void delete final byte regionname  final delete delete
throws ioexception
/**
* put an array of deletes into the specified region
*
* @param regionname region name
* @param deletes delete list to execute
* @return the number of processed deletes.  returns -1 if all deletes
* processed successfully.
* @throws ioexception e
*/
public int delete final byte regionname  final list<delete> deletes
throws ioexception
/**
* atomically checks if a row/family/qualifier value match the expectedvalue.
* if it does, it adds the put. if passed expected value is null, then the
* check is for non-existance of the row/column.
*
* @param regionname region name
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param value the expected value
* @param put data to put if check succeeds
* @throws ioexception e
* @return true if the new put was execute, false otherwise
*/
public boolean checkandput final byte regionname  final byte  row
final byte  family  final byte  qualifier  final byte  value
final put put
throws ioexception
/**
* atomically checks if a row/family/qualifier value match the expectedvalue.
* if it does, it adds the delete. if passed expected value is null, then the
* check is for non-existance of the row/column.
*
* @param regionname region name
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param value the expected value
* @param delete data to delete if check succeeds
* @throws ioexception e
* @return true if the new delete was execute, false otherwise
*/
public boolean checkanddelete final byte regionname  final byte  row
final byte  family  final byte  qualifier  final byte  value
final delete delete
throws ioexception
/**
* atomically increments a column value. if the column value isn't long-like,
* this could throw an exception. if passed expected value is null, then the
* check is for non-existance of the row/column.
*
* @param regionname region name
* @param row row to check
* @param family column family
* @param qualifier column qualifier
* @param amount long amount to increment
* @param writetowal whether to write the increment to the wal
* @return new incremented column value
* @throws ioexception e
*/
public long incrementcolumnvalue byte  regionname  byte  row
byte  family  byte  qualifier  long amount  boolean writetowal
throws ioexception
public void mutaterow byte regionname  rowmutations rm
throws ioexception
/**
* appends values to one or more columns values in a row. optionally
* returns the updated keys after the append.
* <p>
* this operation does not appear atomic to readers. appends are done
* under a row lock but readers do not take row locks.
* @param regionname region name
* @param append append operation
* @return changed cells (maybe null)
*/
public result append byte regionname  append append
throws ioexception
/**
* increments one or more columns values in a row.  returns the
* updated keys after the increment.
* <p>
* this operation does not appear atomic to readers.  increments are done
* under a row lock but readers do not take row locks.
* @param regionname region name
* @param increment increment operation
* @return incremented cells
*/
public result increment byte regionname  increment increment
throws ioexception
//
// remote scanner interface
//
/**
* opens a remote scanner with a rowfilter.
*
* @param regionname name of region to scan
* @param scan configured scan object
* @return scannerid scanner identifier used in other calls
* @throws ioexception e
*/
public long openscanner final byte  regionname  final scan scan
throws ioexception
/**
* get the next set of values
* @param scannerid clientid passed to openscanner
* @return map of values; returns null if no results.
* @throws ioexception e
*/
public result next long scannerid  throws ioexception
/**
* get the next set of values
* @param scannerid clientid passed to openscanner
* @param numberofrows the number of rows to fetch
* @return array of results (map of values); array is empty if done with this
* region and null if we are not to go to the next region (happens when a
* filter rules that the scan is done).
* @throws ioexception e
*/
public result  next long scannerid  int numberofrows  throws ioexception
/**
* close a scanner
*
* @param scannerid the scanner id returned by openscanner
* @throws ioexception e
*/
public void close long scannerid  throws ioexception
/**
* opens a remote row lock.
*
* @param regionname name of region
* @param row row to lock
* @return lockid lock identifier
* @throws ioexception e
*/
public long lockrow final byte  regionname  final byte  row
throws ioexception
/**
* releases a remote row lock.
*
* @param regionname region name
* @param lockid the lock id returned by lockrow
* @throws ioexception e
*/
public void unlockrow final byte  regionname  final long lockid
throws ioexception
/**
* @return all regions online on this region server
* @throws ioexception e
*/
public list<hregioninfo> getonlineregions   throws ioexception
/**
* method used when a master is taking the place of another failed one.
* @return this servers {@link hserverinfo}; it has regionserver pov on the
* hostname which may not agree w/ how the master sees this server.
* @throws ioexception e
* @deprecated
*/
public hserverinfo gethserverinfo   throws ioexception
/**
* method used for doing multiple actions(deletes, gets and puts) in one call
* @param multi
* @return multiresult
* @throws ioexception
*/
public <r> multiresponse multi multiaction<r> multi  throws ioexception
/**
* atomically bulk load multiple hfiles (say from different column families)
* into an open region.
*
* @param familypaths list of (family, hfile path) pairs
* @param regionname name of region to load hfiles into
* @return true if successful, false if failed recoverably
* @throws ioexception if fails unrecoverably
*/
public boolean bulkloadhfiles list<pair<byte  string>> familypaths  byte regionname
throws ioexception
// master methods
/**
* opens the specified region.
*
* @param region
*          region to open
* @return regionopeningstate
*         opened         - if region open request was successful.
*         already_opened - if the region was already opened.
*         failed_opening - if region opening failed.
*
* @throws ioexception
*/
public regionopeningstate openregion final hregioninfo region  throws ioexception
/**
* opens the specified region.
* @param region
*          region to open
* @param versionofofflinenode
*          the version of znode to compare when rs transitions the znode from
*          offline state.
* @return regionopeningstate
*         opened         - if region open request was successful.
*         already_opened - if the region was already opened.
*         failed_opening - if region opening failed.
* @throws ioexception
*/
public regionopeningstate openregion hregioninfo region  int versionofofflinenode
throws ioexception
/**
* opens the specified regions.
* @param regions regions to open
* @throws ioexception
*/
public void openregions final list<hregioninfo> regions  throws ioexception
/**
* closes the specified region.
* @param region region to close
* @return true if closing region, false if not
* @throws ioexception
*/
public boolean closeregion final hregioninfo region
throws ioexception
/**
* closes the specified region.
* @param region region to close
* @param versionofclosingnode
*          the version of znode to compare when rs transitions the znode
*          from closing state.
* @return true if closing region, false if not
* @throws ioexception
*/
public boolean closeregion final hregioninfo region
final int versionofclosingnode
throws ioexception
/**
* closes the specified region and will use or not use zk during the close
* according to the specified flag.
* @param region region to close
* @param zk true if transitions should be done in zk, false if not
* @return true if closing region, false if not
* @throws ioexception
*/
public boolean closeregion final hregioninfo region  final boolean zk
throws ioexception
/**
* closes the region in the rs with the specified encoded regionname and will
* use or not use zk during the close according to the specified flag. note
* that the encoded region name is in byte format.
*
* @param encodedregionname
*          in bytes
* @param zk
*          true if to use zookeeper, false if need not.
* @return true if region is closed, false if not.
* @throws ioexception
*/
public boolean closeregion byte encodedregionname  final boolean zk
throws ioexception
// region administrative methods
/**
* flushes the memstore of the specified region.
* <p>
* this method is synchronous.
* @param regioninfo region to flush
* @throws notservingregionexception
* @throws ioexception
* @deprecated use {@link #flushregion(byte[])} instead
*/
void flushregion hregioninfo regioninfo
throws notservingregionexception  ioexception
/**
* splits the specified region.
* <p>
* this method currently flushes the region and then forces a compaction which
* will then trigger a split.  the flush is done synchronously but the
* compaction is asynchronous.
* @param regioninfo region to split
* @throws notservingregionexception
* @throws ioexception
*/
void splitregion hregioninfo regioninfo
throws notservingregionexception  ioexception
/**
* splits the specified region.
* <p>
* this method currently flushes the region and then forces a compaction which
* will then trigger a split.  the flush is done synchronously but the
* compaction is asynchronous.
* @param regioninfo region to split
* @param splitpoint the explicit row to split on
* @throws notservingregionexception
* @throws ioexception
*/
void splitregion hregioninfo regioninfo  byte splitpoint
throws notservingregionexception  ioexception
/**
* compacts the specified region.  performs a major compaction if specified.
* <p>
* this method is asynchronous.
* @param regioninfo region to compact
* @param major true to force major compaction
* @throws notservingregionexception
* @throws ioexception
*/
void compactregion hregioninfo regioninfo  boolean major
throws notservingregionexception  ioexception
/**
* replicates the given entries. the guarantee is that the given entries
* will be durable on the slave cluster if this method returns without
* any exception.
* hbase.replication has to be set to true for this to work.
*
* @param entries entries to replicate
* @throws ioexception
*/
public void replicatelogentries hlog entry entries  throws ioexception
/**
* executes a single {@link org.apache.hadoop.hbase.ipc.coprocessorprotocol}
* method using the registered protocol handlers.
* {@link coprocessorprotocol} implementations must be registered via the
* {@link org.apache.hadoop.hbase.regionserver.hregion#registerprotocol(class, org.apache.hadoop.hbase.ipc.coprocessorprotocol)}
* method before they are available.
*
* @param regionname name of the region against which the invocation is executed
* @param call an {@code exec} instance identifying the protocol, method name,
*     and parameters for the method invocation
* @return an {@code execresult} instance containing the region name of the
*     invocation and the return value
* @throws ioexception if no registered protocol handler is found or an error
*     occurs during the invocation
* @see org.apache.hadoop.hbase.regionserver.hregion#registerprotocol(class, org.apache.hadoop.hbase.ipc.coprocessorprotocol)
*/
execresult execcoprocessor byte regionname  exec call
throws ioexception
/**
* atomically checks if a row/family/qualifier value match the expectedvalue.
* if it does, it adds the put. if passed expected value is null, then the
* check is for non-existance of the row/column.
*
* @param regionname
* @param row
* @param family
* @param qualifier
* @param compareop
* @param comparator
* @param put
* @throws ioexception
* @return true if the new put was execute, false otherwise
*/
public boolean checkandput final byte regionname  final byte row
final byte family  final byte qualifier  final compareop compareop
final writablebytearraycomparable comparator  final put put
throws ioexception
/**
* atomically checks if a row/family/qualifier value match the expectedvalue.
* if it does, it adds the delete. if passed expected value is null, then the
* check is for non-existance of the row/column.
*
* @param regionname
* @param row
* @param family
* @param qualifier
* @param compareop
* @param comparator
* @param delete
* @throws ioexception
* @return true if the new put was execute, false otherwise
*/
public boolean checkanddelete final byte regionname  final byte row
final byte family  final byte qualifier  final compareop compareop
final writablebytearraycomparable comparator  final delete delete
throws ioexception
/**
* performs a blockcache summary and returns a list of blockcachecolumnfamilysummary objects.
* this method could be fairly heavyweight in that it evaluates the entire hbase file-system
* against what is in the regionserver blockcache.
*
* @return blockcachecolumnfamilysummary
* @throws ioexception exception
*/
public list<blockcachecolumnfamilysummary> getblockcachecolumnfamilysummaries   throws ioexception
/**
* roll the log writer. that is, start writing log messages to a new file.
*
* @throws ioexception
* @throws failedlogcloseexception
* @return if lots of logs, flush the returned regions so next time through
* we can clean logs. returns null if nothing to flush.  names are actual
* region names as returned by {@link hregioninfo#getencodedname()}
*/
public byte rollhlogwriter   throws ioexception  failedlogcloseexception
@override
public void stop string why