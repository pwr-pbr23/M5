/*
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase filter
import org apache hadoop hbase keyvalue
import org apache hadoop io writable
import java util list
/**
* interface for row and column filters directly applied within the regionserver.
* a filter can expect the following call sequence:
*<ul>
* <li>{@link #reset()}</li>
* <li>{@link #filterallremaining()} -> true indicates scan is over, false, keep going on.</li>
* <li>{@link #filterrowkey(byte[],int,int)} -> true to drop this row,
* if false, we will also call</li>
* <li>{@link #filterkeyvalue(keyvalue)} -> true to drop this key/value</li>
* <li>{@link #filterrow(list)} -> allows directmodification of the final list to be submitted
* <li>{@link #filterrow()} -> last chance to drop entire row based on the sequence of
* filtervalue() calls. eg: filter a row if it doesn't contain a specified column.
* </li>
* </ul>
*
* filter instances are created one per region/scan.  this interface replaces
* the old rowfilterinterface.
*
* when implementing your own filters, consider inheriting {@link filterbase} to help
* you reduce boilerplate.
*
* @see filterbase
*/
public interface filter extends writable
/**
* reset the state of the filter between rows.
*/
public void reset
/**
* filters a row based on the row key. if this returns true, the entire
* row will be excluded.  if false, each keyvalue in the row will be
* passed to {@link #filterkeyvalue(keyvalue)} below.
*
* @param buffer buffer containing row key
* @param offset offset into buffer where row key starts
* @param length length of the row key
* @return true, remove entire row, false, include the row (maybe).
*/
public boolean filterrowkey byte  buffer  int offset  int length
/**
* if this returns true, the scan will terminate.
*
* @return true to end scan, false to continue.
*/
public boolean filterallremaining
/**
* a way to filter based on the column family, column qualifier and/or the
* column value. return code is described below.  this allows filters to
* filter only certain number of columns, then terminate without matching ever
* column.
*
* if your filter returns <code>returncode.next_row</code>, it should return
* <code>returncode.next_row</code> until {@link #reset()} is called
* just in case the caller calls for the next row.
*
* @param v the keyvalue in question
* @return code as described below
* @see filter.returncode
*/
public returncode filterkeyvalue final keyvalue v
/**
* give the filter a chance to transform the passed keyvalue.
* if the keyvalue is changed a new keyvalue object must be returned.
* @see org.apache.hadoop.hbase.keyvalue#shallowcopy()
*
* the transformed keyvalue is what is eventually returned to the
* client. most filters will return the passed keyvalue unchanged.
* @see org.apache.hadoop.hbase.filter.keyonlyfilter#transform(keyvalue)
* for an example of a transformation.
*
* @param v the keyvalue in question
* @return the changed keyvalue
*/
public keyvalue transform final keyvalue v
/**
* return codes for filtervalue().
*/
public enum returncode
/**
* include the keyvalue
*/
include
/**
* skip this keyvalue
*/
skip
/**
* skip this column. go to the next column in this row.
*/
next_col
/**
* done with columns, skip to next row. note that filterrow() will
* still be called.
*/
next_row
/**
* seek to next key which is given as hint by the filter.
*/
seek_next_using_hint
/**
* chance to alter the list of keyvalues to be submitted.
* modifications to the list will carry on
* @param kvs the list of keyvalues to be filtered
*/
public void filterrow list<keyvalue> kvs
/**
* @return true if this filter actively uses filterrow(list).
* primarily used to check for conflicts with scans(such as scans
* that do not read a full row at a time)
*/
public boolean hasfilterrow
/**
* last chance to veto row based on previous {@link #filterkeyvalue(keyvalue)}
* calls. the filter needs to retain state then return a particular value for
* this call if they wish to exclude a row if a certain column is missing
* (for example).
* @return true to exclude row, false to include row.
*/
public boolean filterrow
/**
* if the filter returns the match code seek_next_using_hint, then
* it should also tell which is the next key it must seek to.
* after receiving the match code seek_next_using_hint, the querymatcher would
* call this function to find out which key it must next seek to.
* @return keyvalue which must be next seeked. return null if the filter is
* not sure which key to seek to next.
*/
public keyvalue getnextkeyhint final keyvalue currentkv