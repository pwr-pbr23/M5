/*
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import java io datainput
import java io dataoutput
import java io ioexception
import java util arraylist
import java util arrays
import java util comparator
import java util list
import java util map
import java util navigablemap
import java util treemap
import org apache hadoop hbase keyvalue
import org apache hadoop hbase keyvalue splitkeyvalue
import org apache hadoop hbase io immutablebyteswritable
import org apache hadoop hbase io writablewithsize
import org apache hadoop hbase util bytes
import org apache hadoop io writable
/**
* single row result of a {@link get} or {@link scan} query.<p>
*
* this class is not thread safe.<p>
*
* convenience methods are available that return various {@link map}
* structures and values directly.<p>
*
* to get a complete mapping of all cells in the result, which can include
* multiple families and multiple versions, use {@link #getmap()}.<p>
*
* to get a mapping of each family to its columns (qualifiers and values),
* including only the latest version of each, use {@link #getnoversionmap()}.
*
* to get a mapping of qualifiers to latest values for an individual family use
* {@link #getfamilymap(byte[])}.<p>
*
* to get the latest value for a specific family and qualifier use {@link #getvalue(byte[], byte[])}.
*
* a result is backed by an array of {@link keyvalue} objects, each representing
* an hbase cell defined by the row, family, qualifier, timestamp, and value.<p>
*
* the underlying {@link keyvalue} objects can be accessed through the method {@link #list()}.
* each keyvalue can then be accessed
* through {@link keyvalue#getrow()}, {@link keyvalue#getfamily()}, {@link keyvalue#getqualifier()},
* {@link keyvalue#gettimestamp()}, and {@link keyvalue#getvalue()}.
*/
public class result implements writable  writablewithsize
private static final byte result_version    byte 1
private keyvalue  kvs   null
private navigablemap<byte
navigablemap<byte  navigablemap<long  byte>>> familymap   null
// we're not using java serialization.  transient here is just a marker to say
// that this is where we cache row if we're ever asked for it.
private transient byte  row   null
private immutablebyteswritable bytes   null
/**
* constructor used for writable.
*/
public result
/**
* instantiate a result with the specified array of keyvalues.
* @param kvs array of keyvalues
*/
public result keyvalue  kvs
if kvs    null    kvs length > 0
this kvs   kvs
/**
* instantiate a result with the specified list of keyvalues.
* @param kvs list of keyvalues
*/
public result list<keyvalue> kvs
this kvs toarray new keyvalue
/**
* instantiate a result from the specified raw binary format.
* @param bytes raw binary format of result
*/
public result immutablebyteswritable bytes
this bytes   bytes
/**
* method for retrieving the row key that corresponds to
* the row from which this result was created.
* @return row
*/
public byte  getrow
if  this row    null
if this kvs    null
readfields
this row   this kvs length    0? null  this kvs getrow
return this row
/**
* return the array of keyvalues backing this result instance.
*
* the array is sorted from smallest -> largest using the
* {@link keyvalue#comparator}.
*
* the array only contains what your get or scan specifies and no more.
* for example if you request column "a" 1 version you will have at most 1
* keyvalue in the array. if you request column "a" with 2 version you will
* have at most 2 keyvalues, with the first one being the newer timestamp and
* the second being the older timestamp (this is the sort order defined by
* {@link keyvalue#comparator}).  if columns don't exist, they won't be
* present in the result. therefore if you ask for 1 version all columns,
* it is safe to iterate over this array and expect to see 1 keyvalue for
* each column and no more.
*
* this api is faster than using getfamilymap() and getmap()
*
* @return array of keyvalues
*/
public keyvalue raw
if this kvs    null
readfields
return kvs
/**
* create a sorted list of the keyvalue's in this result.
*
* since hbase 0.20.5 this is equivalent to raw().
*
* @return the sorted list of keyvalue's.
*/
public list<keyvalue> list
if this kvs    null
readfields
return isempty  ? null  arrays aslist raw
/**
* return the keyvalues for the specific column.  the keyvalues are sorted in
* the {@link keyvalue#comparator} order.  that implies the first entry in
* the list is the most recent column.  if the query (scan or get) only
* requested 1 version the list will contain at most 1 entry.  if the column
* did not exist in the result set (either the column does not exist
* or the column was not selected in the query) the list will be empty.
*
* also see getcolumnlatest which returns just a keyvalue
*
* @param family the family
* @param qualifier
* @return a list of keyvalues for this column or empty list if the column
* did not exist in the result set
*/
public list<keyvalue> getcolumn byte  family  byte  qualifier
list<keyvalue> result   new arraylist<keyvalue>
keyvalue  kvs   raw
if  kvs    null    kvs length    0
return result
int pos   binarysearch kvs  family  qualifier
if  pos     1
return result     cant find it
for  int i   pos   i < kvs length   i
keyvalue kv   kvs
if  kv matchingcolumn family qualifier
result add kv
else
break
return result
protected int binarysearch final keyvalue  kvs
final byte  family
final byte  qualifier
keyvalue searchterm
keyvalue createfirstonrow kvs getrow
family  qualifier
// pos === ( -(insertion point) - 1)
int pos   arrays binarysearch kvs  searchterm  keyvalue comparator
// never will exact match
if  pos < 0
pos    pos 1     1
// pos is now insertion point
if  pos    kvs length
return  1     doesn't exist
return pos
/**
* the keyvalue for the most recent for a given column. if the column does
* not exist in the result set - if it wasn't selected in the query (get/scan)
* or just does not exist in the row the return value is null.
*
* @param family
* @param qualifier
* @return keyvalue for the column or null
*/
public keyvalue getcolumnlatest byte  family  byte  qualifier
keyvalue  kvs   raw       side effect possibly
if  kvs    null    kvs length    0
return null
int pos   binarysearch kvs  family  qualifier
if  pos     1
return null
keyvalue kv   kvs
if  kv matchingcolumn family  qualifier
return kv
return null
/**
* get the latest version of the specified column.
* @param family family name
* @param qualifier column qualifier
* @return value of latest version of column, null if none found
*/
public byte getvalue byte  family  byte  qualifier
keyvalue kv   getcolumnlatest family  qualifier
if  kv    null
return null
return kv getvalue
/**
* checks for existence of the specified column.
* @param family family name
* @param qualifier column qualifier
* @return true if at least one value exists in the result, false if not
*/
public boolean containscolumn byte  family  byte  qualifier
keyvalue kv   getcolumnlatest family  qualifier
return kv    null
/**
* map of families to all versions of its qualifiers and values.
* <p>
* returns a three level map of the form:
* <code>map&amp;family,map&lt;qualifier,map&lt;timestamp,value>>></code>
* <p>
* note: all other map returning methods make use of this map internally.
* @return map from families to qualifiers to versions
*/
public navigablemap<byte  navigablemap<byte  navigablemap<long  byte>>> getmap
if this familymap    null
return this familymap
if isempty
return null
this familymap
new treemap<byte  navigablemap<byte  navigablemap<long  byte>>>
bytes bytes_comparator
for keyvalue kv   this kvs
splitkeyvalue splitkv   kv split
byte  family   splitkv getfamily
navigablemap<byte  navigablemap<long  byte>> columnmap
familymap get family
if columnmap    null
columnmap   new treemap<byte  navigablemap<long  byte>>
bytes bytes_comparator
familymap put family  columnmap
byte  qualifier   splitkv getqualifier
navigablemap<long  byte> versionmap   columnmap get qualifier
if versionmap    null
versionmap   new treemap<long  byte> new comparator<long>
public int compare long l1  long l2
return l2 compareto l1
columnmap put qualifier  versionmap
long timestamp   bytes tolong splitkv gettimestamp
byte  value   splitkv getvalue
versionmap put timestamp  value
return this familymap
/**
* map of families to their most recent qualifiers and values.
* <p>
* returns a two level map of the form: <code>map&amp;family,map&lt;qualifier,value>></code>
* <p>
* the most recent version of each qualifier will be used.
* @return map from families to qualifiers and value
*/
public navigablemap<byte  navigablemap<byte  byte>> getnoversionmap
if this familymap    null
getmap
if isempty
return null
navigablemap<byte  navigablemap<byte  byte>> returnmap
new treemap<byte  navigablemap<byte  byte>> bytes bytes_comparator
for map entry<byte  navigablemap<byte  navigablemap<long  byte>>>
familyentry   familymap entryset
navigablemap<byte  byte> qualifiermap
new treemap<byte  byte> bytes bytes_comparator
for map entry<byte  navigablemap<long  byte>> qualifierentry
familyentry getvalue   entryset
byte  value
qualifierentry getvalue   get qualifierentry getvalue   firstkey
qualifiermap put qualifierentry getkey    value
returnmap put familyentry getkey    qualifiermap
return returnmap
/**
* map of qualifiers to values.
* <p>
* returns a map of the form: <code>map&lt;qualifier,value></code>
* @param family column family to get
* @return map of qualifiers to values
*/
public navigablemap<byte  byte> getfamilymap byte  family
if this familymap    null
getmap
if isempty
return null
navigablemap<byte  byte> returnmap
new treemap<byte  byte> bytes bytes_comparator
navigablemap<byte  navigablemap<long  byte>> qualifiermap
familymap get family
if qualifiermap    null
return returnmap
for map entry<byte  navigablemap<long  byte>> entry
qualifiermap entryset
byte  value
entry getvalue   get entry getvalue   firstkey
returnmap put entry getkey    value
return returnmap
/**
* returns the value of the first column in the result.
* @return value of the first column
*/
public byte  value
if  isempty
return null
return kvs getvalue
/**
* returns the raw binary encoding of this result.<p>
*
* please note, there may be an offset into the underlying byte array of the
* returned immutablebyteswritable.  be sure to use both
* {@link immutablebyteswritable#get()} and {@link immutablebyteswritable#getoffset()}
* @return pointer to raw binary of result
*/
public immutablebyteswritable getbytes
return this bytes
/**
* check if the underlying keyvalue [] is empty or not
* @return true if empty
*/
public boolean isempty
if this kvs    null
readfields
return this kvs    null    this kvs length    0
/**
* @return the size of the underlying keyvalue []
*/
public int size
if this kvs    null
readfields
return this kvs    null? 0  this kvs length
/**
* @return string
*/
@override
public string tostring
stringbuilder sb   new stringbuilder
sb append
if isempty
sb append
return sb tostring
sb append
boolean morethanone   false
for keyvalue kv   this kvs
if morethanone
sb append
else
morethanone   true
sb append kv tostring
sb append
return sb tostring
//writable
public void readfields final datainput in
throws ioexception
familymap   null
row   null
kvs   null
int totalbuffer   in readint
if totalbuffer    0
bytes   null
return
byte  raw   new byte
in readfully raw  0  totalbuffer
bytes   new immutablebyteswritable raw  0  totalbuffer
//create keyvalue[] when needed
private void readfields
if  bytes    null
this kvs   new keyvalue
return
byte  buf   bytes get
int offset   bytes getoffset
int finaloffset   bytes getsize     offset
list<keyvalue> kvs   new arraylist<keyvalue>
while offset < finaloffset
int keylength   bytes toint buf  offset
offset    bytes sizeof_int
kvs add new keyvalue buf  offset  keylength
offset    keylength
this kvs   kvs toarray new keyvalue
public long getwritablesize
if  isempty
return bytes sizeof_int     int size   0
long size   bytes sizeof_int     totallen
for  keyvalue kv   kvs
size    kv getlength
size    bytes sizeof_int     kv getlength
return size
public void write final dataoutput out
throws ioexception
if isempty
out writeint 0
else
int totallen   0
for keyvalue kv   kvs
totallen    kv getlength     bytes sizeof_int
out writeint totallen
for keyvalue kv   kvs
out writeint kv getlength
out write kv getbuffer    kv getoffset    kv getlength
public static long getwritearraysize result  results
long size   bytes sizeof_byte     result_version
if  results    null    results length    0
size    bytes sizeof_int
return size
size    bytes sizeof_int     results length
size    bytes sizeof_int     buflen
for  result result   results
size    bytes sizeof_int     either 0 or result size
if  result    null    result isempty
continue
for  keyvalue kv   result raw
size    bytes sizeof_int     kv getlength
size    kv getlength
return size
public static void writearray final dataoutput out  result  results
throws ioexception
// write version when writing array form.
// this assumes that results are sent to the client as result[], so we
// have an opportunity to handle version differences without affecting
// efficiency.
out writebyte result_version
if results    null    results length    0
out writeint 0
return
out writeint results length
int buflen   0
for result result   results
buflen    bytes sizeof_int
if result    null    result isempty
continue
for keyvalue key   result raw
buflen    key getlength     bytes sizeof_int
out writeint buflen
for result result   results
if result    null    result isempty
out writeint 0
continue
out writeint result size
for keyvalue kv   result raw
out writeint kv getlength
out write kv getbuffer    kv getoffset    kv getlength
public static result  readarray final datainput in
throws ioexception
// read version for array form.
// this assumes that results are sent to the client as result[], so we
// have an opportunity to handle version differences without affecting
// efficiency.
int version   in readbyte
if  version > result_version
throw new ioexception
int numresults   in readint
if numresults    0
return new result
result  results   new result
int bufsize   in readint
byte  buf   new byte
int offset   0
for int i 0 i<numresults i
int numkeys   in readint
offset    bytes sizeof_int
if numkeys    0
results   new result  immutablebyteswritable null
continue
int initialoffset   offset
for int j 0 j<numkeys j
int keylen   in readint
bytes putint buf  offset  keylen
offset    bytes sizeof_int
in readfully buf  offset  keylen
offset    keylen
int totallength   offset   initialoffset
results   new result new immutablebyteswritable buf  initialoffset
totallength
return results
/**
* does a deep comparison of two results, down to the byte arrays.
* @param res1 first result to compare
* @param res2 second result to compare
* @throws exception every difference is throwing an exception
*/
public static void compareresults result res1  result res2
throws exception
if  res2    null
throw new exception
bytes tostringbinary res1 getrow
if  res1 size      res2 size
throw new exception
res1 tostring         res2 tostring
keyvalue ourkvs   res1 raw
keyvalue replicatedkvs   res2 raw
for  int i   0  i < res1 size    i
if   ourkvs equals replicatedkvs
bytes equals ourkvs getvalue    replicatedkvs getvalue
throw new exception
res1 tostring         res2 tostring