/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements. see the notice file distributed with this
* work for additional information regarding copyright ownership. the asf
* licenses this file to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
* http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis, without
* warranties or conditions of any kind, either express or implied. see the
* license for the specific language governing permissions and limitations
* under the license.
*/
package org apache hadoop hbase io encoding
import java io datainputstream
import java io dataoutputstream
import java io ioexception
import java nio bytebuffer
import org apache hadoop hbase keyvalue
import org apache hadoop io rawcomparator
/**
* encoding of keyvalue. it aims to be fast and efficient using assumptions:
* <ul>
* <li>the keyvalues are stored sorted by key</li>
* <li>we know the structure of keyvalue</li>
* <li>the values are always iterated forward from beginning of block</li>
* <li>knowledge of key value format</li>
* </ul>
* it is designed to work fast enough to be feasible as in memory compression.
*/
public interface datablockencoder
/**
* compress keyvalues and write them to output buffer.
* @param out where to write compressed data.
* @param in source of keyvalue for compression.
* @param includesmemstorets true if including memstore timestamp after every
*          key-value pair
* @throws ioexception if there is an error writing to output stream.
*/
public void compresskeyvalues dataoutputstream out
bytebuffer in  boolean includesmemstorets  throws ioexception
/**
* uncompress.
* @param source compressed stream of keyvalues.
* @param includesmemstorets true if including memstore timestamp after every
*          key-value pair
* @return uncompressed block of keyvalues.
* @throws ioexception if there is an error in source.
*/
public bytebuffer uncompresskeyvalues datainputstream source
boolean includesmemstorets  throws ioexception
/**
* uncompress.
* @param source compressed stream of keyvalues.
* @param allocateheaderlength allocate this many bytes for the header.
* @param skiplastbytes do not copy n last bytes.
* @param includesmemstorets true if including memstore timestamp after every
*          key-value pair
* @return uncompressed block of keyvalues.
* @throws ioexception if there is an error in source.
*/
public bytebuffer uncompresskeyvalues datainputstream source
int allocateheaderlength  int skiplastbytes  boolean includesmemstorets
throws ioexception
/**
* return first key in block. useful for indexing. typically does not make
* a deep copy but returns a buffer wrapping a segment of the actual block's
* byte array. this is because the first key in block is usually stored
* unencoded.
* @param block encoded block we want index, the position will not change
* @return first key in block.
*/
public bytebuffer getfirstkeyinblock bytebuffer block
/**
* create a hfileblock seeker which find keyvalues within a block.
* @param comparator what kind of comparison should be used
* @param includesmemstorets true if including memstore timestamp after every
*          key-value pair
* @return a newly created seeker.
*/
public encodedseeker createseeker rawcomparator<byte> comparator
boolean includesmemstorets
/**
* an interface which enable to seek while underlying data is encoded.
*
* it works on one hfileblock, but it is reusable. see
* {@link #setcurrentbuffer(bytebuffer)}.
*/
public static interface encodedseeker
/**
* set on which buffer there will be done seeking.
* @param buffer used for seeking.
*/
public void setcurrentbuffer bytebuffer buffer
/**
* does a deep copy of the key at the current position. a deep copy is
* necessary because buffers are reused in the decoder.
* @return key at current position
*/
public bytebuffer getkeydeepcopy
/**
* does a shallow copy of the value at the current position. a shallow
* copy is possible because the returned buffer refers to the backing array
* of the original encoded buffer.
* @return value at current position
*/
public bytebuffer getvalueshallowcopy
/** @return key value at current position. */
public bytebuffer getkeyvaluebuffer
/**
* @return the keyvalue object at the current position. includes memstore
*         timestamp.
*/
public keyvalue getkeyvalue
/** set position to beginning of given block */
public void rewind
/**
* move to next position
* @return true on success, false if there is no more positions.
*/
public boolean next
/**
* moves the seeker position within the current block to:
* <ul>
* <li>the last key that that is less than or equal to the given key if
* <code>seekbefore</code> is false</li>
* <li>the last key that is strictly less than the given key if <code>
* seekbefore</code> is true. the caller is responsible for loading the
* previous block if the requested key turns out to be the first key of the
* current block.</li>
* </ul>
* @param key byte array containing the key
* @param offset key position the array
* @param length key length in bytes
* @param seekbefore find the key strictly less than the given key in case
*          of an exact match. does not matter in case of an inexact match.
* @return 0 on exact match, 1 on inexact match.
*/
public int seektokeyinblock byte key  int offset  int length
boolean seekbefore