/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase io hfile
import java io bytearrayoutputstream
import java io ioexception
import java nio bytebuffer
import java util zip checksum
import org apache hadoop fs path
import org apache hadoop io dataoutputbuffer
import org apache hadoop hbase hconstants
import org apache hadoop hbase util bytes
import org apache hadoop hbase util checksumfactory
import org apache hadoop hbase util checksumtype
/**
* utility methods to compute and validate checksums.
*/
public class checksumutil
/** this is used to reserve space in a byte buffer */
private static byte dummy_value   new byte
/**
* this is used by unit tests to make checksum failures throw an
* exception instead of returning null. returning a null value from
* checksum validation will cause the higher layer to retry that
* read with hdfs-level checksums. instead, we would like checksum
* failures to cause the entire unit test to fail.
*/
private static boolean generateexceptions   false
/**
* generates a checksum for all the data in indata. the checksum is
* written to outdata.
* @param indata input data stream
* @param startoffset starting offset in the indata stream from where to
*                    compute checkums from
* @param endoffset ending offset in the indata stream upto
*                   which checksums needs to be computed
* @param outdata the output buffer where checksum values are written
* @param outoffset the starting offset in the outdata where the
*                  checksum values are written
* @param checksumtype type of checksum
* @param bytesperchecksum number of bytes per checksum value
*/
static void generatechecksums byte indata
int startoffset  int endoffset
byte outdata  int outoffset
checksumtype checksumtype
int bytesperchecksum  throws ioexception
if  checksumtype    checksumtype null
return     no checkums for this block
checksum checksum   checksumtype getchecksumobject
int bytesleft   endoffset   startoffset
int chunknum   0
while  bytesleft > 0
// generate the checksum for one chunk
checksum reset
int count   math min bytesleft  bytesperchecksum
checksum update indata  startoffset  count
// write the checksum value to the output buffer.
int cksumvalue    int checksum getvalue
outoffset   bytes putint outdata  outoffset  cksumvalue
chunknum
startoffset    count
bytesleft    count
/**
* validates that the data in the specified hfileblock matches the
* checksum.  generates the checksum for the data and
* then validate that it matches the value stored in the header.
* if there is a checksum mismatch, then return false. otherwise
* return true.
* the header is extracted from the specified hfileblock while the
* data-to-be-verified is extracted from 'data'.
*/
static boolean validateblockchecksum path path  hfileblock block
byte data  int hdrsize  throws ioexception
// if this is an older version of the block that does not have
// checksums, then return false indicating that checksum verification
// did not succeed. actually, this methiod should never be called
// when the minorversion is 0, thus this is a defensive check for a
// cannot-happen case. since this is a cannot-happen case, it is
// better to return false to indicate a checksum validation failure.
if  block getminorversion   < hfileblock minor_version_with_checksum
return false
// get a checksum object based on the type of checksum that is
// set in the hfileblock header. a checksumtype.null indicates that
// the caller is not interested in validating checksums, so we
// always return true.
checksumtype cktype   checksumtype codetotype block getchecksumtype
if  cktype    checksumtype null
return true     no checkums validations needed for this block
checksum checksumobject   cktype getchecksumobject
checksumobject reset
// read in the stored value of the checksum size from the header.
int bytesperchecksum   block getbytesperchecksum
// bytesperchecksum is always larger than the size of the header
if  bytesperchecksum < hdrsize
string msg
hdrsize
bytesperchecksum
hfile log warn msg
return false       cannot happen case  unable to verify checksum
// extract the header and compute checksum for the header.
bytebuffer hdr   block getbufferwithheader
checksumobject update hdr array    hdr arrayoffset    hdrsize
int off   hdrsize
int consumed   hdrsize
int bytesleft   block getondiskdatasizewithheader     off
int cksumoffset   block getondiskdatasizewithheader
// validate each chunk
while  bytesleft > 0
int thischunksize   bytesperchecksum   consumed
int count   math min bytesleft  thischunksize
checksumobject update data  off  count
int storedchecksum   bytes toint data  cksumoffset
if  storedchecksum     int checksumobject getvalue
string msg       path
storedchecksum
cksumoffset
checksumobject getvalue
data length
off       count
hfileblock tostringheader block getbufferreadonly
hfile log warn msg
if  generateexceptions
throw new ioexception msg      this is only for unit tests
else
return false                   checksum validation failure
cksumoffset    hfileblock checksum_size
bytesleft    count
off    count
consumed   0
checksumobject reset
return true     checksum is valid
/**
* returns the number of bytes needed to store the checksums for
* a specified data size
* @param datasize number of bytes of data
* @param bytesperchecksum number of bytes in a checksum chunk
* @return the number of bytes needed to store the checksum values
*/
static long numbytes long datasize  int bytesperchecksum
return numchunks datasize  bytesperchecksum
hfileblock checksum_size
/**
* returns the number of checksum chunks needed to store the checksums for
* a specified data size
* @param datasize number of bytes of data
* @param bytesperchecksum number of bytes in a checksum chunk
* @return the number of checksum chunks
*/
static long numchunks long datasize  int bytesperchecksum
long numchunks   datasize bytesperchecksum
if  datasize % bytesperchecksum    0
numchunks
return numchunks
/**
* write dummy checksums to the end of the specified bytes array
* to reserve space for writing checksums later
* @param baos outputstream to write dummy checkum values
* @param numbytes number of bytes of data for which dummy checksums
*                 need to be generated
* @param bytesperchecksum number of bytes per checksum value
*/
static void reservespaceforchecksums bytearrayoutputstream baos
int numbytes  int bytesperchecksum  throws ioexception
long numchunks   numchunks numbytes  bytesperchecksum
long bytesleft   numchunks   hfileblock checksum_size
while  bytesleft > 0
long count   math min bytesleft  dummy_value length
baos write dummy_value  0   int count
bytesleft    count
/**
* mechanism to throw an exception in case of hbase checksum
* failure. this is used by unit tests only.
* @param value setting this to true will cause hbase checksum
*              verification failures to generate exceptions.
*/
public static void generateexceptionforchecksumfailurefortest boolean value
generateexceptions   value