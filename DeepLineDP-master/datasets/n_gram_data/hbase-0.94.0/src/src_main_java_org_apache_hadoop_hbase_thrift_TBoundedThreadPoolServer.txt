/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase thrift
import java util concurrent executorservice
import java util concurrent linkedblockingqueue
import java util concurrent rejectedexecutionexception
import java util concurrent synchronousqueue
import java util concurrent threadpoolexecutor
import java util concurrent timeunit
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop hbase thrift callqueue call
import org apache hadoop hbase util threads
import org apache thrift texception
import org apache thrift tprocessor
import org apache thrift protocol tprotocol
import org apache thrift server tserver
import org apache thrift server tthreadpoolserver
import org apache thrift transport tservertransport
import org apache thrift transport tsocket
import org apache thrift transport ttransport
import org apache thrift transport ttransportexception
import com google common util concurrent threadfactorybuilder
/**
* a bounded thread pool server customized for hbase.
*/
public class tboundedthreadpoolserver extends tserver
private static final string queue_full_msg
/**
* the "core size" of the thread pool. new threads are created on every
* connection until this many threads are created.
*/
public static final string min_worker_threads_conf_key
/**
* this default core pool size should be enough for many test scenarios. we
* want to override this with a much larger number (e.g. at least 200) for a
* large-scale production setup.
*/
public static final int default_min_worker_threads   16
/**
* the maximum size of the thread pool. when the pending request queue
* overflows, new threads are created until their number reaches this number.
* after that, the server starts dropping connections.
*/
public static final string max_worker_threads_conf_key
public static final int default_max_worker_threads   1000
/**
* the maximum number of pending connections waiting in the queue. if there
* are no idle threads in the pool, the server queues requests. only when
* the queue overflows, new threads are added, up to
* hbase.thrift.maxqueuedrequests threads.
*/
public static final string max_queued_requests_conf_key
public static final int default_max_queued_requests   1000
/**
* default amount of time in seconds to keep a thread alive. worker threads
* are stopped after being idle for this long.
*/
public static final string thread_keep_alive_time_sec_conf_key
private static final int default_thread_keep_alive_time_sec   60
/**
* time to wait after interrupting all worker threads. this is after a clean
* shutdown has been attempted.
*/
public static final int time_to_wait_after_shutdown_ms   5000
private static final log log   logfactory getlog
tboundedthreadpoolserver class getname
private final callqueue callqueue
public static class args extends tthreadpoolserver args
int maxqueuedrequests
int threadkeepalivetimesec
public args tservertransport transport  configuration conf
super transport
minworkerthreads   conf getint min_worker_threads_conf_key
default_min_worker_threads
maxworkerthreads   conf getint max_worker_threads_conf_key
default_max_worker_threads
maxqueuedrequests   conf getint max_queued_requests_conf_key
default_max_queued_requests
threadkeepalivetimesec   conf getint thread_keep_alive_time_sec_conf_key
default_thread_keep_alive_time_sec
@override
public string tostring
return     minworkerthreads
maxworkerthreads
maxqueuedrequests
/** executor service for handling client connections */
private executorservice executorservice
/** flag for stopping the server */
private volatile boolean stopped
private args serveroptions
public tboundedthreadpoolserver args options  thriftmetrics metrics
super options
if  options maxqueuedrequests > 0
this callqueue   new callqueue
new linkedblockingqueue<call> options maxqueuedrequests   metrics
else
this callqueue   new callqueue new synchronousqueue<call>    metrics
threadfactorybuilder tfb   new threadfactorybuilder
tfb setdaemon true
tfb setnameformat
executorservice
new threadpoolexecutor options minworkerthreads
options maxworkerthreads  options threadkeepalivetimesec
timeunit seconds  this callqueue  tfb build
serveroptions   options
public void serve
try
servertransport_ listen
catch  ttransportexception ttx
log error    ttx
return
runtime getruntime   addshutdownhook
new thread getclass   getsimplename
@override
public void run
tboundedthreadpoolserver this stop
stopped   false
while   stopped     thread interrupted
ttransport client   null
try
client   servertransport_ accept
catch  ttransportexception ttx
if   stopped
log warn    ttx
continue
else
// the server has been stopped
break
clientconnnection command   new clientconnnection client
try
executorservice execute command
catch  rejectedexecutionexception rex
if  client getclass      tsocket class
// we expect the client to be tsocket.
log warn queue_full_msg
tsocket  client  getsocket   getremotesocketaddress
else
log warn queue_full_msg  rex
client close
shutdownserver
/**
* loop until {@link executorservice#awaittermination} finally does return
* without an interrupted exception. if we don't do this, then we'll shut
* down prematurely. we want to let the executor service clear its task
* queue, closing client sockets appropriately.
*/
private void shutdownserver
executorservice shutdown
long mslefttowait
serveroptions stoptimeoutunit tomillis serveroptions stoptimeoutval
long timemillis   system currenttimemillis
log info     mslefttowait
boolean interrupted   false
while  mslefttowait >  0
try
executorservice awaittermination mslefttowait  timeunit milliseconds
break
catch  interruptedexception ix
long timepassed   system currenttimemillis     timemillis
mslefttowait    timepassed
timemillis    timepassed
interrupted   true
log info
time_to_wait_after_shutdown_ms
// this will interrupt all the threads, even those running a task.
executorservice shutdownnow
threads sleepwithoutinterrupt time_to_wait_after_shutdown_ms
// preserve the interrupted status.
if  interrupted
thread currentthread   interrupt
log info
@override
public void stop
stopped   true
servertransport_ interrupt
private class clientconnnection implements runnable
private ttransport client
/**
* default constructor.
*
* @param client transport to process
*/
private clientconnnection ttransport client
this client   client
/**
* loops on processing a client forever
*/
public void run
tprocessor processor   null
ttransport inputtransport   null
ttransport outputtransport   null
tprotocol inputprotocol   null
tprotocol outputprotocol   null
try
processor   processorfactory_ getprocessor client
inputtransport   inputtransportfactory_ gettransport client
outputtransport   outputtransportfactory_ gettransport client
inputprotocol   inputprotocolfactory_ getprotocol inputtransport
outputprotocol   outputprotocolfactory_ getprotocol outputtransport
// we check stopped_ first to make sure we're not supposed to be shutting
// down. this is necessary for graceful shutdown.
while   stopped    processor process inputprotocol  outputprotocol
catch  ttransportexception ttx
// assume the client died and continue silently
catch  texception tx
log error    tx
catch  exception x
log error    x
if  inputtransport    null
inputtransport close
if  outputtransport    null
outputtransport close