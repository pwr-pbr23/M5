/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase catalog
import java io eofexception
import java io ioexception
import java net connectexception
import java net noroutetohostexception
import java net socketexception
import java net sockettimeoutexception
import java net unknownhostexception
import java util concurrent atomic atomicboolean
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop hbase abortable
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase notallmetaregionsonlineexception
import org apache hadoop hbase servername
import org apache hadoop hbase client hconnection
import org apache hadoop hbase client hconnectionmanager
import org apache hadoop hbase client retriesexhaustedexception
import org apache hadoop hbase ipc hregioninterface
import org apache hadoop hbase ipc servernotrunningyetexception
import org apache hadoop hbase util bytes
import org apache hadoop hbase zookeeper metanodetracker
import org apache hadoop hbase zookeeper rootregiontracker
import org apache hadoop hbase zookeeper zookeeperwatcher
import org apache hadoop ipc remoteexception
/**
* tracks the availability of the catalog tables <code>-root-</code> and
* <code>.meta.</code>.
*
* this class is "read-only" in that the locations of the catalog tables cannot
* be explicitly set.  instead, zookeeper is used to learn of the availability
* and location of <code>-root-</code>.  <code>-root-</code> is used to learn of
* the location of <code>.meta.</code>  if not available in <code>-root-</code>,
* zookeeper is used to monitor for a new location of <code>.meta.</code>.
*
* <p>call {@link #start()} to start up operation.  call {@link #stop()}} to
* interrupt waits and close up shop.
*/
public class catalogtracker
// todo: this class needs a rethink.  the original intent was that it would be
// the one-stop-shop for root and meta locations and that it would get this
// info from reading and watching zk state.  the class was to be used by
// servers when they needed to know of root and meta movement but also by
// client-side (inside in htable) so rather than figure root and meta
// locations on fault, the client would instead get notifications out of zk.
//
// but this original intent is frustrated by the fact that this class has to
// read an hbase table, the -root- table, to figure out the .meta. region
// location which means we depend on an hconnection.  hconnection will do
// retrying but also, it has its own mechanism for finding root and meta
// locations (and for 'verifying'; it tries the location and if it fails, does
// new lookup, etc.).  so, at least for now, hconnection (or htable) can't
// have a ct since ct needs a hconnection (even then, do want ht to have a ct?
// for ht keep up a session with zk?  rather, shouldn't we do like asynchbase
// where we'd open a connection to zk, read what we need then let the
// connection go?).  the 'fix' is make it so both root and meta addresses
// are wholey up in zk -- not in zk (root) -- and in an hbase table (meta).
//
// but even then, this class does 'verification' of the location and it does
// this by making a call over an hconnection (which will do its own root
// and meta lookups).  isn't this verification 'useless' since when we
// return, whatever is dependent on the result of this call then needs to
// use hconnection; what we have verified may change in meantime (hconnection
// uses the ct primitives, the root and meta trackers finding root locations).
//
// when meta is moved to zk, this class may make more sense.  in the
// meantime, it does not cohere.  it should just watch meta and root and not
// not do verification -- let that be out in hconnection since its going to
// be done there ultimately anyways.
//
// this class has spread throughout the codebase.  it needs to be reigned in.
// this class should be used server-side only, even if we move meta location
// up into zk.  currently its used over in the client package. its used in
// metareader and metaeditor classes usually just to get the configuration
// its using (it does this indirectly by asking its hconnection for its
// configuration and even then this is just used to get an hconnection out on
// the other end). i made https://issues.apache.org/jira/browse/hbase-4495 for
// doing ct fixup. st.ack 09/30/2011.
//
// todo: timeouts have never been as advertised in here and its worse now
// with retries; i.e. the hconnection retries and pause goes ahead whatever
// the passed timeout is.  fix.
private static final log log   logfactory getlog catalogtracker class
private final hconnection connection
private final zookeeperwatcher zookeeper
private final rootregiontracker rootregiontracker
private final metanodetracker metanodetracker
private final atomicboolean metaavailable   new atomicboolean false
private boolean instantiatedzkw   false
private abortable abortable
/*
* do not clear this address once set.  its needed when we do
* server shutdown processing -- we need to know who had .meta. last.  if you
* want to know if the address is good, rely on {@link #metaavailable} value.
*/
private servername metalocation
/*
* timeout waiting on root or meta to be set.
*/
private final int defaulttimeout
private boolean stopped   false
static final byte  root_region_name
hregioninfo root_regioninfo getregionname
static final byte  meta_region_name
hregioninfo first_meta_regioninfo getregionname
/**
* constructs a catalog tracker. find current state of catalog tables.
* begin active tracking by executing {@link #start()} post construction. does
* not timeout.
*
* @param conf
*          the {@link configuration} from which a {@link hconnection} will be
*          obtained; if problem, this connections
*          {@link hconnection#abort(string, throwable)} will be called.
* @throws ioexception
*/
public catalogtracker final configuration conf  throws ioexception
this null  conf  null
/**
* constructs the catalog tracker.  find current state of catalog tables.
* begin active tracking by executing {@link #start()} post construction.
* does not timeout.
* @param zk if zk is null, we'll create an instance (and shut it down
* when {@link #stop()} is called) else we'll use what is passed.
* @param conf
* @param abortable if fatal exception we'll call abort on this.  may be null.
* if it is we'll use the connection associated with the passed
* {@link configuration} as our abortable.
* @throws ioexception
*/
public catalogtracker final zookeeperwatcher zk  final configuration conf
final abortable abortable
throws ioexception
this zk  conf  abortable
conf getint    1000
/**
* constructs the catalog tracker.  find current state of catalog tables.
* begin active tracking by executing {@link #start()} post construction.
* @param zk if zk is null, we'll create an instance (and shut it down
* when {@link #stop()} is called) else we'll use what is passed.
* @param conf
* @param abortable if fatal exception we'll call abort on this.  may be null.
* if it is we'll use the connection associated with the passed
* {@link configuration} as our abortable.
* @param defaulttimeout timeout to use.  pass zero for no timeout
* ({@link object#wait(long)} when passed a <code>0</code> waits for ever).
* @throws ioexception
*/
public catalogtracker final zookeeperwatcher zk  final configuration conf
abortable abortable  final int defaulttimeout
throws ioexception
this zk  conf  hconnectionmanager getconnection conf   abortable  defaulttimeout
catalogtracker final zookeeperwatcher zk  final configuration conf
hconnection connection  abortable abortable  final int defaulttimeout
throws ioexception
this connection   connection
if  abortable    null
// a connection is abortable.
this abortable   this connection
abortable throwableaborter   new abortable
@override
public void abort string why  throwable e
throw new runtimeexception why  e
@override
public boolean isaborted
return true
if  zk    null
// create our own.  set flag so we tear it down on stop.
this zookeeper
new zookeeperwatcher conf      connection tostring
abortable
instantiatedzkw   true
else
this zookeeper   zk
this rootregiontracker   new rootregiontracker zookeeper  throwableaborter
final catalogtracker ct   this
// override nodedeleted so we get notified when meta node deleted
this metanodetracker   new metanodetracker zookeeper  throwableaborter
public void nodedeleted string path
if   path equals node   return
ct resetmetalocation
this defaulttimeout   defaulttimeout
/**
* starts the catalog tracker.
* determines current availability of catalog tables and ensures all further
* transitions of either region are tracked.
* @throws ioexception
* @throws interruptedexception
*/
public void start   throws ioexception  interruptedexception
log debug     this
try
this rootregiontracker start
this metanodetracker start
catch  runtimeexception e
throwable t   e getcause
this abortable abort e getmessage    t
throw new ioexception    t
/**
* stop working.
* interrupts any ongoing waits.
*/
public void stop
if   this stopped
log debug     this
this stopped   true
this rootregiontracker stop
this metanodetracker stop
try
if  this connection    null
this connection close
catch  ioexception e
// although the {@link closeable} interface throws an {@link
// ioexception}, in reality, the implementation would never do that.
log error    e
if  this instantiatedzkw
this zookeeper close
// call this and it will interrupt any ongoing waits on meta.
synchronized  this metaavailable
this metaavailable notifyall
/**
* gets the current location for <code>-root-</code> or null if location is
* not currently available.
* @return {@link servername} for server hosting <code>-root-</code> or null
* if none available
* @throws interruptedexception
*/
public servername getrootlocation   throws interruptedexception
return this rootregiontracker getrootregionlocation
/**
* @return {@link servername} for server hosting <code>.meta.</code> or null
* if none available
*/
public servername getmetalocation
return this metalocation
/**
* method used by master on startup trying to figure state of cluster.
* returns the current meta location unless its null.  in this latter case,
* it has not yet been set so go check whats up in <code>-root-</code> and
* return that.
* @return {@link servername} for server hosting <code>.meta.</code> or if null,
* we'll read the location that is up in <code>-root-</code> table (which
* could be null or just plain stale).
* @throws ioexception
*/
public servername getmetalocationorreadlocationfromroot   throws ioexception
servername sn   getmetalocation
return sn    null? sn  metareader getmetaregionlocation this
/**
* waits indefinitely for availability of <code>-root-</code>.  used during
* cluster startup.
* @throws interruptedexception if interrupted while waiting
*/
public void waitforroot
throws interruptedexception
this rootregiontracker blockuntilavailable
/**
* gets the current location for <code>-root-</code> if available and waits
* for up to the specified timeout if not immediately available.  returns null
* if the timeout elapses before root is available.
* @param timeout maximum time to wait for root availability, in milliseconds
* @return {@link servername} for server hosting <code>-root-</code> or null
* if none available
* @throws interruptedexception if interrupted while waiting
* @throws notallmetaregionsonlineexception if root not available before
* timeout
*/
servername waitforroot final long timeout
throws interruptedexception  notallmetaregionsonlineexception
servername sn   rootregiontracker waitrootregionlocation timeout
if  sn    null
throw new notallmetaregionsonlineexception     timeout
return sn
/**
* gets a connection to the server hosting root, as reported by zookeeper,
* waiting up to the specified timeout for availability.
* @param timeout how long to wait on root location
* @see #waitforroot(long) for additional information
* @return connection to server hosting root
* @throws interruptedexception
* @throws notallmetaregionsonlineexception if timed out waiting
* @throws ioexception
* @deprecated use #getrootserverconnection(long)
*/
public hregioninterface waitforrootserverconnection long timeout
throws interruptedexception  notallmetaregionsonlineexception  ioexception
return getrootserverconnection timeout
/**
* gets a connection to the server hosting root, as reported by zookeeper,
* waiting up to the specified timeout for availability.
* <p>warning: does not retry.  use an {@link htable} instead.
* @param timeout how long to wait on root location
* @see #waitforroot(long) for additional information
* @return connection to server hosting root
* @throws interruptedexception
* @throws notallmetaregionsonlineexception if timed out waiting
* @throws ioexception
*/
hregioninterface getrootserverconnection long timeout
throws interruptedexception  notallmetaregionsonlineexception  ioexception
return getcachedconnection waitforroot timeout
/**
* gets a connection to the server hosting root, as reported by zookeeper,
* waiting for the default timeout specified on instantiation.
* @see #waitforroot(long) for additional information
* @return connection to server hosting root
* @throws notallmetaregionsonlineexception if timed out waiting
* @throws ioexception
* @deprecated use #getrootserverconnection(long)
*/
public hregioninterface waitforrootserverconnectiondefault
throws notallmetaregionsonlineexception  ioexception
try
return getrootserverconnection this defaulttimeout
catch  interruptedexception e
throw new notallmetaregionsonlineexception
/**
* gets a connection to the server currently hosting <code>.meta.</code> or
* null if location is not currently available.
* <p>
* if a location is known, a connection to the cached location is returned.
* if refresh is true, the cached connection is verified first before
* returning.  if the connection is not valid, it is reset and rechecked.
* <p>
* if no location for meta is currently known, method checks root for a new
* location, verifies meta is currently there, and returns a cached connection
* to the server hosting meta.
*
* @return connection to server hosting meta, null if location not available
* @throws ioexception
* @throws interruptedexception
*/
private hregioninterface getmetaserverconnection
throws ioexception  interruptedexception
synchronized  metaavailable
if  metaavailable get
hregioninterface current   getcachedconnection this metalocation
// if we are to refresh, verify we have a good connection by making
// an invocation on it.
if  verifyregionlocation current  this metalocation  meta_region_name
return current
resetmetalocation
// we got here because there is no meta available or because whats
// available is bad.
// now read the current .meta. content from -root-.  note: this goes via
// an hconnection.  it has its own way of figuring root and meta locations
// which we have to wait on.
servername newlocation   metareader getmetaregionlocation this
if  newlocation    null  return null
hregioninterface newconnection   getcachedconnection newlocation
if  verifyregionlocation newconnection  newlocation  meta_region_name
setmetalocation newlocation
return newconnection
else
if  log istraceenabled
log trace     newlocation
this metalocation
return null
/**
* waits indefinitely for availability of <code>.meta.</code>.  used during
* cluster startup.  does not verify meta, just that something has been
* set up in zk.
* @see #waitformeta(long)
* @throws interruptedexception if interrupted while waiting
*/
public void waitformeta   throws interruptedexception
while   this stopped
try
if  waitformeta 100     null  break
catch  notallmetaregionsonlineexception e
if  log istraceenabled
log info
e getmessage
catch  ioexception e
log info    e
/**
* gets the current location for <code>.meta.</code> if available and waits
* for up to the specified timeout if not immediately available.  throws an
* exception if timed out waiting.  this method differs from {@link #waitformeta()}
* in that it will go ahead and verify the location gotten from zookeeper and
* -root- region by trying to use returned connection.
* @param timeout maximum time to wait for meta availability, in milliseconds
* @return {@link servername} for server hosting <code>.meta.</code> or null
* if none available
* @throws interruptedexception if interrupted while waiting
* @throws ioexception unexpected exception connecting to meta server
* @throws notallmetaregionsonlineexception if meta not available before
* timeout
*/
public servername waitformeta long timeout
throws interruptedexception  ioexception  notallmetaregionsonlineexception
long stop   system currenttimemillis     timeout
long waittime   math min 50  timeout
synchronized  metaavailable
while  stopped     timeout    0    system currenttimemillis   < stop
if  getmetaserverconnection      null
return metalocation
// perhaps -root- region isn't available, let us wait a bit and retry.
metaavailable wait waittime
if  getmetaserverconnection      null
throw new notallmetaregionsonlineexception     timeout
return metalocation
/**
* gets a connection to the server hosting meta, as reported by zookeeper,
* waiting up to the specified timeout for availability.
* @see #waitformeta(long) for additional information
* @return connection to server hosting meta
* @throws interruptedexception
* @throws notallmetaregionsonlineexception if timed out waiting
* @throws ioexception
* @deprecated does not retry; use an htable instance instead.
*/
public hregioninterface waitformetaserverconnection long timeout
throws interruptedexception  notallmetaregionsonlineexception  ioexception
return getcachedconnection waitformeta timeout
/**
* gets a connection to the server hosting meta, as reported by zookeeper,
* waiting up to the specified timeout for availability.
* used in tests.
* @see #waitformeta(long) for additional information
* @return connection to server hosting meta
* @throws notallmetaregionsonlineexception if timed out or interrupted
* @throws ioexception
* @deprecated does not retry; use an htable instance instead.
*/
public hregioninterface waitformetaserverconnectiondefault
throws notallmetaregionsonlineexception  ioexception
try
return getcachedconnection waitformeta defaulttimeout
catch  interruptedexception e
throw new notallmetaregionsonlineexception
/**
* called when we figure current meta is off (called from zk callback).
*/
public void resetmetalocation
log debug     metalocation
synchronized this metaavailable
this metaavailable set false
this metaavailable notifyall
/**
* @param metalocation
*/
void setmetalocation final servername metalocation
log debug     metalocation
synchronized  this metaavailable
this metalocation   metalocation
this metaavailable set true
// no synchronization because these are private and already under lock
this metaavailable notifyall
/**
* @param sn servername to get a connection against.
* @return the hregioninterface we got when we connected to <code>sn</code>
* may have come from cache, may not be good, may have been setup by this
* invocation, or may be null.
* @throws ioexception
*/
private hregioninterface getcachedconnection servername sn
throws ioexception
if  sn    null
return null
hregioninterface protocol   null
try
protocol   connection gethregionconnection sn gethostname    sn getport
catch  retriesexhaustedexception e
if  e getcause      null    e getcause   instanceof connectexception
// catch this; presume it means the cached connection has gone bad.
else
throw e
catch  sockettimeoutexception e
log debug     sn
catch  noroutetohostexception e
log debug     sn  e
catch  socketexception e
log debug     sn
catch  unknownhostexception e
log debug     sn
catch  ioexception ioe
throwable cause   ioe getcause
if  cause    null    cause instanceof eofexception
// catch. other end disconnected us.
else if  cause    null    cause getmessage      null
cause getmessage   tolowercase   contains
// catch. connection reset.
else
throw ioe
return protocol
/**
* verify we can connect to <code>hostingserver</code> and that its carrying
* <code>regionname</code>.
* @param hostingserver interface to the server hosting <code>regionname</code>
* @param servername the servername that goes with the <code>metaserver</code>
* interface.  used logging.
* @param regionname the regionname we are interested in.
* @return true if we were able to verify the region located at other side of
* the interface.
* @throws ioexception
*/
// todo: we should be able to get the servername from the hregioninterface
// rather than have to pass it in.  its made awkward by the fact that the
// hri is likely a proxy against remote server so the getservername needs
// to be fixed to go to a local method or to a cache before we can do this.
private boolean verifyregionlocation hregioninterface hostingserver
final servername address  final byte  regionname
throws ioexception
if  hostingserver    null
log info
return false
throwable t   null
try
// try and get regioninfo from the hosting server.
return hostingserver getregioninfo regionname     null
catch  connectexception e
t   e
catch  retriesexhaustedexception e
t   e
catch  remoteexception e
ioexception ioe   e unwrapremoteexception
t   ioe
catch  ioexception e
throwable cause   e getcause
if  cause    null    cause instanceof eofexception
t   cause
else if  cause    null    cause getmessage      null
cause getmessage   contains
t   cause
else
t   e
log info     bytes tostringbinary regionname
address       t
return false
/**
* verify <code>-root-</code> is deployed and accessible.
* @param timeout how long to wait on zk for root address (passed through to
* the internal call to {@link #waitforrootserverconnection(long)}.
* @return true if the <code>-root-</code> location is healthy.
* @throws ioexception
* @throws interruptedexception
*/
public boolean verifyrootregionlocation final long timeout
throws interruptedexception  ioexception
hregioninterface connection   null
try
connection   waitforrootserverconnection timeout
catch  notallmetaregionsonlineexception e
// pass
catch  servernotrunningyetexception e
// pass -- remote server is not up so can't be carrying root
catch  unknownhostexception e
// pass -- server name doesn't resolve so it can't be assigned anything.
return  connection    null ? false
verifyregionlocation connection
this rootregiontracker getrootregionlocation    root_region_name
/**
* verify <code>.meta.</code> is deployed and accessible.
* @param timeout how long to wait on zk for <code>.meta.</code> address
* (passed through to the internal call to {@link #waitformetaserverconnection(long)}.
* @return true if the <code>.meta.</code> location is healthy.
* @throws ioexception some unexpected ioe.
* @throws interruptedexception
*/
public boolean verifymetaregionlocation final long timeout
throws interruptedexception  ioexception
hregioninterface connection   null
try
connection   waitformetaserverconnection timeout
catch  notallmetaregionsonlineexception e
// pass
catch  servernotrunningyetexception e
// pass -- remote server is not up so can't be carrying .meta.
catch  unknownhostexception e
// pass -- server name doesn't resolve so it can't be assigned anything.
catch  retriesexhaustedexception e
// pass -- failed after bunch of retries.
log debug    e
return connection    null
// used by tests.
metanodetracker getmetanodetracker
return this metanodetracker
public hconnection getconnection
return this connection