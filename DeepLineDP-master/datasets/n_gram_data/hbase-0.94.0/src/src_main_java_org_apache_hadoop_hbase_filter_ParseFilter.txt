/**
* copyright 2011 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase filter
import java lang reflect invocationtargetexception
import java lang reflect method
import java nio bytebuffer
import java nio charset charactercodingexception
import java util
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase keyvalue
import org apache hadoop hbase filter comparefilter compareop
import org apache hadoop hbase util bytes
/**
* this class allows a user to specify a filter via a string
* the string is parsed using the methods of this class and
* a filter object is constructed. this filter object is then wrapped
* in a scanner object which is then returned
* <p>
* this class addresses the hbase-4168 jira. more documentaton on this
* filter language can be found at: https://issues.apache.org/jira/browse/hbase-4176
*/
public class parsefilter
private static final log log   logfactory getlog parsefilter class
private static hashmap<bytebuffer  integer> operatorprecedencehashmap
private static hashmap<string  string> filterhashmap
static
// registers all the filter supported by the filter language
filterhashmap   new hashmap<string  string>
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
filterhashmap put    parseconstants filter_package
// creates the operatorprecedencehashmap
operatorprecedencehashmap   new hashmap<bytebuffer  integer>
operatorprecedencehashmap put parseconstants skip_buffer  1
operatorprecedencehashmap put parseconstants while_buffer  1
operatorprecedencehashmap put parseconstants and_buffer  2
operatorprecedencehashmap put parseconstants or_buffer  3
/**
* parses the filterstring and constructs a filter using it
* <p>
* @param filterstring filter string given by the user
* @return filter object we constructed
*/
public filter parsefilterstring  string filterstring
throws charactercodingexception
return parsefilterstring bytes tobytes filterstring
/**
* parses the filterstring and constructs a filter using it
* <p>
* @param filterstringasbytearray filter string given by the user
* @return filter object we constructed
*/
public filter parsefilterstring  byte  filterstringasbytearray
throws charactercodingexception
// stack for the operators and parenthesis
stack <bytebuffer> operatorstack   new stack<bytebuffer>
// stack for the filter objects
stack <filter> filterstack   new stack<filter>
filter filter   null
for  int i 0  i<filterstringasbytearray length  i
if  filterstringasbytearray    parseconstants lparen
// lparen found
operatorstack push parseconstants lparen_buffer
else if  filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants tab
// whitespace or tab found
continue
else if  checkforor filterstringasbytearray  i
// or found
i    parseconstants or_array length   1
reduce operatorstack  filterstack  parseconstants or_buffer
operatorstack push parseconstants or_buffer
else if  checkforand filterstringasbytearray  i
// and found
i    parseconstants and_array length   1
reduce operatorstack  filterstack  parseconstants and_buffer
operatorstack push parseconstants and_buffer
else if  checkforskip filterstringasbytearray  i
// skip found
i    parseconstants skip_array length   1
reduce operatorstack  filterstack  parseconstants skip_buffer
operatorstack push parseconstants skip_buffer
else if  checkforwhile filterstringasbytearray  i
// while found
i    parseconstants while_array length   1
reduce operatorstack  filterstack  parseconstants while_buffer
operatorstack push parseconstants while_buffer
else if  filterstringasbytearray    parseconstants rparen
// rparen found
if  operatorstack empty
throw new illegalargumentexception
bytebuffer argumentontopofstack   operatorstack peek
while    argumentontopofstack equals parseconstants lparen_buffer
filterstack push poparguments operatorstack  filterstack
if  operatorstack empty
throw new illegalargumentexception
argumentontopofstack   operatorstack pop
else
// simplefilterexpression found
byte  filtersimpleexpression   extractfiltersimpleexpression filterstringasbytearray  i
i    filtersimpleexpression length   1
filter   parsesimplefilterexpression filtersimpleexpression
filterstack push filter
// finished parsing filterstring
while   operatorstack empty
filterstack push poparguments operatorstack  filterstack
filter   filterstack pop
if   filterstack empty
throw new illegalargumentexception
return filter
/**
* extracts a simple filter expression from the filter string given by the user
* <p>
* a simplefilterexpression is of the form: filtername('arg', 'arg', 'arg')
* the user given filter string can have many simplefilterexpressions combined
* using operators.
* <p>
* this function extracts a simplefilterexpression from the
* larger filterstring given the start offset of the simpler expression
* <p>
* @param filterstringasbytearray filter string given by the user
* @param filterexpressionstartoffset start index of the simple filter expression
* @return byte array containing the simple filter expression
*/
public byte  extractfiltersimpleexpression  byte  filterstringasbytearray
int filterexpressionstartoffset
throws charactercodingexception
int quotecount   0
for  int i filterexpressionstartoffset  i<filterstringasbytearray length  i
if  filterstringasbytearray    parseconstants single_quote
if  isquoteunescaped filterstringasbytearray  i
quotecount
else
// to skip the next quote that has been escaped
i
if  filterstringasbytearray    parseconstants rparen     quotecount %2      0
byte  filtersimpleexpression   new byte
bytes putbytes filtersimpleexpression  0  filterstringasbytearray
filterexpressionstartoffset  i filterexpressionstartoffset   1
return filtersimpleexpression
throw new illegalargumentexception
/**
* constructs a filter object given a simple filter expression
* <p>
* @param filterstringasbytearray filter string given by the user
* @return filter object we constructed
*/
public filter parsesimplefilterexpression  byte  filterstringasbytearray
throws charactercodingexception
string filtername   bytes tostring getfiltername filterstringasbytearray
arraylist<byte > filterarguments   getfilterarguments filterstringasbytearray
if   filterhashmap containskey filtername
throw new illegalargumentexception     filtername
try
filtername   filterhashmap get filtername
class c   class forname filtername
class argtypes   new class   arraylist class
method m   c getdeclaredmethod    argtypes
return  filter  m invoke null filterarguments
catch  classnotfoundexception e
e printstacktrace
catch  nosuchmethodexception e
e printstacktrace
catch  illegalaccessexception e
e printstacktrace
catch  invocationtargetexception e
e printstacktrace
throw new illegalargumentexception
new string filterstringasbytearray
/**
* returns the filter name given a simple filter expression
* <p>
* @param filterstringasbytearray a simple filter expression
* @return name of filter in the simple filter expression
*/
public static byte  getfiltername  byte  filterstringasbytearray
int filternamestartindex   0
int filternameendindex   0
for  int i filternamestartindex  i<filterstringasbytearray length  i
if  filterstringasbytearray    parseconstants lparen
filterstringasbytearray    parseconstants whitespace
filternameendindex   i
break
if  filternameendindex    0
throw new illegalargumentexception
byte  filtername   new byte
bytes putbytes filtername  0  filterstringasbytearray  0
filternameendindex   filternamestartindex
return filtername
/**
* returns the arguments of the filter from the filter string
* <p>
* @param filterstringasbytearray filter string given by the user
* @return an arraylist containing the arguments of the filter in the filter string
*/
public static arraylist<byte > getfilterarguments  byte  filterstringasbytearray
int argumentliststartindex   keyvalue getdelimiter filterstringasbytearray  0
filterstringasbytearray length
parseconstants lparen
if  argumentliststartindex     1
throw new illegalargumentexception
int argumentstartindex   0
int argumentendindex   0
arraylist<byte > filterarguments   new arraylist<byte >
for  int i   argumentliststartindex   1  i<filterstringasbytearray length  i
if  filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants comma
filterstringasbytearray    parseconstants rparen
continue
// the argument is in single quotes - for example 'prefix'
if  filterstringasbytearray    parseconstants single_quote
argumentstartindex   i
for  int j   argumentstartindex 1  j < filterstringasbytearray length  j
if  filterstringasbytearray    parseconstants single_quote
if  isquoteunescaped filterstringasbytearray j
argumentendindex   j
i   j 1
byte  filterargument   createunescapdargument filterstringasbytearray
argumentstartindex  argumentendindex
filterarguments add filterargument
break
else
// to jump over the second escaped quote
j
else if  j    filterstringasbytearray length   1
throw new illegalargumentexception
else
// the argument is an integer, boolean, comparison operator like <, >, != etc
argumentstartindex   i
for  int j   argumentstartindex  j < filterstringasbytearray length  j
if  filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants comma
filterstringasbytearray    parseconstants rparen
argumentendindex   j   1
i   j
byte  filterargument   new byte
bytes putbytes filterargument  0  filterstringasbytearray
argumentstartindex  argumentendindex   argumentstartindex   1
filterarguments add filterargument
break
else if  j    filterstringasbytearray length   1
throw new illegalargumentexception
return filterarguments
/**
* this function is called while parsing the filterstring and an operator is parsed
* <p>
* @param operatorstack the stack containing the operators and parenthesis
* @param filterstack the stack containing the filters
* @param operator the operator found while parsing the filterstring
*/
public void reduce stack<bytebuffer> operatorstack
stack<filter> filterstack
bytebuffer operator
while   operatorstack empty
parseconstants lparen_buffer equals operatorstack peek
hashigherpriority operatorstack peek    operator
filterstack push poparguments operatorstack  filterstack
/**
* pops an argument from the operator stack and the number of arguments required by the operator
* from the filterstack and evaluates them
* <p>
* @param operatorstack the stack containing the operators
* @param filterstack the stack containing the filters
* @return the evaluated filter
*/
public static filter poparguments  stack<bytebuffer> operatorstack  stack <filter> filterstack
bytebuffer argumentontopofstack   operatorstack peek
if  argumentontopofstack equals parseconstants or_buffer
// the top of the stack is an or
try
arraylist<filter> listoffilters   new arraylist<filter>
while   operatorstack empty      operatorstack peek   equals parseconstants or_buffer
filter filter   filterstack pop
listoffilters add 0  filter
operatorstack pop
filter filter   filterstack pop
listoffilters add 0  filter
filter orfilter   new filterlist filterlist operator must_pass_one  listoffilters
return orfilter
catch  emptystackexception e
throw new illegalargumentexception
else if  argumentontopofstack equals parseconstants and_buffer
// the top of the stack is an and
try
arraylist<filter> listoffilters   new arraylist<filter>
while   operatorstack empty      operatorstack peek   equals parseconstants and_buffer
filter filter   filterstack pop
listoffilters add 0  filter
operatorstack pop
filter filter   filterstack pop
listoffilters add 0  filter
filter andfilter   new filterlist filterlist operator must_pass_all  listoffilters
return andfilter
catch  emptystackexception e
throw new illegalargumentexception
else if  argumentontopofstack equals parseconstants skip_buffer
// the top of the stack is a skip
try
filter wrappedfilter   filterstack pop
filter skipfilter   new skipfilter wrappedfilter
operatorstack pop
return skipfilter
catch  emptystackexception e
throw new illegalargumentexception
else if  argumentontopofstack equals parseconstants while_buffer
// the top of the stack is a while
try
filter wrappedfilter   filterstack pop
filter whilematchfilter   new whilematchfilter wrappedfilter
operatorstack pop
return whilematchfilter
catch  emptystackexception e
throw new illegalargumentexception
else if  argumentontopofstack equals parseconstants lparen_buffer
// the top of the stack is a lparen
try
filter filter    filterstack pop
operatorstack pop
return filter
catch  emptystackexception e
throw new illegalargumentexception
else
throw new illegalargumentexception
/**
* returns which operator has higher precedence
* <p>
* if a has higher precedence than b, it returns true
* if they have the same precedence, it returns false
*/
public boolean hashigherpriority bytebuffer a  bytebuffer b
if   operatorprecedencehashmap get a    operatorprecedencehashmap get b   < 0
return true
return false
/**
* removes the single quote escaping a single quote - thus it returns an unescaped argument
* <p>
* @param filterstringasbytearray filter string given by user
* @param argumentstartindex start index of the argument
* @param argumentendindex end index of the argument
* @return returns an unescaped argument
*/
public static byte  createunescapdargument  byte  filterstringasbytearray
int argumentstartindex  int argumentendindex
int unescapedargumentlength   2
for  int i   argumentstartindex   1  i <  argumentendindex   1  i
unescapedargumentlength
if  filterstringasbytearray    parseconstants single_quote
i     argumentendindex   1
filterstringasbytearray    parseconstants single_quote
i
continue
byte  unescapedargument   new byte
int count   1
unescapedargument
for  int i   argumentstartindex   1  i <  argumentendindex   1  i
if  filterstringasbytearray     parseconstants single_quote
i     argumentendindex   1
filterstringasbytearray     parseconstants single_quote
unescapedargument   filterstringasbytearray
i
else
unescapedargument   filterstringasbytearray
unescapedargument
return unescapedargument
/**
* checks if the current index of filter string we are on is the beginning of the keyword 'or'
* <p>
* @param filterstringasbytearray filter string given by the user
* @param indexofor index at which an 'o' was read
* @return true if the keyword 'or' is at the current index
*/
public static boolean checkforor  byte  filterstringasbytearray  int indexofor
throws charactercodingexception  arrayindexoutofboundsexception
try
if  filterstringasbytearray    parseconstants o
filterstringasbytearray    parseconstants r
filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants rparen
filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants lparen
return true
else
return false
catch  arrayindexoutofboundsexception e
return false
/**
* checks if the current index of filter string we are on is the beginning of the keyword 'and'
* <p>
* @param filterstringasbytearray filter string given by the user
* @param indexofand index at which an 'a' was read
* @return true if the keyword 'and' is at the current index
*/
public static boolean checkforand  byte  filterstringasbytearray  int indexofand
throws charactercodingexception
try
if  filterstringasbytearray    parseconstants a
filterstringasbytearray    parseconstants n
filterstringasbytearray    parseconstants d
filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants rparen
filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants lparen
return true
else
return false
catch  arrayindexoutofboundsexception e
return false
/**
* checks if the current index of filter string we are on is the beginning of the keyword 'skip'
* <p>
* @param filterstringasbytearray filter string given by the user
* @param indexofskip index at which an 's' was read
* @return true if the keyword 'skip' is at the current index
*/
public static boolean checkforskip  byte  filterstringasbytearray  int indexofskip
throws charactercodingexception
try
if  filterstringasbytearray    parseconstants s
filterstringasbytearray    parseconstants k
filterstringasbytearray    parseconstants i
filterstringasbytearray    parseconstants p
indexofskip    0
filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants rparen
filterstringasbytearray    parseconstants lparen
filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants lparen
return true
else
return false
catch  arrayindexoutofboundsexception e
return false
/**
* checks if the current index of filter string we are on is the beginning of the keyword 'while'
* <p>
* @param filterstringasbytearray filter string given by the user
* @param indexofwhile index at which an 'w' was read
* @return true if the keyword 'while' is at the current index
*/
public static boolean checkforwhile  byte  filterstringasbytearray  int indexofwhile
throws charactercodingexception
try
if  filterstringasbytearray    parseconstants w
filterstringasbytearray    parseconstants h
filterstringasbytearray    parseconstants i
filterstringasbytearray    parseconstants l
filterstringasbytearray    parseconstants e
indexofwhile    0    filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants rparen
filterstringasbytearray    parseconstants lparen
filterstringasbytearray    parseconstants whitespace
filterstringasbytearray    parseconstants lparen
return true
else
return false
catch  arrayindexoutofboundsexception e
return false
/**
* returns a boolean indicating whether the quote was escaped or not
* <p>
* @param array byte array in which the quote was found
* @param quoteindex index of the single quote
* @return returns true if the quote was unescaped
*/
public static boolean isquoteunescaped  byte  array  int quoteindex
if  array    null
throw new illegalargumentexception
if  quoteindex    array length   1    array    parseconstants single_quote
return true
else
return false
/**
* takes a quoted byte array and converts it into an unquoted byte array
* for example: given a byte array representing 'abc', it returns a
* byte array representing abc
* <p>
* @param quotedbytearray the quoted byte array
* @return unquoted byte array
*/
public static byte  removequotesfrombytearray  byte  quotedbytearray
if  quotedbytearray    null
quotedbytearray length < 2
quotedbytearray    parseconstants single_quote
quotedbytearray    parseconstants single_quote
throw new illegalargumentexception
else
byte  targetstring   new byte
bytes putbytes targetstring  0  quotedbytearray  1  quotedbytearray length   2
return targetstring
/**
* converts an int expressed in a byte array to an actual int
* <p>
* this doesn't use bytes.toint because that assumes
* that there will be {@link bytes#sizeof_int} bytes available.
* <p>
* @param numberasbytearray the int value expressed as a byte array
* @return the int value
*/
public static int convertbytearraytoint  byte  numberasbytearray
long tempresult   parsefilter convertbytearraytolong numberasbytearray
if  tempresult > integer max_value
throw new illegalargumentexception
else if  tempresult < integer min_value
throw new illegalargumentexception
int result    int  tempresult
return result
/**
* converts a long expressed in a byte array to an actual long
* <p>
* this doesn't use bytes.tolong because that assumes
* that there will be {@link bytes#sizeof_int} bytes available.
* <p>
* @param numberasbytearray the long value expressed as a byte array
* @return the long value
*/
public static long convertbytearraytolong  byte  numberasbytearray
if  numberasbytearray    null
throw new illegalargumentexception
int i   0
long result   0
boolean isnegative   false
if  numberasbytearray    parseconstants minus_sign
i
isnegative   true
while  i    numberasbytearray length
if  numberasbytearray < parseconstants zero
numberasbytearray > parseconstants nine
throw new illegalargumentexception
result   result 10    numberasbytearray   parseconstants zero
if  result < 0
throw new illegalargumentexception
i
if  isnegative
return  result
else
return result
/**
* converts a boolean expressed in a byte array to an actual boolean
*<p>
* this doesn't used bytes.toboolean because bytes.toboolean(byte [])
* assumes that 1 stands for true and 0 for false.
* here, the byte array representing "true" and "false" is parsed
* <p>
* @param booleanasbytearray the boolean value expressed as a byte array
* @return the boolean value
*/
public static boolean convertbytearraytoboolean  byte  booleanasbytearray
if  booleanasbytearray    null
throw new illegalargumentexception
if  booleanasbytearray length    4
booleanasbytearray         booleanasbytearray
booleanasbytearray         booleanasbytearray
booleanasbytearray         booleanasbytearray
booleanasbytearray         booleanasbytearray
return true
else if  booleanasbytearray length    5
booleanasbytearray         booleanasbytearray
booleanasbytearray         booleanasbytearray
booleanasbytearray         booleanasbytearray
booleanasbytearray         booleanasbytearray
booleanasbytearray         booleanasbytearray
return false
else
throw new illegalargumentexception
/**
* takes a compareoperator symbol as a byte array and returns the corresponding compareoperator
* <p>
* @param compareopasbytearray the comparatoroperator symbol as a byte array
* @return the compare operator
*/
public static comparefilter compareop createcompareop  byte  compareopasbytearray
bytebuffer compareop   bytebuffer wrap compareopasbytearray
if  compareop equals parseconstants less_than_buffer
return compareop less
else if  compareop equals parseconstants less_than_or_equal_to_buffer
return compareop less_or_equal
else if  compareop equals parseconstants greater_than_buffer
return compareop greater
else if  compareop equals parseconstants greater_than_or_equal_to_buffer
return compareop greater_or_equal
else if  compareop equals parseconstants not_equal_to_buffer
return compareop not_equal
else if  compareop equals parseconstants equal_to_buffer
return compareop equal
else
throw new illegalargumentexception
/**
* parses a comparator of the form comparatortype:comparatorvalue form and returns a comparator
* <p>
* @param comparator the comparator in the form comparatortype:comparatorvalue
* @return the parsed comparator
*/
public static writablebytearraycomparable createcomparator  byte  comparator
if  comparator    null
throw new illegalargumentexception
byte  parsedcomparator   parsefilter parsecomparator comparator
byte  comparatortype   parsedcomparator
byte  comparatorvalue   parsedcomparator
if  bytes equals comparatortype  parseconstants binarytype
return new binarycomparator comparatorvalue
else if  bytes equals comparatortype  parseconstants binaryprefixtype
return new binaryprefixcomparator comparatorvalue
else if  bytes equals comparatortype  parseconstants regexstringtype
return new regexstringcomparator new string comparatorvalue
else if  bytes equals comparatortype  parseconstants substringtype
return new substringcomparator new string comparatorvalue
else
throw new illegalargumentexception
/**
* splits a column in comparatortype:comparatorvalue form into separate byte arrays
* <p>
* @param comparator the comparator
* @return the parsed arguments of the comparator as a 2d byte array
*/
public static byte  parsecomparator  byte  comparator
final int index   keyvalue getdelimiter comparator  0  comparator length  parseconstants colon
if  index     1
throw new illegalargumentexception
byte  result   new byte
result   new byte
system arraycopy comparator  0  result  0  index
final int len   comparator length    index   1
result   new byte
system arraycopy comparator  index   1  result  0  len
return result
/**
* return a set of filters supported by the filter language
*/
public set<string> getsupportedfilters
return filterhashmap keyset
/**
* returns all known filters
* @return an unmodifiable map of filters
*/
public static map<string  string> getallfilters
return collections unmodifiablemap filterhashmap
/**
* register a new filter with the parser.  if the filter is already registered,
* an illegalargumentexception will be thrown.
*
* @param name a name for the filter
* @param filterclass fully qualified class name
*/
public static void registerfilter string name  string filterclass
if log isinfoenabled
log info     name
filterhashmap put name  filterclass