/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import java lang ref reference
import java lang ref referencequeue
import java lang ref softreference
import java util arraylist
import java util collection
import java util collections
import java util comparator
import java util linkedhashset
import java util map
import java util navigablemap
import java util set
import java util sortedmap
import java util treemap
/**
* a sortedmap implementation that uses soft reference values
* internally to make it play well with the gc when in a low-memory
* situation. use as a cache where you also need sortedmap functionality.
*
* @param <k> key class
* @param <v> value class
*/
public class softvaluesortedmap<k v> implements sortedmap<k v>
private final sortedmap<k  softvalue<k v>> internalmap
private final referencequeue<v> rq   new referencequeue<v>
private object sync
/** constructor */
public softvaluesortedmap
this new treemap<k  softvalue<k v>>
/**
* constructor
* @param c comparator
*/
public softvaluesortedmap final comparator<k> c
this new treemap<k  softvalue<k v>> c
/** internal constructor
* @param original object to wrap and synchronize on
*/
private softvaluesortedmap sortedmap<k softvalue<k v>> original
this original  original
/** internal constructor
* for headmap, tailmap, and submap support
* @param original object to wrap
* @param sync object to synchronize on
*/
private softvaluesortedmap sortedmap<k softvalue<k v>> original  object sync
this internalmap   original
this sync   sync
/**
* checks soft references and cleans any that have been placed on
* referencequeue.  call if get/put etc. are not called regularly.
* internally these call checkreferences on each access.
* @return how many references cleared.
*/
@suppresswarnings
private int checkreferences
int i   0
for  reference<? extends v> ref   ref   this rq poll       null
i
this internalmap remove   softvalue<k v> ref  key
return i
public v put k key  v value
synchronized sync
checkreferences
softvalue<k v> oldvalue   this internalmap put key
new softvalue<k v> key  value  this rq
return oldvalue    null ? null   oldvalue get
@override
public void putall map<? extends k  ? extends v> m
throw new runtimeexception
public v get object key
synchronized sync
checkreferences
softvalue<k v> value   this internalmap get key
if  value    null
return null
if  value get      null
this internalmap remove key
return null
return value get
public v remove object key
synchronized sync
checkreferences
softvalue<k v> value   this internalmap remove key
return value    null ? null   value get
public boolean containskey object key
synchronized sync
checkreferences
return this internalmap containskey key
public boolean containsvalue object value
throw new unsupportedoperationexception
public k firstkey
synchronized sync
checkreferences
return internalmap firstkey
public k lastkey
synchronized sync
checkreferences
return internalmap lastkey
public softvaluesortedmap<k v> headmap k key
synchronized sync
checkreferences
return new softvaluesortedmap<k v> this internalmap headmap key   sync
public softvaluesortedmap<k v> tailmap k key
synchronized sync
checkreferences
return new softvaluesortedmap<k v> this internalmap tailmap key   sync
public softvaluesortedmap<k v> submap k fromkey  k tokey
synchronized sync
checkreferences
return new softvaluesortedmap<k v> this internalmap submap fromkey
tokey   sync
/*
* retrieves the value associated with the greatest key strictly less than
*  the given key, or null if there is no such key
* @param key the key we're interested in
*/
public synchronized v lowervaluebykey k key
synchronized sync
checkreferences
map entry<k softvalue<k v>> entry
navigablemap<k  softvalue<k v>>  this internalmap  lowerentry key
if  entry  null
return null
softvalue<k v> value entry getvalue
if  value  null
return null
if  value get      null
this internalmap remove key
return null
return value get
public boolean isempty
synchronized sync
checkreferences
return this internalmap isempty
public int size
synchronized sync
checkreferences
return this internalmap size
public void clear
synchronized sync
checkreferences
this internalmap clear
public set<k> keyset
synchronized sync
checkreferences
// this is not correct as per sortedmap contract (keyset should be
// modifiable)
// needed here so that another thread cannot modify the keyset
// without locking
return collections unmodifiableset this internalmap keyset
public comparator<? super k> comparator
return this internalmap comparator
public set<map entry<k v>> entryset
synchronized sync
checkreferences
// this is not correct as per sortedmap contract (entryset should be
// backed by map)
set<map entry<k  v>> realentries   new linkedhashset<map entry<k  v>>
for  map entry<k  softvalue<k  v>> entry   this internalmap entryset
realentries add entry getvalue
return realentries
public collection<v> values
synchronized sync
checkreferences
arraylist<v> hardvalues   new arraylist<v>
for  softvalue<k v> softvalue   this internalmap values
hardvalues add softvalue get
return hardvalues
private static class softvalue<k v> extends softreference<v> implements map entry<k  v>
final k key
softvalue k key  v value  referencequeue<v> q
super value  q
this key   key
public k getkey
return this key
public v getvalue
return get
public v setvalue v value
throw new runtimeexception