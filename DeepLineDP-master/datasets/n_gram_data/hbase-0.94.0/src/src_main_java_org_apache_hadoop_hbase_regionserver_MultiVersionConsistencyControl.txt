/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver
import java util linkedlist
import org apache hadoop hbase util bytes
import org apache hadoop hbase util classsize
import org apache commons logging logfactory
import org apache commons logging log
/**
* manages the read/write consistency within memstore. this provides
* an interface for readers to determine what entries to ignore, and
* a mechanism for writers to obtain new write numbers, then "commit"
* the new writes for readers to read (thus forming atomic transactions).
*/
public class multiversionconsistencycontrol
private volatile long memstoreread   0
private volatile long memstorewrite   0
private final object readwaiters   new object
// this is the pending queue of writes.
private final linkedlist<writeentry> writequeue
new linkedlist<writeentry>
private static final threadlocal<long> perthreadreadpoint
new threadlocal<long>
@override
protected
long initialvalue
return long max_value
/**
* default constructor. initializes the memstoreread/write points to 0.
*/
public multiversionconsistencycontrol
this memstoreread   this memstorewrite   0
/**
* initializes the memstoreread/write points appropriately.
* @param startpoint
*/
public void initialize long startpoint
synchronized  writequeue
if  this memstorewrite    this memstoreread
throw new runtimeexception
this memstoreread   this memstorewrite   startpoint
/**
* get this thread's read point. used primarily by the memstore scanner to
* know which values to skip (ie: have not been completed/committed to
* memstore).
*/
public static long getthreadreadpoint
return perthreadreadpoint get
/**
* set the thread read point to the given value. the thread mvcc
* is used by the memstore scanner so it knows which values to skip.
* give it a value of 0 if you want everything.
*/
public static void setthreadreadpoint long readpoint
perthreadreadpoint set readpoint
/**
* set the thread mvcc read point to whatever the current read point is in
* this particular instance of mvcc.  returns the new thread read point value.
*/
public static long resetthreadreadpoint multiversionconsistencycontrol mvcc
perthreadreadpoint set mvcc memstorereadpoint
return getthreadreadpoint
/**
* set the thread mvcc read point to 0 (include everything).
*/
public static void resetthreadreadpoint
perthreadreadpoint set 0l
public writeentry beginmemstoreinsert
synchronized  writequeue
long nextwritenumber     memstorewrite
writeentry e   new writeentry nextwritenumber
writequeue add e
return e
public void completememstoreinsert writeentry e
advancememstore e
waitforread e
boolean advancememstore writeentry e
synchronized  writequeue
e markcompleted
long nextreadvalue    1
boolean ranonce false
while   writequeue isempty
ranonce true
writeentry queuefirst   writequeue getfirst
if  nextreadvalue > 0
if  nextreadvalue 1    queuefirst getwritenumber
throw new runtimeexception
nextreadvalue       queuefirst getwritenumber
if  queuefirst iscompleted
nextreadvalue   queuefirst getwritenumber
writequeue removefirst
else
break
if   ranonce
throw new runtimeexception
if  nextreadvalue > 0
synchronized  readwaiters
memstoreread   nextreadvalue
readwaiters notifyall
if  memstoreread >  e getwritenumber
return true
return false
/**
* wait for the global readpoint to advance upto
* the specified transaction number.
*/
public void waitforread writeentry e
boolean interrupted   false
synchronized  readwaiters
while  memstoreread < e getwritenumber
try
readwaiters wait 0
catch  interruptedexception ie
// we were interrupted... finish the loop -- i.e. cleanup --and then
// on our way out, reset the interrupt flag.
interrupted   true
if  interrupted  thread currentthread   interrupt
public long memstorereadpoint
return memstoreread
public static class writeentry
private long writenumber
private boolean completed   false
writeentry long writenumber
this writenumber   writenumber
void markcompleted
this completed   true
boolean iscompleted
return this completed
long getwritenumber
return this writenumber
public static final long fixed_size   classsize align
classsize object
2   bytes sizeof_long
2   classsize reference