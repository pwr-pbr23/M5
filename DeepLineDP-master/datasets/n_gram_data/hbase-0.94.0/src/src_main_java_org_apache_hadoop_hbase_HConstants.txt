/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase
import java util arraylist
import java util arrays
import java util list
import java util uuid
import java util regex pattern
import org apache hadoop hbase ipc hregioninterface
import org apache hadoop hbase util bytes
/**
* hconstants holds a bunch of hbase-related constants
*/
public final class hconstants
/**
* status codes used for return values of bulk operations.
*/
public enum operationstatuscode
not_run
success
sanity_check_failure
failure
/** long constant for zero */
public static final long zero_l   long valueof 0l
public static final string nines
public static final string zeroes
// for migration
/** name of version file */
public static final string version_file_name
/**
* current version of file system.
* version 4 supports only one kind of bloom filter.
* version 5 changes versions in catalog table regions.
* version 6 enables blockcaching on catalog tables.
* version 7 introduces hfile -- hbase 0.19 to 0.20..
*/
// public static final string file_system_version = "6";
public static final string file_system_version
// configuration parameters
//todo: is having hbase homed on port 60k ok?
/** cluster is in distributed mode or not */
public static final string cluster_distributed
/** config for pluggable load balancers */
public static final string hbase_master_loadbalancer_class
/** cluster is standalone or pseudo-distributed */
public static final boolean cluster_is_local   false
/** cluster is fully-distributed */
public static final boolean cluster_is_distributed   true
/** default value for cluster distributed mode */
public static final boolean default_cluster_distributed   cluster_is_local
/** default host address */
public static final string default_host
/** parameter name for port master listens on. */
public static final string master_port
/** default port that the master listens on */
public static final int default_master_port   60000
/** default port for master web api */
public static final int default_master_infoport   60010
/** parameter name for the master type being backup (waits for primary to go inactive). */
public static final string master_type_backup
/** by default every master is a possible primary master unless the conf explicitly overrides it */
public static final boolean default_master_type_backup   false
/** name of zookeeper quorum configuration parameter. */
public static final string zookeeper_quorum
/** name of zookeeper config file in conf/ directory. */
public static final string zookeeper_config_name
/** common prefix of zookeeper configuration properties */
public static final string zk_cfg_property_prefix
public static final int zk_cfg_property_prefix_len
zk_cfg_property_prefix length
/**
* the zk client port key in the zk properties map. the name reflects the
* fact that this is not an hbase configuration key.
*/
public static final string client_port_str
/** parameter name for the client port that the zookeeper listens on */
public static final string zookeeper_client_port
zk_cfg_property_prefix   client_port_str
/** default client port that the zookeeper listens on */
public static final int default_zookeper_client_port   2181
/** parameter name for the wait time for the recoverable zookeeper */
public static final string zookeeper_recoverable_waittime
/** default wait time for the recoverable zookeeper */
public static final long default_zookeper_recoverable_waitime   10000
/** parameter name for the root dir in zk for this cluster */
public static final string zookeeper_znode_parent
public static final string default_zookeeper_znode_parent
/**
* parameter name for the limit on concurrent client-side zookeeper
* connections
*/
public static final string zookeeper_max_client_cnxns
zk_cfg_property_prefix
/** parameter name for the zk data directory */
public static final string zookeeper_data_dir
zk_cfg_property_prefix
/** default limit on concurrent client-side zookeeper connections */
public static final int default_zookeper_max_client_cnxns   300
/** configuration key for zookeeper session timeout */
public static final string zk_session_timeout
/** default value for zookeeper session timeout */
public static final int default_zk_session_timeout   180   1000
/** parameter name for port region server listens on. */
public static final string regionserver_port
/** default port region server listens on. */
public static final int default_regionserver_port   60020
/** default port for region server web api */
public static final int default_regionserver_infoport   60030
/** a flag that enables automatic selection of regionserver info port */
public static final string regionserver_info_port_auto
/** parameter name for what region server interface to use. */
public static final string region_server_class
/** parameter name for what region server implementation to use. */
public static final string region_server_impl
/** default region server interface class name. */
public static final string default_region_server_class   hregioninterface class getname
/** parameter name for what master implementation to use. */
public static final string master_impl
/** parameter name for how often threads should wake up */
public static final string thread_wake_frequency
/** default value for thread wake frequency */
public static final int default_thread_wake_frequency   10   1000
/** parameter name for how often we should try to write a version file, before failing */
public static final string version_file_write_attempts
/** parameter name for how often we should try to write a version file, before failing */
public static final int default_version_file_write_attempts   3
/** parameter name for how often a region should should perform a major compaction */
public static final string major_compaction_period
/** parameter name for hbase instance root directory */
public static final string hbase_dir
/** parameter name for hbase client ipc pool type */
public static final string hbase_client_ipc_pool_type
/** parameter name for hbase client ipc pool size */
public static final string hbase_client_ipc_pool_size
/** parameter name for hbase client operation timeout, which overrides rpc timeout */
public static final string hbase_client_operation_timeout
/** default hbase client operation timeout, which is tantamount to a blocking call */
public static final int default_hbase_client_operation_timeout   integer max_value
/** used to construct the name of the log directory for a region server
* use '.' as a special character to seperate the log files from table data */
public static final string hregion_logdir_name
/** used to construct the name of the splitlog directory for a region server */
public static final string split_logdir_name
public static final string corrupt_dir_name
/** like the previous, but for old logs that are about to be deleted */
public static final string hregion_oldlogdir_name
/** used to construct the name of the compaction directory during compaction */
public static final string hregion_compactiondir_name
/** conf key for the max file size after which we split the region */
public static final string hregion_max_filesize
/** default maximum file size */
public static final long default_max_file_size   10   1024   1024   1024l
/**
* the max number of threads used for opening and closing stores or store
* files in parallel
*/
public static final string hstore_open_and_close_threads_max
/**
* the default number for the max number of threads used for opening and
* closing stores or store files in parallel
*/
public static final int default_hstore_open_and_close_threads_max   1
/** conf key for the memstore size at which we flush the memstore */
public static final string hregion_memstore_flush_size
/** default size of a reservation block   */
public static final int default_size_reservation_block   1024   1024   5
/** maximum value length, enforced on keyvalue construction */
public static final int maximum_value_length   integer max_value
/** name of the file for unique cluster id */
public static final string cluster_id_file_name
/** configuration key storing the cluster id */
public static final string cluster_id
// always store the location of the root table's hregion.
// this hregion is never split.
// region name = table + startkey + regionid. this is the row key.
// each row in the root and meta tables describes exactly 1 region
// do we ever need to know all the information that we are storing?
// note that the name of the root table starts with "-" and the name of the
// meta table starts with "." why? it's a trick. it turns out that when we
// store region names in memory, we use a sortedmap. since "-" sorts before
// "." (and since no other table name can start with either of these
// characters, the root region will always be the first entry in such a map,
// followed by all the meta regions (which will be ordered by their starting
// row key as well), followed by all user tables. so when the master is
// choosing regions to assign, it will always choose the root region first,
// followed by the meta regions, followed by user regions. since the root
// and meta regions always need to be on-line, this ensures that they will
// be the first to be reassigned if the server(s) they are being served by
// should go down.
/** the root table's name.*/
public static final byte  root_table_name   bytes tobytes
/** the meta table's name. */
public static final byte  meta_table_name   bytes tobytes
/** delimiter used between portions of a region name */
public static final int meta_row_delimiter
/** the catalog family as a string*/
public static final string catalog_family_str
/** the catalog family */
public static final byte  catalog_family   bytes tobytes catalog_family_str
/** the regioninfo column qualifier */
public static final byte  regioninfo_qualifier   bytes tobytes
/** the server column qualifier */
public static final byte  server_qualifier   bytes tobytes
/** the startcode column qualifier */
public static final byte  startcode_qualifier   bytes tobytes
/** the lower-half split region column qualifier */
public static final byte  splita_qualifier   bytes tobytes
/** the upper-half split region column qualifier */
public static final byte  splitb_qualifier   bytes tobytes
/**
* the meta table version column qualifier.
* we keep current version of the meta table in this column in <code>-root-</code>
* table: i.e. in the 'info:v' column.
*/
public static final byte  meta_version_qualifier   bytes tobytes
/**
* the current version of the meta table.
* before this the meta had htabledescriptor serialized into the hregioninfo;
* i.e. pre-hbase 0.92.  there was no meta_version column in the root table
* in this case.  the presence of a version and its value being zero indicates
* meta is up-to-date.
*/
public static final short meta_version   0
// other constants
/**
* an empty instance.
*/
public static final byte  empty_byte_array   new byte
/**
* used by scanners, etc when they want to start at the beginning of a region
*/
public static final byte  empty_start_row   empty_byte_array
/**
* last row in a table.
*/
public static final byte  empty_end_row   empty_start_row
/**
* used by scanners and others when they're trying to detect the end of a
* table
*/
public static final byte  last_row   empty_byte_array
/**
* max length a row can have because of the limitation in tfile.
*/
public static final int max_row_length   short max_value
/** when we encode strings, we always specify utf8 encoding */
public static final string utf8_encoding
/**
* timestamp to use when we want to refer to the latest cell.
* this is the timestamp sent by clients when no timestamp is specified on
* commit.
*/
public static final long latest_timestamp   long max_value
/**
* timestamp to use when we want to refer to the oldest cell.
*/
public static final long oldest_timestamp   long min_value
/**
* latest_timestamp in bytes form
*/
public static final byte  latest_timestamp_bytes   bytes tobytes latest_timestamp
/**
* define for 'return-all-versions'.
*/
public static final int all_versions   integer max_value
/**
* unlimited time-to-live.
*/
//  public static final int forever = -1;
public static final int forever   integer max_value
/**
* seconds in a week
*/
public static final int week_in_seconds   7   24   3600
//todo: although the following are referenced widely to format strings for
//      the shell. they really aren't a part of the public api. it would be
//      nice if we could put them somewhere where they did not need to be
//      public. they could have package visibility
public static final string name
public static final string versions
public static final string in_memory
/**
* this is a retry backoff multiplier table similar to the bsd tcp syn
* backoff table, a bit more aggressive than simple exponential backoff.
*/
public static int retry_backoff     1  1  1  2  2  4  4  8  16  32
public static final string region_impl
/** modifytable op for replacing the table descriptor */
public static enum modify
close_region
table_compact
table_flush
table_major_compact
table_set_htd
table_split
/**
* scope tag for locally scoped data.
* this data will not be replicated.
*/
public static final int replication_scope_local   0
/**
* scope tag for globally scoped data.
* this data will be replicated to all peers.
*/
public static final int replication_scope_global   1
/**
* default cluster id, cannot be used to identify a cluster so a key with
* this value means it wasn't meant for replication.
*/
public static final uuid default_cluster_id   new uuid 0l 0l
/**
* parameter name for maximum number of bytes returned when calling a
* scanner's next method.
*/
public static string hbase_client_scanner_max_result_size_key
/**
* maximum number of bytes returned when calling a scanner's next method.
* note that when a single row is larger than this limit the row is still
* returned completely.
*
* the default value is unlimited.
*/
public static long default_hbase_client_scanner_max_result_size   long max_value
/**
* parameter name for client pause value, used mostly as value to wait
* before running a retry of a failed get, region lookup, etc.
*/
public static string hbase_client_pause
/**
* default value of {@link #hbase_client_pause}.
*/
public static long default_hbase_client_pause   1000
/**
* parameter name for maximum retries, used as maximum for all retryable
* operations such as fetching of the root region from root region server,
* getting a cell's value, starting a row update, etc.
*/
public static string hbase_client_retries_number
/**
* default value of {@link #hbase_client_retries_number}.
*/
public static int default_hbase_client_retries_number   10
/**
* parameter name for maximum attempts, used to limit the number of times the
* client will try to obtain the proxy for a given region server.
*/
public static string hbase_client_rpc_maxattempts
/**
* default value of {@link #hbase_client_rpc_maxattempts}.
*/
public static int default_hbase_client_rpc_maxattempts   1
/**
* parameter name for client prefetch limit, used as the maximum number of regions
* info that will be prefetched.
*/
public static string hbase_client_prefetch_limit
/**
* default value of {@link #hbase_client_prefetch_limit}.
*/
public static int default_hbase_client_prefetch_limit   10
/**
* parameter name for number of rows that will be fetched when calling next on
* a scanner if it is not served from memory. higher caching values will
* enable faster scanners but will eat up more memory and some calls of next
* may take longer and longer times when the cache is empty.
*/
public static string hbase_meta_scanner_caching
/**
* default value of {@link #hbase_meta_scanner_caching}.
*/
public static int default_hbase_meta_scanner_caching   100
/**
* parameter name for unique identifier for this {@link org.apache.hadoop.conf.configuration}
* instance. if there are two or more {@link org.apache.hadoop.conf.configuration} instances that,
* for all intents and purposes, are the same except for their instance ids,
* then they will not be able to share the same {@link org.apache.hadoop.hbase.client.hconnection} instance.
* on the other hand, even if the instance ids are the same, it could result
* in non-shared {@link org.apache.hadoop.hbase.client.hconnection}
* instances if some of the other connection parameters differ.
*/
public static string hbase_client_instance_id
/**
* hregion server lease period in milliseconds. clients must report in within this period
* else they are considered dead. unit measured in ms (milliseconds).
*/
public static string hbase_regionserver_lease_period_key
/**
* default value of {@link #hbase_regionserver_lease_period_key}.
*/
public static long default_hbase_regionserver_lease_period   60000
/**
* timeout for each rpc
*/
public static string hbase_rpc_timeout_key
/**
* default value of {@link #hbase_rpc_timeout_key}
*/
public static int default_hbase_rpc_timeout   60000
/*
* cluster replication constants.
*/
public static final string
replication_enable_key
public static final string
replication_source_service_classname
public static final string
replication_sink_service_classname
public static final string replication_service_classname_default
/** hbck special code name used as server name when manipulating zk nodes */
public static final string hbck_code_name
public static final servername hbck_code_servername
new servername hbck_code_name   1   1l
public static final string key_for_hostname_seen_by_master
public static final string hbase_master_logcleaner_plugins
public static final string hbase_region_split_policy_key
/**
* configuration key for the size of the block cache
*/
public static final string hfile_block_cache_size_key
public static final float hfile_block_cache_size_default   0 25f
/*
* minimum percentage of free heap necessary for a successful cluster startup.
*/
public static final float hbase_cluster_minimum_memory_threshold   0 2f
public static final list<string> hbase_non_user_table_dirs   new arraylist<string>
arrays aslist new string  hregion_logdir_name  hregion_oldlogdir_name
corrupt_dir_name  bytes tostring meta_table_name
bytes tostring root_table_name   split_logdir_name
public static final pattern cp_htd_attr_key_pattern   pattern compile
pattern case_insensitive
public static final pattern cp_htd_attr_value_pattern
pattern compile
public static final string cp_htd_attr_value_param_key_pattern
public static final string cp_htd_attr_value_param_value_pattern
public static final pattern cp_htd_attr_value_param_pattern   pattern compile
cp_htd_attr_value_param_key_pattern
cp_htd_attr_value_param_value_pattern
/** the delay when re-trying a socket operation in a loop (hbase-4712) */
public static final int socket_retry_wait_ms   200
/** host name of the local machine */
public static final string localhost
/** enable file permission modification from standard hbase */
public static final string enable_data_file_umask
/** file permission umask to use when creating hbase data files */
public static final string data_file_umask_key
/**
* if this parameter is set to true, then hbase will read
* data and then verify checksums. checksum verification
* inside hdfs will be switched off.  however, if the hbase-checksum
* verification fails, then it will switch back to using
* hdfs checksums for verifiying data that is being read from storage.
*
* if this parameter is set to false, then hbase will not
* verify any checksums, instead it will depend on checksum verification
* being done in the hdfs client.
*/
public static final string hbase_checksum_verification
/**
* the name of the configuration parameter that specifies
* the number of bytes in a newly created checksum chunk.
*/
public static final string bytes_per_checksum
/**
* the name of the configuration parameter that specifies
* the name of an algorithm that is used to compute checksums
* for newly created blocks.
*/
public static final string checksum_type_name
/** configuration name of hlog compression */
public static final string enable_wal_compression
private hconstants
// can't be instantiated with this ctor.