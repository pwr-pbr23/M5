/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import java io datainput
import java io dataoutput
import java io ioexception
import java io unsupportedencodingexception
import java lang reflect field
import java math bigdecimal
import java math biginteger
import java nio bytebuffer
import java nio byteorder
import java security accesscontroller
import java security privilegedaction
import java util comparator
import java util iterator
import org apache commons lang stringutils
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase hconstants
import org apache hadoop hbase io immutablebyteswritable
import org apache hadoop io rawcomparator
import org apache hadoop io writablecomparator
import org apache hadoop io writableutils
import sun misc unsafe
import com google common annotations visiblefortesting
/**
* utility class that handles byte arrays, conversions to/from other types,
* comparisons, hash code generation, manufacturing keys for hashmaps or
* hashsets, etc.
*/
public class bytes
private static final log log   logfactory getlog bytes class
/**
* size of boolean in bytes
*/
public static final int sizeof_boolean   byte size   byte size
/**
* size of byte in bytes
*/
public static final int sizeof_byte   sizeof_boolean
/**
* size of char in bytes
*/
public static final int sizeof_char   character size   byte size
/**
* size of double in bytes
*/
public static final int sizeof_double   double size   byte size
/**
* size of float in bytes
*/
public static final int sizeof_float   float size   byte size
/**
* size of int in bytes
*/
public static final int sizeof_int   integer size   byte size
/**
* size of long in bytes
*/
public static final int sizeof_long   long size   byte size
/**
* size of short in bytes
*/
public static final int sizeof_short   short size   byte size
/**
* estimate of size cost to pay beyond payload in jvm for instance of byte [].
* estimate based on study of jhat and jprofiler numbers.
*/
// jhat says bu is 56 bytes.
// sizeof which uses java.lang.instrument says 24 bytes. (3 longs?)
public static final int estimated_heap_tax   16
/**
* byte array comparator class.
*/
public static class bytearraycomparator implements rawcomparator<byte >
/**
* constructor
*/
public bytearraycomparator
super
public int compare byte  left  byte  right
return compareto left  right
public int compare byte  b1  int s1  int l1  byte  b2  int s2  int l2
return lexicographicalcomparerholder best_comparer
compareto b1  s1  l1  b2  s2  l2
/**
* pass this to treemaps where byte [] are keys.
*/
public static comparator<byte > bytes_comparator
new bytearraycomparator
/**
* use comparing byte arrays, byte-by-byte
*/
public static rawcomparator<byte > bytes_rawcomparator
new bytearraycomparator
/**
* read byte-array written with a writableableutils.vint prefix.
* @param in input to read from.
* @return byte array read off <code>in</code>
* @throws ioexception e
*/
public static byte  readbytearray final datainput in
throws ioexception
int len   writableutils readvint in
if  len < 0
throw new negativearraysizeexception integer tostring len
byte  result   new byte
in readfully result  0  len
return result
/**
* read byte-array written with a writableableutils.vint prefix.
* ioexception is converted to a runtimeexception.
* @param in input to read from.
* @return byte array read off <code>in</code>
*/
public static byte  readbytearraythrowsruntime final datainput in
try
return readbytearray in
catch  exception e
throw new runtimeexception e
/**
* write byte-array with a writableableutils.vint prefix.
* @param out output stream to be written to
* @param b array to write
* @throws ioexception e
*/
public static void writebytearray final dataoutput out  final byte  b
throws ioexception
if b    null
writableutils writevint out  0
else
writebytearray out  b  0  b length
/**
* write byte-array to out with a vint length prefix.
* @param out output stream
* @param b array
* @param offset offset into array
* @param length length past offset
* @throws ioexception e
*/
public static void writebytearray final dataoutput out  final byte  b
final int offset  final int length
throws ioexception
writableutils writevint out  length
out write b  offset  length
/**
* write byte-array from src to tgt with a vint length prefix.
* @param tgt target array
* @param tgtoffset offset into target array
* @param src source array
* @param srcoffset source offset
* @param srclength source length
* @return new offset in src array.
*/
public static int writebytearray final byte  tgt  final int tgtoffset
final byte  src  final int srcoffset  final int srclength
byte  vint   vinttobytes srclength
system arraycopy vint  0  tgt  tgtoffset  vint length
int offset   tgtoffset   vint length
system arraycopy src  srcoffset  tgt  offset  srclength
return offset   srclength
/**
* put bytes at the specified byte array position.
* @param tgtbytes the byte array
* @param tgtoffset position in the array
* @param srcbytes array to write out
* @param srcoffset source offset
* @param srclength source length
* @return incremented offset
*/
public static int putbytes byte tgtbytes  int tgtoffset  byte srcbytes
int srcoffset  int srclength
system arraycopy srcbytes  srcoffset  tgtbytes  tgtoffset  srclength
return tgtoffset   srclength
/**
* write a single byte out to the specified byte array position.
* @param bytes the byte array
* @param offset position in the array
* @param b byte to write out
* @return incremented offset
*/
public static int putbyte byte bytes  int offset  byte b
bytes   b
return offset   1
/**
* returns a new byte array, copied from the passed bytebuffer.
* @param bb a bytebuffer
* @return the byte array
*/
public static byte tobytes bytebuffer bb
int length   bb limit
byte  result   new byte
system arraycopy bb array    bb arrayoffset    result  0  length
return result
/**
* @param b presumed utf-8 encoded byte array.
* @return string made from <code>b</code>
*/
public static string tostring final byte  b
if  b    null
return null
return tostring b  0  b length
/**
* joins two byte arrays together using a separator.
* @param b1 the first byte array.
* @param sep the separator to use.
* @param b2 the second byte array.
*/
public static string tostring final byte  b1
string sep
final byte  b2
return tostring b1  0  b1 length    sep   tostring b2  0  b2 length
/**
* this method will convert utf8 encoded bytes into a string. if
* an unsupportedencodingexception occurs, this method will eat it
* and return null instead.
*
* @param b presumed utf-8 encoded byte array.
* @param off offset into array
* @param len length of utf-8 sequence
* @return string made from <code>b</code> or null
*/
public static string tostring final byte  b  int off  int len
if  b    null
return null
if  len    0
return
try
return new string b  off  len  hconstants utf8_encoding
catch  unsupportedencodingexception e
log error    e
return null
/**
* write a printable representation of a byte array.
*
* @param b byte array
* @return string
* @see #tostringbinary(byte[], int, int)
*/
public static string tostringbinary final byte  b
if  b    null
return
return tostringbinary b  0  b length
/**
* converts the given byte buffer, from its array offset to its limit, to
* a string. the position and the mark are ignored.
*
* @param buf a byte buffer
* @return a string representation of the buffer's binary contents
*/
public static string tostringbinary bytebuffer buf
if  buf    null
return
return tostringbinary buf array    buf arrayoffset    buf limit
/**
* write a printable representation of a byte array. non-printable
* characters are hex escaped in the format \\x%02x, eg:
* \x00 \x05 etc
*
* @param b array to write out
* @param off offset to start at
* @param len length to write
* @return string output
*/
public static string tostringbinary final byte  b  int off  int len
stringbuilder result   new stringbuilder
try
string first   new string b  off  len
for  int i   0  i < first length       i
int ch   first charat i    0xff
if    ch >       ch <
ch >       ch <
ch >       ch <
<> ?" indexof ch  >  0
result append first charat i
else
result append string format    ch
catch  unsupportedencodingexception e
log error    e
return result tostring
private static boolean ishexdigit char c
return
c >       c <
c >       c <
/**
* takes a ascii digit in the range a-f0-9 and returns
* the corresponding integer/ordinal value.
* @param ch  the hex digit.
* @return the converted hex value as a byte.
*/
public static byte tobinaryfromhex byte ch
if   ch >       ch <
return  byte    byte 10    byte   ch
// else
return  byte   ch
public static byte  tobytesbinary string in
// this may be bigger than we need, but lets be safe.
byte  b   new byte
int size   0
for  int i   0  i < in length      i
char ch   in charat i
if  ch
// begin hex escape:
char next   in charat i 1
if  next
// invalid escape sequence, ignore this one.
b    byte ch
continue
// ok, take next 2 hex digits.
char hd1   in charat i 2
char hd2   in charat i 3
// they need to be a-f0-9:
if   ishexdigit hd1
ishexdigit hd2
// bogus escape code, ignore:
continue
// turn hex ascii digit -> number
byte d    byte    tobinaryfromhex  byte hd1  << 4    tobinaryfromhex  byte hd2
b   d
i    3     skip 3
else
b    byte  ch
// resize:
byte  b2   new byte
system arraycopy b  0  b2  0  size
return b2
/**
* converts a string to a utf-8 byte array.
* @param s string
* @return the byte array
*/
public static byte tobytes string s
try
return s getbytes hconstants utf8_encoding
catch  unsupportedencodingexception e
log error    e
return null
/**
* convert a boolean to a byte array. true becomes -1
* and false becomes 0.
*
* @param b value
* @return <code>b</code> encoded in a byte array.
*/
public static byte  tobytes final boolean b
return new byte   b ?  byte   1    byte  0
/**
* reverses {@link #tobytes(boolean)}
* @param b array
* @return true or false.
*/
public static boolean toboolean final byte  b
if  b length    1
throw new illegalargumentexception     b length
return b     byte  0
/**
* convert a long value to a byte array using big-endian.
*
* @param val value to convert
* @return the byte array
*/
public static byte tobytes long val
byte  b   new byte
for  int i   7  i > 0  i
b    byte  val
val >>>  8
b    byte  val
return b
/**
* converts a byte array to a long value. reverses
* {@link #tobytes(long)}
* @param bytes array
* @return the long value
*/
public static long tolong byte bytes
return tolong bytes  0  sizeof_long
/**
* converts a byte array to a long value. assumes there will be
* {@link #sizeof_long} bytes available.
*
* @param bytes bytes
* @param offset offset
* @return the long value
*/
public static long tolong byte bytes  int offset
return tolong bytes  offset  sizeof_long
/**
* converts a byte array to a long value.
*
* @param bytes array of bytes
* @param offset offset into array
* @param length length of data (must be {@link #sizeof_long})
* @return the long value
* @throws illegalargumentexception if length is not {@link #sizeof_long} or
* if there's not enough room in the array at the offset indicated.
*/
public static long tolong byte bytes  int offset  final int length
if  length    sizeof_long    offset   length > bytes length
throw explainwronglengthoroffset bytes  offset  length  sizeof_long
long l   0
for int i   offset  i < offset   length  i
l <<  8
l ^  bytes   0xff
return l
private static illegalargumentexception
explainwronglengthoroffset final byte bytes
final int offset
final int length
final int expectedlength
string reason
if  length    expectedlength
reason       length       expectedlength
else
reason       offset       length
bytes length
return new illegalargumentexception reason
/**
* put a long value out to the specified byte array position.
* @param bytes the byte array
* @param offset position in the array
* @param val long to write out
* @return incremented offset
* @throws illegalargumentexception if the byte array given doesn't have
* enough room at the offset specified.
*/
public static int putlong byte bytes  int offset  long val
if  bytes length   offset < sizeof_long
throw new illegalargumentexception
offset       bytes length
for int i   offset   7  i > offset  i
bytes    byte  val
val >>>  8
bytes    byte  val
return offset   sizeof_long
/**
* presumes float encoded as ieee 754 floating-point "single format"
* @param bytes byte array
* @return float made from passed byte array.
*/
public static float tofloat byte  bytes
return tofloat bytes  0
/**
* presumes float encoded as ieee 754 floating-point "single format"
* @param bytes array to convert
* @param offset offset into array
* @return float made from passed byte array.
*/
public static float tofloat byte  bytes  int offset
return float intbitstofloat toint bytes  offset  sizeof_int
/**
* @param bytes byte array
* @param offset offset to write to
* @param f float value
* @return new offset in <code>bytes</code>
*/
public static int putfloat byte  bytes  int offset  float f
return putint bytes  offset  float floattorawintbits f
/**
* @param f float value
* @return the float represented as byte []
*/
public static byte  tobytes final float f
// encode it as int
return bytes tobytes float floattorawintbits f
/**
* @param bytes byte array
* @return return double made from passed bytes.
*/
public static double todouble final byte  bytes
return todouble bytes  0
/**
* @param bytes byte array
* @param offset offset where double is
* @return return double made from passed bytes.
*/
public static double todouble final byte  bytes  final int offset
return double longbitstodouble tolong bytes  offset  sizeof_long
/**
* @param bytes byte array
* @param offset offset to write to
* @param d value
* @return new offset into array <code>bytes</code>
*/
public static int putdouble byte  bytes  int offset  double d
return putlong bytes  offset  double doubletolongbits d
/**
* serialize a double as the ieee 754 double format output. the resultant
* array will be 8 bytes long.
*
* @param d value
* @return the double represented as byte []
*/
public static byte  tobytes final double d
// encode it as a long
return bytes tobytes double doubletorawlongbits d
/**
* convert an int value to a byte array
* @param val value
* @return the byte array
*/
public static byte tobytes int val
byte  b   new byte
for int i   3  i > 0  i
b    byte  val
val >>>  8
b    byte  val
return b
/**
* converts a byte array to an int value
* @param bytes byte array
* @return the int value
*/
public static int toint byte bytes
return toint bytes  0  sizeof_int
/**
* converts a byte array to an int value
* @param bytes byte array
* @param offset offset into array
* @return the int value
*/
public static int toint byte bytes  int offset
return toint bytes  offset  sizeof_int
/**
* converts a byte array to an int value
* @param bytes byte array
* @param offset offset into array
* @param length length of int (has to be {@link #sizeof_int})
* @return the int value
* @throws illegalargumentexception if length is not {@link #sizeof_int} or
* if there's not enough room in the array at the offset indicated.
*/
public static int toint byte bytes  int offset  final int length
if  length    sizeof_int    offset   length > bytes length
throw explainwronglengthoroffset bytes  offset  length  sizeof_int
int n   0
for int i   offset  i <  offset   length   i
n <<  8
n ^  bytes   0xff
return n
/**
* put an int value out to the specified byte array position.
* @param bytes the byte array
* @param offset position in the array
* @param val int to write out
* @return incremented offset
* @throws illegalargumentexception if the byte array given doesn't have
* enough room at the offset specified.
*/
public static int putint byte bytes  int offset  int val
if  bytes length   offset < sizeof_int
throw new illegalargumentexception
offset       bytes length
for int i  offset   3  i > offset  i
bytes    byte  val
val >>>  8
bytes    byte  val
return offset   sizeof_int
/**
* convert a short value to a byte array of {@link #sizeof_short} bytes long.
* @param val value
* @return the byte array
*/
public static byte tobytes short val
byte b   new byte
b    byte  val
val >>  8
b    byte  val
return b
/**
* converts a byte array to a short value
* @param bytes byte array
* @return the short value
*/
public static short toshort byte bytes
return toshort bytes  0  sizeof_short
/**
* converts a byte array to a short value
* @param bytes byte array
* @param offset offset into array
* @return the short value
*/
public static short toshort byte bytes  int offset
return toshort bytes  offset  sizeof_short
/**
* converts a byte array to a short value
* @param bytes byte array
* @param offset offset into array
* @param length length, has to be {@link #sizeof_short}
* @return the short value
* @throws illegalargumentexception if length is not {@link #sizeof_short}
* or if there's not enough room in the array at the offset indicated.
*/
public static short toshort byte bytes  int offset  final int length
if  length    sizeof_short    offset   length > bytes length
throw explainwronglengthoroffset bytes  offset  length  sizeof_short
short n   0
n ^  bytes   0xff
n <<  8
n ^  bytes   0xff
return n
/**
* this method will get a sequence of bytes from pos -> limit,
* but will restore pos after.
* @param buf
* @return byte array
*/
public static byte getbytes bytebuffer buf
int savedpos   buf position
byte  newbytes   new byte
buf get newbytes
buf position savedpos
return newbytes
/**
* put a short value out to the specified byte array position.
* @param bytes the byte array
* @param offset position in the array
* @param val short to write out
* @return incremented offset
* @throws illegalargumentexception if the byte array given doesn't have
* enough room at the offset specified.
*/
public static int putshort byte bytes  int offset  short val
if  bytes length   offset < sizeof_short
throw new illegalargumentexception
offset       bytes length
bytes    byte  val
val >>  8
bytes    byte  val
return offset   sizeof_short
/**
* convert a bigdecimal value to a byte array
*
* @param val
* @return the byte array
*/
public static byte tobytes bigdecimal val
byte valuebytes   val unscaledvalue   tobytearray
byte result   new byte
int offset   putint result  0  val scale
putbytes result  offset  valuebytes  0  valuebytes length
return result
/**
* converts a byte array to a bigdecimal
*
* @param bytes
* @return the char value
*/
public static bigdecimal tobigdecimal byte bytes
return tobigdecimal bytes  0  bytes length
/**
* converts a byte array to a bigdecimal value
*
* @param bytes
* @param offset
* @param length
* @return the char value
*/
public static bigdecimal tobigdecimal byte bytes  int offset  final int length
if  bytes    null    length < sizeof_int   1
offset   length > bytes length
return null
int scale   toint bytes  offset
byte tcbytes   new byte
system arraycopy bytes  offset   sizeof_int  tcbytes  0  length   sizeof_int
return new bigdecimal new biginteger tcbytes   scale
/**
* put a bigdecimal value out to the specified byte array position.
*
* @param bytes  the byte array
* @param offset position in the array
* @param val    bigdecimal to write out
* @return incremented offset
*/
public static int putbigdecimal byte bytes  int offset  bigdecimal val
if  bytes    null
return offset
byte valuebytes   val unscaledvalue   tobytearray
byte result   new byte
offset   putint result  offset  val scale
return putbytes result  offset  valuebytes  0  valuebytes length
/**
* @param vint integer to make a vint of.
* @return vint as bytes array.
*/
public static byte  vinttobytes final long vint
long i   vint
int size   writableutils getvintsize i
byte  result   new byte
int offset   0
if  i >   112    i <  127
result    byte  i
return result
int len    112
if  i < 0
i ^   1l     take one
len    120
long tmp   i
while  tmp    0
tmp   tmp >> 8
len
result    byte  len
len    len <  120  ?   len   120      len   112
for  int idx   len  idx    0  idx
int shiftbits    idx   1    8
long mask   0xffl << shiftbits
result    byte   i   mask  >> shiftbits
return result
/**
* @param buffer buffer to convert
* @return vint bytes as an integer.
*/
public static long bytestovint final byte  buffer
int offset   0
byte firstbyte   buffer
int len   writableutils decodevintsize firstbyte
if  len    1
return firstbyte
long i   0
for  int idx   0  idx < len 1  idx
byte b   buffer
i   i << 8
i   i    b   0xff
return  writableutils isnegativevint firstbyte  ? ~i   i
/**
* reads a zero-compressed encoded long from input stream and returns it.
* @param buffer binary array
* @param offset offset into array at which vint begins.
* @throws java.io.ioexception e
* @return deserialized long from stream.
*/
public static long readvlong final byte  buffer  final int offset
throws ioexception
byte firstbyte   buffer
int len   writableutils decodevintsize firstbyte
if  len    1
return firstbyte
long i   0
for  int idx   0  idx < len 1  idx
byte b   buffer
i   i << 8
i   i    b   0xff
return  writableutils isnegativevint firstbyte  ? ~i   i
/**
* @param left left operand
* @param right right operand
* @return 0 if equal, < 0 if left is less than right, etc.
*/
public static int compareto final byte  left  final byte  right
return lexicographicalcomparerholder best_comparer
compareto left  0  left length  right  0  right length
/**
* lexicographically compare two arrays.
*
* @param buffer1 left operand
* @param buffer2 right operand
* @param offset1 where to start comparing in the left buffer
* @param offset2 where to start comparing in the right buffer
* @param length1 how much to compare from the left buffer
* @param length2 how much to compare from the right buffer
* @return 0 if equal, < 0 if left is less than right, etc.
*/
public static int compareto byte buffer1  int offset1  int length1
byte buffer2  int offset2  int length2
return lexicographicalcomparerholder best_comparer
compareto buffer1  offset1  length1  buffer2  offset2  length2
interface comparer<t>
abstract public int compareto t buffer1  int offset1  int length1
t buffer2  int offset2  int length2
@visiblefortesting
static comparer<byte> lexicographicalcomparerjavaimpl
return lexicographicalcomparerholder purejavacomparer instance
/**
* provides a lexicographical comparer implementation; either a java
* implementation or a faster implementation based on {@link unsafe}.
*
* <p>uses reflection to gracefully fall back to the java implementation if
* {@code unsafe} isn't available.
*/
@visiblefortesting
static class lexicographicalcomparerholder
static final string unsafe_comparer_name
lexicographicalcomparerholder class getname
static final comparer<byte> best_comparer   getbestcomparer
/**
* returns the unsafe-using comparer, or falls back to the pure-java
* implementation if unable to do so.
*/
static comparer<byte> getbestcomparer
try
class<?> theclass   class forname unsafe_comparer_name
// yes, unsafecomparer does implement comparer<byte[]>
@suppresswarnings
comparer<byte> comparer
comparer<byte>  theclass getenumconstants
return comparer
catch  throwable t       ensure we really catch  everything
return lexicographicalcomparerjavaimpl
enum purejavacomparer implements comparer<byte>
instance
@override
public int compareto byte buffer1  int offset1  int length1
byte buffer2  int offset2  int length2
// short circuit equal case
if  buffer1    buffer2
offset1    offset2
length1    length2
return 0
// bring writablecomparator code local
int end1   offset1   length1
int end2   offset2   length2
for  int i   offset1  j   offset2  i < end1    j < end2  i    j
int a    buffer1   0xff
int b    buffer2   0xff
if  a    b
return a   b
return length1   length2
@visiblefortesting
enum unsafecomparer implements comparer<byte>
instance
static final unsafe theunsafe
/** the offset to the first element in a byte array. */
static final int byte_array_base_offset
static
theunsafe    unsafe  accesscontroller doprivileged
new privilegedaction<object>
@override
public object run
try
field f   unsafe class getdeclaredfield
f setaccessible true
return f get null
catch  nosuchfieldexception e
// it doesn't matter what we throw;
// it's swallowed in getbestcomparer().
throw new error
catch  illegalaccessexception e
throw new error
byte_array_base_offset   theunsafe arraybaseoffset byte class
// sanity check - this should never fail
if  theunsafe arrayindexscale byte class     1
throw new assertionerror
static final boolean littleendian
byteorder nativeorder   equals byteorder little_endian
/**
* returns true if x1 is less than x2, when both values are treated as
* unsigned.
*/
static boolean lessthanunsigned long x1  long x2
return  x1   long min_value  <  x2   long min_value
/**
* lexicographically compare two arrays.
*
* @param buffer1 left operand
* @param buffer2 right operand
* @param offset1 where to start comparing in the left buffer
* @param offset2 where to start comparing in the right buffer
* @param length1 how much to compare from the left buffer
* @param length2 how much to compare from the right buffer
* @return 0 if equal, < 0 if left is less than right, etc.
*/
@override
public int compareto byte buffer1  int offset1  int length1
byte buffer2  int offset2  int length2
// short circuit equal case
if  buffer1    buffer2
offset1    offset2
length1    length2
return 0
int minlength   math min length1  length2
int minwords   minlength   sizeof_long
int offset1adj   offset1   byte_array_base_offset
int offset2adj   offset2   byte_array_base_offset
/*
* compare 8 bytes at a time. benchmarking shows comparing 8 bytes at a
* time is no slower than comparing 4 bytes at a time even on 32-bit.
* on the other hand, it is substantially faster on 64-bit.
*/
for  int i   0  i < minwords   sizeof_long  i    sizeof_long
long lw   theunsafe getlong buffer1  offset1adj    long  i
long rw   theunsafe getlong buffer2  offset2adj    long  i
long diff   lw ^ rw
if  diff    0
if   littleendian
return lessthanunsigned lw  rw  ?  1   1
// use binary search
int n   0
int y
int x    int  diff
if  x    0
x    int   diff >>> 32
n   32
y   x << 16
if  y    0
n    16
else
x   y
y   x << 8
if  y    0
n    8
return  int     lw >>> n    0xffl      rw >>> n    0xffl
// the epilogue to cover the last (minlength % 8) elements.
for  int i   minwords   sizeof_long  i < minlength  i
int a    buffer1   0xff
int b    buffer2   0xff
if  a    b
return a   b
return length1   length2
/**
* @param left left operand
* @param right right operand
* @return true if equal
*/
public static boolean equals final byte  left  final byte  right
// could use arrays.equals?
//noinspection simplifiableconditionalexpression
if  left    right  return true
if  left    null    right    null  return false
if  left length    right length  return false
if  left length    0  return true
// since we're often comparing adjacent sorted data,
// it's usual to have equal arrays except for the very last byte
// so check that first
if  left    right  return false
return compareto left  right     0
public static boolean equals final byte left  int leftoffset  int leftlen
final byte right  int rightoffset  int rightlen
// short circuit case
if  left    right
leftoffset    rightoffset
leftlen    rightlen
return true
// different lengths fast check
if  leftlen    rightlen
return false
if  leftlen    0
return true
// since we're often comparing adjacent sorted data,
// it's usual to have equal arrays except for the very last byte
// so check that first
if  left    right  return false
return lexicographicalcomparerholder best_comparer
compareto left  leftoffset  leftlen  right  rightoffset  rightlen     0
/**
* return true if the byte array on the right is a prefix of the byte
* array on the left.
*/
public static boolean startswith byte bytes  byte prefix
return bytes    null    prefix    null
bytes length >  prefix length
lexicographicalcomparerholder best_comparer
compareto bytes  0  prefix length  prefix  0  prefix length     0
/**
* @param b bytes to hash
* @return runs {@link writablecomparator#hashbytes(byte[], int)} on the
* passed in array.  this method is what {@link org.apache.hadoop.io.text} and
* {@link immutablebyteswritable} use calculating hash code.
*/
public static int hashcode final byte  b
return hashcode b  b length
/**
* @param b value
* @param length length of the value
* @return runs {@link writablecomparator#hashbytes(byte[], int)} on the
* passed in array.  this method is what {@link org.apache.hadoop.io.text} and
* {@link immutablebyteswritable} use calculating hash code.
*/
public static int hashcode final byte  b  final int length
return writablecomparator hashbytes b  length
/**
* @param b bytes to hash
* @return a hash of <code>b</code> as an integer that can be used as key in
* maps.
*/
public static integer mapkey final byte  b
return hashcode b
/**
* @param b bytes to hash
* @param length length to hash
* @return a hash of <code>b</code> as an integer that can be used as key in
* maps.
*/
public static integer mapkey final byte  b  final int length
return hashcode b  length
/**
* @param a lower half
* @param b upper half
* @return new array that has a in lower half and b in upper half.
*/
public static byte  add final byte  a  final byte  b
return add a  b  hconstants empty_byte_array
/**
* @param a first third
* @param b second third
* @param c third third
* @return new array made from a, b and c
*/
public static byte  add final byte  a  final byte  b  final byte  c
byte  result   new byte
system arraycopy a  0  result  0  a length
system arraycopy b  0  result  a length  b length
system arraycopy c  0  result  a length   b length  c length
return result
/**
* @param a array
* @param length amount of bytes to grab
* @return first <code>length</code> bytes from <code>a</code>
*/
public static byte  head final byte  a  final int length
if  a length < length
return null
byte  result   new byte
system arraycopy a  0  result  0  length
return result
/**
* @param a array
* @param length amount of bytes to snarf
* @return last <code>length</code> bytes from <code>a</code>
*/
public static byte  tail final byte  a  final int length
if  a length < length
return null
byte  result   new byte
system arraycopy a  a length   length  result  0  length
return result
/**
* @param a array
* @param length new array size
* @return value in <code>a</code> plus <code>length</code> prepended 0 bytes
*/
public static byte  padhead final byte  a  final int length
byte  padding   new byte
for  int i   0  i < length  i
padding   0
return add padding a
/**
* @param a array
* @param length new array size
* @return value in <code>a</code> plus <code>length</code> appended 0 bytes
*/
public static byte  padtail final byte  a  final int length
byte  padding   new byte
for  int i   0  i < length  i
padding   0
return add a padding
/**
* split passed range.  expensive operation relatively.  uses biginteger math.
* useful splitting ranges for mapreduce jobs.
* @param a beginning of range
* @param b end of range
* @param num number of times to split range.  pass 1 if you want to split
* the range in two; i.e. one split.
* @return array of dividing values
*/
public static byte  split final byte  a  final byte  b  final int num
return split a  b  false  num
/**
* split passed range.  expensive operation relatively.  uses biginteger math.
* useful splitting ranges for mapreduce jobs.
* @param a beginning of range
* @param b end of range
* @param inclusive whether the end of range is prefix-inclusive or is
* considered an exclusive boundary.  automatic splits are generally exclusive
* and manual splits with an explicit range utilize an inclusive end of range.
* @param num number of times to split range.  pass 1 if you want to split
* the range in two; i.e. one split.
* @return array of dividing values
*/
public static byte split final byte a  final byte b
boolean inclusive  final int num
byte ret   new byte
int i   0
iterable<byte> iter   iterateonsplits a  b  inclusive  num
if  iter    null
return null
for  byte elem   iter
ret   elem
return ret
/**
* iterate over keys within the passed range, splitting at an [a,b) boundary.
*/
public static iterable<byte> iterateonsplits final byte a
final byte b  final int num
return iterateonsplits a  b  false  num
/**
* iterate over keys within the passed range.
*/
public static iterable<byte> iterateonsplits
final byte a  final byteb  boolean inclusive  final int num
byte  apadded
byte  bpadded
if  a length < b length
apadded   padtail a  b length   a length
bpadded   b
else if  b length < a length
apadded   a
bpadded   padtail b  a length   b length
else
apadded   a
bpadded   b
if  compareto apadded bpadded  >  0
throw new illegalargumentexception
if  num <  0
throw new illegalargumentexception
byte  prependheader    1  0
final biginteger startbi   new biginteger add prependheader  apadded
final biginteger stopbi   new biginteger add prependheader  bpadded
biginteger diffbi   stopbi subtract startbi
if  inclusive
diffbi   diffbi add biginteger one
final biginteger splitsbi   biginteger valueof num   1
if diffbi compareto splitsbi  < 0
return null
final biginteger intervalbi
try
intervalbi   diffbi divide splitsbi
catch exception e
log error    e
return null
final iterator<byte> iterator   new iterator<byte>
private int i    1
@override
public boolean hasnext
return i < num 1
@override
public byte next
i
if  i    0  return a
if  i    num   1  return b
biginteger curbi   startbi add intervalbi multiply biginteger valueof i
byte  padded   curbi tobytearray
if  padded    0
padded   tail padded  padded length   2
else
padded   tail padded  padded length   1
return padded
@override
public void remove
throw new unsupportedoperationexception
return new iterable<byte>
@override
public iterator<byte> iterator
return iterator
/**
* @param bytes array to hash
* @param offset offset to start from
* @param length length to hash
* */
public static int hashcode byte bytes  int offset  int length
int hash   1
for  int i   offset  i < offset   length  i
hash    31   hash     int  bytes
return hash
/**
* @param t operands
* @return array of byte arrays made from passed array of text
*/
public static byte  tobytearrays final string  t
byte  result   new byte
for  int i   0  i < t length  i
result   bytes tobytes t
return result
/**
* @param column operand
* @return a byte array of a byte array where first and only entry is
* <code>column</code>
*/
public static byte  tobytearrays final string column
return tobytearrays tobytes column
/**
* @param column operand
* @return a byte array of a byte array where first and only entry is
* <code>column</code>
*/
public static byte  tobytearrays final byte  column
byte  result   new byte
result   column
return result
/**
* binary search for keys in indexes.
*
* @param arr array of byte arrays to search for
* @param key the key you want to find
* @param offset the offset in the key you want to find
* @param length the length of the key
* @param comparator a comparator to compare.
* @return zero-based index of the key, if the key is present in the array.
*         otherwise, a value -(i + 1) such that the key is between arr[i -
*         1] and arr[i] non-inclusively, where i is in [0, i], if we define
*         arr[-1] = -inf and arr[n] = inf for an n-element array. the above
*         means that this function can return 2n + 1 different values
*         ranging from -(n + 1) to n - 1.
*/
public static int binarysearch byte arr  byte key  int offset
int length  rawcomparator<byte > comparator
int low   0
int high   arr length   1
while  low <  high
int mid    low high  >>> 1
// we have to compare in this order, because the comparator order
// has special logic when the 'left side' is a special key.
int cmp   comparator compare key  offset  length
arr  0  arr length
// key lives above the midpoint
if  cmp > 0
low   mid   1
// key lives below the midpoint
else if  cmp < 0
high   mid   1
// bam. how often does this really happen?
else
return mid
return    low 1
/**
* bytewise binary increment/deincrement of long contained in byte array
* on given amount.
*
* @param value - array of bytes containing long (length <= sizeof_long)
* @param amount value will be incremented on (deincremented if negative)
* @return array of bytes containing incremented long (length == sizeof_long)
*/
public static byte  incrementbytes byte value  long amount
byte val   value
if  val length < sizeof_long
// hopefully this doesn't happen too often.
byte  newvalue
if  val < 0
newvalue   new byte  1   1   1   1   1   1   1   1
else
newvalue   new byte
system arraycopy val  0  newvalue  newvalue length   val length
val length
val   newvalue
else if  val length > sizeof_long
throw new illegalargumentexception
val length
if amount    0  return val
if val < 0
return binaryincrementneg val  amount
return binaryincrementpos val  amount
/* increment/deincrement for positive value */
private static byte  binaryincrementpos byte  value  long amount
long amo   amount
int sign   1
if  amount < 0
amo    amount
sign    1
for int i 0 i<value length i
int cur     int amo % 256    sign
amo    amo >> 8
int val   value   0x0ff
int total   val   cur
if total > 255
amo    sign
total %  256
else if  total < 0
amo    sign
value    byte total
if  amo    0  return value
return value
/* increment/deincrement for negative value */
private static byte  binaryincrementneg byte  value  long amount
long amo   amount
int sign   1
if  amount < 0
amo    amount
sign    1
for int i 0 i<value length i
int cur     int amo % 256    sign
amo    amo >> 8
int val     ~value    0x0ff    1
int total   cur   val
if total >  0
amo    sign
else if  total <  256
amo    sign
total %  256
value    byte total
if  amo    0  return value
return value
/**
* writes a string as a fixed-size field, padded with zeros.
*/
public static void writestringfixedsize final dataoutput out  string s
int size  throws ioexception
byte b   tobytes s
if  b length > size
throw new ioexception     b length
tostringbinary b        size
out writebytes s
for  int i   0  i < size   s length      i
out writebyte 0
/**
* reads a fixed-size field and interprets it as a string padded with zeros.
*/
public static string readstringfixedsize final datainput in  int size
throws ioexception
byte b   new byte
in readfully b
int n   b length
while  n > 0    b    0
n
return tostring b  0  n