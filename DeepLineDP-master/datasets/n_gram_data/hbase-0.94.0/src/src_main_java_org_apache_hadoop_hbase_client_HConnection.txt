/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import java io closeable
import java io ioexception
import java util list
import java util map
import java util concurrent executorservice
import org apache hadoop conf configuration
import org apache hadoop hbase abortable
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase hregionlocation
import org apache hadoop hbase hserveraddress
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase masternotrunningexception
import org apache hadoop hbase zookeeperconnectionexception
import org apache hadoop hbase catalog catalogtracker
import org apache hadoop hbase client coprocessor batch
import org apache hadoop hbase ipc coprocessorprotocol
import org apache hadoop hbase ipc hmasterinterface
import org apache hadoop hbase ipc hregioninterface
import org apache hadoop hbase zookeeper zookeeperwatcher
/**
* cluster connection.  hosts a connection to the zookeeper ensemble and
* thereafter into the hbase cluster.  knows how to locate regions out on the cluster,
* keeps a cache of locations and then knows how to recalibrate after they move.
* {@link hconnectionmanager} manages instances of this class.
*
* <p>hconnections are used by {@link htable} mostly but also by
* {@link hbaseadmin}, {@link catalogtracker},
* and {@link zookeeperwatcher}.  hconnection instances can be shared.  sharing
* is usually what you want because rather than each hconnection instance
* having to do its own discovery of regions out on the cluster, instead, all
* clients get to share the one cache of locations.  sharing makes cleanup of
* hconnections awkward.  see {@link hconnectionmanager} for cleanup
* discussion.
*
* @see hconnectionmanager
*/
public interface hconnection extends abortable  closeable
/**
* @return configuration instance being used by this hconnection instance.
*/
public configuration getconfiguration
/**
* retrieve zookeeperwatcher used by this connection.
* @return zookeeperwatcher handle being used by the connection.
* @throws ioexception if a remote or network exception occurs
* @deprecated removed because it was a mistake exposing zookeeper in this
* interface (zookeeper is an implementation detail).
* deprecated in hbase 0.94
*/
@deprecated
public zookeeperwatcher getzookeeperwatcher   throws ioexception
/**
* @return proxy connection to master server for this instance
* @throws masternotrunningexception if the master is not running
* @throws zookeeperconnectionexception if unable to connect to zookeeper
* @deprecated removed because it was a mistake exposing master in this
* interface (master is an implementation detail). master functions are
* available from hconnection or hbaseadmin, without having to use
* directly the master.
* deprecated in hbase 0.94
*/
@deprecated
public hmasterinterface getmaster
throws masternotrunningexception  zookeeperconnectionexception
/** @return - true if the master server is running */
public boolean ismasterrunning
throws masternotrunningexception  zookeeperconnectionexception
/**
* a table that istableenabled == false and istabledisabled == false
* is possible. this happens when a table has a lot of regions
* that must be processed.
* @param tablename table name
* @return true if the table is enabled, false otherwise
* @throws ioexception if a remote or network exception occurs
*/
public boolean istableenabled byte tablename  throws ioexception
/**
* @param tablename table name
* @return true if the table is disabled, false otherwise
* @throws ioexception if a remote or network exception occurs
*/
public boolean istabledisabled byte tablename  throws ioexception
/**
* @param tablename table name
* @return true if all regions of the table are available, false otherwise
* @throws ioexception if a remote or network exception occurs
*/
public boolean istableavailable byte tablename  throws ioexception
/**
* list all the userspace tables.  in other words, scan the meta table.
*
* if we wanted this to be really fast, we could implement a special
* catalog table that just contains table names and their descriptors.
* right now, it only exists as part of the meta table's region info.
*
* @return - returns an array of htabledescriptors
* @throws ioexception if a remote or network exception occurs
*/
public htabledescriptor listtables   throws ioexception
/**
* @param tablename table name
* @return table metadata
* @throws ioexception if a remote or network exception occurs
*/
public htabledescriptor gethtabledescriptor byte tablename
throws ioexception
/**
* find the location of the region of <i>tablename</i> that <i>row</i>
* lives in.
* @param tablename name of the table <i>row</i> is in
* @param row row key you're trying to find the region of
* @return hregionlocation that describes where to find the region in
* question
* @throws ioexception if a remote or network exception occurs
*/
public hregionlocation locateregion final byte  tablename
final byte  row
throws ioexception
/**
* allows flushing the region cache.
*/
public void clearregioncache
/**
* allows flushing the region cache of all locations that pertain to
* <code>tablename</code>
* @param tablename name of the table whose regions we are to remove from
* cache.
*/
public void clearregioncache final byte  tablename
/**
* find the location of the region of <i>tablename</i> that <i>row</i>
* lives in, ignoring any value that might be in the cache.
* @param tablename name of the table <i>row</i> is in
* @param row row key you're trying to find the region of
* @return hregionlocation that describes where to find the region in
* question
* @throws ioexception if a remote or network exception occurs
*/
public hregionlocation relocateregion final byte  tablename
final byte  row
throws ioexception
/**
* gets the location of the region of <i>regionname</i>.
* @param regionname name of the region to locate
* @return hregionlocation that describes where to find the region in
* question
* @throws ioexception if a remote or network exception occurs
*/
public hregionlocation locateregion final byte  regionname
throws ioexception
/**
* gets the locations of all regions in the specified table, <i>tablename</i>.
* @param tablename table to get regions of
* @return list of region locations for all regions of table
* @throws ioexception
*/
public list<hregionlocation> locateregions byte tablename
throws ioexception
/**
* establishes a connection to the region server at the specified address.
* @param regionserver - the server to connect to
* @return proxy for hregionserver
* @throws ioexception if a remote or network exception occurs
* @deprecated use {@link #gethregionconnection(string, int)}
*/
public hregioninterface gethregionconnection hserveraddress regionserver
throws ioexception
/**
* establishes a connection to the region server at the specified address.
* @param hostname regionserver hostname
* @param port regionserver port
* @return proxy for hregionserver
* @throws ioexception if a remote or network exception occurs
*
*/
public hregioninterface gethregionconnection final string hostname  final int port
throws ioexception
/**
* establishes a connection to the region server at the specified address.
* @param regionserver - the server to connect to
* @param getmaster - do we check if master is alive
* @return proxy for hregionserver
* @throws ioexception if a remote or network exception occurs
* @deprecated use {@link #gethregionconnection(hserveraddress, boolean)}
*/
public hregioninterface gethregionconnection hserveraddress regionserver
boolean getmaster
throws ioexception
/**
* establishes a connection to the region server at the specified address.
* @param hostname regionserver hostname
* @param port regionserver port
* @param getmaster - do we check if master is alive
* @return proxy for hregionserver
* @throws ioexception if a remote or network exception occurs
*/
public hregioninterface gethregionconnection final string hostname
final int port  boolean getmaster
throws ioexception
/**
* find region location hosting passed row
* @param tablename table name
* @param row row to find.
* @param reload if true do not use cache, otherwise bypass.
* @return location of row.
* @throws ioexception if a remote or network exception occurs
*/
hregionlocation getregionlocation byte  tablename  byte  row
boolean reload
throws ioexception
/**
* pass in a servercallable with your particular bit of logic defined and
* this method will manage the process of doing retries with timed waits
* and refinds of missing regions.
*
* @param <t> the type of the return value
* @param callable callable to run
* @return an object of type t
* @throws ioexception if a remote or network exception occurs
* @throws runtimeexception other unspecified error
* @deprecated use {@link hconnectionmanager#withoutretries(servercallable)}
*/
public <t> t getregionserverwithretries servercallable<t> callable
throws ioexception  runtimeexception
/**
* pass in a servercallable with your particular bit of logic defined and
* this method will pass it to the defined region server.
* @param <t> the type of the return value
* @param callable callable to run
* @return an object of type t
* @throws ioexception if a remote or network exception occurs
* @throws runtimeexception other unspecified error
* @deprecated use {@link hconnectionmanager#withoutretries(servercallable)}
*/
public <t> t getregionserverwithoutretries servercallable<t> callable
throws ioexception  runtimeexception
/**
* process a mixed batch of get, put and delete actions. all actions for a
* regionserver are forwarded in one rpc call.
*
*
* @param actions the collection of actions.
* @param tablename name of the hbase table
* @param pool thread pool for parallel execution
* @param results an empty array, same size as list. if an exception is thrown,
* you can test here for partial results, and to determine which actions
* processed successfully.
* @throws ioexception if there are problems talking to meta. per-item
* exceptions are stored in the results array.
*/
public void processbatch list<? extends row> actions  final byte tablename
executorservice pool  object results
throws ioexception  interruptedexception
/**
* parameterized batch processing, allowing varying return types for different
* {@link row} implementations.
*/
public <r> void processbatchcallback list<? extends row> list
byte tablename
executorservice pool
object results
batch callback<r> callback  throws ioexception  interruptedexception
/**
* executes the given
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.call}
* callable for each row in the given list and invokes
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.callback#update(byte[], byte[], object)}
* for each result returned.
*
* @param protocol the protocol interface being called
* @param rows a list of row keys for which the callable should be invoked
* @param tablename table name for the coprocessor invoked
* @param pool executorservice used to submit the calls per row
* @param call instance on which to invoke
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.call#call(object)}
* for each row
* @param callback instance on which to invoke
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.callback#update(byte[], byte[], object)}
* for each result
* @param <t> the protocol interface type
* @param <r> the callable's return type
* @throws ioexception
*/
public <t extends coprocessorprotocol r> void processexecs
final class<t> protocol
list<byte> rows
final byte tablename
executorservice pool
final batch call<t r> call
final batch callback<r> callback  throws ioexception  throwable
/**
* enable or disable region cache prefetch for the table. it will be
* applied for the given table's all htable instances within this
* connection. by default, the cache prefetch is enabled.
* @param tablename name of table to configure.
* @param enable set to true to enable region cache prefetch.
*/
public void setregioncacheprefetch final byte tablename
final boolean enable
/**
* check whether region cache prefetch is enabled or not.
* @param tablename name of table to check
* @return true if table's region cache prefetch is enabled. otherwise
* it is disabled.
*/
public boolean getregioncacheprefetch final byte tablename
/**
* load the region map and warm up the global region cache for the table.
* @param tablename name of the table to perform region cache prewarm.
* @param regions a region map.
*/
public void prewarmregioncache final byte tablename
final map<hregioninfo  hserveraddress> regions
/**
* scan zookeeper to get the number of region servers
* @return the number of region servers that are currently running
* @throws ioexception if a remote or network exception occurs
* @deprecated this method will be changed from public to package protected.
*/
public int getcurrentnrhrs   throws ioexception
/**
* @param tablenames list of table names
* @return htd[] table metadata
* @throws ioexception if a remote or network exception occurs
*/
public htabledescriptor gethtabledescriptors list<string> tablenames
throws ioexception
/**
* @return true if this connection is closed
*/
public boolean isclosed
/**
* clear any caches that pertain to server name <code>sn</code>
* @param sn a server name as hostname:port
*/
public void clearcaches final string sn