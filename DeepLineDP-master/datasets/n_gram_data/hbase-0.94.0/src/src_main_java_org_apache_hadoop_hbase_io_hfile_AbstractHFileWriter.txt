/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase io hfile
import java io dataoutput
import java io ioexception
import java util arraylist
import java util arrays
import java util list
import org apache hadoop conf configuration
import org apache hadoop fs fsdataoutputstream
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop fs permission fspermission
import org apache hadoop hbase hconstants
import org apache hadoop hbase keyvalue keycomparator
import org apache hadoop hbase io hfile hfile fileinfo
import org apache hadoop hbase regionserver metrics schemaconfigured
import org apache hadoop hbase util bytes
import org apache hadoop hbase util fsutils
import org apache hadoop io rawcomparator
import org apache hadoop io writable
/**
* common functionality needed by all versions of {@link hfile} writers.
*/
public abstract class abstracthfilewriter extends schemaconfigured
implements hfile writer
/** key previously appended. becomes the last key in the file. */
protected byte lastkeybuffer   null
protected int lastkeyoffset    1
protected int lastkeylength    1
/** filesystem stream to write into. */
protected fsdataoutputstream outputstream
/** true if we opened the <code>outputstream</code> (and so will close it). */
protected final boolean closeoutputstream
/** a "file info" block: a key-value map of file-wide metadata. */
protected fileinfo fileinfo   new hfile fileinfo
/** number of uncompressed bytes we allow per block. */
protected final int blocksize
/** total # of key/value entries, i.e. how many times add() was called. */
protected long entrycount   0
/** used for calculating the average key length. */
protected long totalkeylength   0
/** used for calculating the average value length. */
protected long totalvaluelength   0
/** total uncompressed bytes, maybe calculate a compression ratio later. */
protected long totaluncompressedbytes   0
/** key comparator. used to ensure we write in order. */
protected final rawcomparator<byte> comparator
/** meta block names. */
protected list<byte> metanames   new arraylist<byte>
/** {@link writable}s representing meta block data. */
protected list<writable> metadata   new arraylist<writable>
/** the compression algorithm used. none if no compression. */
protected final compression algorithm compressalgo
/**
* the data block encoding which will be used.
* {@link noopdatablockencoder#instance} if there is no encoding.
*/
protected final hfiledatablockencoder blockencoder
/** first key in a block. */
protected byte firstkeyinblock   null
/** may be null if we were passed a stream. */
protected final path path
/** cache configuration for caching data on write. */
protected final cacheconfig cacheconf
/**
* name for this object used when logging or in tostring. is either
* the result of a tostring on stream or else name of passed file path.
*/
protected final string name
public abstracthfilewriter cacheconfig cacheconf
fsdataoutputstream outputstream  path path  int blocksize
compression algorithm compressalgo
hfiledatablockencoder datablockencoder
keycomparator comparator
super null  path
this outputstream   outputstream
this path   path
this name   path    null ? path getname     outputstream tostring
this blocksize   blocksize
this compressalgo   compressalgo    null
? hfile default_compression_algorithm   compressalgo
this blockencoder   datablockencoder    null
? datablockencoder   noopdatablockencoder instance
this comparator   comparator    null ? comparator
bytes bytes_rawcomparator
closeoutputstream   path    null
this cacheconf   cacheconf
/**
* add last bits of metadata to file info before it is written out.
*/
protected void finishfileinfo   throws ioexception
if  lastkeybuffer    null
// make a copy. the copy is stuffed into hmapwritable. needs a clean
// byte buffer. won't take a tuple.
fileinfo append fileinfo lastkey  arrays copyofrange lastkeybuffer
lastkeyoffset  lastkeyoffset   lastkeylength   false
// average key length.
int avgkeylen
entrycount    0 ? 0    int   totalkeylength   entrycount
fileinfo append fileinfo avg_key_len  bytes tobytes avgkeylen   false
// average value length.
int avgvaluelen
entrycount    0 ? 0    int   totalvaluelength   entrycount
fileinfo append fileinfo avg_value_len  bytes tobytes avgvaluelen   false
/**
* add to the file info. all added key/value pairs can be obtained using
* {@link hfile.reader#loadfileinfo()}.
*
* @param k key
* @param v value
* @throws ioexception in case the key or the value are invalid
*/
@override
public void appendfileinfo final byte k  final byte v
throws ioexception
fileinfo append k  v  true
/**
* sets the file info offset in the trailer, finishes up populating fields in
* the file info, and writes the file info into the given data output. the
* reason the data output is not always {@link #outputstream} is that we store
* file info as a block in version 2.
*
* @param trailer fixed file trailer
* @param out the data output to write the file info to
* @throws ioexception
*/
protected final void writefileinfo fixedfiletrailer trailer  dataoutput out
throws ioexception
trailer setfileinfooffset outputstream getpos
finishfileinfo
fileinfo write out
/**
* checks that the given key does not violate the key order.
*
* @param key key to check.
* @return true if the key is duplicate
* @throws ioexception if the key or the key order is wrong
*/
protected boolean checkkey final byte key  final int offset
final int length  throws ioexception
boolean isduplicatekey   false
if  key    null    length <  0
throw new ioexception
if  length > hfile maximum_key_length
throw new ioexception     length
hfile maximum_key_length
if  lastkeybuffer    null
int keycomp   comparator compare lastkeybuffer  lastkeyoffset
lastkeylength  key  offset  length
if  keycomp > 0
throw new ioexception
bytes tostringbinary key  offset  length
bytes tostringbinary lastkeybuffer  lastkeyoffset
lastkeylength
else if  keycomp    0
isduplicatekey   true
return isduplicatekey
/** checks the given value for validity. */
protected void checkvalue final byte value  final int offset
final int length  throws ioexception
if  value    null
throw new ioexception
/**
* @return path or null if we were passed a stream rather than a path.
*/
@override
public path getpath
return path
@override
public string tostring
return      path    null ? path tostring     null
name       compressalgo getname
/**
* sets remaining trailer fields, writes the trailer to disk, and optionally
* closes the output stream.
*/
protected void finishclose fixedfiletrailer trailer  throws ioexception
trailer setmetaindexcount metanames size
trailer settotaluncompressedbytes totaluncompressedbytes  trailer gettrailersize
trailer setentrycount entrycount
trailer setcompressioncodec compressalgo
trailer serialize outputstream
if  closeoutputstream
outputstream close
outputstream   null
public static compression algorithm compressionbyname string algoname
if  algoname    null
return hfile default_compression_algorithm
return compression getcompressionalgorithmbyname algoname
/** a helper method to create hfile output streams in constructors */
protected static fsdataoutputstream createoutputstream configuration conf
filesystem fs  path path  throws ioexception
fspermission perms   fsutils getfilepermissions fs  conf
hconstants data_file_umask_key
return fsutils create fs  path  perms