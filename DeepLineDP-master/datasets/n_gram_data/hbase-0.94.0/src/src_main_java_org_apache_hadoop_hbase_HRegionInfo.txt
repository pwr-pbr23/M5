/**
* copyright 2007 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase
import java io datainput
import java io dataoutput
import java io eofexception
import java io ioexception
import java util arrays
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hbase keyvalue kvcomparator
import org apache hadoop hbase migration hregioninfo090x
import org apache hadoop hbase util bytes
import org apache hadoop hbase util fstabledescriptors
import org apache hadoop hbase util jenkinshash
import org apache hadoop hbase util md5hash
import org apache hadoop io versionedwritable
import org apache hadoop io writablecomparable
/**
* hregion information.
* contains hregion id, start and end keys, a reference to this
* hregions' table descriptor, etc.
*/
public class hregioninfo extends versionedwritable
implements writablecomparable<hregioninfo>
// version == 0 when hregioninfo had an htabledescriptor inside it.
public static final byte version_pre_092   0
public static final byte version   1
private static final log log   logfactory getlog hregioninfo class
/**
* the new format for a region name contains its encodedname at the end.
* the encoded name also serves as the directory name for the region
* in the filesystem.
*
* new region name format:
*    &lt;tablename>,,&lt;startkey>,&lt;regionidtimestamp>.&lt;encodedname>.
* where,
*    &lt;encodedname> is a hex version of the md5 hash of
*    &lt;tablename>,&lt;startkey>,&lt;regionidtimestamp>
*
* the old region name format:
*    &lt;tablename>,&lt;startkey>,&lt;regionidtimestamp>
* for region names in the old format, the encoded name is a 32-bit
* jenkinshash integer value (in its decimal notation, string form).
*<p>
* **note**
*
* root, the first meta region, and regions created by an older
* version of hbase (0.20 or prior) will continue to use the
* old region name format.
*/
/** separator used to demarcate the encodedname in a region name
* in the new format. see description on new format above.
*/
private static final int enc_separator
public  static final int md5_hex_length     32
/**
* does region name contain its encoded name?
* @param regionname region name
* @return boolean indicating if this a new format region
*         name which contains its encoded name.
*/
private static boolean hasencodedname final byte regionname
// check if region name ends in enc_separator
if   regionname length >  1
regionname    enc_separator
// region name is new format. it contains the encoded name.
return true
return false
/**
* @param regionname
* @return the encodedname
*/
public static string encoderegionname final byte  regionname
string encodedname
if  hasencodedname regionname
// region is in new format:
// <tablename>,<startkey>,<regionidtimestamp>/encodedname/
encodedname   bytes tostring regionname
regionname length   md5_hex_length   1
md5_hex_length
else
// old format region name. root and first meta region also
// use this format.encodedname is the jenkinshash value.
int hashval   math abs jenkinshash getinstance   hash regionname
regionname length  0
encodedname   string valueof hashval
return encodedname
/**
* use logging.
* @param encodedregionname the encoded regionname.
* @return <code>-root-</code> if passed <code>70236052</code> or
* <code>.meta.</code> if passed </code>1028785192</code> else returns
* <code>encodedregionname</code>
*/
public static string prettyprint final string encodedregionname
if  encodedregionname equals
return encodedregionname
else if  encodedregionname equals
return encodedregionname
return encodedregionname
/** delimiter used between portions of a region name */
public static final int delimiter
/** hregioninfo for root region */
public static final hregioninfo root_regioninfo
new hregioninfo 0l  bytes tobytes
/** hregioninfo for first meta region */
public static final hregioninfo first_meta_regioninfo
new hregioninfo 1l  bytes tobytes
private byte  endkey   hconstants empty_byte_array
// this flag is in the parent of a split while the parent is still referenced
// by daughter regions.  we used to set this flag when we disabled a table
// but now table state is kept up in zookeeper as of 0.90.0 hbase.
private boolean offline   false
private long regionid    1
private transient byte  regionname   hconstants empty_byte_array
private string regionnamestr
private boolean split   false
private byte  startkey   hconstants empty_byte_array
private int hashcode    1
//todo: move no_hash to hstorefile which is really the only place it is used.
public static final string no_hash   null
private volatile string encodedname   no_hash
private byte  encodednameasbytes   null
// current tablename
private byte tablename   null
private void sethashcode
int result   arrays hashcode this regionname
result ^  this regionid
result ^  arrays hashcode this startkey
result ^  arrays hashcode this endkey
result ^  boolean valueof this offline  hashcode
result ^  arrays hashcode this tablename
this hashcode   result
/**
* private constructor used constructing hregioninfo for the catalog root and
* first meta regions
*/
private hregioninfo long regionid  byte tablename
super
this regionid   regionid
this tablename   tablename clone
// note: root & first meta regions names are still in old format
this regionname   createregionname tablename  null
regionid  false
this regionnamestr   bytes tostringbinary this regionname
sethashcode
/** default constructor - creates empty object */
public hregioninfo
super
/**
* used only for migration
* @param other hregioninfoformigration
*/
public hregioninfo hregioninfo090x other
super
this endkey   other getendkey
this offline   other isoffline
this regionid   other getregionid
this regionname   other getregionname
this regionnamestr   bytes tostringbinary this regionname
this split   other issplit
this startkey   other getstartkey
this hashcode   other hashcode
this encodedname   other getencodedname
this tablename   other gettabledesc   getname
public hregioninfo final byte tablename
this tablename  null  null
/**
* construct hregioninfo with explicit parameters
*
* @param tablename the table name
* @param startkey first key in region
* @param endkey end of key range
* @throws illegalargumentexception
*/
public hregioninfo final byte tablename  final byte startkey
final byte endkey
throws illegalargumentexception
this tablename  startkey  endkey  false
/**
* construct hregioninfo with explicit parameters
*
* @param tablename the table descriptor
* @param startkey first key in region
* @param endkey end of key range
* @param split true if this region has split and we have daughter regions
* regions that may or may not hold references to this region.
* @throws illegalargumentexception
*/
public hregioninfo final byte tablename  final byte startkey
final byte endkey  final boolean split
throws illegalargumentexception
this tablename  startkey  endkey  split  system currenttimemillis
/**
* construct hregioninfo with explicit parameters
*
* @param tablename the table descriptor
* @param startkey first key in region
* @param endkey end of key range
* @param split true if this region has split and we have daughter regions
* regions that may or may not hold references to this region.
* @param regionid region id to use.
* @throws illegalargumentexception
*/
public hregioninfo final byte tablename  final byte startkey
final byte endkey  final boolean split  final long regionid
throws illegalargumentexception
super
if  tablename    null
throw new illegalargumentexception
this tablename   tablename clone
this offline   false
this regionid   regionid
this regionname   createregionname this tablename  startkey  regionid  true
this regionnamestr   bytes tostringbinary this regionname
this split   split
this endkey   endkey    null? hconstants empty_end_row  endkey clone
this startkey   startkey    null?
hconstants empty_start_row  startkey clone
this tablename   tablename clone
sethashcode
/**
* costruct a copy of another hregioninfo
*
* @param other
*/
public hregioninfo hregioninfo other
super
this endkey   other getendkey
this offline   other isoffline
this regionid   other getregionid
this regionname   other getregionname
this regionnamestr   bytes tostringbinary this regionname
this split   other issplit
this startkey   other getstartkey
this hashcode   other hashcode
this encodedname   other getencodedname
this tablename   other tablename
/**
* make a region name of passed parameters.
* @param tablename
* @param startkey can be null
* @param regionid region id (usually timestamp from when region was created).
* @param newformat should we create the region name in the new format
*                  (such that it contains its encoded name?).
* @return region name made of passed tablename, startkey and id
*/
public static byte  createregionname final byte  tablename
final byte  startkey  final long regionid  boolean newformat
return createregionname tablename  startkey  long tostring regionid   newformat
/**
* make a region name of passed parameters.
* @param tablename
* @param startkey can be null
* @param id region id (usually timestamp from when region was created).
* @param newformat should we create the region name in the new format
*                  (such that it contains its encoded name?).
* @return region name made of passed tablename, startkey and id
*/
public static byte  createregionname final byte  tablename
final byte  startkey  final string id  boolean newformat
return createregionname tablename  startkey  bytes tobytes id   newformat
/**
* make a region name of passed parameters.
* @param tablename
* @param startkey can be null
* @param id region id (usually timestamp from when region was created).
* @param newformat should we create the region name in the new format
*                  (such that it contains its encoded name?).
* @return region name made of passed tablename, startkey and id
*/
public static byte  createregionname final byte  tablename
final byte  startkey  final byte  id  boolean newformat
byte  b   new byte [tablename length   2   id length
startkey    null? 0  startkey length
newformat ?  md5_hex_length   2    0 ]
int offset   tablename length
system arraycopy tablename  0  b  0  offset
b   delimiter
if  startkey    null    startkey length > 0
system arraycopy startkey  0  b  offset  startkey length
offset    startkey length
b   delimiter
system arraycopy id  0  b  offset  id length
offset    id length
if  newformat
//
// encoded name should be built into the region name.
//
// use the region name thus far (namely, <tablename>,<startkey>,<id>)
// to compute a md5 hash to be used as the encoded name, and append
// it to the byte buffer.
//
string md5hash   md5hash getmd5ashex b  0  offset
byte  md5hashbytes   bytes tobytes md5hash
if  md5hashbytes length    md5_hex_length
log error     md5_hex_length
md5hashbytes length
// now append the bytes '.<encodedname>.' to the end
b   enc_separator
system arraycopy md5hashbytes  0  b  offset  md5_hex_length
offset    md5_hex_length
b   enc_separator
return b
/**
* gets the table name from the specified region name.
* @param regionname
* @return table name.
*/
public static byte  gettablename byte  regionname
int offset    1
for  int i   0  i < regionname length  i
if  regionname    delimiter
offset   i
break
byte  tablename   new byte
system arraycopy regionname  0  tablename  0  offset
return tablename
/**
* separate elements of a regionname.
* @param regionname
* @return array of byte[] containing tablename, startkey and id
* @throws ioexception
*/
public static byte  parseregionname final byte  regionname
throws ioexception
int offset    1
for  int i   0  i < regionname length  i
if  regionname    delimiter
offset   i
break
if offset     1  throw new ioexception
byte  tablename   new byte
system arraycopy regionname  0  tablename  0  offset
offset    1
for  int i   regionname length   1  i > 0  i
if regionname    delimiter
offset   i
break
if offset     1  throw new ioexception
byte  startkey   hconstants empty_byte_array
if offset    tablename length   1
startkey   new byte
system arraycopy regionname  tablename length   1  startkey  0
offset   tablename length   1
byte  id   new byte
system arraycopy regionname  offset   1  id  0
regionname length   offset   1
byte  elements   new byte
elements   tablename
elements   startkey
elements   id
return elements
/** @return the regionid */
public long getregionid
return regionid
/**
* @return the regionname as an array of bytes.
* @see #getregionnameasstring()
*/
public byte  getregionname
return regionname
/**
* @return region name as a string for use in logging, etc.
*/
public string getregionnameasstring
if  hasencodedname this regionname
// new format region names already have their encoded name.
return this regionnamestr
// old format. regionnamestr doesn't have the region name.
//
//
return this regionnamestr       this getencodedname
/** @return the encoded region name */
public synchronized string getencodedname
if  this encodedname    no_hash
this encodedname   encoderegionname this regionname
return this encodedname
public synchronized byte  getencodednameasbytes
if  this encodednameasbytes    null
this encodednameasbytes   bytes tobytes getencodedname
return this encodednameasbytes
/** @return the startkey */
public byte  getstartkey
return startkey
/** @return the endkey */
public byte  getendkey
return endkey
/**
* get current table name of the region
* @return byte array of table name
*/
public byte gettablename
if  tablename    null    tablename length    0
tablename   gettablename getregionname
return tablename
/**
* get current table name as string
* @return string representation of current table
*/
public string gettablenameasstring
return bytes tostring tablename
/**
* returns true if the given inclusive range of rows is fully contained
* by this region. for example, if the region is foo,a,g and this is
* passed ["b","c"] or ["a","c"] it will return true, but if this is passed
* ["b","z"] it will return false.
* @throws illegalargumentexception if the range passed is invalid (ie end < start)
*/
public boolean containsrange byte rangestartkey  byte rangeendkey
if  bytes compareto rangestartkey  rangeendkey  > 0
throw new illegalargumentexception
bytes tostringbinary rangestartkey
bytes tostringbinary rangeendkey
boolean firstkeyinrange   bytes compareto rangestartkey  startkey  >  0
boolean lastkeyinrange
bytes compareto rangeendkey  endkey  < 0
bytes equals endkey  hconstants empty_byte_array
return firstkeyinrange    lastkeyinrange
/**
* return true if the given row falls in this region.
*/
public boolean containsrow byte row
return bytes compareto row  startkey  >  0
bytes compareto row  endkey  < 0
bytes equals endkey  hconstants empty_byte_array
/**
* @return the tabledesc
* @deprecated do not use; expensive call
*         use hregioninfo.gettablenameasstring() in place of
*         hregioninfo.gettabledesc().getnameasstring()
*/
@deprecated
public htabledescriptor gettabledesc
configuration c   hbaseconfiguration create
filesystem fs
try
fs   filesystem get c
catch  ioexception e
throw new runtimeexception e
fstabledescriptors fstd
new fstabledescriptors fs  new path c get hconstants hbase_dir
try
return fstd get this tablename
catch  ioexception e
throw new runtimeexception e
/**
* @param newdesc new table descriptor to use
* @deprecated do not use; expensive call
*/
@deprecated
public void settabledesc htabledescriptor newdesc
configuration c   hbaseconfiguration create
filesystem fs
try
fs   filesystem get c
catch  ioexception e
throw new runtimeexception e
fstabledescriptors fstd
new fstabledescriptors fs  new path c get hconstants hbase_dir
try
fstd add newdesc
catch  ioexception e
throw new runtimeexception e
/** @return true if this is the root region */
public boolean isrootregion
return bytes equals tablename  hregioninfo root_regioninfo gettablename
/** @return true if this region is from a table that is a meta table,
* either <code>.meta.</code> or <code>-root-</code>
*/
public boolean ismetatable
return isrootregion      ismetaregion
/** @return true if this region is a meta region */
public boolean ismetaregion
return bytes equals tablename  hregioninfo first_meta_regioninfo gettablename
/**
* @return true if has been split and has daughters.
*/
public boolean issplit
return this split
/**
* @param split set split status
*/
public void setsplit boolean split
this split   split
/**
* @return true if this region is offline.
*/
public boolean isoffline
return this offline
/**
* the parent of a region split is offline while split daughters hold
* references to the parent. offlined regions are closed.
* @param offline set online/offline status.
*/
public void setoffline boolean offline
this offline   offline
/**
* @return true if this is a split parent region.
*/
public boolean issplitparent
if   issplit    return false
if   isoffline
log warn     getregionnameasstring
return true
/**
* @see java.lang.object#tostring()
*/
@override
public string tostring
return     hconstants name
this regionnamestr
bytes tostringbinary this startkey
bytes tostringbinary this endkey
getencodedname
isoffline  ?
issplit  ?
/**
* @see java.lang.object#equals(java.lang.object)
*/
@override
public boolean equals object o
if  this    o
return true
if  o    null
return false
if    o instanceof hregioninfo
return false
return this compareto  hregioninfo o     0
/**
* @see java.lang.object#hashcode()
*/
@override
public int hashcode
return this hashcode
/** @return the object version number */
@override
public byte getversion
return version
//
// writable
//
@override
public void write dataoutput out  throws ioexception
super write out
bytes writebytearray out  endkey
out writeboolean offline
out writelong regionid
bytes writebytearray out  regionname
out writeboolean split
bytes writebytearray out  startkey
bytes writebytearray out  tablename
out writeint hashcode
@override
public void readfields datainput in  throws ioexception
// read the single version byte.  we don't ask the super class do it
// because freaks out if its not the current classes' version.  this method
// can deserialize version 0 and version 1 of hri.
byte version   in readbyte
if  version    0
// this is the old hri that carried an htd.  migrate it.  the below
// was copied from the old 0.90 hri readfields.
this endkey   bytes readbytearray in
this offline   in readboolean
this regionid   in readlong
this regionname   bytes readbytearray in
this regionnamestr   bytes tostringbinary this regionname
this split   in readboolean
this startkey   bytes readbytearray in
try
htabledescriptor htd   new htabledescriptor
htd readfields in
this tablename   htd getname
catch eofexception eofe
throw new ioexception    eofe
this hashcode   in readint
else if  getversion      version
this endkey   bytes readbytearray in
this offline   in readboolean
this regionid   in readlong
this regionname   bytes readbytearray in
this regionnamestr   bytes tostringbinary this regionname
this split   in readboolean
this startkey   bytes readbytearray in
this tablename   bytes readbytearray in
this hashcode   in readint
else
throw new ioexception     getversion
//
// comparable
//
public int compareto hregioninfo o
if  o    null
return 1
// are regions of same table?
int result   bytes compareto this tablename  o tablename
if  result    0
return result
// compare start keys.
result   bytes compareto this startkey  o startkey
if  result    0
return result
// compare end keys.
result   bytes compareto this endkey  o endkey
if  result    0
if  this getstartkey   length    0
this getendkey   length    0
return 1     this is last region
if  o getstartkey   length    0
o getendkey   length    0
return  1     o is the last region
return result
// regionid is usually milli timestamp -- this defines older stamps
// to be "smaller" than newer stamps in sort order.
if  this regionid > o regionid
return 1
else if  this regionid < o regionid
return  1
if  this offline    o offline
return 0
if  this offline    true  return  1
return 1
/**
* @return comparator to use comparing {@link keyvalue}s.
*/
public kvcomparator getcomparator
return isrootregion  ? keyvalue root_comparator  ismetaregion  ?
keyvalue meta_comparator  keyvalue comparator