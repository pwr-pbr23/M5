/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase executor
import java io ioexception
import java util concurrent atomic atomiclong
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase server
/**
* abstract base class for all hbase event handlers. subclasses should
* implement the {@link #process()} method.  subclasses should also do all
* necessary checks up in their constructor if possible -- check table exists,
* is disabled, etc. -- so they fail fast rather than later when process is
* running.  do it this way because process be invoked directly but event
* handlers are also
* run in an executor context -- i.e. asynchronously -- and in this case,
* exceptions thrown at process time will not be seen by the invoker, not till
* we implement a call-back mechanism so the client can pick them up later.
* <p>
* event handlers have an {@link eventtype}.
* {@link eventtype} is a list of all handler event types.  we need to keep
* a full list in one place -- and as enums is a good shorthand for an
* implemenations -- because event handlers can be passed to executors when
* they are to be run asynchronously. the
* hbase executor, see {@link executorservice}, has a switch for passing
* event type to executor.
* <p>
* event listeners can be installed and will be called pre- and post- process if
* this eventhandler is run in a thread (its a runnable so if its {@link #run()}
* method gets called).  implement
* {@link eventhandlerlistener}s, and registering using
* {@link #setlistener(eventhandlerlistener)}.
* @see executorservice
*/
public abstract class eventhandler implements runnable  comparable<runnable>
private static final log log   logfactory getlog eventhandler class
// type of event this object represents
protected eventtype eventtype
protected server server
// sequence id generator for default fifo ordering of events
protected static atomiclong seqids   new atomiclong 0
// sequence id for this event
private final long seqid
// listener to call pre- and post- processing.  may be null.
private eventhandlerlistener listener
// time to wait for events to happen, should be kept short
protected final int waitingtimeforevents
/**
* this interface provides pre- and post-process hooks for events.
*/
public interface eventhandlerlistener
/**
* called before any event is processed
* @param event the event handler whose process method is about to be called.
*/
public void beforeprocess eventhandler event
/**
* called after any event is processed
* @param event the event handler whose process method is about to be called.
*/
public void afterprocess eventhandler event
/**
* list of all hbase event handler types.  event types are named by a
* convention: event type names specify the component from which the event
* originated and then where its destined -- e.g. rs2zk_ prefix means the
* event came from a regionserver destined for zookeeper -- and then what
* the even is; e.g. region_opening.
*
* <p>we give the enums indices so we can add types later and keep them
* grouped together rather than have to add them always to the end as we
* would have to if we used raw enum ordinals.
*/
public enum eventtype
// messages originating from rs (note: there is no direct communication from
// rs to master). these are a result of rs updates into zk.
//rs_zk_region_closing    (1),   // it is replaced by m_zk_region_closing(hbase-4739)
rs_zk_region_closed        2        rs has finished closing a region
rs_zk_region_opening       3        rs is in process of opening a region
rs_zk_region_opened        4        rs has finished opening a region
rs_zk_region_splitting     5        rs has started a region split
rs_zk_region_split         6        rs split has completed
rs_zk_region_failed_open   7        rs failed to open a region
// messages originating from master to rs
m_rs_open_region           20       master asking rs to open a region
m_rs_open_root             21       master asking rs to open root
m_rs_open_meta             22       master asking rs to open meta
m_rs_close_region          23       master asking rs to close a region
m_rs_close_root            24       master asking rs to close root
m_rs_close_meta            25       master asking rs to close meta
// messages originating from client to master
c_m_delete_table           40        client asking master to delete a table
c_m_disable_table          41        client asking master to disable a table
c_m_enable_table           42        client asking master to enable a table
c_m_modify_table           43        client asking master to modify a table
c_m_add_family             44        client asking master to add family to table
c_m_delete_family          45        client asking master to delete family of table
c_m_modify_family          46        client asking master to modify family of table
c_m_create_table           47        client asking master to create a table
// updates from master to zk. this is done by the master and there is
// nothing to process by either master or rs
m_zk_region_offline        50       master adds this region as offline in zk
m_zk_region_closing        51       master adds this region as closing in zk
// master controlled events to be executed on the master
m_server_shutdown          70       master is processing shutdown of a rs
m_meta_server_shutdown     72       master is processing shutdown of rs hosting a meta region   root  or  meta
/**
* constructor
*/
eventtype int value
public boolean isonlineschemachangesupported
return
this equals eventtype c_m_add_family
this equals eventtype c_m_delete_family
this equals eventtype c_m_modify_family
this equals eventtype c_m_modify_table
/**
* default base class constructor.
*/
public eventhandler server server  eventtype eventtype
this server   server
this eventtype   eventtype
seqid   seqids incrementandget
this waitingtimeforevents   server getconfiguration
getint    1000
public void run
try
if  getlistener      null  getlistener   beforeprocess this
process
if  getlistener      null  getlistener   afterprocess this
catch throwable t
log error     eventtype  t
/**
* this method is the main processing loop to be implemented by the various
* subclasses.
* @throws ioexception
*/
public abstract void process   throws ioexception
/**
* return the event type
* @return the event type.
*/
public eventtype geteventtype
return this eventtype
/**
* get the priority level for this handler instance.  this uses natural
* ordering so lower numbers are higher priority.
* <p>
* lowest priority is integer.max_value.  highest priority is 0.
* <p>
* subclasses should override this method to allow prioritizing handlers.
* <p>
* handlers with the same priority are handled in fifo order.
* <p>
* @return integer.max_value by default, override to set higher priorities
*/
public int getpriority
return integer max_value
/**
* @return this events' sequence id.
*/
public long getseqid
return this seqid
/**
* default prioritized runnable comparator which implements a fifo ordering.
* <p>
* subclasses should not override this.  instead, if they want to implement
* priority beyond fifo, they should override {@link #getpriority()}.
*/
@override
public int compareto runnable o
eventhandler eh    eventhandler o
if getpriority      eh getpriority
return  getpriority   < eh getpriority    ?  1   1
return  this seqid < eh seqid  ?  1   1
/**
* @return current listener or null if none set.
*/
public synchronized eventhandlerlistener getlistener
return listener
/**
* @param listener listener to call pre- and post- {@link #process()}.
*/
public synchronized void setlistener eventhandlerlistener listener
this listener   listener
@override
public string tostring
return     getseqid
eventtype
getinformativename
/**
* event implementations should override thie class to provide an
* informative name about what event they are handling. for example,
* event-specific information such as which region or server is
* being processed should be included if possible.
*/
public string getinformativename
return this getclass   tostring