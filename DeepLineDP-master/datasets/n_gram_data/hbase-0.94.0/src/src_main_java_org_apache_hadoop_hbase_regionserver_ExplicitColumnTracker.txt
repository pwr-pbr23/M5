/*
* copyright 2009 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver
import java util arraylist
import java util list
import java util navigableset
import org apache hadoop hbase hconstants
import org apache hadoop hbase keyvalue
import org apache hadoop hbase regionserver scanquerymatcher matchcode
import org apache hadoop hbase util bytes
/**
* this class is used for the tracking and enforcement of columns and numbers
* of versions during the course of a get or scan operation, when explicit
* column qualifiers have been asked for in the query.
*
* with a little magic (see {@link scanquerymatcher}), we can use this matcher
* for both scans and gets.  the main difference is 'next' and 'done' collapse
* for the scan case (since we see all columns in order), and we only reset
* between rows.
*
* <p>
* this class is utilized by {@link scanquerymatcher} through two methods:
* <ul><li>{@link #checkcolumn} is called when a put satisfies all other
* conditions of the query.  this method returns a {@link org.apache.hadoop.hbase.regionserver.scanquerymatcher.matchcode} to define
* what action should be taken.
* <li>{@link #update} is called at the end of every storefile or memstore.
* <p>
* this class is not thread-safe as queries are never multi-threaded
*/
public class explicitcolumntracker implements columntracker
private final int maxversions
private final int minversions
/**
* contains the list of columns that the explicitcolumntracker is tracking.
* each columncount instance also tracks how many versions of the requested
* column have been returned.
*/
private final list<columncount> columns
private final list<columncount> columnstoreuse
private int index
private columncount column
/** keeps track of the latest timestamp included for current column.
* used to eliminate duplicates. */
private long latesttsofcurrentcolumn
private long oldeststamp
/**
* default constructor.
* @param columns columns specified user in query
* @param minversions minimum number of versions to keep
* @param maxversions maximum versions to return per column
* @param oldestunexpiredts the oldest timestamp we are interested in,
*  based on ttl
* @param ttl the timetolive to enforce
*/
public explicitcolumntracker navigableset<byte> columns  int minversions
int maxversions  long oldestunexpiredts
this maxversions   maxversions
this minversions   minversions
this oldeststamp   oldestunexpiredts
this columns   new arraylist<columncount> columns size
this columnstoreuse   new arraylist<columncount> columns size
for byte  column   columns
this columnstoreuse add new columncount column
reset
/**
* done when there are no more columns to match against.
*/
public boolean done
return this columns size      0
public columncount getcolumnhint
return this column
/**
* {@inheritdoc}
*/
@override
public scanquerymatcher matchcode checkcolumn byte  bytes  int offset
int length  long timestamp  byte type  boolean ignorecount
// delete markers should never be passed to an
// *explicit*columntracker
assert  keyvalue isdelete type
do
// no more columns left, we are done with this query
if this columns size      0
return scanquerymatcher matchcode seek_next_row     done_row
// no more columns to match against, done with storefile
if this column    null
return scanquerymatcher matchcode seek_next_row     done_row
// compare specific column to current column
int ret   bytes compareto column getbuffer    column getoffset
column getlength    bytes  offset  length
// column matches. if it is not a duplicate key, increment the version count
// and include.
if ret    0
if  ignorecount  return scanquerymatcher matchcode include
//if column matches, check if it is a duplicate timestamp
if  sameaspreviousts timestamp
//if duplicate, skip this key
return scanquerymatcher matchcode skip
int count   this column increment
if count >  maxversions     count >  minversions    isexpired timestamp
// done with versions for this column
// note: because we are done with this column, and are removing
// it from columns, we don't do a ++this.index. the index stays
// the same but the columns have shifted within the array such
// that index now points to the next column we are interested in.
this columns remove this index
resetts
if  this columns size      this index
// we have served all the requested columns.
this column   null
return scanquerymatcher matchcode include_and_seek_next_row
else
// we are done with current column; advance to next column
// of interest.
this column   this columns get this index
return scanquerymatcher matchcode include_and_seek_next_col
else
setts timestamp
return scanquerymatcher matchcode include
resetts
if  ret > 0
// the current kv is smaller than the column the explicitcolumntracker
// is interested in, so seek to that column of interest.
return scanquerymatcher matchcode seek_next_col
// the current kv is bigger than the column the explicitcolumntracker
// is interested in. that means there is no more data for the column
// of interest. advance the explicitcolumntracker state to next
// column of interest, and check again.
if  ret <   1
if    this index >  this columns size
// no more to match, do not include, done with this row.
return scanquerymatcher matchcode seek_next_row     done_row
// this is the recursive case.
this column   this columns get this index
while true
/**
* called at the end of every storefile or memstore.
*/
public void update
if this columns size      0
this index   0
this column   this columns get this index
else
this index    1
this column   null
// called between every row.
public void reset
buildcolumnlist
this index   0
this column   this columns get this index
resetts
private void resetts
latesttsofcurrentcolumn   hconstants latest_timestamp
private void setts long timestamp
latesttsofcurrentcolumn   timestamp
private boolean sameaspreviousts long timestamp
return timestamp    latesttsofcurrentcolumn
private boolean isexpired long timestamp
return timestamp < oldeststamp
private void buildcolumnlist
this columns clear
this columns addall this columnstoreuse
for columncount col   this columns
col setcount 0
/**
* this method is used to inform the column tracker that we are done with
* this column. we may get this information from external filters or
* timestamp range and we then need to indicate this information to
* tracker. it is required only in case of explicitcolumntracker.
* @param bytes
* @param offset
* @param length
*/
public void donewithcolumn byte  bytes  int offset  int length
while  this column    null
int compare   bytes compareto column getbuffer    column getoffset
column getlength    bytes  offset  length
resetts
if  compare    0
this columns remove this index
if  this columns size      this index
// will not hit any more columns in this storefile
this column   null
else
this column   this columns get this index
return
else if   compare <   1
if   this index    this columns size
this column   this columns get this index
else
this column   null
else
return
public matchcode getnextrowornextcolumn byte bytes  int offset
int quallength
donewithcolumn bytes  offset quallength
if  getcolumnhint      null
return matchcode seek_next_row
else
return matchcode seek_next_col
public boolean isdone long timestamp
return minversions <  0    isexpired timestamp