/**
* copyright 2011 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import java util arraylist
import java util collection
import java util comparator
import java util list
import java util map entry
import java util treemap
import java util treeset
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase util bytes bytearraycomparator
import com google common collect arraylistmultimap
import com google common collect multimap
import com google common collect treemultimap
/**
* this is a generic region split calculator. it requires ranges that provide
* start, end, and a comparator. it works in two phases -- the first adds ranges
* and rejects backwards ranges. then one calls calcregions to generate the
* multimap that has a start split key as a key and possibly multiple ranges as
* members.
*
* to traverse, one normally would get the split set, and iterate through the
* calcregions. normal regions would have only one entry, holes would have zero,
* and any overlaps would have multiple entries.
*
* the interface is a bit cumbersome currently but is exposed this way so that
* clients can choose how to iterate through the region splits.
*
* @param <r>
*/
public class regionsplitcalculator<r extends keyrange>
final static log log   logfactory getlog regionsplitcalculator class
private final comparator<r> rangecmp
/**
* this contains a sorted set of all the possible split points
*
* invariant: once populated this has 0 entries if empty or at most n+1 values
* where n == number of added ranges.
*/
private final treeset<byte> splits   new treeset<byte> bytes_comparator
/**
* this is a map from start key to regions with the same start key.
*
* invariant: this always have n values in total
*/
private final multimap<byte  r> starts   arraylistmultimap create
/**
* special case
*/
private final static byte endkey   null
public regionsplitcalculator comparator<r> cmp
rangecmp   cmp
public final static comparator<byte> bytes_comparator   new bytearraycomparator
@override
public int compare byte l  byte r
if  l    null    r    null
return 0
if  l    null
return 1
if  r    null
return  1
return super compare l  r
/**
* special case wrapper for empty end key
*
* @return endkey if end key is empty, else normal endkey.
*/
private static <r extends keyrange> byte specialendkey r range
byte end   range getendkey
if  end length    0
return endkey
return end
/**
* adds an edge to the split calculator
*
* @return true if is included, false if backwards/invalid
*/
public boolean add r range
byte start   range getstartkey
byte end   specialendkey range
if  end    endkey    bytes compareto start  end  > 0
// don't allow backwards edges
log debug     bytes tostring start
bytes tostring end
return false
splits add start
splits add end
starts put start  range
return true
/**
* generates a coverage multimap from split key to regions that start with the
* split key.
*
* @return coverage multimap
*/
public multimap<byte  r> calccoverage
// this needs to be sorted to force the use of the comparator on the values,
// otherwise byte array comparison isn't used
multimap<byte  r> regions   treemultimap create bytes_comparator
rangecmp
// march through all splits from the start points
for  entry<byte  collection<r>> start   starts asmap   entryset
byte key   start getkey
for  r r   start getvalue
regions put key  r
for  byte coveredsplit   splits subset r getstartkey
specialendkey r
regions put coveredsplit  r
return regions
public treeset<byte> getsplits
return splits
public multimap<byte  r> getstarts
return starts
/**
* find specified number of top ranges in a big overlap group.
* it could return less if there are not that many top ranges.
* once these top ranges are excluded, the big overlap group will
* be broken into ranges with no overlapping, or smaller overlapped
* groups, and most likely some holes.
*
* @param bigoverlap a list of ranges that overlap with each other
* @param count the max number of ranges to find
* @return a list of ranges that overlap with most others
*/
public static <r extends keyrange> list<r>
findbigranges collection<r> bigoverlap  int count
list<r> bigranges   new arraylist<r>
// the key is the count of overlaps,
// the value is a list of ranges that have that many overlaps
treemap<integer  list<r>> overlaprangemap   new treemap<integer  list<r>>
for  r r  bigoverlap
// calculates the # of overlaps for each region
// and populates rangeoverlapmap
byte startkey   r getstartkey
byte endkey   specialendkey r
int overlappedregions   0
for  r rr  bigoverlap
byte start   rr getstartkey
byte end   specialendkey rr
if  bytes_comparator compare startkey  end  < 0
bytes_comparator compare endkey  start  > 0
overlappedregions
// one region always overlaps with itself,
// so overlappedregions should be more than 1
// for actual overlaps.
if  overlappedregions > 1
integer key   integer valueof overlappedregions
list<r> ranges   overlaprangemap get key
if  ranges    null
ranges   new arraylist<r>
overlaprangemap put key  ranges
ranges add r
int tobeadded   count
for  integer key  overlaprangemap descendingkeyset
list<r> chunk   overlaprangemap get key
int chunksize   chunk size
if  chunksize <  tobeadded
bigranges addall chunk
tobeadded    chunksize
if  tobeadded > 0  continue
else
// try to use the middle chunk in case the overlapping is
// chained, for example: [a, c), [b, e), [d, g), [f h)...
// in such a case, sideline the middle chunk will break
// the group efficiently.
int start    chunksize   tobeadded  2
int end   start   tobeadded
for  int i   start  i < end  i
bigranges add chunk get i
break
return bigranges