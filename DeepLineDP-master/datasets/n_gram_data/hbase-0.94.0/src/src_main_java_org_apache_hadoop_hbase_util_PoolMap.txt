/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import java util arraylist
import java util collection
import java util hashmap
import java util hashset
import java util linkedlist
import java util list
import java util map
import java util set
import java util concurrent concurrenthashmap
import java util concurrent concurrentlinkedqueue
import java util concurrent copyonwritearraylist
import java util concurrent atomic atomicinteger
/**
*
* the <code>poolmap</code> maps a key to a collection of values, the elements
* of which are managed by a pool. in effect, that collection acts as a shared
* pool of resources, access to which is closely controlled as per the semantics
* of the pool.
*
* <p>
* in case the size of the pool is set to a non-zero positive number, that is
* used to cap the number of resources that a pool may contain for any given
* key. a size of {@link integer#max_value} is interpreted as an unbounded pool.
* </p>
*
* @param <k>
*          the type of the key to the resource
* @param <v>
*          the type of the resource being pooled
*/
public class poolmap<k  v> implements map<k  v>
private pooltype pooltype
private int poolmaxsize
private map<k  pool<v>> pools   new concurrenthashmap<k  pool<v>>
public poolmap pooltype pooltype
this pooltype   pooltype
public poolmap pooltype pooltype  int poolmaxsize
this pooltype   pooltype
this poolmaxsize   poolmaxsize
@override
public v get object key
pool<v> pool   pools get key
return pool    null ? pool get     null
@override
public v put k key  v value
pool<v> pool   pools get key
if  pool    null
pools put key  pool   createpool
return pool    null ? pool put value    null
@suppresswarnings
@override
public v remove object key
pool<v> pool   pools remove key
if  pool    null
remove  k  key  pool get
return null
public boolean remove k key  v value
pool<v> pool   pools get key
boolean res   false
if  pool    null
res   pool remove value
if  res    pool size      0
pools remove key
return res
@override
public collection<v> values
collection<v> values   new arraylist<v>
for  pool<v> pool   pools values
collection<v> poolvalues   pool values
if  poolvalues    null
values addall poolvalues
return values
public collection<v> values k key
collection<v> values   new arraylist<v>
pool<v> pool   pools get key
if  pool    null
collection<v> poolvalues   pool values
if  poolvalues    null
values addall poolvalues
return values
@override
public boolean isempty
return pools isempty
@override
public int size
return pools size
public int size k key
pool<v> pool   pools get key
return pool    null ? pool size     0
@override
public boolean containskey object key
return pools containskey key
@override
public boolean containsvalue object value
if  value    null
return false
for  pool<v> pool   pools values
if  value equals pool get
return true
return false
@override
public void putall map<? extends k  ? extends v> map
for  map entry<? extends k  ? extends v> entry   map entryset
put entry getkey    entry getvalue
@override
public void clear
for  pool<v> pool   pools values
pool clear
pools clear
@override
public set<k> keyset
return pools keyset
@override
public set<map entry<k  v>> entryset
set<map entry<k  v>> entries   new hashset<entry<k  v>>
for  map entry<k  pool<v>> poolentry   pools entryset
final k poolkey   poolentry getkey
final pool<v> pool   poolentry getvalue
for  final v poolvalue   pool values
if  pool    null
entries add new map entry<k  v>
@override
public k getkey
return poolkey
@override
public v getvalue
return poolvalue
@override
public v setvalue v value
return pool put value
return null
protected interface pool<r>
public r get
public r put r resource
public boolean remove r resource
public void clear
public collection<r> values
public int size
public enum pooltype
reusable  threadlocal  roundrobin
public static pooltype valueof string pooltypename
pooltype defaultpooltype  pooltype    allowedpooltypes
pooltype pooltype   pooltype fuzzymatch pooltypename
if  pooltype    null
boolean allowedtype   false
if  pooltype equals defaultpooltype
allowedtype   true
else
if  allowedpooltypes    null
for  pooltype allowedpooltype   allowedpooltypes
if  pooltype equals allowedpooltype
allowedtype   true
break
if   allowedtype
pooltype   null
return  pooltype    null  ? pooltype   defaultpooltype
public static string fuzzynormalize string name
return name    null ? name replaceall       trim   tolowercase
public static pooltype fuzzymatch string name
for  pooltype pooltype   values
if  fuzzynormalize name  equals fuzzynormalize pooltype name
return pooltype
return null
protected pool<v> createpool
switch  pooltype
case reusable
return new reusablepool<v> poolmaxsize
case roundrobin
return new roundrobinpool<v> poolmaxsize
case threadlocal
return new threadlocalpool<v>
return null
/**
* the <code>reusablepool</code> represents a {@link poolmap.pool} that builds
* on the {@link linkedlist} class. it essentially allows resources to be
* checked out, at which point it is removed from this pool. when the resource
* is no longer required, it should be returned to the pool in order to be
* reused.
*
* <p>
* if {@link #maxsize} is set to {@link integer#max_value}, then the size of
* the pool is unbounded. otherwise, it caps the number of consumers that can
* check out a resource from this pool to the (non-zero positive) value
* specified in {@link #maxsize}.
* </p>
*
* @param <r>
*          the type of the resource
*/
@suppresswarnings
public class reusablepool<r> extends concurrentlinkedqueue<r> implements pool<r>
private int maxsize
public reusablepool int maxsize
this maxsize   maxsize
@override
public r get
return poll
@override
public r put r resource
if  size   < maxsize
add resource
return null
@override
public collection<r> values
return this
/**
* the <code>roundrobinpool</code> represents a {@link poolmap.pool}, which
* stores its resources in an {@link arraylist}. it load-balances access to
* its resources by returning a different resource every time a given key is
* looked up.
*
* <p>
* if {@link #maxsize} is set to {@link integer#max_value}, then the size of
* the pool is unbounded. otherwise, it caps the number of resources in this
* pool to the (non-zero positive) value specified in {@link #maxsize}.
* </p>
*
* @param <r>
*          the type of the resource
*
*/
@suppresswarnings
class roundrobinpool<r> extends copyonwritearraylist<r> implements pool<r>
private int maxsize
private int nextresource   0
public roundrobinpool int maxsize
this maxsize   maxsize
@override
public r put r resource
if  size   < maxsize
add resource
return null
@override
public r get
if  size   < maxsize
return null
nextresource %  size
r resource   get nextresource
return resource
@override
public collection<r> values
return this
/**
* the <code>threadlocalpool</code> represents a {@link poolmap.pool} that
* builds on the {@link threadlocal} class. it essentially binds the resource
* to the thread from which it is accessed.
*
* <p>
* note that the size of the pool is essentially bounded by the number of threads
* that add resources to this pool.
* </p>
*
* @param <r>
*          the type of the resource
*/
static class threadlocalpool<r> extends threadlocal<r> implements pool<r>
private static final map<threadlocalpool<?>  atomicinteger> poolsizes   new hashmap<threadlocalpool<?>  atomicinteger>
public threadlocalpool
@override
public r put r resource
r previousresource   get
if  previousresource    null
atomicinteger poolsize   poolsizes get this
if  poolsize    null
poolsizes put this  poolsize   new atomicinteger 0
poolsize incrementandget
this set resource
return previousresource
@override
public void remove
super remove
atomicinteger poolsize   poolsizes get this
if  poolsize    null
poolsize decrementandget
@override
public int size
atomicinteger poolsize   poolsizes get this
return poolsize    null ? poolsize get     0
@override
public boolean remove r resource
r previousresource   super get
if  resource    null    resource equals previousresource
remove
return true
else
return false
@override
public void clear
super remove
@override
public collection<r> values
list<r> values   new arraylist<r>
values add get
return values