/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements. see the notice file distributed with this
* work for additional information regarding copyright ownership. the asf
* licenses this file to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
* http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis, without
* warranties or conditions of any kind, either express or implied. see the
* license for the specific language governing permissions and limitations
* under the license.
*/
package org apache hadoop hbase io encoding
import java io bytearrayinputstream
import java io bytearrayoutputstream
import java io datainputstream
import java io dataoutputstream
import java io ioexception
import java nio bytebuffer
import java util iterator
import org apache commons lang notimplementedexception
import org apache hadoop hbase keyvalue
import org apache hadoop io compress compressor
/**
* encapsulates a data block compressed using a particular encoding algorithm.
* useful for testing and benchmarking.
*/
public class encodeddatablock
private static final int buffer_size   4   1024
protected datablockencoder datablockencoder
bytearrayoutputstream uncompressedoutputstream
bytebuffer uncompressedbuffer
private byte cachecompressdata
private bytearrayoutputstream compressedstream   new bytearrayoutputstream
private boolean includesmemstorets
/**
* create a buffer which will be encoded using datablockencoder.
* @param datablockencoder algorithm used for compression.
*/
public encodeddatablock datablockencoder datablockencoder
boolean includesmemstorets
this datablockencoder   datablockencoder
uncompressedoutputstream   new bytearrayoutputstream buffer_size
/**
* add keyvalue and compress it.
* @param kv item to be added and compressed.
*/
public void addkv keyvalue kv
cachecompressdata   null
uncompressedoutputstream write
kv getbuffer    kv getoffset    kv getlength
/**
* provides access to compressed value.
* @return forwards sequential iterator.
*/
public iterator<keyvalue> getiterator
final int uncompressedsize   uncompressedoutputstream size
final bytearrayinputstream bais   new bytearrayinputstream
getcompresseddata
final datainputstream dis   new datainputstream bais
return new iterator<keyvalue>
private bytebuffer decompresseddata   null
@override
public boolean hasnext
if  decompresseddata    null
return uncompressedsize > 0
return decompresseddata hasremaining
@override
public keyvalue next
if  decompresseddata    null
try
decompresseddata   datablockencoder uncompresskeyvalues
dis  includesmemstorets
catch  ioexception e
throw new runtimeexception
e
decompresseddata rewind
int offset   decompresseddata position
keyvalue kv   new keyvalue decompresseddata array    offset
decompresseddata position offset   kv getlength
return kv
@override
public void remove
throw new notimplementedexception
@override
public string tostring
return     datablockencoder getclass   getname
/**
* find the size of minimal buffer that could store compressed data.
* @return size in bytes of compressed data.
*/
public int getsize
return getcompresseddata   length
/**
* find the size of compressed data assuming that buffer will be compressed
* using given algorithm.
* @param compressor algorithm used for compression.
* @param buffer array to be compressed.
* @param offset offset to beginning of the data.
* @param length length to be compressed.
* @return size of compressed data in bytes.
*/
public static int checkcompressedsize compressor compressor  byte buffer
int offset  int length
byte compressedbuffer   new byte
// in fact the buffer could be of any positive size
compressor setinput buffer  offset  length
compressor finish
int currentpos   0
while   compressor finished
try
// we don't care about compressed data,
// we just want to callculate number of bytes
currentpos    compressor compress compressedbuffer  0
compressedbuffer length
catch  ioexception e
throw new runtimeexception
compressor getclass   getname    e
return currentpos
/**
* estimate size after second stage of compression (e.g. lzo).
* @param compressor algorithm which will be used for compressions.
* @return size after second stage of compression.
*/
public int checkcompressedsize compressor compressor
// compress
byte compressedbytes   getcompresseddata
return checkcompressedsize compressor  compressedbytes  0
compressedbytes length
private byte getcompresseddata
// is cached
if  cachecompressdata    null
return cachecompressdata
cachecompressdata   docompressdata
return cachecompressdata
private bytebuffer getuncompressedbuffer
if  uncompressedbuffer    null
uncompressedbuffer limit   < uncompressedoutputstream size
uncompressedbuffer   bytebuffer wrap
uncompressedoutputstream tobytearray
return uncompressedbuffer
/**
* do the compression.
* @return compressed byte buffer.
*/
public byte docompressdata
compressedstream reset
dataoutputstream dataout   new dataoutputstream compressedstream
try
this datablockencoder compresskeyvalues
dataout  getuncompressedbuffer    includesmemstorets
catch  ioexception e
throw new runtimeexception string format
tostring     e
return compressedstream tobytearray
@override
public string tostring
return datablockencoder tostring
/**
* get uncompressed buffer.
* @return the buffer.
*/
public byte getrawkeyvalues
return uncompressedoutputstream tobytearray