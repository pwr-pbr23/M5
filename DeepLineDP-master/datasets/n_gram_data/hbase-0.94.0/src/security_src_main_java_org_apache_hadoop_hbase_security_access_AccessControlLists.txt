/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase security access
import com google common collect arraylistmultimap
import com google common collect listmultimap
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop hbase hcolumndescriptor
import org apache hadoop hbase hconstants
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase keyvalue
import org apache hadoop hbase catalog metareader
import org apache hadoop hbase client delete
import org apache hadoop hbase client get
import org apache hadoop hbase client htable
import org apache hadoop hbase client put
import org apache hadoop hbase client result
import org apache hadoop hbase client resultscanner
import org apache hadoop hbase client scan
import org apache hadoop hbase io hbaseobjectwritable
import org apache hadoop hbase io hfile compression
import org apache hadoop hbase master masterservices
import org apache hadoop hbase regionserver hregion
import org apache hadoop hbase regionserver internalscanner
import org apache hadoop hbase regionserver storefile
import org apache hadoop hbase util bytes
import org apache hadoop hbase util pair
import org apache hadoop io text
import java io bytearrayoutputstream
import java io datainput
import java io dataoutput
import java io dataoutputstream
import java io ioexception
import java util
/**
* maintains lists of permission grants to users and groups to allow for
* authorization checks by {@link accesscontroller}.
*
* <p>
* access control lists are stored in an "internal" metadata table named
* {@code _acl_}. each table's permission grants are stored as a separate row,
* keyed by the table name. keyvalues for permissions assignments are stored
* in one of the formats:
* <pre>
* key                      desc
* --------                 --------
* user                     table level permissions for a user [r=read, w=write]
* @group                   table level permissions for a group
* user,family              column family level permissions for a user
* @group,family            column family level permissions for a group
* user,family,qualifier    column qualifier level permissions for a user
* @group,family,qualifier  column qualifier level permissions for a group
* </pre>
* all values are encoded as byte arrays containing the codes from the
* {@link org.apache.hadoop.hbase.security.access.tablepermission.action} enum.
* </p>
*/
public class accesscontrollists
/** internal storage table for access control lists */
public static final string acl_table_name_str
public static final byte acl_table_name   bytes tobytes acl_table_name_str
/** column family used to store acl grants */
public static final string acl_list_family_str
public static final byte acl_list_family   bytes tobytes acl_list_family_str
/** table descriptor for acl internal table */
public static final htabledescriptor acl_tabledesc   new htabledescriptor
acl_table_name
static
acl_tabledesc addfamily
new hcolumndescriptor acl_list_family
10     ten is arbitrary number   keep versions to help debugging
compression algorithm none getname    true  true  8   1024
hconstants forever  storefile bloomtype none tostring
hconstants replication_scope_local
/**
* delimiter to separate user, column family, and qualifier in
* _acl_ table info: column keys */
public static final char acl_key_delimiter
/** prefix character to denote group names */
public static final string group_prefix
/** configuration key for superusers */
public static final string superuser_conf_key
private static log log   logfactory getlog accesscontrollists class
/**
* check for existence of {@code _acl_} table and create it if it does not exist
* @param master reference to hmaster
*/
static void init masterservices master  throws ioexception
if   metareader tableexists master getcatalogtracker    acl_table_name_str
master createtable acl_tabledesc  null
/**
* stores a new table permission grant in the access control lists table.
* @param conf the configuration
* @param tablename the table to which access is being granted
* @param username the user or group being granted the permission
* @param perm the details of the permission being granted
* @throws ioexception in the case of an error accessing the metadata table
*/
static void addtablepermission configuration conf
byte tablename  string username  tablepermission perm
throws ioexception
put p   new put tablename
byte key   bytes tobytes username
if  perm getfamily      null    perm getfamily   length > 0
key   bytes add key
bytes add new byte acl_key_delimiter   perm getfamily
if  perm getqualifier      null    perm getqualifier   length > 0
key   bytes add key
bytes add new byte acl_key_delimiter   perm getqualifier
tablepermission action actions   perm getactions
if   actions    null      actions length    0
log warn   username
return
byte value   new byte
for  int i   0  i < actions length  i
value   actions code
p add acl_list_family  key  value
if  log isdebugenabled
log debug
bytes tostring tablename
bytes tostring key    bytes tostringbinary value
htable acls   null
try
acls   new htable conf  acl_table_name
acls put p
finally
if  acls    null  acls close
/**
* removes a previously granted permission from the stored access control
* lists.  the {@link tablepermission} being removed must exactly match what
* is stored -- no wildcard matching is attempted.  ie, if user "bob" has
* been granted "read" access to the "data" table, but only to column family
* plus qualifier "info:cola", then trying to call this method with only
* user "bob" and the table name "data" (but without specifying the
* column qualifier "info:cola") will have no effect.
*
* @param conf the configuration
* @param tablename the table of the current permission grant
* @param username the user or group currently granted the permission
* @param perm the details of the permission to be revoked
* @throws ioexception if there is an error accessing the metadata table
*/
static void removetablepermission configuration conf
byte tablename  string username  tablepermission perm
throws ioexception
delete d   new delete tablename
byte key   null
if  perm getfamily      null    perm getfamily   length > 0
key   bytes tobytes username   acl_key_delimiter
bytes tostring perm getfamily
if  perm getqualifier      null    perm getqualifier   length > 0
key   bytes tobytes username   acl_key_delimiter
bytes tostring perm getfamily      acl_key_delimiter
bytes tostring perm getqualifier
else
key   bytes tobytes username   acl_key_delimiter
bytes tostring perm getfamily
else
key   bytes tobytes username
if  log isdebugenabled
log debug     username
perm tostring
d deletecolumns acl_list_family  key
htable acls   null
try
acls   new htable conf  acl_table_name
acls delete d
finally
if  acls    null  acls close
/**
* returns {@code true} if the given region is part of the {@code _acl_}
* metadata table.
*/
static boolean isaclregion hregion region
return bytes equals acl_table_name  region gettabledesc   getname
/**
* loads all of the permission grants stored in a region of the {@code _acl_}
* table.
*
* @param aclregion
* @return
* @throws ioexception
*/
static map<byte listmultimap<string tablepermission>> loadall
hregion aclregion
throws ioexception
if   isaclregion aclregion
throw new ioexception   acl_table_name_str
map<byte listmultimap<string tablepermission>> allperms
new treemap<byte listmultimap<string tablepermission>> bytes bytes_comparator
// do a full scan of _acl_ table
scan scan   new scan
scan addfamily acl_list_family
internalscanner iscanner   null
try
iscanner   aclregion getscanner scan
while  true
list<keyvalue> row   new arraylist<keyvalue>
boolean hasnext   iscanner next row
listmultimap<string tablepermission> perms   arraylistmultimap create
byte table   null
for  keyvalue kv   row
if  table    null
table   kv getrow
pair<string tablepermission> permissionsofuserontable
parsetablepermissionrecord table  kv
if  permissionsofuserontable    null
string username   permissionsofuserontable getfirst
tablepermission permissions   permissionsofuserontable getsecond
perms put username  permissions
if  table    null
allperms put table  perms
if   hasnext
break
finally
if  iscanner    null
iscanner close
return allperms
/**
* load all permissions from the region server holding {@code _acl_},
* primarily intended for testing purposes.
*/
static map<byte listmultimap<string tablepermission>> loadall
configuration conf  throws ioexception
map<byte listmultimap<string tablepermission>> allperms
new treemap<byte listmultimap<string tablepermission>> bytes bytes_comparator
// do a full scan of _acl_, filtering on only first table region rows
scan scan   new scan
scan addfamily acl_list_family
htable acls   null
resultscanner scanner   null
try
acls   new htable conf  acl_table_name
scanner   acls getscanner scan
for  result row   scanner
listmultimap<string tablepermission> resultperms
parsetablepermissions row getrow    row
allperms put row getrow    resultperms
finally
if  scanner    null  scanner close
if  acls    null  acls close
return allperms
/**
* reads user permission assignments stored in the <code>l:</code> column
* family of the first table row in <code>_acl_</code>.
*
* <p>
* see {@link accesscontrollists class documentation} for the key structure
* used for storage.
* </p>
*/
static listmultimap<string tablepermission> gettablepermissions
configuration conf  byte tablename
throws ioexception
/* todo: -root- and .meta. cannot easily be handled because they must be
* online before _acl_ table.  can anything be done here?
*/
if  bytes equals tablename  hconstants root_table_name
bytes equals tablename  hconstants meta_table_name
bytes equals tablename  accesscontrollists acl_table_name
return arraylistmultimap create 0 0
// for normal user tables, we just read the table row from _acl_
listmultimap<string tablepermission> perms   arraylistmultimap create
htable acls   null
try
acls   new htable conf  acl_table_name
get get   new get tablename
get addfamily acl_list_family
result row   acls get get
if   row isempty
perms   parsetablepermissions tablename  row
else
log info   acl_table_name_str
bytes tostring tablename
finally
if  acls    null  acls close
return perms
/**
* returns the currently granted permissions for a given table as a list of
* user plus associated permissions.
*/
static list<userpermission> getuserpermissions
configuration conf  byte tablename
throws ioexception
listmultimap<string tablepermission> allperms   gettablepermissions
conf  tablename
list<userpermission> perms   new arraylist<userpermission>
for  map entry<string  tablepermission> entry   allperms entries
userpermission up   new userpermission bytes tobytes entry getkey
entry getvalue   gettable    entry getvalue   getfamily
entry getvalue   getqualifier    entry getvalue   getactions
perms add up
return perms
private static listmultimap<string tablepermission> parsetablepermissions
byte table  result result
listmultimap<string tablepermission> perms   arraylistmultimap create
if  result    null    result size   > 0
for  keyvalue kv   result raw
pair<string tablepermission> permissionsofuserontable
parsetablepermissionrecord table  kv
if  permissionsofuserontable    null
string username   permissionsofuserontable getfirst
tablepermission permissions   permissionsofuserontable getsecond
perms put username  permissions
return perms
private static pair<string tablepermission> parsetablepermissionrecord
byte table  keyvalue kv
// return x given a set of permissions encoded in the permissionrecord kv.
byte family   kv getfamily
if   bytes equals family  acl_list_family
return null
byte key   kv getqualifier
byte value   kv getvalue
if  log isdebugenabled
log debug
bytes tostringbinary key
bytes tostringbinary value
// check for a column family appended to the key
// todo: avoid the string conversion to make this more efficient
string username   bytes tostring key
int idx   username indexof acl_key_delimiter
byte permfamily   null
byte permqualifier   null
if  idx > 0    idx < username length   1
string remainder   username substring idx 1
username   username substring 0  idx
idx   remainder indexof acl_key_delimiter
if  idx > 0    idx < remainder length   1
permfamily   bytes tobytes remainder substring 0  idx
permqualifier   bytes tobytes remainder substring idx 1
else
permfamily   bytes tobytes remainder
return new pair<string tablepermission>
username  new tablepermission table  permfamily  permqualifier  value
/**
* writes a set of permissions as {@link org.apache.hadoop.io.writable} instances
* to the given output stream.
* @param out
* @param perms
* @param conf
* @throws ioexception
*/
public static void writepermissions dataoutput out
listmultimap<string ? extends permission> perms  configuration conf
throws ioexception
set<string> keys   perms keyset
out writeint keys size
for  string key   keys
text writestring out  key
hbaseobjectwritable writeobject out  perms get key   list class  conf
/**
* writes a set of permissions as {@link org.apache.hadoop.io.writable} instances
* and returns the resulting byte array.
*/
public static byte writepermissionsasbytes
listmultimap<string ? extends permission> perms  configuration conf
try
bytearrayoutputstream bos   new bytearrayoutputstream
writepermissions new dataoutputstream bos   perms  conf
return bos tobytearray
catch  ioexception ioe
// shouldn't happen here
log error    ioe
return null
/**
* reads a set of permissions as {@link org.apache.hadoop.io.writable} instances
* from the input stream.
*/
public static <t extends permission> listmultimap<string t> readpermissions
datainput in  configuration conf  throws ioexception
listmultimap<string t> perms   arraylistmultimap create
int length   in readint
for  int i 0  i<length  i
string user   text readstring in
list<t> userperms
list hbaseobjectwritable readobject in  conf
perms putall user  userperms
return perms
/**
* returns whether or not the given name should be interpreted as a group
* principal.  currently this simply checks if the name starts with the
* special group prefix character ("@").
*/
public static boolean isgroupprincipal string name
return name    null    name startswith group_prefix
/**
* returns the actual name for a group principal (stripped of the
* group prefix).
*/
public static string getgroupname string aclkey
if   isgroupprincipal aclkey
return aclkey
return aclkey substring group_prefix length