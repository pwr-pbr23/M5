/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import java io closeable
import java io ioexception
import java util collection
import java util list
import java util map
import org apache hadoop conf configuration
import org apache hadoop hbase hbaseconfiguration
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase client coprocessor batch
import org apache hadoop hbase ipc coprocessorprotocol
import org apache hadoop hbase util bytes
import org apache hadoop hbase util poolmap
import org apache hadoop hbase util poolmap pooltype
/**
* a simple pool of htable instances.
*
* each htablepool acts as a pool for all tables. to use, instantiate an
* htablepool and use {@link #gettable(string)} to get an htable from the pool.
*
* this method is not needed anymore, clients should call
* htableinterface.close() rather than returning the tables to the pool
*
* once you are done with it, close your instance of {@link htableinterface}
* by calling {@link htableinterface#close()} rather than returning the tables
* to the pool with (deprecated) {@link #puttable(htableinterface)}.
*
* <p>
* a pool can be created with a <i>maxsize</i> which defines the most htable
* references that will ever be retained for each table. otherwise the default
* is {@link integer#max_value}.
*
* <p>
* pool will manage its own connections to the cluster. see
* {@link hconnectionmanager}.
*/
public class htablepool implements closeable
private final poolmap<string  htableinterface> tables
private final int maxsize
private final pooltype pooltype
private final configuration config
private final htableinterfacefactory tablefactory
/**
* default constructor. default hbaseconfiguration and no limit on pool size.
*/
public htablepool
this hbaseconfiguration create    integer max_value
/**
* constructor to set maximum versions and use the specified configuration.
*
* @param config
*          configuration
* @param maxsize
*          maximum number of references to keep for each table
*/
public htablepool final configuration config  final int maxsize
this config  maxsize  null  null
/**
* constructor to set maximum versions and use the specified configuration and
* table factory.
*
* @param config
*          configuration
* @param maxsize
*          maximum number of references to keep for each table
* @param tablefactory
*          table factory
*/
public htablepool final configuration config  final int maxsize
final htableinterfacefactory tablefactory
this config  maxsize  tablefactory  pooltype reusable
/**
* constructor to set maximum versions and use the specified configuration and
* pool type.
*
* @param config
*          configuration
* @param maxsize
*          maximum number of references to keep for each table
* @param pooltype
*          pool type which is one of {@link pooltype#reusable} or
*          {@link pooltype#threadlocal}
*/
public htablepool final configuration config  final int maxsize
final pooltype pooltype
this config  maxsize  null  pooltype
/**
* constructor to set maximum versions and use the specified configuration,
* table factory and pool type. the htablepool supports the
* {@link pooltype#reusable} and {@link pooltype#threadlocal}. if the pool
* type is null or not one of those two values, then it will default to
* {@link pooltype#reusable}.
*
* @param config
*          configuration
* @param maxsize
*          maximum number of references to keep for each table
* @param tablefactory
*          table factory
* @param pooltype
*          pool type which is one of {@link pooltype#reusable} or
*          {@link pooltype#threadlocal}
*/
public htablepool final configuration config  final int maxsize
final htableinterfacefactory tablefactory  pooltype pooltype
// make a new configuration instance so i can safely cleanup when
// done with the pool.
this config   config    null ? hbaseconfiguration create     config
this maxsize   maxsize
this tablefactory   tablefactory    null ? new htablefactory
tablefactory
if  pooltype    null
this pooltype   pooltype reusable
else
switch  pooltype
case reusable
case threadlocal
this pooltype   pooltype
break
default
this pooltype   pooltype reusable
break
this tables   new poolmap<string  htableinterface> this pooltype
this maxsize
/**
* get a reference to the specified table from the pool.
* <p>
* <p/>
*
* @param tablename
*          table name
* @return a reference to the specified table
* @throws runtimeexception
*           if there is a problem instantiating the htable
*/
public htableinterface gettable string tablename
// call the old gettable implementation renamed to findorcreatetable
htableinterface table   findorcreatetable tablename
// return a proxy table so when user closes the proxy, the actual table
// will be returned to the pool
try
return new pooledhtable table
catch  ioexception ioe
throw new runtimeexception ioe
/**
* get a reference to the specified table from the pool.
* <p>
*
* create a new one if one is not available.
*
* @param tablename
*          table name
* @return a reference to the specified table
* @throws runtimeexception
*           if there is a problem instantiating the htable
*/
private htableinterface findorcreatetable string tablename
htableinterface table   tables get tablename
if  table    null
table   createhtable tablename
return table
/**
* get a reference to the specified table from the pool.
* <p>
*
* create a new one if one is not available.
*
* @param tablename
*          table name
* @return a reference to the specified table
* @throws runtimeexception
*           if there is a problem instantiating the htable
*/
public htableinterface gettable byte tablename
return gettable bytes tostring tablename
/**
* this method is not needed anymore, clients should call
* htableinterface.close() rather than returning the tables to the pool
*
* @param table
*          the proxy table user got from pool
* @deprecated
*/
public void puttable htableinterface table  throws ioexception
// we need to be sure nobody puts a proxy implementation in the pool
// but if the client code is not updated
// and it will continue to call puttable() instead of calling close()
// then we need to return the wrapped table to the pool instead of the
// proxy
// table
if  table instanceof pooledhtable
returntable   pooledhtable  table  getwrappedtable
else
// normally this should not happen if clients pass back the same
// table
// object they got from the pool
// but if it happens then it's better to reject it
throw new illegalargumentexception     table
/**
* puts the specified htable back into the pool.
* <p>
*
* if the pool already contains <i>maxsize</i> references to the table, then
* the table instance gets closed after flushing buffered edits.
*
* @param table
*          table
*/
private void returntable htableinterface table  throws ioexception
// this is the old puttable method renamed and made private
string tablename   bytes tostring table gettablename
if  tables size tablename  >  maxsize
// release table instance since we're not reusing it
this tables remove tablename  table
this tablefactory releasehtableinterface table
return
tables put tablename  table
protected htableinterface createhtable string tablename
return this tablefactory createhtableinterface config
bytes tobytes tablename
/**
* closes all the htable instances , belonging to the given table, in the
* table pool.
* <p>
* note: this is a 'shutdown' of the given table pool and different from
* {@link #puttable(htableinterface)}, that is used to return the table
* instance to the pool for future re-use.
*
* @param tablename
*/
public void closetablepool final string tablename  throws ioexception
collection<htableinterface> tables   this tables values tablename
if  tables    null
for  htableinterface table   tables
this tablefactory releasehtableinterface table
this tables remove tablename
/**
* see {@link #closetablepool(string)}.
*
* @param tablename
*/
public void closetablepool final byte tablename  throws ioexception
closetablepool bytes tostring tablename
/**
* closes all the htable instances , belonging to all tables in the table
* pool.
* <p>
* note: this is a 'shutdown' of all the table pools.
*/
public void close   throws ioexception
for  string tablename   tables keyset
closetablepool tablename
this tables clear
int getcurrentpoolsize string tablename
return tables size tablename
/**
* a proxy class that implements htableinterface.close method to return the
* wrapped table back to the table pool
*
*/
class pooledhtable extends htable
private htableinterface table     actual table implementation
public pooledhtable htableinterface table  throws ioexception
super table getconfiguration    table gettablename
this table   table
@override
public byte gettablename
return table gettablename
@override
public configuration getconfiguration
return table getconfiguration
@override
public htabledescriptor gettabledescriptor   throws ioexception
return table gettabledescriptor
@override
public boolean exists get get  throws ioexception
return table exists get
@override
public void batch list<? extends row> actions  object results  throws ioexception
interruptedexception
table batch actions  results
@override
public object batch list<? extends row> actions  throws ioexception
interruptedexception
return table batch actions
@override
public result get get get  throws ioexception
return table get get
@override
public result get list<get> gets  throws ioexception
return table get gets
@override
public result getroworbefore byte row  byte family  throws ioexception
return table getroworbefore row  family
@override
public resultscanner getscanner scan scan  throws ioexception
return table getscanner scan
@override
public resultscanner getscanner byte family  throws ioexception
return table getscanner family
@override
public resultscanner getscanner byte family  byte qualifier
throws ioexception
return table getscanner family  qualifier
@override
public void put put put  throws ioexception
table put put
@override
public void put list<put> puts  throws ioexception
table put puts
@override
public boolean checkandput byte row  byte family  byte qualifier
byte value  put put  throws ioexception
return table checkandput row  family  qualifier  value  put
@override
public void delete delete delete  throws ioexception
table delete delete
@override
public void delete list<delete> deletes  throws ioexception
table delete deletes
@override
public boolean checkanddelete byte row  byte family  byte qualifier
byte value  delete delete  throws ioexception
return table checkanddelete row  family  qualifier  value  delete
@override
public result increment increment increment  throws ioexception
return table increment increment
@override
public long incrementcolumnvalue byte row  byte family
byte qualifier  long amount  throws ioexception
return table incrementcolumnvalue row  family  qualifier  amount
@override
public long incrementcolumnvalue byte row  byte family
byte qualifier  long amount  boolean writetowal  throws ioexception
return table incrementcolumnvalue row  family  qualifier  amount
writetowal
@override
public boolean isautoflush
return table isautoflush
@override
public void flushcommits   throws ioexception
table flushcommits
/**
* returns the actual table back to the pool
*
* @throws ioexception
*/
public void close   throws ioexception
returntable table
@override
public rowlock lockrow byte row  throws ioexception
return table lockrow row
@override
public void unlockrow rowlock rl  throws ioexception
table unlockrow rl
@override
public <t extends coprocessorprotocol> t coprocessorproxy
class<t> protocol  byte row
return table coprocessorproxy protocol  row
@override
public <t extends coprocessorprotocol  r> map<byte  r> coprocessorexec
class<t> protocol  byte startkey  byte endkey
batch call<t  r> callable  throws ioexception  throwable
return table coprocessorexec protocol  startkey  endkey  callable
@override
public <t extends coprocessorprotocol  r> void coprocessorexec
class<t> protocol  byte startkey  byte endkey
batch call<t  r> callable  batch callback<r> callback
throws ioexception  throwable
table coprocessorexec protocol  startkey  endkey  callable  callback
@override
public string tostring
return         table
/**
* expose the wrapped htable to tests in the same package
*
* @return wrapped htable
*/
htableinterface getwrappedtable
return table