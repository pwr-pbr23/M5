/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
/**
* restrict the domain of a data attribute, often times to fulfill business rules/requirements.
*
<p>
<h2> table of contents</h2>
<ul>
<li><a href="#overview">overview</a></li>
<li><a href="#concurrency">concurrency and atomicity</a></li>
<li><a href="#caveats">caveats</a></li>
<li><a href="#usage">example usage</a></li>
</ul>
</p>
<h2><a name="overview">overview</a></h2>
constraints are used to enforce business rules in a database.
by checking all {@link org.apache.hadoop.hbase.client.put puts} on a given table, you can enforce very specific data policies.
for instance, you can ensure that a certain column family-column qualifier pair always has a value between 1 and 10.
otherwise, the {@link org.apache.hadoop.hbase.client.put} is rejected and the data integrity is maintained.
<p>
constraints are designed to be configurable, so a constraint can be used across different tables, but implement different
behavior depending on the specific configuration given to that constraint.
<p>
by adding a constraint to a table (see <a href="#usage">example usage</a>), constraints will automatically enabled.
you also then have the option of to disable (just 'turn off') or remove (delete all associated information) all constraints on a table.
if you remove all constraints
(see {@link org.apache.hadoop.hbase.constraint.constraints#remove(org.apache.hadoop.hbase.htabledescriptor)},
you must re-add any {@link org.apache.hadoop.hbase.constraint.constraint} you want on that table.
however, if they are just disabled (see {@link org.apache.hadoop.hbase.constraint.constraints#disable(org.apache.hadoop.hbase.htabledescriptor)},
all you need to do is enable constraints again, and everything will be turned back on as it was configured.
individual constraints can also be individually enabled, disabled or removed without affecting other constraints.
<p>
by default, constraints are disabled on a table.
this means you will not see <i>any</i> slow down on a table if constraints are not enabled.
<p>
<h2><a name="concurrency">concurrency and atomicity</a></h2>
currently, no attempts at enforcing correctness in a multi-threaded scenario when modifying a constraint, via
{@link org.apache.hadoop.hbase.constraint.constraints}, to the the {@link org.apache.hadoop.hbase.htabledescriptor}.
this is particularly important when adding a constraint(s) to the {@link org.apache.hadoop.hbase.htabledescriptor}
as it first retrieves the next priority from a custom value set in the descriptor,
adds each constraint (with increasing priority) to the descriptor, and then the next available priority is re-stored
back in the {@link org.apache.hadoop.hbase.htabledescriptor}.
<p>
locking is recommended around each of constraints add methods:
{@link org.apache.hadoop.hbase.constraint.constraints#add(org.apache.hadoop.hbase.htabledescriptor, class...)},
{@link org.apache.hadoop.hbase.constraint.constraints#add(org.apache.hadoop.hbase.htabledescriptor, org.apache.hadoop.hbase.util.pair...)},
and {@link org.apache.hadoop.hbase.constraint.constraints#add(org.apache.hadoop.hbase.htabledescriptor, class, org.apache.hadoop.conf.configuration)}.
any changes on <i>a single htabledescriptor</i> should be serialized, either within a single thread or via external mechanisms.
<p>
note that having a higher priority means that a constraint will run later; e.g. a constraint with priority 1 will run before a
constraint with priority 2.
<p>
since constraints currently are designed to just implement simple checks (e.g. is the value in the right range), there will
be no atomicity conflicts.
even if one of the puts finishes the constraint first, the single row will not be corrupted and the 'fastest' write will win;
the underlying region takes care of breaking the tie and ensuring that writes get serialized to the table.
so yes, this doesn't ensure that we are going to get specific ordering or even a fully consistent view of the underlying data.
<p>
each constraint should only use local/instance variables, unless doing more advanced usage. static variables could cause difficulties
when checking concurrent writes to the same region, leading to either highly locked situations (decreasing through-put) or higher probability of errors.
however, as long as each constraint just uses local variables, each thread interacting with the constraint will execute correctly and efficiently.
<h2><a name="caveats">caveats</a></h2>
in traditional (sql) databases, constraints are often used to enforce <a href="http://en.wikipedia.org/wiki/relational_database#constraints">referential integrity</a>.
however, in hbase, this will likely cause significant overhead and dramatically decrease the number of
{@link org.apache.hadoop.hbase.client.put puts}/second possible on a table. this is because to check the referential integrity
when making a {@link org.apache.hadoop.hbase.client.put}, one must block on a scan for the 'remote' table, checking for the valid reference.
for millions of {@link org.apache.hadoop.hbase.client.put puts} a second, this will breakdown very quickly.
there are several options around the blocking behavior including, but not limited to:
<ul>
<li>create a 'pre-join' table where the keys are already denormalized</li>
<li>designing for 'incorrect' references</li>
<li>using an external enforcement mechanism</li>
</ul>
there are also several general considerations that must be taken into account, when using constraints:
<ol>
<li>all changes made via {@link org.apache.hadoop.hbase.constraint.constraints} will make modifications to the
{@link org.apache.hadoop.hbase.htabledescriptor} for a given table. as such, the usual renabling of tables should be used for
propagating changes to the table. when at all possible, constraints should be added to the table before the table is created.</li>
<li>constraints are run in the order that they are added to a table. this has implications for what order constraints should
be added to a table.</li>
<li>whenever new constraint jars are added to a region server, those region servers need to go through a rolling restart to
make sure that they pick up the new jars and can enable the new constraints.</li>
<li>there are certain keys that are reserved for the configuration namespace:
<ul>
<li>_enabled - used server-side to determine if a constraint should be run</li>
<li>_priority - used server-side to determine what order a constraint should be run</li>
</ul>
if these items are set, they will be respected in the constraint configuration, but they are taken care of by default in when
adding constraints to an {@link org.apache.hadoop.hbase.htabledescriptor} via the usual method.</li>
</ol>
<p>
under the hood, constraints are implemented as a coprocessor (see {@link org.apache.hadoop.hbase.constraint.constraintprocessor}
if you are interested).
<h2><a name="usage">example usage</a></h2>
first, you must define a {@link org.apache.hadoop.hbase.constraint.constraint}.
the best way to do this is to extend {@link org.apache.hadoop.hbase.constraint.baseconstraint}, which takes care of some of the more
mundane details of using a {@link org.apache.hadoop.hbase.constraint.constraint}.
<p>
let's look at one possible implementation of a constraint - an integerconstraint(there are also several simple examples in the tests).
the integerconstraint checks to make sure that the value is a string-encoded <code>int</code>.
it is really simple to implement this kind of constraint, the only method needs to be implemented is
{@link org.apache.hadoop.hbase.constraint.constraint#check(org.apache.hadoop.hbase.client.put)}:
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
public class integerconstraint extends baseconstraint {
public void check(put p) throws constraintexception {
map&ltbyte[], list&ltkeyvalue&gt&gt familymap = p.getfamilymap();
for (list &ltkeyvalue&gt kvs : familymap.values()) {
for (keyvalue kv : kvs) {
// just make sure that we can actually pull out an int
// this will automatically throw a numberformatexception if we try to
// store something that isn't an integer.
try {
integer.parseint(new string(kv.getvalue()));
} catch (numberformatexception e) {
throw new constraintexception("value in put (" + p
+ ") was not a string-encoded integer", e);
} } }
</pre></blockquote>
</div>
<p>
note that all exceptions that you expect to be thrown must be caught and then rethrown as a
{@link org.apache.hadoop.hbase.constraint.constraintexception}. this way, you can be sure that a
{@link org.apache.hadoop.hbase.client.put} fails for an expected reason, rather than for any reason.
for example, an {@link java.lang.outofmemoryerror} is probably indicative of an inherent problem in
the {@link org.apache.hadoop.hbase.constraint.constraint}, rather than a failed {@link org.apache.hadoop.hbase.client.put}.
<p>
if an unexpected exception is thrown (for example, any kind of uncaught {@link java.lang.runtimeexception}),
constraint-checking will be 'unloaded' from the regionserver where that error occurred.
this means no further {@link org.apache.hadoop.hbase.constraint.constraint constraints} will be checked on that server
until it is reloaded. this is done to ensure the system remains as available as possible.
therefore, be careful when writing your own constraint.
<p>
so now that we have a constraint, we want to add it to a table. it's as easy as:
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
htabledescriptor desc = new htabledescriptor(table_name);
...
constraints.add(desc, integerconstraint.class);
</pre></blockquote></div>
<p>
once we added the integerconstraint, constraints will be enabled on the table (once it is created) and
we will always check to make sure that the value is an string-encoded integer.
<p>
however, suppose we also write our own constraint, <code>myconstraint.java</code>.
first, you need to make sure this class-files are in the classpath (in a jar) on the regionserver where
that constraint will be run (this could require a rolling restart on the region server - see <a href="#caveats">caveats</a> above)
<p>
suppose that myconstraint also uses a configuration (see {@link org.apache.hadoop.hbase.constraint.constraint#getconf()}).
then adding myconstraint looks like this:
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
htabledescriptor desc = new htabledescriptor(table_name);
configuration conf = new configuration(false);
...
(add values to the conf)
(modify the table descriptor)
...
constraints.add(desc, new pair(myconstraint.class, conf));
</pre></blockquote></div>
<p>
at this point we added both the integerconstraint and myconstraint to the table, the integerconstraint
<i>will be run first</i>, followed by myconstraint.
<p>
suppose we realize that the {@link org.apache.hadoop.conf.configuration} for myconstraint is actually wrong
when it was added to the table. note, when it is added to the table, it is <i>not</i> added by reference,
but is instead copied into the {@link org.apache.hadoop.hbase.htabledescriptor}.
thus, to change the {@link org.apache.hadoop.conf.configuration} we are using for myconstraint, we need to do this:
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
(add/modify the conf)
...
constraints.setconfiguration(desc, myconstraint.class, conf);
</pre></blockquote></div>
<p>
this will overwrite the previous configuration for myconstraint, but <i>not</i> change the order of the
constraint nor if it is enabled/disabled.
<p>
note that the same constraint class can be added multiple times to a table without repercussion.
a use case for this is the same constraint working differently based on its configuration.
<p>
suppose then we want to disable <i>just</i> myconstraint. its as easy as:
<div style="background-color: #cccccc">
<blockquote><pre>
constraints.disable(desc, myconstraint.class);
</pre></blockquote></div>
<p>
this just turns off myconstraint, but retains the position and the configuration associated with myconstraint.
now, if we want to re-enable the constraint, its just another one-liner:
<div style="background-color: #cccccc">
<blockquote><pre>
constraints.enable(desc, myconstraint.class);
</pre></blockquote></div>
<p>
similarly, constraints on the entire table are disabled via:
<div style="background-color: #cccccc">
<blockquote><pre>
constraints.disable(desc);
</pre></blockquote></div>
<p>
or enabled via:
<div style="background-color: #cccccc">
<blockquote><pre>
constraints.enable(desc);
</pre></blockquote></div>
<p>
lastly, suppose you want to remove myconstraint from the table, including with position it should be run at and its configuration.
this is similarly simple:
<div style="background-color: #cccccc">
<blockquote><pre>
constraints.remove(desc, myconstraint.class);
</pre></blockquote></div>
<p>
also, removing <i>all</i> constraints from a table is similarly simple:
<div style="background-color: #cccccc">
<blockquote><pre>
constraints.remove(desc);
</pre></blockquote></div>
this will remove all constraints (and associated information) from the table and turn off the constraint processing.
<p><b>note</b><p>
it is important to note the use above of
<div style="background-color: #cccccc">
<blockquote><pre>
configuration conf = new configuration(false);
</pre></blockquote></div>
if you just use <code> new configuration()</code>, then the configuration will be loaded with the default
properties. while in the simple case, this is not going to be an issue, it will cause pain down the road.
first, these extra properties are going to cause serious bloat in your {@link org.apache.hadoop.hbase.htabledescriptor},
meaning you are keeping around a ton of redundant information. second, it is going to make examining
your table in the shell, via <code>describe 'table'</code>, a huge pain as you will have to dig through
a ton of irrelevant config values to find the ones you set. in short, just do it the right way.
*/
package org apache hadoop hbase constraint