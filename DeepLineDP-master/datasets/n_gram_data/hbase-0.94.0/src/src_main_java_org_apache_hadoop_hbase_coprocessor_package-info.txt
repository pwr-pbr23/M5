/*
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
/**
<h2>table of contents</h2>
<ul>
<li><a href="#overview">overview</a></li>
<li><a href="#coprocessor">coprocessor</a></li>
<li><a href="#regionobserver">regionobserver</a></li>
<li><a href="#commandtarget">endpoint</a></li>
<li><a href="#load">coprocessor loading</a></li>
</ul>
<h2><a name="overview">overview</a></h2>
coprocessors are code that runs in-process on each region server. regions
contain references to the coprocessor implementation classes associated
with them. coprocessor classes can be loaded either from local
jars on the region server's classpath or via the hdfs classloader.
<p>
multiple types of coprocessors are provided to provide sufficient flexibility
for potential use cases. right now there are:
<p>
<ul>
<li>coprocessor: provides region lifecycle management hooks, e.g., region
open/close/split/flush/compact operations.</li>
<li>regionobserver: provides hook for monitor table operations from
client side, such as table get/put/scan/delete, etc.</li>
<li>endpoint: provides on demand triggers for any arbitrary function
executed at a region. one use case is column aggregation at region
server. </li>
</ul>
<h2><a name="coprocessor">coprocessor</a></h2>
a coprocessor is required to
implement <code>coprocessor</code> interface so that coprocessor framework
can manage it internally.
<p>
another design goal of this interface is to provide simple features for
making coprocessors useful, while exposing no more internal state or
control actions of the region server than necessary and not exposing them
directly.
<p>
over the lifecycle of a region, the methods of this interface are invoked
when the corresponding events happen. the master transitions regions
through the following states:
<p>
&nbsp;&nbsp;&nbsp;
unassigned -> pendingopen -> open -> pendingclose -> closed.
<p>
coprocessors have opportunity to intercept and handle events in
pendingopen, open, and pendingclose states.
<p>
<h3>pendingopen</h3>
<p>
the region server is opening a region to bring it online. coprocessors
can piggyback or fail this process.
<p>
<ul>
<li>preopen, postopen: called before and after the region is reported as
online to the master.</li><p>
</ul>
<p>
<h3>open</h3>
the region is open on the region server and is processing both client
requests (get, put, scan, etc.) and administrative actions (flush, compact,
split, etc.). coprocessors can piggyback administrative actions via:
<p>
<ul>
<li>preflush, postflush: called before and after the memstore is flushed
into a new store file.</li><p>
<li>precompact, postcompact: called before and after compaction.</li><p>
<li>presplit, postsplit: called after the region is split.</li><p>
</ul>
<p>
<h3>pendingclose</h3>
the region server is closing the region. this can happen as part of normal
operations or may happen when the region server is aborting due to fatal
conditions such as oome, health check failure, or fatal filesystem
problems. coprocessors can piggyback this event. if the server is aborting
an indication to this effect will be passed as an argument.
<p>
<ul>
<li>preclose and postclose: called before and after the region is
reported as closed to the master.</li><p>
</ul>
<p>
<h2><a name="regionobserver">regionobserver</a></h2>
if the coprocessor implements the <code>regionobserver</code> interface it can
observe and mediate client actions on the region:
<p>
<ul>
<li>preget, postget: called before and after a client makes a get
request.</li><p>
<li>preexists, postexists: called before and after the client tests
for existence using a get.</li><p>
<li>preput and postput: called before and after the client stores a value.
</li><p>
<li>predelete and postdelete: called before and after the client
deletes a value.</li><p>
<li>prescanneropen postscanneropen: called before and after the client
opens a new scanner.</li><p>
<li>prescannernext, postscannernext: called before and after the client
asks for the next row on a scanner.</li><p>
<li>prescannerclose, postscannerclose: called before and after the client
closes a scanner.</li><p>
<li>precheckandput, postcheckandput: called before and after the client
calls checkandput().</li><p>
<li>precheckanddelete, postcheckanddelete: called before and after the client
calls checkanddelete().</li><p>
</ul>
you can also extend abstract class <code>baseregionobservercoprocessor</code>
which
implements both <code>coprocessor</code> and <code>regionobserver</code>.
in addition, it overrides all methods with default behaviors so you don't
have to override all of them.
<p>
here's an example of what a simple regionobserver might look like. this
example shows how to implement access control for hbase. this
coprocessor checks user information for a given client request, e.g.,
get/put/delete/scan by injecting code at certain
<code>regionobserver</code>
prexxx hooks. if the user is not allowed to access the resource, a
coprocessorexception will be thrown. and the client request will be
denied by receiving this exception.
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
package org.apache.hadoop.hbase.coprocessor;
import java.util.list;
import org.apache.hadoop.hbase.keyvalue;
import org.apache.hadoop.hbase.client.get;
// sample access-control coprocessor. it utilizes regionobserver
// and intercept prexxx() method to check user privilege for the given table
// and column family.
public class accesscontrolcoprocessor extends baseregionobservercoprocessor {
// @override
public get preget(coprocessorenvironment e, get get)
throws coprocessorexception {
// check permissions..
if (access_not_allowed)  {
throw new accessdeniedexception(&quot;user is not allowed to access.&quot;);
}
return get;
}
// override preput(), predelete(), etc.
}
</pre></blockquote>
</div>
<h2><a name="commandtarget">endpoint</a></h2>
<code>coprocessor</code> and <code>regionobserver</code> provide certain hooks
for injecting user code running at each region. the user code will be triggerd
by existing <code>htable</code> and <code>hbaseadmin</code> operations at
the certain hook points.
<p>
through endpoint and dynamic rpc protocol, you can define your own
interface communicated between client and region server,
i.e., you can create a new method, specify passed parameters and return types
for this new method.
and the new endpoint methods can be triggered by
calling client side dynamic rpc functions -- <code>htable.coprocessorexec(...)
</code>.
<p>
to implement a endpoint, you need to:
<ul>
<li>extend <code>coprocessorprotocol</code>: the interface defines
communication protocol for the new endpoint, and will be
served as the rpc protocol between client and region server.</li>
<li>extend both <code>baseendpointcoprocessor</code> abstract class,
and the above extended <code>coprocessorprotocol</code> interface:
the actually implemented class running at region server.</li>
</ul>
<p>
here's an example of performing column aggregation at region server:
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
// a sample protocol for performing aggregation at regions.
public static interface columnaggregationprotocol
extends coprocessorprotocol {
// perform aggregation for a given column at the region. the aggregation
// will include all the rows inside the region. it can be extended to
// allow passing start and end rows for a fine-grained aggregation.
public int sum(byte[] family, byte[] qualifier) throws ioexception;
}
// aggregation implementation at a region.
public static class columnaggregationendpoint extends baseendpointcoprocessor
implements columnaggregationprotocol {
// @override
// scan the region by the given family and qualifier. return the aggregation
// result.
public int sum(byte[] family, byte[] qualifier)
throws ioexception {
// aggregate at each region
scan scan = new scan();
scan.addcolumn(family, qualifier);
int sumresult = 0;
// use an internal scanner to perform scanning.
internalscanner scanner = getenvironment().getregion().getscanner(scan);
try {
list&lt;keyvalue&gt; curvals = new arraylist&lt;keyvalue&gt;();
boolean done = false;
do {
curvals.clear();
done = scanner.next(curvals);
keyvalue kv = curvals.get(0);
sumresult += bytes.toint(kv.getvalue());
} while (done);
} finally {
scanner.close();
}
return sumresult;
}
}
</pre></blockquote>
</div>
<p>
client invocations are performed through <code>htable</code>,
which has the following methods added by dynamic rpc protocol:
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
public &lt;t extends coprocessorprotocol&gt; t coprocessorproxy(class&lt;t&gt; protocol, row row)
public &lt;t extends coprocessorprotocol, r&gt; void coprocessorexec(
class&lt;t&gt; protocol, list&lt;? extends row&gt; rows,
batchcall&lt;t,r&gt; callable, batchcallback&lt;r&gt; callback)
public &lt;t extends coprocessorprotocol, r&gt; void coprocessorexec(
class&lt;t&gt; protocol, rowrange range,
batchcall&lt;t,r&gt; callable, batchcallback&lt;r&gt; callback)
</pre></blockquote>
</div>
<p>
here is a client side example of invoking
<code>columnaggregationendpoint</code>:
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
htable table = new htable(util.getconfiguration(), test_table);
scan scan;
map&lt;byte[], integer&gt; results;
// scan: for all regions
scan = new scan();
results = table.coprocessorexec(columnaggregationprotocol.class, scan,
new batchcall&lt;columnaggregationprotocol,integer&gt;() {
public integer call(columnaggregationprotocol instance) throws ioexception{
return instance.sum(test_family, test_qualifier);
}
});
int sumresult = 0;
int expectedresult = 0;
for (map.entry&lt;byte[], integer&gt; e : results.entryset()) {
sumresult += e.getvalue();
}
</pre></blockquote>
</div>
<h2><a name="load">coprocess loading</a></h2>
a customized coprocessor can be loaded by two different ways, by configuration,
or by <code>htabledescriptor</code> for a newly created table.
<p>
(currently we don't really have an on demand coprocessor loading machanism for
opened regions.)
<h3>load from configuration</h3>
whenever a region is opened, it will read coprocessor class names from
<code>hbase.coprocessor.region.classes</code> from <code>configuration</code>.
coprocessor framework will automatically load the configured classes as
default coprocessors. the classes must be included in the classpath already.
<p>
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
&lt;property&gt;
&lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
&lt;value&gt;org.apache.hadoop.hbase.coprocessor.accesscontrollcoprocessor, org.apache.hadoop.hbase.coprocessor.columnaggregationprotocol&lt;/value&gt;
&lt;description&gt;a comma-separated list of coprocessors that are loaded by
default. for any override coprocessor method from regionobservor or
coprocessor, these classes' implementation will be called
in order. after implement your own
coprocessor, just put it in hbase's classpath and add the fully
qualified class name here.
&lt;/description&gt;
&lt;/property&gt;
</pre></blockquote>
</div>
<p>
the first defined coprocessor will be assigned
<code>coprocessor.priority.system</code> as priority. and each following
coprocessor's priority will be incremented by one. coprocessors are executed
in order according to the natural ordering of the int.
<h3>load from table attribute</h3>
coprocessor classes can also be configured at table attribute. the
attribute key must start with "coprocessor" and values of the form is
&lt;path&gt;:&lt;class&gt;:&lt;priority&gt;, so that the framework can
recognize and load it.
<p>
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
&#39;coprocessor$1&#39; =&gt; &#39;hdfs://localhost:8020/hbase/coprocessors/test.jar:test:1000&#39;
&#39;coprocessor$2&#39; =&gt; &#39;/hbase/coprocessors/test2.jar:anothertest:1001&#39;
</pre></blockquote>
</div>
<p>
&lt;path&gt; must point to a jar, can be on any filesystem supported by the
hadoop </code>filesystem</code> object.
<p>
&lt;class&gt; is the coprocessor implementation class. a jar can contain
more than one coprocessor implementation, but only one can be specified
at a time in each table attribute.
<p>
&lt;priority&gt; is an integer. coprocessors are executed in order according
to the natural ordering of the int. coprocessors can optionally abort
actions. so typically one would want to put authoritative cps (security
policy implementations, perhaps) ahead of observers.
<p>
<div style="background-color: #cccccc; padding: 2px">
<blockquote><pre>
path path = new path(fs.geturi() + path.separator +
"testclassloading.jar");
// create a table that references the jar
htabledescriptor htd = new htabledescriptor(getclass().getname());
htd.addfamily(new hcolumndescriptor("test"));
htd.setvalue("coprocessor$1",
path.tostring() +
":" + classfullname +
":" + coprocessor.priority.user);
hbaseadmin admin = new hbaseadmin(this.conf);
admin.createtable(htd);
<h3>chain of regionobservers</h3>
as described above, multiple coprocessors can be loaded at one region at the
same time. in case of regionobserver, you can have more than one
regionobservers register to one same hook point, i.e, preget(), etc.
when a region reach the
hook point, the framework will invoke each registered regionobserver by the
order of assigned priority.
</pre></blockquote>
</div>
*/
package org.apache.hadoop.hbase.coprocessor;