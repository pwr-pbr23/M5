/*
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import org apache hadoop hbase hconstants
import org apache hadoop hbase keyvalue
import org apache hadoop hbase util bytes
import org apache hadoop io writable
import java io datainput
import java io dataoutput
import java io ioexception
import java util arraylist
import java util list
import java util map
/**
* used to perform delete operations on a single row.
* <p>
* to delete an entire row, instantiate a delete object with the row
* to delete.  to further define the scope of what to delete, perform
* additional methods as outlined below.
* <p>
* to delete specific families, execute {@link #deletefamily(byte[]) deletefamily}
* for each family to delete.
* <p>
* to delete multiple versions of specific columns, execute
* {@link #deletecolumns(byte[], byte[]) deletecolumns}
* for each column to delete.
* <p>
* to delete specific versions of specific columns, execute
* {@link #deletecolumn(byte[], byte[], long) deletecolumn}
* for each column version to delete.
* <p>
* specifying timestamps, deletefamily and deletecolumns will delete all
* versions with a timestamp less than or equal to that passed.  if no
* timestamp is specified, an entry is added with a timestamp of 'now'
* where 'now' is the servers's system.currenttimemillis().
* specifying a timestamp to the deletecolumn method will
* delete versions only with a timestamp equal to that specified.
* if no timestamp is passed to deletecolumn, internally, it figures the
* most recent cell's timestamp and adds a delete at that timestamp; i.e.
* it deletes the most recently added cell.
* <p>the timestamp passed to the constructor is used only for delete of
* rows.  for anything less -- a deletecolumn, deletecolumns or
* deletefamily -- then you need to use the method overrides that take a
* timestamp.  the constructor timestamp is not referenced.
*/
public class delete extends mutation
implements writable  comparable<row>
private static final byte delete_version    byte 3
/** constructor for writable.  do not use */
public delete
this  byte  null
/**
* create a delete operation for the specified row.
* <p>
* if no further operations are done, this will delete everything
* associated with the specified row (all versions of all columns in all
* families).
* @param row row key
*/
public delete byte  row
this row  hconstants latest_timestamp  null
/**
* create a delete operation for the specified row and timestamp, using
* an optional row lock.<p>
*
* if no further operations are done, this will delete all columns in all
* families of the specified row with a timestamp less than or equal to the
* specified timestamp.<p>
*
* this timestamp is only used for a delete row operation.  if specifying
* families or columns, you must specify each timestamp individually.
* @param row row key
* @param timestamp maximum version timestamp (only for delete row)
* @param rowlock previously acquired row lock, or null
*/
public delete byte  row  long timestamp  rowlock rowlock
this row   row
this ts   timestamp
if  rowlock    null
this lockid   rowlock getlockid
/**
* @param d delete to clone.
*/
public delete final delete d
this row   d getrow
this ts   d gettimestamp
this lockid   d getlockid
this familymap putall d getfamilymap
this writetowal   d writetowal
/**
* advanced use only.
* add an existing delete marker to this delete object.
* @param kv an existing keyvalue of type "delete".
* @return this for invocation chaining
* @throws ioexception
*/
public delete adddeletemarker keyvalue kv  throws ioexception
if   kv isdelete
throw new ioexception
bytes tostringbinary this row
if  bytes compareto this row  0  row length  kv getbuffer
kv getrowoffset    kv getrowlength       0
throw new ioexception
bytes tostringbinary kv getbuffer    kv getrowoffset
kv getrowlength
bytes tostringbinary this row
byte  family   kv getfamily
list<keyvalue> list   familymap get family
if  list    null
list   new arraylist<keyvalue>
list add kv
familymap put family  list
return this
/**
* delete all versions of all columns of the specified family.
* <p>
* overrides previous calls to deletecolumn and deletecolumns for the
* specified family.
* @param family family name
* @return this for invocation chaining
*/
public delete deletefamily byte  family
this deletefamily family  hconstants latest_timestamp
return this
/**
* delete all columns of the specified family with a timestamp less than
* or equal to the specified timestamp.
* <p>
* overrides previous calls to deletecolumn and deletecolumns for the
* specified family.
* @param family family name
* @param timestamp maximum version timestamp
* @return this for invocation chaining
*/
public delete deletefamily byte  family  long timestamp
list<keyvalue> list   familymap get family
if list    null
list   new arraylist<keyvalue>
else if  list isempty
list clear
list add new keyvalue row  family  null  timestamp  keyvalue type deletefamily
familymap put family  list
return this
/**
* delete all versions of the specified column.
* @param family family name
* @param qualifier column qualifier
* @return this for invocation chaining
*/
public delete deletecolumns byte  family  byte  qualifier
this deletecolumns family  qualifier  hconstants latest_timestamp
return this
/**
* delete all versions of the specified column with a timestamp less than
* or equal to the specified timestamp.
* @param family family name
* @param qualifier column qualifier
* @param timestamp maximum version timestamp
* @return this for invocation chaining
*/
public delete deletecolumns byte  family  byte  qualifier  long timestamp
list<keyvalue> list   familymap get family
if  list    null
list   new arraylist<keyvalue>
list add new keyvalue this row  family  qualifier  timestamp
keyvalue type deletecolumn
familymap put family  list
return this
/**
* delete the latest version of the specified column.
* this is an expensive call in that on the server-side, it first does a
* get to find the latest versions timestamp.  then it adds a delete using
* the fetched cells timestamp.
* @param family family name
* @param qualifier column qualifier
* @return this for invocation chaining
*/
public delete deletecolumn byte  family  byte  qualifier
this deletecolumn family  qualifier  hconstants latest_timestamp
return this
/**
* delete the specified version of the specified column.
* @param family family name
* @param qualifier column qualifier
* @param timestamp version timestamp
* @return this for invocation chaining
*/
public delete deletecolumn byte  family  byte  qualifier  long timestamp
list<keyvalue> list   familymap get family
if list    null
list   new arraylist<keyvalue>
list add new keyvalue
this row  family  qualifier  timestamp  keyvalue type delete
familymap put family  list
return this
/**
* set the timestamp of the delete.
*
* @param timestamp
*/
public void settimestamp long timestamp
this ts   timestamp
@override
public map<string  object> tomap int maxcols
// we start with the fingerprint map and build on top of it.
map<string  object> map   super tomap maxcols
// why is put not doing this?
map put    this ts
return map
//writable
public void readfields final datainput in  throws ioexception
int version   in readbyte
if  version > delete_version
throw new ioexception
this row   bytes readbytearray in
this ts   in readlong
this lockid   in readlong
if  version > 2
this writetowal   in readboolean
this familymap clear
int numfamilies   in readint
for int i 0 i<numfamilies i
byte  family   bytes readbytearray in
int numcolumns   in readint
list<keyvalue> list   new arraylist<keyvalue> numcolumns
for int j 0 j<numcolumns j
keyvalue kv   new keyvalue
kv readfields in
list add kv
this familymap put family  list
if  version > 1
readattributes in
public void write final dataoutput out  throws ioexception
out writebyte delete_version
bytes writebytearray out  this row
out writelong this ts
out writelong this lockid
out writeboolean this writetowal
out writeint familymap size
for map entry<byte   list<keyvalue>> entry   familymap entryset
bytes writebytearray out  entry getkey
list<keyvalue> list   entry getvalue
out writeint list size
for keyvalue kv   list
kv write out
writeattributes out