/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase ipc
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop hbase donotretryioexception
import org apache hadoop hbase hconstants
import org apache hadoop hbase client retriesexhaustedexception
import org apache hadoop hbase security user
import org apache hadoop io writable
import org apache hadoop net netutils
import org apache hadoop util reflectionutils
import javax net socketfactory
import java io ioexception
import java lang reflect method
import java lang reflect proxy
import java net connectexception
import java net inetsocketaddress
import java net sockettimeoutexception
import java util hashmap
import java util map
/** a simple rpc mechanism.
*
* this is a local hbase copy of the hadoop rpc so we can do things like
* address hadoop-414 for hbase-only and try other hbase-specific
* optimizations like using our own version of objectwritable.  class has been
* renamed to avoid confusing it w/ hadoop versions.
* <p>
*
*
* a <i>protocol</i> is a java interface.  all parameters and return types must
* be one of:
*
* <ul> <li>a primitive type, <code>boolean</code>, <code>byte</code>,
* <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>,
* <code>float</code>, <code>double</code>, or <code>void</code>; or</li>
*
* <li>a {@link string}; or</li>
*
* <li>a {@link writable}; or</li>
*
* <li>an array of the above types</li> </ul>
*
* all methods in the protocol should throw only ioexception.  no field data of
* the protocol instance is transmitted.
*/
public class hbaserpc
// leave this out in the hadoop ipc package but keep class name.  do this
// so that we dont' get the logging of this class's invocations by doing our
// blanket enabling debug on the o.a.h.h. package.
protected static final log log
logfactory getlog
private hbaserpc
super
no public ctor
/**
* configuration key for the {@link rpcengine} implementation to load to
* handle connection protocols.  handlers for individual protocols can be
* configured using {@code "hbase.rpc.engine." + protocol.class.name}.
*/
public static final string rpc_engine_prop
// cache of rpcengines by protocol
private static final map<class rpcengine> protocol_engines
new hashmap<class rpcengine>
// track what rpcengine is used by a proxy class, for stopproxy()
private static final map<class rpcengine> proxy_engines
new hashmap<class rpcengine>
// thread-specific rpc timeout, which may override that of rpcengine
private static threadlocal<integer> rpctimeout   new threadlocal<integer>
@override
protected integer initialvalue
return hconstants default_hbase_client_operation_timeout
// set a protocol to use a non-default rpcengine
static void setprotocolengine configuration conf
class protocol  class engine
conf setclass rpc_engine_prop   protocol getname    engine  rpcengine class
// return the rpcengine configured to handle a protocol
private static synchronized rpcengine getprotocolengine class protocol
configuration conf
rpcengine engine   protocol_engines get protocol
if  engine    null
// check for a configured default engine
class<?> defaultengine
conf getclass rpc_engine_prop  writablerpcengine class
// check for a per interface override
class<?> impl   conf getclass rpc_engine_prop   protocol getname
defaultengine
log debug   impl getname     protocol getname
engine    rpcengine  reflectionutils newinstance impl  conf
if  protocol isinterface
proxy_engines put proxy getproxyclass protocol getclassloader
protocol
engine
protocol_engines put protocol  engine
return engine
// return the rpcengine that handles a proxy object
private static synchronized rpcengine getproxyengine object proxy
return proxy_engines get proxy getclass
/**
* a version mismatch for the rpc protocol.
*/
@suppresswarnings
public static class versionmismatch extends ioexception
private static final long serialversionuid   0
private string interfacename
private long clientversion
private long serverversion
/**
* create a version mismatch exception
* @param interfacename the name of the protocol mismatch
* @param clientversion the client's version of the protocol
* @param serverversion the server's version of the protocol
*/
public versionmismatch string interfacename  long clientversion
long serverversion
super     interfacename
clientversion       serverversion
this interfacename   interfacename
this clientversion   clientversion
this serverversion   serverversion
/**
* get the interface name
* @return the java class name
*          (eg. org.apache.hadoop.mapred.intertrackerprotocol)
*/
public string getinterfacename
return interfacename
/**
* @return the client's preferred version
*/
public long getclientversion
return clientversion
/**
* @return the server's agreed to version.
*/
public long getserverversion
return serverversion
/**
* an error requesting an rpc protocol that the server is not serving.
*/
public static class unknownprotocolexception extends donotretryioexception
private class<?> protocol
public unknownprotocolexception string mesg
// required for unwrapping from a remoteexception
super mesg
public unknownprotocolexception class<?> protocol
this protocol    protocol getname
public unknownprotocolexception class<?> protocol  string mesg
super mesg
this protocol   protocol
public class getprotocol
return protocol
/**
* @param protocol protocol interface
* @param clientversion which client version we expect
* @param addr address of remote service
* @param conf configuration
* @param maxattempts max attempts
* @param rpctimeout timeout for each rpc
* @param timeout timeout in milliseconds
* @return proxy
* @throws ioexception e
*/
@suppresswarnings
public static versionedprotocol waitforproxy class protocol
long clientversion
inetsocketaddress addr
configuration conf
int maxattempts
int rpctimeout
long timeout
throws ioexception
// hbase does limited number of reconnects which is different from hadoop.
long starttime   system currenttimemillis
ioexception ioe
int reconnectattempts   0
while  true
try
return getproxy protocol  clientversion  addr  conf  rpctimeout
catch connectexception se        namenode has not been started
ioe   se
if  maxattempts >  0      reconnectattempts >  maxattempts
log info     addr
reconnectattempts
throw new retriesexhaustedexception
protocol       addr tostring
reconnectattempts  se
catch sockettimeoutexception te        namenode is busy
log info     addr
ioe   te
// check if timed out
if  system currenttimemillis   timeout >  starttime
throw ioe
// wait for retry
try
thread sleep 1000
catch  interruptedexception ie
// ignore
/**
* construct a client-side proxy object that implements the named protocol,
* talking to a server at the named address.
*
* @param protocol interface
* @param clientversion version we are expecting
* @param addr remote address
* @param conf configuration
* @param factory socket factory
* @param rpctimeout timeout for each rpc
* @return proxy
* @throws ioexception e
*/
public static versionedprotocol getproxy class<? extends versionedprotocol> protocol
long clientversion  inetsocketaddress addr  configuration conf
socketfactory factory  int rpctimeout  throws ioexception
return getproxy protocol  clientversion  addr
user getcurrent    conf  factory  rpctimeout
/**
* construct a client-side proxy object that implements the named protocol,
* talking to a server at the named address.
*
* @param protocol interface
* @param clientversion version we are expecting
* @param addr remote address
* @param ticket ticket
* @param conf configuration
* @param factory socket factory
* @param rpctimeout timeout for each rpc
* @return proxy
* @throws ioexception e
*/
public static versionedprotocol getproxy
class<? extends versionedprotocol> protocol
long clientversion  inetsocketaddress addr  user ticket
configuration conf  socketfactory factory  int rpctimeout
throws ioexception
versionedprotocol proxy
getprotocolengine protocol conf
getproxy protocol  clientversion  addr  ticket  conf  factory  math min rpctimeout  hbaserpc getrpctimeout
long serverversion   proxy getprotocolversion protocol getname
clientversion
if  serverversion    clientversion
return proxy
throw new versionmismatch protocol getname    clientversion
serverversion
/**
* construct a client-side proxy object with the default socketfactory
*
* @param protocol interface
* @param clientversion version we are expecting
* @param addr remote address
* @param conf configuration
* @param rpctimeout timeout for each rpc
* @return a proxy instance
* @throws ioexception e
*/
public static versionedprotocol getproxy
class<? extends versionedprotocol> protocol
long clientversion  inetsocketaddress addr  configuration conf
int rpctimeout
throws ioexception
return getproxy protocol  clientversion  addr  conf  netutils
getdefaultsocketfactory conf   rpctimeout
/**
* stop this proxy and release its invoker's resource
* @param proxy the proxy to be stopped
*/
public static void stopproxy versionedprotocol proxy
if  proxy  null
getproxyengine proxy  stopproxy proxy
/**
* expert: make multiple, parallel calls to a set of servers.
*
* @param method method to invoke
* @param params array of parameters
* @param addrs array of addresses
* @param conf configuration
* @return values
* @throws ioexception e
* @deprecated instead of calling statically, use
*     {@link hbaserpc#getprotocolengine(class, org.apache.hadoop.conf.configuration)}
*     to obtain an {@link rpcengine} instance and then use
*     {@link rpcengine#call(java.lang.reflect.method, object[][], java.net.inetsocketaddress[], class, org.apache.hadoop.hbase.security.user, org.apache.hadoop.conf.configuration)}
*/
@deprecated
public static object call method method  object params
inetsocketaddress addrs
class<? extends versionedprotocol> protocol
user ticket
configuration conf
throws ioexception  interruptedexception
return getprotocolengine protocol  conf
call method  params  addrs  protocol  ticket  conf
/**
* construct a server for a protocol implementation instance listening on a
* port and address.
*
* @param instance instance
* @param bindaddress bind address
* @param port port to bind to
* @param numhandlers number of handlers to start
* @param verbose verbose flag
* @param conf configuration
* @return server
* @throws ioexception e
*/
public static rpcserver getserver final object instance
final class<?> ifaces
final string bindaddress  final int port
final int numhandlers
int metahandlercount  final boolean verbose  configuration conf  int highprioritylevel
throws ioexception
return getserver instance getclass    instance  ifaces  bindaddress  port  numhandlers  metahandlercount  verbose  conf  highprioritylevel
/** construct a server for a protocol implementation instance. */
public static rpcserver getserver class protocol
final object instance
final class<?> ifaces  string bindaddress
int port
final int numhandlers
int metahandlercount  final boolean verbose  configuration conf  int highprioritylevel
throws ioexception
return getprotocolengine protocol  conf
getserver protocol  instance  ifaces  bindaddress  port  numhandlers  metahandlercount  verbose  conf  highprioritylevel
public static void setrpctimeout int rpctimeout
hbaserpc rpctimeout set rpctimeout
public static int getrpctimeout
return hbaserpc rpctimeout get
public static void resetrpctimeout
hbaserpc rpctimeout remove