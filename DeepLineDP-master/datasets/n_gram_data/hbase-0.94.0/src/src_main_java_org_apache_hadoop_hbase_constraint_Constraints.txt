/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase constraint
import java io bytearrayinputstream
import java io bytearrayoutputstream
import java io dataoutputstream
import java io ioexception
import java util arraylist
import java util collections
import java util comparator
import java util list
import java util map
import java util map entry
import java util regex pattern
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase io immutablebyteswritable
import org apache hadoop hbase util bytes
import org apache hadoop hbase util pair
/**
* utilities for adding/removing constraints from a table.
* <p>
* constraints can be added on table load time, via the {@link htabledescriptor}.
* <p>
* note: this class is not thread safe. concurrent setting/enabling/disabling of
* constraints can cause constraints to be run at incorrect times or not at all.
*/
public final class constraints
private static final int default_priority    1
private constraints
private static final log log   logfactory getlog constraints class
private static final string constraint_htd_key_prefix
private static final pattern constraint_htd_attr_key_pattern   pattern
compile constraint_htd_key_prefix  pattern literal
// configuration key for if the constraint is enabled
private static final string enabled_key
// configuration key for the priority
private static final string priority_key
// smallest priority a constraint can have
private static final long min_priority   0l
// ensure a priority less than the smallest we could intentionally set
private static final long unset_priority   min_priority   1
private static string counter_key
/**
* enable constraints on a table.
* <p>
* currently, if you attempt to add a constraint to the table, then
* constraints will automatically be turned on.
*
* @param desc
*          table description to add the processor
* @throws ioexception
*           if the {@link constraintprocessor} cp couldn't be added to the
*           table.
*/
public static void enable htabledescriptor desc  throws ioexception
// if the cp has already been loaded, do nothing
string clazz   constraintprocessor class getname
if  desc hascoprocessor clazz
return
// add the constrain processor cp to the table
desc addcoprocessor clazz
/**
* turn off processing constraints for a given table, even if constraints have
* been turned on or added.
*
* @param desc
*          {@link htabledescriptor} where to disable {@link constraint
*          constraints}.
*/
public static void disable htabledescriptor desc
desc removecoprocessor constraintprocessor class getname
/**
* remove all {@link constraint constraints} that have been added to the table
* and turn off the constraint processing.
* <p>
* all {@link configuration configurations} and their associated
* {@link constraint} are removed.
*
* @param desc
*          {@link htabledescriptor} to remove {@link constraint constraints}
*          from.
*/
public static void remove htabledescriptor desc
// disable constraints
disable desc
// remove all the constraint settings
list<immutablebyteswritable> keys   new arraylist<immutablebyteswritable>
// loop through all the key, values looking for constraints
for  map entry<immutablebyteswritable  immutablebyteswritable> e   desc
getvalues   entryset
string key   bytes tostring  e getkey   get
string classname   constraint_htd_attr_key_pattern split key
if  classname length    2
keys add e getkey
// now remove all the keys we found
for  immutablebyteswritable key   keys
desc remove key get
/**
* check to see if the constraint is currently set.
*
* @param desc
*          {@link htabledescriptor} to check
* @param clazz
*          {@link constraint} class to check for.
* @return <tt>true</tt> if the {@link constraint} is present, even if it is
*         disabled. <tt>false</tt> otherwise.
*/
public static boolean has htabledescriptor desc
class<? extends constraint> clazz
return getkeyvalueforclass desc  clazz     null
/**
* get the kv {@link entry} in the descriptor for the specified class
*
* @param desc
*          {@link htabledescriptor} to read
* @param clazz
*          to search for
* @return the {@link pair} of <key, value> in the table, if that class is
*         present. <tt>null</tt> otherwise.
*/
private static pair<string  string> getkeyvalueforclass
htabledescriptor desc  class<? extends constraint> clazz
// get the serialized version of the constraint
string key   serializeconstraintclass clazz
string value   desc getvalue key
return value    null ? null   new pair<string  string> key  value
/**
* add configuration-less constraints to the table.
* <p>
* this will overwrite any configuration associated with the previous
* constraint of the same class.
* <p>
* each constraint, when added to the table, will have a specific priority,
* dictating the order in which the {@link constraint} will be run. a
* {@link constraint} earlier in the list will be run before those later in
* the list. the same logic applies between two constraints over time (earlier
* added is run first on the regionserver).
*
* @param desc
*          {@link htabledescriptor} to add {@link constraint constraints}
* @param constraints
*          {@link constraint constraints} to add. all constraints are
*          considered automatically enabled on add
* @throws ioexception
*           if constraint could not be serialized/added to table
*/
public static void add htabledescriptor desc
class<? extends constraint>    constraints  throws ioexception
// make sure constraints are enabled
enable desc
long priority   getnextpriority desc
// store each constraint
for  class<? extends constraint> clazz   constraints
addconstraint desc  clazz  null  priority
updatelatestpriority desc  priority
/**
* add constraints and their associated configurations to the table.
* <p>
* adding the same constraint class twice will overwrite the first
* constraint's configuration
* <p>
* each constraint, when added to the table, will have a specific priority,
* dictating the order in which the {@link constraint} will be run. a
* {@link constraint} earlier in the list will be run before those later in
* the list. the same logic applies between two constraints over time (earlier
* added is run first on the regionserver).
*
* @param desc
*          {@link htabledescriptor} to add a {@link constraint}
* @param constraints
*          {@link pair} of a {@link constraint} and its associated
*          {@link configuration}. the constraint will be configured on load
*          with the specified configuration.all constraints are considered
*          automatically enabled on add
* @throws ioexception
*           if any constraint could not be deserialized. assumes if 1
*           constraint is not loaded properly, something has gone terribly
*           wrong and that all constraints need to be enforced.
*/
public static void add htabledescriptor desc
pair<class<? extends constraint>  configuration>    constraints
throws ioexception
enable desc
long priority   getnextpriority desc
for  pair<class<? extends constraint>  configuration> pair   constraints
addconstraint desc  pair getfirst    pair getsecond    priority
updatelatestpriority desc  priority
/**
* add a {@link constraint} to the table with the given configuration
* <p>
* each constraint, when added to the table, will have a specific priority,
* dictating the order in which the {@link constraint} will be run. a
* {@link constraint} added will run on the regionserver before those added to
* the {@link htabledescriptor} later.
*
* @param desc
*          table descriptor to the constraint to
* @param constraint
*          to be added
* @param conf
*          configuration associated with the constraint
* @throws ioexception
*           if any constraint could not be deserialized. assumes if 1
*           constraint is not loaded properly, something has gone terribly
*           wrong and that all constraints need to be enforced.
*/
public static void add htabledescriptor desc
class<? extends constraint> constraint  configuration conf
throws ioexception
enable desc
long priority   getnextpriority desc
addconstraint desc  constraint  conf  priority
updatelatestpriority desc  priority
/**
* write the raw constraint and configuration to the descriptor.
* <p>
* this method takes care of creating a new configuration based on the passed
* in configuration and then updating that with enabled and priority of the
* constraint.
* <p>
* when a constraint is added, it is automatically enabled.
*/
private static void addconstraint htabledescriptor desc
class<? extends constraint> clazz  configuration conf  long priority
throws ioexception
writeconstraint desc  serializeconstraintclass clazz
configure conf  true  priority
/**
* setup the configuration for a constraint as to whether it is enabled and
* its priority
*
* @param conf
*          on which to base the new configuration
* @param enabled
*          <tt>true</tt> if it should be run
* @param priority
*          relative to other constraints
* @returns a new configuration, storable in the {@link htabledescriptor}
*/
private static configuration configure configuration conf  boolean enabled
long priority
// create the configuration to actually be stored
// clone if possible, but otherwise just create an empty configuration
configuration towrite   conf    null ? new configuration
new configuration conf
// update internal properties
towrite setbooleanifunset enabled_key  enabled
// set if unset long
if  towrite getlong priority_key  unset_priority     unset_priority
towrite setlong priority_key  priority
return towrite
/**
* just write the class to a string representation of the class as a key for
* the {@link htabledescriptor}
*
* @param clazz
*          constraint class to convert to a {@link htabledescriptor} key
* @return key to store in the {@link htabledescriptor}
*/
private static string serializeconstraintclass
class<? extends constraint> clazz
string constraintclazz   clazz getname
return constraint_htd_key_prefix   constraintclazz
/**
* write the given key and associated configuration to the
* {@link htabledescriptor}
*/
private static void writeconstraint htabledescriptor desc  string key
configuration conf  throws ioexception
// store the key and conf in the descriptor
desc setvalue key  serializeconfiguration conf
/**
* write the configuration to a string
*
* @param conf
*          to write
* @return string representation of that configuration
* @throws ioexception
*/
private static string serializeconfiguration configuration conf
throws ioexception
// write the configuration out to the data stream
bytearrayoutputstream bos   new bytearrayoutputstream
dataoutputstream dos   new dataoutputstream bos
conf writexml dos
dos flush
byte data   bos tobytearray
return bytes tostring data
/**
* read the {@link configuration} stored in the byte stream.
*
* @param bytes
*          to read from
* @return a valid configuration
*/
private static configuration readconfiguration byte bytes
throws ioexception
bytearrayinputstream is   new bytearrayinputstream bytes
configuration conf   new configuration false
conf addresource is
return conf
/**
* read in the configuration from the string encoded configuration
*
* @param bytes
*          to read from
* @return a valid configuration
* @throws ioexception
*           if the configuration could not be read
*/
private static configuration readconfiguration string bytes
throws ioexception
return readconfiguration bytes tobytes bytes
private static long getnextpriority htabledescriptor desc
string value   desc getvalue counter_key
long priority
// get the current priority
if  value    null
priority   min_priority
else
priority   long parselong value    1
return priority
private static void updatelatestpriority htabledescriptor desc  long priority
// update the max priority
desc setvalue counter_key  long tostring priority
/**
* update the configuration for the {@link constraint}; does not change the
* order in which the constraint is run.
*
* @param desc
*          {@link htabledescriptor} to update
* @param clazz
*          {@link constraint} to update
* @param configuration
*          to update the {@link constraint} with.
* @throws ioexception
*           if the constraint was not stored correctly
* @throws illegalargumentexception
*           if the constraint was not present on this table.
*/
public static void setconfiguration htabledescriptor desc
class<? extends constraint> clazz  configuration configuration
throws ioexception  illegalargumentexception
// get the entry for this class
pair<string  string> e   getkeyvalueforclass desc  clazz
if  e    null
throw new illegalargumentexception     clazz getname
// clone over the configuration elements
configuration conf   new configuration configuration
// read in the previous info about the constraint
configuration internal   readconfiguration e getsecond
// update the fields based on the previous settings
conf setifunset enabled_key  internal get enabled_key
conf setifunset priority_key  internal get priority_key
// update the current value
writeconstraint desc  e getfirst    conf
/**
* remove the constraint (and associated information) for the table
* descriptor.
*
* @param desc
*          {@link htabledescriptor} to modify
* @param clazz
*          {@link constraint} class to remove
*/
public static void remove htabledescriptor desc
class<? extends constraint> clazz
string key   serializeconstraintclass clazz
desc remove key
/**
* enable the given {@link constraint}. retains all the information (e.g.
* configuration) for the {@link constraint}, but makes sure that it gets
* loaded on the table.
*
* @param desc
*          {@link htabledescriptor} to modify
* @param clazz
*          {@link constraint} to enable
* @throws ioexception
*           if the constraint cannot be properly deserialized
*/
public static void enableconstraint htabledescriptor desc
class<? extends constraint> clazz  throws ioexception
changeconstraintenabled desc  clazz  true
/**
* disable the given {@link constraint}. retains all the information (e.g.
* configuration) for the {@link constraint}, but it just doesn't load the
* {@link constraint} on the table.
*
* @param desc
*          {@link htabledescriptor} to modify
* @param clazz
*          {@link constraint} to disable.
* @throws ioexception
*           if the constraint cannot be found
*/
public static void disableconstraint htabledescriptor desc
class<? extends constraint> clazz  throws ioexception
changeconstraintenabled desc  clazz  false
/**
* change the whether the constraint (if it is already present) is enabled or
* disabled.
*/
private static void changeconstraintenabled htabledescriptor desc
class<? extends constraint> clazz  boolean enabled  throws ioexception
// get the original constraint
pair<string  string> entry   getkeyvalueforclass desc  clazz
if  entry    null
throw new illegalargumentexception     clazz getname
// create a new configuration from that conf
configuration conf   readconfiguration entry getsecond
// set that it is enabled
conf setboolean enabled_key  enabled
// write it back out
writeconstraint desc  entry getfirst    conf
/**
* check to see if the given constraint is enabled.
*
* @param desc
*          {@link htabledescriptor} to check.
* @param clazz
*          {@link constraint} to check for
* @return <tt>true</tt> if the {@link constraint} is present and enabled.
*         <tt>false</tt> otherwise.
* @throws ioexception
*           if the constraint has improperly stored in the table
*/
public static boolean enabled htabledescriptor desc
class<? extends constraint> clazz  throws ioexception
// get the kv
pair<string  string> entry   getkeyvalueforclass desc  clazz
// its not enabled so just return false. in fact, its not even present!
if  entry    null
return false
// get the info about the constraint
configuration conf   readconfiguration entry getsecond
return conf getboolean enabled_key  false
/**
* get the constraints stored in the table descriptor
*
* @param desc
*          to read from
* @param classloader
*          to use when loading classes. if a special classloader is used on a
*          region, for instance, then that should be the classloader used to
*          load the constraints. this could also apply to unit-testing
*          situation, where want to ensure that class is reloaded or not.
* @return list of configured {@link constraint constraints}
* @throws ioexception
*           if any part of reading/arguments fails
*/
static list<? extends constraint> getconstraints htabledescriptor desc
classloader classloader  throws ioexception
list<constraint> constraints   new arraylist<constraint>
// loop through all the key, values looking for constraints
for  map entry<immutablebyteswritable  immutablebyteswritable> e   desc
getvalues   entryset
// read out the constraint
string key   bytes tostring e getkey   get    trim
string classname   constraint_htd_attr_key_pattern split key
if  classname length    2
key   classname
if  log isdebugenabled
log debug     key
// read in the rest of the constraint
configuration conf
try
conf   readconfiguration e getvalue   get
catch  ioexception e1
// long that we don't have a valid configuration stored, and move on.
log warn     key
continue
// if it is not enabled, skip it
if   conf getboolean enabled_key  false
if  log isdebugenabled
log debug     key
// go to the next constraint
continue
try
// add the constraint, now that we expect it to be valid.
class<? extends constraint> clazz   classloader loadclass key
assubclass constraint class
constraint constraint   clazz newinstance
constraint setconf conf
constraints add constraint
catch  classnotfoundexception e1
throw new ioexception e1
catch  instantiationexception e1
throw new ioexception e1
catch  illegalaccessexception e1
throw new ioexception e1
// sort them, based on the priorities
collections sort constraints  constraintcomparator
return constraints
private static final comparator<constraint> constraintcomparator   new comparator<constraint>
@override
public int compare constraint c1  constraint c2
// compare the priorities of the constraints stored in their configuration
return long valueof c1 getconf   getlong priority_key  default_priority
compareto c2 getconf   getlong priority_key  default_priority