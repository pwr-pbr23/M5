/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import org apache commons logging log
import org apache commons logging logfactory
import java io bufferedinputstream
import java io bufferedoutputstream
import java io bytearrayinputstream
import java io bytearrayoutputstream
import java io file
import java io fileinputstream
import java io fileoutputstream
import java io filterinputstream
import java io filteroutputstream
import java io ioexception
import java io inputstream
import java io objectinputstream
import java io objectoutputstream
import java io outputstream
import java io serializable
import java io unsupportedencodingexception
import java util zip gzipinputstream
import java util zip gzipoutputstream
/**
* encodes and decodes to and from base64 notation.
*
* <p>
* homepage: <a href="http://iharder.net/base64">http://iharder.net/base64</a>.
* </p>
*
* <p>
* change log:
* </p>
* <ul>
*   <li>v2.2.1 - fixed bug using url_safe and ordered encodings. fixed bug
*     when using very small files (~< 40 bytes).</li>
*   <li>v2.2 - added some helper methods for encoding/decoding directly from
*     one file to the next. also added a main() method to support command
*     line encoding/decoding from one file to the next. also added these
*     base64 dialects:
*     <ol>
*       <li>the default is rfc3548 format.</li>
*       <li>using base64.urlsafe generates url and file name friendly format as
*         described in section 4 of rfc3548.
*         http://www.faqs.org/rfcs/rfc3548.html</li>
*       <li>using base64.ordered generates url and file name friendly format
*         that preserves lexical ordering as described in
*         http://www.faqs.org/qa/rfcc-1940.html</li>
*     </ol>
*     <p>
*     special thanks to jim kellerman at <a href="http://www.powerset.com/">
*     http://www.powerset.com/</a> for contributing the new base64 dialects.
*   </li>
*
*   <li>v2.1 - cleaned up javadoc comments and unused variables and methods.
*     added some convenience methods for reading and writing to and from files.
*   </li>
*   <li>v2.0.2 - now specifies utf-8 encoding in places where the code fails on
*     systems with other encodings (like ebcdic).</li>
*   <li>v2.0.1 - fixed an error when decoding a single byte, that is, when the
*     encoded data was a single byte.</li>
*   <li>v2.0 - i got rid of methods that used booleans to set options. now
*     everything is more consolidated and cleaner. the code now detects when
*     data that's being decoded is gzip-compressed and will decompress it
*     automatically. generally things are cleaner. you'll probably have to
*     change some method calls that you were making to support the new options
*     format (<tt>int</tt>s that you "or" together).</li>
*   <li>v1.5.1 - fixed bug when decompressing and decoding to a byte[] using
*     <tt>decode( string s, boolean gzipcompressed )</tt>. added the ability to
*     "suspend" encoding in the output stream so you can turn on and off the
*     encoding if you need to embed base64 data in an otherwise "normal" stream
*     (like an xml file).</li>
*   <li>v1.5 - output stream pases on flush() command but doesn't do anything
*     itself. this helps when using gzip streams. added the ability to
*     gzip-compress objects before encoding them.</li>
*   <li>v1.4 - added helper methods to read/write files.</li>
*   <li>v1.3.6 - fixed outputstream.flush() so that 'position' is reset.</li>
*   <li>v1.3.5 - added flag to turn on and off line breaks. fixed bug in input
*     stream where last buffer being read, if not completely full, was not
*     returned.</li>
*   <li>v1.3.4 - fixed when "improperly padded stream" error was thrown at the
*     wrong time.</li>
*   <li>v1.3.3 - fixed i/o streams which were totally messed up.</li>
* </ul>
*
* <p>
* i am placing this code in the public domain. do with it as you will. this
* software comes with no guarantees or warranties but with plenty of
* well-wishing instead!
* <p>
* please visit <a href="http://iharder.net/base64">http://iharder.net/base64</a>
* periodically to check for updates or to contribute improvements.
* <p>
* author: robert harder, rob@iharder.net
* <br>
* version: 2.2.1
*/
public class base64
/* ******** p u b l i c   f i e l d s ******** */
/** no options specified. value is zero. */
public final static int no_options   0
/** specify encoding. */
public final static int encode   1
/** specify decoding. */
public final static int decode   0
/** specify that data should be gzip-compressed. */
public final static int gzip   2
/** don't break lines when encoding (violates strict base64 specification) */
public final static int dont_break_lines   8
/**
* encode using base64-like encoding that is url and filename safe as
* described in section 4 of rfc3548:
* <a href="http://www.faqs.org/rfcs/rfc3548.html">
* http://www.faqs.org/rfcs/rfc3548.html</a>.
* it is important to note that data encoded this way is <em>not</em>
* officially valid base64, or at the very least should not be called base64
* without also specifying that is was encoded using the url and
* filename safe dialect.
*/
public final static int url_safe   16
/**
* encode using the special "ordered" dialect of base64 described here:
* <a href="http://www.faqs.org/qa/rfcc-1940.html">
* http://www.faqs.org/qa/rfcc-1940.html</a>.
*/
public final static int ordered   32
/* ******** p r i v a t e   f i e l d s ******** */
private static final log log   logfactory getlog base64 class
/** maximum line length (76) of base64 output. */
private final static int max_line_length   76
/** the equals sign (=) as a byte. */
private final static byte equals_sign    byte
/** the new line character (\n) as a byte. */
private final static byte new_line    byte
/** preferred encoding. */
private final static string preferred_encoding
private final static byte white_space_enc    5     indicates white space
private final static byte equals_sign_enc    1     indicates equals sign
/* ******** s t a n d a r d   b a s e 6 4   a l p h a b e t ******** */
/** the 64 valid base64 values. */
/*
* host platform may be something funny like ebcdic, so we hardcode these
* values.
*/
private final static byte _standard_alphabet      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte
/**
* translates a base64 value to either its 6-bit reconstruction value or a
* negative number indicating some other meaning.
*/
private final static byte _standard_decodabet
9   9   9   9   9   9   9   9   9                 decimal 0   8
5   5                                             whitespace  tab  newline
9   9                                             decimal 11   12
5                                                 whitespace  return
9   9   9   9   9   9   9   9   9   9   9   9   9     decimal 14   26
9   9   9   9   9                                 decimal 27   31
5                                                 whitespace  space
9   9   9   9   9   9   9   9   9   9             decimal 33   42
62                                                 plus sign at decimal 43
9   9   9                                         decimal 44   46
63                                                 slash at decimal 47
52  53  54  55  56  57  58  59  60  61             numbers zero   nine
9   9   9                                         decimal 58   60
1                                                 equals sign at decimal 61
9   9   9                                         decimal 62   64
0  1  2  3  4  5  6  7  8  9  10  11  12  13       letters
14  15  16  17  18  19  20  21  22  23  24  25     letters
9   9   9   9   9   9                             decimal 91   96
26  27  28  29  30  31  32  33  34  35  36  37  38     letters
39  40  41  42  43  44  45  46  47  48  49  50  51     letters
9   9   9   9                                     decimal 123   126
/* ******** u r l   s a f e   b a s e 6 4   a l p h a b e t ******** */
/**
* used in the url and filename safe dialect described in section 4 of rfc3548
* <a href="http://www.faqs.org/rfcs/rfc3548.html">
* http://www.faqs.org/rfcs/rfc3548.html</a>.
* notice that the last two bytes become "hyphen" and "underscore" instead of
* "plus" and "slash."
*/
private final static byte _url_safe_alphabet      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte
/**
* used in decoding url and filename safe dialects of base64.
*/
private final static byte _url_safe_decodabet
9   9   9   9   9   9   9   9   9                     decimal 0   8
5   5                                                 whitespace  tab  newline
9   9                                                 decimal 11   12
5                                                     whitespace  return
9   9   9   9   9   9   9   9   9   9   9   9   9     decimal 14   26
9   9   9   9   9                                     decimal 27   31
5                                                     whitespace  space
9   9   9   9   9   9   9   9   9   9                 decimal 33   42
9                                                     plus sign at 43
9                                                     decimal 44
62                                                     minus sign at 45
9                                                     decimal 46
9                                                     slash at 47
52  53  54  55  56  57  58  59  60  61                 numbers 0   9
9   9   9                                             decimal 58   60
1                                                     equals sign at 61
9   9   9                                             decimal 62   64
0  1  2  3  4  5  6  7  8  9  10  11  12  13           letters
14  15  16  17  18  19  20  21  22  23  24  25         letters
9   9   9   9                                         decimal 91   94
63                                                     underscore at 95
9                                                     decimal 96
26  27  28  29  30  31  32  33  34  35  36  37  38     letters
39  40  41  42  43  44  45  46  47  48  49  50  51     letters
9   9   9   9                                         decimal 123   126
/* ******** o r d e r e d   b a s e 6 4   a l p h a b e t ******** */
/**
* in addition to being url and file name friendly, this encoding preserves
* the sort order of encoded values. whatever is input, be it string or
* just an array of bytes, when you use this encoding, the encoded value sorts
* exactly the same as the input value. it is described in the rfc change
* request: <a href="http://www.faqs.org/qa/rfcc-1940.html">
* http://www.faqs.org/qa/rfcc-1940.html</a>.
*
* it replaces "plus" and "slash" with "hyphen" and "underscore" and
* rearranges the alphabet so that the characters are in their natural sort
* order.
*/
private final static byte _ordered_alphabet      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte      byte      byte      byte      byte
byte      byte
/**
* used in decoding the "ordered" dialect of base64.
*/
private final static byte _ordered_decodabet
9   9   9   9   9   9   9   9   9                     decimal 0   8
5   5                                                 whitespace  tab  newline
9   9                                                 decimal 11   12
5                                                     whitespace  return
9   9   9   9   9   9   9   9   9   9   9   9   9     decimal 14   26
9   9   9   9   9                                     decimal 27   31
5                                                     whitespace  space
9   9   9   9   9   9   9   9   9   9                 decimal 33   42
9                                                     plus sign at 43
9                                                     decimal 44
0                                                      minus sign at 45
9                                                     decimal 46
9                                                     slash at decimal 47
1  2  3  4  5  6  7  8  9  10                          numbers 0   9
9   9   9                                             decimal 58   60
1                                                     equals sign at 61
9   9   9                                             decimal 62   64
11  12  13  14  15  16  17  18  19  20  21  22  23     letters
24  25  26  27  28  29  30  31  32  33  34  35  36     letters
9   9   9   9                                         decimal 91   94
37                                                     underscore at 95
9                                                     decimal 96
38  39  40  41  42  43  44  45  46  47  48  49  50     letters
51  52  53  54  55  56  57  58  59  60  61  62  63     letters
9   9   9   9                                         decimal 123   126
/* ******** d e t e r m i n e   w h i c h   a l h a b e t ******** */
/**
* returns one of the _something_alphabet byte arrays depending on the options
* specified. it's possible, though silly, to specify ordered and urlsafe in
* which case one of them will be picked, though there is no guarantee as to
* which one will be picked.
*
* @param options url_safe or ordered
* @return alphabet array to use
*/
protected static byte getalphabet int options
if   options   url_safe     url_safe
return _url_safe_alphabet
else if   options   ordered     ordered
return _ordered_alphabet
else
return _standard_alphabet
end getalphabet
/**
* returns one of the _something_decodabet byte arrays depending on the
* options specified. it's possible, though silly, to specify ordered and
* url_safe in which case one of them will be picked, though there is no
* guarantee as to which one will be picked.
* @param options url_safe or ordered
* @return alphabet array to use
*/
protected static byte getdecodabet int options
if   options   url_safe     url_safe
return _url_safe_decodabet
else if   options   ordered     ordered
return _ordered_decodabet
else
return _standard_decodabet
end getdecodabet
/** defeats instantiation. */
private base64
/**
* main program. used for testing.
*
* encodes or decodes two files from the command line
*
* @param args command arguments
*/
public static void main string args
if  args length < 3
usage
else
string flag   args
string infile   args
string outfile   args
if  flag equals                                   encode
encodefiletofile infile  outfile
else if  flag equals                            decode
decodefiletofile infile  outfile
else
usage     flag
end main
/**
* prints command line usage.
*
* @param msg a message to include with usage info.
*/
private static void usage string msg
system err println msg
system err println
end usage
/* ******** e n c o d i n g   m e t h o d s ******** */
/**
* encodes up to the first three bytes of array <var>threebytes</var> and
* returns a four-byte array in base64 notation. the actual number of
* significant bytes in your array is given by <var>numsigbytes</var>. the
* array <var>threebytes</var> needs only be as big as <var>numsigbytes</var>.
* code can reuse a byte array by passing a four-byte array as <var>b4</var>.
*
* @param b4 a reusable byte array to reduce array instantiation
* @param threebytes the array to convert
* @param numsigbytes the number of significant bytes in your array
* @param options options for get alphabet
* @return four byte array in base64 notation.
* @since 1.5.1
*/
protected static byte encode3to4 byte b4  byte threebytes
int numsigbytes  int options
encode3to4 threebytes  0  numsigbytes  b4  0  options
return b4
end encode3to4
/**
* encodes up to three bytes of the array <var>source</var> and writes the
* resulting four base64 bytes to <var>destination</var>. the source and
* destination arrays can be manipulated anywhere along their length by
* specifying <var>srcoffset</var> and <var>destoffset</var>. this method
* does not check to make sure your arrays are large enough to accomodate
* <var>srcoffset</var> + 3 for the <var>source</var> array or
* <var>destoffset</var> + 4 for the <var>destination</var> array. the
* actual number of significant bytes in your array is given by
* <var>numsigbytes</var>.
* <p>
* this is the lowest level of the encoding methods with all possible
* parameters.
*
* @param source the array to convert
* @param srcoffset the index where conversion begins
* @param numsigbytes the number of significant bytes in your array
* @param destination the array to hold the conversion
* @param destoffset the index where output will be put
* @param options options for get alphabet
* @return the <var>destination</var> array
* @since 1.3
*/
protected static byte encode3to4 byte source  int srcoffset
int numsigbytes  byte destination  int destoffset  int options
byte alphabet   getalphabet options
//           1         2         3
// 01234567890123456789012345678901 bit position
// --------000000001111111122222222 array position from threebytes
// --------|    ||    ||    ||    | six bit groups to index alphabet
//          >>18  >>12  >> 6  >> 0  right shift necessary
//                0x3f  0x3f  0x3f  additional and
// create buffer with zero-padding if there are only one or two
// significant bytes passed in the array.
// we have to shift left 24 in order to flush out the 1's that appear
// when java treats a value as negative that is cast from a byte to an int.
int inbuff
numsigbytes > 0 ?   source << 24  >>> 8    0
numsigbytes > 1 ?   source << 24  >>> 16    0
numsigbytes > 2 ?   source << 24  >>> 24    0
switch  numsigbytes
case 3
destination   alphabet
destination   alphabet
destination   alphabet
destination   alphabet
return destination
case 2
destination   alphabet
destination   alphabet
destination   alphabet
destination   equals_sign
return destination
case 1
destination   alphabet
destination   alphabet
destination   equals_sign
destination   equals_sign
return destination
default
return destination
end switch
end encode3to4
/**
* serializes an object and returns the base64-encoded version of that
* serialized object. if the object cannot be serialized or there is another
* error, the method will return <tt>null</tt>. the object is not
* gzip-compressed before being encoded.
*
* @param serializableobject the object to encode
* @return the base64-encoded object
* @since 1.4
*/
public static string encodeobject serializable serializableobject
return encodeobject serializableobject  no_options
end encodeobject
/**
* serializes an object and returns the base64-encoded version of that
* serialized object. if the object cannot be serialized or there is another
* error, the method will return <tt>null</tt>.
* <p>
* valid options:
* <ul>
*   <li>gzip: gzip-compresses object before encoding it.</li>
*   <li>dont_break_lines: don't break lines at 76 characters. <i>note:
*     technically, this makes your encoding non-compliant.</i></li>
* </ul>
* <p>
* example: <code>encodeobject( myobj, base64.gzip )</code> or
* <p>
* example:
* <code>encodeobject( myobj, base64.gzip | base64.dont_break_lines )</code>
*
* @param serializableobject the object to encode
* @param options specified options
* @see base64#gzip
* @see base64#dont_break_lines
* @return the base64-encoded object
* @since 2.0
*/
@suppresswarnings
public static string encodeobject serializable serializableobject
int options
bytearrayoutputstream baos   new bytearrayoutputstream
outputstream b64os   null
objectoutputstream oos   null
try
// objectoutputstream -> (gzip) -> base64 -> bytearrayoutputstream
b64os   new base64outputstream baos  encode   options
oos     options   gzip     gzip  ?
new objectoutputstream new gzipoutputstream b64os
new objectoutputstream b64os
oos writeobject serializableobject
return new string baos tobytearray    preferred_encoding
catch  unsupportedencodingexception uue
return new string baos tobytearray
catch  ioexception e
log error    e
return null
finally
if  oos    null
try
oos close
catch  exception e
log error    e
if  b64os    null
try
b64os close
catch  exception e
log error    e
try
baos close
catch  exception e
log error    e
end finally
end encode
/**
* encodes a byte array into base64 notation. does not gzip-compress data.
*
* @param source the data to convert
* @return encoded byte array
* @since 1.4
*/
public static string encodebytes byte source
return encodebytes source  0  source length  no_options
end encodebytes
/**
* encodes a byte array into base64 notation.
* <p>
* valid options:
* <ul>
*   <li>gzip: gzip-compresses object before encoding it.</li>
*   <li>dont_break_lines: don't break lines at 76 characters. <i>note:
*     technically, this makes your encoding non-compliant.</i></li>
* </ul>
*
* <p>
* example: <code>encodebytes( mydata, base64.gzip )</code> or
* <p>
* example:
* <code>encodebytes( mydata, base64.gzip | base64.dont_break_lines )</code>
*
* @param source the data to convert
* @param options specified options
* @see base64#gzip
* @see base64#dont_break_lines
* @see base64#url_safe
* @see base64#ordered
* @return encoded byte array
* @since 2.0
*/
public static string encodebytes byte source  int options
return encodebytes source  0  source length  options
end encodebytes
/**
* encodes a byte array into base64 notation. does not gzip-compress data.
*
* @param source the data to convert
* @param off offset in array where conversion should begin
* @param len length of data to convert
* @return encoded byte array
* @since 1.4
*/
public static string encodebytes byte source  int off  int len
return encodebytes source  off  len  no_options
end encodebytes
/**
* encodes a byte array into base64 notation.
* <p>
* valid options:
* <ul>
*   <li>gzip: gzip-compresses object before encoding it.</li>
*   <li>dont_break_lines: don't break lines at 76 characters. <i>note:
*     technically, this makes your encoding non-compliant.</i></li>
* </ul>
*
* <p>
* example: <code>encodebytes( mydata, base64.gzip )</code> or
* <p>
* example:
* <code>encodebytes( mydata, base64.gzip | base64.dont_break_lines )</code>
*
* @param source the data to convert
* @param off offset in array where conversion should begin
* @param len length of data to convert
* @param options specified options
* @see base64#gzip
* @see base64#dont_break_lines
* @see base64#url_safe
* @see base64#ordered
* @return encoded byte array
* @since 2.0
*/
public static string encodebytes byte source  int off  int len  int options
if   options   gzip     gzip                                   compress?
// gzip -> base64 -> bytearray
bytearrayoutputstream baos   new bytearrayoutputstream
gzipoutputstream gzos   null
try
gzos
new gzipoutputstream new base64outputstream baos  encode   options
gzos write source  off  len
gzos close
gzos   null
return new string baos tobytearray    preferred_encoding
catch  unsupportedencodingexception uue
return new string baos tobytearray
catch  ioexception e
log error    e
return null
finally
if  gzos    null
try
gzos close
catch  exception e
log error    e
try
baos close
catch  exception e
log error    e
end finally
end compress
// don't compress. better not to use streams at all then.
boolean breaklines     options   dont_break_lines     0
int len43   len   4   3
byte outbuff
new byte[ len43                                              main 4 3
len % 3  > 0 ? 4   0                            padding
breaklines ?  len43   max_line_length    0 ]     new lines
int d   0
int e   0
int len2   len   2
int linelength   0
for    d < len2  d    3  e    4
encode3to4 source  d   off  3  outbuff  e  options
linelength    4
if  breaklines    linelength    max_line_length
outbuff   new_line
e
linelength   0
end if  end of line
end for  each piece of array
if  d < len
encode3to4 source  d   off  len   d  outbuff  e  options
e    4
end if  some padding needed
// return value according to relevant encoding.
try
return new string outbuff  0  e  preferred_encoding
catch  unsupportedencodingexception uue
return new string outbuff  0  e
end encodebytes
/* ******** d e c o d i n g   m e t h o d s ******** */
/**
* decodes four bytes from array <var>source</var> and writes the resulting
* bytes (up to three of them) to <var>destination</var>. the source and
* destination arrays can be manipulated anywhere along their length by
* specifying <var>srcoffset</var> and <var>destoffset</var>. this method
* does not check to make sure your arrays are large enough to accomodate
* <var>srcoffset</var> + 4 for the <var>source</var> array or
* <var>destoffset</var> + 3 for the <var>destination</var> array. this
* method returns the actual number of bytes that were converted from the
* base64 encoding.
* <p>
* this is the lowest level of the decoding methods with all possible
* parameters.
* </p>
*
* @param source the array to convert
* @param srcoffset the index where conversion begins
* @param destination the array to hold the conversion
* @param destoffset the index where output will be put
* @param options options for getdecoabet
* @see base64#url_safe
* @see base64#ordered
* @return the number of decoded bytes converted
* @since 1.3
*/
@suppresswarnings
protected static int decode4to3 byte source  int srcoffset
byte destination  int destoffset  int options
byte decodabet   getdecodabet options
if  source    equals_sign                       example  dk
// two ways to do the same thing. don't know which way i like best.
// int outbuff = ( ( decodabet[ source[ srcoffset ] ] << 24 ) >>> 6 )
// | ( ( decodabet[ source[ srcoffset + 1] ] << 24 ) >>> 12 );
int outbuff
decodabet]   0xff  << 18
decodabet]   0xff  << 12
destination    byte   outbuff >>> 16
return 1
else if  source    equals_sign                example  dkl
// two ways to do the same thing. don't know which way i like best.
// int outbuff = ( ( decodabet[ source[ srcoffset ] ] << 24 ) >>> 6 )
// | ( ( decodabet[ source[ srcoffset + 1 ] ] << 24 ) >>> 12 )
// | ( ( decodabet[ source[ srcoffset + 2 ] ] << 24 ) >>> 18 );
int outbuff
decodabet]   0xff  << 18
decodabet]   0xff  << 12
decodabet]   0xff  << 6
destination    byte   outbuff >>> 16
destination    byte   outbuff >>> 8
return 2
else                                                         example  dkle
try
// two ways to do the same thing. don't know which way i like best.
// int outbuff = ( ( decodabet[ source[ srcoffset ] ] << 24 ) >>> 6 )
// | ( ( decodabet[ source[ srcoffset + 1 ] ] << 24 ) >>> 12 )
// | ( ( decodabet[ source[ srcoffset + 2 ] ] << 24 ) >>> 18 )
// | ( ( decodabet[ source[ srcoffset + 3 ] ] << 24 ) >>> 24 );
int outbuff
decodabet]   0xff  << 18
decodabet]   0xff  << 12
decodabet]   0xff  << 6
decodabet]   0xff
destination    byte   outbuff >> 16
destination    byte   outbuff >> 8
destination    byte   outbuff
return 3
catch  exception e
log error     source
decodabet]        source
decodabet]
source        decodabet]
source
decodabet]   e
return  1
end catch
end decodetobytes
/**
* very low-level access to decoding ascii characters in the form of a byte
* array. does not support automatically gunzipping or any other "fancy"
* features.
*
* @param source the base64 encoded data
* @param off the offset of where to begin decoding
* @param len the length of characters to decode
* @param options options for getdecodabet
* @see base64#url_safe
* @see base64#ordered
* @return decoded data
* @since 1.3
*/
public static byte decode byte source  int off  int len  int options
byte decodabet   getdecodabet options
int len34   len   3   4
byte outbuff   new byte               upper limit on size of output
int outbuffposn   0
byte b4   new byte
int b4posn   0
int i
byte sbicrop
byte sbidecode
for  i   off  i < off   len  i
sbicrop    byte   source   0x7f           only the low seven bits
sbidecode   decodabet
if  sbidecode >  white_space_enc             whitespace  equals or better
if  sbidecode >  equals_sign_enc           equals or better
b4   sbicrop
if  b4posn > 3
outbuffposn    decode4to3 b4  0  outbuff  outbuffposn  options
b4posn   0
// if that was the equals sign, break out of 'for' loop
if  sbicrop    equals_sign
break
end if  quartet built
end if  equals sign or better
else
log error     i       source
return null
end else
each input character
byte out   new byte
system arraycopy outbuff  0  out  0  outbuffposn
return out
end decode
/**
* decodes data from base64 notation, automatically detecting gzip-compressed
* data and decompressing it.
*
* @param s the string to decode
* @return the decoded data
* @since 1.4
*/
public static byte decode string s
return decode s  no_options
/**
* decodes data from base64 notation, automatically detecting gzip-compressed
* data and decompressing it.
*
* @param s the string to decode
* @param options options for decode
* @see base64#url_safe
* @see base64#ordered
* @return the decoded data
* @since 1.4
*/
public static byte decode string s  int options
byte bytes
try
bytes   s getbytes preferred_encoding
catch  unsupportedencodingexception uee
bytes   s getbytes
end catch
// decode
bytes   decode bytes  0  bytes length  options
// check to see if it's gzip-compressed
// gzip magic two-byte number: 0x8b1f (35615)
if  bytes    null    bytes length >  4
int head    bytes   0xff      bytes << 8    0xff00
if  gzipinputstream gzip_magic    head
gzipinputstream gzis   null
bytearrayoutputstream baos   new bytearrayoutputstream
try
gzis   new gzipinputstream new bytearrayinputstream bytes
byte buffer   new byte
for  int length   length   gzis read buffer   >  0
baos write buffer  0  length
end while  reading input
// no error? get new bytes.
bytes   baos tobytearray
catch  ioexception e
// just return originally-decoded bytes
finally
try
baos close
catch  exception e
log error    e
if  gzis    null
try
gzis close
catch  exception e
log error    e
end finally
end if  gzipped
end if  bytes length >  2
return bytes
end decode
/**
* attempts to decode base64 data and deserialize a java object within.
* returns <tt>null</tt> if there was an error.
*
* @param encodedobject the base64 data to decode
* @return the decoded and deserialized object
* @since 1.5
*/
public static object decodetoobject string encodedobject
// decode and gunzip if necessary
byte objbytes   decode encodedobject
object obj   null
objectinputstream ois   null
try
ois   new objectinputstream new bytearrayinputstream objbytes
obj   ois readobject
catch  ioexception e
log error    e
catch  classnotfoundexception e
log error    e
finally
if  ois    null
try
ois close
catch  exception e
log error    e
end finally
return obj
end decodeobject
/**
* convenience method for encoding data to a file.
*
* @param datatoencode byte array of data to encode in base64 form
* @param filename filename for saving encoded data
* @return <tt>true</tt> if successful, <tt>false</tt> otherwise
*
* @since 2.1
*/
public static boolean encodetofile byte datatoencode  string filename
boolean success   false
base64outputstream bos   null
try
bos   new base64outputstream new fileoutputstream filename   encode
bos write datatoencode
success   true
catch  ioexception e
log error     filename  e
success   false
finally
if  bos    null
try
bos close
catch  exception e
log error    e
end finally
return success
end encodetofile
/**
* convenience method for decoding data to a file.
*
* @param datatodecode base64-encoded data as a string
* @param filename filename for saving decoded data
* @return <tt>true</tt> if successful, <tt>false</tt> otherwise
*
* @since 2.1
*/
public static boolean decodetofile string datatodecode  string filename
boolean success   false
base64outputstream bos   null
try
bos   new base64outputstream new fileoutputstream filename   decode
bos write datatodecode getbytes preferred_encoding
success   true
catch  ioexception e
log error     filename  e
success   false
finally
if  bos    null
try
bos close
catch  exception e
log error    e
end finally
return success
end decodetofile
/**
* convenience method for reading a base64-encoded file and decoding it.
*
* @param filename filename for reading encoded data
* @return decoded byte array or null if unsuccessful
*
* @since 2.1
*/
public static byte decodefromfile string filename
byte decodeddata   null
base64inputstream bis   null
try
file file   new file filename
byte buffer
// check the size of file
if  file length   > integer max_value
log fatal
file length
return null
end if  file too big for int index
buffer   new byte
// open a stream
bis   new base64inputstream new bufferedinputstream
new fileinputstream file    decode
// read until done
int length   0
for  int numbytes   numbytes   bis read buffer  length  4096   >  0
length    numbytes
// save in a variable to return
decodeddata   new byte
system arraycopy buffer  0  decodeddata  0  length
catch  ioexception e
log error     filename  e
finally
if  bis    null
try
bis close
catch  exception e
log error    e
end finally
return decodeddata
end decodefromfile
/**
* convenience method for reading a binary file and base64-encoding it.
*
* @param filename filename for reading binary data
* @return base64-encoded string or null if unsuccessful
*
* @since 2.1
*/
public static string encodefromfile string filename
string encodeddata   null
base64inputstream bis   null
try
file file   new file filename
// need max() for math on small files (v2.2.1)
byte buffer   new byte
// open a stream
bis   new base64inputstream new bufferedinputstream
new fileinputstream file    encode
// read until done
int length   0
for  int numbytes   numbytes   bis read buffer  length  4096   >  0
length    numbytes
// save in a variable to return
encodeddata   new string buffer  0  length  preferred_encoding
catch  ioexception e
log error     filename  e
finally
if  bis    null
try
bis close
catch  exception e
log error    e
end finally
return encodeddata
end encodefromfile
/**
* reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.
*
* @param infile input file
* @param outfile output file
* @since 2.2
*/
public static void encodefiletofile string infile  string outfile
string encoded   encodefromfile infile
outputstream out   null
try
out   new bufferedoutputstream new fileoutputstream outfile
out write encoded getbytes         strict  7 bit output
catch  ioexception e
log error     infile       outfile  e
finally
if  out    null
try
out close
catch  exception e
log error     outfile  e
end finally
end encodefiletofile
/**
* reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.
*
* @param infile input file
* @param outfile output file
* @since 2.2
*/
public static void decodefiletofile string infile  string outfile
byte decoded   decodefromfile infile
outputstream out   null
try
out   new bufferedoutputstream new fileoutputstream outfile
out write decoded
catch  ioexception e
log error     infile       outfile  e
finally
if  out    null
try
out close
catch  exception e
log error     outfile  e
end finally
end decodefiletofile
/* ******** i n n e r   c l a s s   i n p u t s t r e a m ******** */
/**
* a {@link base64.base64inputstream} will read data from another
* <tt>inputstream</tt>, given in the constructor, and
* encode/decode to/from base64 notation on the fly.
*
* @see base64
* @since 1.3
*/
public static class base64inputstream extends filterinputstream
private boolean encode                         encoding or decoding
private int position                           current position in the buffer
private byte buffer                          buffer holding converted data
private int bufferlength                       length of buffer  3 or 4
private int numsigbytes                        meaningful bytes in the buffer
private int linelength
private boolean breaklines                     break lines at < 80 characters
private int options                            record options
private byte decodabet                       local copy avoids method calls
/**
* constructs a {@link base64inputstream} in decode mode.
*
* @param in the <tt>inputstream</tt> from which to read data.
* @since 1.3
*/
public base64inputstream inputstream in
this in  decode
end constructor
/**
* constructs a {@link base64.base64inputstream} in either encode or decode mode.
* <p>
* valid options:
*
* <pre>
*   encode or decode: encode or decode as data is read.
*   dont_break_lines: don't break lines at 76 characters
*     (only meaningful when encoding)
*     &lt;i&gt;note: technically, this makes your encoding non-compliant.&lt;/i&gt;
* </pre>
*
* <p>
* example: <code>new base64.base64inputstream( in, base64.decode )</code>
*
*
* @param in the <tt>inputstream</tt> from which to read data.
* @param options specified options
* @see base64#encode
* @see base64#decode
* @see base64#dont_break_lines
* @since 2.0
*/
public base64inputstream inputstream in  int options
super in
this breaklines    options   dont_break_lines     dont_break_lines
this encode    options   encode     encode
this bufferlength   encode ? 4   3
this buffer   new byte
this position    1
this linelength   0
this options   options     record for later  mostly to determine which
// alphabet to use
this decodabet   getdecodabet options
end constructor
/**
* reads enough of the input stream to convert to/from base64 and returns
* the next byte.
*
* @return next byte
* @since 1.3
*/
@override
public int read   throws ioexception
// do we need to get data?
if  position < 0
if  encode
byte b3   new byte
int numbinarybytes   0
for  int i   0  i < 3  i
try
int b   in read
// if end of stream, b is -1.
if  b >  0
b3    byte  b
numbinarybytes
end if  not end of stream
catch  ioexception e
// only a problem if we got no data at all.
if  i    0
throw e
end catch
end for  each needed input byte
if  numbinarybytes > 0
encode3to4 b3  0  numbinarybytes  buffer  0  options
position   0
numsigbytes   4
else
return  1
end else
else
byte b4   new byte
int i
for  i   0  i < 4  i
// read four "meaningful" bytes:
int b
do
b   in read
while  b >  0    decodabet <  white_space_enc
if  b < 0
break     reads a  1 if end of stream
b4    byte  b
end for  each needed input byte
if  i    4
numsigbytes   decode4to3 b4  0  buffer  0  options
position   0
else if  i    0
return  1
else
// must have broken out from above.
throw new ioexception
end
end else  decode
end else  get data
// got data?
if  position >  0
// end of relevant data?
if       encode      position >  numsigbytes
return  1
if  encode    breaklines    linelength >  max_line_length
linelength   0
return
linelength                         this isn't important when decoding
// but throwing an extra "if" seems
// just as wasteful.
int b   buffer
if  position >  bufferlength
position    1
return b   0xff                    this is how you   a byte that's
// intended to be unsigned.
// when jdk1.4 is more accepted, use an assertion here.
throw new ioexception
end read
/**
* calls {@link #read()} repeatedly until the end of stream is reached or
* <var>len</var> bytes are read. returns number of bytes read into array
* or -1 if end of stream is encountered.
*
* @param dest array to hold values
* @param off offset for array
* @param len max number of bytes to read into array
* @return bytes read into array or -1 if end of stream is encountered.
* @since 1.3
*/
@override
public int read byte dest  int off  int len  throws ioexception
int i
int b
for  i   0  i < len  i
b   read
if  b >  0
dest    byte  b
else if  i    0
return  1
else
break     out of   loop
end for  each byte read
return i
end read
end inner class inputstream
/* ******** i n n e r   c l a s s   o u t p u t s t r e a m ******** */
/**
* a {@link base64.base64outputstream} will write data to another
* <tt>outputstream</tt>, given in the constructor, and
* encode/decode to/from base64 notation on the fly.
*
* @see base64
* @since 1.3
*/
public static class base64outputstream extends filteroutputstream
private boolean encode
private int position
private byte buffer
private int bufferlength
private int linelength
private boolean breaklines
private byte b4                              scratch used in a few places
private boolean suspendencoding
private int options                            record for later
private byte decodabet                       local copy avoids method calls
/**
* constructs a {@link base64outputstream} in encode mode.
*
* @param out the <tt>outputstream</tt> to which data will be written.
* @since 1.3
*/
public base64outputstream outputstream out
this out  encode
end constructor
/**
* constructs a {@link base64outputstream} in either encode or decode mode.
* <p>
* valid options:
*
* <ul>
*   <li>encode or decode: encode or decode as data is read.</li>
*   <li>dont_break_lines: don't break lines at 76 characters (only
*     meaningful when encoding) <i>note: technically, this makes your
*     encoding non-compliant.</i></li>
* </ul>
*
* <p>
* example: <code>new base64.base64outputstream( out, base64.encode )</code>
*
* @param out the <tt>outputstream</tt> to which data will be written.
* @param options specified options.
* @see base64#encode
* @see base64#decode
* @see base64#dont_break_lines
* @since 1.3
*/
public base64outputstream outputstream out  int options
super out
this breaklines    options   dont_break_lines     dont_break_lines
this encode    options   encode     encode
this bufferlength   encode ? 3   4
this buffer   new byte
this position   0
this linelength   0
this suspendencoding   false
this b4   new byte
this options   options
this decodabet   getdecodabet options
end constructor
/**
* writes the byte to the output stream after converting to/from base64
* notation. when encoding, bytes are buffered three at a time before the
* output stream actually gets a write() call. when decoding, bytes are
* buffered four at a time.
*
* @param thebyte the byte to write
* @since 1.3
*/
@override
public void write int thebyte  throws ioexception
// encoding suspended?
if  suspendencoding
super out write thebyte
return
end if  supsended
// encode?
if  encode
buffer    byte  thebyte
if  position >  bufferlength                       enough to encode
out write encode3to4 b4  buffer  bufferlength  options
linelength    4
if  breaklines    linelength >  max_line_length
out write new_line
linelength   0
end if  end of line
position   0
end if  enough to output
else
// meaningful base64 character?
if  decodabet > white_space_enc
buffer    byte  thebyte
if  position >  bufferlength                     enough to output
int len   decode4to3 buffer  0  b4  0  options
out write b4  0  len
position   0
end if  enough to output
else if  decodabet    white_space_enc
throw new ioexception
end else  not white space either
end else  decoding
end write
/**
* calls {@link #write(int)} repeatedly until <var>len</var> bytes are
* written.
*
* @param thebytes array from which to read bytes
* @param off offset for array
* @param len max number of bytes to read into array
* @since 1.3
*/
@override
public void write byte thebytes  int off  int len  throws ioexception
// encoding suspended?
if  suspendencoding
super out write thebytes  off  len
return
end if  supsended
for  int i   0  i < len  i
write thebytes
end for  each byte written
end write
/**
* method added by phil. [thanks, phil. -rob] this pads the buffer without
* closing the stream.
*
* @throws ioexception e
*/
public void flushbase64   throws ioexception
if  position > 0
if  encode
out write encode3to4 b4  buffer  position  options
position   0
else
throw new ioexception
end else  decoding
end if  buffer partially full
end flush
/**
* flushes and closes (i think, in the superclass) the stream.
*
* @since 1.3
*/
@override
public void close   throws ioexception
// 1. ensure that pending characters are written
flushbase64
// 2. actually close the stream
// base class both flushes and closes.
super close
buffer   null
out   null
end close
/**
* suspends encoding of the stream. may be helpful if you need to embed a
* piece of base640-encoded data in a stream.
*
* @throws ioexception e
* @since 1.5.1
*/
public void suspendencoding   throws ioexception
flushbase64
this suspendencoding   true
end suspendencoding
/**
* resumes encoding of the stream. may be helpful if you need to embed a
* piece of base640-encoded data in a stream.
*
* @since 1.5.1
*/
public void resumeencoding
this suspendencoding   false
end resumeencoding
end inner class outputstream
end class base64