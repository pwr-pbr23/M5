/**
* copyright 2008 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase io
import java io datainput
import java io dataoutput
import java io ioexception
import java util collection
import java util comparator
import java util map
import java util set
import java util sortedmap
import java util treemap
import java util concurrent atomic atomicreference
import org apache hadoop conf configurable
import org apache hadoop conf configuration
import org apache hadoop hbase util bytes
import org apache hadoop io writable
import org apache hadoop util reflectionutils
/**
* a writable map.
* like {@link org.apache.hadoop.io.mapwritable} but dumb. it will fail
* if passed a value type that it has not already been told about. its  been
* primed with hbase writables and byte [].  keys are always byte arrays.
*
* @param <k> <byte []> key  todo: parameter k is never used, could be removed.
* @param <v> value expects a writable or byte [].
*/
public class hbasemapwritable <k v>
implements sortedmap<byte v>  configurable  writable  codetoclassandback
private atomicreference<configuration> conf   null
protected sortedmap<byte   v> instance   null
/**
* the default contructor where a treemap is used
**/
public hbasemapwritable
this  new treemap<byte   v> bytes bytes_comparator
/**
* contructor where another sortedmap can be used
*
* @param map the sortedmap to be used
*/
public hbasemapwritable sortedmap<byte  v> map
conf   new atomicreference<configuration>
instance   map
/** @return the conf */
public configuration getconf
return conf get
/** @param conf the conf to set */
public void setconf configuration conf
this conf set conf
public void clear
instance clear
public boolean containskey object key
return instance containskey key
public boolean containsvalue object value
return instance containsvalue value
public set<entry<byte   v>> entryset
return instance entryset
public v get object key
return instance get key
public boolean isempty
return instance isempty
public set<byte > keyset
return instance keyset
public int size
return instance size
public collection<v> values
return instance values
public void putall map<? extends byte   ? extends v> m
this instance putall m
public v remove object key
return this instance remove key
public v put byte  key  v value
return this instance put key  value
public comparator<? super byte> comparator
return this instance comparator
public byte firstkey
return this instance firstkey
public sortedmap<byte  v> headmap byte tokey
return this instance headmap tokey
public byte lastkey
return this instance lastkey
public sortedmap<byte  v> submap byte fromkey  byte tokey
return this instance submap fromkey  tokey
public sortedmap<byte  v> tailmap byte fromkey
return this instance tailmap fromkey
// writable
/** @return the class class for the specified id */
@suppresswarnings
protected class<?> getclass byte id
return code_to_class get id
/** @return the id for the specified class */
@suppresswarnings
protected byte getid class<?> clazz
byte b   class_to_code get clazz
if  b    null
throw new nullpointerexception     clazz
return b
/**
* @see java.lang.object#tostring()
*/
@override
public string tostring
return this instance tostring
public void write dataoutput out  throws ioexception
// write out the number of entries in the map
out writeint this instance size
// then write out each key/value pair
for  map entry<byte   v> e  instance entryset
bytes writebytearray out  e getkey
byte id   getid e getvalue   getclass
out writebyte id
object value   e getvalue
if  value instanceof byte
bytes writebytearray out   byte  value
else
writable value  write out
@suppresswarnings
public void readfields datainput in  throws ioexception
// first clear the map.  otherwise we will just accumulate
// entries every time this method is called.
this instance clear
// read the number of entries in the map
int entries   in readint
// then read each key/value pair
for  int i   0  i < entries  i
byte  key   bytes readbytearray in
byte id   in readbyte
class clazz   getclass id
v value   null
if  clazz equals byte  class
byte  bytes   bytes readbytearray in
value    v bytes
else
writable w    writable reflectionutils
newinstance clazz  getconf
w readfields in
value    v w
this instance put key  value