/**
* copyright 2009 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver
import java io ioexception
import org apache hadoop hbase regionserver scanquerymatcher matchcode
/**
* implementing classes of this interface will be used for the tracking
* and enforcement of columns and numbers of versions and timetolive during
* the course of a get or scan operation.
* <p>
* currently there are two different types of store/family-level queries.
* <ul><li>{@link explicitcolumntracker} is used when the query specifies
* one or more column qualifiers to return in the family.
* <p>
* this class is utilized by {@link scanquerymatcher} through two methods:
* <ul><li>{@link #checkcolumn} is called when a put satisfies all other
* conditions of the query.  this method returns a {@link org.apache.hadoop.hbase.regionserver.scanquerymatcher.matchcode} to define
* what action should be taken.
* <li>{@link #update} is called at the end of every storefile or memstore.
* <p>
* this class is not thread-safe as queries are never multi-threaded
*/
public interface columntracker
/**
* keeps track of the number of versions for the columns asked for
* @param bytes
* @param offset
* @param length
* @param ttl the timetolive to enforce.
* @param type the type of the keyvalue
* @param ignorecount indicates if the kv needs to be excluded while counting
*   (used during compactions. we only count kv's that are older than all the
*   scanners' read points.)
* @return the match code instance.
* @throws ioexception in case there is an internal consistency problem
*      caused by a data corruption.
*/
public scanquerymatcher matchcode checkcolumn byte bytes  int offset
int length  long ttl  byte type  boolean ignorecount
throws ioexception
/**
* updates internal variables in between files
*/
public void update
/**
* resets the matcher
*/
public void reset
/**
*
* @return <code>true</code> when done.
*/
public boolean done
/**
* used by matcher and scan/get to get a hint of the next column
* to seek to after checkcolumn() returns skip.  returns the next interesting
* column we want, or null there is none (wildcard scanner).
*
* implementations aren't required to return anything useful unless the most recent
* call was to checkcolumn() and the return code was skip.  this is pretty implementation
* detail-y, but optimizations are like that.
*
* @return null, or a columncount that we should seek to
*/
public columncount getcolumnhint
/**
* retrieve the matchcode for the next row or column
*/
public matchcode getnextrowornextcolumn byte bytes  int offset
int quallength
/**
* give the tracker a chance to declare it's done based on only the timestamp
* to allow an early out.
*
* @param timestamp
* @return <code>true</code> to early out based on timestamp.
*/
public boolean isdone long timestamp