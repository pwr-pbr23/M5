/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver metrics
import java lang reflect field
import java lang reflect method
import java util map
import java util map entry
import java util concurrent atomic atomiclong
import java util concurrent atomic atomicinteger
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase regionserver hregion
import org apache hadoop hbase util pair
import org apache hadoop metrics metricscontext
import org apache hadoop metrics metricsrecord
import org apache hadoop metrics metricsutil
import org apache hadoop metrics updater
import org apache hadoop metrics util metricsbase
import org apache hadoop metrics util metricslongvalue
import org apache hadoop metrics util metricsregistry
import org apache hadoop metrics util metricstimevaryingrate
/**
*
* this class is for maintaining  the various rpc statistics
* and publishing them through the metrics interfaces.
* this also registers the jmx mbean for rpc.
* <p>
* this class has a number of metrics variables that are publicly accessible;
* these variables (objects) have methods to update their values;
* for example: rpcqueuetime.inc(time)
*
*/
public class regionserverdynamicmetrics implements updater
private static final string unable_to_clear
private metricsrecord metricsrecord
private metricscontext context
private final regionserverdynamicstatistics rsdynamicstatistics
private method updatembeaninfoifmetricslistchanged   null
private static final log log
logfactory getlog regionserverdynamicstatistics class
private boolean reflectioninitialized   false
private field recordmetricmapfield
private field registrymetricmapfield
/**
* the metrics variables are public:
*  - they can be set directly by calling their set/inc methods
*  -they can also be read directly - e.g. jmx does this.
*/
public final metricsregistry registry   new metricsregistry
private regionserverdynamicmetrics
this context   metricsutil getcontext
this metricsrecord   metricsutil createrecord
this context
context registerupdater this
this rsdynamicstatistics   new regionserverdynamicstatistics this registry
try
updatembeaninfoifmetricslistchanged
this rsdynamicstatistics getclass   getsuperclass
getdeclaredmethod
new class
updatembeaninfoifmetricslistchanged setaccessible true
catch  exception e
log error e
public static regionserverdynamicmetrics newinstance
regionserverdynamicmetrics metrics
new regionserverdynamicmetrics
return metrics
public synchronized void setnumericmetric string name  long amt
metricslongvalue m    metricslongvalue registry get name
if  m    null
m   new metricslongvalue name  this registry
try
if  updatembeaninfoifmetricslistchanged    null
updatembeaninfoifmetricslistchanged invoke this rsdynamicstatistics
new object
catch  exception e
log error e
m set amt
public synchronized void incrtimevaryingmetric
string name
long amt
int numops
metricstimevaryingrate m    metricstimevaryingrate registry get name
if  m    null
m   new metricstimevaryingrate name  this registry
try
if  updatembeaninfoifmetricslistchanged    null
updatembeaninfoifmetricslistchanged invoke this rsdynamicstatistics
new object
catch  exception e
log error e
if  numops > 0
m inc numops  amt
/**
* clear all metrics this exposes.
* uses reflection to clear them from hadoop metrics side as well.
*/
@suppresswarnings
public void clear
// if this is the first clear use reflection to get the two maps that hold copies of our
// metrics on the hadoop metrics side. we have to use reflection because there is not
// remove metrics on the hadoop side. if we can't get them then clearing old metrics
// is not possible and bailing out early is our best option.
if   this reflectioninitialized
this reflectioninitialized   true
try
this recordmetricmapfield   this metricsrecord getclass   getdeclaredfield
this recordmetricmapfield setaccessible true
catch  securityexception e
log debug unable_to_clear
return
catch  nosuchfieldexception e
log debug unable_to_clear
return
try
this registrymetricmapfield   this registry getclass   getdeclaredfield
this registrymetricmapfield setaccessible true
catch  securityexception e
log debug unable_to_clear
return
catch  nosuchfieldexception e
log debug unable_to_clear
return
//if we found both fields then try and clear the maps.
if  this recordmetricmapfield    null    this registrymetricmapfield    null
try
map recordmap    map  this recordmetricmapfield get this metricsrecord
recordmap clear
map registrymap    map  this registrymetricmapfield get this registry
registrymap clear
catch  illegalargumentexception e
log debug unable_to_clear
catch  illegalaccessexception e
log debug unable_to_clear
else
log debug unable_to_clear
/**
* push the metrics to the monitoring subsystem on doupdate() call.
* @param context ctx
*/
public void doupdates metricscontext context
/* get dynamically created numeric metrics, and push the metrics */
for  entry<string  atomiclong> entry   regionmetricsstorage getnumericmetrics   entryset
this setnumericmetric entry getkey    entry getvalue   getandset 0
/* get dynamically created numeric metrics, and push the metrics.
* these ones aren't to be reset; they are cumulative. */
for  entry<string  atomiclong> entry   regionmetricsstorage getnumericpersistentmetrics   entryset
this setnumericmetric entry getkey    entry getvalue   get
/* get dynamically created time varying metrics, and push the metrics */
for  entry<string  pair<atomiclong  atomicinteger>> entry
regionmetricsstorage gettimevaryingmetrics   entryset
pair<atomiclong  atomicinteger> value   entry getvalue
this incrtimevaryingmetric entry getkey
value getfirst   getandset 0
value getsecond   getandset 0
synchronized  registry
// iterate through the registry to propagate the different rpc metrics.
for  string metricname   registry getkeylist
metricsbase value   registry get metricname
value pushmetric metricsrecord
metricsrecord update
public void shutdown
if  rsdynamicstatistics    null
rsdynamicstatistics shutdown