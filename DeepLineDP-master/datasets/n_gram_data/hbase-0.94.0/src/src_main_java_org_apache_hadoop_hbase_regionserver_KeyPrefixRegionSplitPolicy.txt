/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver
import java util arrays
import org apache commons logging log
import org apache commons logging logfactory
/**
* a custom regionsplitpolicy implementing a splitpolicy that groups
* rows by a prefix of the row-key
*
* this ensures that a region is not split "inside" a prefix of a row key.
* i.e. rows can be co-located in a regionb by their prefix.
*/
public class keyprefixregionsplitpolicy extends increasingtoupperboundregionsplitpolicy
private static final log log   logfactory
getlog keyprefixregionsplitpolicy class
public static string prefix_length_key
private int prefixlength   0
@override
protected void configureforregion hregion region
super configureforregion region
if  region    null
prefixlength   0
// read the prefix length from the table descriptor
string prefixlengthstring   region gettabledesc   getvalue
prefix_length_key
if  prefixlengthstring    null
log error prefix_length_key
region gettabledesc   getnameasstring
return
try
prefixlength   integer parseint prefixlengthstring
catch  numberformatexception nfe
// ignore
if  prefixlength <  0
log error     prefix_length_key
region gettabledesc   getnameasstring
prefixlengthstring
@override
protected byte getsplitpoint
byte splitpoint   super getsplitpoint
if  prefixlength > 0    splitpoint    null    splitpoint length > 0
// group split keys by a prefix
return arrays copyof splitpoint
math min prefixlength  splitpoint length
else
return splitpoint