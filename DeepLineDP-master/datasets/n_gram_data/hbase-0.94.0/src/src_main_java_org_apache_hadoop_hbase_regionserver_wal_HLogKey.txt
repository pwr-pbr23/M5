/**
* copyright 2007 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver wal
import java io datainput
import java io dataoutput
import java io eofexception
import java io ioexception
import java util hashmap
import java util map
import java util uuid
import org apache hadoop hbase hconstants
import org apache hadoop hbase util bytes
import org apache hadoop io writablecomparable
import org apache hadoop io writableutils
/**
* a key for an entry in the change log.
*
* the log intermingles edits to many tables and rows, so each log entry
* identifies the appropriate table and row.  within a table and row, they're
* also sorted.
*
* <p>some transactional edits (start, commit, abort) will not have an
* associated row.
*/
public class hlogkey implements writablecomparable<hlogkey>
// should be < 0 (@see #readfields(datainput))
// version 2 supports hlog compression
enum version
unversioned 0
// initial number we put on hlogkey when we introduced versioning.
initial  1
// version -2 introduced a dictionary compression facility.  only this
// dictionary-based compression is available in version -2.
compressed  2
final int code
static final version bycode
static
bycode   version values
for  int i   0  i < bycode length  i
if  bycode code     1   i
throw new assertionerror
version int code
this code   code
boolean atleast version other
return code <  other code
static version fromcode int code
return bycode
private static final version version   version compressed
//  the encoded region name.
private byte  encodedregionname
private byte  tablename
private long logseqnum
// time at which this edit was written.
private long writetime
private uuid clusterid
private compressioncontext compressioncontext
/** writable constructor -- do not use. */
public hlogkey
this null  null  0l  hconstants latest_timestamp
hconstants default_cluster_id
/**
* create the log key!
* we maintain the tablename mainly for debugging purposes.
* a regionname is always a sub-table object.
*
* @param encodedregionname encoded name of the region as returned by
* <code>hregioninfo#getencodednameasbytes()</code>.
* @param tablename   - name of table
* @param logseqnum   - log sequence number
* @param now time at which this edit was written.
* @param clusterid of the cluster (used in replication)
*/
public hlogkey final byte  encodedregionname  final byte  tablename
long logseqnum  final long now  uuid clusterid
this encodedregionname   encodedregionname
this tablename   tablename
this logseqnum   logseqnum
this writetime   now
this clusterid   clusterid
/**
* @param compressioncontext compression context to use
*/
public void setcompressioncontext compressioncontext compressioncontext
this compressioncontext   compressioncontext
/** @return encoded region name */
public byte  getencodedregionname
return encodedregionname
/** @return table name */
public byte  gettablename
return tablename
/** @return log sequence number */
public long getlogseqnum
return logseqnum
void setlogseqnum long logseqnum
this logseqnum   logseqnum
/**
* @return the write time
*/
public long getwritetime
return this writetime
/**
* get the id of the original cluster
* @return cluster id.
*/
public uuid getclusterid
return clusterid
/**
* set the cluster id of this key
* @param clusterid
*/
public void setclusterid uuid clusterid
this clusterid   clusterid
@override
public string tostring
return bytes tostring tablename        bytes tostring encodedregionname
logseqnum
/**
* produces a string map for this key. useful for programmatic use and
* manipulation of the data stored in an hlogkey, for example, printing
* as json.
*
* @return a map containing data from this key
*/
public map<string  object> tostringmap
map<string  object> stringmap   new hashmap<string  object>
stringmap put    bytes tostringbinary tablename
stringmap put    bytes tostringbinary encodedregionname
stringmap put    logseqnum
return stringmap
@override
public boolean equals object obj
if  this    obj
return true
if  obj    null    getclass      obj getclass
return false
return compareto  hlogkey obj     0
@override
public int hashcode
int result   bytes hashcode this encodedregionname
result ^  this logseqnum
result ^  this writetime
result ^  this clusterid hashcode
return result
public int compareto hlogkey o
int result   bytes compareto this encodedregionname  o encodedregionname
if  result    0
if  this logseqnum < o logseqnum
result    1
else if  this logseqnum > o logseqnum
result   1
if  result    0
if  this writetime < o writetime
result    1
else if  this writetime > o writetime
return 1
// why isn't cluster id accounted for?
return result
/**
* drop this instance's tablename byte array and instead
* hold a reference to the provided tablename. this is not
* meant to be a general purpose setter - it's only used
* to collapse references to conserve memory.
*/
void interntablename byte tablename
// we should not use this as a setter - only to swap
// in a new reference to the same table name.
assert bytes equals tablename  this tablename
this tablename   tablename
/**
* drop this instance's region name byte array and instead
* hold a reference to the provided region name. this is not
* meant to be a general purpose setter - it's only used
* to collapse references to conserve memory.
*/
void internencodedregionname byte encodedregionname
// we should not use this as a setter - only to swap
// in a new reference to the same table name.
assert bytes equals this encodedregionname  encodedregionname
this encodedregionname   encodedregionname
@override
public void write dataoutput out  throws ioexception
writableutils writevint out  version code
if  compressioncontext    null
bytes writebytearray out  this encodedregionname
bytes writebytearray out  this tablename
else
compressor writecompressed this encodedregionname  0
this encodedregionname length  out
compressioncontext regiondict
compressor writecompressed this tablename  0  this tablename length  out
compressioncontext tabledict
out writelong this logseqnum
out writelong this writetime
// avoid storing 16 bytes when replication is not enabled
if  this clusterid    hconstants default_cluster_id
out writeboolean false
else
out writeboolean true
out writelong this clusterid getmostsignificantbits
out writelong this clusterid getleastsignificantbits
@override
public void readfields datainput in  throws ioexception
version version   version unversioned
// hlogkey was not versioned in the beginning.
// in order to introduce it now, we make use of the fact
// that encodedregionname was written with bytes.writebytearray,
// which encodes the array length as a vint which is >= 0.
// hence if the vint is >= 0 we have an old version and the vint
// encodes the length of encodedregionname.
// if < 0 we just read the version and the next vint is the length.
// @see bytes#readbytearray(datainput)
int len   writableutils readvint in
if  len < 0
// what we just read was the version
version   version fromcode len
// we only compress v2 of hlogkey.
// if compression is on, the length is handled by the dictionary
if  compressioncontext    null     version atleast version compressed
len   writableutils readvint in
if  compressioncontext    null     version atleast version compressed
this encodedregionname   new byte
in readfully this encodedregionname
this tablename   bytes readbytearray in
else
this encodedregionname   compressor readcompressed in  compressioncontext regiondict
this tablename   compressor readcompressed in  compressioncontext tabledict
this logseqnum   in readlong
this writetime   in readlong
this clusterid   hconstants default_cluster_id
if  version atleast version initial
if  in readboolean
this clusterid   new uuid in readlong    in readlong
else
try
// dummy read (former byte cluster id)
in readbyte
catch eofexception e
// means it's a very old key, just continue