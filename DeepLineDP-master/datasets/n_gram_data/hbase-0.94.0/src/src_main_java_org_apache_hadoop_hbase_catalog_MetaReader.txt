/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase catalog
import java io ioexception
import java util arraylist
import java util list
import java util map
import java util navigablemap
import java util set
import java util treemap
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase notservingregionexception
import org apache hadoop hbase servername
import org apache hadoop hbase client get
import org apache hadoop hbase client htable
import org apache hadoop hbase client result
import org apache hadoop hbase client resultscanner
import org apache hadoop hbase client scan
import org apache hadoop hbase ipc hregioninterface
import org apache hadoop hbase util bytes
import org apache hadoop hbase util pair
import org apache hadoop hbase util writables
import org apache hadoop ipc remoteexception
/**
* reads region and assignment information from <code>.meta.</code>.
*/
public class metareader
// todo: strip catalogtracker from this class.  its all over and in the end
// its only used to get its configuration so we can get associated
// connection.
private static final log log   logfactory getlog metareader class
static final byte  meta_region_prefix
static
// copy the prefix from first_meta_regioninfo into meta_region_prefix.
// first_meta_regioninfo == '.meta.,,1'.  meta_region_prefix == '.meta.,'
int len   hregioninfo first_meta_regioninfo getregionname   length   2
meta_region_prefix   new byte
system arraycopy hregioninfo first_meta_regioninfo getregionname    0
meta_region_prefix  0  len
/**
* @param row
* @return true if <code>row</code> is row of <code>-root-</code> table.
*/
private static boolean isroottablerow final byte  row
if  row length < meta_region_prefix length   2
// can't be meta table region.
return false
// compare the prefix of row.  if it matches meta_region_prefix prefix,
// then this is row from -root_ table.
return bytes equals row  0  meta_region_prefix length
meta_region_prefix  0  meta_region_prefix length
/**
* performs a full scan of <code>.meta.</code>, skipping regions from any
* tables in the specified set of disabled tables.
* @param catalogtracker
* @param disabledtables set of disabled tables that will not be returned
* @return returns a map of every region to it's currently assigned server,
* according to meta.  if the region does not have an assignment it will have
* a null value in the map.
* @throws ioexception
*/
public static map<hregioninfo  servername> fullscan
catalogtracker catalogtracker  final set<string> disabledtables
throws ioexception
return fullscan catalogtracker  disabledtables  false
/**
* performs a full scan of <code>.meta.</code>, skipping regions from any
* tables in the specified set of disabled tables.
* @param catalogtracker
* @param disabledtables set of disabled tables that will not be returned
* @param excludeofflinedsplitparents if true, do not include offlined split
* parents in the return.
* @return returns a map of every region to it's currently assigned server,
* according to meta.  if the region does not have an assignment it will have
* a null value in the map.
* @throws ioexception
*/
public static map<hregioninfo  servername> fullscan
catalogtracker catalogtracker  final set<string> disabledtables
final boolean excludeofflinedsplitparents
throws ioexception
final map<hregioninfo  servername> regions
new treemap<hregioninfo  servername>
visitor v   new visitor
@override
public boolean visit result r  throws ioexception
if  r     null    r isempty    return true
pair<hregioninfo  servername> region   parsecatalogresult r
if  region    null  return true
hregioninfo hri   region getfirst
if  hri     null  return true
if  hri gettablenameasstring      null  return true
if  disabledtables contains
hri gettablenameasstring     return true
// are we to include split parents in the list?
if  excludeofflinedsplitparents    hri issplitparent    return true
regions put hri  region getsecond
return true
fullscan catalogtracker  v
return regions
/**
* performs a full scan of <code>.meta.</code>.
* @return list of {@link result}
* @throws ioexception
*/
public static list<result> fullscan catalogtracker catalogtracker
throws ioexception
collectallvisitor v   new collectallvisitor
fullscan catalogtracker  v  null
return v getresults
/**
* performs a full scan of a <code>-root-</code> table.
* @return list of {@link result}
* @throws ioexception
*/
public static list<result> fullscanofroot catalogtracker catalogtracker
throws ioexception
collectallvisitor v   new collectallvisitor
fullscan catalogtracker  v  null  true
return v getresults
/**
* performs a full scan of <code>.meta.</code>.
* @param catalogtracker
* @param visitor visitor invoked against each row.
* @throws ioexception
*/
public static void fullscan catalogtracker catalogtracker
final visitor visitor
throws ioexception
fullscan catalogtracker  visitor  null
/**
* performs a full scan of <code>.meta.</code>.
* @param catalogtracker
* @param visitor visitor invoked against each row.
* @param startrow where to start the scan. pass null if want to begin scan
* at first row (the visitor will stop the scan when its done so no need to
* pass a stoprow).
* @throws ioexception
*/
public static void fullscan catalogtracker catalogtracker
final visitor visitor  final byte  startrow
throws ioexception
fullscan catalogtracker  visitor  startrow  false
/**
* callers should call close on the returned {@link htable} instance.
* @param catalogtracker we'll use this catalogtracker's connection
* @param tablename table to get an {@link htable} against.
* @return an {@link htable} for <code>tablename</code>
* @throws ioexception
*/
private static htable gethtable final catalogtracker catalogtracker
final byte  tablename
throws ioexception
// passing the catalogtracker's connection configuration ensures this
// htable instance uses the catalogtracker's connection.
org apache hadoop hbase client hconnection c   catalogtracker getconnection
if  c    null  throw new nullpointerexception
return new htable catalogtracker getconnection   getconfiguration    tablename
/**
* callers should call close on the returned {@link htable} instance.
* @param catalogtracker
* @param row row we are putting
* @return
* @throws ioexception
*/
static htable getcataloghtable final catalogtracker catalogtracker
final byte  row
throws ioexception
return isroottablerow row ?
getroothtable catalogtracker
getmetahtable catalogtracker
/**
* callers should call close on the returned {@link htable} instance.
* @param ct
* @return an {@link htable} for <code>.meta.</code>
* @throws ioexception
*/
static htable getmetahtable final catalogtracker ct
throws ioexception
return gethtable ct  hconstants meta_table_name
/**
* callers should call close on the returned {@link htable} instance.
* @param ct
* @return an {@link htable} for <code>-root-</code>
* @throws ioexception
*/
static htable getroothtable final catalogtracker ct
throws ioexception
return gethtable ct  hconstants root_table_name
/**
* @param t table to use (will be closed when done).
* @param g get to run
* @throws ioexception
*/
private static result get final htable t  final get g  throws ioexception
try
return t get g
finally
t close
/**
* reads the location of meta from root.
* @param metaserver connection to server hosting root
* @return location of meta in root where location, or null if not available
* @throws ioexception
* @deprecated does not retry; use #getmetaregionlocation(catalogtracker)
*/
public static servername readmetalocation hregioninterface metaserver
throws ioexception
return readlocation metaserver  catalogtracker root_region_name
catalogtracker meta_region_name
/**
* gets the location of <code>.meta.</code> region by reading content of
* <code>-root-</code>.
* @param ct
* @return location of <code>.meta.</code> region as a {@link servername} or
* null if not found
* @throws ioexception
*/
static servername getmetaregionlocation final catalogtracker ct
throws ioexception
return metareader readregionlocation ct  catalogtracker meta_region_name
/**
* reads the location of the specified region
* @param catalogtracker
* @param regionname region whose location we are after
* @return location of region as a {@link servername} or null if not found
* @throws ioexception
*/
static servername readregionlocation catalogtracker catalogtracker
byte  regionname
throws ioexception
pair<hregioninfo  servername> pair   getregion catalogtracker  regionname
return  pair    null    pair getsecond      null ? null  pair getsecond
// todo: remove when deprecated dependencies are removed.
private static servername readlocation hregioninterface metaserver
byte  catalogregionname  byte  regionname
throws ioexception
result r   null
try
r   metaserver get catalogregionname
new get regionname
addcolumn hconstants catalog_family
hconstants server_qualifier
addcolumn hconstants catalog_family
hconstants startcode_qualifier
catch  java net sockettimeoutexception e
// treat this exception + message as unavailable catalog table. catch it
// and fall through to return a null
catch  java net socketexception e
// treat this exception + message as unavailable catalog table. catch it
// and fall through to return a null
catch  remoteexception re
ioexception ioe   re unwrapremoteexception
if  ioe instanceof notservingregionexception
// treat this nsre as unavailable table.  catch and fall through to
// return null below
else if  ioe getmessage   contains
// treat as unavailable table.
else
throw re
catch  ioexception e
if  e getcause      null    e getcause   instanceof ioexception
e getcause   getmessage      null
e getcause   getmessage   contains
// treat this exception + message as unavailable catalog table. catch it
// and fall through to return a null
else
throw e
if  r    null    r isempty
return null
return getservernamefromcatalogresult r
/**
* gets the region info and assignment for the specified region.
* @param catalogtracker
* @param regionname region to lookup.
* @return location and hregioninfo for <code>regionname</code>
* @throws ioexception
*/
public static pair<hregioninfo  servername> getregion
catalogtracker catalogtracker  byte  regionname
throws ioexception
get get   new get regionname
get addfamily hconstants catalog_family
result r   get getcataloghtable catalogtracker  regionname   get
return  r    null    r isempty   ? null  parsecatalogresult r
/**
* extract a {@link servername}
* for use on catalog table {@link result}.
* @param r result to pull from
* @return a servername instance or null if necessary fields not found or empty.
*/
public static servername getservernamefromcatalogresult final result r
byte value   r getvalue hconstants catalog_family
hconstants server_qualifier
if  value    null    value length    0  return null
string hostandport   bytes tostring value
value   r getvalue hconstants catalog_family
hconstants startcode_qualifier
if  value    null    value length    0  return null
return new servername hostandport  bytes tolong value
/**
* extract a hregioninfo and servername.
* for use on catalog table {@link result}.
* @param r result to pull from
* @return a pair of the {@link hregioninfo} and the {@link servername}
* (or null for server address if no address set in .meta.).
* @throws ioexception
*/
public static pair<hregioninfo  servername> parsecatalogresult final result r
throws ioexception
hregioninfo info
parsehregioninfofromcatalogresult r  hconstants regioninfo_qualifier
servername sn   getservernamefromcatalogresult r
return new pair<hregioninfo  servername> info  sn
/**
* parse the content of the cell at {@link hconstants#catalog_family} and
* <code>qualifier</code> as an hregioninfo and return it, or null.
* for use on catalog table {@link result}.
* @param r result instance to pull from.
* @param qualifier column family qualifier -- either
* {@link hconstants#splita_qualifier}, {@link hconstants#splitb_qualifier} or
* {@link hconstants#regioninfo_qualifier}.
* @return an hregioninfo instance or null.
* @throws ioexception
*/
public static hregioninfo parsehregioninfofromcatalogresult final result r
byte  qualifier
throws ioexception
byte  bytes   r getvalue hconstants catalog_family  qualifier
if  bytes    null    bytes length <  0  return null
return writables gethregioninfoornull bytes
/**
* checks if the specified table exists.  looks at the meta table hosted on
* the specified server.
* @param catalogtracker
* @param tablename table to check
* @return true if the table exists in meta, false if not
* @throws ioexception
*/
public static boolean tableexists catalogtracker catalogtracker
string tablename
throws ioexception
if  tablename equals htabledescriptor root_tabledesc getnameasstring
tablename equals htabledescriptor meta_tabledesc getnameasstring
// catalog tables always exist.
return true
final byte  tablenamebytes   bytes tobytes tablename
// make a version of resultcollectingvisitor that only collects the first
collectingvisitor<hregioninfo> visitor   new collectingvisitor<hregioninfo>
private hregioninfo current   null
@override
public boolean visit result r  throws ioexception
this current
parsehregioninfofromcatalogresult r  hconstants regioninfo_qualifier
if  this current    null
log warn     r
return true
if   isinsidetable this current  tablenamebytes   return false
if  this current issplitparent    return true
// else call super and add this result to the collection.
super visit r
// stop collecting regions from table after we get one.
return false
@override
void add result r
// add the current hri.
this results add this current
fullscan catalogtracker  visitor  gettablestartrowformeta tablenamebytes
// if visitor has results >= 1 then table exists.
return visitor getresults   size   >  1
/**
* gets all of the regions of the specified table.
* @param catalogtracker
* @param tablename
* @return ordered list of {@link hregioninfo}.
* @throws ioexception
*/
public static list<hregioninfo> gettableregions catalogtracker catalogtracker
byte  tablename
throws ioexception
return gettableregions catalogtracker  tablename  false
/**
* gets all of the regions of the specified table.
* @param catalogtracker
* @param tablename
* @param excludeofflinedsplitparents if true, do not include offlined split
* parents in the return.
* @return ordered list of {@link hregioninfo}.
* @throws ioexception
*/
public static list<hregioninfo> gettableregions catalogtracker catalogtracker
byte  tablename  final boolean excludeofflinedsplitparents
throws ioexception
list<pair<hregioninfo  servername>> result   null
try
result   gettableregionsandlocations catalogtracker  tablename
excludeofflinedsplitparents
catch  interruptedexception e
throw new runtimeexception e
return getlistofhregioninfos result
static list<hregioninfo> getlistofhregioninfos final list<pair<hregioninfo  servername>> pairs
if  pairs    null    pairs isempty    return null
list<hregioninfo> result   new arraylist<hregioninfo> pairs size
for  pair<hregioninfo  servername> pair  pairs
result add pair getfirst
return result
/**
* @param current
* @param tablename
* @return true if <code>current</code> tablename is equal to
* <code>tablename</code>
*/
static boolean isinsidetable final hregioninfo current  final byte  tablename
return bytes equals tablename  current gettablename
/**
* @param tablename
* @return place to start scan in <code>.meta.</code> when passed a
* <code>tablename</code>; returns &lt;tablename&rt; &lt;,&rt; &lt;,&rt;
*/
static byte  gettablestartrowformeta final byte  tablename
byte  startrow   new byte
system arraycopy tablename  0  startrow  0  tablename length
startrow   hregioninfo delimiter
startrow   hregioninfo delimiter
return startrow
/**
* this method creates a scan object that will only scan catalog rows that
* belong to the specified table. it doesn't specify any columns.
* this is a better alternative to just using a start row and scan until
* it hits a new table since that requires parsing the hri to get the table
* name.
* @param tablename bytes of table's name
* @return configured scan object
*/
public static scan getscanfortablename byte tablename
string strname   bytes tostring tablename
// start key is just the table name with delimiters
byte startkey   bytes tobytes strname
// stop key appends the smallest possible char to the table name
byte stopkey   bytes tobytes strname
scan scan   new scan startkey
scan setstoprow stopkey
return scan
/**
* @param catalogtracker
* @param tablename
* @return return list of regioninfos and server.
* @throws ioexception
* @throws interruptedexception
*/
public static list<pair<hregioninfo  servername>>
gettableregionsandlocations catalogtracker catalogtracker  string tablename
throws ioexception  interruptedexception
return gettableregionsandlocations catalogtracker  bytes tobytes tablename
true
/**
* @param catalogtracker
* @param tablename
* @return return list of regioninfos and server addresses.
* @throws ioexception
* @throws interruptedexception
*/
public static list<pair<hregioninfo  servername>>
gettableregionsandlocations final catalogtracker catalogtracker
final byte  tablename  final boolean excludeofflinedsplitparents
throws ioexception  interruptedexception
if  bytes equals tablename  hconstants root_table_name
// if root, do a bit of special handling.
servername servername   catalogtracker getrootlocation
list<pair<hregioninfo  servername>> list
new arraylist<pair<hregioninfo  servername>>
list add new pair<hregioninfo  servername> hregioninfo root_regioninfo
servername
return list
// make a version of collectingvisitor that collects hregioninfo and serveraddress
collectingvisitor<pair<hregioninfo  servername>> visitor
new collectingvisitor<pair<hregioninfo  servername>>
private pair<hregioninfo  servername> current   null
@override
public boolean visit result r  throws ioexception
hregioninfo hri
parsehregioninfofromcatalogresult r  hconstants regioninfo_qualifier
if  hri    null
log warn     r
return true
if   isinsidetable hri  tablename   return false
if  excludeofflinedsplitparents    hri issplitparent    return true
servername sn   getservernamefromcatalogresult r
// populate this.current so available when we call #add
this current   new pair<hregioninfo  servername> hri  sn
// else call super and add this result to the collection.
return super visit r
@override
void add result r
this results add this current
fullscan catalogtracker  visitor  gettablestartrowformeta tablename
bytes equals tablename  hconstants meta_table_name
return visitor getresults
/**
* @param catalogtracker
* @param servername
* @return list of user regions installed on this server (does not include
* catalog regions).
* @throws ioexception
*/
public static navigablemap<hregioninfo  result>
getserveruserregions catalogtracker catalogtracker  final servername servername
throws ioexception
final navigablemap<hregioninfo  result> hris   new treemap<hregioninfo  result>
// fill the above hris map with entries from .meta. that have the passed
// servername.
collectingvisitor<result> v   new collectingvisitor<result>
@override
void add result r
if  r    null    r isempty    return
servername sn   getservernamefromcatalogresult r
if  sn    null    sn equals servername   this results add r
fullscan catalogtracker  v
list<result> results   v getresults
if  results    null     results isempty
// convert results to map keyed by hri
for  result r  results
pair<hregioninfo  servername> p   parsecatalogresult r
if  p    null    p getfirst      null  hris put p getfirst    r
return hris
public static void fullscanmetaandprint final catalogtracker catalogtracker
throws ioexception
visitor v   new visitor
@override
public boolean visit result r  throws ioexception
if  r     null    r isempty    return true
log info     r
hregioninfo hrim   metaeditor gethregioninfo r
log info     hrim
return true
fullscan catalogtracker  v
/**
* fully scan a given region, on a given server starting with given row.
* @param hregioninterface region server
* @param visitor visitor
* @param regionname name of region
* @param startrow start row
* @throws ioexception
* @deprecated does not retry; use fullscan xxx instead.
x
*/
public static void fullscan hregioninterface hregioninterface
visitor visitor  final byte regionname
byte startrow  throws ioexception
if  hregioninterface    null  return
scan scan   new scan
if  startrow    null  scan setstartrow startrow
scan addfamily hconstants catalog_family
long scannerid   hregioninterface openscanner regionname  scan
try
result data
while  data   hregioninterface next scannerid      null
if   data isempty    visitor visit data
finally
hregioninterface close scannerid
return
/**
* performs a full scan of a catalog table.
* @param catalogtracker
* @param visitor visitor invoked against each row.
* @param startrow where to start the scan. pass null if want to begin scan
* at first row.
* @param scanroot true if we are to scan <code>-root-</code> rather than
* <code>.meta.</code>, the default (pass false to scan .meta.)
* @throws ioexception
*/
static void fullscan catalogtracker catalogtracker
final visitor visitor  final byte  startrow  final boolean scanroot
throws ioexception
scan scan   new scan
if  startrow    null  scan setstartrow startrow
scan addfamily hconstants catalog_family
htable metatable   scanroot?
getroothtable catalogtracker   getmetahtable catalogtracker
resultscanner scanner   metatable getscanner scan
try
result data
while  data   scanner next       null
if  data isempty    continue
// break if visit returns false.
if   visitor visit data   break
finally
scanner close
metatable close
return
/**
* implementations 'visit' a catalog table row.
*/
public interface visitor
/**
* visit the catalog table row.
* @param r a row from catalog table
* @return true if we are to proceed scanning the table, else false if
* we are to stop now.
*/
public boolean visit final result r  throws ioexception
/**
* a {@link visitor} that collects content out of passed {@link result}.
*/
static abstract class collectingvisitor<t> implements visitor
final list<t> results   new arraylist<t>
@override
public boolean visit result r  throws ioexception
if  r     null    r isempty    return true
add r
return true
abstract void add result r
/**
* @return collected results; wait till visits complete to collect all
* possible results
*/
list<t> getresults
return this results
/**
* collects all returned.
*/
static class collectallvisitor extends collectingvisitor<result>
@override
void add result r
this results add r