/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase filter
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase keyvalue
import org apache hadoop hbase client scan
import org apache hadoop hbase filter comparefilter compareop
import org apache hadoop hbase io hbaseobjectwritable
import org apache hadoop hbase util bytes
import java io datainput
import java io dataoutput
import java io ioexception
import java util arrays
import java util list
import java util arraylist
import com google common base preconditions
/**
* this filter is used to filter cells based on value. it takes a {@link comparefilter.compareop}
* operator (equal, greater, not equal, etc), and either a byte [] value or
* a writablebytearraycomparable.
* <p>
* if we have a byte [] value then we just do a lexicographic compare. for
* example, if passed value is 'b' and cell has 'a' and the compare operator
* is less, then we will filter out this cell (return true).  if this is not
* sufficient (eg you want to deserialize a long and then compare it to a fixed
* long value), then you can pass in your own comparator instead.
* <p>
* you must also specify a family and qualifier.  only the value of this column
* will be tested. when using this filter on a {@link scan} with specified
* inputs, the column to be tested should also be added as input (otherwise
* the filter will regard the column as missing).
* <p>
* to prevent the entire row from being emitted if the column is not found
* on a row, use {@link #setfilterifmissing}.
* otherwise, if the column is found, the entire row will be emitted only if
* the value passes.  if the value fails, the row will be filtered out.
* <p>
* in order to test values of previous versions (timestamps), set
* {@link #setlatestversiononly} to false. the default is true, meaning that
* only the latest version's value is tested and all previous versions are ignored.
* <p>
* to filter based on the value of all scanned columns, use {@link valuefilter}.
*/
public class singlecolumnvaluefilter extends filterbase
static final log log   logfactory getlog singlecolumnvaluefilter class
protected byte  columnfamily
protected byte  columnqualifier
private compareop compareop
private writablebytearraycomparable comparator
private boolean foundcolumn   false
private boolean matchedcolumn   false
private boolean filterifmissing   false
private boolean latestversiononly   true
/**
* writable constructor, do not use.
*/
public singlecolumnvaluefilter
/**
* constructor for binary compare of the value of a single column.  if the
* column is found and the condition passes, all columns of the row will be
* emitted.  if the condition fails, the row will not be emitted.
* <p>
* use the filterifcolumnmissing flag to set whether the rest of the columns
* in a row will be emitted if the specified column to check is not found in
* the row.
*
* @param family name of column family
* @param qualifier name of column qualifier
* @param compareop operator
* @param value value to compare column values against
*/
public singlecolumnvaluefilter final byte  family  final byte  qualifier
final compareop compareop  final byte value
this family  qualifier  compareop  new binarycomparator value
/**
* constructor for binary compare of the value of a single column.  if the
* column is found and the condition passes, all columns of the row will be
* emitted.  if the condition fails, the row will not be emitted.
* <p>
* use the filterifcolumnmissing flag to set whether the rest of the columns
* in a row will be emitted if the specified column to check is not found in
* the row.
*
* @param family name of column family
* @param qualifier name of column qualifier
* @param compareop operator
* @param comparator comparator to use.
*/
public singlecolumnvaluefilter final byte  family  final byte  qualifier
final compareop compareop  final writablebytearraycomparable comparator
this columnfamily   family
this columnqualifier   qualifier
this compareop   compareop
this comparator   comparator
/**
* @return operator
*/
public compareop getoperator
return compareop
/**
* @return the comparator
*/
public writablebytearraycomparable getcomparator
return comparator
/**
* @return the family
*/
public byte getfamily
return columnfamily
/**
* @return the qualifier
*/
public byte getqualifier
return columnqualifier
public returncode filterkeyvalue keyvalue keyvalue
// system.out.println("remove key=" + keyvalue.tostring() + ", value=" + bytes.tostring(keyvalue.getvalue()));
if  this matchedcolumn
// we already found and matched the single column, all keys now pass
return returncode include
else if  this latestversiononly    this foundcolumn
// we found but did not match the single column, skip to next row
return returncode next_row
if   keyvalue matchingcolumn this columnfamily  this columnqualifier
return returncode include
foundcolumn   true
if  filtercolumnvalue keyvalue getbuffer
keyvalue getvalueoffset    keyvalue getvaluelength
return this latestversiononly? returncode next_row  returncode include
this matchedcolumn   true
return returncode include
private boolean filtercolumnvalue final byte  data  final int offset
final int length
int compareresult   this comparator compareto data  offset  length
switch  this compareop
case less
return compareresult <  0
case less_or_equal
return compareresult < 0
case equal
return compareresult    0
case not_equal
return compareresult    0
case greater_or_equal
return compareresult > 0
case greater
return compareresult >  0
default
throw new runtimeexception     compareop name
public boolean filterrow
// if column was found, return false if it was matched, true if it was not
// if column not found, return true if we filter if missing, false if not
return this foundcolumn?  this matchedcolumn  this filterifmissing
public void reset
foundcolumn   false
matchedcolumn   false
/**
* get whether entire row should be filtered if column is not found.
* @return true if row should be skipped if column not found, false if row
* should be let through anyways
*/
public boolean getfilterifmissing
return filterifmissing
/**
* set whether entire row should be filtered if column is not found.
* <p>
* if true, the entire row will be skipped if the column is not found.
* <p>
* if false, the row will pass if the column is not found.  this is default.
* @param filterifmissing flag
*/
public void setfilterifmissing boolean filterifmissing
this filterifmissing   filterifmissing
/**
* get whether only the latest version of the column value should be compared.
* if true, the row will be returned if only the latest version of the column
* value matches. if false, the row will be returned if any version of the
* column value matches. the default is true.
* @return return value
*/
public boolean getlatestversiononly
return latestversiononly
/**
* set whether only the latest version of the column value should be compared.
* if true, the row will be returned if only the latest version of the column
* value matches. if false, the row will be returned if any version of the
* column value matches. the default is true.
* @param latestversiononly flag
*/
public void setlatestversiononly boolean latestversiononly
this latestversiononly   latestversiononly
public static filter createfilterfromarguments arraylist<byte > filterarguments
preconditions checkargument filterarguments size      4    filterarguments size      6
filterarguments size
byte  family   parsefilter removequotesfrombytearray filterarguments get 0
byte  qualifier   parsefilter removequotesfrombytearray filterarguments get 1
compareop compareop   parsefilter createcompareop filterarguments get 2
writablebytearraycomparable comparator   parsefilter createcomparator
parsefilter removequotesfrombytearray filterarguments get 3
if  comparator instanceof regexstringcomparator
comparator instanceof substringcomparator
if  compareop    compareop equal
compareop    compareop not_equal
throw new illegalargumentexception
singlecolumnvaluefilter filter   new singlecolumnvaluefilter family  qualifier
compareop  comparator
if  filterarguments size      6
boolean filterifmissing   parsefilter convertbytearraytoboolean filterarguments get 4
boolean latestversiononly   parsefilter convertbytearraytoboolean filterarguments get 5
filter setfilterifmissing filterifmissing
filter setlatestversiononly latestversiononly
return filter
public void readfields final datainput in  throws ioexception
this columnfamily   bytes readbytearray in
if this columnfamily length    0
this columnfamily   null
this columnqualifier   bytes readbytearray in
if this columnqualifier length    0
this columnqualifier   null
this compareop   compareop valueof in readutf
this comparator
writablebytearraycomparable hbaseobjectwritable readobject in  null
this foundcolumn   in readboolean
this matchedcolumn   in readboolean
this filterifmissing   in readboolean
this latestversiononly   in readboolean
public void write final dataoutput out  throws ioexception
bytes writebytearray out  this columnfamily
bytes writebytearray out  this columnqualifier
out writeutf compareop name
hbaseobjectwritable writeobject out  comparator
writablebytearraycomparable class  null
out writeboolean foundcolumn
out writeboolean matchedcolumn
out writeboolean filterifmissing
out writeboolean latestversiononly
@override
public string tostring
return string format
this getclass   getsimplename    bytes tostringbinary this columnfamily
bytes tostringbinary this columnqualifier   this compareop name
bytes tostringbinary this comparator getvalue