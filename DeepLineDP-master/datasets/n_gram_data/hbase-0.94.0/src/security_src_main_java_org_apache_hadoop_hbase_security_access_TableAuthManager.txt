/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase security access
import com google common collect arraylistmultimap
import com google common collect listmultimap
import com google common collect lists
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop hbase keyvalue
import org apache hadoop hbase security user
import org apache hadoop hbase util bytes
import org apache hadoop hbase zookeeper zookeeperwatcher
import org apache zookeeper keeperexception
import java io
import java util hashmap
import java util list
import java util map
import java util concurrent concurrentskiplistmap
/**
* performs authorization checks for a given user's assigned permissions
*/
public class tableauthmanager
/** key for the user and group cache maps for globally assigned permissions */
private static final string global_cache_key
private static log log   logfactory getlog tableauthmanager class
private static tableauthmanager instance
/** cache of global user permissions */
private listmultimap<string permission> user_cache   arraylistmultimap create
/** cache of global group permissions */
private listmultimap<string permission> group_cache   arraylistmultimap create
private concurrentskiplistmap<byte  listmultimap<string tablepermission>> table_user_cache
new concurrentskiplistmap<byte  listmultimap<string tablepermission>> bytes bytes_comparator
private concurrentskiplistmap<byte  listmultimap<string tablepermission>> table_group_cache
new concurrentskiplistmap<byte  listmultimap<string tablepermission>> bytes bytes_comparator
private configuration conf
private zkpermissionwatcher zkperms
private tableauthmanager zookeeperwatcher watcher  configuration conf
throws ioexception
this conf   conf
this zkperms   new zkpermissionwatcher watcher  this  conf
try
this zkperms start
catch  keeperexception ke
log error    ke
// initialize global permissions based on configuration
initglobal conf
private void initglobal configuration conf  throws ioexception
user user   user getcurrent
if  user    null
throw new ioexception
string currentuser   user getshortname
// the system user is always included
list<string> superusers   lists aslist currentuser  conf getstrings
accesscontrollists superuser_conf_key  new string
if  superusers    null
for  string name   superusers
if  accesscontrollists isgroupprincipal name
group_cache put accesscontrollists getgroupname name
new permission permission action values
else
user_cache put name  new permission permission action values
public zkpermissionwatcher getzkpermissionwatcher
return this zkperms
public void refreshcachefromwritable byte table  byte data  throws ioexception
if  data    null    data length > 0
datainput in   new datainputstream  new bytearrayinputstream data
listmultimap<string tablepermission> perms   accesscontrollists readpermissions in  conf
cache table  perms
else
log debug
/**
* updates the internal permissions cache for a single table, splitting
* the permissions listed into separate caches for users and groups to optimize
* group lookups.
*
* @param table
* @param tableperms
*/
private void cache byte table
listmultimap<string tablepermission> tableperms
// split user from group assignments so we don't have to prepend the group
// prefix every time we query for groups
listmultimap<string tablepermission> userperms   arraylistmultimap create
listmultimap<string tablepermission> groupperms   arraylistmultimap create
if  tableperms    null
for  map entry<string tablepermission> entry   tableperms entries
if  accesscontrollists isgroupprincipal entry getkey
groupperms put
entry getkey   substring accesscontrollists group_prefix length
entry getvalue
else
userperms put entry getkey    entry getvalue
table_group_cache put table  groupperms
table_user_cache put table  userperms
private list<tablepermission> getuserpermissions string username  byte table
listmultimap<string  tablepermission> tableperms   table_user_cache get table
if  tableperms    null
return tableperms get username
return null
private list<tablepermission> getgrouppermissions string groupname  byte table
listmultimap<string  tablepermission> tableperms   table_group_cache get table
if  tableperms    null
return tableperms get groupname
return null
/**
* authorizes a global permission
* @param perms
* @param action
* @return
*/
private boolean authorize list<permission> perms  permission action action
if  perms    null
for  permission p   perms
if  p implies action
return true
else if  log isdebugenabled
log debug
return false
/**
* authorize a global permission based on acls for the given user and the
* user's groups.
* @param user
* @param action
* @return
*/
public boolean authorize user user  permission action action
if  user    null
return false
if  authorize user_cache get user getshortname     action
return true
string groups   user getgroupnames
if  groups    null
for  string group   groups
if  authorize group_cache get group   action
return true
return false
private boolean authorize list<tablepermission> perms  byte table  byte family
permission action action
return authorize perms  table  family  null  action
private boolean authorize list<tablepermission> perms  byte table  byte family
byte qualifier  permission action action
if  perms    null
for  tablepermission p   perms
if  p implies table  family  qualifier  action
return true
else if  log isdebugenabled
log debug   bytes tostringbinary table
return false
public boolean authorize user user  byte table  keyvalue kv
tablepermission action action
list<tablepermission> userperms   getuserpermissions
user getshortname    table
if  authorize userperms  table  kv  action
return true
string groupnames   user getgroupnames
if  groupnames    null
for  string group   groupnames
list<tablepermission> groupperms   getgrouppermissions group  table
if  authorize groupperms  table  kv  action
return true
return false
private boolean authorize list<tablepermission> perms  byte table  keyvalue kv
tablepermission action action
if  perms    null
for  tablepermission p   perms
if  p implies table  kv  action
return true
else if  log isdebugenabled
log debug
bytes tostringbinary table
return false
/**
* checks global authorization for a specific action for a user, based on the
* stored user permissions.
*/
public boolean authorizeuser string username  permission action action
return authorize user_cache get username   action
/**
* checks authorization to a given table and column family for a user, based on the
* stored user permissions.
*
* @param username
* @param table
* @param family
* @param action
* @return
*/
public boolean authorizeuser string username  byte table  byte family
permission action action
return authorizeuser username  table  family  null  action
public boolean authorizeuser string username  byte table  byte family
byte qualifier  permission action action
// global authorization supercedes table level
if  authorizeuser username  action
return true
return authorize getuserpermissions username  table   table  family
qualifier  action
/**
* checks authorization for a given action for a group, based on the stored
* permissions.
*/
public boolean authorizegroup string groupname  permission action action
return authorize group_cache get groupname   action
/**
* checks authorization to a given table and column family for a group, based
* on the stored permissions.
* @param groupname
* @param table
* @param family
* @param action
* @return
*/
public boolean authorizegroup string groupname  byte table  byte family
permission action action
// global authorization supercedes table level
if  authorizegroup groupname  action
return true
return authorize getgrouppermissions groupname  table   table  family  action
public boolean authorize user user  byte table  byte family
byte qualifier  permission action action
if  authorizeuser user getshortname    table  family  qualifier  action
return true
string groups   user getgroupnames
if  groups    null
for  string group   groups
if  authorizegroup group  table  family  action
return true
return false
public boolean authorize user user  byte table  byte family
permission action action
return authorize user  table  family  null  action
/**
* returns true if the given user has a {@link tablepermission} matching up
* to the column family portion of a permission.  note that this permission
* may be scoped to a given column qualifier and does not guarantee that
* authorize() on the same column family would return true.
*/
public boolean matchpermission user user
byte table  byte family  tablepermission action action
list<tablepermission> userperms   getuserpermissions
user getshortname    table
if  userperms    null
for  tablepermission p   userperms
if  p matchesfamily table  family  action
return true
string groups   user getgroupnames
if  groups    null
for  string group   groups
list<tablepermission> groupperms   getgrouppermissions group  table
if  groupperms    null
for  tablepermission p   groupperms
if  p matchesfamily table  family  action
return true
return false
public boolean matchpermission user user
byte table  byte family  byte qualifier
tablepermission action action
list<tablepermission> userperms   getuserpermissions
user getshortname    table
if  userperms    null
for  tablepermission p   userperms
if  p matchesfamilyqualifier table  family  qualifier  action
return true
string groups   user getgroupnames
if  groups    null
for  string group   groups
list<tablepermission> groupperms   getgrouppermissions group  table
if  groupperms    null
for  tablepermission p   groupperms
if  p matchesfamilyqualifier table  family  qualifier  action
return true
return false
public void remove byte table
table_user_cache remove table
table_group_cache remove table
/**
* overwrites the existing permission set for a given user for a table, and
* triggers an update for zookeeper synchronization.
* @param username
* @param table
* @param perms
*/
public void setuserpermissions string username  byte table
list<tablepermission> perms
listmultimap<string tablepermission> tableperms   table_user_cache get table
if  tableperms    null
tableperms   arraylistmultimap create
table_user_cache put table  tableperms
tableperms replacevalues username  perms
writetozookeeper table  tableperms  table_group_cache get table
/**
* overwrites the existing permission set for a group and triggers an update
* for zookeeper synchronization.
* @param group
* @param table
* @param perms
*/
public void setgrouppermissions string group  byte table
list<tablepermission> perms
listmultimap<string tablepermission> tableperms   table_group_cache get table
if  tableperms    null
tableperms   arraylistmultimap create
table_group_cache put table  tableperms
tableperms replacevalues group  perms
writetozookeeper table  table_user_cache get table   tableperms
public void writetozookeeper byte table
listmultimap<string tablepermission> userperms
listmultimap<string tablepermission> groupperms
listmultimap<string tablepermission> tmp   arraylistmultimap create
if  userperms    null
tmp putall userperms
if  groupperms    null
for  string group   groupperms keyset
tmp putall accesscontrollists group_prefix   group
groupperms get group
byte serialized   accesscontrollists writepermissionsasbytes tmp  conf
zkperms writetozookeeper bytes tostring table   serialized
static map<zookeeperwatcher tableauthmanager> managermap
new hashmap<zookeeperwatcher tableauthmanager>
public synchronized static tableauthmanager get
zookeeperwatcher watcher  configuration conf  throws ioexception
instance   managermap get watcher
if  instance    null
instance   new tableauthmanager watcher  conf
managermap put watcher  instance
return instance