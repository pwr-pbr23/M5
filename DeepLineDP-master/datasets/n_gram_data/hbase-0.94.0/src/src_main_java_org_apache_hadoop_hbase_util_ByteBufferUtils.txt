/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements. see the notice file distributed with this
* work for additional information regarding copyright ownership. the asf
* licenses this file to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
* http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis, without
* warranties or conditions of any kind, either express or implied. see the
* license for the specific language governing permissions and limitations
* under the license.
*/
package org apache hadoop hbase util
import java io datainput
import java io datainputstream
import java io ioexception
import java io inputstream
import java io outputstream
import java nio bytebuffer
import org apache hadoop hbase io encoding
encoderbuffertoosmallexception
import org apache hadoop io writableutils
/**
* utility functions for working with byte buffers, such as reading/writing
* variable-length long numbers.
*/
public final class bytebufferutils
// "compressed integer" serialization helper constants.
private final static int value_mask   0x7f
private final static int next_bit_shift   7
private final static int next_bit_mask   1 << 7
private bytebufferutils
/**
* similar to {@link writableutils#writevlong(java.io.dataoutput, long)},
* but writes to a {@link bytebuffer}.
*/
public static void writevlong bytebuffer out  long i
if  i >   112    i <  127
out put  byte  i
return
int len    112
if  i < 0
i ^   1l     take one's complement
len    120
long tmp   i
while  tmp    0
tmp   tmp >> 8
len
out put  byte  len
len    len <  120  ?   len   120      len   112
for  int idx   len  idx    0  idx
int shiftbits    idx   1    8
long mask   0xffl << shiftbits
out put  byte    i   mask  >> shiftbits
/**
* similar to {@link writableutils#readvlong(datainput)} but reads from a
* {@link bytebuffer}.
*/
public static long readvlong bytebuffer in
byte firstbyte   in get
int len   writableutils decodevintsize firstbyte
if  len    1
return firstbyte
long i   0
for  int idx   0  idx < len 1  idx
byte b   in get
i   i << 8
i   i    b   0xff
return  writableutils isnegativevint firstbyte  ?  i ^  1l    i
/**
* put in buffer integer using 7 bit encoding. for each written byte:
* 7 bits are used to store value
* 1 bit is used to indicate whether there is next bit.
* @param value int to be compressed.
* @param out where to put compressed data
* @return number of bytes written.
* @throws ioexception on stream error
*/
public static int putcompressedint outputstream out  final int value
throws ioexception
int i   0
int tmpvalue   value
do
byte b    byte   tmpvalue   value_mask
tmpvalue >>>  next_bit_shift
if  tmpvalue    0
b     byte  next_bit_mask
out write b
i
while  tmpvalue    0
return i
/**
* put in output stream 32 bit integer (big endian byte order).
* @param out where to put integer.
* @param value value of integer.
* @throws ioexception on stream error.
*/
public static void putint outputstream out  final int value
throws ioexception
for  int i   bytes sizeof_int   1  i >  0    i
out write  byte   value >>>  i   8
/**
* copy the data to the output stream and update position in buffer.
* @param out the stream to write bytes to
* @param in the buffer to read bytes from
* @param length the number of bytes to copy
*/
public static void movebuffertostream outputstream out  bytebuffer in
int length  throws ioexception
copybuffertostream out  in  in position    length
skip in  length
/**
* copy data from a buffer to an output stream. does not update the position
* in the buffer.
* @param out the stream to write bytes to
* @param in the buffer to read bytes from
* @param offset the offset in the buffer (from the buffer's array offset)
*      to start copying bytes from
* @param length the number of bytes to copy
*/
public static void copybuffertostream outputstream out  bytebuffer in
int offset  int length  throws ioexception
if  in hasarray
out write in array    in arrayoffset     offset
length
else
for  int i   0  i < length    i
out write in get offset   i
public static int putlong outputstream out  final long value
final int fitinbytes  throws ioexception
long tmpvalue   value
for  int i   0  i < fitinbytes    i
out write  byte   tmpvalue   0xff
tmpvalue >>>  8
return fitinbytes
/**
* check how many bytes are required to store value.
* @param value value which size will be tested.
* @return how many bytes are required to store value.
*/
public static int longfitsin final long value
if  value < 0
return 8
if  value <  1l << 4   8
// no more than 4 bytes
if  value <  1l << 2   8
if  value <  1l << 1   8
return 1
return 2
if  value <  1l << 3   8
return 3
return 4
// more than 4 bytes
if  value <  1l << 6   8
if  value <  1l << 5   8
return 5
return 6
if  value <  1l << 7   8
return 7
return 8
/**
* check how many bytes is required to store value.
* @param value value which size will be tested.
* @return how many bytes are required to store value.
*/
public static int intfitsin final int value
if  value < 0
return 4
if  value <  1 << 2   8
if  value <  1 << 1   8
return 1
return 2
if  value <   1 << 3   8
return 3
return 4
/**
* read integer from stream coded in 7 bits and increment position.
* @return the integer that has been read
* @throws ioexception
*/
public static int readcompressedint inputstream input
throws ioexception
int result   0
int i   0
byte b
do
b    byte  input read
result     b   value_mask  <<  next_bit_shift   i
i
if  i > bytes sizeof_int   1
throw new illegalstateexception
i   1
while  0     b   next_bit_mask
return result
/**
* read integer from buffer coded in 7 bits and increment position.
* @return read integer.
*/
public static int readcompressedint bytebuffer buffer
byte b   buffer get
if   b   next_bit_mask     0
return  b   value_mask     readcompressedint buffer  << next_bit_shift
return b   value_mask
/**
* read long which was written to fitinbytes bytes and increment position.
* @param fitinbytes in how many bytes given long is stored.
* @return the value of parsed long.
* @throws ioexception
*/
public static long readlong inputstream in  final int fitinbytes
throws ioexception
long tmplong   0
for  int i   0  i < fitinbytes    i
tmplong     in read     0xffl  <<  8   i
return tmplong
/**
* read long which was written to fitinbytes bytes and increment position.
* @param fitinbytes in how many bytes given long is stored.
* @return the value of parsed long.
*/
public static long readlong bytebuffer in  final int fitinbytes
long tmplength   0
for  int i   0  i < fitinbytes    i
tmplength     in get     0xffl  <<  8l   i
return tmplength
/**
* asserts that there is at least the given amount of unfilled space
* remaining in the given buffer.
* @param out typically, the buffer we are writing to
* @param length the required space in the buffer
* @throws encoderbuffertoosmallexception if there are no enough bytes.
*/
public static void ensurespace bytebuffer out  int length
throws encoderbuffertoosmallexception
if  out position     length > out limit
throw new encoderbuffertoosmallexception
out position
out limit
length
/**
* copy the given number of bytes from the given stream and put it at the
* current position of the given buffer, updating the position in the buffer.
* @param out the buffer to write data to
* @param in the stream to read data from
* @param length the number of bytes to read/write
*/
public static void copyfromstreamtobuffer bytebuffer out
datainputstream in  int length  throws ioexception
if  out hasarray
in readfully out array    out position     out arrayoffset
length
skip out  length
else
for  int i   0  i < length    i
out put in readbyte
/**
* copy from one buffer to another from given offset
* @param out destination buffer
* @param in source buffer
* @param sourceoffset offset in the source buffer
* @param length how many bytes to copy
*/
public static void copyfrombuffertobuffer bytebuffer out
bytebuffer in  int sourceoffset  int length
if  in hasarray      out hasarray
system arraycopy in array    sourceoffset   in arrayoffset
out array    out position
out arrayoffset    length
skip out  length
else
for  int i   0  i < length    i
out put in get sourceoffset   i
/**
* find length of common prefix of two parts in the buffer
* @param buffer where parts are located.
* @param offsetleft offset of the first part.
* @param offsetright offset of the second part.
* @param limit maximal length of common prefix.
* @return length of prefix.
*/
public static int findcommonprefix bytebuffer buffer  int offsetleft
int offsetright  int limit
int prefix   0
for    prefix < limit    prefix
if  buffer get offsetleft   prefix     buffer get offsetright   prefix
break
return prefix
/**
* find length of common prefix in two arrays.
* @param left array to be compared.
* @param leftoffset offset in left array.
* @param leftlength length of left array.
* @param right array to be compared.
* @param rightarray offset in right array.
* @param rightlength length of right array.
*/
public static int findcommonprefix
byte left  int leftoffset  int leftlength
byte right  int rightoffset  int rightlength
int length   math min leftlength  rightlength
int result   0
while  result < length
left    right
result
return result
/**
* check whether two parts in the same buffer are equal.
* @param buffer in which buffer there are parts
* @param offsetleft beginning of first part.
* @param lengthleft length of the first part.
* @param offsetright beginning of the second part.
* @param lengthright length of the second part.
* @return
*/
public static boolean arepartsequal bytebuffer buffer
int offsetleft  int lengthleft
int offsetright  int lengthright
if  lengthleft    lengthright
return false
if  buffer hasarray
return 0    bytes compareto
buffer array    buffer arrayoffset     offsetleft  lengthleft
buffer array    buffer arrayoffset     offsetright  lengthright
for  int i   0  i < lengthright    i
if  buffer get offsetleft   i     buffer get offsetright   i
return false
return true
/**
* increment position in buffer.
* @param buffer in this buffer.
* @param length by that many bytes.
*/
public static void skip bytebuffer buffer  int length
buffer position buffer position     length