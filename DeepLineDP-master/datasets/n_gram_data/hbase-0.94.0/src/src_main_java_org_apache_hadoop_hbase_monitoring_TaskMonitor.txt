/**
* copyright 2011 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase monitoring
import java io printwriter
import java lang ref weakreference
import java lang reflect invocationhandler
import java lang reflect method
import java lang reflect proxy
import java util arraylist
import java util iterator
import java util list
import org apache commons logging log
import org apache commons logging logfactory
import com google common annotations visiblefortesting
import com google common collect lists
/**
* singleton which keeps track of tasks going on in this vm.
* a task here is anything which takes more than a few seconds
* and the user might want to inquire about the status
*/
public class taskmonitor
private static final log log   logfactory getlog taskmonitor class
// don't keep around any tasks that have completed more than
// 60 seconds ago
private static final long expiration_time   60 1000
@visiblefortesting
static final int max_tasks   1000
private static taskmonitor instance
private list<taskandweakrefpair> tasks
lists newarraylist
/**
* get singleton instance.
* todo this would be better off scoped to a single daemon
*/
public static synchronized taskmonitor get
if  instance    null
instance   new taskmonitor
return instance
public synchronized monitoredtask createstatus string description
monitoredtask stat   new monitoredtaskimpl
stat setdescription description
monitoredtask proxy    monitoredtask  proxy newproxyinstance
stat getclass   getclassloader
new class<?>   monitoredtask class
new passthroughinvocationhandler<monitoredtask> stat
taskandweakrefpair pair   new taskandweakrefpair stat  proxy
synchronized  this
tasks add pair
return proxy
public synchronized monitoredrpchandler createrpcstatus string description
monitoredrpchandler stat   new monitoredrpchandlerimpl
stat setdescription description
monitoredrpchandler proxy    monitoredrpchandler  proxy newproxyinstance
stat getclass   getclassloader
new class<?>   monitoredrpchandler class
new passthroughinvocationhandler<monitoredrpchandler> stat
taskandweakrefpair pair   new taskandweakrefpair stat  proxy
synchronized  this
tasks add pair
return proxy
private synchronized void purgeexpiredtasks
int size   0
for  iterator<taskandweakrefpair> it   tasks iterator
it hasnext
taskandweakrefpair pair   it next
monitoredtask stat   pair get
if  pair isdead
// the class who constructed this leaked it. so we can
// assume it's done.
if  stat getstate      monitoredtaskimpl state running
log warn     stat
stat cleanup
if  canpurge stat
it remove
else
size
if  size > max_tasks
log warn
tasks   tasks sublist size   max_tasks  size
/**
* produces a list containing copies of the current state of all non-expired
* monitoredtasks handled by this taskmonitor.
* @return a complete list of monitoredtasks.
*/
public synchronized list<monitoredtask> gettasks
purgeexpiredtasks
arraylist<monitoredtask> ret   lists newarraylistwithcapacity tasks size
for  taskandweakrefpair pair   tasks
monitoredtask t   pair get
ret add t clone
return ret
private boolean canpurge monitoredtask stat
long cts   stat getcompletiontimestamp
return  cts > 0    system currenttimemillis     cts > expiration_time
public void dumpastext printwriter out
long now   system currenttimemillis
list<monitoredtask> tasks   gettasks
for  monitoredtask task   tasks
out println     task getdescription
out println     task getstate         task getstatus
long running    now   task getstarttime    1000
if  task getcompletiontimestamp       1
long completed    now   task getcompletiontimestamp      1000
out println     completed
out println
task getcompletiontimestamp     task getstarttime    1000
else
out println     running
out println
/**
* this class encapsulates an object as well as a weak reference to a proxy
* that passes through calls to that object. in art form:
* <code>
*     proxy  <------------------
*       |                       \
*       v                        \
* passthroughinvocationhandler   |  weak reference
*       |                       /
* monitoredtaskimpl            /
*       |                     /
* statandweakrefproxy  ------/
*
* since we only return the proxy to the creator of the monitorablestatus,
* this means that they can leak that object, and we'll detect it
* since our weak reference will go null. but, we still have the actual
* object, so we can log it and display it as a leaked (incomplete) action.
*/
private static class taskandweakrefpair
private monitoredtask impl
private weakreference<monitoredtask> weakproxy
public taskandweakrefpair monitoredtask stat
monitoredtask proxy
this impl   stat
this weakproxy   new weakreference<monitoredtask> proxy
public monitoredtask get
return impl
public boolean isdead
return weakproxy get      null
/**
* an invocationhandler that simply passes through calls to the original
* object.
*/
private static class passthroughinvocationhandler<t> implements invocationhandler
private t delegatee
public passthroughinvocationhandler t delegatee
this delegatee   delegatee
@override
public object invoke object proxy  method method  object args
throws throwable
return method invoke delegatee  args