/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver
import java io ioexception
import org apache hadoop hbase hconstants
import org apache hadoop hbase keyvalue
import org apache hadoop hbase regionserver scanquerymatcher matchcode
import org apache hadoop hbase util bytes
/**
* keeps track of the columns for a scan if they are not explicitly specified
*/
public class scanwildcardcolumntracker implements columntracker
private byte  columnbuffer   null
private int columnoffset   0
private int columnlength   0
private int currentcount   0
private int maxversions
private int minversions
/* keeps track of the latest timestamp and type included for current column.
* used to eliminate duplicates. */
private long latesttsofcurrentcolumn
private byte latesttypeofcurrentcolumn
private long oldeststamp
/**
* return maxversions of every row.
* @param minversion minimum number of versions to keep
* @param maxversion maximum number of versions to return
* @param oldestunexpiredts oldest timestamp that has not expired according
*          to the ttl.
*/
public scanwildcardcolumntracker int minversion  int maxversion
long oldestunexpiredts
this maxversions   maxversion
this minversions   minversion
this oldeststamp   oldestunexpiredts
/**
* {@inheritdoc}
* this receives puts *and* deletes.
* deletes do not count as a version, but rather take the version
* of the previous put (so eventually all but the last can be reclaimed).
*/
@override
public matchcode checkcolumn byte bytes  int offset  int length
long timestamp  byte type  boolean ignorecount  throws ioexception
if  columnbuffer    null
// first iteration.
resetbuffer bytes  offset  length
if  ignorecount  return scanquerymatcher matchcode include
// do not count a delete marker as another version
return checkversion type  timestamp
int cmp   bytes compareto bytes  offset  length
columnbuffer  columnoffset  columnlength
if  cmp    0
if  ignorecount  return scanquerymatcher matchcode include
//if column matches, check if it is a duplicate timestamp
if  sameasprevioustsandtype timestamp  type
return scanquerymatcher matchcode skip
return checkversion type  timestamp
resettsandtype
// new col > old col
if  cmp > 0
// switched columns, lets do something.x
resetbuffer bytes  offset  length
if  ignorecount  return scanquerymatcher matchcode include
return checkversion type  timestamp
// new col < oldcol
// warning: this means that very likely an edit for some other family
// was incorrectly stored into the store for this one. throw an exception,
// because this might lead to data corruption.
throw new ioexception
bytes tostringbinary bytes  offset  length
private void resetbuffer byte bytes  int offset  int length
columnbuffer   bytes
columnoffset   offset
columnlength   length
currentcount   0
/**
* check whether this version should be retained.
* there are 4 variables considered:
* if this version is past max versions -> skip it
* if this kv has expired or was deleted, check min versions
* to decide whther to skip it or not.
*
* increase the version counter unless this is a delete
*/
private matchcode checkversion byte type  long timestamp
if   keyvalue isdelete type
currentcount
if  currentcount > maxversions
return scanquerymatcher matchcode seek_next_col     skip to next col
// keep the kv if required by minversions or it is not expired, yet
if  currentcount <  minversions     isexpired timestamp
settsandtype timestamp  type
return scanquerymatcher matchcode include
else
return matchcode seek_next_col
@override
public void update
// no-op, shouldn't even be called
throw new unsupportedoperationexception
@override
public void reset
columnbuffer   null
resettsandtype
private void resettsandtype
latesttsofcurrentcolumn   hconstants latest_timestamp
latesttypeofcurrentcolumn   0
private void settsandtype long timestamp  byte type
latesttsofcurrentcolumn   timestamp
latesttypeofcurrentcolumn   type
private boolean sameasprevioustsandtype long timestamp  byte type
return timestamp    latesttsofcurrentcolumn    type    latesttypeofcurrentcolumn
private boolean isexpired long timestamp
return timestamp < oldeststamp
/**
* used by matcher and scan/get to get a hint of the next column
* to seek to after checkcolumn() returns skip.  returns the next interesting
* column we want, or null there is none (wildcard scanner).
*
* @return the column count.
*/
public columncount getcolumnhint
return null
/**
* we can never know a-priori if we are done, so always return false.
* @return false
*/
@override
public boolean done
return false
public matchcode getnextrowornextcolumn byte bytes  int offset
int quallength
return matchcode seek_next_col
public boolean isdone long timestamp
return minversions <  0    isexpired timestamp