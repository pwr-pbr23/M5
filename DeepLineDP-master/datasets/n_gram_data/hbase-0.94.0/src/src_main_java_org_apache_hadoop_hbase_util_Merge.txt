/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop conf configured
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hbase hbaseconfiguration
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase keyvalue
import org apache hadoop hbase masternotrunningexception
import org apache hadoop hbase zookeeperconnectionexception
import org apache hadoop hbase client delete
import org apache hadoop hbase client get
import org apache hadoop hbase client hbaseadmin
import org apache hadoop hbase regionserver hregion
import org apache hadoop hbase regionserver wal hlog
import org apache hadoop io writablecomparator
import org apache hadoop util genericoptionsparser
import org apache hadoop util tool
import org apache hadoop util toolrunner
import java io ioexception
import java util list
/**
* utility that can merge any two regions in the same table: adjacent,
* overlapping or disjoint.
*/
public class merge extends configured implements tool
static final log log   logfactory getlog merge class
private path rootdir
private volatile metautils utils
private byte  tablename                   name of table
private volatile byte  region1            name of region 1
private volatile byte  region2            name of region 2
private volatile boolean ismetatable
private volatile hregioninfo mergeinfo
/** default constructor */
public merge
super
/**
* @param conf configuration
*/
public merge configuration conf
this mergeinfo   null
setconf conf
public int run string args  throws exception
if  parseargs args     0
return  1
// verify file system is up.
filesystem fs   filesystem get getconf                     get dfs handle
log info
try
fsutils checkfilesystemavailable fs
catch  ioexception e
log fatal    e
return  1
// verify hbase is down
log info
try
hbaseadmin checkhbaseavailable getconf
log fatal
return  1
catch  zookeeperconnectionexception zkce
// if no zk, presume no master.
catch  masternotrunningexception e
// expected. ignore.
// initialize metautils and and get the root of the hbase installation
this utils   new metautils getconf
this rootdir   fsutils getrootdir getconf
try
if  ismetatable
mergetwometaregions
else
mergetworegions
return 0
catch  exception e
log fatal    e
utils scanmetaregion hregioninfo first_meta_regioninfo
new metautils scannerlistener
public boolean processrow hregioninfo info
system err println info tostring
return true
return  1
finally
if  this utils    null
this utils shutdown
/** @return hregioninfo for merge result */
hregioninfo getmergedhregioninfo
return this mergeinfo
/*
* merge two meta regions. this is unlikely to be needed soon as we have only
* seend the meta table split once and that was with 64mb regions. with 256mb
* regions, it will be some time before someone has enough data in hbase to
* split the meta region and even less likely that a merge of two meta
* regions will be needed, but it is included for completeness.
*/
private void mergetwometaregions   throws ioexception
hregion rootregion   utils getrootregion
get get   new get region1
get addcolumn hconstants catalog_family  hconstants regioninfo_qualifier
list<keyvalue> cells1    rootregion get get  null  list
hregioninfo info1   writables gethregioninfo  cells1    null ? null  cells1 get 0  getvalue
get   new get region2
get addcolumn hconstants catalog_family  hconstants regioninfo_qualifier
list<keyvalue> cells2    rootregion get get  null  list
hregioninfo info2   writables gethregioninfo  cells2    null ? null  cells2 get 0  getvalue
hregion merged   merge htabledescriptor meta_tabledesc  info1  rootregion  info2  rootregion
log info     merged getregioninfo
rootregion getregioninfo
hregion addregiontometa rootregion  merged
merged close
private static class metascannerlistener
implements metautils scannerlistener
private final byte  region1
private final byte  region2
private hregioninfo meta1   null
private hregioninfo meta2   null
metascannerlistener final byte  region1  final byte  region2
this region1   region1
this region2   region2
public boolean processrow hregioninfo info
if  meta1    null    hregion rowisinrange info  region1
meta1   info
if  region2    null    meta2    null
hregion rowisinrange info  region2
meta2   info
return meta1    null     region2    null    meta2    null
hregioninfo getmeta1
return meta1
hregioninfo getmeta2
return meta2
/*
* merges two regions from a user table.
*/
private void mergetworegions   throws ioexception
log info     bytes tostringbinary this region1
bytes tostringbinary this region2        bytes tostring this tablename
// scan the root region for all the meta regions that contain the regions
// we're merging.
metascannerlistener listener   new metascannerlistener region1  region2
this utils scanrootregion listener
hregioninfo meta1   listener getmeta1
if  meta1    null
throw new ioexception     bytes tostringbinary region1
hregioninfo meta2   listener getmeta2
if  meta2    null
throw new ioexception     bytes tostringbinary region2
log info     bytes tostringbinary meta1 getregionname
bytes tostringbinary meta2 getregionname
hregion metaregion1   this utils getmetaregion meta1
get get   new get region1
get addcolumn hconstants catalog_family  hconstants regioninfo_qualifier
list<keyvalue> cells1    metaregion1 get get  null  list
hregioninfo info1
writables gethregioninfo  cells1    null ? null  cells1 get 0  getvalue
if  info1    null
throw new nullpointerexception
bytes tostringbinary region1        meta1
hregion metaregion2
if  bytes equals meta1 getregionname    meta2 getregionname
metaregion2   metaregion1
else
metaregion2   utils getmetaregion meta2
get   new get region2
get addcolumn hconstants catalog_family  hconstants regioninfo_qualifier
list<keyvalue> cells2    metaregion2 get get  null  list
hregioninfo info2   writables gethregioninfo  cells2    null ? null  cells2 get 0  getvalue
if  info2    null
throw new nullpointerexception     meta2
htabledescriptor htd   fstabledescriptors gettabledescriptor filesystem get getconf
this rootdir  this tablename
hregion merged   merge htd  info1  metaregion1  info2  metaregion2
// now find the meta region which will contain the newly merged region
listener   new metascannerlistener merged getregionname    null
utils scanrootregion listener
hregioninfo mergedinfo   listener getmeta1
if  mergedinfo    null
throw new ioexception
bytes tostringbinary merged getregionname
hregion mergemeta
if  bytes equals mergedinfo getregionname    meta1 getregionname
mergemeta   metaregion1
else if  bytes equals mergedinfo getregionname    meta2 getregionname
mergemeta   metaregion2
else
mergemeta   utils getmetaregion mergedinfo
log info     merged getregioninfo
mergemeta getregioninfo
hregion addregiontometa mergemeta  merged
merged close
/*
* actually merge two regions and update their info in the meta region(s)
* if the meta is split, meta1 may be different from meta2. (and we may have
* to scan the meta if the resulting merged region does not go in either)
* returns hregion object for newly merged region
*/
private hregion merge final htabledescriptor htd  hregioninfo info1
hregion meta1  hregioninfo info2  hregion meta2
throws ioexception
if  info1    null
throw new ioexception     bytes tostringbinary region1
bytes tostringbinary meta1 getregionname
if  info2    null
throw new ioexception     bytes tostringbinary region2
bytes tostringbinary meta2 getregionname
hregion merged   null
hlog log   utils getlog
hregion r1   hregion openhregion info1  htd  log  getconf
try
hregion r2   hregion openhregion info2  htd  log  getconf
try
merged   hregion merge r1  r2
finally
if   r2 isclosed
r2 close
finally
if   r1 isclosed
r1 close
// remove the old regions from meta.
// hregion.merge has already deleted their files
removeregionfrommeta meta1  info1
removeregionfrommeta meta2  info2
this mergeinfo   merged getregioninfo
return merged
/*
* removes a region's meta information from the passed <code>meta</code>
* region.
*
* @param meta meta hregion to be updated
* @param regioninfo hregioninfo of region to remove from <code>meta</code>
*
* @throws ioexception
*/
private void removeregionfrommeta hregion meta  hregioninfo regioninfo
throws ioexception
if  log isdebugenabled
log debug     regioninfo       meta
delete delete    new delete regioninfo getregionname
system currenttimemillis    null
meta delete delete  null  true
/*
* adds a region's meta information from the passed <code>meta</code>
* region.
*
* @param metainfo meta hregioninfo to be updated
* @param region hregion to add to <code>meta</code>
*
* @throws ioexception
*/
private int parseargs string args  throws ioexception
genericoptionsparser parser
new genericoptionsparser getconf    args
string remainingargs   parser getremainingargs
if  remainingargs length    3
usage
return  1
tablename   bytes tobytes remainingargs
ismetatable   bytes compareto tablename  hconstants meta_table_name     0
region1   bytes tobytesbinary remainingargs
region2   bytes tobytesbinary remainingargs
int status   0
if  notintable tablename  region1     notintable tablename  region2
status    1
else if  bytes equals region1  region2
log error
status    1
return status
private boolean notintable final byte  tn  final byte  rn
if  writablecomparator comparebytes tn  0  tn length  rn  0  tn length     0
log error     bytes tostringbinary rn
bytes tostring tn
return true
return false
private void usage
system err println
public static void main string args
int status
try
status   toolrunner run hbaseconfiguration create    new merge    args
catch  exception e
log error    e
status    1
system exit status