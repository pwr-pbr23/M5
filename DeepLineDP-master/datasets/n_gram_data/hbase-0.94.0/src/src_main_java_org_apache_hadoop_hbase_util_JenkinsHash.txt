/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import static java lang integer rotateleft
import java io fileinputstream
import java io ioexception
/**
* produces 32-bit hash for hash table lookup.
*
* <pre>lookup3.c, by bob jenkins, may 2006, public domain.
*
* you can use this free for any purpose.  it's in the public domain.
* it has no warranty.
* </pre>
*
* @see <a href="http://burtleburtle.net/bob/c/lookup3.c">lookup3.c</a>
* @see <a href="http://www.ddj.com/184410284">hash functions (and how this
* function compares to others such as crc, md?, etc</a>
* @see <a href="http://burtleburtle.net/bob/hash/doobs.html">has update on the
* dr. dobbs article</a>
*/
public class jenkinshash extends hash
private static final int byte_mask   0xff
private static jenkinshash _instance   new jenkinshash
public static hash getinstance
return _instance
/**
* taken from  hashlittle() -- hash a variable-length key into a 32-bit value
*
* @param key the key (the unaligned variable-length array of bytes)
* @param nbytes number of bytes to include in hash
* @param initval can be any integer value
* @return a 32-bit value.  every bit of the key affects every bit of the
* return value.  two keys differing by one or two bits will have totally
* different hash values.
*
* <p>the best hash table sizes are powers of 2.  there is no need to do mod
* a prime (mod is sooo slow!).  if you need less than 32 bits, use a bitmask.
* for example, if you need only 10 bits, do
* <code>h = (h & hashmask(10));</code>
* in which case, the hash table should have hashsize(10) elements.
*
* <p>if you are hashing n strings byte[][] k, do it like this:
* for (int i = 0, h = 0; i < n; ++i) h = hash( k[i], h);
*
* <p>by bob jenkins, 2006.  bob_jenkins@burtleburtle.net.  you may use this
* code any way you wish, private, educational, or commercial.  it's free.
*
* <p>use for hash table lookup, or anything where one collision in 2^^32 is
* acceptable.  do not use for cryptographic purposes.
*/
@override
@suppresswarnings
public int hash byte key  int off  int nbytes  int initval
int length   nbytes
int a  b  c
a   b   c   0xdeadbeef   length   initval
int offset   off
for    length > 12  offset    12  length    12
a     key   byte_mask
a      key   byte_mask  <<  8
a      key   byte_mask  << 16
a      key   byte_mask  << 24
b     key   byte_mask
b      key   byte_mask  <<  8
b      key   byte_mask  << 16
b      key   byte_mask  << 24
c     key   byte_mask
c      key   byte_mask  <<  8
c      key   byte_mask  << 16
c      key   byte_mask  << 24
/*
* mix -- mix 3 32-bit values reversibly.
* this is reversible, so any information in (a,b,c) before mix() is
* still in (a,b,c) after mix().
*
* if four pairs of (a,b,c) inputs are run through mix(), or through
* mix() in reverse, there are at least 32 bits of the output that
* are sometimes the same for one pair and different for another pair.
*
* this was tested for:
* - pairs that differed by one bit, by two bits, in any combination
*   of top bits of (a,b,c), or in any combination of bottom bits of
*   (a,b,c).
* - "differ" is defined as +, -, ^, or ~^.  for + and -, i transformed
*   the output delta to a gray code (a^(a>>1)) so a string of 1's (as
*    is commonly produced by subtraction) look like a single 1-bit
*    difference.
* - the base values were pseudorandom, all zero but one bit set, or
*   all zero plus a counter that starts at zero.
*
* some k values for my "a-=c; a^=rot(c,k); c+=b;" arrangement that
* satisfy this are
*     4  6  8 16 19  4
*     9 15  3 18 27 15
*    14  9  3  7 17  3
* well, "9 15 3 18 27 15" didn't quite get 32 bits diffing for
* "differ" defined as + with a one-bit base and a two-bit delta.  i
* used http://burtleburtle.net/bob/hash/avalanche.html to choose
* the operations, constants, and arrangements of the variables.
*
* this does not achieve avalanche.  there are input bits of (a,b,c)
* that fail to affect some output bits of (a,b,c), especially of a.
* the most thoroughly mixed value is c, but it doesn't really even
* achieve avalanche in c.
*
* this allows some parallelism.  read-after-writes are good at doubling
* the number of bits affected, so the goal of mixing pulls in the
* opposite direction as the goal of parallelism.  i did what i could.
* rotates seem to cost as much as shifts on every machine i could lay
* my hands on, and rotates are much kinder to the top and bottom bits,
* so i used rotates.
*
* #define mix(a,b,c) \
* { \
*   a -= c;  a ^= rot(c, 4);  c += b; \
*   b -= a;  b ^= rot(a, 6);  a += c; \
*   c -= b;  c ^= rot(b, 8);  b += a; \
*   a -= c;  a ^= rot(c,16);  c += b; \
*   b -= a;  b ^= rot(a,19);  a += c; \
*   c -= b;  c ^= rot(b, 4);  b += a; \
* }
*
* mix(a,b,c);
*/
a    c  a ^  rotateleft c  4   c    b
b    a  b ^  rotateleft a  6   a    c
c    b  c ^  rotateleft b  8   b    a
a    c  a ^  rotateleft c  16   c    b
b    a  b ^  rotateleft a  19   a    c
c    b  c ^  rotateleft b  4   b    a
//-------------------------------- last block: affect all 32 bits of (c)
switch  length                         all the case statements fall through
case 12
c      key   byte_mask  << 24
case 11
c      key   byte_mask  << 16
case 10
c      key   byte_mask  <<  8
case  9
c     key   byte_mask
case  8
b      key   byte_mask  << 24
case  7
b      key   byte_mask  << 16
case  6
b      key   byte_mask  <<  8
case  5
b     key   byte_mask
case  4
a      key   byte_mask  << 24
case  3
a      key   byte_mask  << 16
case  2
a      key   byte_mask  <<  8
case  1
//noinspection pointlessarithmeticexpression
a     key   byte_mask
break
case  0
return c
/*
* final -- final mixing of 3 32-bit values (a,b,c) into c
*
* pairs of (a,b,c) values differing in only a few bits will usually
* produce values of c that look totally different.  this was tested for
* - pairs that differed by one bit, by two bits, in any combination
*   of top bits of (a,b,c), or in any combination of bottom bits of
*   (a,b,c).
*
* - "differ" is defined as +, -, ^, or ~^.  for + and -, i transformed
*   the output delta to a gray code (a^(a>>1)) so a string of 1's (as
*   is commonly produced by subtraction) look like a single 1-bit
*   difference.
*
* - the base values were pseudorandom, all zero but one bit set, or
*   all zero plus a counter that starts at zero.
*
* these constants passed:
*   14 11 25 16 4 14 24
*   12 14 25 16 4 14 24
* and these came close:
*    4  8 15 26 3 22 24
*   10  8 15 26 3 22 24
*   11  8 15 26 3 22 24
*
* #define final(a,b,c) \
* {
*   c ^= b; c -= rot(b,14); \
*   a ^= c; a -= rot(c,11); \
*   b ^= a; b -= rot(a,25); \
*   c ^= b; c -= rot(b,16); \
*   a ^= c; a -= rot(c,4);  \
*   b ^= a; b -= rot(a,14); \
*   c ^= b; c -= rot(b,24); \
* }
*
*/
c ^  b  c    rotateleft b  14
a ^  c  a    rotateleft c  11
b ^  a  b    rotateleft a  25
c ^  b  c    rotateleft b  16
a ^  c  a    rotateleft c  4
b ^  a  b    rotateleft a  14
c ^  b  c    rotateleft b  24
return c
/**
* compute the hash of the specified file
* @param args name of file to compute hash of.
* @throws ioexception e
*/
public static void main string args  throws ioexception
if  args length    1
system err println
system exit  1
fileinputstream in   new fileinputstream args
byte bytes   new byte
int value   0
jenkinshash hash   new jenkinshash
for  int length   in read bytes   length > 0  length   in read bytes
value   hash hash bytes  length  value
system out println math abs value