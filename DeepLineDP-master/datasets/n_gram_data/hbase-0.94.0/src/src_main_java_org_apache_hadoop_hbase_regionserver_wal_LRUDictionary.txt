/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver wal
import java util hashmap
import org apache hadoop classification interfaceaudience
import org apache hadoop hbase util bytes
import com google common base preconditions
/**
* waldictionary using an lru eviction algorithm. uses a linked list running
* through a hashtable.  currently has max of 2^15 entries.  will start
* evicting if exceeds this number  the maximum memory we expect this dictionary
* to take in the worst case is about:
* <code>(2 ^ 15) * 5 (regionname, row key, cf, column qual, table) * 100 bytes (these are some big names) = ~16mb</code>.
* if you want to get silly, even at 1kb entries, it maxes out at 160 megabytes.
*/
@interfaceaudience private
public class lrudictionary implements dictionary
private final bidirectionallrumap backingstore   new bidirectionallrumap
@override
public byte getentry short idx
return backingstore get idx
@override
public short findentry byte data  int offset  int length
short ret   backingstore findidx data  offset  length
if  ret    not_in_dictionary
addentry data  offset  length
return ret
@override
public short addentry byte data  int offset  int length
if  length <  0  return not_in_dictionary
return backingstore put data  offset  length
@override
public void clear
backingstore clear
/*
* internal class used to implement lru eviction and dual lookup (by key and
* value).
*
* this is not thread safe. don't use in multi-threaded applications.
*/
static class bidirectionallrumap
static final int max_size   short max_value
private int currsize   0
// head and tail of the lru list.
private node head
private node tail
private hashmap<node  short> nodetoindex   new hashmap<node  short>
private node indextonode   new node
public bidirectionallrumap
for  int i   0  i < max_size  i
indextonode   new node
private short put byte array  int offset  int length
// we copy the bytes we want, otherwise we might be holding references to
// massive arrays in our dictionary (or those arrays might change)
byte stored   new byte
bytes putbytes stored  0  array  offset  length
if  currsize < max_size
// there is space to add without evicting.
indextonode setcontents stored  0  stored length
sethead indextonode
short ret    short  currsize
nodetoindex put indextonode  ret
return ret
else
short s   nodetoindex remove tail
tail setcontents stored  0  stored length
// we need to rehash this.
nodetoindex put tail  s
movetohead tail
return s
private short findidx byte array  int offset  int length
short s
final node comparisonnode   new node
comparisonnode setcontents array  offset  length
if   s   nodetoindex get comparisonnode      null
movetohead indextonode
return s
else
return  1
private byte get short idx
preconditions checkelementindex idx  currsize
movetohead indextonode
return indextonode container
private void movetohead node n
if  head    n
// no-op -- it's already the head.
return
// at this point we definitely have prev, since it's not the head.
assert n prev    null
// unlink prev.
n prev next   n next
// unlink next
if  n next    null
n next prev   n prev
else
assert n    tail
tail   n prev
// node is now removed from the list. re-add it at the head.
sethead n
private void sethead node n
// assume it's already unlinked from the list at this point.
n prev   null
n next   head
if  head    null
assert head prev    null
head prev   n
head   n
// first entry
if  tail    null
tail   n
private void clear
currsize   0
nodetoindex clear
tail   null
head   null
for  node n   indextonode
n container   null
for  int i   0  i < max_size  i
indextonode next   null
indextonode prev   null
private static class node
byte container
int offset
int length
node next     link towards the tail
node prev     link towards the head
public node
private void setcontents byte container  int offset  int length
this container   container
this offset   offset
this length   length
@override
public int hashcode
return bytes hashcode container  offset  length
@override
public boolean equals object other
if    other instanceof node
return false
node casted    node  other
return bytes equals container  offset  length  casted container
casted offset  casted length