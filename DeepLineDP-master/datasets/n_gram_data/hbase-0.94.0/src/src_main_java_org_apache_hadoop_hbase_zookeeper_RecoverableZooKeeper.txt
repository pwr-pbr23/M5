/**
* copyright 2011 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase zookeeper
import java io ioexception
import java lang management managementfactory
import java util arraylist
import java util list
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase util bytes
import org apache hadoop hbase util retrycounter
import org apache hadoop hbase util retrycounterfactory
import org apache zookeeper asynccallback
import org apache zookeeper createmode
import org apache zookeeper keeperexception
import org apache zookeeper watcher
import org apache zookeeper zookeeper
import org apache zookeeper zookeeper states
import org apache zookeeper data acl
import org apache zookeeper data stat
/**
* a zookeeper that can handle 'recoverable' errors.
* to handle recoverable errors, developers need to realize that there are two
* classes of requests: idempotent and non-idempotent requests. read requests
* and unconditional sets and deletes are examples of idempotent requests, they
* can be reissued with the same results.
* (although, the delete may throw a nonodeexception on reissue its effect on
* the zookeeper state is the same.) non-idempotent requests need special
* handling, application and library writers need to keep in mind that they may
* need to encode information in the data or name of znodes to detect
* retries. a simple example is a create that uses a sequence flag.
* if a process issues a create("/x-", ..., sequence) and gets a connection
* loss exception, that process will reissue another
* create("/x-", ..., sequence) and get back x-111. when the process does a
* getchildren("/"), it sees x-1,x-30,x-109,x-110,x-111, now it could be
* that x-109 was the result of the previous create, so the process actually
* owns both x-109 and x-111. an easy way around this is to use "x-process id-"
* when doing the create. if the process is using an id of 352, before reissuing
* the create it will do a getchildren("/") and see "x-222-1", "x-542-30",
* "x-352-109", x-333-110". the process will know that the original create
* succeeded an the znode it created is "x-352-109".
* @see "http://wiki.apache.org/hadoop/zookeeper/errorhandling"
*/
public class recoverablezookeeper
private static final log log   logfactory getlog recoverablezookeeper class
// the actual zookeeper client instance
private zookeeper zk
private final retrycounterfactory retrycounterfactory
// an identifier of this process in the cluster
private final string identifier
private final byte id
private int retryintervalmillis
// the metadata attached to each piece of data has the
// format:
//   <magic> 1-byte constant
//   <id length> 4-byte big-endian integer (length of next field)
//   <id> identifier corresponding uniquely to this process
// it is prepended to the data supplied by the user.
// the magic number is to be backward compatible
private static final byte magic   byte  0xff
private static final int magic_size   bytes sizeof_byte
private static final int id_length_offset   magic_size
private static final int id_length_size    bytes sizeof_int
public recoverablezookeeper string quorumservers  int seesiontimeout
watcher watcher  int maxretries  int retryintervalmillis
throws ioexception
this zk   new zookeeper quorumservers  seesiontimeout  watcher
this retrycounterfactory
new retrycounterfactory maxretries  retryintervalmillis
this retryintervalmillis   retryintervalmillis
// the identifier = processid@hostname
this identifier   managementfactory getruntimemxbean   getname
log info     identifier
this id   bytes tobytes identifier
/**
* delete is an idempotent operation. retry before throwing exception.
* this function will not throw nonodeexception if the path does not
* exist.
*/
public void delete string path  int version
throws interruptedexception  keeperexception
retrycounter retrycounter   retrycounterfactory create
boolean isretry   false     false for first attempt  true for all retries
while  true
try
zk delete path  version
return
catch  keeperexception e
switch  e code
case nonode
if  isretry
log info     path
return
log warn     path
throw e
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
isretry   true
/**
* exists is an idempotent operation. retry before throwing exception
* @return a stat instance
*/
public stat exists string path  watcher watcher
throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
while  true
try
return zk exists path  watcher
catch  keeperexception e
switch  e code
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
/**
* exists is an idempotent operation. retry before throwing exception
* @return a stat instance
*/
public stat exists string path  boolean watch
throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
while  true
try
return zk exists path  watch
catch  keeperexception e
switch  e code
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
private void retryorthrow retrycounter retrycounter  keeperexception e
string opname  throws keeperexception
log warn     e
if   retrycounter shouldretry
log error     opname
retrycounter getmaxretries
throw e
/**
* getchildren is an idempotent operation. retry before throwing exception
* @return list of children znodes
*/
public list<string> getchildren string path  watcher watcher
throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
while  true
try
return zk getchildren path  watcher
catch  keeperexception e
switch  e code
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
/**
* getchildren is an idempotent operation. retry before throwing exception
* @return list of children znodes
*/
public list<string> getchildren string path  boolean watch
throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
while  true
try
return zk getchildren path  watch
catch  keeperexception e
switch  e code
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
/**
* getdata is an idempotent operation. retry before throwing exception
* @return data
*/
public byte getdata string path  watcher watcher  stat stat
throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
while  true
try
byte revdata   zk getdata path  watcher  stat
return this removemetadata revdata
catch  keeperexception e
switch  e code
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
/**
* getdata is an idemnpotent operation. retry before throwing exception
* @return data
*/
public byte getdata string path  boolean watch  stat stat
throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
while  true
try
byte revdata   zk getdata path  watch  stat
return this removemetadata revdata
catch  keeperexception e
switch  e code
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
/**
* setdata is not an idempotent operation. retry may cause badversion exception
* adding an identifier field into the data to check whether
* badversion is caused by the result of previous correctly setdata
* @return stat instance
*/
public stat setdata string path  byte data  int version
throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
byte newdata   appendmetadata data
while  true
try
return zk setdata path  newdata  version
catch  keeperexception e
switch  e code
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
case badversion
// try to verify whether the previous setdata success or not
try
stat stat   new stat
byte revdata   zk getdata path  false  stat
int idlength   bytes toint revdata  id_length_size
int datalength   revdata length id_length_size idlength
int dataoffset   id_length_size idlength
if bytes compareto revdata  id_length_size  id length
revdata  dataoffset  datalength     0
// the bad version is caused by previous successful setdata
return stat
catch keeperexception keeperexception
// the zk is not reliable at this moment. just throwing exception
throw keeperexception
// throw other exceptions and verified bad version exceptions
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
/**
* <p>
* nonsequential create is idempotent operation.
* retry before throwing exceptions.
* but this function will not throw the nodeexist exception back to the
* application.
* </p>
* <p>
* but sequential is not idempotent operation. it is necessary to add
* identifier to the path to verify, whether the previous one is successful
* or not.
* </p>
*
* @return path
*/
public string create string path  byte data  list<acl> acl
createmode createmode
throws keeperexception  interruptedexception
byte newdata   appendmetadata data
switch  createmode
case ephemeral
case persistent
return createnonsequential path  newdata  acl  createmode
case ephemeral_sequential
case persistent_sequential
return createsequential path  newdata  acl  createmode
default
throw new illegalargumentexception
createmode
private string createnonsequential string path  byte data  list<acl> acl
createmode createmode  throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
boolean isretry   false     false for first attempt  true for all retries
while  true
try
return zk create path  data  acl  createmode
catch  keeperexception e
switch  e code
case nodeexists
if  isretry
// if the connection was lost, there is still a possibility that
// we have successfully created the node at our previous attempt,
// so we read the node and compare.
byte currentdata   zk getdata path  false  null
if  currentdata    null
bytes compareto currentdata  data     0
// we successfully created a non-sequential node
return path
log error     path
bytes tostringbinary currentdata
bytes tostringbinary data
throw e
log error     path
throw e
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
isretry   true
private string createsequential string path  byte data
list<acl> acl  createmode createmode
throws keeperexception  interruptedexception
retrycounter retrycounter   retrycounterfactory create
boolean first   true
string newpath   path this identifier
while  true
try
if   first
// check if we succeeded on a previous attempt
string previousresult   findprevioussequentialnode newpath
if  previousresult    null
return previousresult
first   false
return zk create newpath  data  acl  createmode
catch  keeperexception e
switch  e code
case connectionloss
case operationtimeout
retryorthrow retrycounter  e
break
default
throw e
retrycounter sleepuntilnextretry
retrycounter useretry
private string findprevioussequentialnode string path
throws keeperexception  interruptedexception
int lastslashidx   path lastindexof
assert lastslashidx     1
string parent   path substring 0  lastslashidx
string nodeprefix   path substring lastslashidx 1
list<string> nodes   zk getchildren parent  false
list<string> matching   filterbyprefix nodes  nodeprefix
for  string node   matching
string nodepath   parent       node
stat stat   zk exists nodepath  false
if  stat    null
return nodepath
return null
public byte removemetadata byte data
if data    null    data length    0
return data
// check the magic data; to be backward compatible
byte magic   data
if magic    magic
return data
int idlength   bytes toint data  id_length_offset
int datalength   data length magic_size id_length_size idlength
int dataoffset   magic_size id_length_size idlength
byte newdata   new byte
system arraycopy data  dataoffset  newdata  0  datalength
return newdata
private byte appendmetadata byte data
if data    null    data length    0
return data
byte newdata   new byte
int pos   0
pos   bytes putbyte newdata  pos  magic
pos   bytes putint newdata  pos  id length
pos   bytes putbytes newdata  pos  id  0  id length
pos   bytes putbytes newdata  pos  data  0  data length
return newdata
public long getsessionid
return zk getsessionid
public void close   throws interruptedexception
zk close
public states getstate
return zk getstate
public zookeeper getzookeeper
return zk
public byte getsessionpasswd
return zk getsessionpasswd
public void sync string path  asynccallback voidcallback cb  object ctx
this zk sync path  null  null
/**
* filters the given node list by the given prefixes.
* this method is all-inclusive--if any element in the node list starts
* with any of the given prefixes, then it is included in the result.
*
* @param nodes the nodes to filter
* @param prefixes the prefixes to include in the result
* @return list of every element that starts with one of the prefixes
*/
private static list<string> filterbyprefix list<string> nodes
string    prefixes
list<string> lockchildren   new arraylist<string>
for  string child   nodes
for  string prefix   prefixes
if  child startswith prefix
lockchildren add child
break
return lockchildren