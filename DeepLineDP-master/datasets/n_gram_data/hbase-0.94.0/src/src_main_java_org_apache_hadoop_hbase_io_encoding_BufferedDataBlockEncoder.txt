/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements. see the notice file distributed with this
* work for additional information regarding copyright ownership. the asf
* licenses this file to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
* http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis, without
* warranties or conditions of any kind, either express or implied. see the
* license for the specific language governing permissions and limitations
* under the license.
*/
package org apache hadoop hbase io encoding
import java io datainputstream
import java io dataoutputstream
import java io ioexception
import java nio bytebuffer
import org apache hadoop hbase keyvalue
import org apache hadoop hbase keyvalue sameprefixcomparator
import org apache hadoop hbase util bytebufferutils
import org apache hadoop hbase util bytes
import org apache hadoop io rawcomparator
import org apache hadoop io writableutils
/**
* base class for all data block encoders that use a buffer.
*/
abstract class buffereddatablockencoder implements datablockencoder
private static int initial_key_buffer_size   512
@override
public bytebuffer uncompresskeyvalues datainputstream source
boolean includesmemstorets  throws ioexception
return uncompresskeyvalues source  0  0  includesmemstorets
protected static class seekerstate
protected int valueoffset    1
protected int keylength
protected int valuelength
protected int lastcommonprefix
/** we need to store a copy of the key. */
protected byte keybuffer   new byte
protected long memstorets
protected int nextkvoffset
protected boolean isvalid
return valueoffset     1
protected void invalidate
valueoffset    1
protected void ensurespaceforkey
if  keylength > keybuffer length
// rare case, but we need to handle arbitrary length of key
int newkeybufferlength   math max keybuffer length  1    2
while  keylength > newkeybufferlength
newkeybufferlength    2
byte newkeybuffer   new byte
system arraycopy keybuffer  0  newkeybuffer  0  keybuffer length
keybuffer   newkeybuffer
/**
* copy the state from the next one into this instance (the previous state
* placeholder). used to save the previous state when we are advancing the
* seeker to the next key/value.
*/
protected void copyfromnext seekerstate nextstate
if  keybuffer length    nextstate keybuffer length
keybuffer   nextstate keybuffer clone
else if   isvalid
// note: we can only call isvalid before we override our state, so this
// comes before all the assignments at the end of this method.
system arraycopy nextstate keybuffer  0  keybuffer  0
nextstate keylength
else
// don't copy the common prefix between this key and the previous one
system arraycopy nextstate keybuffer  nextstate lastcommonprefix
keybuffer  nextstate lastcommonprefix  nextstate keylength
nextstate lastcommonprefix
valueoffset   nextstate valueoffset
keylength   nextstate keylength
valuelength   nextstate valuelength
lastcommonprefix   nextstate lastcommonprefix
nextkvoffset   nextstate nextkvoffset
memstorets   nextstate memstorets
protected abstract static class
bufferedencodedseeker<state extends seekerstate>
implements encodedseeker
protected final rawcomparator<byte> comparator
protected final sameprefixcomparator<byte> sameprefixcomparator
protected bytebuffer currentbuffer
protected state current   createseekerstate       always valid
protected state previous   createseekerstate       may not be valid
@suppresswarnings
public bufferedencodedseeker rawcomparator<byte> comparator
this comparator   comparator
if  comparator instanceof sameprefixcomparator
this sameprefixcomparator    sameprefixcomparator<byte>  comparator
else
this sameprefixcomparator   null
@override
public void setcurrentbuffer bytebuffer buffer
currentbuffer   buffer
decodefirst
previous invalidate
@override
public bytebuffer getkeydeepcopy
bytebuffer keybuffer   bytebuffer allocate current keylength
keybuffer put current keybuffer  0  current keylength
return keybuffer
@override
public bytebuffer getvalueshallowcopy
return bytebuffer wrap currentbuffer array
currentbuffer arrayoffset     current valueoffset
current valuelength
@override
public bytebuffer getkeyvaluebuffer
bytebuffer kvbuffer   bytebuffer allocate
2   bytes sizeof_int   current keylength   current valuelength
kvbuffer putint current keylength
kvbuffer putint current valuelength
kvbuffer put current keybuffer  0  current keylength
kvbuffer put currentbuffer array
currentbuffer arrayoffset     current valueoffset
current valuelength
return kvbuffer
@override
public keyvalue getkeyvalue
bytebuffer kvbuf   getkeyvaluebuffer
keyvalue kv   new keyvalue kvbuf array    kvbuf arrayoffset
kv setmemstorets current memstorets
return kv
@override
public void rewind
currentbuffer rewind
decodefirst
previous invalidate
@override
public boolean next
if   currentbuffer hasremaining
return false
decodenext
previous invalidate
return true
@override
public int seektokeyinblock byte key  int offset  int length
boolean seekbefore
int commonprefix   0
previous invalidate
do
int comp
if  sameprefixcomparator    null
commonprefix   math min commonprefix  current lastcommonprefix
// extend commonprefix
commonprefix    bytebufferutils findcommonprefix
key  offset   commonprefix  length   commonprefix
current keybuffer  commonprefix
current keylength   commonprefix
comp   sameprefixcomparator compareignoringprefix commonprefix  key
offset  length  current keybuffer  0  current keylength
else
comp   comparator compare key  offset  length
current keybuffer  0  current keylength
if  comp    0       exact match
if  seekbefore
if   previous isvalid
// the caller (seekbefore) has to ensure that we are not at the
// first key in the block.
throw new illegalstateexception
bytes tostringbinary key  offset  length
movetoprevious
return 1
return 0
if  comp < 0       already too large  check previous
if  previous isvalid
movetoprevious
return 1
// move to next, if more data is available
if  currentbuffer hasremaining
previous copyfromnext current
decodenext
else
break
while  true
// we hit the end of the block, not an exact match
return 1
private void movetoprevious
if   previous isvalid
throw new illegalstateexception
state tmp   previous
previous   current
current   tmp
// move after last key value
currentbuffer position current nextkvoffset
previous invalidate
@suppresswarnings
protected state createseekerstate
// this will fail for non-default seeker state if the subclass does not
// override this method.
return  state  new seekerstate
abstract protected void decodefirst
abstract protected void decodenext
protected final void afterencodingkeyvalue bytebuffer in
dataoutputstream out  boolean includesmemstorets
if  includesmemstorets
// copy memstore timestamp from the byte buffer to the output stream.
long memstorets    1
try
memstorets   bytebufferutils readvlong in
writableutils writevlong out  memstorets
catch  ioexception ex
throw new runtimeexception
memstorets
protected final void afterdecodingkeyvalue datainputstream source
bytebuffer dest  boolean includesmemstorets
if  includesmemstorets
long memstorets    1
try
// copy memstore timestamp from the data input stream to the byte
// buffer.
memstorets   writableutils readvlong source
bytebufferutils writevlong dest  memstorets
catch  ioexception ex
throw new runtimeexception
memstorets