/**
* copyright 2011 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver compactions
import java io ioexception
import java util list
import java util concurrent rejectedexecutionhandler
import java util concurrent threadpoolexecutor
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase remoteexceptionhandler
import org apache hadoop hbase regionserver hregion
import org apache hadoop hbase regionserver hregionserver
import org apache hadoop hbase regionserver store
import org apache hadoop hbase regionserver storefile
import org apache hadoop hbase util environmentedgemanager
import org apache hadoop util stringutils
import com google common base function
import com google common base joiner
import com google common base preconditions
import com google common base predicate
import com google common collect collections2
/**
* this class holds all details necessary to run a compaction.
*/
public class compactionrequest implements comparable<compactionrequest>
runnable
static final log log   logfactory getlog compactionrequest class
private final hregion r
private final store s
private final compactselection compactselection
private final long totalsize
private final boolean ismajor
private int p
private final long timeinnanos
private hregionserver server   null
public compactionrequest hregion r  store s
compactselection files  boolean ismajor  int p
preconditions checknotnull r
preconditions checknotnull files
this r   r
this s   s
this compactselection   files
long sz   0
for  storefile sf   files getfilestocompact
sz    sf getreader   length
this totalsize   sz
this ismajor   ismajor
this p   p
this timeinnanos   system nanotime
public void finishrequest
this compactselection finishrequest
/**
* this function will define where in the priority queue the request will
* end up.  those with the highest priorities will be first.  when the
* priorities are the same it will first compare priority then date
* to maintain a fifo functionality.
*
* <p>note: the date is only accurate to the millisecond which means it is
* possible that two requests were inserted into the queue within a
* millisecond.  when that is the case this function will break the tie
* arbitrarily.
*/
@override
public int compareto compactionrequest request
//note: the head of the priority queue is the least element
if  this equals request
return 0    they are the same request
int compareval
compareval   p   request p    compare priority
if  compareval    0
return compareval
compareval   timeinnanos compareto request timeinnanos
if  compareval    0
return compareval
// break the tie based on hash code
return this hashcode     request hashcode
/** gets the hregion for the request */
public hregion gethregion
return r
/** gets the store for the request */
public store getstore
return s
/** gets the compact selection object for the request */
public compactselection getcompactselection
return compactselection
/** gets the storefiles for the request */
public list<storefile> getfiles
return compactselection getfilestocompact
/** gets the total size of all storefiles in compaction */
public long getsize
return totalsize
public boolean ismajor
return this ismajor
/** gets the priority for the request */
public int getpriority
return p
/** gets the priority for the request */
public void setpriority int p
this p   p
public void setserver hregionserver hrs
this server   hrs
@override
public string tostring
string fslist   joiner on    join
collections2 transform collections2 filter
compactselection getfilestocompact
new predicate<storefile>
public boolean apply storefile sf
return sf getreader      null
new function<storefile  string>
public string apply storefile sf
return stringutils humanreadableint sf getreader   length
return     r getregionnameasstring
new string s getfamily   getname
compactselection getfilestocompact   size
stringutils humanreadableint totalsize
fslist isempty    ?         fslist
p       timeinnanos
@override
public void run
preconditions checknotnull server
if  server isstopped
return
try
long start   environmentedgemanager currenttimemillis
boolean completed   r compact this
long now   environmentedgemanager currenttimemillis
log info   completed  ?
this       stringutils formattimediff now  start
if  completed
server getmetrics   addcompaction now   start  this totalsize
// degenerate case: blocked regions require recursive enqueues
if  s getcompactpriority   <  0
server compactsplitthread
requestcompaction r  s
else
// see if the compaction has caused us to exceed max region size
server compactsplitthread requestsplit r
catch  ioexception ex
log error     this  remoteexceptionhandler
checkioexception ex
server checkfilesystem
catch  exception ex
log error     this  ex
server checkfilesystem
finally
s finishrequest this
log debug     server compactsplitthread
/**
* cleanup class to use when rejecting a compaction request from the queue.
*/
public static class rejection implements rejectedexecutionhandler
@override
public void rejectedexecution runnable request  threadpoolexecutor pool
if  request instanceof compactionrequest
compactionrequest cr    compactionrequest  request
log debug     cr
cr getstore   finishrequest cr