/**
* copyright 2009 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase io hfile
import java io ioexception
import java nio bytebuffer
import org apache hadoop hbase keyvalue
/**
* a scanner allows you to position yourself within a hfile and
* scan through it.  it allows you to reposition yourself as well.
*
* <p>a scanner doesn't always have a key/value that it is pointing to
* when it is first created and before
* {@link #seekto()}/{@link #seekto(byte[])} are called.
* in this case, {@link #getkey()}/{@link #getvalue()} returns null.  at most
* other times, a key and value will be available.  the general pattern is that
* you position the scanner using the seekto variants and then getkey and
* getvalue.
*/
public interface hfilescanner
/**
* seekto or just before the passed <code>key</code>.  examine the return
* code to figure whether we found the key or not.
* consider the key stream of all the keys in the file,
* <code>k[0] .. k[n]</code>, where there are n keys in the file.
* @param key key to find.
* @return -1, if key < k[0], no position;
* 0, such that k[i] = key and scanner is left in position i; and
* 1, such that k[i] < key, and scanner is left in position i.
* the scanner will position itself between k[i] and k[i+1] where
* k[i] < key <= k[i+1].
* if there is no key k[i+1] greater than or equal to the input key, then the
* scanner will position itself at the end of the file and next() will return
* false when it is called.
* @throws ioexception
*/
public int seekto byte key  throws ioexception
public int seekto byte key  int offset  int length  throws ioexception
/**
* reseek to or just before the passed <code>key</code>. similar to seekto
* except that this can be called even if the scanner is not at the beginning
* of a file.
* this can be used to seek only to keys which come after the current position
* of the scanner.
* consider the key stream of all the keys in the file,
* <code>k[0] .. k[n]</code>, where there are n keys in the file after
* current position of hfilescanner.
* the scanner will position itself between k[i] and k[i+1] where
* k[i] < key <= k[i+1].
* if there is no key k[i+1] greater than or equal to the input key, then the
* scanner will position itself at the end of the file and next() will return
* false when it is called.
* @param key key to find (should be non-null)
* @return -1, if key < k[0], no position;
* 0, such that k[i] = key and scanner is left in position i; and
* 1, such that k[i] < key, and scanner is left in position i.
* @throws ioexception
*/
public int reseekto byte key  throws ioexception
public int reseekto byte key  int offset  int length  throws ioexception
/**
* consider the key stream of all the keys in the file,
* <code>k[0] .. k[n]</code>, where there are n keys in the file.
* @param key key to find
* @return false if key <= k[0] or true with scanner in position 'i' such
* that: k[i] < key.  furthermore: there may be a k[i+1], such that
* k[i] < key <= k[i+1] but there may also not be a k[i+1], and next() will
* return false (eof).
* @throws ioexception
*/
public boolean seekbefore byte  key  throws ioexception
public boolean seekbefore byte key  int offset  int length  throws ioexception
/**
* positions this scanner at the start of the file.
* @return false if empty file; i.e. a call to next would return false and
* the current key and value are undefined.
* @throws ioexception
*/
public boolean seekto   throws ioexception
/**
* scans to the next entry in the file.
* @return returns false if you are at the end otherwise true if more in file.
* @throws ioexception
*/
public boolean next   throws ioexception
/**
* gets a buffer view to the current key. you must call
* {@link #seekto(byte[])} before this method.
* @return byte buffer for the key. the limit is set to the key size, and the
* position is 0, the start of the buffer view.
*/
public bytebuffer getkey
/**
* gets a buffer view to the current value.  you must call
* {@link #seekto(byte[])} before this method.
*
* @return byte buffer for the value. the limit is set to the value size, and
* the position is 0, the start of the buffer view.
*/
public bytebuffer getvalue
/**
* @return instance of {@link keyvalue}.
*/
public keyvalue getkeyvalue
/**
* convenience method to get a copy of the key as a string - interpreting the
* bytes as utf8. you must call {@link #seekto(byte[])} before this method.
* @return key as a string
*/
public string getkeystring
/**
* convenience method to get a copy of the value as a string - interpreting
* the bytes as utf8. you must call {@link #seekto(byte[])} before this method.
* @return value as a string
*/
public string getvaluestring
/**
* @return reader that underlies this scanner instance.
*/
public hfile reader getreader
/**
* @return true is scanner has had one of the seek calls invoked; i.e.
* {@link #seekbefore(byte[])} or {@link #seekto()} or {@link #seekto(byte[])}.
* otherwise returns false.
*/
public boolean isseeked