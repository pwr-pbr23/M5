/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import java io closeable
import java io ioexception
import java util list
import org apache hadoop conf configuration
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase keyvalue
import org apache hadoop hbase client coprocessor batch
import org apache hadoop hbase ipc coprocessorprotocol
import java util map
/**
* used to communicate with a single hbase table.
*
* @since 0.21.0
*/
public interface htableinterface extends closeable
/**
* gets the name of this table.
*
* @return the table name.
*/
byte gettablename
/**
* returns the {@link configuration} object used by this instance.
* <p>
* the reference returned is not a copy, so any change made to it will
* affect this instance.
*/
configuration getconfiguration
/**
* gets the {@link htabledescriptor table descriptor} for this table.
* @throws ioexception if a remote or network exception occurs.
*/
htabledescriptor gettabledescriptor   throws ioexception
/**
* test for the existence of columns in the table, as specified in the get.
* <p>
*
* this will return true if the get matches one or more keys, false if not.
* <p>
*
* this is a server-side call so it prevents any data from being transfered to
* the client.
*
* @param get the get
* @return true if the specified get matches one or more keys, false if not
* @throws ioexception e
*/
boolean exists get get  throws ioexception
/**
* method that does a batch call on deletes, gets and puts. the ordering of
* execution of the actions is not defined. meaning if you do a put and a
* get in the same {@link #batch} call, you will not necessarily be
* guaranteed that the get returns what the put had put.
*
* @param actions list of get, put, delete objects
* @param results empty object[], same size as actions. provides access to partial
*                results, in case an exception is thrown. a null in the result array means that
*                the call for that action failed, even after retries
* @throws ioexception
* @since 0.90.0
*/
void batch final list<?extends row> actions  final object results  throws ioexception  interruptedexception
/**
* same as {@link #batch(list, object[])}, but returns an array of
* results instead of using a results parameter reference.
*
* @param actions list of get, put, delete objects
* @return the results from the actions. a null in the return array means that
*         the call for that action failed, even after retries
* @throws ioexception
* @since 0.90.0
*/
object batch final list<? extends row> actions  throws ioexception  interruptedexception
/**
* extracts certain cells from a given row.
* @param get the object that specifies what data to fetch and from which row.
* @return the data coming from the specified row, if it exists.  if the row
* specified doesn't exist, the {@link result} instance returned won't
* contain any {@link keyvalue}, as indicated by {@link result#isempty()}.
* @throws ioexception if a remote or network exception occurs.
* @since 0.20.0
*/
result get get get  throws ioexception
/**
* extracts certain cells from the given rows, in batch.
*
* @param gets the objects that specify what data to fetch and from which rows.
*
* @return the data coming from the specified rows, if it exists.  if the row
*         specified doesn't exist, the {@link result} instance returned won't
*         contain any {@link keyvalue}, as indicated by {@link result#isempty()}.
*         if there are any failures even after retries, there will be a null in
*         the results array for those gets, and an exception will be thrown.
* @throws ioexception if a remote or network exception occurs.
*
* @since 0.90.0
*/
result get list<get> gets  throws ioexception
/**
* return the row that matches <i>row</i> exactly,
* or the one that immediately precedes it.
*
* @param row a row key.
* @param family column family to include in the {@link result}.
* @throws ioexception if a remote or network exception occurs.
* @since 0.20.0
*
* @deprecated as of version 0.92 this method is deprecated without
* replacement.
* getroworbefore is used internally to find entries in .meta. and makes
* various assumptions about the table (which are true for .meta. but not
* in general) to be efficient.
*/
result getroworbefore byte row  byte family  throws ioexception
/**
* returns a scanner on the current table as specified by the {@link scan}
* object.
* note that the passed {@link scan}'s start row and caching properties
* maybe changed.
*
* @param scan a configured {@link scan} object.
* @return a scanner.
* @throws ioexception if a remote or network exception occurs.
* @since 0.20.0
*/
resultscanner getscanner scan scan  throws ioexception
/**
* gets a scanner on the current table for the given family.
*
* @param family the column family to scan.
* @return a scanner.
* @throws ioexception if a remote or network exception occurs.
* @since 0.20.0
*/
resultscanner getscanner byte family  throws ioexception
/**
* gets a scanner on the current table for the given family and qualifier.
*
* @param family the column family to scan.
* @param qualifier the column qualifier to scan.
* @return a scanner.
* @throws ioexception if a remote or network exception occurs.
* @since 0.20.0
*/
resultscanner getscanner byte family  byte qualifier  throws ioexception
/**
* puts some data in the table.
* <p>
* if {@link #isautoflush isautoflush} is false, the update is buffered
* until the internal buffer is full.
* @param put the data to put.
* @throws ioexception if a remote or network exception occurs.
* @since 0.20.0
*/
void put put put  throws ioexception
/**
* puts some data in the table, in batch.
* <p>
* if {@link #isautoflush isautoflush} is false, the update is buffered
* until the internal buffer is full.
* <p>
* this can be used for group commit, or for submitting user defined
* batches.  the writebuffer will be periodically inspected while the list
* is processed, so depending on the list size the writebuffer may flush
* not at all, or more than once.
* @param puts the list of mutations to apply. the batch put is done by
* aggregating the iteration of the puts over the write buffer
* at the client-side for a single rpc call.
* @throws ioexception if a remote or network exception occurs.
* @since 0.20.0
*/
void put list<put> puts  throws ioexception
/**
* atomically checks if a row/family/qualifier value matches the expected
* value. if it does, it adds the put.  if the passed value is null, the check
* is for the lack of column (ie: non-existance)
*
* @param row to check
* @param family column family to check
* @param qualifier column qualifier to check
* @param value the expected value
* @param put data to put if check succeeds
* @throws ioexception e
* @return true if the new put was executed, false otherwise
*/
boolean checkandput byte row  byte family  byte qualifier
byte value  put put  throws ioexception
/**
* deletes the specified cells/row.
*
* @param delete the object that specifies what to delete.
* @throws ioexception if a remote or network exception occurs.
* @since 0.20.0
*/
void delete delete delete  throws ioexception
/**
* deletes the specified cells/rows in bulk.
* @param deletes list of things to delete.  list gets modified by this
* method (in particular it gets re-ordered, so the order in which the elements
* are inserted in the list gives no guarantee as to the order in which the
* {@link delete}s are executed).
* @throws ioexception if a remote or network exception occurs. in that case
* the {@code deletes} argument will contain the {@link delete} instances
* that have not be successfully applied.
* @since 0.20.1
*/
void delete list<delete> deletes  throws ioexception
/**
* atomically checks if a row/family/qualifier value matches the expected
* value. if it does, it adds the delete.  if the passed value is null, the
* check is for the lack of column (ie: non-existance)
*
* @param row to check
* @param family column family to check
* @param qualifier column qualifier to check
* @param value the expected value
* @param delete data to delete if check succeeds
* @throws ioexception e
* @return true if the new delete was executed, false otherwise
*/
boolean checkanddelete byte row  byte family  byte qualifier
byte value  delete delete  throws ioexception
/**
* performs multiple mutations atomically on a single row. currently
* {@link put} and {@link delete} are supported.
*
* @param arm object that specifies the set of mutations to perform
* atomically
* @throws ioexception
*/
public void mutaterow final rowmutations rm  throws ioexception
/**
* appends values to one or more columns within a single row.
* <p>
* this operation does not appear atomic to readers.  appends are done
* under a single row lock, so write operations to a row are synchronized, but
* readers do not take row locks so get and scan operations can see this
* operation partially completed.
*
* @param append object that specifies the columns and amounts to be used
*                  for the increment operations
* @throws ioexception e
* @return values of columns after the append operation (maybe null)
*/
public result append final append append  throws ioexception
/**
* increments one or more columns within a single row.
* <p>
* this operation does not appear atomic to readers.  increments are done
* under a single row lock, so write operations to a row are synchronized, but
* readers do not take row locks so get and scan operations can see this
* operation partially completed.
*
* @param increment object that specifies the columns and amounts to be used
*                  for the increment operations
* @throws ioexception e
* @return values of columns after the increment
*/
public result increment final increment increment  throws ioexception
/**
* atomically increments a column value.
* <p>
* equivalent to {@link #incrementcolumnvalue(byte[], byte[], byte[],
* long, boolean) incrementcolumnvalue}(row, family, qualifier, amount,
* <b>true</b>)}
* @param row the row that contains the cell to increment.
* @param family the column family of the cell to increment.
* @param qualifier the column qualifier of the cell to increment.
* @param amount the amount to increment the cell with (or decrement, if the
* amount is negative).
* @return the new value, post increment.
* @throws ioexception if a remote or network exception occurs.
*/
long incrementcolumnvalue byte row  byte family  byte qualifier
long amount  throws ioexception
/**
* atomically increments a column value. if the column value already exists
* and is not a big-endian long, this could throw an exception. if the column
* value does not yet exist it is initialized to <code>amount</code> and
* written to the specified column.
*
* <p>setting writetowal to false means that in a fail scenario, you will lose
* any increments that have not been flushed.
* @param row the row that contains the cell to increment.
* @param family the column family of the cell to increment.
* @param qualifier the column qualifier of the cell to increment.
* @param amount the amount to increment the cell with (or decrement, if the
* amount is negative).
* @param writetowal if {@code true}, the operation will be applied to the
* write ahead log (wal).  this makes the operation slower but safer, as if
* the call returns successfully, it is guaranteed that the increment will
* be safely persisted.  when set to {@code false}, the call may return
* successfully before the increment is safely persisted, so it's possible
* that the increment be lost in the event of a failure happening before the
* operation gets persisted.
* @return the new value, post increment.
* @throws ioexception if a remote or network exception occurs.
*/
long incrementcolumnvalue byte row  byte family  byte qualifier
long amount  boolean writetowal  throws ioexception
/**
* tells whether or not 'auto-flush' is turned on.
*
* @return {@code true} if 'auto-flush' is enabled (default), meaning
* {@link put} operations don't get buffered/delayed and are immediately
* executed.
*/
boolean isautoflush
/**
* executes all the buffered {@link put} operations.
* <p>
* this method gets called once automatically for every {@link put} or batch
* of {@link put}s (when <code>put(list<put>)</code> is used) when
* {@link #isautoflush} is {@code true}.
* @throws ioexception if a remote or network exception occurs.
*/
void flushcommits   throws ioexception
/**
* releases any resources help or pending changes in internal buffers.
*
* @throws ioexception if a remote or network exception occurs.
*/
void close   throws ioexception
/**
* obtains a lock on a row.
*
* @param row the row to lock.
* @return a {@link rowlock} containing the row and lock id.
* @throws ioexception if a remote or network exception occurs.
* @see rowlock
* @see #unlockrow
*/
rowlock lockrow byte row  throws ioexception
/**
* releases a row lock.
*
* @param rl the row lock to release.
* @throws ioexception if a remote or network exception occurs.
* @see rowlock
* @see #unlockrow
*/
void unlockrow rowlock rl  throws ioexception
/**
* creates and returns a proxy to the coprocessorprotocol instance running in the
* region containing the specified row.  the row given does not actually have
* to exist.  whichever region would contain the row based on start and end keys will
* be used.  note that the {@code row} parameter is also not passed to the
* coprocessor handler registered for this protocol, unless the {@code row}
* is separately passed as an argument in a proxy method call.  the parameter
* here is just used to locate the region used to handle the call.
*
* @param protocol the class or interface defining the remote protocol
* @param row the row key used to identify the remote region location
* @return a coprocessorprotocol instance
*/
<t extends coprocessorprotocol> t coprocessorproxy class<t> protocol  byte row
/**
* invoke the passed
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.call} against
* the {@link coprocessorprotocol} instances running in the selected regions.
* all regions beginning with the region containing the <code>startkey</code>
* row, through to the region containing the <code>endkey</code> row (inclusive)
* will be used.  if <code>startkey</code> or <code>endkey</code> is
* <code>null</code>, the first and last regions in the table, respectively,
* will be used in the range selection.
*
* @param protocol the coprocessorprotocol implementation to call
* @param startkey start region selection with region containing this row
* @param endkey select regions up to and including the region containing
* this row
* @param callable wraps the coprocessorprotocol implementation method calls
* made per-region
* @param <t> coprocessorprotocol subclass for the remote invocation
* @param <r> return type for the
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.call#call(object)}
* method
* @return a <code>map</code> of region names to
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.call#call(object)} return values
*/
<t extends coprocessorprotocol  r> map<byte r> coprocessorexec
class<t> protocol  byte startkey  byte endkey  batch call<t r> callable
throws ioexception  throwable
/**
* invoke the passed
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.call} against
* the {@link coprocessorprotocol} instances running in the selected regions.
* all regions beginning with the region containing the <code>startkey</code>
* row, through to the region containing the <code>endkey</code> row
* (inclusive)
* will be used.  if <code>startkey</code> or <code>endkey</code> is
* <code>null</code>, the first and last regions in the table, respectively,
* will be used in the range selection.
*
* <p>
* for each result, the given
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.callback#update(byte[], byte[], object)}
* method will be called.
*</p>
*
* @param protocol the coprocessorprotocol implementation to call
* @param startkey start region selection with region containing this row
* @param endkey select regions up to and including the region containing
* this row
* @param callable wraps the coprocessorprotocol implementation method calls
* made per-region
* @param callback an instance upon which
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.callback#update(byte[], byte[], object)} with the
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.call#call(object)}
* return value for each region
* @param <t> coprocessorprotocol subclass for the remote invocation
* @param <r> return type for the
* {@link org.apache.hadoop.hbase.client.coprocessor.batch.call#call(object)}
* method
*/
<t extends coprocessorprotocol  r> void coprocessorexec
class<t> protocol  byte startkey  byte endkey
batch call<t r> callable  batch callback<r> callback
throws ioexception  throwable