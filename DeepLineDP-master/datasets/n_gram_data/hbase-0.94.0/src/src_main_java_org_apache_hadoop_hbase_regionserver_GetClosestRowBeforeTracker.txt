/*
* copyright 2009 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver
import java util navigablemap
import java util navigableset
import java util treemap
import java util treeset
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase keyvalue
import org apache hadoop hbase keyvalue kvcomparator
import org apache hadoop hbase util bytes
/**
* state and utility processing {@link hregion#getclosestrowbefore(byte[], byte[])}.
* like {@link scandeletetracker} and {@link scandeletetracker} but does not
* implement the {@link deletetracker} interface since state spans rows (there
* is no update nor reset method).
*/
class getclosestrowbeforetracker
private final keyvalue targetkey
// any cell w/ a ts older than this is expired.
private final long oldestts
private keyvalue candidate   null
private final kvcomparator kvcomparator
// flag for whether we're doing getclosest on a metaregion.
private final boolean metaregion
// offset and length into targetkey demarking table name (if in a metaregion).
private final int rowoffset
private final int tablenameplusdelimiterlength
// deletes keyed by row.  comparator compares on row portion of keyvalue only.
private final navigablemap<keyvalue  navigableset<keyvalue>> deletes
/**
* @param c
* @param kv presume first on row: i.e. empty column, maximum timestamp and
* a type of type.maximum
* @param ttl time to live in ms for this store
* @param metaregion true if this is .meta. or -root- region.
*/
getclosestrowbeforetracker final kvcomparator c  final keyvalue kv
final long ttl  final boolean metaregion
super
this metaregion   metaregion
this targetkey   kv
// if we are in a metaregion, then our table name is the prefix on the
// targetkey.
this rowoffset   kv getrowoffset
int l    1
if  metaregion
l   keyvalue getdelimiter kv getbuffer    rowoffset  kv getrowlength
hregioninfo delimiter    this rowoffset
this tablenameplusdelimiterlength   metaregion? l   1   1
this oldestts   system currenttimemillis     ttl
this kvcomparator   c
keyvalue rowcomparator rc   new keyvalue rowcomparator this kvcomparator
this deletes   new treemap<keyvalue  navigableset<keyvalue>> rc
/**
* @param kv
* @return true if this <code>kv</code> is expired.
*/
boolean isexpired final keyvalue kv
return store isexpired kv  this oldestts
/*
* add the specified keyvalue to the list of deletes.
* @param kv
*/
private void adddelete final keyvalue kv
navigableset<keyvalue> rowdeletes   this deletes get kv
if  rowdeletes    null
rowdeletes   new treeset<keyvalue> this kvcomparator
this deletes put kv  rowdeletes
rowdeletes add kv
/*
* @param kv adds candidate if nearer the target than previous candidate.
* @return true if updated candidate.
*/
private boolean addcandidate final keyvalue kv
if   isdeleted kv     isbettercandidate kv
this candidate   kv
return true
return false
boolean isbettercandidate final keyvalue contender
return this candidate    null
this kvcomparator comparerows this candidate  contender  < 0
this kvcomparator comparerows contender  this targetkey  <  0
/*
* check if specified keyvalue buffer has been deleted by a previously
* seen delete.
* @param kv
* @return true is the specified keyvalue is deleted, false if not
*/
private boolean isdeleted final keyvalue kv
if  this deletes isempty    return false
navigableset<keyvalue> rowdeletes   this deletes get kv
if  rowdeletes    null    rowdeletes isempty    return false
return isdeleted kv  rowdeletes
/**
* check if the specified keyvalue buffer has been deleted by a previously
* seen delete.
* @param kv
* @param ds
* @return true is the specified keyvalue is deleted, false if not
*/
public boolean isdeleted final keyvalue kv  final navigableset<keyvalue> ds
if  deletes    null    deletes isempty    return false
for  keyvalue d  ds
long kvts   kv gettimestamp
long dts   d gettimestamp
if  d isdeletefamily
if  kvts <  dts  return true
continue
// check column
int ret   bytes compareto kv getbuffer    kv getqualifieroffset
kv getqualifierlength
d getbuffer    d getqualifieroffset    d getqualifierlength
if  ret <   1
// this delete is for an earlier column.
continue
else if  ret >  1
// beyond this kv.
break
// check timestamp
if  kvts > dts  return false
// check type
switch  keyvalue type codetotype d gettype
case delete  return kvts    dts
case deletecolumn  return true
default  continue
return false
/*
* handle keys whose values hold deletes.
* add to the set of deletes and then if the candidate keys contain any that
* might match, then check for a match and remove it.  implies candidates
* is made with a comparator that ignores key type.
* @param kv
* @return true if we removed <code>k</code> from <code>candidates</code>.
*/
boolean handledeletes final keyvalue kv
adddelete kv
boolean deleted   false
if   hascandidate    return deleted
if  isdeleted this candidate
this candidate   null
deleted   true
return deleted
/**
* do right thing with passed key, add to deletes or add to candidates.
* @param kv
* @return true if we added a candidate
*/
boolean handle final keyvalue kv
if  kv isdelete
handledeletes kv
return false
return addcandidate kv
/**
* @return true if has candidate
*/
public boolean hascandidate
return this candidate    null
/**
* @return best candidate or null.
*/
public keyvalue getcandidate
return this candidate
public keyvalue gettargetkey
return this targetkey
/**
* @param kv current kv
* @param first on row kv.
* @param state
* @return true if we went too far, past the target key.
*/
boolean istoofar final keyvalue kv  final keyvalue firstonrow
return this kvcomparator comparerows kv  firstonrow  > 0
boolean istargettable final keyvalue kv
if   metaregion  return true
// compare start of keys row.  compare including delimiter.  saves having
// to calculate where tablename ends in the candidate kv.
return bytes compareto this targetkey getbuffer    this rowoffset
this tablenameplusdelimiterlength
kv getbuffer    kv getrowoffset    this tablenameplusdelimiterlength     0