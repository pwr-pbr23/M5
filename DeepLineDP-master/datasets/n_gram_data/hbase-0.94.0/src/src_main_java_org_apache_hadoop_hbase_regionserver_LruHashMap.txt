/**
* copyright 2010 the apache software foundation
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hbase io heapsize
import org apache hadoop hbase util bytes
import org apache hadoop hbase util classsize
import java util arraylist
import java util collection
import java util hashset
import java util list
import java util map
import java util set
/**
* the lruhashmap is a memory-aware hashmap with a configurable maximum
* memory footprint.
* <p>
* it maintains an ordered list of all entries in the map ordered by
* access time.  when space needs to be freed becase the maximum has been
* reached, or the application has asked to free memory, entries will be
* evicted according to an lru (least-recently-used) algorithm.  that is,
* those entries which have not been accessed the longest will be evicted
* first.
* <p>
* both the key and value objects used for this class must extend
* <code>heapsize</code> in order to track heap usage.
* <p>
* this class contains internal synchronization and is thread-safe.
*/
public class lruhashmap<k extends heapsize  v extends heapsize>
implements heapsize  map<k v>
static final log log   logfactory getlog lruhashmap class
/** the default size (in bytes) of the lru */
private static final long default_max_mem_usage   50000
/** the default capacity of the hash table */
private static final int default_initial_capacity   16
/** the maxmum capacity of the hash table */
private static final int maximum_capacity   1 << 30
/** the default load factor to use */
private static final float default_load_factor   0 75f
/** memory overhead of this object (for heapsize) */
private static final int overhead   5   bytes sizeof_long
2   bytes sizeof_int   2   bytes sizeof_float   3   classsize reference
1   classsize array
/** load factor allowed (usually 75%) */
private final float loadfactor
/** number of key/vals in the map */
private int size
/** size at which we grow hash */
private int threshold
/** entries in the map */
private entry  entries
/** pointer to least recently used entry */
private entry<k v> headptr
/** pointer to most recently used entry */
private entry<k v> tailptr
/** maximum memory usage of this map */
private long memtotal   0
/** amount of available memory */
private long memfree   0
/** number of successful (found) get() calls */
private long hitcount   0
/** number of unsuccessful (not found) get() calls */
private long misscount   0
/**
* constructs a new, empty map with the specified initial capacity,
* load factor, and maximum memory usage.
*
* @param initialcapacity the initial capacity
* @param loadfactor the load factor
* @param maxmemusage the maximum total memory usage
* @throws illegalargumentexception if the initial capacity is less than one
* @throws illegalargumentexception if the initial capacity is greater than
* the maximum capacity
* @throws illegalargumentexception if the load factor is <= 0
* @throws illegalargumentexception if the max memory usage is too small
* to support the base overhead
*/
public lruhashmap int initialcapacity  float loadfactor
long maxmemusage
if  initialcapacity < 1
throw new illegalargumentexception
if  initialcapacity > maximum_capacity
throw new illegalargumentexception
if  loadfactor <  0    float isnan loadfactor
throw new illegalargumentexception
if  maxmemusage <   overhead   initialcapacity   classsize reference
throw new illegalargumentexception
/** find a power of 2 >= initialcapacity */
int capacity   calculatecapacity initialcapacity
this loadfactor   loadfactor
this threshold   calculatethreshold capacity loadfactor
this entries   new entry
this memfree   maxmemusage
this memtotal   maxmemusage
init
/**
* constructs a new, empty map with the specified initial capacity and
* load factor, and default maximum memory usage.
*
* @param initialcapacity the initial capacity
* @param loadfactor the load factor
* @throws illegalargumentexception if the initial capacity is less than one
* @throws illegalargumentexception if the initial capacity is greater than
* the maximum capacity
* @throws illegalargumentexception if the load factor is <= 0
*/
public lruhashmap int initialcapacity  float loadfactor
this initialcapacity  loadfactor  default_max_mem_usage
/**
* constructs a new, empty map with the specified initial capacity and
* with the default load factor and maximum memory usage.
*
* @param initialcapacity the initial capacity
* @throws illegalargumentexception if the initial capacity is less than one
* @throws illegalargumentexception if the initial capacity is greater than
* the maximum capacity
*/
public lruhashmap int initialcapacity
this initialcapacity  default_load_factor  default_max_mem_usage
/**
* constructs a new, empty map with the specified maximum memory usage
* and with default initial capacity and load factor.
*
* @param maxmemusage the maximum total memory usage
* @throws illegalargumentexception if the max memory usage is too small
* to support the base overhead
*/
public lruhashmap long maxmemusage
this default_initial_capacity  default_load_factor
maxmemusage
/**
* constructs a new, empty map with the default initial capacity,
* load factor and maximum memory usage.
*/
public lruhashmap
this default_initial_capacity  default_load_factor
default_max_mem_usage
//--------------------------------------------------------------------------
/**
* get the currently available memory for this lru in bytes.
* this is (maxallowed - currentlyused).
*
* @return currently available bytes
*/
public long getmemfree
return memfree
/**
* get the maximum memory allowed for this lru in bytes.
*
* @return maximum allowed bytes
*/
public long getmemmax
return memtotal
/**
* get the currently used memory for this lru in bytes.
*
* @return currently used memory in bytes
*/
public long getmemused
return  memtotal   memfree      findbugs is2_inconsistent_sync
/**
* get the number of hits to the map.  this is the number of times
* a call to get() returns a matched key.
*
* @return number of hits
*/
public long gethitcount
return hitcount
/**
* get the number of misses to the map.  this is the number of times
* a call to get() returns null.
*
* @return number of misses
*/
public long getmisscount
return misscount     findbugs is2_inconsistent_sync
/**
* get the hit ratio.  this is the number of hits divided by the
* total number of requests.
*
* @return hit ratio (double between 0 and 1)
*/
public double gethitratio
return  double   double hitcount
double  hitcount misscount
/**
* free the requested amount of memory from the lru map.
*
* this will do lru eviction from the map until at least as much
* memory as requested is freed.  this does not affect the maximum
* memory usage parameter.
*
* @param requestedamount memory to free from lru in bytes
* @return actual amount of memory freed in bytes
*/
public synchronized long freememory long requestedamount  throws exception
if requestedamount >  getmemused     getminimumusage
return clearall
long freedmemory   0
while freedmemory < requestedamount
freedmemory    evictfromlru
return freedmemory
/**
* the total memory usage of this map
*
* @return memory usage of map in bytes
*/
public long heapsize
return  memtotal   memfree
//--------------------------------------------------------------------------
/**
* retrieves the value associated with the specified key.
*
* if an entry is found, it is updated in the lru as the most recently
* used (last to be evicted) entry in the map.
*
* @param key the key
* @return the associated value, or null if none found
* @throws nullpointerexception if key is null
*/
public synchronized v get object key
checkkey  k key
int hash   hash key
int i   hashindex hash  entries length
entry<k v> e   entries
while  true
if  e    null
misscount
return null
if  e hash    hash    isequal key  e key
// hit!  update position in lru
hitcount
updatelru e
return e value
e   e next
/**
* insert a key-value mapping into the map.
*
* entry will be inserted as the most recently used.
*
* both the key and value are required to be objects and must
* implement the heapsize interface.
*
* @param key the key
* @param value the value
* @return the value that was previously mapped to this key, null if none
* @throws unsupportedoperationexception if either objects do not
* implement heapsize
* @throws nullpointerexception if the key or value is null
*/
public synchronized v put k key  v value
checkkey key
checkvalue value
int hash   hash key
int i   hashindex hash  entries length
// for old values
for  entry<k v> e   entries  e    null  e   e next
if  e hash    hash    isequal key  e key
v oldvalue   e value
long memchange   e replacevalue value
checkandfreememory memchange
// if replacing an old value for this key, update in lru
updatelru e
return oldvalue
long memchange   addentry hash  key  value  i
checkandfreememory memchange
return null
/**
* deletes the mapping for the specified key if it exists.
*
* @param key the key of the entry to be removed from the map
* @return the value associated with the specified key, or null
* if no mapping exists.
*/
public synchronized v remove object key
entry<k v> e   removeentryforkey  k key
if e    null  return null
// add freed memory back to available
memfree    e heapsize
return e value
/**
* gets the size (number of entries) of the map.
*
* @return size of the map
*/
public int size
return size
/**
* checks whether the map is currently empty.
*
* @return true if size of map is zero
*/
public boolean isempty
return size    0
/**
* clears all entries from the map.
*
* this frees all entries, tracking memory usage along the way.
* all references to entries are removed so they can be gc'd.
*/
public synchronized void clear
memfree    clearall
//--------------------------------------------------------------------------
/**
* checks whether there is a value in the map for the specified key.
*
* does not affect the lru.
*
* @param key the key to check
* @return true if the map contains a value for this key, false if not
* @throws nullpointerexception if the key is null
*/
public synchronized boolean containskey object key
checkkey  k key
int hash   hash key
int i   hashindex hash  entries length
entry e   entries
while  e    null
if  e hash    hash    isequal key  e key
return true
e   e next
return false
/**
* checks whether this is a mapping which contains the specified value.
*
* does not affect the lru.  this is an inefficient operation.
*
* @param value the value to check
* @return true if the map contains an entry for this value, false
* if not
* @throws nullpointerexception if the value is null
*/
public synchronized boolean containsvalue object value
checkvalue  v value
entry tab   entries
for  int i   0  i < tab length   i
for  entry e   tab   e    null   e   e next
if  value equals e value
return true
return false
//--------------------------------------------------------------------------
/**
* enforces key constraints.  null keys are not permitted and key must
* implement heapsize.  it should not be necessary to verify the second
* constraint because that's enforced on instantiation?
*
* can add other constraints in the future.
*
* @param key the key
* @throws nullpointerexception if the key is null
* @throws unsupportedoperationexception if the key class does not
* implement the heapsize interface
*/
private void checkkey k key
if key    null
throw new nullpointerexception
/**
* enforces value constraints.  null values are not permitted and value must
* implement heapsize.  it should not be necessary to verify the second
* constraint because that's enforced on instantiation?
*
* can add other contraints in the future.
*
* @param value the value
* @throws nullpointerexception if the value is null
* @throws unsupportedoperationexception if the value class does not
* implement the heapsize interface
*/
private void checkvalue v value
if value    null
throw new nullpointerexception
/**
* returns the minimum memory usage of the base map structure.
*
* @return baseline memory overhead of object in bytes
*/
private long getminimumusage
return overhead    entries length   classsize reference
//--------------------------------------------------------------------------
/**
* evicts and frees based on lru until at least as much memory as requested
* is available.
*
* @param memneeded the amount of memory needed in bytes
*/
private void checkandfreememory long memneeded
while memfree < memneeded
evictfromlru
memfree    memneeded
/**
* evicts based on lru.  this removes all references and updates available
* memory.
*
* @return amount of memory freed in bytes
*/
private long evictfromlru
long freed   headptr heapsize
memfree    freed
removeentry headptr
return freed
/**
* moves the specified entry to the most recently used slot of the
* lru.  this is called whenever an entry is fetched.
*
* @param e entry that was accessed
*/
private void updatelru entry<k v> e
entry<k v> prev   e getprevptr
entry<k v> next   e getnextptr
if next    null
if prev    null
prev setnextptr next
next setprevptr prev
else
headptr   next
headptr setprevptr null
e setnextptr null
e setprevptr tailptr
tailptr setnextptr e
tailptr   e
/**
* removes the specified entry from the map and lru structure.
*
* @param entry entry to be removed
*/
private void removeentry entry<k v> entry
k k   entry key
int hash   entry hash
int i   hashindex hash  entries length
entry<k v> prev   entries
entry<k v> e   prev
while  e    null
entry<k v> next   e next
if  e hash    hash    isequal k  e key
size
if  prev    e
entries   next
else
prev next   next
entry<k v> prevptr   e getprevptr
entry<k v> nextptr   e getnextptr
if prevptr    null    nextptr    null
prevptr setnextptr nextptr
nextptr setprevptr prevptr
else if prevptr    null
tailptr   prevptr
prevptr setnextptr null
else if nextptr    null
headptr   nextptr
nextptr setprevptr null
return
prev   e
e   next
/**
* removes and returns the entry associated with the specified
* key.
*
* @param key key of the entry to be deleted
* @return entry that was removed, or null if none found
*/
private entry<k v> removeentryforkey k key
int hash   hash key
int i   hashindex hash  entries length
entry<k v> prev   entries
entry<k v> e   prev
while  e    null
entry<k v> next   e next
if  e hash    hash    isequal key  e key
size
if  prev    e
entries   next
else
prev next   next
// updating lru
entry<k v> prevptr   e getprevptr
entry<k v> nextptr   e getnextptr
if prevptr    null    nextptr    null
prevptr setnextptr nextptr
nextptr setprevptr prevptr
else if prevptr    null
tailptr   prevptr
prevptr setnextptr null
else if nextptr    null
headptr   nextptr
nextptr setprevptr null
return e
prev   e
e   next
return e
/**
* adds a new entry with the specified key, value, hash code, and
* bucket index to the map.
*
* also puts it in the bottom (most-recent) slot of the list and
* checks to see if we need to grow the array.
*
* @param hash hash value of key
* @param key the key
* @param value the value
* @param bucketindex index into hash array to store this entry
* @return the amount of heap size used to store the new entry
*/
private long addentry int hash  k key  v value  int bucketindex
entry<k v> e   entries
entry<k v> newe   new entry<k v> hash  key  value  e  tailptr
entries   newe
// add as most recently used in lru
if  size    0
headptr   newe
tailptr   newe
else
newe setprevptr tailptr
tailptr setnextptr newe
tailptr   newe
// grow table if we are past the threshold now
if  size   >  threshold
growtable 2   entries length
return newe heapsize
/**
* clears all the entries in the map.  tracks the amount of memory being
* freed along the way and returns the total.
*
* cleans up all references to allow old entries to be gc'd.
*
* @return total memory freed in bytes
*/
private long clearall
entry cur
long freedmemory   0
for int i 0  i<entries length  i
cur   entries
while cur    null
freedmemory    cur heapsize
cur   cur next
entries   null
headptr   null
tailptr   null
size   0
return freedmemory
//--------------------------------------------------------------------------
/**
* recreates the entire contents of the hashmap into a new array
* with double the capacity.  this method is called when the number of
* keys in the map reaches the current threshold.
*
* @param newcapacity the new size of the hash entries
*/
private void growtable int newcapacity
entry  oldtable   entries
int oldcapacity   oldtable length
// do not allow growing the table beyond the max capacity
if  oldcapacity    maximum_capacity
threshold   integer max_value
return
// determine how much additional space will be required to grow the array
long requiredspace    newcapacity   oldcapacity    classsize reference
// verify/enforce we have sufficient memory to grow
checkandfreememory requiredspace
entry  newtable   new entry
// transfer existing entries to new hash table
for int i 0  i < oldcapacity  i
entry<k v> entry   oldtable
if entry    null
// set to null for gc
oldtable   null
do
entry<k v> next   entry next
int idx   hashindex entry hash  newcapacity
entry next   newtable
newtable   entry
entry   next
while entry    null
entries   newtable
threshold    int  newcapacity   loadfactor
/**
* gets the hash code for the specified key.
* this implementation uses the additional hashing routine
* from jdk 1.4.
*
* @param key the key to get a hash value for
* @return the hash value
*/
private int hash object key
int h   key hashcode
h    ~ h << 9
h ^    h >>> 14
h      h << 4
h ^    h >>> 10
return h
/**
* compares two objects for equality.  method uses equals method and
* assumes neither value is null.
*
* @param x the first value
* @param y the second value
* @return true if equal
*/
private boolean isequal object x  object y
return  x    y    x equals y
/**
* determines the index into the current hash table for the specified
* hashvalue.
*
* @param hashvalue the hash value
* @param length the current number of hash buckets
* @return the index of the current hash array to use
*/
private int hashindex int hashvalue  int length
return hashvalue    length   1
/**
* calculates the capacity of the array backing the hash
* by normalizing capacity to a power of 2 and enforcing
* capacity limits.
*
* @param proposedcapacity the proposed capacity
* @return the normalized capacity
*/
private int calculatecapacity int proposedcapacity
int newcapacity   1
if proposedcapacity > maximum_capacity
newcapacity   maximum_capacity
else
while newcapacity < proposedcapacity
newcapacity <<  1
if newcapacity > maximum_capacity
newcapacity   maximum_capacity
return newcapacity
/**
* calculates the threshold of the map given the capacity and load
* factor.  once the number of entries in the map grows to the
* threshold we will double the size of the array.
*
* @param capacity the size of the array
* @param factor the load factor of the hash
*/
private int calculatethreshold int capacity  float factor
return  int  capacity   factor
/**
* set the initial heap usage of this class.  includes class variable
* overhead and the entry array.
*/
private void init
memfree    overhead
memfree     entries length   classsize reference
//--------------------------------------------------------------------------
/**
* debugging function that returns a list sorted by access time.
*
* the order is oldest to newest (first in list is next to be evicted).
*
* @return sorted list of entries
*/
public list<entry<k v>> entrylrulist
list<entry<k v>> entrylist   new arraylist<entry<k v>>
entry<k v> entry   headptr
while entry    null
entrylist add entry
entry   entry getnextptr
return entrylist
/**
* debugging function that returns a set of all entries in the hash table.
*
* @return set of entries in hash
*/
public set<entry<k v>> entrytableset
set<entry<k v>> entryset   new hashset<entry<k v>>
entry  table   entries     findbugs is2_inconsistent_sync
for int i 0 i<table length i
for entry e   table  e    null  e   e next
entryset add e
return entryset
/**
* get the head of the linked list (least recently used).
*
* @return head of linked list
*/
public entry getheadptr
return headptr
/**
* get the tail of the linked list (most recently used).
*
* @return tail of linked list
*/
public entry gettailptr
return tailptr
//--------------------------------------------------------------------------
/**
* to best optimize this class, some of the methods that are part of a
* map implementation are not supported.  this is primarily related
* to being able to get sets and iterators of this map which require
* significant overhead and code complexity to support and are
* unnecessary for the requirements of this class.
*/
/**
* intentionally unimplemented.
*/
public set<map entry<k v>> entryset
throw new unsupportedoperationexception
/**
* intentionally unimplemented.
*/
public boolean equals object o
throw new unsupportedoperationexception
/**
* intentionally unimplemented.
*/
public int hashcode
throw new unsupportedoperationexception
/**
* intentionally unimplemented.
*/
public set<k> keyset
throw new unsupportedoperationexception
/**
* intentionally unimplemented.
*/
public void putall map<? extends k  ? extends v> m
throw new unsupportedoperationexception
/**
* intentionally unimplemented.
*/
public collection<v> values
throw new unsupportedoperationexception
//--------------------------------------------------------------------------
/**
* entry to store key/value mappings.
* <p>
* contains previous and next pointers for the doubly linked-list which is
* used for lru eviction.
* <p>
* instantiations of this class are memory aware.  both the key and value
* classes used must also implement <code>heapsize</code>.
*/
protected static class entry<k extends heapsize  v extends heapsize>
implements map entry<k v>  heapsize
/** the baseline overhead memory usage of this class */
static final int overhead   1   bytes sizeof_long
5   classsize reference   2   bytes sizeof_int
/** the key */
protected final k key
/** the value */
protected v value
/** the hash value for this entries key */
protected final int hash
/** the next entry in the hash chain (for collisions) */
protected entry<k v> next
/** the previous entry in the lru list (towards lru) */
protected entry<k v> prevptr
/** the next entry in the lru list (towards mru) */
protected entry<k v> nextptr
/** the precomputed heap size of this entry */
protected long heapsize
/**
* create a new entry.
*
* @param h the hash value of the key
* @param k the key
* @param v the value
* @param nextchainptr the next entry in the hash chain, null if none
* @param prevlruptr the previous entry in the lru
*/
entry int h  k k  v v  entry<k v> nextchainptr  entry<k v> prevlruptr
value   v
next   nextchainptr
key   k
hash   h
prevptr   prevlruptr
nextptr   null
// pre-compute heap size
heapsize   overhead   k heapsize     v heapsize
/**
* get the key of this entry.
*
* @return the key associated with this entry
*/
public k getkey
return key
/**
* get the value of this entry.
*
* @return the value currently associated with this entry
*/
public v getvalue
return value
/**
* set the value of this entry.
*
* it is not recommended to use this method when changing the value.
* rather, using <code>replacevalue</code> will return the difference
* in heap usage between the previous and current values.
*
* @param newvalue the new value to associate with this entry
* @return the value previously associated with this entry
*/
public v setvalue v newvalue
v oldvalue   value
value   newvalue
return oldvalue
/**
* replace the value of this entry.
*
* computes and returns the difference in heap size when changing
* the value associated with this entry.
*
* @param newvalue the new value to associate with this entry
* @return the change in heap usage of this entry in bytes
*/
protected long replacevalue v newvalue
long sizediff   newvalue heapsize     value heapsize
value   newvalue
heapsize    sizediff
return sizediff
/**
* returns true is the specified entry has the same key and the
* same value as this entry.
*
* @param o entry to test against current
* @return true is entries have equal key and value, false if no
*/
public boolean equals object o
if    o instanceof map entry
return false
map entry e    map entry o
object k1   getkey
object k2   e getkey
if  k1    k2     k1    null    k1 equals k2
object v1   getvalue
object v2   e getvalue
if  v1    v2     v1    null    v1 equals v2
return true
return false
/**
* returns the hash code of the entry by xor'ing the hash values
* of the key and value of this entry.
*
* @return hash value of this entry
*/
public int hashcode
return  key hashcode   ^ value hashcode
/**
* returns string representation of the entry in form "key=value"
*
* @return string value of entry
*/
public string tostring
return getkey         getvalue
//------------------------------------------------------------------------
/**
* sets the previous pointer for the entry in the lru.
* @param prevptr previous entry
*/
protected void setprevptr entry<k v> prevptr
this prevptr   prevptr
/**
* returns the previous pointer for the entry in the lru.
* @return previous entry
*/
protected entry<k v> getprevptr
return prevptr
/**
* sets the next pointer for the entry in the lru.
* @param nextptr next entry
*/
protected void setnextptr entry<k v> nextptr
this nextptr   nextptr
/**
* returns the next pointer for the entry in teh lru.
* @return next entry
*/
protected entry<k v> getnextptr
return nextptr
/**
* returns the pre-computed and "deep" size of the entry
* @return size of the entry in bytes
*/
public long heapsize
return heapsize