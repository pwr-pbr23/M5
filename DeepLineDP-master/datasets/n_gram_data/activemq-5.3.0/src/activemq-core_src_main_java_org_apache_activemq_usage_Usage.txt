/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq usage
import java util arraylist
import java util iterator
import java util linkedlist
import java util list
import java util concurrent copyonwritearraylist
import java util concurrent executor
import java util concurrent linkedblockingqueue
import java util concurrent threadfactory
import java util concurrent threadpoolexecutor
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import org apache activemq service
import org apache commons logging log
import org apache commons logging logfactory
/**
* used to keep track of how much of something is being used so that a
* productive working set usage can be controlled. main use case is manage
* memory usage.
*
* @org.apache.xbean.xbean
* @version $revision: 1.3 $
*/
public abstract class usage<t extends usage> implements service
private static final log log   logfactory getlog usage class
protected final object usagemutex   new object
protected int percentusage
protected t parent
private usagecapacity limiter   new defaultusagecapacity
private int percentusagemindelta   1
private final list<usagelistener> listeners   new copyonwritearraylist<usagelistener>
private final boolean debug   log isdebugenabled
private string name
private float usageportion   1 0f
private list<t> children   new copyonwritearraylist<t>
private final list<runnable> callbacks   new linkedlist<runnable>
private int pollingtime   100
private volatile threadpoolexecutor executor
private atomicboolean started new atomicboolean
public usage t parent  string name  float portion
this parent   parent
this usageportion   portion
if  parent    null
this limiter setlimit  long  parent getlimit     portion
name   parent name       name
this name   name
protected abstract long retrieveusage
/**
* @throws interruptedexception
*/
public void waitforspace   throws interruptedexception
waitforspace 0
/**
* @param timeout
* @throws interruptedexception
* @return true if space
*/
public boolean waitforspace long timeout  throws interruptedexception
if  parent    null
if   parent waitforspace timeout
return false
synchronized  usagemutex
percentusage caclpercentusage
if  percentusage >  100
long deadline   timeout > 0 ? system currenttimemillis     timeout   long max_value
long timeleft   deadline
while  timeleft > 0
percentusage caclpercentusage
if  percentusage >  100
usagemutex wait pollingtime
timeleft   deadline   system currenttimemillis
else
break
return percentusage < 100
public boolean isfull
if  parent    null    parent isfull
return true
synchronized  usagemutex
percentusage caclpercentusage
return percentusage >  100
public void addusagelistener usagelistener listener
listeners add listener
public void removeusagelistener usagelistener listener
listeners remove listener
public long getlimit
synchronized  usagemutex
return limiter getlimit
/**
* sets the memory limit in bytes. setting the limit in bytes will set the
* usageportion to 0 since the usagemanager is not going to be portion based
* off the parent.
* when set using xbean, values of the form "20 mb", "1024kb", and "1g" can be used
*
* @org.apache.xbean.property propertyeditor="org.apache.activemq.util.memorypropertyeditor"
*/
public void setlimit long limit
if  percentusagemindelta < 0
throw new illegalargumentexception
synchronized  usagemutex
this limiter setlimit limit
this usageportion   0
onlimitchange
protected void onlimitchange
// we may need to calculate the limit
if  usageportion > 0    parent    null
synchronized  usagemutex
this limiter setlimit  long  parent getlimit     usageportion
// reset the percent currently being used.
int percentusage
synchronized  usagemutex
percentusage   caclpercentusage
setpercentusage percentusage
// let the children know that the limit has changed. they may need to
// set
// their limits based on ours.
for  t child   children
child onlimitchange
public float getusageportion
synchronized  usagemutex
return usageportion
public void setusageportion float usageportion
synchronized  usagemutex
this usageportion   usageportion
onlimitchange
public int getpercentusage
synchronized  usagemutex
return percentusage
public int getpercentusagemindelta
synchronized  usagemutex
return percentusagemindelta
/**
* sets the minimum number of percentage points the usage has to change
* before a usagelistener event is fired by the manager.
*
* @param percentusagemindelta
*/
public void setpercentusagemindelta int percentusagemindelta
if  percentusagemindelta < 1
throw new illegalargumentexception
int percentusage
synchronized  usagemutex
this percentusagemindelta   percentusagemindelta
percentusage   caclpercentusage
setpercentusage percentusage
public long getusage
synchronized  usagemutex
return retrieveusage
protected void setpercentusage int value
synchronized  usagemutex
int oldvalue   percentusage
percentusage   value
if  oldvalue    value
fireevent oldvalue  value
protected int caclpercentusage
if  limiter getlimit      0
return 0
return  int     retrieveusage     100    limiter getlimit      percentusagemindelta    percentusagemindelta
private void fireevent final int oldpercentusage  final int newpercentusage
if  debug
log debug     oldpercentusage
newpercentusage
if  started get
// switching from being full to not being full..
if  oldpercentusage >  100    newpercentusage < 100
synchronized  usagemutex
usagemutex notifyall
for  iterator<runnable> iter   new arraylist<runnable> callbacks  iterator    iter hasnext
runnable callback   iter next
getexecutor   execute callback
callbacks clear
// let the listeners know on a separate thread
runnable listenernotifier   new runnable
public void run
for  iterator<usagelistener> iter   listeners iterator    iter hasnext
usagelistener l   iter next
l onusagechanged usage this  oldpercentusage  newpercentusage
if  started get
getexecutor   execute listenernotifier
else
log warn
public string getname
return name
public string tostring
return     getname         percentusage       retrieveusage         limiter getlimit         percentusagemindelta
@suppresswarnings
public void start
if  started compareandset false  true
if  parent    null
parent addchild this
for  t t children
t start
@suppresswarnings
public void stop
if  started compareandset true  false
if  parent    null
parent removechild this
if  this executor    null
this executor shutdownnow
//clear down any callbacks
synchronized  usagemutex
usagemutex notifyall
for  iterator<runnable> iter   new arraylist<runnable> this callbacks  iterator    iter hasnext
runnable callback   iter next
callback run
this callbacks clear
for  t t children
t stop
private void addchild t child
children add child
if  started get
child start
private void removechild t child
children remove child
/**
* @param callback
* @return true if the usagemanager was full. the callback will only be
*         called if this method returns true.
*/
public boolean notifycallbackwhennotfull final runnable callback
if  parent    null
runnable r   new runnable
public void run
synchronized  usagemutex
if  percentusage >  100
callbacks add callback
else
callback run
if  parent notifycallbackwhennotfull r
return true
synchronized  usagemutex
if  percentusage >  100
callbacks add callback
return true
else
return false
/**
* @return the limiter
*/
public usagecapacity getlimiter
return this limiter
/**
* @param limiter the limiter to set
*/
public void setlimiter usagecapacity limiter
this limiter   limiter
/**
* @return the pollingtime
*/
public int getpollingtime
return this pollingtime
/**
* @param pollingtime the pollingtime to set
*/
public void setpollingtime int pollingtime
this pollingtime   pollingtime
public void setname string name
this name   name
public t getparent
return parent
public void setparent t parent
this parent   parent
protected executor getexecutor
if  this executor    null
synchronized usagemutex
if  this executor    null
this executor   new threadpoolexecutor 1  1  0
timeunit nanoseconds
new linkedblockingqueue<runnable>    new threadfactory
public thread newthread runnable runnable
thread thread   new thread runnable  getname
thread setdaemon true
return thread
return this executor