/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache kahadb index
import java io datainput
import java io dataoutput
import java io ioexception
import java io printwriter
import java util arrays
import java util iterator
import java util map
import java util nosuchelementexception
import java util map entry
import org apache kahadb index btreeindex prefixer
import org apache kahadb page page
import org apache kahadb page transaction
import org apache kahadb util variablemarshaller
/**
* the btreenode class represents a node in the btree object graph.  it is stored in
* one page of a pagefile.
*/
public final class btreenode<key value>
// the index that this node is part of.
private final btreeindex<key value> index
// the parent node or null if this is the root node of the btree
private btreenode<key value> parent
// the page associated with this node
private page<btreenode<key value>> page
// order list of keys in the node
private key keys
// values associated with the keys. null if this is a branch node.
private value values
// nodeid pointers to children btreenodes. null if this is a leaf node.
private long children
// the next leaf node after this one.  used for fast iteration of the entries.
private long next    1
private final class keyvalueentry implements map entry<key  value>
private final key key
private final value value
public keyvalueentry key key  value value
this key   key
this value   value
public key getkey
return key
public value getvalue
return value
public value setvalue value value
throw new unsupportedoperationexception
private final class btreeiterator implements iterator<map entry<key  value>>
private final transaction tx
btreenode<key value> current
int nextindex
map entry<key value> nextentry
private btreeiterator transaction tx  btreenode<key value> current  int nextindex
this tx   tx
this current   current
this nextindex nextindex
synchronized private void findnextpage
if  nextentry  null
return
try
while  current  null
if  nextindex >  current keys length
// we need to roll to the next leaf..
if  current next >  0
current   index loadnode tx  current next  null
nextindex 0
else
break
else
nextentry   new keyvalueentry current keys  current values
nextindex
break
catch  ioexception e
public boolean hasnext
findnextpage
return nextentry   null
public entry<key  value> next
findnextpage
if  nextentry   null
entry<key  value> lastentry   nextentry
nextentry null
return lastentry
else
throw new nosuchelementexception
public void remove
throw new unsupportedoperationexception
/**
* the marshaller is used to store and load the data in the btreenode into a page.
*
* @param <key>
* @param <value>
*/
static public class marshaller<key value> extends variablemarshaller<btreenode<key value>>
private final btreeindex<key value> index
public marshaller btreeindex<key value> index
this index   index
public void writepayload btreenode<key value> node  dataoutput os  throws ioexception
// write the keys
short count    short node keys length     cast may truncate value
if  count    node keys length
throw new ioexception
os writeshort count
for  int i   0  i < node keys length  i
index getkeymarshaller   writepayload node keys  os
if  node isbranch
// if this is a branch...
os writeboolean true
for  int i   0  i < count 1  i
os writelong node children
else
// if this is a leaf
os writeboolean false
for  int i   0  i < count  i
index getvaluemarshaller   writepayload node values  os
os writelong node next
@suppresswarnings
public btreenode<key value> readpayload datainput is  throws ioexception
btreenode<key value>  node   new btreenode<key value> index
int count   is readshort
node keys    key new object
for  int i   0  i < count  i
node keys   index getkeymarshaller   readpayload is
if  is readboolean
node children   new long
for  int i   0  i < count 1  i
node children   is readlong
else
node values    value new object
for  int i   0  i < count  i
node values   index getvaluemarshaller   readpayload is
node next   is readlong
return node
public btreenode btreeindex<key value> index
this index   index
public void setempty
setleafdata createkeyarray 0   createvaluearray 0
/**
* internal (to the btreenode) method. because this method is called only by
* btreenode itself, no synchronization done inside of this method.
* @throws ioexception
*/
private btreenode<key value> getchild transaction tx  int idx  throws ioexception
if  isbranch      idx >  0    idx < children length
btreenode<key  value> result   this index loadnode tx  children  this
return result
else
return null
public value remove transaction tx  key key  throws ioexception
if isbranch
int idx   arrays binarysearch keys  key
idx   idx < 0 ?   idx   1    idx   1
btreenode<key  value> child   getchild tx  idx
if  child getpageid      index getpageid
throw new ioexception
value rc   child remove tx  key
// child node is now empty.. remove it from the branch node.
if  child keys length    0
// if the child node is a branch, promote
if  child isbranch
// this is cause branches are never really empty.. they just go down to 1 child..
children   child children
else
// the child was a leaf. then we need to actually remove it from this branch node..
// we need to update the previous child's next pointer to skip over the child being removed....
if  idx > 0    children length > 1
btreenode<key  value> previouschild   getchild tx  idx 1
previouschild next   child next
index storenode tx  previouschild  true
if  idx < children length 1
// delete it and key to the right.
setbranchdata arraydelete keys  idx   arraydelete children  idx
else
// it was the last child.. then delete it and key to the left
setbranchdata arraydelete keys  idx 1   arraydelete children  idx
// if we are the root node, and only have 1 child left.  then
// make the root be the leaf node.
if  children length    1    parent  null
child   getchild tx  0
keys   child keys
children   child children
values   child values
// free up the page..
tx free child getpage
index storenode tx  this  true
return rc
else
int idx   arrays binarysearch keys  key
if  idx < 0
return null
else
value oldvalue   values
setleafdata arraydelete keys  idx   arraydelete values  idx
if  keys length  0    parent  null
tx free getpage
else
index storenode tx  this  true
return oldvalue
public value put transaction tx  key key  value value  throws ioexception
if  key    null
throw new illegalargumentexception
if  isbranch
return getleafnode tx  this  key  put tx  key  value
else
int idx   arrays binarysearch keys  key
value oldvalue null
if  idx >  0
// key was found... overwrite
oldvalue   values
values   value
setleafdata keys  values
else
// key was not found, insert it
idx     idx   1
setleafdata arrayinsert keys  key  idx   arrayinsert values  value  idx
try
index storenode tx  this  allowoverflow
catch   transaction pageoverflowioexception e
// if we get an overflow
split tx
return oldvalue
private void promotevalue transaction tx  key key  long nodeid  throws ioexception
int idx   arrays binarysearch keys  key
idx   idx < 0 ?   idx   1    idx   1
setbranchdata arrayinsert keys  key  idx   arrayinsert children  nodeid  idx   1
try
index storenode tx  this  allowoverflow
catch   transaction pageoverflowioexception e
split tx
/**
* internal to the btreenode method
*/
private void split transaction tx  throws ioexception
key leftkeys
key rightkeys
value leftvalues null
value rightvalues null
long leftchildren null
long rightchildren null
key separator
int vc   keys length
int pivot   vc   2
// split the node into two nodes
if  isbranch
leftkeys   createkeyarray pivot
leftchildren   new long
rightkeys   createkeyarray vc    pivot   1
rightchildren   new long
system arraycopy keys  0  leftkeys  0  leftkeys length
system arraycopy children  0  leftchildren  0  leftchildren length
system arraycopy keys  leftkeys length   1  rightkeys  0  rightkeys length
system arraycopy children  leftchildren length  rightchildren  0  rightchildren length
// is it a simple prefix btree??
prefixer<key> prefixer   index getprefixer
if prefixer  null
separator   prefixer getsimpleprefix leftkeys  rightkeys
else
separator   keys
else
leftkeys   createkeyarray pivot
leftvalues   createvaluearray leftkeys length
rightkeys   createkeyarray vc   pivot
rightvalues   createvaluearray rightkeys length
system arraycopy keys  0  leftkeys  0  leftkeys length
system arraycopy values  0  leftvalues  0  leftvalues length
system arraycopy keys  leftkeys length  rightkeys  0  rightkeys length
system arraycopy values  leftvalues length  rightvalues  0  rightvalues length
// separator = getseparator(leftvals[leftvals.length - 1],
// rightvals[0]);
separator   rightkeys
// promote the pivot to the parent branch
if  parent    null
// this can only happen if this is the root
btreenode<key value> rnode   this index createnode tx  this
btreenode<key value> lnode   this index createnode tx  this
if  isbranch
rnode setbranchdata rightkeys  rightchildren
lnode setbranchdata leftkeys  leftchildren
else
rnode setleafdata rightkeys  rightvalues
lnode setleafdata leftkeys  leftvalues
lnode setnext rnode getpageid
key v   createkeyarray 1
v separator
setbranchdata v  new long   lnode getpageid    rnode getpageid
index storenode tx  this  true
index storenode tx  rnode  true
index storenode tx  lnode  true
else
btreenode<key value> rnode   this index createnode tx  parent
if  isbranch
setbranchdata leftkeys  leftchildren
rnode setbranchdata rightkeys  rightchildren
else
rnode setnext next
next   rnode getpageid
setleafdata leftkeys  leftvalues
rnode setleafdata rightkeys  rightvalues
index storenode tx  this  true
index storenode tx  rnode  true
parent promotevalue tx  separator  rnode getpageid
public void printstructure transaction tx  printwriter out  string prefix  throws ioexception
if  prefix length  >0    parent    null
throw new illegalstateexception
if  isbranch
for int i 0   i < children length  i
btreenode<key  value> child   getchild tx  i
if  i    children length 1
out println prefix   child getpageid    child isbranch  ?  child children length
child printstructure tx  out  prefix
else
out println prefix   child getpageid    child isbranch  ?  child children length        keys
child printstructure tx  out  prefix
public int getminleafdepth transaction tx  int depth  throws ioexception
depth
if  isbranch
int min   integer max_value
for int i 0   i < children length  i
min   math min min  getchild tx  i  getminleafdepth tx  depth
return min
else
//            print(depth*2, "- "+page.getpageid());
return depth
public int getmaxleafdepth transaction tx  int depth  throws ioexception
depth
if  isbranch
int v   0
for int i 0   i < children length  i
v   math max v  getchild tx  i  getmaxleafdepth tx  depth
depth   v
return depth
public value get transaction tx  key key  throws ioexception
if  key    null
throw new illegalargumentexception
if  isbranch
return getleafnode tx  this  key  get tx  key
else
int idx   arrays binarysearch keys  key
if  idx < 0
return null
else
return values
public void visit transaction tx  btreevisitor<key  value> visitor  throws ioexception
if  visitor    null
throw new illegalargumentexception
if  isbranch
for int i 0  i < this children length  i
key key1   null
if  i  0
key1   keys
key key2   null
if  i  this children length 1
key2   keys
if  visitor isinterestedinkeysbetween key1  key2
btreenode<key  value> child   getchild tx  i
child visit tx  visitor
else
visitor visit arrays aslist keys   arrays aslist values
public map entry<key value> getfirst transaction tx  throws ioexception
btreenode<key  value> node   this
while  node  isbranch
node   node getchild tx  0
if  node values length>0
return new keyvalueentry node keys  node values
else
return null
public map entry<key value> getlast transaction tx  throws ioexception
btreenode<key  value> node   this
while  node isbranch
node   node getchild tx  node children length 1
if  node values length>0
int idx   node values length 1
return new keyvalueentry node keys  node values
else
return null
public btreenode<key value> getfirstleafnode transaction tx  throws ioexception
btreenode<key  value> node   this
while  node  isbranch
node   node getchild tx  0
return node
public iterator<map entry<key value>> iterator final transaction tx  key startkey  throws ioexception
if  startkey    null
return iterator tx
if  isbranch
return getleafnode tx  this  startkey  iterator tx  startkey
else
int idx   arrays binarysearch keys  startkey
if  idx < 0
idx     idx   1
return new btreeiterator tx  this  idx
public iterator<map entry<key value>> iterator final transaction tx  throws ioexception
return new btreeiterator tx  getfirstleafnode tx   0
public void clear transaction tx  throws ioexception
if  isbranch
for  int i   0  i < children length  i
btreenode<key  value> node   index loadnode tx  children  this
node clear tx
tx free node getpage
// reset the root node to be a leaf.
if  parent    null
setleafdata createkeyarray 0   createvaluearray 0
next  1
index storenode tx  this  true
private static <key value> btreenode<key  value> getleafnode transaction tx  final btreenode<key  value> node  key key  throws ioexception
btreenode<key  value> current   node
while  true
if  current isbranch
int idx   arrays binarysearch current keys  key
idx   idx < 0 ?   idx   1    idx   1
btreenode<key  value> child   current getchild tx  idx
// a little cycle detection for sanity's sake
if  child    node
throw new ioexception
current   child
else
break
return current
public boolean contains transaction tx  key key  throws ioexception
if  key    null
throw new illegalargumentexception
if  isbranch
return getleafnode tx  this  key  contains tx  key
else
int idx   arrays binarysearch keys  key
if  idx < 0
return false
else
return true
///////////////////////////////////////////////////////////////////
// implementation methods
///////////////////////////////////////////////////////////////////
private boolean allowoverflow
// only allow page overflow if there are <= 3 keys in the node.  otherwise a split will occur on overflow
return this keys length< 3
private void setleafdata key keys  value values
this keys   keys
this values   values
this children   null
private void setbranchdata key keys  long nodeids
this keys   keys
this children   nodeids
this values   null
@suppresswarnings
private key createkeyarray int size
return  key new object
@suppresswarnings
private value createvaluearray int size
return  value new object
@suppresswarnings
static private <t> t arraydelete t vals  int idx
t newvals    t new object
if  idx > 0
system arraycopy vals  0  newvals  0  idx
if  idx < newvals length
system arraycopy vals  idx   1  newvals  idx  newvals length   idx
return newvals
static private long arraydelete long vals  int idx
long newvals   new long
if  idx > 0
system arraycopy vals  0  newvals  0  idx
if  idx < newvals length
system arraycopy vals  idx   1  newvals  idx  newvals length   idx
return newvals
@suppresswarnings
static private <t> t arrayinsert t vals  t val  int idx
t newvals    t new object
if  idx > 0
system arraycopy vals  0  newvals  0  idx
newvals   val
if  idx < vals length
system arraycopy vals  idx  newvals  idx   1  vals length   idx
return newvals
static private long arrayinsert long vals  long val  int idx
long newvals   new long
if  idx > 0
system arraycopy vals  0  newvals  0  idx
newvals   val
if  idx < vals length
system arraycopy vals  idx  newvals  idx   1  vals length   idx
return newvals
///////////////////////////////////////////////////////////////////
// property accessors
///////////////////////////////////////////////////////////////////
private boolean isbranch
return children  null
public long getpageid
return page getpageid
public btreenode<key  value> getparent
return parent
public void setparent btreenode<key  value> parent
this parent   parent
public page<btreenode<key  value>> getpage
return page
public void setpage page<btreenode<key  value>> page
this page   page
public long getnext
return next
public void setnext long next
this next   next
@override
public string tostring
return    isbranch  ?       arrays aslist keys