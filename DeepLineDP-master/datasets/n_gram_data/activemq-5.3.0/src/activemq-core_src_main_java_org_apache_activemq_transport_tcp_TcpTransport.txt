/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq transport tcp
import java io datainputstream
import java io dataoutputstream
import java io ioexception
import java io interruptedioexception
import java net inetaddress
import java net inetsocketaddress
import java net socket
import java net socketexception
import java net sockettimeoutexception
import java net uri
import java net unknownhostexception
import java util hashmap
import java util map
import java util concurrent countdownlatch
import java util concurrent synchronousqueue
import java util concurrent threadfactory
import java util concurrent threadpoolexecutor
import java util concurrent timeunit
import java util concurrent atomic atomicreference
import javax net socketfactory
import org apache activemq service
import org apache activemq transport transport
import org apache activemq transport transportloggerfactory
import org apache activemq transport transportthreadsupport
import org apache activemq util introspectionsupport
import org apache activemq util servicestopper
import org apache activemq wireformat wireformat
import org apache commons logging log
import org apache commons logging logfactory
/**
* an implementation of the {@link transport} interface using raw tcp/ip
*
* @author david martin clavo david(dot)martin(dot)clavo(at)gmail.com (logging improvement modifications)
* @version $revision$
*/
public class tcptransport extends transportthreadsupport implements transport  service  runnable
private static final log log   logfactory getlog tcptransport class
private static final threadpoolexecutor socket_close
protected final uri remotelocation
protected final uri locallocation
protected final wireformat wireformat
protected int connectiontimeout   30000
protected int sotimeout
protected int socketbuffersize   64   1024
protected int iobuffersize   8   1024
protected boolean closeasync true
protected socket socket
protected dataoutputstream dataout
protected datainputstream datain
protected tcpbufferedoutputstream buffout   null
/**
* trace=true -> the transport stack where this tcptransport
* object will be, will have a transportlogger layer
* trace=false -> the transport stack where this tcptransport
* object will be, will not have a transportlogger layer, and therefore
* will never be able to print logging messages.
* this parameter is most probably set in connection or transportconnector uris.
*/
protected boolean trace   false
/**
* name of the logwriter implementation to use.
* names are mapped to classes in the resources/meta-inf/services/org/apache/activemq/transport/logwriters directory.
* this parameter is most probably set in connection or transportconnector uris.
*/
protected string logwritername   transportloggerfactory defaultlogwritername
/**
* specifies if the transportlogger will be manageable by jmx or not.
* also, as long as there is at least 1 transportlogger which is manageable,
* a transportloggercontrol mbean will me created.
*/
protected boolean dynamicmanagement   false
/**
* startlogging=true -> the transportlogger object of the transport stack
* will initially write messages to the log.
* startlogging=false -> the transportlogger object of the transport stack
* will initially not write messages to the log.
* this parameter only has an effect if trace == true.
* this parameter is most probably set in connection or transportconnector uris.
*/
protected boolean startlogging   true
/**
* specifies the port that will be used by the jmx server to manage
* the transportloggers.
* this should only be set in an uri by a client (producer or consumer) since
* a broker will already create a jmx server.
* it is useful for people who test a broker and clients in the same machine
* and want to control both via jmx; a different port will be needed.
*/
protected int jmxport   1099
protected boolean uselocalhost   true
protected int minmumwireformatversion
protected socketfactory socketfactory
protected final atomicreference<countdownlatch> stoppedlatch   new atomicreference<countdownlatch>
private map<string  object> socketoptions
private boolean keepalive
private boolean tcpnodelay
private thread runnerthread
/**
* connect to a remote node - e.g. a broker
*
* @param wireformat
* @param socketfactory
* @param remotelocation
* @param locallocation - e.g. local inetaddress and local port
* @throws ioexception
* @throws unknownhostexception
*/
public tcptransport wireformat wireformat  socketfactory socketfactory  uri remotelocation
uri locallocation  throws unknownhostexception  ioexception
this wireformat   wireformat
this socketfactory   socketfactory
try
this socket   socketfactory createsocket
catch  socketexception e
this socket   null
this remotelocation   remotelocation
this locallocation   locallocation
setdaemon false
/**
* initialize from a server socket
*
* @param wireformat
* @param socket
* @throws ioexception
*/
public tcptransport wireformat wireformat  socket socket  throws ioexception
this wireformat   wireformat
this socket   socket
this remotelocation   null
this locallocation   null
setdaemon true
/**
* a one way asynchronous send
*/
public void oneway object command  throws ioexception
checkstarted
wireformat marshal command  dataout
dataout flush
/**
* @return pretty print of 'this'
*/
public string tostring
return     socket getinetaddress         socket getport
/**
* reads packets from a socket
*/
public void run
log trace     this
this runnerthread thread currentthread
try
while   isstopped
dorun
catch  ioexception e
stoppedlatch get   countdown
onexception e
catch  throwable e
stoppedlatch get   countdown
ioexception ioe new ioexception
ioe initcause e
onexception ioe
finally
stoppedlatch get   countdown
protected void dorun   throws ioexception
try
object command   readcommand
doconsume command
catch  sockettimeoutexception e
catch  interruptedioexception e
protected object readcommand   throws ioexception
return wireformat unmarshal datain
// properties
// -------------------------------------------------------------------------
public boolean istrace
return trace
public void settrace boolean trace
this trace   trace
public string getlogwritername
return logwritername
public void setlogwritername string logformat
this logwritername   logformat
public boolean isdynamicmanagement
return dynamicmanagement
public void setdynamicmanagement boolean usejmx
this dynamicmanagement   usejmx
public boolean isstartlogging
return startlogging
public void setstartlogging boolean startlogging
this startlogging   startlogging
public int getjmxport
return jmxport
public void setjmxport int jmxport
this jmxport   jmxport
public int getminmumwireformatversion
return minmumwireformatversion
public void setminmumwireformatversion int minmumwireformatversion
this minmumwireformatversion   minmumwireformatversion
public boolean isuselocalhost
return uselocalhost
/**
* sets whether 'localhost' or the actual local host name should be used to
* make local connections. on some operating systems such as macs its not
* possible to connect as the local host name so localhost is better.
*/
public void setuselocalhost boolean uselocalhost
this uselocalhost   uselocalhost
public int getsocketbuffersize
return socketbuffersize
/**
* sets the buffer size to use on the socket
*/
public void setsocketbuffersize int socketbuffersize
this socketbuffersize   socketbuffersize
public int getsotimeout
return sotimeout
/**
* sets the socket timeout
*/
public void setsotimeout int sotimeout
this sotimeout   sotimeout
public int getconnectiontimeout
return connectiontimeout
/**
* sets the timeout used to connect to the socket
*/
public void setconnectiontimeout int connectiontimeout
this connectiontimeout   connectiontimeout
public boolean getkeepalive
return keepalive
/**
* enable/disable tcp keep_alive mode
*/
public void setkeepalive boolean keepalive
this keepalive   keepalive
public boolean gettcpnodelay
return tcpnodelay
/**
* enable/disable the tcp_nodelay option on the socket
*/
public void settcpnodelay boolean tcpnodelay
this tcpnodelay   tcpnodelay
/**
* @return the iobuffersize
*/
public int getiobuffersize
return this iobuffersize
/**
* @param iobuffersize the iobuffersize to set
*/
public void setiobuffersize int iobuffersize
this iobuffersize   iobuffersize
/**
* @return the closeasync
*/
public boolean iscloseasync
return closeasync
/**
* @param closeasync the closeasync to set
*/
public void setcloseasync boolean closeasync
this closeasync   closeasync
// implementation methods
// -------------------------------------------------------------------------
protected string resolvehostname string host  throws unknownhostexception
string localname   inetaddress getlocalhost   gethostname
if  localname    null    isuselocalhost
if  localname equals host
return
return host
/**
* configures the socket for use
*
* @param sock
* @throws socketexception
*/
protected void initialisesocket socket sock  throws socketexception
if  socketoptions    null
introspectionsupport setproperties socket  socketoptions
try
sock setreceivebuffersize socketbuffersize
sock setsendbuffersize socketbuffersize
catch  socketexception se
log warn     socketbuffersize
log debug     se  se
sock setsotimeout sotimeout
if  keepalive    null
sock setkeepalive keepalive booleanvalue
if  tcpnodelay    null
sock settcpnodelay tcpnodelay booleanvalue
protected void dostart   throws exception
connect
stoppedlatch set new countdownlatch 1
super dostart
protected void connect   throws exception
if  socket    null    socketfactory    null
throw new illegalstateexception
inetsocketaddress localaddress   null
inetsocketaddress remoteaddress   null
if  locallocation    null
localaddress   new inetsocketaddress inetaddress getbyname locallocation gethost
locallocation getport
if  remotelocation    null
string host   resolvehostname remotelocation gethost
remoteaddress   new inetsocketaddress host  remotelocation getport
if  socket    null
if  localaddress    null
socket bind localaddress
// if it's a server accepted socket.. we don't need to connect it
// to a remote address.
if  remoteaddress    null
if  connectiontimeout >  0
socket connect remoteaddress  connectiontimeout
else
socket connect remoteaddress
else
// for ssl sockets.. you can't create an unconnected socket :(
// this means the timout option are not supported either.
if  localaddress    null
socket   socketfactory createsocket remoteaddress getaddress    remoteaddress getport
localaddress getaddress    localaddress getport
else
socket   socketfactory createsocket remoteaddress getaddress    remoteaddress getport
initialisesocket socket
initializestreams
protected void dostop servicestopper stopper  throws exception
if  log isdebugenabled
log debug     this
// closing the streams flush the sockets before closing.. if the socket
// is hung.. then this hangs the close.
// closestreams();
if  socket    null
if  closeasync
//closing the socket can hang also
final countdownlatch latch   new countdownlatch 1
socket_close execute new runnable
public void run
try
socket close
catch  ioexception e
log debug   e
finally
latch countdown
latch await 1 timeunit seconds
else
try
socket close
catch  ioexception e
log debug   e
/**
* override so that stop() blocks until the run thread is no longer running.
*/
@override
public void stop   throws exception
super stop
countdownlatch countdownlatch   stoppedlatch get
if  countdownlatch    null    thread currentthread      this runnerthread
countdownlatch await 1 timeunit seconds
protected void initializestreams   throws exception
tcpbufferedinputstream buffin   new tcpbufferedinputstream socket getinputstream    iobuffersize
this datain   new datainputstream buffin
buffout   new tcpbufferedoutputstream socket getoutputstream    iobuffersize
this dataout   new dataoutputstream buffout
protected void closestreams   throws ioexception
if  dataout    null
dataout close
if  datain    null
datain close
public void setsocketoptions map<string  object> socketoptions
this socketoptions   new hashmap<string  object> socketoptions
public string getremoteaddress
if  socket    null
return     socket getremotesocketaddress
return null
@override
public <t> t narrow class<t> target
if  target    socket class
return target cast socket
else if   target    tcpbufferedoutputstream class
return target cast buffout
return super narrow target
static
socket_close     new threadpoolexecutor 0  integer max_value  10  timeunit seconds  new synchronousqueue<runnable>    new threadfactory
public thread newthread runnable runnable
thread thread   new thread runnable    runnable
thread setpriority thread max_priority
thread setdaemon true
return thread