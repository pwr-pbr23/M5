/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store journal
import java io file
import java io ioexception
import java util arraylist
import java util hashset
import java util iterator
import java util set
import java util concurrent callable
import java util concurrent concurrenthashmap
import java util concurrent countdownlatch
import java util concurrent futuretask
import java util concurrent linkedblockingqueue
import java util concurrent threadfactory
import java util concurrent threadpoolexecutor
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import org apache activeio journal invalidrecordlocationexception
import org apache activeio journal journal
import org apache activeio journal journaleventlistener
import org apache activeio journal recordlocation
import org apache activeio packet bytearraypacket
import org apache activeio packet packet
import org apache activemq broker brokerservice
import org apache activemq broker brokerserviceaware
import org apache activemq broker connectioncontext
import org apache activemq command activemqdestination
import org apache activemq command activemqqueue
import org apache activemq command activemqtopic
import org apache activemq command datastructure
import org apache activemq command journalqueueack
import org apache activemq command journaltopicack
import org apache activemq command journaltrace
import org apache activemq command journaltransaction
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq filter noncachedmessageevaluationcontext
import org apache activemq openwire openwireformat
import org apache activemq store messagestore
import org apache activemq store persistenceadapter
import org apache activemq store topicmessagestore
import org apache activemq store transactionstore
import org apache activemq store jdbc jdbcpersistenceadapter
import org apache activemq store journal journaltransactionstore tx
import org apache activemq store journal journaltransactionstore txoperation
import org apache activemq thread scheduler
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq usage usage
import org apache activemq usage usagelistener
import org apache activemq usage systemusage
import org apache activemq util bytesequence
import org apache activemq util ioexceptionsupport
import org apache activemq wireformat wireformat
import org apache commons logging log
import org apache commons logging logfactory
/**
* an implementation of {@link persistenceadapter} designed for use with a
* {@link journal} and then check pointing asynchronously on a timeout with some
* other long term persistent storage.
*
* @org.apache.xbean.xbean
* @version $revision: 1.17 $
*/
public class journalpersistenceadapter implements persistenceadapter  journaleventlistener  usagelistener  brokerserviceaware
private brokerservice brokerservice
protected static final scheduler scheduler   scheduler getinstance
private static final log log   logfactory getlog journalpersistenceadapter class
private final journal journal
private final persistenceadapter longtermpersistence
private final wireformat wireformat   new openwireformat
private final concurrenthashmap<activemqqueue  journalmessagestore> queues   new concurrenthashmap<activemqqueue  journalmessagestore>
private final concurrenthashmap<activemqtopic  journaltopicmessagestore> topics   new concurrenthashmap<activemqtopic  journaltopicmessagestore>
private systemusage usagemanager
private long checkpointinterval   1000   60   5
private long lastcheckpointrequest   system currenttimemillis
private long lastcleanup   system currenttimemillis
private int maxcheckpointworkers   10
private int maxcheckpointmessageaddsize   1024   1024
private journaltransactionstore transactionstore   new journaltransactionstore this
private threadpoolexecutor checkpointexecutor
private taskrunner checkpointtask
private countdownlatch nextcheckpointcountdownlatch   new countdownlatch 1
private boolean fullcheckpoint
private atomicboolean started   new atomicboolean false
private final runnable periodiccheckpointtask   createperiodiccheckpointtask
public journalpersistenceadapter journal journal  persistenceadapter longtermpersistence  taskrunnerfactory taskrunnerfactory  throws ioexception
this journal   journal
journal setjournaleventlistener this
checkpointtask   taskrunnerfactory createtaskrunner new task
public boolean iterate
return docheckpoint
this longtermpersistence   longtermpersistence
final runnable createperiodiccheckpointtask
return new runnable
public void run
long lasttime   0
synchronized  this
lasttime   lastcheckpointrequest
if  system currenttimemillis   > lasttime   checkpointinterval
checkpoint false  true
/**
* @param usagemanager the usagemanager that is controlling the
*                destination's memory usage.
*/
public void setusagemanager systemusage usagemanager
this usagemanager   usagemanager
longtermpersistence setusagemanager usagemanager
public set<activemqdestination> getdestinations
set<activemqdestination> destinations   new hashset<activemqdestination> longtermpersistence getdestinations
destinations addall queues keyset
destinations addall topics keyset
return destinations
private messagestore createmessagestore activemqdestination destination  throws ioexception
if  destination isqueue
return createqueuemessagestore  activemqqueue destination
else
return createtopicmessagestore  activemqtopic destination
public messagestore createqueuemessagestore activemqqueue destination  throws ioexception
journalmessagestore store   queues get destination
if  store    null
messagestore checkpointstore   longtermpersistence createqueuemessagestore destination
store   new journalmessagestore this  checkpointstore  destination
queues put destination  store
return store
public topicmessagestore createtopicmessagestore activemqtopic destinationname  throws ioexception
journaltopicmessagestore store   topics get destinationname
if  store    null
topicmessagestore checkpointstore   longtermpersistence createtopicmessagestore destinationname
store   new journaltopicmessagestore this  checkpointstore  destinationname
topics put destinationname  store
return store
/**
* cleanup method to remove any state associated with the given destination
*
* @param destination destination to forget
*/
public void removequeuemessagestore activemqqueue destination
queues remove destination
/**
* cleanup method to remove any state associated with the given destination
*
* @param destination destination to forget
*/
public void removetopicmessagestore activemqtopic destination
topics remove destination
public transactionstore createtransactionstore   throws ioexception
return transactionstore
public long getlastmessagebrokersequenceid   throws ioexception
return longtermpersistence getlastmessagebrokersequenceid
public void begintransaction connectioncontext context  throws ioexception
longtermpersistence begintransaction context
public void committransaction connectioncontext context  throws ioexception
longtermpersistence committransaction context
public void rollbacktransaction connectioncontext context  throws ioexception
longtermpersistence rollbacktransaction context
public synchronized void start   throws exception
if   started compareandset false  true
return
checkpointexecutor   new threadpoolexecutor maxcheckpointworkers  maxcheckpointworkers  30  timeunit seconds  new linkedblockingqueue<runnable>    new threadfactory
public thread newthread runnable runable
thread t   new thread runable
t setpriority 7
return t
// checkpointexecutor.allowcorethreadtimeout(true);
this usagemanager getmemoryusage   addusagelistener this
if  longtermpersistence instanceof jdbcpersistenceadapter
// disabled periodic clean up as it deadlocks with the checkpoint
// operations.
jdbcpersistenceadapter longtermpersistence  setcleanupperiod 0
longtermpersistence start
createtransactionstore
recover
// do a checkpoint periodically.
scheduler executeperiodically periodiccheckpointtask  checkpointinterval   10
public void stop   throws exception
this usagemanager getmemoryusage   removeusagelistener this
if   started compareandset true  false
return
scheduler cancel periodiccheckpointtask
// take one final checkpoint and stop checkpoint processing.
checkpoint true  true
checkpointtask shutdown
checkpointexecutor shutdown
queues clear
topics clear
ioexception firstexception   null
try
journal close
catch  exception e
firstexception   ioexceptionsupport create     e  e
longtermpersistence stop
if  firstexception    null
throw firstexception
// properties
// -------------------------------------------------------------------------
public persistenceadapter getlongtermpersistence
return longtermpersistence
/**
* @return returns the wireformat.
*/
public wireformat getwireformat
return wireformat
// implementation methods
// -------------------------------------------------------------------------
/**
* the journal give us a call back so that we can move old data out of the
* journal. taking a checkpoint does this for us.
*
* @see org.apache.activemq.journal.journaleventlistener#overflownotification(org.apache.activemq.journal.recordlocation)
*/
public void overflownotification recordlocation safelocation
checkpoint false  true
/**
* when we checkpoint we move all the journalled data to long term storage.
*
* @param stopping
* @param b
*/
public void checkpoint boolean sync  boolean fullcheckpoint
try
if  journal    null
throw new illegalstateexception
long now   system currenttimemillis
countdownlatch latch   null
synchronized  this
latch   nextcheckpointcountdownlatch
lastcheckpointrequest   now
if  fullcheckpoint
this fullcheckpoint   true
checkpointtask wakeup
if  sync
log debug
latch await
catch  interruptedexception e
thread currentthread   interrupt
log warn     e  e
public void checkpoint boolean sync
checkpoint sync  sync
/**
* this does the actual checkpoint.
*
* @return
*/
public boolean docheckpoint
countdownlatch latch   null
boolean fullcheckpoint
synchronized  this
latch   nextcheckpointcountdownlatch
nextcheckpointcountdownlatch   new countdownlatch 1
fullcheckpoint   this fullcheckpoint
this fullcheckpoint   false
try
log debug
recordlocation newmark   null
arraylist<futuretask<recordlocation>> futuretasks   new arraylist<futuretask<recordlocation>> queues size     topics size
//
// we do many partial checkpoints (fullcheckpoint==false) to move
// topic messages
// to long term store as soon as possible.
//
// we want to avoid doing that for queue messages since removes the
// come in the same
// checkpoint cycle will nullify the previous message add.
// therefore, we only
// checkpoint queues on the fullcheckpoint cycles.
//
if  fullcheckpoint
iterator<journalmessagestore> iterator   queues values   iterator
while  iterator hasnext
try
final journalmessagestore ms   iterator next
futuretask<recordlocation> task   new futuretask<recordlocation> new callable<recordlocation>
public recordlocation call   throws exception
return ms checkpoint
futuretasks add task
checkpointexecutor execute task
catch  exception e
log error     e  e
iterator<journaltopicmessagestore> iterator   topics values   iterator
while  iterator hasnext
try
final journaltopicmessagestore ms   iterator next
futuretask<recordlocation> task   new futuretask<recordlocation> new callable<recordlocation>
public recordlocation call   throws exception
return ms checkpoint
futuretasks add task
checkpointexecutor execute task
catch  exception e
log error     e  e
try
for  iterator<futuretask<recordlocation>> iter   futuretasks iterator    iter hasnext
futuretask<recordlocation> ft   iter next
recordlocation mark   ft get
// we only set a newmark on full checkpoints.
if  fullcheckpoint
if  mark    null     newmark    null    newmark compareto mark  < 0
newmark   mark
catch  throwable e
log error     e  e
if  fullcheckpoint
try
if  newmark    null
log debug     newmark
journal setmark newmark  true
catch  exception e
log error     e  e
if  longtermpersistence instanceof jdbcpersistenceadapter
// we may be check pointing more often than the
// checkpointinterval if under high use
// but we don't want to clean up the db that often.
long now   system currenttimemillis
if  now > lastcleanup   checkpointinterval
lastcleanup   now
jdbcpersistenceadapter longtermpersistence  cleanup
log debug
finally
latch countdown
synchronized  this
return this fullcheckpoint
/**
* @param location
* @return
* @throws ioexception
*/
public datastructure readcommand recordlocation location  throws ioexception
try
packet packet   journal read location
return  datastructure wireformat unmarshal tobytesequence packet
catch  invalidrecordlocationexception e
throw createreadexception location  e
catch  ioexception e
throw createreadexception location  e
/**
* move all the messages that were in the journal into long term storage. we
* just replay and do a checkpoint.
*
* @throws ioexception
* @throws ioexception
* @throws invalidrecordlocationexception
* @throws illegalstateexception
*/
private void recover   throws illegalstateexception  invalidrecordlocationexception  ioexception  ioexception
recordlocation pos   null
int transactioncounter   0
log info     journal
connectioncontext context   new connectioncontext new noncachedmessageevaluationcontext
// while we have records in the journal.
while   pos   journal getnextrecordlocation pos      null
packet data   journal read pos
datastructure c    datastructure wireformat unmarshal tobytesequence data
if  c instanceof message
message message    message c
journalmessagestore store    journalmessagestore createmessagestore message getdestination
if  message isintransaction
transactionstore addmessage store  message  pos
else
store replayaddmessage context  message
transactioncounter
else
switch  c getdatastructuretype
case journalqueueack data_structure_type
journalqueueack command    journalqueueack c
journalmessagestore store    journalmessagestore createmessagestore command getdestination
if  command getmessageack   isintransaction
transactionstore removemessage store  command getmessageack    pos
else
store replayremovemessage context  command getmessageack
transactioncounter
break
case journaltopicack data_structure_type
journaltopicack command    journaltopicack c
journaltopicmessagestore store    journaltopicmessagestore createmessagestore command getdestination
if  command gettransactionid      null
transactionstore acknowledge store  command  pos
else
store replayacknowledge context  command getclientid    command getsubscritionname    command getmessageid
transactioncounter
break
case journaltransaction data_structure_type
journaltransaction command    journaltransaction c
try
// try to replay the packet.
switch  command gettype
case journaltransaction xa_prepare
transactionstore replayprepare command gettransactionid
break
case journaltransaction xa_commit
case journaltransaction local_commit
tx tx   transactionstore replaycommit command gettransactionid    command getwasprepared
if  tx    null
break     we may be trying to replay a commit
// that
// was already committed.
// replay the committed operations.
tx getoperations
for  iterator iter   tx getoperations   iterator    iter hasnext
txoperation op    txoperation iter next
if  op operationtype    txoperation add_operation_type
op store replayaddmessage context   message op data
if  op operationtype    txoperation remove_operation_type
op store replayremovemessage context   messageack op data
if  op operationtype    txoperation ack_operation_type
journaltopicack ack    journaltopicack op data
journaltopicmessagestore op store  replayacknowledge context  ack getclientid    ack getsubscritionname    ack getmessageid
transactioncounter
break
case journaltransaction local_rollback
case journaltransaction xa_rollback
transactionstore replayrollback command gettransactionid
break
default
throw new ioexception     command gettype
catch  ioexception e
log error     c       e  e
break
case journaltrace data_structure_type
journaltrace trace    journaltrace c
log debug     trace getmessage
break
default
log error     c
recordlocation location   writetracemessage    true
journal setmark location  true
log info     transactioncounter
private ioexception createreadexception recordlocation location  exception e
return ioexceptionsupport create     location       e  e
protected ioexception createwriteexception datastructure packet  exception e
return ioexceptionsupport create     packet       e  e
protected ioexception createwriteexception string command  exception e
return ioexceptionsupport create     command       e  e
protected ioexception createrecoveryfailedexception exception e
return ioexceptionsupport create     e  e
/**
* @param command
* @param sync
* @return
* @throws ioexception
*/
public recordlocation writecommand datastructure command  boolean sync  throws ioexception
if  started get
try
return journal write topacket wireformat marshal command    sync
catch  ioexception ioe
log error    ioe
stopbroker
throw ioe
throw new ioexception
private recordlocation writetracemessage string message  boolean sync  throws ioexception
journaltrace trace   new journaltrace
trace setmessage message
return writecommand trace  sync
public void onusagechanged usage usage  int oldpercentusage  int newpercentusage
newpercentusage    newpercentusage   10    10
oldpercentusage    oldpercentusage   10    10
if  newpercentusage >  70    oldpercentusage < newpercentusage
boolean sync   newpercentusage >  90
checkpoint sync  true
public journaltransactionstore gettransactionstore
return transactionstore
public void deleteallmessages   throws ioexception
try
journaltrace trace   new journaltrace
trace setmessage
recordlocation location   journal write topacket wireformat marshal trace    false
journal setmark location  true
log info
catch  ioexception e
throw e
catch  throwable e
throw ioexceptionsupport create e
longtermpersistence deleteallmessages
public systemusage getusagemanager
return usagemanager
public int getmaxcheckpointmessageaddsize
return maxcheckpointmessageaddsize
public void setmaxcheckpointmessageaddsize int maxcheckpointmessageaddsize
this maxcheckpointmessageaddsize   maxcheckpointmessageaddsize
public int getmaxcheckpointworkers
return maxcheckpointworkers
public void setmaxcheckpointworkers int maxcheckpointworkers
this maxcheckpointworkers   maxcheckpointworkers
public boolean isuseexternalmessagereferences
return false
public void setuseexternalmessagereferences boolean enable
if  enable
throw new illegalargumentexception
public packet topacket bytesequence sequence
return new bytearraypacket new org apache activeio packet bytesequence sequence data  sequence offset  sequence length
public bytesequence tobytesequence packet packet
org apache activeio packet bytesequence sequence   packet asbytesequence
return new bytesequence sequence getdata    sequence getoffset    sequence getlength
public void setbrokername string brokername
longtermpersistence setbrokername brokername
public string tostring
return     longtermpersistence
public void setdirectory file dir
public long size
return 0
public void setbrokerservice brokerservice brokerservice
this brokerservice   brokerservice
persistenceadapter pa   getlongtermpersistence
if  pa instanceof brokerserviceaware
brokerserviceaware pa  setbrokerservice brokerservice
protected void stopbroker
new thread
public void run
try
brokerservice stop
catch  exception e
log warn
start