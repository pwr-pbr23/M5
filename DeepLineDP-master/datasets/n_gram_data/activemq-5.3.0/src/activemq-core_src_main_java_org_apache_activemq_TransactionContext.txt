/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq
import java io interruptedioexception
import java util arraylist
import java util arrays
import java util list
import java util concurrent concurrenthashmap
import javax jms jmsexception
import javax jms transactioninprogressexception
import javax transaction xa xaexception
import javax transaction xa xaresource
import javax transaction xa xid
import org apache activemq command command
import org apache activemq command connectionid
import org apache activemq command dataarrayresponse
import org apache activemq command datastructure
import org apache activemq command integerresponse
import org apache activemq command localtransactionid
import org apache activemq command response
import org apache activemq command transactionid
import org apache activemq command transactioninfo
import org apache activemq command xatransactionid
import org apache activemq transaction synchronization
import org apache activemq util jmsexceptionsupport
import org apache activemq util longsequencegenerator
import org apache commons logging log
import org apache commons logging logfactory
/**
* a transactioncontext provides the means to control a jms transaction. it
* provides a local transaction interface and also an xaresource interface. <p/>
* an application server controls the transactional assignment of an xasession
* by obtaining its xaresource. it uses the xaresource to assign the session to
* a transaction, prepare and commit work on the transaction, and so on. <p/> an
* xaresource provides some fairly sophisticated facilities for interleaving
* work on multiple transactions, recovering a list of transactions in progress,
* and so on. a jta aware jms provider must fully implement this functionality.
* this could be done by using the services of a database that supports xa, or a
* jms provider may choose to implement this functionality from scratch. <p/>
*
* @version $revision: 1.10 $
* @see javax.jms.session
* @see javax.jms.queuesession
* @see javax.jms.topicsession
* @see javax.jms.xasession
*/
public class transactioncontext implements xaresource
private static final log log   logfactory getlog transactioncontext class
// xatransactionid -> arraylist of transactioncontext objects
private final static concurrenthashmap<transactionid  list<transactioncontext>> ended_xa_transaction_contexts   new concurrenthashmap<transactionid  list<transactioncontext>>
private final activemqconnection connection
private final longsequencegenerator localtransactionidgenerator
private final connectionid connectionid
private list<synchronization> synchronizations
// to track xa transactions.
private xid associatedxid
private transactionid transactionid
private localtransactioneventlistener localtransactioneventlistener
public transactioncontext activemqconnection connection
this connection   connection
this localtransactionidgenerator   connection getlocaltransactionidgenerator
this connectionid   connection getconnectioninfo   getconnectionid
public boolean isinxatransaction
return transactionid    null    transactionid isxatransaction
public boolean isinlocaltransaction
return transactionid    null    transactionid islocaltransaction
public boolean isintransaction
return transactionid    null
/**
* @return returns the localtransactioneventlistener.
*/
public localtransactioneventlistener getlocaltransactioneventlistener
return localtransactioneventlistener
/**
* used by the resource adapter to listen to transaction events.
*
* @param localtransactioneventlistener the localtransactioneventlistener to
*                set.
*/
public void setlocaltransactioneventlistener localtransactioneventlistener localtransactioneventlistener
this localtransactioneventlistener   localtransactioneventlistener
// ///////////////////////////////////////////////////////////
//
// methods that work with the synchronization objects registered with
// the transaction.
//
// ///////////////////////////////////////////////////////////
public void addsynchronization synchronization s
if  synchronizations    null
synchronizations   new arraylist<synchronization> 10
synchronizations add s
private void afterrollback   throws jmsexception
if  synchronizations    null
return
int size   synchronizations size
try
for  int i   0  i < size  i
synchronizations get i  afterrollback
catch  jmsexception e
throw e
catch  throwable e
throw jmsexceptionsupport create e
finally
synchronizations   null
private void aftercommit   throws jmsexception
if  synchronizations    null
return
int size   synchronizations size
try
for  int i   0  i < size  i
synchronizations get i  aftercommit
catch  jmsexception e
throw e
catch  throwable e
throw jmsexceptionsupport create e
finally
synchronizations   null
private void beforeend   throws jmsexception
if  synchronizations    null
return
int size   synchronizations size
try
for  int i   0  i < size  i
synchronizations get i  beforeend
catch  jmsexception e
throw e
catch  throwable e
throw jmsexceptionsupport create e
public transactionid gettransactionid
return transactionid
// ///////////////////////////////////////////////////////////
//
// local transaction interface.
//
// ///////////////////////////////////////////////////////////
/**
* start a local transaction.
* @throws javax.jms.jmsexception on internal error
*/
public void begin   throws jmsexception
if  isinxatransaction
throw new transactioninprogressexception
if  transactionid    null
synchronizations   null
this transactionid   new localtransactionid connectionid  localtransactionidgenerator getnextsequenceid
transactioninfo info   new transactioninfo getconnectionid    transactionid  transactioninfo begin
this connection ensureconnectioninfosent
this connection asyncsendpacket info
// notify the listener that the tx was started.
if  localtransactioneventlistener    null
localtransactioneventlistener beginevent
if  log isdebugenabled
log debug     transactionid
/**
* rolls back any work done in this transaction and releases any locks
* currently held.
*
* @throws jmsexception if the jms provider fails to roll back the
*                 transaction due to some internal error.
* @throws javax.jms.illegalstateexception if the method is not called by a
*                 transacted session.
*/
public void rollback   throws jmsexception
if  isinxatransaction
throw new transactioninprogressexception
beforeend
if  transactionid    null
if  log isdebugenabled
log debug      transactionid
synchronizations    null ? synchronizations size     0
transactioninfo info   new transactioninfo getconnectionid    transactionid  transactioninfo rollback
this transactionid   null
//make this synchronous - see https://issues.apache.org/activemq/browse/amq-2364
this connection syncsendpacket info
// notify the listener that the tx was rolled back
if  localtransactioneventlistener    null
localtransactioneventlistener rollbackevent
afterrollback
/**
* commits all work done in this transaction and releases any locks
* currently held.
*
* @throws jmsexception if the jms provider fails to commit the transaction
*                 due to some internal error.
* @throws javax.jms.illegalstateexception if the method is not called by a
*                 transacted session.
*/
public void commit   throws jmsexception
if  isinxatransaction
throw new transactioninprogressexception
beforeend
// only send commit if the transaction was started.
if  transactionid    null
if  log isdebugenabled
log debug      transactionid
synchronizations    null ? synchronizations size     0
transactioninfo info   new transactioninfo getconnectionid    transactionid  transactioninfo commit_one_phase
this transactionid   null
// notify the listener that the tx was committed back
syncsendpacketwithinterruptionhandling info
if  localtransactioneventlistener    null
localtransactioneventlistener commitevent
aftercommit
// ///////////////////////////////////////////////////////////
//
// xaresource implementation
//
// ///////////////////////////////////////////////////////////
/**
* associates a transaction with the resource.
*/
public void start xid xid  int flags  throws xaexception
if  log isdebugenabled
log debug     xid
if  isinlocaltransaction
throw new xaexception xaexception xaer_proto
// are we already associated?
if  associatedxid    null
throw new xaexception xaexception xaer_proto
// if ((flags & tmjoin) == tmjoin) {
// // todo: verify that the server has seen the xid
// }
// if ((flags & tmjoin) == tmresume) {
// // todo: verify that the xid was suspended.
// }
// associate
synchronizations   null
setxid xid
/**
* @return connectionid for connection
*/
private connectionid getconnectionid
return connection getconnectioninfo   getconnectionid
public void end xid xid  int flags  throws xaexception
if  log isdebugenabled
log debug     xid
if  isinlocaltransaction
throw new xaexception xaexception xaer_proto
if   flags    tmsuspend   tmfail      0
// you can only suspend the associated xid.
if   equals associatedxid  xid
throw new xaexception xaexception xaer_proto
// todo: we may want to put the xid in a suspended list.
try
beforeend
catch  jmsexception e
throw toxaexception e
setxid null
else if   flags   tmsuccess     tmsuccess
// set to null if this is the current xid.
// otherwise this could be an asynchronous success call
if  equals associatedxid  xid
try
beforeend
catch  jmsexception e
throw toxaexception e
setxid null
else
throw new xaexception xaexception xaer_inval
private boolean equals xid xid1  xid xid2
if  xid1    xid2
return true
if  xid1    null ^ xid2    null
return false
return xid1 getformatid      xid2 getformatid      arrays equals xid1 getbranchqualifier    xid2 getbranchqualifier
arrays equals xid1 getglobaltransactionid    xid2 getglobaltransactionid
public int prepare xid xid  throws xaexception
if  log isdebugenabled
log debug     xid
// we allow interleaving multiple transactions, so
// we don't limit prepare to the associated xid.
xatransactionid x
// this should never happen because end(xid, tmsuccess) should have been
// called first
if  xid    null     equals associatedxid  xid
throw new xaexception xaexception xaer_proto
else
// todo: cache the known xids so we don't keep recreating this one??
x   new xatransactionid xid
try
transactioninfo info   new transactioninfo getconnectionid    x  transactioninfo prepare
// find out if the server wants to commit or rollback.
integerresponse response    integerresponse syncsendpacketwithinterruptionhandling info
return response getresult
catch  jmsexception e
throw toxaexception e
public void rollback xid xid  throws xaexception
if  log isdebugenabled
log debug     xid
// we allow interleaving multiple transactions, so
// we don't limit rollback to the associated xid.
xatransactionid x
if  xid    null
throw new xaexception xaexception xaer_proto
if  equals associatedxid  xid
// i think this can happen even without an end(xid) call. need to
// check spec.
x    xatransactionid transactionid
else
x   new xatransactionid xid
try
this connection checkclosedorfailed
this connection ensureconnectioninfosent
// let the server know that the tx is rollback.
transactioninfo info   new transactioninfo getconnectionid    x  transactioninfo rollback
syncsendpacketwithinterruptionhandling info
list<transactioncontext> l   ended_xa_transaction_contexts remove x
if  l    null     l isempty
for  transactioncontext ctx   l
ctx afterrollback
catch  jmsexception e
throw toxaexception e
// xaresource interface
public void commit xid xid  boolean onephase  throws xaexception
if  log isdebugenabled
log debug     xid
// we allow interleaving multiple transactions, so
// we don't limit commit to the associated xid.
xatransactionid x
if  xid    null     equals associatedxid  xid
// should never happen, end(xid,tmsuccess) must have been previously
// called
throw new xaexception xaexception xaer_proto
else
x   new xatransactionid xid
try
this connection checkclosedorfailed
this connection ensureconnectioninfosent
// notify the server that the tx was committed back
transactioninfo info   new transactioninfo getconnectionid    x  onephase ? transactioninfo commit_one_phase   transactioninfo commit_two_phase
syncsendpacketwithinterruptionhandling info
list<transactioncontext> l   ended_xa_transaction_contexts remove x
if  l    null     l isempty
for  transactioncontext ctx   l
ctx aftercommit
catch  jmsexception e
throw toxaexception e
public void forget xid xid  throws xaexception
if  log isdebugenabled
log debug     xid
// we allow interleaving multiple transactions, so
// we don't limit forget to the associated xid.
xatransactionid x
if  xid    null
throw new xaexception xaexception xaer_proto
if  equals associatedxid  xid
// todo determine if this can happen... i think not.
x    xatransactionid transactionid
else
x   new xatransactionid xid
transactioninfo info   new transactioninfo getconnectionid    x  transactioninfo forget
try
// tell the server to forget the transaction.
syncsendpacketwithinterruptionhandling info
catch  jmsexception e
throw toxaexception e
public boolean issamerm xaresource xaresource  throws xaexception
if  xaresource    null
return false
if    xaresource instanceof transactioncontext
return false
transactioncontext xar    transactioncontext xaresource
try
return getresourcemanagerid   equals xar getresourcemanagerid
catch  throwable e
throw  xaexception new xaexception    initcause e
public xid recover int flag  throws xaexception
if  log isdebugenabled
log debug     flag
transactioninfo info   new transactioninfo getconnectionid    null  transactioninfo recover
try
this connection checkclosedorfailed
this connection ensureconnectioninfosent
dataarrayresponse receipt    dataarrayresponse this connection syncsendpacket info
datastructure data   receipt getdata
xatransactionid answer
if  data instanceof xatransactionid
answer    xatransactionid data
else
answer   new xatransactionid
system arraycopy data  0  answer  0  data length
return answer
catch  jmsexception e
throw toxaexception e
public int gettransactiontimeout   throws xaexception
return 0
public boolean settransactiontimeout int seconds  throws xaexception
return false
// ///////////////////////////////////////////////////////////
//
// helper methods.
//
// ///////////////////////////////////////////////////////////
private string getresourcemanagerid   throws jmsexception
return this connection getresourcemanagerid
private void setxid xid xid  throws xaexception
try
this connection checkclosedorfailed
this connection ensureconnectioninfosent
catch  jmsexception e
throw toxaexception e
if  xid    null
// associate
associatedxid   xid
transactionid   new xatransactionid xid
transactioninfo info   new transactioninfo connectionid  transactionid  transactioninfo begin
try
this connection asyncsendpacket info
if  log isdebugenabled
log debug     transactionid
catch  jmsexception e
throw toxaexception e
else
if  transactionid    null
transactioninfo info   new transactioninfo connectionid  transactionid  transactioninfo end
try
syncsendpacketwithinterruptionhandling info
if  log isdebugenabled
log debug     transactionid
catch  jmsexception e
throw toxaexception e
// add our self to the list of contexts that are interested in
// post commit/rollback events.
list<transactioncontext> l   ended_xa_transaction_contexts get transactionid
if  l    null
l   new arraylist<transactioncontext> 3
ended_xa_transaction_contexts put transactionid  l
l add this
else if   l contains this
l add this
// dis-associate
associatedxid   null
transactionid   null
/**
* sends the given command. also sends the command in case of interruption,
* so that important commands like rollback and commit are never interrupted.
* if interruption occurred, set the interruption state of the current
* after performing the action again.
*
* @return the response
*/
private response syncsendpacketwithinterruptionhandling command command  throws jmsexception
try
return this connection syncsendpacket command
catch  jmsexception e
if  e getlinkedexception   instanceof interruptedioexception
try
thread interrupted
return this connection syncsendpacket command
finally
thread currentthread   interrupt
throw e
/**
* converts a jmsexception from the server to an xaexception. if the
* jmsexception contained a linked xaexception that is returned instead.
*
* @param e jmsexception to convert
* @return xaexception wrapping original exception or its message
*/
private xaexception toxaexception jmsexception e
if  e getcause      null    e getcause   instanceof xaexception
xaexception original    xaexception e getcause
xaexception xae   new xaexception original getmessage
xae errorcode   original errorcode
xae initcause original
return xae
xaexception xae   new xaexception e getmessage
xae errorcode   xaexception xaer_rmfail
xae initcause e
return xae
public activemqconnection getconnection
return connection
public void cleanup
associatedxid   null
transactionid   null