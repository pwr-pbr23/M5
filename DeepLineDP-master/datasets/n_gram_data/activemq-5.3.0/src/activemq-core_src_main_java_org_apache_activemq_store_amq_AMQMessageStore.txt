/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq store amq
import java io ioexception
import java io interruptedioexception
import java util arraylist
import java util collections
import java util hashset
import java util iterator
import java util linkedhashmap
import java util list
import java util map
import java util set
import java util map entry
import java util concurrent countdownlatch
import java util concurrent atomic atomicreference
import java util concurrent locks lock
import org apache activemq broker connectioncontext
import org apache activemq command activemqdestination
import org apache activemq command datastructure
import org apache activemq command journalqueueack
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messageid
import org apache activemq filter noncachedmessageevaluationcontext
import org apache activemq kaha impl async location
import org apache activemq store abstractmessagestore
import org apache activemq store messagerecoverylistener
import org apache activemq store persistenceadapter
import org apache activemq store referencestore
import org apache activemq store referencestore referencedata
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq transaction synchronization
import org apache activemq usage memoryusage
import org apache activemq util callback
import org apache activemq util transactiontemplate
import org apache commons logging log
import org apache commons logging logfactory
/**
* a messagestore that uses a journal to store it's messages.
*
* @version $revision: 1.14 $
*/
public class amqmessagestore extends abstractmessagestore
private static final log log   logfactory getlog amqmessagestore class
protected final amqpersistenceadapter peristenceadapter
protected final amqtransactionstore transactionstore
protected final referencestore referencestore
protected final transactiontemplate transactiontemplate
protected location lastlocation
protected location lastwrittenlocation
protected set<location> inflighttxlocations   new hashset<location>
protected final taskrunner asyncwritetask
protected countdownlatch flushlatch
private map<messageid  referencedata> messages   new linkedhashmap<messageid  referencedata>
private list<messageack> messageacks   new arraylist<messageack>
/** a messagestore that we can use to retrieve messages quickly. */
private map<messageid  referencedata> cpaddedmessageids
private final boolean debug   log isdebugenabled
private final atomicreference<location> mark   new atomicreference<location>
protected final lock lock
public amqmessagestore amqpersistenceadapter adapter  referencestore referencestore  activemqdestination destination
super destination
this peristenceadapter   adapter
this lock   referencestore getstorelock
this transactionstore   adapter gettransactionstore
this referencestore   referencestore
this transactiontemplate   new transactiontemplate adapter  new connectioncontext
new noncachedmessageevaluationcontext
asyncwritetask   adapter gettaskrunnerfactory   createtaskrunner new task
public boolean iterate
asyncwrite
return false
destination
public void setmemoryusage memoryusage memoryusage
referencestore setmemoryusage memoryusage
/**
* not synchronize since the journal has better throughput if you increase the number of concurrent writes that it
* is doing.
*/
public final void addmessage connectioncontext context  final message message  throws ioexception
final messageid id   message getmessageid
final location location   peristenceadapter writecommand message  message isresponserequired
if   context isintransaction
if  debug
log debug     id       location
this peristenceadapter addinprogressdatafile this  location getdatafileid
addmessage message  location
else
if  debug
log debug     id       location
lock lock
try
inflighttxlocations add location
finally
lock unlock
transactionstore addmessage this  message  location
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
if  debug
log debug     id       location
lock lock
try
inflighttxlocations remove location
finally
lock unlock
addmessage message  location
public void afterrollback   throws exception
if  debug
log debug     id       location
lock lock
try
inflighttxlocations remove location
finally
lock unlock
final void addmessage final message message  final location location  throws interruptedioexception
referencedata data   new referencedata
data setexpiration message getexpiration
data setfileid location getdatafileid
data setoffset location getoffset
lock lock
try
lastlocation   location
messages put message getmessageid    data
finally
lock unlock
if  messages size   > this peristenceadapter getmaxcheckpointmessageaddsize
flush
else
try
asyncwritetask wakeup
catch  interruptedexception e
throw new interruptedioexception
public boolean replayaddmessage connectioncontext context  message message  location location
messageid id   message getmessageid
try
// only add the message if it has not already been added.
referencedata data   referencestore getmessagereference id
if  data    null
data   new referencedata
data setexpiration message getexpiration
data setfileid location getdatafileid
data setoffset location getoffset
referencestore addmessagereference context  id  data
return true
catch  throwable e
log warn     id
e  e
return false
/**
*/
public void removemessage final connectioncontext context  final messageack ack  throws ioexception
journalqueueack remove   new journalqueueack
remove setdestination destination
remove setmessageack ack
final location location   peristenceadapter writecommand remove  ack isresponserequired
if   context isintransaction
if  debug
log debug     ack getlastmessageid         location
removemessage ack  location
else
if  debug
log debug     ack getlastmessageid         location
lock lock
try
inflighttxlocations add location
finally
lock unlock
transactionstore removemessage this  ack  location
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
if  debug
log debug     ack getlastmessageid
location
lock lock
try
inflighttxlocations remove location
finally
lock unlock
removemessage ack  location
public void afterrollback   throws exception
if  debug
log debug     ack getlastmessageid
location
lock lock
try
inflighttxlocations remove location
finally
lock unlock
final void removemessage final messageack ack  final location location  throws interruptedioexception
referencedata data
lock lock
try
lastlocation   location
messageid id   ack getlastmessageid
data   messages remove id
if  data    null
messageacks add ack
else
// message never got written so datafilereference will still exist
amqmessagestore this peristenceadapter removeinprogressdatafile amqmessagestore this  data getfileid
finally
lock unlock
if  messageacks size   > this peristenceadapter getmaxcheckpointmessageaddsize
flush
else if  data    null
try
asyncwritetask wakeup
catch  interruptedexception e
throw new interruptedioexception
public boolean replayremovemessage connectioncontext context  messageack messageack
try
// only remove the message if it has not already been removed.
referencedata t   referencestore getmessagereference messageack getlastmessageid
if  t    null
referencestore removemessage context  messageack
return true
catch  throwable e
log warn     messageack getlastmessageid
e
return false
/**
* waits till the lastest data has landed on the referencestore
*
* @throws interruptedioexception
*/
public void flush   throws interruptedioexception
if  log isdebugenabled
log debug
countdownlatch countdown
lock lock
try
if  lastwrittenlocation    lastlocation
return
if  flushlatch    null
flushlatch   new countdownlatch 1
countdown   flushlatch
finally
lock unlock
try
asyncwritetask wakeup
countdown await
catch  interruptedexception e
throw new interruptedioexception
if  log isdebugenabled
log debug
/**
* @return
* @throws ioexception
*/
synchronized void asyncwrite
try
countdownlatch countdown
lock lock
try
countdown   flushlatch
flushlatch   null
finally
lock unlock
mark set doasyncwrite
if  countdown    null
countdown countdown
catch  ioexception e
log error     e  e
/**
* @return
* @throws ioexception
*/
protected location doasyncwrite   throws ioexception
final list<messageack> cpremovedmessagelocations
final list<location> cpactivejournallocations
final int maxcheckpointmessageaddsize   peristenceadapter getmaxcheckpointmessageaddsize
final location lastlocation
// swap out the message hash maps..
lock lock
try
cpaddedmessageids   this messages
cpremovedmessagelocations   this messageacks
cpactivejournallocations   new arraylist<location> inflighttxlocations
this messages   new linkedhashmap<messageid  referencedata>
this messageacks   new arraylist<messageack>
lastlocation   this lastlocation
finally
lock unlock
if  log isdebugenabled
log debug     cpaddedmessageids size
cpremovedmessagelocations size
transactiontemplate run new callback
public void execute   throws exception
int size   0
persistenceadapter persitanceadapter   transactiontemplate getpersistenceadapter
connectioncontext context   transactiontemplate getcontext
// checkpoint the added messages.
iterator<entry<messageid  referencedata>> iterator   cpaddedmessageids entryset   iterator
while  iterator hasnext
entry<messageid  referencedata> entry   iterator next
try
if  referencestore addmessagereference context  entry getkey    entry getvalue
if  log isdebugenabled
log debug     entry getkey
size
else
if  log isdebugenabled
log debug     entry getkey         entry getvalue
amqmessagestore this peristenceadapter removeinprogressdatafile amqmessagestore this  entry
getvalue   getfileid
catch  throwable e
log warn     e getmessage    e
// commit the batch if it's getting too big
if  size >  maxcheckpointmessageaddsize
persitanceadapter committransaction context
persitanceadapter begintransaction context
size   0
persitanceadapter committransaction context
persitanceadapter begintransaction context
// checkpoint the removed messages.
for  messageack ack   cpremovedmessagelocations
try
referencestore removemessage transactiontemplate getcontext    ack
catch  throwable e
log warn     e getmessage    e
log debug
lock lock
try
cpaddedmessageids   null
lastwrittenlocation   lastlocation
finally
lock unlock
if  cpactivejournallocations size   > 0
collections sort cpactivejournallocations
return cpactivejournallocations get 0
else
return lastlocation
/**
*
*/
public message getmessage messageid identity  throws ioexception
location location   getlocation identity
if  location    null
datastructure rc   peristenceadapter readcommand location
try
return  message  rc
catch  classcastexception e
throw new ioexception     identity       location
rc
return null
protected location getlocation messageid messageid  throws ioexception
referencedata data   null
lock lock
try
// is it still in flight???
data   messages get messageid
if  data    null    cpaddedmessageids    null
data   cpaddedmessageids get messageid
finally
lock unlock
if  data    null
data   referencestore getmessagereference messageid
if  data    null
return null
location location   new location
location setdatafileid data getfileid
location setoffset data getoffset
return location
/**
* replays the referencestore first as those messages are the oldest ones, then messages are replayed from the
* transaction log and then the cache is updated.
*
* @param listener
* @throws exception
*/
public void recover final messagerecoverylistener listener  throws exception
flush
referencestore recover new recoverylisteneradapter this  listener
public void start   throws exception
referencestore start
public void stop   throws exception
flush
asyncwritetask shutdown
referencestore stop
/**
* @return returns the longtermstore.
*/
public referencestore getreferencestore
return referencestore
/**
* @see org.apache.activemq.store.messagestore#removeallmessages(connectioncontext)
*/
public void removeallmessages connectioncontext context  throws ioexception
flush
referencestore removeallmessages context
public void addmessagereference connectioncontext context  messageid messageid  long expirationtime
string messageref  throws ioexception
throw new ioexception
public string getmessagereference messageid identity  throws ioexception
throw new ioexception
/**
* @return
* @throws ioexception
* @see org.apache.activemq.store.messagestore#getmessagecount()
*/
public int getmessagecount   throws ioexception
flush
return referencestore getmessagecount
public void recovernextmessages int maxreturned  messagerecoverylistener listener  throws exception
recoverylisteneradapter recoverylistener   new recoverylisteneradapter this  listener
referencestore recovernextmessages maxreturned  recoverylistener
if  recoverylistener size      0    recoverylistener hasspace
flush
referencestore recovernextmessages maxreturned  recoverylistener
message getmessage referencedata data  throws ioexception
location location   new location
location setdatafileid data getfileid
location setoffset data getoffset
datastructure rc   peristenceadapter readcommand location
try
return  message  rc
catch  classcastexception e
throw new ioexception     location
rc
public void resetbatching
referencestore resetbatching
public location getmark
return mark get
public void dispose connectioncontext context
try
flush
catch  interruptedioexception e
thread currentthread   interrupt
referencestore dispose context
super dispose context
public void setbatch messageid messageid
try
flush
catch  interruptedioexception e
log debug    e
getreferencestore   setbatch messageid