/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region
import org apache activemq broker brokerservice
import org apache activemq broker connectioncontext
import org apache activemq broker producerbrokerexchange
import org apache activemq broker region cursors pendingmessagecursor
import org apache activemq broker region cursors storequeuecursor
import org apache activemq broker region cursors vmpendingmessagecursor
import org apache activemq broker region group messagegrouphashbucketfactory
import org apache activemq broker region group messagegroupmap
import org apache activemq broker region group messagegroupmapfactory
import org apache activemq broker region policy dispatchpolicy
import org apache activemq broker region policy roundrobindispatchpolicy
import org apache activemq command activemqdestination
import org apache activemq command consumerid
import org apache activemq command exceptionresponse
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messagedispatchnotification
import org apache activemq command messageid
import org apache activemq command producerack
import org apache activemq command producerinfo
import org apache activemq command response
import org apache activemq filter booleanexpression
import org apache activemq filter messageevaluationcontext
import org apache activemq filter noncachedmessageevaluationcontext
import org apache activemq selector selectorparser
import org apache activemq store messagerecoverylistener
import org apache activemq store messagestore
import org apache activemq thread deterministictaskrunner
import org apache activemq thread scheduler
import org apache activemq thread task
import org apache activemq thread taskrunner
import org apache activemq thread taskrunnerfactory
import org apache activemq transaction synchronization
import org apache activemq usage usage
import org apache activemq usage usagelistener
import org apache activemq util brokersupport
import org apache commons logging log
import org apache commons logging logfactory
import java io ioexception
import java util abstractlist
import java util arraylist
import java util collection
import java util collections
import java util comparator
import java util hashset
import java util iterator
import java util linkedhashmap
import java util linkedlist
import java util list
import java util set
import java util concurrent copyonwritearrayset
import java util concurrent countdownlatch
import java util concurrent executorservice
import java util concurrent executors
import java util concurrent threadfactory
import java util concurrent timeunit
import javax jms invalidselectorexception
import javax jms jmsexception
/**
* the queue is a list of messageentry objects that are dispatched to matching
* subscriptions.
*
* @version $revision: 1.28 $
*/
public class queue extends basedestination implements task  usagelistener
protected static final log log   logfactory getlog queue class
protected taskrunnerfactory taskfactory
protected taskrunner taskrunner
protected final list<subscription> consumers   new arraylist<subscription> 50
protected pendingmessagecursor messages
private final linkedhashmap<messageid queuemessagereference> pagedinmessages   new linkedhashmap<messageid queuemessagereference>
// messages that are paged in but have not yet been targeted at a subscription
private list<queuemessagereference> pagedinpendingdispatch   new arraylist<queuemessagereference> 100
private messagegroupmap messagegroupowners
private dispatchpolicy dispatchpolicy   new roundrobindispatchpolicy
private messagegroupmapfactory messagegroupmapfactory   new messagegrouphashbucketfactory
private final object sendlock   new object
private executorservice executor
protected final linkedlist<runnable> messageswaitingforspace   new linkedlist<runnable>
private final object dispatchmutex   new object
private boolean useconsumerpriority true
private boolean strictorderdispatch false
private queuedispatchselector dispatchselector
private boolean optimizeddispatch false
private boolean firstconsumer   false
private int timebeforedispatchstarts   0
private int consumersbeforedispatchstarts   0
private countdownlatch consumersbeforestartslatch
private final runnable sendmessageswaitingforspacetask   new runnable
public void run
wakeup
private final runnable expiremessagestask   new runnable
public void run
expiremessages
private final object iteratingmutex   new object
private static final scheduler scheduler   scheduler getinstance
private static final comparator<subscription>orderedcompare   new comparator<subscription>
public int compare subscription s1  subscription s2
//we want the list sorted in descending order
return s2 getconsumerinfo   getpriority     s1 getconsumerinfo   getpriority
public queue brokerservice brokerservice  final activemqdestination destination  messagestore store destinationstatistics parentstats
taskrunnerfactory taskfactory  throws exception
super brokerservice  store  destination  parentstats
this taskfactory taskfactory
this dispatchselector new queuedispatchselector destination
public list<subscription> getconsumers
synchronized  consumers
return new arraylist<subscription> consumers
// make the queue easily visible in the debugger from its task runner threads
final class queuethread extends thread
final queue queue
public queuethread runnable runnable  string name
queue queue
super runnable  name
this queue   queue
public void initialize   throws exception
if  this messages    null
if  destination istemporary      broker    null    store    null
this messages   new vmpendingmessagecursor
else
this messages   new storequeuecursor broker  this
// if a vmpendingmessagecursor don't use the default producer system usage
// since it turns into a shared blocking queue which can lead to a network deadlock.
// if we are cursoring to disk..it's not and issue because it does not block due
// to large disk sizes.
if  messages instanceof vmpendingmessagecursor
this systemusage   brokerservice getsystemusage
memoryusage setparent systemusage getmemoryusage
if  isoptimizeddispatch
this taskrunner   taskfactory createtaskrunner this      destination getphysicalname
else
final queue queue   this
this executor    executors newsinglethreadexecutor new threadfactory
public thread newthread runnable runnable
thread thread   new queuethread runnable    destination  queue
thread setdaemon true
thread setpriority thread norm_priority
return thread
this taskrunner   new deterministictaskrunner this executor this
super initialize
if  store    null
// restore the persistent messages.
messages setsystemusage systemusage
messages setenableaudit isenableaudit
messages setmaxauditdepth getmaxauditdepth
messages setmaxproducerstoaudit getmaxproducerstoaudit
messages setusecache isusecache
messages setmemoryusagehighwatermark getcursormemoryhighwatermark
if  messages isrecoveryrequired
store recover new messagerecoverylistener
public boolean recovermessage message message
// message could have expired while it was being
// loaded..
if  broker isexpired message
messageexpired createconnectioncontext    createmessagereference message
// drop message will decrement so counter balance here
destinationstatistics getmessages   increment
return true
if  hasspace
message setregiondestination queue this
synchronized  messages
try
messages addmessagelast message
catch  exception e
log fatal    e
destinationstatistics getmessages   increment
return true
return false
public boolean recovermessagereference messageid messagereference  throws exception
throw new runtimeexception
public boolean hasspace
return true
public boolean isduplicate messageid id
return false
else
int messagecount   store getmessagecount
destinationstatistics getmessages   setcount messagecount
/*
* holder for subscription and pagedinmessages as a browser
* needs access to existing messages in the queue that have
* already been dispatched
*/
class browserdispatch
arraylist<queuemessagereference> messages
queuebrowsersubscription browser
public browserdispatch queuebrowsersubscription browsersubscription
collection<queuemessagereference> values
messages    new arraylist<queuemessagereference> values
browser   browsersubscription
browser incrementqueueref
void done
try
browser decrementqueueref
catch  exception e
log warn     browser  e
public queuebrowsersubscription getbrowser
return browser
linkedlist<browserdispatch> browserdispatches   new linkedlist<browserdispatch>
public void addsubscription connectioncontext context  subscription sub  throws exception
// synchronize with dispatch method so that no new messages are sent
// while setting up a subscription. avoid out of order messages,
// duplicates, etc.
synchronized dispatchmutex
sub add context  this
destinationstatistics getconsumers   increment
// needs to be synchronized - so no contention with dispatching
synchronized  consumers
// set a flag if this is a first consumer
if  consumers size      0
firstconsumer   true
if  consumersbeforedispatchstarts    0
consumersbeforestartslatch   new countdownlatch consumersbeforedispatchstarts   1
else
if  consumersbeforestartslatch    null
consumersbeforestartslatch countdown
addtoconsumerlist sub
if  sub getconsumerinfo   isexclusive
subscription exclusiveconsumer   dispatchselector getexclusiveconsumer
if exclusiveconsumer  null
exclusiveconsumer sub
else if  sub getconsumerinfo   getpriority   > exclusiveconsumer getconsumerinfo   getpriority
exclusiveconsumer sub
dispatchselector setexclusiveconsumer exclusiveconsumer
if  sub instanceof queuebrowsersubscription
queuebrowsersubscription browsersubscription    queuebrowsersubscription  sub
// do again in iterate to ensure new messages are dispatched
pageinmessages false
synchronized  pagedinmessages
if   pagedinmessages isempty
browserdispatch browserdispatch   new browserdispatch browsersubscription  pagedinmessages values
browserdispatches addlast browserdispatch
if    this optimizeddispatch    isslave
wakeup
if  this optimizeddispatch    isslave
// outside of dispatchlock() to maintain the lock hierarchy of
// iteratingmutex -> dispatchlock. - see https://issues.apache.org/activemq/browse/amq-1878
wakeup
public void removesubscription connectioncontext context  subscription sub  long lastdeiveredsequenceid
throws exception
destinationstatistics getconsumers   decrement
// synchronize with dispatch method so that no new messages are sent
// while removing up a subscription.
synchronized dispatchmutex
if  log isdebugenabled
log debug     sub       lastdeiveredsequenceid
getdestinationstatistics   getdequeues   getcount
getdestinationstatistics   getdispatched   getcount
getdestinationstatistics   getinflight   getcount
synchronized  consumers
removefromconsumerlist sub
if  sub getconsumerinfo   isexclusive
subscription exclusiveconsumer   dispatchselector
getexclusiveconsumer
if  exclusiveconsumer    sub
exclusiveconsumer   null
for  subscription s   consumers
if  s getconsumerinfo   isexclusive
exclusiveconsumer    null
s getconsumerinfo   getpriority   > exclusiveconsumer
getconsumerinfo   getpriority
exclusiveconsumer   s
dispatchselector setexclusiveconsumer exclusiveconsumer
consumerid consumerid   sub getconsumerinfo   getconsumerid
getmessagegroupowners   removeconsumer consumerid
// redeliver inflight messages
list<queuemessagereference> list   new arraylist<queuemessagereference>
for  messagereference ref   sub remove context  this
queuemessagereference qmr    queuemessagereference ref
if  qmr getlockowner    sub
qmr unlock
// only increment redelivery if it was delivered or we have no delivery information
if  lastdeiveredsequenceid    0    qmr getmessageid   getbrokersequenceid   <  lastdeiveredsequenceid
qmr incrementredeliverycounter
list add qmr
if   list isempty
dodispatch list
if    this optimizeddispatch    isslave
wakeup
if  this optimizeddispatch    isslave
// outside of dispatchlock() to maintain the lock hierarchy of
// iteratingmutex -> dispatchlock. - see https://issues.apache.org/activemq/browse/amq-1878
wakeup
public void send final producerbrokerexchange producerexchange  final message message  throws exception
final connectioncontext context   producerexchange getconnectioncontext
// there is delay between the client sending it and it arriving at the
// destination.. it may have expired.
message setregiondestination this
final producerinfo producerinfo   producerexchange getproducerstate   getinfo
final boolean sendproducerack    message isresponserequired      producerinfo getwindowsize   > 0     context isinrecoverymode
if  message isexpired
//message not stored - or added to stats yet - so chuck here
broker getroot   messageexpired context  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
return
if memoryusage isfull
isfull context  memoryusage
fastproducer context  producerinfo
if  isproducerflowcontrol      context isproducerflowcontrol
if warnonproducerflowcontrol
warnonproducerflowcontrol   false
log info    getactivemqdestination   getqualifiedname
if  systemusage issendfailifnospace
throw new javax jms resourceallocationexception     message getproducerid        getactivemqdestination   getqualifiedname
// we can avoid blocking due to low usage if the producer is sending
// a sync message or
// if it is using a producer window
if  producerinfo getwindowsize   > 0    message isresponserequired
// copy the exchange state since the context will be modified while we are waiting
// for space.
final producerbrokerexchange producerexchangecopy   producerexchange copy
synchronized  messageswaitingforspace
messageswaitingforspace add new runnable
public void run
try
// while waiting for space to free up... the
// message may have expired.
if  message isexpired
broker messageexpired context  message
destinationstatistics getexpired   increment
else
domessagesend producerexchangecopy  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
else
response response   new response
response setcorrelationid message getcommandid
context getconnection   dispatchasync response
catch  exception e
if   sendproducerack     context isinrecoverymode
exceptionresponse response   new exceptionresponse e
response setcorrelationid message getcommandid
context getconnection   dispatchasync response
// if the user manager is not full, then the task will not
// get called..
if   memoryusage notifycallbackwhennotfull sendmessageswaitingforspacetask
// so call it directly here.
sendmessageswaitingforspacetask run
context setdontsendreponse true
return
else
// producer flow control cannot be used, so we have do the flow
// control at the broker
// by blocking this thread until there is space available.
while   memoryusage waitforspace 1000
if  context getstopping   get
throw new ioexception
// the usage manager could have delayed us by the time
// we unblock the message could have expired..
if  message isexpired
if  log isdebugenabled
log debug     message
broker getroot   messageexpired context  message
return
domessagesend producerexchange  message
if  sendproducerack
producerack ack   new producerack producerinfo getproducerid    message getsize
context getconnection   dispatchasync ack
void domessagesend final producerbrokerexchange producerexchange  final message message  throws ioexception  exception
final connectioncontext context   producerexchange getconnectioncontext
synchronized  sendlock
if  store    null    message ispersistent
if  systemusage getstoreusage   isfull
final string logmessage       message getproducerid         getactivemqdestination   getqualifiedname
log info logmessage
if  systemusage issendfailifnospace
throw new javax jms resourceallocationexception logmessage
while   systemusage getstoreusage   waitforspace 1000
if  context getstopping   get
throw new ioexception
log debug this        message
message getmessageid   setbrokersequenceid getdestinationsequenceid
store addmessage context  message
if  context isintransaction
// if this is a transacted message.. increase the usage now so that
// a big tx does not blow up
// our memory. this increment is decremented once the tx finishes..
message incrementreferencecount
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
try
// it could take while before we receive the commit
// op, by that time the message could have expired..
if  broker isexpired message
broker messageexpired context  message
destinationstatistics getexpired   increment
return
sendmessage context  message
finally
message decrementreferencecount
@override
public void afterrollback   throws exception
message decrementreferencecount
else
// add to the pending list, this takes care of incrementing the
// usage manager.
sendmessage context  message
private void expiremessages
if  log isdebugenabled
log debug
// just track the insertion count
list<message> browsedmessages   new abstractlist<message>
int size   0
@override
public void add int index  message element
size
@override
public int size
return size
@override
public message get int index
return null
dobrowse true  browsedmessages  this getmaxexpirepagesize
public void gc
public void acknowledge connectioncontext context  subscription sub  messageack ack  messagereference node  throws ioexception
messageconsumed context  node
if  store    null    node ispersistent
// the original ack may be a ranged ack, but we are trying to delete a specific
// message store here so we need to convert to a non ranged ack.
if  ack getmessagecount   > 0
// dup the ack
messageack a   new messageack
ack copy a
ack   a
// convert to non-ranged.
ack setfirstmessageid node getmessageid
ack setlastmessageid node getmessageid
ack setmessagecount 1
store removemessage context  ack
message loadmessage messageid messageid  throws ioexception
message msg   store getmessage messageid
if  msg    null
msg setregiondestination this
return msg
public string tostring
int size   0
synchronized  messages
size   messages size
return     destination getphysicalname         consumers size         memoryusage getpercentusage         size
messagegroupowners
public void start   throws exception
if  memoryusage    null
memoryusage start
systemusage getmemoryusage   addusagelistener this
messages start
if  getexpiremessagesperiod   > 0
scheduler schedualperiodically expiremessagestask  getexpiremessagesperiod
dopagein false
public void stop   throws exception
if  taskrunner    null
taskrunner shutdown
if  this executor    null
this executor shutdownnow
scheduler cancel expiremessagestask
if  messages    null
messages stop
systemusage getmemoryusage   removeusagelistener this
if  memoryusage    null
memoryusage stop
if  store  null
store stop
// properties
// -------------------------------------------------------------------------
public activemqdestination getactivemqdestination
return destination
public messagegroupmap getmessagegroupowners
if  messagegroupowners    null
messagegroupowners   getmessagegroupmapfactory   createmessagegroupmap
return messagegroupowners
public dispatchpolicy getdispatchpolicy
return dispatchpolicy
public void setdispatchpolicy dispatchpolicy dispatchpolicy
this dispatchpolicy   dispatchpolicy
public messagegroupmapfactory getmessagegroupmapfactory
return messagegroupmapfactory
public void setmessagegroupmapfactory messagegroupmapfactory messagegroupmapfactory
this messagegroupmapfactory   messagegroupmapfactory
public pendingmessagecursor getmessages
return this messages
public void setmessages pendingmessagecursor messages
this messages   messages
public boolean isuseconsumerpriority
return useconsumerpriority
public void setuseconsumerpriority boolean useconsumerpriority
this useconsumerpriority   useconsumerpriority
public boolean isstrictorderdispatch
return strictorderdispatch
public void setstrictorderdispatch boolean strictorderdispatch
this strictorderdispatch   strictorderdispatch
public boolean isoptimizeddispatch
return optimizeddispatch
public void setoptimizeddispatch boolean optimizeddispatch
this optimizeddispatch   optimizeddispatch
public int gettimebeforedispatchstarts
return timebeforedispatchstarts
public void settimebeforedispatchstarts int timebeforedispatchstarts
this timebeforedispatchstarts   timebeforedispatchstarts
public int getconsumersbeforedispatchstarts
return consumersbeforedispatchstarts
public void setconsumersbeforedispatchstarts int consumersbeforedispatchstarts
this consumersbeforedispatchstarts   consumersbeforedispatchstarts
// implementation methods
// -------------------------------------------------------------------------
private queuemessagereference createmessagereference message message
queuemessagereference result   new indirectmessagereference message
return result
public message browse
list<message> l   new arraylist<message>
dobrowse false  l  getmaxbrowsepagesize
return l toarray new message
public void dobrowse boolean forcepagein  list<message> l  int max
final connectioncontext connectioncontext   createconnectioncontext
try
pageinmessages forcepagein
list<messagereference> toexpire   new arraylist<messagereference>
synchronized dispatchmutex
synchronized  pagedinpendingdispatch
addall pagedinpendingdispatch  l  max  toexpire
for  messagereference ref   toexpire
pagedinpendingdispatch remove ref
if  broker isexpired ref
messageexpired connectioncontext  ref
toexpire clear
synchronized  pagedinmessages
addall pagedinmessages values    l  max  toexpire
for  messagereference ref   toexpire
if  broker isexpired ref
messageexpired connectioncontext  ref
else
synchronized  pagedinmessages
pagedinmessages remove ref getmessageid
if  l size   < getmaxbrowsepagesize
synchronized  messages
try
messages reset
while  messages hasnext      l size   < max
messagereference node   messages next
messages rollback node getmessageid
if  node    null
if  broker isexpired node
messageexpired connectioncontext
createmessagereference node getmessage
else if  l contains node getmessage       false
l add node getmessage
finally
messages release
catch  exception e
log error    e
private void addall collection<queuemessagereference> refs
list<message> l  int maxbrowsepagesize  list<messagereference> toexpire  throws exception
for  iterator<queuemessagereference> i   refs iterator    i hasnext
l size   < getmaxbrowsepagesize
queuemessagereference ref   i next
if  ref isexpired
toexpire add ref
else if  l contains ref getmessage       false
l add ref getmessage
public message getmessage string id
messageid msgid   new messageid id
try
synchronized  pagedinmessages
queuemessagereference r   this pagedinmessages get msgid
if  r    null
return r getmessage
synchronized  messages
try
messages reset
while  messages hasnext
try
messagereference r   messages next
messages rollback r getmessageid
if  msgid equals r getmessageid
message m   r getmessage
if  m    null
return m
break
catch  ioexception e
log error
id
finally
messages release
catch  ioexception e
log error     id
return null
public void purge   throws exception
connectioncontext c   createconnectioncontext
list<messagereference> list   null
do
pageinmessages
synchronized  pagedinmessages
list   new arraylist<messagereference> pagedinmessages values
for  messagereference ref   list
try
queuemessagereference r    queuemessagereference  ref
removemessage c  indirectmessagereference  r
catch  ioexception e
while   pagedinmessages isempty      this destinationstatistics getmessages   getcount   > 0
gc
this destinationstatistics getmessages   setcount 0
getmessages   clear
/**
* removes the message matching the given messageid
*/
public boolean removemessage string messageid  throws exception
return removematchingmessages createmessageidfilter messageid   1  > 0
/**
* removes the messages matching the given selector
*
* @return the number of messages removed
*/
public int removematchingmessages string selector  throws exception
return removematchingmessages selector   1
/**
* removes the messages matching the given selector up to the maximum number
* of matched messages
*
* @return the number of messages removed
*/
public int removematchingmessages string selector  int maximummessages  throws exception
return removematchingmessages createselectorfilter selector   maximummessages
/**
* removes the messages matching the given filter up to the maximum number
* of matched messages
*
* @return the number of messages removed
*/
public int removematchingmessages messagereferencefilter filter  int maximummessages  throws exception
int movedcounter   0
set<messagereference> set   new copyonwritearrayset<messagereference>
connectioncontext context   createconnectioncontext
do
pageinmessages
synchronized  pagedinmessages
set addall pagedinmessages values
list <messagereference>list   new arraylist<messagereference> set
for  messagereference ref   list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
removemessage context  r
set remove r
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
while  set size   < this destinationstatistics getmessages   getcount
return movedcounter
/**
* copies the message matching the given messageid
*/
public boolean copymessageto connectioncontext context  string messageid  activemqdestination dest  throws exception
return copymatchingmessages context  createmessageidfilter messageid   dest  1  > 0
/**
* copies the messages matching the given selector
*
* @return the number of messages copied
*/
public int copymatchingmessagesto connectioncontext context  string selector  activemqdestination dest  throws exception
return copymatchingmessagesto context  selector  dest   1
/**
* copies the messages matching the given selector up to the maximum number
* of matched messages
*
* @return the number of messages copied
*/
public int copymatchingmessagesto connectioncontext context  string selector  activemqdestination dest  int maximummessages  throws exception
return copymatchingmessages context  createselectorfilter selector   dest  maximummessages
/**
* copies the messages matching the given filter up to the maximum number of
* matched messages
*
* @return the number of messages copied
*/
public int copymatchingmessages connectioncontext context  messagereferencefilter filter  activemqdestination dest  int maximummessages  throws exception
int movedcounter   0
int count   0
set<messagereference> set   new copyonwritearrayset<messagereference>
do
int oldmaxsize getmaxpagesize
setmaxpagesize  int  this destinationstatistics getmessages   getcount
pageinmessages
setmaxpagesize oldmaxsize
synchronized  pagedinmessages
set addall pagedinmessages values
list <messagereference>list   new arraylist<messagereference> set
for  messagereference ref   list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
r incrementreferencecount
try
message m   r getmessage
brokersupport resend context  m  dest
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
finally
r decrementreferencecount
count
while  count < this destinationstatistics getmessages   getcount
return movedcounter
/**
* move a message
* @param context connection context
* @param m message
* @param dest activemqdestination
* @throws exception
*/
public boolean movemessageto connectioncontext context message m activemqdestination dest  throws exception
queuemessagereference r   createmessagereference m
brokersupport resend context  m  dest
removemessage context  r
synchronized  messages
messages rollback r getmessageid
return true
/**
* moves the message matching the given messageid
*/
public boolean movemessageto connectioncontext context  string messageid  activemqdestination dest  throws exception
return movematchingmessagesto context  createmessageidfilter messageid   dest  1  > 0
/**
* moves the messages matching the given selector
*
* @return the number of messages removed
*/
public int movematchingmessagesto connectioncontext context  string selector  activemqdestination dest  throws exception
return movematchingmessagesto context  selector  dest integer max_value
/**
* moves the messages matching the given selector up to the maximum number
* of matched messages
*/
public int movematchingmessagesto connectioncontext context  string selector  activemqdestination dest  int maximummessages  throws exception
return movematchingmessagesto context  createselectorfilter selector   dest  maximummessages
/**
* moves the messages matching the given filter up to the maximum number of
* matched messages
*/
public int movematchingmessagesto connectioncontext context
messagereferencefilter filter  activemqdestination dest
int maximummessages  throws exception
int movedcounter   0
set<messagereference> set   new copyonwritearrayset<messagereference>
do
dopagein true
synchronized  pagedinmessages
set addall pagedinmessages values
list<messagereference> list   new arraylist<messagereference> set
for  messagereference ref   list
indirectmessagereference r    indirectmessagereference  ref
if  filter evaluate context  r
// we should only move messages that can be locked.
movemessageto context  ref getmessage    dest
set remove r
if    movedcounter >  maximummessages
maximummessages > 0
return movedcounter
while  set size   < this destinationstatistics getmessages   getcount
set size   < maximummessages
return movedcounter
browserdispatch getnextbrowserdispatch
synchronized  pagedinmessages
if  browserdispatches isempty
return null
return browserdispatches removefirst
/**
* @return true if we would like to iterate again
* @see org.apache.activemq.thread.task#iterate()
*/
public boolean iterate
boolean pageinmoremessages   false
synchronized iteratingmutex
// do early to allow dispatch of these waiting messages
synchronized messageswaitingforspace
while   messageswaitingforspace isempty       memoryusage isfull
runnable op   messageswaitingforspace removefirst
op run
browserdispatch rd
while   rd   getnextbrowserdispatch       null
pageinmoremessages   true
try
messageevaluationcontext msgcontext   new noncachedmessageevaluationcontext
msgcontext setdestination destination
queuebrowsersubscription browser   rd getbrowser
for  queuemessagereference node   rd messages
if   node isacked
msgcontext setmessagereference node
if  browser matches node  msgcontext
browser add node
rd done
catch  exception e
log warn     rd getbrowser    e
if  firstconsumer
firstconsumer   false
try
if  consumersbeforedispatchstarts > 0
int timeout   1000     wait one second by default if consumer count isn't reached
if  timebeforedispatchstarts > 0
timeout   timebeforedispatchstarts
if  consumersbeforestartslatch await timeout  timeunit milliseconds
if  log isdebugenabled
log debug consumers size
else
if  log isdebugenabled
log debug timeout        consumers size
if  timebeforedispatchstarts > 0    consumersbeforedispatchstarts <  0
iteratingmutex wait timebeforedispatchstarts
if  log isdebugenabled
log debug timebeforedispatchstarts
catch  exception e
log error e
synchronized  messages
pageinmoremessages     messages isempty
// kinda ugly.. but i think dispatchlock is the only mutex protecting the
// pagedinpendingdispatch variable.
synchronized dispatchmutex
pageinmoremessages     pagedinpendingdispatch isempty
// perhaps we should page always into the pagedinpendingdispatch list is
// !messages.isempty(), and then if !pagedinpendingdispatch.isempty()
// then we do a dispatch.
if  pageinmoremessages
try
pageinmessages false
catch  throwable e
log error    e
return  messageswaitingforspace isempty
protected messagereferencefilter createmessageidfilter final string messageid
return new messagereferencefilter
public boolean evaluate connectioncontext context  messagereference r
return messageid equals r getmessageid   tostring
public string tostring
return   messageid
protected messagereferencefilter createselectorfilter string selector  throws invalidselectorexception
final booleanexpression selectorexpression   selectorparser parse selector
return new messagereferencefilter
public boolean evaluate connectioncontext context  messagereference r  throws jmsexception
messageevaluationcontext messageevaluationcontext   context getmessageevaluationcontext
messageevaluationcontext setmessagereference r
if  messageevaluationcontext getdestination      null
messageevaluationcontext setdestination getactivemqdestination
return selectorexpression matches messageevaluationcontext
protected void removemessage connectioncontext c  queuemessagereference r  throws ioexception
removemessage c  null  r
protected void removemessage connectioncontext c  subscription subs queuemessagereference r  throws ioexception
messageack ack   new messageack
ack setacktype messageack standard_ack_type
ack setdestination destination
ack setmessageid r getmessageid
removemessage c  subs  r  ack
protected void removemessage connectioncontext context subscription sub final queuemessagereference reference messageack ack  throws ioexception
reference setacked true
// this sends the ack the the journal..
if   ack isintransaction
acknowledge context  sub  ack  reference
getdestinationstatistics   getdequeues   increment
dropmessage reference
else
try
acknowledge context  sub  ack  reference
finally
context gettransaction   addsynchronization new synchronization
public void aftercommit   throws exception
getdestinationstatistics   getdequeues   increment
dropmessage reference
wakeup
public void afterrollback   throws exception
reference setacked false
if  ack ispoisonack
// message gone to dlq, is ok to allow redelivery
synchronized messages
messages rollback reference getmessageid
private void dropmessage queuemessagereference reference
reference drop
destinationstatistics getmessages   decrement
synchronized pagedinmessages
pagedinmessages remove reference getmessageid
public void messageexpired connectioncontext context messagereference reference
messageexpired context null reference
public void messageexpired connectioncontext context subscription subs  messagereference reference
if  log isdebugenabled
log debug     reference
broker messageexpired context  reference
destinationstatistics getexpired   increment
try
removemessage context subs  queuemessagereference reference
catch  ioexception e
log error   e
asyncwakeup
protected connectioncontext createconnectioncontext
connectioncontext answer   new connectioncontext new noncachedmessageevaluationcontext
answer setbroker this broker
answer getmessageevaluationcontext   setdestination getactivemqdestination
return answer
final void sendmessage final connectioncontext context  message msg  throws exception
if   msg ispersistent      messages getsystemusage      null
if  systemusage gettempusage   isfull
final string logmessage       msg getproducerid         getactivemqdestination   getqualifiedname
log info logmessage
if  systemusage issendfailifnospace
throw new javax jms resourceallocationexception logmessage
messages getsystemusage   gettempusage   waitforspace
synchronized messages
messages addmessagelast msg
destinationstatistics getenqueues   increment
destinationstatistics getmessages   increment
messagedelivered context  msg
synchronized  consumers
if  consumers isempty
onmessagewithnoconsumers context  msg
wakeup
public void wakeup
if  optimizeddispatch    isslave
iterate
else
asyncwakeup
public void asyncwakeup
try
this taskrunner wakeup
catch  interruptedexception e
log warn    e
private boolean isslave
return broker getbrokerservice   isslave
private list<queuemessagereference> dopagein boolean force  throws exception
list<queuemessagereference> result   null
list<queuemessagereference> resultlist   null
synchronized dispatchmutex
int topagein   math min getmaxpagesize    messages size
if  log isdebugenabled
log debug destination getphysicalname          topagein
destinationstatistics getinflight   getcount
pagedinmessages size
if  islazydispatch      force
// only page in the minimum number of messages which can be dispatched immediately.
topagein   math min getconsumermessagecountbeforefull    topagein
if   force     consumers isempty       topagein > 0
int count   0
result   new arraylist<queuemessagereference> topagein
synchronized  messages
try
messages setmaxbatchsize topagein
messages reset
while  messages hasnext      count < topagein
messagereference node   messages next
node incrementreferencecount
messages remove
queuemessagereference ref   createmessagereference node getmessage
if   broker isexpired node
result add ref
count
else
messageexpired createconnectioncontext    ref
finally
messages release
// only add new messages, not already pagedin to avoid multiple dispatch attempts
synchronized  pagedinmessages
resultlist   new arraylist<queuemessagereference> result size
for queuemessagereference ref   result
if   pagedinmessages containskey ref getmessageid
pagedinmessages put ref getmessageid    ref
resultlist add ref
else
// avoid return null list, if condition is not validated
resultlist   new arraylist<queuemessagereference>
return resultlist
private void dodispatch list<queuemessagereference> list  throws exception
boolean dowakeup   false
synchronized dispatchmutex
synchronized  pagedinpendingdispatch
if   pagedinpendingdispatch isempty
// try to first dispatch anything that had not been
// dispatched before.
pagedinpendingdispatch   doactualdispatch pagedinpendingdispatch
// and now see if we can dispatch the new stuff.. and append to
// the pending
// list anything that does not actually get dispatched.
if  list    null     list isempty
if  pagedinpendingdispatch isempty
pagedinpendingdispatch addall doactualdispatch list
else
for  queuemessagereference qmr   list
if   pagedinpendingdispatch contains qmr
pagedinpendingdispatch add qmr
dowakeup    true
if  dowakeup
wakeup
/**
* @return list of messages that could get dispatched to consumers if they
*         were not full.
*/
private list<queuemessagereference> doactualdispatch list<queuemessagereference> list  throws exception
list<subscription> consumers
synchronized  this consumers
if  this consumers isempty      isslave
// slave dispatch happens in processdispatchnotification
return list
consumers   new arraylist<subscription> this consumers
list<queuemessagereference> rc   new arraylist<queuemessagereference> list size
set<subscription> fullconsumers   new hashset<subscription> this consumers size
for  messagereference node   list
subscription target   null
int interestcount 0
for  subscription s   consumers
if  s instanceof queuebrowsersubscription
interestcount
continue
if  dispatchselector canselect s  node
if   fullconsumers contains s
if   s isfull
// dispatch it.
s add node
target   s
break
else
// no further dispatch of list to a full consumer to avoid out of order message receipt
fullconsumers add s
interestcount
else
// makes sure it gets dispatched again
if   node isdropped         queuemessagereference node  isacked        node isdropped      s getconsumerinfo   isbrowser
interestcount
if   target    null    interestcount>0     consumers size      0
// this means all subs were full or that there are no consumers...
rc add  queuemessagereference node
// if it got dispatched, rotate the consumer list to get round robin distribution.
if  target    null     strictorderdispatch    consumers size   > 1
dispatchselector isexclusiveconsumer target
synchronized  this consumers
if  removefromconsumerlist target
addtoconsumerlist target
consumers   new arraylist<subscription> this consumers
return rc
private void pageinmessages   throws exception
pageinmessages true
protected void pageinmessages boolean force  throws exception
dodispatch dopagein force
private void addtoconsumerlist subscription sub
if  useconsumerpriority
consumers add sub
collections sort consumers  orderedcompare
else
consumers add sub
private boolean removefromconsumerlist subscription sub
return consumers remove sub
private int getconsumermessagecountbeforefull   throws exception
int total   0
boolean zeroprefetch   false
synchronized  consumers
for  subscription s   consumers
zeroprefetch    s getprefetchsize      0
int countbeforefull   s countbeforefull
total    countbeforefull
if  total  0    zeroprefetch
total 1
return total
/*
* in slave mode, dispatch is ignored till we get this notification as the dispatch
* process is non deterministic between master and slave.
* on a notification, the actual dispatch to the subscription (as chosen by the master)
* is completed.
* (non-javadoc)
* @see org.apache.activemq.broker.region.basedestination#processdispatchnotification(org.apache.activemq.command.messagedispatchnotification)
*/
public void processdispatchnotification
messagedispatchnotification messagedispatchnotification  throws exception
// do dispatch
subscription sub   getmatchingsubscription messagedispatchnotification
if  sub    null
messagereference message   getmatchingmessage messagedispatchnotification
sub add message
sub processmessagedispatchnotification messagedispatchnotification
private queuemessagereference getmatchingmessage messagedispatchnotification messagedispatchnotification  throws exception
queuemessagereference message   null
messageid messageid   messagedispatchnotification getmessageid
synchronized dispatchmutex
synchronized  pagedinpendingdispatch
for queuemessagereference ref   pagedinpendingdispatch
if  messageid equals ref getmessageid
message   ref
pagedinpendingdispatch remove ref
break
if  message    null
synchronized  pagedinmessages
message   pagedinmessages get messageid
if  message    null
synchronized  messages
try
messages setmaxbatchsize getmaxpagesize
messages reset
while  messages hasnext
messagereference node   messages next
node incrementreferencecount
messages remove
if  messageid equals node getmessageid
message   this createmessagereference node getmessage
break
finally
messages release
if  message    null
message msg   loadmessage messageid
if  msg    null
message   this createmessagereference msg
if  message    null
throw new jmsexception
messagedispatchnotification getmessageid
messagedispatchnotification getdestination
pagedinpendingdispatch size
messagedispatchnotification getconsumerid
return message
/**
* find a consumer that matches the id in the message dispatch notification
* @param messagedispatchnotification
* @return sub or null if the subscription has been removed before dispatch
* @throws jmsexception
*/
private subscription getmatchingsubscription messagedispatchnotification messagedispatchnotification  throws jmsexception
subscription sub   null
synchronized  consumers
for  subscription s   consumers
if  messagedispatchnotification getconsumerid   equals s getconsumerinfo   getconsumerid
sub   s
break
return sub
public void onusagechanged usage usage  int oldpercentusage  int newpercentusage
if  oldpercentusage > newpercentusage
asyncwakeup