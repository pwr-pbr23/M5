/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq broker region
import java util hashset
import java util iterator
import java util list
import java util set
import java util concurrent concurrenthashmap
import javax jms invaliddestinationexception
import javax jms jmsexception
import org apache activemq advisory advisorysupport
import org apache activemq broker connectioncontext
import org apache activemq broker region policy policyentry
import org apache activemq command activemqdestination
import org apache activemq command connectionid
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command removesubscriptioninfo
import org apache activemq command sessionid
import org apache activemq command subscriptioninfo
import org apache activemq store topicmessagestore
import org apache activemq thread taskrunnerfactory
import org apache activemq usage systemusage
import org apache activemq util longsequencegenerator
import org apache activemq util subscriptionkey
import org apache commons logging log
import org apache commons logging logfactory
/**
* @version $revision: 1.12 $
*/
public class topicregion extends abstractregion
private static final log log   logfactory getlog topicregion class
protected final concurrenthashmap<subscriptionkey  durabletopicsubscription> durablesubscriptions   new concurrenthashmap<subscriptionkey  durabletopicsubscription>
private final longsequencegenerator recovereddurablesubidgenerator   new longsequencegenerator
private final sessionid recovereddurablesubsessionid   new sessionid new connectionid     recovereddurablesubidgenerator getnextsequenceid
private boolean keepdurablesubsactive
public topicregion regionbroker broker  destinationstatistics destinationstatistics  systemusage memorymanager  taskrunnerfactory taskrunnerfactory
destinationfactory destinationfactory
super broker  destinationstatistics  memorymanager  taskrunnerfactory  destinationfactory
public subscription addconsumer connectioncontext context  consumerinfo info  throws exception
if  info isdurable
activemqdestination destination   info getdestination
if   destination ispattern
// make sure the destination is created.
lookup context  destination
string clientid   context getclientid
string subscriptionname   info getsubscriptionname
subscriptionkey key   new subscriptionkey clientid  subscriptionname
durabletopicsubscription sub   durablesubscriptions get key
if  sub    null
if  sub isactive
throw new jmsexception     clientid       subscriptionname
// has the selector changed??
if  hasdurablesubchanged info  sub getconsumerinfo
// remove the consumer first then add it.
durablesubscriptions remove key
synchronized  destinationsmutex
for  iterator<destination> iter   destinations values   iterator    iter hasnext
destination dest   iter next
//account for virtual destinations
if  dest instanceof topic
topic topic    topic dest
topic deletesubscription context  key
super removeconsumer context  sub getconsumerinfo
super addconsumer context  info
sub   durablesubscriptions get key
else
// change the consumer id key of the durable sub.
if  sub getconsumerinfo   getconsumerid      null
subscriptions remove sub getconsumerinfo   getconsumerid
subscriptions put info getconsumerid    sub
else
super addconsumer context  info
sub   durablesubscriptions get key
if  sub    null
throw new jmsexception     info getconsumerid         key getclientid
key getsubscriptionname
sub activate usagemanager  context  info
return sub
else
return super addconsumer context  info
public void removeconsumer connectioncontext context  consumerinfo info  throws exception
if  info isdurable
subscriptionkey key   new subscriptionkey context getclientid    info getsubscriptionname
durabletopicsubscription sub   durablesubscriptions get key
if  sub    null
sub deactivate keepdurablesubsactive
else
super removeconsumer context  info
public void removesubscription connectioncontext context  removesubscriptioninfo info  throws exception
subscriptionkey key   new subscriptionkey info getclientid    info getsubscriptionname
durabletopicsubscription sub   durablesubscriptions get key
if  sub    null
throw new invaliddestinationexception     info getsubscriptionname
if  sub isactive
throw new jmsexception
durablesubscriptions remove key
synchronized  destinationsmutex
for  iterator<destination> iter   destinations values   iterator    iter hasnext
destination dest   iter next
//account for virtual destinations
if  dest instanceof topic
topic topic    topic dest
topic deletesubscription context  key
super removeconsumer context  sub getconsumerinfo
public string tostring
return     destinations size         subscriptions size         usagemanager getmemoryusage   getpercentusage
@override
protected list<subscription> addsubscriptionsfordestination connectioncontext context  destination dest  throws exception
list<subscription> rc   super addsubscriptionsfordestination context  dest
set<subscription> dupchecker   new hashset<subscription> rc
topicmessagestore store    topicmessagestore dest getmessagestore
// eagerly recover the durable subscriptions
if  store    null
subscriptioninfo infos   store getallsubscriptions
for  int i   0  i < infos length  i
subscriptioninfo info   infos
log debug     infos
subscriptionkey key   new subscriptionkey info
// a single durable sub may be subscribing to multiple topics.
// so it might exist already.
durabletopicsubscription sub   durablesubscriptions get key
consumerinfo consumerinfo   createinactiveconsumerinfo info
if  sub    null
connectioncontext c   new connectioncontext
c setbroker context getbroker
c setclientid key getclientid
c setconnectionid consumerinfo getconsumerid   getparentid   getparentid
sub    durabletopicsubscription createsubscription c  consumerinfo
if  dupchecker contains sub
continue
dupchecker add sub
rc add sub
dest addsubscription context  sub
// now perhaps there other durable subscriptions (via wild card)
// that would match this destination..
durablesubscriptions values
for  iterator<durabletopicsubscription> iterator   durablesubscriptions values   iterator    iterator hasnext
durabletopicsubscription sub   iterator next
// skip over subscriptions that we allready added..
if  dupchecker contains sub
continue
if  sub matches dest getactivemqdestination
rc add sub
dest addsubscription context  sub
return rc
private consumerinfo createinactiveconsumerinfo subscriptioninfo info
consumerinfo rc   new consumerinfo
rc setselector info getselector
rc setsubscriptionname info getsubscriptionname
rc setdestination info getsubscribeddestination
rc setconsumerid createconsumerid
return rc
private consumerid createconsumerid
return new consumerid recovereddurablesubsessionid  recovereddurablesubidgenerator getnextsequenceid
protected void configuretopic topic topic  activemqdestination destination
if  broker getdestinationpolicy      null
policyentry entry   broker getdestinationpolicy   getentryfor destination
if  entry    null
entry configure topic
protected subscription createsubscription connectioncontext context  consumerinfo info  throws jmsexception
activemqdestination destination   info getdestination
if  info isdurable
if  advisorysupport isadvisorytopic info getdestination
throw new jmsexception
subscriptionkey key   new subscriptionkey context getclientid    info getsubscriptionname
durabletopicsubscription sub   durablesubscriptions get key
if  sub    null
sub   new durabletopicsubscription broker  usagemanager  context  info  keepdurablesubsactive
if  destination    null    broker getdestinationpolicy      null
policyentry entry   broker getdestinationpolicy   getentryfor destination
if  entry    null
entry configure broker  usagemanager  sub
durablesubscriptions put key  sub
else
throw new jmsexception
return sub
try
topicsubscription answer   new topicsubscription broker  context  info  usagemanager
// lets configure the subscription depending on the destination
if  destination    null    broker getdestinationpolicy      null
policyentry entry   broker getdestinationpolicy   getentryfor destination
if  entry    null
entry configure broker  usagemanager  answer
answer init
return answer
catch  exception e
log error    e
jmsexception jmsex   new jmsexception
jmsex setlinkedexception e
throw jmsex
/**
*/
private boolean hasdurablesubchanged consumerinfo info1  consumerinfo info2
if  info1 getselector      null ^ info2 getselector      null
return true
if  info1 getselector      null     info1 getselector   equals info2 getselector
return true
return  info1 getdestination   equals info2 getdestination
protected set<activemqdestination> getinactivedestinations
set<activemqdestination> inactivedestinations   super getinactivedestinations
for  iterator<activemqdestination> iter   inactivedestinations iterator    iter hasnext
activemqdestination dest   iter next
if   dest istopic
iter remove
return inactivedestinations
public boolean iskeepdurablesubsactive
return keepdurablesubsactive
public void setkeepdurablesubsactive boolean keepdurablesubsactive
this keepdurablesubsactive   keepdurablesubsactive