/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache activemq network
import java io ioexception
import java security generalsecurityexception
import java util collection
import java util list
import java util properties
import java util concurrent concurrenthashmap
import java util concurrent countdownlatch
import java util concurrent synchronousqueue
import java util concurrent threadfactory
import java util concurrent threadpoolexecutor
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomiclong
import org apache activemq service
import org apache activemq advisory advisorysupport
import org apache activemq broker brokerservice
import org apache activemq broker brokerserviceaware
import org apache activemq broker transportconnection
import org apache activemq broker region abstractregion
import org apache activemq broker region regionbroker
import org apache activemq broker region subscription
import org apache activemq command activemqdestination
import org apache activemq command activemqmessage
import org apache activemq command activemqtempdestination
import org apache activemq command activemqtopic
import org apache activemq command brokerid
import org apache activemq command brokerinfo
import org apache activemq command command
import org apache activemq command connectionerror
import org apache activemq command connectionid
import org apache activemq command connectioninfo
import org apache activemq command consumerid
import org apache activemq command consumerinfo
import org apache activemq command datastructure
import org apache activemq command destinationinfo
import org apache activemq command exceptionresponse
import org apache activemq command keepaliveinfo
import org apache activemq command message
import org apache activemq command messageack
import org apache activemq command messagedispatch
import org apache activemq command networkbridgefilter
import org apache activemq command producerinfo
import org apache activemq command removeinfo
import org apache activemq command response
import org apache activemq command sessioninfo
import org apache activemq command shutdowninfo
import org apache activemq command wireformatinfo
import org apache activemq filter destinationfilter
import org apache activemq transport defaulttransportlistener
import org apache activemq transport futureresponse
import org apache activemq transport responsecallback
import org apache activemq transport transport
import org apache activemq transport transportdisposedioexception
import org apache activemq transport transportlistener
import org apache activemq util idgenerator
import org apache activemq util introspectionsupport
import org apache activemq util longsequencegenerator
import org apache activemq util marshallingsupport
import org apache activemq util servicestopper
import org apache activemq util servicesupport
import org apache commons logging log
import org apache commons logging logfactory
/**
* a useful base class for implementing demand forwarding bridges.
*
* @version $revision$
*/
public abstract class demandforwardingbridgesupport implements networkbridge  brokerserviceaware
private static final log log   logfactory getlog demandforwardingbridge class
private static final threadpoolexecutor async_tasks
protected final transport localbroker
protected final transport remotebroker
protected final idgenerator idgenerator   new idgenerator
protected final longsequencegenerator consumeridgenerator   new longsequencegenerator
protected connectioninfo localconnectioninfo
protected connectioninfo remoteconnectioninfo
protected sessioninfo localsessioninfo
protected producerinfo producerinfo
protected string remotebrokername
protected string localclientid
protected consumerinfo demandconsumerinfo
protected int demandconsumerdispatched
protected final atomicboolean localbridgestarted   new atomicboolean false
protected final atomicboolean remotebridgestarted   new atomicboolean false
protected atomicboolean disposed   new atomicboolean
protected brokerid localbrokerid
protected activemqdestination excludeddestinations
protected activemqdestination dynamicallyincludeddestinations
protected activemqdestination staticallyincludeddestinations
protected activemqdestination durabledestinations
protected final concurrenthashmap<consumerid  demandsubscription> subscriptionmapbylocalid   new concurrenthashmap<consumerid  demandsubscription>
protected final concurrenthashmap<consumerid  demandsubscription> subscriptionmapbyremoteid   new concurrenthashmap<consumerid  demandsubscription>
protected final brokerid localbrokerpath   new brokerid  null
protected countdownlatch startedlatch   new countdownlatch 2
protected countdownlatch localstartedlatch   new countdownlatch 1
protected countdownlatch remotebrokernameknownlatch   new countdownlatch 1
protected countdownlatch localbrokeridknownlatch   new countdownlatch 1
protected final atomicboolean remoteinterupted   new atomicboolean false
protected final atomicboolean lastconnectsucceeded   new atomicboolean false
protected networkbridgeconfiguration configuration
final atomiclong enqueuecounter   new atomiclong
final atomiclong dequeuecounter   new atomiclong
private networkbridgelistener networkbridgelistener
private boolean createdbyduplex
private brokerinfo localbrokerinfo
private brokerinfo remotebrokerinfo
private atomicboolean started   new atomicboolean
private transportconnection duplexinitiatingconnection
private brokerservice brokerservice   null
public demandforwardingbridgesupport networkbridgeconfiguration configuration  transport localbroker  transport remotebroker
this configuration   configuration
this localbroker   localbroker
this remotebroker   remotebroker
public void duplexstart transportconnection connection  brokerinfo localbrokerinfo  brokerinfo remotebrokerinfo  throws exception
this localbrokerinfo   localbrokerinfo
this remotebrokerinfo   remotebrokerinfo
this duplexinitiatingconnection   connection
start
serviceremotecommand remotebrokerinfo
public void start   throws exception
if  started compareandset false  true
localbroker settransportlistener new defaulttransportlistener
public void oncommand object o
command command    command o
servicelocalcommand command
public void onexception ioexception error
servicelocalexception error
remotebroker settransportlistener new transportlistener
public void oncommand object o
command command    command o
serviceremotecommand command
public void onexception ioexception error
serviceremoteexception error
public void transportinterupted
// clear any subscriptions - to try and prevent the bridge
// from stalling the broker
if  remoteinterupted compareandset false  true
log info     remotebrokername
if  localbridgestarted get
cleardownsubscriptions
synchronized  demandforwardingbridgesupport this
try
localbroker oneway localconnectioninfo createremovecommand
catch  transportdisposedioexception td
log debug    td
catch  ioexception e
log warn    e
localbridgestarted set false
remotebridgestarted set false
startedlatch   new countdownlatch 2
localstartedlatch   new countdownlatch 1
public void transportresumed
if  remoteinterupted compareandset true  false
// we want to slow down false connects so that we don't
// get in a busy loop.
// false connects can occurr if you using ssh tunnels.
if   lastconnectsucceeded get
try
log debug
thread sleep 1000
catch  interruptedexception e
thread currentthread   interrupt
lastconnectsucceeded set false
try
startlocalbridge
remotebridgestarted set true
startedlatch countdown
log info     remotebrokername
catch  exception e
log error    e
localbroker start
remotebroker start
if  configuration isduplex      duplexinitiatingconnection    null
// initiator side of duplex network
remotebrokernameknownlatch await
try
triggerremotestartbridge
catch  ioexception e
log warn    e
networkbridgelistener l   this networkbridgelistener
if  l    null
l onstart this
protected void triggerlocalstartbridge   throws ioexception
async_tasks execute new runnable
public void run
final string originalname   thread currentthread   getname
thread currentthread   setname     localbroker
try
startlocalbridge
catch  exception e
servicelocalexception e
finally
thread currentthread   setname originalname
protected void triggerremotestartbridge   throws ioexception
async_tasks execute new runnable
public void run
final string originalname   thread currentthread   getname
thread currentthread   setname     localbroker
try
startremotebridge
catch  exception e
serviceremoteexception e
finally
thread currentthread   setname originalname
protected void startlocalbridge   throws exception
if  localbridgestarted compareandset false  true
synchronized  this
if  log istraceenabled
log trace configuration getbrokername         localbroker
remotebrokernameknownlatch await
localconnectioninfo   new connectioninfo
localconnectioninfo setconnectionid new connectionid idgenerator generateid
localclientid       remotebrokername       configuration getbrokername
localconnectioninfo setclientid localclientid
localconnectioninfo setusername configuration getusername
localconnectioninfo setpassword configuration getpassword
localbroker oneway localconnectioninfo
localsessioninfo   new sessioninfo localconnectioninfo  1
localbroker oneway localsessioninfo
log info     localbroker       remotebroker       remotebrokername
startedlatch countdown
localstartedlatch countdown
setupstaticdestinations
protected void startremotebridge   throws exception
if  remotebridgestarted compareandset false  true
if  log istraceenabled
log trace configuration getbrokername         localbroker
synchronized  this
if   iscreatedbyduplex
brokerinfo brokerinfo   new brokerinfo
brokerinfo setbrokername configuration getbrokername
brokerinfo setnetworkconnection true
brokerinfo setduplexconnection configuration isduplex
// set our properties
properties props   new properties
introspectionsupport getproperties configuration  props  null
string str   marshallingsupport propertiestostring props
brokerinfo setnetworkproperties str
brokerinfo setbrokerid this localbrokerid
remotebroker oneway brokerinfo
if  remoteconnectioninfo    null
remotebroker oneway remoteconnectioninfo createremovecommand
remoteconnectioninfo   new connectioninfo
remoteconnectioninfo setconnectionid new connectionid idgenerator generateid
remoteconnectioninfo setclientid     configuration getbrokername
remoteconnectioninfo setusername configuration getusername
remoteconnectioninfo setpassword configuration getpassword
remotebroker oneway remoteconnectioninfo
sessioninfo remotesessioninfo   new sessioninfo remoteconnectioninfo  1
remotebroker oneway remotesessioninfo
producerinfo   new producerinfo remotesessioninfo  1
producerinfo setresponserequired false
remotebroker oneway producerinfo
// listen to consumer advisory messages on the remote broker to
// determine demand.
demandconsumerinfo   new consumerinfo remotesessioninfo  1
demandconsumerinfo setdispatchasync configuration isdispatchasync
string advisorytopic   advisorysupport consumer_advisory_topic_prefix   configuration getdestinationfilter
if  configuration isbridgetempdestinations
advisorytopic        advisorysupport temp_destination_composite_advisory_topic
demandconsumerinfo setdestination new activemqtopic advisorytopic
demandconsumerinfo setprefetchsize configuration getprefetchsize
remotebroker oneway demandconsumerinfo
startedlatch countdown
if   disposed get
triggerlocalstartbridge
public void stop   throws exception
if  started compareandset true  false
if  disposed compareandset false  true
log debug     configuration getbrokername         remotebrokername
networkbridgelistener l   this networkbridgelistener
if  l    null
l onstop this
try
remotebridgestarted set false
final countdownlatch sendshutdown   new countdownlatch 1
async_tasks execute new runnable
public void run
try
localbroker oneway new shutdowninfo
sendshutdown countdown
remotebroker oneway new shutdowninfo
catch  throwable e
log debug    e
finally
sendshutdown countdown
if   sendshutdown await 10  timeunit seconds
log info
finally
servicestopper ss   new servicestopper
ss stop remotebroker
ss stop localbroker
// release the started latch since another thread could be
// stuck waiting for it to start up.
startedlatch countdown
startedlatch countdown
localstartedlatch countdown
ss throwfirstexception
log info configuration getbrokername         remotebrokername
public void serviceremoteexception throwable error
if   disposed get
if  error instanceof securityexception    error instanceof generalsecurityexception
log error     localbroker       remotebroker       error
else
log warn     localbroker       remotebroker       error
log debug     error  error
async_tasks execute new runnable
public void run
servicesupport dispose getcontrollingservice
firebridgefailed
protected void serviceremotecommand command command
if   disposed get
try
if  command ismessagedispatch
waitstarted
messagedispatch md    messagedispatch command
serviceremoteconsumeradvisory md getmessage   getdatastructure
demandconsumerdispatched
if  demandconsumerdispatched >  demandconsumerinfo getprefetchsize      75
remotebroker oneway new messageack md  messageack standard_ack_type  demandconsumerdispatched
demandconsumerdispatched   0
else if  command isbrokerinfo
lastconnectsucceeded set true
remotebrokerinfo    brokerinfo command
properties props   marshallingsupport stringtoproperties remotebrokerinfo getnetworkproperties
try
introspectionsupport getproperties configuration  props  null
if  configuration getexcludeddestinations      null
excludeddestinations   configuration getexcludeddestinations   toarray
new activemqdestination
if  configuration getstaticallyincludeddestinations      null
staticallyincludeddestinations   configuration getstaticallyincludeddestinations   toarray
new activemqdestination
if  configuration getdynamicallyincludeddestinations      null
dynamicallyincludeddestinations   configuration getdynamicallyincludeddestinations
toarray
new activemqdestination[configuration getdynamicallyincludeddestinations
size  ]
catch  throwable t
log error    t
serviceremotebrokerinfo command
// let the local broker know the remote broker's id.
localbroker oneway command
else if  command getclass      connectionerror class
connectionerror ce    connectionerror command
serviceremoteexception ce getexception
else
if  isduplex
if  command ismessage
activemqmessage message    activemqmessage command
if  advisorysupport isconsumeradvisorytopic message getdestination
serviceremoteconsumeradvisory message getdatastructure
else
if   ispermissabledestination message getdestination    true
return
if  message isresponserequired
response reply   new response
reply setcorrelationid message getcommandid
localbroker oneway message
remotebroker oneway reply
else
localbroker oneway message
else
switch  command getdatastructuretype
case connectioninfo data_structure_type
case sessioninfo data_structure_type
case producerinfo data_structure_type
localbroker oneway command
break
case consumerinfo data_structure_type
localstartedlatch await
if  started get
if   addconsumerinfo  consumerinfo  command
if  log isdebugenabled
log debug    command
else
if  log istraceenabled
log trace    command
else
// received a subscription whilst stopping
log warn    command
break
default
if  log isdebugenabled
log debug     command
else
switch  command getdatastructuretype
case keepaliveinfo data_structure_type
case wireformatinfo data_structure_type
case shutdowninfo data_structure_type
break
default
log warn     command
catch  throwable e
if  log isdebugenabled
log debug     command  e
serviceremoteexception e
private void serviceremoteconsumeradvisory datastructure data  throws ioexception
final int networkttl   configuration getnetworkttl
if  data getclass      consumerinfo class
// create a new local subscription
consumerinfo info    consumerinfo data
brokerid path   info getbrokerpath
if  path    null    path length >  networkttl
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername       networkttl       info
return
if  contains path  localbrokerpath
// ignore this consumer as it's a consumer we locally sent to the broker.
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername       info
return
if   ispermissabledestination info getdestination
// ignore if not in the permitted or in the excluded list
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername       info getdestination         info
return
// in a cyclic network there can be multiple bridges per broker that can propagate
// a network subscription so there is a need to synchronise on a shared entity
synchronized brokerservice getvmconnectoruri
if  addconsumerinfo info
if  log isdebugenabled
log debug configuration getbrokername         localbroker       remotebrokername       info
else
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername       info
else if  data getclass      destinationinfo class
// it's a destination info - we want to pass up
// information about temporary destinations
destinationinfo destinfo    destinationinfo data
brokerid path   destinfo getbrokerpath
if  path    null    path length >  networkttl
if  log isdebugenabled
log debug configuration getbrokername         destinfo       networkttl
return
if  contains destinfo getbrokerpath    localbrokerpath
// ignore this consumer as it's a consumer we locally sent to
// the broker.
if  log isdebugenabled
log debug configuration getbrokername         destinfo
return
destinfo setconnectionid localconnectioninfo getconnectionid
if  destinfo getdestination   instanceof activemqtempdestination
// re-set connection id so comes from here
activemqtempdestination tempdest    activemqtempdestination destinfo getdestination
tempdest setconnectionid localsessioninfo getsessionid   getconnectionid
destinfo setbrokerpath appendtobrokerpath destinfo getbrokerpath    getremotebrokerpath
if  log istraceenabled
log trace     destinfo
localbroker oneway destinfo
else if  data getclass      removeinfo class
consumerid id    consumerid   removeinfo data  getobjectid
removedemandsubscription id
public void servicelocalexception throwable error
if   disposed get
log info     localbroker       remotebroker       error
log debug     error  error
async_tasks execute new runnable
public void run
servicesupport dispose getcontrollingservice
firebridgefailed
protected service getcontrollingservice
return duplexinitiatingconnection    null ? duplexinitiatingconnection   demandforwardingbridgesupport this
protected void addsubscription demandsubscription sub  throws ioexception
if  sub    null
localbroker oneway sub getlocalinfo
protected void removesubscription final demandsubscription sub  throws ioexception
if  sub    null
if  log isdebugenabled
log debug configuration getbrokername         sub getremoteinfo   getconsumerid
subscriptionmapbylocalid remove sub getlocalinfo   getconsumerid
// continue removal in separate thread to free up this thread for outstanding responses
async_tasks execute new runnable
public void run
sub waitforcompletion
try
localbroker oneway sub getlocalinfo   createremovecommand
catch  ioexception e
log warn     sub getremoteinfo   getconsumerid    e
protected message configuremessage messagedispatch md
message message   md getmessage   copy
// update the packet to show where it came from.
message setbrokerpath appendtobrokerpath message getbrokerpath    localbrokerpath
message setproducerid producerinfo getproducerid
message setdestination md getdestination
if  message getoriginaltransactionid      null
message setoriginaltransactionid message gettransactionid
message settransactionid null
return message
protected void servicelocalcommand command command
if   disposed get
try
if  command ismessagedispatch
enqueuecounter incrementandget
final messagedispatch md    messagedispatch command
final demandsubscription sub   subscriptionmapbylocalid get md getconsumerid
if  sub    null    md getmessage    null
// see if this consumer's brokerpath tells us it came from the broker at the other end
// of the bridge. i think we should be making this decision based on the message's
// broker bread crumbs and not the consumer's? however, the message's broker bread
// crumbs are null, which is another matter.
boolean camefromremote   false
object consumerinfo   md getmessage   getdatastructure
if  consumerinfo    null     consumerinfo instanceof consumerinfo
camefromremote   contains    consumerinfo consumerinfo  getbrokerpath   remotebrokerinfo getbrokerid
message message   configuremessage md
if  log isdebugenabled
log debug     configuration getbrokername         remotebrokername       message
if   message isresponserequired
// if the message was originally sent using async
// send, we will preserve that qos
// by bridging it using an async send (small chance
// of message loss).
// don't send it off to the remote if it originally came from the remote.
if   camefromremote
remotebroker oneway message
else
if  log isdebugenabled
log debug
localbroker oneway new messageack md  messageack individual_ack_type  1
dequeuecounter incrementandget
else
// the message was not sent using async send, so we
// should only ack the local
// broker when we get confirmation that the remote
// broker has received the message.
responsecallback callback   new responsecallback
public void oncompletion futureresponse future
try
response response   future getresult
if  response isexception
exceptionresponse er    exceptionresponse response
servicelocalexception er getexception
else
localbroker oneway new messageack md  messageack individual_ack_type  1
dequeuecounter incrementandget
catch  ioexception e
servicelocalexception e
finally
sub decrementoutstandingresponses
remotebroker asyncrequest message  callback
sub incrementoutstandingresponses
else
if  log isdebugenabled
log debug     md getconsumerid         md getmessage
else if  command isbrokerinfo
localbrokerinfo    brokerinfo command
servicelocalbrokerinfo command
else if  command isshutdowninfo
log info configuration getbrokername
// don't shut down the whole connector if the remote side
// was interrupted.
// the local transport is just shutting down temporarily
// until the remote side
// is restored.
if   remoteinterupted get
stop
else if  command getclass      connectionerror class
connectionerror ce    connectionerror command
servicelocalexception ce getexception
else
switch  command getdatastructuretype
case wireformatinfo data_structure_type
break
default
log warn     command
catch  throwable e
log warn   e
servicelocalexception e
/**
* @return returns the dynamicallyincludeddestinations.
*/
public activemqdestination getdynamicallyincludeddestinations
return dynamicallyincludeddestinations
/**
* @param dynamicallyincludeddestinations the
*                dynamicallyincludeddestinations to set.
*/
public void setdynamicallyincludeddestinations activemqdestination dynamicallyincludeddestinations
this dynamicallyincludeddestinations   dynamicallyincludeddestinations
/**
* @return returns the excludeddestinations.
*/
public activemqdestination getexcludeddestinations
return excludeddestinations
/**
* @param excludeddestinations the excludeddestinations to set.
*/
public void setexcludeddestinations activemqdestination excludeddestinations
this excludeddestinations   excludeddestinations
/**
* @return returns the staticallyincludeddestinations.
*/
public activemqdestination getstaticallyincludeddestinations
return staticallyincludeddestinations
/**
* @param staticallyincludeddestinations the staticallyincludeddestinations
*                to set.
*/
public void setstaticallyincludeddestinations activemqdestination staticallyincludeddestinations
this staticallyincludeddestinations   staticallyincludeddestinations
/**
* @return returns the durabledestinations.
*/
public activemqdestination getdurabledestinations
return durabledestinations
/**
* @param durabledestinations the durabledestinations to set.
*/
public void setdurabledestinations activemqdestination durabledestinations
this durabledestinations   durabledestinations
/**
* @return returns the localbroker.
*/
public transport getlocalbroker
return localbroker
/**
* @return returns the remotebroker.
*/
public transport getremotebroker
return remotebroker
/**
* @return the createdbyduplex
*/
public boolean iscreatedbyduplex
return this createdbyduplex
/**
* @param createdbyduplex the createdbyduplex to set
*/
public void setcreatedbyduplex boolean createdbyduplex
this createdbyduplex   createdbyduplex
public static boolean contains brokerid brokerpath  brokerid brokerid
if  brokerpath    null
for  int i   0  i < brokerpath length  i
if  brokerid equals brokerpath
return true
return false
protected brokerid appendtobrokerpath brokerid brokerpath  brokerid pathstoappend
if  brokerpath    null    brokerpath length    0
return pathstoappend
brokerid rc   new brokerid
system arraycopy brokerpath  0  rc  0  brokerpath length
system arraycopy pathstoappend  0  rc  brokerpath length  pathstoappend length
return rc
protected brokerid appendtobrokerpath brokerid brokerpath  brokerid idtoappend
if  brokerpath    null    brokerpath length    0
return new brokerid  idtoappend
brokerid rc   new brokerid
system arraycopy brokerpath  0  rc  0  brokerpath length
rc   idtoappend
return rc
protected boolean ispermissabledestination activemqdestination destination
return ispermissabledestination destination  false
protected boolean ispermissabledestination activemqdestination destination  boolean allowtemporary
// are we not bridging temp destinations?
if  destination istemporary
if  allowtemporary
return true
else
return configuration isbridgetempdestinations
final destinationfilter filter   destinationfilter parsefilter destination
activemqdestination dests   excludeddestinations
if  dests    null    dests length > 0
for  int i   0  i < dests length  i
destinationfilter exclusionfilter   filter
activemqdestination match   dests
if  exclusionfilter instanceof org apache activemq filter simpledestinationfilter
destinationfilter newfilter   destinationfilter parsefilter match
if    newfilter instanceof org apache activemq filter simpledestinationfilter
exclusionfilter   newfilter
match   destination
if  match    null    exclusionfilter matches match     dests getdestinationtype      destination getdestinationtype
return false
dests   dynamicallyincludeddestinations
if  dests    null    dests length > 0
for  int i   0  i < dests length  i
destinationfilter inclusionfilter   filter
activemqdestination match   dests
if  inclusionfilter instanceof org apache activemq filter simpledestinationfilter
destinationfilter newfilter   destinationfilter parsefilter match
if    newfilter instanceof org apache activemq filter simpledestinationfilter
inclusionfilter   newfilter
match   destination
if  match    null    inclusionfilter matches match     dests getdestinationtype      destination getdestinationtype
return true
return false
return true
/**
* subscriptions for these destinations are always created
*/
protected void setupstaticdestinations
activemqdestination dests   staticallyincludeddestinations
if  dests    null
for  int i   0  i < dests length  i
activemqdestination dest   dests
demandsubscription sub   createdemandsubscription dest
try
addsubscription sub
catch  ioexception e
log error     dest  e
if  log istraceenabled
log trace     dest
protected boolean addconsumerinfo final consumerinfo consumerinfo  throws ioexception
boolean consumeradded   false
consumerinfo info   consumerinfo copy
addremotebrokertobrokerpath info
demandsubscription sub   createdemandsubscription info
if  sub    null
if  duplicatesuppressionisrequired sub
undomapregistration sub
else
addsubscription sub
consumeradded   true
return consumeradded
private void undomapregistration demandsubscription sub
subscriptionmapbylocalid remove sub getlocalinfo   getconsumerid
subscriptionmapbyremoteid remove sub getremoteinfo   getconsumerid
/*
* check our existing subs networkconsumerids against the list of network ids in this subscription
* a match means a duplicate which we suppress for topics and maybe for queues
*/
private boolean duplicatesuppressionisrequired demandsubscription candidate
final consumerinfo consumerinfo   candidate getremoteinfo
boolean suppress   false
if  consumerinfo getdestination   isqueue       configuration issuppressduplicatequeuesubscriptions
return suppress
list<consumerid> candidateconsumers   consumerinfo getnetworkconsumerids
collection<subscription> currentsubs
getregionsubscriptions consumerinfo getdestination   istopic
for  subscription sub   currentsubs
list<consumerid> networkconsumers    sub getconsumerinfo   getnetworkconsumerids
if   networkconsumers isempty
if  matchfound candidateconsumers  networkconsumers
suppress   haslowerpriority sub  candidate getlocalinfo
break
return suppress
private boolean haslowerpriority subscription existingsub  consumerinfo candidateinfo
boolean suppress   false
if  existingsub getconsumerinfo   getpriority   >  candidateinfo getpriority
if  log isdebugenabled
log debug configuration getbrokername         remotebrokername
candidateinfo
existingsub getconsumerinfo          existingsub getconsumerinfo   getnetworkconsumerids
suppress   true
else
// remove the existing lower priority duplicate and allow this candidate
try
removeduplicatesubscription existingsub
if  log isdebugenabled
log debug configuration getbrokername         existingsub getconsumerinfo
remotebrokername
candidateinfo
candidateinfo getnetworkconsumerids
catch  ioexception e
log error    existingsub  e
return suppress
private void removeduplicatesubscription subscription existingsub  throws ioexception
for  networkconnector connector  brokerservice getnetworkconnectors
if  connector removedemandsubscription existingsub getconsumerinfo   getconsumerid
break
private boolean matchfound list<consumerid> candidateconsumers  list<consumerid> networkconsumers
boolean found   false
for  consumerid aliasconsumer   networkconsumers
if  candidateconsumers contains aliasconsumer
found   true
break
return found
private final collection<subscription> getregionsubscriptions boolean istopic
regionbroker region    regionbroker  brokerservice getregionbroker
abstractregion abstractregion    abstractregion
istopic ? region gettopicregion     region getqueueregion
return abstractregion getsubscriptions   values
protected demandsubscription createdemandsubscription consumerinfo info  throws ioexception
//add our original id to ourselves
info addnetworkconsumerid info getconsumerid
return docreatedemandsubscription info
protected demandsubscription docreatedemandsubscription consumerinfo info  throws ioexception
demandsubscription result   new demandsubscription info
result getlocalinfo   setconsumerid new consumerid localsessioninfo getsessionid    consumeridgenerator getnextsequenceid
if  info getdestination   istemporary
// reset the local connection id
activemqtempdestination dest    activemqtempdestination result getlocalinfo   getdestination
dest setconnectionid localconnectioninfo getconnectionid   tostring
if  configuration isdecreasenetworkconsumerpriority
byte priority   consumerinfo network_consumer_priority
if  info getbrokerpath      null    info getbrokerpath   length > 1
// the longer the path to the consumer, the less it's consumer priority.
priority    info getbrokerpath   length   1
result getlocalinfo   setpriority priority
if  log isdebugenabled
log debug configuration getbrokername         priority       info
configuredemandsubscription info  result
return result
final protected demandsubscription createdemandsubscription activemqdestination destination
consumerinfo info   new consumerinfo
info setdestination destination
// the remote info held by the demandsubscription holds the original
// consumerid,
// the local info get's overwritten
info setconsumerid new consumerid localsessioninfo getsessionid    consumeridgenerator getnextsequenceid
demandsubscription result   null
try
result   createdemandsubscription info
catch  ioexception e
log error   e
if  result    null
result getlocalinfo   setpriority consumerinfo network_consumer_priority
return result
protected void configuredemandsubscription consumerinfo info  demandsubscription sub  throws ioexception
sub getlocalinfo   setdispatchasync configuration isdispatchasync
sub getlocalinfo   setprefetchsize configuration getprefetchsize
subscriptionmapbylocalid put sub getlocalinfo   getconsumerid    sub
subscriptionmapbyremoteid put sub getremoteinfo   getconsumerid    sub
// this works for now since we use a vm connection to the local broker.
// may need to change if we ever subscribe to a remote broker.
sub getlocalinfo   setadditionalpredicate createnetworkbridgefilter info
protected void removedemandsubscription consumerid id  throws ioexception
demandsubscription sub   subscriptionmapbyremoteid remove id
if  log isdebugenabled
log debug configuration getbrokername         localbroker       remotebrokername       id       sub
if  sub    null
removesubscription sub
if  log isdebugenabled
log debug configuration getbrokername         localbroker       remotebrokername       sub getremoteinfo
protected boolean removedemandsubscriptionbylocalid consumerid consumerid
boolean removedone   false
demandsubscription sub   subscriptionmapbylocalid get consumerid
if  sub    null
try
removedemandsubscription sub getremoteinfo   getconsumerid
removedone   true
catch  ioexception e
log debug     consumerid  e
return removedone
protected void waitstarted   throws interruptedexception
startedlatch await
localbrokeridknownlatch await
protected void cleardownsubscriptions
subscriptionmapbylocalid clear
subscriptionmapbyremoteid clear
protected abstract networkbridgefilter createnetworkbridgefilter consumerinfo info  throws ioexception
protected abstract void servicelocalbrokerinfo command command  throws interruptedexception
protected abstract void addremotebrokertobrokerpath consumerinfo info  throws ioexception
protected abstract void serviceremotebrokerinfo command command  throws ioexception
protected abstract brokerid getremotebrokerpath
public void setnetworkbridgelistener networkbridgelistener listener
this networkbridgelistener   listener
private void firebridgefailed
networkbridgelistener l   this networkbridgelistener
if  l    null
l bridgefailed
public string getremoteaddress
return remotebroker getremoteaddress
public string getlocaladdress
return localbroker getremoteaddress
public string getremotebrokername
return remotebrokerinfo    null ? null   remotebrokerinfo getbrokername
public string getlocalbrokername
return localbrokerinfo    null ? null   localbrokerinfo getbrokername
public long getdequeuecounter
return dequeuecounter get
public long getenqueuecounter
return enqueuecounter get
protected boolean isduplex
return configuration isduplex      createdbyduplex
public void setbrokerservice brokerservice brokerservice
this brokerservice   brokerservice
static
async_tasks     new threadpoolexecutor 0  integer max_value  30  timeunit seconds  new synchronousqueue<runnable>    new threadfactory
public thread newthread runnable runnable
thread thread   new thread runnable
thread setdaemon true
return thread