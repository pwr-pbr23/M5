/*
derby - class org.apache.derby.iapi.sql.dictionary.triggerdescriptor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import org apache derby iapi services io formatable
import org apache derby iapi sql depend dependent
import org apache derby iapi sql depend provider
import org apache derby iapi error standardexception
import org apache derby catalog uuid
import java sql timestamp
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql activation
import org apache derby iapi sql statementtype
import org apache derby catalog dependablefinder
import org apache derby catalog dependable
import org apache derby iapi services io storedformatids
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi store access transactioncontroller
import org apache derby iapi services context contextservice
import org apache derby impl sql execute droptriggerconstantaction
import java io objectoutput
import java io objectinput
import java io ioexception
/**
* a trigger.
* <p>
* we are dependent on tabledescriptors, spsdescriptors (for our
* when clause and our action).  note that we don't strictly
* need to be dependent on out spses because we could just disallow
* anyone from dropping an sps of type 't', but to keep dependencies
* uniform, we'll do be dependent.
* <p>
* we are a provider for dml (preparedstatements or spses)
*
* the public methods for this class are:
*
* <ol>
* <li>getuuid
* <li>getname
* <li>getschemadescriptor
* <li>	public boolean listensforevent(int event);
* <li>	public int gettriggereventmask();
* <li>	public timestamp getcreationtimestamp();
* <li>	public boolean isbeforetrigger();
* <li> public boolean isrowtrigger();
* <li> public uuid getactionid();
* <li> public spsdescriptor getactionsps();
* <li>	public uuid getwhenclauseid();
* <li>	public spsdescriptor getwhenclausesps()
* <li>	public tabledescriptor gettabledescriptor()
* <li> public referencedcolumns getreferencedcolumnsdescriptor()
* <li> public int[] getreferencedcols();
* <li> public boolean isenabled();
* <li> public void setenabled();
* <li> public void setdisabled();
* <li> public boolean needstofire(int stmttype, int[] modifiedcols)
* <li> public string gettriggerdefinition();
* <li> public boolean getreferencingold();
* <li> public boolean getreferencingnew();
* <li> public string getoldreferencingname();
* <li> public string getnewreferencingname();
* </ol>
*/
public class triggerdescriptor extends tupledescriptor
implements uniquesqlobjectdescriptor  provider  dependent  formatable
// field that we want users to be able to know about
public static final int systriggers_state_field   8
public static final int trigger_event_update   1
public static final int trigger_event_delete   2
public static final int trigger_event_insert   4
private	uuid				id
private string				name
private string				oldreferencingname
private string				newreferencingname
private string				triggerdefinition
private schemadescriptor	sd
private int					eventmask
private boolean				isbefore
private boolean 			isrow
private boolean				referencingold
private boolean				referencingnew
private	tabledescriptor		td
private	uuid				actionspsid
private spsdescriptor		actionsps
private	uuid				whenspsid
private spsdescriptor		whensps
private	boolean				isenabled
private	int				referencedcols
private	timestamp			creationtimestamp
private uuid				triggerschemaid
private uuid				triggertableid
/**
* niladic constructor, for formatable
*/
public triggerdescriptor
/**
* constructor.  used when creating a trigger from sys.systriggers
*
* @param datadictionary 	the data dictionary
* @param sd	the schema descriptor for this trigger
* @param id	the trigger id
* @param name	the trigger name
* @param eventmask	triggerdescriptor.trigger_event_xxxx
* @param isbefore	is this a before (as opposed to after) trigger
* @param isrow		is this a row trigger or statement trigger
* @param isenabled	is this trigger enabled or disabled
* @param td		the table upon which this trigger is defined
* @param whenspsid	the sps id for the when clause (may be null)
* @param actionspsid	the spsid for the trigger action (may be null)
* @param creationtimestamp	when was this trigger created?
* @param referencedcols	what columns does this trigger reference (may be null)
* @param triggerdefinition the original user text of the trigger action
* @param referencingold whether or not old appears in referencing clause
* @param referencingnew whether or not new appears in referencing clause
* @param oldreferencingname old referencing table name, if any, that appears in refercing clause
* @param newreferencingname new referencing table name, if any, that appears in refercing clause
*/
public triggerdescriptor
datadictionary		datadictionary
schemadescriptor	sd
uuid				id
string				name
int					eventmask
boolean				isbefore
boolean				isrow
boolean				isenabled
tabledescriptor		td
uuid				whenspsid
uuid				actionspsid
timestamp			creationtimestamp
int				referencedcols
string				triggerdefinition
boolean				referencingold
boolean				referencingnew
string				oldreferencingname
string				newreferencingname
super datadictionary
this id   id
this sd   sd
this name   name
this eventmask   eventmask
this isbefore   isbefore
this isrow   isrow
this td   td
this actionspsid   actionspsid
this whenspsid   whenspsid
this isenabled   isenabled
this referencedcols   referencedcols
this creationtimestamp   creationtimestamp
this triggerdefinition   triggerdefinition
this referencingold   referencingold
this referencingnew   referencingnew
this oldreferencingname   oldreferencingname
this newreferencingname   newreferencingname
triggerschemaid   sd getuuid
triggertableid   td getuuid
/**
* get the trigger uuid
*
* @return the id
*/
public uuid getuuid
return id
/**
* get the trigger name
*
* @return	the name
*/
public string getname
return name
public uuid gettableid
return triggertableid
/**
* get the triggers schema descriptor
*
* @return the schema descriptor
*
* @exception standardexception on error
*/
public schemadescriptor getschemadescriptor
throws standardexception
if  sd    null
sd   getdatadictionary   getschemadescriptor triggerschemaid  null
return sd
/**
* indicate whether this trigger listens for this
* type of event.
*
* @param event trigger_event_xxxx
*
* @return true if it listens to the specified event.
*/
public boolean listensforevent int event
return  event   eventmask     event
/**
* get the trigger event mask.  currently, a trigger
* may only listen for a single event, though it may
* or multiple events in the future.
*
* @return the trigger event mask
*/
public int gettriggereventmask
return eventmask
/**
* get the time that this trigger was created.
*
* @return the time the trigger was created
*/
public timestamp getcreationtimestamp
return creationtimestamp
/**
* is this a before trigger
*
* @return true if it is a before trigger
*/
public boolean isbeforetrigger
return isbefore
/**
* is this a row trigger
*
* @return true if it is a before trigger
*/
public boolean isrowtrigger
return isrow
/**
* get the trigger action sps uuid
*
* @return the uuid of the sps action
*/
public uuid getactionid
return actionspsid
/**
* get the trigger action sps
*
* @return the trigger action sps
*
* @exception standardexception on error
*/
public spsdescriptor getactionsps languageconnectioncontext lcc
throws standardexception
if  actionsps    null
//bug 4821 - do the sysstatement look up in a nested readonly
//transaction rather than in the user transaction. because of
//this, the nested compile transaction which is attempting to
//compile the trigger will not run into any locking issues with
//the user transaction for sysstatements.
lcc beginnestedtransaction true
actionsps   getdatadictionary   getspsdescriptor actionspsid
lcc commitnestedtransaction
return actionsps
/**
* get the trigger when clause sps uuid
*
* @return the uuid of the sps action
*/
public uuid getwhenclauseid
return whenspsid
/**
* get the trigger when clause sps
*
* @return the sps of the when clause
*
* @exception standardexception on error
*/
public spsdescriptor getwhenclausesps
throws standardexception
if  whensps    null
whensps   getdatadictionary   getspsdescriptor whenspsid
return whensps
/**
* get the trigger table descriptor
*
* @return the table descripor upon which this trigger
* is declared
*
* @exception standardexception on error
*/
public tabledescriptor gettabledescriptor
throws standardexception
if  td    null
td   getdatadictionary   gettabledescriptor triggertableid
return td
/**
* get the referenced table descriptor for this trigger.
*
* @return the referenced table descriptor
*
* @exception standardexception on error
*/
// caller converts referencedcols to referencedcolsdescriptor...
//  	public referencedcolumns getreferencedcolumnsdescriptor()
//  		throws standardexception
//  	{
//  		return (referencedcols == null) ?
//  				(referencedcolumns)null :
//  				new referencedcolumnsdescriptorimpl(referencedcols);
//  	}
/**
* get the referenced column array for this trigger, used in "alter table
* drop column", we get the handle and change it
*
* @return the referenced column array
*/
public int getreferencedcols
return referencedcols
/**
* is this trigger enabled
*
* @return true if it is enabled
*/
public boolean isenabled
return isenabled
/**
* mark this trigger as enabled
*
*/
public void setenabled
isenabled   true
/**
* mark this trigger as disabled
*
*/
public void setdisabled
isenabled   false
/**
* does this trigger need to fire on this type of
* dml?
*
* @param stmttype	the type of dml
* (statementtype.insert|statementtype.update|statementtype.delete)
* @param modifiedcols	the columns modified, or null for all
*
* @return true/false
*
* @exception standardexception on error
*/
public boolean needstofire int stmttype  int modifiedcols
throws standardexception
if  sanitymanager debug
if     stmttype    statementtype insert
stmttype    statementtype bulk_insert_replace
stmttype    statementtype update
stmttype    statementtype delete
sanitymanager throwassert   stmttype
/*
** if we are disabled, we never fire
*/
if   isenabled
return false
if  stmttype    statementtype insert
return  eventmask   trigger_event_insert     eventmask
if  stmttype    statementtype delete
return  eventmask   trigger_event_delete     eventmask
// this is a temporary restriction, but it may not be lifted
// anytime soon.
if  stmttype    statementtype bulk_insert_replace
throw standardexception newexception sqlstate lang_no_bulk_insert_replace_with_trigger
gettabledescriptor   getqualifiedname    name
// if update, only relevant if columns intersect
return   eventmask   trigger_event_update     eventmask
constraintdescriptor docolumnsintersect modifiedcols  referencedcols
/**
* get the original trigger definition.
*
* @return the trigger definition.
*/
public string gettriggerdefinition
return triggerdefinition
/**
* get whether or not old was replaced
* in the referencing clause.
*
* @return whether or not old was replaced
* in the referencing clause.
*/
public boolean getreferencingold
return referencingold
/**
* get whether or not new was replaced
* in the referencing clause.
*
* @return whether or not new was replaced
* in the referencing clause.
*/
public boolean getreferencingnew
return referencingnew
/**
* get the old referencing name, if any,
* from the referencing clause.
*
* @return the old referencing name, if any,
* from the referencing clause.
*/
public string getoldreferencingname
return oldreferencingname
/**
* get the new referencing name, if any,
* from the referencing clause.
*
* @return the new referencing name, if any,
* from the referencing clause.
*/
public string getnewreferencingname
return newreferencingname
public string tostring
if  sanitymanager debug
return   name
else
return
////////////////////////////////////////////////////////////////////
//
// provider interface
//
////////////////////////////////////////////////////////////////////
/**
* @return the stored form of this provider
*
* @see dependable#getdependablefinder
*/
public dependablefinder getdependablefinder
return getdependablefinder storedformatids trigger_descriptor_finder_v01_id
/**
* return the name of this provider.  (useful for errors.)
*
* @return string	the name of this provider.
*/
public string getobjectname
return name
/**
* get the provider's uuid
*
* @return 	the provider's uuid
*/
public uuid getobjectid
return id
/**
* get the provider's type.
*
* @return char		the provider's type.
*/
public string getclasstype
return dependable trigger
//////////////////////////////////////////////////////
//
// dependent interface
//
// triggers are dependent on the underlying table,
// and their spses (for the trigger action and the when
// clause).
//
//////////////////////////////////////////////////////
/**
* check that all of the dependent's dependencies are valid.
*
* @return true if the dependent is currently valid
*/
public synchronized boolean isvalid
return true
/**
* prepare to mark the dependent as invalid (due to at least one of
* its dependencies being invalid).
*
* @param action	the action causing the invalidation
* @param p			the provider
* @param lcc		the language connection context
*
* @exception standardexception thrown if unable to make it invalid
*/
public void preparetoinvalidate
provider 					p
int							action
languageconnectioncontext	lcc
throws standardexception
switch  action
/*
** we are only dependent on the underlying table, and our spses and
** privileges on various objects.  (we should be dropped before our
** table is dropped. also, we should be dropped before revoke
** restrict privilege is issued otherwise revoke restrict will
** throw an exception).
** currently, in derby, an execute routine privilege can be revoked
** only if there are no dependents on that privilege. when revoke
** execute restrict is exectued, all the dependents will receive
** revoke_privilege_restrict and they should throw exception.
** we handle this for triggerdescriptor by throwning an exception
** below. for all the other types of revoke privileges, for
** instance, select, update, delete, insert, references,
** trigger, we don't do anything here and later in makeinvalid, we
** make the triggerdescriptor drop itself.
*/
case dependencymanager drop_table
case dependencymanager drop_synonym
case dependencymanager drop_sps
case dependencymanager rename
case dependencymanager revoke_privilege_restrict
dependencymanager dm   getdatadictionary   getdependencymanager
throw standardexception newexception sqlstate lang_provider_has_dependent_object
dm getactionstring action
p getobjectname       name
/*
** the trigger descriptor depends on the trigger table.
** this means that we get called whenever anything happens
** to the trigger table. there are so many cases where this
** can happen that it doesn't make sense to have an assertion
** here to check whether the action was expected (it makes
** the code hard to maintain, and creates a big switch statement).
*/
default
break
/**
* mark the dependent as invalid (due to at least one of
* its dependencies being invalid).  always an error
* for a trigger -- should never have gotten here.
*
* @param 	lcc the language connection context
* @param	action	the action causing the invalidation
*
* @exception standardexception thrown if called in sanity mode
*/
public void makeinvalid int action  languageconnectioncontext lcc  throws standardexception
// no sanity check for valid action. trigger descriptors depend on
// the trigger table, so there is a very large number of actions
// that we would have to check against. this is hard to maintain,
// so don't bother.
switch  action
// invalidate this trigger descriptor
case dependencymanager user_recompile_request
dependencymanager dm   getdatadictionary   getdependencymanager
dm invalidatefor this  dependencymanager prepared_statement_release  lcc
break
// when revoke_privilege gets sent (this happens for privilege
// types select, update, delete, insert, references, trigger), we
// make the triggerdescriptor drop itself.
case dependencymanager revoke_privilege
drop lcc
break
default
break
public void drop languageconnectioncontext   lcc  throws standardexception
datadictionary dd   getdatadictionary
dependencymanager dm   getdatadictionary   getdependencymanager
transactioncontroller tc   lcc gettransactionexecute
dm invalidatefor this  dependencymanager drop_trigger  lcc
// drop the trigger
dd droptriggerdescriptor this  tc
// clear the dependencies for the trigger
dm cleardependencies lcc  this
// drop the spses
spsdescriptor spsd   dd getspsdescriptor this getactionid
// there shouldn't be any dependencies, but in case
// there are, lets clear them
dm invalidatefor spsd  dependencymanager drop_trigger  lcc
dm cleardependencies lcc  spsd
dd dropspsdescriptor spsd  tc
if  getwhenclauseid      null
spsd   dd getspsdescriptor getwhenclauseid
dm invalidatefor spsd  dependencymanager drop_trigger  lcc
dm cleardependencies lcc  spsd
dd dropspsdescriptor spsd  tc
//////////////////////////////////////////////////////////////
//
// formatable
//
//////////////////////////////////////////////////////////////
/**
* read this object from a stream of stored objects.
*
* @param in read this.
*
* @exception ioexception					thrown on error
* @exception classnotfoundexception		thrown on error
*/
public void readexternal objectinput in
throws ioexception  classnotfoundexception
id    uuid in readobject
name    string in readobject
triggerschemaid    uuid in readobject
triggertableid    uuid in readobject
eventmask   in readint
isbefore   in readboolean
isrow   in readboolean
isenabled   in readboolean
whenspsid    uuid in readobject
actionspsid    uuid in readobject
int length   in readint
if  length    0
referencedcols   new int
for  int i   0  i < length  i
referencedcols   in readint
triggerdefinition    string in readobject
referencingold   in readboolean
referencingnew   in readboolean
oldreferencingname    string in readobject
newreferencingname    string in readobject
protected datadictionary getdatadictionary
/*
note: we need to do this since when this trigger is read back from
disk (when it is associated with a sps), the datadictionary has not
been initialized and therefore can give a nullpointerexception
*/
datadictionary dd   super getdatadictionary
if  dd    null
languageconnectioncontext lcc    languageconnectioncontext
contextservice getcontext languageconnectioncontext context_id
dd   lcc getdatadictionary
setdatadictionary dd
return dd
/**
* write this object to a stream of stored objects.
*
* @param out write bytes here.
*
* @exception ioexception		thrown on error
*/
public void writeexternal  objectoutput out
throws ioexception
if  sanitymanager debug
sanitymanager assert triggerschemaid    null
sanitymanager assert triggertableid    null
out writeobject id
out writeobject name
out writeobject triggerschemaid
out writeobject triggertableid
out writeint eventmask
out writeboolean isbefore
out writeboolean isrow
out writeboolean isenabled
out writeobject whenspsid
out writeobject actionspsid
if  referencedcols    null
out writeint 0
else
out writeint referencedcols length
for  int i   0  i < referencedcols length  i
out writeint referencedcols
out writeobject triggerdefinition
out writeboolean referencingold
out writeboolean referencingnew
out writeobject oldreferencingname
out writeobject newreferencingname
/**
* get the formatid which corresponds to this class.
*
*	@return	the formatid of this class
*/
public	int	gettypeformatid  	  return storedformatids trigger_descriptor_v01_id
/** @see tupledescriptor#getdescriptortype */
public string getdescriptortype
return
/** @see tupledescriptor#getdescriptorname */
public string getdescriptorname     return name