/*
derby - class org.apache.derby.impl.sql.compile.fromlist
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile optimizablelist
import org apache derby iapi sql compile optimizer
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi util jbitset
import org apache derby iapi util stringutil
import java util properties
import java util enumeration
import java util vector
/**
* a fromlist represents the list of tables in a from clause in a dml
* statement.  it extends querytreenodevector.
*
*/
public class fromlist extends querytreenodevector implements optimizablelist
properties	properties
// resolve: the default should be false
boolean		fixedjoinorder   true
// true by default.
boolean 	usestatistics   true
// fromlist could have a view in it's list. if the view is defined in session
// schema, then we do not want to cache the statement's plan. this boolean
// will help keep track of such a condition.
private boolean  referencessessionschema
/* whether or not this fromlist is transparent.  a "transparent" fromlist
* is one in which all fromtables are bound based on an outer query's
* fromlist.  this means that the fromtables in the transparent list are
* allowed to see and reference fromtables in the outer query's list.
* or put differently, a fromtable which sits in a transparent fromlist
* does not "see" the transparent fromlist when binding; rather, it sees
* (and can therefore reference) the fromlist of an outer query.
*/
private boolean istransparent
/** initializer for a fromlist */
public void init object optimizejoinorder
fixedjoinorder        boolean  optimizejoinorder  booleanvalue
istransparent   false
/**
* initializer for a fromlist
*
* @exception standardexception		thrown on error
*/
public void init object optimizejoinorder  object fromtable
throws standardexception
init optimizejoinorder
addfromtable  fromtable  fromtable
/*
* optimizablelist interface
*/
/**
* @see org.apache.derby.iapi.sql.compile.optimizablelist#getoptimizable
*/
public optimizable getoptimizable int index
return  optimizable  elementat index
/**
* @see org.apache.derby.iapi.sql.compile.optimizablelist#setoptimizable
*/
public void setoptimizable int index  optimizable optimizable
setelementat  fromtable  optimizable  index
/**
* @see optimizablelist#verifyproperties
* @exception standardexception		thrown on error
*/
public void verifyproperties datadictionary ddictionary  throws standardexception
int size   size
for  int index   0  index < size  index
optimizable  elementat index   verifyproperties ddictionary
/**
* add a table to the from list.
*
* @param fromtable	a fromtable to add to the list
*
* @exception standardexception		thrown on error
*/
public void addfromtable fromtable fromtable  throws standardexception
/* don't worry about checking tableoperatornodes since
* they don't have exposed names.  this will potentially
* allow duplicate exposed names in some degenerate cases,
* but the binding of the columnreferences will catch those
* cases with a different error.  if the query does not have
* any columnreferences from the duplicate exposed name, the
* user is executing a really dumb query and we won't throw
* and exception - consider it an ansi extension.
*/
tablename lefttable   null
tablename righttable   null
if     fromtable instanceof tableoperatornode
/* check for duplicate table name in from list */
int size   size
for  int index   0  index < size  index
lefttable   fromtable gettablename
if   fromtable  elementat index   instanceof tableoperatornode
continue
else
righttable     fromtable  elementat index   gettablename
if lefttable equals righttable
throw standardexception newexception sqlstate lang_from_list_duplicate_table_name  fromtable getexposedname
addelement fromtable
/**
* search to see if a query references the specifed table name.
*
* @param name		table name (string) to search for.
* @param basetable	whether or not name is for a base table
*
* @return	true if found, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencestarget string name  boolean basetable
throws standardexception
fromtable		fromtable
boolean			found   false
/* check for table or vti name in from list */
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
if  fromtable referencestarget name  basetable
found   true
break
return found
/**
* return true if the node references session schema tables (temporary or permanent)
*
* @return	true if references session schema tables, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencessessionschema
throws standardexception
fromtable		fromtable
boolean			found   false
// following if will return true if this fromlist object had any views
// from session schema as elements.  this information is gathered during
// the bindtables method. at the end of the bindtables, we loose
// the information on views since they get replaced with their view
// definition. hence, we need to intercept in the middle on the bindtables
// method and save that information in referencesseesionschema field.
if  referencessessionschema  return true
/* check for table or vti name in from list */
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
if  fromtable referencessessionschema
found   true
break
return found
/**
* determine whether or not the specified name is an exposed name in
* the current query block.
*
* @param name	the specified name to search for as an exposed name.
* @param schemaname	schema name, if non-null.
* @param exactmatch	whether or not we need an exact match on specified schema and table
*						names or match on table id.
*
* @return the fromtable, if any, with the exposed name.
*
* @exception standardexception		thrown on error
*/
protected fromtable getfromtablebyname string name  string schemaname  boolean exactmatch
throws standardexception
boolean			found   false
fromtable		fromtable
fromtable		result   null
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
result   fromtable getfromtablebyname name  schemaname  exactmatch
if  result    null
return result
return result
/**
* bind the tables in this fromlist.  this includes looking them up in
* the datadictionary, getting their tabledescriptors and assigning the
* table numbers.
*
* @param datadictionary	the datadictionary to use for binding
* @param fromlistparam		fromlist to use/append to.
*
* @exception standardexception		thrown on error
*/
public void bindtables datadictionary datadictionary
fromlist fromlistparam
throws standardexception
fromtable	fromtable
/* now we bind the tables - this is a 2 step process.
* we first bind all of the non-vtis, then we bind the vtis.
* this enables us to handle the passing of correlation
* columns in vti parameters.
* note: we set the table numbers for all of the vtis in the
* first step, when we find them, in order to avoid an ordering
* problem with join columns in parameters.
*/
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
resultsetnode newnode   fromtable bindnonvtitables datadictionary  fromlistparam
// if the fromtable is a view in the session schema, then we need to save that information
// in referencessessionschema element. the reason for this is that the view will get
// replaced by it's view definition and we will loose the information that the statement
// was referencing a session schema object.
if  fromtable referencessessionschema
referencessessionschema   true
setelementat newnode  index
for  int index   0  index < size  index
fromtable    fromtable  elementat index
resultsetnode newnode   fromtable bindvtitables fromlistparam
if  fromtable referencessessionschema
referencessessionschema   true
setelementat newnode  index
/**
* bind the expressions in this fromlist.  this means
* binding the sub-expressions, as well as figuring out what the return
* type is for each expression.
*
* @exception standardexception		thrown on error
*/
public void bindexpressions  fromlist fromlistparam
throws standardexception
fromtable	fromtable
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
/* if this fromlist is transparent then its fromtables should
* be bound based on the outer query's from list.
*/
fromtable bindexpressions
istransparent ? fromlistparam   this
/**
* bind the result columns of the resultsetnodes in this fromlist when there is no
* base table to bind them to.  this is useful for select statements,
* where the result columns get their types from the expressions that
* live under them.
*
* @param fromlistparam		fromlist to use/append to.
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumns fromlist fromlistparam
throws standardexception
fromtable	fromtable
int origlist   fromlistparam size
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
if  fromtable needsspecialrclbinding
fromtable bindresultcolumns fromlistparam
fromlistparam insertelementat fromtable  0
/* remove all references added here */
while  fromlistparam size   > origlist
fromlistparam removeelementat 0
/**
* returns true if any outer joins present. used to set nullability
*
* @return	true if has any outer joins. false otherwise.
*/
public boolean hasouterjoins
throws standardexception
fromtable	fromtable
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
if  fromtable instanceof halfouterjoinnode
return true
return false
/**
* expand a "*" into the appropriate resultcolumnlist. if the "*"
* is unqualified it will expand into a list of all columns in all
* of the base tables in the from list at the current nesting level;
* otherwise it will expand into a list of all of the columns in the
* base table that matches the qualification.
*
* note: callers are responsible for ordering the fromlist by nesting
* level, with tables at the deepest (current) nesting level first.
* we will expand the "*" into a list of all columns from all tables
* having the same nesting level as the first fromtable in this list.
* the check for nesting level exists because it's possible that this
* fromlist includes fromtables from an outer query, which can happen
* if there is a "transparent" fromlist above this one in the query
* tree.  ex:
*
*  select j from onerow where exists
*    (select 1 from somerow
*      union select * from diffrow where onerow.j < diffrow.k)
*
* if "this" is the fromlist for the right child of the union then it will
* contain both "diffrow" and "onerow", the latter of which was passed
* down via a transparent fromlist (to allow binding of the where clause).
* in that case the "*" should only expand the result columns of "diffrow";
* it should not expand the result columns of "onerow" because that table
* is from an outer query.  we can achieve this selective expansion by
* looking at nesting levels.
*
* @param alltablename		the qualification on the "*" as a string.
*
* @return resultcolumnlist representing expansion
*
* @exception standardexception		thrown on error
*/
public resultcolumnlist expandall tablename alltablename
throws standardexception
resultcolumnlist resultcolumnlist   null
resultcolumnlist temprclist   null
boolean			 matchfound   false
fromtable	 fromtable
/* expand the "*" for the table that matches, if it is qualified
* (alltablename is not null) or for all tables in the list at the
* current nesting level if the "*" is not qualified (alltablename
* is null).  current nesting level is determined by the nesting
* level of the first fromtable in the list.
*/
int targetnestinglevel     fromtable elementat 0   getlevel
int size   size
/* make sure our assumption about nesting-based ordering
* has been satisified.  i.e. that the list is ordered
* with the most deeply nested fromtables first.
*/
if  sanitymanager debug
int prevnl   targetnestinglevel
for  int i   1  i < size  i
int currnl     fromtable elementat i   getlevel
sanitymanager assert  prevnl >  currnl
prevnl   currnl
for  int index   0  index < size  index
fromtable    fromtable  elementat index
if  targetnestinglevel    fromtable getlevel
/* we only expand result columns for tables at the
* target nesting level.  since the fromtables are
* sorted based on nesting level, we're done if we
* get here.
*/
break
/* we let the fromtable decide if there is a match on
* the exposed name.  (a joinnode will not have an
* exposed name, so it will need to pass the info to its
* left and right children.)
*/
temprclist   fromtable getallresultcolumns alltablename
if  temprclist    null
continue
/* expand the column list and append to the list that
* we will return.
*/
if  resultcolumnlist    null
resultcolumnlist   temprclist
else
resultcolumnlist nondestructiveappend temprclist
/* if the "*" is qualified, then we can stop the
* expansion as soon as we find the matching table.
*/
if  alltablename    null
matchfound   true
/* give an error if the qualification name did not match
* an exposed name
*/
if  resultcolumnlist    null
throw standardexception newexception sqlstate lang_exposed_name_not_found  alltablename
return resultcolumnlist
/**
* bind a column reference to one of the tables in this fromlist.  the column name
* must be unique within the tables in the fromlist.  an exception is thrown
* if a column name is not unique.
*
* note: callers are responsible for ordering the fromlist by nesting level,
* with tables at the deepest (current) nesting level first.  we will try to
* match against all fromtables at a given nesting level.  if no match is
* found at a nesting level, then we proceed to the next level.  we stop
* walking the list when the nesting level changes and we have found a match.
*
* note: if the columnreference is qualified, then we will stop the search
* at the first nesting level where there is a match on the exposed table name.
* for example, s (a, b, c), t (d, e, f)
*		select * from s where exists (select * from t s where s.c = a)
* will not find a match for s.c, which is the expected ansi behavior.
*
* bindtables() must have already been called on this fromlist before
* calling this method.
*
* @param columnreference	the columnreference describing the column to bind
*
* @return	resultcolumn	the matching resultcolumn
*
* @exception standardexception		thrown on error
*/
public resultcolumn bindcolumnreference columnreference columnreference
throws standardexception
boolean			columnnamematch   false
boolean			tablenamematch   false
fromtable		fromtable
int				currentlevel    1
int				previouslevel    1
resultcolumn	matchingrc   null
resultcolumn	resultcolumn
string			crtablename   columnreference gettablename
/*
** find the first table with matching column name.  if there
** is more than one table with a matching column name at the same
** nesting level, give an error.
*/
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
/* we can stop if we've found a matching column or table name
* at the previous nesting level.
*/
currentlevel   fromtable getlevel
if  previouslevel    currentlevel
if  columnnamematch
break
if  tablenamematch
break
/* simpler to always set previouslevel then to test and set */
previouslevel   currentlevel
resultcolumn   fromtable getmatchingcolumn columnreference
if  resultcolumn    null
if    columnnamematch
/* tablenumbers are set in the cr in the underlying
* fromtable.  this ensures that they get the table
* number from the underlying table, not the join node.
* this is important for beging able to push predicates
* down through join nodes.
*/
matchingrc   resultcolumn
columnreference setsource resultcolumn
columnreference settype resultcolumn gettypeservices
/* set the nesting level at which the cr appears and the nesting level
* of its source rc.
*/
columnreference setnestinglevel   fromtable  elementat 0   getlevel
columnreference setsourcelevel currentlevel
columnnamematch   true
if  fromtable isprivilegecollectionrequired
getcompilercontext   addrequiredcolumnpriv  resultcolumn gettablecolumndescriptor
else
throw standardexception newexception sqlstate lang_ambiguous_column_name
columnreference getsqlcolumnname
/* remember if we get a match on the exposed table name, so that
* we can stop at the beginning of the next level.
*/
tablenamematch   tablenamematch
crtablename    null
crtablename equals fromtable getexposedname
return matchingrc
/**
* check for (and reject) all ? parameters directly under the resultcolumns.
* this is done for select statements.
*
* @exception standardexception		thrown if a ? parameter found
*									directly under a resultcolumn
*/
public void rejectparameters   throws standardexception
fromtable	fromtable
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
fromtable rejectparameters
// this method reorders lojs in the from clause.
// for now, we process only a loj.  for example, "... from loj_1, loj2 ..."
// will not be processed.
public boolean loj_reorderable int numtables  throws standardexception
boolean anychange   false
if  size   > 1  return anychange
fromtable ft    fromtable  elementat 0
anychange   ft loj_reorderable numtables
return anychange
/**
* preprocess the query tree - this currently means:
*	o  generating a referenced table map for each resultsetnode.
*  o  putting the where and having clauses in conjunctive normal form (cnf).
*  o  converting the where and having clauses into predicatelists and
*	   classifying them.
*  o  flatten those fromsubqueries which can be flattened.
*  o  ensuring that a projectrestrictnode is generated on top of every
*     frombasetable and generated in place of every fromsubquery which
*	   could not be flattened.
*  o  pushing single table predicates down to the new projectrestrictnodes.
*
* @param numtables			the number of tables in the dml statement
* @param gbl				the group by list, if any
*
* @exception standardexception		thrown on error
*/
public void preprocess int numtables
groupbylist gbl
valuenode predicatetree
throws standardexception
int size   size
/* preprocess each fromtable in the list */
for  int index   0  index < size  index
fromtable ft    fromtable  elementat index
/* transform any outer joins to inner joins where appropriate */
ft   ft transformouterjoins predicatetree  numtables
/* preprocess this fromtable */
setelementat ft preprocess numtables  gbl  this   index
/**
* flatten all the fromtables that are flattenable.
* resolve - right now we just flatten fromsubqueries.  we
* should also flatten flattenable joinnodes here.
*
* @param rcl				the rcl from the outer query
* @param predicatelist		the predicatelist from the outer query
* @param sql				the subquerylist from the outer query
* @param gbl				the group by list, if any
*
* @exception standardexception		thrown on error
*/
public void flattenfromtables resultcolumnlist rcl
predicatelist predicatelist
subquerylist sql
groupbylist gbl
throws standardexception
boolean			flattened   true
vector 			flattenedtablenumbers   new vector
if  sanitymanager debug
sanitymanager assert rcl    null
sanitymanager assert predicatelist    null
sanitymanager assert sql    null
/* loop until all flattenable entries are flattened.
* we restart the inner loop after flattening an in place
* to simplify the logic and so that we don't have to worry
* about walking a list while we are modifying it.
*/
while  flattened
flattened   false
for  int index   0  index < size        flattened  index
fromtable ft    fromtable  elementat index
/* flatten fromsubquerys and flattenable joinnodes */
if   ft instanceof fromsubquery
ft isflattenablejoinnode
//save the table number of the node to be flattened
flattenedtablenumbers addelement new integer ft gettablenumber
/* remove the node from the list and insert its
* fromlist here.
*/
fromlist	 flatteningfl   ft flatten
rcl
predicatelist
sql
gbl
if  sanitymanager debug
sanitymanager assert flatteningfl    null
flatteningfl size   > 0
if  flatteningfl    null
setelementat flatteningfl elementat 0   index
int innersize   flatteningfl size
for  int inner   1  inner < innersize  inner
insertelementat flatteningfl elementat inner   index   inner
else
/*
** if flatten returns null, that means it wants to
** be removed from the fromlist.
*/
removeelementat index
flattened   true
/* fix up dependency maps for exists base tables since they might have a
* dependency on this join node
*/
if  flattenedtablenumbers size   > 0
for  int i   0  i < size    i
fromtable ft    fromtable  elementat i
if  ft instanceof projectrestrictnode
resultsetnode rst     projectrestrictnode ft  getchildresult
if  rst instanceof frombasetable
frombasetable rst  cleardependency flattenedtablenumbers
/**
* categorize and push the predicates that are pushable.
*
* @param predicatelist		the query's predicatelist
*
* @exception standardexception		thrown on error
*/
void pushpredicates predicatelist predicatelist
throws standardexception
if  sanitymanager debug
sanitymanager assert predicatelist    null
/* we can finally categorize each predicate and try to push them down.
* note: the predicatelist may be empty, but that's okay, we still
* call pushexpressions() for each entry in the fromlist because that's
* where any outer join conditions will get pushed down.
*/
predicatelist categorize
int size   size
for  int index   0  index < size  index
fromtable fromtable    fromtable  elementat index
fromtable pushexpressions predicatelist
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
fromtable	fromtable
super printsubnodes depth
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
fromtable treeprint depth   1
/**
* set the (query block) level (0-based) for the fromtables in this
* fromlist.
*
* @param level		the query block level for this table.
*/
public void setlevel int level
int size   size
for  int index   0  index < size  index
fromtable fromtable    fromtable  elementat index
fromtable setlevel level
/**
* get the fromtable from this list which has the specified resultcolumn in
* its rcl.
*
* @param rc	the resultcolumn match on.
*
* @return fromtable	the matching fromtable.
*/
public fromtable getfromtablebyresultcolumn resultcolumn rc
fromtable	fromtable   null
int size   size
for  int index   0  index < size  index
fromtable    fromtable  elementat index
if  fromtable getresultcolumns   indexof rc      1
break
if  sanitymanager debug
sanitymanager assert fromtable    null
return fromtable
/**
* set the properties list for this fromlist.
*
* @exception standardexception		thrown on error
*/
public void setproperties properties props  throws standardexception
properties   props
/*
** validate the properties list now.  this is possible because
** there is nothing in this properties list that relies on binding
** or optimization to validate.
*/
enumeration e   properties keys
while  e hasmoreelements
string key    string  e nextelement
string value    string  properties get key
if  key equals
if  stringutil sqlequalsignorecase value
fixedjoinorder   true
else if  stringutil sqlequalsignorecase value
fixedjoinorder   false
else
throw standardexception newexception sqlstate lang_invalid_join_order_spec  value
else if  key equals
if  stringutil sqlequalsignorecase value
usestatistics   true
else if  stringutil sqlequalsignorecase value
usestatistics   false
else
throw standardexception newexception sqlstate lang_invalid_statistics_spec  value
else
throw standardexception newexception sqlstate lang_invalid_from_list_property  key  value
/** @see optimizablelist#reorder */
public void reorder int joinorder
int	posn
if  sanitymanager debug
if  joinorder length    size
sanitymanager throwassert     size         joinorder length
/*
** determine that the values in the list are unique and in range.
** the easiest way to determine that they are unique is to add
** them all up and see whether the result is what's expected
** for that array size.
*/
int sum   0
for  int i   0  i < joinorder length  i
if  joinorder < 0    joinorder >  joinorder length   1
sanitymanager throwassert     i
joinorder
joinorder length   1
sum    joinorder
/*
** the sum of all integers from 0 through n is (n * (n - 1)) / 2.
*/
if  sum        joinorder length    joinorder length   1      2
string arrayvals
for  int i   0  i < joinorder length  i
arrayvals   arrayvals   joinorder
sanitymanager throwassert     arrayvals
/* form a list that's in the order we want */
querytreenode orderedfl   new fromtable
for  posn   0  posn < joinorder length  posn
/*
** get the element at the i'th join order position from the
** current list and make it the next element of orderedlist.
*/
orderedfl   elementat joinorder
/* now orderedlist has been built, so set this list to the same order */
for  posn   0  posn < joinorder length  posn
setelementat orderedfl  posn
/** @see optimizablelist#usestatistics */
public boolean usestatistics
return usestatistics
/** @see optimizablelist#optimizejoinorder */
public boolean optimizejoinorder
return   fixedjoinorder
/** @see optimizablelist#legaljoinorder */
public boolean legaljoinorder int numtablesinquery
jbitset			assignedtablemap   new jbitset numtablesinquery
int size   size
for  int index   0  index < size  index
fromtable ft    fromtable  elementat index
assignedtablemap or ft getreferencedtablemap
if     ft legaljoinorder assignedtablemap
return false
return true
/** @see optimizablelist#initaccesspaths */
public void initaccesspaths optimizer optimizer
int size   size
for  int index   0  index < size  index
fromtable ft    fromtable  elementat index
ft initaccesspaths optimizer
/**
* bind any untyped null nodes to the types in the given resultcolumnlist.
*
* @param bindingrcl	the resultcolumnlist with the types to bind to.
*
* @exception standardexception		thrown on error
*/
public void binduntypednullstoresultcolumns resultcolumnlist bindingrcl
throws standardexception
int size   size
for  int index   0  index < size  index
fromtable fromtable    fromtable  elementat index
fromtable binduntypednullstoresultcolumns bindingrcl
/**
* decrement (query block) level (0-based) for
* all of the tables in this from list.
* this is useful when flattening a subquery.
*
* @param decrement	the amount to decrement by.
*/
void decrementlevel int decrement
int size   size
for  int index   0  index < size  index
fromtable fromtable    fromtable  elementat index
fromtable decrementlevel decrement
/* decrement the level of any crs in single table
* predicates that are interesting to transitive
* closure.
*/
projectrestrictnode prn    projectrestrictnode  fromtable
predicatelist pl   prn getrestrictionlist
if  pl    null
pl decrementlevel this  decrement
/**
* this method is used for both subquery flattening and distinct
* elimination based on a uniqueness condition.  for subquery
* flattening we want to make sure that the query block
* will return at most 1 row.  for distinct elimination we
* want to make sure that the query block will not return
* any duplicates.
* this is true if every table in the from list is
* (a base table and the set of columns from the table that
* are in equality comparisons with expressions that do not include columns
* from the same table is a superset of any unique index
* on the table) or an exists fbt.  in addition, at least 1 of the tables
* in the list has a set of columns in equality comparisons with expressions
* that do not include column references from the same query block
* is a superset of a unique index
* on that table.  (this ensures that the query block will onlyr
* return a single row.)
* this method is expected to be called after normalization and
* after the from list has been preprocessed.
* it can be called both before and after the predicates have
* been pulled from the where clause.
* the algorithm for this is as follows
*
*	if any table in the query block is not a base table, give up.
* 	for each table in the query
*		ignore exists table since they can only produce one row
*
*		create a matrix of tables and columns from the table (tablecolmap)
*		(this is used to keep track of the join columns and constants
*		that can be used to figure out whether the rows from a join
*		or in a select list are distinct based on unique indexes)
*
*		create an array of columns from the table(eqoutercol)
*		(this is used to determine that only one row will be returned
*		from a join)
*
*		if the current table is the table for the result columns
*			set the result columns in the eqoutercol and tablecolmap
*			(if these columns are a superset of a unique index and
*			all joining tables result in only one row, the
*			results will be distinct)
*		go through all the predicates and update tablecolmap  and
*		eqoutercol with join columns and correlation variables,
*		parameters and constants
*		since setting constants, correlation variables and parameters,
* 		reduces the number of columns required for uniqueness in a
*		multi-column index, they are set for all the tables (if the
*		table is not the result table, in this case only the column of the
*		result table is set)
*		join columns are just updated for the column in the row of the
*		joining table.
*
*		check if the marked columns in tablecolmap are a superset of a unique
*			index
*			(this means that the join will only produce 1 row when joined
*			with 1 row of another table)
*		check that there is a least one table for which the columns in
*			eqoutercol(i.e. constant values) are a superset of a unique index
*			(this quarantees that there will be only one row selected
*			from this table).
*
*	once all tables have been evaluated, check that all the tables can be
* 	joined by unique index or will have only one row
*
*
*
* @param rcl				if non-null, the rcl from the query block.
*							if non-null for subqueries, then entry can
*							be considered as part of an = comparison.
* @param whereclause		the where clause to consider.
* @param wherepredicates	the predicates that have already been
*							pulled from the where clause.
* @param dd				the datadictionary to use.
*
* @return	whether or not query block will return
*			at most 1 row for a subquery, no duplicates
*			for a distinct.
*
* @exception standardexception		thrown on error
*/
boolean returnsatmostsinglerow resultcolumnlist rcl
valuenode whereclause
predicatelist wherepredicates
datadictionary dd
throws standardexception
boolean			satisfiesouter   false
int			tablenumbers
columnreference	additionalcr   null
predicatelist predicatestemp
predicatestemp    predicatelist  getnodefactory   getnode
c_nodetypes predicate_list 	getcontextmanager
int wherepredicatessize   wherepredicates size
for  int index   0  index < wherepredicatessize  index
predicatestemp addpredicate  predicate wherepredicates elementat index
/* when considering subquery flattening, we are interested
* in the 1st (and only) entry in the rcl.  (the rcl will be
* null if result column is not of interest for subquery flattening.)
* we are interested in all entries in the rcl for distinct
* elimination.
*/
if  rcl    null
resultcolumn rc    resultcolumn  rcl elementat 0
if  rc getexpression   instanceof columnreference
additionalcr    columnreference  rc getexpression
/* first see if all entries are frombasetables.  no point
* in continuing if not.
*/
int size   size
for  int index   0  index < size  index
fromtable fromtable    fromtable  elementat index
if     fromtable instanceof projectrestrictnode
return false
projectrestrictnode prn    projectrestrictnode  fromtable
if     prn getchildresult   instanceof frombasetable
return false
frombasetable fbt    frombasetable  prn getchildresult
//following for loop code is to take care of derby-251 (distinct returns
//duplicate rows).
//derby-251 returned duplicate rows because we were looking at predicates
//that belong to existstable to determine distinct elimination
//
//(check method level comments to understand distinct elimination rules.)
//
//for one specific example, consider the query below
//select  distinct  q1."no1" from idept q1, idept q2
//where  ( q2."discrim_dept" = 'hardwaredept')
//and  ( q1."discrim_dept" = 'softwaredept')  and  ( q1."no1" <> all
//(select  q3."no1" from idept q3 where  (q3."reportto_no" =  q2."no1")))
//(select  q3."no1" from idept q3 where  ( abs(q3."reportto_no") =  q2."no1")))
//
//table idept in the query above has a primary key defined on column "no1"
//this query gets converted to following during optimization
//
//select  distinct  q1."no1" from idept q1, idept q2
//where  ( q2."discrim_dept" = 'hardwaredept')
//and  ( q1."discrim_dept" = 'softwaredept')  and  not exists (
//(select  q3."no1" from idept q3 where
//(  ( abs(q3."reportto_no") =  q2."no1")  and q3."no1" = q1."no1") ) )  ;
//
//for the optimized query above, derby generates following predicates.
//abs(q3.reportto_no) = q2.no1
//q2.discrim_dept = 'hardwaredept'
//q1.descrim_dept = 'softwaredept'
//q1.no1 = q3.no1
//the predicate abs(q3."no1") = q1."no1" should not be considered when trying
//to determine if q1 in the outer query has equality comparisons.
//similarly, the predicate q3.reportto_no = q2.no1 should not be
//considered when trying to determine if q2 in the outer query has
//equality comparisons. to achieve this, predicates based on exists base
//table q3 (the first and the last predicate) should be removed while
//evaluating outer query for uniqueness.
//
if  fbt getexistsbasetable
int existstablenumber   fbt gettablenumber
int predicatestempsize   predicatestemp size
for  int predicatestempindex   predicatestempsize 1
predicatestempindex >  0  predicatestempindex
andnode topandnode    andnode
predicate  predicatestemp elementat predicatestempindex   getandnode
for  valuenode wherewalker   topandnode  wherewalker instanceof andnode
wherewalker     andnode  wherewalker  getrightoperand
// see if this is a candidate =
andnode and    andnode  wherewalker
//we only need to worry about equality predicates because only those
//predicates are considered during distinct elimination.
if   and getleftoperand   isrelationaloperator
relationaloperator  and getleftoperand     getoperator
relationaloperator equals_relop
continue
jbitset referencedtables   and getleftoperand   gettablesreferenced
if  referencedtables get existstablenumber
predicatestemp removeelementat predicatestempindex
break
/* build an array of tablenumbers from this query block.
* we will use that array to find out if we have at least
* one table with a uniqueness condition based only on
* constants, parameters and correlation columns.
*/
tablenumbers   gettablenumbers
jbitset tablecolmap   new jbitset
boolean onerow   new boolean
boolean onerowresult   false
/* see if each table has a uniqueness condition */
for  int index   0  index < size  index
projectrestrictnode prn    projectrestrictnode  elementat index
frombasetable fbt    frombasetable  prn getchildresult
// skip over exists fbt since they cannot introduce duplicates
if  fbt getexistsbasetable
onerow   true
continue
int numcolumns   fbt gettabledescriptor   getnumberofcolumns
boolean eqoutercols   new boolean
int tablenumber   fbt gettablenumber
boolean resultcoltable   false
for  int i   0  i < size  i
tablecolmap   new jbitset numcolumns   1
if  additionalcr    null
additionalcr gettablenumber      tablenumber
rcl recordcolumnreferences eqoutercols  tablecolmap  index
resultcoltable   true
/* now see if there are any equality conditions
* of interest in the where clause.
*/
if  whereclause    null
whereclause checktoppredicatesforequalsconditions
tablenumber  eqoutercols  tablenumbers
tablecolmap  resultcoltable
/* now see if there are any equality conditions
* of interest in the where predicates.
*/
predicatestemp checktoppredicatesforequalsconditions
tablenumber  eqoutercols  tablenumbers
tablecolmap  resultcoltable
/* now see if there are any equality conditions
* of interest that were already pushed down to the
* prn above the fbt. (single table predicates.)
*/
if  prn getrestrictionlist      null
prn getrestrictionlist   checktoppredicatesforequalsconditions
tablenumber  eqoutercols  tablenumbers
tablecolmap  resultcoltable
/* we can finally check to see if the marked columns
* are a superset of any unique index.
*/
if    fbt supersetofuniqueindex tablecolmap
return false
/* do we have at least 1 table whose equality condition
* is based solely on constants, parameters and correlation columns.
*/
onerowresult   fbt supersetofuniqueindex eqoutercols
if  onerowresult
onerow   true
satisfiesouter   true
/* have we met all of the criteria */
if  satisfiesouter
/* check that all the tables are joined by unique indexes
* or only produce 1 row
*/
boolean foundonerow   true
while  foundonerow
foundonerow   false
for  int index   0  index < size  index
if  onerow
for  int i   0  i < size  i
/* unique key join - exists tables already marked as
* 1 row - so don't need to look at them
*/
if   onerow    tablecolmap get 0
onerow   true
foundonerow   true
/* does any table produce more than one row */
for  int index   0  index < size  index
if   onerow
satisfiesouter   false
break
return satisfiesouter
int gettablenumbers
int size   size
int tablenumbers   new int
for  int index   0  index < size  index
projectrestrictnode prn    projectrestrictnode  elementat index
if     prn getchildresult   instanceof fromtable
continue
fromtable ft    fromtable  prn getchildresult
tablenumbers   ft gettablenumber
return tablenumbers
/**
* mark all of the frombasetables in the list as exists fbts.
* each ebt has the same dependency list - those tables that are referenced
* minus the tables in the from list.
*
* @param referencedtablemap	the referenced table map.
* @param outerfromlist			fromlist from outer query block
* @param isnotexists			whether or not for not exists
*
* @exception standardexception		thrown on error
*/
void genexistsbasetables jbitset referencedtablemap  fromlist outerfromlist
boolean isnotexists
throws standardexception
jbitset			dependencymap    jbitset  referencedtablemap clone
// we currently only flatten single table from lists
if  sanitymanager debug
if  size      1
sanitymanager throwassert
size
/* create the dependency map */
int size   size
for  int index   0  index < size  index
resultsetnode ft     projectrestrictnode  elementat index   getchildresult
if  ft instanceof fromtable
dependencymap clear   fromtable  ft  gettablenumber
/* degenerate case - if flattening a non-correlated exists subquery
* then we need to make the table that is getting flattened dependendent on
* all of the tables in the outer query block.  gross but true.  otherwise
* that table can get chosen as an outer table and introduce duplicates.
* the reason that duplicates can be introduced is that we do special processing
* in the join to make sure only one qualified row from the right side is
* returned.  if the exists table is on the left, we can return all the
* qualified rows.
*/
if  dependencymap getfirstsetbit       1
int outersize   outerfromlist size
for  int outer   0  outer < outersize  outer
dependencymap or   fromtable  outerfromlist elementat outer   getreferencedtablemap
/* do the marking */
for  int index   0  index < size  index
fromtable fromtable    fromtable  elementat index
if  fromtable instanceof projectrestrictnode
projectrestrictnode prn    projectrestrictnode  fromtable
if  prn getchildresult   instanceof frombasetable
frombasetable fbt    frombasetable  prn getchildresult
fbt setexistsbasetable true   jbitset  dependencymap clone    isnotexists
/**
* get the lock mode for the target of an update statement
* (a delete or update).  the update mode will always be row for
* currentofnodes.  it will be table if there is no where clause.
*
* @return	the lock mode
*/
public int updatetargetlockmode
if  sanitymanager debug
if  size      1
sanitymanager throwassert
return   resultsetnode  elementat 0   updatetargetlockmode
/**
* return whether or not the user specified a hash join for any of the
* tables in this list.
*
* @return	whether or not the user specified a hash join for any of the
*			tables in this list.
*/
boolean hashjoinspecified
int size   size
for  int index   0  index < size  index
fromtable ft    fromtable  elementat index
string joinstrategy   ft getuserspecifiedjoinstrategy
if  joinstrategy    null    stringutil sqltouppercase joinstrategy  equals
return true
return false
/**
* indicate that this fromlist is "transparent", which means that
* its fromtables should be bound to tables from an outer query.
* generally this is not allowed, but there are exceptions.  see
* setoperatornode.setresulttobooleantruenode() for more.
*/
void markastransparent
istransparent   true
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
int size   size
for  int index   0  index < size  index
fromtable fromtable    fromtable  elementat index
setelementat  querytreenode  fromtable accept v   index
return this