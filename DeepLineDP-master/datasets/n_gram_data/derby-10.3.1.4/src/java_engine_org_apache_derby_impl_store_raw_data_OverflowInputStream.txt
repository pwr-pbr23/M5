/*
derby - class org.apache.derby.impl.store.raw.data.overflowinputstream
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi store raw recordhandle
import org apache derby iapi types resetable
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store access transactioncontroller
import java io inputstream
import java io ioexception
/**
a overflowinputstream is used by store to turn a long column
into an inputstream.
*/
public class overflowinputstream
extends bufferedbyteholderinputstream
implements resetable
protected basecontainerhandle owner
protected long overflowpage
protected int overflowid
// remember first page and id for reset
protected long firstoverflowpage
protected int firstoverflowid
// the row to lock for blobs/clobs
protected recordhandle recordtolock
public overflowinputstream byteholder bh  basecontainerhandle owner
long overflowpage  int overflowid  recordhandle recordtolock
throws ioexception  standardexception
super bh
this owner   owner
this overflowpage   overflowpage
this overflowid   overflowid
this firstoverflowpage   overflowpage
this firstoverflowid   overflowid
this recordtolock   recordtolock
fillbyteholder
public void fillbyteholder   throws ioexception
if   this bh available      0      this overflowpage     1
this bh clear
try
// fill the byte holder with data from the page.
basepage columnoverflowpage
basepage  this owner getpage overflowpage
if  columnoverflowpage    null
columnoverflowpage restoreportionlongcolumn this
columnoverflowpage unlatch
columnoverflowpage   null
catch  standardexception se
throw new ioexception  se tostring
this bh startreading
public long getoverflowpage
return this overflowpage
public int getoverflowid
return this overflowid
public void setoverflowpage long overflowpage
this overflowpage   overflowpage
public void setoverflowid int overflowid
this overflowid   overflowid
/*
methods of resetable interface.
*/
/*
resets the stream to the beginning.
*/
public void resetstream   throws ioexception  standardexception
// check the container is open, this is needed to make sure the
// container closed exception is thrown as a standardexception and not
// as an ioexception
owner checkopen
// return to the original overflow page and id
this overflowpage   firstoverflowpage
this overflowid   firstoverflowid
// completely clear the byte holder
this bh clear
this bh startreading
// fill the byte holder
fillbyteholder
/*
initialize.  reopen the container. this will have the effect of
getting an intent shared lock on the table, which will stay around until
the end of the transaction (or until the enclosing blob/clob object is
closed). also get a read lock on the appropriate row.
*/
public void initstream   throws standardexception
// it is possible that the transaction in which the stream was
// created is committed and no longer valid
// dont want to get npe but instead throw error that
// container was not opened
if  owner gettransaction      null
throw standardexception newexception sqlstate data_container_closed
/*
we might want to use the mode and isolation level of the container.
this would have the advantage that, if the isolation level
is read_committed, resources would be freed if blobs/clob finalizers are
called (e.g. they are garbage collected) before the end of transaction.
if the mode was mode_container, opencontainer would get an s lock on the
table instead of an is lock, and lockrecordforread would have no effect.
to do this, need to consider:
sometimes the container's locking policy may not reflect the correct
locking policy. for example, if the container is a table (not an index)
and access handles the locking of the table via an index, the container's
locking policy would be set to do no locking.
moreover, if the container is an index, the locking policy would
always be set to do no locking.
*/
lockingpolicy lp
owner gettransaction   newlockingpolicy
lockingpolicy mode_record
transactioncontroller isolation_repeatable_read  true
// reopen the container
owner    basecontainerhandle  owner gettransaction   opencontainer
owner getid    lp  owner getmode
// get a read lock on the appropriate row
// this will wait until either the lock is granted or an exception is
// thrown
owner getlockingpolicy   lockrecordforread
owner gettransaction    owner  recordtolock  true  false
/*
close the container associated with this stream. (in the future if we use
a read committed isolation mode, this will also free the associated is
table lock and the associated s row lock.)
*/
public void closestream
owner close