/*
derby - class org.apache.derby.impl.sql.compile.valuenode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import java util vector
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services i18n messageservice
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile nodefactory
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile typecompiler
import org apache derby iapi store access qualifier
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluefactory
import org apache derby iapi types typeid
import org apache derby iapi util jbitset
/**
* a valuenode is an abstract class for all nodes that can represent data
* values, that is, constants, columns, and expressions.
*
*/
public abstract class valuenode extends querytreenode
/**
* the data type for this node.
*/
protected datatypedescriptor	datatypeservices
private typecompiler typecompiler
// whether or not additional predicates have been created from this one.
boolean	transformed
/*
** constructor for untyped valuenodes, for example, untyped nulls
** and parameter nodes.
**
** binding will replace all untyped valuenodes with typed valuenodes
** when it figures out what their types should be.
*/
public valuenode
/**
* set this node's type from type components.
*/
final void settype typeid typeid
boolean isnullable
int maximumwidth
throws standardexception
settype
new datatypedescriptor
typeid  typeid
isnullable
maximumwidth
/**
* set this node's type from type components.
*/
final void settype typeid typeid
int precision  int scale
boolean isnullable
int maximumwidth
throws standardexception
settype
new datatypedescriptor
typeid  typeid
precision
scale
isnullable
maximumwidth
/**
* initializer for numeric types.
*
*
* @param typeid	the typeid of this new node
* @param precision	the precision of this new node
* @param scale		the scale of this new node
* @param isnullable	the nullability of this new node
* @param maximumwidth	the maximum width of this new node
*
* @exception standardexception
*/
public void init
object typeid
object precision
object scale
object isnullable
object maximumwidth
throws standardexception
settype
new datatypedescriptor
typeid  typeid
integer  precision  intvalue
integer  scale  intvalue
boolean  isnullable  booleanvalue
integer  maximumwidth  intvalue
/**
* initializer for non-numeric types.
*
*
* @param tcf		the factory to get the
*					datatypeservicesfactory from
* @param typeid	the typeid of this new node
* @param isnullable	the nullability of this new node
* @param maximumwidth	the maximum width of this new node
*
* @exception standardexception
*/
valuenode
object tcf
object typeid
object isnullable
object maximumwidth
throws standardexception
settype new datatypedescriptor
typeid  typeid
boolean  isnullable  booleanvalue
integer  maximumwidth  intvalue
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return
datatypeservices    null  ?
datatypeservices tostring
super tostring
else
return
/**
* get the datatypeservices from this valuenode.
*
* @return	the datatypeservices from this valuenode.  this
*		may be null if the node isn't bound yet.
*/
public datatypedescriptor gettypeservices   throws standardexception
return datatypeservices
/**
* get the typeid from this valuenode.
*
* @return	the typeid from this valuenode.  this
*		may be null if the node isn't bound yet.
*/
public typeid gettypeid   throws standardexception
datatypedescriptor dtd   gettypeservices
if  dtd    null
return dtd gettypeid
return null
/**
return the datavaluefactory
*/
protected final datavaluefactory getdatavaluefactory
return getlanguageconnectioncontext   getdatavaluefactory
/**
* get the typecompiler from this valuenode, based on its typeid
* using gettypeid().
*
* @return	this valuenode's typecompiler
*
*/
public final typecompiler gettypecompiler   throws standardexception
return gettypecompiler gettypeid
/**
* set the datatypeservices for this valuenode.  this method is
* overridden in parameternode.
*
* @param datatypeservices	the datatypeservices to set in this
*				valuenode
*/
public void settype datatypedescriptor datatypeservices  throws standardexception
this datatypeservices   datatypeservices
// clear the typecompiler, just in case type has changed
typecompiler   null
/**
* there are many subclasses of valuenode where we want the
* datatypedescriptor of the node to have the same collation type as the
* compilation schema's collation type. for that purpose, this method in
* the baseclass here can be utilized by the subclasses. in addition, the
* subclasses can pass the collationderivation that they expect the
* datatypedescriptor to have.
*
* @param collationderivation this can be
* stringdatavalue#collation_derivation_implicit
* stringdatavalue#collation_derivation_none
* stringdatavalue#collation_derivation_explicit
*
* @throws standardexception
*/
protected void setcollationusingcompilationschema int collationderivation
throws standardexception
gettypeservices   setcollationtype
getschemadescriptor null  false  getcollationtype
gettypeservices   setcollationderivation collationderivation
/**
* get the source for this valuenode.
*
* @return	the source of this valuenode, null if this node
* is not sourced by a column.
*/
public resultcolumn getsourceresultcolumn
return null
/**
* mark this predicate has having been transformed (other predicates
* were generated from it).  this will help us with ensure that the
* predicate does not get calculated into the selectivity multiple
* times.
*/
void settransformed
transformed   true
/**
* return whether or not this predicate has been transformed.
*
* @return whether or not this predicate has been transformed.
*/
boolean gettransformed
return transformed
public valuenode bindexpression
fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
return bindexpression fromlist  subquerylist  aggregatevector false
/**
* bind this expression.  this is a place-holder method - it should never
* be called.
*
* @param fromlist			the from list to use for binding
* @param subquerylist		the subquerylist we are building as we hit
*							subquerynodes.
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception	thrown on error
*/
public valuenode bindexpression
fromlist fromlist  subquerylist subquerylist
vector aggregatevector  boolean forqueryrewrite
throws standardexception
/* there are a bizillion classes which extend valuenode.  here is info
* on some of the classes that bindexpression() should not be called on
* and why:
*	o  basecolumnnodes should only appear under the resultcolumnlist
*     in the frombasetable.  they are created/bound when binding the
*     frombasetable.
*/
if  sanitymanager debug
sanitymanager assert false
this getclass   tostring
return this
/**
* generate a sql->java->sql conversion tree above the current node
* and bind the new nodes individually.
* this is useful when doing comparisons, built-in functions, etc. on
* java types which have a direct mapping to system built-in types.
*
* @return valuenode	the new tree.
*
* @exception standardexception	thrown on error
*/
public valuenode gensqljavasqltree
throws standardexception
if  sanitymanager debug
sanitymanager assert gettypeid      null
sanitymanager assert gettypeid   usertype
javavaluenode stjvn    javavaluenode  getnodefactory   getnode
c_nodetypes sql_to_java_value_node
this
getcontextmanager
valuenode jtsvn    valuenode  getnodefactory   getnode
c_nodetypes java_to_sql_value_node
stjvn
getcontextmanager
jtsvn settype datatypedescriptor getsqldatatypedescriptor stjvn getjavatypename
return jtsvn
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
return this
/**
* eliminate notnodes in the current query block.  we traverse the tree,
* inverting ands and ors and eliminating nots as we go.  we stop at
* comparisonoperators and boolean expressions.  we invert
* comparisonoperators and replace boolean expressions with
* boolean expression = false.
* note: since we do not recurse under comparisonoperators, there
* still could be notnodes left in the tree.
*
* @param	undernotnode		whether or not we are under a notnode.
*
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
valuenode eliminatenots boolean undernotnode
throws standardexception
if    undernotnode
return this
/* bind() has ensured that this node's type is sqlboolean */
if  sanitymanager debug
sanitymanager assert
gettypeid   isbooleantypeid
gettypeid   getsqltypename
/* return valuenode = false */
return genequalsfalsetree
/**
* transform this into this = false.  useful for not elimination.
*
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode genequalsfalsetree
throws standardexception
binaryrelationaloperatornode equalsnode
booleanconstantnode		 falsenode
boolean 				nullableresult
nodefactory				nodefactory   getnodefactory
falsenode    booleanconstantnode  nodefactory getnode
c_nodetypes boolean_constant_node
boolean false
getcontextmanager
equalsnode    binaryrelationaloperatornode
nodefactory getnode
c_nodetypes binary_equals_operator_node
this
falsenode
getcontextmanager
nullableresult   gettypeservices   isnullable
equalsnode settype new datatypedescriptor
typeid boolean_id
nullableresult
return equalsnode
/**
* transform this into this is null.  useful for not elimination.
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode genisnulltree
throws standardexception
isnullnode isnullnode
isnullnode    isnullnode
getnodefactory   getnode
c_nodetypes is_null_node
this
getcontextmanager
isnullnode settype new datatypedescriptor
typeid boolean_id
false
return isnullnode
/**
* verify that eliminatenots() did its job correctly.  verify that
* there are no notnodes above the top level comparison operators
* and boolean expressions.
*
* @return		boolean which reflects validity of the tree.
*/
boolean verifyeliminatenots
if  sanitymanager assert
return     this instanceof notnode
else
return true
/**
* do the 1st step in putting an expression into conjunctive normal
* form.  this step ensures that the top level of the expression is
* a chain of andnodes.
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode putandsontop
throws standardexception
nodefactory		nodefactory   getnodefactory
querytreenode truenode   nodefactory getnode
c_nodetypes boolean_constant_node
boolean true
getcontextmanager
andnode andnode    andnode  nodefactory getnode
c_nodetypes and_node
this
truenode
getcontextmanager
andnode postbindfixup
return andnode
/**
* verify that putandsontop() did its job correctly.  verify that the top level
* of the expression is a chain of andnodes.
*
* @return		boolean which reflects validity of the tree.
*/
public boolean verifyputandsontop
return true
/**
* finish putting an expression into conjunctive normal
* form.  an expression tree in conjunctive normal form meets
* the following criteria:
*		o  if the expression tree is not null,
*		   the top level will be a chain of andnodes terminating
*		   in a true booleanconstantnode.
*		o  the left child of an andnode will never be an andnode.
*		o  any right-linked chain that includes an andnode will
*		   be entirely composed of andnodes terminated by a true booleanconstantnode.
*		o  the left child of an ornode will never be an ornode.
*		o  any right-linked chain that includes an ornode will
*		   be entirely composed of ornodes terminated by a false booleanconstantnode.
*		o  valuenodes other than andnodes and ornodes are considered
*		   leaf nodes for purposes of expression normalization.
*		   in other words, we won't do any normalization under
*		   those nodes.
*
* in addition, we track whether or not we are under a top level andnode.
* subquerynodes need to know this for subquery flattening.
*
* @param	undertopandnode		whether or not we are under a top level andnode.
*
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode changetocnf boolean undertopandnode
throws standardexception
return this
/**
* verify that changetocnf() did its job correctly.  verify that:
*		o  andnode  - rightoperand is not instanceof ornode
*				      leftoperand is not instanceof andnode
*		o  ornode	- rightoperand is not instanceof andnode
*					  leftoperand is not instanceof ornode
*
* @return		boolean which reflects validity of the tree.
*/
public boolean verifychangetocnf
return true
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode.
*
* @exception standardexception			thrown on error
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
throws standardexception
return true
/**
* this returns the user-supplied schema name of the column.
* at this class level, it simply returns null. but, the subclasses
* of valuenode will overwrite this method to return the
* user-supplied schema name.
*
* when the value node is in a result column of a select list,
* the user can request metadata information. the result column
* won't have a column descriptor, so we return some default
* information through the expression. this lets expressions that
* are simply columns return all of the info, and others use
* this supertype's default values.
*
* @return the default schema name for an expression -- null
*/
public string getschemaname   throws standardexception
return null
/**
* this returns the user-supplied table name of the column.
* at this class level, it simply returns null. but, the subclasses
* of valuenode will overwrite this method to return the
* user-supplied table name.
*
* when the value node is in a result column of a select list,
* the user can request metadata information. the result column
* won't have a column descriptor, so we return some default
* information through the expression. this lets expressions that
* are simply columns return all of the info, and others use
* this supertype's default values.
*
* @return the default table name for an expression -- null
*/
public string gettablename
return null
/**
* @return the default updatability for an expression - false
*/
public boolean updatablebycursor
return false
/**
* this is null so that the caller will substitute in the resultset generated
* name as needed.
*
* @return the default column name for an expression -- null.
*/
public string getcolumnname
return null
/**
* get a bit map of table references in this expression
*
* @return	a bit map of table numbers referred to in this expression
*
* @exception standardexception			thrown on error
*/
jbitset gettablesreferenced
throws standardexception
referencedtablesvisitor rtv   new referencedtablesvisitor new jbitset 0
accept rtv
return rtv gettablemap
/**
* return whether or not this expression tree is cloneable.
*
* @return boolean	whether or not this expression tree is cloneable.
*/
public boolean iscloneable
return false
/**
* return a clone of this node.
*
* @return valuenode	a clone of this node.
*
* @exception standardexception			thrown on error
*/
public valuenode getclone   throws standardexception
if  sanitymanager debug
sanitymanager assert false
getclass   getname
return null
/**
* copy all of the "appropriate fields" for a shallow copy.
*
* @param oldvn		the valuenode to copy from.
*
*/
public void copyfields valuenode oldvn  throws standardexception
datatypeservices   oldvn gettypeservices
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @return valuenode			the remapped expression tree.
*
* @exception standardexception			thrown on error
*/
public valuenode remapcolumnreferencestoexpressions   throws standardexception
return this
/**
* return whether or not this expression tree represents a constant expression.
*
* @return	whether or not this expression tree represents a constant expression.
*/
public boolean isconstantexpression
return false
/**
* return whether or not this expression tree represents a constant value.
* in this case, "constant" means that it will always evaluate to the
* same thing, even if it includes columns.  a column is constant if it
* is compared to a constant expression.
*
* @return	true means this expression tree represents a constant value.
*/
public boolean constantexpression predicatelist whereclause
return false
/**
* bind time logic. raises an error if this valuenode, once compiled, returns
* unstable results and if we're in a context where unstable results are
* forbidden.
*
* called by children who may not appear in the where subclauses of add table clauses.
*
*	@param	fragmenttype	type of fragment as a string, for inclusion in error messages.
*	@param	fragmentbitmask	type of fragment as a bitmask of possible fragment types
*
* @exception standardexception		thrown on error
*/
public	void	checkreliability  string fragmenttype  int fragmentbitmask
throws standardexception
// if we're in a context that forbids unreliable fragments, raise an error
if     getcompilercontext   getreliability     fragmentbitmask      0
throwreliabilityexception  fragmenttype
/**
* bind time logic. raises an error if this valuenode, once compiled, returns
* unstable results and if we're in a context where unstable results are
* forbidden.
*
* called by children who may not appear in the where subclauses of add table clauses.
*
*	@param	fragmentbitmask	type of fragment as a bitmask of possible fragment types
*	@param	fragmenttype	type of fragment as a string, to be fetch for the error message.
*
* @exception standardexception		thrown on error
*/
public	void	checkreliability  int fragmentbitmask  string fragmenttype
throws standardexception
// if we're in a context that forbids unreliable fragments, raise an error
if     getcompilercontext   getreliability     fragmentbitmask      0
string fragmenttypetxt   messageservice gettextmessage  fragmenttype
throwreliabilityexception  fragmenttypetxt
/**
* common code for the 2 checkreliability functions.  always throws standardexception.
*
* @param fragmenttype type of fragment as a string, for inclusion in error messages.
* @exception standardexception        throws an error, always.
*/
private void throwreliabilityexception  string fragmenttype   throws standardexception
string sqlstate
/* error string somewhat dependent on operation due to different
* nodes being allowed for different operations.
*/
if  getcompilercontext   getreliability      compilercontext default_restriction
sqlstate   sqlstate lang_invalid_default_definition
else
sqlstate   sqlstate lang_unreliable_query_fragment
throw standardexception newexception sqlstate  fragmenttype
/**
* return the variant type for the underlying expression.
* the variant type can be:
*		variant				- variant within a scan
*							  (method calls and non-static field access)
*		scan_invariant		- invariant within a scan
*							  (column references from outer tables)
*		query_invariant		- invariant within the life of a query
*							  (constant expressions)
*
* @return	the variant type for the underlying expression.
* @exception standardexception		thrown on error
*/
protected int getorderablevarianttype   throws standardexception
// the default is variant
return qualifier variant
/**
* bind time logic. raises an error if this valuenode does not resolve to
*	a boolean value. this method is called by where clauses.
*
*	@return	bound coercion of this node to a builtin type as necessary
*
* @exception standardexception		thrown on error
*/
public	valuenode	checkisboolean
throws standardexception
valuenode	whereclause   this
/*
** is the datatype of the where clause boolean?
**
** note: this test is not necessary in sql92 entry level, because
** it is syntactically impossible to have a non-boolean where clause
** in that level of the standard.  but we intend to extend the
** language to allow boolean user functions in the where clause,
** so we need to test for the error condition.
*/
typeid wheretypeid   whereclause gettypeid
/* if the where clause is not a built-in type, then generate a bound
* conversion tree to a built-in type.
*/
if  wheretypeid usertype
whereclause   whereclause gensqljavasqltree
wheretypeid   whereclause gettypeid
if    wheretypeid equals typeid boolean_id
throw standardexception newexception sqlstate lang_non_boolean_where_clause
wheretypeid getsqltypename
return	whereclause
/**
* return an object representing the bind time value of this
* expression tree.  if the expression tree does not evaluate to
* a constant at bind time then we return null.
* this is useful for bind time resolution of vtis.
* resolve: what do we do for primitives?
*
* @return	an object representing the bind time value of this expression tree.
*			(null if not a bind time constant.)
*
* @exception standardexception		thrown on error
*/
object getconstantvalueasobject
throws standardexception
return null
/////////////////////////////////////////////////////////////////////////
//
//	the valuenode defers its generate() work to a method that works on
//	expressionclassbuilders rather than activationclassbuilders. this
//	is so that expression generation can be shared by the core compiler
//	and the replication filter compiler.
//
/////////////////////////////////////////////////////////////////////////
/**
* do the code generation for this node.  call the more general
* routine that generates expressions.
*
* @param acb	the activationclassbuilder for the class being built
* @param mb	the method the expression will go into
*
*
* @exception standardexception		thrown on error
*/
protected final	void generate activationclassbuilder acb
methodbuilder mb
throws standardexception
generateexpression  acb  mb
/**
* the only reason this routine exists is so that i don't have to change
* the protection on generateexpression() and rototill all of querytree.
*
* @param ecb	the expressionclassbuilder for the class being built
* @param mb	the method the expression will go into
*
*
* @exception standardexception		thrown on error
*/
public	void generatefilter expressionclassbuilder ecb
methodbuilder mb
throws standardexception
generateexpression  ecb  mb
/**
* the default selectivity for value nodes is 50%.  this is overridden
* in specific cases, such as the relationaloperators.
*/
public double selectivity optimizable opttable
throws standardexception
// return 1 if additional predicates have been generated from this one.
if  transformed
return 1 0
else
return 0 5d
/**
* update the array of columns in = conditions with expressions without
* column references from the same table.  this is useful when doing
* subquery flattening on the basis of an equality condition.
* eqoutercols or tablecolmap may be null if the calling routine
* doesn't need the information provided
*
* @param tablenumber	the tablenumber of the table from which
*						the columns of interest come from.
* @param eqoutercols	array of booleans for noting which columns
*						are in = predicates without columns from the
*						subquery block. may be null.
* @param tablenumbers	array of table numbers in this query block.
* @param tablecolmap	array of bits for noting which columns
*						are in = predicates for each table in the
*						query block. may be null.
* @param resultcoltable true if tablenumber is the table containing result
* 						columns
*
* @exception standardexception			thrown on error
*
*/
void checktoppredicatesforequalsconditions
int tablenumber  boolean eqoutercols  int tablenumbers
jbitset tablecolmap  boolean resultcoltable
throws standardexception
for  valuenode wherewalker   this  wherewalker instanceof andnode
wherewalker     andnode  wherewalker  getrightoperand
// see if this is a candidate =
andnode and    andnode  wherewalker
if   and getleftoperand   isrelationaloperator
relationaloperator  and getleftoperand     getoperator      relationaloperator equals_relop
continue
binaryrelationaloperatornode beon
binaryrelationaloperatornode  and getleftoperand
valuenode left   beon getleftoperand
valuenode right   beon getrightoperand
int resulttable   0
if  resultcoltable
for     resulttable < tablenumbers length  resulttable
if  tablenumbers    tablenumber
break
else
resulttable    1
/* is this = of the right form? */
if   left instanceof columnreference
columnreference  left  gettablenumber      tablenumber
updatemaps tablecolmap  eqoutercols  tablenumbers  tablenumber
resulttable  right  left
else if   right instanceof columnreference
columnreference  right  gettablenumber      tablenumber
updatemaps tablecolmap  eqoutercols  tablenumbers  tablenumber
resulttable  left  right
/**
* does this represent a true constant.
*
* @return whether or not this node represents a true constant.
*/
boolean isbooleantrue
return false
/**
* does this represent a false constant.
*
* @return whether or not this node represents a false constant.
*/
boolean isbooleanfalse
return false
/**
* generate code for this calculation.  this is a place-holder method -
* it should not be called.
*
* @param acb	the expressionclassbuilder for the class being built
* @param mb	the method the expression will go into
*
*
* @exception standardexception		thrown on error
*/
public void generateexpression expressionclassbuilder acb
methodbuilder mb
throws standardexception
if  sanitymanager debug
sanitymanager assert false
/**
* set the correct bits in tablecolmap and set the boolean value in eqoutercols
* given two arguments to an = predicate
* tablecolmap[t] - bit is set if the column is in an = predicate with a column
*					in table t, or a bit is set if the column is in an
*					= predicate with a constant,parameter or correlation variable
*				    (for all table t, if this tablecolmap is not for the
*					table with the result columns)
* eqoutercols[c] - is true if the column is in an = predicate with a constant,
*					parameter or correlation variable
*
*
* @param tablecolmap	array of bitmaps for noting which columns are in =
*						predicates with columns from each table
* @param eqoutercols	array of booleans for noting which columns
*						are in = predicates without columns from the
*						subquery block.
* @param tablenumber	table number for which we are setting up the maps
* @param resulttable	-1 if this table is not the result table; otherwise
*						the index into tablenumbers for the result table
* @param arg1			one side of the = predicate
* @param arg2			other side of the = predicate
*
*
* @exception standardexception		thrown on error
*/
private void updatemaps jbitset tablecolmap  boolean eqoutercols
int tablenumbers   int tablenumber  int resulttable
valuenode arg1  valuenode arg2
throws standardexception
/* arg2 is a column from our table.  this
* is a good = for both all tables and outer arrays
* if the right side is a constant or a parameter
* or a column from an outer table.
* it is a good = for only the all array if
* the right side is a column from this query block.
*/
if   arg1 instanceof constantnode      arg1 requirestypefromcontext
setvaluecols tablecolmap  eqoutercols
columnreference  arg2  getcolumnnumber    resulttable
else if  arg1 instanceof columnreference
columnreference  arg1  gettablenumber      tablenumber
/* see if other columns is a correlation column */
int othertn     columnreference  arg1  gettablenumber
int index   0
int colnumber  	  columnreference  arg2  getcolumnnumber
for     index < tablenumbers length  index
if  othertn    tablenumbers
break
/* correlation column, so we can treat it as a constant */
if  index    tablenumbers length
setvaluecols tablecolmap  eqoutercols  colnumber  resulttable
else if  tablecolmap    null
tablecolmap set colnumber
else
/* see if other side contains a column reference from the same table */
jbitset referencedtables   arg1 gettablesreferenced
/* see if other columns are all correlation columns */
int index   0
int colnumber  	  columnreference  arg2  getcolumnnumber
for     index < tablenumbers length  index
if  referencedtables get tablenumbers
break
/* correlation column, so we can treat it as a constant */
if  index    tablenumbers length
setvaluecols tablecolmap  eqoutercols  colnumber  resulttable
else if  tablecolmap    null     referencedtables get tablenumber
tablecolmap set colnumber
/**
* set eqoutercols and the column in all the tables for constants,
* parmeters and correlation columns
* the column in the tablecolmap is set only for the current table
* if the table is the result column table.  for other tables in the
* query we set the column for all the tables since the constant will
* reduced the number of columns required in a unique multicolumn index for
* distinctness.
* for example, given an unique index on t1(a,b), setting b=1 means that
* t1(a) is unique since there can be no duplicates for a where b=1 without
* destroying the uniqueness of t1(a,b).  however, for the result columns
* setting b=1, does not mean that a select list of t1.a is distinct if
* t1.a is the only column used in joining with another table
* e.g. select t1.a from t1, t2 where t1.a = t2.a and t1.b = 1;
*
* 	t1			t2			result
*	a	b		a			a
*  1	1		1			1
*  1 	2		2			1
*	2	1
*
*
* @param tablecolmap	array of bitmaps for noting which columns are in =
*						predicates with columns from each table
* @param eqoutercols	array of booleans for noting which columns
*						are in = predicates without columns from the
*						subquery block.
* @param colreference	the column to set
* @param resulttable	if -1 set all the bit for all the tables for that
*						column; otherwise set the bit for the specified table
*
*
*/
private void setvaluecols jbitset tablecolmap  boolean eqoutercols
int colreference  int resulttable
if  eqoutercols    null
eqoutercols   true
if  tablecolmap    null
if  resulttable     1
for  int i   0  i < tablecolmap length  i
tablecolmap set colreference
else
tablecolmap set colreference
/**
* returns true if this valuenode is a relational operator. relational
* operators are <, <=, =, >, >=, <> as well as is null and is not
* null. this is the preferred way of figuring out if a valuenode is
* relational or not.
* @see relationaloperator
* @see binaryrelationaloperatornode
* @see isnullnode
*/
public boolean isrelationaloperator
return false
/**
* returns true if this value node is a <em>equals</em> operator.
*
* @see valuenode#isrelationaloperator
*/
public boolean isbinaryequalsoperatornode
return false
/**
* returns true if this value node is an operator created
* for optimized performance of an in list.
*
* or more specifically, returns true if this value node is
* an equals operator of the form "col = ?" that we generated
* during preprocessing to allow index multi-probing.
*/
public boolean isinlistprobenode
return false
/** return true if the predicate represents an optimizable equality node.
* an expression is considered to be an optimizable equality node if all the
* following conditions are met:
* <ol>
* <li> the operator is an <em>=</em> or <em>is null</em> operator </li>
* <li> one of the operands is a column specified by opttable/columnnumber</li>
* <li> both operands are not the same column; i.e tab.col = tab.col </li>
* <li> there are no implicit varchar comparisons of the operands; i.e
* either both operands are string like (varchar, char, longvarchar) or
* neither operand is string like </li>
* </ol>
*
* @param opttable	the table being optimized. column reference must be from
* this table.
* @param columnnumber the column number. one of the operands of this
* predicate must be the column number specified by opttable/columnnumber
* @param isnullokay if set to true we also consider is null predicates;
* otherwise consider only = predicates.
*/
public boolean optimizableequalitynode optimizable opttable
int columnnumber
boolean isnullokay
throws standardexception
return false
/**
* returns true if the type of this node will be determined from the
* context in which it is getting used. if true is returned then
* after bindexpression() is called on the node, its type
* must be set (from the relevant context) using settype().
*
* @return whether this node's type will be determined from the context
*/
public boolean requirestypefromcontext
return false
/**
* returns true if this is a parameter node. we do lots of special things
* with parameter nodes.
*
*/
public boolean isparameternode
return false
/**
* tests if this node is equivalent to the specified valuenode. two
* valuenodes are considered equivalent if they will evaluate to the same
* value during query execution.
* <p>
* this method provides basic expression matching facility for the derived
* class of valuenode and it is used by the language layer to compare the
* node structural form of the two expressions for equivalence at bind
* phase.
*  <p>
* note that it is not comparing the actual row values at runtime to produce
* a result; hence, when comparing sql nulls, they are considered to be
* equivalent and not unknown.
*  <p>
* one usage case of this method in this context is to compare the select
* column expression against the group by expression to check if they are
* equivalent.  e.g.:
*  <p>
* select c1+c2 from t1 group by c1+c2
*  <p>
* in general, node equivalence is determined by the derived class of
* valuenode.  but they generally abide to the rules below:
*  <ul>
* <li>the two valuenodes must be of the same node type to be considered
*   equivalent.  e.g.:  castnode vs. castnode - equivalent (if their args
*   also match), columnreference vs castnode - not equivalent.
*
* <li>if node p contains other valuenode(s) and so on, those node(s) must
*   also be of the same node type to be considered equivalent.
*
* <li>if node p takes a parameter list, then the number of arguments and its
*   arguments for the two nodes must also match to be considered
*   equivalent.  e.g.:  cast(c1 as integer) vs cast(c1 as smallint), they
*   are not equivalent.
*
* <li>when comparing sql nulls in this context, they are considered to be
*   equivalent.
*
* <li>if this does not apply or it is determined that the two nodes are not
*   equivalent then the derived class of this method should return false;
*   otherwise, return true.
* </ul>
*
* @param other the node to compare this valuenode against.
* @return <code>true</code> if the two nodes are equivalent,
* <code>false</code> otherwise.
*
* @throws standardexception
*/
protected abstract boolean isequivalent valuenode other
throws standardexception
/**
* tests if this node is of the same type as the specified node as
* reported by {@link querytreenode#getnodetype()}.
*
* @param other the node to compare this value node against.
*
* @return <code>true</code> if the two nodes are of the same type.
*/
protected final boolean issamenodetype valuenode other
if  other    null
return other getnodetype      getnodetype
return false