/*
derby - class org.apache.derby.impl.sql.compile.ornode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import java util vector
public class ornode extends binarylogicaloperatornode
/* is this the 1st or in the or chain? */
private boolean firstor
/**
* initializer for an ornode
*
* @param leftoperand	the left operand of the or
* @param rightoperand	the right operand of the or
*/
public void init object leftoperand  object rightoperand
super init leftoperand  rightoperand
this shortcircuitvalue   true
/**
* mark this ornode as the 1st or in the or chain.
* we will consider converting the chain to an in list
* during preprocess() if all entries are of the form:
*		columnreference = expression
*/
void setfirstor
firstor   true
/**
* bind this logical operator.  all that has to be done for binding
* a logical operator is to bind the operands, check that both operands
* are booleandatavalue, and set the result type to booleandatavalue.
*
* @param fromlist			the query's from list
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression
fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
super bindexpression fromlist  subquerylist  aggregatevector
postbindfixup
return this
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
super preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
/* if this is the first or in the or chain then we will
* consider converting it to an in list and then performing
* whatever in list conversions/optimizations are available.
* an or can be converted to an in list if all of the entries
* in the chain are of the form:
*		columnreference = x
*	or:
*		x = columnreference
* where all columnreferences are from the same table.
*/
if  firstor
boolean			convert   true
columnreference	cr   null
int				columnnumber    1
int				tablenumber    1
for  valuenode vn   this  vn instanceof ornode  vn     ornode  vn  getrightoperand
ornode on    ornode  vn
valuenode left   on getleftoperand
// is the operator an =
if   left isrelationaloperator
/* if the operator is an in-list disguised as a relational
* operator then we can still convert it--we'll just
* combine the existing in-list ("left") with the new in-
* list values.  so check for that case now.
*/
if  sanitymanager debug
/* at the time of writing the only way a call to
* left.isrelationaloperator() would return false for
* a binaryrelationaloperatornode was if that node
* was for an in-list probe predicate.  that's why we
* we can get by with the simple "instanceof" check
* below.  but if we're running in sane mode, do a
* quick check to make sure that's still valid.
*/
binaryrelationaloperatornode bron   null
if  left instanceof binaryrelationaloperatornode
bron    binaryrelationaloperatornode left
if  bron getinlistop      null
sanitymanager throwassert
convert    left instanceof binaryrelationaloperatornode
if   convert
break
if      relationaloperator left  getoperator      relationaloperator equals_relop
convert   false
break
binaryrelationaloperatornode bron    binaryrelationaloperatornode left
if  bron getleftoperand   instanceof columnreference
cr    columnreference  bron getleftoperand
if  tablenumber     1
tablenumber   cr gettablenumber
columnnumber   cr getcolumnnumber
else if  tablenumber    cr gettablenumber
columnnumber    cr getcolumnnumber
convert   false
break
else if  bron getrightoperand   instanceof columnreference
cr    columnreference  bron getrightoperand
if  tablenumber     1
tablenumber   cr gettablenumber
columnnumber   cr getcolumnnumber
else if  tablenumber    cr gettablenumber
columnnumber    cr getcolumnnumber
convert   false
break
else
convert   false
break
/* so, can we convert the or chain? */
if  convert
valuenodelist vnl    valuenodelist  getnodefactory   getnode
c_nodetypes value_node_list
getcontextmanager
// build the in list
for  valuenode vn   this  vn instanceof ornode  vn     ornode  vn  getrightoperand
ornode on    ornode  vn
binaryrelationaloperatornode bron
binaryrelationaloperatornode  on getleftoperand
if  bron getinlistop      null
/* if we have an or between multiple in-lists on the same
* column then just combine them into a single in-list.
* ex.
*
*   select ... from t1 where i in (2, 3) or i in (7, 10)
*
* effectively becomes:
*
*   select ... from t1 where i in (2, 3, 7, 10).
*/
vnl destructiveappend
bron getinlistop   getrightoperandlist
else if  bron getleftoperand   instanceof columnreference
vnl addvaluenode bron getrightoperand
else
vnl addvaluenode bron getleftoperand
inlistoperatornode ilon
inlistoperatornode  getnodefactory   getnode
c_nodetypes in_list_operator_node
cr
vnl
getcontextmanager
// transfer the result type info to the in list
ilon settype gettypeservices
/* we return the result of preprocess() on the
* in list so that any compilation time transformations
* will be done.
*/
return ilon preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
return this
/**
* eliminate notnodes in the current query block.  we traverse the tree,
* inverting ands and ors and eliminating nots as we go.  we stop at
* comparisonoperators and boolean expressions.  we invert
* comparisonoperators and replace boolean expressions with
* boolean expression = false.
* note: since we do not recurse under comparisonoperators, there
* still could be notnodes left in the tree.
*
* @param	undernotnode		whether or not we are under a notnode.
*
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
valuenode eliminatenots boolean undernotnode
throws standardexception
leftoperand   leftoperand eliminatenots undernotnode
rightoperand   rightoperand eliminatenots undernotnode
if    undernotnode
return this
/* convert the ornode to an andnode */
andnode	andnode
andnode    andnode  getnodefactory   getnode
c_nodetypes and_node
leftoperand
rightoperand
getcontextmanager
andnode settype gettypeservices
return andnode
/**
* finish putting an expression into conjunctive normal
* form.  an expression tree in conjunctive normal form meets
* the following criteria:
*		o  if the expression tree is not null,
*		   the top level will be a chain of andnodes terminating
*		   in a true booleanconstantnode.
*		o  the left child of an andnode will never be an andnode.
*		o  any right-linked chain that includes an andnode will
*		   be entirely composed of andnodes terminated by a true booleanconstantnode.
*		o  the left child of an ornode will never be an ornode.
*		o  any right-linked chain that includes an ornode will
*		   be entirely composed of ornodes terminated by a false booleanconstantnode.
*		o  valuenodes other than andnodes and ornodes are considered
*		   leaf nodes for purposes of expression normalization.
*		   in other words, we won't do any normalization under
*		   those nodes.
*
* in addition, we track whether or not we are under a top level andnode.
* subquerynodes need to know this for subquery flattening.
*
* @param	undertopandnode		whether or not we are under a top level andnode.
*
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode changetocnf boolean undertopandnode
throws standardexception
ornode curor   this
/* if rightoperand is an andnode, then we must generate an
* ornode above it.
*/
if  rightoperand instanceof andnode
booleanconstantnode	falsenode
falsenode    booleanconstantnode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean false
getcontextmanager
rightoperand    valuenode  getnodefactory   getnode
c_nodetypes or_node
rightoperand
falsenode
getcontextmanager
ornode  rightoperand  postbindfixup
/* we need to ensure that the right chain is terminated by
* a false booleanconstantnode.
*/
while  curor getrightoperand   instanceof ornode
curor    ornode  curor getrightoperand
/* add the false booleanconstantnode if not there yet */
if    curor getrightoperand   isbooleanfalse
booleanconstantnode	falsenode
falsenode    booleanconstantnode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean false
getcontextmanager
curor setrightoperand
valuenode  getnodefactory   getnode
c_nodetypes or_node
curor getrightoperand
falsenode
getcontextmanager
ornode  curor getrightoperand    postbindfixup
/* if leftoperand is an ornode, then we modify the tree from:
*
*				this
*			   /	\
*			or2		nodex
*		   /	\		...
*		left2	right2
*
*	to:
*
*						this
*					   /	\
*	left2.changetocnf()		 or2
*							/	\
*		right2.changetocnf()	 nodex.changetocnf()
*
*	note: we could easily switch places between left2.changetocnf() and
*  right2.changetocnf().
*/
while  leftoperand instanceof ornode
valuenode newleft
ornode	  oldleft
ornode	  newright
valuenode oldright
/* for "clarity", we first get the new and old operands */
newleft     ornode  leftoperand  getleftoperand
oldleft    ornode  leftoperand
newright    ornode  leftoperand
oldright   rightoperand
/* we then twiddle the tree to match the above diagram */
leftoperand   newleft
rightoperand   newright
newright setleftoperand oldleft getrightoperand
newright setrightoperand oldright
/* finally, we continue to normalize the left and right subtrees. */
leftoperand   leftoperand changetocnf false
rightoperand   rightoperand changetocnf false
return this
/**
* verify that changetocnf() did its job correctly.  verify that:
*		o  andnode  - rightoperand is not instanceof ornode
*				      leftoperand is not instanceof andnode
*		o  ornode	- rightoperand is not instanceof andnode
*					  leftoperand is not instanceof ornode
*
* @return		boolean which reflects validity of the tree.
*/
public boolean verifychangetocnf
boolean isvalid   true
if  sanitymanager assert
isvalid     rightoperand instanceof ornode
rightoperand isbooleanfalse
if  rightoperand instanceof ornode
isvalid   rightoperand verifychangetocnf
if  leftoperand instanceof ornode
isvalid   false
else
isvalid   leftoperand verifychangetocnf
return isvalid
/**
* do bind() by hand for an andnode that was generated after bind(),
* eg by putandsontop(). (set the data type and nullability info.)
*
* @exception standardexception		thrown on error
*/
void postbindfixup
throws standardexception
settype resolvelogicalbinaryoperator
leftoperand gettypeservices
rightoperand gettypeservices