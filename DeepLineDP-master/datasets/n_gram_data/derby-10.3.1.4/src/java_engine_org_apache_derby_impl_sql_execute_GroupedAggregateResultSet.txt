/*
derby - class org.apache.derby.impl.sql.execute.groupedaggregateresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import java util properties
import org apache derby iapi error standardexception
import org apache derby iapi services io formatablearrayholder
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql activation
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute noputresultset
import org apache derby iapi store access columnordering
import org apache derby iapi store access scancontroller
import org apache derby iapi store access sortcontroller
import org apache derby iapi store access sortobserver
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
/**
* this resultset evaluates grouped, non distinct aggregates.
* it will scan the entire source result set and calculate
* the grouped aggregates when scanning the source during the
* first call to next().
*
*/
class groupedaggregateresultset extends genericaggregateresultset
implements cursorresultset
/* run time statistics variables */
public int rowsinput
public int rowsreturned
// set in constructor and not altered during
// life of object.
private columnordering order
private execindexrow sorttemplaterow
public	boolean	hasdistinctaggregate 	   true if distinct aggregate
public	boolean isinsortedorder 				   true if source results in sorted order
private int maxrowsize
// set in open and not modified thereafter
private scancontroller scancontroller
// cache execindexrow
private execindexrow sourceexecindexrow
private execindexrow sortresultrow
// in order group bys
private execindexrow currsortedrow
private boolean nextcalled
// used to track and close sorts
private long distinctaggsortid
private boolean dropdistinctaggsort
private long genericsortid
private boolean dropgenericsort
private transactioncontroller tc
// rts
public properties sortproperties   new properties
/**
* constructor
*
* @param	s			input result set
* @param	isinsortedorder	true if the source results are in sorted order
* @param	aggregateitem	indicates the number of the
*		savedobject off of the preparedstatement that holds the
*		aggregatorinfolist used by this routine.
* @param	orderingitem	indicates the number of the
*		savedobject off of the preparedstatement that holds the
*		columordering array used by this routine
* @param	a				activation
* @param	ra				generated method to build an empty
*	 	output row
* @param	maxrowsize		approx row size, passed to sorter
* @param	resultsetnumber	the resultsetnumber for this result set
*
* @exception standardexception thrown on error
*/
groupedaggregateresultset noputresultset s
boolean isinsortedorder
int	aggregateitem
int	orderingitem
activation a
generatedmethod ra
int maxrowsize
int resultsetnumber
double optimizerestimatedrowcount
double optimizerestimatedcost  throws standardexception
super s  aggregateitem  a  ra  resultsetnumber  optimizerestimatedrowcount  optimizerestimatedcost
this isinsortedorder   isinsortedorder
sorttemplaterow   getexecutionfactory   getindexablerow  execrow  rowallocator invoke activation
order    columnordering
formatablearrayholder
a getpreparedstatement   getsavedobject orderingitem
getarray columnordering class
if  sanitymanager debug
sanitymanager debug
a getpreparedstatement   getsavedobject aggregateitem
constructortime    getelapsedmillis begintime
///////////////////////////////////////////////////////////////////////////////
//
// resultset interface (leftover from noputresultset)
//
///////////////////////////////////////////////////////////////////////////////
/**
* open the scan.  load the sorter and prepare to get
* rows from it.
*
* @exception standardexception thrown if cursor finished.
*/
public void	opencore   throws standardexception
begintime   getcurrenttimemillis
// revisit: through the direct db api, this needs to be an
// error, not an assert; users can open twice. only through jdbc
// is access to open controlled and ensured valid.
if  sanitymanager debug
sanitymanager assert    isopen
sortresultrow   getexecutionfactory   getindexablerow sorttemplaterow getclone
sourceexecindexrow   getexecutionfactory   getindexablerow sorttemplaterow getclone
source opencore
/* if this is an in-order group by then we do not need the sorter.
* (we can do the aggregation ourselves.)
* we save a clone of the first row so that subsequent next()s
* do not overwrite the saved row.
*/
if  isinsortedorder
currsortedrow   getnextrowfromrs
if  currsortedrow    null
currsortedrow    execindexrow  currsortedrow getclone
initializevectoraggregation currsortedrow
else
/*
** load up the sorter
*/
scancontroller   loadsorter
isopen   true
numopens
opentime    getelapsedmillis begintime
/**
* load up the sorter.  feed it every row from the
* source scan.  if we have a vector aggregate, initialize
* the aggregator for each source row.  when done, close
* the source scan and open the sort.  return the sort
* scan controller.
*
* @exception standardexception thrown on failure.
*
* @return	the sort controller
*/
private scancontroller loadsorter
throws standardexception
sortcontroller 			sorter
long 					sortid
execrow 				sourcerow
execrow 				inputrow
int						inputrowcountestimate    int  optimizerestimatedrowcount
boolean					inorder   isinsortedorder
tc   gettransactioncontroller
columnordering currentordering   order
/*
** do we have any distinct aggregates?  if so, we'll need
** a separate sort.  we use all of the sorting columns and
** drop the aggregation on the distinct column.  then
** we'll feed this into the sorter again w/o the distinct
** column in the ordering list.
*/
if  agginfolist hasdistinct
hasdistinctaggregate   true
genericaggregator aggsnodistinct   getsortaggregators agginfolist  true
activation getlanguageconnectioncontext    source
sortobserver sortobserver   new aggregatesortobserver true  aggsnodistinct  aggregates
sorttemplaterow
sortid   tc createsort  properties null
sorttemplaterow getrowarray
order
sortobserver
false 			   not in order
inputrowcountestimate 				   est rows   1 means no idea
maxrowsize		   est rowsize
sorter   tc opensort sortid
distinctaggsortid   sortid
dropdistinctaggsort   true
while   sourcerow   source getnextrowcore     null
sorter insert sourcerow getrowarray
rowsinput
/*
** end the sort and open up the result set
*/
source close
sortproperties   sorter getsortinfo   getallsortinfo sortproperties
sorter completedinserts
scancontroller
tc opensortscan sortid  activation getresultsetholdability
/*
** aggs are initialized and input rows
** are in order.  all we have to do is
** another sort to remove (merge) the
** duplicates in the distinct column
*/
inorder   true
inputrowcountestimate   rowsinput
/*
** drop the last column from the ordering.  the
** last column is the distinct column.  don't
** pay any attention to the fact that the ordering
** object's name happens to correspond to a techo
** band from the 80's.
**
** if there aren't any ordering columns other
** than the distinct (i.e. for scalar distincts)
** just skip the 2nd sort altogether -- we'll
** do the aggregate merge ourselves rather than
** force a 2nd sort.
*/
if  order length    1
return scancontroller
columnordering neworder   new columnordering
system arraycopy order  0  neworder  0  order length   1
currentordering   neworder
sortobserver sortobserver   new aggregatesortobserver true  aggregates  aggregates
sorttemplaterow
sortid   tc createsort  properties null
sorttemplaterow getrowarray
currentordering
sortobserver
inorder
inputrowcountestimate     est rows
maxrowsize			   est rowsize
sorter   tc opensort sortid
genericsortid   sortid
dropgenericsort   true
/* the sorter is responsible for doing the cloning */
while   inputrow   getnextrowfromrs       null
sorter insert inputrow getrowarray
source close
sortproperties   sorter getsortinfo   getallsortinfo sortproperties
sorter completedinserts
return tc opensortscan sortid  activation getresultsetholdability
/**
* return the next row.
*
* @exception standardexception thrown on failure.
* @exception standardexception resultsetnotopen thrown if not yet open.
*
* @return the next row in the result
*/
public execrow	getnextrowcore   throws standardexception
if   isopen
return null
begintime   getcurrenttimemillis
// in order group by
if  isinsortedorder
// no rows, no work to do
if  currsortedrow    null
nexttime    getelapsedmillis begintime
return null
execindexrow nextrow   getnextrowfromrs
/* drain and merge rows until we find new distinct values for the grouping columns. */
while  nextrow    null
/* we found a new set of values for the grouping columns.
* update the current row and return this group.
*/
if    samegroupingvalues currsortedrow  nextrow
execindexrow result   currsortedrow
/* save a clone of the new row so that it doesn't get overwritten */
currsortedrow    execindexrow  nextrow getclone
initializevectoraggregation currsortedrow
nexttime    getelapsedmillis begintime
rowsreturned
return finishaggregation result
else
/* same group - initialize the new row and then merge the aggregates */
initializevectoraggregation nextrow
mergevectoraggregates nextrow  currsortedrow
// get the next row
nextrow   getnextrowfromrs
// we've drained the source, so no more rows to return
execindexrow result   currsortedrow
currsortedrow   null
nexttime    getelapsedmillis begintime
return finishaggregation result
else
execindexrow sortresult   null
if   sortresult   getnextrowfromrs       null
setcurrentrow sortresult
/*
** only finish the aggregation
** if we have a return row.  we don't generate
** a row on a vector aggregate unless there was
** a group.
*/
if  sortresult    null
sortresult   finishaggregation sortresult
currentrow   sortresult
if  sortresult    null
rowsreturned
nexttime    getelapsedmillis begintime
return sortresult
/**
* return whether or not the new row has the same values for the
* grouping columns as the current row.  (this allows us to process in-order
* group bys without a sorter.)
*
* @param currrow	the current row.
* @param newrow	the new row.
*
* @return	whether or not to filter out the new row has the same values for the
*			grouping columns as the current row.
*
* @exception standardexception thrown on failure to get row location
*/
private boolean samegroupingvalues execrow currrow  execrow newrow
throws standardexception
for  int index   0  index < order length  index
datavaluedescriptor currorderable   currrow getcolumn order getcolumnid     1
datavaluedescriptor neworderable   newrow getcolumn order getcolumnid     1
if     currorderable compare datavaluedescriptor order_op_equals  neworderable  true  true
return false
return true
/**
* if the result set has been opened,
* close the open scan.
*
* @exception standardexception thrown on error
*/
public void	close   throws standardexception
begintime   getcurrenttimemillis
if   isopen
// we don't want to keep around a pointer to the
// row ... so it can be thrown away.
// revisit: does this need to be in a finally
// block, to ensure that it is executed?
clearcurrentrow
sortresultrow   null
sourceexecindexrow   null
closesource
if  dropdistinctaggsort
tc dropsort distinctaggsortid
dropdistinctaggsort   false
if  dropgenericsort
tc dropsort genericsortid
dropgenericsort   false
super close
else
if  sanitymanager debug
sanitymanager debug
closetime    getelapsedmillis begintime
isopen   false
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
long tottime   constructortime   opentime   nexttime
closetime
if  type    noputresultset current_resultset_only
return	tottime   originalsource gettimespent entire_resultset_tree
else
return tottime
///////////////////////////////////////////////////////////////////////////////
//
// cursorresultset interface
//
///////////////////////////////////////////////////////////////////////////////
/**
* this result set has its row location from
* the last fetch done. if the cursor is closed,
* a null is returned.
*
* @see cursorresultset
*
* @return the row location of the current cursor row.
* @exception standardexception thrown on failure to get row location
*/
public rowlocation getrowlocation   throws standardexception
if    isopen  return null
// revisit: could we reuse the same rowlocation object
// across several calls?
rowlocation rl
rl   scancontroller newrowlocationtemplate
scancontroller fetchlocation rl
return rl
/**
* this result set has its row from the last fetch done.
* if the cursor is closed, a null is returned.
*
* @see cursorresultset
*
* @return the last row returned;
* @exception standardexception thrown on failure.
*/
/* resolve - this should return activation.getcurrentrow(resultsetnumber),
* once there is such a method.  (currentrow is redundant)
*/
public execrow getcurrentrow   throws standardexception
if  sanitymanager debug
sanitymanager assert isopen
return currentrow
///////////////////////////////////////////////////////////////////////////////
//
// scan abstraction utilities
//
///////////////////////////////////////////////////////////////////////////////
/**
* get the next output row for processing
*/
private execindexrow getnextrowfromrs
throws standardexception
return  scancontroller    null  ?
getrowfromresultset
getrowfromsorter
/**
* get a row from the input result set.
*/
private execindexrow getrowfromresultset
throws standardexception
execrow					sourcerow
execindexrow			inputrow   null
if   sourcerow   source getnextrowcore       null
rowsinput
sourceexecindexrow execrowtoexecindexrow sourcerow
inputrow   sourceexecindexrow
return inputrow
/**
* get a row from the sorter.  side effects:
* sets currentrow.
*/
private execindexrow getrowfromsorter
throws standardexception
execindexrow			inputrow   null
if  scancontroller next
// remind: hackalert we are assuming that result will
// point to what sortresult is manipulating when
// we complete the fetch.
currentrow   sortresultrow
inputrow   getexecutionfactory   getindexablerow currentrow
scancontroller fetch inputrow getrowarray
return inputrow
/**
* close the source of whatever we have been scanning.
*
* @exception standardexception thrown on error
*/
public void	closesource   throws standardexception
if  scancontroller    null
/*
** note: do not null out source, we
** may be opened again, in which case
** we will open source again.
*/
source close
else
scancontroller close
scancontroller   null
///////////////////////////////////////////////////////////////////////////////
//
// aggregation utilities
//
///////////////////////////////////////////////////////////////////////////////
/**
* run the aggregator initialization method for
* each aggregator in the row.  accumulate the
* input column.  warning: initializiation performs
* accumulation -- no need to accumulate a row
* that has been passed to initialization.
*
* @param	row	the row to initialize
*
* @exception	standard derby exception
*/
private void initializevectoraggregation execrow row
throws standardexception
int size   aggregates length
if  sanitymanager debug
sanitymanager assert row    null
for  int i   0  i < size  i
genericaggregator curraggregate   aggregates
// initialize the aggregator
curraggregate initialize row
// get the first value, accumulate it into itself
curraggregate accumulate row  row
/**
* run the aggregator merge method for
* each aggregator in the row.
*
* @param	newrow	the row to merge
* @param	currrow the row to merge into
*
* @exception	standard derby exception
*/
private void mergevectoraggregates execrow newrow  execrow currrow
throws standardexception
for  int i   0  i < aggregates length  i
genericaggregator curraggregate   aggregates
// merge the aggregator
curraggregate merge newrow  currrow