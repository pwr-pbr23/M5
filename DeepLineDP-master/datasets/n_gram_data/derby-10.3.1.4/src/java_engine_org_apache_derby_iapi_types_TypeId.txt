/*
derby - class org.apache.derby.iapi.types.typeid
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi types
import org apache derby iapi services io formatable
import org apache derby iapi services io storedformatids
import org apache derby iapi services monitor monitor
import org apache derby iapi services loader classfactory
import org apache derby iapi error standardexception
import org apache derby catalog types basetypeidimpl
import org apache derby catalog types decimaltypeidimpl
import org apache derby catalog types userdefinedtypeidimpl
import org apache derby iapi reference limits
import java io objectoutput
import java io objectinput
import java io ioexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi types
import org apache derby iapi types
import org apache derby iapi reference jdbc20translation
import org apache derby iapi reference jdbc30translation
import java sql types
/**
* the typeid interface provides methods to get information about datatype ids.
<p>
* the equals(object) method can be used to determine if two typeids are for the same type,
* which defines type id equality.
*
*/
public final class typeid implements formatable
/**
* various fixed numbers related to datatypes.
*/
public static final int longint_precision                         19
public static final int longint_scale                             0
public static final int longint_maxwidth                          8
public static final int int_precision                     10
public static final int int_scale                                 0
public static final int int_maxwidth                      4
public static final int smallint_precision                        5
public static final int smallint_scale                            0
public static final int smallint_maxwidth                         2
public static final int tinyint_precision                         3
public static final int tinyint_scale                             0
public static final int tinyint_maxwidth                          1
// precision in number of bits
public static final int double_precision                          52
// the resultsetmetadata needs to have the precision for numeric data
// in decimal digits, rather than number of bits, so need a separate constant.
public static final int double_precision_in_digits                15
public static final int double_scale                              0
public static final int double_maxwidth                           8
// precision in number of bits
public static final int real_precision                    23
// the resultsetmetadata needs to have the precision for numeric data
// in decimal digits, rather than number of bits, so need a separate constant.
public static final int real_precision_in_digits          7
public static final int real_scale                                0
public static final int real_maxwidth                     4
public static final int decimal_precision                         limits db2_max_decimal_precision_scale
public static final int decimal_scale                             limits db2_max_decimal_precision_scale
public static final int decimal_maxwidth                          limits db2_max_decimal_precision_scale
public static final int boolean_maxwidth                          1
public static final int char_maxwidth             limits db2_char_maxwidth
public static final int varchar_maxwidth          limits db2_varchar_maxwidth
public static final int longvarchar_maxwidth   limits db2_longvarchar_maxwidth
public static final int national_char_maxwidth    integer max_value
public static final int national_varchar_maxwidth         integer max_value
public static final int national_longvarchar_maxwidth   limits db2_longvarchar_maxwidth
public static final int bit_maxwidth              limits db2_char_maxwidth
public static final int varbit_maxwidth           limits db2_varchar_maxwidth
public static final int longvarbit_maxwidth   limits db2_longvarchar_maxwidth
// not supposed to be limited! 4096g should be ok(?), if derby can handle...
public static final int blob_maxwidth   integer max_value     to change long
public static final int clob_maxwidth   integer max_value     to change long
public static final int nclob_maxwidth   integer max_value     to change long
public static final int xml_maxwidth   integer max_value
// max width for datetime values is the length of the
// string returned from a call to "tostring()" on the
// java.sql.date, java.sql.time, and java.sql.timestamp
// classes (the result of tostring() on those classes
// is defined by the jdbc api).  this value is also
// used as the "precision" for those types.
public static final int date_maxwidth             10 	   yyyy mm dd
public static final int time_maxwidth             8 	   hh mm ss
public static final int timestamp_maxwidth        26 	   yyyy mm dd hh mm ss ffffff
// scale does exist for time values.  for a timestamp value,
// it's 6 ('ffffff'); for a time value, it's 0 (because there
// are no fractional seconds).  note that date values do
// not have a scale.
public static final int time_scale             0
public static final int timestamp_scale        6
/* these define all the type names for sql92 and jdbc
* note: boolean is sql3
*/
//public static final string      bit_name = "bit";
//public static final string      varbit_name = "bit varying";
//public static final string      longvarbit_name = "long bit varying";
public static final string      bit_name
public static final string      varbit_name
public static final string      longvarbit_name
public static final string      tinyint_name
public static final string      smallint_name
public static final string      integer_name
public static final string      longint_name
public static final string      float_name
public static final string      real_name
public static final string      double_name
public static final string      numeric_name
public static final string      decimal_name
public static final string      char_name
public static final string      varchar_name
public static final string      longvarchar_name
public static final string      date_name
public static final string      time_name
public static final string      timestamp_name
public static final string      binary_name
public static final string      varbinary_name
public static final string      longvarbinary_name
public static final string      boolean_name
public static final string      ref_name
public static final string      national_char_name
public static final string      national_varchar_name
public static final string      national_longvarchar_name
public static final string      blob_name
public static final string      clob_name
public static final string      nclob_name
// following use of "xml" is per sql/xml (2003) spec,
// section "10.2 type name determination".
public static final string      xml_name
// array and struct are jdbc 2.0 data types that are not
// supported by derby.
public static final string      array_name
public static final string      struct_name
// datalink is a jdbc 3.0 data type. not supported by derby.
public static final string      datalink_name
// rowid and sqlxml are new types in jdbc 4.0. not supported
// by derby.
public static final string      rowid_name
public static final string      sqlxml_name
/**
* the following constants define the type precedence hierarchy.
*/
public static final int user_precedence    1000
public static final int xml_precedence         180
public static final int blob_precedence   170
public static final int longvarbit_precedence   160
public static final int varbit_precedence          150
public static final int bit_precedence             140
public static final int boolean_precedence         130
public static final int time_precedence    120
public static final int timestamp_precedence   110
public static final int date_precedence    100
public static final int double_precedence          90
public static final int real_precedence    80
public static final int decimal_precedence         70
public static final int numeric_precedence         69
public static final int longint_precedence         60
public static final int int_precedence             50
public static final int smallint_precedence   40
public static final int tinyint_precedence         30
public static final int ref_precedence             25
public static final int national_longvarchar_precedence   18
public static final int national_varchar_precedence    17
public static final int national_char_precedence           16
public static final int clob_precedence   14
public static final int nclob_precedence   13
public static final int longvarchar_precedence   12
public static final int varchar_precedence    10
public static final int char_precedence    0
/*
** static runtime fields for typeids
** these are put here because the system needs them init time.
*/
public static final typeid              boolean_id   new typeid storedformatids boolean_type_id
new basetypeidimpl storedformatids boolean_type_id_impl
public static final typeid              integer_id   new typeid storedformatids int_type_id
new basetypeidimpl storedformatids int_type_id_impl
public static final typeid              char_id   new typeid storedformatids char_type_id
new basetypeidimpl storedformatids char_type_id_impl
/*
** others are created on demand by the getbuiltintypeid(int),
** if they are built-in (i.e.? part of jdbc .types),
** or by getbuiltintypeid(string) if they are national types or ref_name type.
*/
private static typeid                   tinyint_id
private static typeid                   smallint_id
private static typeid                   longint_id
private static typeid                   real_id
private static typeid                   double_id
private static typeid                   decimal_id
private static typeid                   numeric_id
private static typeid                   varchar_id
private static typeid                   national_char_id
private static typeid                   national_longvarchar_id
private static typeid                   national_varchar_id
private static typeid                   date_id
private static typeid                   time_id
private static typeid                   timestamp_id
private static typeid                   bit_id
private static typeid                   varbit_id
private static typeid                   ref_id
private static typeid                   longvarchar_id
private static typeid                   longvarbit_id
private static typeid                   blob_id
private static typeid                   clob_id
private static typeid                   nclob_id
private static typeid                   xml_id
/**
* implementation of decimal datatype for generating holders through getnull.
* set by the booted datavaluefactory implementation.
*/
static datavaluedescriptor		decimalimplementation
/*
** static methods to obtain typeids
*/
/**
* get a typeid of the given jdbc type.  this factory method is
* intended to be used for built-in types.  for user-defined types,
* we will need a factory method that takes a java type name.
*
* @param jdbctypeid    the jdbc id of the type, as listed in
*                      java.sql.types
*
* @return      the appropriate typeid, or null if there is no such
*                      typeid.
*/
public static typeid getbuiltintypeid int jdbctypeid
typeid ret   null
switch  jdbctypeid
case types tinyint
ret   tinyint_id
if  ret    null
ret   tinyint_id   new typeid storedformatids tinyint_type_id
new basetypeidimpl storedformatids tinyint_type_id_impl
break
case types smallint
ret   smallint_id
if  ret    null
ret   smallint_id   new typeid storedformatids smallint_type_id
new basetypeidimpl storedformatids smallint_type_id_impl
break
case types integer
return integer_id
case types bigint
ret   longint_id
if  ret    null
ret   longint_id   new typeid storedformatids longint_type_id
new basetypeidimpl storedformatids longint_type_id_impl
break
case types real
ret   real_id
if  ret    null
ret   real_id   new typeid storedformatids real_type_id
new basetypeidimpl storedformatids real_type_id_impl
break
case types float
case types double
ret   double_id
if  ret    null
ret   double_id   new typeid storedformatids double_type_id
new basetypeidimpl storedformatids double_type_id_impl
break
case types decimal
ret   decimal_id
if  ret    null
ret   decimal_id   new typeid storedformatids decimal_type_id
new decimaltypeidimpl
break
case types numeric
ret   numeric_id
if  ret    null
decimaltypeidimpl numerictypeidimpl   new decimaltypeidimpl
numerictypeidimpl setnumerictype
ret   numeric_id   new typeid storedformatids decimal_type_id  numerictypeidimpl
break
case types char
return char_id
case types varchar
ret   varchar_id
if  ret    null
ret   varchar_id   new typeid storedformatids varchar_type_id
new basetypeidimpl storedformatids varchar_type_id_impl
break
case types date
ret   date_id
if  ret    null
ret   date_id   new typeid storedformatids date_type_id
new basetypeidimpl storedformatids date_type_id_impl
break
case types time
ret   time_id
if  ret    null
ret   time_id   new typeid storedformatids time_type_id
new basetypeidimpl storedformatids time_type_id_impl
break
case types timestamp
ret   timestamp_id
if  ret    null
ret   timestamp_id   new typeid storedformatids timestamp_type_id
new basetypeidimpl storedformatids timestamp_type_id_impl
break
case types bit
case jdbc30translation sql_types_boolean
return boolean_id
case types binary
ret   bit_id
if  ret    null
ret   bit_id   new typeid storedformatids bit_type_id
new basetypeidimpl storedformatids bit_type_id_impl
break
case types varbinary
ret   varbit_id
if  ret    null
ret   varbit_id   new typeid storedformatids varbit_type_id
new basetypeidimpl storedformatids varbit_type_id_impl
break
case types longvarbinary
ret   longvarbit_id
if  ret    null
ret   longvarbit_id   new typeid storedformatids longvarbit_type_id
new basetypeidimpl storedformatids longvarbit_type_id_impl
break
case types longvarchar
ret   longvarchar_id
if  ret    null
ret   longvarchar_id   new typeid storedformatids longvarchar_type_id
new basetypeidimpl storedformatids longvarchar_type_id_impl
break
case jdbc20translation sql_types_blob
ret   blob_id
if  ret    null
ret   blob_id   new typeid storedformatids blob_type_id
new basetypeidimpl storedformatids blob_type_id_impl
break
case jdbc20translation sql_types_clob
ret   clob_id
if  ret    null
ret   clob_id   new typeid storedformatids clob_type_id
new basetypeidimpl storedformatids clob_type_id_impl
break
// xml is not a jdbc type, so we have to check for our
// internal xml type.
case storedformatids xml_type_id
ret   xml_id
if  ret    null
ret   xml_id   new typeid storedformatids xml_type_id
new basetypeidimpl storedformatids xml_type_id_impl
break
return ret
public static typeid getuserdefinedtypeid string classname  boolean delimitedidentifier
return new typeid storedformatids userdefined_type_id_v3
new userdefinedtypeidimpl classname   delimitedidentifier
/**
* get a typeid for the class that corresponds to the given
* java type name.
*
* @param javatypename          the name of the java type
*
* @return      a typeid for the sql type that corresponds to
*                      the java type, null if there is no corresponding type.
*/
public static typeid getsqltypeforjavatype string javatypename
if  javatypename equals
javatypename equals
return typeid boolean_id
else if  javatypename equals
return getbuiltintypeid types varbinary
else if  javatypename equals
return getbuiltintypeid types varchar
else if  javatypename equals
javatypename equals
return typeid integer_id
else if  javatypename equals
return getbuiltintypeid types tinyint
else if  javatypename equals
return getbuiltintypeid types smallint
else if  javatypename equals
javatypename equals
return getbuiltintypeid types bigint
else if  javatypename equals
javatypename equals
return getbuiltintypeid types real
else if  javatypename equals
javatypename equals
return getbuiltintypeid types double
else if  javatypename equals
return getbuiltintypeid types decimal
else if  javatypename equals
return getbuiltintypeid types date
else if  javatypename equals
return getbuiltintypeid types time
else if  javatypename equals
return getbuiltintypeid types timestamp
else if  javatypename equals
return getbuiltintypeid jdbc20translation sql_types_blob
else if  javatypename equals
return getbuiltintypeid jdbc20translation sql_types_clob
else if  javatypename equals
return getbuiltintypeid storedformatids xml_type_id
else
/*
** if it's a java primitive type, return null to indicate that
** there is no corresponding sql type (all the java primitive
** types that have corresponding sql types are handled above).
**
** there is only one primitive type not mentioned above, char.
*/
if  javatypename equals
return null
/*
** it's a non-primitive type (a class) that does not correspond
** to a sql built-in type, so treat it as a user-defined type.
*/
return typeid getuserdefinedtypeid javatypename  false
public static typeid getbuiltintypeid string sqltypename
if  sqltypename equals typeid boolean_name
return typeid boolean_id
if  sqltypename equals typeid char_name
return typeid char_id
if  sqltypename equals typeid date_name
return getbuiltintypeid types date
if  sqltypename equals typeid double_name
return getbuiltintypeid types double
if  sqltypename equals typeid float_name
return getbuiltintypeid types double
if  sqltypename equals typeid integer_name
return typeid integer_id
if  sqltypename equals typeid longint_name
return getbuiltintypeid types bigint
if  sqltypename equals typeid real_name
return getbuiltintypeid types real
if  sqltypename equals typeid smallint_name
return getbuiltintypeid types smallint
if  sqltypename equals typeid time_name
return getbuiltintypeid types time
if  sqltypename equals typeid timestamp_name
return getbuiltintypeid types timestamp
if  sqltypename equals typeid varchar_name
return getbuiltintypeid types varchar
if  sqltypename equals typeid bit_name
return getbuiltintypeid types binary
if  sqltypename equals typeid varbit_name
return getbuiltintypeid types varbinary
if  sqltypename equals typeid tinyint_name
return getbuiltintypeid types tinyint
if  sqltypename equals typeid decimal_name
return getbuiltintypeid types decimal
if  sqltypename equals typeid numeric_name
return getbuiltintypeid types numeric
if  sqltypename equals typeid longvarchar_name
return getbuiltintypeid types longvarchar
if  sqltypename equals typeid longvarbit_name
return getbuiltintypeid types longvarbinary
if  sqltypename equals typeid blob_name
return getbuiltintypeid jdbc20translation sql_types_blob
if  sqltypename equals typeid clob_name
return getbuiltintypeid jdbc20translation sql_types_clob
if  sqltypename equals typeid xml_name
return getbuiltintypeid storedformatids xml_type_id
typeid ret   null
// types defined below here are sql types and non-jdbc types that are supported by derby
if  sqltypename equals typeid nclob_name
ret   nclob_id
if  ret    null
ret   nclob_id   new typeid storedformatids nclob_type_id
new basetypeidimpl storedformatids nclob_type_id_impl
else if  sqltypename equals typeid national_char_name
ret   national_char_id
if  ret    null
ret   national_char_id   new typeid storedformatids national_char_type_id
new basetypeidimpl storedformatids national_char_type_id_impl
else if  sqltypename equals typeid national_longvarchar_name
ret   national_longvarchar_id
if  ret    null
ret   national_longvarchar_id   new typeid storedformatids national_longvarchar_type_id
new basetypeidimpl storedformatids national_longvarchar_type_id_impl
else if  sqltypename equals typeid national_varchar_name
ret   national_varchar_id
if  ret    null
ret   national_varchar_id   new typeid storedformatids national_varchar_type_id
new basetypeidimpl storedformatids national_varchar_type_id_impl
else if  sqltypename equals typeid ref_name
ret   ref_id
if  ret    null
ret   ref_id   new typeid storedformatids ref_type_id
new basetypeidimpl storedformatids ref_type_id_impl
return ret
/*
** instance fields and methods
*/
private basetypeidimpl  basetypeid
private int                             formatid
/* set in settypeidspecificinstancevariables() as needed */
private boolean                 classnamewasdelimitedidentifier
private boolean                 isbittypeid
private boolean                 islobtypeid
private boolean                 isbooleantypeid
private boolean                 isconcatabletypeid
private boolean                 isdecimaltypeid
private boolean                 islongconcatabletypeid
private boolean                 isnumerictypeid
private boolean                 isreftypeid
private boolean                 isstringtypeid
private boolean                 isfloatingpointtypeid
private boolean                 isrealtypeid
private boolean                 isdatetimetimestamptypeid
private boolean                 isuserdefinedtypeid
private int                             maxprecision
private int                             maxscale
private int                             typeprecedence
private string                  javatypename
private int                             maxmaxwidth
/**
* 1 argmument constructor. needed for formatable interface to work.
*
* @param formatid      format id of specific type id.
*/
public  typeid int formatid
this formatid   formatid
settypeidspecificinstancevariables
/**
* constructor for a typeid
*
* @param formatid      format id of specific type id.
* @param basetypeid    the base type id
*/
public typeid int formatid  basetypeidimpl basetypeid
this formatid   formatid
this basetypeid   basetypeid
settypeidspecificinstancevariables
/**
* constructor for a typeid for user defined types
*
* @param formatid                                                      format id of specific type id.
* @param basetypeid                                            the base type id
* @param classnamewasdelimitedidentifier       whether or not the class name
*                                                                                      was a delimited identifier
*/
public typeid int formatid  basetypeidimpl basetypeid
boolean classnamewasdelimitedidentifier
this formatid   formatid
this basetypeid   basetypeid
this classnamewasdelimitedidentifier   classnamewasdelimitedidentifier
settypeidspecificinstancevariables
/**
* we want equals to say if these are the same type id or not.
*/
public boolean equals object that
if  that instanceof typeid
return this getsqltypename   equals   typeid that  getsqltypename
else
return false
/*
hashcode which works with equals.
*/
public int hashcode
return this getsqltypename   hashcode
private void settypeidspecificinstancevariables
switch  formatid
case storedformatids bit_type_id
typeprecedence   bit_precedence
javatypename
maxmaxwidth   typeid bit_maxwidth
isbittypeid   true
isconcatabletypeid   true
break
case storedformatids boolean_type_id
typeprecedence   boolean_precedence
javatypename
maxmaxwidth   typeid boolean_maxwidth
isbooleantypeid   true
break
case storedformatids char_type_id
typeprecedence   char_precedence
javatypename
maxmaxwidth   typeid char_maxwidth
isstringtypeid   true
isconcatabletypeid   true
break
case storedformatids date_type_id
typeprecedence   date_precedence
javatypename
maxmaxwidth   typeid date_maxwidth
maxprecision   typeid date_maxwidth
isdatetimetimestamptypeid   true
break
case storedformatids decimal_type_id
maxprecision   typeid decimal_precision
maxscale   typeid decimal_scale
typeprecedence   decimal_precedence
javatypename
maxmaxwidth   typeid decimal_maxwidth
isdecimaltypeid   true
isnumerictypeid   true
break
case storedformatids double_type_id
maxprecision   typeid double_precision
maxscale   typeid double_scale
typeprecedence   double_precedence
javatypename
maxmaxwidth   typeid double_maxwidth
isnumerictypeid   true
isfloatingpointtypeid   true
break
case storedformatids int_type_id
maxprecision   typeid int_precision
maxscale   typeid int_scale
typeprecedence   int_precedence
javatypename
maxmaxwidth   typeid int_maxwidth
isnumerictypeid   true
break
case storedformatids longint_type_id
maxprecision   typeid longint_precision
maxscale   typeid longint_scale
typeprecedence   longint_precedence
javatypename
maxmaxwidth   typeid longint_maxwidth
isnumerictypeid   true
break
case storedformatids longvarbit_type_id
typeprecedence   longvarbit_precedence
javatypename
maxmaxwidth   typeid longvarbit_maxwidth
isbittypeid   true
isconcatabletypeid   true
islongconcatabletypeid   true
break
case storedformatids longvarchar_type_id
typeprecedence   longvarchar_precedence
javatypename
maxmaxwidth   typeid longvarchar_maxwidth
isstringtypeid   true
isconcatabletypeid   true
islongconcatabletypeid   true
break
case storedformatids national_char_type_id
typeprecedence   national_char_precedence
javatypename
maxmaxwidth   typeid national_char_maxwidth
isstringtypeid   true
isconcatabletypeid   true
break
case storedformatids national_longvarchar_type_id
typeprecedence   national_longvarchar_precedence
javatypename
maxmaxwidth   typeid national_longvarchar_maxwidth
isstringtypeid   true
isconcatabletypeid   true
islongconcatabletypeid   true
break
case storedformatids national_varchar_type_id
typeprecedence   national_varchar_precedence
javatypename
maxmaxwidth   typeid national_varchar_maxwidth
isstringtypeid   true
isconcatabletypeid   true
break
case storedformatids real_type_id
maxprecision   typeid real_precision
maxscale   typeid real_scale
typeprecedence   real_precedence
javatypename
maxmaxwidth   typeid real_maxwidth
isnumerictypeid   true
isrealtypeid   true
isfloatingpointtypeid   true
break
case storedformatids ref_type_id
typeprecedence   ref_precedence
isreftypeid   true
break
case storedformatids smallint_type_id
maxprecision   typeid smallint_precision
maxscale   typeid smallint_scale
typeprecedence   smallint_precedence
javatypename
maxmaxwidth   typeid smallint_maxwidth
isnumerictypeid   true
break
case storedformatids time_type_id
typeprecedence   time_precedence
javatypename
maxscale   typeid time_scale
maxmaxwidth   typeid time_maxwidth
maxprecision   typeid time_maxwidth
isdatetimetimestamptypeid   true
break
case storedformatids timestamp_type_id
typeprecedence   timestamp_precedence
javatypename
maxscale   typeid timestamp_scale
maxmaxwidth   typeid timestamp_maxwidth
maxprecision   typeid timestamp_maxwidth
isdatetimetimestamptypeid   true
break
case storedformatids tinyint_type_id
maxprecision   typeid tinyint_precision
maxscale   typeid tinyint_scale
typeprecedence   tinyint_precedence
javatypename
maxmaxwidth   typeid tinyint_maxwidth
isnumerictypeid   true
break
case storedformatids userdefined_type_id_v3
if  basetypeid    null
setusertypeidinfo
else
typeprecedence   user_precedence
maxmaxwidth    1
isuserdefinedtypeid   true
break
case storedformatids varbit_type_id
typeprecedence   varbit_precedence
javatypename
maxmaxwidth   typeid varbit_maxwidth
isbittypeid   true
isconcatabletypeid   true
break
case storedformatids blob_type_id
typeprecedence   blob_precedence
javatypename
maxmaxwidth   typeid blob_maxwidth
isbittypeid   true
isconcatabletypeid   true
islongconcatabletypeid   true     ??
islobtypeid   true
break
case storedformatids varchar_type_id
typeprecedence   varchar_precedence
javatypename
maxmaxwidth   typeid varchar_maxwidth
isstringtypeid   true
isconcatabletypeid   true
break
case storedformatids clob_type_id
typeprecedence   clob_precedence
javatypename
maxmaxwidth   typeid clob_maxwidth
isstringtypeid   true
isconcatabletypeid   true
islongconcatabletypeid   true     ??
islobtypeid   true
break
case storedformatids nclob_type_id
typeprecedence   nclob_precedence
javatypename
maxmaxwidth   typeid nclob_maxwidth
isstringtypeid   true
isconcatabletypeid   true
islongconcatabletypeid   true     ??
islobtypeid   true
break
case storedformatids xml_type_id
typeprecedence   xml_precedence
javatypename
maxmaxwidth   typeid xml_maxwidth
// we set this to true in order to disallow use
// of the xml datatype for procedure/function args.
islongconcatabletypeid   true
break
/**
* jdbc has its own idea of type identifiers which is different from
* the derby internal type ids.  the jdbc type ids are defined
* as public final static ints in java.sql.types.  this method translates
* a derby internal typeid to a jdbc type id. for java objects this
* returns java_object in java2 and other in jdk 1.1. for boolean datatypes,
* this returns type.boolean in jdk1.4 and type.bit for jdks prior to 1.4
*
* @return      the jdbc type id for this type
*/
public final int getjdbctypeid
return basetypeid getjdbctypeid
/**
* returns the sql name of the datatype. if it is a user-defined type,
* it returns the full java path name for the datatype, meaning the
* dot-separated path including the package names.
*
* @return      a string containing the sql name of this type.
*/
public string   getsqltypename
return basetypeid getsqltypename
/**
* tell whether this is a built-in type.
* note: there are 3 "classes" of types:
*                      built-in                - system provided types which are implemented internally
*                                                        (int, smallint, etc.)
*                      system built-in - system provided types, independent of implementation
*                                                        (date, time, etc.)
*                      user types              - types implemented outside of the system
*                                                        (java.lang.integer, asdf.asdf.asdf, etc.)
*
* @return      true for built-in types, false for user-defined types.
*/
public final boolean usertype
return basetypeid usertype
/**
* get the maximum precision of the type.  for types with variable
* precision, this is an arbitrary high precision.
*
* @return      the maximum precision of the type
*/
public int getmaximumprecision
return maxprecision
/**
* get the maximum scale of the type.  for types with variable scale,
* this is an arbitrary high scale.
*
* @return      the maximum scale of the type
*/
public int getmaximumscale
return maxscale
/**
* set the nested basetypeid in this typeid.
*/
public void setnestedtypeid basetypeidimpl typeid
basetypeid   typeid
switch  formatid
case storedformatids userdefined_type_id_v3
setusertypeidinfo
private void setusertypeidinfo
userdefinedtypeidimpl baseusertypeid
userdefinedtypeidimpl  basetypeid
typeprecedence   user_precedence
javatypename   baseusertypeid getclassname
/**
* for user types, tell whether or not the class name was a
* delimited identifier. for all other types, return false.
*
* @return whether or not the class name was a delimited identifier.
*/
public boolean getclassnamewasdelimitedidentifier
return classnamewasdelimitedidentifier
/**
* does this typeid represent a typeid for a stringdatatype.
*
* @return whether or not this typeid represents a typeid for a stringdatatype.
*/
public boolean isstringtypeid
return isstringtypeid
/**
* is this a typeid for date/time/timestamp
*
* @return true if this is a date/time/timestamp
*/
public boolean isdatetimetimestamptypeid
return isdatetimetimestamptypeid
/**
* is this a typeid for real
*
* @return true if this is a real
*/
public boolean isrealtypeid
return isrealtypeid
/**
* is this a typeid for floating point (real/double)
*
* @return true if this is a real or double
*/
public boolean isfloatingpointtypeid
return isfloatingpointtypeid
/**
* is this a typeid for double
*
* @return true if this is a double
*/
public boolean isdoubletypeid
return isfloatingpointtypeid       isrealtypeid
/**
* is this a fixed string type?
* @return true if this is char or nchar
*/
public boolean isfixedstringtypeid
return   formatid    storedformatids char_type_id
formatid    storedformatids national_char_type_id
/**
*is this a clob?
* @return true if this is clob or nclob
*/
public boolean isclobtypeid
return   formatid    storedformatids clob_type_id
formatid    storedformatids nclob_type_id
/**
*is this a blob?
* @return true if this is blob
*/
public boolean isblobtypeid
return   formatid    storedformatids blob_type_id
/**
*is this a longvarchar?
* @return true if this is longvarchar
*/
public boolean islongvarchartypeid
return   formatid    storedformatids longvarchar_type_id
formatid    storedformatids national_longvarchar_type_id
/**
* is this date/time or timestamp?
*
* @return true if this date/time or timestamp
*/
public boolean isdatetimetimestamptypeid
return   formatid    storedformatids date_type_id
formatid    storedformatids time_type_id
formatid    storedformatids timestamp_type_id
/**
does this type id represent a national character string.
if this returns true then isstringtypeid will also return true.
*/
public boolean isnationalstringtypeid
switch  formatid
default
return false
case storedformatids national_char_type_id
case storedformatids national_longvarchar_type_id
case storedformatids national_varchar_type_id
case storedformatids nclob_type_id
return true
/**
*is this an xml doc?
* @return true if this is xml
*/
public boolean isxmltypeid
return  formatid    storedformatids xml_type_id
/**
* tell whether this type is orderable, that is, can participate
* in comparisons.
*
* @param cf    a classfactory
*
* @return      true for orderable types, false for non-orderable types.
*/
public boolean orderable classfactory cf
boolean orderable
switch  formatid
// cmp not allowed, indexing not allowed
case storedformatids blob_type_id
case storedformatids clob_type_id
case storedformatids nclob_type_id
case storedformatids national_longvarchar_type_id
case storedformatids longvarchar_type_id
case storedformatids xml_type_id
case storedformatids longvarbit_type_id
return false
case storedformatids userdefined_type_id_v3
/* is this type orderable? */
// for user java classes we are orderable if we
// implement java.lang.orderable (jdk1.2) or
// have a int compareto(object) method (jdk1.1 or jdk1.2)
userdefinedtypeidimpl baseusertypeid
userdefinedtypeidimpl  basetypeid
string classname   baseusertypeid getclassname
try
class c   cf getclassinspector   getclass classname
orderable   java lang comparable class isassignablefrom c
catch  classnotfoundexception cnfe
orderable   false
break
default
orderable   true
return orderable
/**
* each built-in type in jsql has a precedence.  this precedence determines
* how to do type promotion when using binary operators.  for example, float
* has a higher precedence than int, so when adding an int to a float, the
* result type is float.
*
* the precedence for some types is arbitrary.  for example, it doesn't
* matter what the precedence of the boolean type is, since it can't be
* mixed with other types.  but the precedence for the number types is
* critical.  the sql standard requires that exact numeric types be
* promoted to approximate numeric when one operator uses both.  also,
* the precedence is arranged so that one will not lose precision when
* promoting a type.
* note: char, varchar, and longvarchar must appear at the bottom of
* the hierarchy, but above user_precedence, since we allow the implicit
* conversion of those types to any other built-in system type.
*
* @return              the precedence of this type.
*/
public int typeprecedence
return typeprecedence
/**
* get the name of the corresponding java type.
*
* each sql type has a corresponding java type.  when a sql value is
* passed to a java method, it is translated to its corresponding java
* type.  for example, when a sql date column is passed to a method,
* it is translated to a java.sql.date.
*
* @return      the name of the corresponding java type.
*/
public string getcorrespondingjavatypename
if  sanitymanager debug
if  formatid    storedformatids ref_type_id
sanitymanager throwassert
sanitymanager assert javatypename    null
return javatypename
/**
* get the name of the corresponding java type.
*
* this method is used directly from embedresultsetmetadata (jdbc)
* to return the corresponding type (as choosen by getobject).
* it solves a specific problem for blob types where the
* getcorrespondingjavatypename() is used internall for casting
* which doesn't work if changed from byte[] to java.sql.blob.
* so we do it here instread, to avoid unexpected sideeffects.
*
* @return      the name of the corresponding java type.
*/
public string getresultsetmetadatatypename
if   blob_id    null     blob_id equals this
return
if   clob_id    null     clob_id equals this
return
if   nclob_id    null     nclob_id equals this
return
return getcorrespondingjavatypename
/**
* get the maximum maximum width of the type (that's not a typo).  for
* types with variable length, this is the absolute maximum for the type.
*
* @return      the maximum maximum width of the type
*/
public int getmaximummaximumwidth
return maxmaxwidth
/**
* converts this typeid, given a data type descriptor (including length/precision),
* to a string. e.g.
*
*                      varchar(30)
*
*
*      for most data types, we just return the sql type name.
*
*      @param  dts     data type descriptor that holds the length/precision etc. as necessary
*
*       @return        string version of datatype, suitable for running through
*                      the parser.
*/
public string   toparsablestring datatypedescriptor dts
return  basetypeid toparsablestring dts
/**
* is this a type id for a numeric type?
*
* @return whether or not this a type id for a numeric type.
*/
public boolean isnumerictypeid
return isnumerictypeid
/**
* is this a type id for a decimal type?
*
* @return whether or not this a type id for a decimal type.
*/
public boolean isdecimaltypeid
return isdecimaltypeid
/**
* is this a type id for a boolean type?
*
* @return whether or not this a type id for a boolean type.
*/
public boolean isbooleantypeid
return isbooleantypeid
/**
* is this a type id for a ref type?
*
* @return whether or not this a type id for a ref type.
*/
public boolean isreftypeid
return isreftypeid
/**
* is this a type id for a concatable type?
*
* @return whether or not this a type id for a concatable type.
*/
public boolean isconcatabletypeid
return isconcatabletypeid
/**
* is this a type id for a bit type?
*
* @return whether or not this a type id for a bit type.
*/
public boolean isbittypeid
return isbittypeid
/**
* is this a type id for a lob type?
*
* @return whether or not this a type id for a lob type.
*/
public boolean islobtypeid
return islobtypeid
/**
* is this a type id for a long concatable type?
*
* @return whether or not this a type id for a long concatable type.
*/
public boolean islongconcatabletypeid
return islongconcatabletypeid
/**
* is this a type id for a user defined type?
*
* @return whether or not this a type id for a user defined type.
*/
public boolean isuserdefinedtypeid
return isuserdefinedtypeid
// formatable interface
/**
* read this object from a stream of stored objects.
*
* @param in read this.
*
* @exception ioexception                                       thrown on error
* @exception classnotfoundexception            thrown on error
*/
public void readexternal  objectinput in
throws ioexception  classnotfoundexception
basetypeid    basetypeidimpl  in readobject
/* we need to set the type specific variables
* for user types when reading back off of the
* disk becuse the basetypeid was null when the
* 0 argument constructor was called.
*/
switch  formatid
case storedformatids userdefined_type_id_v3
settypeidspecificinstancevariables
/**
* write this object to a stream of stored objects.
*
* @param out write bytes here.
*
* @exception ioexception               thrown on error
*/
public void writeexternal  objectoutput out
throws ioexception
out writeobject  basetypeid
/**
* get the formatid which corresponds to this class.
*
*      @return the formatid of this class
*/
public  int     gettypeformatid
return formatid
/**
*  get sql null value.
*  @return sql null value for this type.
*/
public datavaluedescriptor getnull
switch  formatid
case storedformatids bit_type_id
return new sqlbit
case storedformatids boolean_type_id
return new sqlboolean
case storedformatids char_type_id
return new sqlchar
// implementation of decimal can change.
case storedformatids decimal_type_id
return decimalimplementation getnewnull
case storedformatids double_type_id
return new sqldouble
case storedformatids int_type_id
return new sqlinteger
case storedformatids longint_type_id
return new sqllongint
case storedformatids longvarbit_type_id
return new sqllongvarbit
case storedformatids blob_type_id
return new sqlblob
case storedformatids clob_type_id
return new sqlclob
case storedformatids nclob_type_id
return new sqlnclob
case storedformatids longvarchar_type_id
return new sqllongvarchar
case storedformatids national_char_type_id
return new sqlnationalchar
case storedformatids national_varchar_type_id
return new sqlnationalvarchar
case storedformatids national_longvarchar_type_id
return new sqlnationallongvarchar
case storedformatids real_type_id
return new sqlreal
case storedformatids ref_type_id
return new sqlref
case storedformatids smallint_type_id
return new sqlsmallint
case storedformatids tinyint_type_id
return new sqltinyint
case storedformatids date_type_id
return new sqldate
case storedformatids time_type_id
return new sqltime
case storedformatids timestamp_type_id
return new sqltimestamp
case storedformatids userdefined_type_id_v3
return new usertype
case storedformatids varbit_type_id
return new sqlvarbit
case storedformatids varchar_type_id
return new sqlvarchar
case storedformatids xml_type_id
return new xml
default
if  sanitymanager debug
sanitymanager throwassert
formatid
return null
/**
* is this type streamstorable?
*
* @return      true if this type has variable length.
*/
public boolean  streamstorable
return isstringtypeid      isbittypeid
//
//      class methods
//
/**
* get the approximate length of this type in bytes.
* for most datatypes this is just going to be
* dts.getmaximumwidth().  some types, such as
* bit, will override this.
*
* @param dts data type descriptor that holds the
*              length/precision etc. as necessary
*
* @return the length in bytes
*/
public int getapproximatelengthinbytes datatypedescriptor dts
switch  formatid
case storedformatids bit_type_id
return  int  math ceil dts getmaximumwidth   8d
case storedformatids char_type_id
case storedformatids national_char_type_id
return  2   dts getmaximumwidth      2
case storedformatids decimal_type_id
// return 200 if precision is max int
if  dts getprecision      integer max_value
return 200
else
return 8    int   math ceil   double dts getprecision    2d
case storedformatids longvarbit_type_id
case storedformatids blob_type_id
case storedformatids clob_type_id
case storedformatids nclob_type_id
// resolve: should xml be here?  what's this value mean, anyway?
case storedformatids xml_type_id
return 10240
case storedformatids ref_type_id
return 16
case storedformatids userdefined_type_id_v3
/* for user types we'll guess on the high side
** (200) to avoid being too low in most cases.
*/
return 200
case storedformatids varbit_type_id
// return 200 if maximum width is max int
if  dts getmaximumwidth      integer max_value
return 200
else
return  int  math ceil dts getmaximumwidth   8d
case storedformatids national_varchar_type_id
case storedformatids varchar_type_id
case storedformatids longvarchar_type_id
case storedformatids national_longvarchar_type_id
// return 200 if maximum width is max int
if  dts getmaximumwidth      integer max_value
return 200
else
return  dts getmaximumwidth     2    2
/*
** for date/time we know the exact size
** thanks to some investigative work by
** someone or other (sad isn't it).
*/
case storedformatids date_type_id
return 18
case storedformatids time_type_id
return 16
case storedformatids timestamp_type_id
return 29
default
return dts getmaximumwidth
/**
* get the base type id that is embedded in this type id.  the base type
* id is an object with a minimal implementation of typeid that is intended
* to be usable on the client side.
*/
public basetypeidimpl getbasetypeid
return basetypeid
/**
* get the precision of the merge of two decimals
*
* @param lefttype the left type
* @param righttype the left type
*
* @return      the resultant precision
*/
public int getprecision datatypedescriptor lefttype
datatypedescriptor righttype
if  sanitymanager debug
if  formatid    storedformatids decimal_type_id
sanitymanager throwassert
formatid
long lscale    long lefttype getscale
long rscale    long righttype getscale
long lprec    long lefttype getprecision
long rprec    long righttype getprecision
long val
/*
** take the maximum left of decimal digits plus the scale.
*/
val   this getscale lefttype  righttype
math max lprec   lscale  rprec   rscale
if  val > integer max_value
val   integer max_value
return  int val
/**
* get the scale of the merge of two decimals
*
* @param lefttype the left type
* @param righttype the left type
*
* @return      the resultant precision
*/
public int getscale datatypedescriptor lefttype
datatypedescriptor righttype
if  sanitymanager debug
if  formatid    storedformatids decimal_type_id
sanitymanager throwassert
formatid
/*
** retain greatest scale
*/
return math max lefttype getscale    righttype getscale
/**
* does type hava a declared variable length (defined by the application).
* examples are char(10), clob(1m).
* unbounded long types, like long varchar return false here.
* @return boolean true if type is variable length false if not.
*/
public boolean variablelength
switch  formatid
case storedformatids bit_type_id
case storedformatids varbit_type_id
case storedformatids decimal_type_id
case storedformatids char_type_id
case storedformatids varchar_type_id
case storedformatids national_char_type_id
case storedformatids national_varchar_type_id
case storedformatids blob_type_id
case storedformatids clob_type_id
return true
default
return false