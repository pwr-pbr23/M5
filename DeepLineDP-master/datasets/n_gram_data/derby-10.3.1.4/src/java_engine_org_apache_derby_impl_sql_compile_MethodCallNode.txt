/*
derby - class org.apache.derby.impl.sql.compile.methodcallnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services loader classinspector
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi types stringdatavalue
import org apache derby iapi types typeid
import org apache derby iapi types jsqltype
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile compilercontext
import org apache derby iapi types datatypedescriptor
import org apache derby iapi sql compile typecompiler
import org apache derby catalog typedescriptor
import org apache derby iapi reference sqlstate
import org apache derby iapi reference jdbc30translation
import org apache derby iapi store access qualifier
import org apache derby iapi util jbitset
import org apache derby impl sql compile expressionclassbuilder
import org apache derby catalog types routinealiasinfo
import java lang reflect modifier
import java lang reflect member
import java util stringtokenizer
import java util vector
/**
* a methodcallnode represents a java method call.  method calls can be done
* through dml (as expressions) or through the call statement.
*
*/
abstract class methodcallnode extends javavaluenode
/*
** name of the method.
*/
string	methodname
/** the name of the class containing the method. may not be known until bindexpression() has been called.
* @see #bindexpression
* @see #getjavaclassname()
*/
string javaclassname
/**
for a procedure or function call
*/
routinealiasinfo routineinfo
/**
true if this is an internal call, just used to set up a generated method call.
*/
boolean internalcall
/**
for resolution of procedure inout/out parameters to the primitive
form, such as int[]. may be null.
*/
private string procedureprimitivearraytype
// bound signature of arguments, stated in universal types (jsqltype)
protected jsqltype				signature
/*
** parameters to the method, if any.  no elements if no parameters.
*/
protected javavaluenode	methodparms
/* the method call */
protected member method
protected string actualmethodreturntype
/**
the parameter types for the resolved method.
*/
string methodparametertypes
/**
* initializer for a methodcallnode
*
* @param	methodname	the name of the method to call
*/
public void init object methodname
this methodname    string  methodname
public string getmethodname
return  methodname
/**
* @return the name of the class that contains the method, null if not known. it may not be known
*         until this node has been bound.
*/
public string getjavaclassname
return javaclassname
/**
* add the parameter list
*
* @param parameterlist		a vector of the parameters
*
* @exception standardexception		thrown on error
*/
public void addparms vector parameterlist  throws standardexception
methodparms   new javavaluenode
int	plsize   parameterlist size
for  int index   0  index < plsize  index
querytreenode	qt
qt    querytreenode  parameterlist elementat index
/*
** since we need the parameter to be in java domain format, put a
** sqltojavavaluenode on top of the parameter node if it is a
** sqlvaluenode. but if the parameter is already in java domain
** format, then we don't need to do anything.
*/
if      qt instanceof javavaluenode
qt    sqltojavavaluenode  getnodefactory   getnode
c_nodetypes sql_to_java_value_node
qt
getcontextmanager
methodparms    javavaluenode  qt
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
int	parm
super printsubnodes depth
if  methodparms    null
for  parm   0  parm < methodparms length  parm
if  methodparms    null
printlabel depth      parm
methodparms treeprint depth   1
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return
methodname    null ? methodname
super tostring
else
return
/**
* bind this expression.  this means binding the sub-expressions,
* as well as figuring out what the return type is for this expression.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @exception standardexception		thrown on error
*/
final void bindparameters
fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
/* bind the parameters */
if  methodparms    null
int		count   methodparms length
// with a procedure call the signature
// is preformed in staticmethodcall from
// the procedures signature.
if  signature    null
signature   new jsqltype
for  int parm   0  parm < count  parm
if  methodparms    null
methodparms
methodparms bindexpression
fromlist  subquerylist  aggregatevector
if  routineinfo    null
signature   methodparms getjsqltype
// prohibit lob columns/types
if  signature    null
string type   signature getsqltype   gettypeid   getsqltypename
if  type equals       type equals       type equals
throw standardexception newexception sqlstate lob_as_method_argument_or_receiver
/**
* return whether or not all of the parameters to this node are
* query_invariant or constant.  this is useful for vtis - a vti is a candidate
* for materialization if all of its parameters are query_invariant or constant
*
* @return whether or not all of the parameters to this node are query_invariant or constant
* @exception standardexception	thrown on error
*/
protected boolean areparametersqueryinvariant   throws standardexception
return  getvarianttypeofparams      qualifier query_invariant
/**
* build parameters for error message and throw the exception when there
* is no matching signature found.
*
* @param receivertypename	type name for receiver
* @param parmtypenames		type names for parameters as object types
* @param primparmtypenames	type names for parameters as primitive types
*
* @exception standardexception		thrown on error
*/
void thrownomethodfound string receivertypename
string parmtypenames
string primparmtypenames
throws standardexception
/* put the parameter type names into a single string */
stringbuffer	parmtypes   new stringbuffer
for  int i   0  i < parmtypenames length  i
if  i    0
parmtypes append
/* resolve - shouldn't be using hard coded strings for output */
parmtypes append   parmtypenames length      0 ?
parmtypenames
if   primparmtypenames    null
primparmtypenames equals parmtypenames       has primitive
parmtypes append     primparmtypenames
throw standardexception newexception sqlstate lang_no_method_found
receivertypename
methodname
parmtypes
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @exception standardexception		thrown on error
*/
public void preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
int	parm
/* preprocess the parameters */
if  methodparms    null
for  parm   0  parm < methodparms length  parm
if  methodparms    null
methodparms preprocess numtables
outerfromlist
outersubquerylist
outerpredicatelist
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode.
* @exception standardexception			thrown on error
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
throws standardexception
/* we stop here when only considering simple predicates
*  as we don't consider method calls when looking
* for null invariant predicates.
*/
if  simplepredsonly
return false
boolean pushable   true
int		param
if  methodparms    null
for  param   0  param < methodparms length  param
if  methodparms    null
pushable   methodparms categorize referencedtabs  simplepredsonly
pushable
/* we need to push down method call.  then the predicate can be used for start/stop
* key for index scan.  the fact that method call's cost is not predictable and can
* be expensive doesn't mean we shouldn't push it down. beetle 4826.
*/
return pushable
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @return javavaluenode			the remapped expression tree.
*
* @exception standardexception			thrown on error
*/
public javavaluenode remapcolumnreferencestoexpressions
throws standardexception
int	param
if  methodparms    null
for  param   0  param < methodparms length  param
if  methodparms    null
methodparms
methodparms remapcolumnreferencestoexpressions
return this
/**
* generate the parameters to the given method call
*
* @param acb	the expressionclassbuilder for the class we're generating
* @param mb the method  the expression will go into
*
* @return	count of arguments to the method.
*
* @exception standardexception		thrown on error
*/
public	int generateparameters expressionclassbuilder acb
methodbuilder mb
throws standardexception
int				param
string expectedtypes   methodparametertypes
classinspector classinspector   getclassfactory   getclassinspector
/* generate the code for each user parameter, generating the appropriate
* cast when the passed type needs to get widened to the expected type.
*/
for  param   0  param < methodparms length  param
generateoneparameter  acb  mb  param
// type from the sql-j expression
string argumenttype   getparametertypename  methodparms
// type of the method
string parametertype   expectedtypes
if   parametertype equals argumenttype
// since we reached here through method resolution
// casts are only required for primitive types.
// in any other case the expression type must be assignable
// to the parameter type.
if  classinspector primitivetype parametertype
mb cast parametertype
else
// for a prodcedure
if  routineinfo    null
continue     probably should be only for inout out parameters
if  sanitymanager debug
sanitymanager assert classinspector assignableto argumenttype  parametertype
argumenttype       parametertype
/*
** set the parameter type in case the argument type is narrower
** than the parameter type.
*/
mb upcast parametertype
return methodparms length
static	public	string	getparametertypename  javavaluenode param
throws standardexception
string	argumenttype
// resolve - shouldn't this logic be inside javavaluenode ??
// i.e. once the value is primitive then its java type name is its
// primitive type name.
if  param isprimitivetype      argumenttype   param getprimitivetypename
else   argumenttype   param getjavatypename
return	argumenttype
/**
* generate one parameter to the given method call. this method is overriden by
* repstaticmethodcallnode.
*
* @param acb				the expressionclassbuilder for the class we're generating
* @param mb the method the expression will go into
* @param parameternumber	identifies which parameter to generate. 0 based.
*
* @exception standardexception		thrown on error
*/
public	void generateoneparameter expressionclassbuilder acb
methodbuilder mb
int parameternumber
throws standardexception
methodparms generateexpression acb  mb
/**
* set the appropriate type information for a null passed as a parameter.
* this method is called after method resolution, when a signature was
* successfully matched.
*
* @param parmtypenames	string[] with the java type names for the parameters
*        as declared by the method
*
* @exception standardexception		thrown on error
*/
public void	setnullparameterinfo string parmtypenames
throws standardexception
for  int i   0  i < methodparms length  i
/* null parameters are represented by a java type name of "" */
if  methodparms getjavatypename   equals
/* set the type information in the null constant node */
datatypedescriptor dts   datatypedescriptor getsqldatatypedescriptor parmtypenames
sqltojavavaluenode methodparms  value settype dts
/* set the correct java type name */
methodparms setjavatypename parmtypenames
signature   methodparms getjsqltype
protected void resolvemethodcall string javaclassname
boolean staticmethod
throws standardexception
// only allow direct method calls through routines and internal sql.
if  routineinfo    null     internalcall
// see if we are being executed in an internal context
if   getcompilercontext   getreliability     compilercontext internal_sql_illegal     0
throw standardexception newexception sqlstate lang_syntax_error   javaclassname    staticmethod ?          methodname
int			count   signature length
classinspector classinspector   getclassfactory   getclassinspector
string		parmtypenames
string		primparmtypenames   null
boolean		isparam   getisparam
boolean hasdynamicresultsets    routineinfo    null      count    0      count    methodparms length
/*
** find the matching method that is public.
*/
int signatureoffset   methodname indexof
// support java signatures by checking if the method name contains a '('
if  signatureoffset     1
parmtypenames   parsevalidatesignature methodname  signatureoffset  hasdynamicresultsets
methodname   methodname substring 0  signatureoffset
// if the signature is specified then derby resolves to exactly
// that method. setting this flag to false disables the method
// resolution from automatically optionally repeating the last
// parameter as needed.
hasdynamicresultsets   false
else
parmtypenames   getobjectsignature
try
method   classinspector findpublicmethod javaclassname
methodname
parmtypenames

isparam
staticmethod
hasdynamicresultsets
// db2 luw does not support java object types for smallint, integer, bigint, real, double
// and these are the only types that can map to a primitive or an object type according
// to sql part 13. so we never have a second chance match.
// also if the ddl specified a signature, then no alternate resolution
if  signatureoffset     1    routineinfo    null
/* if no match, then retry with combinations of object and
* primitive types.
*/
if  method    null
primparmtypenames   getprimitivesignature false
method   classinspector findpublicmethod javaclassname
methodname
parmtypenames
primparmtypenames
isparam
staticmethod
hasdynamicresultsets
catch  classnotfoundexception e
/*
** if one of the classes couldn't be found, just act like the
** method couldn't be found.  the error lists all the class names,
** which should give the user enough info to diagnose the problem.
*/
method   null
/* throw exception if no matching signature found */
if  method    null
thrownomethodfound javaclassname  parmtypenames  primparmtypenames
string	typename   classinspector gettype method
actualmethodreturntype   typename
if  routineinfo    null
/* void methods are only okay for call statements */
if  typename equals
if   forcallstatement
throw standardexception newexception sqlstate lang_void_method_call
else
string promotename   null
typedescriptor returntype   routineinfo getreturntype
string requiredtype
if  returntype    null
// must have a void method for a procedure call.
requiredtype
else
// db2 luw does not support java object types for smallint, integer, bigint, real, double
// and these are the only types that can map to a primitive or an object type according
// to sql part 13. so always map to the primitive type. we can not use the getprimitivesignature()
// as it (incorrectly but historically always has) maps a decimal to a double.
typeid returntypeid   typeid getbuiltintypeid returntype getjdbctypeid
switch  returntype getjdbctypeid
case java sql types smallint
case java sql types integer
case java sql types bigint
case java sql types real
case java sql types double
typecompiler tc   gettypecompiler returntypeid
requiredtype   tc getcorrespondingprimitivetypename
if   routineinfo calledonnullinput      routineinfo getparametercount      0
promotename   returntypeid getcorrespondingjavatypename
break
default
requiredtype   returntypeid getcorrespondingjavatypename
break
if   requiredtype equals typename
thrownomethodfound requiredtype       javaclassname  parmtypenames  primparmtypenames
// for a returns null on null input with a primitive
// type we need to promote to an object so we can return null.
if  promotename    null
typename   promotename
setjavatypename  typename
methodparametertypes   classinspector getparametertypes method
for  int i   0  i < methodparametertypes length  i
string methodparameter   methodparametertypes
if  routineinfo    null
if  i < routineinfo getparametercount
int parametermode   routineinfo getparametermodes
switch  parametermode
case jdbc30translation parameter_mode_in
break
case jdbc30translation parameter_mode_in_out
// we need to see if the type of the array is
// primitive, not the array itself.
methodparameter   methodparameter substring 0  methodparameter length     2
break
case jdbc30translation parameter_mode_out
// value is not obtained *from* parameter.
continue
if  classinspector primitivetype methodparameter
methodparms casttoprimitive true
/* set type info for any null parameters */
if   someparametersarenull
setnullparameterinfo methodparametertypes
/* bug 4450 - if the callable statement is ? = call form, generate the metadata
infor for the return parameter. we don't really need that info in order to
execute the callable statement. but with jdbc3.0, this information should be
made available for return parameter through parametermetadata class.
parser sets a flag in compilercontext if ? = call. if the flag is set,
we generate the metadata info for the return parameter and reset the flag
in the compilercontext for future call statements*/
datatypedescriptor dts   datatypedescriptor getsqldatatypedescriptor typename
if  getcompilercontext   getreturnparameterflag
getcompilercontext   getparametertypes     dts
/**
* parse the user supplied signature for a method and validate
* it, need to match the number of parameters passed in and match
* the valid types for the parameter.
* @param offset character offset of first paren
* @param hasdynamicresultsets can resultset[] parameters be specified.
* @return the valid array of types for resolution.
* @throws standardexception
*/
private string parsevalidatesignature string externalname  int offset
boolean hasdynamicresultsets
throws standardexception
int siglen   externalname length
// ensure the opening paren is not the last
// character and that the last character is a close paren
if    offset   1     siglen
externalname charat siglen   1
throw standardexception newexception sqlstate sqlj_signature_invalid      invalid
stringtokenizer st   new stringtokenizer externalname substring offset   1  siglen   1      true
string signaturetypes   new string
int count
boolean seenclass   false
for  count   0  st hasmoretokens
string type   st nexttoken   trim
// check sequence is <class><comma>class> etc.
if    equals type
if   seenclass
throw standardexception newexception sqlstate sqlj_signature_invalid      invalid
seenclass   false
continue
else
if  type length      0
throw standardexception newexception sqlstate sqlj_signature_invalid      invalid
seenclass   true
count
if  count > signature length
if  hasdynamicresultsets
// allow any number of dynamic result set holders
// but they must match the exact type.
string rstype   signature getsqltype
gettypeid   getcorrespondingjavatypename
if   type equals rstype
throw standardexception newexception sqlstate lang_data_type_get_mismatch
type  rstype
if  signaturetypes length    signature length
// expand once
string sigs   new string
system arraycopy signaturetypes  0  sigs  0  signaturetypes length
signaturetypes   sigs
signaturetypes   type
continue
throw standardexception newexception sqlstate sqlj_signature_parameter_count
integer tostring count
integer tostring signature length       too many types
typeid	paramtypeid   signature getsqltype   gettypeid
// does it match the object name
if  type equals paramtypeid getcorrespondingjavatypename
signaturetypes   type
continue
// how about the primitive name
if   paramtypeid isnumerictypeid       paramtypeid isdecimaltypeid
paramtypeid isbooleantypeid
typecompiler tc   gettypecompiler paramtypeid
if  type equals tc getcorrespondingprimitivetypename
signaturetypes   type
continue
throw standardexception newexception sqlstate lang_data_type_get_mismatch
type  paramtypeid getsqltypename        type conversion error
// did signature end with trailing comma?
if  count    0     seenclass
throw standardexception newexception sqlstate sqlj_signature_invalid      invalid
if  count < signaturetypes length
if  hasdynamicresultsets
// we can tolerate a count of one less than the
// expected count, which means the procedure is declared
// to have dynamic result sets, but the explict signature
// doesn't have any resultset[] types.
// so accept, and procedure will automatically have 0
// dynamic results at runtime
if  count     signature length   1
string sigs   new string
system arraycopy signaturetypes  0  sigs  0  count
return sigs
throw standardexception newexception sqlstate sqlj_signature_parameter_count
integer tostring count
integer tostring signature length       too few types
return signaturetypes
/**
*	return true if some parameters are null, false otherwise.
*/
protected	boolean	someparametersarenull
int		count   signature length
for   int ictr   0  ictr < count  ictr
if   signature    null
return true
return false
/**
*	build an array of names of the argument types. these types are biased toward
*	java objects. that is, if an argument is of sqltype, then we map it to the
*	corresponding java synonym class (e.g., sqlint is mapped to 'java.lang.integer').
*
*
*	@return	array of type names
*
* @exception standardexception		thrown on error
*/
protected	string	getobjectsignature
throws standardexception
int		count   signature length
string	parmtypenames   new string
for   int i   0  i < count  i       parmtypenames   getobjecttypename  signature
return parmtypenames
/**
* build an array of booleans denoting whether or not a given method
* parameter is a ?.
*
* @return array of booleans denoting wheter or not a given method
* parameter is a ?.
*/
protected boolean getisparam
if  methodparms    null
return new boolean
boolean isparam   new boolean
for  int index   0  index < methodparms length  index
if  methodparms instanceof sqltojavavaluenode
sqltojavavaluenode stjvn    sqltojavavaluenode  methodparms
if  stjvn value requirestypefromcontext
isparam   true
return isparam
private	string	getobjecttypename  jsqltype jsqltype
throws standardexception
if   jsqltype    null
switch  jsqltype getcategory
case jsqltype sqltype
typeid	ctid   maptotypeid  jsqltype
if   ctid    null     return null
else
// db2 luw does not support java object types for smallint, integer, bigint, real, double
// and these are the only types that can map to a primitive or an object type according
// to sql part 13. so always map to the primitive type. we can not use the getprimitivesignature()
// as it (incorrectly but historically always has) maps a decimal to a double.
switch  ctid getjdbctypeid
case java sql types smallint
case java sql types integer
case java sql types bigint
case java sql types real
case java sql types double
if  routineinfo    null
typecompiler tc   gettypecompiler ctid
return tc getcorrespondingprimitivetypename
// fall through
default
return ctid getcorrespondingjavatypename
case jsqltype java_class  return jsqltype getjavaclassname
case jsqltype java_primitive  return jsqltype primitivenames
default
if  sanitymanager debug
sanitymanager throwassert      jsqltype
return
string	getprimitivesignature  boolean casttoprimitiveasnecessary
throws standardexception
int					count   signature length
string 			primparmtypenames   new string
jsqltype			jsqltype
for  int i   0  i < count  i
jsqltype   signature
if   jsqltype    null     primparmtypenames
else
switch  jsqltype getcategory
case jsqltype sqltype
if   procedureprimitivearraytype    null
i < procedureprimitivearraytype length
procedureprimitivearraytype    null
primparmtypenames   procedureprimitivearraytype
else
typeid	ctid   maptotypeid  jsqltype
if   ctid isnumerictypeid       ctid isdecimaltypeid       ctid isbooleantypeid
typecompiler tc   gettypecompiler ctid
primparmtypenames   tc getcorrespondingprimitivetypename
if   casttoprimitiveasnecessary    methodparms casttoprimitive true
else   primparmtypenames   ctid getcorrespondingjavatypename
break
case jsqltype java_class
primparmtypenames   jsqltype getjavaclassname
break
case jsqltype java_primitive
primparmtypenames   jsqltype primitivenames
if   casttoprimitiveasnecessary    methodparms casttoprimitive true
break
default
if  sanitymanager debug
sanitymanager throwassert      jsqltype
end switch
end if
end for
return primparmtypenames
/**
* return the variant type for the underlying expression.
* the variant type can be:
*		variant				- variant within a scan
*							  (non-static field access)
*		scan_invariant		- invariant within a scan
*							  (column references from outer tables)
*		query_invariant		- invariant within the life of a query
*							  (constant expressions)
*
* @return	the variant type for the underlying expression.
*/
protected int getorderablevarianttype   throws standardexception
// beetle 4880. we return the most variant type of the parameters. if no
// params then query-invariant. this makes more sense, and we can evaluate
// only once per query (good for performance) because method call could be
// expensive.  and if we push down method qualifier to store, language
// can pre-evaluate the method call.  this avoids letting store evaluate
// the method while holding page latch, causing deadlock.
return getvarianttypeofparams
private int getvarianttypeofparams   throws standardexception
int variance   qualifier query_invariant
if  methodparms    null
for  int parm   0  parm < methodparms length  parm
if  methodparms    null
int paramvarianttype
methodparms getorderablevarianttype
if  paramvarianttype < variance 	  return the most variant type
variance   paramvarianttype
else
variance   qualifier variant
return variance
/////////////////////////////////////////////////////////////////////
//
//	accessors
//
/////////////////////////////////////////////////////////////////////
/**
* get the method parameters.
*
* @return	the method parameters
*/
public javavaluenode	getmethodparms
return methodparms
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
visitable		returnnode   v visit this
if  v skipchildren this
return returnnode
for  int parm   0
v stoptraversal      parm < methodparms length
parm
if  methodparms    null
methodparms    javavaluenode methodparms accept v
return returnnode