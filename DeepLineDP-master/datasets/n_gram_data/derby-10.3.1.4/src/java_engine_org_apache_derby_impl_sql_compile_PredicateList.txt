/*
derby - class org.apache.derby.impl.sql.compile.predicatelist
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services compiler localfield
import org apache derby iapi reference classname
import org apache derby iapi services classfile vmopcode
import org apache derby iapi error standardexception
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile expressionclassbuilderinterface
import org apache derby iapi sql compile optimizablepredicate
import org apache derby iapi sql compile optimizablepredicatelist
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile accesspath
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute executionfactory
import org apache derby iapi sql activation
import org apache derby iapi sql row
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary statisticsdescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby impl sql compile expressionclassbuilder
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi util jbitset
import java lang reflect modifier
import java sql types
import java util arraylist
import java util enumeration
import java util properties
import java util vector
/**
* a predicatelist represents the list of top level predicates.
* each top level predicate consists of an andnode whose leftoperand is the
* top level predicate and whose rightoperand is true.  it extends
* querytreenodevector.
*
*/
public class predicatelist extends querytreenodevector implements optimizablepredicatelist
private int	numberofstartpredicates
private int numberofstoppredicates
private int numberofqualifiers
public predicatelist
/*
* optimizablelist interface
*/
/**
* @see org.apache.derby.iapi.sql.compile.optimizablepredicatelist#getoptpredicate
*/
public optimizablepredicate getoptpredicate int index
return  optimizablepredicate  elementat index
/**
* @see org.apache.derby.iapi.sql.compile.optimizablepredicatelist#removeoptpredicate
*
* @exception standardexception		thrown on error
*/
public final void removeoptpredicate int predctr  throws standardexception
predicate predicate    predicate  remove predctr
if  predicate isstartkey
numberofstartpredicates
if  predicate isstopkey
numberofstoppredicates
if  predicate isqualifier
numberofqualifiers
/**
* another version of removeoptpredicate that takes the predicate to be
* removed, rather than the position of the predicate.  this is not part
* any interface (yet).
*/
public final void removeoptpredicate optimizablepredicate pred
removeelement  predicate  pred
if  pred isstartkey
numberofstartpredicates
if  pred isstopkey
numberofstoppredicates
if  pred isqualifier
numberofqualifiers
/** @see optimizablepredicatelist#addoptpredicate */
public void addoptpredicate optimizablepredicate optpredicate
addelement  predicate optpredicate
if  optpredicate isstartkey
numberofstartpredicates
if  optpredicate isstopkey
numberofstoppredicates
if  optpredicate isqualifier
numberofqualifiers
/**
* another flavor of addoptpredicate that inserts the given predicate
* at a given position.  this is not yet part of any interface.
*/
public void addoptpredicate optimizablepredicate optpredicate  int position
insertelementat  predicate  optpredicate  position
if  optpredicate isstartkey
numberofstartpredicates
if  optpredicate isstopkey
numberofstoppredicates
if  optpredicate isqualifier
numberofqualifiers
/**
* @see optimizablepredicatelist#useful
* @exception standardexception		thrown on error
*/
public boolean useful optimizable opttable  conglomeratedescriptor cd
throws standardexception
boolean			retval   false
/*
** most of this assumes btree,
** so should move into a configurable module
*/
/* if the conglomerate isn't an index, the predicate isn't useful */
if     cd isindex
return false
/*
** a predicatelist is useful for a btree if it contains a relational
** operator directly below a top-level and comparing the first column
** in the index to an expression that does not contain a reference
** to the table in question.  let's look for that.
*/
int size   size
for  int index   0  index < size  index
predicate	pred    predicate  elementat index
relationaloperator relop   pred getrelop
/* inlistoperatornodes, while not relational operators, may still
* be useful.  there are two cases: a) we transformed the in-list
* into a probe predicate of the form "col = ?", which can then be
* optimized/generated as a start/stop key and used for "multi-
* probing" at execution; or b) we did *not* transform the in-list,
* in which case we'll generate _dynamic_ start and stop keys in
* order to improve scan performance (beetle 3858).  in either case
* the in-list may still prove "useful".
*/
inlistoperatornode innode   pred getsourceinlist
boolean isin    innode    null
/* if it's not a relational operator and it's not "in", then it's
* not useful.
*/
if   isin     relop    null
continue
/*
** if the relational operator is neither a useful start key
** nor a useful stop key for this table, it is not useful
** for limiting an index scan.
*/
if      isin         relop usefulstartkey opttable
relop usefulstopkey opttable
continue
/*
** look for a the first column of the index on one side of the
** relop.  if it's not found, this predicate is not optimizable.
*/
columnreference indexcol   null
if  isin
if  innode getleftoperand   instanceof columnreference
indexcol    columnreference  innode getleftoperand
if  indexcol getcolumnnumber
cd getindexdescriptor   basecolumnpositions
indexcol   null
else
indexcol
relop getcolumnoperand
opttable
cd getindexdescriptor   basecolumnpositions
if  indexcol    null
continue
/*
** look at the expression that the index column is compared to.
** if it contains columns from the table in question, the
** predicate is not optimizable.
*/
if   isin    innode selfreference indexcol
isin    relop selfcomparison indexcol
continue
/* the predicate is optimizable */
retval   true
break
return retval
/**
* @see optimizablepredicatelist#pushusefulpredicates
*
* @exception standardexception		thrown on error
*/
public void pushusefulpredicates optimizable opttable
throws standardexception
accesspath ap   opttable gettrulythebestaccesspath
orderusefulpredicates opttable
ap getconglomeratedescriptor
true
ap getnonmatchingindexscan
ap getcoveringindexscan
/**
* @see optimizablepredicatelist#classify
*
* @exception standardexception		thrown on error
*/
public void classify optimizable opttable  conglomeratedescriptor cd
throws standardexception
/*
** don't push the predicates - at this point, we are only determining
** which predicates are useful.  also, we don't know yet whether
** we have a non-matching index scan or a covering index scan -
** this method call will help determine that.  so, let's say they're
** false for now.
*/
orderusefulpredicates opttable  cd  false  false  false
/** @see optimizablepredicatelist#markallpredicatesqualifiers */
public void markallpredicatesqualifiers
int size   size
for  int index   0  index < size  index
predicate  elementat index   markqualifier
numberofqualifiers   size
/**
* @see optimizablepredicatelist#hasoptimizableequalitypredicate
*
* @exception standardexception		thrown on error
*/
public boolean hasoptimizableequalitypredicate optimizable opttable
int columnnumber
boolean isnullokay
throws standardexception
int size   size
for  int index   0  index < size  index
andnode			andnode
predicate		predicate
predicate    predicate  elementat index
andnode    andnode  predicate getandnode
// skip non-equality predicates
valuenode opnode   andnode getleftoperand
if  opnode optimizableequalitynode opttable
columnnumber
isnullokay
return true
return false
/**
* @see optimizablepredicatelist#hasoptimizableequijoin
*
* @exception standardexception		thrown on error
*/
public boolean hasoptimizableequijoin optimizable opttable
int columnnumber
throws standardexception
int size   size
for  int index   0  index < size  index
andnode			andnode
predicate		predicate
predicate    predicate  elementat index
// this method is used by hashjoinstrategy to determine if
// there are any equality predicates that can be used to
// perform a hash join (see the findhashkeycolumns()
// method in hashjoinstrategy.java).  that said, if the
// predicate was scoped and pushed down from an outer query,
// then it's no longer possible to perform the hash join
// because one of the operands is in an outer query and
// the other (scoped) operand is down in a subquery. thus
// we skip this predicate if it has been scoped.
if  predicate isscopedforpush
continue
andnode    andnode  predicate getandnode
valuenode opnode   andnode getleftoperand
if     opnode optimizableequalitynode opttable
columnnumber
false
continue
/*
** skip comparisons that are not qualifiers for the table
** in question.
*/
if       relationaloperator  opnode  isqualifier opttable  false
continue
/*
** skip non-join comparisons.
*/
if  predicate getreferencedmap   hassinglebitset
continue
// we found a match
return true
return false
/**
* @see optimizablepredicatelist#putoptimizableequalitypredicatefirst
*
* @exception standardexception		thrown on error
*/
public void putoptimizableequalitypredicatefirst optimizable opttable
int columnnumber
throws standardexception
int size   size
for  int index   0  index < size  index
predicate		predicate    predicate  elementat index
andnode			andnode
andnode    andnode  predicate getandnode
// skip non-equality predicates
valuenode opnode   andnode getleftoperand
if   opnode optimizableequalitynode opttable  columnnumber  false
continue
// we found a match - make this entry first in the list
if  index    0
removeelementat index
insertelementat predicate  0
return
/* we should never get here since this method only called when we
* know that the desired equality predicate exists.
*/
if  sanitymanager debug
sanitymanager throwassert
columnnumber
private void orderusefulpredicates optimizable opttable
conglomeratedescriptor cd
boolean pushpreds
boolean nonmatchingindexscan
boolean coveringindexscan
throws standardexception
boolean	deletes
int		basecolumnpositions
boolean	isascending
int			size   size
predicate	usefulpredicates   new predicate
int			usefulcount   0
predicate	predicate
/*
** clear all the scan flags for this predicate list, so that the
** flags that get set are only for the given conglomerate.
*/
for  int index   0  index < size  index
predicate    predicate  elementat index
predicate clearscanflags
/*
** resolve: for now, not pushing any predicates for heaps.  when this
** changes, we also need to make the scan in
** tablescanresultset.getcurrentrow() check the qualifiers to see
** if the row still qualifies (there is a new method in scancontroller
** for this.
*/
/* is a heap scan or a non-matching index scan on a covering index? */
if   cd    null         cd isindex
nonmatchingindexscan    coveringindexscan
/*
** for the heap, the useful predicates are the relational
** operators that have a column from the table on one side,
** and an expression that doesn't have a column from that
** table on the other side.
**
** for the heap, all useful predicates become qualifiers, so
** they don't have to be in any order.
**
** note: we can logically delete the current element when
** traversing the vector in the next loop,
** so we must build an array of elements to
** delete while looping and then delete them
** in reverse order after completing the loop.
*/
predicate preds   new predicate
for  int index   0  index < size  index
predicate	pred    predicate  elementat index
/*
** skip over it if it's not a relational operator (this includes
** binarycomparisonoperators and isnullnodes.
*/
if   pred isrelationaloppredicate
// possible or clause, check for it.
if   pred ispushableorclause opttable
/* not an or or and, so go on to next predicate.
*
* note: if "pred" (or any predicates in the tree
* beneath "pred") is an in-list probe predicate
* then we'll "revert" it to its original form
* (i.e. to the source inlistoperatornode from
* which it originated) as part of code generation.
* see generateexpression() in binaryoperatornode.
*/
continue
else
if     pred getrelop   isqualifier opttable  pushpreds
// not a qualifier, go on to next predicate.
continue
pred markqualifier
if  sanitymanager debug
if  pred isinlistprobepredicate
sanitymanager throwassert
pred binaryrelopcolrefstostring
if  pushpreds
/* push the predicate down.
* (just record for now.)
*/
if  opttable pushoptpredicate pred
preds   pred
/* now we actually push the predicates down */
for  int inner   size   1  inner >  0  inner
if  preds    null
removeoptpredicate preds
return
basecolumnpositions   cd getindexdescriptor   basecolumnpositions
isascending   cd getindexdescriptor   isascending
/* if we have a "useful" in list probe predicate we will generate a
* start/stop key for opttable of the form "col = <val>", where <val>
* is the first value in the in-list.  then during normal index multi-
* probing (esp. as implemented by exec/multiprobetablescanresultset)
* we will use that start/stop key as a "placeholder" into which we'll
* plug the values from the in-list one at a time.
*
* that said, if we're planning to do a hash join with opttable then
* we won't generate a multiprobetablescanresult; instead we'll
* generate a hashscanresultset, which does not (yet) account for
* in-list multi-probing.  that means the start/stop key "col = <val>"
* would be treated as a regular restriction, which could lead to
* incorrect results.  so if we're dealing with a hash join, we do
* not consider in-list probe predicates to be "useful". derby-2500.
*
* note that it should be possible to enhance hashscanresultset to
* correctly perform index multi-probing at some point, and there
* would indeed be benefits to doing so (namely, we would scan fewer
* rows from disk and build a smaller hash table). but until that
* happens we have to make sure we do not consider probe predicates
* to be "useful" for hash joins.
*
* only need to do this check if "pushpreds" is true, i.e. if we're
* modifying access paths and thus we know for sure that we are going
* to generate a hash join.
*/
boolean skipprobepreds   pushpreds
opttable gettrulythebestaccesspath   getjoinstrategy   ishashjoin
/*
** create an array of useful predicates.  also, count how many
** useful predicates there are.
*/
for  int index   0  index < size  index
predicate pred    predicate  elementat index
columnreference indexcol   null
int			indexposition
relationaloperator relop   pred getrelop
/* inlistoperatornodes, while not relational operators, may still
* be useful.  there are two cases: a) we transformed the in-list
* into a probe predicate of the form "col = ?", which can then be
* optimized/generated as a start/stop key and used for "multi-
* probing" at execution; or b) we did *not* transform the in-list,
* in which case we'll generate _dynamic_ start and stop keys in
* order to improve scan performance (beetle 3858).  in either case
* the in-list may still prove "useful".
*/
inlistoperatornode innode   pred getsourceinlist
boolean isin    innode    null
/* if it's not an "in" operator and either a) it's not a relational
* operator or b) it's not a qualifier, then it's not useful for
* limiting the scan, so skip it.
*/
if   isin
relop    null      relop isqualifier opttable  pushpreds
continue
/* skip it if we're doing a hash join and it's a probe predicate.
* then, since the probe predicate is deemed not useful, it will
* be implicitly "reverted" to its underlying in-list as part of
* code generation.
*/
if  skipprobepreds    pred isinlistprobepredicate
continue
/* look for an index column on one side of the relop */
for  indexposition   0
indexposition < basecolumnpositions length
indexposition
if  isin
if  innode getleftoperand   instanceof columnreference
indexcol    columnreference  innode getleftoperand
if   opttable gettablenumber      indexcol gettablenumber
indexcol getcolumnnumber      basecolumnpositions
innode selfreference indexcol
indexcol   null
else if  pred isinlistprobepredicate
indexposition > 0
/* if the predicate is an in-list probe predicate
* then we only consider it to be useful if the
* referenced column is the *first* one in the
* index (i.e. if (indexposition == 0)).  otherwise
* the predicate would be treated as a qualifier
* for store, which could lead to incorrect
* results.
*/
indexcol   null
else
indexcol
relop getcolumnoperand
opttable
basecolumnpositions
if  indexcol    null
break
/*
** skip over it if there is no index column on one side of the
** operand.
*/
if  indexcol    null
/* if we're pushing predicates then this is the last time
* we'll get here before code generation.  so if we have
* any in-list probe predicates that are not useful, we'll
* need to "revert" them back to their original in-list
* form so that they can be generated as regular in-list
* restrictions.  that "revert" operation happens in
* the generateexpression() method of binaryoperatornode.
*/
continue
pred setindexposition indexposition
/* remember the useful predicate */
usefulpredicates   pred
/* we can end up with no useful
* predicates with a force index override -
* each predicate is on a non-key column or both
* sides of the operator are columns from the same table.
* there's no predicates to push down, so return and we'll
* evaluate them in a prn.
*/
if  usefulcount    0
return
/* the array of useful predicates may have unused slots.  shrink it */
if  usefulpredicates length > usefulcount
predicate	shrink   new predicate
system arraycopy usefulpredicates  0  shrink  0  usefulcount
usefulpredicates   shrink
/* sort the array of useful predicates in index position order */
java util arrays sort usefulpredicates
/* push the sorted predicates down to the optimizable table */
int		currentstartposition    1
boolean	gapinstartpositions   false
int		currentstopposition    1
boolean	gapinstoppositions   false
boolean seennonequals   false
int		firstnonequalsposition    1
int		laststartequalsposition    1
/* beetle 4572. we need to truncate if necessary potential multi-column
* start key up to the first one whose start operator is gt, and make
* start operator gt;
* or start operator is ge if there's no such column.  we need to
* truncate if necessary potential multi-column stop key up to the
* first one whose stop operator is ge, and make stop operator ge; or
* stop operator is gt if no such column.
* eg., start key (a,b,c,d,e,f), potential start operators
* (ge,ge,ge,gt,ge,gt)
* then start key should really be (a,b,c,d) with start operator gt.
*/
boolean seenge   false  seengt   false
for  int i   0  i < usefulcount  i
predicate	        thispred            usefulpredicates
int			        thisindexposition   thispred getindexposition
boolean		        thispredmarked      false
relationaloperator	relop               thispred getrelop
int                 thisoperator         1
boolean isin    thispred getsourceinlist      null
if  relop    null
thisoperator   relop getoperator
/* allow only one start and stop position per index column */
if  currentstartposition    thisindexposition
/*
** we're working on a new index column for the start position.
** is it just one more than the previous position?
*/
if   thisindexposition   currentstartposition  > 1
/*
** there's a gap in the start positions.  don't mark any
** more predicates as start predicates.
*/
gapinstartpositions   true
else if   thisoperator    relationaloperator equals_relop
thisoperator    relationaloperator is_null_relop
/* remember the last "=" or is null predicate in the start
* position.  (the sort on the predicates above has ensured
* that these predicates appear 1st within the predicates on
* a specific column.)
*/
laststartequalsposition   thisindexposition
if     gapinstartpositions
/*
** there is no gap in start positions.  is this predicate
** useful as a start position?  this depends on the
** operator - for example, indexcol = <expr> is useful,
** while indexcol < <expr> is not useful with asc index
** we simply need to reverse the logic for desc indexes
**
** the relop has to figure out whether the index column
** is on the left or the right, so pass the optimizable
** table to help it.
*/
if    seengt
isin      relop usefulstartkey opttable     isascending
relop usefulstopkey opttable       isascending
thispred markstartkey
currentstartposition   thisindexposition
thispredmarked   true
seengt    thispred getstartoperator opttable     scancontroller gt
/* same as above, except for stop keys */
if  currentstopposition    thisindexposition
if   thisindexposition   currentstopposition  > 1
gapinstoppositions   true
if     gapinstoppositions
if    seenge
isin      relop usefulstopkey opttable     isascending
relop usefulstartkey opttable       isascending
thispred markstopkey
currentstopposition   thisindexposition
thispredmarked   true
seenge    thispred getstopoperator opttable     scancontroller ge
/* mark this predicate as a qualifier if it is not a start/stop
* position or if we have already seen a previous column whose
* relops do not include "=" or is null.  for example, if
* the index is on (a, b, c) and the predicates are a > 1 and b = 1
* and c = 1, then b = 1 and c = 1 also need to be a qualifications,
* otherwise we may match on (2, 0, 3).
*/
if      isin    	   store can never treat   as qualifier
thispredmarked
seennonequals    thisindexposition    firstnonequalsposition
thispred markqualifier
/* remember if we have seen a column without an "=" */
if  laststartequalsposition    thisindexposition
firstnonequalsposition     1
thisoperator    relationaloperator equals_relop
thisoperator    relationaloperator is_null_relop
seennonequals   true
/* remember the column */
firstnonequalsposition   thisindexposition
if  pushpreds
/* we only roughly detected that the predicate may be useful
* earlier, it may turn out that it's not actually start/stop
* key because another better predicate on the column is chosen.
* we don't want to push "in" in this case, since it's not a
* qualifier.  beetle 4316.
*/
if  isin      thispredmarked
/* if we get here for an in-list probe pred then we know
* that we are *not* using the probe predicate as a
* start/stop key.  we also know that we're in the middle
* of modifying access paths (because pushpreds is true),
* which means we are preparing to generate code.  those
* two facts together mean we have to "revert" the
* probe predicate back to its original state so that
* it can be generated as normal in-list.  that "revert"
* operation happens from within the generateexpression()
* method of binaryoperatornode.java.
*/
continue
/*
** push the predicate down.  they get pushed down in the
** order of the index.
*/
/* if this is an inlistoperator predicate, make a copy of the
* the predicate (including the and node contained within it)
* and then push the _copy_ (instead of the original) into
* opttable.  we need to do this to avoid having the exact
* same predicate object (and in particular, the exact same
* andnode object) be referenced in both opttable and this.v,
* which can lead to an infinite recursion loop when we get to
* restorepredicates(), and thus to stack overflow
* (beetle 4974).
*
* note: we don't do this if the predicate is an in-list
* probe predicate.  in that case we want to push the
* predicate down to the base table for special handling.
*/
predicate predtopush
if  isin     thispred isinlistprobepredicate
andnode andcopy    andnode  getnodefactory   getnode
c_nodetypes and_node
thispred getandnode   getleftoperand
thispred getandnode   getrightoperand
getcontextmanager
andcopy copyfields thispred getandnode
predicate predcopy    predicate  getnodefactory   getnode
c_nodetypes predicate
andcopy
thispred getreferencedset
getcontextmanager
predcopy copyfields thispred
predtopush   predcopy
else
predtopush   thispred
if  opttable pushoptpredicate predtopush
/* although we generated dynamic start and stop keys
* for "in", we still need this predicate for further
* restriction--*unless* we're dealing with a probe
* predicate, in which case the restriction is handled
* via execution-time index probes (for more see
* execute/multiprobetablescanresultset.java).
*/
if   isin    thispred isinlistprobepredicate
removeoptpredicate thispred
else if  sanitymanager debug
sanitymanager assert false
else
/*
** we're not pushing the predicates down, so put them at the
** beginning of this predicate list in index order.
*/
removeoptpredicate thispred
addoptpredicate thispred  i
/**
* add a predicate to the list.
*
* @param predicate	a predicate to add to the list
*
* @exception standardexception		thrown on error
*/
public void addpredicate predicate predicate  throws standardexception
if  predicate isstartkey
numberofstartpredicates
if  predicate isstopkey
numberofstoppredicates
if  predicate isqualifier
numberofqualifiers
addelement predicate
/**
* transfer the non-qualifiers from this predicate list to the specified
* predicate list.
* this is useful for arbitrary hash join, where we need to separate the 2
* as the qualifiers get applied when probing the hash table and the
* non-qualifiers get * applied afterwards.
*
* @param opttable	the optimizable that we want qualifiers for
* @param otherpl	parameterlist for non-qualifiers
*
* @exception standardexception		thrown on error
*/
protected void transfernonqualifiers optimizable opttable  predicatelist otherpl
throws standardexception
/* walk list backwards since we can delete while
* traversing the list.
*/
for  int index   size     1  index >  0  index
predicate	pred    predicate  elementat index
// transfer each non-qualifier
if   pred isrelationaloppredicate
pred getrelop   isqualifier opttable  false
pred clearscanflags
removeelementat index
otherpl addelement pred
// mark all remaining predicates as qualifiers
markallpredicatesqualifiers
/**
* categorize the predicates in the list.  initially, this means
* building a bit map of the referenced tables for each predicate.
*
* @exception standardexception			thrown on error
*/
public void categorize
throws standardexception
int size   size
for  int index   0  index < size  index
predicate  elementat index   categorize
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
predicate		predicate
super printsubnodes depth
for  int index   0  index < size    index
predicate    predicate  elementat index
predicate treeprint depth   1
/**
*  eliminate predicates of the form:
*							andnode
*							/	   \
*	true booleanconstantnode		true booleanconstantnode
*  this is useful when checking for a nop prn as the
*  like transformation on c1 like 'asdf%' can leave
*  one of these predicates in the list.
*/
public void eliminatebooleantrueandbooleantrue
/* walk list backwards since we can delete while
* traversing the list.
*/
for  int index   size     1  index >  0  index
andnode			nextand
/* look at the current predicate from the predicate list */
nextand     predicate  elementat index   getandnode
if   nextand getleftoperand   isbooleantrue
nextand getrightoperand   isbooleantrue
removeelementat index
/**
* rebuild a constant expression tree from the remaining constant
* predicates and delete those entries from the predicatelist.
* the rightoperand of every top level andnode is always a true
* booleanconstantnode, so we can blindly overwrite that pointer.
* optimizations:
*
* we take this opportunity to eliminate:
*							andnode
*						 /		   \
*	true booleanconstantnode	true booleanconstantnode
*
* we remove the andnode if the predicate list is a single andnode:
*					andnode
*				   /	   \
*		leftoperand			rightoperand
*
* becomes:
*					leftoperand
*
* if the leftoperand of any andnode is false, then the entire expression
* will be false.  the expression simple becomes:
*					false booleanconstantnode
*
* @return valuenode	the rebuilt expression tree.
*/
public valuenode restoreconstantpredicates
throws standardexception
andnode			nextand
andnode			falseand   null
valuenode		restriction   null
/* walk list backwards since we can delete while
* traversing the list.
*/
for  int index   size     1  index >  0  index
/* look at the current predicate from the predicate list */
nextand     predicate  elementat index   getandnode
// skip over the predicate if it is not a constant expression
if    nextand isconstantexpression
continue
// this node is a constant expression, so we can remove it from the list
removeelementat index
/* we can skip over true and true */
if   nextand getleftoperand   isbooleantrue
nextand getrightoperand   isbooleantrue
continue
/* remember if we see a false booleanconstantnode */
if  nextand getleftoperand   isbooleanfalse
falseand   nextand
if  restriction    null
nextand setrightoperand restriction
/* if any of the predicates is nullable, then the resulting
* tree must be nullable.
*/
if  restriction gettypeservices   isnullable
nextand gettypeservices   setnullability true
restriction   nextand
/* if restriction is a single andnode, then it's rightoperand must be
* a true booleanconstantnode.  we simply chop out the andnode and set
* restriction to andnode.leftoperand.
*/
if   restriction    null
andnode  restriction  getrightoperand   isbooleantrue
restriction     andnode  restriction  getleftoperand
else if  falseand    null
/* expression is ... and false and ...
* replace the entire expression with a false booleanconstantnode.
*/
restriction   falseand getleftoperand
return restriction
/**
* rebuild an expression tree from the remaining predicates and delete those
* entries from the predicatelist.
* the rightoperand of every top level andnode is always a true
* booleanconstantnode, so we can blindly overwrite that pointer.
* optimizations:
*
* we take this opportunity to eliminate:
*						andnode
*					   /	   \
*	true booleanconstantnode	true booleanconstantnode
*
* we remove the andnode if the predicate list is a single andnode:
*					andnode
*				   /	   \
*		leftoperand			rightoperand
*
* becomes:
*					leftoperand
*
* if the leftoperand of any andnode is false, then the entire expression
* will be false.  the expression simple becomes:
*					false booleanconstantnode
*
* @return valuenode	the rebuilt expression tree.
*/
public valuenode restorepredicates
throws standardexception
andnode			nextand
andnode			falseand   null
valuenode		restriction   null
int size   size
for  int index   0  index < size  index
nextand     predicate  elementat index   getandnode
/* we can skip over true and true */
if   nextand getleftoperand   isbooleantrue
nextand getrightoperand   isbooleantrue
continue
/* remember if we see a false booleanconstantnode */
if  nextand getleftoperand   isbooleanfalse
falseand   nextand
if  restriction    null
nextand setrightoperand restriction
/* if any of the predicates is nullable, then the resulting
* tree must be nullable.
*/
if  restriction gettypeservices   isnullable
nextand gettypeservices   setnullability true
restriction   nextand
/* if restriction is a single andnode, then it's rightoperand must be
* a true booleanconstantnode.  we simply chop out the andnode and set
* restriction to andnode.leftoperand.
*/
if   restriction    null
andnode  restriction  getrightoperand   isbooleantrue
restriction     andnode  restriction  getleftoperand
else if  falseand    null
/* expression is ... and false and ...
* replace the entire expression with a simple false
* booleanconstantnode.
*/
restriction   falseand getleftoperand
/* remove all predicates from the list */
removeallelements
return restriction
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @exception standardexception			thrown on error
*/
public void remapcolumnreferencestoexpressions   throws standardexception
predicate		pred
int size   size
for  int index   0  index < size  index
pred    predicate  elementat index
pred setandnode  andnode
pred getandnode   remapcolumnreferencestoexpressions
/**
* break apart the search clause into matching a predicatelist
* where each top level predicate is a separate element in the list.
* build a bit map to represent the fromtables referenced within each
* top level predicate.
* note: we want the rightoperand of every andnode to be true, in order
* to simplify the algorithm for putting the predicates back into the tree.
* (as we put an andnode back into the tree, we can ignore it's rightoperand.)
*
* @param numtables			number of tables in the dml statement
* @param searchclause	the search clause to operate on.
*
* @exception standardexception		thrown on error
*/
void pullexpressions int numtables
valuenode searchclause
throws standardexception
andnode		thisand
andnode		topand
jbitset		newjbitset
predicate	newpred
booleanconstantnode	truenode   null
if  searchclause    null
topand    andnode  searchclause
searchclause   null
truenode    booleanconstantnode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean true
getcontextmanager
while  topand getrightoperand   instanceof andnode
/* break out the next top andnode */
thisand   topand
topand    andnode  topand getrightoperand
thisand setrightoperand null
/* set the rightoperand to true */
thisand setrightoperand truenode
/* add the top andnode to the predicatelist */
newjbitset   new jbitset numtables
newpred    predicate  getnodefactory   getnode
c_nodetypes predicate
thisand
newjbitset
getcontextmanager
addpredicate newpred
/* add the last top andnode to the predicatelist */
newjbitset   new jbitset numtables
newpred    predicate  getnodefactory   getnode
c_nodetypes predicate
topand
newjbitset
getcontextmanager
addpredicate newpred
/**
* xor frommap with the referenced table map in every remaining
* predicate in the list.  this is useful when pushing down
* multi-table predicates.
*
* @param frommap	the jbitset to xor with.
*/
public void xorreferencedset jbitset frommap
predicate		predicate
int size   size
for  int index   0  index < size  index
predicate    predicate  elementat index
if  sanitymanager debug
sanitymanager assert
frommap size      predicate getreferencedset   size
frommap size
predicate getreferencedset   size
predicate getreferencedset   xor frommap
private void countscanflags
predicate		predicate
int size   size
for  int index   0  index < size  index
predicate    predicate  elementat index
if  predicate isstartkey
numberofstartpredicates
if  predicate isstopkey
numberofstoppredicates
if  predicate isqualifier
numberofqualifiers
/**
* push all predicates, which can be pushed, into the underlying select.
* a predicate can be pushed into an underlying select if the source of
* every columnreference in the predicate is itself a columnreference.
*
* this is useful when attempting to push predicates into non-flattenable
* views or derived tables or into unions.
*
* @param select			the underlying selectnode.
* @param copypredicate		whether to make a copy of the predicate
*							before pushing
*
* @exception standardexception		thrown on error
*/
void pushexpressionsintoselect selectnode select  boolean copypredicate
throws standardexception
/* walk list backwards since we can delete while
* traversing the list.
*/
for  int index   size     1  index >  0  index
predicate	predicate
predicate    predicate  elementat index
collectnodesvisitor getcrs
new collectnodesvisitor columnreference class
predicate getandnode   accept getcrs
vector colrefs   getcrs getlist
/* state doesn't become true until we find the 1st
* columnreference.  (we probably will always find
* at least 1 cr, but just to be safe, ...)
*/
boolean state   colrefs size   > 0
if  state
for  enumeration e   colrefs elements    e hasmoreelements
columnreference ref    columnreference e nextelement
if   ref pointstocolumnreference
state   false
break
if   state
continue
if  copypredicate
// copy this predicate and push this instead
andnode andnode   predicate getandnode
valuenode leftoperand
columnreference crnode
binaryrelationaloperatornode opnode null
inlistoperatornode innode null
// make sure we are only pushing binary relations and inlist for
// copypredicate case. it should be benificial to push expressions that
// can be pushed, so they can be applied closer to the data.
if  andnode getleftoperand   instanceof binaryrelationaloperatornode
opnode    binaryrelationaloperatornode  andnode getleftoperand
// investigate using invariant interface to check rightoperand
if     opnode getleftoperand   instanceof columnreference
opnode getrightoperand   instanceof constantnode
opnode getrightoperand   instanceof parameternode
continue
crnode    columnreference  opnode getleftoperand
else if  andnode getleftoperand   instanceof inlistoperatornode
innode    inlistoperatornode  andnode getleftoperand
if     innode getrightoperandlist   isconstantexpression
continue
crnode    columnreference  innode getleftoperand
else
continue
// remap this crnode to underlying column reference in the select, if possible.
columnreference newcrnode   select findcolumnreferenceinresult crnode columnname
if  newcrnode    null
continue
// create a copy of the predicate to push down
// <column> <relop> <value> and true
if  andnode getleftoperand   instanceof binaryrelationaloperatornode
/* if the operator is a binary relational operator that was
* created for a probe predicate then we have to make a
* copy of the underlying in-list as well, so that we can
* give it the correct left operand (i.e. the new column
* reference node).  then we pass that copy into the new
* relational operator node.
*/
innode   opnode getinlistop
if  innode    null
innode   innode shallowcopy
innode setleftoperand newcrnode
binaryrelationaloperatornode newrelop    binaryrelationaloperatornode
getnodefactory   getnode
opnode getnodetype
newcrnode
opnode getrightoperand
innode
getcontextmanager
newrelop bindcomparisonoperator
leftoperand   newrelop
else
inlistoperatornode newinnode    inlistoperatornode
getnodefactory   getnode
c_nodetypes in_list_operator_node
newcrnode
innode getrightoperandlist
getcontextmanager
newinnode settype innode gettypeservices
leftoperand   newinnode
// convert the predicate into cnf form
valuenode truenode    valuenode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean true
getcontextmanager
andnode newand    andnode  getnodefactory   getnode
c_nodetypes and_node
leftoperand
truenode
getcontextmanager
newand postbindfixup
jbitset tablemap   new jbitset select referencedtablemap size
// use newly constructed predicate
predicate    predicate  getnodefactory   getnode
c_nodetypes predicate
newand
tablemap
getcontextmanager
else
// keep the counters up to date when removing a predicate
if  predicate isstartkey
numberofstartpredicates
if  predicate isstopkey
numberofstoppredicates
if  predicate isqualifier
numberofqualifiers
/* clear all of the scan flags since they may be different
* due to the splitting of the list.
*/
predicate clearscanflags
// remove this predicate from the list
removeelementat index
// push it into the select
select pushexpressionsintoselect predicate
/**
* mark all of the rcs and the rcs in their rc/vcn chain
* referenced in the predicate list as referenced.
*
* @exception standardexception		thrown on error
*/
void markreferencedcolumns
throws standardexception
collectnodesvisitor collectcrs
new collectnodesvisitor columnreference class
int size   size
for  int index   0  index < size  index
predicate predicate    predicate  elementat index
predicate getandnode   accept collectcrs
vector colrefs   collectcrs getlist
for  enumeration e   colrefs elements    e hasmoreelements
columnreference ref    columnreference e nextelement
ref getsource   markallrcsinchainreferenced
/**
* update the array of columns in = conditions with constants
* or correlation or join columns.  this is useful when doing
* subquery flattening on the basis of an equality condition.
*
* @param tablenumber	the tablenumber of the table from which
*						the columns of interest come from.
* @param eqoutercols	array of booleans for noting which columns
*						are in = predicates with constants or
*						correlation columns.
* @param tablenumbers	array of table numbers in this query block.
* @param resultcoltable tablenumber is the table the result columns are
*						coming from
*
* @exception standardexception		thrown on error
*/
void checktoppredicatesforequalsconditions
int         tablenumber
boolean   eqoutercols
int       tablenumbers
jbitset   tablecolmap
boolean     resultcoltable
throws standardexception
int size   size
for  int index   0  index < size  index
andnode and    andnode    predicate  elementat index   getandnode
and checktoppredicatesforequalsconditions
tablenumber  eqoutercols  tablenumbers  tablecolmap
resultcoltable
/**
* check if all of the predicates in the list are pushable.
*
* @return whether or not all of the predicates in the list are pushable.
*/
boolean allpushable
int size   size
for  int index   0  index < size  index
predicate		predicate    predicate  elementat index
if    predicate getpushable
return false
return true
/**
* build a list of pushable predicates, if any,
* that satisfy the referencedtablemap.
*
* @param referencedtablemap	the referenced table map
*
* @return a list of pushable predicates, if any,
* that satisfy the referencedtablemap.
*
* @exception standardexception		thrown on error
*/
predicatelist getpushablepredicates jbitset referencedtablemap
throws standardexception
predicatelist pushplist   null
// walk the list backwards because of possible deletes
for  int index   size     1  index >  0  index
predicate predicate    predicate  elementat index
if    predicate getpushable
continue
jbitset curbitset   predicate getreferencedset
/* do we have a match? */
if  referencedtablemap contains curbitset
/* add the matching predicate to the push list */
if  pushplist    null
pushplist    predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
pushplist addpredicate predicate
/* remap all of the columnreferences to point to the
* source of the values.
*/
remapcrsvisitor rcrv   new remapcrsvisitor true
predicate getandnode   accept rcrv
/* remove the matching predicate from the outer list */
removeelementat index
return pushplist
/**
* decrement the level of any crs from the subquery's
* from list that are interesting to transitive closure.
*
* @param fromlist	the subquery's from list.
* @param decrement	decrement size.
*/
void decrementlevel fromlist fromlist  int decrement
int tablenumbers   fromlist gettablenumbers
/* for each top level relop, find all top level
* crs from the subquery and decrement their
* nesting level.
*/
int size   size
for  int index   0  index < size  index
columnreference cr1   null
columnreference cr2   null
predicate predicate    predicate  elementat index
valuenode vn   predicate getandnode   getleftoperand
if  vn instanceof binaryoperatornode
binaryoperatornode bon    binaryoperatornode  vn
if  bon getleftoperand   instanceof columnreference
cr1    columnreference  bon getleftoperand
if  bon getrightoperand   instanceof columnreference
cr2    columnreference  bon getrightoperand
else if  vn instanceof unaryoperatornode
unaryoperatornode uon    unaryoperatornode  vn
if  uon getoperand   instanceof columnreference
cr1    columnreference  uon getoperand
/* see if any of the crs need to have their
* source level decremented.
*/
if  cr1    null
int sourcetable   cr1 gettablenumber
for  int inner   0  inner < tablenumbers length  inner
if  tablenumbers    sourcetable
cr1 setsourcelevel
cr1 getsourcelevel     decrement
break
if  cr2    null
int sourcetable   cr2 gettablenumber
for  int inner   0  inner < tablenumbers length  inner
if  tablenumbers    sourcetable
cr2 setsourcelevel
cr2 getsourcelevel     decrement
break
/**
* perform transitive closure on join clauses.  for each table in the query,
* we build a list of equijoin clauses of the form:
*		<columnreference> <=> <columnreference>
* each join clause is put on 2 lists since it joins 2 tables.
*
* we then walk the array of lists.  we first walk it as the outer list.
* for each equijoin predicate, we assign an equivalence class if it does
* not yet have one.  we then walk the predicate list (as middle) for the
* other table, searching for other equijoins with the middle table number
* and column number.  all such predicates are assigned the same
* equivalence class. we then walk the predicate list (as inner) for the
* other side of the middle predicate to see if we can find an equijoin
* between outer and inner.  if so, then we simply assign it to the same
* equivalence class.  if not, then we add the new equijoin clause.
*
* @param numtables	the number of tables in the query
* @param fromlist	the fromlist in question.
* @param cc		the compilercontext to use
*
* @exception standardexception		thrown on error
*/
void joinclausetransitiveclosure int numtables
fromlist fromlist  compilercontext cc
throws standardexception
// nothing to do if < 3 tables
if  fromlist size   < 3
return
/* create an array of numtables predicatelists to hold the join clauses. */
predicatelist joinclauses   new predicatelist
for  int index   0  index < numtables  index
joinclauses   new predicatelist
/* pull the equijoin clauses, putting each one in the list for
* each of the tables being joined.
*/
int size   size
for  int index   0  index < size  index
predicate predicate    predicate  elementat index
valuenode vn   predicate getandnode   getleftoperand
if     vn isbinaryequalsoperatornode
continue
/* is this an equijoin clause between 2 columnreferences? */
binaryrelationaloperatornode equals
binaryrelationaloperatornode  vn
valuenode left   equals getleftoperand
valuenode right   equals getrightoperand
if   left  instanceof columnreference
right instanceof columnreference
columnreference leftcr    columnreference  left
columnreference rightcr    columnreference  right
if  leftcr getsourcelevel      rightcr getsourcelevel
leftcr gettablenumber      rightcr gettablenumber
// add the equijoin clause to each of the lists
joinclauses addelement predicate
joinclauses addelement predicate
continue
/* walk each of the predicatelists, using each 1 as the starting point
* of an equivalence class.
*/
for  int index   0  index < numtables  index
predicatelist outerjcl   joinclauses
// skip the empty lists
if  outerjcl size      0
continue
/* put all of the join clauses that already have an equivalence
* class at the head of the outer list to optimize search.
*/
vector movepreds   new vector
for  int jcindex   outerjcl size     1  jcindex >  0  jcindex
predicate predicate    predicate  outerjcl elementat jcindex
if  predicate getequivalenceclass       1
outerjcl removeelementat jcindex
movepreds addelement predicate
for  int mpindex   0  mpindex < movepreds size    mpindex
outerjcl insertelementat
predicate  movepreds elementat mpindex   0
// walk this list as the outer
for  int outerindex   0  outerindex < outerjcl size    outerindex
columnreference innercr   null
columnreference outercr   null
int outertablenumber   index
int middletablenumber
int outercolumnnumber
int middlecolumnnumber
int outerec
/* assign an equivalence class to those predicates
* that have not already been assigned an equivalence class.
*/
predicate outerp    predicate  outerjcl elementat outerindex
if  outerp getequivalenceclass       1
outerp setequivalenceclass cc getnextequivalenceclass
outerec   outerp getequivalenceclass
// get the table and column numbers
binaryrelationaloperatornode equals
binaryrelationaloperatornode  outerp getandnode   getleftoperand
columnreference leftcr    columnreference  equals getleftoperand
columnreference rightcr    columnreference  equals getrightoperand
if  leftcr gettablenumber      outertablenumber
outercolumnnumber   leftcr getcolumnnumber
middletablenumber   rightcr gettablenumber
middlecolumnnumber   rightcr getcolumnnumber
outercr   leftcr
else
outercolumnnumber   rightcr getcolumnnumber
middletablenumber   leftcr gettablenumber
middlecolumnnumber   leftcr getcolumnnumber
outercr   rightcr
/* walk the other list as the middle to find other join clauses
* in the chain/equivalence class
*/
predicatelist middlejcl   joinclauses
for  int middleindex   0  middleindex < middlejcl size    middleindex
/* skip those predicates that have already been
* assigned a different equivalence class.
*/
predicate middlep    predicate  middlejcl elementat middleindex
if  middlep getequivalenceclass       1
middlep getequivalenceclass      outerec
continue
int innertablenumber
int innercolumnnumber
// get the table and column numbers
binaryrelationaloperatornode middleequals
binaryrelationaloperatornode  middlep getandnode   getleftoperand
columnreference mleftcr    columnreference  middleequals getleftoperand
columnreference mrightcr    columnreference  middleequals getrightoperand
/* find the other side of the equijoin, skipping this predicate if
* not on middlecolumnnumber.
*/
if  mleftcr gettablenumber      middletablenumber
if  mleftcr getcolumnnumber      middlecolumnnumber
continue
innertablenumber   mrightcr gettablenumber
innercolumnnumber   mrightcr getcolumnnumber
else
if  mrightcr getcolumnnumber      middlecolumnnumber
continue
innertablenumber   mleftcr gettablenumber
innercolumnnumber   mleftcr getcolumnnumber
// skip over outertablenumber.outercolumnnumber = middletablenumber.middlecolumnnumber
if  outertablenumber    innertablenumber
outercolumnnumber    innercolumnnumber
continue
// put this predicate into the outer equivalence class
middlep setequivalenceclass outerec
/* now go to the inner list and see if there is an equijoin
* between inner and outer on innercolumnnumber and outercolumnnumber.
* if so, then we continue our walk across middle, otherwise we
* add a new equijoin to both the inner and outer lists before
* continuing to walk across middle.
*/
int newtablenumber
int newcolumnnumber
predicate innerp   null
predicatelist innerjcl   joinclauses
int innerindex   0
for     innerindex < innerjcl size    innerindex
innerp    predicate  innerjcl elementat innerindex
// skip over predicates with other equivalence classes
if  innerp getequivalenceclass       1
innerp getequivalenceclass      outerec
continue
/* now we see if the inner predicate completes the loop.
* if so, then add it to the outer equivalence class
* and stop.
*/
// get the table and column numbers
binaryrelationaloperatornode innerequals
binaryrelationaloperatornode  innerp getandnode   getleftoperand
columnreference ileftcr    columnreference  innerequals getleftoperand
columnreference irightcr    columnreference  innerequals getrightoperand
if  ileftcr gettablenumber      innertablenumber
if  ileftcr getcolumnnumber      innercolumnnumber
continue
newtablenumber   irightcr gettablenumber
newcolumnnumber   irightcr getcolumnnumber
innercr   ileftcr
else
if  irightcr getcolumnnumber      innercolumnnumber
continue
newtablenumber   ileftcr gettablenumber
newcolumnnumber   ileftcr getcolumnnumber
innercr   irightcr
// did we find the equijoin between inner and outer
if  newtablenumber    outertablenumber
newcolumnnumber    outercolumnnumber
break
// did we find an equijoin on inner and outer
if  innerindex    innerjcl size
// match found
// put this predicate into the outer equivalence class
innerp setequivalenceclass outerec
continue
// no match, add new equijoin
// build a new predicate
binaryrelationaloperatornode newequals    binaryrelationaloperatornode
getnodefactory   getnode
c_nodetypes binary_equals_operator_node
outercr getclone
innercr getclone
getcontextmanager
newequals bindcomparisonoperator
/* create the and */
valuenode truenode    valuenode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean true
getcontextmanager
andnode newand    andnode  getnodefactory   getnode
c_nodetypes and_node
newequals
truenode
getcontextmanager
newand postbindfixup
// add a new predicate to both the equijoin clauses and this list
jbitset tablemap   new jbitset numtables
newand categorize tablemap  false
predicate newpred    predicate  getnodefactory   getnode
c_nodetypes predicate
newand
tablemap
getcontextmanager
newpred setequivalenceclass outerec
addpredicate newpred
/* add the new predicate right after the outer position
* so that we can follow all of the predicates in equivalence
* classes before those that do not yet have equivalence classes.
*/
if  outerindex    outerjcl size     1
outerjcl insertelementat newpred  outerindex   1
else
outerjcl addelement newpred
innerjcl addelement newpred
/**
* perform transitive closure on search clauses.  we build a
* list of search clauses of the form:
*		<columnreference> <relationaloperator> [<constantnode>]
* we also build a list of equijoin conditions of form:
*		<columnreference1> = <columnreference2>
* where both columns are from different tables in the same query block.
* for each search clause in the list, we search the equijoin list to see
* if there is an equijoin clause on the same column.  if so, then we
* search the search clause list for a search condition on the column
* being joined against with the same relation operator and constant.  if
* a match is found, then there is no need to add a new predicate.
* otherwise, we add a new search condition on the column being joined
* with.  in either case, if the relational operator in the search
* clause is an "=" then we mark the equijoin clause as being redundant.
* redundant equijoin clauses will be removed at the end of the search as
* they are * unnecessary.
*
* @param numtables			the number of tables in the query
* @param hashjoinspecified	whether or not user specified a hash join
*
* @exception standardexception		thrown on error
*/
void searchclausetransitiveclosure int numtables  boolean hashjoinspecified
throws standardexception
predicatelist	equijoinclauses   new predicatelist
predicatelist	searchclauses   new predicatelist
relationaloperator	equalsnode   null
int size   size
for  int index   0  index < size  index
predicate		predicate    predicate  elementat index
andnode			andnode   predicate getandnode
// skip anything that's not a relationaloperator
if   predicate isrelationaloppredicate
continue
relationaloperator operator    relationaloperator  andnode getleftoperand
// is this an equijoin?
if    valuenode operator  isbinaryequalsoperatornode
binaryrelationaloperatornode equals    binaryrelationaloperatornode  operator
// remember any equals node for redundancy check at end
equalsnode   equals
valuenode left   equals getleftoperand
valuenode right   equals getrightoperand
if   left instanceof columnreference    right instanceof columnreference
columnreference leftcr    columnreference  left
columnreference rightcr    columnreference  right
if  leftcr getsourcelevel      rightcr getsourcelevel
leftcr gettablenumber      rightcr gettablenumber
equijoinclauses addelement predicate
continue
// is this a usable search clause?
if  operator instanceof unarycomparisonoperatornode
if    unarycomparisonoperatornode  operator  getoperand   instanceof columnreference
searchclauses addelement predicate
continue
else if  operator instanceof binarycomparisonoperatornode
binarycomparisonoperatornode bcon    binarycomparisonoperatornode  operator
valuenode left   bcon getleftoperand
valuenode right   bcon getrightoperand
// resolve: consider using variant type of the expression, instead of
// constantnode or parameternode in the future.
if  left instanceof columnreference
right instanceof constantnode    right instanceof parameternode
searchclauses addelement predicate
else if  right instanceof constantnode    left instanceof columnreference
// put the columnreference on the left to simplify things
bcon swapoperands
searchclauses addelement predicate
continue
// nothing to do if no search clauses or equijoin clauses
if  equijoinclauses size      0    searchclauses size      0
return
/* now we do the real work.
* note: we can append to the searchclauses while walking
* them, thus we cannot cache the value of size().
*/
for  int scindex   0  scindex < searchclauses size    scindex
columnreference searchcr
datavaluedescriptor searchodv   null
relationaloperator ro    relationaloperator
andnode
predicate  searchclauses elementat scindex   getandnode    getleftoperand
// find the columnreference and constant value, if any, in the search clause
if  ro instanceof unarycomparisonoperatornode
searchcr    columnreference    unarycomparisonoperatornode  ro  getoperand
else
searchcr    columnreference    binarycomparisonoperatornode  ro  getleftoperand
// don't get value for parameternode since not known yet.
if    binarycomparisonoperatornode  ro  getrightoperand   instanceof constantnode
constantnode currcn    constantnode    binarycomparisonoperatornode  ro  getrightoperand
searchodv    datavaluedescriptor  currcn getvalue
else searchodv   null
// cache the table and column numbers of searchcr
int tablenumber   searchcr gettablenumber
int colnumber   searchcr getcolumnnumber
// look for any equijoin clauses of interest
int ejcsize   equijoinclauses size
for  int ejcindex   0  ejcindex < ejcsize  ejcindex
/* skip the current equijoin clause if it has already been used
* when adding a new search clause of the same type
* via transitive closure.
* note: we check the type of the search clause instead of just the
* fact that a search clause was added because multiple search clauses
* can get added when preprocessing like and between.
*/
predicate predicate    predicate  equijoinclauses elementat ejcindex
if  predicate transitivesearchclauseadded ro
continue
binaryrelationaloperatornode equals    binaryrelationaloperatornode
andnode
predicate getandnode    getleftoperand
columnreference leftcr    columnreference  equals getleftoperand
columnreference rightcr    columnreference  equals getrightoperand
columnreference othercr
if  leftcr gettablenumber      tablenumber
leftcr getcolumnnumber      colnumber
othercr   rightcr
else if  rightcr gettablenumber      tablenumber
rightcr getcolumnnumber      colnumber
othercr   leftcr
else
// this is not a matching equijoin clause
continue
/* at this point we've found a search clause and an equijoin that
* are candidates for adding a new search clause via transitive
* closure.  look to see if a matching search clause already
* exists on the other table.  if not, then add one.
* note: in either case we mark the join clause has having added
* a search clause of this type to short circuit any future searches
*/
predicate settransitivesearchclauseadded ro
boolean match   false
columnreference searchcr2   null
relationaloperator ro2   null
int scsize   searchclauses size
for  int scindex2   0  scindex2 < scsize  scindex2
datavaluedescriptor currodv   null
ro2    relationaloperator
andnode
predicate  searchclauses elementat scindex2   getandnode    getleftoperand
// find the columnreference in the search clause
if  ro2 instanceof unarycomparisonoperatornode
searchcr2    columnreference    unarycomparisonoperatornode  ro2  getoperand
else
searchcr2    columnreference    binarycomparisonoperatornode  ro2  getleftoperand
if    binarycomparisonoperatornode  ro2  getrightoperand   instanceof constantnode
constantnode currcn    constantnode    binarycomparisonoperatornode  ro2  getrightoperand
currodv    datavaluedescriptor  currcn getvalue
else currodv   null
/* is this a match? a match is a search clause with
* the same operator on the same column with a comparison against
* the same value.
*/
if  searchcr2 gettablenumber      othercr gettablenumber
searchcr2 getcolumnnumber      othercr getcolumnnumber
currodv    null    searchodv    null    currodv compare searchodv     0
currodv    null    searchodv    null
ro2 getoperator      ro getoperator
ro2 getclass   getname   equals ro getclass   getname
match   true
break
// add the new search clause if no match found
if    match
// build a new predicate
relationaloperator roclone   ro gettransitivesearchclause  columnreference  othercr getclone
/* set type info for the operator node */
if  roclone instanceof binarycomparisonoperatornode
binarycomparisonoperatornode  roclone  bindcomparisonoperator
else
unarycomparisonoperatornode  roclone  bindcomparisonoperator
/* create the and */
valuenode truenode    valuenode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean true
getcontextmanager
andnode newand    andnode  getnodefactory   getnode
c_nodetypes and_node
roclone
truenode
getcontextmanager
newand postbindfixup
// add a new predicate to both the search clauses and this list
jbitset tablemap   new jbitset numtables
newand categorize tablemap  false
predicate newpred    predicate  getnodefactory   getnode
c_nodetypes predicate
newand
tablemap
getcontextmanager
addpredicate newpred
searchclauses addelement newpred
/* finally, we eliminate any equijoin clauses made redundant by
* transitive closure, but only if the user did not specify a hash join
* in the current query block.
*/
if  hashjoinspecified
return
/* walk list backwards since we can delete while
* traversing the list.
*/
for  int index   size     1  index >  0  index
predicate predicate    predicate  elementat index
if  predicate transitivesearchclauseadded equalsnode
removeelementat index
/**
* remove redundant predicates.  a redundant predicate has an equivalence
* class (!= -1) and there are other predicates in the same equivalence
* class after it in the list.  (actually, we remove all of the predicates
* in the same equivalence class that appear after this one.)
*/
void removeredundantpredicates
/* walk backwards since we may remove 1 or more
* elements for each predicate in the outer pass.
*/
int outer   size     1
while  outer >  0
predicate predicate    predicate  elementat outer
int equivalenceclass   predicate getequivalenceclass
if  equivalenceclass     1
outer
continue
// walk the rest of the list backwards.
for  int inner   outer   1  inner >  0  inner
predicate innerpredicate    predicate  elementat inner
if  innerpredicate getequivalenceclass      equivalenceclass
/* only 1 predicate per column can be marked as a start
* and/or a stop position.
* when removing a redundant predicate, we need to make sure
* that the outer predicate gets marked as a start and/or
* stop key if the inner predicate is a start and/or stop
* key.  in this case, we are not changing the number of
* start and/or stop positions, so we leave that count alone.
*/
if  innerpredicate isstartkey
predicate markstartkey
if  innerpredicate isstopkey
predicate markstopkey
if  innerpredicate isstartkey      innerpredicate isstopkey
if  innerpredicate isqualifier
// bug 5868 - query returns duplicate rows. in order to fix this,
// if the inner predicate is a qualifer along with being a start and/or stop,
// then mark the outer predicate as a qualifer too(along with marking it as a start
// and/or stop) if it is not already marked as qualifer and increment the qualifiers counter
// the reason we do this is that a start and/or stop key is not equivalent to
// a qualifier. in the orderusefulpredicates method in this class(comment on line 786),
// we mark a start/stop as qualifier if we have already seen a previous column in composite
// index whose relops do not include '=' or is null. and hence we should not disregard
// the qualifier flag of inner predicate
if   predicate isqualifier
predicate markqualifier
numberofqualifiers
/*
* if the redundant predicate is a qualifier, then we must
* decrement the qualifier count.  (remaining predicate is
* already marked correctly.)
*/
if  innerpredicate isqualifier
numberofqualifiers
removeelementat inner
outer
outer
/**
* @see optimizablepredicatelist#transferpredicates
*
* @exception standardexception		thrown on error
*/
public void transferpredicates optimizablepredicatelist otherlist
jbitset referencedtablemap
optimizable table
throws standardexception
predicate		predicate
predicatelist	theotherlist    predicatelist  otherlist
/* walk list backwards since we can delete while
* traversing the list.
*/
for  int index   size     1  index >  0  index
predicate    predicate  elementat index
if  sanitymanager debug
if  referencedtablemap size      predicate getreferencedset   size
sanitymanager throwassert
referencedtablemap size
predicate getreferencedset   size
if  referencedtablemap contains predicate getreferencedset
// we need to keep the counters up to date when removing a predicate
if  predicate isstartkey
numberofstartpredicates
if  predicate isstopkey
numberofstoppredicates
if  predicate isqualifier
numberofqualifiers
/* clear all of the scan flags since they may be different
* due to the splitting of the list.
*/
predicate clearscanflags
// do the actual xfer
theotherlist addpredicate predicate
removeelementat index
// order the useful predicates on the other list
accesspath ap   table gettrulythebestaccesspath
theotherlist orderusefulpredicates
table
ap getconglomeratedescriptor
false
ap getnonmatchingindexscan
ap getcoveringindexscan
// count the start/stop positions and qualifiers
theotherlist countscanflags
/**
* @see optimizablepredicatelist#transferallpredicates
*
* @exception standardexception		thrown on error
*/
public void transferallpredicates optimizablepredicatelist otherlist
throws standardexception
predicatelist	theotherlist    predicatelist  otherlist
int size   size
for  int index   0  index < size  index
predicate predicate    predicate  elementat index
/*
** clear all of the scan flags since they may be different
** when the new list is re-classified
*/
predicate clearscanflags
// add the predicate to the other list
theotherlist addpredicate predicate
// remove all of the predicates from this list
removeallelements
/*
** this list is now empty, so there are no start predicates,
** stop predicates, or qualifiers.
*/
numberofstartpredicates   0
numberofstoppredicates   0
numberofqualifiers  0
/**
* @see optimizablepredicatelist#copypredicatestootherlist
*
* @exception standardexception		thrown on error
*/
public void copypredicatestootherlist optimizablepredicatelist otherlist
throws standardexception
for  int i   0  i < size    i
otherlist addoptpredicate getoptpredicate i
/**
* @see optimizablepredicatelist#isredundantpredicate
*/
public boolean isredundantpredicate int prednum
predicate pred    predicate  elementat prednum
if  pred getequivalenceclass       1
return false
for  int index   0  index < prednum  index
if     predicate  elementat index   getequivalenceclass      pred getequivalenceclass
return true
return false
/**
* @see optimizablepredicatelist#setpredicatesandproperties
*
* @exception standardexception		thrown on error
*/
public void setpredicatesandproperties optimizablepredicatelist otherlist
throws standardexception
predicatelist theotherlist    predicatelist  otherlist
theotherlist removeallelements
for  int i   0  i < size    i
theotherlist addoptpredicate getoptpredicate i
theotherlist numberofstartpredicates   numberofstartpredicates
theotherlist numberofstoppredicates   numberofstoppredicates
theotherlist numberofqualifiers   numberofqualifiers
/** @see optimizablepredicatelist#startoperator */
public int startoperator optimizable opttable
int	startoperator
/*
** this is the value we will use if there are no keys.  it doesn't
** matter what it is, as long as the operator is one of gt or ge
** (to match the openscan() interface).
*/
startoperator   scancontroller gt
int size   size
/* beetle 4572. start operator should be the last start key column's
* start operator.  note that all previous ones should be ge.
*/
for  int index   size   1  index >  0  index
predicate pred     predicate  elementat index
if     pred isstartkey
continue
startoperator   pred getstartoperator opttable
break
return startoperator
/**
* @see optimizablepredicatelist#generatestopkey
*
* @exception standardexception		thrown on error
*/
public void generatestopkey expressionclassbuilderinterface acbi
methodbuilder mb
optimizable opttable
throws standardexception
expressionclassbuilder acb    expressionclassbuilder  acbi
/*
** to make the stop-key allocating function we cycle through
** the predicates and generate the function and initializer:
**
** private execindexrow exprn()
** { execindexrow r = getexecutionfactory().getindexablerow(# stop keys);
**   for (pred = each predicate in list)
**	 {
**		if (pred.isstartkey())
**		{
**			pred.generatekey(acb);
**		}
**	 }
** }
**
** if there are no start predicates, we do not generate anything.
*/
if  numberofstoppredicates    0
/* this sets up the method and the static field */
methodbuilder exprfun   acb newexprfun
/* now we fill in the body of the method */
localfield rowfield
generateindexablerow acb  numberofstoppredicates
int	colnum   0
int size   size
for  int index   0  index < size  index
predicate pred     predicate  elementat index
if     pred isstopkey
continue
generatesetcolumn acb  exprfun  colnum
pred  opttable  rowfield  false
colnum
if  sanitymanager debug
sanitymanager assert colnum    numberofstoppredicates
finishkey acb  mb  exprfun  rowfield
return
mb pushnull classname generatedmethod
/** @see optimizablepredicatelist#stopoperator */
public int stopoperator optimizable opttable
int	stopoperator
/*
** this is the value we will use if there are no keys.  it doesn't
** matter what it is, as long as the operator is one of gt or ge
** (to match the openscan() interface).
*/
stopoperator   scancontroller gt
int size   size
/* beetle 4572. stop operator should be the last start key column's
* stop operator.  note that all previous ones should be gt.
*/
for  int index   size   1  index >  0  index
predicate pred     predicate  elementat index
if     pred isstopkey
continue
stopoperator   pred getstopoperator opttable
break
return stopoperator
private void generatesinglequalifiercode
methodbuilder           consmb
optimizable             opttable
boolean                 absolute
expressionclassbuilder  acb
relationaloperator      or_node
localfield              qualfield
int                     array_idx_1
int                     array_idx_2
throws standardexception
consmb getfield qualfield      first arg for setqualifier
// get instance for getqualifier call
consmb pushthis
consmb callmethod
vmopcode invokevirtual
acb getbaseclassname
executionfactory module  0
// column id - first arg
if  absolute
or_node generateabsolutecolumnid consmb  opttable
else
or_node generaterelativecolumnid consmb  opttable
// operator - second arg
or_node generateoperator consmb  opttable
// method to evaluate qualifier -- third arg
or_node generatequalmethod acb  consmb  opttable
// receiver for above method - fourth arg
acb pushthisasactivation consmb
// ordered nulls? - fifth arg
or_node generateorderednulls consmb
/*
** "unknown" return value. for qualifiers,
** we never want to return rows where the
** result of a comparison is unknown.
** but we can't just generate false, because
** the comparison result could be negated.
** so, generate the same as the negation
** operand - that way, false will not be
** negated, and true will be negated to false.
*/
or_node generatenegate consmb  opttable
/* negate comparison result? */
or_node generatenegate consmb  opttable
/* varianttype for qualifier's orderable */
consmb push or_node getorderablevarianttype opttable
consmb callmethod
vmopcode invokeinterface
executionfactory module
classname qualifier  8
// result of getqualifier() is second arg for setqualifier
consmb push array_idx_1            third  arg for setqualifier
consmb push array_idx_2            fourth arg for setqualifier
consmb callmethod
vmopcode invokestatic
acb getbaseclassname
4
/**
* if there is an in-list probe predicate in this list then generate
* the corresponding in-list values as a datavaluedescriptor array,
* to be used for probing at execution time.  also generate a boolean
* value indicating whether or not the values are already in sorted
* order.
*
* assumption is that by the time we get here there is at most one
* in-list probe predicate in this list.
*
* @param acb the activationclassbuilder for the class we're building
* @param mb the methodbuilder for the method we're building
*/
protected void generateinlistvalues expressionclassbuilder acb
methodbuilder mb  throws standardexception
for  int index   size     1  index >  0  index
predicate pred    predicate elementat index
// don't do anything if it's not an in-list probe predicate.
if   pred isinlistprobepredicate
continue
/* we're going to generate the relevant code for the probe
* predicate below, so we no longer need it to be in the
* list.  remove it now.
*/
removeoptpredicate pred
/* this list is a store restriction list for a specific base
* table, and we can only have one probe predicate per base
* table (any others, if any, will be "reverted" back to
* their original inlistoperatornodes and generated as
* qualifiers). so make sure there are no other probe preds
* in this list.
*/
if  sanitymanager debug
for  int i   0  i < index  i
if    predicate elementat i   isinlistprobepredicate
sanitymanager throwassert
inlistoperatornode ilon   pred getsourceinlist
mb getfield ilon generatelistasarray acb  mb
mb push ilon isordered
return
/* if we get here then we didn't find any probe predicates.  but
* if that's true then we shouldn't have made it to this method
* to begin with.
*/
if  sanitymanager debug
sanitymanager throwassert
/**
* @see optimizablepredicatelist#generatequalifiers
*
* @exception standardexception		thrown on error
*/
public void generatequalifiers
expressionclassbuilderinterface acbi
methodbuilder mb
optimizable opttable
boolean absolute
throws standardexception
expressionclassbuilder  acb            expressionclassbuilder  acbi
string                  retvaltype    classname qualifier
methodbuilder           consmb        acb getconstructor
methodbuilder           executemb     acb getexecutemethod
/* create and initialize the array of qualifiers */
localfield qualfield
acb newfielddeclaration modifier private  retvaltype
/*
** stick a reinitialize of the qualifier array in execute().
** done because although we call exec/qualifier.clearorderablecache()
** before each query, we only clear the cache for variant and
** scan_invariant qualifiers.  however, each time the same
** statement is executed, even the query_invariant qualifiers
** need to be flushed.  for example:
**	prepare select c1 from t where c1 = (select max(c1) from t) as p;
**	execute p; -- we now have the materialized subquery result (1)
**			   -- in our predicate
**	insert into t values 666;
**	execute p; -- we need to clear out 1 and recache the subq result
*/
// pushcompiler
//		if (mb == executemb) {
//			system.out.println("adding code to method in two places");
//			new throwable().printstacktrace();
//		}
//
// generate code to reinitializequalifiers(qualifier[][] qualifiers)
executemb getfield qualfield      first arg to reinitializequalifiers
executemb callmethod
vmopcode invokestatic
acb getbaseclassname          1
/*
** initialize the qualifier array to a new qualifier[][] if
** there are any qualifiers.  it is automatically initialized to
** null if it isn't explicitly initialized.
*/
if  numberofqualifiers    0
if  sanitymanager debug
if  numberofqualifiers > size
sanitymanager throwassert
numberofqualifiers
size              this hashcode
// determine number of leading and qualifiers, and subsequent
// trailing or qualifiers.
int num_of_or_conjunctions   0
for  int i   0  i < numberofqualifiers  i
if    predicate  elementat i   isorlist
num_of_or_conjunctions
/* assign the initializer to the qualifier[] field */
consmb pushnewarray
classname qualifier       int  num_of_or_conjunctions   1
consmb setfield qualfield
// allocate qualifiers[0] which is an entry for each of the leading
// and clauses.
consmb getfield qualfield                  1st arg allocatequalarray
consmb push  int  0                        2nd arg allocatequalarray
consmb push  int  numberofqualifiers   num_of_or_conjunctions       3rd arg allocatequalarray
consmb callmethod
vmopcode invokestatic
acb getbaseclassname
3
/* sort the qualifiers by "selectivity" before generating.
* we want the qualifiers ordered by selectivity with the
* most selective ones first.  there are 3 groups of qualifiers:
* = and is null are the most selective,
* <> and is not null are the least selective and
* all of the other relops are in between.
* we break the list into 4 parts (3 types of qualifiers and
* then everything else) and then rebuild the ordered list.
* resolve - we will eventually want to order the qualifiers
* by (column #, selectivity) once the store does just in time
* instantiation.
*/
if  numberofqualifiers > 0
orderqualifiers
/* generate each of the qualifiers, if any */
// first generate the "leading" and qualifiers.
int	qualnum   0
int size   size
boolean gotorqualifier   false
for  int index   0  index < size  index
predicate pred     predicate  elementat index
if   pred isqualifier
continue
else if  pred isorlist
gotorqualifier   true
// will generate the or qualifiers below.
break
else
generatesinglequalifiercode
consmb
opttable
absolute
acb
pred getrelop
qualfield
0
qualnum
qualnum
if  gotorqualifier
// process each set of or's into a list which are and'd.  each
// predicate will become an array list in the qualifier array of
// array's.
//
// the first list of and's went into qual[0][0...n]
// now each subquent predicate is actually a list of or's so
// will be passed as:
//     1st or predicate -> qual[1][0.. number of or terms]
//     2nd or predicate -> qual[2][0.. number of or terms]
//     ...
//
int and_idx   1
// the remaining qualifiers must all be or predicates, which
// are pushed slightly differently than the leading and qualifiers.
for  int index   qualnum  index < size  index    and_idx
predicate pred     predicate  elementat index
if  sanitymanager debug
sanitymanager assert pred isorlist
// create an arraylist of the or nodes.  we need the count
// of or's in order to first generate the allocatequalarray()
// call, then we walk the list assigning each of the or's to
// entries in the array in generatesinglequalifiercode().
arraylist a_list   new arraylist
querytreenode node   pred getandnode   getleftoperand
while  node instanceof ornode
ornode or_node    ornode  node
// the left operand of or node is one of the terms,
// (ie. a = 1)
if  or_node getleftoperand   instanceof relationaloperator
a_list add or_node getleftoperand
// the next or node in the list if linked to the right.
node   or_node getrightoperand
// allocate an array to hold each of the terms of this or,
// clause.  ie. (a = 1 or b = 2), will allocate a 2 entry array.
consmb getfield qualfield             1st arg allocatequalarray
consmb push  int  and_idx             2nd arg allocatequalarray
consmb push  int  a_list size         3rd arg allocatequalarray
consmb callmethod
vmopcode invokestatic
acb getbaseclassname
3
// finally transfer the nodes to the 2-d qualifier
for  int i   0  i < a_list size    i
generatesinglequalifiercode
consmb
opttable
absolute
acb
relationaloperator  a_list get i
qualfield
and_idx
i
qualnum
if  sanitymanager debug
sanitymanager assert qualnum    numberofqualifiers
qualnum
numberofqualifiers
/*
** return a reference to the field that holds the initialized
** array of qualifiers.
*/
mb getfield qualfield
/* sort the qualifiers by "selectivity" before generating.
* we want the qualifiers ordered by selectivity with the
* most selective ones first.  there are 3 groups of qualifiers:
* = and is null are the most selective,
* <> and is not null are the least selective and
* all of the other relops are in between.
* we break the list into 4 parts (3 types of qualifiers and
* then everything else) and then rebuild the ordered list.
* resolve - we will eventually want to order the qualifiers
* by (column #, selectivity) once the store does just in time
* instantiation.
*/
private static final int    qualifier_order_equals        0
private static final int    qualifier_order_other_relop   1
private static final int    qualifier_order_not_equals    2
private static final int    qualifier_order_non_qual      3
private static final int    qualifier_order_or_clause     4
private static final int    qualifier_num_categories      5
private void orderqualifiers
// sort the predicates into buckets, sortlist[0] is the most
// selective, while sortlist[4] is the least restrictive.
//
//     sortlist[0]:  "= and is null"
//     sortlist[1]:  "a set of or'd conjunctions"
//     sortlist[2]:  "all other relop's"
//     sortlist[3]:  "<> and is not null"
//     sortlist[4]:  "everything else"
predicatelist sortlist   new predicatelist
for  int i   sortlist length   1  i >  0  i
sortlist   new predicatelist
int predindex
int size   size
for  predindex   0  predindex < size  predindex
predicate pred    predicate  elementat predindex
if    pred isqualifier
sortlist addelement pred
continue
andnode node   pred getandnode
if    node getleftoperand   instanceof ornode
relationaloperator relop
relationaloperator  node getleftoperand
int op   relop getoperator
switch  op
case relationaloperator equals_relop
case relationaloperator is_null_relop
sortlist addelement pred
break
case relationaloperator not_equals_relop
case relationaloperator is_not_null_relop
sortlist addelement pred
break
default
sortlist addelement pred
else
sortlist addelement pred
/* rebuild the list */
predindex   0
for  int index   0  index < qualifier_num_categories  index
for  int items   0  items < sortlist size    items
setelementat sortlist elementat items   predindex
/**
* @see optimizablepredicatelist#generatestartkey
*
* @exception standardexception		thrown on error
*/
public void generatestartkey expressionclassbuilderinterface acbi
methodbuilder mb
optimizable opttable
throws standardexception
expressionclassbuilder acb    expressionclassbuilder  acbi
/*
** to make the start-key allocating function we cycle through
** the predicates and generate the function and initializer:
**
** private object exprn()
** { execindexrow r = getexecutionfactory().getindexablerow(# start keys);
**   for (pred = each predicate in list)
**	 {
**		if (pred.isstartkey())
**		{
**			pred.generatekey(acb);
**		}
**	 }
** }
**
** if there are no start predicates, we do not generate anything.
*/
if  numberofstartpredicates    0
/* this sets up the method and the static field */
methodbuilder exprfun   acb newexprfun
/* now we fill in the body of the method */
localfield rowfield   generateindexablerow acb  numberofstartpredicates
int	colnum   0
int size   size
for  int index   0  index < size  index
predicate pred     predicate  elementat index
if     pred isstartkey
continue
generatesetcolumn acb  exprfun  colnum
pred  opttable  rowfield  true
colnum
if  sanitymanager debug
sanitymanager assert colnum    numberofstartpredicates
finishkey acb  mb  exprfun  rowfield
return
mb pushnull classname generatedmethod
/**
* @see optimizablepredicatelist#samestartstopposition
*
* @exception standardexception		thrown on error
*/
public boolean samestartstopposition
throws standardexception
/* we can only use the same row for both the
* start and stop positions if the number of
* start and stop predicates are the same.
*/
if  numberofstartpredicates    numberofstoppredicates
return false
/* we can only use the same row for both the
* start and stop positions when a predicate is
* a start key iff it is a stop key.
*/
int size   size
for  int index   0  index < size  index
predicate pred     predicate  elementat index
if    pred isstartkey         pred isstopkey
pred isstopkey         pred isstartkey
return false
/* "in"'s dynamic start and stop key are not the same, beetle 3858
*/
if  pred getandnode   getleftoperand   instanceof inlistoperatornode
return false
return true
/**
* generate the indexable row for a start key or stop key.
*
* @param acb	the activationclassbuilder for the class we're building
* @param numberofcolumns	the number of columns in the key
*
* @return	the field that holds the indexable row
*/
private localfield generateindexablerow expressionclassbuilder acb  int numberofcolumns
methodbuilder mb   acb getconstructor
/*
** generate a call to get an indexable row
** with the given number of columns
*/
acb pushgetexecutionfactoryexpression mb      instance
mb push numberofcolumns
mb callmethod vmopcode invokeinterface  classname executionfactory     classname execindexrow  1
/*
** assign the indexable row to a field, and put this assignment into
** the constructor for the activation class.  this way, we only have
** to get the row once.
*/
localfield field
acb newfielddeclaration modifier private  classname execindexrow
mb setfield field
return field
/**
* generate the code to set the value from a predicate in an index column.
*
* @param acb	the activationclassbuilder for the class we're building
* @param exprfun	the methodbuilder for the method we're building
* @param columnnumber	the position number of the column we're setting
*						the value in (zero-based)
* @param pred	the predicate with the value to put in the index column
* @param opttable	the optimizable table the column is in
* @param rowfield	the field that holds the indexable row
* @param isstartkey are we generating start or stop key?  this information
*					 is useful for "in"'s dynamic start/stop key, bug 3858
*
* @exception standardexception		thrown on error
*/
private void generatesetcolumn expressionclassbuilder acb
methodbuilder exprfun
int columnnumber
predicate pred
optimizable opttable
localfield rowfield
boolean isstartkey
throws standardexception
methodbuilder mb
/* code gets generated in constructor if comparison against
* a constant, otherwise gets generated in the current
* statement block.
*/
boolean withknownconstant   false
if  pred comparewithknownconstant opttable  false
withknownconstant   true
mb   acb getconstructor
else
mb   exprfun
int	basecolumns   opttable gettrulythebestaccesspath
getconglomeratedescriptor
getindexdescriptor   basecolumnpositions
boolean	isascending   opttable gettrulythebestaccesspath
getconglomeratedescriptor
getindexdescriptor   isascending
/* if the predicate is an in-list probe predicate then we are
* using it as a start/stop key "placeholder", to be over-ridden
* at execution time.  put differently, we want to generate
* "column = ?" as a start/stop key and then use the "?" value
* as a placeholder into which we'll plug the various in values
* at execution time.
*
* in that case "isin" will be false here, which is fine: there's
* no need to generate dynamic start/stop keys like we do for
* "normal" in lists because we're just using the key as a place-
* holder.  so by generating the probe predicate ("column = ?")
* as a normal one-sided start/stop key, we get our requisite
* execution-time placeholder and that's that.  for more on how
* we use this "placeholder", see multiprobetablescanresultset.
*
* note that we generate the corresponding in-list values
* separately (see generateinlistvalues() in this class).
*/
boolean isin   pred getandnode   getleftoperand   instanceof inlistoperatornode
/*
** generate statements of the form
**
** r.setcolumn(columnnumber, columnexpression);
**
** and put the generated statement in the allocator function.
*/
mb getfield rowfield
mb push columnnumber   1
// second arg
if  isin
pred getsourceinlist   generatestartstopkey
isascending  isstartkey  acb  mb
else
pred generateexpressionoperand opttable  basecolumns  acb  mb
mb upcast classname datavaluedescriptor
mb callmethod vmopcode invokeinterface  classname row        2
/* also tell the row if this column uses ordered null semantics */
if   isin
relationaloperator relop   pred getrelop
boolean setorderednulls   relop orderednulls
/* beetle 4464, performance work.  if index column is not nullable
* (which is frequent), we should treat it as though nulls are
* ordered (indeed because they don't exist) so that we do not have
* to check null at scan time for each row, each column.  this is
* an overload to "is null" operator, so that we have less overhead,
* provided that they don't interfere.  it doesn't interfere if it
* doesn't overload if key is null.  if key is null, but operator
* is not orderednull type (is null), skipscan will use this flag
* (false) to skip scan.
*/
if     setorderednulls
relop getcolumnoperand opttable  gettypeservices   isnullable
if  withknownconstant
setorderednulls   true
else
valuenode keyexp
relop getexpressionoperand
opttable gettablenumber
basecolumns
fromtable opttable
if  keyexp instanceof columnreference
setorderednulls
columnreference  keyexp  gettypeservices   isnullable
if  setorderednulls
mb getfield rowfield
mb push columnnumber
mb callmethod vmopcode invokeinterface  classname execindexrow        1
/**
* finish generating a start or stop key
*
* @param acb	the activationclassbuilder for the class we're building
* @param exprfun	the methodbuilder for the method we're building
* @param rowfield	the name of the field that holds the indexable row
*/
private void finishkey expressionclassbuilder acb
methodbuilder mb
methodbuilder exprfun
localfield rowfield
/* generate return statement and add to exprfun */
exprfun getfield rowfield
exprfun methodreturn
/* we are done putting stuff in exprfun */
exprfun complete
/*
** what we use is the access of the static field,
** i.e. the pointer to the method.
*/
acb pushmethodreference mb  exprfun
/* class implementation */
boolean constantcolumn columnreference colref
boolean retval   false
/*
** walk this list
*/
int size   size
for  int index   0  index < size  index
predicate	pred    predicate  elementat index
relationaloperator relop   pred getrelop
if  pred isrelationaloppredicate
if  relop getoperator      relationaloperator equals_relop
valuenode exprop   relop getoperand
colref
pred getreferencedset   size
true
if  exprop    null
if  exprop isconstantexpression
retval   true
break
else if  relop getoperator
relationaloperator is_null_relop
columnreference columnop
columnreference relop getoperand
colref
pred getreferencedset   size
false
if  columnop    null
retval   true
return retval
/**
* @see optimizablepredicatelist#selectivity
*/
public double selectivity optimizable opttable
throws standardexception
tabledescriptor td   opttable gettabledescriptor
conglomeratedescriptor conglomerates   td getconglomeratedescriptors
int numpredicates   size
int numconglomerates   conglomerates length
if  numconglomerates    1
return  1 0d     one conglomerate  must be heap
if  numpredicates    0
return  1 0d 		   no predicates why bother?
boolean nothingyet   true
/* before we start, lets select non-redundant prediates into a working
* list; we'll work with the workingpredicates list from now on in this
* routine.
*/
predicatelist workingpredicates   new predicatelist
for  int i   0  i < numpredicates  i
if  isredundantpredicate i
continue
/* to workingpredicates only add useful predicates... */
workingpredicates addoptpredicate  predicate elementat i
int numworkingpredicates   workingpredicates size
/*--------------------------------------------------------------------
* in the first phase, the routine initializes an array of
* predicatewrapperlists-- one list for each conglomerate that has
* statistics.
*
* predsforconglomerates is an array of pwlist. for each conglomerate we
* keep a pwlist of predicates that have an equals predicate on a column
* in the conglomerate.
*
* as an example consider a table t, with indices on
* t(c1)-->conglom_one, t(c2,c1)-->conglom_two.
*
* if we have the following predicates:
*  t.c1=t1.x (p1) and t.c1=t2.y (p2) and t.c2=t1.z (p3), then we'll have the
* after the first loop is done, we'll have the following setup.
*
* conglom_one: pwlist [p1,p2]
* conglom_two: pwlist [p1,p2,p3].
*
* note that although p1,p2 appear on both conglomerates, the
* indexposition of p1 and p2 on the first list is 0 (first index
* position) while the index position of p1,p2 on the second list is 1
* (second index position).
*
* predicatewrapper and predicatewrapperlists are inner classes used
* only in this file.
* -------------------------------------------------------------------- */
predicatewrapperlist
predsforconglomerates  	new predicatewrapperlist
for  int i   0  i < numconglomerates  i
conglomeratedescriptor cd   conglomerates
if   cd isindex
continue
if   td statisticsexist cd
continue
int basecolumnlist
cd getindexdescriptor   basecolumnpositions
for  int j   0  j < numworkingpredicates  j
predicate pred    predicate workingpredicates elementat j
int ip   pred hasequaloncolumnlist basecolumnlist
opttable
if  ip < 0
continue 	   look at the next predicate
nothingyet   false
if  predsforconglomerates    null
predsforconglomerates   new predicatewrapperlist numworkingpredicates
predicatewrapper newpw   new predicatewrapper ip  pred  j
predsforconglomerates insert newpw
for  j   0
for  i   0  i <
if  nothingyet
return  1 0
/*------------------------------------------------------------------
* in the second phase we,
* walk the predsforconglomeratelist again-- if we find
* a break in the indexpositions we remove the predicates
* after the gap. to clarify, if we have equal predicates on the first
* and the third index positions, we can throw away the predicate on
* the 3rd index position-- it doesn't do us any good.
*-------------------------------------------------------------------*/
int maxoverlap    1
for  int i   0  i < numconglomerates  i
if  predsforconglomerates    null
continue
predsforconglomerates retainleadingcontiguous
for  i   0  i <
calculateweight predsforconglomerates  numworkingpredicates
/*-------------------------------------------------------------------
* in the third phase we loop through predsforconglomerates choosing the
* best fit (chooselongestmatch) of predicates. we use the statistics
* for the set of predicates returned by chooselongestmatch and then
* loop until we can't find any more statistics or we have exhausted all
* the predicates for which we are trying to find statistics.
*--------------------------------------------------------------------*/
vector statistics   new vector numworkingpredicates
double selectivity   1 0
vector maxpreds   new vector
while  true
maxpreds removeallelements
int conglomindex   chooselongestmatch predsforconglomerates
maxpreds  numworkingpredicates
if  conglomindex     1
break 			   no more stats available
selectivity
td selectivityforconglomerate conglomerates  maxpreds size
for  int i   0  i < maxpreds size    i
/* remove the predicates that we've calculated the selectivity
* of, from workingpredicates.
*/
predicate p   predicate  maxpreds elementat i
workingpredicates removeoptpredicate p
if  workingpredicates size      0
break
if  workingpredicates size      0
selectivity    workingpredicates selectivitynostatistics opttable
return selectivity
/* assign a weight to each predicate-- the maximum weight that a predicate
* can have is numusefulpredicates. if a predicate corresponds to the first
* index position then its weight is numusefulpredicates. the weight of a
* pwlist is the sum of the weights of individual predicates.
*/
private void calculateweight predicatewrapperlist pwlist  int numusefulpredicates
int s   new int
for  int i   0  i < pwlist length  i
if  pwlist    null
continue
for  int j   0  j < pwlist size    j
s elementat j  getpredicateid  ]
numusefulpredicates   j
for  int i   0  i < pwlist length  i
int w   0
if  pwlist    null
continue
for  int j   0  j < pwlist size    j
w    s elementat j  getpredicateid  ]
pwlist setweight w
/**
* choose the statistic which has the maximum match with the predicates.
* value is returned in ret.
*/
private int chooselongestmatch predicatewrapperlist predarray  vector ret
int numworkingpredicates
int max   0  maxweight   0
int position    1
int weight
for  int i   0  i < predarray length  i
if  predarray    null
continue
if  predarray uniquesize      0
continue
if  predarray uniquesize   > max
max   predarray uniquesize
position   i
maxweight   predarray getweight
if  predarray uniquesize      max
/* if the matching length is the same, choose the one with the
* lower weight.
*/
if  predarray getweight   > maxweight
continue
position   i
max   predarray uniquesize
maxweight   predarray getweight
if  position     1
return  1
/* the problem here is that i might have more than one predicate
* matching on the same index position; i.e
* col_1 = .. [p1] and col_1 = .. [p2] and col_2 = ..[p3];
* in that case that maximum matching predicate is [p1] and [p3] but
* [p2] shuld be considered again later.
*/
predicatewrapperlist pwl   predarray
vector uniquepreds   pwl createleadingunique
/* uniqueprds is a vector of predicate (along with wrapper) that i'm
going  to use to get statistics from-- we now have to delete these
predicates from all the predicatewrapperlists!
*/
for  int i   0  i < uniquepreds size    i
predicate p
predicatewrapper uniquepreds elementat i   getpredicate
ret addelement p
for  int j   0  j < predarray length  j
if  predarray    null
continue
pwl   predarray
/* note that we use object identity with the predicate and not
* the predicatewrapper to remove it from the prediate wrapper
* lists.
*/
pwl removeelement p
/* if removing this predicate caused a gap, get rid of everything after
* the gaps.
*/
for  int i   0  i < predarray length  i
if  predarray    null
continue
predarray retainleadingcontiguous
/* recalculate the weights of the pwlists... */
calculateweight predarray  numworkingpredicates
return position
/**
* compute selectivity the old fashioned way.
*/
private double selectivitynostatistics optimizable opttable
throws standardexception
double selectivity   1 0
for  int i   0  i < size    i
optimizablepredicate pred    optimizablepredicate elementat i
selectivity    pred selectivity  optimizable opttable
return selectivity
/**
* inner class which helps statistics routines do their work.
* we need to keep track of the index position for each predicate for each
* index while we're manipulating predicates and statistics. each predicate
* does have internal state for indexposition, but this is a more permanent
* sort of indexposition, which keeps track of the position for the index
* being considered in estimatecost. for us, each predicate can have
* different index positions for different indices.
*/
private class predicatewrapper
int indexposition
predicate pred
int predicateid
predicatewrapper int ip  predicate p  int predicateid
this indexposition   ip
this pred   p
this predicateid   predicateid
int getindexposition     return indexposition
predicate getpredicate     return pred
int getpredicateid     return predicateid
/* a predicatewrapper is before another predicate wrapper iff its index
* position is less than the index position of the other.
*/
boolean before predicatewrapper other
return  indexposition < other getindexposition
/* for our purposes two predicates at the same index
position are contiguous. (have i spelled this right?)
*/
boolean contiguous predicatewrapper other
int otherip   other getindexposition
return   indexposition    otherip      indexposition   otherip    1
indexposition   otherip     1
/** another inner class which is basically a list of predicate wrappers.
*/
private class predicatewrapperlist
vector pwlist
int numpreds
int numduplicates
int weight
predicatewrapperlist int maxvalue
pwlist   new vector maxvalue
void removeelement predicatewrapper pw
int index   pwlist indexof pw
if  index >  0
removeelementat index
void removeelement predicate p
for  int i   numpreds   1  i >  0  i
predicate predonlist   elementat i  getpredicate
if  predonlist    p     object equality is what we need
removeelementat i
void removeelementat int index
if  index < numpreds   1
predicatewrapper nextpw   elementat index 1
if  nextpw getindexposition      index
numduplicates
pwlist removeelementat index
numpreds
predicatewrapper elementat int i
return  predicatewrapper pwlist elementat i
void insert predicatewrapper pw
int i
for  i   0  i < pwlist size    i
if  pw getindexposition      elementat i  getindexposition
numduplicates
if  pw before elementat i
break
numpreds
pwlist insertelementat pw  i
int size
return numpreds
/* number of unique references to a column; i.e two predicates which
* refer to the same column in the table will give rise to duplicates.
*/
int uniquesize
if  numpreds > 0
return numpreds   numduplicates
return 0
/* from a list of predicatewrappers, retain only contiguous ones. get
* rid of everything after the first gap.
*/
void retainleadingcontiguous
if  pwlist    null
return
if  pwlist size      0
return
if  elementat 0  getindexposition      0
pwlist removeallelements
numpreds   numduplicates   0
return
int j
for  j   0  j < numpreds   1  j
if    elementat j  contiguous elementat j 1
break
/* j points to the last good one; i.e
* 		0 1 1 2 4 4
* j points to 2. remove 4 and everything after it.
* beetle 4321 - need to remove from back to front
* to prevent array out of bounds problems
*
*/
for  int k   numpreds   1  k > j  k
if  elementat k  getindexposition
elementat k 1  getindexposition
numduplicates
pwlist removeelementat k
numpreds   j   1
/* from a list of pw, extract the leading unique predicates; i.e if the
* pw's with index positions are strung together like this:
* 0 0 1 2 3 3
* i need to extract out 0 1 2 3.
* leaving 0 2 3 in there.
*/
vector createleadingunique
vector scratch   new vector
if  numpreds    0
return null
int lastindexposition   elementat 0  getindexposition
if  lastindexposition    0
return null
scratch addelement elementat 0   	   always add 0
for  int i   1  i < numpreds  i
if  elementat i  getindexposition      lastindexposition
continue
lastindexposition   elementat i  getindexposition
scratch addelement elementat i
return scratch
void setweight int weight
this weight   weight
int getweight
return weight