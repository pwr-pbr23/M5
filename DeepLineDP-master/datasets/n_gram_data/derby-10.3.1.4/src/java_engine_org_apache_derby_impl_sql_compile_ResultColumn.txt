/*
derby - class org.apache.derby.impl.sql.compile.resultcolumn
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services context contextmanager
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types stringdatavalue
import org apache derby iapi sql resultcolumndescriptor
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi services io storedformatids
import org apache derby iapi types datavaluefactory
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile rowordering
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile c_nodetypes
import org apache derby impl sql compile activationclassbuilder
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi store access qualifier
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi reference classname
import org apache derby iapi util jbitset
import org apache derby iapi util stringutil
import java sql types
import java util vector
/**
* a resultcolumn represents a result column in a select, insert, or update
* statement.  in a select statement, the result column just represents an
* expression in a row being returned to the client.  for insert and update
* statements, the result column represents an column in a stored table.
* so, a resultcolumn has to be bound differently depending on the type of
* statement it appears in.
*
*/
public class resultcolumn extends valuenode
implements resultcolumndescriptor  comparable
{
/* name and exposedname should point to the same string, unless there is a
* derived column list, in which case name will point to the underlying name
* and exposedname will point to the name from the derived column list.
*/
string			name
string			exposedname
string			tablename
string			sourcetablename
//used by metadata api resultsetmetadata.getschemaname to get a column's table's schema.
string			sourceschemaname
valuenode		expression
columndescriptor	columndescriptor
boolean			isgenerated
boolean			isgeneratedforunmatchedcolumnininsert
boolean			isgroupingcolumn
boolean			isreferenced
boolean			isredundant
boolean			isnamegenerated
boolean			updated
boolean			updatablebycursor
private boolean defaultcolumn
// tells us if this resultcolumn is a placeholder for a generated
// autoincrement value for an insert statement.
boolean			autoincrementgenerated
// tells us if this resultcolumn represents an autoincrement column in a
// base table.
boolean 		autoincrement
/* resultsetnumber for the resultset (at generate() time) that we belong to */
private int		resultsetnumber    1
columnreference reference     used to verify quals at bind time  if given
/* virtualcolumnid is the resultcolumn's position (1-based) within the resultset */
private int		virtualcolumnid
/**
* different types of initializer parameters indicate different
* types of initialization. parameters may be:
*
* <ul>
* <li>arg1	the name of the column, if any.</li>
* <li>arg2	the expression this result column represents</li>
* </ul>
*
* <p>
* - or -
* </p>
*
* <ul>
* <li>arg1	a column reference node</li>
* <li>arg2	the expression this result column represents</li>
* </ul>
*
* <p>
* - or -
* </p>
*
* <ul>
* <li>arg1	the column descriptor.</li>
* <li>arg2	the expression this result column represents</li>
* </ul>
*
* <p>
* - or -
* </p>
*
* <ul>
* <li>dtd			the type of the column</li>
* <li>expression	the expression this result column represents</li>
* </ul>
*/
public void init object arg1  object arg2  throws standardexception
{
// resolve: this is something of a hack - it is not obvious that
// the first argument being null means it should be treated as
// a string.
if   arg1 instanceof string      arg1    null
{
this name    string  arg1
this exposedname   this name
this expression    valuenode  arg2
}
else if  arg1 instanceof columnreference
{
columnreference ref    columnreference  arg1
this name   ref getcolumnname
this exposedname   ref getcolumnname
/*
when we bind, we'll want to make sure
the reference has the right table name.
*/
this reference   ref
this expression    valuenode  arg2
}
else if  arg1 instanceof columndescriptor
{
columndescriptor coldes    columndescriptor  arg1
datatypedescriptor coltype   coldes gettype
this name   coldes getcolumnname
this exposedname   name
/* clone the type info here, so we can change nullability if needed */
settype new datatypedescriptor coltype  coltype isnullable
this columndescriptor   coldes
this expression    valuenode  arg2
this autoincrement   coldes isautoincrement
}
else
{
settype  datatypedescriptor  arg1
this expression    valuenode  arg2
if  arg2 instanceof columnreference
{
reference    columnreference  arg2
}
}
/* this result column represents a <default> keyword in an insert or
* update statement
*/
if  expression    null
expression isinstanceof c_nodetypes default_node
defaultcolumn   true
}
/**
* returns true if the resultcolumn is standing in for a default keyword in
* an insert/update statement.
*/
public boolean isdefaultcolumn
{
return defaultcolumn
}
public void setdefaultcolumn boolean value
{
defaultcolumn   value
}
/**
* the following methods implement the resultcolumndescriptor
* interface.  see the language module interface for details.
*/
public string getname
{
return exposedname
}
public string getschemaname   throws standardexception
{
if   columndescriptor  null
columndescriptor gettabledescriptor      null
return columndescriptor gettabledescriptor   getschemaname
else
{
if  expression    null
// remind: could look in reference, if set.
return expression getschemaname
else
return null
}
}
public string gettablename
{
if  tablename    null
{
return tablename
}
if   columndescriptor  null
columndescriptor gettabledescriptor      null
{
return columndescriptor gettabledescriptor   getname
}
else
{
return expression gettablename
}
}
/**
* @see resultcolumndescriptor#getsourcetablename
*/
public string getsourcetablename
{
return sourcetablename
}
/**
* @see resultcolumndescriptor#getsourceschemaname
*/
public string getsourceschemaname
{
return sourceschemaname
}
/**
* clear the table name for the underlying columnreference.
* see updatenode.scrubresultcolumns() for full explaination.
*/
public void cleartablename
{
if  expression instanceof columnreference
{
columnreference  expression  settablenamenode  tablename  null
}
}
public datatypedescriptor gettype
{
return datatypeservices
}
public datatypedescriptor getexpressiontype   throws standardexception
{
return  expression    null  ?
datatypeservices
expression gettypeservices
}
public int getcolumnposition
{
if  columndescriptor  null
return columndescriptor getposition
else
return virtualcolumnid
}
/**
* set the expression in this resultcolumn.  this is useful in those
* cases where you don't know the expression in advance, like for
* insert statements with column lists, where the column list and
* select or values clause are parsed separately, and then have to
* be hooked up.
*
* @param expression	the expression to be set in this resultcolumn
*/
public void setexpression valuenode expression
{
this expression   expression
}
/**
* get the expression in this resultcolumn.
*
* @return valuenode	this.expression
*/
public valuenode getexpression
{
return expression
}
/**
* set the expression to a null node of the
* correct type.
*
* @exception standardexception		thrown on error
*/
void setexpressiontonullnode
throws standardexception
{
expression   getnullnode gettypeid
getcontextmanager    gettypeservices   getcollationtype
gettypeservices   getcollationderivation
}
/**
* set the name in this resultcolumn.  this is useful when you don't
* know the name at the time you create the resultcolumn, for example,
* in an insert-select statement, where you want the names of the
* result columns to match the table being inserted into, not the
* table they came from.
*
* @param name	the name to set in this resultcolumn
*/
public void setname string name
{
if  this name    null
{
this name   name
}
else
if  sanitymanager debug
sanitymanager assert reference    null
name equals reference getcolumnname
}
this exposedname   name
}
/**
* is the name for this resultcolumn generated?
*/
public boolean isnamegenerated
{
return isnamegenerated
}
/**
* set that this result column name is generated.
*/
public void setnamegenerated boolean value
{
isnamegenerated   value
}
/**
* set the resultsetnumber for this resultcolumn.  this is the
* resultsetnumber for the resultset that we belong to.  this
* is useful for generate() and necessary since we do not have a
* back pointer to the rsn.
*
* @param resultsetnumber	the resultsetnumber.
*/
public void setresultsetnumber int resultsetnumber
{
this resultsetnumber   resultsetnumber
}
/**
* get the resultsetnumber for this resultcolumn.
*
* @return int	the resultsetnumber.
*/
public int getresultsetnumber
{
return resultsetnumber
}
/**
* adjust the virtualcolumnid for this resultcolumn	by the specified amount
*
* @param adjust	the adjustment for the virtualcolumnid
*/
public void adjustvirtualcolumnid int adjust
{
virtualcolumnid    adjust
}
/**
* set the virtualcolumnid for this resultcolumn
*
* @param id	the virtualcolumnid for this resultcolumn
*/
public void setvirtualcolumnid int id
{
virtualcolumnid   id
}
/**
* get the virtualcolumnid for this resultcolumn
*
* @return virtualcolumnid for this resultcolumn
*/
public int getvirtualcolumnid
{
return virtualcolumnid
}
/**
* adjust this virtualcolumnid to account for the removal of a column
*
* this routine is called when bind processing finds and removes
* duplicate columns in the result list which were pulled up due to their
* presence in the order by clause, but were later found to be duplicate.
*
* if this column is a virtual column, and if this column's virtual
* column id is greater than the column id which is being removed, then
* we must logically shift this column to the left by decrementing its
* virtual column id.
*
* @param removedcolumnid   id of the column being removed.
*/
public void collapsevirtualcolumnidgap int removedcolumnid
{
if  columndescriptor    null    virtualcolumnid > removedcolumnid
virtualcolumnid
}
/**
* generate a unique (across the entire statement) column name for unnamed
* resultcolumns
*
* @exception standardexception		thrown on error
*/
public void guaranteecolumnname   throws standardexception
{
if  exposedname    null
{
/* unions may also need generated names, if both sides name don't match */
exposedname      getcompilercontext   getnextcolumnnumber
isnamegenerated   true
}
}
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
{
if  sanitymanager debug
{
return     exposedname
name
tablename
isnamegenerated
sourcetablename
datatypeservices
columndescriptor
isgenerated
isgeneratedforunmatchedcolumnininsert
isgroupingcolumn
isreferenced
isredundant
virtualcolumnid
resultsetnumber
super tostring
}
else
{
return
}
}
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
{
if  sanitymanager debug
{
super printsubnodes depth
if  expression    null
{
printlabel depth
expression treeprint depth   1
}
if  reference    null
{
printlabel depth
reference treeprint depth   1
}
}
}
/**
* bind this expression.  this means binding the sub-expressions.
* in this case, we figure out what the result type of this result
* column is when we call one of the bindresultcolumn*() methods.
* the reason is that there are different ways of binding the
* result columns depending on the statement type, and this is
* a standard interface that does not take the statement type as
* a parameter.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
{
/*
** set the type of a parameter to the type of the result column.
** don't do it if this result column doesn't have a type yet.
** this can happen if the parameter is part of a table constructor.
*/
if  expression requirestypefromcontext
{
if  gettypeservices      null
{
expression settype gettypeservices
}
}
expression   expression bindexpression fromlist  subquerylist
aggregatevector
if  expression instanceof columnreference
{
autoincrement     columnreference expression  getsource   isautoincrement
}
return this
}
/**
* bind this result column by ordinal position and set the virtualcolumnid.
* this is useful for insert statements like "insert into t values (1, 2, 3)",
* where the user did not specify a column list.
* if a columndescriptor is not found for a given position, then
* the user has specified more values than the # of columns in
* the table and an exception is thrown.
*
* note: we must set the virtualcolumnid here because insert does not
* construct the resultcolumnlist in the usual way.
*
* @param tabledescriptor	the descriptor for the table being
*				inserted into
* @param columnid		the ordinal position of the column
*						in the table, starting at 1.
*
* @exception standardexception		thrown on error
*/
void bindresultcolumnbyposition tabledescriptor tabledescriptor
int columnid
throws standardexception
{
columndescriptor	columndescriptor
columndescriptor   tabledescriptor getcolumndescriptor columnid
if  columndescriptor    null
{
string		errorstring
string		schemaname
errorstring
schemaname   tabledescriptor getschemaname
if  schemaname    null
errorstring    schemaname
errorstring    tabledescriptor getname
throw standardexception newexception sqlstate lang_too_many_result_columns  errorstring
}
setcolumndescriptor tabledescriptor  columndescriptor
setvirtualcolumnid columnid
}
/**
* bind this result column by its name and set the virtualcolumnid.
* this is useful for update statements, and for insert statements
* like "insert into t (a, b, c) values (1, 2, 3)" where the user
* specified a column list.
* an exception is thrown when a columndescriptor cannot be found for a
* given name.  (there is no column with that name.)
*
* note: we must set the virtualcolumnid here because insert does not
* construct the resultcolumnlist in the usual way.
*
* @param tabledescriptor	the descriptor for the table being
*				updated or inserted into
* @param columnid		the ordinal position of the column
*						in the table, starting at 1. (used to
*						set the virtualcolumnid.)
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumnbyname tabledescriptor tabledescriptor
int columnid
throws standardexception
{
columndescriptor	columndescriptor
columndescriptor   tabledescriptor getcolumndescriptor exposedname
if  columndescriptor    null
{
string		errorstring
string		schemaname
errorstring
schemaname   tabledescriptor getschemaname
if  schemaname    null
errorstring    schemaname
errorstring    tabledescriptor getname
throw standardexception newexception sqlstate lang_column_not_found_in_table  exposedname  errorstring
}
setcolumndescriptor tabledescriptor  columndescriptor
setvirtualcolumnid columnid
if  isprivilegecollectionrequired
getcompilercontext   addrequiredcolumnpriv  columndescriptor
}
/**
* change an untyped null to a typed null.
*
* @exception standardexception		thrown on error
*/
public void typeuntypednullexpression  resultcolumn bindingrc
throws standardexception
{
typeid typeid   bindingrc gettypeid
/* this is where we catch null in a values clause outside
* of insert values()
*/
if  typeid    null
{
throw standardexception newexception sqlstate lang_null_in_values_clause
}
if  expression instanceof untypednullconstantnode
//since we don't know the type of such a constant node, we just
//use the default values for collation type and derivation.
//eg insert into table1 values(1,null)
//when this method is executed for the sql above, we don't know
//the type of the null at this point.
expression   getnullnode  typeid  getcontextmanager
stringdatavalue collation_type_ucs_basic
stringdatavalue collation_derivation_implicit
else if    expression instanceof columnreference     expression gettypeservices      null
{
// the expression must be a reference to a null column in a values table.
expression settype  bindingrc gettype
}
}
/**
* set the column descriptor for this result column.  it also gets
* the data type services from the column descriptor and stores it in
* this result column: this is redundant, but we have to store the result
* type here for select statements, and it is more orthogonal if the type
* can be found here regardless of what type of statement it is.
*
* @param tabledescriptor	the tabledescriptor for the table
*				being updated or inserted into.
*				this parameter is used only for
*				error reporting.
* @param columndescriptor	the columndescriptor to set in
*				this resultcolumn.
*
* @exception standardexception tablenamemismatch
*/
void setcolumndescriptor tabledescriptor tabledescriptor
columndescriptor columndescriptor  throws standardexception
{
/* callers are responsible for verifying that the column exists */
if  sanitymanager debug
sanitymanager assert columndescriptor    null
settype columndescriptor gettype
this columndescriptor   columndescriptor
/*
if the node was created using a reference, the table name
of the reference must agree with that of the tabledescriptor.
*/
if  reference    null    reference gettablename      null
{
if    tabledescriptor getname   equals
reference gettablename
{
/* remind: need to have schema name comparison someday as well...
** left out for now, lots of null checking needed...
** || ! tabledescriptor.getschemaname().equals(
**	reference.gettablenamenode().getschemaname())) {
*/
string realname   tabledescriptor getname
string refname   reference gettablename
throw standardexception newexception sqlstate lang_table_name_mismatch
realname  refname
}
}
}
/**
* bind the result column to the expression that lives under it.
* all this does is copy the datatype information to this node.
* this is useful for select statements, where the result type
* of each column is the type of the column's expression.
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumntoexpression
throws standardexception
{
/*
** this gets the same datatypeservices object as
** is used in the expression.  it is probably not
** necessary to clone the object here.
*/
settype expression gettypeservices
if  expression instanceof columnreference
{
columnreference cr    columnreference  expression
tablename   cr gettablename
sourcetablename   cr getsourcetablename
sourceschemaname   cr getsourceschemaname
}
}
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
{
if  expression    null
return this
expression   expression preprocess numtables  outerfromlist
outersubquerylist
outerpredicatelist
return this
}
/**
this verifies that the expression is storable into the result column.
it checks versus the given resultcolumn.
this method should not be called until the result column and
expression both have a valid type, i.e. after they are bound
appropriately. its use is for statements like insert, that need to
verify if a given value can be stored into a column.
@exception standardexception thrown if types not suitable.
*/
public void checkstorableexpression resultcolumn tostore
throws standardexception
{
typeid columntypeid  tostoretypeid
tostoretypeid   tostore gettypeid
if  tostoretypeid    null
return
columntypeid   gettypeid
if    gettypecompiler   storable tostoretypeid  getclassfactory
throw standardexception newexception sqlstate lang_not_storable
columntypeid getsqltypename
tostoretypeid getsqltypename
}
/**
this verifies that the expression is storable into the result column.
it checks versus the expression under this resultcolumn.
this method should not be called until the result column and
expression both have a valid type, i.e. after they are bound
appropriately. its use is for statements like update, that need to
verify if a given value can be stored into a column.
@exception standardexception thrown if types not suitable.
*/
public void checkstorableexpression
throws standardexception
{
typeid columntypeid   gettypeid
typeid tostoretypeid   getexpressiontype   gettypeid
if    gettypecompiler   storable tostoretypeid  getclassfactory
throw standardexception newexception sqlstate lang_not_storable
columntypeid getsqltypename
tostoretypeid getsqltypename
}
/**
* do code generation for a result column.  this consists of doing the code
* generation for the underlying expression.
*
* @param ecb	the expressionclassbuilder for the class we're generating
* @param mb	the method the expression will go into
*
*
* @exception standardexception		thrown on error
*/
public void generateexpression expressionclassbuilder ecb
methodbuilder mb
throws standardexception
{
expression generateexpression ecb  mb
}
/**
* do code generation to return a null of the appropriate type
* for the result column.
requires the getcolumnexpress value pushed onto the stack
*
* @param acb		the activationclassbuilder for the class we're generating
* @param eb		the expressionblock that the generate code is to go into
* @param getcolumnexpression "fieldx.getcolumn(y)"
*
* @exception standardexception		thrown on error
*/
/*pushcompile
public void generatenulls(expressionclassbuilder acb,
methodbuilder mb,
expression getcolumnexpress)
throws standardexception
{
acb.pushdatavaluefactory(mb);
gettypecompiler().generatenull(mb, acb.getbaseclassname());
mb.cast(classname.datavaluedescriptor);
return eb.newcastexpression(
classname.datavaluedescriptor,
gettypecompiler().
generatenull(
eb,
acb.getbaseclassname(),
acb.getdatavaluefactory(eb),
getcolumnexpress));
}
*/
/**
generate the code to create a column the same shape and
size as this resultcolumn.
used in resultcolumnlist.generateholder().
@exception standardexception  thrown on failure
*/
public void generateholder expressionclassbuilder acb
methodbuilder mb
throws standardexception
{
// generate expression of the form
// (datavaluedescriptor) columnspace
acb generatenull mb  gettypecompiler    gettypeservices   getcollationtype
mb upcast classname datavaluedescriptor
}
/*
** check whether the column length and type of this result column
** match the expression under the columns.  this is useful for
** insert and update statements.  for select statements this method
** should always return true.  there is no need to call this for a
** delete statement.
**
** @return	true means the column matches its expressions,
**			false means it doesn't match.
*/
boolean columntypeandlengthmatch
throws standardexception
{
datatypedescriptor	resultcolumntype
datatypedescriptor	expressiontype   expression gettypeservices
/*
** we can never make any assumptions about
** parameters.  so don't even bother in this
** case.
*/
if  expression requirestypefromcontext
{
return false
}
resultcolumntype   gettype
if  sanitymanager debug
{
if     resultcolumntype    null
{
sanitymanager throwassert
this
}
}
// are we inserting/updating an xml column?  if so, we always
// return false so that normalization will occur.  we have to
// do this because there are different "kinds" of xml values
// and we need to make sure they match--but we don't know
// the "kind" until execution time.  see the "normalize"
// method in org.apache.derby.iapi.types.xml for more.
if  resultcolumntype gettypeid   isxmltypeid
return false
/* are they the same type? */
if     resultcolumntype gettypeid   getsqltypename   equals
expressiontype gettypeid   getsqltypename
{
return false
}
/* are they the same precision? */
if  resultcolumntype getprecision      expressiontype getprecision
{
return false
}
/* are they the same scale? */
if  resultcolumntype getscale      expressiontype getscale
{
return false
}
/* are they the same width? */
if  resultcolumntype getmaximumwidth      expressiontype getmaximumwidth
{
return false
}
/* is the source nullable and the target non-nullable? */
if     resultcolumntype isnullable       expressiontype isnullable
{
return false
}
return true
}
boolean columntypeandlengthmatch resultcolumn othercolumn
throws standardexception
{
datatypedescriptor	resultcolumntype
datatypedescriptor	otherresultcolumntype
valuenode otherexpression   othercolumn getexpression
resultcolumntype   gettype
otherresultcolumntype   othercolumn gettype
if  sanitymanager debug
{
sanitymanager assert resultcolumntype    null
this
sanitymanager assert otherresultcolumntype    null
othercolumn
}
/*
** we can never make any assumptions about
** parameters.  so don't even bother in this
** case.
*/
if   otherexpression    null      otherexpression requirestypefromcontext
expression requirestypefromcontext
{
return false
}
// are we inserting/updating an xml column?  if so, we always
// return false so that normalization will occur.  we have to
// do this because there are different "kinds" of xml values
// and we need to make sure they match--but we don't know
// the "kind" until execution time.  see the "normalize"
// method in org.apache.derby.iapi.types.xml for more.
if  resultcolumntype gettypeid   isxmltypeid
return false
/* are they the same type? */
if     resultcolumntype gettypeid   equals
otherresultcolumntype gettypeid
{
/* if the source is a constant of a different type then
* we try to convert that constant to a constant of our
* type. (the initial implementation only does the conversion
* to string types because the most common problem is a char
* constant with a varchar column.)
* note: we do not attempt any conversion here if the source
* is a string type and the target is not or vice versa in
* order to avoid problems with implicit varchar conversions.
* anyway, we will check if the "converted" constant has the
* same type as the original constant.  if not, then the conversion
* happened.  in that case, we will reuse the constantnode, for simplicity,
* and reset the type to match the desired type.
*/
if  otherexpression instanceof constantnode
{
constantnode constant    constantnode othercolumn getexpression
datavaluedescriptor oldvalue   constant getvalue
datavaluedescriptor newvalue   convertconstant
resultcolumntype gettypeid
resultcolumntype getmaximumwidth
oldvalue
if   oldvalue    newvalue
oldvalue instanceof stringdatavalue
newvalue instanceof stringdatavalue
{
constant setvalue newvalue
constant settype gettypeservices
othercolumn bindresultcolumntoexpression
otherresultcolumntype   othercolumn gettype
}
//if we are dealing with stringdatavalue, then make sure we
//have correct collation type and derivaiton set and the value
//represented by collation is either sqlxxx or collatorsqlxxx
//depending on the collation type.
if  newvalue instanceof stringdatavalue
{
constant gettypeservices   setcollationderivation
resultcolumntype getcollationderivation
constant gettypeservices   setcollationtype
resultcolumntype getcollationtype
datavaluefactory dvf   getdatavaluefactory
newvalue     stringdatavalue newvalue  getvalue dvf getcharactercollator
constant gettypeservices   getcollationtype
constant setvalue newvalue
}
}
if     resultcolumntype gettypeid   equals
otherresultcolumntype gettypeid
{
return false
}
}
/* are they the same precision? */
if  resultcolumntype getprecision
otherresultcolumntype getprecision
{
return false
}
/* are they the same scale? */
if  resultcolumntype getscale      otherresultcolumntype getscale
{
return false
}
/* are they the same width? */
if  resultcolumntype getmaximumwidth
otherresultcolumntype getmaximumwidth
{
return false
}
/* is the source nullable and the target non-nullable?
* the source is nullable if it is nullable or if the target is generated
* for an unmatched column in an insert with a column list.
* this additional check is needed because when we generate any additional
* source rcs for an insert with a column list the generated rcs for any
* non-specified columns get the type info from the column.  thus,
* for t1(non_nullable, nullable)
*	insert into t2 (nullable) values 1;
* rctype.isnullable() returns false for the generated source rc for
* non_nullable.  in this case, we want to see it as
*/
if     resultcolumntype isnullable
otherresultcolumntype isnullable
othercolumn isgeneratedforunmatchedcolumnininsert
{
return false
}
return true
}
/**
* is this a generated column?
*
* @return boolean - whether or not this column is a generated column.
*/
public boolean isgenerated
{
return  isgenerated    true
}
/**
* is this columm generated for an unmatched column in an insert?
*
* @return boolean - whether or not this columm was generated for an unmatched column in an insert.
*/
public boolean isgeneratedforunmatchedcolumnininsert
{
return  isgeneratedforunmatchedcolumnininsert    true
}
/**
* mark this a columm as a generated column
*/
public void markgenerated
{
isgenerated   true
/* a generated column is a referenced column */
isreferenced   true
}
/**
* mark this a columm as generated for an unmatched column in an insert
*/
public void markgeneratedforunmatchedcolumnininsert
{
isgeneratedforunmatchedcolumnininsert   true
/* a generated column is a referenced column */
isreferenced   true
}
/**
* is this a referenced column?
*
* @return boolean - whether or not this column is a referenced column.
*/
public boolean isreferenced
{
return isreferenced
}
/**
* mark this column as a referenced column.
*/
public void setreferenced
{
isreferenced   true
}
/**
* mark this column as a referenced column if it is already marked as referenced or if any result column in
* its chain of virtual columns is marked as referenced.
*/
void pullvirtualisreferenced
{
if  isreferenced
return
for  valuenode expr   expression  expr    null     expr instanceof virtualcolumnnode
{
virtualcolumnnode vcn    virtualcolumnnode  expr
resultcolumn src   vcn getsourcecolumn
if  src isreferenced
{
setreferenced
return
}
expr   src getexpression
}
end of pullvirtualisreferenced
/**
* mark this column as an unreferenced column.
*/
public void setunreferenced
{
isreferenced   false
}
/**
* mark this rc and all rcs in the underlying
* rc/vcn chain as referenced.
*/
void markallrcsinchainreferenced
{
setreferenced
valuenode vn   expression
while  vn instanceof virtualcolumnnode
{
virtualcolumnnode vcn    virtualcolumnnode  vn
resultcolumn rc   vcn getsourcecolumn
rc setreferenced
vn   rc getexpression
}
}
/**
* is this a redundant resultcolumn?
*
* @return boolean - whether or not this rc is redundant.
*/
public boolean isredundant
{
return isredundant
}
/**
* mark this resultcolumn as redundant.
*/
public void setredundant
{
isredundant   true
}
/**
* mark this resultcolumn as a grouping column in the select list
*/
public void markasgroupingcolumn
{
isgroupingcolumn   true
}
/**
* look for and reject ?/-?/+? parameter under this resultcolumn.  this is
* called for select statements.
*
* @exception standardexception		thrown if a ?/-?/+? parameter was found
*									directly under this resultcolumn.
*/
void rejectparameter   throws standardexception
{
if   expression    null      expression isparameternode
throw standardexception newexception sqlstate lang_param_in_select_list
}
/*
** the following methods implement the comparable interface.
*/
public int compareto object other
{
resultcolumn otherresultcolumn    resultcolumn  other
return this getcolumnposition     otherresultcolumn getcolumnposition
}
/**
* mark this column as being updated by an update statemment.
*/
void markupdated
{
updated   true
}
/**
* mark this column as being updatable, so we can make sure it is in the
* "for update" list of a positioned update.
*/
void markupdatablebycursor
{
updatablebycursor   true
}
/**
* tell whether this column is being updated.
*
* @return	true means this column is being updated.
*/
boolean updated
{
return updated
}
/**
* tell whether this column is updatable by a positioned update.
*
* @return	true means this column is updatable
*/
public boolean updatablebycursor
{
return updatablebycursor
}
/**
* @see querytreenode#disableprivilegecollection
*/
public void disableprivilegecollection
{
super disableprivilegecollection
if  expression    null
expression disableprivilegecollection
}
/**
* make a copy of this resultcolumn in a new resultcolumn
*
* @return	a new resultcolumn with the same contents as this one
*
* @exception standardexception		thrown on error
*/
resultcolumn cloneme   throws standardexception
{
resultcolumn	newresultcolumn
valuenode		cloneexpr
/* if expression is a columnreference, then we want to
* have the rc's clone have a clone of the columnreference
* for it's expression.  this is for the special case of
* cloning the select list for the having clause in the parser.
* the select generated for the having needs its own copy
* of the columnreferences.
*/
if  expression instanceof columnreference
{
cloneexpr     columnreference  expression  getclone
}
else
{
cloneexpr   expression
}
/* if a columndescriptor exists, then we must propagate it */
if  columndescriptor    null
{
newresultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
columndescriptor
expression
getcontextmanager
newresultcolumn setexpression cloneexpr
}
else
{
newresultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
getname
cloneexpr
getcontextmanager
}
/* set the virtualcolumnid and name in the new node */
newresultcolumn setvirtualcolumnid getvirtualcolumnid
/* set the type and name information in the new node */
newresultcolumn setname getname
newresultcolumn settype gettypeservices
newresultcolumn setnamegenerated isnamegenerated
/* set the "is generated for unmatched column in insert" status in the new node
this if for bug 4194*/
if  isgeneratedforunmatchedcolumnininsert
newresultcolumn markgeneratedforunmatchedcolumnininsert
/* set the "is referenced" status in the new node */
if  isreferenced
newresultcolumn setreferenced
/* set the "updated" status in the new node */
if  updated
newresultcolumn markupdated
/* setthe "updatable by cursor" status in the new node */
if  updatablebycursor
newresultcolumn markupdatablebycursor
if  isautoincrementgenerated
newresultcolumn setautoincrementgenerated
if  isautoincrement
newresultcolumn setautoincrement
if  isgroupingcolumn
newresultcolumn markasgroupingcolumn
if  isgenerated
newresultcolumn markgenerated
}
return newresultcolumn
}
/**
* get the maximum size of the column
*
* @return the max size
*/
public int getmaximumcolumnsize
{
return datatypeservices gettypeid
getapproximatelengthinbytes datatypeservices
}
/**
* return the variant type for the underlying expression.
* the variant type can be:
*		variant				- variant within a scan
*							  (method calls and non-static field access)
*		scan_invariant		- invariant within a scan
*							  (column references from outer tables)
*		query_invariant		- invariant within the life of a query
*		constant				- constant
*
* @return	the variant type for the underlying expression.
* @exception standardexception	thrown on error
*/
protected int getorderablevarianttype   throws standardexception
{
/*
** if the expression is variant, then
** return variant.  otherwise, we return
** constant. for result columns that are
** generating autoincrement values, the result
** is variant-- note that there is no expression
** associated with an autoincrement column in
** an insert statement.
*/
int exptype     expression    null  ?
expression getorderablevarianttype
isautoincrementgenerated    ?
qualifier variant   qualifier constant
switch  exptype
{
case qualifier variant
return qualifier variant
case qualifier scan_invariant
case qualifier query_invariant
return qualifier scan_invariant
default
return qualifier constant
}
}
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
{
visitable returnnode   v visit this
if  v skipchildren this
{
return returnnode
}
if  expression    null     v stoptraversal
{
expression    valuenode expression accept v
}
return returnnode
}
/**
* set the nullability of this resultcolumn.
*/
public void setnullability boolean nullability
{
datatypeservices setnullability nullability
}
/**
* is this column in this array of strings?
*
* @param list the array of column names to compare
*
* @return true/false
*/
public boolean foundinlist string list
{
return foundstring list  name
}
/**
* verify that this rc is orderable.
*
* @exception standardexception		thrown on error
*/
void verifyorderable   throws standardexception
{
/*
* do not check to see if we can map user types
* to built-in types.  the ability to do so does
* not mean that ordering will work.  in fact,
* as of version 2.0, ordering does not work on
* user types.
*/
if   gettypeid   orderable getclassfactory
{
throw standardexception newexception sqlstate lang_column_not_orderable_during_execution
gettypeid   getsqltypename
}
}
/**
if this resultcolumn is bound to a column in a table
get the column descriptor for the column in the table.
otherwise return null.
*/
columndescriptor gettablecolumndescriptor    return columndescriptor
/**
* returns true if this result column is a placeholder for a generated
* autoincrement value.
*/
public boolean isautoincrementgenerated
{
return autoincrementgenerated
}
public void setautoincrementgenerated
{
autoincrementgenerated   true
}
public void resetautoincrementgenerated
{
autoincrementgenerated   false
}
public boolean isautoincrement
{
return autoincrement
}
public void setautoincrement
{
autoincrement   true
}
public boolean isgroupingcolumn
{
return isgroupingcolumn
}
/**
* @exception standardexception		thrown on error
*/
private datavaluedescriptor convertconstant typeid totypeid  int maxwidth
datavaluedescriptor constantvalue
throws standardexception
{
int formatid   totypeid gettypeformatid
datavaluefactory dvf   getdatavaluefactory
switch  formatid
{
default
case storedformatids char_type_id
return constantvalue
case storedformatids varchar_type_id
case storedformatids national_char_type_id
case storedformatids national_varchar_type_id
string sourcevalue   constantvalue getstring
int sourcewidth   sourcevalue length
int posn
/*
** if the input is already the right length, no normalization is
** necessary - just return the source.
**
*/
if  sourcewidth <  maxwidth
{
switch  formatid
{
// for nchar we must pad the result, saves on normilization later if all
// constants are of the correct size
case storedformatids national_char_type_id
if  sourcewidth < maxwidth
{
stringbuffer stringbuffer   new stringbuffer sourcevalue
int needed   maxwidth   sourcewidth
char blankarray   new char
for  int i   0  i < needed  i
blankarray
stringbuffer append blankarray  0
maxwidth   sourcewidth
sourcevalue   stringbuffer tostring
}
return dvf getnationalchardatavalue sourcevalue
case storedformatids national_varchar_type_id
return dvf getnationalvarchardatavalue sourcevalue
case storedformatids varchar_type_id
return dvf getvarchardatavalue sourcevalue
}
}
/*
** check whether any non-blank characters will be truncated.
*/
for  posn   maxwidth  posn < sourcewidth  posn
{
if  sourcevalue charat posn
{
string typename   null
switch  formatid
{
case storedformatids national_char_type_id
typename   typeid national_char_name
break
case storedformatids national_varchar_type_id
typename   typeid national_varchar_name
break
case storedformatids varchar_type_id
typename   typeid varchar_name
break
}
throw standardexception newexception sqlstate lang_string_truncation
typename
stringutil formatforprint sourcevalue
string valueof maxwidth
}
}
switch  formatid
{
case storedformatids national_char_type_id
return dvf getnationalchardatavalue sourcevalue substring 0  maxwidth
case storedformatids national_varchar_type_id
return dvf getnationalvarchardatavalue sourcevalue substring 0  maxwidth
case storedformatids varchar_type_id
return dvf getvarchardatavalue sourcevalue substring 0  maxwidth
}
case storedformatids longvarchar_type_id
//no need to check widths here (unlike varchar), since no max width
return dvf getlongvarchardatavalue constantvalue getstring
case storedformatids national_longvarchar_type_id
//no need to check widths here (unlike varchar), since no max width
return dvf getnationallongvarchardatavalue constantvalue getstring
}
}
/**
* get the datatypeservices from this node.
*
* @return	the datatypeservices from this node.  this
*		may be null if the node isn't bound yet.
*/
public datatypedescriptor gettypeservices   throws standardexception
{
datatypedescriptor dtd   super gettypeservices
if  dtd    null    expression    null
{
dtd   expression gettypeservices
if  dtd    null
settype  dtd
}
return dtd
end of gettypeservices
public tablename gettablenameobject
return null
}
/* get the wrapped reference if any */
public	columnreference	getreference     return reference
/**
* get the source basecolumnnode for this result column. the
* basecolumnnode cannot be found unless the resultcolumn is bound
* and is a simple reference to a column in a basefromtable.
*
* @return a basecolumnnode,
*   or null if a basecolumnnode cannot be found
*/
public basecolumnnode getbasecolumnnode
valuenode vn   expression
while  true
if  vn instanceof resultcolumn
vn     resultcolumn  vn  expression
else if  vn instanceof columnreference
vn     columnreference  vn  getsource
else if  vn instanceof virtualcolumnnode
vn     virtualcolumnnode  vn  getsourcecolumn
else if  vn instanceof basecolumnnode
return  basecolumnnode  vn
else
return null
}
}
}
/**
* search the tree beneath this resultcolumn until we find
* the number of the table to which this rc points, and
* return that table number.  if we can't determine which
* table this rc is for, then return -1.
*
* there are two places we can find the table number: 1) if
* our expression is a columnreference, then we can get the
* target table number from the columnreference and that's
* it; 2) if expression is a virtualcolumnnode, then if
* the virtualcolumnnode points to a frombasetable, we can
* get that fbt's table number; otherwise, we walk the
* virtualcolumnnode-resultcolumn chain and do a recursive
* search.
*
* @return the number of the table to which this resultcolumn
*  points, or -1 if we can't determine that from where we are.
*/
public int gettablenumber
throws standardexception
{
if  expression instanceof columnreference
return   columnreference expression  gettablenumber
else if  expression instanceof virtualcolumnnode
{
virtualcolumnnode vcn    virtualcolumnnode expression
// if the vcn points to a frombasetable, just get that
// table's number.
if  vcn getsourceresultset   instanceof frombasetable
{
return   frombasetable vcn getsourceresultset
gettablenumber
}
// else recurse down the vcn.
return vcn getsourcecolumn   gettablenumber
}
// we can get here if expression has neither a column
// reference nor a frombasetable beneath it--for example,
// if it is of type basecolumnnode.
return  1
}
public boolean isequivalent valuenode o  throws standardexception
{
if  o getnodetype      getnodetype
{
resultcolumn other    resultcolumn o
if  expression    null
return expression isequivalent other expression
}
}
return false
}
}