/*
derby - class org.apache.derby.impl.sql.compile.castnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services compiler localfield
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi types datatypeutilities
import org apache derby iapi types stringdatavalue
import org apache derby iapi types typeid
import org apache derby iapi reference limits
import org apache derby iapi reference sqlstate
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql compile typecompiler
import org apache derby iapi util stringutil
import org apache derby iapi reference classname
import org apache derby iapi reference jdbc30translation
import org apache derby iapi services classfile vmopcode
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import java lang reflect modifier
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi types numberdatatype
import org apache derby iapi util jbitset
import org apache derby iapi util reusefactory
import java sql types
import java util vector
/**
* an castnode represents a cast expressionr.
*
*/
public class castnode extends valuenode
valuenode			castoperand
private int					targetchartype
typeid	sourcecti   null
private boolean fordatatypefunction   false
/** this variable gets set by the parser to indiciate that this cast node
* has been generated by the parser. this means that we should use the
* collation info of the current compilation schmea for this node's
* collation setting. if this variable does not get set to true, then it
* means that this cast node has been an internally generated node and we
* should not touch the collation info set for this cast node because it
* has been already set correctly by the class that generated this cast
* node. collation info is part of the datatypedescriptor that's defined
* on the valuenode (the super class of this castnode class)
*/
private boolean externallygeneratedcastnode   false
/*
** static array of valid casts.  dimentions
** produce a single boolean which indicates
** whether the case is possible or not.
*/
/**
* initializer for a castnode
*
* @param castoperand	the operand of the node
* @param casttarget	datatypeservices (target type of cast)
*
* @exception standardexception		thrown on error
*/
public void init object castoperand  object casttarget
throws standardexception
this castoperand    valuenode  castoperand
settype  datatypedescriptor  casttarget
/**
* initializer for a castnode
*
* @param castoperand	the operand of the node
* @param chartype		char or varchar jdbc type as target
* @param charlength	target type length
*
* @exception standardexception		thrown on error
*/
public void init object castoperand  object chartype  object charlength
throws standardexception
this castoperand    valuenode  castoperand
int charlen     integer  charlength  intvalue
targetchartype     integer  chartype  intvalue
if  charlen < 0 	   unknown  figure out later
return
settype datatypedescriptor getbuiltindatatypedescriptor targetchartype  charlen
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return		this object as a string
*/
public string tostring
if  sanitymanager debug
try
return     gettypeservices
super tostring
catch  standardexception e
// temp - gettypeservices() should not be throwing an exception
return
else
return
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  castoperand    null
printlabel depth
castoperand treeprint depth   1
protected int getorderablevarianttype   throws standardexception
return castoperand getorderablevarianttype
/**
* bind this expression.  this means binding the sub-expressions,
* as well as figuring out what the return type is for this expression.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression fromlist fromlist  subquerylist subquerylist
vector aggregatevector
throws standardexception
castoperand   castoperand bindexpression
fromlist  subquerylist
aggregatevector
if  gettypeservices      null      char or varchar function without specifying target length
datatypedescriptor opndtype   castoperand gettypeservices
int length    1
typeid srctypeid   opndtype gettypeid
if  opndtype    null
if  srctypeid isnumerictypeid
length   opndtype getprecision     1     1 for the sign
if  opndtype getscale   > 0
length    1                   1 for the decimal
/*
* derby-1132 : the length for the target type was calculated
* incorrectly while char & varchar functions were used. thus
* adding the check for char & varchar and calculating the
* length based on the operand type.
*/
else if srctypeid isstringtypeid
length   opndtype getmaximumwidth
// truncate the target type width to the max width of the
// data type
if  this targetchartype    types char
length   math min length  limits db2_char_maxwidth
else if  this targetchartype    types varchar
length   math min length  limits db2_varchar_maxwidth
else
typeid typeid   opndtype gettypeid
if  length < 0
length   datatypeutilities getcolumndisplaysize typeid getjdbctypeid    1
if  length < 0
length   1      same default as in parser
settype datatypedescriptor getbuiltindatatypedescriptor targetchartype  length
/*
** if castoperand is an untyped null,
** then we must set the type.
*/
if  castoperand instanceof untypednullconstantnode
castoperand settype gettypeservices
bindcastnodeonly
/* we can't chop out cast above an untyped null because
* the store can't handle it.
*/
if   castoperand instanceof constantnode
castoperand instanceof untypednullconstantnode
/* if the castoperand is a typed constant then we do the cast at
* bind time and return a constant of the correct type.
* note: this could return an exception, but we're prepared to
* deal with that. (numberformatexception, etc.)
* we only worry about the easy (and useful)
* converions at bind time.
* here's what we support:
*			source					destination
*			------					-----------
*			boolean					boolean
*			boolean					char
*			char					boolean
*			char					date/time/ts
*			char					non-decimal numeric
*			date/time/ts			char
*			numeric					char
*			numeric					non-decimal numeric
*/
/* resolve - to be filled in. */
valuenode retnode   this
int		  sourcejdbctypeid   sourcecti getjdbctypeid
int		  destjdbctypeid   gettypeid   getjdbctypeid
switch  sourcejdbctypeid
case types bit
case jdbc30translation sql_types_boolean
// (bit is boolean)
if  destjdbctypeid    types bit    destjdbctypeid    jdbc30translation sql_types_boolean
retnode   castoperand
else if  destjdbctypeid    types char
booleanconstantnode bcn    booleanconstantnode  castoperand
string booleanstring   bcn getvalueasstring
retnode    valuenode  getnodefactory   getnode
c_nodetypes char_constant_node
booleanstring
reusefactory getinteger
gettypeservices   getmaximumwidth
getcontextmanager
break
case types char
retnode   getcastfromcharconstant destjdbctypeid
break
case types date
case types time
case types timestamp
if  destjdbctypeid    types char
string castvalue
usertypeconstantnode  castoperand
getobjectvalue
tostring
retnode    valuenode  getnodefactory   getnode
c_nodetypes char_constant_node
castvalue
reusefactory getinteger
gettypeservices   getmaximumwidth
getcontextmanager
break
case types decimal
// ignore decimal -> decimal casts for now
if  destjdbctypeid    types decimal
destjdbctypeid    types numeric
break
// fall through
case types tinyint
case types smallint
case types integer
case types bigint
case types double
case types real
retnode   getcastfromnumerictype
constantnode  castoperand  getvalue
destjdbctypeid
break
// return the new constant if the cast was performed
return retnode
return this
/**
* bind this node but not its child.  caller has already bound
* the child.
* this is useful for when we generate a castnode during binding
* after having already bound the child.
*
* @exception standardexception		thrown on error
*/
public void bindcastnodeonly
throws standardexception
/*
** the result type is always casttarget.
*/
sourcecti   castoperand gettypeid
//if the result type of cast is string data type, then that data type
//should get it's collation type from the current schema.
if  externallygeneratedcastnode    gettypeid   isstringtypeid
//set the collation type to be same as the compilation schema's
//collation type. collation derivation will be set to "implicit".
setcollationusingcompilationschema
stringdatavalue collation_derivation_implicit
/*
** if it is a java cast, do some work to make sure
** the classes are ok and that they are compatible
*/
if  gettypeid   usertype
string classname   gettypeid   getcorrespondingjavatypename
verifyclassexist classname
settype new datatypedescriptor typeid getuserdefinedtypeid classname  false
true    assume nullable for now  change it if not nullable
// obviously the type of a parameter that
// requires its type from context (a parameter)
// gets its type from the type of the cast.
if  castoperand requirestypefromcontext
castoperand settype gettypeservices
/*
** if it isn't null, then we have
** a cast from one jbms type to another.  so we
** have to figure out if it is legit.
*/
else if    castoperand instanceof untypednullconstantnode
/*
** make sure we can assign the two classes
*/
typecompiler tc   castoperand gettypecompiler
if    tc convertible gettypeid    fordatatypefunction
throw standardexception newexception sqlstate lang_invalid_cast
sourcecti getsqltypename
gettypeid   getsqltypename
/**
* get a constant representing the cast from a char to another
* type.  if this is not an "easy" cast to perform, then just
* return this cast node.
* here's what we think is "easy":
*			source			destination
*			------			-----------
*			char			boolean
*			char			date/time/ts
*			char			non-decimal numeric
*
* @param destjdbctypeid	the destination jdbc typeid
*
* @return the new top of the tree (this castnode or a new constant)
*
* @exception standardexception		thrown on error
*/
private valuenode getcastfromcharconstant int destjdbctypeid
throws standardexception
string	  charvalue     charconstantnode  castoperand  getstring
string	  cleancharvalue   stringutil sqltouppercase charvalue trim
valuenode retnode   this
switch  destjdbctypeid
case types bit
case jdbc30translation sql_types_boolean
if  cleancharvalue equals
return  valuenode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean true
getcontextmanager
else if  cleancharvalue equals
return  valuenode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean false
getcontextmanager
else
throw standardexception newexception sqlstate lang_format_exception
case types date
return  valuenode  getnodefactory   getnode
c_nodetypes usertype_constant_node
getdatavaluefactory   getdatevalue cleancharvalue  false
getcontextmanager
case types timestamp
return  valuenode  getnodefactory   getnode
c_nodetypes usertype_constant_node
getdatavaluefactory   gettimestampvalue cleancharvalue  false
getcontextmanager
case types time
return  valuenode  getnodefactory   getnode
c_nodetypes usertype_constant_node
getdatavaluefactory   gettimevalue cleancharvalue  false
getcontextmanager
case types tinyint
case types smallint
case types integer
case types bigint
try
// #3756 - truncate decimal portion for casts to integer
return getcastfromintegraltype  new double cleancharvalue   longvalue
destjdbctypeid
catch  numberformatexception nfe
string sqlname   typeid getbuiltintypeid destjdbctypeid  getsqltypename
throw standardexception newexception sqlstate lang_format_exception  sqlname
case types real
float floatvalue
try
floatvalue   float valueof cleancharvalue
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_format_exception
return  valuenode  getnodefactory   getnode
c_nodetypes float_constant_node
floatvalue
getcontextmanager
case types double
double doublevalue
try
doublevalue   new double cleancharvalue
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_format_exception
return  valuenode  getnodefactory   getnode
c_nodetypes double_constant_node
doublevalue
getcontextmanager
return retnode
/**
* get a constant representing the cast from an integral type to another
* type.  if this is not an "easy" cast to perform, then just
* return this cast node.
* here's what we think is "easy":
*			source				destination
*			------				-----------
*			integral type		 non-decimal numeric
*			integral type		 char
*
* @param longvalue			integral type as a long to cast from
* @param destjdbctypeid	the destination jdbc typeid
*
* @return the new top of the tree (this castnode or a new constant)
*
* @exception standardexception		thrown on error
*/
private valuenode getcastfromintegraltype
long longvalue
int destjdbctypeid
throws standardexception
valuenode retnode   this
switch  destjdbctypeid
case types char
return  valuenode  getnodefactory   getnode
c_nodetypes char_constant_node
long tostring longvalue
reusefactory getinteger
gettypeservices   getmaximumwidth
getcontextmanager
case types tinyint
if  longvalue < byte min_value
longvalue > byte max_value
throw standardexception newexception sqlstate lang_outside_range_for_datatype
return  valuenode  getnodefactory   getnode
c_nodetypes tinyint_constant_node
reusefactory getbyte  byte  longvalue
getcontextmanager
case types smallint
if  longvalue < short min_value
longvalue > short max_value
throw standardexception newexception sqlstate lang_outside_range_for_datatype
return  valuenode  getnodefactory   getnode
c_nodetypes smallint_constant_node
reusefactory getshort
short  longvalue
getcontextmanager
case types integer
if  longvalue < integer min_value
longvalue > integer max_value
throw standardexception newexception sqlstate lang_outside_range_for_datatype
return  valuenode  getnodefactory   getnode
c_nodetypes int_constant_node
reusefactory getinteger
int  longvalue
getcontextmanager
case types bigint
return  valuenode  getnodefactory   getnode
c_nodetypes longint_constant_node
reusefactory getlong longvalue
getcontextmanager
case types real
if  math abs longvalue  > float max_value
throw standardexception newexception sqlstate lang_outside_range_for_datatype
return  valuenode  getnodefactory   getnode
c_nodetypes float_constant_node
new float  float  longvalue
getcontextmanager
case types double
return  valuenode  getnodefactory   getnode
c_nodetypes double_constant_node
new double  double  longvalue
getcontextmanager
return retnode
/**
* get a constant representing the cast from a non-integral type to another
* type.  if this is not an "easy" cast to perform, then just
* return this cast node.
* here's what we think is "easy":
*			source				destination
*			------				-----------
*			non-integral type	 non-decimal numeric
*			non-integral type	 char
*
* @param constantvalue		non-integral type a a double to cast from
* @param destjdbctypeid	the destination jdbc typeid
*
* @return the new top of the tree (this castnode or a new constant)
*
* @exception standardexception		thrown on error
*/
private valuenode getcastfromnumerictype
datavaluedescriptor constantvalue
int destjdbctypeid
throws standardexception
int nodetype    1
object constantobject   null
switch  destjdbctypeid
case types char
nodetype   c_nodetypes char_constant_node
constantobject   constantvalue getstring
return  valuenode  getnodefactory   getnode
nodetype
constantobject
reusefactory getinteger
gettypeservices   getmaximumwidth
getcontextmanager
case types tinyint
nodetype   c_nodetypes tinyint_constant_node
constantobject   new byte constantvalue getbyte
break
case types smallint
nodetype   c_nodetypes smallint_constant_node
constantobject   reusefactory getshort constantvalue getshort
break
case types integer
nodetype   c_nodetypes int_constant_node
constantobject   reusefactory getinteger constantvalue getint
break
case types bigint
nodetype   c_nodetypes longint_constant_node
constantobject   reusefactory getlong constantvalue getlong
break
case types real
nodetype   c_nodetypes float_constant_node
constantobject   new float numberdatatype normalizereal constantvalue getdouble
break
case types double
// no need to normalize here because no constant could be out of range for a double
nodetype   c_nodetypes double_constant_node
constantobject   new double constantvalue getdouble
break
if  nodetype     1
return this
return  valuenode  getnodefactory   getnode
nodetype
constantobject
getcontextmanager
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
castoperand   castoperand preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
return this
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode.
*
* @exception standardexception			thrown on error
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
throws standardexception
return castoperand categorize referencedtabs  simplepredsonly
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @return valuenode			the remapped expression tree.
*
* @exception standardexception			thrown on error
*/
public valuenode remapcolumnreferencestoexpressions
throws standardexception
castoperand   castoperand remapcolumnreferencestoexpressions
return this
/**
* return whether or not this expression tree represents a constant expression.
*
* @return	whether or not this expression tree represents a constant expression.
*/
public boolean isconstantexpression
return castoperand isconstantexpression
/** @see valuenode#constantexpression */
public boolean constantexpression predicatelist whereclause
return castoperand constantexpression whereclause
/**
* return an object representing the bind time value of this
* expression tree.  if the expression tree does not evaluate to
* a constant at bind time then we return null.
* this is useful for bind time resolution of vtis.
* resolve: what do we do for primitives?
*
* @return	an object representing the bind time value of this expression tree.
*			(null if not a bind time constant.)
*
* @exception standardexception		thrown on error
*/
object getconstantvalueasobject
throws standardexception
object sourceobject   castoperand getconstantvalueasobject
// resolve - need to figure out how to handle casts
if  sourceobject    null
return null
// simple if source and destination are of same type
if  sourcecti getcorrespondingjavatypename   equals
gettypeid   getcorrespondingjavatypename
return sourceobject
// resolve - simply return null until we can figure out how to
// do the cast
return null
/**
* do code generation for this unary operator.
*
* @param acb	the expressionclassbuilder for the class we're generating
* @param mb	the method the code to place the code
*
* @exception standardexception		thrown on error
*/
public void generateexpression expressionclassbuilder acb
methodbuilder mb
throws standardexception
castoperand generateexpression acb  mb
/* no need to generate code for null constants */
if  castoperand instanceof untypednullconstantnode
return
/* hack alert. when casting a parameter, there
* is not sourcecti.  code generation requires one,
* so we simply set it to be the same as the
* destcti.  the user can still pass whatever
* type they'd like in as a parameter.
* they'll get an exception, as expected, if the
* conversion cannot be performed.
*/
else if  castoperand requirestypefromcontext
sourcecti   gettypeid
gendatavalueconversion acb  mb
private void gendatavalueconversion expressionclassbuilder acb
methodbuilder mb
throws standardexception
methodbuilder	acbconstructor   acb getconstructor
string resulttypename   gettypecompiler   interfacename
/* field = method call */
/* allocate an object for re-use to hold the result of the operator */
localfield field   acb newfielddeclaration modifier private  resulttypename
/*
** store the result of the method call in the field, so we can re-use
** the object.
*/
acb generatenull acbconstructor  gettypecompiler gettypeid
gettypeservices   getcollationtype
acbconstructor setfield field
/*
for most types generate
targetdvd.setvalue(sourcedvd);
for source or destination java types generate
object o = sourcedvd.getobject();
targetdvd.setobjectforcast(o, o instanceof dest java type, dest java type);
// optional for variable length types
targetdvd.setwidth();
*/
if   sourcecti usertype       gettypeid   usertype
mb getfield field      targetdvd reference for the setvalue method call
mb swap
mb upcast classname datavaluedescriptor
mb callmethod vmopcode invokeinterface  classname datavaluedescriptor
1
else
/*
** generate: expr.getobject()
*/
mb callmethod vmopcode invokeinterface  classname datavaluedescriptor
0
//castexpr
mb getfield field      instance for the setvalue setobjectforcast method call
mb swap       push it before the value
/*
** we are casting a java type, generate:
**
**		datavaluedescriptor.setobjectforcast(java.lang.object castexpr, boolean instanceofexpr, destinationclassname)
** where instanceofexpr is "source instanceof destinationclass".
**
*/
string destinationtype   gettypeid   getcorrespondingjavatypename
// at this point method instance and cast result are on the stack
// we duplicate the cast value in order to perform the instanceof check
mb dup
mb isinstanceof destinationtype
mb push destinationtype
mb callmethod vmopcode invokeinterface  classname datavaluedescriptor
3
mb getfield field
/*
** if we are casting to a variable length datatype, we
** have to make sure we have set it to the correct
** length.
*/
if  gettypeid   variablelength
boolean isnumber   gettypeid   isnumerictypeid
// to leave the datavaluedescriptor value on the stack, since setwidth is void
mb dup
/* setwidth() is on vsdv - upcast since
* decimal implements subinterface
* of vsdv.
*/
mb push isnumber ? gettypeservices   getprecision     gettypeservices   getmaximumwidth
mb push gettypeservices   getscale
mb push  sourcecti variablelength      isnumber
mb callmethod vmopcode invokeinterface  classname variablesizedatavalue
3
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
visitable returnnode   v visit this
if  v skipchildren this
return returnnode
if  castoperand    null     v stoptraversal
castoperand    valuenode castoperand accept v
return returnnode
/** this method gets called by the parser to indiciate that this cast node
* has been generated by the parser. this means that we should use the
* collation info of the current compilation schmea for this node's
* collation setting. if this method does not get called, then it means
* that this cast node has been an internally generated node and we should
* not touch the collation of this cast node because it has been already
* set correctly by the class that generated this cast node.
*/
void setforexternallygeneratedcastnode
externallygeneratedcastnode   true
/** set this to be a datatypescalarfunction
*
* @param b true to use function conversion rules
*/
void setfordatatypefunction boolean b
fordatatypefunction   b
/**
* {@inheritdoc}
* @throws standardexception
*/
protected boolean isequivalent valuenode o  throws standardexception
if  issamenodetype o
castnode other    castnode o
return gettypeservices   equals other gettypeservices
castoperand isequivalent other castoperand
return false