/*
derby - class org.apache.derby.impl.sql.compile.columnreference
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile nodefactory
import org apache derby iapi types datatypedescriptor
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store access qualifier
import org apache derby iapi util jbitset
import java util vector
/**
* a columnreference represents a column in the query tree.  the parser generates a
* columnreference for each column reference.  a column refercence could be a column in
* a base table, a column in a view (which could expand into a complex
* expression), or a column in a subquery in the from clause.
*
*/
public class columnreference extends valuenode
string	columnname
/*
** this is the user-specified table name.  it will be null if the
** user specifies a column without a table name.  leave it null even
** when the column is bound as it is only used in binding.
*/
tablename	tablename
/* the table this column reference is bound to */
private int			tablenumber
/* the column number in the underlying base table */
private int			columnnumber
/* this is where the value for this column reference will be coming from */
private resultcolumn	source
/* for unremapping */
resultcolumn	origsource
private string	origname
int				origtablenumber    1
int				origcolumnnumber    1
/* reuse generated code where possible */
//expression genresult;
private boolean		replacesaggregate
private int			nestinglevel    1
private int			sourcelevel    1
/* whether or not this column reference been scoped for the
sake of predicate pushdown.
*/
private boolean		scoped
/* list of saved remap data if this columnreference is scoped
and has been remapped multiple times.
*/
private java util arraylist remaps
/**
* initializer.
* this one is called by the parser where we could
* be dealing with delimited identifiers.
*
* @param columnname	the name of the column being referenced
* @param tablename		the qualification for the column
* @param tokbeginoffset begin position of token for the column name
*					identifier from parser.
* @param tokendoffset	end position of token for the column name
*					identifier from parser.
*/
public void init object columnname
object tablename
object	tokbeginoffset
object	tokendoffset
this columnname    string  columnname
this tablename    tablename  tablename
this setbeginoffset   integer  tokbeginoffset  intvalue
this setendoffset   integer  tokendoffset  intvalue
tablenumber    1
remaps   null
/**
* initializer.
*
* @param columnname	the name of the column being referenced
* @param tablename		the qualification for the column
*/
public void init object columnname  object tablename
this columnname    string  columnname
this tablename    tablename  tablename
tablenumber    1
remaps   null
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return     columnname
tablenumber
columnnumber
replacesaggregate
tablename    null  ? tablename tostring
nestinglevel
sourcelevel
super tostring
else
return
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  source    null
printlabel depth
source treeprint depth   1
/**
* return whether or not this cr is correlated.
*
* @return whether or not this cr is correlated.
*/
boolean getcorrelated
if  sanitymanager debug
sanitymanager assert nestinglevel     1
columnname
sanitymanager assert sourcelevel     1
columnname
return sourcelevel    nestinglevel
/**
* set the nesting level for this cr.  (the nesting level
* at which the cr appears.)
*
* @param nestinglevel	the nesting level at which the cr appears.
*/
void setnestinglevel int nestinglevel
if  sanitymanager debug
sanitymanager assert nestinglevel     1
this nestinglevel   nestinglevel
/**
* get the nesting level for this cr.
*
* @return	the nesting level for this cr.
*/
private int getnestinglevel
return nestinglevel
/**
* set the source level for this cr.  (the nesting level
* of the source of the cr.)
*
* @param sourcelevel	the nesting level of the source of the cr.
*/
void setsourcelevel int sourcelevel
if  sanitymanager debug
sanitymanager assert sourcelevel     1
this sourcelevel   sourcelevel
/**
* get the source level for this cr.
*
* @return	the source level for this cr.
*/
int getsourcelevel
return sourcelevel
/**
* mark this node as being generated to replace an aggregate.
* (useful for replacing aggregates in the having clause with
* column references to the matching aggregate in the
* user's select.
*/
public void markgeneratedtoreplaceaggregate
replacesaggregate   true
/**
* determine whether or not this node was generated to
* replace an aggregate in the user's select.
*
* @return boolean	whether or not this node was generated to replace
*					an aggregate in the user's select.
*/
public boolean getgeneratedtoreplaceaggregate
return replacesaggregate
/**
* return a clone of this node.
*
* @return valuenode	a clone of this node.
*
* @exception standardexception			thrown on error
*/
public valuenode getclone
throws standardexception
columnreference newcr    columnreference  getnodefactory   getnode
c_nodetypes column_reference
columnname
tablename
getcontextmanager
newcr copyfields this
return newcr
/**
* copy all of the "appropriate fields" for a shallow copy.
*
* @param oldcr		the columnreference to copy from.
*
* @exception standardexception			thrown on error
*/
public void copyfields columnreference oldcr
throws standardexception
super copyfields oldcr
tablename   oldcr gettablenamenode
tablenumber   oldcr gettablenumber
columnnumber   oldcr getcolumnnumber
source   oldcr getsource
nestinglevel   oldcr getnestinglevel
sourcelevel   oldcr getsourcelevel
replacesaggregate   oldcr getgeneratedtoreplaceaggregate
scoped   oldcr isscoped
/**
* bind this expression.  this means binding the sub-expressions,
* as well as figuring out what the return type is for this expression.
*
* note: we must explicitly check for a null fromlist here, column reference
* without a from list, as the grammar allows the following:
*			insert into t1 values(c1)
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression fromlist fromlist  subquerylist subquerylist
vector aggregatevector
throws standardexception
resultcolumn matchingrc
if  sanitymanager debug
sanitymanager assert fromlist    null
if  fromlist size      0
throw standardexception newexception sqlstate lang_illegal_column_reference  columnname
matchingrc   fromlist bindcolumnreference this
/* error if no match found in fromlist */
if  matchingrc    null
throw standardexception newexception sqlstate lang_column_not_found  getsqlcolumnname
/* set the columnnumber from the base table.
* useful for optimizer and generation.
*/
columnnumber   matchingrc getcolumnposition
return this
/**
* get the column name for purposes of error
* messages or debugging. this returns the column
* name as used in the sql statement. thus if it was qualified
* with a table, alias name that will be included.
*
* @return	the  column name in the form [[schema.]table.]column
*/
public string getsqlcolumnname
if  tablename    null
return columnname
return tablename tostring         columnname
/**
* get the name of this column
*
* @return	the name of this column
*/
public string getcolumnname
return columnname
/**
* set the name of this column
*
* @param columnname	the name of this column
*/
public void setcolumnname string columnname
this columnname   columnname
/**
* get the table number for this columnreference.
*
* @return	int the table number for this columnreference
*/
public int gettablenumber
return tablenumber
/**
* set this columnreference to refer to the given table number.
*
* @param tablenumber	the table number this columnreference will refer to
*/
public void settablenumber int tablenumber
if  sanitymanager debug
sanitymanager assert tablenumber     1
this tablenumber   tablenumber
/**
* get the user-supplied table name of this column.  this will be null
* if the user did not supply a name (for example, select a from t).
* the method will return b for this example, select b.a from t as b
* the method will return t for this example, select t.a from t
*
* @return	the user-supplied name of this column.  null if no user-
* 		supplied name.
*/
public string gettablename
return     tablename    null  ? tablename gettablename     null
/**
* get the name of the underlying(base) table this column comes from, if any.
* following example queries will all return t
* select a from t
* select b.a from t as b
* select t.a from t
*
* @return	the name of the base table that this column comes from.
*			null if not a columnreference.
*/
public string getsourcetablename
return   source    null  ? source gettablename     null
/**
* get the name of the schema for the column's base table, if any.
* following example queries will all return app (assuming user is in schema app)
* select t.a from t
* select b.a from t as b
* select app.t.a from t
*
* @return	the name of the schema for column's base table. if the column
*		is not in a schema (i.e. is a derived column), it returns null.
*/
public string getsourceschemaname   throws standardexception
return   source    null  ? source getschemaname     null
/**
* is the column wirtable by the cursor or not. (ie, is it in the list of for update columns list)
*
* @return true, if the column is a base column of a table and is
* writable by cursor.
*/
public boolean updatablebycursor
return   source    null  ? source updatablebycursor     false
/**
return the table name as the node it is.
@return the column's table name.
*/
public tablename gettablenamenode
return tablename
public void settablenamenode tablename tablename
this tablename   tablename
/**
* get the column number for this columnreference.
*
* @return	int the column number for this columnreference
*/
public int getcolumnnumber
return columnnumber
/**
* set the column number for this columnreference.  this is
* used when scoping predicates for pushdown.
*
* @param colnum the new column number.
*/
public void setcolumnnumber int colnum
this columnnumber   colnum
/**
* get the source this columnreference
*
* @return	the source of this columnreference
*/
public resultcolumn getsource
return source
/**
* set the source this columnreference
*
* @param source	the source of this columnreference
*/
public void setsource resultcolumn source
this source   source
/**
* do the 1st step in putting an expression into conjunctive normal
* form.  this step ensures that the top level of the expression is
* a chain of andnodes.
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode putandsontop
throws standardexception
binarycomparisonoperatornode		equalsnode
booleanconstantnode	truenode
nodefactory		nodefactory   getnodefactory
valuenode		andnode
truenode    booleanconstantnode  nodefactory getnode
c_nodetypes boolean_constant_node
boolean true
getcontextmanager
equalsnode    binarycomparisonoperatornode
nodefactory getnode
c_nodetypes binary_equals_operator_node
this
truenode
getcontextmanager
/* set type info for the operator node */
equalsnode bindcomparisonoperator
andnode    valuenode  nodefactory getnode
c_nodetypes and_node
equalsnode
truenode
getcontextmanager
andnode  andnode  postbindfixup
return andnode
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
*
* also, don't allow a predicate to be pushed down if it contains a
* columnreference that replaces an aggregate.  this can happen if
* the aggregate is in the having clause.  in this case, we would be
* pushing the predicate into the selectnode that evaluates the aggregate,
* which doesn't make sense, since the having clause is supposed to be
* applied to the result of the selectnode.
*
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode or a constantnode.
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
if  sanitymanager debug
sanitymanager assert tablenumber >  0
referencedtabs set tablenumber
return     replacesaggregate
source getexpression   instanceof columnreference
source getexpression   instanceof virtualcolumnnode
source getexpression   instanceof constantnode
/**
* remap all of the columnreferences in this expression tree
* to point to the resultcolumn that is 1 level under their
* current source resultcolumn.
* this is useful for pushing down single table predicates.
*
* resolve: once we start pushing join clauses, we will need to walk the
* resultcolumn/virtualcolumnnode chain for them to remap the references.
*/
public void remapcolumnreferences
valuenode expression   source getexpression
if  sanitymanager debug
// sanitymanager.assert(origsource == null,
// 		"trying to remap columnreference twice without unremapping it.");
if        expression instanceof virtualcolumnnode
expression instanceof columnreference
return
/* scoped column references are a special case: they can be
* remapped several times (once for every projectrestrictnode
* through which the scoped columnreference is pushed before
* reaching its target result set) and will be un-remapped
* several times, as well (as the scoped predicate is "pulled"
* back up the query tree to it's original location).  so we
* have to keep track of the "orig" info for every remap
* operation, not just for the most recent one.
*/
if  scoped     origsource    null
if  remaps    null
remaps   new java util arraylist
remaps add new remapinfo
columnnumber  tablenumber  columnname  source
else
origsource   source
origname   columnname
origcolumnnumber   columnnumber
origtablenumber   tablenumber
/* find the matching resultcolumn */
source   getsourceresultcolumn
columnname   source getname
columnnumber   source getcolumnposition
if  source getexpression   instanceof columnreference
columnreference cr    columnreference  source getexpression
tablenumber   cr gettablenumber
if  sanitymanager debug
// if dummy cr generated to replace aggregate, it may not have table number
// because underneath can be more than 1 table.
if  tablenumber     1      cr getgeneratedtoreplaceaggregate
sanitymanager throwassert
origname
public void unremapcolumnreferences
if  origsource    null
return
if  sanitymanager debug
// sanitymanager.assert(origsource != null,
// 	"trying to unremap a columnreference that was not remapped.");
if   remaps    null      remaps size      0
source   origsource
origsource   null
columnname   origname
origname   null
tablenumber   origtablenumber
columnnumber   origcolumnnumber
else
// this cr is multiply-remapped, so undo the most
// recent (and only the most recent) remap operation.
remapinfo ri    remapinfo remaps remove remaps size     1
source   ri getsource
columnname   ri getcolumnname
tablenumber   ri gettablenumber
columnnumber   ri getcolumnnumber
ri   null
if  remaps size      0
remaps   null
/**
* returns true if this columnreference has been remapped; false
* otherwise.
*
* @return whether or not this columnreference has been remapped.
*/
protected boolean hasbeenremapped
return  origsource    null
/*
* get the resultcolumn that the source points to.  this is useful for
* getting what the source will be after this columnreference is remapped.
*/
public resultcolumn getsourceresultcolumn
/* resolve - if expression is a columnreference, then we are hitting
* the top of a query block (derived table or view.)
* in order to be able to push the expression down into the next
* query block, it looks like we should reset the contents of the
* current columnreference to be the same as expression.  (this probably
* only means names and tablenumber.)  we would then "rebind" the top
* level predicate somewhere up the call stack and see if we could push
* the predicate through.
*/
return source getexpression   getsourceresultcolumn
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @return valuenode			the remapped expression tree.
*
* @exception standardexception			thrown on error
*/
public valuenode remapcolumnreferencestoexpressions
throws standardexception
resultcolumn	rc
resultcolumn	sourcerc   source
/* nothing to do if we are not pointing to a redundant rc */
if    source isredundant
return this
/* find the last redundant rc in the chain.  we
* want to clone its expression.
*/
for  rc   source  rc    null    rc isredundant
/* find the matching resultcolumn */
resultcolumn nextrc   rc getexpression   getsourceresultcolumn
if  nextrc    null    nextrc isredundant
sourcerc   nextrc
rc   nextrc
if  sanitymanager debug
if  sourcerc    null
sanitymanager throwassert
columnname
if     sourcerc isredundant
sanitymanager throwassert
columnname
/* if last expression is a vcn, then we can't clone it.
* instead, we just reset our source to point to the
* source of the vcn, those chopping out the layers.
* otherwise, we return a clone of the underlying expression.
*/
if  sourcerc getexpression   instanceof virtualcolumnnode
virtualcolumnnode vcn
virtualcolumnnode   sourcerc getexpression
resultsetnode rsn   vcn getsourceresultset
if  rsn instanceof fromtable
fromtable ft    fromtable rsn
tablenumber   ft gettablenumber
if  sanitymanager debug
sanitymanager assert tablenumber     1
/* it's not enough to just set the table number.  depending
* on the original query specified and on whether or not
* subquery flattening has occurred, it's possible that
* the expression to which we're remapping has a different
* rcl ordering than the one to which we were mapped before
* we got here.  in that case we also need to update the
* columnnumber to point to the correct column in "ft".
* see derby-2526 for details.
*/
resultcolumn ftrc
ft getresultcolumns   getresultcolumn columnname
if  sanitymanager debug
sanitymanager assert ftrc    null
columnname
ft gettablename
columnnumber   ftrc getcolumnposition
else
if  sanitymanager debug
sanitymanager throwassert     rsn getclass   getname
source   sourcerc getexpression   getsourceresultcolumn
return this
else
return sourcerc getexpression   getclone
/**
* update the table map to reflect the source
* of this cr.
*
* @param refs	the table map.
*/
void gettablesreferenced jbitset refs
if  refs size   < tablenumber
refs grow tablenumber
if  tablenumber     1 	   it may not be set if replacesaggregate is true
refs set tablenumber
/**
* return whether or not this expression tree is cloneable.
*
* @return boolean	whether or not this expression tree is cloneable.
*/
public boolean iscloneable
return true
/** @see valuenode#constantexpression */
public boolean constantexpression predicatelist whereclause
return whereclause constantcolumn this
/**
* columnreference's are to the current row in the system.
* this lets us generate
* a faster get that simply returns the column from the
* current row, rather than getting the value out and
* returning that, only to have the caller (in the situations
* needed) stuffing it back into a new column holder object.
* we will assume the general generate() path is for getting
* the value out, and use generatecolumn() when we want to
* keep the column wrapped.
*
* @exception standardexception		thrown on error
*/
public void generateexpression expressionclassbuilder acb
methodbuilder mb
throws standardexception
int sourceresultsetnumber   source getresultsetnumber
//pushcompile
/* reuse generated code, where possible */
/*
** if the source is redundant, return the generation of its source.
** most redundant nodes will be flattened out by this point, but
** in at least one case (elimination of redundant projectrestricts
** during generation) we don't do this.
*/
if  source isredundant
source generateexpression acb  mb
return
if  sanitymanager debug
if  sourceresultsetnumber < 0
sanitymanager throwassert     gettablename         getcolumnname
/* the columnreference is from an immediately underlying resultset.
* the row for that resultset is activation.row[sourceresultsetnumber],
* where sourceresultsetnumber is the resultsetnumber for that resultset.
*
* the generated java is the expression:
*	(<interface>) this.row[sourceresultsetnumber].getcolumn(#columnid);
*
* where <interface> is the appropriate datatype protocol interface
* for the type of the column.
*/
acb pushcolumnreference mb  sourceresultsetnumber
source getvirtualcolumnid
mb cast gettypecompiler   interfacename
/* remember generated code for possible resuse */
/**
* get the user-supplied schema name of this column.  this will be null
* if the user did not supply a name (for example, select t.a from t).
* another example for null return value (for example, select b.a from t as b).
* but for following query select app.t.a from t, this will return app
* code generation of aggregate functions relies on this method
*
* @return	the user-supplied schema name of this column.  null if no user-
* 		supplied name.
*/
public string getschemaname
return     tablename    null  ? tablename getschemaname     null
/**
* return the variant type for the underlying expression.
* the variant type can be:
*		variant				- variant within a scan
*							  (method calls and non-static field access)
*		scan_invariant		- invariant within a scan
*							  (column references from outer tables)
*		query_invariant		- invariant within the life of a query
*							  (constant expressions)
*
* @return	the variant type for the underlying expression.
*/
protected int getorderablevarianttype
// columnreferences are invariant for the life of the scan
return qualifier scan_invariant
/**
* return whether or not the source of this columnreference is itself a columnreference.
*
* @return whether or not the source of this columnreference is itself a columnreference.
*/
boolean pointstocolumnreference
return  source getexpression   instanceof columnreference
/**
* get the datatypeservices from this node.
*
* @return	the datatypeservices from this node.  this
*		may be null if the node isn't bound yet.
*/
public datatypedescriptor gettypeservices   throws standardexception
datatypedescriptor dtd   super gettypeservices
if  dtd    null    source    null
dtd   source gettypeservices
if  dtd    null
settype  dtd
return dtd
end of gettypeservices
/**
* find the source result set for this columnreference and
* return it.  also, when the source result set is found,
* return the position (within the source result set's rcl)
* of the column referenced by this columnreference.  the
* position is returned vai the colnum parameter.
*
* @param colnum place to store the position of the column
*  to which this columnreference points (position is w.r.t
*  the source result set).
* @return the source result set for this columnreference;
*  null if there is no source result set.
*/
protected resultsetnode getsourceresultset int  colnum
throws standardexception
if  source    null
/* this can happen if column reference is pointing to a column
* that is not from a base table.  for example, if we have a
* values clause like
*
*    (values (1, 2), (3, 4)) v1 (i, j)
*
* and then a column reference to vi.i, the column reference
* won't have a source.
*/
return null
valuenode rcexpr   null
resultcolumn rc   getsource
// walk the resultcolumn->columnreference chain until we
// find a resultcolumn whose expression is a virtualcolumnnode.
rcexpr   rc getexpression
colnum   getcolumnnumber
/* we have to make sure we enter this loop if rc is redundant,
* so that we can navigate down to the actual source result
* set (derby-1777). if rc *is* redundant, then rcexpr is not
* guaranteed to be a columnreference, so we have to check
* for that case inside the loop.
*/
while   rcexpr    null
rc isredundant       rcexpr instanceof columnreference
if  rcexpr instanceof columnreference
colnum     columnreference rcexpr  getcolumnnumber
rc     columnreference rcexpr  getsource
/* if "rc" is redundant then that means it points to another
* resultcolumn that in turn points to the source expression.
* this can happen in cases where "rc" points to a subquery
* that has been flattened into the query above it (flattening
* of subqueries occurs during preprocessing).  in that case
* we want to skip over the redundant rc and find the
* resultcolumn that actually holds the source expression.
*/
while  rc isredundant
rcexpr   rc getexpression
if  rcexpr instanceof virtualcolumnnode
rc   rcexpr getsourceresultcolumn
else if  rcexpr instanceof columnreference
colnum     columnreference rcexpr  getcolumnnumber
rc     columnreference rcexpr  getsource
else
/* if rc isn't pointing to a virtualcolumnnode nor
* to a columnreference, then it's not pointing to
* a result set.  it could, for example, be pointing
* to a constant node or to the result of an aggregate
* or function.  break out of both loops and return
* null since there is no source result set.
*/
rcexpr   null
break
rcexpr   rc getexpression
// if we found a virtualcolumnnode, return the virtualcolumnnode's
// sourceresultset.  the column within that sourceresultset that
// is referenced by this columnreference is also returned, via
// the colnum parameter, and was set above.
if   rcexpr    null      rcexpr instanceof virtualcolumnnode
return   virtualcolumnnode rcexpr  getsourceresultset
// if we get here then the columnreference doesn't reference
// a result set, so return null.
colnum    1
return null
protected boolean isequivalent valuenode o  throws standardexception
if   issamenodetype o
return false
columnreference other    columnreference o
return  tablenumber    other tablenumber
columnname equals other getcolumnname
/**
* mark this column reference as "scoped", which means that it
* was created (as a clone of another columnreference) to serve
* as the left or right operand of a scoped predicate.
*/
protected void markasscoped
scoped   true
/**
* return whether or not this columnreference is scoped.
*/
protected boolean isscoped
return scoped
/**
* helper class to keep track of remap data when a columnreference
* is remapped multiple times.  this allows the cr to be un-
* remapped multiple times, as well.
*/
private class remapinfo
int colnum
int tablenum
string colname
resultcolumn source
remapinfo int cnum  int tnum  string cname  resultcolumn rc
colnum   cnum
tablenum   tnum
colname   cname
source   rc
int getcolumnnumber     return colnum
int gettablenumber     return tablenum
string getcolumnname     return colname
resultcolumn getsource     return source
void setcolnumber int cnum    colnum   cnum
void settablenumber int tnum    tablenum   tnum
void setcolname string cname    colname   cname
void setsource resultcolumn rc    source   rc