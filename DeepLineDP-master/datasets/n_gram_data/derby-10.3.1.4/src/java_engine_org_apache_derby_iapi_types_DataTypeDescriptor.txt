/*
derby - class org.apache.derby.iapi.types.datatypedescriptor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi types
import java io ioexception
import java io objectinput
import java io objectoutput
import java sql types
import java text rulebasedcollator
import org apache derby catalog typedescriptor
import org apache derby catalog types typedescriptorimpl
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services io formatable
import org apache derby iapi services io storedformatids
import org apache derby iapi services loader classfactory
import org apache derby iapi services loader classinspector
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql conn connectionutil
/**
* this is an implementation of datatypedescriptor from the generic language
* datatype module interface.
*
* @version 1.0
*/
public final class datatypedescriptor implements typedescriptor  formatable
/********************************************************
**
**	this class implements formatable. that means that it
**	can write itself to and from a formatted stream. if
**	you add more fields to this class, make sure that you
**	also write/read them with the writeexternal()/readexternal()
**	methods.
**
**	if, inbetween releases, you add more fields to this class,
**	then you should bump the version number emitted by the gettypeformatid()
**	method.
**
********************************************************/
/*
** static creators
*/
/**
* get a descriptor that corresponds to a builtin jdbc type.
*
* @param jdbctype	the int type of the jdbc type for which to get
*						a corresponding sql datatypedescriptor
*
* @return	a new datatypedescriptor that corresponds to the java type.
*			a null return value means there is no corresponding sql type
*/
public static datatypedescriptor getbuiltindatatypedescriptor
int	jdbctype
return datatypedescriptor getbuiltindatatypedescriptor jdbctype  true
public static datatypedescriptor getbuiltindatatypedescriptor
int	jdbctype
int length
return datatypedescriptor getbuiltindatatypedescriptor jdbctype  true  length
/**
* get a descriptor that corresponds to a builtin jdbc type.
*
* @param jdbctype	the int type of the jdbc type for which to get
*						a corresponding sql datatypedescriptor
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
*
* @return	a new datatypedescriptor that corresponds to the java type.
*			a null return value means there is no corresponding sql type
*/
public static datatypedescriptor getbuiltindatatypedescriptor
int	jdbctype
boolean	isnullable
typeid typeid   typeid getbuiltintypeid jdbctype
if  typeid    null
return null
return new datatypedescriptor typeid  isnullable
/**
* get a descriptor that corresponds to a builtin jdbc type.
*
* @param jdbctype	the int type of the jdbc type for which to get
*						a corresponding sql datatypedescriptor
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
*
* @return	a new datatypedescriptor that corresponds to the java type.
*			a null return value means there is no corresponding sql type
*/
public static datatypedescriptor getbuiltindatatypedescriptor
int	jdbctype
boolean	isnullable
int maxlength
typeid typeid   typeid getbuiltintypeid jdbctype
if  typeid    null
return null
return new datatypedescriptor typeid  isnullable  maxlength
/**
* get a datatypeservices that corresponds to a builtin sql type
*
* @param sqltypename	the name of the type for which to get
*						a corresponding sql datatypedescriptor
*
* @return	a new datatypedescriptor that corresponds to the java type.
*			a null return value means there is no corresponding sql type (only for 'char')
*/
public static datatypedescriptor getbuiltindatatypedescriptor
string	sqltypename
return new datatypedescriptor typeid getbuiltintypeid sqltypename   true
/**
* get a datatypeservices that corresponds to a builtin sql type
*
* @param sqltypename	the name of the type for which to get
*						a corresponding sql datatypedescriptor
*
* @return	a new datatypedescriptor that corresponds to the java type.
*			a null return value means there is no corresponding sql type (only for 'char')
*/
public static datatypedescriptor getbuiltindatatypedescriptor
string	sqltypename
int length
return new datatypedescriptor typeid getbuiltintypeid sqltypename   true  length
/**
* get a datatypeservices that corresponds to a java type
*
* @param javatypename	the name of the java type for which to get
*						a corresponding sql datatypedescriptor
*
* @return	a new datatypedescriptor that corresponds to the java type.
*			a null return value means there is no corresponding sql type (only for 'char')
*/
public static datatypedescriptor getsqldatatypedescriptor
string	javatypename
return datatypedescriptor getsqldatatypedescriptor javatypename  true
/**
* get a datatypeservices that corresponds to a java type
*
* @param javatypename	the name of the java type for which to get
*						a corresponding sql datatypedescriptor
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
*
* @return	a new datatypedescriptor that corresponds to the java type.
*			a null return value means there is no corresponding sql type (only for 'char')
*/
public static datatypedescriptor getsqldatatypedescriptor
string	javatypename
boolean	isnullable
typeid typeid   typeid getsqltypeforjavatype javatypename
if  typeid    null
return null
return new datatypedescriptor typeid  isnullable
/**
* get a datatypedescriptor that corresponds to a java type
*
* @param javatypename	the name of the java type for which to get
*						a corresponding sql datatypedescriptor
* @param precision	the number of decimal digits
* @param scale		the number of digits after the decimal point
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
* @param maximumwidth	the maximum width of a data value
*			represented by this type.
*
* @return	a new datatypedescriptor that corresponds to the java type.
*			a null return value means there is no corresponding sql type.
*/
public static datatypedescriptor getsqldatatypedescriptor
string	javatypename
int 	precision
int 	scale
boolean	isnullable
int 	maximumwidth
typeid typeid   typeid getsqltypeforjavatype javatypename
if  typeid    null
return null
return new datatypedescriptor typeid
precision
scale
isnullable
maximumwidth
/*
** instance fields & methods
*/
private typedescriptorimpl	typedescriptor
private typeid			typeid
/**
* public niladic constructor. needed for formatable interface to work.
*
*/
public	datatypedescriptor
/**
* constructor for use with numeric types
*
* @param typeid	the typeid of the type being described
* @param precision	the number of decimal digits.
* @param scale		the number of digits after the decimal point.
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
* @param maximumwidth	the maximum number of bytes for this datatype
*/
public datatypedescriptor typeid typeid  int precision  int scale
boolean isnullable  int maximumwidth
this typeid   typeid
typedescriptor   new typedescriptorimpl typeid getbasetypeid
precision
scale
isnullable
maximumwidth
/**
* constructor to use when the caller doesn't know if it is requesting
* numeric or no-numeric dtd. for instance, when dealing with max/min
* aggregrate operators, aggregatenode.bindexpression could be dealing
* with a character string operand or a numeric operand. the result of
* max/min will depend on the type of it's operand. and hence when this
* constructor gets called by aggregatenode.bindexpression, we don't know
* what type we are constructing and hence this constructor supports
* arguments for both numeric and non-numeric types.
*
* @param typeid	the typeid of the type being described
* @param precision	the number of decimal digits.
* @param scale		the number of digits after the decimal point.
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
* @param maximumwidth	the maximum number of bytes for this datatype
* @param collationtype the collation type of a string data type
* @param collationderivation collation derivation of a string data type
*/
public datatypedescriptor typeid typeid  int precision  int scale
boolean isnullable  int maximumwidth  int collationtype
int collationderivation
this typeid   typeid
typedescriptor   new typedescriptorimpl typeid getbasetypeid
precision
scale
isnullable
maximumwidth
collationtype
collationderivation
/**
* constructor for use with non-numeric types
*
* @param typeid	the typeid of the type being described
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
* @param maximumwidth	the maximum number of bytes for this datatype
*/
public datatypedescriptor typeid typeid  boolean isnullable
int maximumwidth
this typeid   typeid
typedescriptor   new typedescriptorimpl typeid getbasetypeid
isnullable
maximumwidth
public datatypedescriptor typeid typeid  boolean isnullable
this typeid   typeid
typedescriptor   new typedescriptorimpl typeid getbasetypeid
typeid getmaximumprecision
typeid getmaximumscale
isnullable
typeid getmaximummaximumwidth
public datatypedescriptor datatypedescriptor source  boolean isnullable
//there might be other places, but one place this method gets called
//from is resultcolumn.init. when the resultcolumn(rc) is for a
//columndescriptor(cd), the rc's typedescriptorimpl(tdi) should get
//all the attributes of cd's tdi. so, if the cd is for a user table's
//character type column, then this call by rc.init should have cd's
//collation attributes copied into rc along with other attributes.
this typeid   source typeid
typedescriptor   new typedescriptorimpl source typedescriptor
source getprecision
source getscale
isnullable
source getmaximumwidth
source getcollationtype
source getcollationderivation
/**
* constructor for internal uses only.
* (this is useful when the precision and scale are potentially wider than
* those in the source, like when determining the dominant data type.)
*
* @param source	the dtsi to copy
* @param precision	the number of decimal digits.
* @param scale		the number of digits after the decimal point.
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
* @param maximumwidth	the maximum number of bytes for this datatype
*/
public datatypedescriptor datatypedescriptor source
int precision
int scale
boolean isnullable
int maximumwidth
this typeid   source typeid
typedescriptor   new typedescriptorimpl source typedescriptor
precision
scale
isnullable
maximumwidth
source getcollationtype
source getcollationderivation
/**
* constructor for internal uses only
*
* @param source	the dtsi to copy
* @param isnullable	true means it could contain null, false means
*			it definitely cannot contain null.
* @param maximumwidth	the maximum number of bytes for this datatype
*/
public datatypedescriptor datatypedescriptor source  boolean isnullable
int maximumwidth
this typeid   source typeid
typedescriptor   new typedescriptorimpl source typedescriptor
source getprecision
source getscale
isnullable
maximumwidth
source getcollationtype
source getcollationderivation
/**
* constructor for use in reconstructing a datatypedescriptor from a
* typedescriptorimpl and a typeid
*
* @param source	the typedescriptorimpl to construct this dtsi from
*/
public datatypedescriptor typedescriptorimpl source  typeid typeid
typedescriptor   source
this typeid   typeid
/* datatypedescriptor interface */
public datavaluedescriptor normalize datavaluedescriptor source
datavaluedescriptor cacheddest
throws standardexception
if  sanitymanager debug
if  cacheddest    null
if   gettypeid   isuserdefinedtypeid
string t1   gettypename
string t2   cacheddest gettypename
if   t1 equals t2
if      t1 equals       t1 equals
t2 equals       t2 equals
t1 startswith       t2 startswith          int integer
sanitymanager throwassert
t2       t1
if  source isnull
if   isnullable
throw standardexception newexception sqlstate lang_null_into_non_null
if  cacheddest    null
cacheddest   getnull
else
cacheddest settonull
else
if  cacheddest    null
cacheddest   getnull
int jdbcid   getjdbctypeid
cacheddest normalize this  source
//doing the following check after normalize so that normalize method would get called on long varchs and long varbinary
//need normalize to be called on long varchar for bug 5592 where we need to enforce a lenght limit in db2 mode
if   jdbcid    types longvarchar      jdbcid    types longvarbinary
// special case for possible streams
if  source getclass      cacheddest getclass
return source
return cacheddest
/**
* get the dominant type (datatypedescriptor) of the 2.
* for variable length types, the resulting type will have the
* biggest max length of the 2.
* if either side is nullable, then the result will also be nullable.
*
* if dealing with character string types, then make sure to set the
* collation info on the dominant type. following algorithm will be used
* for dominant dtd's collation determination. each of the steps of the
* algorithm have been numbered in the comments below and those same
* numbers are used in the actual algorithm below so it is easier to
* understand and maintain.
*
* step 1
* if the dtd for "this" node has the same collation derivation as the
* otherdts, then check if their collation types match too. if the
* collation types match too, then dtd for dominant type will get the same
* collation derivation and type.
*
* step 2
* if the collation derivation for dtd for "this" node and otherdts do not
* match, then check if one of them has the collation derivation of none.
* if that is the case, then dominant dtd will get the collation type and
* derivation of dtd whose collation derivation is not none.
*
* step 3
* if the collation derivation for dtd for "this" node and otherdts do not
* match, and none of them have the derivation of none then it means that
* we are dealing with collation derivation of implicit and explicit and
* hence the dominant dtd should get collation derivation of none. this is
* not a possibility in derby 10.3 because the only 2 possible collation
* derivation supported are implicit and none.
*
* step 4
* if the collation derivation for dtd for "this" node and otherdts match,
* then check if the collation types match too. if not, then the dominant
* dtd should get collation derivation of none.
*
* @param otherdts	datatypedescriptor to compare with.
* @param cf		a classfactory
*
* @return datatypedescriptor  dts for dominant type
*
* @exception standardexception		thrown on error
*/
public datatypedescriptor getdominanttype datatypedescriptor otherdts  classfactory cf
throws standardexception
boolean				nullable
typeid				thistype
typeid				othertype
datatypedescriptor	highertype   null
datatypedescriptor	lowertype   null
int					maximumwidth
int					precision   getprecision
int					scale   getscale
thistype   gettypeid
othertype   otherdts gettypeid
/* the result is nullable if either side is nullable */
nullable   isnullable      otherdts isnullable
/*
** the result will have the maximum width of both sides
*/
maximumwidth    getmaximumwidth   > otherdts getmaximumwidth
? getmaximumwidth     otherdts getmaximumwidth
/* we need 2 separate methods of determining type dominance - 1 if both
* types are system built-in types and the other if at least 1 is
* a user type. (typeprecedence is meaningless for user types.)
*/
if   thistype usertype       othertype usertype
typeid  highertypeid
typeid  lowertypeid
if  thistype typeprecedence   > othertype typeprecedence
highertype   this
lowertype   otherdts
highertypeid   thistype
lowertypeid   othertype
else
highertype   otherdts
lowertype   this
highertypeid   othertype
lowertypeid   thistype
//following is checking if higher type argument is real and other argument is decimal/bigint/integer/smallint,
//then result type should be double
if  highertypeid isrealtypeid        lowertypeid isrealtypeid       lowertypeid isnumerictypeid
highertype   datatypedescriptor getbuiltindatatypedescriptor types double
highertypeid   typeid getbuiltintypeid types double
/*
** if we have a decimal/numeric we have to do some
** extra work to make sure the resultant type can
** handle the maximum values for the two input
** types.  we cannot just take the maximum for
** precision.  e.g. we want something like:
**
**		dec(10,10) and dec(3,0) => dec(13,10)
**
** (var)char type needs some conversion handled later.
*/
if  highertypeid isdecimaltypeid        lowertypeid isstringtypeid
precision   highertypeid getprecision this  otherdts
if  precision > 31  precision   31    db2 silently does this and so do we
scale   highertypeid getscale this  otherdts
/* maximumwidth needs to count possible leading '-' and
* decimal point and leading '0' if scale > 0.  see also
* sqlgrammar.jj(exactnumerictype).  beetle 3875
*/
maximumwidth    scale > 0  ? precision   3   precision   1
else if  thistype typeprecedence      othertype typeprecedence
precision   highertype getprecision
scale   highertype getscale
/* gross hacks:
* if we are doing an implicit (var)char->(var)bit conversion
* then the maximum width for the (var)char as a (var)bit
* is really 16 * its width as a (var)char.  adjust
* maximumwidth accordingly.
* if we are doing an implicit (var)char->decimal conversion
* then we need to increment the decimal's precision by
* 2 * the maximum width for the (var)char and the scale
* by the maximum width for the (var)char. the maximumwidth
* becomes the new precision + 3.  this is because
* the (var)char could contain any decimal value from xxxxxx
* to 0.xxxxx.  (in other words, we don't know which side of the
* decimal point the characters will be on.)
*/
if  lowertypeid isstringtypeid
if  highertypeid isbittypeid
highertypeid islongconcatabletypeid
if  lowertypeid islongconcatabletypeid
if  maximumwidth >  integer max_value   16
maximumwidth   integer max_value
else
maximumwidth    16
else
int charmaxwidth
int fromwidth   lowertype getmaximumwidth
if  fromwidth >  integer max_value   16
charmaxwidth   integer max_value
else
charmaxwidth   16   fromwidth
maximumwidth    maximumwidth >  charmaxwidth  ?
maximumwidth   charmaxwidth
/*
* if we are doing an implicit (var)char->decimal conversion
* then the resulting decimal's precision could be as high as
* 2 * the maximum width (precisely 2mw-1) for the (var)char
* and the scale could be as high as the maximum width
* (precisely mw-1) for the (var)char.
* the maximumwidth becomes the new precision + 3.  this is
* because the (var)char could contain any decimal value from
* xxxxxx to 0.xxxxx.  (in other words, we don't know which
* side of the decimal point the characters will be on.)
*
* we don't follow this algorithm for long varchar because the
* maximum length of a long varchar is maxint, and we don't
* want to allocate a huge decimal value.  so in this case,
* the precision, scale, and maximum width all come from
* the decimal type.
*/
if  lowertypeid isstringtypeid
lowertypeid islongconcatabletypeid
highertypeid isdecimaltypeid
int charmaxwidth   lowertype getmaximumwidth
int charprecision
/*
** be careful not to overflow when calculating the
** precision.  remember that we will be adding
** three to the precision to get the maximum width.
*/
if  charmaxwidth >  integer max_value   3    2
charprecision   integer max_value   3
else
charprecision   charmaxwidth   2
if  precision < charprecision
precision   charprecision
if  scale < charmaxwidth
scale   charmaxwidth
maximumwidth   precision   3
else
/* at least 1 type is not a system built-in type */
classinspector		cu   cf getclassinspector
typeid thiscomptype    typeid  thistype
typeid othercomptype    typeid  othertype
if  cu assignableto thiscomptype getcorrespondingjavatypename
othercomptype getcorrespondingjavatypename
highertype   otherdts
else
if  sanitymanager debug
sanitymanager assert
cu assignableto othercomptype getcorrespondingjavatypename
thiscomptype getcorrespondingjavatypename
othercomptype getcorrespondingjavatypename
thiscomptype getcorrespondingjavatypename
highertype   this
precision   highertype getprecision
scale   highertype getscale
highertype   new datatypedescriptor highertype
precision  scale  nullable  maximumwidth
//set collation info on the dtd for dominant type if it is string type
//the algorithm used is explained in this method's javadoc
if  highertype gettypeid   isstringtypeid
if  getcollationderivation      otherdts getcollationderivation
if  getcollationderivation      stringdatavalue collation_derivation_none
//step 2
highertype setcollationderivation otherdts getcollationderivation
highertype setcollationtype otherdts getcollationtype
else if  otherdts getcollationderivation      stringdatavalue collation_derivation_none
//step 2
highertype setcollationderivation getcollationderivation
highertype setcollationtype getcollationtype
else
//step 3
highertype setcollationderivation stringdatavalue collation_derivation_none
else if  getcollationtype      otherdts getcollationtype
//step 4
highertype setcollationderivation stringdatavalue collation_derivation_none
else
//step 1
highertype setcollationderivation getcollationderivation
highertype setcollationtype getcollationtype
return highertype
/**
* check whether or not the 2 types (datatypedescriptor) have the same type
* and length.
* this is useful for union when trying to decide whether a normalizeresultset
* is required.
*
* @param otherdts	datatypedescriptor to compare with.
*
* @return boolean  whether or not the 2 dtss have the same type and length.
*/
public boolean isexacttypeandlengthmatch datatypedescriptor otherdts
/* do both sides have the same length? */
if  getmaximumwidth      otherdts getmaximumwidth
return false
if  getscale      otherdts getscale
return false
if  getprecision      otherdts getprecision
return false
typeid thistype   gettypeid
typeid othertype   otherdts gettypeid
/* do both sides have the same type? */
if     thistype equals othertype
return false
return true
/**
* @see typedescriptor#getmaximumwidth
*/
public int	getmaximumwidth
return typedescriptor getmaximumwidth
/**
* @see typedescriptor#getmaximumwidthinbytes
*/
public int	getmaximumwidthinbytes
return typedescriptor getmaximumwidthinbytes
/**
* gets the typeid for the datatype.
*
* @return	the typeid for the datatype.
*/
public typeid gettypeid
return typeid
/**
get a null for this type.
*/
public datavaluedescriptor getnull   throws standardexception
datavaluedescriptor returndvd   typeid getnull
//if we are dealing with default collation, then we have got the
//right dvd already. just return it.
if  typedescriptor getcollationtype      stringdatavalue collation_type_ucs_basic
return returndvd
//if we are dealing with territory based collation and returndvd is
//of type stringdatavalue, then we need to return a stringdatavalue
//with territory based collation.
if  returndvd instanceof stringdatavalue
try
rulebasedcollator rbs   connectionutil getcurrentlcc   getdatavaluefactory
getcharactercollator typedescriptor getcollationtype
return   stringdatavalue returndvd  getvalue rbs
catch  java sql sqlexception sqle
throw standardexception plainwrapexception  sqle
else
return returndvd
/**
* gets the name of this datatype.
*
*
*  @return	the name of this datatype
*/
public	string		gettypename
return typeid getsqltypename
/**
* get the jdbc type id for this type.  jdbc type can be
* found in java.sql.types.
*
* @return	a jdbc type, e.g. java.sql.types.decimal
*
* @see types
*/
public int getjdbctypeid
return typeid getjdbctypeid
/**
* returns the number of decimal digits for the datatype, if applicable.
*
* @return	the number of decimal digits for the datatype.  returns
*		zero for non-numeric datatypes.
*/
public int	getprecision
return typedescriptor getprecision
/**
* returns the number of digits to the right of the decimal for
* the datatype, if applicable.
*
* @return	the number of digits to the right of the decimal for
*		the datatype.  returns zero for non-numeric datatypes.
*/
public int	getscale
return typedescriptor getscale
/** @see typedescriptor#getcollationtype() */
public int	getcollationtype
return typedescriptor getcollationtype
/**
* gets the name of this datatype.
* <p>
* used to generate strings decribing collation type for error messages.
*
*
*  @return	the name of the collation being used in this type.
*/
public string getcollationname
return typedescriptor getcollationname
/**
* set the collation type of this typedescriptor
* @param collationtypevalue this will be collation_type_ucs_basic
* or collation_type_territory_based
*
* @see stringdatavalue#collation_type_ucs_basic
* @see stringdatavalue#collation_type_territory_based
*/
public void	setcollationtype int collationtypevalue
typedescriptor setcollationtype collationtypevalue
/** @see typedescriptor#getcollationderivation() */
public int	getcollationderivation
return typedescriptor getcollationderivation
/**
* set the collation derivation of this dtd
* @param collationderivationvalue this will be
* collation_derivation_none/collation_derivation_implicit/collation_derivation_explicit
* in derby 10.3, we do not expect to get value collation_derivation_explicit.
*
* @see stringdatavalue#collation_derivation_none
* @see stringdatavalue#collation_derivation_implicit
* @see stringdatavalue#collation_derivation_explicit
*/
public void	setcollationderivation int collationderivationvalue
typedescriptor setcollationderivation collationderivationvalue
/**
* returns true if the datatype can contain null, false if not.
* jdbc supports a return value meaning "nullability unknown" -
* i assume we will never have columns where the nullability is unknown.
*
* @return	true if the datatype can contain null, false if not.
*/
public boolean	isnullable
return typedescriptor isnullable
/**
* set the nullability of the datatype described by this descriptor
*
* @param nullable	true means set nullability to true, false
*			means set it to false
*/
public void	setnullability boolean nullable
typedescriptor setnullability nullable
/**
* return a type descriptor identical to the this type
* with the exception of its nullability. if the nullablity
* required matches the nullability of this then this is returned.
*
* @param isnullable true to return a nullable type, false otherwise.
*/
public datatypedescriptor getnullabilitytype boolean isnullable
if  isnullable      isnullable
return this
return new datatypedescriptor this  isnullable
/**
compare if two typedescriptors are exactly the same
@param atypedescriptor the typedescriptor to compare to.
*/
public boolean equals object atypedescriptor
return typedescriptor equals atypedescriptor
/**
* check if this type is comparable with the passed type.
*
* @param comparewithdtd the type of the instance to compare with this type.
* @param forequals true if this is an = or <> comparison, false
*					otherwise.
* @param cf		a classfactory
* @return true if comparewithdtd is comparable to this type, else false.
*/
public boolean	comparable datatypedescriptor comparewithdtd
boolean forequals
classfactory cf
typeid comparewithtypeid   comparewithdtd gettypeid
int comparewithjdbctypeid   comparewithtypeid getjdbctypeid
// long types cannot be compared.
// xml types also fall in this window
// says sql/xml[2003] spec:
// 4.2.2 xml comparison and assignment
// "xml values are not comparable."
// an xml value cannot be compared to any type--
// not even to other xml values.
if  comparewithtypeid islongconcatabletypeid      typeid islongconcatabletypeid
return false
// ref types cannot be compared
if  typeid isreftypeid      comparewithtypeid isreftypeid
return false
//if this dtd is not user defined type but the dtd to be compared with
//is user defined type, then let the other dtd decide what should be the
//outcome of the comparable method.
if    typeid isuserdefinedtypeid
comparewithtypeid isuserdefinedtypeid
return comparewithdtd comparable this  forequals  cf
//numeric types are comparable to numeric types, boolean types and to
//comparable user types
if  typeid isnumerictypeid
return  comparewithtypeid isnumerictypeid
comparewithtypeid isbooleantypeid
//char, varchar and longvarchar are comparable to strings, boolean,
//date/time/timestamp and to comparable user types
if  typeid isstringtypeid
if  comparewithtypeid isdatetimetimestamptypeid
comparewithtypeid isbooleantypeid
return true
//if both the types are string types, then we need to make sure
//they have the same collation set on them
if  comparewithtypeid isstringtypeid      typeid isstringtypeid
return comparecollationinfo comparewithdtd
else
return false   can't be compared
//are comparable to other bit types and comparable user types
if  typeid isbittypeid
return  comparewithtypeid isbittypeid
//booleans are comparable to boolean, string, numeric and to
//comparable user types
if  typeid isbooleantypeid
return  comparewithtypeid getsqltypename   equals typeid getsqltypename
comparewithtypeid isstringtypeid
comparewithtypeid isnumerictypeid
//dates are comparable to dates, strings and to comparable
//user types.
if  typeid getjdbctypeid      types date
if  comparewithjdbctypeid    types date
comparewithtypeid isstringtypeid
return true
else
return false
//times are comparable to times, strings and to comparable
//user types.
if  typeid getjdbctypeid      types time
if  comparewithjdbctypeid    types time
comparewithtypeid isstringtypeid
return true
else
return false
//timestamps are comparable to timestamps, strings and to
//comparable user types.
if  typeid getjdbctypeid      types timestamp
if  comparewithjdbctypeid    types timestamp
comparewithtypeid isstringtypeid
return true
else
return false
//user types are comparable to other user types only if
//(for now) they are the same type and are being used to
//implement some jdbc type.  this is sufficient for
//date/time types; it may be generalized later for e.g.
//comparison of any user type with one of its subtypes.
if  typeid isuserdefinedtypeid      typeid getjdbctypeid      types other
if  forequals
return true
try
class thisclass   cf getclassinspector   getclass
typeid getcorrespondingjavatypename
return java lang comparable class isassignablefrom thisclass
catch  classnotfoundexception cnfe
return false
return false
/**
* compare the collation info on this dtd with the passed dtd. the rules
* for comparison are as follows (these are as per sql standard 2003
* section 9.13)
*
* 1)if both the dtds have collation derivation of none, then they can't be
* compared and we return false.
* 2)if both the dtds have same collation derivation (which in derby's case
* at this point will mean collation derivation of implicit), then check
* the collation types. if they match, then return true. if they do not
* match, then they can't be compared and hence return false.
* 3)if one dtd has collation derivation of implicit and other dtd has
* collation derivation of none, then 2 dtds are comparable using the
* collation type of dtd with collation derivation of implicit. derby does
* not implement this rule currently and it is being traked as derby-2678.
* derby's current behavior is to throw an exception if both the dtds
* involved in collation operation do not have collation derivation of
* implicit. this behavior is a subset of sql standard.
* 4)derby currently does not support collation derivation of explicit and
* hence we do not have the code to enforce rules as mentioned in section
* 9.13 of sql spec for collation derivation of explicit. when we implement
* collation derivation of explicit, we should make sure that we follow the
* rules as specified in the sql spec for comparability.
*
* @param comparewithdtd compare this dtd's collation info
*
* @return value depends on the algorithm above.
*/
public boolean comparecollationinfo datatypedescriptor comparewithdtd
//both the operands can not have the collation derivation of
//none. this is because in that case, we do not know what kind
//of collation to use for comparison.
if  getcollationderivation      comparewithdtd getcollationderivation
getcollationderivation      stringdatavalue collation_derivation_none
return false
if  getcollationderivation      comparewithdtd getcollationderivation
getcollationtype      comparewithdtd getcollationtype
return true   collation matches
else
return false   collation does not match
/**
* converts this data type descriptor (including length/precision)
* to a string. e.g.
*
*			varchar(30)
*
*	or
*
*			 java.util.hashtable
*
* @return	string version of datatype, suitable for running through
*			the parser.
*/
public string	getsqlstring
return typeid toparsablestring  this
/**
* get the simplified type descriptor that is intended to be stored
* in the system tables.
*/
public typedescriptorimpl getcatalogtype
return typedescriptor
/**
* get the estimated memory usage for this type descriptor.
*/
public double estimatedmemoryusage
switch  typeid gettypeformatid
case storedformatids longvarbit_type_id
/* who knows?  let's just use some big number */
return 10000 0
case storedformatids bit_type_id
return  double        float  getmaximumwidth      8 0    0 5
case storedformatids boolean_type_id
return 4 0
case storedformatids char_type_id
case storedformatids varchar_type_id
case storedformatids national_char_type_id
case storedformatids national_varchar_type_id
return  double   2 0   getmaximumwidth
case storedformatids longvarchar_type_id
case storedformatids national_longvarchar_type_id
/* who knows? let's just use some big number */
return 10000 0
case storedformatids decimal_type_id
/*
** 0.415 converts from number decimal digits to number of 8-bit digits.
** add 1.0 for the sign byte, and 0.5 to force it to round up.
*/
return  double     getprecision     0 415    1 5
case storedformatids double_type_id
return 8 0
case storedformatids int_type_id
return 4 0
case storedformatids longint_type_id
return 8 0
case storedformatids real_type_id
return 4 0
case storedformatids smallint_type_id
return 2 0
case storedformatids tinyint_type_id
return 1 0
case storedformatids ref_type_id
/* i think 12 is the right number */
return 12 0
case storedformatids userdefined_type_id_v3
if  typeid usertype
/* who knows?  let's just use some medium-sized number */
return 256 0
case storedformatids date_type_id
case storedformatids time_type_id
case storedformatids timestamp_type_id
return 12 0
default
return 0 0
/**
* compare jdbctypeids to determine if they represent equivalent
* sql types. for example types.numeric and types.decimal are
* equivalent
*
* @param existingtype  jdbc type id of derby data type
* @param jdbctypeid   jdbc type id passed in from application.
*
* @return boolean true if types are equivalent, false if not
*/
public static boolean isjdbctypeequivalent int existingtype  int jdbctypeid
// any type matches itself.
if  existingtype    jdbctypeid
return true
// to a numeric type
if  datatypedescriptor isnumerictype existingtype
if  datatypedescriptor isnumerictype jdbctypeid
return true
if  datatypedescriptor ischaractertype jdbctypeid
return true
return false
// to character type.
if  datatypedescriptor ischaractertype existingtype
if  datatypedescriptor ischaractertype jdbctypeid
return true
if  datatypedescriptor isnumerictype jdbctypeid
return true
switch  jdbctypeid
case types date
case types time
case types timestamp
return true
default
break
return false
// to binary type
if  datatypedescriptor isbinarytype existingtype
if  datatypedescriptor isbinarytype jdbctypeid
return true
return false
// to date, time
if  existingtype    types date    existingtype    types time
if  datatypedescriptor ischaractertype jdbctypeid
return true
if  jdbctypeid    types timestamp
return true
return false
// to timestamp
if  existingtype    types timestamp
if  datatypedescriptor ischaractertype jdbctypeid
return true
if  jdbctypeid    types date
return true
return false
// to clob
if  existingtype    types clob    datatypedescriptor ischaractertype jdbctypeid
return true
return false
public static boolean isnumerictype int jdbctype
switch  jdbctype
case types bit
case org apache derby iapi reference jdbc30translation sql_types_boolean
case types tinyint
case types smallint
case types integer
case types bigint
case types real
case types float
case types double
case types decimal
case types numeric
return true
default
return false
/**
* check whether a jdbc type is one of the character types that are
* compatible with the java type <code>string</code>.
*
* <p><strong>note:</strong> <code>clob</code> is not compatible with
* <code>string</code>. see tables b-4, b-5 and b-6 in the jdbc 3.0
* specification.
*
* <p> there are some non-character types that are compatible with
* <code>string</code> (examples: numeric types, binary types and
* time-related types), but they are not covered by this method.
*
* @param jdbctype a jdbc type
* @return <code>true</code> iff <code>jdbctype</code> is a character type
* and compatible with <code>string</code>
* @see java.sql.types
*/
private static boolean ischaractertype int jdbctype
switch  jdbctype
case types char
case types varchar
case types longvarchar
return true
default
return false
/**
* check whether a jdbc type is compatible with the java type
* <code>byte[]</code>.
*
* <p><strong>note:</strong> <code>blob</code> is not compatible with
* <code>byte[]</code>. see tables b-4, b-5 and b-6 in the jdbc 3.0
* specification.
*
* @param jdbctype a jdbc type
* @return <code>true</code> iff <code>jdbctype</code> is compatible with
* <code>byte[]</code>
* @see java.sql.types
*/
private static boolean isbinarytype int jdbctype
switch  jdbctype
case types binary
case types varbinary
case types longvarbinary
return true
default
return false
/**
* determine if an ascii stream can be inserted into a column or parameter
* of type <code>jdbctype</code>.
*
* @param jdbctype jdbc type of column or parameter
* @return <code>true</code> if an ascii stream can be inserted;
*         <code>false</code> otherwise
*/
public static boolean isasciistreamassignable int jdbctype
return jdbctype    types clob    ischaractertype jdbctype
/**
* determine if a binary stream can be inserted into a column or parameter
* of type <code>jdbctype</code>.
*
* @param jdbctype jdbc type of column or parameter
* @return <code>true</code> if a binary stream can be inserted;
*         <code>false</code> otherwise
*/
public static boolean isbinarystreamassignable int jdbctype
return jdbctype    types blob    isbinarytype jdbctype
/**
* determine if a character stream can be inserted into a column or
* parameter of type <code>jdbctype</code>.
*
* @param jdbctype jdbc type of column or parameter
* @return <code>true</code> if a character stream can be inserted;
*         <code>false</code> otherwise
*/
public static boolean ischaracterstreamassignable int jdbctype
// currently, we support the same types for ascii streams and
// character streams
return isasciistreamassignable jdbctype
public string	tostring
return typedescriptor tostring
// formatable methods
/**
* read this object from a stream of stored objects.
*
* @param in read this.
*
* @exception ioexception					thrown on error
* @exception classnotfoundexception		thrown on error
*/
public void readexternal  objectinput in
throws ioexception  classnotfoundexception
/* note: we only write out the generic type id.
* typeid will be reset to be the generic type id
* when we get read back in since the generic
* one is all that is needed at execution time.
*/
typeid    typeid  in readobject
typedescriptor    typedescriptorimpl  in readobject
/**
* write this object to a stream of stored objects.
*
* @param out write bytes here.
*
* @exception ioexception		thrown on error
*/
public void writeexternal  objectoutput out
throws ioexception
out writeobject  typeid
out writeobject  typedescriptor
/**
* get the formatid which corresponds to this class.
*
*	@return	the formatid of this class
*/
public	int	gettypeformatid  	  return storedformatids data_type_services_impl_v01_id
/**
* check to make sure that this type id is something a user can create
* him/herself directly through an sql create table statement.
*
* this method is used for create table as ... with [no] data binding
* because it's possible for the query to return types which are not
* actually creatable for a user.  derby-2605.
*
* three examples are:
*
*  boolean: a user can select boolean columns from system tables, but
*   s/he is not allowed to create such a column him/herself.
*
*  java_object: a user can select columns of various java object types
*   from system tables, but s/he is not allowed to create such a column
*   him/herself.
*
*  decimal: a user can specify a values clause with a constant that
*   has a precision of greater than 31.  derby can apparently handle
*   such a value internally, but the user is not supposed to be able
*   create such a column him/herself.
*
* @return true if the type associated with this dtd can be created via
*  the create table syntax; false otherwise.
*/
public boolean isusercreatabletype   throws standardexception
switch  typeid getjdbctypeid
case types boolean
case types java_object
return false
case types decimal
return
getprecision   <  typeid getmaximumprecision
getscale   <  typeid getmaximumscale
getmaximumwidth   <  typeid getmaximummaximumwidth
default  break
return true
/**
* return the sql type name and, if applicable, scale/precision/length
* for this datatypedescriptor.  note that we want the values from *this*
* object specifically, not the max values defined on this.typeid.
*/
public string getfullsqltypename
stringbuffer sbuf   new stringbuffer typeid getsqltypename
if  typeid isdecimaltypeid      typeid isnumerictypeid
sbuf append
sbuf append getprecision
sbuf append
sbuf append getscale
sbuf append
else if  typeid variablelength
sbuf append
sbuf append getmaximumwidth
sbuf append
return sbuf tostring