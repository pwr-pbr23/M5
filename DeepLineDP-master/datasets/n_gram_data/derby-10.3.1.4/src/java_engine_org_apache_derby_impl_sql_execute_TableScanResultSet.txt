/*
derby - class org.apache.derby.impl.sql.execute.tablescanresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import java util hashtable
import java util properties
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services i18n messageservice
import org apache derby iapi services io formatablebitset
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql activation
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql execute temporaryrowholder
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
/**
* takes a table and a table filter and returns
* the table's rows satisfying the filter as a result set.
*
* there are several things we could do during object
* construction that are done in the open & next calls, to
* improve performance.
*
*/
class tablescanresultset extends scanresultset
implements cursorresultset  cloneable
{
protected scancontroller scancontroller
protected boolean		scancontrolleropened
protected boolean		iskeyed
protected boolean		firstscan   true
protected execindexrow	startposition
protected execindexrow	stopposition
// set in constructor and not altered during
// life of object.
protected long conglomid
protected dynamiccompiledopenconglominfo dcoci
protected staticcompiledopenconglominfo scoci
protected generatedmethod resultrowallocator
protected generatedmethod startkeygetter
protected int startsearchoperator
protected generatedmethod stopkeygetter
protected int stopsearchoperator
public    qualifier qualifiers
public string tablename
public string usersuppliedoptimizeroverrides
public string indexname
protected boolean runtimestatisticson
protected formatablebitset accessedcols
protected int indexcols 		  index keys base column position array
public int rowsperread
public boolean forupdate
private boolean samestartstopposition
private boolean nextdone
private rowlocation rltemplate
// run time statistics
private properties scanproperties
public string startpositionstring
public string stoppositionstring
public boolean isconstraint
public boolean coarserlock
public boolean onerowscan
protected long	rowsthisscan
private long estimatedrowcount
/* following fields are used by beetle 3865, updateable cursor using index. "past2futuretbl"
* is a hash table containing updated rows that are thrown into future direction of the
* index scan and as a result we'll hit it again but should skip it.  if this hash table
* is full, we scan forward and have a virtual memory style temp heap holding future row
* id's.
*/
protected hashtable past2futuretbl
protected temporaryrowholder futureforupdaterows     tmp table for materialized rids
protected temporaryrowholderresultset futurerowresultset 	  result set for reading from above
protected boolean skipfuturerowholder 		  skip reading rows from above
protected boolean sourcedrained 			  all row ids materialized
protected boolean currentrowprescanned 	  got a row from above tmp table
protected boolean comparetolastkey 		  see comments in updateresultset
protected execrow lastcursorkey
private execrow sparserow 				  sparse row in heap column order
private formatablebitset sparserowmap 			  which columns to read
// for scrollable insensitive updatable result sets, only qualify a row the
// first time it's been read, since an update can change a row so that it
// no longer qualifies
private boolean qualify
// currentrowisvalid is set to the result of positioning at a rowlocation.
// it will be true if the positioning was successful and false if the row
// was deleted under our feet. whenenver currentrowisvalid is false it means
// that the row has been deleted.
private boolean currentrowisvalid
// indicates whether the scan has been positioned back to a previously read
// row, or it is accessing a row for the first time.
private boolean scanrepositioned
//
// class interface
//
tablescanresultset long conglomid
staticcompiledopenconglominfo scoci
activation activation
generatedmethod resultrowallocator
int resultsetnumber
generatedmethod startkeygetter  int startsearchoperator
generatedmethod stopkeygetter  int stopsearchoperator
boolean samestartstopposition
qualifier[][] qualifiers,
string tablename
string usersuppliedoptimizeroverrides
string indexname
boolean isconstraint
boolean forupdate
int colrefitem
int indexcolitem
int lockmode
boolean tablelocked
int isolationlevel
int rowsperread
boolean onerowscan
double optimizerestimatedrowcount
double optimizerestimatedcost
throws standardexception
{
super activation
resultsetnumber
resultrowallocator
lockmode  tablelocked  isolationlevel
optimizerestimatedrowcount
optimizerestimatedcost
this conglomid   conglomid
/* static info created at compile time and can be shared across
* instances of the plan.
* dynamic info created on 1st opening of this resultset as
* it cannot be shared.
*/
this scoci   scoci
if  sanitymanager debug
sanitymanager assert  activation  null
sanitymanager assert  resultrowallocator   null
if  samestartstopposition
{
sanitymanager assert stopkeygetter    null
}
}
this resultrowallocator   resultrowallocator
this startkeygetter   startkeygetter
this startsearchoperator   startsearchoperator
this stopkeygetter   stopkeygetter
this stopsearchoperator   stopsearchoperator
this samestartstopposition   samestartstopposition
this qualifiers   qualifiers
this tablename   tablename
this usersuppliedoptimizeroverrides   usersuppliedoptimizeroverrides
this indexname   indexname
this isconstraint   isconstraint
this forupdate   forupdate
this rowsperread   rowsperread
this onerowscan   onerowscan
// retrieve the valid column list from
// the saved objects, if it exists
this accessedcols   null
if  colrefitem     1
{
this accessedcols    formatablebitset  activation getpreparedstatement
getsavedobject colrefitem
}
if  indexcolitem     1
{
this indexcols    int  activation getpreparedstatement
getsavedobject indexcolitem
}
if  indexcols    null
activation setforupdateindexscan this
runtimestatisticson    activation    null
activation getlanguageconnectioncontext   getruntimestatisticsmode
constructortime    getelapsedmillis begintime
/* always qualify the first time a row is being read */
qualify   true
currentrowisvalid   false
scanrepositioned   false
}
//
// resultset interface (leftover from noputresultset)
//
/**
* open a scan on the table. scan parameters are evaluated
* at each open, so there is probably some way of altering
* their values...
*
* @exception standardexception thrown on failure to open
*/
public void	opencore   throws standardexception
{
if (sanitymanager.debug)
sanitymanager assert    isopen
// get the current transaction controller
transactioncontroller tc   activation gettransactioncontroller
initisolationlevel
if  dcoci    null
dcoci   tc getdynamiccompiledconglominfo conglomid
if  startkeygetter    null
{
startposition    execindexrow  startkeygetter invoke activation
if  samestartstopposition
{
stopposition   startposition
}
}
if  stopkeygetter    null
{
stopposition    execindexrow  stopkeygetter invoke activation
}
/* note: we always open the scancontroller on the 1st open
* to do the keyed conglomerate check.
*/
// determine whether the conglomerate is keyed.  this determines
// how we find the rowlocation for the base heap.  for non-keyed
// conglomerates, we ask the scan.  for keyed conglomerates, it
// is the last column in the row.
//
// do this here, rather than in the constructor, so we can avoid
// throwing exceptions from the constructor
if  firstscan
{
openscancontroller tc
iskeyed   scancontroller iskeyed
/*
** if scan tracing is turned on, print information about this
** tablescanresultset when it is first opened.  we would like
** to do this when it is constructed, but it is not always
** possible to get the start and stop positioners at the time
** this object is constructed (because they may depend on outer
** rows).
*/
if (sanitymanager.debug)
{
if  sanitymanager debug_on
{
//tracescanparameters();
}
}
}
// check whether there are any comparisons with unordered nulls
// on either the start or stop position.  if there are, we can
// (and must) skip the scan, because no rows can qualify
if  skipscan startposition  stopposition
{
scancontrolleropened   false
}
/* note: we always open the scancontroller on the 1st open
* to do the keyed conglomerate check, so we only need to
* do it here if not the 1st scan.
*/
else if    firstscan
{
openscancontroller tc
}
/* if the scan is on an index and opened for update,
* then we cache the scan controller and conglomerate
* number in the activation so that the scan controller
* can be re-used by the update/delete if the index
* that we are scanning also needs to be updated.
*/
if  forupdate    iskeyed
{
activation setindexscancontroller scancontroller
activation setindexconglomeratenumber conglomid
}
firstscan   false
isopen   true
numopens
nextdone   false
opentime    getelapsedmillis begintime
}
/*
** open the scan controller
**
** @param transaction controller will open one if null
*/
protected void openscancontroller transactioncontroller tc
throws standardexception
{
openscancontroller tc   datavaluedescriptor null
}
/*
** does the work of openscancontroller.
**
** @param tc transaction controller; will open one if null.
** @param probevalue if non-null then we will open the scan controller
**  and position it using the received probevalue as the start key.
**  otherwise we'll use whatever value is in startposition (if non-
**  null) as the start key.
*/
protected void openscancontroller transactioncontroller tc
datavaluedescriptor probevalue  throws standardexception
{
datavaluedescriptor startpositionrow
startposition    null ? null   startposition getrowarray
datavaluedescriptor stoppositionrow
stopposition    null ? null   stopposition getrowarray
/* if we have a probe value then we do the "probe" by positioning
* the scan at the first row matching the value.  the way to do
* that is to use the value as a start key, which is what will
* happen if we plug it into first column of "startpositionrow".
* so in this case startpositionrow[0] functions as a "place-holder"
* for the probe value.  the same goes for stoppositionrow[0].
*
* note that it *is* possible for a start/stop key to contain more
* than one column (ex. if we're scanning a multi-column index). in
* that case we plug probevalue into the first column of the start
* and/or stop key and leave the rest of the key as it is.  as an
* example, assume we have the following predicates:
*
*    ... where d in (1, 20000) and b > 200 and b <= 500
*
* and assume further that we have an index defined on (d, b).
* in this case it's possible that we have two start predicates
* and two stop predicates: the in list will give us "d = probeval",
* which is a start predicate and a stop predicate; then "b > 200"
* may give us a second start predicate, while "b <= 500" may give
* us a second stop predicate.  so in this situation we want our
* start key to be:
*
*    (probevalue, 200)
*
* and our stop key to be:
*
*    (probevalue, 500).
*
* this will effectively limit the scan so that it only returns
* rows whose "d" column equals probevalue and whose "b" column
* falls in the range of 200 thru 500.
*
* note: derby currently only allows a single start/stop predicate
* per column. see predicatelist.orderusefulpredicates().
*/
if  probevalue    null
{
startpositionrow   probevalue
/* if the start key and stop key are the same, we've already set
* stopposition equal to startposition as part of opencore().
* so by putting the probe value into startpositionrow[0], we
* also put it into stoppositionrow[0].
*/
if   samestartstopposition
stoppositionrow   probevalue
}
// clear the qualifiers's orderable cache
if  qualifiers    null
{
clearorderablecache qualifiers
}
// get the current transaction controller
if  tc    null
tc   activation gettransactioncontroller
int openmode   0
if  forupdate
{
openmode   transactioncontroller openmode_forupdate
if  activation iscursoractivation
openmode    transactioncontroller openmode_use_update_locks
}
scancontroller   tc opencompiledscan
activation getresultsetholdability
openmode
lockmode
isolationlevel
accessedcols
startpositionrow
// not used when giving null start position
startsearchoperator,
qualifiers
stoppositionrow
// not used when giving null stop position
stopsearchoperator,
scoci
dcoci
/* remember that we opened the scan */
scancontrolleropened   true
rowsthisscan   0
/*
** inform the activation of the estimated number of rows.  only
** do it here, not in reopen, so that we don't do this costly
** check too often.
*/
estimatedrowcount   scancontroller getestimatedrowcount
activation informofrowcount
this
scancontroller getestimatedrowcount
);
}
/*
** reopen the scan controller
*/
protected void reopenscancontroller   throws standardexception
{
reopenscancontroller  datavaluedescriptor null
}
/*
** does the work of reopenscancontroller.
**
** @param probevalue if non-null then we will open the scan controller
**  and position it using the received probevalue as the start key.
**  otherwise we'll use whatever value is in startposition (if non-
**  null) as the start key.
*/
protected void reopenscancontroller datavaluedescriptor probevalue
throws standardexception
{
datavaluedescriptor startpositionrow
startposition    null ? null   startposition getrowarray
datavaluedescriptor stoppositionrow
stopposition    null ? null   stopposition getrowarray
/* if we have a probe value then we do the "probe" by using the
* value as a start and stop key.  see openscancontroller() for
* details.  note that in this case we do *not* want to reset
* the rowsthisscan variable because we are going to be doing
* multiple "probes" for a single scan.  logic to detect when
* when we've actually started a new scan (as opposed to just
* repositioning an existing scan based on a probe value) is
* in multiprobetablescanresultset.reopenscancontroller(),
* and that method will then take care of resetting the variable
* (if needed) for probing scans.
*/
if  probevalue    null
{
startpositionrow   probevalue
if   samestartstopposition
stoppositionrow   probevalue
}
else
rowsthisscan   0
// clear the qualifiers's orderable cache
if  qualifiers    null
{
clearorderablecache qualifiers
}
scancontroller reopenscan
startpositionrow
startsearchoperator,
qualifiers
stoppositionrow
stopsearchoperator
/* remember that we opened the scan */
scancontrolleropened   true
}
/**
* reopen a table scan.  here we take advantage
* of the reopenscan() interface on scancontroller
* for optimimal performance on joins where we are
* an inner table.
*
* @exception standardexception thrown on failure to open
*/
public void	reopencore   throws standardexception
{
begintime   getcurrenttimemillis
if (sanitymanager.debug)
sanitymanager assert isopen
if  startkeygetter    null
{
startposition    execindexrow  startkeygetter invoke activation
if  samestartstopposition
{
stopposition   startposition
}
}
if  stopkeygetter    null
{
stopposition    execindexrow  stopkeygetter invoke activation
}
// check whether there are any comparisons with unordered nulls
// on either the start or stop position.  if there are, we can
// (and must) skip the scan, because no rows can qualify
if  skipscan startposition  stopposition
{
scancontrolleropened   false
}
else
{
if  scancontroller    null
openscancontroller  transactioncontroller null
else
reopenscancontroller
}
numopens
nextdone   false
opentime    getelapsedmillis begintime
}
/**
* check and make sure sparse heap row and accessed bit map are created.
* beetle 3865, update cursor using index.
*
* @exception standardexception thrown on failure
*/
private void getsparserowandmap   throws standardexception
{
int numcols   1  colpos
for  int i   0  i < indexcols length  i
{
colpos    indexcols > 0  ? indexcols    indexcols
if  colpos > numcols
numcols   colpos
}
sparserow   new valuerow numcols
sparserowmap   new formatablebitset numcols
for  int i   0  i < indexcols length  i
{
if  accessedcols get i
{
colpos    indexcols > 0  ? indexcols    indexcols
sparserow setcolumn colpos  candidate getcolumn i   1
sparserowmap set colpos   1
}
}
}
/**
* return the next row (if any) from the scan (if open).
*
* @exception standardexception thrown on failure to get next row
*/
public execrow getnextrowcore   throws standardexception
{
checkcancellationflag
if  currentrow    null    scanrepositioned
{
currentrow
getcompactrow candidate  accessedcols   formatablebitset  null  iskeyed
}
begintime   getcurrenttimemillis
execrow result   null
/* beetle 3865, updateable cursor using index. we first saved updated rows with new value
* falling into future direction of index scan in hash table, if it's full, we scanned
* forward and saved future row ids in a virtual mem heap.
*/
if  futureforupdaterows    null
{
currentrowprescanned   false
if    skipfuturerowholder
{
if  futurerowresultset    null
{
futurerowresultset    temporaryrowholderresultset  futureforupdaterows getresultset
futurerowresultset opencore
}
execrow ridrow   futurerowresultset getnextrowcore
if  ridrow    null
{
/* to boost performance, we used virtual mem heap, and we can insert after
* we start retrieving results.  the assumption is to
* delete current row right after we retrieve it.
*/
futurerowresultset deletecurrentrow
rowlocation rl    rowlocation  ridrow getcolumn 1
conglomeratecontroller basecc   activation getheapconglomeratecontroller
if  sparserow    null
getsparserowandmap
basecc fetch
rl  sparserow getrowarray    sparserowmap
rowlocation rl2    rowlocation  rl getclone
currentrow setcolumn currentrow ncolumns    rl2
candidate setcolumn candidate ncolumns    rl2  		   have to be consistent
result   currentrow
currentrowprescanned   true
}
else if  sourcedrained
{
currentrowprescanned   true
currentrow   null
}
if  currentrowprescanned
{
setcurrentrow result
nexttime    getelapsedmillis begintime
return result
}
}
}
if   isopen      nextdone
{
/* only need to do 1 next per scan
* for 1 row scans.
*/
nextdone   onerowscan
if  scancontrolleropened
{
boolean morerows
while  morerows
scancontroller fetchnext candidate getrowarray
{
rowsseen
rowsthisscan
/*
** skip rows where there are start or stop positioners
** that do not implement ordered null semantics and
** there are columns in those positions that contain
** null.
** no need to check if start and stop positions are the
** same, since all predicates in both will be ='s,
** and hence evaluated in the store.
*/
if     samestartstopposition     skiprow candidate
{
rowsfiltered
continue
}
/* beetle 3865, updateable cursor use index. if we have a hash table that
* holds updated records, and we hit it again, skip it, and remove it from
* hash since we can't hit it again, and we have a space in hash, so can
* stop scanning forward.
*/
if  past2futuretbl    null
{
rowlocation rowloc    rowlocation  currentrow getcolumn currentrow ncolumns
if  past2futuretbl get rowloc     null
{
past2futuretbl remove rowloc
continue
}
}
result   currentrow
break;
}
/*
** if we just finished a full scan of the heap, update
** the number of rows in the scan controller.
**
** note: it would be more efficient to only update the
** scan controller if the optimizer's estimated number of
** rows were wrong by more than some threshold (like 10%).
** this would require a little more work than i have the
** time for now, however, as the row estimate that is given
** to this result set is the total number of rows for all
** scans, not the number of rows per scan.
*/
if    morerows
{
setrowcountifpossible rowsthisscan
currentrow   null
}
}
}
setcurrentrow result
currentrowisvalid   true
scanrepositioned   false
qualify   true
nexttime    getelapsedmillis begintime
return result
}
/**
* if the result set has been opened,
* close the open scan.
* @exception standardexception on error
*/
public void	close   throws standardexception
{
begintime   getcurrenttimemillis
if   isopen
{
/*
** if scan tracing is turned on, print information about this
** tablescanresultset when it is closed.
*/
if (sanitymanager.debug)
{
if  sanitymanager debug_on
{
//traceclose();
}
}
// we don't want to keep around a pointer to the
// row ... so it can be thrown away.
// revisit: does this need to be in a finally
// block, to ensure that it is executed?
clearcurrentrow
if  scancontroller    null
{
// this is where we get the positioner info for inner tables
if  runtimestatisticson
{
// this is where we get the scan properties for a subquery
scanproperties   getscanproperties
startpositionstring   printstartposition
stoppositionstring   printstopposition
}
scancontroller close
scancontroller   null     should not access after close
activation clearindexscaninfo
}
scancontrolleropened   false
startposition   null
stopposition   null
super close
if  indexcols    null
{
conglomeratecontroller borrowedbasecc   activation getheapconglomeratecontroller
if  borrowedbasecc    null
{
borrowedbasecc close
activation clearheapconglomeratecontroller
}
}
if  futurerowresultset    null
futurerowresultset close
}
else
if (sanitymanager.debug)
sanitymanager debug
closetime    getelapsedmillis begintime
}
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
{
long tottime   constructortime   opentime   nexttime   closetime
/* resolve - subtract out store time later, when available */
if  type    noputresultset current_resultset_only
{
return	tottime
}
else
{
return tottime
}
}
//
// cursorresultset interface
//
/**
* this result set has its row location from
* the last fetch done. if the cursor is closed,
* or the row has been deleted a null is returned.
*
* @see cursorresultset
*
* @return the row location of the current cursor row.
* @exception standardexception thrown on failure to get row location
*/
public rowlocation getrowlocation   throws standardexception
{
rowlocation rl
if    isopen  return null
if     scancontrolleropened
return null
/*
** if the conglomerate is keyed, the row location of the base row
** is in the last column of the current row.  if it's not keyed,
** we get the row location from the scan of the heap.
*/
if (iskeyed)
{
if (sanitymanager.debug)
{
sanitymanager assert currentrow    null
}
rl    rowlocation  currentrow getcolumn
currentrow ncolumns
}
else
{
if  currentrowisvalid
// we reuse the same rowlocation object across several calls.
if  rltemplate    null
rltemplate   scancontroller newrowlocationtemplate
rl   rltemplate
try
scancontroller fetchlocation rl
catch  standardexception se
if  se getmessageid
equals sqlstate heap_scan_not_positioned
//have a easier to understand error message than what
//we get from store
throw standardexception
newexception sqlstate no_current_row
}
throw se
}
else
rl   null
}
}
return rl
}
/**
* this result set has its row from the last fetch done.
* if the cursor is closed, the row has been deleted, or
* no longer qualifies (for forward only result sets) a
* null is returned.
*
* @see cursorresultset
*
* @return the last row returned;
* @exception standardexception thrown on failure.
*/
/* resolve - this should return activation.getcurrentrow(resultsetnumber),
* once there is such a method.  (currentrow is redundant)
*/
public execrow getcurrentrow   throws standardexception
{
execrow result   null
if (sanitymanager.debug)
sanitymanager assert isopen
if  currentrowprescanned
return currentrow
/* nothing to do if we're not currently on a row or
* if the current row get deleted out from under us
* or if there is no current scan (can happen if the
* scan is being skipped) or if the current position
* no longer qualifies.
*/
try
{
if   currentrow    null
currentrowisvalid
scancontrolleropened
qualify    scancontroller iscurrentpositiondeleted
qualify      scancontroller doescurrentpositionqualify
{
return null
}
}
catch  standardexception se
{
if  se getmessageid   equals sqlstate am_scan_not_positioned
{
//bug 4515 - have a easier to understand error message than what we get from store
se standardexception newexception sqlstate no_current_row
throw se
}
}
result    execrow  resultrowallocator invoke activation
currentrow
getcompactrow result  accessedcols   formatablebitset  null  iskeyed
try
{
scancontroller fetchwithoutqualify result getrowarray
}
catch  standardexception se
{
if  se getmessageid   equals sqlstate am_record_not_found
{
// somehow the row got deleted between the above
// doescurrentpositionqualify() call and here (one way is if
// this scan is read uncommitted isolation level).
return null
}
else
{
throw se
}
}
setcurrentrow result
return currentrow
}
/**
* @see noputresultset#positionscanatrowlocation
*
* also sets qualify to false so that later calls to getcurrentrow
* will not attempt to re-qualify the current row.
*/
public void positionscanatrowlocation rowlocation rl
throws standardexception
{
// check if the scancontroller is a b-tree scan controller. do not
// attempt to re-position a b-tree controller.
if   iskeyed
currentrowisvalid   scancontroller positionatrowlocation rl
}
qualify   false
scanrepositioned   true
}
/**
* print the parameters that constructed this result set to the
* trace stream.
*/
/*
private final void tracescanparameters()
{
if (sanitymanager.debug)
{
headerprintwriter tracestream = sanitymanager.get_debug_stream();
tracestream.println("");
tracestream.println("tablescanresultset number " +
resultsetnumber +
" parameters:");
tracestream.println("");
tracestream.println("\ttable name: " + tablename);
if (indexname != null)
{
tracestream.println("\tindex name: " + indexname);
}
tracestream.println("");
tracestream.println("\tstart position is: ");
traceprintposition(tracestream,
startsearchoperator,
startkeygetter);
tracestream.println("");
tracestream.println("\tstop position is: " );
traceprintposition(tracestream,
stopsearchoperator,
stopkeygetter);
tracestream.println("");
tracestream.println("\tqualifiers are: ");
traceprintqualifiers(tracestream, qualifiers, 2);
tracestream.println("");
}
}
*/
/**
* print i/o statistics about a scan when it closes.
*/
/*
private final void traceclose()
{
if (sanitymanager.debug)
{
infostreams			infostreams;
headerprintwriter	tracestream;
tracestream = sanitymanager.get_debug_stream();
tracestream.println("tablescanresultset number " +
resultsetnumber +
" closed.");
if (iskeyed)
{
tracestream.println("\t" +
rowcount() +
" row(s) qualified from " +
"keyed" +
" table " +
tablename +
" using index " +
indexname);
}
else
{
tracestream.println("\t" +
rowcount() +
" row(s) qualified from " +
"non-keyed" +
" table " +
tablename);
}
tracestream.println("");
}
}
*/
/**
* print a start or stop positioner to the trace stream.
*/
/*
private final void traceprintposition(headerprintwriter tracestream,
int searchoperator,
generatedmethod positiongetter)
{
if (sanitymanager.debug)
{
if (positiongetter == null)
{
tracestream.println("\t\tnone");
return;
}
execindexrow	positioner = null;
try
{
positioner = (execindexrow) positiongetter.invoke(activation);
}
catch (standardexception e)
{
tracestream.println("\t\tunexpected exception " +
e +
" getting positioner.");
e.printstacktrace(tracestream.getprintwriter());
return;
}
if (positioner == null)
{
tracestream.println("\t\tnone");
return;
}
string searchop = null;
switch (searchoperator)
{
case scancontroller.ge:
searchop = "ge";
break;
case scancontroller.gt:
searchop = "gt";
break;
default:
searchop = "unknown value (" + searchoperator + ")";
break;
}
tracestream.println("\t\t" +
searchop +
" on first " +
positioner.ncolumns() +
" column(s).");
tracestream.print(
"\t\tordered null semantics on the following columns: ");
for (int position = 0; position < positioner.ncolumns(); position++)
{
if (positioner.arenullsordered(position))
{
tracestream.print(position + " ");
}
}
tracestream.println("");
}
}
*/
/**
* print an array of qualifiers to the trace stream.
*/
/*
private final void traceprintqualifiers(headerprintwriter tracestream,
qualifier[][] qualifiers,
int depth)
{
if (sanitymanager.debug)
{
char[] indentchars = new char[depth];
/*
** form an array of tab characters for indentation.
*
while (depth > 0)
{
indentchars[depth - 1] = '\t';
depth--;
}
string indent = new string(indentchars);
if (qualifiers == null)
{
tracestream.println(indent +
messageservice.gettextmessage(
sqlstate.lang_none)
);
return;
}
// resolve (mikem) we don't support 2-d qualifiers yet.
if (sanitymanager.debug)
{
sanitymanager.assert(qualifiers.length == 1);
}
for (int i = 0; i < qualifiers[0].length; i++)
{
qualifier qual = qualifiers[0][i];
tracestream.println("");
tracestream.println(indent + "column id: " + qual.getcolumnid());
int operator = qual.getoperator();
string opstring = null;
switch (operator)
{
case orderable.order_op_equals:
opstring = "=";
break;
case orderable.order_op_lessorequals:
opstring = "<=";
break;
case orderable.order_op_lessthan:
opstring = "<";
break;
default:
opstring = "unknown value (" + operator + ")";
break;
}
tracestream.println(indent + "operator: " + opstring);
tracestream.println(indent + "ordered nulls: " +
qual.getorderednulls());
tracestream.println(indent + "unknown return value: " +
qual.getunknownrv());
tracestream.println(indent + "negate comparison result: " +
qual.negatecompareresult());
tracestream.println("");
}
}
}
*/
public string printstartposition
{
return printposition startsearchoperator  startkeygetter  startposition
}
public string printstopposition
{
if  samestartstopposition
{
return printposition stopsearchoperator  startkeygetter  startposition
}
else
{
return printposition stopsearchoperator  stopkeygetter  stopposition
}
}
/**
* return a start or stop positioner as a string.
*
* if we already generated the information, then use
* that.  otherwise, invoke the activation to get it.
*/
private string printposition int searchoperator
generatedmethod positiongetter
execindexrow positioner
{
string idt
string output
if (positiongetter == null)
{
return
messageservice gettextmessage sqlstate lang_none
}
if (positioner == null)
{
try
{
positioner    execindexrow positiongetter invoke activation
}
catch (standardexception e)
{
// the positiongetter will fail with a nullpointerexception
// if the outer table is empty
// (this isn't a problem since we won't call it on the inner
// table if there are no rows on the outer table)
if  e getsqlstate      sqlstate lang_unexpected_user_exception
return     messageservice gettextmessage
sqlstate lang_position_not_avail
return     messageservice gettextmessage
sqlstate lang_unexpected_exc_getting_positioner
e tostring
}
}
if (positioner == null)
{
return
messageservice gettextmessage sqlstate lang_none
}
string searchop = null;
switch (searchoperator)
{
case scancontroller.ge:
searchop
break;
case scancontroller.gt:
searchop
break;
default:
if (sanitymanager.debug)
{
sanitymanager throwassert
searchoperator
}
// note: this does not have to be internationalized because
// this code should never be reached.
searchop = "unknown value (" + searchoperator + ")";
break;
}
output   output
messageservice.gettextmessage(
sqlstate lang_positioner
searchop
string valueof positioner ncolumns
output   output
messageservice.gettextmessage(
sqlstate lang_ordered_null_semantics
for (int position = 0; position < positioner.ncolumns(); position++)
{
if (positioner.arenullsordered(position))
{
output   output   position
}
}
return output
}
public properties getscanproperties
{
if  scanproperties    null
{
scanproperties   new properties
}
try
{
if  scancontroller    null
{
scancontroller getscaninfo   getallscaninfo scanproperties
/* did we get a coarser lock due to
* a covering lock, lock escalation
* or configuration?
*/
coarserlock   scancontroller istablelocked
lockmode    transactioncontroller mode_record
}
}
catch standardexception se
{
// ignore
}
return scanproperties
}
/**
* @see noputresultset#requiresrelocking
*/
public boolean requiresrelocking
{
return
isolationlevel
transactioncontroller isolation_read_committed_noholdlock
}
/**
* update the number of rows in the scan controller.
*
* note: it would be more efficient to only update the
* scan controller if the optimizer's estimated number of
* rows were wrong by more than some threshold (like 10%).
* this would require a little more work than i have the
* time for now, however, as the row estimate that is given
* to this result set is the total number of rows for all
* scans, not the number of rows per scan.
*
*
* @param rowsthisscan	the number of rows to update the scancontroller to
*
* @exception standardexception		thrown on error
*/
protected final void setrowcountifpossible long rowsthisscan
throws standardexception
{
/*
** is it a heap scan with no qualifiers (full table scan?)
** and is it not for update (we don't want to count rows we're
** about to delete.
*/
if       scancontroller iskeyed
qualifiers    null    qualifiers length    0
forupdate
{
// only update rows if different by more than 10%
long diff   rowsthisscan   estimatedrowcount
long tenpercent   estimatedrowcount    10
if  diff < 0
diff    diff
if  diff > tenpercent
scancontroller setestimatedrowcount rowsthisscan
}
}
/**
* can we get instantaneous locks when getting share row
* locks at read committed.
*/
protected boolean cangetinstantaneouslocks
{
return false
}
/**
* is this resultset or it's source result set for update
*
* @return whether or not the result set is for update.
*/
public boolean isforupdate
{
return forupdate
}
/**
* shallow clone this result set.  used in trigger reference.
* beetle 4373.
*/
public object clone
{
object clo   null
try
clo   super clone
}
catch  clonenotsupportedexception e
return clo
}
}