/*
derby - class org.apache.derby.impl.sql.execute.ddlconstantaction
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import java util iterator
import java util list
import org apache derby catalog uuid
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi sql activation
import org apache derby iapi sql conn authorizer
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql depend dependent
import org apache derby iapi sql dictionary colpermsdescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary permissionsdescriptor
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary statementcolumnpermission
import org apache derby iapi sql dictionary statementpermission
import org apache derby iapi sql dictionary statementroutinepermission
import org apache derby iapi sql dictionary statementschemapermission
import org apache derby iapi sql dictionary statementtablepermission
import org apache derby iapi sql execute constantaction
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access transactioncontroller
/**
* abstract class that has actions that are across
* all ddl actions.
*
*/
abstract class ddlconstantaction implements constantaction
/**
* get the schema descriptor for the schemaid.
*
* @param dd the data dictionary
* @param schemaid the schema id
* @param statementtype string describing type of statement for error
*	reporting.  e.g. "alter statement"
*
* @return the schema descriptor
*
* @exception standardexception if schema is system schema
*/
static schemadescriptor getandcheckschemadescriptor
datadictionary		dd
uuid				schemaid
string				statementtype
throws standardexception
schemadescriptor sd   dd getschemadescriptor schemaid  null
return sd
/**
* get the schema descriptor in the creation of an object in
the passed in schema.
*
* @param dd the data dictionary
@param activation activation
@param schemaname name of the schema
*
* @return the schema descriptor
*
* @exception standardexception if the schema does not exist
*/
static schemadescriptor getschemadescriptorforcreate
datadictionary		dd
activation activation
string schemaname
throws standardexception
transactioncontroller tc   activation getlanguageconnectioncontext   gettransactionexecute
schemadescriptor sd   dd getschemadescriptor schemaname  tc  false
if  sd    null    sd getuuid      null
constantaction csca
new createschemaconstantaction schemaname   string  null
try
csca executeconstantaction activation
catch  standardexception se
if  se getmessageid
equals sqlstate lang_object_already_exists
// ignore "schema already exists". another thread has
// probably created it after we checked for it
else
throw se
sd   dd getschemadescriptor schemaname  tc  true
return sd
/**
* lock the table in exclusive or share mode to prevent deadlocks.
*
* @param tc						the transactioncontroller
* @param heapconglomeratenumber	the conglomerate number for the heap.
* @param exclusivemode				whether or not to lock the table in exclusive mode.
*
* @exception standardexception if schema is system schema
*/
final void locktableforddl transactioncontroller tc
long heapconglomeratenumber  boolean exclusivemode
throws standardexception
conglomeratecontroller cc
cc   tc openconglomerate
heapconglomeratenumber
false
exclusivemode  ?
transactioncontroller openmode_forupdate
transactioncontroller openmode_for_lock_only
transactioncontroller openmode_for_lock_only
transactioncontroller mode_table
transactioncontroller isolation_serializable
cc close
protected string constructtostring
string				statementtype
string              objectname
// do not put this under sanitymanager.debug - it is needed for
// error reporting.
return statementtype   objectname
/**
*	this method saves dependencies of constraints on privileges in the
*  dependency system. it gets called by createconstraintconstantaction.
*  views and triggers and constraints run with definer's privileges. if
*  one of the required privileges is revoked from the definer, the
*  dependent view/trigger/constraint on that privilege will be dropped
*  automatically. in order to implement this behavior, we need to save
*  view/trigger/constraint dependencies on required privileges in the
*  dependency system. following method accomplishes that part of the
*  equation for constraints only. the dependency collection for
*  constraints is not same as for views and triggers and hence
*  constraints are handled by this special method.
* 	views and triggers can depend on many different kind of privileges
*  where as constraints only depend on references privilege on a table.
*  another difference is only one view or trigger can be defined by a
*  sql statement and hence all the dependencies collected for the sql
*  statement apply to the view or trigger in question. as for constraints,
*  one sql statement can defined multiple constraints and hence the
*  all the privileges required by the statement are not necessarily
*  required by all the constraints defined by that sql statement. we need
*  to identify right privileges for right constraints for a given sql
*  statement. because of these differences between constraints and views
*  (and triggers), there are 2 different methods in this class to save
*  their privileges in the dependency system.
*
*  @param activation the execution environment for this constant action.
*  @param dependent make this object depend on required privileges
*  @param reftableuuid make sure we are looking for references privilege
* 		for right table
*
* @exception standardexception		thrown on failure
*/
protected void storeconstraintdependenciesonprivileges
activation activation  dependent dependent  uuid reftableuuid
throws standardexception
languageconnectioncontext lcc   activation getlanguageconnectioncontext
datadictionary dd   lcc getdatadictionary
dependencymanager dm   dd getdependencymanager
//if the database owner is creating this constraint, then no need to
//collect any privilege dependencies because the database owner can
//access any objects without any restrictions
if    lcc getauthorizationid   equals dd getauthorizationdatabaseowner
permissionsdescriptor permdesc
//now, it is time to add into dependency system, constraint's
//dependency on references privilege. if the references privilege is
//revoked from the constraint owner, the constraint will get
//dropped automatically.
list requiredpermissionslist   activation getpreparedstatement   getrequiredpermissionslist
if  requiredpermissionslist    null      requiredpermissionslist isempty
for iterator iter   requiredpermissionslist iterator   iter hasnext
statementpermission statperm    statementpermission  iter next
//first check if we are dealing with a table or
//column level privilege. all the other privileges
//are not required for a foreign key constraint.
if  statperm instanceof statementtablepermission
it is a table column level privilege
statementtablepermission statementtablepermission
statementtablepermission  statperm
//check if we are dealing with references privilege.
//if not, move on to the next privilege in the
//required privileges list
if  statementtablepermission getprivtype      authorizer references_priv
continue
//next check is this references privilege is
//on the same table as referenced by the foreign
//key constraint? if not, move on to the next
//privilege in the required privileges list
if   statementtablepermission gettableuuid   equals reftableuuid
continue
else if  statperm instanceof statementschemapermission
statperm instanceof statementroutinepermission
continue
//we know that we are working with a references
//privilege. find all the permissiondescriptors for
//this privilege and make constraint depend on it
//through dependency manager.
//the references privilege could be defined at the
//table level or it could be defined at individual
//column levels. in addition, individual column
//references privilege could be available at the
//user level or public level.
permdesc   statperm getpermissiondescriptor lcc getauthorizationid    dd
if  permdesc    null
//no references privilege exists for given
//authorizer at table or column level.
//references privilege has to exist at at public level
permdesc   statperm getpermissiondescriptor authorizer public_authorization_id  dd
if    permdesc checkowner lcc getauthorizationid
dm adddependency dependent  permdesc  lcc getcontextmanager
else
//if the object on which permission is required is owned by the
//same user as the current user, then no need to keep that
//object's privilege dependency in the dependency system
if    permdesc checkowner lcc getauthorizationid
dm adddependency dependent  permdesc  lcc getcontextmanager
if  permdesc instanceof colpermsdescriptor
//the if statement above means we found a
//references privilege at column level for
//the given authorizer. if this privilege
//doesn't cover all the column , then there
//has to exisit references for the remaining
//columns at public level. get that permission
//descriptor and save it in dependency system
statementcolumnpermission statementcolumnpermission    statementcolumnpermission  statperm
permdesc   statementcolumnpermission getpubliclevelcolpermsdescriptor lcc getauthorizationid    dd
//following if checks if some column level privileges
//exist only at public level. if so, then the public
//level column privilege dependency is added
//into the dependency system
if  permdesc    null
dm adddependency dependent  permdesc  lcc getcontextmanager
//we have found the references privilege for all the
//columns in foreign key constraint and we don't
//need to go through the rest of the privileges
//for this sql statement.
break
/**
*	this method saves dependencies of views and triggers on privileges in
*  the dependency system. it gets called by createviewconstantaction
*  and createtriggerconstantaction. views and triggers and constraints
*  run with definer's privileges. if one of the required privileges is
*  revoked from the definer, the dependent view/trigger/constraint on
*  that privilege will be dropped automatically. in order to implement
*  this behavior, we need to save view/trigger/constraint dependencies
*  on required privileges in the dependency system. following method
*  accomplishes that part of the equation for views and triggers. the
*  dependency collection for constraints is not same as for views and
*  triggers and hence constraints are not covered by this method.
*  views and triggers can depend on many different kind of privileges
*  where as constraints only depend on references privilege on a table.
*  another difference is only one view or trigger can be defined by a
*  sql statement and hence all the dependencies collected for the sql
*  statement apply to the view or trigger in question. as for constraints,
*  one sql statement can defined multiple constraints and hence the
*  all the privileges required by the statement are not necessarily
*  required by all the constraints defined by that sql statement. we need
*  to identify right privileges for right constraints for a given sql
*  statement. because of these differences between constraints and views
*  (and triggers), there are 2 different methods in this class to save
*  their privileges in the dependency system.
*
*  @param activation the execution environment for this constant action.
*  @param dependent make this object depend on required privileges
*
* @exception standardexception		thrown on failure
*/
protected void storeviewtriggerdependenciesonprivileges
activation activation  dependent dependent
throws standardexception
languageconnectioncontext lcc   activation getlanguageconnectioncontext
datadictionary dd   lcc getdatadictionary
dependencymanager dm   dd getdependencymanager
//if the database owner is creating this view/triiger, then no need to
//collect any privilege dependencies because the database owner can
//access any objects without any restrictions
if    lcc getauthorizationid   equals dd getauthorizationdatabaseowner
permissionsdescriptor permdesc
list requiredpermissionslist   activation getpreparedstatement   getrequiredpermissionslist
if  requiredpermissionslist    null      requiredpermissionslist isempty
for iterator iter   requiredpermissionslist iterator   iter hasnext
statementpermission statperm    statementpermission  iter next
//the schema ownership permission just needs to be checked
//at object creation time, to see if the object creator has
//permissions to create the object in the specified schema.
//but we don't need to add schema permission to list of
//permissions that the object is dependent on once it is
//created.
if  statperm instanceof statementschemapermission
continue
//see if we can find the required privilege for given authorizer?
permdesc   statperm getpermissiondescriptor lcc getauthorizationid    dd
if  permdesc    null   privilege not found for given authorizer
//the if condition above means that required privilege does
//not exist at the user level. the privilege has to exist at
//public level.
permdesc   statperm getpermissiondescriptor authorizer public_authorization_id  dd
//if the user accessing the object is the owner of that
//object, then no privilege tracking is needed for the
//owner.
if    permdesc checkowner lcc getauthorizationid
dm adddependency dependent  permdesc  lcc getcontextmanager
continue
//if the object on which permission is required is owned by the
//same user as the current user, then no need to keep that
//object's privilege dependency in the dependency system
if    permdesc checkowner lcc getauthorizationid
dm adddependency dependent  permdesc  lcc getcontextmanager
if  permdesc instanceof colpermsdescriptor
//for a given table, the table owner can give privileges
//on some columns at individual user level and privileges
//on some columns at public level. hence, when looking for
//column level privileges, we need to look both at user
//level as well as public level(only if user level column
//privileges do not cover all the columns accessed by this
//object). we have finished adding dependency for user level
//columns, now we are checking if some required column
//level privileges are at public level.
//a specific eg of a view
//user1
//create table t11(c11 int, c12 int);
//grant select(c11) on t1 to user2;
//grant select(c12) on t1 to public;
//user2
//create view v1 as select c11 from user1.t11 where c12=2;
//for the view above, there are 2 column level privilege
//depencies, one for column c11 which exists directly
//for user2 and one for column c12 which exists at public level.
statementcolumnpermission statementcolumnpermission    statementcolumnpermission  statperm
permdesc   statementcolumnpermission getpubliclevelcolpermsdescriptor lcc getauthorizationid    dd
//following if checks if some column level privileges
//exist only at public level. if so, then the public
//level column privilege dependency of view is added
//into dependency system.
if  permdesc    null
dm adddependency dependent  permdesc  lcc getcontextmanager