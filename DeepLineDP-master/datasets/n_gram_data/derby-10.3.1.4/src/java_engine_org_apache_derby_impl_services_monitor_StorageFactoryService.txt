/*
derby - class org.apache.derby.impl.services.monitor.storagefactoryservice
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services monitor
import org apache derby iapi util privilegedfileops
import org apache derby iapi reference messageid
import org apache derby iapi reference sqlstate
import org apache derby iapi services i18n messageservice
import org apache derby iapi services monitor monitor
import org apache derby iapi services monitor persistentservice
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby io storagefile
import org apache derby io storagefactory
import org apache derby io writablestoragefactory
import org apache derby iapi reference attribute
import org apache derby iapi reference property
import java io file
import java io fileinputstream
import java io fileoutputstream
import java io inputstream
import java io bufferedinputstream
import java io outputstream
import java io ioexception
import java io filenotfoundexception
import java util enumeration
import java util nosuchelementexception
import java util properties
import java security accesscontroller
import java security privilegedaction
import java security privilegedexceptionaction
import java security privilegedactionexception
/**
* this class implements the persistentservice interface using a storagefactory class.
* it handles all subsubprotocols except for cache.
*/
final class storagefactoryservice implements persistentservice
private string home     the path of the database home directory  can be null
private string canonicalhome     will be null if home is null
private final string subsubprotocol
private final class storagefactoryclass
private storagefactory rootstoragefactory
private char separatorchar
storagefactoryservice  string subsubprotocol  class storagefactoryclass
throws standardexception
this subsubprotocol   subsubprotocol
this storagefactoryclass   storagefactoryclass
object monitorenv   monitor getmonitor   getenvironment
if  monitorenv instanceof file
final file relativeroot    file  monitorenv
try
accesscontroller doprivileged
new java security privilegedexceptionaction
public object run   throws ioexception  standardexception
home   relativeroot getpath
canonicalhome   relativeroot getcanonicalpath
rootstoragefactory   getstoragefactoryinstance  true  null  null  null
if  home    null
storagefile rootdir   rootstoragefactory newstoragefile  null
rootdir mkdirs
return null
catch  privilegedactionexception pae
home   null
canonicalhome   null
if  rootstoragefactory    null
try
rootstoragefactory   getstoragefactoryinstance  true  null  null  null
catch  ioexception ioe   throw monitor exceptionstartingmodule   servicename     ioe
accesscontroller doprivileged
new java security privilegedaction
public object run
separatorchar   rootstoragefactory getseparator
return null
end of constructor
/*
** methods of persistentservice
*/
/**
* @return true if the persistentservice has a storagefactory, false if not.
*/
public boolean hasstoragefactory
return true
/**
* get an initialized storagefactoryinstance
*
* @param usehome if true and the database name is not absolute then the database directory will be
*                relative to the home directory, if one is defined in the properties file.
* @param databasename the name of the database (directory). the name does not include the subsubprotocol.
*                     if null then the storage factory will only be used to deal with the directory containing
*                     the databases.
* @param tempdirname the name of the temporary file directory set in properties. if null then a default
*                    directory should be used. each database should get a separate temporary file
*                    directory within this one to avoid collisions.
* @param uniquename a unique name that can be used to create the temporary file directory for this database.
*                   if null then temporary files will not be created in this storagefactory instance.
*
* @return an initialized storagefactory.
*
* @exception ioexception if create, the database directory does not exist, and it cannot be created;
*                        if !create and the database does not exist as a directory.
*/
public storagefactory getstoragefactoryinstance final boolean usehome
final string databasename
final string tempdirname
final string uniquename
throws standardexception  ioexception
try
return  storagefactory  accesscontroller doprivileged
new privilegedexceptionaction
public object run   throws instantiationexception  illegalaccessexception  ioexception
return privgetstoragefactoryinstance  usehome  databasename  tempdirname  uniquename
catch  privilegedactionexception pae
exception e   pae getexception
throw standardexception newexception  sqlstate registered_class_instance_error
e  subsubprotocol  storagefactoryclass
end of getstoragefactoryinstance
private storagefactory privgetstoragefactoryinstance  boolean usehome
string databasename
string tempdirname
string uniquename
throws instantiationexception  illegalaccessexception  ioexception
storagefactory storagefactory    storagefactory  storagefactoryclass newinstance
string dbn
if  databasename    null
subsubprotocol    null
databasename startswith  subsubprotocol
dbn   databasename substring  subsubprotocol length     1
else
dbn   databasename
storagefactory init  usehome ? home   null  dbn  tempdirname  uniquename
return storagefactory
end of privgetstoragefactoryinstance
/**
the type of the service is 'directory'
@see persistentservice#gettype
*/
public string gettype
return subsubprotocol
/**
return a list of all the directoies in the system directory.
@see persistentservice#getboottimeservices
*/
public enumeration getboottimeservices
if  home    null
return null
return new directorylist
/**
open the service properties in the directory identified by the service name.
the property service_root (db2j.rt.serviceroot) is added
by this method and set to the service directory.
@return a properties object or null if servicename does not represent a valid service.
@exception standardexception service appears valid but the properties cannot be created.
*/
public properties getserviceproperties  final string servicename  properties defaultproperties
throws standardexception
if  sanitymanager debug
if    servicename equals getcanonicalservicename servicename
sanitymanager throwassert     servicename
getcanonicalservicename servicename
//recreate the service root  if requested by the user.
final string recreatefrom   recreateserviceroot servicename  defaultproperties
final properties serviceproperties   new properties defaultproperties
try
accesscontroller doprivileged
new privilegedexceptionaction
public object run
throws ioexception  standardexception
instantiationexception  illegalaccessexception
if  recreatefrom    null     restore from a file
file propfile   new file recreatefrom  persistentservice properties_name
inputstream is   new fileinputstream propfile
try
serviceproperties load new bufferedinputstream is
finally
is close
else
storagefactory storagefactory   privgetstoragefactoryinstance  true  servicename  null  null
storagefile file   storagefactory newstoragefile  persistentservice properties_name
try
inputstream is   file getinputstream
try
// need to load the properties before closing the
// storagefactory.
serviceproperties load new bufferedinputstream is
finally
is close
finally
storagefactory shutdown
return null
return serviceproperties
catch  privilegedactionexception pae
if  pae getexception   instanceof filenotfoundexception
return null
throw monitor exceptionstartingmodule  pae getexception
catch  securityexception se    throw monitor exceptionstartingmodule   servicename     se
end of getserviceproperties
/**
@exception standardexception properties cannot be saved.
*/
public void saveserviceproperties  final string servicename
storagefactory sf
final properties properties
final boolean replace
throws standardexception
if  sanitymanager debug
sanitymanager assert servicename equals getcanonicalservicename servicename    servicename
if     sf instanceof writablestoragefactory
throw standardexception newexception sqlstate read_only_service
final writablestoragefactory storagefactory    writablestoragefactory  sf
try
accesscontroller doprivileged
new privilegedexceptionaction
public object run   throws standardexception
storagefile backupfile   null
storagefile servicepropertiesfile   storagefactory newstoragefile  persistentservice properties_name
if  replace
backupfile   storagefactory newstoragefile  persistentservice properties_name concat
try
if  servicepropertiesfile renameto backupfile
throw standardexception newexception sqlstate unable_to_rename_file
servicepropertiesfile  backupfile
catch  securityexception se    throw monitor exceptionstartingmodule se
outputstream os   null
try
os   servicepropertiesfile getoutputstream
properties store  os  servicename   messageservice gettextmessage messageid service_properties_dont_edit
storagefactory sync  os  false
os close
os   null
catch  ioexception ioe
if  os    null
try
os close
catch  ioexception ioe2
os   null
if  backupfile    null
// need to re-name the old properties file back again
try
servicepropertiesfile delete
backupfile renameto servicepropertiesfile
catch  securityexception se
throw monitor exceptionstartingmodule ioe
if  backupfile    null
try
backupfile delete
backupfile   null
catch  securityexception se
return null
catch  privilegedactionexception pae    throw  standardexception  pae getexception
end of saveserviceproperties
/**
save to a backup file
@exception standardexception properties cannot be saved.
*/
public void saveserviceproperties final string servicename
final properties properties
final boolean replace
throws standardexception
try
accesscontroller doprivileged
new privilegedexceptionaction
file backupfile   null
public object run   throws standardexception
file servicepropertiesfile
new file servicename  persistentservice properties_name
if  replace
backupfile
new file servicename  persistentservice properties_name concat
try
if  servicepropertiesfile renameto backupfile
throw standardexception newexception
sqlstate unable_to_rename_file  servicepropertiesfile  backupfile
catch  securityexception se
throw monitor exceptionstartingmodule se
fileoutputstream fos   null
try
fos   new fileoutputstream servicepropertiesfile
properties store fos
servicename
messageservice gettextmessage
messageid service_properties_dont_edit
fos getfd   sync
fos close
fos   null
catch  ioexception ioe
if  fos    null
try
fos close
catch  ioexception ioe2
fos   null
if  backupfile    null
// need to re-name the old properties file back again
try
servicepropertiesfile delete
backupfile renameto servicepropertiesfile
catch  securityexception se
throw monitor exceptionstartingmodule ioe
if  backupfile    null
try
backupfile delete
backupfile   null
catch  securityexception se
// do nothing
return null
catch  privilegedactionexception pae    throw  standardexception  pae getexception
/*
**recreates service root if required depending on which of the following
**attribute is specified on the conection url:
** attribute.create_from (create database from backup if it does not exist):
** when a database not exist, the service(database) root is created
** and the persistentservice.properties_name (service.properties) file
** is restored from the backup.
** attribute.restore_from (delete the whole database if it exists and then restore
** it from backup)
** existing database root  is deleted and the new the service(database) root is created.
** persistentservice.properties_name (service.properties) file is restored from the backup.
** attribute.roll_forward_recovery_from:(perform rollforward recovery;
** except for the log directory everthing else is replced  by the copy  from
** backup. log files in the backup are copied to the existing online log
** directory.):
** when a database not exist, the service(database) root is created.
** persistentservice.properties_name (service.properties) file is deleted
** from the service dir and  recreated with the properties from backup.
*/
protected string recreateserviceroot  final string servicename
properties properties  throws standardexception
//if there are no propertues then nothing to do in this routine
if properties    null
return null
string restorefrom    location where backup copy of service properties available
boolean createroot   false
boolean deleteexistingroot   false
//check if user wants to create a database from a backup copy
restorefrom   properties getproperty attribute create_from
if restorefrom   null
//create root dicretory if it  does not exist.
createroot  true
deleteexistingroot   false
else
check if user requested a complete restore version recovery  from backup
restorefrom   properties getproperty attribute restore_from
//create root dir if it does not exists and  if there exists one already delete and recreate
if restorefrom   null
createroot  true
deleteexistingroot   true
else
//check if user has requested roll forward recovery using a backup
restorefrom   properties getproperty attribute roll_forward_recovery_from
if restorefrom   null
//if service root does not exist then only create one
//this is useful when logdevice was on some other device
//and the device on which data directorties existied has
//failed and user is trying to restore it some other device.
try
if  accesscontroller doprivileged
new privilegedexceptionaction
public object run
throws ioexception  standardexception  instantiationexception  illegalaccessexception
storagefactory storagefactory
privgetstoragefactoryinstance  true  servicename  null  null
try
storagefile servicedirectory   storagefactory newstoragefile  null
return servicedirectory exists   ? this   null
finally  storagefactory shutdown

createroot  true
deleteexistingroot   false
catch  privilegedactionexception pae
throw monitor exceptionstartingmodule   ioexception  pae getexception
//restore the service properties from backup
if restorefrom    null
//first make sure backup service directory exists in the specified path
file backuproot   new file restorefrom
if privilegedfileops exists backuproot
//first make sure backup have service.properties
file bserviceprop   new file restorefrom  persistentservice properties_name
if privilegedfileops exists bserviceprop
//create service root if required
if createroot
createserviceroot servicename  deleteexistingroot
try
accesscontroller doprivileged
new privilegedexceptionaction
public object run
throws ioexception  standardexception  instantiationexception  illegalaccessexception
writablestoragefactory storagefactory
writablestoragefactory  privgetstoragefactoryinstance  true
servicename


try
storagefile cserviceprop   storagefactory newstoragefile  persistentservice properties_name
if cserviceprop exists
if  cserviceprop delete
throw standardexception newexception sqlstate unable_to_delete_file
cserviceprop
return null
finally   storagefactory shutdown
catch  privilegedactionexception pae
throw monitor exceptionstartingmodule   ioexception pae getexception
else
throw standardexception newexception sqlstate property_file_not_found_in_backup  bserviceprop
else
throw standardexception newexception sqlstate service_directory_not_in_backup  backuproot
properties put property in_restore_from_backup
if createroot
properties put property delete_root_on_error
return restorefrom
end of recreateserviceroot
/**
properties cannot be saved
*/
public string createserviceroot final string name  final boolean deleteexisting
throws standardexception
if     rootstoragefactory instanceof writablestoragefactory
throw standardexception newexception sqlstate read_only_service
// we need to create the directory before we can call
// getcanonicalpath() on it, because if intermediate directories
// need to be created the getcanonicalpath() will fail.
throwable t   null
try
string protocolleadin
//prepend the subsub protocol name to the storage factoty canonical
//name to form the service name except in case of the the
//default subsubprototcol(persistentservice.directory)
if    gettype   equals  persistentservice directory
protocolleadin   gettype
return protocolleadin    string  accesscontroller doprivileged
new privilegedexceptionaction
public object run
throws standardexception  ioexception  instantiationexception  illegalaccessexception
storagefactory storagefactory   privgetstoragefactoryinstance  true  name  null  null
try
storagefile servicedirectory   storagefactory newstoragefile  null
if  servicedirectory exists
if  deleteexisting
if   servicedirectory deleteall
throw standardexception newexception sqlstate service_directory_remove_error
getdirectorypath  name
else
throw standardexception newexception sqlstate service_directory_exists_error
getdirectorypath  name
if  servicedirectory mkdirs
try
return storagefactory getcanonicalname
catch  ioexception ioe
servicedirectory deleteall
throw ioe
throw standardexception newexception sqlstate service_directory_create_error  servicedirectory
finally   storagefactory shutdown
catch  securityexception se    t   se
catch  privilegedactionexception pae
t   pae getexception
if  t instanceof standardexception
throw  standardexception  t
throw standardexception newexception sqlstate service_directory_create_error  t  name
end of createserviceroot
private string getdirectorypath  string name
stringbuffer sb   new stringbuffer
if  home    null
sb append  home
sb append  separatorchar
if  separatorchar
sb append  name replace     separatorchar
else
sb append  name
return sb tostring
end of getdirectorypath
public boolean removeserviceroot final string servicename
if     rootstoragefactory instanceof writablestoragefactory
return false
try
return accesscontroller doprivileged
new privilegedexceptionaction
public object run
throws standardexception  ioexception  instantiationexception  illegalaccessexception
storagefactory storagefactory   privgetstoragefactoryinstance  true  servicename  null  null
try
if  sanitymanager debug
sanitymanager assert
servicename equals
storagefactory getcanonicalname
servicename
storagefactory getcanonicalname
storagefile servicedirectory   storagefactory newstoragefile  null
return servicedirectory deleteall   ? this   null
finally   storagefactory shutdown

catch  privilegedactionexception pae   return false
end of removeserviceroot
public string getcanonicalservicename string name
throws standardexception
string protocolleadin   gettype
int colon   name indexof
if  colon > 1     subsubprotocols must be at least 2 characters long
if    name startswith  protocolleadin
return null     it is not our database
name   name substring  colon   1
if  gettype   equals  persistentservice directory      the default subsubprototcol
protocolleadin
final string nm   name
try
return protocolleadin    string  accesscontroller doprivileged
new privilegedexceptionaction
public object run
throws standardexception  ioexception  instantiationexception  illegalaccessexception
storagefactory storagefactory   privgetstoragefactoryinstance  true  nm  null  null
try
return storagefactory getcanonicalname
finally   storagefactory shutdown
catch  privilegedactionexception pae
throw monitor exceptionstartingmodule pae getexception
end of getcanonicalservicename
public string getuserservicename string servicename
if  home    null
// allow for file separatorchar by adding 1 to the length
if   servicename length   >  canonicalhome length     1      servicename startswith canonicalhome
servicename   servicename substring canonicalhome length
if  servicename charat 0     separatorchar
servicename   servicename substring 1
return servicename replace  separatorchar
public boolean issameservice string servicename1  string servicename2
if  sanitymanager debug
try
sanitymanager assert servicename1 equals getcanonicalservicename servicename1    servicename1
sanitymanager assert servicename2 equals getcanonicalservicename servicename2    servicename2
catch  standardexception se
return false
return servicename1 equals servicename2
end of issameservice
/**
* get the storagefactory implementation for this persistentservice
*
* @return the storagefactory class.
*/
public class getstoragefactoryclass
return storagefactoryclass
final class directorylist implements enumeration  privilegedaction
private string contents
private storagefile systemdirectory
private int      index
private boolean  validindex
private int actioncode
private static final int init_action   0
private static final int has_more_elements_action   1
directorylist
actioncode   init_action
accesscontroller doprivileged  this
public boolean hasmoreelements
if  contents    null
return false
if  validindex
return true
actioncode   has_more_elements_action
return accesscontroller doprivileged  this     null
end of hasmoreelements
public object nextelement   throws nosuchelementexception
if   hasmoreelements
throw new nosuchelementexception
validindex   false
return contents
end of nextelement
// privilegedaction method
public final object run
switch  actioncode
case init_action
systemdirectory   rootstoragefactory newstoragefile  null
contents   systemdirectory list
return null
case has_more_elements_action
for    index < contents length  contents   null
try
string dirname   contents
storagefile dir   rootstoragefactory newstoragefile dirname
if   dir isdirectory
continue
// look to see if service.properties is in this
// directory.
storagefile properties
rootstoragefactory newstoragefile dir
persistentservice properties_name
if   properties exists
continue
// convert to a canonical name while we are here.
contents   dir getcanonicalpath
validindex   true
return this
catch  exception se    continue
return null
return null
end of run
end of class directorylist