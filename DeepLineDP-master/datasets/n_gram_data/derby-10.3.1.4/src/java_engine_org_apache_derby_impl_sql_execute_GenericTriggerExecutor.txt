/*
derby - class org.apache.derby.impl.sql.execute.generictriggerexecutor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi error standardexception
import org apache derby iapi sql dictionary spsdescriptor
import org apache derby iapi sql dictionary triggerdescriptor
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql execute execpreparedstatement
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn statementcontext
import org apache derby iapi reference sqlstate
/**
* a trigger executor is an object that executes
* a trigger.  it is subclassed by row and statement
* executors.
*/
public abstract class generictriggerexecutor
protected internaltriggerexecutioncontext	tec
protected triggerdescriptor					triggerd
protected activation						activation
protected languageconnectioncontext			lcc
private	boolean			whenclauseretrieved
private	boolean			actionretrieved
private spsdescriptor	whenclause
private spsdescriptor	action
private execpreparedstatement	ps
private activation 				spsactivation
/**
* constructor
*
* @param tec the execution context
* @param triggerd the trigger descriptor
* @param activation the activation
* @param lcc the lcc
*/
generictriggerexecutor
internaltriggerexecutioncontext tec
triggerdescriptor 				triggerd
activation						activation
languageconnectioncontext		lcc
this tec   tec
this triggerd   triggerd
this activation   activation
this lcc   lcc
/**
* fire the trigger based on the event.
*
* @param event	    the trigger event
* @param brs		the before result set
* @param ars		the after result set
*
* @exception standardexception on error or user exception
* from trigger action
*/
abstract void firetrigger
triggerevent 		event
cursorresultset 	brs
cursorresultset 	ars
throws standardexception
protected spsdescriptor getwhenclause   throws standardexception
if   whenclauseretrieved
whenclauseretrieved   true
whenclause   triggerd getwhenclausesps
return whenclause
protected spsdescriptor getaction   throws standardexception
if   actionretrieved
actionretrieved   true
action   triggerd getactionsps lcc
return action
/**
* execute the given stored prepared statement.  we
* just grab the prepared statement from the spsd,
* get a new activation holder and let er rip.
*
* @exception standardexception on error
*/
protected void executesps spsdescriptor sps  throws standardexception
boolean recompile   false
while  true
/*
** only grab the ps the 1st time through.  this
** way a row trigger doesn't do any unnecessary
** setup work.
*/
if  ps    null    recompile
/*
** we need to clone the prepared statement so we don't
** wind up marking that ps that is tied to sps as finished
** during the course of execution.
*/
ps   sps getpreparedstatement
ps   ps getclone
// it should be valid since we've just prepared for it
ps setvalid
spsactivation   ps getactivation lcc  false
/*
** normally, we want getsource() for an sps invocation
** to be exec statement xxx, but in this case, since
** we are executing the sps in our own fashion, we want
** the text to be the trigger action.  so set it accordingly.
*/
ps setsource sps gettext
ps setspsaction
// save the active statement context for exception handling purpose
statementcontext active_sc   lcc getstatementcontext
/*
** execute the activation.  if we have an error, we
** are going to go to some extra work to pop off
** our statement context.  this is because we are
** a nested statement (we have 2 activations), but
** we aren't a nested connection, so we have to
** pop off our statementcontext to get error handling
** to work correctly.  this is normally a no-no, but
** we are an unusual case.
*/
try
// this is a substatement; for now, we do not set any timeout
// for it. we might change this behaviour later, by linking
// timeout to its parent statement's timeout settings.
resultset rs   ps execute spsactivation  false  0l
if  rs returnsrows
// fetch all the data to ensure that functions in the select list or values statement will
// be evaluated and side effects will happen. why else would the trigger action return
// rows, but for side effects?
// the result set was opened in ps.execute()
while  rs getnextrow      null
rs close
catch  standardexception e
/*
** when a trigger sps action is executed and results in
** an exception, the system needs to clean up the active
** statement context(sc) and the trigger execution context
** (tec) in language connection context(lcc) properly (e.g.:
** "maximum depth triggers exceeded" exception); otherwise,
** this will leave old tecs lingering and may result in
** subsequent statements within the same connection to throw
** the same exception again prematurely.
**
** a new statement context will be created for the sps before
** it is executed.  however, it is possible for some
** standardexception to be thrown before a new statement
** context is pushed down to the context stack; hence, the
** trigger executor needs to ensure that the current active sc
** is associated with the sps, so that it is cleaning up the
** right statement context in lcc.
**
** when the active sc is cleaned up, the tec will be removed
** from lcc and the sc object will be popped off from the lcc
** as part of cleanuponerror logic.
*/
/* retrieve the current active sc */
statementcontext sc   lcc getstatementcontext
/* make sure that the cleanup is on the new sc */
if  active_sc    sc
sc cleanuponerror e
/* handle dynamic recompiles */
if  e getmessageid   equals sqlstate lang_statement_needs_recompile
recompile   true
sps revalidate lcc
continue
spsactivation close
throw e
/* done with execution without any recompiles */
break
/**
* cleanup after executing an sps.
*
* @exception standardexception on error
*/
protected void clearsps   throws standardexception
if  spsactivation    null
spsactivation close
ps   null
spsactivation   null