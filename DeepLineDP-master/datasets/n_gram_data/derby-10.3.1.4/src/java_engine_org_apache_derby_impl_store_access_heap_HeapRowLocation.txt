/*
derby - class org.apache.derby.impl.store.access.heap.heaprowlocation
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access heap
import org apache derby iapi error standardexception
import org apache derby iapi services cache classsize
import org apache derby iapi services io arrayinputstream
import org apache derby iapi services io compressednumber
import org apache derby iapi services io storedformatids
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw containerhandle
import org apache derby iapi types datatype
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import java io objectoutput
import java io objectinput
import java io ioexception
/**
* a heap row location represents the location of a row in the heap.
* <p>
* it is implementad as a wrapper around a raw store record handle.
*
* @format_id access_heap_row_location_v1_id
*
* @purpose   object used to store the location of a row within a heap table.
*            one of these is stored in every row of a btree secondary index
*            built on a heap base table.
*
* @upgrade   the type of the btree determines the type of rowlocation stored.
*            in current btree implementations only one type of rowlocation can
*            be stored per tree, and it's type is stored in the format id
*            array stored in the conglomerate object.
*
* @disk_layout
*     page number(compressednumber.writelong())
*     record id(compressednumber.writeint())
**/
public class heaprowlocation extends datatype implements rowlocation
{
/**
the heaprowlocation simply maintains a raw store record handle.
**/
private long         pageno
private int          recid
private recordhandle rh
private static final int base_memory_usage   classsize estimatebasefromcatalog  heaprowlocation class
private static final int record_handle_memory_usage
classsize estimatebasefromcatalog  org apache derby impl store raw data recordid class
public int estimatememoryusage
{
int sz   base_memory_usage
if  null    rh
sz    record_handle_memory_usage
return sz
end of estimatememoryusage
public string gettypename
return
}
public void setvaluefromresultset java sql resultset resultset  int colnumber
boolean isnullable
}
public datavaluedescriptor getnewnull
return new heaprowlocation
}
public object getobject
return null
}
/*
** methods of cloneableobject.
*/
public object cloneobject
{
return getclone
}
public datavaluedescriptor getclone
return new heaprowlocation this
}
/**
* recycle this heaprowlocation object.
*
* @return this object reset to its initial state
*/
public datavaluedescriptor recycle
pageno   0l
recid   0
rh   null
return this
}
public int getlength
return 10
}
public string getstring
return tostring
}
/*
** methods of orderable (from rowlocation)
**
** see description in
** protocol/database/storage/access/interface/orderable.java
**
*/
public boolean compare int op
datavaluedescriptor other
boolean orderednulls
boolean unknownrv
{
// heaprowlocation should not be null, ignore orderednulls
int result   compare other
switch op
{
case order_op_lessthan
return  result < 0      this < other
case order_op_equals
return  result    0       this    other
case order_op_lessorequals
return  result <  0       this <  other
default
if (sanitymanager.debug)
sanitymanager throwassert
return false
}
}
public int compare datavaluedescriptor other
{
// revisit: do we need this check?
if (sanitymanager.debug)
sanitymanager assert other instanceof heaprowlocation
heaprowlocation arg    heaprowlocation  other
// xxx (nat) assumption is that these heaprowlocations are
// never null.  however, if they ever become null, need
// to add null comparison logic.
//
// resolve - change these to be state based
/*
if (sanitymanager.debug)
sanitymanager.assert(getrecordhandle() != null);
if (sanitymanager.debug)
sanitymanager.assert(arg.getrecordhandle() != null);
*/
long mypage       this pageno
long otherpage    arg pageno
if  mypage < otherpage
return  1
else if  mypage > otherpage
return 1
int myrecordid        this recid
int otherrecordid     arg recid
if  myrecordid    otherrecordid
return 0
else if  myrecordid < otherrecordid
return  1
else
return 1
}
/*
** methods of heaprowlocation
*/
heaprowlocation recordhandle rh
{
setfrom rh
}
public heaprowlocation
{
this pageno   0
this recid    recordhandle invalid_record_handle
}
/* for cloning */
private heaprowlocation heaprowlocation other
{
this pageno   other pageno
this recid   other recid
this rh   other rh
}
public recordhandle getrecordhandle containerhandle ch
throws standardexception
{
if  rh    null
return rh
return rh   ch makerecordhandle this pageno  this recid
}
void setfrom recordhandle rh
{
this pageno   rh getpagenumber
this recid    rh getid
this rh   rh
}
//public void setfrom(long pageno, int recid)
//{
//    this.pageno = pageno;
//    this.recid  = recid;
//}
/*
* internalrowlocation interface
*/
/**
* return a recordhandle built from current rowlocation.
* <p>
* build a recordhandle from the current rowlocation.  the main client
* of this interface is row level locking secondary indexes which read
* the rowlocation field from a secondary index row, and then need a
* recordhandle built from this rowlocation.
* <p>
* the interface is not as generic as one may have wanted in order to
* store as compressed a version of a rowlocation as possible.  so
* if an implementation of a rowlocation does not have the segmentid,
* and containerid stored, use the input parameters instead.  if the
* rowlocation does have the values stored use them and ignore the
* input parameters.
* <p>
* example:
* <p>
* the heaprowlocation implementation of rowlocation generated by the
* heap class, only stores the page and record id.  the b2i conglomerate
* implements a secondary index on top of a heap class.  b2i knows the
* segmentid and containerid of it's base table, and knows that it can
* find an internalrowlocation in a particular column of it's rows.  it
* uses internalrowlocation.getrecordhandle() to build a recordhandle
* from the internalrowlocation, and uses it to set a row lock on that
* row in the btree.
*
* @return the newly allocated recordhandle.
*
* @param segmentid     the segment id to store in recordhandle.
* @param containerid   the segment id to store in recordhandle.
*
* @exception  standardexception  standard exception policy.
**/
/*public recordhandle getrecordhandle(
transactionmanager   tran,
long                 segmentid,
long                 containerid)
throws standardexception
{
return(
this.getrecordhandle(
tran.getrawstorexact(), segmentid, containerid));
}
*/
/*
* storable interface, implies externalizable, typedformat
*/
/**
return my format identifier.
@see org.apache.derby.iapi.services.io.typedformat#gettypeformatid
*/
public int gettypeformatid
return storedformatids access_heap_row_location_v1_id
}
public boolean isnull
{
return false
}
public void writeexternal objectoutput out
throws ioexception
{
// write the page number, compressed
compressednumber writelong out  this pageno
// write the record id
compressednumber writeint out  this recid
}
/**
@exception java.lang.classnotfoundexception a class needed to read the
stored form of this object could not be found.
@see java.io.externalizable#readexternal
*/
public void readexternal objectinput in
throws ioexception  classnotfoundexception
{
this pageno   compressednumber readlong in
this recid    compressednumber readint in
rh   null
}
public void readexternalfromarray arrayinputstream in
throws ioexception  classnotfoundexception
{
this pageno   in readcompressedlong
this recid    in readcompressedint
rh   null
}
public void restoretonull
{
if (sanitymanager.debug)
sanitymanager throwassert
}
protected void setfrom datavaluedescriptor thevalue
if (sanitymanager.debug)
sanitymanager throwassert
}
/*
**		methods of object
*/
/**
implement value equality.
<br>
mt - thread safe
*/
public boolean equals object ref
{
if   ref instanceof heaprowlocation
{
heaprowlocation other    heaprowlocation  ref
return(
this pageno    other pageno      this recid    other recid
}
else
{
return false
}
}
/**
return a hashcode based on value.
<br>
mt - thread safe
*/
public int hashcode
{
return   int  this pageno  ^ this recid
}
/*
* standard tostring() method.
*/
public string tostring
{
string string
this pageno       this recid
return string
}
}