/*
derby - class org.apache.derby.impl.sql.execute.createindexconstantaction
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import java util properties
import org apache derby catalog uuid
import org apache derby catalog types statisticsimpl
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services io formatablebitset
import org apache derby iapi services loader classfactory
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql activation
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary columndescriptorlist
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary conglomeratedescriptorlist
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi sql dictionary datadescriptorgenerator
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary indexrowgenerator
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary statisticsdescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql execute constantaction
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute execrow
import org apache derby iapi store access columnordering
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access groupfetchscancontroller
import org apache derby iapi store access rowlocationretrowsource
import org apache derby iapi store access scancontroller
import org apache derby iapi store access sortcontroller
import org apache derby iapi store access sortobserver
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi types typeid
/**
* constantaction to create an index either through
* a create index statement or as a backing index to
* a constraint.
*/
class createindexconstantaction extends indexconstantaction
private boolean			unique
private string			indextype
private string		columnnames
private boolean		isascending
private boolean			isconstraint
private uuid			conglomerateuuid
private properties		properties
private execrow indextemplaterow
// constructors
/**
*	make the constantaction to create an index.
*
*  @param unique		true means it will be a unique index
*  @param indextype	the type of index (btree, for example)
*  @param schemaname	the schema that table (and index) lives in.
*  @param indexname	name of the index
*  @param tablename	name of table the index will be on
*  @param tableid		uuid of table
*  @param columnnames	names of the columns in the index, in order
*	@param isascending	array of booleans telling asc/desc on each column
*  @param isconstraint	true if index is backing up a constraint, else false
*  @param conglomerateuuid	id of conglomerate
*  @param properties	the optional properties list associated with the index.
*/
createindexconstantaction
boolean			unique
string			indextype
string			schemaname
string			indexname
string			tablename
uuid			tableid
string		columnnames
boolean		isascending
boolean			isconstraint
uuid			conglomerateuuid
properties		properties
super tableid  indexname  tablename  schemaname
this unique   unique
this indextype   indextype
this columnnames   columnnames
this isascending   isascending
this isconstraint   isconstraint
this conglomerateuuid   conglomerateuuid
this properties   properties
///////////////////////////////////////////////
//
// object shadows
//
///////////////////////////////////////////////
public	string	tostring
// do not put this under sanitymanager.debug - it is needed for
// error reporting.
return     indexname
// interface methods
/**
*	this is the guts of the execution-time logic for
*  creating an index.
*
*  <p>
*  a index is represented as:
*  <ul>
*  <li> conglomeratedescriptor.
*  </ul>
*  no dependencies are created.
*
*  @see conglomeratedescriptor
*  @see schemadescriptor
*	@see constantaction#executeconstantaction
*
* @exception standardexception		thrown on failure
*/
public void	executeconstantaction  activation activation
throws standardexception
boolean						forcreatetable
tabledescriptor 			td
uuid 						toid
columndescriptor			columndescriptor
int						basecolumnpositions
indexrowgenerator			indexrowgenerator   null
execrow					baserows
execindexrow				indexrows
execrow					compactbaserows
groupfetchscancontroller    scan
rowlocationretrowsource	    rowsource
long						sortid
int							maxbasecolumnposition    1
languageconnectioncontext lcc   activation getlanguageconnectioncontext
datadictionary dd   lcc getdatadictionary
dependencymanager dm   dd getdependencymanager
transactioncontroller tc   lcc gettransactionexecute
/* remember whether or not we are doing a create table */
forcreatetable   activation getforcreatetable
/*
** inform the data dictionary that we are about to write to it.
** there are several calls to data dictionary "get" methods here
** that might be done in "read" mode in the data dictionary, but
** it seemed safer to do this whole operation in "write" mode.
**
** we tell the data dictionary we're done writing at the end of
** the transaction.
*/
dd startwriting lcc
/*
** if the schema descriptor is null, then
** we must have just read ourselves in.
** so we will get the corresponding schema
** descriptor from the data dictionary.
*/
schemadescriptor sd   dd getschemadescriptor schemaname  tc  true
/* get the table descriptor. */
/* see if we can get the tabledescriptor
* from the activation.  (will be there
* for backing indexes.)
*/
td   activation getddltabledescriptor
if  td    null
/* tableid will be non-null if adding an index to
* an existing table (as opposed to creating a
* table with a constraint with a backing index).
*/
if  tableid    null
td   dd gettabledescriptor tableid
else
td   dd gettabledescriptor tablename  sd
if  td    null
throw standardexception newexception sqlstate lang_create_index_no_table
indexname  tablename
if  td gettabletype      tabledescriptor system_table_type
throw standardexception newexception sqlstate lang_create_system_index_attempted
indexname  tablename
/* get a shared table lock on the table. we need to lock table before
* invalidate dependents, otherwise, we may interfere with the
* compilation/re-compilation of dml/ddl.  see beetle 4325 and $ws/
* docs/language/solutionstoconcurrencyissues.txt (point f).
*/
locktableforddl tc  td getheapconglomerateid    false
// invalidate any prepared statements that
// depended on this table (including this one)
if    forcreatetable
dm invalidatefor td  dependencymanager create_index  lcc
// translate the base column names to column positions
basecolumnpositions   new int
for  int i   0  i < columnnames length  i
// look up the column in the data dictionary
columndescriptor   td getcolumndescriptor columnnames
if  columndescriptor    null
throw standardexception newexception sqlstate lang_column_not_found_in_table
columnnames
tablename
typeid typeid   columndescriptor gettype   gettypeid
// don't allow a column to be created on a non-orderable type
classfactory cf   lcc getlanguageconnectionfactory   getclassfactory
boolean isindexable   typeid orderable cf
if  isindexable    typeid usertype
string userclass   typeid getcorrespondingjavatypename
// don't allow indexes to be created on classes that
// are loaded from the database. this is because recovery
// won't be able to see the class and it will need it to
// run the compare method.
try
if  cf isapplicationclass cf loadapplicationclass userclass
isindexable   false
catch  classnotfoundexception cnfe
// shouldn't happen as we just check the class is orderable
isindexable   false
if   isindexable
throw standardexception newexception sqlstate lang_column_not_orderable_during_execution
typeid getsqltypename
// remember the position in the base table of each column
basecolumnpositions   columndescriptor getposition
if  maxbasecolumnposition < basecolumnpositions
maxbasecolumnposition   basecolumnpositions
// check if we have similar indices already for this table
conglomeratedescriptor congdescs   td getconglomeratedescriptors
boolean duplicate   false
long conglomid   0
for  int i   0  i < congdescs length  i
conglomeratedescriptor cd   congdescs
if     cd isindex
continue
indexrowgenerator irg   cd getindexdescriptor
int bcps   irg basecolumnpositions
boolean ia   irg isascending
int j   0
/* for an index to be considered a duplicate of already existing index, the
* following conditions have to be satisfied:
* 1. the set of columns (both key and include columns) and their
*  order in the index is the same as that of an existing index and
* 2. the ordering attributes are the same and
* 3. both the previously existing index and the one being created
*  are non-unique or the previously existing index is unique
*/
if   bcps length    basecolumnpositions length
irg isunique       unique
indextype equals irg indextype
for    j < bcps length  j
if   bcps    basecolumnpositions      ia    isascending
break
if  j    basecolumnpositions length 	   duplicate
/*
* don't allow users to create a duplicate index. allow if being done internally
* for a constraint
*/
if   isconstraint
activation addwarning
standardexception newwarning
sqlstate lang_index_duplicate
cd getconglomeratename
return
//duplicate indexes share the physical conglomerate underneath
conglomid   cd getconglomeratenumber
indexrowgenerator   cd getindexdescriptor
//derby-655 and derby-1343
//duplicate indexes will have unqiue logical conglomerate uuids.
conglomerateuuid   dd getuuidfactory   createuuid
duplicate   true
break
/* if this index already has an essentially same one, we share the
* conglomerate with the old one, and just simply add a descriptor
* entry into sysconglomerates.
*/
datadescriptorgenerator ddg   dd getdatadescriptorgenerator
if  duplicate
conglomeratedescriptor cgd
ddg newconglomeratedescriptor conglomid  indexname  true
indexrowgenerator  isconstraint
conglomerateuuid  td getuuid    sd getuuid
dd adddescriptor cgd  sd  datadictionary sysconglomerates_catalog_num  false  tc
// add newly added conglomerate to the list of conglomerate
// descriptors in the td.
conglomeratedescriptorlist cdl
td getconglomeratedescriptorlist
cdl add cgd
// can't just return yet, need to get member "indextemplaterow"
// because create constraint may use it
// describe the properties of the index to the store using properties
// resolve: the following properties assume a btree index.
properties	indexproperties
if  properties    null
indexproperties   properties
else
indexproperties   new properties
// tell it the conglomerate id of the base table
indexproperties put
long tostring td getheapconglomerateid
// all indexes are unique because they contain the rowlocation.
// the number of uniqueness columns must include the rowlocation
// if the user did not specify a unique index.
indexproperties put
integer tostring unique ? basecolumnpositions length
basecolumnpositions length   1
// by convention, the row location column is the last column
indexproperties put
integer tostring basecolumnpositions length
// for now, all columns are key fields, including the rowlocation
indexproperties put
integer tostring basecolumnpositions length   1
// for now, assume that all index columns are ordered columns
if    duplicate
indexrowgenerator   new indexrowgenerator indextype  unique
basecolumnpositions
isascending
basecolumnpositions length
/* now add the rows from the base table to the conglomerate.
* we do this by scanning the base table and inserting the
* rows into a sorter before inserting from the sorter
* into the index.  this gives us better performance
* and a more compact index.
*/
rowsource   null
sortid   0
boolean needtodropsort   false 	   set to true once the sorter is created
/* bulkfetchsize will be 16 (for now) unless
* we are creating the table in which case it
* will be 1.  too hard to remove scan when
* creating index on new table, so minimize
* work where we can.
*/
int bulkfetchsize    forcreatetable  ? 1   16
int numcolumns   td getnumberofcolumns
int approximaterowsize   0
// create the formatablebitset for mapping the partial to full base row
formatablebitset bitset   new formatablebitset numcolumns 1
for  int index   0  index < basecolumnpositions length  index
bitset set basecolumnpositions
formatablebitset zerobasedbitset   rowutil shift bitset  1
// start by opening a full scan on the base table.
scan   tc opengroupfetchscan
td getheapconglomerateid
false 	   hold
0 	   open base table read only
transactioncontroller mode_table
transactioncontroller isolation_serializable
zerobasedbitset        all fields as objects
datavaluedescriptor  null 	   startkeyvalue
0 		   not used when giving null start posn
null 	   qualifier
datavaluedescriptor  null 	   stopkeyvalue
0  		   not used when giving null stop posn
// create an array to put base row template
baserows   new execrow
indexrows   new execindexrow
compactbaserows   new execrow
try
// create the array of base row template
for  int i   0  i < bulkfetchsize  i
// create a base row template
baserows   activation getexecutionfactory   getvaluerow maxbasecolumnposition
// create an index row template
indexrows   indexrowgenerator getindexrowtemplate
// create a compact base row template
compactbaserows   activation getexecutionfactory   getvaluerow
basecolumnpositions length
indextemplaterow   indexrows
// fill the partial row with nulls of the correct type
columndescriptorlist cdl   td getcolumndescriptorlist
int					 cdlsize   cdl size
for  int index   0  numset   0  index < cdlsize  index
if    zerobasedbitset get index
continue
numset
columndescriptor cd    columndescriptor  cdl elementat index
datatypedescriptor dts   cd gettype
for  int i   0  i < bulkfetchsize  i
// put the column in both the compact and sparse base rows
baserows setcolumn index   1
dts getnull
compactbaserows setcolumn numset
baserows getcolumn index   1
// calculate the approximate row size for the index row
approximaterowsize    dts gettypeid   getapproximatelengthinbytes dts
// get an array of rowlocation template
rowlocation rl   new rowlocation
for  int i   0  i < bulkfetchsize  i
rl   scan newrowlocationtemplate
// get an index row based on the base row
indexrowgenerator getindexrow compactbaserows  rl  indexrows  bitset
/* now that we got indextemplaterow, done for duplicate index
*/
if  duplicate
return
/* for non-unique indexes, we order by all columns + the rid.
* for unique indexes, we just order by the columns.
* we create a unique index observer for unique indexes
* so that we can catch duplicate key.
* we create a basic sort observer for non-unique indexes
* so that we can reuse the wrappers during an external
* sort.
*/
int numcolumnorderings
sortobserver sortobserver   null
if  unique
numcolumnorderings   basecolumnpositions length
// if the index is a constraint, use constraintname in possible error messagge
string indexorconstraintname   indexname
if   conglomerateuuid    null
conglomeratedescriptor cd   dd getconglomeratedescriptor conglomerateuuid
if   isconstraint      cd    null    cd getuuid      null    td    null
constraintdescriptor condesc   dd getconstraintdescriptor td
cd getuuid
indexorconstraintname   condesc getconstraintname
sortobserver   new uniqueindexsortobserver true  isconstraint
indexorconstraintname
indextemplaterow
true
td getname
else
numcolumnorderings   basecolumnpositions length   1
sortobserver   new basicsortobserver true  false
indextemplaterow
true
columnordering	order   new columnordering
for  int i 0  i < numcolumnorderings  i
order
new indexcolumnorder
i
unique    i < numcolumnorderings   1 ?
isascending   true
// create the sorter
sortid   tc createsort  properties null
indextemplaterow getrowarrayclone
order
sortobserver
false 			   not in order
scan getestimatedrowcount
approximaterowsize	   est row size   1 means no idea
needtodropsort   true
// populate sorter and get the output of the sorter into a row
// source.  the sorter has the indexed columns only and the columns
// are in the correct order.
rowsource   loadsorter baserows  indexrows  tc
scan  sortid  rl
conglomid
tc createandloadconglomerate
indextype
indextemplaterow getrowarray   	   index row template
order    colums sort order
indexrowgenerator getcolumncollationids
td getcolumndescriptorlist
indexproperties
transactioncontroller is_default     not temporary
rowsource
long  null
finally
/* close the table scan */
if  scan    null
scan close
/* close the sorter row source before throwing exception */
if  rowsource    null
rowsource closerowsource
/*
** drop the sort so that intermediate external sort run can be
** removed from disk
*/
if  needtodropsort
tc dropsort sortid
conglomeratecontroller indexcontroller
tc openconglomerate
conglomid  false  0  transactioncontroller mode_table
transactioncontroller isolation_serializable
// check to make sure that the conglomerate can be used as an index
if     indexcontroller iskeyed
indexcontroller close
throw standardexception newexception sqlstate lang_non_keyed_index  indexname
indextype
indexcontroller close
//
// create a conglomerate descriptor with the conglomid filled in and
// add it.
//
conglomeratedescriptor cgd
ddg newconglomeratedescriptor conglomid  indexname  true
indexrowgenerator  isconstraint
conglomerateuuid  td getuuid    sd getuuid
dd adddescriptor cgd  sd  datadictionary sysconglomerates_catalog_num  false  tc
// add newly added conglomerate to the list of conglomerate descriptors
// in the td.
conglomeratedescriptorlist cdl   td getconglomeratedescriptorlist
cdl add cgd
cardinalitycounter ccount    cardinalitycounter rowsource
long numrows
if   numrows   ccount getrowcount    > 0
long c   ccount getcardinality
for  int i   0  i < c length  i
statisticsdescriptor statdesc
new statisticsdescriptor dd  dd getuuidfactory   createuuid
cgd getuuid    td getuuid       new statisticsimpl numrows  c
i   1
dd adddescriptor statdesc  null
datadictionary sysstatistics_catalog_num
true  tc
// class methods
///////////////////////////////////////////////////////////////////////
//
//	getters called by createconstraint
//
///////////////////////////////////////////////////////////////////////
execrow getindextemplaterow
return indextemplaterow
/**
* do necessary clean up (close down controllers, etc.) before throwing
* a statement exception.
*
* @param scan				scancontroller for the heap
* @param indexcontroller	conglomeratecontroller for the index
*/
private void statementexceptioncleanup
scancontroller scan
conglomeratecontroller indexcontroller
throws standardexception
if  indexcontroller    null
indexcontroller close
if  scan    null
scan close
/**
* scan the base conglomerate and insert the keys into a sorter,
* returning a rowsource on the sorter.
*
* @return rowsource on the sorted index keys.
*
* @exception standardexception					thrown on error
*/
private rowlocationretrowsource loadsorter execrow baserows
execindexrow indexrows
transactioncontroller tc
groupfetchscancontroller scan
long sortid
rowlocation rl
throws standardexception
sortcontroller		sorter
long				rowcount   0
sorter   tc opensort sortid
try
// step through all the rows in the base table
// prepare an array or rows for bulk fetch
int bulkfetchsize   baserows length
if  sanitymanager debug
sanitymanager assert bulkfetchsize    indexrows length
sanitymanager assert bulkfetchsize    rl length
datavaluedescriptor baserowarray   new datavaluedescriptor
for  int i   0  i < bulkfetchsize  i
baserowarray   baserows getrowarray
// rl[i] and baserowarray[i] and indexrows[i] are all tied up
// beneath the surface.  fetching the base row and row location
// from the table scan will automagically set up the indexrow
// fetchnextgroup will return how many rows are actually fetched.
int bulkfetched   0
while   bulkfetched   scan fetchnextgroup baserowarray  rl   > 0
for  int i   0  i < bulkfetched  i
sorter insert indexrows getrowarray
rowcount
/*
** we've just done a full scan on the heap, so set the number
** of rows so the optimizer will have an accurate count.
*/
scan setestimatedrowcount rowcount
finally
sorter completedinserts
return new cardinalitycounter tc opensortrowsource sortid