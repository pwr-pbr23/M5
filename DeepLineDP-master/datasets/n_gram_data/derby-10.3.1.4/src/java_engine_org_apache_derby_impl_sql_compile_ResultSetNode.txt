/*
derby - class org.apache.derby.impl.sql.compile.resultsetnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services context contextmanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile costestimate
import org apache derby iapi sql compile optimizerfactory
import org apache derby iapi sql compile optimizer
import org apache derby iapi sql compile optimizablelist
import org apache derby iapi sql compile optimizablepredicatelist
import org apache derby iapi sql compile parser
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile requiredrowordering
import org apache derby iapi sql compile rowordering
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary defaultdescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql execute executioncontext
import org apache derby iapi sql activation
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types stringdatavalue
import org apache derby iapi sql resultcolumndescriptor
import org apache derby iapi sql resultdescription
import org apache derby iapi sql resultset
import org apache derby iapi types typeid
import org apache derby iapi store access transactioncontroller
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi reference classname
import org apache derby iapi services compiler methodbuilder
import org apache derby impl sql compile activationclassbuilder
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi util jbitset
import org apache derby iapi services classfile vmopcode
import org apache derby catalog types defaultinfoimpl
import java util properties
import java util vector
import java util set
/**
* a resultsetnode represents a result set, that is, a set of rows.  it is
* analogous to a resultset in the languagemoduleexternalinterface.  in fact,
* code generation for a a resultsetnode will create a "new" call to a
* constructor for a resultset.
*
*/
public abstract class resultsetnode extends querytreenode
{
int					resultsetnumber
/* bit map of referenced tables under this resultsetnode */
jbitset				referencedtablemap
resultcolumnlist	resultcolumns
boolean				statementresultset
boolean				cursortargettable
boolean				insertsource
costestimate 		costestimate
costestimate		scratchcostestimate
optimizer			optimizer
// final cost estimate for this result set node, which is the estimate
// for this node with respect to the best join order for the top-level
// query. subclasses will set this value where appropriate.
costestimate		finalcostestimate
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
{
if  sanitymanager debug
{
return 	    resultsetnumber
referencedtablemap    null
? referencedtablemap tostring
statementresultset
super tostring
}
else
{
return
}
}
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
{
if  sanitymanager debug
{
super printsubnodes depth
if  resultcolumns    null
{
printlabel depth
resultcolumns treeprint depth
}
}
}
/**
* get the resultsetnumber in this resultsetnode. expected to be set during
* generate().
*
* @return int 	the resultsetnumber.
*/
public int getresultsetnumber
{
return resultsetnumber
}
/**
* get the costestimate for this resultsetnode.
*
* @return	the costestimate for this resultsetnode.
*/
public costestimate getcostestimate
{
if  sanitymanager debug
{
if  costestimate    null
{
sanitymanager throwassert
getclass   getname
}
}
return costestimate
}
/**
* get the final costestimate for this resultsetnode.
*
* @return	the final costestimate for this resultsetnode.
*/
public costestimate getfinalcostestimate
throws standardexception
{
if  sanitymanager debug
{
if  finalcostestimate    null
{
sanitymanager throwassert
getclass   getname
}
}
return finalcostestimate
}
/**
* assign the next resultsetnumber to the resultsetnumber in this resultsetnode.
* expected to be done during generate().
*
* @exception standardexception		thrown on error
*/
public void assignresultsetnumber   throws standardexception
{
resultsetnumber   getcompilercontext   getnextresultsetnumber
resultcolumns setresultsetnumber resultsetnumber
}
/**
* bind the non vti tables in this resultsetnode.  this includes getting their
* descriptors from the data dictionary and numbering them.
*
* @param datadictionary	the datadictionary to use for binding
* @param fromlistparam		fromlist to use/append to.
*
* @return	resultsetnode
*
* @exception standardexception		thrown on error
*/
public resultsetnode bindnonvtitables datadictionary datadictionary
fromlist fromlistparam
throws standardexception
return this
}
/**
* bind the vti tables in this resultsetnode.  this includes getting their
* descriptors from the data dictionary and numbering them.
*
* @param fromlistparam		fromlist to use/append to.
*
* @return	resultsetnode
*
* @exception standardexception		thrown on error
*/
public resultsetnode bindvtitables fromlist fromlistparam
throws standardexception
return this
}
/**
* bind the expressions in this resultsetnode.  this means binding the
* sub-expressions, as well as figuring out what the return type is for
* each expression.
*
* @param fromlistparam		fromlist to use/append to.
*
* @exception standardexception		thrown on error
*/
public void bindexpressions fromlist fromlistparam
throws standardexception
{
if  sanitymanager debug
sanitymanager assert false
this getclass   tostring
}
/**
* bind the expressions in this resultsetnode if it has tables.  this means binding the
* sub-expressions, as well as figuring out what the return type is for
* each expression.
*
* @param fromlistparam		fromlist to use/append to.
*
* @exception standardexception		thrown on error
*/
public void bindexpressionswithtables fromlist fromlistparam
throws standardexception
{
if  sanitymanager debug
sanitymanager assert false
this getclass   tostring
}
/**
* bind the expressions in the target list.  this means binding the
* sub-expressions, as well as figuring out what the return type is
* for each expression.  this is useful for exists subqueries, where we
* need to validate the target list before blowing it away and replacing
* it with a select true.
*
* @exception standardexception		thrown on error
*/
public void bindtargetexpressions fromlist fromlistparam
throws standardexception
{
if  sanitymanager debug
sanitymanager assert false
this getclass   tostring
}
/**
* set the type of each parameter in the result column list for this table constructor.
*
* @param typecolumns	the resultcolumnlist containing the desired result
*						types.
*
* @exception standardexception		thrown on error
*/
void settableconstructortypes resultcolumnlist typecolumns
throws standardexception
{
if  sanitymanager debug
sanitymanager assert resultcolumns visiblesize   <  typecolumns size
/* look for ? parameters in the result column list */
int rclsize   resultcolumns size
for  int index   0  index < rclsize  index
{
resultcolumn	rc    resultcolumn  resultcolumns elementat index
valuenode re   rc getexpression
if  re requirestypefromcontext
{
resultcolumn	typecol
resultcolumn  typecolumns elementat index
/*
** we found a ? - set its type to the type of the
** corresponding column of the target table.
*/
re settype typecol gettypeservices
}
else if  re instanceof charconstantnode
{
// character constants are of type char (fixed length string).
// this causes a problem (beetle 5160) when multiple row values are provided
// as constants for insertion into a variable length string column.
//
// this issue is the query expression
// values 'abc', 'defghi'
// has type of char(6), ie. the length of largest row value for that column.
// this is from the union defined behaviour.
// this causes strings with less than the maximum length to be blank padded
// to that length (char semantics). thus if this values clause is used to
// insert into a variable length string column, then these blank padded values
// are inserted, which is not what is required ...
//
// because, when the values is used as a table constructor sql standard says the
// types of the table constructor's columns are set by the table's column types.
// thus, in this case, each of those string constants should be of type varchar
// (or the matching string type for the table).
//
//
// this is only an issue for fixed length character (char, bit) string or
// binary consraints being inserted into variable length types.
// this is because any other type's fundemental literal value is not affected
// by its data type. e.g. numeric types such as int, real, bigint, decimal etc.
// do not have their value modifed by the union since even if the type is promoted
// to a higher type, its fundemental value remains unchanged.
// values (1.2, 34.4567, 234.47) will be promoted to
// values (1.2000, 34.4567, 234.4700)
// but their numeric value remains the same.
//
//
//
// the fix is to change the base type of the table constructor's value to
// match the column type. its length can be left as-is, because there is
// still a normailzation step when the value is inserted into the table.
// that will set the correct length and perform truncation checks etc.
resultcolumn	typecol
resultcolumn  typecolumns elementat index
typeid coltypeid   typecol gettypeid
if  coltypeid isstringtypeid
if  coltypeid getjdbctypeid      java sql types char
int maxwidth   re gettypeservices   getmaximumwidth
re settype new datatypedescriptor coltypeid  true  maxwidth
}
}
else if  coltypeid isbittypeid
if  coltypeid getjdbctypeid      java sql types varbinary
// then we're trying to cast a char literal into a
// variable bit column.  we can't change the base
// type of the table constructor's value from char
// to bit, so instead, we just change the base type
// of that value from char to varchar--that way,
// no padding will be added when we convert to
// bits later on (beetle 5306).
typeid tid   typeid getbuiltintypeid java sql types varchar
re settype new datatypedescriptor tid  true
typecolumns setelementat typecol  index
}
else if  coltypeid getjdbctypeid      java sql types longvarbinary
typeid tid   typeid getbuiltintypeid java sql types longvarchar
re settype new datatypedescriptor tid  true
typecolumns setelementat typecol  index
}
}
}
else if  re instanceof bitconstantnode
{
resultcolumn	typecol
resultcolumn  typecolumns elementat index
typeid coltypeid   typecol gettypeid
if  coltypeid isbittypeid
// note: don't bother doing this if the column type is blob,
// as we don't allow bit literals to be inserted into blob
// columns (they have to be explicitly casted first); beetle 5266.
if   coltypeid getjdbctypeid      java sql types binary
coltypeid getjdbctypeid      java sql types blob
int maxwidth   re gettypeservices   getmaximumwidth
re settype new datatypedescriptor coltypeid  true  maxwidth
}
}
else if  coltypeid isstringtypeid
if  coltypeid getjdbctypeid      java sql types varchar
// then we're trying to cast a bit literal into a
// variable char column.  we can't change the base
// type of the table constructor's value from bit
// to char, so instead, we just change the base
// type of that value from bit to varbit--that way,
// no padding will be added when we convert to
// char later on.
typeid tid   typeid getbuiltintypeid java sql types varbinary
re settype new datatypedescriptor tid  true
typecolumns setelementat typecol  index
}
else if  coltypeid getjdbctypeid      java sql types longvarchar
typeid tid   typeid getbuiltintypeid java sql types longvarbinary
re settype new datatypedescriptor tid  true
typecolumns setelementat typecol  index
}
}
}
}
}
/**
* remember that this node is the source result set for an insert.
*/
public void setinsertsource
{
insertsource   true
}
/**
* verify that a select * is valid for this type of subquery.
*
* @param outerfromlist	the fromlist from the outer query block(s)
* @param subquerytype	the subquery type
*
* @exception standardexception		thrown on error
*/
public void verifyselectstarsubquery fromlist outerfromlist  int subquerytype
throws standardexception
{
if  sanitymanager debug
sanitymanager assert false
this getclass   tostring
}
/**
* expand "*" into a resultcolumnlist with all of the columns
* in the table's result list.
*
* @param alltablename		the qualifier on the "*"
*
* @return resultcolumnlist the expanded list
*
* @exception standardexception		thrown on error
*/
public resultcolumnlist getallresultcolumns tablename alltablename
throws standardexception
{
if  sanitymanager debug
sanitymanager throwassert
this getclass   getname     this
return null
}
/**
* try to find a resultcolumn in the table represented by this fromtable
* that matches the name in the given columnreference.
*
* @param columnreference	the columnreference whose name we're looking
*				for in the given table.
*
* @return	a resultcolumn whose expression is the columnnode
*			that matches the columnreference.
*		returns null if there is no match.
*
* @exception standardexception		thrown on error
*/
public resultcolumn getmatchingcolumn
columnreference columnreference
throws standardexception
{
if  sanitymanager debug
sanitymanager throwassert
this
return null
}
/**
* set the result column for the subquery to a boolean true,
* useful for transformations such as
* changing:
*		where exists (select ... from ...)
* to:
*		where (select true from ...)
*
* note: no transformation is performed if the resultcolumn.expression is
* already the correct boolean constant.
*
* @param onlyconvertalls	boolean, whether or not to just convert *'s
* @return resultsetnode whose resultcolumn was transformed; defaults
*  to "this" here, but can be overridden by subclasses.
*
* @exception standardexception		thrown on error
*/
public resultsetnode setresulttobooleantruenode boolean onlyconvertalls
throws standardexception
{
booleanconstantnode	booleannode
resultcolumn		resultcolumn
/* we need to be able to handle both resultcolumn and allresultcolumn
* since they are peers.
*/
if  resultcolumns elementat 0  instanceof allresultcolumn
{
resultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column

getcontextmanager
}
else if  onlyconvertalls
{
return this
}
else
{
resultcolumn    resultcolumn  resultcolumns elementat 0
/* nothing to do if query is already select true ... */
if  resultcolumn getexpression   isbooleantrue
{
return this
}
}
booleannode    booleanconstantnode  getnodefactory   getnode
c_nodetypes boolean_constant_node
boolean true
getcontextmanager
resultcolumn setexpression booleannode
resultcolumn settype booleannode gettypeservices
/* virtualcolumnids are 1-based, rcls are 0-based */
resultcolumn setvirtualcolumnid 1
resultcolumns setelementat resultcolumn  0
return this
}
/**
* get the fromlist.  create and return an empty fromlist.  (subclasses
* which actuall have fromlists will override this.)  this is useful because
* there is a fromlist parameter to bindexpressions() which is used as
* the common fromlist to bind against, allowing us to support
* correlation columns under unions in subqueries.
*
* @return fromlist
* @exception standardexception		thrown on error
*/
public fromlist getfromlist
throws standardexception
{
return  fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
}
/**
* @see querytreenode#disableprivilegecollection
*/
public void disableprivilegecollection
{
super disableprivilegecollection
if  resultcolumns    null
resultcolumns disableprivilegecollection
}
/**
* bind the result columns of this resultsetnode when there is no
* base table to bind them to.  this is useful for select statements,
* where the result columns get their types from the expressions that
* live under them.
*
* @param fromlistparam		fromlist to use/append to.
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumns fromlist fromlistparam
throws standardexception
{
resultcolumns bindresultcolumnstoexpressions
}
/**
* bind the result columns for this resultsetnode to a base table.
* this is useful for insert and update statements, where the
* result columns get their types from the table being updated or
* inserted into.
* if a result column list is specified, then the verification that the
* result column list does not contain any duplicates will be done when
* binding them by name.
*
* @param targettabledescriptor	the tabledescriptor for the table being
*				updated or inserted into
* @param targetcolumnlist	for insert statements, the user
*					does not have to supply column
*					names (for example, "insert into t
*					values (1,2,3)".  when this
*					parameter is null, it means that
*					the user did not supply column
*					names, and so the binding should
*					be done based on order.  when it
*					is not null, it means do the binding
*					by name, not position.
* @param statement			calling dmlstatementnode (insert or update)
* @param fromlistparam		fromlist to use/append to.
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumns tabledescriptor targettabledescriptor
fromvti targetvti
resultcolumnlist targetcolumnlist
dmlstatementnode statement
fromlist fromlistparam
throws standardexception
{
/* for insert select, we need to expand any *'s in the
* select before binding the result columns
*/
if  this instanceof selectnode
{
resultcolumns expandallsandnamecolumns   selectnode this  fromlist
}
/* if specified, copy the result column names down to the
* source's target list.
*/
if  targetcolumnlist    null
{
resultcolumns copyresultcolumnnames targetcolumnlist
}
if  targetcolumnlist    null
{
if  targettabledescriptor    null
{
resultcolumns bindresultcolumnsbyname
targettabledescriptor   dmlstatementnode statement
}
else
{
resultcolumns bindresultcolumnsbyname
targetvti getresultcolumns    targetvti  statement
}
}
else
resultcolumns bindresultcolumnsbyposition targettabledescriptor
}
/**
* bind untyped nulls to the types in the given resultcolumnlist.
* this is used for binding the nulls in row constructors and
* table constructors.  in all other cases (as of the time of
* this writing), we do nothing.
*
* @param rcl	the resultcolumnlist with the types to bind nulls to
*
* @exception standardexception		thrown on error
*/
public void binduntypednullstoresultcolumns resultcolumnlist rcl
throws standardexception
{
return
}
/**
* preprocess a resultsetnode - this currently means:
*	o  generating a referenced table map for each resultsetnode.
*  o  putting the where and having clauses in conjunctive normal form (cnf).
*  o  converting the where and having clauses into predicatelists and
*	   classifying them.
*  o  ensuring that a projectrestrictnode is generated on top of every
*     frombasetable and generated in place of every fromsubquery.
*  o  pushing single table predicates down to the new projectrestrictnodes.
*
* @param numtables			the number of tables in the dml statement
* @param gbl				the group by list, if any
* @param fromlist			the from list, if any
*
* @return resultsetnode at top of preprocessed tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode preprocess int numtables
groupbylist gbl
fromlist fromlist
throws standardexception
{
if  sanitymanager debug
sanitymanager throwassert
getclass   tostring
return null
}
/**
* find the unreferenced result columns and project them out.
*/
void projectresultcolumns   throws standardexception
{
// it is only necessary for joins
}
/**
* ensure that the top of the rsn tree has a predicatelist.
*
* @param numtables			the number of tables in the query.
* @return resultsetnode	a rsn tree with a node which has a predicatelist on top.
*
* @exception standardexception		thrown on error
*/
public resultsetnode ensurepredicatelist int numtables
throws standardexception
{
if  sanitymanager debug
sanitymanager throwassert
getclass   tostring
return null
}
/**
* add a new predicate to the list.  this is useful when doing subquery
* transformations, when we build a new predicate with the left side of
* the subquery operator and the subquery's result column.
*
* @param predicate		the predicate to add
*
* @return resultsetnode	the new top of the tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode addnewpredicate predicate predicate
throws standardexception
{
if  sanitymanager debug
sanitymanager throwassert
getclass   tostring
return null
}
/**
* evaluate whether or not the subquery in a fromsubquery is flattenable.
* currently, a fsqry is flattenable if all of the following are true:
*		o  subquery is a selectnode. (ie, not a rowresultsetnode or a unionnode)
*		o  it contains no top level subqueries.  (resolve - we can relax this)
*		o  it does not contain a group by or having clause
*		o  it does not contain aggregates.
*
* @param fromlist	the outer from list
*
* @return boolean	whether or not the fromsubquery is flattenable.
*/
public boolean flattenableinfromsubquery fromlist fromlist
{
if  sanitymanager debug
sanitymanager throwassert
getclass   tostring
return false
}
/**
* get a parent projectrestrictnode above us.
* this is useful when we need to preserve the
* user specified column order when reordering the
* columns in the distinct when we combine
* an order by with a distinct.
*
* @return a parent projectrestrictnode to do column reordering
*
* @exception standardexception		thrown on error
*/
resultsetnode genprojectrestrictforreordering
throws standardexception
{
resultcolumnlist	prrclist
/* we get a shallow copy of the resultcolumnlist and its
* resultcolumns.  (copy maintains resultcolumn.expression for now.)
*/
prrclist   resultcolumns
resultcolumns   resultcolumns copylistandobjects
/* replace resultcolumn.expression with new virtualcolumnnodes
* in the projectrestrictnode's resultcolumnlist.  (virtualcolumnnodes include
* pointers to source resultsetnode, this, and source resultcolumn.)
* note: we don't want to mark the underlying rcs as referenced, otherwise
* we won't be able to project out any of them.
*/
prrclist genvirtualcolumnnodes this  resultcolumns  false
/* finally, we create the new projectrestrictnode */
return  resultsetnode  getnodefactory   getnode
c_nodetypes project_restrict_node
this
prrclist
null 	   restriction
null       restriction as predicatelist
null 	   project subquery list
null 	   restrict subquery list

getcontextmanager
}
/**
* optimize a resultsetnode. this means choosing the best access
* path for each table under the resultsetnode, among other things.
*
* the only rsns that need to implement their own optimize() are a
* selectnode and those rsns that can appear above a selectnode in the
* query tree.  currently, a projectrestrictnode is the only rsn that
* can appear above a selectnode.
*
* @param datadictionary	the datadictionary to use for optimization
* @param predicates		the predicatelist to apply.
* @param outerrows			the number of outer joining rows
*
* @return	resultsetnode	the top of the optimized query tree
*
* @exception standardexception		thrown on error
*/
public resultsetnode optimize datadictionary datadictionary
predicatelist predicates
double outerrows
throws standardexception
{
if  sanitymanager debug
sanitymanager assert false
this getclass   tostring
return null
}
/**
* modify the access paths according to the decisions the optimizer
* made.  this can include adding project/restrict nodes,
* index-to-base-row nodes, etc.
*
* @return	the modified query tree
*
* @exception standardexception		thrown on error
*/
public resultsetnode modifyaccesspaths   throws standardexception
{
/* default behavior is to do nothing */
return this
}
/**
* modify the access paths according to the decisions the optimizer
* made.  this can include adding project/restrict nodes,
* index-to-base-row nodes, etc.
*
* @param predlist a list of optimizable predicates that should
*  be pushed to this resultsetnode, as determined by optimizer.
* @return the modified query tree
* @exception standardexception        thrown on error
*/
public resultsetnode modifyaccesspaths predicatelist predlist
throws standardexception
{
// default behavior is to call the no-arg version of this method.
return modifyaccesspaths
}
resultcolumndescriptor makeresultdescriptors
{
return resultcolumns makeresultdescriptors
}
/*
** check whether the column lengths and types of the result columns
** match the expressions under those columns.  this is useful for
** insert and update statements.  for select statements this method
** should always return true.  there is no need to call this for a
** delete statement.
**
** @return	true means all the columns match their expressions,
**		false means at least one column does not match its
**		expression
*/
boolean columntypesandlengthsmatch
throws standardexception
{
return resultcolumns columntypesandlengthsmatch
}
/**
* set the resultcolumns in this resultsetnode
*
* @param newrcl		the new resultcolumnlist for this resultsetnode
*/
public void setresultcolumns resultcolumnlist newrcl
{
resultcolumns   newrcl
}
/**
* get the resultcolumns for this resultsetnode
*
* @return resultcolumnlist for this resultsetnode
*/
public resultcolumnlist getresultcolumns
{
return resultcolumns
}
/**
* set the referencedtablemap in this resultsetnode
*
* @param newrtm	the new referencedtablemap for this resultsetnode
*/
public void setreferencedtablemap jbitset newrtm
{
referencedtablemap   newrtm
}
/**
* get the referencedtablemap for this resultsetnode
*
* @return jbitset	referenced table map for this resultsetnode
*/
public jbitset getreferencedtablemap
{
return referencedtablemap
}
/**
* fill the referencedtablemap with this resultsetnode.
*
* @param passedmap	the table map to fill in.
*/
public void fillinreferencedtablemap jbitset passedmap
{
}
/**
* check for (and reject) ? parameters directly under the resultcolumns.
* this is done for select statements.
*
* @exception standardexception		thrown if a ? parameter found
*									directly under a resultcolumn
*/
public void rejectparameters   throws standardexception
{
/* okay if no resultcolumns yet - means no parameters there */
if  resultcolumns    null
{
resultcolumns rejectparameters
}
}
/**
* check for (and reject) xml values directly under the resultcolumns.
* this is done for select/values statements.  we reject values
* in this case because jdbc does not define an xml type/binding
* and thus there's no standard way to pass such a type back
* to a jdbc application.
*
* @exception standardexception		thrown if an xml value found
*									directly under a resultcolumn
*/
public void rejectxmlvalues   throws standardexception
{
if  resultcolumns    null
{
resultcolumns rejectxmlvalues
}
}
/**
* rename generated result column names as '1', '2' etc... these will be the result
* column names seen by jdbc clients.
*/
public void renamegeneratedresultnames   throws standardexception
{
for  int i 0  i<resultcolumns size    i
{
resultcolumn rc    resultcolumn  resultcolumns elementat i
if  rc isnamegenerated
rc setname integer tostring i 1
}
}
/**
this method is overridden to allow a resultset node to know
if it is the one controlling the statement -- i.e., it is
the outermost result set node for the statement.
*/
public void markstatementresultset
{
statementresultset   true
}
/**
* this resultset is the source for an insert.  the target rcl
* is in a different order and/or a superset of this rcl.  in most cases
* we will reorder and/or add defaults to the current rcl so that is
* matches the target rcl.
* note - the new or enhanced rcl will be fully bound.
*
* @param numtargetcolumns	# of columns in target rcl
* @param colmap			int array representation of correspondence between
*							rcls - colmap[i] = -1 -> missing in current rcl
*								   colmap[i] = j -> targetrcl(i) <-> thisrcl(j+1)
* @param datadictionary	datadictionary to use
* @param targettd			tabledescriptor for target if the target is not a vti, null if a vti
* @param targetvti         target description if it is a vti, null if not a vti
*
* @exception standardexception		thrown on error
*/
public void enhancerclforinsert int numtargetcolumns  int colmap
datadictionary datadictionary
tabledescriptor targettd
fromvti targetvti
throws standardexception
{
// our newresultcols are put into the bound form straight away.
resultcolumnlist newresultcols
resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
/* create a massaged version of the source rcl.
* (much simpler to build new list and then assign to source,
* rather than massage the source list in place.)
*/
for  int index   0  index < numtargetcolumns  index
{
resultcolumn	newresultcolumn   null
columnreference newcolumnreference
if  colmap     1
{
// getresultcolumn uses 1-based positioning, so offset the colmap entry appropriately
newresultcolumn   resultcolumns getresultcolumn colmap 1
}
else
{
newresultcolumn   gennewrcforinsert targettd  targetvti  index   1  datadictionary
}
newresultcols addresultcolumn newresultcolumn
}
/* set the source rcl to the massaged version */
resultcolumns   newresultcols
}
/**
* generate the rc/expression for an unspecified column in an insert.
* use the default if one exists.
*
* @param targettd			target tabledescriptor if the target is not a vti, null if a vti.
* @param targetvti         target description if it is a vti, null if not a vti
* @param columnnumber		the column number
* @param datadictionary	the datadictionary
* @return	the rc/expression for the unspecified column.
*
* @exception standardexception		thrown on error
*/
resultcolumn gennewrcforinsert tabledescriptor targettd
fromvti targetvti
int columnnumber
datadictionary datadictionary
throws standardexception
{
resultcolumn newresultcolumn   null
// the i-th column's value was not specified, so create an
// expression containing its default value (null for now)
// revisit: will we store trailing nulls?
if  targetvti    null
{
newresultcolumn   targetvti getresultcolumns   getresultcolumn  columnnumber
newresultcolumn   newresultcolumn cloneme
newresultcolumn setexpressiontonullnode
}
else
{
// column position is 1-based, index is 0-based.
columndescriptor coldesc   targettd getcolumndescriptor columnnumber
datatypedescriptor coltype   coldesc gettype
// check for defaults
defaultinfoimpl defaultinfo    defaultinfoimpl  coldesc getdefaultinfo
//column has constant default value ,
//if it have defaultinfo and not be autoincrement.
if  defaultinfo    null      coldesc isautoincrement
{
//resolveparameter - skip the tree if we have the value
/*
if (defaultinfo.getdefaultvalue() != null)
{
}
else
*/
{
// generate the tree for the default
string defaulttext   defaultinfo getdefaulttext
valuenode defaulttree   parsedefault defaulttext
defaulttree   defaulttree bindexpression
getfromlist
subquerylist  null
vector  null
newresultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
defaulttree gettypeservices
defaulttree
getcontextmanager
defaultdescriptor defaultdescriptor   coldesc getdefaultdescriptor datadictionary
if  sanitymanager debug
{
sanitymanager assert defaultdescriptor    null
}
getcompilercontext   createdependency defaultdescriptor
}
}
else if  coldesc isautoincrement
{
newresultcolumn
resultcolumn getnodefactory   getnode
c_nodetypes result_column
coldesc  null
getcontextmanager
newresultcolumn setautoincrementgenerated
}
else
{
newresultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
coltype
getnullnode
coltype gettypeid
getcontextmanager
coltype getcollationtype
coltype getcollationderivation
getcontextmanager
}
}
// mark the new rc as generated for an unmatched column in an insert
newresultcolumn markgeneratedforunmatchedcolumnininsert
return newresultcolumn
}
/**
*	parse a default and turn it into a query tree.
*
*	@param	defaulttext			text of default.
*
* @return	the parsed default as a query tree.
*
* @exception standardexception		thrown on failure
*/
public	valuenode	parsedefault
string				defaulttext
throws standardexception
{
parser						p
valuenode					defaulttree
languageconnectioncontext	lcc   getlanguageconnectioncontext
compilercontext 			compilercontext   getcompilercontext
/* get a statement to pass to the parser */
/* we're all set up to parse. we have to build a compilable sql statement
* before we can parse -  so, we goober up a values defaulttext.
*/
string values       defaulttext
/*
** get a new compiler context, so the parsing of the select statement
** doesn't mess up anything in the current context (it could clobber
** the parametervalueset, for example).
*/
compilercontext newcc   lcc pushcompilercontext
p   newcc getparser
/* finally, we can call the parser */
// since this is always nested inside another sql statement, so toplevel flag
// should be false
statementnode qt   p parsestatement values
if  sanitymanager debug
{
if     qt instanceof cursornode
{
sanitymanager throwassert
qt getclass   getname
}
cursornode cn    cursornode  qt
if     cn getresultsetnode   instanceof rowresultsetnode
{
sanitymanager throwassert
cn getresultsetnode   getclass   getname
}
}
defaulttree     resultcolumn
cursornode  qt  getresultsetnode   getresultcolumns   elementat 0
getexpression
lcc popcompilercontext newcc
return	defaulttree
}
/**
* make a resultdescription for use in a resultset.
* this is useful when generating/executing a normalizeresultset, since
* it can appear anywhere in the tree.
*
* @return	a resultdescription for this resultsetnode.
*/
public resultdescription makeresultdescription
{
resultcolumndescriptor coldescs   makeresultdescriptors
return getexecutionfactory   getresultdescription coldescs  null
}
/**
determine if this result set is updatable or not, for a cursor
(i.e., is it a cursor-updatable select).  this returns false
and we expect selectnode to refine it for further checking.
*
* @exception standardexception		thrown on error
*/
boolean isupdatablecursor datadictionary dd  throws standardexception
{
if  sanitymanager debug
sanitymanager debug
return false
}
/**
return the target table of an updatable cursor result set.
since this is not updatable, just return null.
*/
fromtable getcursortargettable
{
return null
}
/**
mark this resultsetnode as the target table of an updatable
cursor.  most types of resultsetnode can't be target tables.
@return true if the target table supports positioned updates.
*/
public boolean markascursortargettable
{
return false
}
/**
mark this resultsetnode as *not* the target table of an updatable
cursor.
*/
void notcursortargettable
{
cursortargettable   false
}
/**
* put a projectrestrictnode on top of this resultsetnode.
* columnreferences must continue to point to the same resultcolumn, so
* that resultcolumn must percolate up to the new prn.  however,
* that resultcolumn will point to a new expression, a virtualcolumnnode,
* which points to the fromtable and the resultcolumn that is the source for
* the columnreference.
* (the new prn will have the original of the resultcolumnlist and
* the resultcolumns from that list.  the fromtable will get shallow copies
* of the resultcolumnlist and its resultcolumns.  resultcolumn.expression
* will remain at the fromtable, with the prn getting a new
* virtualcolumnnode for each resultcolumn.expression.)
*
* this is useful for unions, where we want to generate a distinctnode above
* the unionnode to eliminate the duplicates, because distinctnodes expect
* their immediate child to be a prn.
*
* @return the generated projectrestrictnode atop the original resultsetnode.
*
* @exception standardexception		thrown on error
*/
public resultsetnode genprojectrestrict
throws standardexception
{
resultcolumnlist	prrclist
/* we get a shallow copy of the resultcolumnlist and its
* resultcolumns.  (copy maintains resultcolumn.expression for now.)
*/
prrclist   resultcolumns
resultcolumns   resultcolumns copylistandobjects
/* replace resultcolumn.expression with new virtualcolumnnodes
* in the projectrestrictnode's resultcolumnlist.  (virtualcolumnnodes include
* pointers to source resultsetnode, this, and source resultcolumn.)
*/
prrclist genvirtualcolumnnodes this  resultcolumns
/* finally, we create the new projectrestrictnode */
return  resultsetnode  getnodefactory   getnode
c_nodetypes project_restrict_node
this
prrclist
null 	   restriction
null       restriction as predicatelist
null 	   project subquery list
null 	   restrict subquery list

getcontextmanager
}
/**
* put a projectrestrictnode on top of each fromtable in the fromlist.
* columnreferences must continue to point to the same resultcolumn, so
* that resultcolumn must percolate up to the new prn.  however,
* that resultcolumn will point to a new expression, a virtualcolumnnode,
* which points to the fromtable and the resultcolumn that is the source for
* the columnreference.
* (the new prn will have the original of the resultcolumnlist and
* the resultcolumns from that list.  the fromtable will get shallow copies
* of the resultcolumnlist and its resultcolumns.  resultcolumn.expression
* will remain at the fromtable, with the prn getting a new
* virtualcolumnnode for each resultcolumn.expression.)
* we then project out the non-referenced columns.  if there are no referenced
* columns, then the prn's resultcolumnlist will consist of a single resultcolumn
* whose expression is 1.
*
* @param numtables			number of tables in the dml statement
*
* @return the generated projectrestrictnode atop the original fromtable.
*
* @exception standardexception		thrown on error
*/
protected resultsetnode genprojectrestrict int numtables
throws standardexception
{
return genprojectrestrict
}
/**
* put a normalizeresultsetnode on top of the specified resultsetnode.
* columnreferences must continue to point to the same resultcolumn, so
* that resultcolumn must percolate up to the new prn.  however,
* that resultcolumn will point to a new expression, a virtualcolumnnode,
* which points to the fromtable and the resultcolumn that is the source for
* the columnreference.
* (the new nrsn will have the original of the resultcolumnlist and
* the resultcolumns from that list.  the fromtable will get shallow copies
* of the resultcolumnlist and its resultcolumns.  resultcolumn.expression
* will remain at the fromtable, with the prn getting a new
* virtualcolumnnode for each resultcolumn.expression.)
*
* this is useful for unions, where we want to generate a distinctnode above
* the unionnode to eliminate the duplicates, because the type going into the
* sort has to agree with what the sort expects.
* (insert into t1 (smallintcol) values 1 union all values 2;
*
* @param normalizechild	child result set for new nrsn.
* @param forupdate			if the normalize result set is being used as a
* child for an update statement, then this is true.
*
* @return the generated normalizeresultsetnode atop the original unionnode.
*
* @exception standardexception		thrown on error
* @see normalizeresultsetnode#init
*/
public normalizeresultsetnode
gennormalizeresultsetnode resultsetnode	normalizechild
boolean forupdate
throws standardexception
{
normalizeresultsetnode	nrsn
resultcolumnlist		prrclist
/* we get a shallow copy of the resultcolumnlist and its
* resultcolumns.  (copy maintains resultcolumn.expression for now.)
*/
prrclist   resultcolumns
resultcolumns   resultcolumns copylistandobjects
// remove any columns that were generated.
prrclist removegeneratedgroupingcolumns
/* replace resultcolumn.expression with new virtualcolumnnodes
* in the normalizeresultsetnode's resultcolumnlist.  (virtualcolumnnodes include
* pointers to source resultsetnode, this, and source resultcolumn.)
*/
prrclist genvirtualcolumnnodes this  resultcolumns
/* finally, we create the new normalizeresultsetnode */
nrsn    normalizeresultsetnode  getnodefactory   getnode
c_nodetypes normalize_result_set_node
normalizechild
prrclist
null  new boolean forupdate
getcontextmanager
// propagate the referenced table map if it's already been created
if  normalizechild getreferencedtablemap      null
{
nrsn setreferencedtablemap  jbitset  normalizechild getreferencedtablemap   clone
}
return nrsn
}
/**
* generate the code for a normalizeresultset.
the call must push two items before calling this method
<ol>
<li> pushgetresultsetfactoryexpression
<li> the expression to normalize
</ol>
*
* @param acb				the activationclassbuilder
* @param mb				the method to put the generated code in
* @param resultsetnumber	the result set number for the nrs
* @param resultdescription	the erd for the resultset
*
*
* @exception standardexception		thrown on error
*/
public void generatenormalizationresultset
activationclassbuilder acb
methodbuilder mb
int resultsetnumber
resultdescription resultdescription
throws standardexception
{
int erdnumber   acb additem resultdescription
// instance and first arg are pushed by caller
mb push resultsetnumber
mb push erdnumber
mb push getcostestimate   rowcount
mb push getcostestimate   getestimatedcost
mb push false
mb callmethod vmopcode invokeinterface   string  null
classname noputresultset  6
}
/**
* the optimizer's decision on the access path for a result set
* may require the generation of extra result sets.  for example,
* if it chooses an index for a frombasetable, we need an indextobaserownode
* above the frombasetable (and the frombasetable has to change its
* column list to match the index.
*
* this method in the parent class does not generate any extra result sets.
* it may be overridden in child classes.
*
* @return	a resultsetnode tree modified to do any extra processing for
*			the chosen access path
*
* @exception standardexception		thrown on error
*/
public resultsetnode changeaccesspath   throws standardexception
{
return this
}
/**
* search to see if a query references the specifed table name.
*
* @param name		table name (string) to search for.
* @param basetable	whether or not name is for a base table
*
* @return	true if found, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencestarget string name  boolean basetable
throws standardexception
{
return false
}
/**
* return whether or not this resultsetnode contains a subquery with a
* reference to the specified target.
*
* @param name	the table name.
*
* @return boolean	whether or not a reference to the table was found.
*
* @exception standardexception		thrown on error
*/
boolean subqueryreferencestarget string name  boolean basetable
throws standardexception
{
return false
}
/**
* return whether or not the underlying resultset tree will return
* a single row, at most.
* this is important for join nodes where we can save the extra next
* on the right side if we know that it will return at most 1 row.
*
* @return whether or not the underlying resultset tree will return a single row.
* @exception standardexception		thrown on error
*/
public boolean isonerowresultset  	throws standardexception
{
// default is false
return false
}
/**
* return whether or not the underlying resultset tree is for a not exists
* join.
*
* @return whether or not the underlying resultset tree if for not exists.
*/
public boolean isnotexists
{
// default is false
return false
}
/**
* get an optimizer to use for this resultsetnode.  only get it once -
* subsequent calls return the same optimizer.
*
* @exception standardexception		thrown on error
*/
protected optimizer getoptimizer
optimizablelist optlist
optimizablepredicatelist predlist
datadictionary datadictionary
requiredrowordering requiredrowordering
throws standardexception
{
if  optimizer    null
{
/* get an optimizer. */
optimizerfactory optimizerfactory   getlanguageconnectioncontext   getoptimizerfactory
optimizer   optimizerfactory getoptimizer
optlist
predlist
datadictionary
requiredrowordering
getcompilercontext   getnumtables
getlanguageconnectioncontext
}
optimizer prepfornextround
return optimizer
}
/**
* get the optimizer for this result set.
*
* @return if this.optimizer has has already been created by the
*  getoptimizer() method above, then return it; otherwise,
*  return null.
*/
protected optimizerimpl getoptimizerimpl
{
// note that the optimizer might be null because it's possible that
// we'll get here before any calls to getoptimizer() were made, which
// can happen if we're trying to save a "best path" but we haven't
// actually found one yet.  in that case we just return the "null"
// value; the caller must check for it and behave appropriately.
// ex. see tableoperatornode.addorloadbestplanmapping().
return  optimizerimpl optimizer
}
/**
* get a cost estimate to use for this resultsetnode.
*
* @exception standardexception		thrown on error
*/
protected costestimate getnewcostestimate
throws standardexception
{
optimizerfactory optimizerfactory   getlanguageconnectioncontext   getoptimizerfactory
return optimizerfactory getcostestimate
}
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
{
visitable returnnode   v visit this
if  v skipchildren this
{
return returnnode
}
if  resultcolumns    null     v stoptraversal
{
resultcolumns    resultcolumnlist resultcolumns accept v
}
return returnnode
}
/**
* consider materialization for this resultset tree if it is valid and cost effective
* (it is not valid if incorrect results would be returned.)
*
* @return top of the new/same resultset tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode considermaterialization jbitset outertables
throws standardexception
{
return this
}
/**
* return whether or not to materialize this resultset tree.
*
* @return whether or not to materialize this resultset tree.
*			would return valid results.
*
* @exception standardexception		thrown on error
*/
public boolean performmaterialization jbitset outertables
throws standardexception
{
return false
}
/**
* determine whether or not the specified name is an exposed name in
* the current query block.
*
* @param name	the specified name to search for as an exposed name.
* @param schemaname	schema name, if non-null.
* @param exactmatch	whether or not we need an exact match on specified schema and table
*						names or match on table id.
*
* @return the fromtable, if any, with the exposed name.
*
* @exception standardexception		thrown on error
*/
protected fromtable getfromtablebyname string name  string schemaname  boolean exactmatch
throws standardexception
{
if  sanitymanager debug
{
sanitymanager throwassert
getclass   getname
}
return null
}
/**
* decrement (query block) level (0-based) for
* all of the tables in this resultset tree.
* this is useful when flattening a subquery.
*
* @param decrement	the amount to decrement by.
*/
abstract void decrementlevel int decrement
/**
* push the order by list down from the cursor node
* into its child result set so that the optimizer
* has all of the information that it needs to
* consider sort avoidance.
*
* @param orderbylist	the order by list
*/
void pushorderbylist orderbylist orderbylist
{
if  sanitymanager debug
{
sanitymanager throwassert
getclass   getname
}
}
/**
* general logic shared by core compilation and by the replication filter
* compiler. a couple resultsets (the ones used by prepare select filter)
* implement this method.
*
* @param acb	the expressionclassbuilder for the class being built
* @param mb	the method the expression will go into
*
*
* @exception standardexception		thrown on error
*/
public void generateresultset expressionclassbuilder acb
methodbuilder mb
throws standardexception
{
system out println     getclass
if  sanitymanager debug
sanitymanager notreached
return
}
/**
* get the lock mode for the target of an update statement
* (a delete or update).  the update mode will always be row for
* currentofnodes.  it will be table if there is no where clause.
*
* @see transactioncontroller
*
* @return	the lock mode
*/
public int updatetargetlockmode
{
return transactioncontroller mode_table
}
/**
* mark this node and its children as not being a flattenable join.
*/
void notflattenablejoin
{
}
/**
* return whether or not the underlying resultset tree
* is ordered on the specified columns.
* resolve - this method currently only considers the outermost table
* of the query block.
*
* @param	crs					the specified columnreference[]
* @param	permuteordering		whether or not the order of the crs in the array can be permuted
* @param	fbtvector			vector that is to be filled with the frombasetable
*
* @return	whether the underlying resultset tree
* is ordered on the specified column.
*
* @exception standardexception		thrown on error
*/
boolean isorderedon columnreference crs  boolean permuteordering  vector fbtvector
throws standardexception
{
return false
}
/**
* return whether or not this resultset tree is guaranteed to return
* at most 1 row based on heuristics.  (a rowresultsetnode and a
* select with a non-grouped aggregate will return at most 1 row.)
*
* @return whether or not this resultset tree is guaranteed to return
* at most 1 row based on heuristics.
*/
boolean returnsatmostonerow
{
return false
}
/**
* replace any defaults with the associated tree for the default.
*
* @param ttd	the tabledescriptor for the target table.
* @param tcl	the rcl for the target table.
*
* @exception standardexception		thrown on error
*/
void replacedefaults tabledescriptor ttd  resultcolumnlist tcl
throws standardexception
{
// only subclasses with something to do override this.
}
/**
* is it possible to do a distinct scan on this resultset tree.
* (see selectnode for the criteria.)
*
* @param distinctcolumns the set of distinct columns
* @return whether or not it is possible to do a distinct scan on this resultset tree.
*/
boolean ispossibledistinctscan set distinctcolumns
{
return false
}
/**
* mark the underlying scan as a distinct scan.
*/
void markfordistinctscan
{
if  sanitymanager debug
{
sanitymanager throwassert
getclass   getname
}
}
/**
* notify the underlying result set tree that the optimizer has chosen
* to "eliminate" a sort.  sort elimination can happen as part of
* preprocessing (see esp. selectnode.preprocess(...)) or it can happen
* if the optimizer chooses an access path that inherently returns the
* rows in the correct order (also known as a "sort avoidance" plan).
* in either case we drop the sort and rely on the underlying result set
* tree to return its rows in the correct order.
*
* for most types of resultsetnodes we automatically get the rows in the
* correct order if the sort was eliminated. one exception to this rule,
* though, is the case of an indexrowtobaserownode, for which we have
* to disable bulk fetching on the underlying base table.  otherwise
* the index scan could return rows out of order if the base table is
* updated while the scan is "in progress" (i.e. while the result set
* is open).
*
* in order to account for this (and potentially other, similar issues
* in the future) this method exists to notify the result set node that
* it is expected to return rows in the correct order.  the result set
* can then take necessary action to satsify this requirement--such as
* disabling bulk fetch in the case of indexrowtobaserownode.
*
* all of that said, any resultsetnodes for which we could potentially
* eliminate sorts should override this method accordingly.  so we don't
* ever expect to get here.
*/
void adjustforsortelimination
{
if  sanitymanager debug
{
sanitymanager throwassert
getclass   getname
}
}
/**
* count the number of distinct aggregates in the list.
* by 'distinct' we mean aggregates of the form:
*	<ul><i>select max(distinct x) from t<\i><\ul>
*
* @return number of aggregates
*/
protected static final int numdistinctaggregates vector aggregatevector
{
int		count   0
int		size   aggregatevector size
for  int index   0  index < size  index
{
count       aggregatenode  aggregatevector elementat index   isdistinct      true  ?
1   0
}
return count
}
// it may be we have a select view underneath a loj.
// return null for now.. we don't do any optimization.
public jbitset lojgetreferencedtables int numtables
throws standardexception
{
if  this instanceof fromtable
{
if    fromtable this  tablenumber     1
{
jbitset map   new jbitset numtables
map set   fromtable this  tablenumber
return map
}
}
return null
}
}