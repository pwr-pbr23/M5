/*
derby - class org.apache.derby.impl.sql.compile.optimizerimpl
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql compile
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile joinstrategy
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile optimizablelist
import org apache derby iapi sql compile optimizablepredicate
import org apache derby iapi sql compile optimizablepredicatelist
import org apache derby iapi sql compile optimizer
import org apache derby iapi sql compile costestimate
import org apache derby iapi sql compile requiredrowordering
import org apache derby iapi sql compile rowordering
import org apache derby iapi sql compile accesspath
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby catalog indexdescriptor
import org apache derby iapi reference sqlstate
import org apache derby iapi util jbitset
import org apache derby iapi util stringutil
import java util properties
import java util hashmap
/**
* this will be the level 1 optimizer.
* resolve - it's a level 0 optimizer right now.
* current state:
*	o  no costing services
*	o  we can only cost a derived table with a join once.
*
* optimizer uses optimizablelist to keep track of the best join order as it
* builds it.  for each available slot in the join order, we cost all of the
* optimizables from that slot til the end of the optimizablelist.  later,
* we will choose the best optimizable for that slot and reorder the list
* accordingly.
* in order to do this, we probably need to move the temporary pushing and
* pulling of join clauses into optimizer, since the logic will be different
* for other implementations.  (of course, we're not pushing and pulling join
* clauses between permutations yet.)
*/
public class optimizerimpl implements optimizer
datadictionary			 ddictionary
/* the number of tables in the query as a whole.  (size of bit maps.) */
int						 numtablesinquery
/* the number of optimizables in the list to optimize */
int						 numoptimizables
/* bit map of tables that have already been assigned to slots.
* useful for pushing join clauses as slots are assigned.
*/
protected jbitset		 assignedtablemap
protected optimizablelist optimizablelist
optimizablepredicatelist predicatelist
jbitset					 noncorrelatedtablemap
protected int			 proposedjoinorder
protected int					 bestjoinorder
protected int			 joinposition
boolean					 desiredjoinorderfound
/* this implements a state machine to jump start to a appearingly good join
* order, when the number of tables is high, and the optimization could take
* a long time.  a good start can prune better, and timeout sooner.  otherwise,
* it may take forever to exhaust or timeout (see beetle 5870).  basically after
* we jump, we walk the high part, then fall when we reach the peak, finally we
* walk the low part til where we jumped to.
*/
private static final int no_jump   0
private static final int ready_to_jump   1
private static final int jumping   2
private static final int walk_high   3
private static final int walk_low   4
private int				 permutestate
private int			 firstlookorder
private boolean			 rulebasedoptimization
private costestimateimpl outermostcostestimate
protected costestimateimpl currentcost
protected costestimateimpl currentsortavoidancecost
protected costestimateimpl bestcost
protected long			 timeoptimizationstarted
protected long			 currenttime
protected boolean		 timeexceeded
private boolean			 notimeout
private boolean 		 usestatistics
private int				 tablelockthreshold
private joinstrategy	joinstrategies
protected requiredrowordering	requiredrowordering
private boolean			 foundabestplan
protected costestimate sortcost
private rowordering currentrowordering   new roworderingimpl
private rowordering bestrowordering   new roworderingimpl
private boolean	conglomerate_onerowresultset
// optimizer trace
protected boolean optimizertrace
protected boolean optimizertracehtml
// max memory use per table
protected int maxmemorypertable
// whether or not we need to reload the best plan for an optimizable
// when we "pull" it.  if the latest complete join order was the
// best one so far, then the optimizable will already have the correct
// best plan loaded so we don't need to do the extra work.  but if
// the most recent join order was _not_ the best, then this flag tells
// us that we need to reload the best plan when pulling.
private boolean reloadbestplan
// set of optimizer->bestjoinorder mappings used to keep track of which
// of this optimizerimpl's "bestjoinorder"s was the best with respect to a
// a specific outer query; the outer query is represented by an instance
// of optimizer.  each outer query could potentially have a different
// idea of what this optimizerimpl's "best join order" is, so we have
// to keep track of them all.
private hashmap savedjoinorders
// value used to figure out when/if we've timed out for this
// optimizable.
protected double timelimit
// cost estimate for the final "best join order" that we chose--i.e.
// the one that's actually going to be generated.
costestimate finalcostestimate
/* status variables used for "jumping" to previous best join
* order when possible.  in particular, this helps when this
* optimizer corresponds to a subquery and we are trying to
* find out what the best join order is if we do a hash join
* with the subquery instead of a nested loop join.  in that
* case the previous best join order will have the best join
* order for a nested loop, so we want to start there when
* considering hash join because odds are that same join order
* will give us the best cost for hash join, as well.  we
* only try this, though, if neither the previous round of
* optimization nor this round relies on predicates that have
* been pushed down from above--because that's the scenario
* for which the best join order is likely to be same for
* consecutive rounds.
*/
private boolean usingpredspushedfromabove
private boolean bestjoinorderusedpredsfromabove
protected  optimizerimpl optimizablelist optimizablelist
optimizablepredicatelist predicatelist
datadictionary ddictionary
boolean rulebasedoptimization
boolean notimeout
boolean usestatistics
int maxmemorypertable
joinstrategy joinstrategies
int tablelockthreshold
requiredrowordering requiredrowordering
int numtablesinquery
throws standardexception
if  sanitymanager debug
sanitymanager assert optimizablelist    null
outermostcostestimate    getnewcostestimate 0 0d  1 0d  1 0d
currentcost   getnewcostestimate 0 0d  0 0d  0 0d
currentsortavoidancecost   getnewcostestimate 0 0d  0 0d  0 0d
bestcost   getnewcostestimate double max_value  double max_value  double max_value
// verify that any properties lists for user overrides are valid
optimizablelist verifyproperties ddictionary
this numtablesinquery   numtablesinquery
numoptimizables   optimizablelist size
proposedjoinorder   new int
if  numtablesinquery > 6
permutestate   ready_to_jump
firstlookorder   new int
else
permutestate   no_jump
/* mark all join positions as unused */
for  int i   0  i < numoptimizables  i
proposedjoinorder    1
bestjoinorder   new int
joinposition    1
this optimizablelist   optimizablelist
this predicatelist   predicatelist
this ddictionary   ddictionary
this rulebasedoptimization   rulebasedoptimization
this notimeout   notimeout
this maxmemorypertable   maxmemorypertable
this joinstrategies   joinstrategies
this tablelockthreshold   tablelockthreshold
this requiredrowordering   requiredrowordering
this usestatistics   usestatistics
/* initialize variables for tracking permutations */
assignedtablemap   new jbitset numtablesinquery
/*
** make a map of the non-correlated tables, which are the tables
** in the list of optimizables we're optimizing.  an reference
** to a table that is not defined in the list of optimizables
** is presumed to be correlated.
*/
noncorrelatedtablemap   new jbitset numtablesinquery
for  int tabctr   0  tabctr < numoptimizables  tabctr
optimizable	curtable   optimizablelist getoptimizable tabctr
noncorrelatedtablemap or curtable getreferencedtablemap
/* get the time that optimization starts */
timeoptimizationstarted   system currenttimemillis
reloadbestplan   false
savedjoinorders   null
timelimit   double max_value
usingpredspushedfromabove   false
bestjoinorderusedpredsfromabove   false
/**
* this method is called before every "round" of optimization, where
* we define a "round" to be the period between the last time a call to
* getoptimizer() (on either a resultsetnode or an optimizerfactory)
* returned _this_ optimizerimpl and the time a call to this optimizerimpl's
* getnextpermutation() method returns false.  any re-initialization
* of state that is required before each round should be done in this
* method.
*/
public void prepfornextround
// we initialize reloadbestplan to false so that if we end up
// pulling an optimizable before we find a best join order
// (which can happen if there is no valid join order for this
// round) we won't inadvertently reload the best plans based
// on some previous round.
reloadbestplan   false
/* since we're preparing for a new round, we have to clear
* out the "bestcost" from the previous round to ensure that,
* when this round of optimizing is done, bestcost will hold
* the best cost estimate found _this_ round, if there was
* one.  if there was no best cost found (which can happen if
* there is no feasible join order) then bestcost will remain
* at double.max_value.  then when outer queries check the
* cost and see that it is so high, they will reject whatever
* outer join order they're trying in favor of something that's
* actually valid (and therefore cheaper).
*
* note that we do _not_ reset the "foundabestplan" variable nor
* the "bestjoinorder" array.  this is because it's possible that
* a "best join order" may not exist for the current round, in
* which case this optimizerimpl must know whether or not it found
* a best join order in a previous round (foundabestplan) and if
* so what the corresponding join order was (bestjoinorder).  this
* information is required so that the correct query plan can be
* generated after optimization is complete, even if that best
* plan was not found in the most recent round.
*/
bestcost   getnewcostestimate
double max_value  double max_value  double max_value
/* if we have predicates that were pushed down to this optimizerimpl
* from an outer query, then we reset the timeout state to prepare for
* the next round of optimization.  otherwise if we timed out during
* a previous round and then we get here for another round, we'll
* immediately "timeout" again before optimizing any of the optimizables
* in our list.  this is okay if we don't have any predicates from
* outer queries because in that case the plan we find this round
* will be the same one we found in the previous round, in which
* case there's no point in resetting the timeout state and doing
* the work a second time.  but if we have predicates from an outer
* query, those predicates could help us find a much better plan
* this round than we did in previous rounds--so we reset the timeout
* state to ensure that we have a chance to consider plans that
* can take advantage of the pushed predicates.
*/
usingpredspushedfromabove   false
if   predicatelist    null      predicatelist size   > 0
for  int i   predicatelist size     1  i >  0  i
// if the predicate is "scoped", then we know it was pushed
// here from an outer query.
if    predicate predicatelist
getoptpredicate i   isscopedforpush
usingpredspushedfromabove   true
break
if  usingpredspushedfromabove
timeoptimizationstarted   system currenttimemillis
timeexceeded   false
/* if user specified the optimizer override for a fixed
* join order, then desiredjoinorderfound could be true
* when we get here.  we have to reset it to false in
* prep for the next round of optimization.  otherwise
* we'd end up quitting the optimization before ever
* finding a plan for this round, and that could, among
* other things, lead to a never-ending optimization
* phase in certain situations.  derby-1866.
*/
desiredjoinorderfound   false
public int getmaxmemorypertable
return maxmemorypertable
/**
* @see optimizer#getnextpermutation
*
* @exception standardexception		thrown on error
*/
public boolean getnextpermutation
throws standardexception
/* don't get any permutations if there is nothing to optimize */
if  numoptimizables < 1
if  optimizertrace
trace no_tables  0  0  0 0  null
endofroundcleanup
return false
/* make sure that all optimizables init their access paths.
* (they wait until optimization since the access path
* references the optimizer.)
*/
optimizablelist initaccesspaths this
/*
** experiments show that optimization time only starts to
** become a problem with seven tables, so only check for
** too much time if there are more than seven tables.
** also, don't check for too much time if user has specified
** no timeout.
*/
if       timeexceeded
numtablesinquery > 6
notimeout
/*
** stop optimizing if the time spent optimizing is greater than
** the current best cost.
*/
currenttime   system currenttimemillis
timeexceeded    currenttime   timeoptimizationstarted  > timelimit
if  optimizertrace    timeexceeded
trace time_exceeded  0  0  0 0  null
if  bestcost isuninitialized      foundabestplan
usingpredspushedfromabove     bestjoinorderusedpredsfromabove
timeexceeded
/* we can get here if this optimizerimpl is for a subquery
* that timed out for a previous permutation of the outer
* query, but then the outer query itself did _not_ timeout.
* in that case we'll end up back here for another round of
* optimization, but our timeexceeded flag will be true.
* we don't want to reset all of the timeout state here
* because that could lead to redundant work (see comments
* in prepfornextround()), but we also don't want to return
* without having a plan, because then we'd return an unfairly
* high "bestcost" value--i.e. double.max_value.  note that
* we can't just revert back to whatever bestcost we had
* prior to this because that cost is for some previous
* permutation of the outer query--not the current permutation--
* and thus would be incorrect.  so instead we have to delay
* the timeout until we find a complete (and valid) join order,
* so that we can return a valid cost estimate.  once we have
* a valid cost we'll then go through the timeout logic
* and stop optimizing.
*
* all of that said, instead of just trying the first possible
* join order, we jump to the join order that gave us the best
* cost in previous rounds.  we know that such a join order exists
* because that's how our timeout value was set to begin with--so
* if there was no best join order, we never would have timed out
* and thus we wouldn't be here.
*
* we can also get here if we've already optimized the list
* of optimizables once (in a previous round of optimization)
* and now we're back to do it again.  if that's true and
* we did *not* receive any predicates pushed from above and
* the bestjoinorder from the previous round did *not* depend
* on predicates pushed from above, then we'll jump to the
* previous join order and start there.  note: if after jumping
* to the previous join order and calculating the cost we haven't
* timed out, we will continue looking at other join orders (as
* usual) until we exhaust them all or we time out.
*/
if  permutestate    jumping
// by setting firstlookorder to our target join order
// and then setting our permutestate to jumping, we'll
// jump to the target join order and get the cost.  that
// cost will then be saved as bestcost, allowing us to
// proceed with normal timeout logic.
if  firstlookorder    null
firstlookorder   new int
for  int i   0  i < numoptimizables  i
firstlookorder   bestjoinorder
permutestate   jumping
/* if we already assigned at least one position in the
* join order when this happened (i.e. if joinposition
* is greater than *or equal* to zero; derby-1777), then
* reset the join order before jumping.  the call to
* rewindjoinorder() here will put joinposition back
* to 0.  but that said, we'll then end up incrementing
* joinposition before we start looking for the next
* join order (see below), which means we need to set
* it to -1 here so that it gets incremented to "0" and
* then processing can continue as normal from there.
* note: we don't need to set reloadbestplan to true
* here because we only get here if we have *not* found
* a best plan yet.
*/
if  joinposition >  0
rewindjoinorder
joinposition    1
// reset the timeexceeded flag so that we'll keep going
// until we find a complete join order.  note: we intentionally
// do _not_ reset the timeoptimizationstarted value because we
// we want to go through this timeout logic for every
// permutation, to make sure we timeout as soon as we have
// our first complete join order.
timeexceeded   false
/*
** pick the next table in the join order, if there is an unused position
** in the join order, and the current plan is less expensive than
** the best plan so far, and the amount of time spent optimizing is
** still less than the cost of the best plan so far, and a best
** cost has been found in the current join position.  otherwise,
** just pick the next table in the current position.
*/
boolean joinposadvanced   false
/* determine if the current plan is still less expensive than
* the best plan so far.  if bestcost is uninitialized then
* we want to return false here; if we didn't, then in the (rare)
* case where the current cost is greater than double.max_value
* (esp. if it's double.positive_infinity, which can occur
* for very deeply nested queries with long fromlists) we would
* give up on the current plan even though we didn't have a
* best plan yet, which would be wrong.  also note: if we have
* a required row ordering then we might end up using the
* sort avoidance plan--but we don't know at this point
* which plan (sort avoidance or "normal") we're going to
* use, so we error on the side of caution and only short-
* circuit if both currentcost and currentsortavoidancecost
* (if the latter is applicable) are greater than bestcost.
*/
boolean alreadycostsmore
bestcost isuninitialized
currentcost compare bestcost  > 0
requiredrowordering    null
currentsortavoidancecost compare bestcost  > 0
if   joinposition <  numoptimizables   1
alreadycostsmore
timeexceeded
/*
** are we either starting at the first join position (in which
** case joinposition will be -1), or has a best cost been found
** in the current join position?  the latter case might not be
** true if there is no feasible join order.
*/
if   joinposition < 0
optimizablelist getoptimizable
proposedjoinorder
getbestaccesspath   getcostestimate      null
joinposition
joinposadvanced   true
/*
** when adding a table to the join order, the best row
** row ordering for the outer tables becomes the starting
** point for the row ordering of the current table.
*/
bestrowordering copy currentrowordering
else
if  optimizertrace
/*
** not considered short-circuiting if all slots in join
** order are taken.
*/
if  joinposition <  numoptimizables   1
trace short_circuiting  0  0  0 0  null
// if we short-circuited the current join order then we need
// to make sure that, when we start pulling optimizables to find
// a new join order, we reload the best plans for those
// optimizables as we pull them.  otherwise we could end up
// generating a plan for an optimizable even though that plan
// was part of a short-circuited (and thus rejected) join
// order.
if  joinposition <  numoptimizables   1
reloadbestplan   true
if  permutestate    jumping     joinposadvanced    joinposition >  0
//not feeling well in the middle of jump
// note: we have to make sure we reload the best plans
// as we rewind since they may have been clobbered
// (as part of the current join order) before we gave
// up on jumping.
reloadbestplan   true
rewindjoinorder       fall
permutestate   no_jump     give up
/*
** the join position becomes < 0 when all the permutations have been
** looked at.
*/
while  joinposition >  0
int nextoptimizable   0
if  desiredjoinorderfound    timeexceeded
/*
** if the desired join order has been found (which will happen
** if the user specifies a join order), pretend that there are
** no more optimizables at this join position.  this will cause
** us to back out of the current join order.
**
** also, don't look at any more join orders if we have taken
** too much time with this optimization.
*/
nextoptimizable   numoptimizables
else if  permutestate    jumping     still jumping
/* we're "jumping" to a join order that puts the optimizables
** with the lowest estimated costs first (insofar as it
** is legal to do so).  the "firstlookorder" array holds the
** ideal join order for position <joinposition> up thru
** position <numoptimizables-1>.  so here, we look at the
** ideal optimizable to place at <joinposition> and see if
** it's legal; if it is, then we're done.  otherwise, we
** swap it with <numoptimizables-1> and see if that gives us
** a legal join order w.r.t <joinposition>.  if not, then we
** swap it with <numoptimizables-2> and check, and if that
** fails, then we swap it with <numoptimizables-3>, and so
** on.  for example, assume we have 6 optimizables whose
** order from least expensive to most expensive is 2, 1, 4,
** 5, 3, 0.  assume also that we've already verified the
** legality of the first two positions--i.e. that joinposition
** is now "2". that means that "firstlookorder" currently
** contains the following:
**
** [ pos ]    0  1  2  3  4  5
** [ opt ]    2  1  4  5  3  0
**
** then at this point, we do the following:
**
**  -- check to see if the ideal optimizable "4" is valid
**     at its current position (2)
**  -- if opt "4" is valid, then we're done; else we
**     swap it with the value at position _5_:
**
** [ pos ]    0  1  2  3  4  5
** [ opt ]    2  1  0  5  3  4
**
**  -- check to see if optimizable "0" is valid at its
**     new position (2).
**  -- if opt "0" is valid, then we're done; else we
**     put "0" back in its original position and swap
**     the ideal optimizer ("4") with the value at
**     position _4_:
**
** [ pos ]    0  1  2  3  4  5
** [ opt ]    2  1  3  5  4  0
**
**  -- check to see if optimizable "3" is valid at its
**     new position (2).
**  -- if opt "3" is valid, then we're done; else we
**     put "3" back in its original position and swap
**     the ideal optimizer ("4") with the value at
**     position _3_:
**
** [ pos ]    0  1  2  3  4  5
** [ opt ]    2  1  5  4  3  0
**
**  -- check to see if optimizable "5" is valid at its
**     new position (2).
**  -- if opt "5" is valid, then we're done; else we've
**     tried all the available optimizables and none
**     of them are legal at position 2.  in this case,
**     we give up on "jumping" and fall back to normal
**     join-order processing.
*/
int idealoptimizable   firstlookorder
nextoptimizable   idealoptimizable
int lookpos   numoptimizables
int lastswappedopt    1
optimizable nextopt
for  nextopt   optimizablelist getoptimizable nextoptimizable
nextopt legaljoinorder assignedtablemap
nextopt   optimizablelist getoptimizable nextoptimizable
// undo last swap, if we had one.
if  lastswappedopt >  0
firstlookorder   idealoptimizable
firstlookorder   lastswappedopt
if  lookpos > joinposition   1
// we still have other possibilities; get the next
// one by "swapping" it into the current position.
lastswappedopt   firstlookorder
firstlookorder   lastswappedopt
firstlookorder   idealoptimizable
nextoptimizable   lastswappedopt
else
// we went through all of the available optimizables
// and none of them were legal in the current position;
// so we give up and fall back to normal processing.
// note: we have to make sure we reload the best plans
// as we rewind since they may have been clobbered
// (as part of the current join order) before we got
// here.
if  joinposition > 0
joinposition
reloadbestplan   true
rewindjoinorder
permutestate   no_jump
break
if  permutestate    no_jump
continue
if  joinposition    numoptimizables   1
// we just set the final position within our
// "firstlookorder" join order; now go ahead
// and search for the best join order, starting from
// the join order stored in "firstlookorder".  this
// is called walking "high" because we're searching
// the join orders that are at or "above" (after) the
// order found in firstlookorder.  ex. if we had three
// optimizables and firstlookorder was [1 2 0], then
// the "high" would be [1 2 0], [2 0 1] and [2 1 0];
// the "low" would be [0 1 2], [0 2 1], and [1 0 2].
// we walk the "high" first, then fall back and
// walk the "low".
permutestate   walk_high
else
/* find the next unused table at this join position */
nextoptimizable   proposedjoinorder   1
for     nextoptimizable < numoptimizables  nextoptimizable
boolean found   false
for  int posn   0  posn < joinposition  posn
/*
** is this optimizable already somewhere
** in the join order?
*/
if  proposedjoinorder    nextoptimizable
found   true
break
/* check to make sure that all of the next optimizable's
* dependencies have been satisfied.
*/
if  nextoptimizable < numoptimizables
optimizable nextopt
optimizablelist getoptimizable nextoptimizable
if     nextopt legaljoinorder assignedtablemap
if  optimizertrace
trace skipping_join_order  nextoptimizable  0  0 0  null
/*
** if this is a user specified join order then it is illegal.
*/
if     optimizablelist optimizejoinorder
if  optimizertrace
trace illegal_user_join_order  0  0  0 0  null
throw standardexception newexception sqlstate lang_illegal_forced_join_order
continue
if    found
break
/*
** we are going to try an optimizable at the current join order
** position.  is there one already at that position?
*/
if  proposedjoinorder >  0
/*
** we are either going to try another table at the current
** join order position, or we have exhausted all the tables
** at the current join order position.  in either case, we
** need to pull the table at the current join order position
** and remove it from the join order.
*/
optimizable pullme
optimizablelist getoptimizable
proposedjoinorder
/*
** subtract the cost estimate of the optimizable being
** removed from the total cost estimate.
**
** the total cost is the sum of all the costs, but the total
** number of rows is the number of rows returned by the
** innermost optimizable.
*/
double prevrowcount
double prevsinglescanrowcount
int prevposition   0
if  joinposition    0
prevrowcount   outermostcostestimate rowcount
prevsinglescanrowcount   outermostcostestimate singlescanrowcount
else
prevposition   proposedjoinorder
costestimate localce
optimizablelist
getoptimizable prevposition
getbestaccesspath
getcostestimate
prevrowcount   localce rowcount
prevsinglescanrowcount   localce singlescanrowcount
/*
** if there is no feasible join order, the cost estimate
** in the best access path may never have been set.
** in this case, do not subtract anything from the
** current cost, since nothing was added to the current
** cost.
*/
double newcost   currentcost getestimatedcost
double pullcost   0 0
costestimate pullcostestimate
pullme getbestaccesspath   getcostestimate
if  pullcostestimate    null
pullcost   pullcostestimate getestimatedcost
newcost    pullcost
/*
** it's possible for newcost to go negative here due to
** loss of precision.
*/
if  newcost < 0 0
newcost   0 0
/* if we are choosing a new outer table, then
* we rest the starting cost to the outermostcost.
* (thus avoiding any problems with floating point
* accuracy and going negative.)
*/
if  joinposition    0
if  outermostcostestimate    null
newcost   outermostcostestimate getestimatedcost
else
newcost   0 0
currentcost setcost
newcost
prevrowcount
prevsinglescanrowcount
/*
** subtract from the sort avoidance cost if there is a
** required row ordering.
**
** note: it is not necessary here to check whether the
** best cost was ever set for the sort avoidance path,
** because it considersortavoidancepath() would not be
** set if there cost were not set.
*/
if  requiredrowordering    null
if  pullme considersortavoidancepath
accesspath ap   pullme getbestsortavoidancepath
double	   prevestimatedcost   0 0d
/*
** subtract the sort avoidance cost estimate of the
** optimizable being removed from the total sort
** avoidance cost estimate.
**
** the total cost is the sum of all the costs, but the
** total number of rows is the number of rows returned
** by the innermost optimizable.
*/
if  joinposition    0
prevrowcount   outermostcostestimate rowcount
prevsinglescanrowcount   outermostcostestimate singlescanrowcount
/* if we are choosing a new outer table, then
* we rest the starting cost to the outermostcost.
* (thus avoiding any problems with floating point
* accuracy and going negative.)
*/
prevestimatedcost   outermostcostestimate getestimatedcost
else
costestimate localce
optimizablelist
getoptimizable prevposition
getbestsortavoidancepath
getcostestimate
prevrowcount   localce rowcount
prevsinglescanrowcount   localce singlescanrowcount
prevestimatedcost   currentsortavoidancecost getestimatedcost
ap getcostestimate   getestimatedcost
currentsortavoidancecost setcost
prevestimatedcost
prevrowcount
prevsinglescanrowcount
/*
** remove the table from the best row ordering.
** it should not be necessary to remove it from
** the current row ordering, because it is
** maintained as we step through the access paths
** for the current optimizable.
*/
bestrowordering removeoptimizable
pullme gettablenumber
/*
** when removing a table from the join order,
** the best row ordering for the remaining outer tables
** becomes the starting point for the row ordering of
** the current table.
*/
bestrowordering copy currentrowordering
/*
** pull the predicates at from the optimizable and put
** them back in the predicate list.
**
** note: this is a little inefficient because it pulls the
** single-table predicates, which are guaranteed to always
** be pushed to the same optimizable.  we could make this
** leave the single-table predicates where they are.
*/
pullme pulloptpredicates predicatelist
/*
** when we pull an optimizable we need to go through and
** load whatever best path we found for that optimizable
** with respect to this optimizerimpl.  the reason is that
** we could be pulling the optimizable for the last time
** (before returning false), in which case we want it (the
** optimizable) to be holding the best access path that it
** had at the time we found bestjoinorder.  this ensures
** that the access path which is generated and executed for
** the optimizable matches the the access path decisions
** made by this optimizerimpl for the best join order.
**
** note: we we only reload the best plan if it's necessary
** to do so--i.e. if the best plans aren't already loaded.
** the plans will already be loaded if the last complete
** join order we had was the best one so far, because that
** means we called "rememberasbest" on every optimizable
** in the list and, as part of that call, we will run through
** and set trulythebestaccesspath for the entire subtree.
** so if we haven't tried any other plans since then,
** we know that every optimizable (and its subtree) already
** has the correct best plan loaded in its trulythebest
** path field.  it's good to skip the load in this case
** because 'reloading best plans' involves walking the
** entire subtree of _every_ optimizable in the list, which
** can be expensive if there are deeply nested subqueries.
*/
if  reloadbestplan
pullme updatebestplanmap fromtable load_plan  this
/* mark current join position as unused */
proposedjoinorder    1
/* have we exhausted all the optimizables at this join position? */
if  nextoptimizable >  numoptimizables
/*
** if we're not optimizing the join order, remember the first
** join order.
*/
if     optimizablelist optimizejoinorder
// verify that the user specified a legal join order
if     optimizablelist legaljoinorder numtablesinquery
if  optimizertrace
trace illegal_user_join_order  0  0  0 0  null
throw standardexception newexception sqlstate lang_illegal_forced_join_order
if  optimizertrace
trace user_join_order_optimized  0  0  0 0  null
desiredjoinorderfound   true
if  permutestate    ready_to_jump    joinposition > 0    joinposition    numoptimizables 1
permutestate   jumping
/* a simple heuristics is that the row count we got indicates a potentially
* good join order.  we'd like row count to get big as late as possible, so
* that less load is carried over.
*/
double rc   new double
for  int i   0  i < numoptimizables  i
firstlookorder   i
costestimate ce   optimizablelist getoptimizable i
getbestaccesspath   getcostestimate
if  ce    null
permutestate   ready_to_jump     come again?
break
rc   ce singlescanrowcount
if  permutestate    jumping
boolean doit   false
int temp
for  int i   0  i < numoptimizables  i   	  simple selection sort
int k   i
for  int j   i 1  j < numoptimizables  j
if  rc < rc   k   j
if  k    i
rc   rc 	  destroy the bridge
temp   firstlookorder
firstlookorder   firstlookorder
firstlookorder   temp
doit   true
if  doit
joinposition
rewindjoinorder       jump from ground
continue
else permutestate   no_jump 	  never
/*
** we have exhausted all the optimizables at this level.
** go back up one level.
*/
/* go back up one join position */
joinposition
/* clear the assigned table map for the previous position
* note: we need to do this here to for the dependency tracking
*/
if  joinposition >  0
optimizable pullme
optimizablelist getoptimizable
proposedjoinorder
/*
** clear the bits from the table at this join position.
** this depends on them having been set previously.
** note: we need to do this here to for the dependency tracking
*/
assignedtablemap xor pullme getreferencedtablemap
if  joinposition < 0    permutestate    walk_high    reached peak
joinposition   0 	  reset  fall down the hill
permutestate   walk_low
continue
/*
** we have found another optimizable to try at this join position.
*/
proposedjoinorder   nextoptimizable
if  permutestate    walk_low
boolean finishedcycle   true
for  int i   0  i < numoptimizables  i
if  proposedjoinorder < firstlookorder
finishedcycle   false
break
else if  proposedjoinorder > firstlookorder     done
break
if  finishedcycle
// we just set proposedjoinorder[joinposition] above, so
// if we're done we need to put it back to -1 to indicate
// that it's an empty slot.  then we rewind and pull any
// other optimizables at positions < joinposition.
// note: we have to make sure we reload the best plans
// as we rewind since they may have been clobbered
// (as part of the current join order) before we got
// here.
proposedjoinorder    1
joinposition
if  joinposition >  0
reloadbestplan   true
rewindjoinorder
joinposition    1
permutestate   ready_to_jump
endofroundcleanup
return false
/* re-init (clear out) the cost for the best access path
* when placing a table.
*/
optimizablelist getoptimizable nextoptimizable
getbestaccesspath   setcostestimate  costestimate  null
/* set the assigned table map to be exactly the tables
* in the current join order.
*/
assignedtablemap clearall
for  int index   0  index <  joinposition  index
assignedtablemap or optimizablelist getoptimizable proposedjoinorder  getreferencedtablemap
if  optimizertrace
trace considering_join_order  0  0  0 0  null
optimizable nextopt
optimizablelist getoptimizable nextoptimizable
nextopt startoptimizing this  currentrowordering
pushpredicates
optimizablelist getoptimizable nextoptimizable
assignedtablemap
return true
endofroundcleanup
return false
private void rewindjoinorder
throws standardexception
for      joinposition
optimizable pullme
optimizablelist getoptimizable
proposedjoinorder
pullme pulloptpredicates predicatelist
if  reloadbestplan
pullme updatebestplanmap fromtable load_plan  this
proposedjoinorder    1
if  joinposition    0  break
currentcost setcost 0 0d  0 0d  0 0d
currentsortavoidancecost setcost 0 0d  0 0d  0 0d
assignedtablemap clearall
/**
* do any work that needs to be done after the current round
* of optimization has completed.  for now this just means walking
* the subtrees for each optimizable and removing the "bestplan"
* that we saved (w.r.t to this optimizerimpl) from all of the
* nodes.  if we don't do this post-optimization cleanup we
* can end up consuming a huge amount of memory for deeply-
* nested queries, which can lead to oom errors.  derby-1315.
*/
private void endofroundcleanup
throws standardexception
for  int i   0  i < numoptimizables  i
optimizablelist getoptimizable i
updatebestplanmap fromtable remove_plan  this
/*
** push predicates from this optimizer's list to the given optimizable,
** as appropriate given the outer tables.
**
** @param curtable	the optimizable to push predicates down to
** @param outertables	a bit map of outer tables
**
** @exception standardexception		thrown on error
*/
void pushpredicates optimizable curtable  jbitset outertables
throws standardexception
/*
** push optimizable clauses to current position in join order.
**
** resolve - we do not push predicates with subqueries not materializable.
*/
int		                numpreds          predicatelist size
jbitset	                predmap           new jbitset numtablesinquery
jbitset                 curtablenums      null
basetablenumbersvisitor btnvis            null
boolean                 pushprednow       false
int                     tnum
predicate               pred
/* walk the optimizablepredicatelist.  for each optimizablepredicate,
* see if it can be assigned to the optimizable at the current join
* position.
*
* note - we walk the opl backwards since we will hopefully be deleted
* entries as we walk it.
*/
for  int predctr   numpreds   1  predctr >  0  predctr
pred    predicate predicatelist getoptpredicate predctr
/* skip over non-pushable predicates */
if    ispushable pred
continue
/* make copy of referenced map so that we can do destructive
* manipulation on the copy.
*/
predmap setto pred getreferencedmap
/* clear bits representing those tables that have already been
* assigned, except for the current table.  the outer table map
* includes the current table, so if the predicate is ready to
* be pushed, predmap will end up with no bits set.
*/
for  int index   0  index < predmap size    index
if  outertables get index
predmap clear index
/*
** only consider non-correlated variables when deciding where
** to push predicates down to.
*/
predmap and noncorrelatedtablemap
/* at this point what we've done is figure out what fromtables
* the predicate references (using the predicate's "referenced
* map") and then: 1) unset the table numbers for any fromtables
* that have already been optimized, 2) unset the table number
* for curtable, which we are about to optimize, and 3) cleared
* out any remaining table numbers which do not directly
* correspond to un-optimized fromtables in this optimizerimpl's
* optimizablelist.
*
* note: the optimizables in this optimpl's optimizablelist are
* called "non-correlated".
*
* so at this point predmap holds a list of tablenumbers which
* correspond to "non-correlated" fromtables that are referenced
* by the predicate but that have not yet been optimized.  if any
* such fromtable exists then we cannot push the predicate yet.
* we can only push the predicate if every fromtable that it
* references either 1) has already been optimized, or 2) is
* about to be optimized (i.e. the fromtable is curtable itself).
* we can check for this condition by seeing if predmap is empty,
* which is what the following line does.
*/
pushprednow    predmap getfirstsetbit       1
/* if the predicate is scoped, there's more work to do. a
* scoped predicate's "referenced map" may not be in sync
* with its actual column references.  or put another way,
* the predicate's referenced map may not actually represent
* the tables that are referenced by the predicate.  for
* example, assume the query tree is something like:
*
*      selectnode0
*     (prn0, prn1)
*       |     |
*       t1 unionnode
*           /   |
*         prn2  prn3
*          |     |
*  selectnode1   selectnode2
*   (prn4, prn5)    (prn6)
*     |     |         |
*     t2    t3        t4
*
* assume further that we have an equijoin predicate between
* t1 and the union node, and that the column reference that
* points to the union ultimately maps to t3.  the predicate
* will then be scoped to prn2 and prn3 and the newly-scoped
* predicates will get passed to the optimizers for selectnode1
* and selectnode2--which brings us here.  assume for this
* example that we're here for selectnode1 and that "curtable"
* is prn4.  since the predicate has been scoped to selectnode1,
* its referenced map will hold the table numbers for t1 and
* prn2--it will not hold the table number for prn5, even
* though prn5 (t3) is the actual target for the predicate.
* given that, the above logic will determine that the predicate
* should be pushed to curtable (prn4)--but that's not correct.
* we said at the start that the predicate ultimately maps to
* t3--so we should not be pushing it to t2.  and hence the
* need for some additional logic.  derby-1866.
*/
if  pushprednow    pred isscopedforpush       numoptimizables > 1
if  btnvis    null
curtablenums   new jbitset numtablesinquery
btnvis         new basetablenumbersvisitor curtablenums
/* what we want to do is find out if the scoped predicate
* is really supposed to be pushed to curtable.  we do
* that by getting the base table numbers referenced by
* curtable along with curtable's own table number.  then
* we get the base table numbers referenced by the scoped
* predicate. if the two sets have at least one table
* number in common, then we know that the predicate
* should be pushed to curtable.  in the above example
* predmap will end up holding the base table number
* for t3, and thus this check will fail when curtable
* is prn4 but will pass when it is prn5, which is what
* we want.
*/
tnum     fromtable curtable  gettablenumber
curtablenums clearall
btnvis settablemap curtablenums
fromtable curtable  accept btnvis
if  tnum >  0
curtablenums set tnum
btnvis settablemap predmap
pred accept btnvis
predmap and curtablenums
if   predmap getfirstsetbit       1
pushprednow   false
/*
** finally, push the predicate down to the optimizable at the
** end of the current proposed join order, if it can be evaluated
** there.
*/
if  pushprednow
/* push the predicate and remove it from the list */
if  curtable pushoptpredicate pred
predicatelist removeoptpredicate predctr
/**
* @see optimizer#getnextdecoratedpermutation
*
* @exception standardexception		thrown on error
*/
public boolean getnextdecoratedpermutation
throws standardexception
boolean		retval
optimizable curopt
optimizablelist getoptimizable proposedjoinorder
double		originalrowcount   0 0
// resolve: should we step through the different join strategies here?
/* returns true until all access paths are exhausted */
retval    curopt nextaccesspath this
optimizablepredicatelist  null
currentrowordering
// if the previous path that we considered for curopt was _not_ the best
// path for this round, then we need to revert back to whatever the
// best plan for curopt was this round.  note that the cost estimate
// for bestaccesspath could be null here if the last path that we
// checked was the only one possible for this round.
if   curopt getbestaccesspath   getcostestimate      null
curopt getcurrentaccesspath   getcostestimate      null
// note: we can't just check to see if bestcost is cheaper
// than currentcost because it's possible that currentcost
// is actually cheaper--but it may have been 'rejected' because
// it would have required too much memory.  so we just check
// to see if bestcost and currentcost are different.  if so
// then we know that the most recent access path (represented
// by "current" access path) was not the best.
if  curopt getbestaccesspath   getcostestimate   compare
curopt getcurrentaccesspath   getcostestimate       0
curopt updatebestplanmap fromtable load_plan  curopt
else if  curopt getbestaccesspath   getcostestimate   rowcount   <
curopt getcurrentaccesspath   getcostestimate   rowcount
// if currentcost and bestcost have the same cost estimate
// but currentcost has been rejected because of memory, we
// still need to revert the plans.  in this case the row
// count for currentcost will be greater than the row count
// for bestcost, so that's what we just checked.
curopt updatebestplanmap fromtable load_plan  curopt
/* if we needed to revert plans for curopt, we just did it above.
* so we no longer need to keep the previous best plan--and in fact,
* keeping it can lead to extreme memory usage for very large
* queries.  so delete the stored plan for curopt. derby-1315.
*/
curopt updatebestplanmap fromtable remove_plan  curopt
/*
** when all the access paths have been looked at, we know what the
** cheapest one is, so remember it.  only do this if a cost estimate
** has been set for the best access path - one will not have been
** set if no feasible plan has been found.
*/
costestimate ce   curopt getbestaccesspath   getcostestimate
if       retval       ce    null
/*
** add the cost of the current optimizable to the total cost.
** the total cost is the sum of all the costs, but the total
** number of rows is the number of rows returned by the innermost
** optimizable.
*/
currentcost setcost
currentcost getestimatedcost     ce getestimatedcost
ce rowcount
ce singlescanrowcount
if  curopt considersortavoidancepath
requiredrowordering    null
/* add the cost for the sort avoidance path, if there is one */
ce   curopt getbestsortavoidancepath   getcostestimate
currentsortavoidancecost setcost
currentsortavoidancecost getestimatedcost
ce getestimatedcost
ce rowcount
ce singlescanrowcount
if  optimizertrace
trace total_cost_non_sa_plan  0  0  0 0  null
if  curopt considersortavoidancepath
trace total_cost_sa_plan  0  0  0 0  null
/* do we have a complete join order? */
if   joinposition     numoptimizables   1
if  optimizertrace
trace complete_join_order  0  0  0 0  null
/* add cost of sorting to non-sort-avoidance cost */
if  requiredrowordering    null
boolean gotsortcost   false
/* only get the sort cost once */
if  sortcost    null
sortcost   newcostestimate
/* requiredrowordering records if the bestcost so far is
* sort-needed or not, as done in rememberbestcost.  if
* the bestcost so far is sort-needed, and assume
* currentcost is also sort-needed, we want this comparison
* to be as accurate as possible.  different plans may
* produce different estimated row count (eg., heap scan
* vs. index scan during a join), sometimes the difference
* could be very big.  however the actual row count should
* be only one value.  so when comparing these two plans,
* we want them to have the same sort cost.  we want to
* take the smaller row count, because a better estimation
* (eg. through index) would yield a smaller number.  we
* adjust the bestcost here if it had a bigger rowcount
* estimate.  the performance improvement of doing this
* sometimes is quite dramatic, eg. from 17 sec to 0.5 sec,
* see beetle 4353.
*/
else if  requiredrowordering getsortneeded
if  bestcost rowcount   > currentcost rowcount
// adjust bestcost
requiredrowordering estimatecost
bestcost rowcount
bestrowordering
sortcost
double oldsortcost   sortcost getestimatedcost
requiredrowordering estimatecost
currentcost rowcount
bestrowordering
sortcost
gotsortcost   true
bestcost setcost bestcost getestimatedcost
oldsortcost
sortcost getestimatedcost
sortcost rowcount
currentcost singlescanrowcount
else if  bestcost rowcount   < currentcost rowcount
// adjust currentcost's rowcount
currentcost setcost currentcost getestimatedcost
bestcost rowcount
currentcost singlescanrowcount
/* this does not figure out if sorting is necessary, just
* an asumption that sort is needed; if the assumption is
* wrong, we'll look at sort-avoidance cost as well, later
*/
if    gotsortcost
requiredrowordering estimatecost
currentcost rowcount
bestrowordering
sortcost
originalrowcount   currentcost rowcount
currentcost setcost currentcost getestimatedcost
sortcost getestimatedcost
sortcost rowcount
currentcost singlescanrowcount
if  optimizertrace
trace cost_of_sorting  0  0  0 0  null
trace total_cost_with_sorting  0  0  0 0  null
/*
** is the cost of this join order lower than the best one we've
** found so far?
**
** note: if the user has specified a join order, it will be the
** only join order the optimizer considers, so it is ok to use
** costing to decide that it is the "best" join order.
**
** for very deeply nested queries, it's possible that the optimizer
** will return an estimated cost of double.infinity, which is
** greater than our uninitialized cost of double.max_value and
** thus the "compare" check below will return false.   so we have
** to check to see if bestcost is uninitialized and, if so, we
** save currentcost regardless of what value it is--because we
** haven't found anything better yet.
**
** that said, it's also possible for bestcost to be infinity
** and for current cost to be infinity, as well.  in that case
** we can't really tell much by comparing the two, so for lack
** of better alternative we look at the row counts.  see
** costestimateimpl.compare() for more.
*/
if     foundabestplan
currentcost compare bestcost  < 0
bestcost isuninitialized
rememberbestcost currentcost  optimizer normal_plan
// since we just remembered all of the best plans,
// no need to reload them when pulling optimizables
// from this join order.
reloadbestplan   false
else
reloadbestplan   true
/* subtract cost of sorting from non-sort-avoidance cost */
if  requiredrowordering    null
/*
** the cost could go negative due to loss of precision.
*/
double newcost   currentcost getestimatedcost
sortcost getestimatedcost
if  newcost < 0 0
newcost   0 0
currentcost setcost newcost
originalrowcount
currentcost singlescanrowcount
/*
** this may be the best sort-avoidance plan if there is a
** required row ordering, and we are to consider a sort
** avoidance path on the last optimizable in the join order.
*/
if  requiredrowordering    null
curopt considersortavoidancepath
if  requiredrowordering sortrequired bestrowordering
requiredrowordering nothing_required
if  optimizertrace
trace current_plan_is_sa_plan  0  0  0 0  null
if   currentsortavoidancecost compare bestcost  <  0
bestcost isuninitialized
rememberbestcost currentsortavoidancecost
optimizer sort_avoidance_plan
return retval
/**
* is the cost of this join order lower than the best one we've
* found so far?  if so, remember it.
*
* note: if the user has specified a join order, it will be the
* only join order the optimizer considers, so it is ok to use
* costing to decide that it is the "best" join order.
*	@exception standardexception	thrown on error
*/
private void rememberbestcost costestimate currentcost  int plantype
throws standardexception
foundabestplan   true
if  optimizertrace
trace cheapest_plan_so_far  0  0  0 0  null
trace plan_type  plantype  0  0 0  null
trace cost_of_cheapest_plan_so_far  0  0  0 0  null
/* remember the current cost as best */
bestcost setcost currentcost
// our time limit for optimizing this round is the time we think
// it will take us to execute the best join order that we've
// found so far (across all rounds of optimizing).  in other words,
// don't spend more time optimizing this optimizerimpl than we think
// it's going to take to execute the best plan.  so if we've just
// found a new "best" join order, use that to update our time limit.
if  bestcost getestimatedcost   < timelimit
timelimit   bestcost getestimatedcost
/*
** remember the current join order and access path
** selections as best.
** note: we want the optimizer trace to print out in
** join order instead of in table number order, so
** we use 2 loops.
*/
bestjoinorderusedpredsfromabove   usingpredspushedfromabove
for  int i   0  i < numoptimizables  i
bestjoinorder   proposedjoinorder
for  int i   0  i < numoptimizables  i
optimizablelist getoptimizable bestjoinorder
rememberasbest plantype  this
/* remember if a sort is not needed for this plan */
if  requiredrowordering    null
if  plantype    optimizer sort_avoidance_plan
requiredrowordering sortnotneeded
else
requiredrowordering sortneeded
if  optimizertrace
if  requiredrowordering    null
trace sort_needed_for_ordering  plantype  0  0 0  null
trace remembering_best_join_order  0  0  0 0  null
/**
* @see org.apache.derby.iapi.sql.compile.optimizer#costpermutation
*
* @exception standardexception		thrown on error
*/
public void costpermutation   throws standardexception
/*
** get the cost of the outer plan so far.  this gives us the current
** estimated rows, ordering, etc.
*/
costestimate outercost
if  joinposition    0
outercost   outermostcostestimate
else
/*
** note: this is somewhat problematic.  we assume here that the
** outer cost from the best access path for the outer table
** is ok to use even when costing the sort avoidance path for
** the inner table.  this is probably ok, since all we use
** from the outer cost is the row count.
*/
outercost
optimizablelist getoptimizable
proposedjoinorder
getbestaccesspath   getcostestimate
/* at this point outercost should be non-null (derby-1777).
* do the assertion here so that we catch it right away;
* otherwise we'd end up with an npe somewhere further
* down the tree and it'd be harder to figure out where
* it came from.
*/
if  sanitymanager debug
sanitymanager assert outercost    null
optimizable optimizable   optimizablelist getoptimizable proposedjoinorder
/*
** don't consider non-feasible join strategies.
*/
if     optimizable feasiblejoinstrategy predicatelist  this
return
/* cost the optimizable at the current join position */
optimizable optimizeit this
predicatelist
outercost
currentrowordering
/**
* @see org.apache.derby.iapi.sql.compile.optimizer#costoptimizable
*
* @exception standardexception		thrown on error
*/
public void	costoptimizable optimizable optimizable
tabledescriptor td
conglomeratedescriptor cd
optimizablepredicatelist predlist
costestimate outercost
throws standardexception
/*
** don't consider non-feasible join strategies.
*/
if     optimizable feasiblejoinstrategy predlist  this
return
/*
** classify the predicates according to the given conglomerate.
** the predicates are classified as start keys, stop keys,
** qualifiers, and none-of-the-above.  they are also ordered
** to match the ordering of columns in keyed conglomerates (no
** ordering is done for heaps).
*/
// if (predlist != null)
// 	predlist.classify(optimizable, cd);
if  rulebasedoptimization
rulebasedcostoptimizable optimizable
td
cd
predlist
outercost
else
costbasedcostoptimizable optimizable
td
cd
predlist
outercost
/**
* this method decides whether the given conglomerate descriptor is
* cheapest based on rules, rather than based on cost estimates.
* the rules are:
*
*		covering matching indexes are preferred above all
*		non-covering matching indexes are next in order of preference
*		covering non-matching indexes are next in order of preference
*		heap scans are next in order of preference
*		non-covering, non-matching indexes are last in order of
*		preference.
*
* in the current language architecture, there will always be a
* heap, so a non-covering, non-matching index scan will never be
* chosen.  however, the optimizer may see a non-covering, non-matching
* index first, in which case it will choose it temporarily as the
* best conglomerate seen so far.
*
* note: this method sets the cost in the optimizable, even though it
* doesn't use the cost to determine which access path to choose.  there
* are two reasons for this: the cost might be needed to determine join
* order, and the cost information is copied to the query plan.
*/
private void rulebasedcostoptimizable optimizable optimizable
tabledescriptor td
conglomeratedescriptor cd
optimizablepredicatelist predlist
costestimate outercost
throws standardexception
/* choose best conglomerate here */
conglomeratedescriptor	conglomeratedescriptor   null
conglomeratedescriptor	bestconglomeratedescriptor   null
accesspath bestap   optimizable getbestaccesspath
int lockmode   optimizable getcurrentaccesspath   getlockmode
/*
** if the current conglomerate better than the best so far?
** the pecking order is:
**		o  covering index useful for predicates
**			(if there are predicates)
**		o  index useful for predicates (if there are predicates)
**		o  covering index
**		o  table scan
*/
/*
** if there is more than one conglomerate descriptor
** choose any index that is potentially useful.
*/
if  predlist    null
predlist useful optimizable  cd
/*
** do not let a non-covering matching index scan supplant a
** covering matching index scan.
*/
boolean newcoveringindex   optimizable iscoveringindex cd
if       bestap getcoveringindexscan
bestap getnonmatchingindexscan
newcoveringindex
bestap setcostestimate
estimatetotalcost
predlist
cd
outercost
optimizable
bestap setconglomeratedescriptor cd
bestap setnonmatchingindexscan false
bestap setcoveringindexscan newcoveringindex
bestap setlockmode optimizable getcurrentaccesspath   getlockmode
optimizable rememberjoinstrategyasbest bestap
return
/* remember the "last" covering index.
* note - since we don't have costing, we just go for the
* last one since that's as good as any
*/
if  optimizable iscoveringindex cd
bestap setcostestimate
estimatetotalcost predlist
cd
outercost
optimizable
bestap setconglomeratedescriptor cd
bestap setnonmatchingindexscan true
bestap setcoveringindexscan true
bestap setlockmode optimizable getcurrentaccesspath   getlockmode
optimizable rememberjoinstrategyasbest bestap
return
/*
** if this is the heap, and the best conglomerate so far is a
** non-covering, non-matching index scan, pick the heap.
*/
if       bestap getcoveringindexscan
bestap getnonmatchingindexscan
cd isindex
bestap setcostestimate
estimatetotalcost predlist
cd
outercost
optimizable
bestap setconglomeratedescriptor cd
bestap setlockmode optimizable getcurrentaccesspath   getlockmode
optimizable rememberjoinstrategyasbest bestap
/*
** no need to set non-matching index scan and covering
** index scan, as these are already correct.
*/
return
/*
** if all else fails, and no conglomerate has been picked yet,
** pick this one.
*/
bestconglomeratedescriptor   bestap getconglomeratedescriptor
if  bestconglomeratedescriptor    null
bestap setcostestimate
estimatetotalcost predlist
cd
outercost
optimizable
bestap setconglomeratedescriptor cd
/*
** we have determined above that this index is neither covering
** nor matching.
*/
bestap setcoveringindexscan false
bestap setnonmatchingindexscan cd isindex
bestap setlockmode optimizable getcurrentaccesspath   getlockmode
optimizable rememberjoinstrategyasbest bestap
return
/**
* this method decides whether the given conglomerate descriptor is
* cheapest based on cost, rather than based on rules.  it compares
* the cost of using the given conglomeratedescriptor with the cost
* of using the best conglomeratedescriptor so far.
*/
private void costbasedcostoptimizable optimizable optimizable
tabledescriptor td
conglomeratedescriptor cd
optimizablepredicatelist predlist
costestimate outercost
throws standardexception
costestimate estimatedcost   estimatetotalcost predlist
cd
outercost
optimizable
// before considering the cost, make sure we set the optimizable's
// "current" cost to be the one that we found.  doing this allows
// us to compare "current" with "best" later on to find out if
// the "current" plan is also the "best" one this round--if it's
// not then we'll have to revert back to whatever the best plan is.
// that check is performed in getnextdecoratedpermutation() of
// this class.
optimizable getcurrentaccesspath   setcostestimate estimatedcost
/*
** skip this access path if it takes too much memory.
**
** note: the default assumption here is that the number of rows in
** a single scan is the total number of rows divided by the number
** of outer rows.  the optimizable may over-ride this assumption.
*/
// resolve: the following call to memoryusageok does not behave
// correctly if outercost.rowcount() is positive_infinity; see
// derby-1259.
if    optimizable memoryusageok  estimatedcost rowcount     outercost rowcount    maxmemorypertable
if  optimizertrace
trace skipping_due_to_excess_memory  0  0  0 0  null
return
/* pick the cheapest cost for this particular optimizable. */
accesspath ap   optimizable getbestaccesspath
costestimate bestcostestimate   ap getcostestimate
if   bestcostestimate    null
bestcostestimate isuninitialized
estimatedcost compare bestcostestimate  < 0
ap setconglomeratedescriptor cd
ap setcostestimate estimatedcost
ap setcoveringindexscan optimizable iscoveringindex cd
/*
** it's a non-matching index scan either if there is no
** predicate list, or nothing in the predicate list is useful
** for limiting the scan.
*/
ap setnonmatchingindexscan
predlist    null
predlist useful optimizable  cd
ap setlockmode optimizable getcurrentaccesspath   getlockmode
optimizable rememberjoinstrategyasbest ap
/*
** keep track of the best sort-avoidance path if there is a
** required row ordering.
*/
if  requiredrowordering    null
/*
** the current optimizable can avoid a sort only if the
** outer one does, also (if there is an outer one).
*/
if  joinposition    0
optimizablelist getoptimizable
proposedjoinorder
considersortavoidancepath
/*
** there is a required row ordering - does the proposed access
** path avoid a sort?
*/
if  requiredrowordering sortrequired currentrowordering
assignedtablemap
requiredrowordering nothing_required
ap   optimizable getbestsortavoidancepath
bestcostestimate   ap getcostestimate
/* is this the cheapest sort-avoidance path? */
if   bestcostestimate    null
bestcostestimate isuninitialized
estimatedcost compare bestcostestimate  < 0
ap setconglomeratedescriptor cd
ap setcostestimate estimatedcost
ap setcoveringindexscan
optimizable iscoveringindex cd
/*
** it's a non-matching index scan either if there is no
** predicate list, or nothing in the predicate list is
** useful for limiting the scan.
*/
ap setnonmatchingindexscan
predlist    null
predlist useful optimizable  cd
ap setlockmode
optimizable getcurrentaccesspath   getlockmode
optimizable rememberjoinstrategyasbest ap
optimizable remembersortavoidancepath
/*
** remember the current row ordering as best
*/
currentrowordering copy bestrowordering
/**
* this is the version of costoptimizable for non-base-tables.
*
* @see optimizer#considercost
*
* @exception standardexception		thrown on error
*/
public void	considercost optimizable optimizable
optimizablepredicatelist predlist
costestimate estimatedcost
costestimate outercost
throws standardexception
/*
** don't consider non-feasible join strategies.
*/
if     optimizable feasiblejoinstrategy predlist  this
return
// before considering the cost, make sure we set the optimizable's
// "current" cost to be the one that we received.  doing this allows
// us to compare "current" with "best" later on to find out if
// the "current" plan is also the "best" one this round--if it's
// not then we'll have to revert back to whatever the best plan is.
// that check is performed in getnextdecoratedpermutation() of
// this class.
optimizable getcurrentaccesspath   setcostestimate estimatedcost
/*
** skip this access path if it takes too much memory.
**
** note: the default assumption here is that the number of rows in
** a single scan is the total number of rows divided by the number
** of outer rows.  the optimizable may over-ride this assumption.
*/
// resolve: the following call to memoryusageok does not behave
// correctly if outercost.rowcount() is positive_infinity; see
// derby-1259.
if    optimizable memoryusageok  estimatedcost rowcount     outercost rowcount
maxmemorypertable
if  optimizertrace
trace skipping_due_to_excess_memory  0  0  0 0  null
return
/* pick the cheapest cost for this particular optimizable.
* note: originally, the code only chose the new access path if
* it was cheaper than the old access path.  however, i (jerry)
* found that the new and old costs were the same for a derived
* table and the old access path did not have a join strategy
* associated with it in that case.  so, we now choose the new
* access path if it is the same cost or cheaper than the current
* access path.
*/
accesspath ap   optimizable getbestaccesspath
costestimate bestcostestimate   ap getcostestimate
if   bestcostestimate    null
bestcostestimate isuninitialized
estimatedcost compare bestcostestimate  <  0
ap setcostestimate estimatedcost
optimizable rememberjoinstrategyasbest ap
/*
** keep track of the best sort-avoidance path if there is a
** required row ordering.
*/
if  requiredrowordering    null
/*
** the current optimizable can avoid a sort only if the
** outer one does, also (if there is an outer one).
*/
if  joinposition    0
optimizablelist getoptimizable
proposedjoinorder
considersortavoidancepath
/*
** there is a required row ordering - does the proposed access
** path avoid a sort?
*/
if  requiredrowordering sortrequired currentrowordering
assignedtablemap
requiredrowordering nothing_required
ap   optimizable getbestsortavoidancepath
bestcostestimate   ap getcostestimate
/* is this the cheapest sort-avoidance path? */
if   bestcostestimate    null
bestcostestimate isuninitialized
estimatedcost compare bestcostestimate  < 0
ap setcostestimate estimatedcost
optimizable rememberjoinstrategyasbest ap
optimizable remembersortavoidancepath
/*
** remember the current row ordering as best
*/
currentrowordering copy bestrowordering
/**
* @see org.apache.derby.iapi.sql.compile.optimizer#getdatadictionary
*/
public datadictionary getdatadictionary
return ddictionary
/**
* @see optimizer#modifyaccesspaths
*
* @exception standardexception		thrown on error
*/
public void modifyaccesspaths   throws standardexception
if  optimizertrace
trace modifying_access_paths  0  0  0 0  null
if     foundabestplan
if  optimizertrace
trace no_best_plan  0  0  0 0  null
throw standardexception newexception sqlstate lang_no_best_plan_found
/* change the join order of the list of optimizables */
optimizablelist reorder bestjoinorder
/* form a bit map of the tables as they are put into the join order */
jbitset outertables   new jbitset numoptimizables
/* modify the access path of each table, as necessary */
for  int ictr   0  ictr < numoptimizables  ictr
optimizable optimizable   optimizablelist getoptimizable ictr
/* current table is treated as an outer table */
outertables or optimizable getreferencedtablemap
/*
** push any appropriate predicates from this optimizer's list
** to the optimizable, as appropriate.
*/
pushpredicates optimizable  outertables
optimizablelist setoptimizable
ictr
optimizable modifyaccesspath outertables
/** @see optimizer#newcostestimate */
public costestimate newcostestimate
return new costestimateimpl
/** @see optimizer#getoptimizedcost */
public costestimate getoptimizedcost
return bestcost
/**
* @see optimizer#getfinalcost
*
* sum up the cost of all of the trulythebestaccesspaths
* for the optimizables in our list.  assumption is that
* we only get here after optimization has completed--i.e.
* while modifying access paths.
*/
public costestimate getfinalcost
// if we already did this once, just return the result.
if  finalcostestimate    null
return finalcostestimate
// the total cost is the sum of all the costs, but the total
// number of rows is the number of rows returned by the innermost
// optimizable.
finalcostestimate   getnewcostestimate 0 0d  0 0d  0 0d
costestimate ce   null
for  int i   0  i < bestjoinorder length  i
ce   optimizablelist getoptimizable bestjoinorder
gettrulythebestaccesspath   getcostestimate
finalcostestimate setcost
finalcostestimate getestimatedcost     ce getestimatedcost
ce rowcount
ce singlescanrowcount
return finalcostestimate
/** @see optimizer#setouterrows */
public void setouterrows double outerrows
outermostcostestimate setcost
outermostcostestimate getestimatedcost
outerrows
outermostcostestimate singlescanrowcount
/** @see optimizer#tablelockthreshold */
public int tablelockthreshold
return tablelockthreshold
/**
* get the number of join strategies supported by this optimizer.
*/
public int getnumberofjoinstrategies
return joinstrategies length
/** @see optimizer#getjoinstrategy */
public joinstrategy getjoinstrategy int whichstrategy
if  sanitymanager debug
if  whichstrategy < 0    whichstrategy >  joinstrategies length
sanitymanager throwassert
whichstrategy
joinstrategies length   1
if  joinstrategies    null
sanitymanager throwassert     whichstrategy
return joinstrategies
/** @see optimizer#getjoinstrategy */
public joinstrategy getjoinstrategy string whichstrategy
joinstrategy retval   null
string uppervalue   stringutil sqltouppercase whichstrategy
for  int i   0  i < joinstrategies length  i
if  uppervalue equals joinstrategies getname
retval   joinstrategies
return retval
/**
@see optimizer#uniquejoinwithoutertable
@exception standardexception	thrown on error
*/
public double uniquejoinwithoutertable optimizablepredicatelist predlist
throws standardexception
double retval    1 0
double numuniquekeys   1 0
double currentrows   currentcost rowcount
if  predlist    null
for  int i   joinposition   1  i >  0  i
optimizable opt   optimizablelist getoptimizable
proposedjoinorder
double uniquekeysthisoptimizable   opt uniquejoin predlist
if  uniquekeysthisoptimizable > 0 0
numuniquekeys    opt uniquejoin predlist
if  numuniquekeys    1 0
retval   numuniquekeys   currentrows
return retval
private boolean ispushable optimizablepredicate pred
/* predicates which contain subqueries that are not materializable are
* not currently pushable.
*/
if  pred hassubquery
return false
else
return true
/**
* estimate the total cost of doing a join with the given optimizable.
*
* @exception standardexception		thrown on error
*/
private costestimate estimatetotalcost optimizablepredicatelist predlist
conglomeratedescriptor cd
costestimate outercost
optimizable optimizable
throws standardexception
/* get the cost of a single scan */
costestimate resultcost
optimizable estimatecost predlist
cd
outercost
this
currentrowordering
return resultcost
/** @see optimizer#getlevel */
public int getlevel
return 1
public costestimateimpl getnewcostestimate double thecost
double therowcount
double thesinglescanrowcount
return new costestimateimpl thecost  therowcount  thesinglescanrowcount
// optimzer trace
public void trace int traceflag  int intparam1  int intparam2
double doubleparam  object objectparam1
/** @see optimizer#usestatistics */
public boolean usestatistics     return usestatistics    optimizablelist usestatistics
/**
* process (i.e. add, load, or remove) current best join order as the
* best one for some outer query or ancestor node, represented by another
* optimizerimpl or an instance of fromtable, respectively. then
* iterate through our optimizablelist and tell each optimizable
* to do the same.  see optimizable.updatebestplan() for more on why
* this is necessary.
*
* @param action indicates whether to add, load, or remove the plan
* @param plankey object to use as the map key when adding/looking up
*  a plan.  if this is an instance of optimizerimpl then it corresponds
*  to an outer query; otherwise it's some optimizable above this
*  optimizerimpl that could potentially reject plans chosen by this
*  optimizerimpl.
*/
protected void updatebestplanmaps short action
object plankey  throws standardexception
// first we process this optimizerimpl's best join order.  if there's
// only one optimizable in the list, then there's only one possible
// join order, so don't bother.
if  numoptimizables > 1
int  joinorder   null
if  action    fromtable remove_plan
if  savedjoinorders    null
savedjoinorders remove plankey
if  savedjoinorders size      0
savedjoinorders   null
else if  action    fromtable add_plan
// if the savedjoinorder map already exists, search for the
// join order for the target optimizer and reuse that.
if  savedjoinorders    null
savedjoinorders   new hashmap
else
joinorder    int savedjoinorders get plankey
// if we don't already have a join order array for the optimizer,
// create a new one.
if  joinorder    null
joinorder   new int
// now copy current bestjoinorder and save it.
for  int i   0  i < bestjoinorder length  i
joinorder   bestjoinorder
savedjoinorders put plankey  joinorder
else
// if we get here, we want to load the best join order from our
// map into this optimizerimpl's bestjoinorder array.
// if we don't have any join orders saved, then there's nothing to
// load.  this can happen if the optimizer tried some join order
// for which there was no valid plan.
if  savedjoinorders    null
joinorder    int savedjoinorders get plankey
if  joinorder    null
// load the join order we found into our
// bestjoinorder array.
for  int i   0  i < joinorder length  i
bestjoinorder   joinorder
// now iterate through all optimizables in this optimizerimpl's
// list and add/load/remove the best plan "mapping" for each one,
// as described in in optimizable.updatebestplanmap().
for  int i   optimizablelist size     1  i >  0  i
optimizablelist getoptimizable i
updatebestplanmap action  plankey
/**
* add scoped predicates to this optimizer's predicatelist. this method
* is intended for use during the modifyaccesspath() phase of
* compilation, as it allows nodes (esp. selectnodes) to add to the
* list of predicates available for the final "push" before code
* generation.  just as the constructor for this class allows a
* caller to specify a predicate list to use during the optimization
* phase, this method allows a caller to specify a predicate list to
* use during the modify-access-paths phase.
*
* before adding the received predicates, this method also
* clears out any scoped predicates that might be sitting in
* optimizerimpl's list from the last round of optimizing.
*
* @param plist list of predicates to add to this optimizerimpl's
*  own list for pushing.
*/
protected void addscopedpredicatestolist predicatelist plist
throws standardexception
if   plist    null      plist    predicatelist
// nothing to do.
return
if  predicatelist    null
// in this case, there is no 'original' predicatelist, so we
// can just create one.
predicatelist   new predicatelist
// first, we need to go through and remove any predicates in this
// optimizer's list that may have been pushed here from outer queries
// during the previous round(s) of optimization.  we know if the
// predicate was pushed from an outer query because it will have
// been scoped to the node for which this optimizerimpl was
// created.
predicate pred   null
for  int i   predicatelist size     1  i >  0  i
pred    predicate predicatelist getoptpredicate i
if  pred isscopedforpush
predicatelist removeoptpredicate i
// now transfer scoped predicates in the received list to
// this optimizerimpl's list, where appropriate.
for  int i   plist size     1  i >  0  i
pred    predicate plist getoptpredicate i
if  pred isscopedtosourceresultset
// clear the scoped predicate's scan flags; they'll be set
// as appropriate when they make it to the restrictionlist
// of the scoped pred's source result set.
pred clearscanflags
predicatelist addoptpredicate pred
plist removeoptpredicate i
return