/*
derby - class org.apache.derby.impl.sql.compile.coalescefunctionnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi reference classname
import org apache derby iapi reference sqlstate
import org apache derby iapi services classfile vmopcode
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi services compiler localfield
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import java lang reflect modifier
import java util vector
/**
* this node represents coalesce/value function which returns the first argument that is not null.
* the arguments are evaluated in the order in which they are specified, and the result of the
* function is the first argument that is not null. the result can be null only if all the arguments
* can be null. the selected argument is converted, if necessary, to the attributes of the result.
*
*
* sql reference guide for db2 has section titled "rules for result data types" at the following url
* http://publib.boulder.ibm.com/infocenter/db2help/index.jsp?topic=/com.ibm.db2.udb.doc/admin/r0008480.htm
* i have constructed following table based on various tables and information under "rules for result data types"
* this table has for bit data types broken out into separate columns for clarity
*
* note that are few differences between derby and db2
* 1)there are few differences between what datatypes are consdiered compatible
* in db2, char for bit data datatypes are compatible with char datatypes
* ie in addition to following table, char is compatible with char for bit data, varchar for bit data and long varchar for bit data
* ie in addition to following table, varchar is compatible with char for bit data, varchar for bit data and long varchar for bit data
* ie in addition to following table, long varchar is compatible with char for bit data, varchar for bit data and long varchar for bit data
* ie in addition to following table, char for bit data is compatible with date, time, timestamp
* ie in addition to following table, varchar for bit data is compatible with date, time, timestamp
*
* 2)few datatypes donot have matching precision in derby and db2
* in db2, precision of time is 8. in derby, precision of time is 0.
* in db2, precision,scale of timestamp is 26,6. in derby, precision of timestamp is 0,0.
* in db2, precision of double is 15. in derby, precision of double is 52.
* in db2, precision of real is 23. in derby, precision of real is 7.
* in db2, precision calculation equation is incorrect when we have int and decimal arguments.
* the equation should be p=x+max(w-x,10) since precision of integer is 10 in both db2 and derby. instead, db2 has p=x+max(w-x,11)
*
* types.             s  i  b  d  r  d  c  v  l  c  v  l  c  d  t  t  b
*                    m  n  i  e  e  o  h  a  o  h  a  o  l  a  i  i  l
*                    a  t  g  c  a  u  a  r  n  a  r  n  o  t  m  m  o
*                    l  e  i  i  l  b  r  c  g  r  c  g  b  e  e  e  b
*                    l  g  n  m     l     h  v  .  h  v           s
*                    i  e  t  a     e     a  a  b  a  a           t
*                    n  r     l           r  r  i  r  r           a
*                    t                       c  t  .  .           m
*                                            h     b  b           p
*                                            a     i  i
*                                            r     t   t
* smallint         { "smallint", "integer", "bigint", "decimal", "double", "double", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error" },
* integer          { "integer", "integer", "bigint", "decimal", "double", "double", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error" },
* bigint           { "bigint", "bigint", "bigint", "decimal", "double", "double", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error" },
* decimal          { "decimal", "decimal", "decimal", "decimal", "double", "double", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error" },
* real             { "double", "double", "double", "double", "real", "double", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error" },
* double           { "double", "double", "double", "double", "double", "double", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error" },
* char             { "error", "error", "error", "error", "error", "error", "char", "varchar", "long varchar", "error", "error", "error", "clob", "date", "time", "timestamp", "error" },
* varchar          { "error", "error", "error", "error", "error", "error", "varchar", "varchar","long varchar", "error", "error", "error", "clob", "date", "time", "timestamp", "error" },
* longvarchar      { "error", "error", "error", "error", "error", "error", "long varchar", "long varchar", "long varchar", "error", "error", "error", "clob", "error", "error", "error", "error" },
* char for bit     { "error", "error", "error", "error", "error", "error", "error", "error", "error", "bit", "bit varying", "long bit varying", "error", "error", "error", "error", "error" },
* varch. bit       { "error", "error", "error", "error", "error", "error", "error", "error", "error", "bit varying", "bit varying", "long bit varying", "error", "error", "error", "error", "error" },
* longvar. bit     { "error", "error", "error", "error", "error", "error", "error", "error", "error", "long bit varying", "long bit varying", "long bit varying", "error", "error", "error", "error", "error" },
* clob             { "error", "error", "error", "error", "error", "error", "clob", "clob", "clob", "error", "error", "error", "clob", "error", "error", "error", "error" },
* date             { "error", "error", "error", "error", "error", "error", "date", "date", "error", "error", "error", "error", "error", "date", "error", "error", "error" },
* time             { "error", "error", "error", "error", "error", "error", "time", "time", "error", "error", "error", "error", "error", "error", "time", "error", "error" },
* timestamp        { "error", "error", "error", "error", "error", "error", "timestamp", "timestamp", "error", "error", "error", "error", "error", "error", "error", "timestamp", "error" },
* blob             { "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "blob" }
*/
public class coalescefunctionnode extends valuenode
string	functionname    are we here because of coalesce function or value function
valuenodelist	argumentslist    this is the list of arguments to the function  we are interested in the first not null argument
valuenode firstnonparameternode   the generated method will generate code to call coalesce on this non parameter argument
/**
* initializer for a calescefunctionnode
*
* @param functionname	tells if the function was called with name coalesce or with name value
* @param argumentslist	the list of arguments to the coalesce/value function
*/
public void init object functionname  object argumentslist
this functionname    string  functionname
this argumentslist    valuenodelist  argumentslist
/**
* binding this expression means setting the result datatypeservices.
* in this case, the result type is based on the rules in the table listed earlier.
*
* @param fromlist			the from list for the statement.
* @param subquerylist		the subquery list being built as we find subquerynodes.
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes.
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
//bind all the arguments
argumentslist bindexpression fromlist  subquerylist  aggregatevector
//there should be more than one argument
if  argumentslist size   < 2
throw standardexception newexception sqlstate lang_db2_number_of_args_invalid  functionname
//check if all the arguments are parameters. if yes, then throw an exception
if  argumentslist containsallparameternodes
throw standardexception newexception sqlstate lang_db2_coalesce_function_all_params
int argumentslistsize   argumentslist size
//find the first non-param argument. the generated method will generate code to call coalesce on this argument
for  int index   0  index < argumentslistsize  index
if      valuenode  argumentslist elementat index   requirestypefromcontext
firstnonparameternode    valuenode  argumentslist elementat index
break
//make sure these arguments are compatible to each other before coalesce can be allowed
for  int index   0  index < argumentslistsize  index
if    valuenode  argumentslist elementat index   requirestypefromcontext      since we don t check for compatibility
continue
argumentslist compatible  valuenode  argumentslist elementat index
//set the result type to the most dominant datatype in the arguments list and based on the table listed above
settype argumentslist getdominanttypeservices
//set all the parameter types to the type of the result type
for  int index   0  index < argumentslistsize  index
if    valuenode  argumentslist elementat index   requirestypefromcontext
valuenode argumentslist elementat index   settype gettypeservices
break
return this
/**
* do code generation for coalese/value
*
* @param acb	the expressionclassbuilder for the class we're generating
* @param mb	the method the expression will go into
*
* @exception standardexception		thrown on error
*/
public void generateexpression expressionclassbuilder acb
methodbuilder mb
throws standardexception
int			argumentslistsize   argumentslist size
string		receivertype   classname datavaluedescriptor
string		argumentslistinterfacetype   classname datavaluedescriptor
// generate the code to build the array
localfield arrayfield
acb newfielddeclaration modifier private  argumentslistinterfacetype
/* the array gets created in the constructor.
* all constant elements in the array are initialized
* in the constructor.
*/
/* assign the initializer to the datavaluedescriptor[] field */
methodbuilder cb   acb getconstructor
cb pushnewarray classname datavaluedescriptor  argumentslistsize
cb setfield arrayfield
/* set the array elements that are constant */
int numconstants   0
methodbuilder nonconstantmethod   null
methodbuilder currentconstmethod   cb
for  int index   0  index < argumentslistsize  index
methodbuilder setarraymethod
if  argumentslist elementat index  instanceof constantnode
numconstants
/*if too many statements are added  to a  method,
*size of method can hit  65k limit, which will
*lead to the class format errors at load time.
*to avoid this problem, when number of statements added
*to a method is > 2048, remaing statements are added to  a new function
*and called from the function which created the function.
*see beetle 5135 or 4293 for further details on this type of problem.
*/
if currentconstmethod statementnumhitlimit 1
methodbuilder genconstantmethod   acb newgeneratedfun    modifier private
currentconstmethod pushthis
currentconstmethod callmethod vmopcode invokevirtual
string  null
genconstantmethod getname
0
//if it is a generate function, close the metod.
if currentconstmethod    cb
currentconstmethod methodreturn
currentconstmethod complete
currentconstmethod   genconstantmethod
setarraymethod   currentconstmethod
else
if  nonconstantmethod    null
nonconstantmethod   acb newgeneratedfun    modifier protected
setarraymethod   nonconstantmethod
setarraymethod getfield arrayfield
valuenode  argumentslist elementat index   generateexpression acb  setarraymethod
setarraymethod upcast receivertype
setarraymethod setarrayelement index
//if a generated function was created to reduce the size of the methods close the functions.
if currentconstmethod    cb
currentconstmethod methodreturn
currentconstmethod complete
if  nonconstantmethod    null
nonconstantmethod methodreturn
nonconstantmethod complete
mb pushthis
mb callmethod vmopcode invokevirtual   string  null  nonconstantmethod getname       0
/*
**  call the method for coalesce/value function.
**	first generate following
**	<first non-param argument in the list>.method(<all the arguments>, <resulttype>)
**	next, if we are dealing with result type that is variable length, then generate a call to setwidth.
*/
firstnonparameternode generateexpression acb  mb     coalesce will be called on this non parameter argument
mb upcast classname datavaluedescriptor
mb getfield arrayfield      first arg to the coalesce function
//following is for the second arg. this arg will be used to pass the return value.
//coalesce method expects this to be initialized to null sqlxxx type object.
localfield field   acb newfielddeclaration modifier private  receivertype
acb generatenull mb  gettypecompiler    gettypeservices   getcollationtype
mb upcast classname datavaluedescriptor
mb putfield field
mb callmethod vmopcode invokeinterface  receivertype     receivertype  2
if  gettypeid   variablelength     since result type is variable length  generate setwidth code
boolean isnumber   gettypeid   isnumerictypeid
// to leave the datavaluedescriptor value on the stack, since setwidth is void
mb dup
mb push isnumber ? gettypeservices   getprecision     gettypeservices   getmaximumwidth
mb push gettypeservices   getscale
mb push true
mb callmethod vmopcode invokeinterface  classname variablesizedatavalue        3
/*
print the non-node subfields
*/
public string tostring
if  sanitymanager debug
return super tostring   functionname   argumentslist
else
return
/**
* {@inheritdoc}
*/
protected boolean isequivalent valuenode o  throws standardexception
if   issamenodetype o
return false
coalescefunctionnode other    coalescefunctionnode o
if  other argumentslist size      argumentslist size
return false
int size   argumentslist size
for  int index   0  index < size  index
valuenode v1    valuenode argumentslist elementat index
valuenode v2    valuenode other argumentslist elementat index
if   v1 isequivalent v2
return false
return true
public visitable accept visitor v  throws standardexception
visitable returnnode   v visit this
if  v skipchildren this     v stoptraversal
return returnnode
int size   argumentslist size
for  int index   0  index < size  index
argumentslist setelementat
querytreenode  argumentslist elementat index   accept v   index
return returnnode
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return						the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
int argumentslistsize   argumentslist size
for  int i 0  i < argumentslistsize  i
valuenode argumentslist elementat i   preprocess
numtables
outerfromlist
outersubquerylist
outerpredicatelist
return this
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth					the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
printlabel depth
int argumentslistsize   argumentslist size
for  int i 0  i < argumentslistsize  i
valuenode argumentslist elementat i   treeprint depth 1