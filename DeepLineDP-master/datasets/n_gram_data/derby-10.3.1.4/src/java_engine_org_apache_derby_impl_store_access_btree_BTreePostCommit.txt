/*
derby - class org.apache.derby.impl.store.access.btree.btreepostcommit
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree
import org apache derby iapi services context contextmanager
import org apache derby iapi services daemon serviceable
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access accessfactory
import org apache derby iapi store access accessfactoryglobals
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw fetchdescriptor
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi reference sqlstate
/**
the btreepostcommit class implements the serviceable protocol.
in it's role as a serviceable object, it stores the state necessary to
find a page in a btree that may have committed delete's to reclaim.
in it's role as a postcommitprocessor it looks up the page described, and
reclaims space in the btree.  it first trys to clean up any deleted commits
on the page.  it then will shrink the tree if it is going to delete all
rows from the page (resolve - not done yet).
**/
class btreepostcommit implements serviceable
private     accessfactory access_factory    null
private     long          page_number   containerhandle invalid_page_number
protected   btree         btree             null
/* constructors for this class: */
btreepostcommit
accessfactory   access_factory
btree           btree
long            input_page_number
this access_factory   access_factory
this btree            btree
this page_number      input_page_number
/* private/protected methods of this class: */
/* public methods of this class: */
/* public methods of serviceable class: */
/**
* the urgency of this post commit work.
* <p>
* this determines where this serviceable is put in the post commit
* queue.  post commit work in the btree can be safely delayed until there
* is not user work to do.
*
* @return false, this work should not be serviced asap
**/
public boolean serviceasap
return true
// @return true, if this work needs to be done on a user thread immediately
public boolean serviceimmediately
return false
private final void doshrink
openbtree               open_btree
datavaluedescriptor	shrink_row
throws standardexception
controlrow root   null
/*
system.out.println(
"calling shrink on tree with levels = " +
open_btree.getheight() + "\n");
*/
// get the root page back, and perform a split following the
// to-be-inserted key.  the split releases the root page latch.
root   controlrow get open_btree  btree rootpageid
root shrinkfor open_btree  shrink_row
root   null
// on return from shrinkfor the root pointer is invalid.  the
// latch has been released, the root page may have changed from
// a branch to a leaf.
return
/**
* perform the work described in the postcommit work.
* <p>
* in this implementation the only work that can be executed by this
* post commit processor is this class itself.
* <p>
*
* @return returns serviceable.done when work has completed, or
*         returns serviceable.requeue if work needs to be requeued.
*
* @param contextmgr the context manager started by the
*         post commit daemon
*
* @exception  standardexception  standard exception policy.
**/
public int performwork contextmanager contextmgr
throws standardexception
// requeue if work was not completed in this try because of locks
boolean             requeue_work   false
transactionmanager tc                transactionmanager
this access_factory getandnametransaction
contextmgr  accessfactoryglobals sys_trans_name
transactionmanager internal_xact    tc getinternaltransaction
if  sanitymanager debug
if  sanitymanager debug_on
system out println
openbtree open_btree   new openbtree
try
// get lock on base table.
// the current space reclamation algorithm requires a table level
// lock on the btree - this is mostly because the shrink algorithm
// is not multi-user.  this lock is requested nowait as it does
// not want to impedede normal operation on the table.  if the lock
// were to wait then the current lock manager livelock algorithm
// would block all subsequent lock requests on this btree even if
// they are compatible with the current holder of the lock.
//
// there are currently 3 outstanding enhancement requests:
// track 4237 - retry the work intelligently
// track 4238 - if can't get table lock, at least reclaim the rows
// track 4239 - do row level lock shrink - very hard to do.
//
conglomeratecontroller base_cc
btree locktable
internal_xact
containerhandle mode_forupdate
containerhandle mode_lock_nowait
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
open_btree init
transactionmanager  null
internal_xact
containerhandle  null               open the container
internal_xact getrawstorexact
false
containerhandle mode_forupdate
transactioncontroller mode_table
btree getbtreelockingpolicy
internal_xact getrawstorexact
transactioncontroller mode_table
lockingpolicy mode_container
transactioncontroller isolation_repeatable_read
base_cc
open_btree
btree
logicalundo  null                  no logical undo necessry
dynamiccompiledopenconglominfo  null
datavaluedescriptor shrink_key
purgecommitteddeletes open_btree  this page_number
// resolve (mikem) - move this call when doing row level locking.
if  shrink_key    null
doshrink open_btree  shrink_key
open_btree close
catch  standardexception se
//2 kinds of errors here expected here.  either container not found or dead lock.
// it is possible by the time this post commit work gets scheduled
// that the container has been dropped and that the open container
// call will return null - in this case just return assuming no
// work to be done.
//if it is a locking error, work is requeued. (4237)
if  se getmessageid   equals sqlstate lock_timeout
se getmessageid   equals sqlstate deadlock
requeue_work   true
//ressolve-mike (4238) if you can't get a table level lock for btree space recovery in
//the post commit thread, maybe you should at least reclaim the
//rows on the page while you are at it.  use the same algorithm
//as exists in btreecontroller.java.  row level shrink is still a
//big problem and a separate track exists for it.
finally
internal_xact commit
internal_xact destroy
return requeue_work ? serviceable requeue   serviceable done
private final datavaluedescriptor getshrinkkey
openbtree   open_btree
controlrow  control_row
int         slot_no
throws standardexception
datavaluedescriptor shrink_key
open_btree getconglomerate   createtemplate
open_btree getrawtran
control_row page fetchfromslot
recordhandle  null
slot_no  shrink_key
fetchdescriptor  null
true
return shrink_key
/**
* reclaim space taken up by committed deleted rows.
* <p>
* this routine assumes it has been called by an internal transaction which
* has performed no work so far, and that it has an exclusive table lock.
* these assumptions mean that any deleted rows encountered must be from
* committed transactions (otherwise we could not have gotten the exclusive
* table lock).
* <p>
* resolve (mikem) - under row locking this routine must do more work to
* determine a deleted row is a committed deleted row.
*
* @param open_btree the btree already opened.
* @param pageno the page number of the page to look for committed deletes.
*
* @exception  standardexception  standard exception policy.
**/
private final datavaluedescriptor purgecommitteddeletes
openbtree           open_btree
long                pageno
throws standardexception
controlrow              control_row   null
datavaluedescriptor	shrink_key    null
try
// the following can fail either if it can't get the latch or
// somehow the page requested no longer exists.  in either case
// the post commit work will just skip it.
control_row   controlrow getnowait open_btree  pageno
if  control_row    null
page page     control_row page
// the number records that can be reclaimed is:
// total recs - control row - recs_not_deleted
int num_possible_commit_delete
page recordcount     1   page nondeletedrecordcount
if  num_possible_commit_delete > 0
// loop backward so that purges which affect the slot table
// don't affect the loop (ie. they only move records we
// have already looked at).
for  int slot_no   page recordcount     1
slot_no > 0
slot_no
if  page isdeletedatslot slot_no
if  page recordcount      2
// about to purge last row from page so
// remember the key so we can shrink the
// tree.
shrink_key   this getshrinkkey
open_btree  control_row  slot_no
page purgeatslot slot_no  1  true
if  sanitymanager debug
if  sanitymanager debug_on
system.out.println(
slot_no
pageno
if  page recordcount      1
if  sanitymanager debug
if  sanitymanager debug_on
system out println
else
if  sanitymanager debug
if  sanitymanager debug_on
system.out.println(
pageno
finally
if  control_row    null
control_row release
return shrink_key