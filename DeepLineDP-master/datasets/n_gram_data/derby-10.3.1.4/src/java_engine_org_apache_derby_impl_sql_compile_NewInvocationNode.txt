/*
derby - class org.apache.derby.impl.sql.compile.newinvocationnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services loader classinspector
import org apache derby iapi services context contextmanager
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services compiler localfield
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi services i18n messageservice
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi reference sqlstate
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi util jbitset
import org apache derby catalog aliasinfo
import java lang reflect member
import java lang reflect modifier
import java util vector
import java util enumeration
/**
* a newinvocationnode represents a new object() invocation.
*
*/
public class newinvocationnode extends methodcallnode
// whether or not to do a single instantiation
private boolean singleinstantiation   false
private boolean delimitedidentifier
/**
* initializer for a newinvocationnode. parameters are:
*
* <ul>
* <li>javaclassname		the full package.class name of the class</li>
* <li>parameterlist		the parameter list for the constructor</li>
* </ul>
*
* @exception standardexception		thrown on error
*/
public void init
object javaclassname
object params
object delimitedidentifier
throws standardexception
super init
addparms  vector  params
this javaclassname    string  javaclassname
this delimitedidentifier
boolean  delimitedidentifier  booleanvalue
/* this version of the "init" method is used for mapping a table name
* or table function name to a corresponding vti class name.  the vti
* is then invoked as a regular new invocation node.
*
* there are two kinds of vti mappings that we do: the first is for
* "table names", the second is for "table function names".  table
* names can only be mapped to vtis that do not accept any arguments;
* any vti that has at least one constructor which accepts one or more
* arguments must be mapped from a table *function* name.  the way we
* tell the difference is by looking at the received arguments: if
* the vtitablefuncname that we receive is null then we are mapping
* a "table name" and tabledescriptor must be non-null; if the
* vtitablefuncname is non-null then we are mapping a "table
* function name" and tabledescriptor must be null.
*
* note that we could have just used a single "init()" method and
* performed the mappings based on what type of object "javaclassname"
* was (string, tabledescriptor, or tablename), but making this vti
* mapping method separate from the "normal" init() method seems
* cleaner...
*
* @param vtitablefuncname a tablename object holding a qualified name
*  that maps to a vti which accepts arguments.  if vtitablefuncname is
*  null then tabledescriptor must not be null.
* @param tabledescriptor a table descriptor that corresponds to a
*  table name (as opposed to a table function name) that will be
*  mapped to a no-argument vti.  if tabledescriptor is null then
*  vtitablefuncname should not be null.
* @param params parameter list for the vti constructor.
* @param delimitedidentifier whether or not the target class name
*  is a delimited identifier.
*/
public void init
object vtitablefuncname
object tabledescriptor
object params
object delimitedidentifier
throws standardexception
super init
addparms  vector  params
if  sanitymanager debug
// exactly one of vtitablefuncname or tabledescriptor should
// be null.
sanitymanager assert
vtitablefuncname    null      tabledescriptor    null
vtitablefuncname    null      tabledescriptor    null
tablename vtiname    tablename vtitablefuncname
tabledescriptor td    tabledescriptor tabledescriptor
boolean istablefunctionvti    vtitablefuncname    null
if  istablefunctionvti
// we have to create a generic tabledescriptor to
// pass to the data dictionary.
td   new tabledescriptor getdatadictionary
vtiname gettablename
getschemadescriptor vtiname getschemaname
tabledescriptor vti_type
tabledescriptor default_lock_granularity
/* use the table descriptor to figure out what the corresponding
* vti class name is; we let the data dictionary do the mapping
* for us.
*/
this javaclassname   getdatadictionary   getvticlass
td  istablefunctionvti
/* if javaclassname is still null at this point then we
* could not find the target class for the received table
* (or table function) name.  so throw the appropriate
* error.
*/
if  this javaclassname    null
if   istablefunctionvti
/* create a tablename object from the table descriptor
* that we received.  this gives us the name to use
* in the error message.
*/
vtiname   maketablename td getschemaname
td getdescriptorname
throw standardexception newexception
istablefunctionvti
? sqlstate lang_no_such_method_alias
sqlstate lang_table_not_found
vtiname getfulltablename
this delimitedidentifier
boolean  delimitedidentifier  booleanvalue
/**
* mark this node as only needing to
* to a single instantiation.  (we can
* reuse the object after newing it.)
*/
void setsingleinstantiation
singleinstantiation   true
/**
*	get the resolved classes of our parameters
*
*	@return	the classes of our parameters
*/
public	class	getmethodparameterclasses
classinspector ci   getclassfactory   getclassinspector
class	parmtypeclasses   new class
for  int i   0  i < methodparms length  i
string classname   methodparametertypes
try
parmtypeclasses   ci getclass classname
catch  classnotfoundexception cnfe
/* we should never get this exception since we verified
* that the classes existed at bind time.  just return null.
*/
if  sanitymanager debug
sanitymanager throwassert    cnfe
return null
return parmtypeclasses
/**
* bind this expression.  this means binding the sub-expressions,
* as well as figuring out what the return type is for this expression.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	nothing
*
* @exception standardexception		thrown on error
*/
public javavaluenode bindexpression
fromlist fromlist  subquerylist subquerylist
vector aggregatevector
throws standardexception
bindparameters fromlist  subquerylist  aggregatevector
verifyclassexist javaclassname
/*
** get the parameter type names out of the parameters and put them
** in an array.
*/
string	parmtypenames   getobjectsignature
boolean	isparam   getisparam
classinspector classinspector   getclassfactory   getclassinspector
/*
** find the matching constructor.
*/
try
/* first try with built-in types and mappings */
method   classinspector findpublicconstructor javaclassname
parmtypenames  null  isparam
/* if no match, then retry to match any possible combinations of
* object and primitive types.
*/
if  method    null
string primparmtypenames   getprimitivesignature false
method   classinspector findpublicconstructor javaclassname
parmtypenames  primparmtypenames  isparam
catch  classnotfoundexception e
/*
** if one of the classes couldn't be found, just act like the
** method couldn't be found.  the error lists all the class names,
** which should give the user enough info to diagnose the problem.
*/
method   null
if  method    null
/* put the parameter type names into a single string */
string	parmtypes
for  int i   0  i < parmtypenames length  i
if  i    0
parmtypes
parmtypes     parmtypenames length      0 ?
parmtypenames
messageservice gettextmessage
sqlstate lang_untyped
throw standardexception newexception sqlstate lang_no_constructor_found
javaclassname
parmtypes
methodparametertypes   classinspector getparametertypes method
for  int i   0  i < methodparametertypes length  i
if  classinspector primitivetype methodparametertypes
methodparms casttoprimitive true
/* set type info for any null parameters */
if   someparametersarenull
setnullparameterinfo methodparametertypes
/* constructor always returns an object of type javaclassname */
if  sanitymanager debug
sanitymanager assert javaclassname equals classinspector gettype method
javaclassname
classinspector gettype method
setjavatypename  javaclassname
return this
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode.
* @exception standardexception		thrown on error
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
throws standardexception
/* we stop here when only considering simple predicates
*  as we don't consider new opeators when looking
* for null invariant predicates.
*/
if  simplepredsonly
return false
boolean pushable   true
pushable   pushable    super categorize referencedtabs  simplepredsonly
return pushable
/**
* build a jbitset of all of the tables that we are
* correlated with.
*
* @param correlationmap	the jbitset of the tables that we are correlated with.
*/
void getcorrelationtables jbitset correlationmap
throws standardexception
collectnodesvisitor getcrs   new collectnodesvisitor columnreference class
super accept getcrs
vector colrefs   getcrs getlist
for  enumeration e   colrefs elements    e hasmoreelements
columnreference ref    columnreference e nextelement
if  ref getcorrelated
correlationmap set ref gettablenumber
/**
* is this class assignable to the specified class?
* this is useful for the vti interface where we want to see
* if the class implements java.sql.resultset.
*
* @param toclassname	the java class name we want to assign to
*
* @return boolean		whether or not this class is assignable to
*						the specified class
*
* @exception standardexception		thrown on error
*/
protected boolean assignableto string toclassname  throws standardexception
classinspector classinspector   getclassfactory   getclassinspector
return classinspector assignableto javaclassname  toclassname
/**
* is this class have a public method with the specified signiture
* this is useful for the vti interface where we want to see
* if the class has the option static method for returning the
* resultsetmetadata.
*
* @param methodname	the method name we are looking for
* @param staticmethod	whether or not the method we are looking for is static
*
* @return member		the member representing the method (or null
*						if the method doesn't exist).
*
* @exception standardexception		thrown on error
*/
protected member findpublicmethod string methodname  boolean staticmethod
throws standardexception
member publicmethod
/*
** get the parameter type names out of the parameters and put them
** in an array.
*/
string	parmtypenames   getobjectsignature
boolean	isparam   getisparam
classinspector classinspector   getclassfactory   getclassinspector
try
publicmethod   classinspector findpublicmethod javaclassname  methodname
parmtypenames  null  isparam  staticmethod  false
/* if no match, then retry to match any possible combinations of
* object and primitive types.
*/
if  publicmethod    null
string primparmtypenames   getprimitivesignature false
publicmethod   classinspector findpublicmethod javaclassname
methodname  parmtypenames
primparmtypenames  isparam  staticmethod  false
catch  classnotfoundexception e
/* we should always be able to find the class at this point
* since the protocol is to check to see if it exists
* before checking for a method off of it.  anyway, just return
* null if the class doesn't exist, since the method doesn't
* exist in that case.
*/
if  sanitymanager debug
sanitymanager throwassert    e
return null
return	publicmethod
/**
* do code generation for this method call
*
* @param acb	the expressionclassbuilder for the class we're generating
* @param mb	the method the expression will go into
*
*
* @exception standardexception		thrown on error
*/
public void generateexpression expressionclassbuilder acb
methodbuilder mb
throws standardexception
/* if this node is for an ungrouped aggregator,
* then we generate a conditional
* wrapper so that we only new the aggregator once.
*		(fx == null) ? fx = new ... : fx
*/
localfield objectfieldlf   null
if  singleinstantiation
/* declare the field */
objectfieldlf   acb newfielddeclaration modifier private  javaclassname
// now we fill in the body of the conditional
mb getfield objectfieldlf
mb conditionalifnull
mb pushnewstart javaclassname
int nargs   generateparameters acb  mb
mb pushnewcomplete nargs
if  singleinstantiation
mb putfield objectfieldlf
mb startelsecode
mb getfield objectfieldlf
mb completeconditional