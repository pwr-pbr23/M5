/*
derby - class org.apache.derby.impl.sql.catalog.dd_version
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql catalog
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io formatable
import org apache derby iapi error standardexception
import org apache derby iapi sql dictionary catalogrowfactory
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary spsdescriptor
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary aliasdescriptor
import org apache derby iapi types datavaluefactory
import org apache derby iapi types rowlocation
import org apache derby iapi reference sqlstate
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi sql dictionary indexrowgenerator
import org apache derby iapi store access scancontroller
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute execindexrow
import org apache derby iapi services io storedformatids
import org apache derby iapi services io formatablebitset
import org apache derby iapi services info productgenusnames
import org apache derby iapi services info productversionholder
import org apache derby iapi reference jdbc30translation
import org apache derby iapi reference limits
import org apache derby iapi util idutil
import org apache derby iapi services uuid uuidfactory
import org apache derby catalog uuid
import org apache derby catalog types routinealiasinfo
import org apache derby catalog aliasinfo
import org apache derby catalog typedescriptor
import org apache derby iapi types datatypedescriptor
import java io ioexception
import java io objectinput
import java io objectoutput
import java sql types
import java util enumeration
import java util properties
/**
* generic code for upgrading data dictionaries.
* currently has all minor version upgrade logic.
* <p>
* a word about minor vs. major upgraded.  minor
* upgrades must be backwards/forwards compatible.
* so they cannot version classes or introduce new
* classes.  major releases are only backwards compatible;
* they will run against an old database, but not the
* other way around.  so they can introduce new classes,
* etc.
*
*/
public	class dd_version implements	formatable
{
////////////////////////////////////////////////////////////////////////
//
//	state
//
////////////////////////////////////////////////////////////////////////
private		transient	datadictionaryimpl	bootingdictionary
int majorversionnumber
private int minorversionnumber
////////////////////////////////////////////////////////////////////////
//
//	constructors
//
////////////////////////////////////////////////////////////////////////
/**
*	public niladic constructor needed for formatable interface.
*/
public	dd_version
/**
* construct a version for the currently booting data dictionary.
* the minor version is set by the subclass.
*
* @param	bootingdictionary	the booting dictionary that needs to be upgraded.
*/
dd_version  datadictionaryimpl bootingdictionary  int majorversionnumber
{
this majorversionnumber   majorversionnumber
this minorversionnumber   getjbmsminorversionnumber
this bootingdictionary   bootingdictionary
}
////////////////////////////////////////////////////////////////////////
//
//	override object methods
//
////////////////////////////////////////////////////////////////////////
/**
*	stringify this version.
*
*	@return	string representation of this version.
*/
public	string	tostring
{
return dd_version majortostring majorversionnumber
}
private static string majortostring int majorversionnumber
switch  majorversionnumber
case datadictionary dd_version_cs_5_0
return
case datadictionary dd_version_cs_5_1
return
case datadictionary dd_version_cs_5_2
return
case datadictionary dd_version_cs_8_1
return
case datadictionary dd_version_cs_10_0
return
case datadictionary dd_version_derby_10_1
return
case datadictionary dd_version_derby_10_2
return
case datadictionary dd_version_derby_10_3
return
default
return null
}
}
////////////////////////////////////////////////////////////////////////
//
//	datadictionary specific
//
////////////////////////////////////////////////////////////////////////
/**
* upgrade the data dictionary catalogs to the version represented by this
* dd_version.
*
* @param dictionaryversion the version of the data dictionary tables.
* @exception standardexception ooops
*/
void upgradeifneeded dd_version dictionaryversion
transactioncontroller tc  properties startparams
throws standardexception
{
// database has been upgrade with a later engine version than this?
if  dictionaryversion majorversionnumber > majorversionnumber
throw standardexception newexception sqlstate lang_cant_upgrade_catalogs
dictionaryversion  this
}
boolean minoronly   false
boolean performmajorupgrade   false
boolean softupgraderun   false
boolean isreadonly   bootingdictionary af isreadonly
if  dictionaryversion majorversionnumber    majorversionnumber
// exact match of engine to database, do nothing.
if  dictionaryversion minorversionnumber    minorversionnumber
return
// database and engine at same major level
minoronly   true
else
if  monitor isfullupgrade startparams  dictionaryversion tostring
performmajorupgrade   true
else
softupgraderun   true
}
}
// make sure we have a clean transaction for the upgrade
tc commit
if  performmajorupgrade
// real upgrade changes. get user name of current user.
string username   idutil getusernamefromurlprops startparams
dofullupgrade tc  dictionaryversion majorversionnumber idutil getuserauthorizationid username
}
if   minoronly     isreadonly
// apply changes that can be made and will continue to work
// against previous version.
// see if we have already applied these changes.
dd_version softupgradeversion    dd_version  tc getproperty
datadictionary soft_data_dictionary_version
// need to apply them if we have never performed a soft upgrade
// or only a soft upgrade using a previous version.
int softupgrademajorversion   0
if  softupgradeversion    null
softupgrademajorversion   softupgradeversion majorversionnumber
if  softupgrademajorversion < majorversionnumber
applysafechanges  tc  dictionaryversion majorversionnumber  softupgrademajorversion
}
}
// changes such as invalidating sps so they will recompile against
// the new internal classes.
// this method also changes the on-disk format version on the disk and in-memory as well.
handleminorrevisionchange tc  dictionaryversion  softupgraderun
// commit any upgrade
tc commit
}
/**
apply changes that can safely be made in soft upgrade.
any changes must not prevent the database from being re-booted
by the a derby engine at the older version frommajorversionnumber.
<br>
examples are fixes to catalog meta data, e.g. fix nullability of
a system column.
<br>
<b>upgrade items for 10.1</b>
<ul>
<li> none.
</ul>
*
* @param	tc	transaction controller
* @param	frommajorversionnumber	version of the on-disk database
@param  lastsoftupgradeversion last engine to perform a soft upgrade that made changes.
*
*	@exception standardexception  standard derby error policy.
*/
private	void	applysafechanges transactioncontroller tc  int frommajorversionnumber  int lastsoftupgradeversion
throws standardexception
{
/*
* old cloudscape 5.1 upgrade code, derby does not support
* upgrade from cloudscape 5.x databases. if it ever is changed
* to do so, this code would be useful.
*
*
if (lastsoftupgradeversion <= datadictionary.dd_version_cs_5_1)
{
// all these soft upgrade actions are new in 5.2 (first ever soft upgrade)
if (frommajorversionnumber <= datadictionary.dd_version_cs_5_0)
modifysystablenullability(tc,
datadictionaryimpl.sysaliases_catalog_num);
if (frommajorversionnumber <= datadictionary.dd_version_cs_5_1)
modifysystablenullability(tc,
datadictionaryimpl.sysstatements_catalog_num);
}
*/
/*
* derby soft upgrade code
*/
if  lastsoftupgradeversion <  datadictionary dd_version_derby_10_2
{
if  frommajorversionnumber <  datadictionary dd_version_derby_10_2
{
modifysystablenullability(tc,
datadictionaryimpl.sysstatements_catalog_num);
modifysystablenullability(tc,
datadictionaryimpl sysviews_catalog_num
}
}
tc setproperty datadictionary soft_data_dictionary_version  this  true
}
/**
do full upgrade.  apply changes that can not be safely made in soft upgrade.
<br>
<b>upgrade items for every new release</b>
<ul>
<li> drop and recreate the stored versions of the jdbc database metadata queries
</ul>
<br>
<b>upgrade items for 10.1</b>
<ul>
<li> none.
</ul>
*
* @param	tc	transaction controller
* @param	frommajorversionnumber	version of the on-disk database
* @param	aid	 authorizationid of current user to be made database owner
*
*	@exception standardexception  standard derby error policy.
*/
private	void	dofullupgrade transactioncontroller tc  int frommajorversionnumber  string aid
throws standardexception
{
// only supports upgrade from derby 10.0 releases onwards
if  frommajorversionnumber < datadictionary dd_version_cs_10_0
{
throw standardexception newexception sqlstate upgrade_unsupported
dd_version majortostring frommajorversionnumber   this
}
//drop and recreate the stored versions of the jdbc database metadata queries
//this is to make sure that we have the stored versions of jdbc database
//metadata queries matching with this release of the engine.
dropjdbcmetadataspses tc  false
bootingdictionary.createsystemsps(tc);
/*
* old cloudscape 5.1 upgrade code, derby does not support
* upgrade from cloudscape 5.x databases. if it ever is changed
* to do so, this code would be useful.
if (frommajorversionnumber <= datadictionary.dd_version_cs_5_1)
{
// drop sps in sysibm, sysibm, recreate sysibm, sysdummy1, populate sysdummy1, create procs
dropjdbcmetadataspses(tc, true);
schemadescriptor sd = bootingdictionary.getschemadescriptor("sysibm", null, false);
if (sd != null)
bootingdictionary.dropschemadescriptor("sysibm", tc);
sd = bootingdictionary.getsysibmschemadescriptor();
bootingdictionary.adddescriptor(sd, null, datadictionary.sysschemas_catalog_num, false, tc);
bootingdictionary.upgrademakecatalog(tc, datadictionary.sysdummy1_catalog_num);
bootingdictionary.populatesysdummy1(tc);
bootingdictionary.create_sysibm_procedures(tc);
bootingdictionary.createsystemsps(tc);
}
*/
if  frommajorversionnumber <  datadictionary dd_version_derby_10_1
{
// add catalogs 1st, subsequent procedure adding may depend on
// catalogs.
// add new system catalogs created for grant and revoke
bootingdictionary upgrademakecatalog
tc  datadictionary systableperms_catalog_num
bootingdictionary upgrademakecatalog
tc  datadictionary syscolperms_catalog_num
bootingdictionary upgrademakecatalog
tc  datadictionary sysroutineperms_catalog_num
}
if  frommajorversionnumber    datadictionary dd_version_cs_10_0
{
// this upgrade depends on the sysutil schema, which only exists
// since 10.0.  will not work to upgrade any db previous to 10.0,
// thus only checks for 10.0 rather than <= 10.0.
bootingdictionary create_10_1_system_procedures
tc
bootingdictionary getsystemutilschemadescriptor   getuuid
}
if  frommajorversionnumber <  datadictionary dd_version_derby_10_1
{
// on ugrade from versions before 10.2, create system procedures
// added in 10.2.
bootingdictionary create_10_2_system_procedures
tc
bootingdictionary getsystemutilschemadescriptor   getuuid
if  sanitymanager debug
{
sanitymanager assert  aid    null
}
// change system schemas to be owned by aid
bootingdictionary updatesystemschemaauthorization aid  tc
// grant public access to some system routines
bootingdictionary grantpublicaccesstosystemroutines tc  aid
}
if  frommajorversionnumber <  datadictionary dd_version_derby_10_2
{
// on ugrade from versions before 10.3, create system procedures
// added in 10.3.
bootingdictionary create_10_3_system_procedures tc
}
}
/**
* do any work needed for a minor revision change.
* for the data dictionary this is always invalidating
* stored prepared statements.  when we are done
* with the upgrade, we always recompile all spses
* so the customer doesn't have to (and isn't going
* to get deadlocks because of the recomp).
*
* @param tc the xact
*
* @exception standardexception  standard derby error policy.
*/
private void handleminorrevisionchange transactioncontroller tc  dd_version fromversion  boolean softupgraderun
throws standardexception
{
boolean isreadonly   bootingdictionary af isreadonly
if   isreadonly
bootingdictionary clearspsplans
dd_version lastrun
if  softupgraderun
{
// log a version that will cause a minor revision change
// for any subsequent re-boot, including an old cloudscape version
fromversion minorversionnumber   1     see getjbmsminorversionnumber
lastrun   fromversion
}
else
{
// log the new version
lastrun   this
// and change the in-memory version.
fromversion majorversionnumber   majorversionnumber
fromversion minorversionnumber   minorversionnumber
}
tc setproperty datadictionary core_data_dictionary_version  fromversion  true
}
else
{
// for a readonly database where we need some kind of upgrade
// (either minor release or soft upgrade) then since we cannot
// invalidate all the procedures we need to indicate that
// any procedure we read off disk is automatically invalid,
// so we do not try to load the generated class.
bootingdictionary readonlyupgrade   true
}
bootingdictionary clearcaches
}
/**
* drop all jdbc metadata spses.  this
* it to ensure that we don't have any problems
* with old metadata queries that have outdated
* query text (the plans are always cleared out
* on upgrade time).
*
* @param tc the xact
* @param removesysibmonly if <code>true</code>, remove stored
* prepared statements in the sysibm schema only; otherwise,
* remove stored prepared statements in all system schemas
* (including sysibm)
*
* @exception standardexception  standard derby error policy.
*/
protected void dropjdbcmetadataspses transactioncontroller tc  boolean removesysibmonly
throws standardexception
{
for  java util iterator it   bootingdictionary getallspsdescriptors   iterator    it hasnext
{
spsdescriptor spsd    spsdescriptor  it next
schemadescriptor sd   spsd getschemadescriptor
// need to compare the name, old sysibm is not built-in
boolean issysibm   sd getschemaname   equals schemadescriptor ibm_system_schema_name
// don't drop statements in non-system schemas
if   sd issystemschema       issysibm
continue
}
// don't drop statements outside the sysibm schema if
// we're told not to
if  removesysibmonly     issysibm
continue
}
bootingdictionary dropspsdescriptor spsd  tc
bootingdictionary dropdependentsstoreddependencies spsd getuuid
tc
}
}
/**
* make a catalog.
*	@param	tc	transactioncontroller
*	@exception standardexception  standard derby error policy.
*/
protected void makesystemcatalog transactioncontroller tc
tabinfoimpl ti
throws standardexception
{
schemadescriptor sd   bootingdictionary getsystemschemadescriptor
bootingdictionary makecatalog ti sd tc
}
/**
remove the description of a system table from the data dictionary.
this does not delete the conglomerates that hold the catalog or
its indexes.
@param	tc transactioncontroller
@param    td table descriptor for the catalog to drop.
@exception standardexception  standard derby error policy.
*/
protected void
dropsystemcatalogdescription transactioncontroller tc  tabledescriptor td
throws standardexception
{
/* drop the columns */
bootingdictionary dropallcolumndescriptors td getuuid    tc
/* drop the conglomerate descriptors */
bootingdictionary dropallconglomeratedescriptors td  tc
/* drop table descriptor */
bootingdictionary droptabledescriptor  td  td getschemadescriptor    tc
bootingdictionary clearcaches
}
/**
* drop a system catalog.
*	@param	tc	transactioncontroller
*  @param  crf catalogrowfactory for the catalog to drop.
*	@exception standardexception  standard derby error policy.
*/
protected void dropsystemcatalog transactioncontroller tc
catalogrowfactory crf
throws standardexception
{
schemadescriptor		sd   bootingdictionary getsystemschemadescriptor
tabledescriptor			td   bootingdictionary gettabledescriptor
crf getcatalogname
sd
conglomeratedescriptor	cds   td getconglomeratedescriptors
for  int index   0  index < cds length  index
{
tc dropconglomerate cds getconglomeratenumber
}
dropsystemcatalogdescription tc td
}
/**
* populates a new system index from the base system table.
*
*	@param	tc						transaction controller
*	@param	heapconglomeratenumber	identifies system table to store
*	@param	tabinfo					describes base system table
*	@param	indexnumber				index to populate
*
*
* @exception standardexception		thrown on failure
*/
protected	void	fillindex
transactioncontroller	tc
long					heapconglomeratenumber
tabinfoimpl					tabinfo
int						indexnumber
throws standardexception
{
long						indexconglomeratenumber   tabinfo getindexconglomerate  indexnumber
indexrowgenerator			indexrowgenerator   tabinfo getindexrowgenerator  indexnumber
catalogrowfactory			rowfactory   tabinfo getcatalogrowfactory
execrow						heaprow   rowfactory makeemptyrow
execindexrow				indexablerow   indexrowgenerator getindexrowtemplate
scancontroller				heapscan
tc openscan
heapconglomeratenumber           conglomerate to open
false                              don't hold open across commit
0                                  for read
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
formatablebitset  null                     all fields as objects
null                               start position   first row
scancontroller ge                  startsearchoperation
null                              scanqualifier
null                              stop position through last row
scancontroller gt                  stopsearchoperation
rowlocation					heaplocation
heapscan newrowlocationtemplate
conglomeratecontroller		indexcontroller
tc openconglomerate
indexconglomeratenumber
false
transactioncontroller openmode_forupdate
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
while   heapscan fetchnext heaprow getrowarray
{
heapscan fetchlocation  heaplocation
indexrowgenerator getindexrow  heaprow  heaplocation  indexablerow   formatablebitset  null
indexcontroller insert indexablerow getrowarray
}
indexcontroller close
heapscan close
}
////////////////////////////////////////////////////////////////////////
//
//	formatable interface
//
////////////////////////////////////////////////////////////////////////
/**
* get the formatid which corresponds to this class.
map to the 5.0 version identifier so that 5.0 will understand
this object when we write it out in soft upgrade mode.
cs 5.0 will de-serialize it correctly.
when we are writing out a 5.1 version number we write out
the 5.1 version just to ensure no problems.
*
*	@return	the formatid of this class
*/
public	int	gettypeformatid
return majorversionnumber    datadictionary dd_version_cs_5_1 ?
storedformatids dd_arwen_version_id   storedformatids dd_db2j72_version_id
}
/**
* read this object from a stream of stored objects. set
* the minor version.  ignore the major version.
*
* @param in read this.
*
* @exception ioexception on error
*/
public final void readexternal  objectinput in   throws ioexception
{
majorversionnumber   in readint
minorversionnumber   in readint
}
/**
* write this object to a stream of stored objects. write
* out the minor version which is bumped across minor release.
* just to be safe, write out the major version too.  this
* will allow us to do versioning of a specific version impl
* in the future.
*
* @param out write bytes here.
*
* @exception ioexception on error
*/
public final void writeexternal  objectoutput out   throws ioexception
{
out writeint majorversionnumber
out writeint minorversionnumber
}
/**
* get the minor version from the jbms product minor version/maint version.
* bumps it up by 1 if production, or 0 if beta to ensure
* minor upgrade across beta.  starts at 2 because of an
* old convention. we use this starting at 2 to allow soft upgrade to
* write a version of 1 with the old major number to ensure a minor upgrade
when reverting to an old version afer a soft upgrade. e.g run with 5.0.2,
then 5.2.1.1, then 5.0.2. want to ensure 5.0.2 does the minor upgrade.
*
* @return the minor version
for 5.0 and 5.1 the minor number was calculated as
jbmsversion.getminorversion()*100 +jbmsversion.getmaintversion() + (jbmsversion.isbeta() ? 0 : 1) + 2
5.0.22 => (0*100) + 22 + 2 =  24 - (5.0 has a unique major number)
5.1.2  => (1*100) + 2 + 2  = 104 - (5.1 has a unique major number)
with the switch to the four part scheme in 5.2, the maint number now is in increments of one million,
thus the above scheme could lead to duplicate numbers. note that the major number may not change
when the minor external release changes, e.g. 5.2 and 5.3 could share a dd_version major number.
5.2.1.100 => (2*100) + 1000100 + 2 = 1000302
5.3.1.0   => (3*100) + 1000000 + 2 = 1000302
*/
private int getjbmsminorversionnumber
{
productversionholder jbmsversion   monitor getmonitor   getengineversion
return jbmsversion getminorversion   100  jbmsversion getmaintversion      jbmsversion isbeta   ? 0   1    2
}
/**
*
* modifies the nullability of the system table corresponding
* to the received catalog number.
*
* @param tc			transactioncontroller.
* @param catalognum	the catalog number corresponding
*  to the table for which we will modify the nullability.
*
*  old cloudscape 5.1 upgrade code
*  if this corresponds to sysaliases, then the nullability of
*  the sysaliases.aliasinfo column will be changed to true
*  (beetle 4430).  if this corresponds to sysstatements,
*  the nullability of the sysstatements.lastcompiled
*  column will be changed to true.
*
*  derby upgrade code
*  if this corresponds to sysstatements, then the nullability of
*  the sysstatements.compilation_schemaid column will
*  be changed to true.  if this corresponds to sysviews, the nullability
*  of the sysviews.compilation_schemaid column will be changed to true.
*
* @exception standardexception   thrown on error
*/
private void modifysystablenullability transactioncontroller tc  int catalognum
throws standardexception
{
tabinfoimpl ti   bootingdictionary getnoncoretibynumber catalognum
catalogrowfactory rowfactory   ti getcatalogrowfactory
if  catalognum    datadictionaryimpl sysstatements_catalog_num
{
// sysstatements table ==> sysstatements_compilation_schemaid needs
// to be modified.
bootingdictionary.upgrade_setnullability(rowfactory,
sysstatementsrowfactory sysstatements_compilation_schemaid
true  tc
}
else if  catalognum    datadictionaryimpl sysviews_catalog_num
{
// sysviews table ==> sysviews_compilation_schemaid needs
// to be modified.
bootingdictionary.upgrade_setnullability(rowfactory,
sysviewsrowfactory sysviews_compilation_schemaid
true  tc
}
/* old cloudscape 5.1 upgrade code. see applysafechanges().
if (catalognum == datadictionaryimpl.sysaliases_catalog_num) {
// sysaliases table ==> aliasinfo needs to be modified.
bootingdictionary.upgrade_setnullability(rowfactory,
sysaliasesrowfactory.sysaliases_aliasinfo, true, tc);
}
else if (catalognum == datadictionaryimpl.sysstatements_catalog_num) {
// sysstatements table ==> lastcompiled needs to be modified.
bootingdictionary.upgrade_setnullability(rowfactory,
sysstatementsrowfactory.sysstatements_lastcompiled, true, tc);
}
*/
}
/**
check to see if a database has been upgraded to the required
level in order to use a language feature.
@param requiredmajorversion data dictionary major version
@param feature non-null to throw an error, null to return the state of the version match.
@return true if the database has been upgraded to the required level, false otherwise.
*/
boolean checkversion int requiredmajorversion  string feature  throws standardexception
if  majorversionnumber < requiredmajorversion
if  feature    null
throw standardexception newexception sqlstate lang_statement_upgrade_required  feature
dd_version majortostring majorversionnumber
dd_version majortostring requiredmajorversion
return false
}
return true
}
}