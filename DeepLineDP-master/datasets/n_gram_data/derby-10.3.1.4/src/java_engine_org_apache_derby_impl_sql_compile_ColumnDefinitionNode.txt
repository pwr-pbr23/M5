/*
derby - class org.apache.derby.impl.sql.compile.columndefinitionnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services loader classinspector
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io storedformatids
import org apache derby iapi reference limits
import org apache derby iapi error standardexception
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary aliasdescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql depend providerlist
import org apache derby iapi sql depend providerinfo
import org apache derby iapi reference sqlstate
import org apache derby impl sql execute columninfo
import org apache derby catalog aliasinfo
import org apache derby catalog defaultinfo
import org apache derby catalog uuid
import org apache derby catalog types defaultinfoimpl
import java util vector
import java sql types
/**
* a columndefinitionnode represents a column definition in a ddl statement.
* there will be a columndefinitionnode for each column in a create table
* statement, and for the column in an alter table add column statement.
*
*/
public class columndefinitionnode extends tableelementnode
boolean						isautoincrement
/**
* the data type of this column.
*/
datatypedescriptor			datatypeservices
datavaluedescriptor			defaultvalue
defaultinfoimpl				defaultinfo
defaultnode					defaultnode
long						autoincrementincrement
long						autoincrementstart
//this variable tells if the autoincrement column is participating
//in create or alter table. and if it is participating in alter
//table, then it further knows if it is represting a change in
//increment value or a change in start value.
//this information is later used to make sure that the autoincrement
//column's increment value is not 0 at the time of create, or is not
//getting set to 0 at the time of increment value modification.
long						autoinc_create_or_modify_start_increment
boolean						autoincrementverify
//autoinc_create_or_modify_start_increment will be set to one of the
//following 3 values.
//create_autoincrement - this autoincrement column definition is for create table
public static final int create_autoincrement   0
//modify_autoincrement_restart_value - this column definition is for
//alter table command to change the start value of the column
public static final int modify_autoincrement_restart_value   1
//modify_autoincrement_inc_value - this column definition is for
//alter table command to change the increment value of the column
public static final int modify_autoincrement_inc_value   2
/**
* initializer for a columndefinitionnode
*
* @param name			the name of the column
* @param defaultnode	the default value of the column
* @param datatypeservices	a datatypeservices telling the type
*				of the column
* @param autoincrementinfo	info for autoincrement columns
*
*/
public void init
object name
object defaultnode
object datatypeservices
object autoincrementinfo
throws standardexception
super init name
this datatypeservices    datatypedescriptor  datatypeservices
if  defaultnode instanceof untypednullconstantnode
/* no dts yet for modify default */
if  datatypeservices    null
defaultvalue
untypednullconstantnode  defaultnode
convertdefaultnode this datatypeservices
else
if  sanitymanager debug
if  defaultnode    null
defaultnode instanceof defaultnode
sanitymanager throwassert
defaultnode getclass   getname
this defaultnode    defaultnode  defaultnode
if  autoincrementinfo    null
long aii    long  autoincrementinfo
autoincrementstart   aii
autoincrementincrement   aii
//parser has passed the info about autoincrement column's status in the
//following array element. it will tell if the autoinc column is part of
//a create table or if is a part of alter table. and if it is part of
//alter table, is it for changing the increment value or for changing
//the start value?
autoinc_create_or_modify_start_increment   aii
/*
* if using db2 syntax to set increment value, will need to check if column
* is already created for autoincrement.
*/
autoincrementverify    aii > 0  ? false   true
isautoincrement   true
// an autoincrement column cannot be null-- setting
// non-nullability for this column is needed because
// you could create a column with ai default, add data, drop
// the default, and try to add it back again you'll get an
// error because the column is marked nullable.
if  datatypeservices    null
this datatypeservices  setnullability false
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return     datatypeservices tostring
defaultvalue
super tostring
else
return
/**
* returns the unqualified name of the column being defined.
*
* @return	the name of the column
*/
public string getcolumnname
return this name
/**
* returns the data type services of the column being defined.
*
* @return	the data type services of the column
*/
public final datatypedescriptor getdatatypeservices
return this datatypeservices
/**
* return the datavaluedescriptor containing the default value for this
* column
*
* @return	the default value of the column
*/
public datavaluedescriptor getdefaultvalue
return this defaultvalue
/**
* return the defaultinfo containing the default information for this
* column
*
* @return	the default info for the column
*/
public defaultinfo getdefaultinfo
return defaultinfo
/**
* return the defaultnode, if any, associated with this node.
*
* @return the defaultnode, if any, associated with this node.
*/
public defaultnode getdefaultnode
return defaultnode
/**
* is this an autoincrement column?
*
* @return whether or not this is an autoincrement column.
*/
public boolean isautoincrementcolumn
if  sanitymanager debug
//increment value for autoincrement column can't be 0 if the autoinc column
//is part of create table or it is part of alter table to change the
//increment value.
if  isautoincrement    autoincrementincrement    0
autoinc_create_or_modify_start_increment    columndefinitionnode create_autoincrement
autoinc_create_or_modify_start_increment    columndefinitionnode modify_autoincrement_inc_value
sanitymanager throwassert
if     isautoincrement
autoincrementstart    0    autoincrementincrement    0
sanitymanager throwassert
return isautoincrement
/**
* get the autoincrement start value
*
* @return autoincrement start value.
*/
long getautoincrementstart
if  sanitymanager debug
sanitymanager assert isautoincrement
return autoincrementstart
/**
* get the autoincrement increment value
*
* @return autoincrement increment value.
*/
long getautoincrementincrement
if  sanitymanager debug
sanitymanager assert isautoincrement
return autoincrementincrement
/**
* get the status of this autoincrement column
*
* @return columndefinitionnode.create_autoincrement -
* 		if this definition is for autoincrement column creatoin
*   columndefinitionnode.modify_autoincrement_restart_value -
* 		if this definition is for alter sutoincrement column to change the start value
*   columndefinitionnode.modify_autoincrement_inc_value
* 		if this definition is for alter autoincrement column to change the increment value
*/
long getautoinc_create_or_modify_start_increment
if  sanitymanager debug
sanitymanager assert isautoincrement
return autoinc_create_or_modify_start_increment
/**
* check the validity of a user type.  checks whether this column
* definition describes a user type that either doesn't exist or is
* inaccessible, or that doesn't implement serializable.
*
* @exception standardexception		thrown on error
*/
public void checkusertype tabledescriptor td
throws standardexception
string			columntypename
/* built-in types need no checking */
if   datatypeservices gettypeid   usertype
return
classinspector classinspector   getclassfactory   getclassinspector
columntypename
datatypeservices gettypeid   getcorrespondingjavatypename
/* user type - we first check for the columntypename as a java class.
* if that fails, then we treat it as a class alias.
*/
boolean foundmatch   false
throwable reason   null
try
foundmatch   classinspector accessible columntypename
catch  classnotfoundexception cnfe
reason   cnfe
if   foundmatch
throw standardexception newexception sqlstate lang_type_doesnt_exist  reason  columntypename
name
if    classinspector assignableto columntypename
// before java2, sqldata is not defined, assignableto call returns false
classinspector assignableto columntypename
getcompilercontext   addwarning
standardexception newwarning sqlstate lang_type_not_serializable  columntypename
name
/**
* get the uuid of the old column default.
*
* @return the uuid of the old column default.
*/
uuid getolddefaultuuid
return null
/**
* get the action associated with this node.
*
* @return the action associated with this node.
*/
int getaction
return columninfo create
/**
* check the validity of the default, if any, for this node.
*
* @param dd		the datadictionary.
* @param td		the tabledescriptor.
*
* @exception standardexception		thrown on error
*/
void bindandvalidatedefault datadictionary dd  tabledescriptor td
throws standardexception
/* db2 requires non-nullable columns to have a default in alter table */
if  td    null     datatypeservices isnullable      defaultnode    null
if   isautoincrement
throw standardexception newexception sqlstate lang_db2_not_null_column_invalid_default  getcolumnname
// no work to do if no user specified default
if  defaultnode    null
return
// no work to do if user specified null
if  defaultvalue    null
return
// now validate the default
validatedefault dd  td
/**
* check the validity of the autoincrement values for this node.
* the following errors are thrown by this routine.
* 1. 42z21 invalid increment; i.e 0.
* 2. 42z22 invalid type; autoincrement created on a non-exact-numeric type
* 3. 42995 the requested function does not apply to global temporary tables
*
* @param 		dd		datadictionary.
* @param		td		table descriptor.
* @param		tabletype	base table or declared global temporary table.
*
* @exception 	standardexception if autoincrement default is incorrect; i.e
* 				if increment is 0 or if initial or increment values are out
* 				of range for the datatype.
*/
public void validateautoincrement datadictionary dd  tabledescriptor td  int tabletype
throws standardexception
if  isautoincrement    false
return
if  tabletype    tabledescriptor global_temporary_table_type
throw standardexception newexception sqlstate lang_not_allowed_for_declared_global_temp_table
//increment value for autoincrement column can't be 0 if the autoinc column
//is part of create table or it is part of alter table to change the
//increment value.
if  autoincrementincrement    0
autoinc_create_or_modify_start_increment    columndefinitionnode create_autoincrement
autoinc_create_or_modify_start_increment    columndefinitionnode modify_autoincrement_inc_value
throw standardexception newexception sqlstate lang_ai_invalid_increment  getcolumnname
int jdbctype   datatypeservices gettypeid   getjdbctypeid
switch  jdbctype
case types tinyint
autoincrementcheckrange  long byte min_value
long byte max_value
typeid tinyint_name
break
case types smallint
autoincrementcheckrange  long short min_value
long short max_value
typeid smallint_name
break
case types integer
autoincrementcheckrange  long integer min_value
long integer max_value
typeid integer_name
break
case types bigint
autoincrementcheckrange long min_value  long max_value
typeid longint_name
break
default
throw standardexception newexception sqlstate lang_ai_invalid_type
getcolumnname
/**
* checks to see if autoincrementincrement and autoincrementinitial
* are within the bounds of the type whose min and max values are
* passed into this routine.
*/
private	void autoincrementcheckrange long minvalue  long maxvalue
string typename
throws standardexception
if   minvalue > autoincrementincrement
maxvalue < autoincrementincrement
throw standardexception newexception
sqlstate lang_outside_range_for_datatype  typename
if   minvalue > autoincrementstart
maxvalue < autoincrementstart
throw standardexception newexception
sqlstate lang_outside_range_for_datatype  typename
/**
* check the validity of the default for this node.
*
* @param td		the tabledescriptor.
*
* @exception standardexception		thrown on error
*/
void validatedefault datadictionary dd  tabledescriptor td
throws standardexception
if  defaultnode    null
return
//examin whether default value is autoincrement.
if  isautoincrement
defaultinfo   createdefaultinfoofautoinc
return
//judged as default value is constant value.
compilercontext cc   getcompilercontext
valuenode defaulttree   defaultnode getdefaulttree
/* bind the default.
* verify that it does not contain any columnreferences or subqueries
* and that it is type compatable with the column.
*/
final int previousreliability   cc getreliability
try
/*
defaults cannot have dependencies as they
should just be constants. code used to exist
to handle dependencies in defaults, now this
is under sanity to ensure no dependencies exist.
*/
providerlist apl   null
providerlist prevapl   null
if  sanitymanager debug
apl   new providerlist
prevapl   cc getcurrentauxiliaryproviderlist
cc setcurrentauxiliaryproviderlist apl
// tell the compiler context to only allow deterministic nodes
cc setreliability  compilercontext default_restriction
defaulttree   defaulttree bindexpression
fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
subquerylist  null
vector  null
typeid columntypeid    typeid  datatypeservices gettypeid
typeid defaulttypeid   defaulttree gettypeid
// check for 'invalid default' errors (42894)
// before checking for 'not storable' errors (42821).
if   defaulttypeisvalid columntypeid  datatypeservices
defaulttypeid  defaulttree  defaultnode getdefaulttext
throw standardexception newexception
sqlstate lang_db2_invalid_default_value
this name
// now check 'not storable' errors.
if    gettypecompiler columntypeid
storable defaulttypeid  getclassfactory
throw standardexception newexception sqlstate lang_not_storable
columntypeid getsqltypename
defaulttypeid getsqltypename
// save off the default text
// resolvedefault - convert to constant if possible
defaultinfo   new defaultinfoimpl false
defaultnode getdefaulttext
defaultvalue
if  sanitymanager debug
/* save the apl off in the constraint node */
if  apl size   > 0
sanitymanager throwassert
// restore the previous auxiliaryproviderlist
cc setcurrentauxiliaryproviderlist prevapl
finally
cc setreliability previousreliability
private static defaultinfoimpl createdefaultinfoofautoinc
return new defaultinfoimpl true


/**
* check the validity of the default for this node
*
* @param columntype typeid of the target column.
* @param columndesc description of the type of the
*		target column.
* @param defaulttype typeid of the default node.
* @param defaultnode parsed valuenode for the default value.
* @param defaulttext unparsed default value (as entered
* 		by user).
* @return true if the defaultnode abides by the restrictions
* 	imposed by db2 on default constants; false otherwise.
*
*/
public boolean defaulttypeisvalid typeid columntype
datatypedescriptor columndesc  typeid defaulttype
valuenode defaultnode  string defaulttext
throws standardexception
if  defaulttext length   > limits db2_char_maxwidth
// db2 spec says this isn't allowed.
return false
/* we can use info about the way the parser works
* to guide this process a little (see the getnumericnode()
* method in sqlgrammar.jj):
*
* 1) tinyint and smallints are both parsed as "int" types,
*	  while integers larger than a basic "int" are parsed into
*	  "longint" or, if needed, "decimal".
* 2) floats, doubles, and decimals with fractional parts
*	  are all parsed as "decimal".
* 3) all strings are parsed as "char" constants (no varchar
*	  or any others; see stringliteral() method in
*	  sqlgrammar.jj).
*/
int coltype   columntype gettypeformatid
int deftype    defaulttype    null ?  1   defaulttype gettypeformatid
if   defaultnode isconstantexpression
// then we have a built-in function, such as "user"
// or "current schema".  if the function is a datetime
// value function, then we don't need any special
// action; however, if it's a "user" or "current schema"
// function, then the column must be a char type with
// minimum lengths matching those of db2 (note that
// such limits are only enforced on defaults, not at
// normal insertion time).
boolean charcol     coltype    storedformatids char_type_id
coltype    storedformatids varchar_type_id
coltype    storedformatids longvarchar_type_id
if  defaultnode instanceof specialfunctionnode
switch  defaultnode getnodetype
case c_nodetypes user_node
case c_nodetypes current_user_node
case c_nodetypes session_user_node
case c_nodetypes system_user_node
// db2 enforces min length of 8.
// note also: any size under 30 gives a warning in db2.
return  charcol     columndesc getmaximumwidth   >
limits db2_min_col_length_for_current_user
case c_nodetypes current_schema_node
// db2 enforces min length of 128.
return  charcol     columndesc getmaximumwidth   >
limits db2_min_col_length_for_current_schema
default
// else, function not allowed.
return false
switch  coltype
case storedformatids int_type_id
// db2 doesn't allow floating point values to be used
// as defaults for integer columns (they are allowed
// as part of normal insertions, but not as defaults).
// if the default is an integer that's too big, then
// it won't have type int_type_id (it'll be either
// longint or decimal)--so we only allow the default
// value if it's integer.
return  deftype    storedformatids int_type_id
case storedformatids longint_type_id
// this is a bigint column: we allow smallints, ints,
// and big int constants.  smallint and int literals
// are both covered by int_type; big int literals are
// covered by long_int type.
return   deftype    storedformatids int_type_id
deftype    storedformatids longint_type_id
case storedformatids decimal_type_id
if  deftype    storedformatids decimal_type_id
// only valid if scale and precision are within
// those of the column.  note that scale here should
// exclude any trailing 0's after the decimal
datatypedescriptor defdesc   defaultnode gettypeservices
int len   defaulttext length
int precision   defdesc getprecision
int scale   defdesc getscale
for  int i   1  i <  scale  scale    precision
if  defaulttext charat len   i
break
return   scale <  columndesc getscale
precision   scale  <
columndesc getprecision     columndesc getscale
else if   deftype    storedformatids longint_type_id
deftype    storedformatids int_type_id
// only valid if number of digits is within limits of
// the decimal column.  we'll check this at insertion time;
// see beetle 5585 regarding the need to move that check to
// here instead of waiting until insert time.  until that's
// done, just allow this and wait for insertion...
return true
else
// no other types allowed.
return false
case storedformatids char_type_id
case storedformatids varchar_type_id
case storedformatids longvarchar_type_id
// only valid if the default type is a character string.
// that's not to say that all character defaults are
// valid, but we only check for character string here;
// further checking will be done at insertion time.  see
// beetle 5585 regarding the need to move that check
// to here instead of waiting until insert time.
return  deftype    storedformatids char_type_id
case storedformatids bit_type_id
case storedformatids varbit_type_id
case storedformatids longvarbit_type_id
// only valid if the default type is a bit string.
return  deftype    storedformatids bit_type_id
case storedformatids userdefined_type_id_v3
// default is only valid if it's the same type as the column.
return  deftype    coltype
case storedformatids blob_type_id
case storedformatids clob_type_id
case storedformatids smallint_type_id
case storedformatids real_type_id
case storedformatids double_type_id
case storedformatids date_type_id
case storedformatids time_type_id
case storedformatids timestamp_type_id
// for these types, validity checks will be performed
// by derby at insertion time--see beetle 5585 regarding
// the need to do such checks here instead of later.  for now,
// just assume we're okay.
return true
default
// all other default type checks either
// (tinyint, national_char, etc), or 2) require a db2 cast-
// function (ex. blob(...), which derby doesn't
// support yet--see beetle 5281), and so they are not
// valid for derby running in db2 compatibility mode.
return false