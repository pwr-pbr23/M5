/*
derby - class org.apache.derby.impl.services.monitor.basemonitor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services monitor
import org apache derby iapi services monitor monitor
import org apache derby iapi services monitor modulefactory
import org apache derby iapi services monitor modulecontrol
import org apache derby iapi services monitor modulesupportable
import org apache derby iapi services monitor persistentservice
import org apache derby iapi services io formatidutil
import org apache derby iapi services io registeredformatids
import org apache derby iapi services io storedformatids
import org apache derby iapi services context contextmanager
import org apache derby iapi services context context
import org apache derby iapi services context contextservice
import org apache derby iapi services context shutdownexception
import org apache derby iapi services stream infostreams
import org apache derby iapi services stream printwritergetheader
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi services uuid uuidfactory
import org apache derby iapi services timer timerfactory
import org apache derby iapi reference property
import org apache derby iapi reference sqlstate
import org apache derby iapi reference attribute
import org apache derby iapi services property propertyutil
import org apache derby iapi services io accessiblebytearrayoutputstream
import org apache derby iapi services loader classinfo
import org apache derby iapi services loader instancegetter
import org apache derby iapi services io formatableinstancegetter
import org apache derby iapi error exceptionseverity
import  org apache derby io storagefactory
import org apache derby iapi services context errorstringbuilder
import org apache derby iapi services info jvminfo
import org apache derby iapi services i18n bundlefinder
import org apache derby iapi services i18n messageservice
import org apache derby impl services monitor storagefactoryservice
import java io ioexception
import java io inputstream
import java io stringwriter
import java io bufferedinputstream
import java io printwriter
import java io bufferedreader
import java io inputstreamreader
import java io bytearrayinputstream
import java io printstream
import java util collections
import java util hashtable
import java util hashmap
import java util iterator
import java util map
import java util properties
import java util enumeration
import java util stringtokenizer
import java util vector
import java util locale
import java util resourcebundle
import java util nosuchelementexception
import java lang reflect method
import java lang reflect modifier
import java lang reflect invocationtargetexception
import java security accesscontroller
import java security privilegedexceptionaction
import java security privilegedactionexception
import java net url
/**
implementation of the monitor that uses the class loader
that the its was loaded in for all class loading.
*/
abstract class basemonitor
implements modulefactory  bundlefinder
/* fields */
/**
hash table of objects that implement persistentservice keyed by their gettype() method.
*/
private hashmap serviceproviders   new hashmap
// vector of class objects of implementations, found in the system, application
// and default (modules.properties) properties
vector     implementationsets
private vector	  services 					   vector of topservices
properties bootproperties 		   specifc properties provided by the boot method  override everything else
properties applicationproperties
boolean inshutdown
// here are the list of modules that we always boot
private infostreams systemstreams
private contextservice contextservice
private uuidfactory uuidfactory
private timerfactory timerfactory
boolean reporton
private printstream logging
threadgroup daemongroup
// anti gc stuff
antigc dontgc
// class registry
/* one byte  format identifiers never used
private instancegetter[]	rc1;
*/
private instancegetter	rc2
//	private instancegetter[]	rc4;
/* constructor  */
basemonitor
super
services   new vector 0  1
services addelement new topservice this   	   first element is always the free floating service
}
/* methods of modulefactory includes bootstrap and runnable */
public infostreams getsystemstreams
return systemstreams
}
public void shutdown
// allow only one caller to shut the monitor down
synchronized  this
if  inshutdown
return
inshutdown   true
}
if  sanitymanager debug    reporton
report
}
// shutdown all threads by iterrupting them
contextservice notifyallactivethreads  context  null
for
topservice ts
int position
synchronized  this
position   services size      1
if  position    0
break
ts    topservice  services elementat position
}
// push a new context manager
contextmanager cm   contextservice newcontextmanager
try
// pop the default shutdown context, we are shutting down
cm popcontext
contextservice setcurrentcontextmanager cm
shutdown ts getservice
finally
contextservice resetcurrentcontextmanager cm
}
}
topservice  services elementat 0   shutdown
synchronized  dontgc
dontgc goaway   true
dontgc notifyall
}
contextservice stop
monitor clearmonitor
}
/**
shut down a service that was started by this monitor. will
cause the stop() method to be called on each loaded module.
*/
public void shutdown object servicemodule
if  servicemodule    null
return
topservice ts   findtopservice servicemodule
if  ts    null
return
// shutdown() returns false if the service is already being shutdown
boolean removeservice   true
try
removeservice   ts shutdown
finally
synchronized  this
if  removeservice
boolean found   services removeelement ts
if (sanitymanager.debug) {
sanitymanager assert found      servicemodule
}
}
}
}
}
protected final void runwithstate properties properties  printstream log
bootproperties   properties
logging   log
// false indicates the full monitor is required, not the lite.
if   initialize false
return
// if monitor is already set then the system is already
// booted or in the process of booting or shutting down.
if   monitor setmonitor this
return
object msgservice   messageservice setfinder this
// start a backgorund thread which keeps a reference to this
// this monitor, and an instance of the monitor class to ensure
// that the monitor instance and the class is not garbage collected
// see sun's bug 4057924 in java developer section 97/08/06
object keepitems   new object
keepitems   this
keepitems   new monitor
keepitems   msgservice
dontgc   new antigc keepitems
thread dontgcthread   getdaemonthread dontgc     true
dontgcthread start
if (sanitymanager.debug) {
reporton   boolean valueof propertyutil getsystemproperty     booleanvalue
}
// set up the application properties
applicationproperties   readapplicationproperties
// the security manager may not let us get the system properties
// object itself, although it may let us look at the properties in it.
properties systemproperties   null
if (sanitymanager.debug) {
// in a production system having this call would
// mean would we have to document it for security
// permission reasons. since we don't require it and
// its a big security hole to allow external code to
// overwrite our own implementations we just support
// it for debugging. this means vm executions such as
// java -dderby.module.javacompiler=com.ibm.db2j.impl.basicservices.javacompiler.javalang.jljava ...
// would only work with a sane codeline.
try
systemproperties   system getproperties
catch  securityexception se
}
}
vector bootimplementations   getimplementations bootproperties  false
vector systemimplementations   null
vector applicationimplementations   null
// temp - making this sanity only breaks the unit test code
// i will fix soon, djd.
if  true    sanitymanager debug
// don't allow external code to override our implementations.
systemimplementations   getimplementations systemproperties  false
applicationimplementations   getimplementations applicationproperties  false
}
vector defaultimplementations   getdefaultimplementations
int implementationcount   0
if  bootimplementations    null
implementationcount
// temp - making this sanity only breaks the unit test code
if  true    sanitymanager debug
// don't allow external code to override our implementations.
if  systemimplementations    null
implementationcount
if  applicationimplementations    null
implementationcount
}
if  defaultimplementations    null
implementationcount
implementationsets   new vector
implementationcount   0
if  bootimplementations    null
implementationsets   bootimplementations
if  true    sanitymanager debug
// don't allow external code to override our implementations.
if  systemimplementations    null
implementationsets   systemimplementations
if  applicationimplementations    null
implementationsets   applicationimplementations
}
if  defaultimplementations    null
implementationsets   defaultimplementations
if (sanitymanager.debug) {
// look for the derby.debug.* properties.
if  applicationproperties    null
adddebugflags applicationproperties getproperty monitor debug_false   false
adddebugflags applicationproperties getproperty monitor debug_true   true
}
adddebugflags propertyutil getsystemproperty monitor debug_false   false
adddebugflags propertyutil getsystemproperty monitor debug_true   true
}
try
systemstreams    infostreams  monitor startsystemmodule
if (sanitymanager.debug) {
sanitymanager set_debug_stream systemstreams stream   getprintwriter
}
contextservice   new contextservice
uuidfactory    uuidfactory  monitor startsystemmodule
timerfactory    timerfactory monitor startsystemmodule
catch  standardexception se
// if we can't create an error log or a context then there's no point going on
reportexception se
// dump any messages we have been saving ...
dumptempwriter true
return
}
// switch cover to the real error stream and
// dump any messages we have been saving ...
dumptempwriter false
if  sanitymanager debug    reporton
dumpproperties    bootproperties
dumpproperties    systemproperties
dumpproperties    applicationproperties
}
// bootup all the service providers
determinesupportedserviceproviders
// see if automatic booting of persistent services is required
boolean bootall   boolean valueof propertyutil getsystemproperty property boot_all   booleanvalue
startservices bootproperties  bootall
startservices systemproperties  bootall
startservices applicationproperties  bootall
if  bootall     only if automatic booting is required
bootpersistentservices
}
public object findservice string factoryinterface  string servicename
if  servicename    null
return null
protocolkey key
try
key   protocolkey create factoryinterface  servicename
catch  standardexception se
return null
}
topservice myts   null
synchronized  this
for  int i   1  i < services size    i
topservice ts    topservice  services elementat i
if  ts ispotentialservice key
myts   ts
break
}
}
}
// the isactiveservice() call may sleep
// so don't hold the 'this' synchronization
if  myts    null
if  myts isactiveservice key
return myts getservice
}
return null
}
public locale getlocale object servicemodule
topservice ts   findtopservice servicemodule
if  ts    null
return null
return ts servicelocale
}
public locale getlocalefromstring string localedescription
throws standardexception
return staticgetlocalefromstring localedescription
}
/**
return the name of the service that the passed in module lives in.
*/
public string getservicename object servicemodule
topservice ts   findtopservice servicemodule
if  ts    null
return null
return ts getservicetype   getuserservicename ts getkey   getidentifier
}
/**
set the locale for the service *outside* of boot time.
@exception standardexception standard derby error.
*/
public locale setlocale object servicemodule  string userdefinedlocale
throws standardexception
topservice ts   findtopservice servicemodule
if  ts    null
return null
persistentservice provider   ts getservicetype
if  provider    null
return null
string servicename   ts getkey   getidentifier
properties properties   provider getserviceproperties servicename   properties  null
properties   new updateserviceproperties provider  servicename  properties  true
return setlocale properties  userdefinedlocale
}
/**
set the locale for the service at boot time. the passed in
properties must be the one passed to the boot method.
@exception standardexception standard derby error.
*/
public locale setlocale properties serviceproperties  string userdefinedlocale
throws standardexception
locale locale   staticgetlocalefromstring userdefinedlocale
// this will write the property through to the service.properties file.
serviceproperties put property service_locale  locale tostring
return locale
}
/**
return the persistentservice object for a service.
will return null if the service does not exist.
*/
public persistentservice getservicetype object servicemodule
topservice ts   findtopservice servicemodule
if  ts    null
return null
return ts getservicetype
}
/**
start a module.
@exception standardexception se an attempt to start the module failed.
@see modulefactory#startmodule
*/
public object startmodule boolean create  object servicemodule  string factoryinterface
string identifier  properties properties  throws standardexception
protocolkey key   protocolkey create factoryinterface  identifier
topservice ts   findtopservice servicemodule
object instance   ts bootmodule create  servicemodule  key  properties
if  instance    null
throw monitor missingimplementation factoryinterface
return instance
}
private synchronized topservice findtopservice object servicemodule
if  servicemodule    null
return  topservice  services elementat 0
for  int i   1  i < services size    i
topservice ts    topservice  services elementat i
if  ts inservice servicemodule
return ts
}
return null
}
public object findmodule object servicemodule  string factoryinterface  string identifier
{
protocolkey key
try
key   protocolkey create factoryinterface  identifier
catch  standardexception se
return null
}
topservice ts   findtopservice servicemodule
if  ts    null
return null
return ts findmodule key  true  null
}
/**
obtain a class that supports the given identifier.
@param fmtid identifer to associate with class
@return a reference instancegetter
@exception standardexception see monitor.classfromidentifier
@see modulefactory#classfromidentifier
*/
public instancegetter classfromidentifier int fmtid
throws standardexception
string classname
int off
instancegetter iga
instancegetter ig
try
off   fmtid   storedformatids min_two_byte_format_id
iga   rc2
if  iga    null
iga   rc2   new instancegetter
}
ig   iga
if  ig    null
return ig
}
classname   registeredformatids twobyte
catch  arrayindexoutofboundsexception aioobe
classname   null
iga   null
off   0
}
if  classname    null
throwable t
try
class clazz   class forname classname
// see if it is a formatableinstancegetter
if  formatableinstancegetter class isassignablefrom clazz
formatableinstancegetter tfig    formatableinstancegetter  clazz newinstance
tfig setformatid fmtid
return iga   tfig
}
return iga   new classinfo clazz
catch  classnotfoundexception cnfe
t   cnfe
catch  illegalaccessexception iae
t   iae
catch  instantiationexception ie
t   ie
catch  linkageerror le
t   le
}
throw standardexception newexception sqlstate registered_class_linakge_error
t  formatidutil formatidtostring fmtid   classname
}
throw standardexception newexception sqlstate registered_class_none  formatidutil formatidtostring fmtid
}
/**
obtain an new instance of a class that supports the given identifier.
@return a reference to a newly created object or null if a matching class
cannot be found.
*/
public object newinstancefromidentifier int identifier
throws standardexception
instancegetter ci   classfromidentifier identifier
throwable t
try
object result   ci getnewinstance
/*
if (sanitymanager.debug) {
if(sanitymanager.debug_on(monitor.new_instance_from_id_trace_debug_flag))
{
string traceresult = "null";
if (result != null) traceresult = "not null";
sanitymanager.debug(monitor.new_instance_from_id_trace_debug_flag,
"newinstancefromidentifier("+identifier+") "+
" classname: "+
result.getclass().getname() +
" returned "+
traceresult);
}
}
*/
return result
}
catch  instantiationexception ie
t   ie
}
catch  illegalaccessexception iae
t   iae
}
catch  invocationtargetexception ite
t   ite
}
catch  linkageerror le
t   le
}
throw standardexception newexception sqlstate registered_class_instance_error
t  new integer identifier       ci getclassname
}
private boolean exceptiontrace
/**
load a module instance.
look through the implementations for a module that implements the
required factory interface and can handle the properties given.
the module's start or create method is not called.
*/
protected object loadinstance class factoryinterface  properties properties
object instance   null
vector localimplementations   getimplementations properties  false
if  localimplementations    null
instance   loadinstance localimplementations  factoryinterface  properties
}
for  int i   0  i < implementationsets length  i
instance   loadinstance implementationsets  factoryinterface  properties
if  instance    null
break
}
return instance
}
private object loadinstance vector implementations  class factoryinterface  properties properties
for  int index   0  true  index
// find an implementation
index   findimplementation implementations  index  factoryinterface
if  index < 0
return null
// try to create an instance
object instance   newinstance  class  implementations elementat index
if  basemonitor cansupport instance  properties
return instance
}
}
/**
find a class that implements the required index, return the index
into the implementations vecotr of that class. returns -1 if no class
could be found.
*/
private static int findimplementation vector implementations  int startindex  class factoryinterface
for  int i   startindex  i < implementations size    i
//try {
class factoryclass    class  implementations elementat i
if   factoryinterface isassignablefrom factoryclass
continue
}
return i
//}
//catch (classnotfoundexception e) {
//	report("class not found " + (string) implementations.elementat(i));
//	continue;
//}
}
return  1
}
/**
*/
private object newinstance string classname
try
class factoryclass   class forname classname
return factoryclass newinstance
}
catch  classnotfoundexception e
report classname       e tostring
}
catch  instantiationexception e
report classname       e tostring
}
catch  illegalaccessexception e
report classname       e tostring
}
catch  linkageerror le
report classname       le tostring
reportexception le
}
return null
}
/**
*/
private object newinstance class classobject
try
return classobject newinstance
}
catch  instantiationexception e
report classobject getname         e tostring
}
catch  illegalaccessexception e
report classobject getname         e tostring
}
catch  linkageerror le
report classobject getname         le tostring
reportexception le
}
return null
}
public properties getapplicationproperties
return applicationproperties
}
/**
return an array of the service identifiers that are running and
implement the passed in protocol (java interface class name).
@return the list of service names, if no services exist that
implement the protocol an array with zero elements is returned.
@see modulefactory#getservicelist
*/
public string getservicelist string protocol
topservice ts
synchronized  this
int count   0
// count the number of services that implement the required protocol
for  int i   1  i < services size    i
ts    topservice  services elementat i
if  ts isactiveservice
if  ts getkey   getfactoryinterface   getname   equals protocol
count
}
}
// and then fill in the newly allocated string array
string list   new string
if  count    0
int j   0
for  int i   1  i < services size    i
ts    topservice  services elementat i
if  ts isactiveservice
if  ts getkey   getfactoryinterface   getname   equals protocol
list   ts getservicetype   getuserservicename ts getkey   getidentifier
if  j    count
break
}
}
}
}
return list
}
}
/*
** non-public methods.
*/
void dumpproperties string title  properties props
if (sanitymanager.debug) {
// this method is only called if reporton is true, so no need to check it here
report title
if  props    null
for  enumeration e   props propertynames    e hasmoreelements
string key    string  e nextelement
// get property as object in case of non-string properties
report key       props getproperty key
}
}
report
}
}
/**
should only be called if reporton is true
apart from report/exception().
*/
protected void report string message
printwriter tpw   gettempwriter
if  tpw    null
tpw println message
if  systemstreams    null
systemstreams stream   printlnwithheader message
}
protected void reportexception throwable t
printwritergetheader pwgh   null
if  systemstreams    null
pwgh   systemstreams stream   getheader
errorstringbuilder esb   new errorstringbuilder pwgh
esb appendln t getmessage
esb stacktrace t
report esb get   tostring
}
private void adddebugflags string flags  boolean set
if (sanitymanager.debug) {
if  flags    null
return
stringtokenizer st   new stringtokenizer flags
for    st hasmoretokens
string flag   st nexttoken
if  set
sanitymanager debug_set flag
else
sanitymanager debug_clear flag
}
}
}
/**
look for any services in the a properties set and the application
property set and then start them.
a service is defined by derby.service.name=protocol
*/
private static final string service
public void startservices properties properties  boolean bootall
if  properties    null
return
for  enumeration e   properties propertynames    e hasmoreelements
string key    string  e nextelement
if  key startswith service
string name   key substring service length
string protocolortype   properties getproperty key
try
if  protocolortype equals monitor service_type_directory
if  bootall 	   only if automatic booting is required
findproviderandstartservice name  properties  true
else
bootservice  persistentservice  null
protocolortype  name   properties null  false
}
catch  standardexception se
// error already in error log, just continue booting
// for persistent services, but non-persistent ones
// will not have put the error in the log
if   protocolortype equals monitor service_type_directory
reportexception se
}
}
}
}
/**
start a peristent service.
@see modulefactory#startpersistentservice
@see monitor#startpersistentservice
*/
public final boolean startpersistentservice string name  properties properties
throws standardexception
return findproviderandstartservice name  properties  false
}
/**
create a persistent service.
@return the module from the service if it was created successfully, null if a service already existed.
@exception standardexception an exception was thrown trying to create the service.
@see monitor#createpersistentservice
*/
public object createpersistentservice string factoryinterface  string name  properties properties
throws standardexception
persistentservice provider   findproviderforcreate name
if  provider    null
throw standardexception newexception sqlstate protocol_unknown  name
}
return bootservice provider  factoryinterface  name  properties  true
}
/**
*  removes a persistentservice.
*  could be used for drop database.
@param name : service name to be removed.
*/
public void removepersistentservice string name
throws standardexception
{
persistentservice provider null
provider   findproviderforcreate name
string servicename   provider getcanonicalservicename name
boolean removed   provider removeserviceroot servicename
if  removed    false
throw standardexception newexception sqlstate service_directory_remove_error servicename
}
/**
start a non-persistent service.
@see monitor#startnonpersistentservice
@see modulefactory#startnonpersistentservice
*/
public object startnonpersistentservice string factoryinterface  string servicename  properties properties
throws standardexception
return bootservice  persistentservice  null  factoryinterface  servicename  properties  false
}
/**
create an implementation set.
look through the properties object for all properties that
start with derby.module and add the value into the vector.
if no implementations are listed in the properties object
then null is returned.
*/
private vector getimplementations properties modulelist  boolean actualmodulelist
if  modulelist    null
return null
vector implementations   actualmodulelist ? new vector modulelist size      new vector 0 1
// get my current jdk environment
int thejdkid   jvminfo jdk_id
int envmodulecount   new int
nextmodule
for  enumeration e   modulelist propertynames    e hasmoreelements
string key    string  e nextelement
// module tagged name in the modules.properties file.
// used as the tag  for dependent properties.
string tag
// dynamically loaded code is defined by a property of
// the form:
// derby.module.<modulename>=<class name>
// or
// derby.subsubprotocol.<modulename>=<classname>
if  key startswith property module_prefix
tag   key substring property module_prefix length
else if  key startswith property sub_sub_protocol_prefix
tag   key substring property module_prefix length
else
continue nextmodule
}
// check to see if it has any environment requirements
// derby.env.jdk.<modulename> - any jdk requirements.
string envkey   property module_env_jdk_prefix concat tag
string envjdk   modulelist getproperty envkey
int envjdkid   0
if  envjdk    null
envjdkid   integer parseint envjdk trim
if  envjdkid > thejdkid
continue nextmodule
}
}
// derby.env.classes.<tag> - any class requirements
envkey   property module_env_classes_prefix concat tag
string envclasses   modulelist getproperty envkey
if  envclasses    null
stringtokenizer st   new stringtokenizer envclasses
for    st hasmoretokens
try
class forname st nexttoken   trim
catch  classnotfoundexception cnfe
continue nextmodule
catch  linkageerror le
continue nextmodule
}
}
}
// try to load the class
// if we can't load the class or create an instance then
// we don't use this calls as a valid module implementation
string classname   modulelist getproperty key
if  sanitymanager debug    reporton
report     classname
}
try
class possiblemodule   class forname classname
// look for the monitors special modules, persistentservice ones.
if  getpersistentserviceimplementation possiblemodule
continue
if  storagefactory class isassignablefrom possiblemodule
storagefactories put tag  classname
continue
}
// if this is a specific jdk version (environment) module
// then it must be ordered in the implementation list by envjdkid.
// those with a higher number are at the front, e.g.
//
//	jdk 1.4 modules (envjdkid == 4)
//  jdk 1.2/1.3 modules (envjdkid == 2)
//  jdk 1.1 modules (envjdkid == 1)
//  generic modules (envjdkid == 0 (not set in modules.properties)
//
//  note modules with envjdkid > thejdkid do not get here
if  envjdkid    0
// total how many modules with a higher envjdkid are ahead of us
int offset   0
for  int eji   thejdkid  eji > envjdkid  eji
offset    envmodulecount
}
implementations insertelementat possiblemodule  offset
envmodulecount
}
else
// just add to the end of the vector
implementations addelement possiblemodule
}
// since modulecontrol and modulesupportable are not called directly
// check that if the have the methods then the class implements the
// interface.
if (sanitymanager.debug) {
// modulesupportable
class csparams     new java util properties   getclass
try
possiblemodule getmethod    csparams
if   modulesupportable class isassignablefrom possiblemodule
sanitymanager throwassert     classname
}
catch  nosuchmethodexception nsme     ok
// modulecontrol
boolean eithermethod   false
class bootparams    boolean type  new java util properties   getclass
try
possiblemodule getmethod    bootparams
eithermethod   true
catch  nosuchmethodexception nsme    ok
class stopparams
try
possiblemodule getmethod    stopparams
eithermethod   true
catch  nosuchmethodexception nsme    ok
if  eithermethod
if   modulecontrol class isassignablefrom possiblemodule
sanitymanager throwassert     classname
}
}
}
}
catch  classnotfoundexception cnfe
report     classname       cnfe tostring
}
catch  linkageerror le
report     classname       le tostring
}
}
if  implementations isempty
return null
implementations trimtosize
return implementations
}
private boolean getpersistentserviceimplementation  class possiblemodule
{
if    persistentservice class isassignablefrom possiblemodule
return false
persistentservice ps    persistentservice  newinstance possiblemodule
if  ps    null
report     possiblemodule getname
else
serviceproviders put ps gettype    ps
}
return true
end of getpersistentserviceimplementation
private vector getdefaultimplementations
properties modulelist   getdefaultmoduleproperties
return getimplementations modulelist  true
end of getdefaultimplementations
/**
* get the complete set of module properties by
* loading in contents of all the org/apache/derby/modules.properties
* files. this must be executed in a privileged block otherwise
* when running in a security manager environment no properties will
* be returned.
*/
properties getdefaultmoduleproperties
{
// security permission - ip1 for modules in this jar
// or other jars shipped with the derby release.
properties modulelist   new properties
boolean firstlist   true
classloader cl   getclass   getclassloader
try
enumeration e   cl    null ?
classloader getsystemresources
cl getresources
while  e hasmoreelements
url modulespropertiesurl    url  e nextelement
inputstream is   null
try
is   modulespropertiesurl openstream
if  firstlist
modulelist load  is
firstlist   false
}
else
// check for duplicates
properties otherlist   new properties
otherlist load  is
for  enumeration newkeys   otherlist keys    newkeys hasmoreelements
{
string key    string  newkeys nextelement
if  modulelist contains  key
// resolve how do we localize messages before we have finished initialization?
report      key       modulespropertiesurl tostring
else
modulelist setproperty  key  otherlist getproperty  key
}
}
catch  ioexception ioe
if  sanitymanager debug
report     modulespropertiesurl tostring         ioe tostring
finally
try
if  is    null
is close
catch  ioexception ioe2
}
}
}
catch  ioexception ioe
if  sanitymanager debug
report     ioe tostring
}
if  sanitymanager debug
{
if  firstlist
report
}
return modulelist
}
/*
** class methods
*/
/**
return a property set that has the runtime properties removed.
*/
protected static properties removeruntimeproperties properties properties
properties subset   new properties
for  enumeration e   properties keys    e hasmoreelements
string key    string  e nextelement
if  key startswith property property_runtime_prefix
continue
subset put key  properties get key
}
return subset
}
/**
get inputstream for application properties file returns nul if it does not exist.
*/
abstract inputstream applicationpropertiesstream
throws ioexception
/**
*/
protected properties readapplicationproperties
inputstream is   null
try
// security permission - op3
is   applicationpropertiesstream
if  is    null
return null
properties properties   new properties
// trim off excess whitespace from properties file, if any,
// and then load the properties into 'properties'.
org apache derby iapi util propertyutil loadwithtrimmedvalues
new bufferedinputstream is   properties
return properties
catch  securityexception se
return null
catch  ioexception ioe
report ioe tostring         property properties_file
reportexception ioe
return null
finally
try
if  is    null
is close
is   null
}
catch  ioexception e
}
}
}
/*
** methods related to service providers.
**
** a service provider implements persistentservice and
** abstracts out:
**
**    finding all serivces that should be started at boot time.
**    finding the service.properties file for a service
**    creating a service's root.
**
** a monitor can have any number of service providers installed,
** any module that implements persistentservice is treated specially
** and stored only in the serviceproviders hashtable, indexed by
** its gettype() method.
**
** once all the implementations have loaded the service providers
** are checked to see if they run in the current environment.
*/
/**
* determine which of the set of service providers (persistentservice objects)
* are supported in the current environment. if a persistentservice
* implementation does not implement modulecontrol then it is assumed
* it does support the current environment. otherwise the cansupport()
* method makes the determination. any providers that are not supported
* are removed from the list.
*/
private void determinesupportedserviceproviders
for  iterator i   serviceproviders values   iterator    i hasnext
object provider   i next
// see if this provider can live in this environment
if   basemonitor cansupport provider   properties  null
i remove
continue
}
}
}
/**
boot all persistent services that can be located at run time.
<br>
this method enumerates through all the service providers that
are active and calls bootpersistentservices(persistentservice)
to boot all the services that that provider knows about.
*/
private void bootpersistentservices
enumeration e   new providerenumeration  applicationproperties
while  e hasmoreelements
persistentservice provider    persistentservice  e nextelement
bootproviderservices provider
}
}
/**
boot all persistent services that can be located by a single service provider
<br>
this method enumerates through all the service providers that
are active and calls bootpersistentservices(persistentservice)
to boot all the services that that provider knows about.
*/
protected void bootproviderservices persistentservice provider
if  sanitymanager debug    reporton
report     provider gettype
}
for  enumeration e   provider getboottimeservices     e    null     e hasmoreelements
string servicename    string  e nextelement
properties serviceproperties
try
serviceproperties   provider getserviceproperties servicename  null
catch  standardexception mse
report     servicename       provider gettype
reportexception mse
continue
}
// see if this service does not want to be auto-booted.
if  boolean valueof serviceproperties getproperty property no_auto_boot   booleanvalue
continue
try
startproviderservice provider  servicename  serviceproperties
catch  standardexception mse
report     servicename       provider gettype
reportexception mse
continue
}
}
}
/**
find a provider and start  a service.
*/
private boolean findproviderandstartservice string name
properties properties  boolean boottime
throws standardexception
persistentservice actualprovider   null
properties serviceproperties   null
string servicename   null
// see if the name already includes a service type
int colon   name indexof
if  colon     1
actualprovider   findproviderfromname name  colon
// if null is returned here then its a sub-sub protocol/provider
// that we don't understand. attempt to load it as an untyped name.
// if we have a protool
// that we do understand and we can't open the service we will
// throw an exception
if  actualprovider    null
servicename   actualprovider getcanonicalservicename name
if  servicename    null
return true      we understand the type  but the service does not exist
serviceproperties
actualprovider getserviceproperties servicename  properties
if  serviceproperties    null
return true     we understand the type  but the service does not exist
// see if this service does not want to be auto-booted.
if  boottime    boolean valueof serviceproperties getproperty property no_auto_boot   booleanvalue
return true
startproviderservice actualprovider  servicename  serviceproperties
return true     we understand the type
}
}
standardexception savedmse   null
for  enumeration e   new providerenumeration  properties   e hasmoreelements
persistentservice provider    persistentservice  e nextelement
string sn   provider getcanonicalservicename name
if  sn    null
continue
properties p   null
try
p   provider getserviceproperties sn  properties
// service does not exist.
if  p    null
continue
catch  standardexception mse
savedmse   mse
}
// yes we can attempt to boot this service
if  actualprovider    null
actualprovider   provider
servicename   sn
serviceproperties   p
continue
}
// we have an ambigious service name
throw standardexception newexception sqlstate ambigious_protocol  name
}
// no such service, if this was a name with no type, ie just name instead of type:name.
// the monitor claims to always understand these.
if  actualprovider    null
return colon     1
if  savedmse    null
throw savedmse
// see if this service does not want to be auto-booted.
if  boottime    boolean valueof serviceproperties getproperty property no_auto_boot   booleanvalue
return true
startproviderservice actualprovider  servicename  serviceproperties
return true
}
protected persistentservice findproviderforcreate string name  throws standardexception
// resolve - hard code creating databases in directories for now.
return  persistentservice  findproviderfromname name  name indexof
}
/**
find the service provider from a name that includes a service type,
ie. is of the form 'type:name'. if type is less than 3 characters
then it is assumed to be of type directory, i.e. a windows driver letter.
*/
private persistentservice findproviderfromname string name  int colon  throws standardexception
{
// empty type, treat as a unknown protocol
if  colon    0
return null
string servicetype
if  colon < 2
// assume it's a windows path (a:/foo etc.) and set the type to be directory
servicetype   persistentservice directory
else
servicetype   name substring 0  colon
}
return getserviceprovider servicetype
}
public persistentservice getserviceprovider string subsubprotocol  throws standardexception
{
if  subsubprotocol    null
return null
if  serviceproviders    null
{
persistentservice ps    persistentservice  serviceproviders get  subsubprotocol
if  ps    null
return ps
}
return getpersistentservice subsubprotocol
end of getserviceprovider
/**
* return a persistentservice implementation to handle the subsubprotocol.
* @return valid persistentservice or null if the protocol is not handled.
*/
private persistentservice getpersistentservice string subsubprotocol
throws standardexception
{
string classname   getstoragefactoryclassname subsubprotocol
return getpersistentservice  classname  subsubprotocol
}
private persistentservice getpersistentservice  final string classname  string subsubprotocol  throws standardexception
{
if  classname    null
return null
class storagefactoryclass   null
try
{
storagefactoryclass   class forname  classname
}
catch  throwable e
{
throw standardexception newexception  sqlstate instantiate_storage_factory_error
e
subsubprotocol  classname
}
return new storagefactoryservice  subsubprotocol  storagefactoryclass
end of getpersistentservice
/**
* find the storagefactory class name that handles the subsub protocol.
* looks in the system property set and the set defined during boot.
* @return valid class name, or null if no storagefactory handles the protocol.
*/
private string getstoragefactoryclassname string subsubprotocol
{
string propertyname   property sub_sub_protocol_prefix   subsubprotocol
string classname   propertyutil getsystemproperty  propertyname
if  classname    null
return classname
return  string  storagefactories get  subsubprotocol
end of getstoragefactoryclassname
private static final hashmap storagefactories   new hashmap
static
string dirstoragefactoryclass
if  jvminfo jdk_id >  jvminfo j2se_14
dirstoragefactoryclass
else
dirstoragefactoryclass
storagefactories put  persistentservice directory  dirstoragefactoryclass
storagefactories put  persistentservice classpath
storagefactories put  persistentservice jar
storagefactories put  persistentservice http
storagefactories put  persistentservice https
}
/**
boot a service under the control of the provider
*/
protected void startproviderservice persistentservice provider  string servicename  properties serviceproperties
throws standardexception
string protocol   serviceproperties getproperty property service_protocol
if  protocol    null
throw standardexception newexception sqlstate property_missing  property service_protocol
}
bootservice provider  protocol  servicename  serviceproperties  false
}
/**
boot (start or create) a service (persistent or non-persistent).
*/
protected object bootservice persistentservice provider
string factoryinterface  string servicename  properties properties
boolean create  throws standardexception
//reget the canonical service name in case if it was recreated
//after we got service name.(like in case of restoring from backup).
if provider    null
servicename   provider getcanonicalservicename servicename
protocolkey servicekey   protocolkey create factoryinterface  servicename
if  sanitymanager debug    reporton
report     servicekey       create
}
contextmanager previouscm   contextservice getcurrentcontextmanager
contextmanager cm   previouscm
object instance
topservice ts   null
context sb   null
try
synchronized  this
if  inshutdown
throw standardexception newexception sqlstate cloudscape_system_shutdown
}
for  int i   1  i < services size    i
topservice ts2    topservice  services elementat i
if  ts2 ispotentialservice servicekey
// if the service already exists then  just return null
return null
}
}
locale servicelocale   null
if  create
// always wrap the property set in an outer set.
// this ensures that any random attributes from
// a jdbc url are not written into the service.properties
// file (e.g. like user and password :-)
properties   new properties properties
servicelocale   setlocale properties
properties put property service_protocol  factoryinterface
servicename   provider createserviceroot servicename
boolean valueof properties getproperty property delete_on_create   booleanvalue
servicekey   protocolkey create factoryinterface  servicename
else if  properties    null
string serverlocaledescription   properties getproperty property service_locale
if   serverlocaledescription    null
servicelocale   staticgetlocalefromstring serverlocaledescription
}
ts   new topservice this  servicekey  provider  servicelocale
services addelement ts
}
if (sanitymanager.debug) {
if  provider    null
{
sanitymanager assert provider getcanonicalservicename servicename  equals servicename
provider getcanonicalservicename servicename
servicename
sanitymanager assert servicename equals servicekey getidentifier
servicename       servicekey getidentifier
}
}
if  properties    null
// these properties must not be stored in the persistent properties,
// otherwise moving databases from one directory to another
// will not work. thus they all have a fixed prefix
// the root of the data
properties put persistentservice root  servicename
// the type of the service
properties put persistentservice type  provider gettype
}
if  sanitymanager debug    reporton
dumpproperties     servicekey tostring    properties
}
// push a new context manager
if  previouscm    null
cm   contextservice newcontextmanager
contextservice setcurrentcontextmanager cm
}
sb   new servicebootcontext cm
updateserviceproperties usproperties
properties serviceproperties
//while doing restore from backup, we don't want service properties to be
//updated until all the files are copied from backup.
boolean inrestore    properties   null ?
properties getproperty property in_restore_from_backup     null false
if   provider    null      properties    null
// we need to track to see if the properties have
// been updated or not. if the database is not created yet, we don't create the
// services.properties file yet. we let the following if (create) statement do
//that at the end of the database creation. after that, the changes in
// services.properties file will be tracked by updateserviceproperties.
usproperties   new updateserviceproperties provider
servicename
properties
create    inrestore
serviceproperties   usproperties
else
usproperties   null
serviceproperties   properties
}
instance   ts bootmodule create  null  servicekey  serviceproperties
if  create    inrestore
// remove all the in-memory properties
provider saveserviceproperties servicename  usproperties getstoragefactory
basemonitor removeruntimeproperties properties   false
usproperties setservicebooted
}
if  cm    previouscm
cm cleanuponerror standardexception closeexception
catch  throwable t
standardexception se
// ensure that the severity will shutdown the service
if   t instanceof standardexception        standardexception  t  getseverity      exceptionseverity database_severity
se    standardexception  t
else
se   monitor exceptionstartingmodule t
if  cm    previouscm
cm cleanuponerror se
}
if  ts    null
ts shutdown
synchronized  this
services removeelement ts
}
// service root will only have been created if
// ts is non-null.
boolean deleteonerror    properties   null ?
properties getproperty property delete_root_on_error    null false
if  create    deleteonerror
provider removeserviceroot servicename
}
throwable nested   se getcause
// never hide threaddeath
if  nested instanceof threaddeath
throw  threaddeath  nested
throw se
finally
if   previouscm    cm      sb    null
sb popme
if  previouscm    null
contextservice resetcurrentcontextmanager cm
}
// from this point onwards the service is open for business
ts settopmodule instance
//
// the following yield allows our background threads to
// execute their run methods. this is needed due to
// bug 4081540 on solaris. when the bug is fixed we can
// remove this yield.
thread yield
return instance
}
/*
** methods of com.ibm.db2j.system.system
*/
/**
return the uuid factory for this system.  returns null
if there isn't one.
see com.ibm.db2j.system.system
*/
public uuidfactory getuuidfactory
return uuidfactory
}
/**
* returns the timer factory for this system.
*
* @return the system's timer factory.
*/
public timerfactory gettimerfactory
return timerfactory
}
/*
** methods to deal with storing error messages until an infostreams is available.
*/
private printwriter tmpwriter
private accessiblebytearrayoutputstream tmparray
private boolean dumpedtempwriter
private printwriter gettempwriter
if  tmpwriter    null     dumpedtempwriter
tmparray   new accessiblebytearrayoutputstream
tmpwriter   new printwriter tmparray
}
return tmpwriter
}
private void dumptempwriter boolean bothplaces
if  tmpwriter    null
return
tmpwriter flush
bufferedreader lnr   new bufferedreader
new inputstreamreader
new bytearrayinputstream tmparray getinternalbytearray
try
string s
while   s   lnr readline       null
if  systemstreams    null
systemstreams stream   printlnwithheader s
if   systemstreams    null     bothplaces
logging println s
}
catch  ioexception ioe
}
if   systemstreams    null     bothplaces
logging flush
tmpwriter   null
tmparray   null
dumpedtempwriter   true
logging   null
}
/**
if the module implements modulesupportable then call its
cansupport() method to see if it can or should run in
this setup. if it doesn't then it can always run.
*/
static boolean cansupport object instance  properties properties
if  instance instanceof modulesupportable
// see if the instance can support the properties
if     modulesupportable  instance  cansupport properties
return false
}
return true
}
/**
boot a module. if the module implements modulecontrol
then its boot() method is called. otherwise all the
boot code is assumed to take place in its constructor.
*/
static void boot object module  boolean create  properties properties
throws standardexception
if  module instanceof modulecontrol
modulecontrol  module  boot create  properties
}
/*
** locale handling
*/
private static locale staticgetlocalefromstring string localedescription
throws standardexception
// check string is of expected format
// even though country should not be optional
// some jvm's support this, so go with the flow.
// xx[_yy[_variant]]
int len   localedescription length
boolean isok    len    2      len    5      len > 6
// must have underscores at position 2
if  isok     len    2
isok   localedescription charat 2
// must have underscores at position 2
if  isok     len > 5
isok   localedescription charat 5
if   isok
throw standardexception newexception sqlstate invalid_locale_description  localedescription
string language   localedescription substring 0  2
string country   len    2 ?     localedescription substring 3  5
if  len < 6
return new locale language  country
}
string variant    len > 6  ? localedescription substring 6  len    null
return new locale language  country  variant
}
private static locale setlocale properties properties
throws standardexception
string userdefinedlocale   properties getproperty attribute territory
locale locale
if  userdefinedlocale    null
locale   locale getdefault
else
// validate the passed in string
locale   staticgetlocalefromstring userdefinedlocale
}
properties put property service_locale  locale tostring
return locale
}
/*
** bundlefinder
*/
//private hashtable localebundles;
/**
get the locale from the contextmanager and then find the bundle
based upon that locale.
*/
public resourcebundle getbundle string messageid
contextmanager cm
try
cm   contextservice getfactory   getcurrentcontextmanager
catch  shutdownexception se
cm   null
}
if  cm    null
return messageservice getbundleforlocale cm getmessagelocale    messageid
}
return null
}
public thread getdaemonthread runnable task  string name  boolean setminpriority
thread t    new thread daemongroup  task    concat name
t setdaemon true
if  setminpriority
t setpriority thread min_priority
}
return t
}
public void setthreadpriority int priority
thread t   thread currentthread
if  t getthreadgroup      daemongroup
t setpriority priority
}
}
/**
initialize the monitor wrt the current environemnt.
returns false if the monitor cannot be initialized, true otherwise.
*/
abstract boolean initialize boolean lite
class providerenumeration implements enumeration
{
private enumeration serviceproviderskeys    serviceproviders    null  ? null
collections enumeration serviceproviders keyset
private properties startparams
private enumeration paramenumeration
private boolean enumerateddirectoryprovider
private persistentservice storagefactorypersistentservice
providerenumeration  properties startparams
{
this startparams   startparams
if  startparams    null
paramenumeration   startparams keys
}
public object nextelement   throws nosuchelementexception
{
if  serviceproviderskeys    null    serviceproviderskeys hasmoreelements
return serviceproviders get  serviceproviderskeys nextelement
getnextstoragefactory
object ret   storagefactorypersistentservice
storagefactorypersistentservice   null
return ret
}
private void getnextstoragefactory
{
if  storagefactorypersistentservice    null
return
if  paramenumeration    null
{
while  paramenumeration hasmoreelements
{
string prop    string  paramenumeration nextelement
if  prop startswith  property sub_sub_protocol_prefix
{
try
{
string storagefactoryclassname    string  startparams get  prop
if  storagefactoryclassname    null
{
storagefactorypersistentservice
getpersistentservice   string  startparams get  prop
prop substring  property sub_sub_protocol_prefix length
if  storagefactorypersistentservice    null
return
}
}
catch  standardexception se
}
}
}
if    enumerateddirectoryprovider
{
try
{
storagefactorypersistentservice
getpersistentservice  getstoragefactoryclassname persistentservice directory
persistentservice directory
}
catch  standardexception se   storagefactorypersistentservice   null
enumerateddirectoryprovider   true
}
end of getnextstoragefactory
public boolean hasmoreelements
{
if  serviceproviderskeys    null    serviceproviderskeys hasmoreelements
return true
getnextstoragefactory
return storagefactorypersistentservice    null
}
end of class providerenumeration
end of class basemonitor
class antigc implements runnable
boolean goaway
private object keep1
antigc object a
keep1   a
}
public void run
while  true
synchronized  this
if  goaway
return
try
wait
catch  interruptedexception ie
}
}
}
}
end of class antigc