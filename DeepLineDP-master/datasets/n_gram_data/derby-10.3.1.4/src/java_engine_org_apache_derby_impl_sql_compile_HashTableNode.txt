/*
derby - class org.apache.derby.impl.sql.compile.hashtablenode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services context contextmanager
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile optimizablepredicate
import org apache derby iapi sql compile optimizablepredicatelist
import org apache derby iapi sql compile optimizer
import org apache derby iapi sql compile costestimate
import org apache derby iapi sql compile optimizablelist
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile requiredrowordering
import org apache derby iapi sql compile rowordering
import org apache derby iapi sql compile accesspath
import org apache derby iapi reference classname
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi error standardexception
import org apache derby iapi store access transactioncontroller
import org apache derby impl sql compile expressionclassbuilder
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services sanity sanitymanager
import org apache derby catalog types referencedcolumnsdescriptorimpl
import org apache derby iapi services io formatablearrayholder
import org apache derby iapi services io formatableintholder
import org apache derby iapi util jbitset
import org apache derby iapi services classfile vmopcode
import java util properties
/**
* a hashtablenode represents a result set where a hash table is built.
*
*/
public class hashtablenode extends singlechildresultsetnode
predicatelist	searchpredicatelist
predicatelist	joinpredicatelist
subquerylist	psubquerylist
subquerylist	rsubquerylist
/**
* initializer for a hashtablenode.
*
* @param childresult			the child result set
* @param tableproperties	properties list associated with the table
* @param resultcolumns			the rcl.
* @param searchpredicatelist	single table clauses
* @param joinpredicatelist		multi table clauses
* @param accesspath			the access path
* @param costestimate			the cost estimate
* @param psubquerylist			list of subqueries in rcl
* @param rsubquerylist			list of subqueries in predicate lists
* @param hashkeycolumns		hash key columns
*/
public void init
object childresult
object tableproperties
object resultcolumns
object searchpredicatelist
object joinpredicatelist
object accesspath
object   costestimate
object	psubquerylist
object   rsubquerylist
object hashkeycolumns
super init childresult  tableproperties
this resultcolumns    resultcolumnlist  resultcolumns
this searchpredicatelist    predicatelist  searchpredicatelist
this joinpredicatelist    predicatelist  joinpredicatelist
this trulythebestaccesspath    accesspathimpl  accesspath
this costestimate    costestimate  costestimate
this psubquerylist    subquerylist  psubquerylist
this rsubquerylist    subquerylist  rsubquerylist
sethashkeycolumns  int  hashkeycolumns
/*
*  optimizable interface
*/
/**
* @see optimizable#modifyaccesspath
*
* @exception standardexception		thrown on error
*/
public optimizable modifyaccesspath jbitset outertables  optimizer optimizer
throws standardexception
return this
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  searchpredicatelist    null
printlabel depth
searchpredicatelist treeprint depth   1
if  joinpredicatelist    null
printlabel depth
joinpredicatelist treeprint depth   1
/**
* for joins, the tree will be (nodes are left out if the clauses
* are empty):
*
*      projectrestrictresultset -- for the having and the select list
*      sortresultset -- for the group by list
*      projectrestrictresultset -- for the where and the select list (if no group or having)
*      the result set for the fromlist
*
*
* @exception standardexception		thrown on error
*/
public void generate activationclassbuilder acb
methodbuilder mb
throws standardexception
if  sanitymanager debug
sanitymanager assert resultcolumns    null
generateminion  acb  mb  false
/**
* general logic shared by core compilation and by the replication filter
* compiler. a couple resultsets (the ones used by prepare select filter)
* implement this method.
*
* @param acb	the expressionclassbuilder for the class being built
* @param mb the method  the expression will go into
*
*
* @exception standardexception		thrown on error
*/
public void generateresultset expressionclassbuilder acb
methodbuilder mb
throws standardexception
generateminion  acb  mb  true
/**
* logic shared by generate() and generateresultset().
*
* @param acb	the expressionclassbuilder for the class being built
* @param mb the method  the expression will go into
*
* @exception standardexception		thrown on error
*/
private void generateminion expressionclassbuilder acb
methodbuilder mb  boolean genchildresultset
throws standardexception
methodbuilder	userexprfun
valuenode	searchclause   null
valuenode	equijoinclause   null
/* the tableproperties, if non-null, must be correct to get this far.
* we simply call verifyproperties to set initialcapacity and
* loadfactor.
*/
verifyproperties getdatadictionary
// build up the tree.
/* put the predicates back into the tree */
if  searchpredicatelist    null
// remove any redundant predicates before restoring
searchpredicatelist removeredundantpredicates
searchclause   searchpredicatelist restorepredicates
/* allow the searchpredicatelist to get garbage collected now
* that we're done with it.
*/
searchpredicatelist   null
// for the single table predicates, we generate an exprfun
// that evaluates the expression of the clause
// against the current row of the child's result.
// if the restriction is empty, simply pass null
// to optimize for run time performance.
// generate the function and initializer:
// note: boolean lets us return nulls (boolean would not)
// private boolean exprn()
// {
//   return <<searchclause.generate(ps)>>;
// }
// static method exprn = method pointer to exprn;
// map the result columns to the source columns
int maparray   resultcolumns mapsourcecolumns
int maparrayitem   acb additem new referencedcolumnsdescriptorimpl maparray
// save the hash key columns
formatableintholder fiharray
formatableintholder getformatableintholders hashkeycolumns
formatablearrayholder hashkeyholder   new formatablearrayholder fiharray
int hashkeyitem   acb additem hashkeyholder
/* generate the hashtableresultset:
*	arg1: childexpress - expression for childresultset
*  arg2: searchexpress - expression for single table predicates
*	arg3	: equijoinexpress - qualifier[] for hash table look up
*  arg4: projectexpress - expression for projection, if any
*  arg5: resultsetnumber
*  arg6: maparrayitem - item # for mapping of source columns
*  arg7: reuseresult - whether or not the result row can be reused
*						(ie, will it always be the same)
*	arg8: hashkeyitem - item # for int[] of hash column #s
*	arg9: removeduplicates - don't remove duplicates in hash table (for now)
*	arg10: maxinmemoryrowcount - max row size for in-memory hash table
*	arg11: initialcapacity - initialcapacity for java.util.hashtable
*	arg12	: loadfactor - loadfactor for java.util.hashtable
*  arg13: estimated row count
*  arg14: estimated cost
*  arg15: close method
*/
acb pushgetresultsetfactoryexpression mb
if  genchildresultset
childresult generateresultset acb  mb
else
childresult generate  activationclassbuilder  acb  mb
/* get the next resultset #, so that we can number this resultsetnode, its
* resultcolumnlist and resultset.
*/
assignresultsetnumber
/* set the point of attachment in all subqueries attached
* to this node.
*/
if  psubquerylist    null    psubquerylist size   > 0
psubquerylist setpointofattachment resultsetnumber
if  sanitymanager debug
sanitymanager assert psubquerylist size      0
if  rsubquerylist    null    rsubquerylist size   > 0
rsubquerylist setpointofattachment resultsetnumber
if  sanitymanager debug
sanitymanager assert rsubquerylist size      0
// get the final cost estimate based on child's cost.
costestimate   childresult getfinalcostestimate
// if there is no searchclause, we just want to pass null.
if  searchclause    null
mb pushnull classname generatedmethod
else
// this sets up the method and the static field.
// generates:
// 	datavaluedescriptor userexprfun { }
userexprfun   acb newuserexprfun
// searchclause knows it is returning its value;
/* generates:
*    return <searchclause.generate(acb)>;
* and adds it to userexprfun
* note: the explicit cast to datavaluedescriptor is required
* since the searchclause may simply be a boolean column or subquery
* which returns a boolean.  for example:
*		where booleancolumn
*/
searchclause generateexpression acb  userexprfun
userexprfun methodreturn
/* pushcompiler
usersb.newreturnstatement(searchclause.generateexpression(acb, usersb));
*/
// we are done modifying userexprfun, complete it.
userexprfun complete
// searchclause is used in the final result set as an access of the new static
// field holding a reference to this new method.
// generates:
//	activationclass.userexprfun
// which is the static field that "points" to the userexprfun
// that evaluates the where clause.
acb pushmethodreference mb  userexprfun
/* generate the qualifiers for the look up into
* the hash table.
*/
joinpredicatelist generatequalifiers acb  mb   optimizable  childresult
false
/* determine whether or not reflection is needed for the projection.
* reflection is not needed if all of the columns map directly to source
* columns.
*/
if  reflectionneededforprojection
// for the resultcolumns, we generate a userexprfun
// that creates a new row from expressions against
// the current row of the child's result.
// (generate optimization: see if we can simply
// return the current row -- we could, but don't, optimize
// the function call out and have execution understand
// that a null function pointer means take the current row
// as-is, with the performance trade-off as discussed above.)
/* generate the row function for the projection */
resultcolumns generatecore acb  mb  false
else
mb pushnull classname generatedmethod
mb push resultsetnumber
mb push maparrayitem
mb push resultcolumns reusableresult
mb push hashkeyitem
mb push false
mb push  1l
mb push initialcapacity
mb push loadfactor
mb push costestimate singlescanrowcount
mb push costestimate getestimatedcost
mb callmethod vmopcode invokeinterface   string  null
classname noputresultset  14
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
if  v skipchildren this
return v visit this
visitable returnnode   super accept v
if  searchpredicatelist    null     v stoptraversal
searchpredicatelist    predicatelist searchpredicatelist accept v
if  joinpredicatelist    null     v stoptraversal
joinpredicatelist    predicatelist joinpredicatelist accept v
return returnnode