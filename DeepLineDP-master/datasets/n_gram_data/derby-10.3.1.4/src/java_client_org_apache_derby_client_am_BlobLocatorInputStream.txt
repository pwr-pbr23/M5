/*
derby - class org.apache.derby.client.am.bloblocatorinputstream
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client am
import java sql callablestatement
import java sql sqlexception
import java io ioexception
import org apache derby shared common sanity sanitymanager
/**
* an <code>inputstream</code> that will use an locator to fetch the
* blob value from the server.
* <p>
* closing a <code>bytearrayinputstream</code> has no effect. the methods in
* this class can be called after the stream has been closed without
* generating an <code>ioexception</code>.
* <p>
* this <code>inputstream</code> implementation is pretty basic.  no
* buffering of data is done.  hence, for efficieny #read(byte[])
* should be used instead of #read().  marks are not supported, but it
* should be pretty simple to extend the implementation to support
* this.  a more efficient skip implementation should also be
* straight-forward.
*/
public class bloblocatorinputstream extends java io inputstream
/**
* create an <code>inputstream</code> for reading the
* <code>blob</code> value represented by the given locator based
* <code>blob</code> object.
* @param connection connection to be used to read the
*        <code>blob</code> value from the server
* @param blob <code>blob</code> object that contains locator for
*        the <code>blob</code> value on the server.
* @throws sqlexception if an error occurs when obtaining the
*         length of the <code>blob</code>.
*/
public bloblocatorinputstream connection connection  blob blob
throws sqlexception
if  sanitymanager debug
sanitymanager assert blob islocator
this connection   connection
this blob   blob
this currentpos   1
//in this case a subset of the blob has
//not been requested for. we set maxpos
//to -1 and instead will call
//blob.sqllength() each time we want
//the maximum length.
this maxpos    1
/**
* create an <code>inputstream</code> for reading the
* <code>blob</code> value represented by the given locator based
* <code>blob</code> object.
* @param connection connection to be used to read the
*        <code>blob</code> value from the server
* @param blob <code>blob</code> object that contains locator for
*        the <code>blob</code> value on the server.
* @param position the position in the <code>blob</code> of the first
*        byte to read.
* @param length the maximum number of bytes to read from
*        the <code>blob</code>.
* @throws sqlexception if an error occurs when obtaining the
*         length of the <code>blob</code>.
*/
public bloblocatorinputstream connection connection  blob blob
long position  long length
throws sqlexception
if  sanitymanager debug
sanitymanager assert blob islocator
this connection   connection
this blob   blob
this currentpos   position
if  length     1     verify if length is  1
this maxpos   math min blob sqllength    position   length   1
else
this maxpos    1
/**
* @see java.io.inputstream#read()
*
* this method fetches one byte at a time from the server. for more
* efficient retrieval, use #read(byte[]).
*/
public int read   throws ioexception
byte bytes   readbytes 1
if  bytes length    0       eof
return  1
else
return bytes
/**
* @see java.io.inputstream#read(byte[], int, int)
*/
public int read byte b  int off  int len  throws ioexception
if  len    0  return 0
if   off < 0      len < 0      off len > b length
throw new indexoutofboundsexception
byte bytes   readbytes len
if  bytes length    0       eof
return  1
else
system arraycopy bytes  0  b  off  bytes length
return bytes length
/**
* read the next <code>len</code> bytes of the <code>blob</code>
* value from the server.
*
* @param len number of bytes to read
* @throws java.io.ioexception wrapped sqlexception if reading
*         from server fails.
* @return <code>byte[]</code> containing the read bytes
*/
private byte readbytes int len  throws ioexception
try
//stores the actual length that can be read
//based on the value of the current position
//in the stream(currentpos) and the length of
//the stream.
int actuallength    1
//check if maxpos has been set and calculate actuallength
//based on that.
if maxpos     1
//maxpos has been set. use maxpos to calculate the
//actual length based on the value set for maxpos.
actuallength
int  math min len  maxpos   currentpos   1
else
//the subset of the blob was not requested for
//hence maxpos is -1. here we use blob.sqllength
//instead.
actuallength
int  math min len  blob sqllength     currentpos   1
byte result   connection locatorprocedurecall
blobgetbytes blob getlocator    currentpos  actuallength
currentpos    result length
return result
catch  sqlexception ex
ioexception ioex   new ioexception
ioex initcause ex
throw ioex
/**
* connection used to read blob from server.
*/
private final connection connection
/**
* the blob to be accessed.
*/
private final blob blob
/**
* current position in the underlying blob.
* blobs are indexed from 1
*/
private long currentpos
/**
* position in blob where to stop reading.
* maxpos starts counting from 1.
*/
private final long maxpos