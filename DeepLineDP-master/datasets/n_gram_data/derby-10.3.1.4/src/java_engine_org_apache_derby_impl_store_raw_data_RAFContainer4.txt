/*
derby - class org.apache.derby.impl.store.raw.data.rafcontainer4
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io formatidutil
import org apache derby impl store raw data basedatafilefactory
import org apache derby iapi store raw containerkey
import java io eofexception
import java io ioexception
import java io randomaccessfile
import java nio bytebuffer
import java nio channels filechannel
import java nio channels closedchannelexception
/**
* rafcontainer4 overrides a few methods in rafcontainer in an attempt to use
* filechannel from java 1.4's new io framework to issue multiple io operations
* to the same file concurrently instead of strictly serializing io operations
* using a mutex on the container object.
* <p>
* note that our requests for multiple concurrent ios may be serialized further
* down in the io stack - this is entirely up to the jvm and os. however, at
* least in linux on sun's 1.4.2_09 jvm we see the desired behavior:
* the filechannel.read/write(bytebuffer buf, long position) calls map to
* pread/pwrite system calls, which enable efficient io to the same file
* descriptor by multiple threads.
* <p>
* this whole class should be merged back into rafcontainer when derby
* officially stops supporting java 1.3.
* <p>
* significant behavior changes from rafcontainer:
* <ol>
* <li> multiple concurrent ios permitted.
* <li> state changes to the container (create, open, close) can now happen while
*      io is in progress due to the lack of locking. closing a container while
*      io is in progress will cause ioexceptions in the thread calling readpage
*      or writepage. if this happens something is probably amiss anyway.
*      the iosinprogress variable is used in an attempt to detect this should it
*      happen while running a debug build.
* </ol>
*
* @see java.nio.channels.filechannel
*/
class rafcontainer4 extends rafcontainer
/**
* this channel will be retrieved from rafcontainer's filedata
* member when filedata is set. we wrap a couple of rafcontainer's methods
* to accomplish this.
*/
private filechannel ourchannel   null
/**
* for debugging - will be incremented when an io is started, decremented
* when it is done. should be == 0 when container state is changed.
*/
private int iosinprogress   0
public rafcontainer4 basedatafilefactory factory
super factory
/*
* wrapping methods that retrieve the filechannel from rafcontainer's
* filedata after calling the real methods in rafcontainer.
*/
synchronized boolean opencontainer containerkey newidentity
throws standardexception
if  sanitymanager debug
sanitymanager assert iosinprogress    0
boolean result   super opencontainer newidentity
if  result    true    super filedata    null
super filedata instanceof java io randomaccessfile
/** xxx - this cast isn't testing friendly.
* a testing class that implements storagerandomaccessfile but isn't
* a randomaccessfile will be "worked around" by this class. an
* example of such a class is
* functiontests/util/corruptio/corruptrandomaccessfile.java.
* an interface rework may be necessary.
*/
ourchannel     randomaccessfile super filedata  getchannel
return result
synchronized void createcontainer containerkey newidentity
throws standardexception
if  sanitymanager debug
sanitymanager assert iosinprogress    0
super createcontainer newidentity
if  super filedata    null
super filedata instanceof java io randomaccessfile
// xxx - see "xxx" comment above.
ourchannel     randomaccessfile  super filedata  getchannel
synchronized void closecontainer
if  sanitymanager debug
// any ios in progress to a container being dropped will be
// ignored, so we should not complain about starting a close
// while there are ios in progress if it is being dropped
// anyway.
sanitymanager assert   iosinprogress    0
getcommitteddropstate
if ourchannel    null
try
ourchannel close
catch  ioexception e
// nevermind.
finally
ourchannel null
super closecontainer
/**
* these are the methods that were rewritten to use filechannel.
**/
/**
*  read a page into the supplied array.
*
*  <br> mt - thread safe
*  @exception ioexception exception reading page
*  @exception standardexception standard derby error policy
*/
protected void readpage long pagenumber  byte pagedata
throws ioexception  standardexception
filechannel iochannel
synchronized  this
iochannel   ourchannel
if  sanitymanager debug
sanitymanager assert  getcommitteddropstate
// if iochannel == null and filedata supports getchannel()
// we have a problem. see this.opencontainer(containerkey
// newidentity).
sanitymanager assert     iochannel    null
super filedata instanceof java io randomaccessfile
if iochannel    null
long pageoffset   pagenumber   pagesize
bytebuffer pagebuf   bytebuffer wrap pagedata
// i hope the try/finally is optimized away by the
// compiler/jvm when sanitymanager.debug == false?
try
if  sanitymanager debug
synchronized this
iosinprogress
readfull pagebuf  iochannel  pageoffset
finally
if  sanitymanager debug
synchronized this
iosinprogress
if  datafactory databaseencrypted
pagenumber    first_alloc_page_number
decryptpage pagedata  pagesize
else
iochannel was not initialized  fall back to original method
super readpage pagenumber  pagedata
/**
*  write a page from the supplied array.
*
*  <br> mt - thread safe
*
*  @exception standardexception standard derby error policy
*  @exception ioexception io error accessing page
*/
protected void writepage long pagenumber  byte pagedata  boolean syncpage
throws ioexception  standardexception
filechannel iochannel
synchronized this
// committed and dropped, do nothing.
// this file container may only be a stub
if  getcommitteddropstate
return
iochannel   ourchannel
if  sanitymanager debug
// if iochannel == null and filedata supports getchannel()
// we have a problem
sanitymanager assert     iochannel    null
super filedata instanceof java io randomaccessfile
if iochannel    null
///////////////////////////////////////////////////
//
// resolve: right now, no logical -> physical mapping.
// we can calculate the offset.  in the future, we may need to
// look at the allocation page or the in memory translation table
// to figure out where the page should go
//
/////////////////////////////////////////////////
long pageoffset   pagenumber   pagesize
byte encryptionbuf   null
// we only need to allocate the encryptionbuf if updatepagearray is
// actually going to use it.
if  datafactory databaseencrypted
encryptionbuf   new byte
byte datatowrite   updatepagearray pagenumber
pagedata
encryptionbuf
false
if  sanitymanager debug
sanitymanager assert datatowrite    null
bytebuffer writebuffer   bytebuffer wrap datatowrite
datafactory writeinprogress
try
if  sanitymanager debug
synchronized this
iosinprogress
writefull writebuffer  iochannel  pageoffset
catch  closedchannelexception ioe
synchronized this
/* if the write failed because the container has been closed
* for deletion between the start of this method and the
* write, we'll just ignore that, as this container is going
* away anyway.
* this could possibly happen if the cache is cleaning this
* container while it is dropped - basedatafilefactory holds
* an exclusive lock on the container while dropping it to
* avoid other interference.
* see the getcommitteddropstate() check at the top of this
* method.
*/
if  getcommitteddropstate
if  sanitymanager debug
sanitymanager debug_print
return
else
// this should not happen, better let the exception
// hurt where it's supposed to.
throw ioe
finally
if  sanitymanager debug
synchronized this
iosinprogress
datafactory writefinished
/* note that the original "try {write} catch ioexception { pad file,
* write again }" in rafcontainer is removed here, because the
* filechannel javadoc specifies that the file will be grown to
* accommodate the new bytes.
*/
if  syncpage
datafactory writeinprogress
try
if  sanitymanager debug
synchronized this
iosinprogress
if   datafactory datanotsyncedatallocation
iochannel force false
finally
if  sanitymanager debug
synchronized this
iosinprogress
datafactory writefinished
else
synchronized this
needssync   true
else      iochannel was not initialized  fall back to original method
super writepage pagenumber  pagedata  syncpage
/**
* attempts to fill buf completely from start until it's full.
* <p>
* filechannel has no readfull() method, so we roll our own.
*/
private final void readfull bytebuffer dstbuffer
filechannel srcchannel
long position
throws ioexception
while dstbuffer remaining   > 0
if  srcchannel read dstbuffer  position   dstbuffer position
1
throw new eofexception
/**
* attempts to write buf completely from start until end, at the given
* position in the destination filechannel.
* <p>
* filechannel has no writefull() method, so we roll our own.
*/
private final void writefull bytebuffer srcbuffer
filechannel dstchannel
long position
throws ioexception
while srcbuffer remaining   > 0
dstchannel write srcbuffer  position   srcbuffer position