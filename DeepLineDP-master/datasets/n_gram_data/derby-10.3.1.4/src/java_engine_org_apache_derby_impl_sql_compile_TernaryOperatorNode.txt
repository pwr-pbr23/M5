/*
derby - class org.apache.derby.impl.sql.compile.ternaryoperatornode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services compiler localfield
import org apache derby iapi services io storedformatids
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi store access qualifier
import org apache derby iapi error standardexception
import org apache derby iapi sql compile typecompiler
import org apache derby iapi types numberdatavalue
import org apache derby iapi types stringdatavalue
import org apache derby iapi types typeid
import org apache derby iapi types datatypedescriptor
import org apache derby iapi store access qualifier
import org apache derby iapi reference sqlstate
import org apache derby iapi reference classname
import org apache derby iapi services classfile vmopcode
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi util jbitset
import org apache derby iapi util reusefactory
import java lang reflect modifier
import java sql types
import java util vector
/**
* a ternaryoperatornode represents a built-in ternary operators.
* this covers  built-in functions like substr().
* java operators are not represented here: the jsql language allows java
* methods to be called from expressions, but not java operators.
*
*/
public class ternaryoperatornode extends valuenode
string		operator
string		methodname
int			operatortype
valuenode	receiver
valuenode	leftoperand
valuenode	rightoperand
string		resultinterfacetype
string		receiverinterfacetype
string		leftinterfacetype
string		rightinterfacetype
int			trimtype
public static final int trim   0
public static final int locate   1
public static final int substring   2
public static final int like   3
public static final int timestampadd   4
public static final int timestampdiff   5
static final string ternaryoperators
static final string ternarymethodnames
static final string ternaryresulttype    classname stringdatavalue
classname numberdatavalue
classname concatabledatavalue
classname booleandatavalue
classname datetimedatavalue
classname numberdatavalue
static final string ternaryargtype
classname stringdatavalue  classname stringdatavalue
classname stringdatavalue  classname stringdatavalue  classname numberdatavalue
classname concatabledatavalue  classname numberdatavalue  classname numberdatavalue
classname datavaluedescriptor  classname datavaluedescriptor  classname datavaluedescriptor
classname datetimedatavalue     classname numberdatavalue      time timestampadd  interval  count
classname datetimedatavalue     classname datetimedatavalue    time2 timestampdiff  interval  time1
/**
* initializer for a ternaryoperatornode
*
* @param receiver		the receiver (eg, string being operated on in substr())
* @param leftoperand	the left operand of the node
* @param rightoperand	the right operand of the node
* @param operatortype	the type of the operand
*/
public void init
object receiver
object leftoperand
object rightoperand
object operatortype
object trimtype
this receiver    valuenode  receiver
this leftoperand    valuenode  leftoperand
this rightoperand    valuenode  rightoperand
this operatortype     integer  operatortype  intvalue
this operator    string  ternaryoperators
this methodname    string  ternarymethodnames
this resultinterfacetype    string  ternaryresulttype
this receiverinterfacetype    string  ternaryargtype
this leftinterfacetype    string  ternaryargtype
this rightinterfacetype    string  ternaryargtype
if  trimtype    null
this trimtype     integer  trimtype  intvalue
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return     operator
methodname
resultinterfacetype
receiverinterfacetype
leftinterfacetype
rightinterfacetype
super tostring
else
return
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  receiver    null
printlabel depth
receiver treeprint depth   1
if  leftoperand    null
printlabel depth
leftoperand treeprint depth   1
if  rightoperand    null
printlabel depth
rightoperand treeprint depth   1
/**
* bind this expression.  this means binding the sub-expressions,
* as well as figuring out what the return type is for this expression.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
receiver   receiver bindexpression fromlist  subquerylist
aggregatevector
leftoperand   leftoperand bindexpression fromlist  subquerylist
aggregatevector
if  rightoperand    null
rightoperand   rightoperand bindexpression fromlist  subquerylist
aggregatevector
if  operatortype    trim
trimbind
else if  operatortype    locate
locatebind
else if  operatortype    substring
substrbind
else if  operatortype    timestampadd
timestampaddbind
else if  operatortype    timestampdiff
timestampdiffbind
return this
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
receiver   receiver preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
leftoperand   leftoperand preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
if  rightoperand    null
rightoperand   rightoperand preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
return this
/**
* do code generation for this ternary operator.
*
* @param acb	the expressionclassbuilder for the class we're generating
* @param mb	the method the expression will go into
*
*
* @exception standardexception		thrown on error
*/
public void generateexpression expressionclassbuilder acb
methodbuilder mb
throws standardexception
int nargs   0
string receivertype   null
/* allocate an object for re-use to hold the result of the operator */
localfield field   acb newfielddeclaration modifier private  resultinterfacetype
receiver generateexpression acb  mb
if  operatortype    trim
mb push trimtype
leftoperand generateexpression acb  mb
mb upcast leftinterfacetype
mb getfield field
nargs   3
receivertype   receiverinterfacetype
else if  operatortype    locate
leftoperand generateexpression acb  mb
mb upcast leftinterfacetype
rightoperand generateexpression acb  mb
mb upcast rightinterfacetype
mb getfield field
nargs   3
else if  operatortype    substring
leftoperand generateexpression acb  mb
mb upcast leftinterfacetype
if  rightoperand    null
rightoperand generateexpression acb  mb
mb upcast rightinterfacetype
else
mb pushnull rightinterfacetype
mb getfield field      third arg
mb push receiver gettypeservices   getmaximumwidth
nargs   4
receivertype   receiverinterfacetype
else if  operatortype    timestampadd    operatortype    timestampdiff
object intervaltype   leftoperand getconstantvalueasobject
if  sanitymanager debug
sanitymanager assert  intervaltype    null    intervaltype instanceof integer
operator
mb push    integer  intervaltype  intvalue
rightoperand generateexpression  acb  mb
mb upcast  ternaryargtype
acb getcurrentdateexpression  mb
mb getfield field
nargs   4
receivertype   receiverinterfacetype
mb callmethod vmopcode invokeinterface  receivertype  methodname  resultinterfacetype  nargs
/*
** store the result of the method call in the field, so we can re-use
** the object.
*/
mb putfield field
/**
* set the leftoperand to the specified valuenode
*
* @param newleftoperand	the new leftoperand
*/
public void setleftoperand valuenode newleftoperand
leftoperand   newleftoperand
/**
* get the leftoperand
*
* @return the current leftoperand.
*/
public valuenode getleftoperand
return leftoperand
/**
* set the rightoperand to the specified valuenode
*
* @param newrightoperand	the new rightoperand
*/
public void setrightoperand valuenode newrightoperand
rightoperand   newrightoperand
/**
* get the rightoperand
*
* @return the current rightoperand.
*/
public valuenode getrightoperand
return rightoperand
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode.
* @exception standardexception			thrown on error
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
throws standardexception
boolean pushable
pushable   receiver categorize referencedtabs  simplepredsonly
pushable    leftoperand categorize referencedtabs  simplepredsonly     pushable
if  rightoperand    null
pushable    rightoperand categorize referencedtabs  simplepredsonly     pushable
return pushable
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @return valuenode			the remapped expression tree.
*
* @exception standardexception			thrown on error
*/
public valuenode remapcolumnreferencestoexpressions
throws standardexception
receiver   receiver remapcolumnreferencestoexpressions
leftoperand   leftoperand remapcolumnreferencestoexpressions
if  rightoperand    null
rightoperand   rightoperand remapcolumnreferencestoexpressions
return this
/**
* return whether or not this expression tree represents a constant expression.
*
* @return	whether or not this expression tree represents a constant expression.
*/
public boolean isconstantexpression
return  receiver isconstantexpression
leftoperand isconstantexpression
rightoperand    null    rightoperand isconstantexpression
/** @see valuenode#constantexpression */
public boolean constantexpression predicatelist whereclause
return  receiver constantexpression whereclause
leftoperand constantexpression whereclause
rightoperand    null
rightoperand constantexpression whereclause
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
visitable returnnode   v visit this
if  v skipchildren this
return returnnode
if  receiver    null     v stoptraversal
receiver    valuenode receiver accept v
if  leftoperand    null     v stoptraversal
leftoperand    valuenode leftoperand accept v
if  rightoperand    null     v stoptraversal
rightoperand    valuenode rightoperand accept v
return returnnode
/**
* bind trim expression.
* the variable receiver is the string that needs to be trimmed.
* the variable leftoperand is the character that needs to be trimmed from
*     receiver.
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
private valuenode trimbind
throws standardexception
typeid	receivertype
typeid	resulttype   typeid getbuiltintypeid types varchar
// handle parameters here
/* is there a ? parameter for the receiver? */
if  receiver requirestypefromcontext
/*
** according to the sql standard, if trim has a ? receiver,
** its type is varchar with the implementation-defined maximum length
** for a varchar.
*/
receiver settype getvarchardescriptor
//check if this parameter can pick up it's collation from the
//character that will be used for trimming. if not(meaning the
//character to be trimmed is also a parameter), then it will take
//it's collation from the compilation schema.
if   leftoperand requirestypefromcontext
receiver gettypeservices   setcollationderivation
leftoperand gettypeservices   getcollationderivation
receiver gettypeservices   setcollationtype
leftoperand gettypeservices   getcollationtype
else
receiver setcollationusingcompilationschema
stringdatavalue collation_derivation_implicit
/* is there a ? parameter on the left? */
if  leftoperand requirestypefromcontext
/* set the left operand type to varchar. */
leftoperand settype getvarchardescriptor
//collation of ? operand should be picked up from the context.
//by the time we come here, receiver will have correct collation
//set on it and hence we can rely on it to get correct collation
//for the ? for the character that needs to be used for trimming.
leftoperand gettypeservices   setcollationderivation
receiver gettypeservices   getcollationderivation
leftoperand gettypeservices   setcollationtype
receiver gettypeservices   getcollationtype
bindtobuiltin
/*
** check the type of the receiver - this function is allowed only on
** string value types.
*/
receivertype   receiver gettypeid
if  receivertype usertype
throwbadtype    receivertype getsqltypename
receiver   castargtostring receiver
if   receivertype gettypeformatid      storedformatids clob_type_id
receivertype gettypeformatid      storedformatids nclob_type_id
// special case for clobs: if we start with a clob, we have to get
// a clob as a result (as opposed to a varchar), because we can have a
// clob that is beyond the max length of varchar (ex. "clob(100k)").
// this is okay because clobs, like varchars, allow variable-length
// values (which is a must for the trim to actually work).
resulttype   receivertype
/*
** check the type of the leftoperand (trimset).
** the leftoperand should be a string value type.
*/
typeid	leftcti
leftcti   leftoperand gettypeid
if  leftcti usertype
throwbadtype    leftcti getsqltypename
leftoperand   castargtostring leftoperand
/*
** the result type of trim is varchar.
*/
setresulttype resulttype
//result of trim should pick up the collation of the character string
//that is getting trimmed (which is variable receiver) because it has
//correct collation set on it.
gettypeservices   setcollationderivation
receiver gettypeservices   getcollationderivation
gettypeservices   setcollationtype
receiver gettypeservices   getcollationtype
return this
/*
** set result type for operator
*/
private void setresulttype typeid resulttype  throws standardexception
settype new datatypedescriptor
resulttype
true
receiver gettypeservices   getmaximumwidth
/**
* bind locate operator
* the variable receiver is the string which will searched
* the variable leftoperand is the search character that will looked in the
*     receiver variable.
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode locatebind   throws standardexception
typeid	firstoperandtype  secondoperandtype  offsettype
/*
* is there a ? parameter for the first arg.  copy the
* left/firstoperand's.  if the left/firstoperand are both parameters,
* both will be max length.
*/
if  receiver requirestypefromcontext
if  leftoperand requirestypefromcontext
receiver settype getvarchardescriptor
//since both receiver and leftoperands are parameters, use the
//collation of compilation schema for receiver.
receiver setcollationusingcompilationschema
stringdatavalue collation_derivation_implicit
else
if  leftoperand gettypeid   isstringtypeid
//since the leftoperand is not a parameter, receiver will
//get it's collation from leftoperand through following
//settype method
receiver settype
leftoperand gettypeservices
/*
* is there a ? parameter for the second arg.  copy the receiver's.
* if the receiver are both parameters, both will be max length.
*/
if leftoperand requirestypefromcontext
if receiver requirestypefromcontext
leftoperand settype getvarchardescriptor
else
if  receiver gettypeid   isstringtypeid
leftoperand settype
receiver gettypeservices
//collation of ? operand should be picked up from the context.
//by the time we come here, receiver will have correct collation
//set on it and hence we can rely on it to get correct collation
//for this ?
leftoperand gettypeservices   setcollationderivation
receiver gettypeservices   getcollationderivation
leftoperand gettypeservices   setcollationtype
receiver gettypeservices   getcollationtype
/*
* is there a ? paramter for the third arg.  it will be an int.
*/
if  rightoperand requirestypefromcontext
rightoperand settype
new datatypedescriptor typeid integer_id  true
bindtobuiltin
/*
** check the type of the operand - this function is allowed only
** for: receiver = char
**      firstoperand = char
**      secondoperand = int
*/
secondoperandtype   leftoperand gettypeid
offsettype   rightoperand gettypeid
firstoperandtype   receiver gettypeid
if   firstoperandtype isstringtypeid
secondoperandtype isstringtypeid
offsettype getjdbctypeid      types integer
throw standardexception newexception sqlstate lang_db2_function_incompatible
/*
** the result type of a locatefunctionnode is an integer.
*/
settype new datatypedescriptor typeid integer_id
receiver gettypeservices   isnullable
return this
/* cast arg to a varchar */
protected valuenode castargtostring valuenode vn  throws standardexception
typecompiler vntc   vn gettypecompiler
if    vn gettypeid   isstringtypeid
valuenode newnode    valuenode
getnodefactory   getnode
c_nodetypes cast_node
vn
datatypedescriptor getbuiltindatatypedescriptor types varchar  true
vntc getcasttocharwidth
vn gettypeservices
getcontextmanager
castnode  newnode  bindcastnodeonly
return newnode
return vn
/**
* bind substr expression.
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode substrbind
throws standardexception
typeid	receivertype
typeid	resulttype
// handle parameters here
/* is there a ? parameter for the receiver? */
if  receiver requirestypefromcontext
/*
** according to the sql standard, if substr has a ? receiver,
** its type is varchar with the implementation-defined maximum length
** for a varchar.
*/
receiver settype getvarchardescriptor
//collation of ? operand should be same as the compilation schema
//because that is the only context available for us to pick up the
//collation. there are no other character operands to substr method
//to pick up the collation from.
receiver setcollationusingcompilationschema
stringdatavalue collation_derivation_implicit
/* is there a ? parameter on the left? */
if  leftoperand requirestypefromcontext
/* set the left operand type to int. */
leftoperand settype
new datatypedescriptor typeid integer_id  true
/* is there a ? parameter on the right? */
if   rightoperand    null     rightoperand requirestypefromcontext
/* set the right operand type to int. */
rightoperand settype
new datatypedescriptor typeid integer_id  true
bindtobuiltin
if   leftoperand gettypeid   isnumerictypeid
rightoperand    null     rightoperand gettypeid   isnumerictypeid
throw standardexception newexception sqlstate lang_db2_function_incompatible
/*
** check the type of the receiver - this function is allowed only on
** string value types.
*/
resulttype   receivertype   receiver gettypeid
switch  receivertype getjdbctypeid
case types char
case types varchar
case types longvarchar
case types clob
break
default
throwbadtype    receivertype getsqltypename
// determine the maximum length of the result
int resultlen   receiver gettypeservices   getmaximumwidth
if  rightoperand    null    rightoperand instanceof constantnode
if    constantnode rightoperand  getvalue   getint   < resultlen
resultlen     constantnode rightoperand  getvalue   getint
/*
** the result type of substr is a string type
*/
settype new datatypedescriptor
resulttype
true
resultlen
//result of susbstr should pick up the collation of the 1st argument
//to substr. the 1st argument to substr is represented by the variable
//receiver in this class.
gettypeservices   setcollationderivation
receiver gettypeservices   getcollationderivation
gettypeservices   setcollationtype
receiver gettypeservices   getcollationtype
return this
/**
* bind timestampadd expression.
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
private valuenode timestampaddbind
throws standardexception
if    bindparameter  rightoperand  types integer
int jdbctype   rightoperand gettypeid   getjdbctypeid
if  jdbctype    types tinyint    jdbctype    types smallint
jdbctype    types integer    jdbctype    types bigint
throw standardexception newexception sqlstate lang_invalid_function_arg_type
rightoperand gettypeid   getsqltypename
reusefactory getinteger  2
operator
binddatetimearg  receiver  3
settype datatypedescriptor getbuiltindatatypedescriptor  types timestamp
return this
end of timestampaddbind
/**
* bind timestampdiff expression.
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
private valuenode timestampdiffbind
throws standardexception
binddatetimearg  rightoperand  2
binddatetimearg  receiver  3
settype datatypedescriptor getbuiltindatatypedescriptor  types bigint
return this
end of timestampdiffbind
private void binddatetimearg  valuenode arg  int argnumber  throws standardexception
if    bindparameter  arg  types timestamp
if    arg gettypeid   isdatetimetimestamptypeid
throw standardexception newexception sqlstate lang_invalid_function_arg_type
arg gettypeid   getsqltypename
reusefactory getinteger  argnumber
operator
end of binddatetimearg
/**
* this method gets called for non-character string types and hence no need
* to set any collation info. collation applies only to character string
* types.
*
* @param arg check if arg is a ? param and if yes, then set it's type to
*    jdbctype if arg doesn't have a type associated with it.
*
* @param jdbctype associate this type with arg if arg is a ? param with no
*    type associated with it
*
* @return true if arg is a ? param with no type associated with it
* @throws standardexception
*/
private boolean bindparameter  valuenode arg  int jdbctype  throws standardexception
if  arg requirestypefromcontext      arg gettypeid      null
arg settype  new datatypedescriptor typeid getbuiltintypeid  jdbctype   true
return true
return false
end of bindparameter
public valuenode getreceiver
return receiver
/* throw bad type message */
private void throwbadtype string funcname  string type
throws standardexception
throw standardexception newexception sqlstate lang_unary_function_bad_type
funcname
type
/* bind arguments to built in types */
protected void bindtobuiltin
throws standardexception
/* if the receiver is not a built-in type, then generate a bound conversion
* tree to a built-in type.
*/
if  receiver gettypeid   usertype
receiver   receiver gensqljavasqltree
/* if the left operand is not a built-in type, then generate a bound conversion
* tree to a built-in type.
*/
if  leftoperand gettypeid   usertype
leftoperand   leftoperand gensqljavasqltree
/* if the right operand is not a built-in type, then generate a bound conversion
* tree to a built-in type.
*/
if  rightoperand    null
if  rightoperand gettypeid   usertype
rightoperand   rightoperand gensqljavasqltree
private datatypedescriptor getvarchardescriptor
return new datatypedescriptor typeid getbuiltintypeid types varchar   true
protected boolean isequivalent valuenode o  throws standardexception
if  issamenodetype o
ternaryoperatornode other    ternaryoperatornode o
/*
* substr function can either have 2 or 3 arguments.  in the
* 2-args case, rightoperand will be null and thus needs
* additional handling in the equivalence check.
*/
return  other methodname equals methodname
other receiver isequivalent receiver
other leftoperand isequivalent leftoperand
rightoperand    null    other rightoperand    null
other rightoperand    null
other rightoperand isequivalent rightoperand
return false