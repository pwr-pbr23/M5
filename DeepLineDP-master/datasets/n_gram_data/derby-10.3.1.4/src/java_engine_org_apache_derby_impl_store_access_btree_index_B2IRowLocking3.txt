/*
derby - class org.apache.derby.impl.store.access.btree.index.b2irowlocking3
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree index
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store raw fetchdescriptor
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw transaction
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby impl store access btree btree
import org apache derby impl store access btree btreelockingpolicy
import org apache derby impl store access btree controlrow
import org apache derby impl store access btree leafcontrolrow
import org apache derby impl store access btree openbtree
import org apache derby impl store access btree btreerowposition
import org apache derby impl store access btree waiterror
/**
implements the jdbc serializable isolation level using row locks.
<p>
holds read and write locks until end of transaction.
obtains previous key locks to protect from phantom reads.
**/
class b2irowlocking3 implements btreelockingpolicy
/**************************************************************************
* private/protected fields of this class:
**************************************************************************
*/
/**
* the container id of the base container for this index.  used to build
* record handles to make lock calls on.
**/
protected conglomeratecontroller        base_cc
/**
* the openbtree to use if we have to lock anything in the btree vs.
* base row locking.
**/
protected openbtree                     open_btree
/**
* the locking policy to use to get and release the scan locks.  we could
* cache this somewhere better.
**/
private lockingpolicy                   scan_locking_policy
/**
* the transaction to associate lock requests with.
**/
private transaction                     rawtran
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
b2irowlocking3
transaction             rawtran
int                     lock_level
lockingpolicy           locking_policy
conglomeratecontroller  base_cc
openbtree               open_btree
this rawtran               rawtran
this base_cc               base_cc
this open_btree            open_btree
this scan_locking_policy
rawtran newlockingpolicy
lockingpolicy mode_record
transactioncontroller isolation_read_committed  true
/**************************************************************************
* private methods of this class:
**************************************************************************
*/
private boolean _lockscan
recordhandle    rh
boolean         forupdate
boolean         wait
throws standardexception
boolean ret_val   true
// only get the scan lock if we are record locking.
if   forupdate
ret_val
scan_locking_policy lockrecordforread
rawtran  open_btree getcontainerhandle
rh  wait  false
else
ret_val
scan_locking_policy lockrecordforwrite
rawtran  rh  false  wait
return ret_val
/**
* lock key previous to first key in btree.
* <p>
* in the previous key locking protocol repeatable read and phantom
* protection is guaranteed by locking a range of keys in the btree.
* the range is defined by the key previous to the first key you look
* at and all subsequent keys you look at.  the first key in the index
* is a special case, as there are no keys previous to it.  in that
* case a special key is declared the "previous key" to the first key
* in the btree and is locked instead.
* <p>
* in this implementation that first key is defined to be in the base
* container, page containerhandle.first_page_number, record id
* previous_key_handle.
* <p>
* note that the previous key is the same for all indexes on a given
* conglomerate.  it seemed better for all locks on a base table to have
* the same containerid, rather than having some locks generated from
* a btree have a containerid from base table and some having a containerid
* from the btree.  if this turns out to be a problem we could either
* have 2 different containerid's, be more creative with the record id, or
* even add more to the lock key.
*
* @param aux_leaf          if non-null, this leaf is unlatched if the
*                          routine has to wait on the lock.
* @param lock_operation    whether to lock exclusive or share.
* @param lock_duration     for what duration should the lock be held,
*                          if instant_duration, then the routine will
*                          guarantee that lock was acquired while holding
*                          the latch, but then immediately release the
*                          lock.  if commit_duration or manual_duration
*                          then the lock be held when routine returns
*                          successfully.
*
* @exception  standardexception  standard exception policy.
**/
private boolean lockprevioustofirstkey
leafcontrolrow          current_leaf
leafcontrolrow          aux_leaf
int                     lock_operation
int                     lock_duration
throws standardexception
// this is first row in table, lock the special key that
// represents the key previous to the first key of the table.
// first try to get the lock nowait, while latch is held.
boolean ret_status
base_cc lockrow
btree rootpageid
recordhandle previous_key_handle
lock_operation
false    nowait
lock_duration
if   ret_status
current_leaf release
current_leaf   null
if  aux_leaf    null
aux_leaf release
aux_leaf   null
// couldn't get the lock nowait, release latch and wait for lock.
base_cc lockrow
btree rootpageid
recordhandle previous_key_handle
lock_operation
true    wait
lock_duration
return ret_status
/**
* lock a btree row (row is at given slot in page).
* <p>
* lock the row at the given slot in the page.  meant to be used if caller
* only has the slot on the page to be locked, and has not read the row
* yet.  this routine fetches the row location field from the page, and then
* locks that rowlocation in the base container.
* <p>
* lock a btree row, enforcing the standard lock/latch protocol.
* on return the row is locked.  return status indicates if the lock
* was waited for, which will mean a latch was dropped while waiting.
* in general a false status means that the caller will either have
* to research the tree unless some protocol has been implemented that
* insures that the row will not have moved while the latch was dropped.
* <p>
* this routine request a row lock nowait on the in-memory row
* "current_row.".  if the lock is granted the routine will return true.
* if the lock cannot be granted nowait, then the routine will release
* the latch on "current_leaf" and "aux_leaf" (if aux_leaf is non-null),
* and then it will request a wait lock on the row.
* <p>
*
* @param btree             the conglomerate we are locking.
* @param current_leaf      latched current leaf where "current" key is.
* @param aux_leaf          if non-null, this leaf is unlatched if the
*                          routine has to wait on the lock.
* @param current_slot      slot of row to lock.
* @param lock_fetch_desc   descriptor for fetching just the rowlocation,
*                          used for locking.
* @param check_changed_rowloc
*                          whether to check for the changed rowloc or not.
* @param lock_operation    whether lock is for key prev to insert or not.
* @param lock_duration     for what duration should the lock be held,
*                          if instant_duration, then the routine will
*                          guarantee that lock was acquired while holding
*                          the latch, but then immediately release the
*                          lock.  if commit_duration or manual_duration
*                          then the lock be held when routine returns
*                          successfully.
*
* @exception  standardexception  standard exception policy.
**/
private boolean lockrowonpage
btree                   btree
leafcontrolrow          current_leaf
leafcontrolrow          aux_leaf
int                     current_slot
boolean                 check_changed_rowloc
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
int                     lock_operation
int                     lock_duration
throws standardexception
if  sanitymanager debug
sanitymanager assert current_leaf    null
if  current_slot <  0
current_slot >  current_leaf getpage   recordcount
sanitymanager throwassert
current_slot
current_leaf getpage   recordcount
if    btree instanceof b2i
sanitymanager throwassert
btree getclass   getname
sanitymanager assert lock_template    null
// for now the rowlocation is expected to be the object located in
// the last column of the lock_template, this may change if we
// ever support rows with rowlocations somewhere else.
sanitymanager assert
lock_row_loc    lock_template
// fetch the row location to lock.
recordhandle rec_handle
current_leaf getpage   fetchfromslot
recordhandle  null  current_slot
lock_template  lock_fetch_desc  true
// first try to get the lock nowait, while latch is held.
boolean ret_status
base_cc lockrow
lock_row_loc
lock_operation
false    nowait     lock_duration
if   ret_status
// could not get the lock nowait, release latch and wait for lock.
if  current_leaf    null
current_leaf release
current_leaf   null
if  aux_leaf    null
aux_leaf release
aux_leaf   null
base_cc lockrow
lock_row_loc
lock_operation
true    wait     lock_duration
return ret_status
private boolean searchleftandlockpreviouskey
b2i                     b2i
leafcontrolrow          current_leaf
int                     current_slot
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
openbtree               open_btree
int                     lock_operation
int                     lock_duration
throws standardexception
boolean         latches_released   false
leafcontrolrow  prev_leaf
leafcontrolrow  prev_prev_leaf
try
// move left in tree, page latch will be requested nowait,
// and waiterror will be thrown if latch not granted.
prev_leaf
leafcontrolrow  current_leaf getleftsibling open_btree
catch  waiterror e
long previous_pageno   current_leaf getleftsiblingpagenumber
// error going from mainpage to first left page.  release
// current page latch and continue the search.
current_leaf release
current_leaf   null
// wait on the left page, which we could not get before.
prev_leaf    leafcontrolrow
controlrow get open_btree  previous_pageno
latches_released   true
while  true
try
// loop searching left in the btree until you either find
// a record to lock, or you reach the leftmost empty leaf.
if  prev_leaf getpage   recordcount   > 1
// lock the last row on the page, which is the previous
// record to the first row on the next page.
boolean ret_status
lockrowonpage
b2i
prev_leaf
current_leaf
prev_leaf getpage   recordcount     1
false
lock_fetch_desc
lock_template
lock_row_loc
lock_operation
lock_duration
if   ret_status
prev_leaf          null
current_leaf       null
latches_released   true
break
else if  prev_leaf isleftmostleaf
// table's first row, lock the key that represents the
// key previous to first key of the table.
boolean ret_status
lockprevioustofirstkey
prev_leaf  current_leaf
lock_operation  lock_duration
if   ret_status
prev_leaf          null
current_leaf       null
latches_released   true
break
// move left in tree, page latch will be requested nowait,
// and waiterror will be thrown if latch not granted.
// release latches on pages between "current_leaf" and
// where the search leads, so that at most 3 latched pages
// (current_leaf, prev_leaf, prev_prev_leaf) are held during
// the search.  do left ladder locking as you walk left,
// but be ready to release l
prev_prev_leaf
leafcontrolrow  prev_leaf getleftsibling open_btree
prev_leaf release
prev_leaf   prev_prev_leaf
prev_prev_leaf   null
catch  waiterror e
long previous_pageno   prev_leaf getleftsiblingpagenumber
// error going left.  release current page latch and
// original page latch continue the search.
current_leaf release
current_leaf   null
prev_leaf release
prev_leaf   null
// wait on the left page, which we could not get before.
prev_leaf    leafcontrolrow
controlrow get open_btree  previous_pageno
latches_released   true
if  prev_leaf    null
prev_leaf release
return  latches_released
/**************************************************************************
* protected methods of this class:
**************************************************************************
*/
/**
* lock a row as part of doing the scan.
* <p>
* lock the row at the given slot (or the previous row if slot is 0).
* get the scan lock on the page if "request_scan_lock" is true.
* <p>
* if this routine returns true all locks were acquired while maintaining
* the latch on leaf.  if this routine returns false, locks may or may
* not have been acquired, and the routine should be called again after
* the client has researched the tree to reget the latch on the
* appropriate page.
* (p>
* as a sided effect stores the value of the record handle of the current
* scan lock.
*
* @return whether locks were acquired without releasing latch on leaf.
*
* @param open_btree        the open_btree to associate latches with -
*                          used if routine has to scan backward.
* @param btree             the conglomerate info.
* @param pos               the position of the row to lock.
* @param request_row_lock  whether to request the row lock, should
*                          only be requested once per page in the scan.
* @param request_scan_lock whether to request the page scan lock, should
*                          only be requested once per page in the scan.
* @param lock_fetch_desc   the fetch descriptor to use to fetch the
*                          row location for the lock request.
* @param lock_template     a scratch area to use to read in rows.
* @param previous_key_lock is this a previous key lock call?
* @param forupdate         is the scan for update or for read only.
*
* @exception  standardexception  standard exception policy.
**/
protected boolean _lockscanrow
openbtree               open_btree
btree                   btree
btreerowposition        pos
boolean                 request_row_lock
boolean                 request_scan_lock
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
boolean                 previous_key_lock
boolean                 forupdate
int                     lock_operation
throws standardexception
boolean latch_released   false
b2i     b2i               b2i  btree
if  request_row_lock
// in order to implement a serialized scan based on previous
// key locking, this method acquires a row lock on
// the base table's row from the index row at [startpage/startslot].
// this will be the 'previous key'.
if  pos current_slot    0
// this call will take care of searching left in the btree
// to find the previous row to lock, 0 is the control row and
// not a valid thing to lock as a previous key.
// it is ok to call the non-scan as this is just a special
// case of a previous key lock call.  the only scan code that
// will call this routine with slot == 0 will retry if this
// routine returns that a latch was released.
latch_released
locknonscanpreviousrow
btree
pos current_leaf
1    lock row previous to row at slot 1
lock_fetch_desc
lock_template
lock_row_loc
open_btree
lock_operation
transactionmanager lock_commit_duration
// special test to see if latch release code works
if  sanitymanager debug
latch_released
openbtree test_errors
open_btree
false
this  pos current_leaf  latch_released
else
// just lock the row at "slot"
latch_released
lockrowonpage
btree
pos current_leaf
leafcontrolrow  null    no other latch currently
pos current_slot
true
lock_fetch_desc
lock_template
lock_row_loc
lock_operation
transactionmanager lock_commit_duration
// special test to see if latch release code works
if  sanitymanager debug
latch_released
openbtree test_errors
open_btree
false
this  pos current_leaf  latch_released
if  request_scan_lock     latch_released
// get the scan lock on the start page.
// get shared record_id_protection_handle lock to make sure that
// we wait for scans in other transactions to move off of this page
// before we split.
latch_released
lockscan
pos current_leaf
leafcontrolrow  null     no other latch currently
false
conglomeratecontroller lock_read     read scan lock position
// special test to see if latch release code works
if  sanitymanager debug
/* resolve - need to get a container here */
latch_released
openbtree test_errors
open_btree
true
this  pos current_leaf  latch_released
return  latch_released
/**************************************************************************
* public methods of this class:
**************************************************************************
*/
/**************************************************************************
* abstract protected lockscan*() locking methods of btree:
*     lockscan                 - lock the scan page
*     lockscanforreclaimspace  - lock page for reclaiming deleted rows.
*     lockscanrow              - lock row and possibly the scan page
*     unlockscan               - unlock the scan page
*     unlockscanrecordafterread- unlock the scan record
**************************************************************************
*/
/**
* lock a control row page for scan.
* <p>
* scanners get shared lock on the page while positioned on a row within
* the page, splitter/purgers/mergers get exclusive lock on the page.
*
* see btree.lockscan() for more info.
*
* @exception  standardexception  standard exception policy.
**/
public boolean lockscan
leafcontrolrow          current_leaf
controlrow              aux_control_row
boolean                 forupdate
int                     lock_operation
throws standardexception
// the scan page lock is implemented as a row lock on the reserved
// row id on the page (recordhandle.record_id_protection_handle).
recordhandle scan_lock_rh
current_leaf getpage   makerecordhandle
recordhandle record_id_protection_handle
// first try to get the lock nowait, while latch is held.
boolean ret_status
_lockscan scan_lock_rh  forupdate  false    nowait
if   ret_status
current_leaf release
current_leaf   null
if  aux_control_row    null
aux_control_row release
aux_control_row   null
// could not get the lock nowait, release latch and wait
// for the lock.
_lockscan scan_lock_rh  forupdate  true    wait
// once we get the lock, give it up as we need to get the lock
// while we have the latch.  when the lock manager gives us the
// ability to do instantaneous locks do that.  we just wait on the
// lock to give the split a chance to finish before we interfere.
if   forupdate
scan_locking_policy unlockrecordafterread
rawtran  open_btree getcontainerhandle
scan_lock_rh  false  true
else
// resolve - need instantaneous locks as there is no way
// currently to release a write lock.  this lock will only
// be requested by split, and will be released by internal
// transaction.
return ret_status
/**
* lock a control row page for reclaiming deleted rows.
* <p>
* when reclaiming deleted rows during split need to get an exclusive
* scan lock on the page, which will mean there are no other scans
* positioned on the page.  if there are other scans positioned, just
* give up on reclaiming space now.
*
* @return true if lock was granted nowait, else false and not lock was
*         granted.
*
* @exception  standardexception  standard exception policy.
**/
public boolean lockscanforreclaimspace
leafcontrolrow          current_leaf
throws standardexception
// the scan page lock is implemented as a row lock on the reserved
// row id on the page (recordhandle.record_id_protection_handle).
recordhandle scan_lock_rh
current_leaf getpage   makerecordhandle
recordhandle record_id_protection_handle
// first try to get the lock nowait, while latch is held.
return
_lockscan scan_lock_rh  true    update     false    nowait
/**
* lock a btree row to determine if it is a committed deleted row.
* <p>
* @see btreelockingpolicy#lockscancommitteddeletedrow
*
* @exception  standardexception  standard exception policy.
**/
public boolean lockscancommitteddeletedrow
openbtree               open_btree
leafcontrolrow          leaf
datavaluedescriptor   template
fetchdescriptor         lock_fetch_desc
int                     slot_no
throws standardexception
if  sanitymanager debug
sanitymanager assert leaf    null
if  slot_no <  0    slot_no >  leaf getpage   recordcount
sanitymanager throwassert
slot_no
leaf getpage   recordcount
sanitymanager assert template    null
rowlocation row_loc    rowlocation
template
// fetch the row location to lock.
leaf getpage   fetchfromslot
recordhandle  null  slot_no  template  lock_fetch_desc  true
// request the lock nowait, return status
return
base_cc lockrow row_loc
conglomeratecontroller lock_upd
false    nowait
transactionmanager lock_commit_duration
/**
* lock a row as part of doing the scan.
* <p>
* lock the row at the given slot (or the previous row if slot is 0).
* get the scan lock on the page if "request_scan_lock" is true.
* <p>
* if this routine returns true all locks were acquired while maintaining
* the latch on leaf.  if this routine returns false, locks may or may
* not have been acquired, and the routine should be called again after
* the client has researched the tree to reget the latch on the
* appropriate page.
* (p>
* as a sided effect stores the value of the record handle of the current
* scan lock.
*
* @return whether locks were acquired without releasing latch on leaf.
*
* @param open_btree        the open_btree to associate latches with -
*                          used if routine has to scan backward.
* @param btree             the conglomerate info.
* @param pos               the position of the row to lock.
* @param request_scan_lock whether to request the page scan lock, should
*                          only be requested once per page in the scan.
* @param lock_template     a scratch area to use to read in rows.
* @param previous_key_lock is this a previous key lock call?
* @param forupdate         is the scan for update or for read only.
*
* @exception  standardexception  standard exception policy.
**/
public boolean lockscanrow
openbtree               open_btree
btree                   btree
btreerowposition        pos
boolean                 request_scan_lock
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
boolean                 previous_key_lock
boolean                 forupdate
int                     lock_operation
throws standardexception
return
_lockscanrow
open_btree
btree
pos
true      request the row lock  always true for iso 3
request_scan_lock
lock_fetch_desc
lock_template
lock_row_loc
previous_key_lock
forupdate
lock_operation
/**
* release read lock on a row.
*
* for serializable, there is no work to do.
*
*
**/
public void unlockscanrecordafterread
btreerowposition        pos
boolean                 forupdate
throws standardexception
return
/**
* release the lock gotten by calling lockscan.  this call can only be
* made to release read scan locks, write scan locks must be held until
* end of transaction.
* <p>
* see btree.unlockscan() for more info.
*
**/
public void unlockscan
long            page_number
// this is first row in table, lock the special key that
// represents the key previous to the first key of the table.
try
recordhandle scan_lock_rh
open_btree makerecordhandle
page_number  recordhandle record_id_protection_handle
scan_locking_policy unlockrecordafterread
rawtran  open_btree getcontainerhandle
scan_lock_rh  false  true
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert se
/**************************************************************************
* abstract protected locknonscan*() locking methods of btree:
*
*     locknonscanpreviousrow   - lock the row previous to the current
*     locknonscanrow           - lock the input row
**************************************************************************
*/
/**
* lock the row previous to the input row.
* <p>
* see btree.lockpreviousrow() for more info.
*
* @exception  standardexception  standard exception policy.
**/
public boolean locknonscanpreviousrow
btree                   btree
leafcontrolrow          current_leaf
int                     current_slot
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
openbtree               open_btree
int                     lock_operation
int                     lock_duration
throws standardexception
boolean          ret_status
if  sanitymanager debug
sanitymanager assert btree instanceof b2i
if  current_slot > 1
// easy case, just lock the key previous to the current one.
// lock (current_slot - 1)
ret_status
lockrowonpage
btree
current_leaf   leafcontrolrow  null
current_slot   1
false
lock_fetch_desc
lock_template
lock_row_loc
lock_operation  lock_duration
else
// should only be called while pointing at a valid location, 0
// is not a valid key slot - it is the control row.
if  sanitymanager debug
sanitymanager assert current_slot    1
if  current_leaf isleftmostleaf
// this is first row in table, lock the special key that
// represents the key previous to the first key of the table.
ret_status
lockprevioustofirstkey
current_leaf   leafcontrolrow  null
lock_operation  lock_duration
else
// the previous key is on a previous page, search left
// through the pages to find the key to latch.
// resolve rll (mikem) - do i need to do the
// record_id_protection_handle lock.
// first guarantee that record id's will not move off this
// current page while searching for previous key, by getting
// the record_id_protection_handle lock on the current page.
// since we have a latch on the cur
// resolve rll (mikem) - no record_id protection in effect.
// caller must research, get new locks if this routine
// releases latches.
ret_status   this searchleftandlockpreviouskey
b2i  btree
current_leaf  current_slot
lock_fetch_desc  lock_template  lock_row_loc
open_btree  lock_operation  lock_duration
return ret_status
/**
* lock the in memory row.
* <p>
* see btree.lockrow() for more info.
*
* @exception  standardexception  standard exception policy.
**/
public boolean locknonscanrow
btree                   btree
leafcontrolrow          current_leaf
leafcontrolrow          aux_leaf
datavaluedescriptor   current_row
int                     lock_operation
throws standardexception
if  sanitymanager debug
sanitymanager assert btree instanceof b2i
b2i b2i    b2i  btree
// first try to get the lock nowait, while latch is held.
boolean ret_status
base_cc lockrow
rowlocation  current_row
lock_operation
false    nowait
transactionmanager lock_commit_duration
if   ret_status
// could not get the lock nowait, release latch and wait for lock.
if  current_leaf    null
current_leaf release
current_leaf   null
if  aux_leaf    null
aux_leaf release
aux_leaf   null
base_cc lockrow
rowlocation  current_row
lock_operation
true    wait
transactionmanager lock_commit_duration
return ret_status
public boolean locknonscanrowonpage
btree                   btree
leafcontrolrow          current_leaf
int                     current_slot
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
int                     lock_operation
throws standardexception
return
lockrowonpage
btree
current_leaf

current_slot
false
lock_fetch_desc
lock_template
lock_row_loc
lock_operation
transactionmanager lock_commit_duration