/*
derby - class org.apache.derby.client.am.sqlexception
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client am
import java sql sqlexception
import java util treemap
import org apache derby shared common i18n messageutil
import org apache derby shared common error exceptionutil
import org apache derby shared common reference sqlstate
// the signature of the stored procedure sqlcamessage i have come out so far is as follows:
// sqlcamessage (
//     in  sqlcode       integer,
//     in  sqlerrml      smallint,
//     in  sqlerrmc      varchar(70),
//     in  sqlerrp       char(8),
//     in  sqlerrd0      integer,
//     in  sqlerrd1      integer,
//     in  sqlerrd2      integer,
//     in  sqlerrd3      integer,
//     in  sqlerrd4      integer,
//     in  sqlerrd5      integer,
//     in  sqlwarn       char(11),
//     in  sqlstate      char(5),
//     in  locale        char(5),
//     in  buffersize    smallint,
//     in  linewidth     smallint,
//     out message       varchar(2400))
//
// some issues have been identified:
// 1. what would be the schema name of the stored procedue sqlcamessage?
// 2. what is the format and type of the locale parameter? if there does, i would really like to know the format of the locale in order to decide the type of the locale parameter. even there does not either, the locale parameter probably still needs to be kept there for future extension, and we need to figure out the format of the locale.
// 3. what would be the format of the output message? is this full message text ok or do we only need the explanation message corresponding to an sql code. this somehow matters whether we need the buffersize and linewidth parameters for the stored procedure.
// 4. what if the invocation of stored procedure failed (due to, eg, connection dropping)? in this case, we probably need to return some client-side message.
//
// note that this class does not extend java.sql.sqlexception.  this is because
// in jdbc 4 there will be multiple subclasses of sqlexception defined by the
// spec.  so we can't also extend sqlexception without having to create our
// own mirror hierarchy of subclasses.
//
// when derby is ready to throw an exception to the application, it catches
// sqlexception and converts it to a java.sql.sqlexception by calling the
// method getsqlexception.
//
// it is also possible that internal routines may call public methods.
// in these cases, it will need to wrap a java.sql.sqlexception inside
// a derby sqlexception so that the internal method does not have to throw
// java.sql.sqlexception.  otherwise the chain of dependencies would quickly
// force the majority of internal methods to throw java.sql.sqlexception.
// you can wrap a java.sql.sqlexception inside a sqlexception by using
// the constructor <code>new sqlexception(java.sql.sqlexception wrapme)</code)
//
public class sqlexception extends exception implements diagnosable
protected static final int default_errcode   99999
protected transient sqlca sqlca_   null     for engine generated errors only
/** tells which of the messages in the sqlca this exception refers to
* (counting from 0). for engine generated errors only. */
private transient int messagenumber_
protected string message_   null
protected string cachedmessage_   null
private string batchpositionlabel_     for batched exceptions only
protected string sqlstate_   null
protected int errorcode_   default_errcode
protected string causestring_   null
protected sqlexception nextexception_
protected throwable throwable_
public static string client_message_resource_name
// constants for message ids used in text we print out -- not used
// in sqlexceptions
public static final string caused_by_exception_id
public static final string batch_position_id
//sqlexception factory initialised with default factory
//it will be over written by the sqlexception factory of the
//supported jdbc version
protected static sqlexceptionfactory
exceptionfactory   new sqlexceptionfactory
/**
*  the message utility instance we use to find messages
*  it's primed with the name of the client message bundle so that
*  it knows to look there if the message isn't found in the
*  shared message bundle.
*/
private static messageutil msgutil_
/**
* this routine provides singleton access to an instance of messageutil
* that is constructed for client messages.  it is recommended to use
* this singleton rather than create your own instance.
*
* the only time you need this instance is if you need to directly
* format an internationalized message string.  in most instances this
* is done for you when you invoke a sqlexception constructor
*
* @return a singleton instance of messageutil configured for client
*   messages
*/
public static messageutil getmessageutil
if   msgutil_    null
msgutil_   new messageutil client_message_resource_name
return msgutil_
/**
* the wrapped sqlexception, if one exists
*/
protected sqlexception wrappedexception_
//-----------------constructors-----------------------------------------------
// new constructors that support internationalized messages
// the message id is wrapped inside a class so that we can distinguish
// between the signatures of the new constructors and the old constructors
/**
* create a sqlexception.  this constructor is the "base" constructor;
* all other constructors (which take a clientmessageid) delegate to this
* constructor
*
* @param logwriter
*      can be null, but if provided, it is used to log this exception
*
* @param msgid
*      the message id for this message.  clientmessageid is a simple type-safe
*      wrapper for org.apache.derby.shared.common.reference.sqlstate message id
*      strings.
*
* @param args
*      the set of substitution arguments for the message.  the java message
*      formatter will substitute these arguments into the internationalized
*      strings using the substitution ({0}, {1}, etc.) markers in the string.
*      any object can be passed, but if you want it to be readable, make sure
*      tostring() for the object returns something useful.
*
* @param cause
*      can be null.  indicates the cause of this exception.  if this is
*      an instance of sqlexception or java.sql.sqlexception then the exception
*      is chained into the nextexception chain.  otherwise it is chained
*      using initcause().  on jdk 1.3, since initcause() does not exist,
*      a non-sql exception can not be chained.  instead, the exception class
*      and message text is appended to the message for this exception.
*/
public sqlexception logwriter logwriter
clientmessageid msgid  object args  throwable cause
this
logwriter
cause
getmessageutil   getcompletemessage
msgid msgid
args
exceptionutil getsqlstatefromidentifier msgid msgid
exceptionutil getseverityfromidentifier msgid msgid
// use the following sqlexceptions when you want to override the error
// code that is derived from the severity of the message id.
public sqlexception logwriter logwriter  clientmessageid msgid  object args
sqlcode sqlcode  throwable t
this logwriter  msgid  args  t
this errorcode_   sqlcode getcode
public sqlexception logwriter logwriter  clientmessageid msgid  object args
sqlcode sqlcode
this logwriter  msgid  args  sqlcode   throwable null
public sqlexception logwriter logwriter  clientmessageid msgid  sqlcode sqlcode
this logwriter  msgid   object null  sqlcode
public sqlexception logwriter logwriter  clientmessageid msgid  object arg1
sqlcode sqlcode
this logwriter  msgid  new object  arg1   sqlcode
public sqlexception logwriter logwriter  clientmessageid msgid  object arg1
object arg2  sqlcode sqlcode
this logwriter  msgid  new object  arg1  arg2   sqlcode
// the following constructors are all wrappers around the base constructor,
// created to make it easy to code against them (you don't have to pass
// null arguments or construct object arrays).  see the javadoc for the
// "base" constructor for an explanation of the parameters
public sqlexception  logwriter logwriter
clientmessageid msgid  throwable cause
this  logwriter  msgid   object null  cause
public sqlexception logwriter logwriter  clientmessageid msgid  object args
this logwriter  msgid  args   throwable null
public sqlexception  logwriter logwriter  clientmessageid msgid
this logwriter  msgid   object null
public sqlexception logwriter logwriter  clientmessageid msgid  object arg1
this logwriter  msgid  new object   arg1
public sqlexception logwriter logwriter  clientmessageid msgid
object arg1  throwable cause
this logwriter  msgid  new object   arg1    cause
public sqlexception logwriter logwriter  clientmessageid msgid
object arg1  object arg2  throwable cause
this logwriter  msgid  new object   arg1  arg2    cause
public sqlexception logwriter logwriter
clientmessageid msgid  object arg1  object arg2
this logwriter  msgid  new object   arg1  arg2
public sqlexception logwriter logwriter
clientmessageid msgid  object arg1  object arg2  object arg3
this logwriter  msgid  new object   arg1  arg2  arg3
/**
* create an exception for an engine generated error.
*
* @param logwriter object used for tracing
* @param sqlca the sqlca sent from the server
*/
public sqlexception logwriter logwriter  sqlca sqlca
this sqlca  0  true
// only set the error code for the first exception in the chain (we
// don't know the error code for the rest)
errorcode_   sqlca getsqlcode
if   logwriter    null
logwriter tracediagnosable this
/**
* create one of the exceptions in an exception chain generated by the
* engine. this constructor calls itself recursively to create the rest of
* the exception chain if <code>chain</code> is <code>true</code>.
*
* @param sqlca the sqlca sent from the server
* @param number the message number for this exception (counting from 0)
* @param chain if <code>true</code>, generate the rest of the exception
* chain recursively and link it to this exception
*/
private sqlexception sqlca sqlca  int number  boolean chain
this sqlca_   sqlca
messagenumber_   number
sqlstate_   sqlca getsqlstate number
int nextmsg   number   1
if  chain     sqlca numberofmessages   > nextmsg
setthrowable new sqlexception sqlca  nextmsg  true
// once all messages are internationalized, these methods should become
// private
protected sqlexception logwriter logwriter  string reason  string sqlstate
int errorcode
this logwriter   throwable null  reason  sqlstate  errorcode
protected sqlexception logwriter logwriter  java lang throwable throwable
string reason  string sqlstate  int errorcode
message_   reason
sqlstate_   sqlstate
errorcode_   errorcode
setthrowable throwable
if  logwriter    null
logwriter tracediagnosable this
/**
* set the cause of this exception based on its type.
* <code>sqlexception</code>s and <code>sqlexception</code>s are
* linked with <code>setnextexception()</code> and <code>initcause()</code>.
* all other exception types are linked with <code>initcause()</code>.
*/
private void setthrowable throwable throwable
if   throwable instanceof sqlexception
setnextexception  sqlexception  throwable
else if   throwable instanceof sqlexception
setnextexception  sqlexception  throwable
if  throwable    null
initcause throwable
/**
* wrap a sqlexception in a sqlexception.  this is used by internal routines
* so the don't have to throw sqlexception, which, through the chain of
* dependencies would force more and more internal routines to throw
* sqlexception
*/
public sqlexception sqlexception wrapme
wrappedexception_   wrapme
/**
* convert this sqlexception into a java.sql.sqlexception
*/
public sqlexception getsqlexception
if   wrappedexception_    null
return wrappedexception_
// when we have support for jdbc 4 sqlexception subclasses, this is
// where we decide which exception to create
sqlexception sqle   exceptionfactory getsqlexception getmessage    getsqlstate
geterrorcode
sqle initcause this
// set up the nextexception chain
if   nextexception_    null
// the exception chain gets constructed automatically through
// the beautiful power of recursion
sqle setnextexception nextexception_ getsqlexception
return sqle
// label an exception element in a batched update exception chain.
// this text will be prepended onto the exceptions message text dynamically
// when getmessage() is called.
// called by the agent.
void setbatchpositionlabel int index
batchpositionlabel_   getmessageutil   gettextmessage batch_position_id
index
public sqlca getsqlca
return sqlca_
public string getmessage
if   wrappedexception_    null
return wrappedexception_ getmessage
// the net jdbc message is retrieved and cached if we have a valid
// sqlca handle.
// it is possible that we don't have one in case of a serialized
// sqlexception for instance. in this case, we set the message to the
// last one cached previously (if any available).
// for serialized sqlexception, we can serialize the sqlca as the
// object handle would become invalid, upon deserialization, causing
// the connection and jdbc not being retrievable (hence why it is
// being cached here).
if  sqlca_    null
cachedmessage_   message_
sqlca  sqlca_  getjdbcmessage messagenumber_
else if  cachedmessage_    null
// sqlca is no longer valid, set the message to the previously
// cached one
message_   cachedmessage_
if  batchpositionlabel_    null
message_   batchpositionlabel_   message_
if   causestring_    null
// append the string indicating the cause of the exception
// (this happens only in jdk13 environments)
message_    causestring_
return message_
public string getsqlstate
if   wrappedexception_    null
return wrappedexception_ getsqlstate
return sqlstate_
public int geterrorcode
if   wrappedexception_    null
return wrappedexception_ geterrorcode
return errorcode_
public sqlexception getnextexception
if   wrappedexception_    null
return new sqlexception wrappedexception_ getnextexception
else
return nextexception_
public void setnextexception sqlexception nextexception
if   wrappedexception_    null
wrappedexception_ setnextexception nextexception getsqlexception
else
nextexception_   nextexception
public void setnextexception sqlexception nextexception
if   wrappedexception_    null
wrappedexception_ setnextexception nextexception
else
// add this exception to the end of the chain
sqlexception theend   this
while  theend nextexception_    null
theend   theend nextexception_
theend nextexception_   new sqlexception nextexception
public void printtrace java io printwriter printwriter  string header
exceptionformatter printtrace this  printwriter  header
/**
* helper method to construct an exception which basically says that
* we encountered an underlying java exception
*/
public static sqlexception javaexception logwriter logwriter  throwable e
return new sqlexception logwriter
new clientmessageid  sqlstate java_exception
new object  e getclass   getname    e getmessage     e
// return a single sqlexception without the "next" pointing to another sqlexception.
// because the "next" is a private field in java.sql.sqlexception,
// we have to create a new sqlexception in order to break the chain with "next" as null.
sqlexception copyasunchainedsqlexception logwriter logwriter
if  sqlca_    null
// server error
return new sqlexception sqlca_  messagenumber_  false
else
return new sqlexception logwriter  getmessage    getsqlstate    geterrorcode        client error
/**
* sets the exceptionfactory to be used for creating sqlexception
* @param factory sqlexceptionfactory
*/
public static void setexceptionfactory  sqlexceptionfactory factory
exceptionfactory   factory
// an intermediate exception encapsulation to provide code-reuse
// for common resultset data conversion exceptions.
class columntypeconversionexception extends sqlexception
columntypeconversionexception logwriter logwriter  string sourcetype
string targettype
super logwriter
new clientmessageid sqlstate lang_data_type_get_mismatch
sourcetype  targettype
// an intermediate exception encapsulation to provide code-reuse
// for common crossconverters data conversion exceptions.
class lossofprecisionconversionexception extends sqlexception
lossofprecisionconversionexception logwriter logwriter  string instance
super logwriter  new clientmessageid sqlstate loss_of_precision_exception
instance