/*
derby - class org.apache.derby.impl.store.raw.data.storedpage
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi reference sqlstate
import org apache derby impl store raw data basepage
import org apache derby impl store raw data longcolumnexception
import org apache derby impl store raw data overflowinputstream
import org apache derby impl store raw data pageversion
import org apache derby impl store raw data recordid
import org apache derby impl store raw data rawfield
import org apache derby impl store raw data reclaimspace
import org apache derby impl store raw data storedfieldheader
import org apache derby impl store raw data storedrecordheader
import org apache derby iapi services io formatidutil
import org apache derby iapi services io formatidinputstream
import org apache derby iapi services io formatidoutputstream
import org apache derby iapi services io storedformatids
import org apache derby iapi services io streamstorable
import org apache derby iapi services io typedformat
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access qualifier
import org apache derby iapi store access rowutil
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw fetchdescriptor
import org apache derby iapi store raw page
import org apache derby iapi store raw pagekey
import org apache derby iapi store raw pagetimestamp
import org apache derby iapi store raw rawstorefactory
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw log loginstant
import org apache derby iapi store raw xact rawtransaction
import org apache derby iapi error standardexception
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types orderable
import org apache derby iapi services io arrayinputstream
import org apache derby iapi services io arrayoutputstream
import org apache derby iapi services io formatablebitset
import org apache derby iapi util bytearray
import org apache derby iapi services io compressednumber
import org apache derby iapi services io dynamicbytearrayoutputstream
import org apache derby iapi services io dynamicbytearrayoutputstream
import org apache derby iapi services io limitobjectinput
import org apache derby iapi services io errorobjectinput
import java util zip crc32
import java io ioexception
import java io eofexception
import java io externalizable
import java io invalidclassexception
import java io objectoutput
import java io objectinput
import java io datainput
import java io dataoutput
import java io inputstream
import java io outputstream
import java io bytearrayinputstream
import java io bytearrayoutputstream
/**
storedpage is a sub class of cachedpage that stores page data in a
fixed size byte array and is designed to be written out to a file
through a datainput/dataoutput interface. a storedpage can exist
in its clean or dirty state without the filecontainer it was created
from being in memory.
<p><b>page format</b><br>
the page is broken into five sections
<pre>
+----------+-------------+-------------------+-------------------+----------+
| formatid | page header | records           | slot offset table | checksum |
+----------+-------------+-------------------+-------------------+----------+
</pre>
<br><b>formatid</b><br>
the formatid is a 4 bytes array, it contains the format id of this page.
<br><b>page header</b><br>
the page header is a fixed size, 56 bytes
<pre>
1 byte  boolean			is page an overflow page
1 byte  byte				page status (a field maintained in base page)
8 bytes long				pageversion (a field maintained in base page)
2 bytes unsigned short	number of slots in slot offset table
4 bytes integer			next record identifier
4 bytes integer			generation number of this page (future use)
4 bytes integer			previous generation of this page (future use)
8 bytes biplocation		the location of the beforeimage page (future use)
2 bytes unsigned short	number of deleted rows on page. (new release 2.0)
2 bytes unsigned short    % of the page to keep free for updates
2 bytes short				spare for future use
4 bytes long				spare for future use (encryption uses to write
random bytes here).
8 bytes long				spare for future use
8 bytes long				spare for future use
</pre>
note that spare space has been guaranteed to be writen with "0", so
that future use of field should not either not use "0" as a valid data
item or pick 0 as a valid default value so that on the fly upgrade can
assume that 0 means field was never assigned.
<br><b>records</b>
the records section contains zero or more records, the format of each record
follows.
minimumrecordsize is the minimum user record size, excluding the space we
use for the record header and field headers.  when a record is inserted, it
is stored in a space at least as large as the sum of the minimumrecordsize
and total header size.
for example,
if minimumrecordsize is 10 bytes,
the user record is 7 bytes,
we used 5 bytes for record and field headers,
this record will take (10 + 5) bytes of space, extra 3 bytes is
put into reserve.
if minimumrecordsize is 10 bytes,
user record is 17 bytes,
we used 5 bytes for record and field headers,
this record will take (17 + 5) bytes of space, no reserve space
here.
minimumrecordsize is defined by user on per container basis.
the default for minimumrecordsize is set to 1.
this implementation always keeps occupied bytes at the low end of the record
section.  thus removing (purging) a record moves all other records down, and
their slots are also moved down.
a page has no empty slot (an empty page has no slot)
<br><b>record & field format</b>
record header format is defined in the storedrecordheader class.
<pre>
<br><b>fields</b>
1 byte	boolean	- is null, if true no more data follows.
4 bytes   integer - length of field that follows (excludes these four bytes).
storedpage will use the static method provided by storedfieldheader
to read/write field status and field data length.
field header format is defined in the storedfieldheader class.
<data>
</pre>
<br><b>slot offset table</b><br>
the slot offset table is a table of 6 or 12 bytes per record, depending on
the pagesize being less or greater than 64k:
2 bytes (unsigned short) or 4 bytes (int) page offset for the record that
is assigned to the slot, and 2 bytes (unsigned short) or 4 bytes (int)
for the length of the record on this page.
2 bytes (unsigned short) or 4 bytes (int) for the length of the reserved
number of bytes for this record on this page.
first slot is slot 0.  the slot table grows backwards. slots are never
left empty.
<br><b>checksum</b><br>
8 bytes of a java.util.zip.crc32 checksum of the entire's page contents
without the 8 bytes representing the checksum.
<p><b>page access</b>
the page data is accessed in this class by one of three methods.
<ol>
<li>as a byte array using pagedata (field in cachedpage). this is the
fastest.
<li>as an arrayinputstream (rawdatain) and arrayoutputstream (rawdataout),
this is used to set limits on any one reading the page logically.
<li>logically through rawdatain (arrayinputstream) and
logicaldataout (formatidoutputstream), this provides the methods to write
logical data (e.g. booleans and integers etc.) and the objectinput
and objectoutput interfaces for datavaluedescriptor's. these logical
streams are constructed using the array streams.
</ol>
@see java.util.zip.crc32
@see arrayinputstream
@see arrayoutputstream
**/
public class storedpage extends cachedpage
/**************************************************************************
* static final fields of the class
**************************************************************************
*/
/*
* typed format
*/
public static final int format_number
storedformatids raw_store_stored_page
/**
* return my format identifier.
**/
public int gettypeformatid
return storedformatids raw_store_stored_page
}
/**
* constants used to find different portions of data on the page.
* <p>
* the page is laid out as follows:
* the page is broken into five sections
* +----------+-------------+---------+-------------------+----------+
* | formatid | page header | records | slot offset table | checksum |
* +----------+-------------+---------+-------------------+----------+
*
* offset               size                    section
* ------               -------------------     --------------------------
* 0                    page_format_id_size     formatid
* page_format_id_size: page_header_size (56)   page header
* record_space_offset: variable                records
**/
/**
* start of page, formatid must fit in 4 bytes.
* <p>
* where the page header starts - page format is mandated by cached page
**/
protected static final int page_header_offset     page_format_id_size
/**
* fixed size of the page header
**/
protected static final int page_header_size       56
/**
start of the record storage area
*/
/**
* start of the record storage area.
* <p>
* note: a subclass may change the start of the record storage area.
* don't always count on this number.
**/
protected static final int record_space_offset
page_header_offset   page_header_size
/**
* offset of the page version number
**/
protected static final int page_version_offset   page_header_offset   2
/**
* small_slot_size are for pages smaller than 64k,
* large_slot_size is for pages bigger than 64k.
**/
protected static final int small_slot_size    2
protected static final int large_slot_size    4
/**
* size of the checksum stored on the page.
*
* the checksum is stored in the last 8 bytes of the page, the slot table
* grows backward up the page starting at the end of the page just before
* the checksum.
**/
protected static final int checksum_size      8
/**
* overflow_pointer_size - number of bytes to reserve for overflow pointer
*
* the overflow pointer is the pointer that the takes the place of the
* last column of a row if the row can't fit on the page.  the pointer
* then points to another page where the next column of the row can be
* found.  the overflow pointer can be bigger than a row, so when
* overflowing a row the code must overflow enough columns so that there
* is enough free space to write the row.  note this means that the
* minimum space a row can take on a page must allow for at least the
* size of the overflow pointers so that if the row is updated it can
* write the over flow pointer.
*
**/
protected static final int overflow_pointer_size   12
/**
* overflow_ptr_field_size - number of bytes of an overflow field
*
* this is the length to reserve for either an column or row overflow
* pointer field.  it includes the size of the field header plus the
* maxium length of the overflow pointer (it could be shorter due to
* compressed storage).
*
* the calcualtion is:
*
* overflow_ptr_field_size =
*     overflow_pointer_size +
*     sizeof(status byte) +
*     sizeof(field length field for a field which is just an overflow ptr)
*
*
**/
protected static final int overflow_ptr_field_size
overflow_pointer_size   1   1
/**
* in memory buffer used as scratch space for streaming columns.
**/
byteholder bh   null
/**************************************************************************
* fields of the class
**************************************************************************
*/
/**
* constants used in call to logcolumn.
* <p>
* action taken in this routine is determined by the kind of column as
* specified in the columnflag:
*     column_none	 - the column is insignificant
*     column_first  - this is the first column in a logrow() call
*     column_long   - this is a known long column, therefore we will
*                     store part of the column on the current page and
*                     overflow the rest if necessary.
**/
protected static final int column_none    0
protected static final int column_first   1
protected static final int column_long    2
/**
* maxfieldsize is a worst case calculation for the size of a record
* on an empty page, with a single field, but still allow room for
* an overflow pointer if another field is to be added.  see initspace().
* maxfieldsize is a worst case calculation for the size of a record
*
* this is used as the threshold for a long column.
*
* maxfieldsize =
*      totalspace * (1 - sparespace/100) -
*      slotentrysize * - 16 - overflow_pointer_size;
**/
protected int maxfieldsize
/**
* the page header is a fixed size, 56 bytes, following are variables used
* to access the fields in the header:
* <p>
*  1 byte  boolean isoverflowpage  is page an overflow page
*  1 byte  byte	pagestatus      page status (field in base page)
*  8 bytes long	pageversion     page version (field in base page)
*  2 bytes ushort	slotsinuse      number of slots in slot offset table
*  4 bytes integer	nextid          next record identifier
*  4 bytes integer	generation      generation number of this page(future use)
*  4 bytes integer	prevgeneration  previous generation of page (future use)
*  8 bytes long    biplocation     the location of the bi page (future use)
*  2 bytes ushort  deletedrowcount number of deleted rows on page.(rel 2.0)
*  2 bytes long		            spare for future use
*  4 bytes long		            spare (encryption writes random bytes)
*  8 bytes long		            spare for future use
*  8 bytes long		            spare for future use
*
*  note that spare space has been guaranteed to be writen with "0", so
*  that future use of field should not either not use "0" as a valid data
*  item or pick 0 as a valid default value so that on the fly upgrade can
*  assume that 0 means field was never assigned.
*
**/
private boolean	isoverflowpage         is page an overflow page?
private int		slotsinuse             number of slots in slot offset table
private int		nextid                 next record identifier
private int		generation              future use  generation number of this page
private int		prevgeneration          future use  previous generation of page
private long	biplocation             future use  the location of the bi page
private int		deletedrowcount        number of deleted rows on page
/**
* is the header in the byte array out of date wrt the fields.
* <p>
* this field must be set to true whenever one of the above header fields
* is modified.  ie any of (isoverflowpage, slotsinuse, nextid, generation,
* prevgeneration, biplocation, deletedrowcount)
**/
private boolean headeroutofdate
/**
* holder for the checksum.
**/
private	crc32		checksum
/**
* minimum space to reserve for record portion length of row.
* <p>
* minimumrecordsize is stored in the container handle.  it is used to
* reserved minimum space for recordportionlength.  default is 1.  to
* get the value from the container handle:
* mycontainer.getminimumrecordsize();
*
* minimumrecordsize is the minimum user record size, excluding the space we
* use for the record header and field headers.  when a record is inserted,
* it is stored in a space at least as large as the sum of the
* minimumrecordsize and total header size.
*
* for example,
* if minimumrecordsize is 10 bytes,
*     the user record is 7 bytes,
*     we used 5 bytes for record and field headers,
*     this record will take (10 + 5) bytes of space, extra 3 bytes is
*     put into reserve.
*
* if minimumrecordsize is 10 bytes,
*     user record is 17 bytes,
*     we used 5 bytes for record and field headers,
*     this record will take (17 + 5) bytes of space, no reserve space
*     here.
*
* minimumrecordsize is defined by user on per container basis.
* the default for minimumrecordsize is set to 1.
*
**/
protected int minimumrecordsize
/**
* scratch variable used to keep track of the total user size for the row.
* the information is used by logrow to maintain minimumrecordsize
* on page.  minimumrecordsize is only considered for main data pages,
* therefore, the page must be latched during an insert operation.
**/
private int userrowsize
/**
* slot field and slot entry size.
* <p>
* the size of these fields is dependant on the page size.
* these 2 variables should be set when pagesize is determined, and should
* not be changed for that page.
*
* each slot entry contains 3 fields (slotoffet, recordportionlength and
* reservedspace) for the record the slot is pointing to.
* slotfieldsize is the size for each of the slot field.
* slotentrysize is the total space used for a single slot entry.
**/
private int	slotfieldsize
private int	slotentrysize
/**
* offset of the first entry in the slot table.
* <p>
* offset table is located at end of page, just before checksum.  it
* grows backward as an array from this point toward the middle of the
* page.
* <p>
* slottableoffsettofirstentry is the offset to the beginning of the
* first entry (slot[0]) in the slot table.  this allows the following
* math to get to the offset of n'th entry in the slot table:
*
*     offset of slot[n] = slottableoffsettofirstentry + (n * slotentrysize)
**/
private int slottableoffsettofirstentry
/**
* offset of the record length entry in the 1st slot table entry.
* <p>
* offset table is located at end of page, just before checksum.  it
* grows backward as an array from this point toward the middle of the
* page.  the record length is stored as the second "field" of the
* slot table entry.
* <p>
* slottableoffsettofirstrecordlengthfield is the offset to the beginning
* of the record length field in the first entry (slot[0]) in the slot
* table.  this allows the following
* math to get to the record length field of n'th entry in the slot table:
*
*     offset of record length of slot[n] slot entry =
*         slottableoffsettofirstrecordlengthfield + (n * slotentrysize)
**/
private int slottableoffsettofirstrecordlengthfield
/**
* offset of the reserved space length entry in the 1st slot table entry.
* <p>
* offset table is located at end of page, just before checksum.  it
* grows backward as an array from this point toward the middle of the
* page.  the reserved space length is stored as the third "field" of the
* slot table entry.
* <p>
* slottableoffsettofirstreservedspacefield is the offset to the beginning
* of the reserved space field in the first entry (slot[0]) in the slot
* table.  this allows the following
* math to get to the reserved space field of n'th entry in the slot table:
*
*     offset of reserved space of slot[n] slot entry =
*         slottableoffsettofirstreservedspacefield + (n * slotentrysize)
**/
private int slottableoffsettofirstreservedspacefield
/**
* total usable space on a page.
* <p>
* this is the space not taken by page hdr, page table, and existing
* slot entries/rows.
**/
protected int	totalspace 			   total usable space on a page
// freespace and firstfreebyte are initliazed to a minimum value.
protected int freespace		  integer min_value     free space on the page
private   int firstfreebyte	  integer min_value     1st free byte on page
/**
* % of page to keep free for updates.
* <p>
* how much of a head page should be reserved as "free" so that the space
* can be used by update which expands the row without needing to overflow
* it.  1 means save 1% of the free space for expansion.
**/
protected int	sparespace
/**
* scratch variable used when you need a overflowrecordheader.  declared
* globally so that object is only allocated once per page.
**/
private storedrecordheader  overflowrecordheader
/**
* input streams used to read/write bytes to/from the page byte array.
**/
protected arrayinputstream		rawdatain
protected arrayoutputstream     rawdataout
protected formatidoutputstream  logicaldataout
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
/**
* simple no-arg constructor for storedpage.
**/
public storedpage
super
}
/**************************************************************************
* private/protected methods of this class:
**************************************************************************
*/
/**
* get scratch space for over flow record header.
* <p>
*
* @exception  standardexception  standard exception policy.
**/
private storedrecordheader getoverflowrecordheader
throws standardexception
return
overflowrecordheader    null ?
overflowrecordheader
overflowrecordheader   new storedrecordheader
}
/**
* initialize the storedpage.
* <p>
* initialize the object, ie. perform work normally perfomed in constructor.
* called by setidentity() and createidentity() - the cacheable interfaces
* which are used to move a page in/out of cache.
**/
protected void initialize
super initialize
if  rawdatain    null
rawdatain              new arrayinputstream
checksum               new crc32
}
if  pagedata    null
rawdatain setdata pagedata
}
/**
* create the output streams.
* <p>
* create the output streams, these are created on demand
* to avoid creating unrequired objects for pages that are
* never modified during their lifetime in the cache.
* <p>
*
* @exception  standardexception  standard exception policy.
**/
private void createoutstreams
rawdataout   new arrayoutputstream
rawdataout setdata pagedata
logicaldataout   new formatidoutputstream rawdataout
}
/**
* tie the logical output stream to a passed in outputstream.
* <p>
* tie the logical output stream to a passed in outputstream with
* no limit as to the number of bytes that can be written.
**/
private void setoutputstream outputstream out
if  rawdataout    null
createoutstreams
logicaldataout setoutput out
}
/**
* reset the logical output stream.
* <p>
* reset the logical output stream (logicaldataout) to be attached
* to the page array stream as is the norm, no limits are placed
* on any writes.
*
**/
private void resetoutputstream
logicaldataout setoutput rawdataout
}
/**************************************************************************
* protected methods of cachedpage class: (create, read and write a page.)
**************************************************************************
*/
/**
* use this passed in page buffer as this object's page data.
* <p>
* the page content may not have been read in from disk yet.
* for pagesize smaller than 64k:
*		size of the record offset stored in a slot (unsigned short)
*		size of the record portion length stored in a slot (unsigned short)
*		size of the record portion length stored in a slot (unsigned short)
*	for pagesize greater than 64k, but less than 2gig:
*		size of the record offset stored in a slot (int)
*		size of the record portion length stored in a slot (int)
*		size of the record portion length stored in a slot (int)
* <p>
*
* @param pagebuffer    the array of bytes to use as the page buffer.
**/
protected void usepagebuffer byte pagebuffer
pagedata   pagebuffer
int pagesize   pagedata length
if  rawdatain    null
rawdatain setdata pagedata
initspace
if  pagesize >  65536
slotfieldsize   large_slot_size
else
slotfieldsize   small_slot_size
slotentrysize   3   slotfieldsize
// offset of slot table entry[0]
slottableoffsettofirstentry
pagesize   checksum_size   slotentrysize
// offset of record length field in slot table entry[0]
slottableoffsettofirstrecordlengthfield
slottableoffsettofirstentry   slotfieldsize
// offset of reserved space field in slot table entry[0]
slottableoffsettofirstreservedspacefield
slottableoffsettofirstentry    2   slotfieldsize
if  rawdataout    null
rawdataout setdata pagedata
}
/**
* create a new storedpage.
* <p>
* make this object represent a new page (ie. a page that never existed
* before, as opposed to reading in an existing page from disk).
* <p>
*
* @param newidentity   the key describing page (segment,container,page).
* @param args          information stored about the page, once in the
*                      container header and passed in through the array.
*
* @exception  standardexception  standard exception policy.
**/
protected void createpage
pagekey newidentity
int   args
throws standardexception
// arg[0] is the formatid of the page
// arg[1] is whether to sync the page to disk or not
int pagesize          args
sparespace            args
minimumrecordsize     args
setpagearray pagesize
cleanpage   			   clean up the page array
setpageversion 0  		   page is being created for the first time
nextid            recordhandle first_record_id     first record id
generation        0
prevgeneration    0 		   there is no previous generation
biplocation       0l
createoutstreams
}
/**
* initialize the page from values in the page buffer.
* <p>
* initialize in memory structure using the buffer in pagedata.  this
* is how a storedpage object is intialized to represent page read in
* from disk.
* <p>
*
* @param mycontainer   the container to read the page in from.
* @param newidentity   the key representing page being read in (segment,
*                      container, page number)
*
* @exception standardexception if the page cannot be read correctly,
*                              or is inconsistent.
**/
protected void initfromdata
filecontainer   mycontainer
pagekey         newidentity
throws standardexception
if  mycontainer    null
// read in info about page stored once in the container header.
sparespace            mycontainer getsparespace
minimumrecordsize     mycontainer getminimumrecordsize
}
// if it is null, assume sparespace and minimumrecordsize is the
// same.  we would only call initfromdata after a restore then.
try
readpageheader
initslottable newidentity
}
catch  ioexception ioe
// i/o methods on the byte array have thrown an ioexception
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  newidentity
}
try
validatechecksum newidentity
}
catch  standardexception se
if  se getmessageid   equals sqlstate file_bad_checksum
// it is remotely possible that the disk transfer got garbled,
// i.e., the page is actually fine on disk but the version we
// got has some rubbish on it.  double check.
int pagesize          getpagesize
byte corruptpage    pagedata
pagedata              null 	   clear this
// set up the new page array
setpagearray pagesize
try
mycontainer readpage newidentity getpagenumber    pagedata
}
catch  ioexception ioe
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  newidentity
}
if  sanitymanager debug
sanitymanager debug_clear
}
// see if this read confirms the checksum error
try
validatechecksum newidentity
}
catch  standardexception sse
// really bad
throw datafactory markcorrupt se
}
// if we got here, this means the first read is bad but the
// second read is good.  this could be due to disk i/o error or
// a bug in the way the file pointer is mis-managed.
string firstimage     pagedatatohexdump corruptpage
string secondimage
sanitymanager debug  ?
tostring     pagedatatohexdump corruptpage
throw standardexception newexception
sqlstate file_io_garbled  se
newidentity  firstimage  secondimage
}
else
throw se
}
}
}
/**
* validate the check sum on the page.
* <p>
* compare the check sum stored in the page on disk with the checksum
* calculated from the bytes on the page.
* <p>
*
* @param id     the key that describes the page.
*
* @exception  standardexception  standard exception policy.
**/
protected void validatechecksum pagekey id
throws standardexception
long ondiskchecksum
try
// read the checksum stored on the page on disk.  it is stored
// in the last "checksum_size" bytes of the page, and is a long.
rawdatain setposition getpagesize     checksum_size
ondiskchecksum   rawdatain readlong
}
catch  ioexception ioe
// i/o methods on the byte array have thrown an ioexception
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  id
}
// force the checksum to be recalculated based on the current page.
checksum reset
checksum update pagedata  0  getpagesize     checksum_size
// force a bad checksum error
if  sanitymanager debug
if  sanitymanager debug_on
// set on disk checksum to wrong value
ondiskchecksum   123456789
}
}
if  ondiskchecksum    checksum getvalue
// try again using new checksum object to be doubly sure
crc32 newchecksum   new crc32
newchecksum reset
newchecksum update pagedata  0  getpagesize   checksum_size
if  ondiskchecksum    newchecksum getvalue
throw standardexception newexception
sqlstate file_bad_checksum
id
new long checksum getvalue
new long ondiskchecksum
pagedatatohexdump pagedata
}
else
// old one is bad, get rid of it
if  sanitymanager debug
sanitymanager throwassert
checksum   newchecksum
}
}
}
/**
* recalculate checksum and write it to the page array.
* <p>
* recalculate the checksum of the page, and write the result back into
* the last bytes of the page.
*
* @exception  ioexception  if writing to end of array fails.
**/
protected void updatechecksum   throws ioexception
checksum reset
checksum update pagedata  0  getpagesize     checksum_size
rawdataout setposition getpagesize     checksum_size
logicaldataout writelong checksum getvalue
}
/**
* write information about page from variables into page byte array.
* <p>
* this routine insures that all information about the page is reflected
* in the page byte buffer.  this involves moving information from local
* variables into encoded version on the page in page header and checksum.
* <p>
*
* @param identity  the key of this page.
*
* @exception  standardexception  standard exception policy.
**/
protected void writepage pagekey identity
throws standardexception
if  sanitymanager debug
// some consistency checks on fields of the page, good to check
// before we write them into the page.
if   freespace < 0
firstfreebyte   freespace      getslotoffset slotsinuse   1
// make sure free space is not negative and does not overlap
// used space.
sanitymanager throwassert     slotsinuse
firstfreebyte
freespace
getslotoffset slotsinuse   1
this
}
if   slotsinuse    0
firstfreebyte     getpagesize     totalspace   checksum_size
sanitymanager throwassert     slotsinuse
firstfreebyte
freespace
getslotoffset slotsinuse   1
this
}
}
try
if  headeroutofdate
updatepageheader
}
else
// page version always need to be updated if page is dirty,
// either do it in updatepageheader or by itself
updatepageversion
}
updatechecksum
}
catch  ioexception ioe
// i/o methods on the byte array have thrown an ioexception
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  identity
}
}
/**
* write out the format id of this page
*
* @param identity  the key of this page.
*
* @exception  standardexception  standard exception policy.
**/
protected void writeformatid pagekey identity  throws standardexception
try
if  rawdataout    null
createoutstreams
rawdataout setposition 0
formatidutil writeformatidinteger
logicaldataout  gettypeformatid
}
catch  ioexception ioe
// i/o methods on the byte array have thrown an ioexception
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  identity
}
}
/**************************************************************************
* protected methods of cacheable interface:
**************************************************************************
*/
/**************************************************************************
* protected overridden methods of basepage:
**************************************************************************
*/
/**
* ensure that the page is released from the cache when it is unlatched.
*
* @see org.apache.derby.impl.store.raw.data.basepage#releaseexclusive
*
**/
protected void releaseexclusive
super releaseexclusive
pagecache release this
}
/**
* return the total number of bytes used, reserved, or wasted by the
* record at this slot.
* <p>
* the amount of space the record on this slot is currently taking on the
* page.
*
* if there is any reserve space or wasted space, count that in also
* do not count the slot entry size
* <p>
*
* @return the number of bytes used by the row at slot "slot".
*
* @param slot  look at row at this slot.
*
* @exception  standardexception  standard exception policy.
**/
public int gettotalspace int slot
throws standardexception
try
// a slot entry looks like the following:
//     1st field:   offset of the record on the page
//     2nd field:   length of the record on the page
//     3rd field:   amount of space reserved for the record to grow.
// position the read at the beginning of the 2nd field.
rawdatain setposition getslotoffset slot    slotfieldsize
// return the size of the record + size of the reserved space.
// the size of the fields to read is determined by slotfieldsize.
return
slotfieldsize    small_slot_size  ?
rawdatain readunsignedshort
rawdatain readunsignedshort
rawdatain readint
rawdatain readint
}
catch  ioexception ioe
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  getpageid
}
}
/**
* is there minimal space for insert?
* <p>
* does quick calculation to see if average size row on this page could
* be inserted on the page.  this is done because the actual row size
* being inserted isn't known until we actually copy the columns from
* their object form into their on disk form which is expensive.  so
* we use this calculation so that in the normal case we only do one
* copy of the row directly onto the page.
* <p>
*
* @return true if we think the page will allow an insert, false otherwise.
*
* @exception  standardexception  standard exception policy.
**/
public boolean spaceforinsert
throws standardexception
// is this an empty page
if  slotsinuse    0
return true
if   allowinsert
return false
int usedspace     totalspace   freespace
int bytesperrow   usedspace   slotsinuse
return bytesperrow <  freespace
}
/**
* is row guaranteed to be inserted successfully on this page?
* <p>
* return true if this record is guaranteed to be inserted successfully
* using insert() or insertatslot(). this guarantee is only valid while
* the row remains unchanged and the page latch is held.
* <p>
*
* @return bolean indicating if row can be inserted on this page.
*
* @param row                   the row to check for insert.
* @param validcolumns          bit map to interpret valid columns in row.
* @param overflowthreshold     the percentage of the page to use for the
*                              insert.  100 means use 100% of the page,
*                              50 means use 50% of page (ie. make sure
*                              2 rows fit per page).
*
* @exception  standardexception  standard exception policy.
**/
public boolean spaceforinsert
object   row
formatablebitset                 validcolumns
int                     overflowthreshold
throws standardexception
// is this an empty page
if  slotsinuse    0
return true
// does the estimate think it won't fit, if not return false to avoid
// cost of calling logrow() just to figure out if the row will fit.
if   allowinsert
return false
dynamicbytearrayoutputstream out   new dynamicbytearrayoutputstream
try
// this is a public call, start column is rawstore only.
// set the starting column for the row to be 0.
logrow
0  true  nextid  row  validcolumns  out
0  page insert_default   1   1  overflowthreshold
}
catch  nospaceonpage nsop
return false
}
catch  ioexception ioe
throw standardexception newexception
sqlstate data_unexpected_exception  ioe
}
return true
}
/**
* is row guaranteed to be inserted successfully on this page?
* <p>
* return true if this record is guaranteed to be inserted successfully
* using insert() or insertatslot(). this guarantee is only valid while
* the row remains unchanged and the page latch is held.
* <p>
* this is a private call only used when calculating whether an overflow
* page can be used to insert part of an overflow row/column.
*
* @return bolean indicating if row can be inserted on this page.
*
* @param row                   the row to check for insert.
* @param validcolumns          bit map to interpret valid columns in row.
* @param overflowthreshold     the percentage of the page to use for the
*                              insert.  100 means use 100% of the page,
*                              50 means use 50% of page (ie. make sure
*                              2 rows fit per page).
*
* @exception  standardexception  standard exception policy.
**/
private boolean spaceforinsert
object   row
formatablebitset                 validcolumns
int                     spaceneeded
int                     startcolumn
int                     overflowthreshold
throws standardexception
if    spaceforinsert       freespace >  spaceneeded
return false
dynamicbytearrayoutputstream out   new dynamicbytearrayoutputstream
try
logrow
0  true  nextid  row  validcolumns  out  startcolumn
page insert_default   1   1  overflowthreshold
}
catch  nospaceonpage nsop
return false
}
catch  ioexception ioe
throw standardexception newexception
sqlstate data_unexpected_exception  ioe
}
return true
}
/**
* is this page unfilled?
* <p>
* returns true if page is relatively unfilled,
* which means the page is < 1/2 full and has enough space to insert an
* "average" sized row onto the page.
* <p>
*
* @return true if page is relatively unfilled.
**/
public boolean unfilled
return  allowinsert       freespace >  getpagesize     2
}
/**
* is there enough space on the page to insert a minimum size row?
* <p>
* calculate whether there is enough space on the page to insert a
* minimum size row.  the calculation includes maintaining the required
* reserved space on the page for existing rows to grow on the page.
* <p>
*
* @return boolean indicating if a minimum sized row can be inserted.
**/
public boolean allowinsert
// is this an empty page
if  slotsinuse    0
return true
int spaceavailable   freespace
spaceavailable    slotentrysize 	   need to account new slot entry
if  spaceavailable < minimumrecordsize
return false
// see that we reserve enough space for existing rows to grow on page
if    spaceavailable   100    totalspace  < sparespace
return false
return true
}
/**
* does this page have enough space to insert the input rows?
* <p>
* can the rows with lengths spaceneeded[0..num_rows-1] be copied onto
* this page?
* <p>
*
* @return true if the sum of the lengths will fit on the page.
*
* @param num_rows      number of rows to check for.
* @param spaceneeded   array of lengths of the rows to insert.
**/
public boolean spaceforcopy int num_rows  int spaceneeded
// determine how many more bytes are needed for the slot entries
int bytesneeded   slotentrysize   num_rows
for  int i   0  i < num_rows  i
if  spaceneeded > 0
// add up the space needed by the rows, add in minimumrecordsize
// if length of actual row is less than minimumrecordsize.
bytesneeded
spaceneeded >  minimumrecordsize ?
spaceneeded   minimumrecordsize
}
}
return  freespace   bytesneeded  >  0
}
protected boolean spaceforcopy int spaceneeded
// add up the space needed by the rows, add in minimumrecordsize
// if length of actual row is less than minimumrecordsize.
int bytesneeded   slotentrysize
spaceneeded >  minimumrecordsize ?
spaceneeded   minimumrecordsize
return  freespace   bytesneeded  >  0
}
/**
* read the record at the given slot into the given row.
* <p>
* this reads and initializes the columns in the row array from the raw
* bytes stored in the page associated with the given slot.  if validcolumns
* is non-null then it will only read those columns indicated by the bit
* set, otherwise it will try to read into every column in row[].
* <p>
* if there are more columns than entries in row[] then it just stops after
* every entry in row[] is full.
* <p>
* if there are more entries in row[] than exist on disk, the requested
* excess columns will be set to null by calling the column's object's
* restoretonull() routine (ie.  ((object) column).restoretonull() ).
* <p>
* if a qualifier list is provided then the row will only be read from
* disk if all of the qualifiers evaluate true.  some of the columns may
* have been read into row[] in the process of evaluating the qualifier.
* <p>
* this routine should only be called on the head portion of a row, it
* will call a utility routine to read the rest of the row if it is a
* long row.
*
*
* @param slot              the slot number
* @param row (out)         filled in sparse row
* @param fetchdesc         information describing fetch, including what
*                          columns to fetch and qualifiers.
* @param recordtolock      the record handle for the row at top level,
*                          and is used in overflowinputstream to lock the
*                          row for blobs/clobs.
* @param isheadrow         the row on this page includes the head record
*                          handle.  will be false for the overflow portions
*                          of a "long" row, where columns of a row span
*                          multiple pages.
*
* @return  false if a qualifier_list is provided and the row does not
*          qualifier (no row read in that case), else true.
*
* @exception standardexception	standard derby error policy
**/
protected boolean restorerecordfromslot
int                     slot
object                row
fetchdescriptor         fetchdesc
recordhandle            recordtolock
storedrecordheader      recordheader
boolean                 isheadrow
throws standardexception
try
int offset_to_row_data
getrecordoffset slot    recordheader size
if  sanitymanager debug
if  getrecordoffset slot  <
page_header_offset   page_header_size
sanitymanager throwassert
getrecordoffset slot
page_header_offset   page_header_size
slot
slotsinuse
}
sanitymanager assert
isheadrow
sanitymanager assert
isoverflowpage
}
// position the array reading stream at beginning of row data just
// past the record header.
arrayinputstream lrdi   rawdatain
lrdi setposition offset_to_row_data
if   recordheader hasoverflow
if  isheadrow
if  fetchdesc    null
fetchdesc getqualifierlist      null
fetchdesc reset
if   qualifyrecordfromslot
row
offset_to_row_data
fetchdesc
recordheader
recordtolock
return false
}
else
// reset position back for subsequent record read.
lrdi setposition offset_to_row_data
}
}
}
// call routine to do the real work.  note that
// readrecordfromstream() may return false for non-overflow
// record, this is in the case where caller requests more
// columns than exist on disk.  in that case we still return
// true at this point as there are no more columns that we
// can return.
if  fetchdesc    null
readrecordfromarray
row
fetchdesc getvalidcolumns      null  ?
row length  1   fetchdesc getmaxfetchcolumnid
fetchdesc getvalidcolumnsarray
fetchdesc getmaterializedcolumns
lrdi
recordheader
recordtolock
}
else
readrecordfromarray
row
row length   1
int  null
int  null
lrdi
recordheader
recordtolock
}
return true
}
else
if  fetchdesc    null
if  fetchdesc getqualifierlist      null
fetchdesc reset
}
readrecordfromarray
row
fetchdesc getvalidcolumns      null  ?
row length   1   fetchdesc getmaxfetchcolumnid
fetchdesc getvalidcolumnsarray
fetchdesc getmaterializedcolumns
lrdi
recordheader
recordtolock
}
else
readrecordfromarray
row
row length   1
int  null
int  null
lrdi
recordheader
recordtolock
}
// call routine to loop through all the overflow portions of
// the row, reading it into "row".
while  recordheader    null
// the record is a long row, loop callng code to read the
// pieces of the row located in a linked list of rows on
// overflow pages.
storedpage overflowpage
getoverflowpage recordheader getoverflowpage
if  sanitymanager debug
if  overflowpage    null
sanitymanager throwassert
}
// this call reads in the columns of the row that reside
// on "overflowpage", and if there is another piece it
// returns the recordheader of the row on overflowpage,
// from which we can find the next piece of the row.  a
// null return means that we have read in the entire row,
// and are done.
recordheader
overflowpage restorelongrecordfromslot
row
fetchdesc
recordtolock
recordheader
overflowpage unlatch
overflowpage   null
}
// for overflow rows just apply qualifiers at end for now.
if   fetchdesc    null
fetchdesc getqualifierlist      null
if   qualifyrecordfromrow
row  fetchdesc getqualifierlist
return false
}
}
return true
}
}
catch  ioexception ioe
if  sanitymanager debug
if  pagedata    null
sanitymanager debug_print
pagekey getidentity         slot
}
else
sanitymanager debug_print
pagekey getidentity         slot
pagedata length       getpagesize
sanitymanager debug_print
pagedatatohexdump pagedata
sanitymanager debug_print
this tostring
}
}
// i/o methods on the byte array have thrown an ioexception
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  getpageid
}
}
private storedrecordheader restorelongrecordfromslot
object                row
fetchdescriptor         fetchdesc
recordhandle            recordtolock
storedrecordheader      parent_recordheader
throws standardexception
int slot
findrecordbyid
parent_recordheader getoverflowid    page first_slot_number
storedrecordheader recordheader   getheaderatslot slot
try
int offset_to_row_data
getrecordoffset slot    recordheader size
if  sanitymanager debug
if  getrecordoffset slot  <
page_header_offset   page_header_size
sanitymanager throwassert
getrecordoffset slot
page_header_offset   page_header_size
slot
slotsinuse
}
}
// position the array reading stream at beginning of row data
// just past the record header.
arrayinputstream lrdi   rawdatain
lrdi setposition offset_to_row_data
if  fetchdesc    null
if  fetchdesc getqualifierlist      null
fetchdesc reset
}
readrecordfromarray
row
fetchdesc getvalidcolumns      null  ?
row length   1   fetchdesc getmaxfetchcolumnid
fetchdesc getvalidcolumnsarray
fetchdesc getmaterializedcolumns
lrdi
recordheader
recordtolock
}
else
readrecordfromarray
row
row length   1
int  null
int  null
lrdi
recordheader
recordtolock
}
return recordheader hasoverflow   ? recordheader   null
}
catch  ioexception ioe
if  sanitymanager debug
if  pagedata    null
sanitymanager debug_print
pagekey getidentity         slot
}
else
sanitymanager debug_print
pagekey getidentity         slot
pagedata length       getpagesize
sanitymanager debug_print
pagedatatohexdump pagedata
sanitymanager debug_print
this tostring
}
}
// i/o methods on the byte array have thrown an ioexception
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  getpageid
}
}
/**
* create a new record handle.
* <p>
* return the next record id for allocation.  callers of this interface
* expect the next id to get bumped some where else - probably by
* storerecordforinsert().
* <p>
*
* @return the next id to assing to a row.
**/
public int newrecordid
return nextid
}
/**
* create a new record handle, and bump the id.
* <p>
* create a new record handle, and bump the id while holding the latch
* so that no other user can ever see this record id.  this will lead
* to unused record id's in the case where an insert fails because there
* is not enough space on the page.
* <p>
*
* @return the next id to assing to a row.
**/
public int newrecordidandbump
// headeroutofdate must be bumped as nextid is changing, and must
// eventually be updated in the page array.
headeroutofdate   true
return nextid
}
/**
* create a new record id based on current one passed in.
* <p>
* this interface is used for the "copy" insert interface of raw store
* where multiple rows are inserted into a page in a single logged
* operation.  we don't want to bump the id until the operation is logged
* so we just allocated each id in order and then bump the next id at
* the end of the operation.
* <p>
*
* @return the next id based on the input id.
*
* @param recordid  the id caller just used, return the next one.
*
**/
protected int newrecordid int recordid
if  sanitymanager debug
sanitymanager assert
recordid >  nextid
}
return recordid   1
}
public boolean isoverflowpage
return isoverflowpage
}
/**************************************************************************
* public methods specific to storedpage:
**************************************************************************
*/
/**
* get the full size of the page.
**/
public final int getpagesize
return pagedata length
}
/**
* zero out a portion of the page.
* <p>
**/
protected final void clearsection int offset  int length
int endoffset   offset   length
while  offset < endoffset
pagedata   0
}
/**
* the maximum free space on this page possible.
* <p>
* the the maximum amount of space that can be used on the page
* for the records and the slot offset table.
* note: subclass may have overwitten it to report less freespace
*
* @return the maximum free space on this page possible.
*
**/
protected int getmaxfreespace
return getpagesize     record_space_offset   checksum_size
}
/**
* the current free space on the page.
**/
protected int getcurrentfreespace
return freespace
}
/**************************************************************************
* page header routines
**************************************************************************
*/
/**
* read the page header from the page array.
* <p>
* read the page header from byte form in the page array into in memory
* variables.
**/
private void readpageheader
throws ioexception
// these reads are always against the page array
arrayinputstream lrdi   rawdatain
lrdi setposition page_header_offset
long spare
isoverflowpage   	lrdi readboolean
setpagestatus		 lrdi readbyte
setpageversion		 lrdi readlong
slotsinuse       	lrdi readunsignedshort
nextid           	lrdi readint
generation       	lrdi readint           page generation  future use
prevgeneration   	lrdi readint           previous generation  future use
biplocation      	lrdi readlong   	   bipage location  future use
// number of deleted rows on page, we start to store this release 2.0.
// for upgrade reasons, a 0 on disk means -1, so, we subtract one here.
deletedrowcount  	lrdi readunsignedshort     1
// the next 4 (total 22 bytes) are reserved for future
spare               lrdi readunsignedshort
spare               lrdi readint           used by encryption
spare               lrdi readlong
spare               lrdi readlong
}
/**
* update the page header in the page array.
* <p>
* write the bytes of the page header, taking the values from those
* in the in memory variables.
**/
private void updatepageheader
throws ioexception
rawdataout setposition page_header_offset
logicaldataout writeboolean isoverflowpage
logicaldataout writebyte getpagestatus
logicaldataout writelong getpageversion
logicaldataout writeshort slotsinuse
logicaldataout writeint nextid
logicaldataout writeint generation          page generation  future use
logicaldataout writeint prevgeneration      previous generation  future use
logicaldataout writelong biplocation  	    bipage location  future use
// number of deleted rows on page, we start to store this release 2.0.
// for upgrade reasons, a 0 on disk means -1, so, we add one when we
// write it to disk.
logicaldataout writeshort deletedrowcount   1
logicaldataout writeshort 0  	            reserved for future
logicaldataout writeint
datafactory random    	            random bytes for encryption
logicaldataout writelong 0                  reserved for future
logicaldataout writelong 0                  reserved for future
// we put a random value int into the page if the database is encrypted
// so that the checksum will be very different even with the same
// page image, when we encrypt or decrypt the page, we move the
// checksum to the front so that the encrypted page will look very
// different even with just the one int difference.  we never look at
// the value of the random number and we could have put it anywhere in
// the page as long as it doesn't obscure real data.
headeroutofdate   false
}
/**
* update the page version number in the byte array
**/
private void updatepageversion
throws ioexception
rawdataout setposition page_version_offset
logicaldataout writelong getpageversion
}
/**************************************************************************
* slot offset & length table manipulation
**************************************************************************
*/
/**
* get the page offset of a given slot entry.
* <p>
* get the page offset of a slot entry, this is not the offset of
* the record stored in the slot, but the offset of the actual slot.
*
* @return the page offset of a given slot entry.
*
* @param slot  the array entry of the slot to find.
**/
private int getslotoffset int slot
// slot table grows backward from the spot at the end of the page just
// before the checksum which is located in the last 8 bytes of the page.
return slottableoffsettofirstentry    slot   slotentrysize
}
/**
* get the page offset of the record associated with the input slot.
* <p>
* this is the actual offset on the page of the beginning of the record.
*
* @return the page offset of the record associated with the input slot.
*
* @param slot  the array entry of the slot to find.
**/
private int getrecordoffset int slot
byte data     pagedata
int    offset   slottableoffsettofirstentry    slot   slotentrysize
// offset on the page of the record is stored in the first 2 or 4 bytes
// of the slot table entry.  code has been inlined for performance
// critical low level routine.
//
// return(
//  (slotfieldsize == small_slot_size) ?
//       readunsignedshort() : readint());
return
slotfieldsize    small_slot_size   ?
data    0xff  <<  8
data      0xff
data   0xff  << 24
data   0xff  << 16
data   0xff  <<  8
data     0xff
}
/**
* set the page offset of the record associated with the input slot.
* <p>
* this is the actual offset on the page of the beginning of the record.
*
* @param slot          the array entry of the slot to set.
* @param recordoffset  the new offset to set.
**/
private void setrecordoffset int slot  int recordoffset
throws ioexception
rawdataout setposition getslotoffset slot
if  slotfieldsize    small_slot_size
logicaldataout writeshort recordoffset
else
logicaldataout writeint recordoffset
}
/**
* return length of row on this page.
* <p>
* return the total length of data and header stored on this page for
* this record.  this length is stored as the second "field" of the
* slot table entry.
*
* @return the length of the row on this page.
*
* @param slot   the slot of the row to look up the length of.
*
**/
protected int getrecordportionlength int slot
throws ioexception
if  sanitymanager debug
sanitymanager assert getrecordoffset slot     0
}
// these reads are always against the page array
arrayinputstream lrdi   rawdatain
lrdi setposition
slottableoffsettofirstrecordlengthfield    slot   slotentrysize
return
slotfieldsize    small_slot_size  ?
lrdi readunsignedshort     lrdi readint
}
/**
* return reserved length of row on this page.
* <p>
* return the reserved length of this record.
* this length is stored as the third "field" of the slot table entry.
*
* @return the reserved length of the row on this page.
*
* @param slot   the slot of the row to look up the length of.
*
**/
public int getreservedcount int slot  throws ioexception
if  sanitymanager debug
sanitymanager assert getrecordoffset slot     0
}
// these reads are always against the page array
arrayinputstream lrdi   rawdatain
lrdi setposition
slottableoffsettofirstreservedspacefield    slot   slotentrysize
return
slotfieldsize    small_slot_size  ?
lrdi readunsignedshort     lrdi readint
}
/**
update the length of data stored on this page for this record
*/
/**
* update the length of data stored on this page for this record
* <p>
* update both the record length "field" and the reserved space "field"
* of the slot table entry associated with "slot".  this length is stored
* as the second "field" of the slot table entry.  the changes to these
* 2 fields are represented as the delta to apply to each field as input
* in "delta" and "reserveddelta."
* <p>
*
* @param slot              the slot of the record to set.
* @param delta             the amount the record length changed.
* @param reserveddelta     the amount the reserved length changed.
*
* @exception  standardexception  standard exception policy.
**/
private void updaterecordportionlength
int slot
int delta
int reserveddelta
throws ioexception
if  sanitymanager debug
sanitymanager assert getrecordoffset slot     0
if   delta   reserveddelta  < 0
sanitymanager throwassert
delta       reserveddelta
if   getrecordportionlength slot    delta  < 0
sanitymanager throwassert
getrecordportionlength slot        delta
if   getreservedcount slot    reserveddelta  < 0
sanitymanager throwassert
getreservedcount slot
reserveddelta
}
// position the stream to beginning of 2nd field of slot entry.
rawdataout setposition
slottableoffsettofirstrecordlengthfield    slot   slotentrysize
// write the new record length to 2nd field
if  slotfieldsize    small_slot_size
logicaldataout writeshort getrecordportionlength slot    delta
else
logicaldataout writeint getrecordportionlength slot    delta
// if necessary, write the 3rd field - above write has positioned the
// stream to the 3rd field.
if  reserveddelta    0
if  slotfieldsize    small_slot_size
logicaldataout writeshort
getreservedcount slot    reserveddelta
}
else
logicaldataout writeint
getreservedcount slot    reserveddelta
}
}
}
/**
* initialize the in-memory slot table.
* <p>
* initialize the in-memory slot table, ie. that of our super-class
* basepage.  go through all the records on the page and set the
* freespace and firstfreebyte on page.
* <p>
* @param newidentity   the identity of the page we are trying to
*                      initialize, since we are in the middle of trying
*                      to build the page existing info in the class is
*                      not set up yet (like getidentity()).
*
* @exception  standardexception  standard exception policy.
**/
private void initslottable
pagekey newidentity
throws standardexception
int localslotsinuse   slotsinuse
// must initialize the header now
initializeheaders localslotsinuse
// mark all the space on the page as free
clearallspace
// first count the space occupied by the slot table
freespace    localslotsinuse   slotentrysize
int lastslotonpage         1
int lastrecordoffset       1
try
for  int slot   0  slot < localslotsinuse  slot
if  sanitymanager debug
if   isoverflowpage
minimumrecordsize > gettotalspace slot
sanitymanager throwassert
slot
minimumrecordsize
gettotalspace slot
getrecordportionlength slot
getreservedcount slot
}
}
int recordoffset   getrecordoffset slot
// check that offset points into the record space area.
if   recordoffset < record_space_offset
recordoffset >   getpagesize     checksum_size
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  newidentity
}
if  recordoffset > lastrecordoffset
lastrecordoffset   recordoffset
lastslotonpage   slot
}
}
bumprecordcount localslotsinuse
if  lastslotonpage     1
// calculate the firstfreebyte for the page,
// and the freespace on page
firstfreebyte
lastrecordoffset   gettotalspace lastslotonpage
freespace       firstfreebyte   record_space_offset
}
if  sanitymanager debug
if   freespace < 0
firstfreebyte   freespace
getslotoffset slotsinuse   1
sanitymanager throwassert
firstfreebyte
freespace
getslotoffset slotsinuse   1
localslotsinuse
}
if  localslotsinuse    0
sanitymanager assert
firstfreebyte
getpagesize     totalspace   checksum_size
}
}
// upgrade issue. pre 1.5 release, we do not store deletedrowcount
// therefore, if we are accessing an older database,
// we need to calculate the deletedrowcount here.
if  deletedrowcount     1
int count   0
int	maxslot   slotsinuse
for  int slot   first_slot_number   slot < maxslot  slot
if  isdeletedonpage slot
count
}
deletedrowcount   count
}
}
catch  ioexception ioe
// i/o methods on the byte array have thrown an ioexception
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  newidentity
}
}
/**
* set up a new slot entry.
* <p>
*
* @param slot                  the slot to initialize.
* @param recordoffset          the offset on the page to find the record.
* @param recordportionlength   the actual length of record+hdr on page.
* @param reservedspace         the reserved length associated with record.
*
* @exception  standardexception  standard exception policy.
**/
private void setslotentry
int slot
int recordoffset
int recordportionlength
int reservedspace
throws ioexception
rawdataout setposition getslotoffset slot
if  sanitymanager debug
if   recordportionlength < 0
reservedspace < 0
recordportionlength >  getpagesize
reservedspace >  getpagesize
sanitymanager throwassert
slot
slotsinuse
recordoffset
recordportionlength
reservedspace
}
if  recordoffset <  page_header_offset   page_header_size
sanitymanager throwassert
slot
slotsinuse
recordoffset
recordportionlength
reservedspace
}
}
if  slotfieldsize    small_slot_size
logicaldataout writeshort recordoffset
logicaldataout writeshort recordportionlength
logicaldataout writeshort reservedspace
}
else
logicaldataout writeint recordoffset
logicaldataout writeint recordportionlength
logicaldataout writeint reservedspace
}
}
/**
* insert a new slot entry into the current slot array.
* <p>
* shift the existing slots from slot to (slotsinuse - 1) up by one.
* up here means from low slot to high slot (e.g from slot 2 to slot 3).
* our slot table grows backward so we have to be careful here.
*
* @param slot                  position the new slot will take
* @param recordoffset          offset of the record for the new slot
* @param recordportionlength   length of the record stored in the new slot
* @param reservedspace         length of reserved space of record in slot
*
**/
private void addslotentry
int slot
int recordoffset
int recordportionlength
int reservedspace
throws ioexception
if  sanitymanager debug
if   slot < 0      slot > slotsinuse
sanitymanager throwassert     slot
if   recordportionlength < 0      reservedspace < 0
sanitymanager throwassert
recordportionlength
reservedspace
if  recordoffset <  page_header_offset   page_header_size
sanitymanager throwassert
slot
slotsinuse
recordoffset
recordportionlength
reservedspace
}
}
int newslotoffset
// todo - (mikem) - i think the math below could be slightly optimized.
if  slot < slotsinuse
// inserting a slot into the middle of array so shift all the
// slots from "slot" logically up by one
int startoffset
getslotoffset slotsinuse   1
int length
getslotoffset slot    slotentrysize    startoffset
newslotoffset   getslotoffset slotsinuse
system arraycopy
pagedata  startoffset  pagedata  newslotoffset  length
}
else
// we are adding at end of slot table, so no moving necessary.
newslotoffset   getslotoffset slot
}
freespace    slotentrysize
slotsinuse
headeroutofdate   true 	   headeroutofdate must be set after setdirty
// because isdirty may be called unlatched
setslotentry slot  recordoffset  recordportionlength  reservedspace
}
/**
* remove slot entry from slot array.
* <p>
* remove a storage slot at slot. shift the existing slots from
* slot+1 to (slotsinuse - 1) down by one..
* down here means from high slot to low slot (e.g from slot 3 to slot 2)
*
* @param slot                  the slot to delete.
*
**/
private void removeslotentry int slot
throws ioexception
if  sanitymanager debug
if   slot < 0      slot >  slotsinuse
sanitymanager throwassert     slot
}
int oldendoffset   getslotoffset slotsinuse   1
int newendoffset   getslotoffset slotsinuse   2
if  slot    slotsinuse   1
// if not removing the last slot, need to shift
// now shift all the slots logically down by one
// from (slot+1 to slotsinuse-1) to (slot and slotsinuse-2)
int length   getslotoffset slot    oldendoffset
system arraycopy
pagedata  oldendoffset  pagedata  newendoffset  length
}
// clear out the last slot
clearsection oldendoffset  slotentrysize
// mark the space as free after we have removed the slot
// no need to keep the space reserved for rollback as this is only
// called for purge.
freespace    slotentrysize
slotsinuse
headeroutofdate   true 	   headeroutofdate must be set after setdirty
// because isdirty maybe called unlatched
}
/**
* create the record header for the specific slot.
* <p>
* create a new record header object, initialize it, and add it
* to the array of cache'd record headers on this page.  finally return
* reference to the initialized record header.
*
* @return the record header for the specific slot.
*
* @param slot   return record header of this slot.
*
* @exception  standardexception  standard exception policy.
**/
public storedrecordheader recordheaderondemand int slot
storedrecordheader recordheader
new storedrecordheader pagedata  getrecordoffset slot
setheaderatslot slot  recordheader
return recordheader
}
/**************************************************************************
* record based routines.
**************************************************************************
*/
/**
* is entire record on the page?
* <p>
*
* @return true if the entire record at slot is on this page,
*         i.e, no overflow row or long columns.
*
* @param slot   check record at this slot.
*
* @exception  standardexception  standard exception policy.
**/
public boolean entirerecordonpage int slot
throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
}
storedrecordheader recordheader   getheaderatslot slot
if  recordheader hasoverflow
return false
// the row chain does not overflow, we need to walk all the fields to
// make sure they are not long columns.
try
int offset   getrecordoffset slot
if  sanitymanager debug
if  offset <  page_header_offset   page_header_size
sanitymanager throwassert
offset
page_header_offset   page_header_size
slot
slotsinuse
}
sanitymanager assert recordheader getfirstfield      0
}
int numberfields   recordheader getnumberfields
// these reads are always against the page array
arrayinputstream lrdi   rawdatain
// position after the record header, at 1st column.
lrdi setposition offset   recordheader size
for  int i   0  i < numberfields  i
int fieldstatus   storedfieldheader readstatus lrdi
if  storedfieldheader isoverflow fieldstatus
return false
int fieldlength
storedfieldheader readfielddatalength
lrdi  fieldstatus  slotfieldsize
if  fieldlength    0
lrdi setposition lrdi getposition     fieldlength
}
}
catch  ioexception ioe
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  getpageid
}
// we have examined all the fields on this page and none overflows
return true
}
/**
* purge one row on an overflow page.
* <p>
* headrowhandle is the recordhandle pointing to the head row piece.
* <p>
*
* @param slot              slot number of row to purge.
* @param headrowhandle     recordhandle of the head row piece.
* @param needdatalogged    when true data is logged for purges otherwise just headers.
*
* @exception  standardexception  standard exception policy.
**/
protected void purgeoverflowatslot
int             slot
recordhandle    headrowhandle
boolean         needdatalogged
throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
sanitymanager assert isoverflowpage
}
if   slot < 0      slot >  slotsinuse
throw standardexception newexception
sqlstate data_slot_not_on_page
}
// todo (mikem) - should a global scratch variable be used?
// this is an overflow page purge, no need to lock the head row (it
// has already been locked, hopefully).  no need to check for long rows
// (they have already been deleted, hopefully).
rawtransaction  t             owner gettransaction
int           recordid      new int
recordid                   getheaderatslot slot  getid
owner getactionset   actionpurge t  this  slot  1  recordid  needdatalogged
}
/**
* purge the column chain that starts at overflowpageid, overflowrecordid
* <p>
* purge just the column chain that starts at the input address.
* the long column chain is pointed at by a field in a row.  the long
* column is then chained as a sequence of "rows", the last column then
* points to the next segment of the chain on each page.
* long columns chains currently are only one row per page so the next
* slot of a row in a long row chain should always be the first slot.
* <p>
*
* @param overflowpageid    the page where the long column chain starts.
* @param overflowrecordid  the record id where long column chain starts.
*
* @exception  standardexception  standard exception policy.
**/
private void purgeonecolumnchain
long    overflowpageid
int     overflowrecordid
throws standardexception
storedpage pageoncolumnchain   null
boolean removepagehappened   false
try
while  overflowpageid    containerhandle invalid_page_number
// now loop over the column chain and get all the column pieces.
pageoncolumnchain     getoverflowpage overflowpageid
removepagehappened    false
if  pageoncolumnchain    null
if  sanitymanager debug
sanitymanager throwassert
getidentity
overflowpageid
break 	   don't know what to do here  the column chain
// is broken.  don't bomb, go to the next field.
}
int overflowslotid   first_slot_number
if  sanitymanager debug
int checkslot
pageoncolumnchain findrecordbyid
overflowrecordid  first_slot_number
if  overflowslotid    checkslot
sanitymanager throwassert
first_slot_number
checkslot
}
sanitymanager assert pageoncolumnchain recordcount      1
}
// hold on to the pointer to next page on the chain before
// we remove the long column page.
recordhandle nextcolumnpiece
pageoncolumnchain getnextcolumnpiece overflowslotid
if  pageoncolumnchain recordcount      1
removepagehappened   true
owner removepage pageoncolumnchain
}
else
if  sanitymanager debug
sanitymanager throwassert
pageoncolumnchain tostring
pageoncolumnchain unlatch
pageoncolumnchain   null
}
// chase the column chain pointer.
if  nextcolumnpiece    null
overflowpageid        nextcolumnpiece getpagenumber
overflowrecordid      nextcolumnpiece getid
}
else
// terminate the loop
overflowpageid        containerhandle invalid_page_number
}
}
}
finally
// if we raised an exception before the page is removed, make sure
// we unlatch the page
if   removepagehappened    pageoncolumnchain    null
pageoncolumnchain unlatch
pageoncolumnchain   null
}
}
}
/**
* purge long columns chains which eminate from this page.
* <p>
* purge all the long column chains emanating from the record on this slot
* of this page.  the headrowhandle is the record handle of the head row
* piece of this row - if this page is the head row, then headrowhandle is
* the record handle at the slot.  otherwise, headrowhandle points to a
* row on a different page, i.e., the head page.
* <p>
*
* @param t             the raw transaction doing the purging.
* @param slot          the slot of the row to purge.
* @param headrowhandle the recordhandle of the head row.
*
*
* @exception  standardexception  standard exception policy.
**/
private void purgecolumnchains
rawtransaction  t
int             slot
recordhandle    headrowhandle
throws standardexception
try
storedrecordheader recordheader   getheaderatslot slot
int numberfields      recordheader getnumberfields
// these reads are always against the page array
arrayinputstream lrdi   rawdatain
// position the stream to just after record header.
int offset            getrecordoffset slot    recordheader size
lrdi setposition offset
for  int i   0  i < numberfields  i
int fieldstatus   storedfieldheader readstatus lrdi
int fieldlength
storedfieldheader readfielddatalength
lrdi  fieldstatus  slotfieldsize
if   storedfieldheader isoverflow fieldstatus
// skip this field, it is not an long column
if  fieldlength    0
lrdi setposition lrdi getposition     fieldlength
continue
}
else
// got an overflow field.  the column value is the
// <pageid, recordid> pair where the next column piece is
// residing
long overflowpageid
compressednumber readlong  inputstream lrdi
int  overflowrecordid
compressednumber readint  inputstream lrdi
purgeonecolumnchain overflowpageid  overflowrecordid
}
}
}
catch  ioexception ioe
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  getpageid
}
}
/**
* purge all the overflow columns and overflow rows of the record at slot.
* <p>
* purge all the overflow columns and overflow rows of the record at slot.
* this is called by basepage.purgeatslot, the head row piece is purged
* there.
* <p>
*
* @param t             the raw transaction doing the purging.
* @param slot          the slot of the row to purge.
* @param headrowhandle the recordhandle of the head row.
* @param needdatalogged    when true data is logged for purges otherwise just headers.
*
* @exception  standardexception  standard exception policy.
**/
protected void purgerowpieces
rawtransaction  t
int             slot
recordhandle    headrowhandle
boolean         needdatalogged
throws standardexception
if  sanitymanager debug
sanitymanager assert isoverflowpage      false
// purge the long columns which start on this page.
purgecolumnchains t  slot  headrowhandle
// drive this loop from the head page. walk each "long" row piece in
// the row chain.
storedrecordheader recordheader   getheaderatslot slot
while  recordheader hasoverflow
// nextpageinrowchain, is the page with the next row piece
storedpage nextpageinrowchain
getoverflowpage recordheader getoverflowpage
if  nextpageinrowchain    null
if  sanitymanager debug
sanitymanager throwassert
getidentity
slot       headrowhandle
recordheader getoverflowpage
recordheader getoverflowid
}
break 	   don't know what to do here  the row chain is
// broken.  don't bomb, just return.
}
try
int nextpageslot
getoverflowslot nextpageinrowchain  recordheader
// first get rid of all long columns from the next row piece.
nextpageinrowchain purgecolumnchains
t  nextpageslot  headrowhandle
// before we purge the next row piece, get the row header to
// see if we need to continue the loop.
recordheader   nextpageinrowchain getheaderatslot nextpageslot
// lastly, purge the next row piece.  if the next row piece is
// the only thing in the entire page, just deallocate the page.
// we can do this because the page is deallocated in this
// transaction.  if we defer this to post commit processing,
// then we have to first purge the row piece and also remember
// the page time stamp.
if  nextpageslot    0    nextpageinrowchain recordcount      1
// this is an overflow page and we just purged the last row.
// free the page.  cannot do it in post commit because the
// head row is gone and cannot be locked at post commit to
// stablelize the row chain.
try
owner removepage nextpageinrowchain
}
finally
// remove page guarantees to unlatch the page even
// if an exception is thrown, need not unlatch it
// again.
nextpageinrowchain   null
}
}
else
nextpageinrowchain purgeoverflowatslot
nextpageslot  headrowhandle  needdatalogged
nextpageinrowchain unlatch
nextpageinrowchain   null
}
}
finally
// unlatch the next row piece before getting the next page in
// the row chain.
if  nextpageinrowchain    null
nextpageinrowchain unlatch
nextpageinrowchain   null
}
}
}
}
/**
* remove a column chain that may have been orphaned by an update.
* <p>
* remove a column chain that may have been orphaned by an update.  this
* is executed as a post commit operation.  this page is the head page of
* the row which used to point to the column chain in question.  the
* location of the orphaned column chain is in the reclaimspace record.
* <br>
* mt - latched.  no lock will be gotten, the head record must already be
* locked exclusive with no outstanding changes that can be rolled back.
* <p>
*
* @param work          object describing the chain to remove.
* @param containerhdl  open container handle to use to remove chain.
*
* @exception  standardexception  standard exception policy.
**/
/* package */
void removeorphanedcolumnchain
reclaimspace    work
containerhandle containerhdl
throws standardexception
// first we need to make sure that this is the first and only time
// this long column is begin reclaimed, to do this we get the first
// page on the long column chain and compare its page time stamp.
// if it is different, don't do anything.
//
// next we need to make sure the update operation commits - we do
// this by finding the row headed by headrecord, go to the column
// in question and see if it points to the first page of the long
// column chain we want to reclaim.  if it does then the update
// operation has rolled back and we don't want to reclaim it.
//
// after we do the above 2 checks, we can reclaim the column
// chain.
storedpage headofchain
storedpage containerhdl getpagenowait work getcolumnpageid
// if someone has it latched, not reclaimable
if  headofchain    null
return
// if the column has been touched, it is not orphaned.  not reclaimable.
boolean pageunchanged
headofchain equaltimestamp work getpagetimestamp
headofchain unlatch   	   unlatch it for now
if  pageunchanged    false
return
// now get to the column in question and make sure it is no longer
// pointing to the column chain.
recordhandle headrowhandle   work getheadrowhandle
if  sanitymanager debug
// system.out.println("executing in removeorphanedcolumnchain.");
// system.out.println("work =  " + work);
// system.out.println("head = " + headofchain);
// system.out.println("this = " + this);
sanitymanager assert islatched
sanitymanager assert
headrowhandle getpagenumber      getpagenumber
}
// first get the row.
int slot
findrecordbyid
headrowhandle getid    headrowhandle getslotnumberhint
// if slot < 0, it means the whole record is gone, the column chain is
// definitely orphaned.
if  slot >  0
if  sanitymanager debug
if  isoverflowpage
sanitymanager throwassert
getpagenumber
work
headofchain
this
}
}
// find the page with the column in question on it.
storedpage pageinrowchain   this     start with the head page
try
int columnid   work getcolumnid
storedrecordheader recordheader   getheaderatslot slot
if  sanitymanager debug
sanitymanager assert recordheader getfirstfield      0
// see if columnid is on pageinrowchain.
while   recordheader getnumberfields
recordheader getfirstfield    <  columnid
// the column in question is not on pageinrowchain.
if  pageinrowchain    this
// keep the head page latched.
pageinrowchain unlatch
pageinrowchain   null
}
if  recordheader hasoverflow
// go to the next row piece
pageinrowchain
getoverflowpage recordheader getoverflowpage
recordheader
pageinrowchain getheaderatslot
getoverflowslot pageinrowchain  recordheader
}
else
//  don't know why, but this is the last column.
//  anyway, the column chain is definite orphaned.
//  this can happen if the update, or subsequent
//  updates, shrink the number of columns in the row.
break
}
}
if   recordheader getnumberfields
recordheader getfirstfield    > columnid
// recordheader is the record header of the row piece on
// pageinrowchain.  the column in question exists and is in
// that row piece.
if   pageinrowchain iscolumnorphaned
recordheader  columnid
work getcolumnpageid    work getcolumnrecordid
// the column is not orphaned, row still points to it.
if  pageinrowchain    this
// keep the head page latched.
pageinrowchain unlatch
pageinrowchain   null
}
return
}
}
}
catch  ioexception ioe
throw standardexception newexception
sqlstate data_unexpected_exception  ioe
}
finally
if  pageinrowchain    this    pageinrowchain    null
pageinrowchain unlatch
}
}
// if we get this far, we have verified that the column chain is indeed
// orphaned. get rid of the column chain.
long nextpageid       work getcolumnpageid
int  nextrecordid     work getcolumnrecordid
purgeonecolumnchain nextpageid  nextrecordid
}
/**
* see if there is a orphaned long colum chain or not.
* <p>
* see if there is a orphaned long colum chain or not.  this is a helper
* function for removeorphanedchain.  this page, which may be a head page
* or overflow page, contains the column specified in columnid.  it used to
* point to a long column chain at oldpageid and oldrecordid.  returns true
* if it no longer points to that long column chain.
* <p>
*
* @return true if page no longer points to the long column chain.
*
* @param recordheader  record header which used to point at the long column
* @param columnid      column id of the long column in head.
* @param oldpageid     the page id where the long column used to be.
* @param oldrecordid   the record id where the long column used to be.
*
* @exception  standardexception  standard exception policy.
**/
private boolean iscolumnorphaned
storedrecordheader  recordheader
int                 columnid
long                oldpageid
long                oldrecordid
throws standardexception  ioexception
int slot   findrecordbyid recordheader getid    page first_slot_number
if  sanitymanager debug
sanitymanager assert slot >  0
sanitymanager assert
columnid >  recordheader getfirstfield
}
// these reads are always against the page array
arrayinputstream lrdi   rawdatain
// set read position to data portion of record to check.
int offset   getrecordoffset slot
lrdi setposition offset   recordheader size
// skip until you get to the record in question.
for  int i   recordheader getfirstfield    i < columnid  i
skipfield lrdi
// read in the info of the column we are interested in.
int fieldstatus   storedfieldheader readstatus lrdi
int fieldlength   storedfieldheader readfielddatalength
lrdi  fieldstatus  slotfieldsize
if  storedfieldheader isoverflow fieldstatus
// it is still an overflow field, check if it still points to
// overflow column in question.
long ovflowpage   compressednumber readlong  inputstream  lrdi
int  ovflowrid    compressednumber readint  inputstream  lrdi
if  ovflowpage    oldpageid    ovflowrid    oldrecordid
// this field still points to the column chain, the
// update must have rolled back.
return false
}
}
// else, either the field is no longer a long column, or it doesn't
// point to oldpageid, oldrecordid.  the column chain is orphaned.
return true
}
/**
@return a recordhandle pointing to the next piece of the column chain.
this page must be an overflow page that is in a column chain.  if this
is the last piece of the overflow colum, return null.
@param slot the slot number where the current piece of overflow column
is at.
@exception standardexception derby standard error policy
*/
/**
* return the next recordhandle in a long column chain.
* <p>
* return a recordhandle pointing to the next piece of the column chain.
* this page must be an overflow page that is in a column chain.  if this
* is the last piece of the overflow colum, return null.
* <p>
*
* @return the next record handle in a long column chain.
*
* @param slot   the slot of the current long column piece.
*
* @exception  standardexception  standard exception policy.
**/
private recordhandle getnextcolumnpiece int slot
throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
sanitymanager assert isoverflowpage
if  recordcount      1
sanitymanager throwassert
recordcount
}
}
try
storedrecordheader recordheader   getheaderatslot slot
int numberfields
recordheader getnumberfields
if  sanitymanager debug
if   numberfields > 2      numberfields < 1
sanitymanager throwassert
numberfields
}
}
if  numberfields    2     end of column chain
return null
// these reads are always against the page array
arrayinputstream lrdi   rawdatain
// the 2nd field is the pointer to the next page in column chain.
int offset   getrecordoffset slot    recordheader size
lrdi setposition offset
// skip the first field
skipfield lrdi
// the 2nd field should be <pageid, recordid> pair, return the
// pageid part and skip over the length.
int fieldstatus   storedfieldheader readstatus lrdi
int fieldlength   storedfieldheader readfielddatalength
lrdi  fieldstatus  slotfieldsize
long ovflowpage   compressednumber readlong  inputstream  lrdi
int  ovflowrid    compressednumber readint  inputstream  lrdi
if  sanitymanager debug
if   storedfieldheader isoverflow fieldstatus
// in version 1.5, the first field is overflow and the
// second is not. in version 2.0 onwards, the first field
// is not overflow and the second is overflow (the overflow
// bit goes with the overflow pointer).  check first field
// to make sure its overflow bit is set on.
// offset still points to the first column.
lrdi setposition offset
fieldstatus   storedfieldheader readstatus lrdi
sanitymanager assert
storedfieldheader isoverflow fieldstatus
}
}
// resolve : this new can get expensive if the column chain is very
// long.  the reason we do this is because we need to return the
// page number and the rid, if we assume that the long column is
// always at slot 0, we can return only the page.
return owner makerecordhandle ovflowpage  ovflowrid
}
catch  ioexception ioe
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  getpageid
}
}
/**************************************************************************
* page space usage
**************************************************************************
*/
/**
* initialize the in memory variables associated with space maintenance.
* <p>
* get the total available space on an empty page.
* initslottable() must be called after the page has been read in.
**/
private void initspace
// note: subclass may have overwitten it to report less freespace,
// always call getmaxfreespace() to get total space.
totalspace   getmaxfreespace
// estimate rh will be about 16 bytes:
// (1 - status, 1 - id, 1 - #fields, 1 - 1stfield, 12 - overflow ptr)
// resolved: track# 3370, 3368
// in the old code below, sparespace/100 is integer division. this means
// that you get a value of 0 for it as long as sparespace is between 0
// and 99. but if sparespace is 100 you get a value of 1. this resulted
// in a negative value for maxfieldsize. this caused e.g. the islong
// method to behave incorrectly when sparespace is 100.
//
// resolved: track# 4385
// maxfieldsize is a worst case calculation for the size of a record
// on an empty page, with a single field, but still allow room for
// an overflow pointer if another field is to be added.  if you don't
// account for the overflow pointer then you can get into the situation
// where the code puts the field on the page (not making it a long
// column), then runs out of space on next column but can't fit overflow
// pointer, so backs up and removes the column from page, and tries
// again on next overflow page - looping forever.
//
// maxfieldsize =
//     totalspace * (1 - sparespace/100) - slotentrysize
//     - 16 - overflow_pointer_size;
maxfieldsize   totalspace   slotentrysize   16   overflow_pointer_size
if  sanitymanager debug
sanitymanager assert maxfieldsize >  0
}
/**
* initialize the freespace count and set the firstfreebyte on page
**/
private void clearallspace
freespace       totalspace
firstfreebyte   getpagesize     totalspace   checksum_size
}
/**
* compress out the space specified by startbyte and endbyte.
* <p>
* as part of moving rows, updating rows, purging rows compact the space
* left between rows.
* <p>
*
* @param startbyte compress out space starting at startbyte offset
* @param endbyte   compress out space ending   at endbyte   offset
*
**/
private void compresspage
int startbyte
int endbyte
throws ioexception
if  sanitymanager debug
if    endbyte   1  > firstfreebyte      startbyte > firstfreebyte
sanitymanager throwassert
startbyte       endbyte
firstfreebyte
}
}
int lengthtoclear   endbyte   1   startbyte
// see if these were not the last occupied record space on the page
if   endbyte   1     firstfreebyte
// shift everything down the page.
int movelength    firstfreebyte   endbyte   1
system arraycopy
pagedata   endbyte   1   pagedata  startbyte  movelength
// fix the page offsets of the rows further down the page
for  int slot   0  slot < slotsinuse  slot
int offset   getrecordoffset slot
if  offset >   endbyte   1
offset    lengthtoclear
setrecordoffset slot  offset
}
}
}
freespace        lengthtoclear
firstfreebyte    lengthtoclear
clearsection firstfreebyte  lengthtoclear
}
/**
* free up required bytes by shifting rows "down" the page.
* <p>
* expand page, move all the data from start offset down the page by
* the amount required to free up the required bytes.
*
* @param startoffset   offset on page to begin the shift
* @param requiredbytes the number of bytes that must be freed.
*
* @exception ioexception	if ioexception is raised during the page mod.
**/
protected void expandpage
int startoffset
int requiredbytes
throws ioexception
if  sanitymanager debug
sanitymanager assert requiredbytes <  freespace
sanitymanager assert startoffset <  firstfreebyte
}
int totallength   firstfreebyte   startoffset
if  totallength > 0
system arraycopy
pagedata  startoffset
pagedata  startoffset   requiredbytes  totallength
// fix the page offsets of the rows further down the page
for  int slot   0  slot < slotsinuse  slot
int offset   getrecordoffset slot
if  offset >  startoffset
offset    requiredbytes
setrecordoffset slot  offset
}
}
}
freespace        requiredbytes
firstfreebyte    requiredbytes
}
/**
* shrink page.
* <p>
* move all the data from start offset up the page by the amount shrunk.
*
*
* @param startoffset   offset on page to begin the shift
* @param shrinkbytes   the number of bytes that must be moved.
*
* @exception ioexception	some ioexception is raised during the page mod,
*                          (unlikely as this is just writing to array).
**/
private void shrinkpage int startoffset  int shrinkbytes
throws ioexception
// the number of bytes that needs to be moved up.
int totallength   firstfreebyte   startoffset
if  sanitymanager debug
sanitymanager debug
getidentity
shrinkbytes
startoffset
startoffset shrinkbytes
totallength
firstfreebyte
sanitymanager assert
totallength >  0
sanitymanager assert
startoffset shrinkbytes  > record_space_offset
if  startoffset    firstfreebyte
// make sure startoffset is at the beginning of a record
boolean foundslot   false
for  int slot   0  slot < slotsinuse  slot
if  getrecordoffset slot     startoffset
foundslot   true
break
}
}
if   foundslot
sanitymanager throwassert
startoffset
}
}
}
if  totallength > 0
system arraycopy
pagedata  startoffset
pagedata  startoffset shrinkbytes   totallength
// fix the page offsets of the rows further down the page
for  int slot   0  slot < slotsinuse  slot
int offset   getrecordoffset slot
if  offset >  startoffset
offset    shrinkbytes
setrecordoffset slot  offset
}
}
}
freespace        shrinkbytes
firstfreebyte    shrinkbytes
}
public int getrecordlength int slot  throws ioexception
return getrecordportionlength slot
}
protected  boolean getisoverflow int slot  throws ioexception
return getheaderatslot slot  hasoverflow
}
/**
log a row into the storeouput stream.
<p>
@exception standardexception	standard derby error policy
@exception ioexception			resolve
*/
/**
* log a row into the storeouput stream.
* <p>
* write the row in its record format to the stream. record format is a
* record header followed by each field with its field header. see this
* class's description for the specifics of these headers.
*
* startcolumn is used to specified which column for this logrow to
* start logging.  when realstartcolumn is specified, that means part of
* the row has already been logged.  startcolumn here indicates that the
* first column was logged in the logbuffer, need to continue log the rest
* of the row starting at realstartcolumn.
*
* this is used when a longcolumn is encountered during a long row.
* after done logging the long column, we need to continue logging the
* rest of the row.
* a -1 value for realstartcolumn, means that it is not significant.
*
* logrow will not throw an nospaceonpage exception, if it is an overflow
* page, and the record we are inserting is the only record on the page.
* we are supporting rows expanding multiple pages through this mechanism.
*
* logrow expects row to be a sparse row.
* <p>
*
* @return the "realstartcolumn" value, -1 if not a long row.
*
* @param slot              the slot of the row being logged.
* @param forinsert         this is logging an insert (not update/delete).
* @param recordid          record id of the row being logged.
* @param row               actual data of row in object form.  if row is
*                          null then we are logging an overflow pointer.
* @param validcolumns      bit map describing valid columns in row.
* @param out               stream to log to.
* @param startcolumn       what column to start with (see above for detail)
* @param insertflag        flag indicating mode we are in,
*                              insert_default - default insert
*                              insert_split   - splitting a row/column
*                                               across pages.
* @param realstartcolumn   if -1 ignore variable, else part of row has
*                          already been logged, and should continue with
*                          this column.
* @param realspaceonpage   use this as space on page if realstartcolumn
*                          is not -1.
* @param overflowthreshold how much of the page to use before deciding
*                          to overflow a row.
*
* @exception  ioexception		  resolve
* @exception  standardexception  standard exception policy.
*
* @see basepage#logrow
**/
public int logrow
int                     slot
boolean                 forinsert
int                     recordid
object                row
formatablebitset                 validcolumns
dynamicbytearrayoutputstream  out
int                     startcolumn
byte                    insertflag
int                     realstartcolumn
int                     realspaceonpage
int                     overflowthreshold
throws standardexception  ioexception
// is this an update that just went through handleincompletelogrow
// and handleincompletelogrow threw an excepiton. in this case the
// buffer is already finished.
if   forinsert
if   realstartcolumn     1      realspaceonpage     1
return realstartcolumn
}
}
int spaceavailable   freespace
setoutputstream out
int beginposition   out getposition
// if we are inserting in the headpage,
// we need to make sure that there is enough room
// on the page for the reserve space.
userrowsize   0
boolean calcminimumrecordsize   false
if  realstartcolumn      1
// in the middle of logging a long row/column.
spaceavailable    realspaceonpage
beginposition     out getbeginposition
}
else
// logging row part that is on head page.
if   forinsert
// an update can use the total space of the record,
// even if not all of the fields are being updated.
// if the updated columns will not fit then some
// columns will move off the page to a new chunk.
spaceavailable    gettotalspace slot
}
else
// need to account for the slot table using extra space...
spaceavailable    slotentrysize
if  startcolumn    0
calcminimumrecordsize   true
}
// <= is ok here as we know we want to write at least one more byte
if  spaceavailable <  0
throw new nospaceonpage(isoverflowpage());
}
try
if  row    null
// if the row is null, we must be writing an overflow pointer.
return logoverflowrecord slot  spaceavailable  out
}
int                numberfields   0
storedrecordheader recordheader
if  forinsert
recordheader   new storedrecordheader
}
else
// get a full copy of the record header since we might change
// it,  and we can't modify the one on the page
recordheader
new storedrecordheader getheaderatslot slot
// an update always starts at the first column on this page
startcolumn   recordheader getfirstfield
}
if  validcolumns    null
// all columns in row[] are valid, we will be logging them all.
numberfields   row length   startcolumn
}
else
// resolve (mikem) - counting on validcolumns.length may be bad
// for performance.
for  int i   validcolumns getlength     1
i >  startcolumn
i
if  validcolumns isset i
numberfields   i   1   startcolumn
break
}
}
}
int onpagenumberfields    1     only valid for update
if  forinsert
recordheader setid recordid
recordheader setnumberfields numberfields
}
else
// an update
onpagenumberfields   recordheader getnumberfields
if  numberfields > onpagenumberfields
// number of fields *might* be increasing
if  recordheader hasoverflow
// other fields will be handled in next portion update
numberfields   onpagenumberfields
}
else
// number of fields is increasing
recordheader setnumberfields numberfields
}
}
else if  numberfields < onpagenumberfields
if  validcolumns    null
// number of fields is decreasing,
// but only allowed when the complete
// row is being updated.
recordheader setnumberfields numberfields
// resolve -
// need some post commit work if row has overflow
// if (recordheader.hasoverflow()) {
// remove overflow portion after commit.
// }
}
else
// we process all the fields, the unchanged ones
// at the end will have a single byte written out
// indicating they are unchanged (nonexistent)
numberfields   onpagenumberfields
}
}
}
int endfieldexclusive   startcolumn   numberfields
if  realstartcolumn >  endfieldexclusive
// the realstartcolumn is greater than the last column we need
// to log, so we are done.
return (-1);
}
if   insertflag   page insert_default     page insert_default
// if this is not logging the part of the row being inserted
// on the main page, then use startcolumn as first field.
recordheader setfirstfield startcolumn
}
// what column to start with?
int firstcolumn   realstartcolumn
if  realstartcolumn      1
// logging on the head page.
int recordheaderlength   recordheader write logicaldataout
spaceavailable    recordheaderlength
if  spaceavailable < 0
// ran out of space just writing the record header.
throw new nospaceonpage(isoverflowpage());
}
firstcolumn   startcolumn
}
boolean monitoringoldfields   false
int validcolumnssize
validcolumns    null  ? 0   validcolumns getlength
if  validcolumns    null
if   forinsert
// we monitor the length of the old fields by skipping them
// but only on a partial update.
if   validcolumns    null
firstcolumn <  startcolumn   onpagenumberfields
rawdatain setposition
getfieldoffset slot  firstcolumn
monitoringoldfields   true
}
}
}
int lastspaceavailable                spaceavailable
int recordsize                        0
int lastcolumnpositionallowoverflow   out getposition
int lastcolumnallowoverflow           startcolumn
if  spaceavailable > overflow_pointer_size
lastcolumnpositionallowoverflow    1
int columnflag   column_first
for  int i   firstcolumn  i < endfieldexclusive  i
object              ref            null
boolean             ignorecolumn   false
// should we log this column or not?
if   validcolumns    null
validcolumnssize > i    validcolumns isset i
if  i < row length
ref   row
}
else if   forinsert
// field is not supplied, log as non-existent
ignorecolumn   true
}
if  spaceavailable > overflow_pointer_size
lastcolumnpositionallowoverflow   out getposition
lastcolumnallowoverflow           i
}
lastspaceavailable   spaceavailable
if  ignorecolumn
if  sanitymanager debug
sanitymanager assert
ref    null
sanitymanager assert
validcolumns    null
}
if  i <  startcolumn   onpagenumberfields
if  sanitymanager debug
sanitymanager assert
monitoringoldfields
}
// need to keep track of the old field lengths
// as they are remaining in the row.
int oldoffset   rawdatain getposition
skipfield rawdatain
int oldfieldlength
rawdatain getposition     oldoffset
if  oldfieldlength <  spaceavailable
//  if field doesn't fit,
//      spaceavailable must be left unchanged.
logcolumn
null  0  out  integer max_value
column_none  overflowthreshold
spaceavailable    oldfieldlength
}
}
else
// this is an update that is increasing the number of
// columns but not providing any value, strange ...
spaceavailable
logcolumn
null  0  out  spaceavailable
columnflag  overflowthreshold
}
}
else
// ignorecolumn is false, we are logging this column.
if  monitoringoldfields
i <  startcolumn   onpagenumberfields
// skip the old version of the field so that
// rawdatain is correctly positioned.
skipfield rawdatain
}
try
if  ref    null
// no new value to provide, use the on page value.
spaceavailable
logcolumn
null  0  out  spaceavailable
columnflag  overflowthreshold
}
else
// log the value provided in the row[i]
spaceavailable
logcolumn
row  i  out  spaceavailable
columnflag  overflowthreshold
}
}
catch  longcolumnexception lce
// logcolumn determined that the column would not fit
// and that the column length exceeded the long column
// threshold so turn this column into a long column.
if   insertflag   page insert_default
page insert_default
// if default insert, just throw no space exception.
// if the lce has throw the column as an inputstream,
// in the following 2 situations
//    1. if column came in 'row[i]' as inputstream
//	  2. if the object stream of 'row[i]' is not
//	     null, which means that the object state of
//	     the column is null.
//
// we need to set the original inputstream column to
// the column that has been thrown by lce.  it is a
// store formated inputstream which remembers all
// the bytes that has been read, but not yet stored.
// therefore, we will not lose any bytes.
//
// in any other situation, we should not change the
// state of the column,
// i.e. if 'row[i]' has an object state, it should
// not be turned into an inputstream.
if   lce getcolumn   instanceof inputstream
row instanceof streamstorable
if   row instanceof inputstream
streamstorable  row  returnstream

// change state of stream so that it uses
// the stream just created by the lce -
// which is remembering the bytes it has
// already read from the stream but couldn't
// log as there was not enough room on
// current page.
streamstorable  row  setstream
inputstream  lce getcolumn
}
}
throw new nospaceonpage(isoverflowpage());
}
// when one of the following two conditions is true,
// we will allow the insert of the long column:
//
// 1.	if this is the last field,
//      and overflow field header fits on page.
// 2.	if it is not the last field,
//      and overflow field header fits on page (for col)
//      and another overflow ptr fits (for row).
//
//
if    spaceavailable >  overflow_ptr_field_size
i     endfieldexclusive   1
spaceavailable >   overflow_ptr_field_size   2
i <  endfieldexclusive   1
// if the column is a long column, it must be a
// inputstream.  we have made the input stream into
// a rememberbytesinputstream, have to set the
// column to that, in order to preserve the bytes
// we already read off the stream.
// caught a long column exception,
// set the variables, and rethrow the error
out setbeginposition beginposition
lce setexceptioninfo out  i  spaceavailable
throw  lce
}
}
}
int nextcolumn
recordsize     lastspaceavailable   spaceavailable
boolean recordislong
overflowthreshold    100  ?
false   islong recordsize  overflowthreshold
// get the no overflow case out of the way asap
if   lastspaceavailable    spaceavailable     recordislong
if   insertflag   page insert_default
page insert_default
throw new nospaceonpage(isoverflowpage());
}
if  recordislong
// if the record is long because of threshold,
// then, we need to reset the logicalout.
// set position to the end of the previous field
out setposition out getposition     recordsize
}
// did not write this column
nextcolumn   i
}
else
// assume that all fields will be written to this page.
nextcolumn   endfieldexclusive
}
// see if we have enough room to write an overflow field if the
// row needs to overflow.  we need overflow if we need to
// write another portion or another portion already exists and
// we will need to point to it.
if   lastspaceavailable    spaceavailable
insertflag   page insert_for_split
page insert_for_split
// the current row has filled the page.
if  spaceavailable <  overflow_pointer_size
if   i    startcolumn
lastcolumnpositionallowoverflow < 0
// not enough room for the overflow recordheader,
// and this is the first column on this page so
// need to try another page.
throw new nospaceonpage(isoverflowpage());
}
else
// we need to go back to the last column
// that left enough room for an overflow pointer.
out setposition lastcolumnpositionallowoverflow
nextcolumn   lastcolumnallowoverflow
}
}
}
if  nextcolumn < endfieldexclusive
// if the number of cols has been reduced.
int actualnumberfields   nextcolumn   startcolumn
// go back and update that numberfields in recordheader.
// no need to update spaceavailable here, because if we are
// here, we will be returning any way, and spaceavailable
// will be thrown away.
int oldsize   recordheader size
recordheader setnumberfields actualnumberfields
int newsize   recordheader size
// now we are ready to write the new record header.
int endposition   out getposition
if  oldsize > newsize
// if the old size is bigger than the new size, then
// leave extra bytes at the beginning of byte stream.
int delta   oldsize   newsize
out setbeginposition beginposition   delta
out setposition beginposition   delta
}
else if  newsize > oldsize
out setposition beginposition
}
else
out setbeginposition beginposition
out setposition beginposition
}
int reallen   recordheader write logicaldataout
if  sanitymanager debug
if   reallen    oldsize   newsize      oldsize
sanitymanager throwassert
reallen
oldsize   newsize        oldsize
}
}
out setposition endposition
if   forinsert
// the update is incomplete, fields beyond this
// point will have to move off the page. for any fields
// that are not being updated we have to save their
// values from this page to insert into an overflow
// portion.
//
// when the complete row is being updated there is no
// need to save any fields so just return.
if  validcolumns    null
handleincompletelogrow
slot  nextcolumn  validcolumns  out
}
}
return  nextcolumn
}
columnflag   column_none
}
out setbeginposition beginposition
startcolumn    1
if   calcminimumrecordsize
spaceavailable <  minimumrecordsize   userrowsize
throw new nospaceonpage(isoverflowpage());
}
}
finally
resetoutputstream();
}
return  startcolumn
}
/**
* handle an update of a record portion that is incomplete.
* <p>
* handle an update of a record portion that is incomplete.
* ie. columns have expanded that require other columns to move
* off the page into a new portion.
* <p>
* this method works out of the columns that need to be moved which are not
* being updated and makes a copy of their data. it then throws an
* exception with this data, much like the long column exception which will
* then allow the original insert to complete.
* <p>
* if no columns need to be saved (ie all the ones that would move are
* being updated) then no exception is thrown, logrow() will return and the
* update completes normally.
* <p>
*
* @param slot          slot of the current update.
* @param startcolumn   column to start at, handles start in middle of row
* @param columnlist    bit map indicating which columns are being updated.
* @param out           place to lot to.
*
* @exception  standardexception  standard exception policy.
**/
private void handleincompletelogrow
int                     slot
int                     startcolumn
formatablebitset                 columnlist
dynamicbytearrayoutputstream  out
throws standardexception
if  sanitymanager debug
sanitymanager assert columnlist    null
storedrecordheader rh   getheaderatslot slot
int endfieldexclusive   rh getfirstfield     rh getnumberfields
// first see if any fields are not being modified
boolean needsave   false
int columnlistsize   columnlist size
for  int i   startcolumn  i < endfieldexclusive  i
if    columnlistsize > i    columnlist get i
needsave   true
break
}
}
if   needsave
return
object savedfields
new object
bytearrayoutputstream fieldstream   null
for  int i   startcolumn  i < endfieldexclusive  i
// row is being updated - ignore
if  columnlistsize > i    columnlist get i
continue
// save the data
try
// use the old value - we use logfield to ensure that we
// get the raw contents of the field and don't follow
// any long columns. in addition we save this as a rawfield
// so that we preserve the state of the field header.
if  fieldstream    null
fieldstream   new bytearrayoutputstream
else
fieldstream reset
logfield slot  i  fieldstream
savedfields
new rawfield fieldstream tobytearray
}
catch  ioexception ioe
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  getpageid
}
}
// use a long column exception to notify the caller of the need
// to perform an insert of the columns that need to move
longcolumnexception lce   new longcolumnexception
lce setexceptioninfo
out  startcolumn   1    indicates not actual long column
lce setcolumn savedfields
throw lce
}
/**
@param row (in/out) the row that is to be restored (sparse representation)
@param limitinput the limit input stream
@param objectinput the object input stream
@exception standardexception	standard derby error policy
@exception ioexception  i/o exception in reading meta data.
*/
/**
* restore a storable row from a limitinputstream.
* <p>
* restore a storable row from an limitinputstream - user must supply two
* streams on top of the same data, one implements objectinput interface
* that knows how to restore the object, the other one implements
* limitinputstream.
* <p>
* @param in           the limit input stream
* @param row          (in/out) row that is to be restored
*                     (sparse representation)
*
* @exception  standardexception  standard exception policy.
**/
public void restorerecordfromstream
limitobjectinput    in
object            row
throws standardexception  ioexception
storedrecordheader recordheader   new storedrecordheader
recordheader read in
readrecordfromstream
row
row length   1
int  null
int  null
in
recordheader

}
/**
* process the qualifier list on the row, return true if it qualifies.
* <p>
* a two dimensional array is to be used to pass around a and's and or's in
* conjunctive normal form.  the top slot of the 2 dimensional array is
* optimized for the more frequent where no or's are present.  the first
* array slot is always a list of and's to be treated as described above
* for single dimensional and qualifier arrays.  the subsequent slots are
* to be treated as and'd arrays or or's.  thus the 2 dimensional array
* qual[][] argument is to be treated as the following, note if
* qual.length = 1 then only the first array is valid and it is and an
* array of and clauses:
*
* (qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1])
* and
* (qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1])
* and
* (qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1])
* ...
* and
* (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
*
*
* @return true if the row qualifies.
*
* @param row               the row being qualified.
* @param qual_list         2 dimensional array representing conjunctive
*                          normal form of simple qualifiers.
*
* @exception  standardexception  standard exception policy.
**/
private boolean qualifyrecordfromrow
object        row
qualifier   qual_list
throws standardexception
boolean     row_qualifies   true
if  sanitymanager debug
sanitymanager assert row    null
}
// first do the qual[0] which is an array of qualifer terms.
if  sanitymanager debug
// routine should not be called if there is no qualifier
sanitymanager assert qual_list    null
sanitymanager assert qual_list length > 0
}
for  int i   0  i < qual_list length  i
// process each and clause
row_qualifies   false
// process each or clause.
qualifier q   qual_list
// get the column from the possibly partial row, of the
// q.getcolumnid()'th column in the full row.
datavaluedescriptor columnvalue
datavaluedescriptor  row
row_qualifies
columnvalue compare
q getoperator
q getorderable
q getorderednulls
q getunknownrv
if  q negatecompareresult
row_qualifies    row_qualifies
// once an and fails the whole qualification fails - do a return!
if   row_qualifies
return false
}
// all the qual[0] and terms passed, now process the or clauses
for  int and_idx   1  and_idx < qual_list length  and_idx
// loop through each of the "and" clause.
row_qualifies   false
if  sanitymanager debug
// each or clause must be non-empty.
sanitymanager assert qual_list length > 0
}
for  int or_idx   0  or_idx < qual_list length  or_idx
// apply one qualifier to the row.
qualifier q        qual_list
int       col_id   q getcolumnid
if  sanitymanager debug
sanitymanager assert
col_id < row length
}
// get the column from the possibly partial row, of the
// q.getcolumnid()'th column in the full row.
datavaluedescriptor columnvalue
datavaluedescriptor  row
if  sanitymanager debug
if  columnvalue    null
sanitymanager throwassert
rowutil tostring row
row length
q getcolumnid
}
// do the compare between the column value and value in the
// qualifier.
row_qualifies
columnvalue compare
q getoperator
q getorderable
q getorderednulls
q getunknownrv
if  q negatecompareresult
row_qualifies    row_qualifies
// sanitymanager.debug_print("storedpage.qual", "processing qual[" + and_idx + "][" + or_idx + "] = " + qual_list[and_idx][or_idx] );
// sanitymanager.debug_print("storedpage.qual", "value = " + row_qualifies);
// processing "or" clauses, so as soon as one is true, break
// to go and process next and clause.
if  row_qualifies
break
}
// the qualifier list represented a set of "and'd"
// qualifications so as soon as one is false processing is done.
if   row_qualifies
break
}
return row_qualifies
}
/**
* read just one column from stream into row.
* <p>
* the routine reads just one column from the row, it is mostly code
* taken from readrecordfromstream, but highly optimized to just get
* one column from a non-overflow row.  it can only be called to read
* a row from the pagedata array as it directly accesses the page array
* to avoid the stream overhead while processing non-user data which
* does not need the limit functionality.
* <p>
* it is expected that this code will be called to read in a column
* associated with a qualifiers which are applied one column at a time,
* and has been specialized to proved the greatest peformance for
* processing qualifiers.  this kind of access is done when scanning
* large datasets while applying qualifiers and thus any performance
* gain at this low level is multiplied by the large number of rows that
* may be iterated over.
* <p>
* the column is read into the object located in row[qual_colid].
*
* @param row                   col is read into object in row[qual_colid].
* @param offset_to_field_data  offset in bytes from top of page to field
* @param colid                 the column id to read, colid n is row[n]
* @param recordheader          record header of row to read column from.
* @param recordtolock          record handle to lock,
*                              used by overflow column code.
*
* @exception  standardexception  standard exception policy.
**/
private final void readonecolumnfrompage
object                row
int                     colid
int                     offset_to_field_data
storedrecordheader      recordheader
recordhandle            recordtolock
throws standardexception  ioexception
errorobjectinput    inusercode   null
// reads in this routine are always against the raw data in the
// pagedata array, thus it can assume array access to page data array.
arrayinputstream lrdi   rawdatain
try
if  sanitymanager debug
if  colid >  row length
sanitymanager throwassert
colid
row length
// currently this routine will not work on long rows.
if  recordheader getfirstfield      0
sanitymanager throwassert
recordheader getfirstfield
}
}
object column       row
// if the column id exists on this page.
if  colid <   recordheader getnumberfields     1
// skip the fields before colid, the column in question
// existent on this page.
for  int columnid   colid  columnid > 0  columnid
offset_to_field_data
storedfieldheader readtotalfieldlength
pagedata  offset_to_field_data
}
// read the field header
// read the status byte.
int fieldstatus
storedfieldheader readstatus
pagedata  offset_to_field_data
// read the field data length, and position on 1st byte of data.
int fielddatalength
storedfieldheader readfieldlengthandsetstreamposition
pagedata
offset_to_field_data
storedfieldheader stored_field_header_status_size
fieldstatus
slotfieldsize
lrdi
if  sanitymanager debug
sanitymanager assert
storedfieldheader isextensible fieldstatus
}
// srw-djd code assumes non-extensible case ...
if   storedfieldheader isnonexistent fieldstatus
boolean isoverflow
storedfieldheader isoverflow fieldstatus
overflowinputstream overflowin   null
if  isoverflow
// a fetched long column is returned as a stream
long overflowpage
compressednumber readlong  inputstream  lrdi
int overflowid
compressednumber readint  inputstream  lrdi
// prepare the stream for results...
// create the byteholder the size of a page, so, that it
// will fit the field data that would fit on a page.
membyteholder byteholder
new membyteholder pagedata length
overflowin   new overflowinputstream
byteholder  owner  overflowpage
overflowid  recordtolock
}
// deal with storable columns
if  column instanceof datavaluedescriptor
datavaluedescriptor scolumn
datavaluedescriptor  column
// is the column null ?
if  storedfieldheader isnull fieldstatus
scolumn restoretonull
}
else
// set the limit for the user read
if   isoverflow
// normal, non-overflow column case.
lrdi setlimit fielddatalength
inusercode   lrdi
scolumn readexternalfromarray lrdi
inusercode   null
int unread   lrdi clearlimit
if  unread    0
lrdi skipbytes unread
}
else
// fetched column is a storable long column.
formatidinputstream newin
new formatidinputstream overflowin
if   scolumn instanceof streamstorable
streamstorable scolumn  setstream newin
}
else
inusercode   newin
scolumn readexternal newin
inusercode   null
}
}
}
}
else
// at this point only non-storable columns.
if  storedfieldheader isnull fieldstatus
// only storables can be null ...
throw standardexception newexception
sqlstate data_null_storable_column
integer tostring colid
}
// this is a non-extensible field, which means the
// caller must know the correct type and thus the
// element in row is the correct type or null. it must
// be serializable.
//
// we do not support externalizable here.
lrdi setlimit fielddatalength
inusercode   lrdi
// resolve (no non-storables?)
row    object  lrdi readobject
inusercode   null
int unread   lrdi clearlimit
if  unread    0
lrdi skipbytes unread
}
}
else
// column does not exist in the row, return null.
// field is non-existent
if  column instanceof datavaluedescriptor
// resolve - this is in place for 1.2. in the future
// we may want to return this column as non-existent
// even if it is a storable column, or maybe use a
// supplied default.
datavaluedescriptor  column  restoretonull
}
else
row   null
}
}
}
else
// field does not exist on this page.
if  column instanceof datavaluedescriptor
// resolve - this is in place for 1.2. in the future
// we may want to return this column as non-existent
// even if it is a storable column, or maybe use a
// supplied default.
datavaluedescriptor  column  restoretonull
}
else
row   null
}
}
}
catch  ioexception ioe
// an exception during the restore of a user column, this doesn't
// make the database corrupt, just that this field is inaccessable
if  inusercode    null
lrdi clearlimit
if  ioe instanceof eofexception
if  sanitymanager debug
sanitymanager debug_print
recordheader
this
sanitymanager showtrace ioe
}
// going beyond the limit in a datainput class results in
// an eofexception when it sees the -1 from a read
throw standardexception newexception
sqlstate data_storable_read_mismatch
ioe  inusercode geterrorinfo
}
// some sqldata error reporting
exception ne   inusercode getnestedexception
if  ne    null
if  ne instanceof instantiationexception
throw standardexception newexception
sqlstate data_sqldata_read_instantiation_exception
ne  inusercode geterrorinfo
}
if  ne instanceof illegalaccessexception
throw standardexception newexception
sqlstate data_sqldata_read_illegal_access_exception
ne  inusercode geterrorinfo
}
if  ne instanceof standardexception
throw  standardexception  ne
}
}
throw standardexception newexception
sqlstate data_storable_read_exception
ioe  inusercode geterrorinfo
}
// re-throw to higher levels so they can put it in correct context.
throw ioe
}
catch  classnotfoundexception cnfe
lrdi clearlimit
// an exception during the restore of a user column, this doesn't
// make the database corrupt, just that this field is inaccessable
throw standardexception newexception
sqlstate data_storable_read_missing_class
cnfe  inusercode geterrorinfo
}
catch  linkageerror le
// some error during the link of a user class
if  inusercode    null
lrdi clearlimit
throw standardexception newexception
sqlstate data_storable_read_exception
le  inusercode geterrorinfo
}
throw le
}
}
/**
* process the list of qualifiers on the row in the stream.
* <p>
* the rawdatain stream is expected to be positioned after the record
* header.
* <p>
* check all qualifiers in the qualifier array against row.  return true
* if all compares specified by the qualifier array return true, else
* return false.
* <p>
* this routine assumes client caller has already checked if the row
* is deleted or not.  the row that it get's is expected to match
* the partial column list of the scan.
* <p>
* on entering this routine the stream should be positioned to the
* beginning of the row data, just after the row header.  on exit
* the stream will also be positioned there.
*
* a two dimensional array is to be used to pass around a and's and or's in
* conjunctive normal form.  the top slot of the 2 dimensional array is
* optimized for the more frequent where no or's are present.  the first
* array slot is always a list of and's to be treated as described above
* for single dimensional and qualifier arrays.  the subsequent slots are
* to be treated as and'd arrays or or's.  thus the 2 dimensional array
* qual[][] argument is to be treated as the following, note if
* qual.length = 1 then only the first array is valid and it is and an
* array of and clauses:
*
* (qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1])
* and
* (qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1])
* and
* (qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1])
* ...
* and
* (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
*
* @return whether or not the row input qualifies.
*
* @param row                   restore row into this object array.
* @param offset_to_row_data    offset in bytes from top of page to row
* @param fetchdesc             description of fetch including which cols
*                              and qualifiers.
* @param recordheader          the record header of the row, it was read
*                              in from stream and datain is positioned
*                              after it.
* @param recordtolock          the head row to use for locking, used to
*                              lock head row of overflow columns/rows.
*
* @exception  standardexception  standard exception policy.
**/
private final boolean qualifyrecordfromslot
object                row
int                     offset_to_row_data
fetchdescriptor         fetchdesc
storedrecordheader      recordheader
recordhandle            recordtolock
throws standardexception  ioexception
boolean         row_qualifies      true
qualifier   qual_list          fetchdesc getqualifierlist
int           materializedcols   fetchdesc getmaterializedcolumns
if  sanitymanager debug
sanitymanager assert qual_list    null
}
if  sanitymanager debug
sanitymanager assert row    null
}
// first process the initial list of and's in the 1st array
for  int i   0  i < qual_list length  i
// process each and clause
row_qualifies   false
// apply one qualifier to the row.
qualifier q        qual_list
int       col_id   q getcolumnid
if  sanitymanager debug
sanitymanager assert
col_id < row length
}
// materialize the column object if we haven't done it yet.
if  materializedcols    0
// materialize just this column from the row, no qualifiers
readonecolumnfrompage
row
col_id
offset_to_row_data
recordheader
recordtolock
// mark offset, indicating the row has been read in.
//
// resolve (mikem) - right now value of entry is useless, it
// is an int so that in the future we could cache the offset
// to fields to improve performance of getting to a column
// after qualifying.
materializedcols   offset_to_row_data
}
// get the column from the possibly partial row, of the
// q.getcolumnid()'th column in the full row.
if  sanitymanager debug
if  row    null
sanitymanager throwassert
rowutil tostring row
row length
q getcolumnid
}
// do the compare between the column value and value in the
// qualifier.
row_qualifies
datavaluedescriptor  row  compare
q getoperator
q getorderable
q getorderednulls
q getunknownrv
if  q negatecompareresult
row_qualifies    row_qualifies
// once an and fails the whole qualification fails - do a return!
if   row_qualifies
return false
}
// now process the subsequent or clause's, beginning with qual_list[1]
for  int and_idx   1  and_idx < qual_list length  and_idx
// loop through each of the "and" clause.
row_qualifies   false
for  int or_idx   0  or_idx < qual_list length  or_idx
// apply one qualifier to the row.
qualifier q        qual_list
int       col_id   q getcolumnid
if  sanitymanager debug
sanitymanager assert
col_id < row length
}
// materialize the column object if we haven't done it yet.
if  materializedcols    0
// materialize just this column from the row, no qualifiers
readonecolumnfrompage
row
col_id
offset_to_row_data
recordheader
recordtolock
// mark offset, indicating the row has been read in.
//
// resolve (mikem) - right now value of entry is useless, it
// is an int so that in the future we could cache the offset
// to fields to improve performance of getting to a column
// after qualifying.
materializedcols   offset_to_row_data
}
// get the column from the possibly partial row, of the
// q.getcolumnid()'th column in the full row.
if  sanitymanager debug
if  row    null
sanitymanager throwassert
rowutil tostring row
row length
q getcolumnid
}
// do the compare between the column value and value in the
// qualifier.
row_qualifies
datavaluedescriptor  row  compare
q getoperator
q getorderable
q getorderednulls
q getunknownrv
if  q negatecompareresult
row_qualifies    row_qualifies
// sanitymanager.debug_print("storedpage.qual", "processing qual[" + and_idx + "][" + or_idx + "] = " + qual_list[and_idx][or_idx] );
// sanitymanager.debug_print("storedpage.qual", "value = " + row_qualifies);
// processing "or" clauses, so as soon as one is true, break
// to go and process next and clause.
if  row_qualifies
break
}
// the qualifier list represented a set of "and'd"
// qualifications so as soon as one is false processing is done.
if   row_qualifies
break
}
return row_qualifies
}
/**
* restore a record from a stream.
* <p>
* the rawdatain stream is expected to be positioned after the record
* header.
*
* @return the identifier to be used to open the conglomerate later.
*
* @param row               restore row into this object array.
* @param max_colid         the maximum numbered column id that will be
*                          requested by caller.  it should be:
*                            min(row.length - 1, maximum bit set in vcols)
*                          it is used to stop the inner most loop from
*                          looking at more columns in the row.
* @param vcols             if not null, bit map indicates valid cols.
* @param mcols             if not null, int array indicates columns already
*                          read in from the stream.  a non-zero entry
*                          means the column has already been read in.
* @param datain            restore row from this stream.
* @param recordheader      the record header of the row, it was read in
*                          from stream and datain is positioned after it.
* @param recordtolock      the head row to use for locking, used to lock
*                          head row of overflow columns/rows.
*
* @exception  standardexception  standard exception policy.
**/
private final boolean readrecordfromstream
object   row
int                     max_colid
int                   vcols
int                   mcols
limitobjectinput        datain
storedrecordheader      recordheader
recordhandle            recordtolock
throws standardexception  ioexception
errorobjectinput inusercode   null
try
// get the number of columns in the row.
int numberfields   recordheader getnumberfields
int startcolumn   recordheader getfirstfield
if  startcolumn > max_colid
// done if the startcolumn is higher than highest column.
return true
}
// for each column in the row, restore the column from
// the corresponding field in the record.  if the field
// is missing or not set, set the column to null.
int highestcolumnonpage   numberfields   startcolumn
int vcolssize              vcols    null   ? 0   vcols length
for  int columnid   startcolumn  columnid <  max_colid  columnid
// skip any "existing" columns not requested, or requested cols
// that have already been read.
if    vcols    null
vcolssize > columnid     vcols    0
mcols    null      mcols    0
if  columnid < highestcolumnonpage
// if the field exists in the row on the page, but the
// partial row being returned does not include it,
// skip the field ...
skipfield datain
}
continue
}
// see if the column identifier is beyond the number of fields
// that this record has
if  columnid >  highestcolumnonpage
// field is non-existent
object column   row
if  column instanceof datavaluedescriptor
// resolve - this is in place for 1.2. in the future
// we may want to return this column as non-existent
// even if it is a storable column, or maybe use a
// supplied default.
datavaluedescriptor  column  restoretonull
}
else
row   null
}
continue
}
// read the field header
int fieldstatus
storedfieldheader readstatus datain
int fielddatalength
storedfieldheader readfielddatalength
datain  fieldstatus  slotfieldsize
if  sanitymanager debug
sanitymanager assert
storedfieldheader isextensible fieldstatus
}
object column       row
overflowinputstream overflowin   null
// srw-djd code assumes non-extensible case ...
// field is non-existent, return null
if  storedfieldheader isnonexistent fieldstatus
if  column instanceof datavaluedescriptor
// resolve - this is in place for 1.2. in the future
// we may want to return this column as non-existent
// even if it is a storable column, or maybe use a
// supplied default.
datavaluedescriptor  column  restoretonull
}
else
row   null
}
continue
}
boolean isoverflow   storedfieldheader isoverflow fieldstatus
if  isoverflow
// a fetched long column needs to be returned as a stream
//
long overflowpage
compressednumber readlong  inputstream  datain
int overflowid
compressednumber readint  inputstream  datain
// prepare the stream for results...
// create the byteholder the size of a page, so, that it
// will fit the field data that would fit on a page.
membyteholder byteholder
new membyteholder pagedata length
overflowin   new overflowinputstream
byteholder  owner  overflowpage
overflowid  recordtolock
}
// deal with object columns
if  column instanceof datavaluedescriptor
datavaluedescriptor scolumn    datavaluedescriptor  column
// is the column null ?
if  storedfieldheader isnull fieldstatus
scolumn restoretonull
continue
}
// set the limit for the user read
if   isoverflow
// normal, non-overflow column case.
datain setlimit fielddatalength
inusercode   datain
scolumn readexternal datain
inusercode   null
int unread   datain clearlimit
if  unread    0
datain skipbytes unread
}
else
// column being fetched is a object long column.
formatidinputstream newin
new formatidinputstream overflowin
// if a column is a long column, store recommends user
// fetch it as a stream.
boolean fetchstream   true
if    scolumn instanceof streamstorable
fetchstream   false
}
if  fetchstream
streamstorable scolumn  setstream newin
}
else
inusercode   newin
scolumn readexternal newin
inusercode   null
}
}
continue
}
// at this point only non-storable columns.
if  storedfieldheader isnull fieldstatus
// only storables can be null ...
throw standardexception newexception
sqlstate data_null_storable_column
integer tostring columnid
}
// this is a non-extensible field, which means the caller must
// know the correct type and thus the element in row is the
// correct type or null. it must be serializable.
//
// we do not support externalizable here.
datain setlimit fielddatalength
inusercode   datain
row    object  datain readobject
inusercode   null
int unread   datain clearlimit
if  unread    0
datain skipbytes unread
continue
}
// if the last column on this page is bigger than the highest
// column we are looking for, then we are done restoring the record.
if   numberfields   startcolumn  > max_colid
return true
else
return false
}
catch  ioexception ioe
// an exception during the restore of a user column, this doesn't
// make the database corrupt, just that this field is inaccessable
if  inusercode    null
datain clearlimit
if  ioe instanceof eofexception
if  sanitymanager debug
sanitymanager debug_print
recordheader
this
}
// going beyond the limit in a datainput class results in
// an eofexception when it sees the -1 from a read
throw standardexception newexception
sqlstate data_storable_read_mismatch
ioe  inusercode geterrorinfo
}
// some sqldata error reporting
exception ne   inusercode getnestedexception
if  ne    null
if  ne instanceof instantiationexception
throw standardexception newexception
sqlstate data_sqldata_read_instantiation_exception
ne  inusercode geterrorinfo
}
if  ne instanceof illegalaccessexception
throw standardexception newexception
sqlstate data_sqldata_read_illegal_access_exception
ne  inusercode geterrorinfo
}
if  ne instanceof standardexception
throw  standardexception  ne
}
}
throw standardexception newexception
sqlstate data_storable_read_exception
ioe  inusercode geterrorinfo
}
// re-throw to higher levels so they can put it in correct context.
throw ioe
}
catch  classnotfoundexception cnfe
datain clearlimit
// an exception during the restore of a user column, this doesn't
// make the database corrupt, just that this field is inaccessable
throw standardexception newexception
sqlstate data_storable_read_missing_class
cnfe  inusercode geterrorinfo
}
catch  linkageerror le
// some error during the link of a user class
if  inusercode    null
datain clearlimit
throw standardexception newexception
sqlstate data_storable_read_exception
le  inusercode geterrorinfo
}
throw le
}
}
private final boolean readrecordfromarray
object   row
int                     max_colid
int                   vcols
int                   mcols
arrayinputstream        datain
storedrecordheader      recordheader
recordhandle            recordtolock
throws standardexception  ioexception
errorobjectinput inusercode   null
try
// get the number of columns in the row.
int numberfields   recordheader getnumberfields
int startcolumn   recordheader getfirstfield
if  startcolumn > max_colid
// done if the startcolumn is higher than highest column.
return true
}
// for each column in the row, restore the column from
// the corresponding field in the record.  if the field
// is missing or not set, set the column to null.
int highestcolumnonpage   numberfields   startcolumn
int vcolssize              vcols    null   ? 0   vcols length
int offset_to_field_data   datain getposition
for  int columnid   startcolumn  columnid <  max_colid  columnid
// skip any "existing" columns not requested, or requested cols
// that have already been read.
if    vcols    null
vcolssize > columnid     vcols    0
mcols    null      mcols    0
if  columnid < highestcolumnonpage
// if the field exists in the row on the page, but the
// partial row being returned does not include it,
// skip the field ...
offset_to_field_data
storedfieldheader readtotalfieldlength
pagedata  offset_to_field_data
}
continue
}
else if  columnid < highestcolumnonpage
// the column is on this page.
// read the field header
// read the status byte.
int fieldstatus
storedfieldheader readstatus
pagedata  offset_to_field_data
// read the field data length, position on 1st byte of data
int fielddatalength
storedfieldheader readfieldlengthandsetstreamposition
pagedata
offset_to_field_data
storedfieldheader stored_field_header_status_size
fieldstatus
slotfieldsize
datain
if  sanitymanager debug
sanitymanager assert
storedfieldheader isextensible fieldstatus
}
object              column       row
overflowinputstream overflowin   null
// srw-djd code assumes non-extensible case ...
if   fieldstatus   storedfieldheader field_nonexistent
storedfieldheader field_nonexistent
// normal path - field exists.
boolean isoverflow
fieldstatus
storedfieldheader field_overflow     0
if  isoverflow
// a fetched long column is returned as a stream
long overflowpage
compressednumber readlong  inputstream  datain
int overflowid
compressednumber readint  inputstream  datain
// prepare the stream for results...
// create the byteholder the size of a page, so,
// that it will fit the field data that would fit
// on a page.
membyteholder byteholder
new membyteholder pagedata length
overflowin   new overflowinputstream
byteholder  owner  overflowpage
overflowid  recordtolock
}
// deal with object columns
if  column instanceof datavaluedescriptor
datavaluedescriptor scolumn
datavaluedescriptor  column
// is the column null ?
if   fieldstatus
storedfieldheader field_null     0
// the field is not null.
// set the limit for the user read
if   isoverflow
// normal, non-overflow column case.
datain setlimit fielddatalength
inusercode   datain
scolumn readexternalfromarray datain
inusercode   null
int unread   datain clearlimit
if  unread    0
datain skipbytes unread
}
else
// column being fetched is a long column.
formatidinputstream newin
new formatidinputstream overflowin
// long columns are fetched as a stream.
boolean fetchstream   true
if    scolumn instanceof streamstorable
fetchstream   false
}
if  fetchstream
streamstorable  scolumn  setstream
newin
}
else
inusercode   newin
scolumn readexternal newin
inusercode   null
}
}
}
else
scolumn restoretonull
}
}
else
// at this point only non-storable columns.
if  storedfieldheader isnull fieldstatus
// only storables can be null ...
throw standardexception newexception
sqlstate data_null_storable_column
integer tostring columnid
}
// this is a non-extensible field, which means the
// caller must know the correct type and thus the
// element in row is the correct type or null. it
// must be serializable.
//
// we do not support externalizable here.
datain setlimit fielddatalength
inusercode   datain
// resolve (no non-storables?)
row    object  datain readobject
inusercode   null
int unread   datain clearlimit
if  unread    0
datain skipbytes unread
}
}
else
// column is non-existent.
if  column instanceof datavaluedescriptor
// resolve - this is in place for 1.2. in the future
// we may want to return this column as non-existent
// even if it is a storable column, or maybe use a
// supplied default.
datavaluedescriptor  column  restoretonull
}
else
row   null
}
}
// move the counter to point to beginning of next field.
offset_to_field_data   datain getposition
}
else
// field is non-existent
object column   row
if  column instanceof datavaluedescriptor
// resolve - this is in place for 1.2. in the future
// we may want to return this column as non-existent
// even if it is a storable column, or maybe use a
// supplied default.
datavaluedescriptor  column  restoretonull
}
else
row   null
}
}
}
// if the last column on this page is bigger than the highest
// column we are looking for, then we are done restoring the record.
if   numberfields   startcolumn  > max_colid
return true
else
return false
}
catch  ioexception ioe
// an exception during the restore of a user column, this doesn't
// make the database corrupt, just that this field is inaccessable
if  inusercode    null
datain clearlimit
if  ioe instanceof eofexception
if  sanitymanager debug
sanitymanager debug_print
recordheader
this
}
// going beyond the limit in a datainput class results in
// an eofexception when it sees the -1 from a read
throw standardexception newexception
sqlstate data_storable_read_mismatch
ioe  inusercode geterrorinfo
}
// some sqldata error reporting
exception ne   inusercode getnestedexception
if  ne    null
if  ne instanceof instantiationexception
throw standardexception newexception
sqlstate data_sqldata_read_instantiation_exception
ne  inusercode geterrorinfo
}
if  ne instanceof illegalaccessexception
throw standardexception newexception
sqlstate data_sqldata_read_illegal_access_exception
ne  inusercode geterrorinfo
}
if  ne instanceof standardexception
throw  standardexception  ne
}
}
throw standardexception newexception
sqlstate data_storable_read_exception
ioe  inusercode geterrorinfo
}
// re-throw to higher levels so they can put it in correct context.
throw ioe
}
catch  classnotfoundexception cnfe
datain clearlimit
// an exception during the restore of a user column, this doesn't
// make the database corrupt, just that this field is inaccessable
throw standardexception newexception
sqlstate data_storable_read_missing_class
cnfe  inusercode geterrorinfo
}
catch  linkageerror le
// some error during the link of a user class
if  inusercode    null
datain clearlimit
throw standardexception newexception
sqlstate data_storable_read_exception
le  inusercode geterrorinfo
}
throw le
}
}
/**
* restore a portion of a long column.
* <p>
* restore a portion of a long column - user must supply two streams on top
* of the same data, one implements objectinput interface that knows how to
* restore the object, the other one implements limitinputstream.
*
* @param fetchstream  the stream to read the next portion of long col from
*
* @exception  standardexception  standard exception policy.
**/
public void restoreportionlongcolumn
overflowinputstream fetchstream
throws standardexception  ioexception
int                 slot
findrecordbyid fetchstream getoverflowid    first_slot_number
storedrecordheader recordheader   getheaderatslot slot
int offset         getrecordoffset slot
int numberfields   recordheader getnumberfields
if  sanitymanager debug
if   numberfields > 2      numberfields < 1
sanitymanager throwassert
numberfields
}
}
rawdatain setposition offset   recordheader size
int fieldstatus
storedfieldheader readstatus rawdatain
int fielddatalength
storedfieldheader readfielddatalength
rawdatain  fieldstatus  slotfieldsize
// read the data portion of this segment from the stream.
byteholder bh   fetchstream getbyteholder
bh write rawdatain  fielddatalength
fetchstream setbyteholder bh
// set the next overflow pointer in the stream...
if  numberfields    1
// this is the last bit of the long column
fetchstream setoverflowpage  1
fetchstream setoverflowid  1
}
else
int firstfieldstatus   fieldstatus 	   for debug check
// get the field status and data length of the overflow pointer.
fieldstatus
storedfieldheader readstatus rawdatain
fielddatalength
storedfieldheader readfielddatalength
rawdatain  fieldstatus  slotfieldsize
if  sanitymanager debug
if   storedfieldheader isoverflow fieldstatus
// in version 1.5, the first field is overflow and the
// second is not.   in version 2.0 onwards, the first
// field is not overflow and the second is overflow
// (the overflow bit goes with the overflow pointer).
// check first field to make sure its overflow bit is
// set on.
sanitymanager assert
storedfieldheader isoverflow firstfieldstatus
}
}
long overflowpage
compressednumber readlong  inputstream  rawdatain
int  overflowid
compressednumber readint  inputstream  rawdatain
// there is more after this chunk.
fetchstream setoverflowpage overflowpage
fetchstream setoverflowid overflowid
}
}
/**
* log a storable to a stream.
* <p>
* log a storable into a stream.  this is used by update field operations
* <p>
* write the column in its field format to the stream. field format is a
* field header followed the data of the column as defined by the data
* itself.  see this class's description for the specifics of the header.
*
* @exception standardexception	    standard derby error policy
* @exception ioexception			resolve
**/
public void logcolumn
int                     slot
int                     fieldid
object                  column
dynamicbytearrayoutputstream  out
int                     overflowthreshold
throws standardexception  ioexception
// calculate the space available on the page, it includes
//	the free space
//  the space the record has reserved but not used
//  the length of the old field itself
// free space
int bytesavailable    freespace
int beginposition      1
// space reserved, but not used by the record
bytesavailable         getreservedcount slot
// the size of the old field is also available for the new field
rawdatain setposition getfieldoffset slot  fieldid
int fieldstatus
storedfieldheader readstatus rawdatain
int fielddatalength
storedfieldheader readfielddatalength
rawdatain  fieldstatus  slotfieldsize
bytesavailable
storedfieldheader size fieldstatus  fielddatalength  slotfieldsize
fielddatalength
try
setoutputstream out
beginposition   rawdataout getposition
object row   new object
row         column
if  bytesavailable    logcolumn
row  0  out  bytesavailable
column_none  overflowthreshold
throw new nospaceonpage(isoverflowpage());
}
}
finally
rawdataout setposition beginposition
resetoutputstream();
}
}
/**
* log a long column into a dataouput.
* <p>
* log a long column into a dataouput.  this is used by insert operations
* <p>
* write the column in its field format to the stream. field format is a
* field header followed the data of the column as defined by the data
* itself.  see this class's description for the specifics of the header.
*
* @param slot      slot of the row with the column
* @param recordid  record id of the
* @param column    the object form of the column to log
* @param out       where to log to the column to.
*
* @exception standardexception	standard derby error policy
* @exception ioexception	    i/o exception from writing to an array.
*
* @see basepage#logcolumn
**/
public int loglongcolumn
int                     slot
int                     recordid
object                  column
dynamicbytearrayoutputstream  out
throws standardexception  ioexception
int spaceavailable   freespace
// need to account for the slot table using extra space...
spaceavailable    slotentrysize
// <= is ok here as we know we want to write at least one more byte
if  spaceavailable <  0
throw new nospaceonpage(isoverflowpage());
setoutputstream out
int beginposition   out getposition
try
// in the long column portion on the new page there will be 1 field
// if the portion fits on the page (2 if it needs another pointer
// to continue to yet another page).
int numberfields   1
storedrecordheader recordheader
new storedrecordheader recordid  numberfields
int recordheaderlength   recordheader write logicaldataout
spaceavailable    recordheaderlength
if  spaceavailable < 0
// this part of long column won't totally fit on page, it
// needs to be linked to another page.  throw exception and
// caller will handle logging an overflow column portion
// with a forward pointer.
throw new nospaceonpage(isoverflowpage());
}
else
// the rest of the long column fits on the page!
object row   new object
row   column
return logcolumn row  0  out  spaceavailable  column_long  100
}
}
finally
resetoutputstream();
}
}
/**
* log column from input row to the given output stream.
* <p>
* read data from row[arrayposition], and write the column data in
* raw store page format to the given column.  along the way determine
* if the column will fit on the current page.
* <p>
* action taken in this routine is determined by the kind of column as
* specified in the columnflag:
*     column_none	 - the column is insignificant
*     column_first  - this is the first column in a logrow() call
*     column_long   - this is a known long column, therefore we will
*                     store part of the column on the current page and
*                     overflow the rest if necessary.
* <p>
* upon entry to this routine logicaldataout is tied to the
* dynamicbytearrayoutputstream out.
* <br>
* if a column is a long column and it does not totally fit on the current
* page, then a longcolumnexception is thrown.  we package up info about
* the current long column in the partially filled in exception so that
* callers can take correct action.  the column will now be set a as a
* stream.
*
* @return the spaceavailable after accounting for space for this column.
*
* @param row           array of column from which to read the column from.
* @param arrayposition the array position of column to be reading from row.
* @param out           the stream to write the raw store page format of the
*                      the column to.
* @param spaceavailable    the number of bytes available on the page for
*                          this column, this may differ from current page
*                          as it may include bytes used by previous
*                          columns.
* @param columnflag    one of: column_none, column_first, or column_long.
*
* @exception  standardexception    standard exception policy.
* @exception  longcolumnexception  thrown if column will not fit on a
*                                  single page. see notes above
**/
private int logcolumn
object                row
int                     arrayposition
dynamicbytearrayoutputstream  out
int                     spaceavailable
int                     columnflag
int                     overflowthreshold
throws standardexception  ioexception
// resolve (mikem) - why will row be null?
object column    row    null ? row   null
// check to see if the data comes from a page, if it is, then the field
// header is already formatted.
if  column instanceof rawfield
// field data is raw, no need to set up a field header etc.
byte data     rawfield  column  getdata
if  data length <  spaceavailable
out write data
spaceavailable    data length
}
return spaceavailable
}
// if this is a long column, it may fit in this page or it may not.
boolean longcolumndone   true
// default field status.
int fieldstatus
storedfieldheader setfixed storedfieldheader setinitial    true
int beginposition         out getposition
int columnbeginposition   0
int headerlength
int fielddatalength       0
if  column instanceof streamstorable
streamstorable  stream_storable_column    streamstorable  column
if  stream_storable_column returnstream      null
column
object  stream_storable_column returnstream
}
}
if  column    null
fieldstatus    storedfieldheader setnonexistent fieldstatus
headerlength
storedfieldheader write
logicaldataout  fieldstatus
fielddatalength  slotfieldsize
}
else if  column instanceof inputstream
rememberbytesinputstream bufferedin   null
int                      bufferlen   0
int estimatedmaxdatasize
getmaxdatalength spaceavailable  overflowthreshold
// if column is already instanceof rememberbytesinputstream, then we
// need to find out how many bytes have already been stored in the
// buffer.
if  column instanceof rememberbytesinputstream
// data is already rememberbytesinputstream
bufferedin    rememberbytesinputstream  column
bufferlen    bufferedin numbytessaved
}
else
// data comes in as an inputstream
bufferedin   new rememberbytesinputstream
inputstream  column  new membyteholder maxfieldsize   1
// always set stream of inputstream to rememberbytesinputstream
// so that all future access to this column will be able to
// get at the bytes drained from the inputstream, and copied
// into the rememberbytesinputstream.
if  row instanceof streamstorable
streamstorable row  setstream bufferedin
// set column to the rememberbytesinputstream so that
// all future access to this column will be able to get
// at bytes that have been already read. this assignment
// is needed to ensure that if long column exception is
// thrown, the column is set correctly
column   bufferedin
}
// read the buffer by reading the max we can read.
if  bufferlen <  estimatedmaxdatasize   1
bufferlen
bufferedin fillbuf estimatedmaxdatasize   1   bufferlen
}
if   bufferlen <  estimatedmaxdatasize
// we will be able to fit this into the page
fielddatalength   bufferlen
fieldstatus       storedfieldheader setfixed fieldstatus  true
headerlength      storedfieldheader write
logicaldataout  fieldstatus
fielddatalength  slotfieldsize
// if the field is extensible, then we write the serializable
// formatid.  if the field is non-extensible, we don't need to
// write the formatid.  but at this point, how do we know
// whether the field is extensible or not???  for plato release,
// we do not support inputstream on extensible types,
// therefore, we ignore the formatid for now.
bufferedin putbuf logicaldataout  fielddatalength
}
else
// current column will not fit into the current page.
if  columnflag    column_long
// column is a long column and the remaining portion does
// not fit on the current page.
longcolumndone   false
// it's a portion of a long column, and there is more to
// write reserve enough room for overflow pointer, then
// write as much data as we can leaving an extra 2 bytes
// for overflow field header.
fielddatalength
estimatedmaxdatasize   overflow_pointer_size   2
fieldstatus
storedfieldheader setfixed fieldstatus  true
headerlength
storedfieldheader write
logicaldataout  fieldstatus
fielddatalength  slotfieldsize
bufferedin putbuf logicaldataout  fielddatalength
// now, we need to adjust the buffer, move the unread
// bytes to the beginning position the cursor correctly,
// so, next time around, we can read more into the buffer.
int remainingbytes   bufferedin available
// move the unread bytes to the beginning of the byteholder.
int bytesshifted   bufferedin shifttofront
}
else
// column not a long column and does not fit on page.
int delta   maxfieldsize   bufferlen   1
if  delta > 0
bufferlen    bufferedin fillbuf delta
fielddatalength   bufferlen
// the data will not fit on this page make sure the new
// input stream is passed back to the upper layer...
column    object  bufferedin
}
}
}
else if  column instanceof datavaluedescriptor
datavaluedescriptor scolumn    datavaluedescriptor  column
boolean isnull   scolumn isnull
if  isnull
fieldstatus   storedfieldheader setnull fieldstatus  true
}
// header is written with 0 length here.
headerlength
storedfieldheader write
logicaldataout  fieldstatus
fielddatalength  slotfieldsize
if   isnull
// write the field data to the log
try
columnbeginposition   out getposition
scolumn writeexternal logicaldataout
}
catch  ioexception ioe
// sqldata error reporting
if  logicaldataout    null
exception ne   logicaldataout getnestedexception
if  ne    null
if  ne instanceof standardexception
throw  standardexception  ne
}
}
}
throw standardexception newexception
sqlstate data_storable_write_exception  ioe
}
fielddatalength
out getposition     beginposition    headerlength
}
}
else if  column instanceof recordhandle
// we are inserting an overflow pointer for a long column
// casted reference to column to avoid repeated casting.
recordhandle overflowhandle    recordhandle  column
fieldstatus       storedfieldheader setoverflow fieldstatus  true
headerlength
storedfieldheader write
logicaldataout  fieldstatus
fielddatalength  slotfieldsize
fielddatalength
compressednumber writelong out  overflowhandle getpagenumber
fielddatalength
compressednumber writeint out  overflowhandle getid
}
else
// serializable/externalizable/formattable
// all look the same at this point.
// header is written with 0 length here.
headerlength
storedfieldheader write
logicaldataout  fieldstatus
fielddatalength  slotfieldsize
logicaldataout writeobject column
fielddatalength
out getposition     beginposition    headerlength
}
// calculate the size of the field on page with compresed field header
fieldstatus   storedfieldheader setfixed fieldstatus  false
int fieldsizeonpage
storedfieldheader size fieldstatus  fielddatalength  slotfieldsize
fielddatalength
userrowsize    fielddatalength
boolean fieldislong   islong fieldsizeonpage  overflowthreshold
// do we have enough space on the page for this field?
if    spaceavailable < fieldsizeonpage      fieldislong
columnflag    column_long
// column was not long before getting here and does not fit.
if  fieldislong
// long column, and this first time we have figured out this
// column is long.
if    column instanceof inputstream
// convert already written object to an inputstream.
bytearray fielddata
new bytearray
dynamicbytearrayoutputstream out  getbytearray
columnbeginposition   fielddatalength
bytearrayinputstream columnin
new bytearrayinputstream
fielddata getarray    columnbeginposition
fielddatalength
membyteholder byteholder
new membyteholder fielddatalength   1
rememberbytesinputstream bufferedin
new rememberbytesinputstream columnin  byteholder
// the data will not fit on this page make sure the new
// input stream is passed back to the upper layer...
column   bufferedin
}
out setposition beginposition
// this exception carries the information for the client
// routine to continue inserting the long row on multiple
// pages.
longcolumnexception lce   new longcolumnexception
lce setcolumn column
throw lce
}
else
// column does not fit on this page, but it isn't a long column.
out setposition beginposition
return spaceavailable
}
}
// now we go back to update the fielddatalength in the field header
out setposition beginposition
// slotfieldsize is set based on the pagesize.
// we are borrowing this to set the size of our fielddatalength.
fieldstatus    storedfieldheader setfixed fieldstatus  true
headerlength   storedfieldheader write
out  fieldstatus  fielddatalength  slotfieldsize
// set position to the end of the field
out setposition beginposition   fielddatalength   headerlength
spaceavailable    fieldsizeonpage
// yyz: revisit
if  columnflag    column_long
// if we are logging a long column, we don't care how much space
// is left on the page, instead, we care whether we are done with
// the column or not.  so, here, we want to return 1. if we are
// not done, and return -1 if we are done.
// if logcolumn returns -1, that flag is returned all the way to
// basepage.insertlongcolumn to signal end of loop.
if  longcolumndone
return  1
else
return 1
else
return  spaceavailable
}
}
/**
* create and write a long row header to the log stream.
* <p>
* called to log a new overflow record, will check for space available
* and throw an exception if the record header will not fit on the page.
* <p>
*
* @return -1
*
* @param slot           slot of record to log.
* @param spaceavailable spaceavaliable on page.
* @param out            stream to log the record to.
*
* @exception  standardexception  standard exception policy.
**/
private int logoverflowrecord
int                     slot
int                     spaceavailable
dynamicbytearrayoutputstream  out
throws standardexception  ioexception
setoutputstream out
storedrecordheader pagerecordheader   getheaderatslot slot
storedrecordheader  overflow_rh   getoverflowrecordheader
overflow_rh setoverflowfields pagerecordheader
if  sanitymanager debug
sanitymanager assert overflow_rh getoverflowpage      0
}
/*
// #1 situation,
// we want to update the header to just an overflow pointer with no data
// so, update the recordheader, and we are done...
if (!overflow_rh.ispartialoverflow()) {
// this recordheader becomes just a overflow pointer,
// we need to make sure that the number of fields is set to 0.
overflow_rh.setnumberfields(0);
spaceavailable -= overflow_rh.write(logicaldataout);
if (spaceavailable < 0) {
throw new nospaceonpage(isoverflowpage());
}
resetoutputstream();
return (-1);
}
*/
// #2 situation,
// we want to only update the recordheader of the page, while leaving
// the data of the record on the page.  just update the header part and
// then arrange for the data part to move to after the new header.
int oldsize   pagerecordheader size
int newsize   overflow_rh size
if  oldsize < newsize
// need extra room...
int delta   newsize   oldsize
if  spaceavailable < delta
throw new nospaceonpage(isoverflowpage());
}
}
// write the new overflow_rh for the record.
overflow_rh write logicaldataout
// now, log the data
logrecorddataportion
slot  log_record_default  pagerecordheader
formatablebitset  null  logicaldataout   recordhandle null
return (-1);
}
private int logoverflowfield
dynamicbytearrayoutputstream  out
int                     spaceavailable
long                    overflowpage
int                     overflowid
throws standardexception  ioexception
int fieldstatus
storedfieldheader setoverflow
storedfieldheader setinitial    true
int fieldsizeonpage
compressednumber sizelong overflowpage
compressednumber sizeint overflowid
int fielddatalength   fieldsizeonpage
fieldsizeonpage
storedfieldheader size fieldstatus  fielddatalength  slotfieldsize
// need to check that we have room on the page for this.
spaceavailable    fieldsizeonpage
// what if there is not enough room for the overflow pointer?
if  spaceavailable < 0
throw new nospaceonpage(isoverflowpage());
// write the field to the page:
storedfieldheader write
logicaldataout  fieldstatus  fielddatalength  slotfieldsize
compressednumber writelong out  overflowpage
compressednumber writeint out  overflowid
// return the available bytes
return spaceavailable
}
/**
* log a record to the objectoutput stream.
* <p>
* write out the complete on-page record to the store stream.  data is
* preceeded by a  compressed int that gives the length of the following
* data.
*
* @exception standardexception	standard derby error policy
* @exception ioexception	    on error writing to log stream.
*
* @see basepage#logrecord
**/
public void logrecord
int             slot
int             flag
int             recordid
formatablebitset         validcolumns
outputstream    out
recordhandle    headrowhandle
throws standardexception  ioexception
storedrecordheader recordheader   getheaderatslot slot
if  recordid    recordheader getid
// the record is being logged under a different identifier,
// write it out with the correct identifier
storedrecordheader newrecordheader
new storedrecordheader recordheader
newrecordheader setid recordid
newrecordheader write out
newrecordheader   null
}
else
// write the original record header
recordheader write out
}
logrecorddataportion
slot  flag  recordheader  validcolumns  out  headrowhandle
}
private void logrecorddataportion
int                 slot
int                 flag
storedrecordheader  recordheader
formatablebitset             validcolumns
outputstream        out
recordhandle        headrowhandle
throws standardexception  ioexception
int offset   getrecordoffset slot
// now skip over the original header before writing the data
int oldheaderlength   recordheader size
offset    oldheaderlength
// write out the record data (fh+data+...) from the page data
int startfield   recordheader getfirstfield
int endfield   startfield   recordheader getnumberfields
int validcolumnssize    validcolumns    null  ? 0   validcolumns getlength
for  int fieldid   startfield  fieldid < endfield  fieldid
rawdatain setposition offset
// get the field header information from the page
int fieldstatus   storedfieldheader readstatus rawdatain
int fielddatalength   storedfieldheader readfielddatalength rawdatain  fieldstatus  slotfieldsize
// see if this field needs to be logged
// no need to write the data portion if the log is getting written
// for purges unless the field is  overflow pointer for a long column.
if    validcolumns    null       validcolumnssize > fieldid    validcolumns isset fieldid
flag   basepage log_record_for_purge   0     storedfieldheader isoverflow fieldstatus
// nope, move page offset along
offset    storedfieldheader size fieldstatus  fielddatalength  slotfieldsize
offset    fielddatalength
// write a non-existent field
fieldstatus   storedfieldheader setinitial
fieldstatus   storedfieldheader setnonexistent fieldstatus
storedfieldheader write out  fieldstatus  0  slotfieldsize
continue
}
// if this field is to be updated, and it points to a long column
// chain, the entire long column chain will be orphaned after the
// update operation.  therefore, need to queue up a post commit
// work to reclaim the long column chain.  we cannot do any clean
// up in this transaction now because we are underneath a log
// action and cannot interrupt the transaction log buffer.
// headrowhandle may be null if updateatslot is called to update a
// non-head row piece.  in that case, don't do anything.
// if temp container, don't do anything.
if    flag   basepage log_record_for_update     0
headrowhandle    null
storedfieldheader isoverflow fieldstatus
owner istemporarycontainer      false
int saveoffset   rawdatain getposition       remember the page offset
long overflowpage   compressednumber readlong  inputstream  rawdatain
int overflowid   compressednumber readint  inputstream  rawdatain
// remember the time stamp on the first page of the column
// chain.  this is to prevent the case where the post commit
// work gets fired twice, in that case, the second time it is
// fired, this overflow page may not part of this row chain
// that is being updated.
page firstpageoncolumnchain   getoverflowpage overflowpage
pagetimestamp ts   firstpageoncolumnchain currenttimestamp
firstpageoncolumnchain unlatch
rawtransaction rxact    rawtransaction owner gettransaction
reclaimspace work
new reclaimspace reclaimspace column_chain
headrowhandle
fieldid     long column about to be orphaned by update
overflowpage     page where the long column starts
overflowid     record id of the beginning of the long column
ts
rxact getdatafactory    true
rxact addpostcommitwork work
rawdatain setposition saveoffset      just to be safe  reset data stream
}
// write the field header for the log
offset    storedfieldheader write out  fieldstatus  fielddatalength  slotfieldsize
if  fielddatalength    0
// write the actual data
out write pagedata  offset  fielddatalength
offset    fielddatalength
}
}
}
/**
log a field to the objectoutput stream.
<p>
find the field in the record and then write out the complete
field, i.e. header and data.
@exception standardexception	standard derby error policy
@exception ioexception			resolve
@see basepage#logfield
*/
public void logfield int slot  int fieldnumber  outputstream out
throws standardexception  ioexception
int offset   getfieldoffset slot  fieldnumber
// these reads are always against the page array
arrayinputstream lrdi   rawdatain
// now write out the field we are interested in ...
lrdi setposition offset
int fieldstatus   storedfieldheader readstatus lrdi
int fielddatalength   storedfieldheader readfielddatalength lrdi  fieldstatus  slotfieldsize
storedfieldheader write out  fieldstatus  fielddatalength  slotfieldsize
if  fielddatalength    0
// and then the data
out write pagedata  lrdi getposition    fielddatalength
}
}
/*
** overidden methods of basepage
*/
/**
override insertatslot to provide long row support.
@exception standardexception standard derby error policy
*/
public recordhandle insertatslot
int                   slot
object row
formatablebitset               validcolumns
logicalundo           undo
byte                  insertflag
int                   overflowthreshold
throws standardexception
try
return super insertatslot slot  row  validcolumns  undo  insertflag  overflowthreshold
catch  nospaceonpage nsop
// super class already handle the case of insert that allows overflow.
// if we get here, we know that the insert should not allow overflow.
// possibles causes:
// 1.	insert to an empty page, row will never fit (ie long row)
// 2.	insert to original page
// we will do:
// return a null to indicate the insert cannot be accepted ..
return null
}
}
/**
update field at specified slot
@exception standardexception standard derby error policy
*/
public recordhandle updatefieldatslot
int                 slot
int                 fieldid
object newvalue
logicalundo         undo
throws standardexception
try
return super updatefieldatslot slot  fieldid  newvalue  undo
catch  nospaceonpage nsop
// empty page apart from the record
if  slotsinuse    1
throw standardexception newexception
sqlstate data_no_space_for_record
}
throw standardexception newexception
sqlstate data_no_space_for_record
/*
// djd			if (isoverflowpage()) {
}
return xxx;
*/
}
}
/**
get the number of fields on the row at slot
@exception standardexception standard derby error policy
*/
public int fetchnumfieldsatslot int slot  throws standardexception
storedrecordheader recordheader   getheaderatslot slot
if   recordheader hasoverflow
return super fetchnumfieldsatslot slot
basepage overflowpage   getoverflowpage recordheader getoverflowpage
int count   overflowpage fetchnumfieldsatslot getoverflowslot overflowpage  recordheader
overflowpage unlatch
return count
}
/**
* move record to a page toward the beginning of the file.
* <p>
* as part of compressing the table records need to be moved from the
* end of the file toward the beginning of the file.  only the
* contiguous set of free pages at the very end of the file can
* be given back to the os.  this call is used to purge the row from
* the current page, insert it into a previous page, and return the
* new row location
* mark the record identified by position as deleted. the record may be
* undeleted sometime later using undelete() by any transaction that sees
* the record.
* <p>
* the interface is optimized to work on a number of rows at a time,
* optimally processing all rows on the page at once.  the call will
* process either all rows on the page, or the number of slots in the
* input arrays - whichever is smaller.
* <b>locking policy</b>
* <p>
* must be called with table locked, not locks are requested.  because
* it is called with table locks the call will go ahead and purge any
* row which is marked deleted.  it will also use purge rather than
* delete to remove the old row after it moves it to a new page.  this
* is ok since the table lock insures that no other transaction will
* use space on the table before this transaction commits.
*
* <br>
* a page latch on the new page will be requested and released.
*
* @param slot           slot of original row to move.
* @param row            a row template to hold all columns of row.
* @param old_handle     an array to be filled in by the call with the
*                       old handles of all rows moved.
* @param new_handle     an array to be filled in by the call with the
*                       new handles of all rows moved.
*
* @return the number of rows processed.
*
* @exception standardexception	standard derby error policy
*
**/
public int moverecordforcompressatslot
int             slot
object        row
recordhandle  old_handle
recordhandle  new_handle
throws standardexception
long src_pageno   getpagenumber
try
fetchfromslot

slot
row
fetchdescriptor  null     all columns retrieved
false
int row_size   getrecordportionlength slot
// first see if row will fit on current page being used to insert
storedpage dest_page
storedpage  owner getpageforcompress 0  src_pageno
if  dest_page    null
if   dest_page getpagenumber   >  getpagenumber
dest_page spaceforcopy row_size
// page won't work
dest_page unlatch
dest_page   null
}
}
if  dest_page    null
// last page did not work, try unfilled page
dest_page    storedpage
owner getpageforcompress
containerhandle get_page_unfilled  src_pageno
if  dest_page    null
if   dest_page getpagenumber   >  getpagenumber
dest_page spaceforcopy row_size
// page won't work
dest_page unlatch
dest_page   null
}
}
}
if  dest_page    null
// last and unfilled page did not work, try getting a free page
dest_page    storedpage  owner addpage
if  dest_page getpagenumber   >  getpagenumber
owner removepage dest_page
dest_page   null
}
}
if  dest_page    null
int dest_slot   dest_page recordcount
old_handle   getrecordhandleatslot slot
copyandpurge dest_page  slot  1  dest_slot
new_handle   dest_page getrecordhandleatslot dest_slot
dest_page unlatch
return 1
}
else
return 0
}
}
catch  ioexception ioe
throw standardexception newexception
sqlstate data_unexpected_exception  ioe
}
}
/*
* methods that is called underneath a page action
*/
/*
* update page version and instance due to actions by a log record
*/
public void logaction loginstant instant  throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
}
if  rawdataout    null
createoutstreams
if   isactuallydirty
// if this is not an overflow page and the page is valid, set the
// initial row count.
if   isoverflowpage        getpagestatus     valid_page     0
initialrowcount   internalnondeletedrecordcount
else
initialrowcount   0
}
setdirty
bumppageversion
updatelastloginstant instant
}
/* clean the page for first use or reuse */
private void cleanpage
setdirty
// set pagedata to all nulls
clearsection 0  getpagesize
slotsinuse   0
deletedrowcount   0
headeroutofdate   true 	   headeroutofdate must be set after setdirty
// because isdirty maybe called unlatched
clearallspace
}
/**
initialize the page.
if reuse, then
clean up any in memory or on disk structure to ready the page for reuse.
this is not only reusing the page buffer, but reusing a free page
which may or may not be cleaned up the the client of raw store when it
was deallocated.
@exception standardexception derby standard error policy
*/
public void initpage loginstant instant  byte status  int recordid
boolean overflow  boolean reuse
throws standardexception
// log action at the end after the page is updated with all the
// pertinent information
logaction instant
if  reuse
cleanpage
super cleanpageforreuse
}
// if not reuse, createpage already called cleanpage
headeroutofdate   true 	   headeroutofdate must be set after setdirty
// because isdirty maybe called unlatched
setpagestatus status
isoverflowpage   overflow
nextid   recordid
}
/**
set page status
@exception standardexception derby standard error policy
*/
public void setpagestatus loginstant instant  byte status
throws standardexception
logaction instant
headeroutofdate   true 	   headeroutofdate must be set after setdirty
// because isdirty maybe called unlatched
setpagestatus status
}
/**
set the row reserved space.
@exception standardexception derby standard error policy
*/
public void setreservedspace loginstant instant  int slot  int value
throws standardexception  ioexception
logaction instant
headeroutofdate   true 	   headeroutofdate must be set after setdirty
// because isdirty maybe called unlatched
int delta   value   getreservedcount slot
if  sanitymanager debug
sanitymanager assert delta <  freespace
sanitymanager assert delta    0
if  value < 0
sanitymanager throwassert
value
}
// find the end of the record that we are about to add or subtract from
// the reserved space.
int nextrecordoffset   getrecordoffset slot    gettotalspace slot
if  delta > 0
// growing - hopefully during a rrr restore
expandpage nextrecordoffset  delta
else
// shrinking, delta is < 0
shrinkpage nextrecordoffset   delta
}
// lastly, update the reserved space count in the slot.
rawdataout setposition getslotoffset slot     2 slotfieldsize
if  slotfieldsize    small_slot_size
logicaldataout writeshort value
else
logicaldataout writeint value
}
/**
store a record at the given slot.
@exception standardexception	standard derby error policy
@exception ioexception			resolve
*/
public void storerecord loginstant instant  int slot  boolean insert  objectinput in
throws standardexception  ioexception
logaction instant
if  insert
storerecordforinsert slot  in
else
storerecordforupdate slot  in
}
private void storerecordforinsert int slot  objectinput in
throws standardexception  ioexception
storedrecordheader recordheader   shiftup slot
if  recordheader    null
recordheader   new storedrecordheader
setheaderatslot slot  recordheader
}
bumprecordcount 1
// recordheader represents the new version of the record header.
recordheader read in
// the record is already marked delete, we need to bump the deletedrowcount
if  recordheader isdeleted
deletedrowcount
headeroutofdate   true
}
// during a rollforward insert, recordid == nextid
// during a rollback of purge, recordid < nextid
if  nextid <  recordheader getid
nextid   recordheader getid   1
int recordoffset   firstfreebyte
int offset   recordoffset
// write each field out to the page
int numberfields   recordheader getnumberfields
rawdataout setposition offset
offset    recordheader write rawdataout
int userdata   0
for  int i   0  i < numberfields  i
// get the field header information, the input stream came from the log
int newfieldstatus   storedfieldheader readstatus in
int newfielddatalength   storedfieldheader readfielddatalength in  newfieldstatus  slotfieldsize
newfieldstatus   storedfieldheader setfixed newfieldstatus  false
rawdataout setposition offset
offset    storedfieldheader write rawdataout  newfieldstatus  newfielddatalength  slotfieldsize
if  newfielddatalength    0
in readfully pagedata  offset  newfielddatalength
offset    newfielddatalength
userdata    newfielddatalength
}
}
int datawritten   offset   firstfreebyte
freespace    datawritten
firstfreebyte    datawritten
int reservedspace   0
if  minimumrecordsize > 0
// make sure we reserve the minimumrecordsize for the user data
// portion of the record excluding the space we took on recordheader
// and fieldheaders.
if  userdata < minimumrecordsize
reservedspace   minimumrecordsize   userdata
freespace    reservedspace
firstfreebyte    reservedspace
}
}
// update the slot table
addslotentry slot  recordoffset  datawritten  reservedspace
if  sanitymanager debug
if   firstfreebyte > getslotoffset slot
freespace < 0
sanitymanager throwassert
firstfreebyte
datawritten
getslotoffset slot
slot
firstfreebyte
freespace
this
}
}
if   firstfreebyte > getslotoffset slot       freespace < 0
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  getpageid
}
}
private void storerecordforupdate int slot  objectinput in
throws standardexception  ioexception
// set up to read the in-memory record header back from the record
storedrecordheader recordheader   getheaderatslot slot
storedrecordheader newrecorderheader   new storedrecordheader
// recordheader represents the new version of the record header.
newrecorderheader read in
int oldfieldcount   recordheader getnumberfields
int newfieldcount   newrecorderheader getnumberfields
int startfield   recordheader getfirstfield
if  sanitymanager debug
if  startfield    newrecorderheader getfirstfield
sanitymanager throwassert     startfield       newrecorderheader getfirstfield
}
// see if the number of fields shrunk, if so clear out the old data
// we do this first to stop shuffling about the fields that are going to
// be deleted during the update of the earlier fields. this case occurs
// on an update that changes the row to be overflowed.
if  newfieldcount < oldfieldcount
int olddatastartingoffset   getfieldoffset slot  startfield   newfieldcount
// calculate the length of the to be deleted fields
int deletelength   getrecordoffset slot    getrecordportionlength slot    olddatastartingoffset
// we are updateing to zero bytes!
updaterecordportionlength slot    deletelength   deletelength
}
// write each field out to the page
int startingoffset   getrecordoffset slot
int newoffset   startingoffset
int oldoffset   startingoffset
// see which field we get to use the reserve space
int reservedspacefieldid   newfieldcount < oldfieldcount ?
newfieldcount   1   oldfieldcount   1
reservedspacefieldid    startfield
// the new data the needs to be written at newoffset but can't until
// unsedspace >= newdatatowrite.length (allowing for the header)
dynamicbytearrayoutputstream newdatatowrite   null
rawdataout setposition newoffset
// write the record header, which may change in size
int oldlength   recordheader size
int newlength   newrecorderheader size
int unusedspace   oldlength     the unused space at newoffset
// no fields, so we can eat into the reserve space
if  reservedspacefieldid < startfield     no fields
unusedspace    getreservedcount slot
if  unusedspace >  newlength
newrecorderheader write rawdataout
newoffset    newlength
unusedspace    newlength
else
newdatatowrite   new dynamicbytearrayoutputstream getpagesize
newrecorderheader write newdatatowrite
}
oldoffset    oldlength
int recorddelta    newlength   oldlength
int oldfieldstatus   0
int oldfielddatalength   0
int newfieldstatus   0
int newfielddatalength   0
int oldendfieldexclusive   startfield   oldfieldcount
int newendfieldexclusive   startfield   newfieldcount
for  int fieldid   startfield  fieldid < newendfieldexclusive  fieldid
int oldfieldlength   0
if  fieldid < oldendfieldexclusive
rawdatain setposition oldoffset
oldfieldstatus   storedfieldheader readstatus rawdatain
oldfielddatalength   storedfieldheader readfielddatalength rawdatain  oldfieldstatus  slotfieldsize
oldfieldlength   storedfieldheader size oldfieldstatus  oldfielddatalength  slotfieldsize
oldfielddatalength
}
newfieldstatus   storedfieldheader readstatus in
newfielddatalength   storedfieldheader readfielddatalength in  newfieldstatus  slotfieldsize
// if no value was provided on an update of a field then use the old value,
// unless the old field didn't exist.
if  storedfieldheader isnonexistent newfieldstatus      fieldid < oldendfieldexclusive
// may need to move this old field ...
if   newdatatowrite    null      newdatatowrite getused      0
// the is no old data to catch up on, is the data at
// the correct position already?
if  newoffset    oldoffset
// yes, nothing to do!!
if  sanitymanager debug
if  unusedspace    0
sanitymanager throwassert     unusedspace
}
else
// need to shift the field left
if  sanitymanager debug
if  unusedspace     oldoffset   newoffset
sanitymanager throwassert
oldoffset   newoffset        unusedspace
}
system arraycopy pagedata  oldoffset  pagedata  newoffset  oldfieldlength
}
newoffset    oldfieldlength
// last field to be updated can eat into the reserve space
if  fieldid    reservedspacefieldid
unusedspace    getreservedcount slot
else
// there is data still to be written, just append this field to the
// saved data
int position   newdatatowrite getposition
newdatatowrite setposition position   oldfieldlength
system arraycopy pagedata  oldoffset
newdatatowrite getbytearray    position  oldfieldlength
unusedspace    oldfieldlength
// last field to be updated can eat into the reserve space
if  fieldid    reservedspacefieldid
unusedspace    getreservedcount slot
// attempt to write out some of what we have in the side buffer now.
int copylength   movesaveddatatopage newdatatowrite  unusedspace  newoffset
newoffset    copylength
unusedspace    copylength
}
oldoffset    oldfieldlength
continue
}
newfieldstatus   storedfieldheader setfixed newfieldstatus  false
int newfieldheaderlength   storedfieldheader size newfieldstatus  newfielddatalength  slotfieldsize
int newfieldlength   newfieldheaderlength   newfielddatalength
recorddelta     newfieldlength   oldfieldlength
// see if we can write this field now
// space available increases by the amount of the old field
unusedspace    oldfieldlength
oldoffset    oldfieldlength
// last field to be updated can eat into the reserve space
if  fieldid    reservedspacefieldid
unusedspace    getreservedcount slot
if   newdatatowrite    null      newdatatowrite getused      0
// catch up on the old data if possible
int copylength   movesaveddatatopage newdatatowrite  unusedspace  newoffset
newoffset    copylength
unusedspace    copylength
}
if    newdatatowrite    null      newdatatowrite getused      0
unusedspace >  newfieldheaderlength
// can fit the header in
rawdataout setposition newoffset
newoffset    storedfieldheader write rawdataout  newfieldstatus  newfielddatalength  slotfieldsize
unusedspace    newfieldheaderlength
if  newfielddatalength    0
// read as much as the field as possible
int fieldcopy   unusedspace >  newfielddatalength ?
newfielddatalength   unusedspace
if  fieldcopy    0
in readfully pagedata  newoffset  fieldcopy
newoffset    fieldcopy
unusedspace    fieldcopy
}
fieldcopy   newfielddatalength   fieldcopy
if  fieldcopy    0
if  newdatatowrite    null
newdatatowrite   new dynamicbytearrayoutputstream newfieldlength   2
// append the remaining portion of the field to the saved data
int position   newdatatowrite getposition
newdatatowrite setposition position   fieldcopy
in readfully newdatatowrite getbytearray
position  fieldcopy
}
}
else
// can't fit these header, or therefore the field, append it
// to the buffer.
if  newdatatowrite    null
newdatatowrite   new dynamicbytearrayoutputstream newfieldlength   2
storedfieldheader write newdatatowrite  newfieldstatus  newfielddatalength  slotfieldsize
// save the new field data
if  newfielddatalength    0
int position   newdatatowrite getposition
newdatatowrite setposition position   newfielddatalength
in readfully newdatatowrite getbytearray
position  newfielddatalength
}
}
}
// at this point there may still be data left in the saved buffer
// but presumably we can't fit it in
int reserveddelta
if   newdatatowrite    null      newdatatowrite getused      0
// need to shift the later records down ...
int nextrecordoffset   startingoffset   gettotalspace slot
int spacerequiredfromfreespace   newdatatowrite getused      nextrecordoffset   newoffset
if  sanitymanager debug
if  newoffset > nextrecordoffset
sanitymanager throwassert     newoffset
nextrecordoffset
if   spacerequiredfromfreespace <  0      spacerequiredfromfreespace > freespace
sanitymanager throwassert     spacerequiredfromfreespace
newdatatowrite getused
nextrecordoffset
newoffset
reservedspacefieldid
startfield
newendfieldexclusive
newfieldcount
oldfieldcount
slot
freespace
unusedspace
getpageid
if   getreservedcount slot    spacerequiredfromfreespace     recorddelta
sanitymanager throwassert     getreservedcount slot
spacerequiredfromfreespace
recorddelta
}
if  spacerequiredfromfreespace > freespace
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  getpageid
}
// see if this is the last record on the page, if so a simple
// shift of the remaining fields will sufice...
expandpage nextrecordoffset  spacerequiredfromfreespace
unusedspace    spacerequiredfromfreespace
movesaveddatatopage newdatatowrite  unusedspace  newoffset
reserveddelta    1   getreservedcount slot
if  sanitymanager debug
if  newdatatowrite getused      0
sanitymanager throwassert     newdatatowrite getused
}
else
reserveddelta    1   recorddelta
}
// now reset the length in the slot entry
updaterecordportionlength slot  recorddelta  reserveddelta
setheaderatslot slot  newrecorderheader
}
private int movesaveddatatopage dynamicbytearrayoutputstream saveddata  int unusedspace  int pageoffset
// catch up on the old data if possible
if  unusedspace >  saveddata getused     2
// copy onto the page
int copylength   unusedspace <  saveddata getused   ?
unusedspace   saveddata getused
system arraycopy saveddata getbytearray    0
pagedata  pageoffset  copylength
// fix up the saved buffer
saveddata discardleft copylength
return copylength
}
return 0
}
/**
create the space to update a portion of a record.
this method ensures there is enough room to replace the
old data of length oldlength at the given offset, with the new data of length
newlength. this method does put any new data on the page, it moves old data around
and zeros out any old data when newlength < oldlength. this method does
update the information in the slot table.
the passed in offset is the correct place to put the data
when this method returns, ie. it only moves data that
has an offset greater then this.
@exception standardexception	standard derby error policy
@exception ioexception			resolve
*/
private void createspaceforupdate int slot  int offset  int oldlength  int newlength
throws standardexception  ioexception
// now replace the old data with the new data
if  newlength <  oldlength
// now shift the remaining data down ...
int difflength   oldlength   newlength
// real easy
if  difflength    0
return
// shift the remaing fields down
int remaininglength
shiftremainingdata slot  offset  oldlength  newlength
// clear the now unused data on the page
clearsection offset   newlength   remaininglength  difflength
if  sanitymanager debug
if   getrecordportionlength slot    difflength
offset   getrecordoffset slot     newlength
remaininglength
sanitymanager throwassert
getrecordportionlength slot    difflength
}
}
// now reset the length in the slot entry, increase the reserved space
updaterecordportionlength slot    difflength   difflength
return
}
// tough case, the new field is bigger than the old field ...
// first attempt, see how much space is in row private reserved space
int extralength   newlength   oldlength
// extralength is always greater than 0.
if  sanitymanager debug
sanitymanager assert extralength > 0
int recordreservedspace   getreservedcount slot
int reserveddelta   0
int spacerequiredfromfreespace   extralength   recordreservedspace
if  sanitymanager debug
if  spacerequiredfromfreespace > freespace
sanitymanager throwassert
spacerequiredfromfreespace
freespace
newlength
oldlength
this
}
if  spacerequiredfromfreespace > 0
// the update requires all the reserved space + some from free space
int nextrecordoffset   getrecordoffset slot    gettotalspace slot
// see if this is the last record on the page, if so a simple
// shift of the remaining fields will sufice...
expandpage nextrecordoffset  spacerequiredfromfreespace
// we used all the reserved space we have, set it to 0
reserveddelta     recordreservedspace
else
// the update uses some amount of space from the rows reserved space
// set reserved delta to account for amount of reserved space used.
reserveddelta     extralength
}
// just shift all remaining fields up
int remaininglength   shiftremainingdata slot  offset  oldlength  newlength
if  sanitymanager debug
if   extralength   reserveddelta  < 0
sanitymanager throwassert
extralength       reserveddelta
spacerequiredfromfreespace
recordreservedspace
}
// now reset the length in the slot entry
updaterecordportionlength slot  extralength  reserveddelta
}
/**
storefield
@exception standardexception	standard derby error policy
@exception ioexception			resolve
*/
public void storefield loginstant instant  int slot  int fieldnumber  objectinput in
throws standardexception  ioexception
logaction instant
int offset   getfieldoffset slot  fieldnumber
// get the field header information, the input stream came from the log
arrayinputstream lrdi   rawdatain
lrdi setposition offset
int oldfieldstatus   storedfieldheader readstatus lrdi
int oldfielddatalength   storedfieldheader readfielddatalength lrdi  oldfieldstatus  slotfieldsize
int newfieldstatus   storedfieldheader readstatus in
int newfielddatalength   storedfieldheader readfielddatalength in  newfieldstatus  slotfieldsize
newfieldstatus   storedfieldheader setfixed newfieldstatus  false
int oldfieldlength   storedfieldheader size oldfieldstatus  oldfielddatalength  slotfieldsize    oldfielddatalength
int newfieldlength   storedfieldheader size newfieldstatus  newfielddatalength  slotfieldsize    newfielddatalength
createspaceforupdate slot  offset  oldfieldlength  newfieldlength
rawdataout setposition offset
offset    storedfieldheader write rawdataout  newfieldstatus  newfielddatalength  slotfieldsize
if  newfielddatalength    0
in readfully pagedata  offset  newfielddatalength
}
/**
reservespaceforslot
this method will reserve at least specified "spacetoreserve" bytes for the record
in the slot.
@exception standardexception	standard derby error policy
@exception ioexception			resolve
*/
public void reservespaceforslot loginstant instant  int slot  int spacetoreserve
throws standardexception  ioexception
logaction instant
int extraspace   spacetoreserve   getreservedcount slot
if  extraspace <  0
return
if  freespace < extraspace
throw new nospaceonpage(isoverflowpage());
// need to shift the later records down ...
int startingoffset   getrecordoffset slot
int nextrecordoffset   startingoffset   gettotalspace slot
// see if this is the last record on the page, if so a simple
// shift of the remaining fields will sufice...
expandpage nextrecordoffset  extraspace
setslotentry slot  startingoffset  getrecordportionlength slot   spacetoreserve
}
/**
skip a field header and its data on the given stream.
@exception ioexception corrupt stream
*/
public void skipfield objectinput in  throws ioexception
int fieldstatus   storedfieldheader readstatus in
int fielddatalength   storedfieldheader readfielddatalength in  fieldstatus  slotfieldsize
if  fielddatalength    0
in skipbytes fielddatalength
}
}
public void skiprecord objectinput in  throws ioexception
storedrecordheader recordheader   new storedrecordheader
recordheader read in
for  int i   recordheader getnumberfields    i > 0  i
skipfield in
}
}
/**
shift data within a record to account for an update.
@param offset  offset where the update starts, need not be on a field boundry.
@param oldlength length of the data being replaced
@param newlength length of the data replacing the old data
@return the length of the data in the record after the replaced data.
*/
private int shiftremainingdata int slot  int offset  int oldlength  int newlength
throws ioexception
// length of valid data remaining in the record after the portion that
// is being replaced.
int remaininglength    getrecordoffset slot    getrecordportionlength slot
offset   oldlength
if  sanitymanager debug
if      remaininglength >  0
getrecordportionlength slot  >  oldlength
sanitymanager throwassert
oldlength       newlength
remaininglength
offset
slot       getrecordoffset slot
slot
getrecordportionlength slot
}
}
if  remaininglength    0
system arraycopy pagedata  offset   oldlength
pagedata  offset   newlength  remaininglength
}
return remaininglength
}
/**
set the deleted status
@exception standardexception	standard derby error policy
@exception ioexception			resolve
@see basepage#setdeletestatus
*/
public void setdeletestatus loginstant instant  int slot  boolean delete
throws standardexception  ioexception
logaction instant
deletedrowcount    super setdeletestatus slot  delete
headeroutofdate   true
int offset   getrecordoffset slot
storedrecordheader recordheader   getheaderatslot slot
rawdataout setposition offset
recordheader write logicaldataout
}
/**
get record count without checking for latch
*/
protected int internaldeletedrecordcount
return deletedrowcount
}
/**
purgerecord from page.  move following slots up by one.
@exception standardexception	standard derby error policy
@exception ioexception			resolve
*/
public void purgerecord loginstant instant  int slot  int recordid
throws standardexception  ioexception
logaction instant
// if record is marked deleted, reduce deletedrowcount
if  getheaderatslot slot  isdeleted
deletedrowcount
int startbyte   getrecordoffset slot
int endbyte   startbyte   gettotalspace slot    1
compresspage startbyte  endbyte
// fix up the on-page slot table
removeslotentry slot
// fix up the in-memory version
removeandshiftdown slot
}
/*
**
*/
/**
get the offset of the field header of the given field for
the record in the given slot.
field number is the absolute number for the complete record, not just this portion.
e.g. if this is a record portion that starts at field 3 and has 6 fields
then the second field on this *page* has field number 4.
*/
private int getfieldoffset int slot  int fieldnumber  throws ioexception
// resolve - overflow, needs to be changed
int offset   getrecordoffset slot
storedrecordheader recordheader   getheaderatslot slot
// get the number of fields
int startfield   recordheader getfirstfield
if  sanitymanager debug
int numberfields   recordheader getnumberfields
if   fieldnumber < startfield      fieldnumber >   startfield   numberfields
sanitymanager throwassert
fieldnumber
startfield
numberfields
}
arrayinputstream lrdi   rawdatain
// skip the record header
lrdi setposition offset   recordheader size
// skip any earlier fields ...
for  int i   startfield  i < fieldnumber  i
skipfield lrdi
}
return rawdatain getposition
}
/*
* time stamp support - this page supports time stamp
*/
/**
get a time stamp for this page
@return page time stamp
*/
public pagetimestamp currenttimestamp
// saving the whole key would be an overkill
return new pageversion getpagenumber    getpageversion
}
/**
set given pageversion to be the as what is on this page
@exception standardexception given time stamp is null or is not a time
stamp implementation this page knows how to deal with
*/
public void settimestamp pagetimestamp ts  throws standardexception
if  ts    null
throw standardexception newexception sqlstate data_time_stamp_null
}
if    ts instanceof pageversion
throw standardexception newexception
sqlstate data_time_stamp_illegal  ts
}
pageversion pv    pageversion ts
pv setpagenumber getpagenumber
pv setpageversion getpageversion
}
/**
compare given pageversion with pageversion on page
@param ts the page version gotton from this page via a currenttimestamp
or settimestamp call earlier
@return true if the same
@exception standardexception given time stamp not gotton from this page
*/
public boolean equaltimestamp pagetimestamp ts  throws standardexception
if  ts    null
return false
if    ts instanceof pageversion
throw standardexception newexception
sqlstate data_time_stamp_illegal  ts
}
pageversion pv    pageversion ts
if  pv getpagenumber      getpagenumber
throw standardexception newexception
sqlstate data_time_stamp_illegal  ts
}
return  pv getpageversion      getpageversion
}
/** debugging, print this page */
public string tostring
if  sanitymanager debug
if  sanitymanager debug_on       sanitymanager debug_on
return     getidentity
string str
str    pageheadertostring
// str += slottabletostring();	// print in memory slot table
// now print each row
for  int s   0  s < slotsinuse  s
str    recordtostring s
//if (sanitymanager.debug_on("dumppageimage"))
str
str    pagedatatohexdump pagedata
str
}
return str
}
else
return null
}
/**
* provide a hex dump of the data in the in memory version of the page.
* <p>
* the output looks like:
*
* 00000000: 4d5a 9000 0300 0000 0400 0000 ffff 0000  mz..............
* 00000010: b800 0000 0000 0000 4000 0000 0000 0000  ........@.......
* 00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
* 00000030: 0000 0000 0000 0000 0000 0000 8000 0000  ................
* 00000040: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468  ........!..l.!th
* 00000050: 6973 2070 726f 6772 616d 2063 616e 6e6f  is program canno
* 00000060: 7420 6265 2072 756e 2069 6e20 444f 5320  t be run in dos
* 00000070: 6d6f 6465 2e0d 0a24 0000 0000 0000 0050  mode...$.......p
* 00000080: 4500 004c 0109 008b abfd 3000 0000 0000  e..l......0.....
* 00000090: 0000 00e0 000e 210b 0102 3700 3405 0000  ......!...7.4...
* 000000a0: 8401 0000 6400 0000 6004 0000 1000 0000  ....d...`.......
* 000000b0: 5005 0000 0008 6000 1000 0000 0200 0001  p.....`.........
* 000000c0: 0000 0000 0000 0004 0000 0000 0000 0000  ................
* 000000d0: 9007 0000 0400 0009 a207 0002 0000 0000  ................
* 000000e0: 0010 0000 1000 0000 0010 0000 1000 0000  ................
* 000000f0: 0000 0010 0000 0000 6006 00ef 8100 0000  ........`.......
* 00000100: 5006 00e6 0c00 0000 0007 00d0 0400 0000  p...............
* 00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
* 00000120: 1007 00c8 7100 0000 0000 0000 0000 0000  ....q...........
* 00000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................
*
* <p>
* resolve - this has been hacked together and is not efficient.  there
* are probably some java utilities to use.
*
* @return the string with the hex dump in it.
*
* @param data   array of bytes to dump.
**/
private static string pagedatatohexdump byte data
return org apache derby iapi util stringutil hexdump data
}
private string pageheadertostring
if  sanitymanager debug
return     getidentity
isoverflowpage
getpageversion
slotsinuse
deletedrowcount
getpagestatus
nextid
firstfreebyte
freespace
totalspace
sparespace
getpagesize
}
else
return null
}
private string recordtostring int slot
if  sanitymanager debug
string str   new string
try
storedrecordheader recordheader   getheaderatslot slot
int offset   getrecordoffset slot
int numberfields   recordheader getnumberfields
str       slot       offset
gettotalspace slot
getrecordportionlength slot
getreservedcount slot
recordheader tostring
rawdatain setposition offset   recordheader size
for  int i   0  i < numberfields  i
int fieldstatus   storedfieldheader readstatus rawdatain
int fielddatalength   storedfieldheader readfielddatalength rawdatain  fieldstatus  slotfieldsize
if  fielddatalength < 0
str        i       offset
storedfieldheader todebugstring fieldstatus
}
else
str        i       offset
fielddatalength
storedfieldheader todebugstring fieldstatus
if  storedfieldheader isoverflow fieldstatus
// not likely to be a real pointer, this is most
// likely an old column chain where the first field
// is set to overflow even though the second field
// is the overflow pointer
if  i    0    fielddatalength    3
// figure out where we should go next
offset   rawdatain getposition     fielddatalength
long overflowpage   compressednumber readlong  inputstream  rawdatain
int overflowid   compressednumber readint  inputstream  rawdatain
str
overflowpage       overflowid
rawdatain setposition offset
}
else
// print the overflow pointer
long overflowpage   compressednumber readlong  inputstream  rawdatain
int overflowid   compressednumber readint  inputstream  rawdatain
str        overflowpage       overflowid
}
}
else
// go to next field
offset   rawdatain getposition     fielddatalength
rawdatain setposition offset
}
}
}
str
}
catch  ioexception ioe
str
str    ioe tostring
}
catch  standardexception se
str
str    se tostring
}
return str
}
else
return null
}
/*
**	overflow related methods
*/
/**
get the overflow page for a record that has already overflowed.
@exception standardexception standard derby error policy
*/
protected storedpage getoverflowpage long pagenumber  throws standardexception
storedpage overflowpage    storedpage  owner getpage pagenumber
if  overflowpage    null
}
// resolve-lr
//if (!overflowpage.isoverflow()) {
//	overflowpage.unlatch();
//}
return overflowpage
}
/**
get an empty overflow page.
@exception standardexception standard derby error policy
*/
protected basepage getnewoverflowpage   throws standardexception
filecontainer mycontainer    filecontainer  containercache find identity getcontainerid
try
// add an overflow page
return  basepage  mycontainer addpage owner  true
finally
containercache release mycontainer
}
}
/**
get the overflow slot for a record that has already overflowed.
@exception standardexception standard derby error policy
*/
protected static int getoverflowslot basepage overflowpage  storedrecordheader recordheader
throws standardexception
int slot   overflowpage findrecordbyid
recordheader getoverflowid    page first_slot_number
if  slot < 0
throw standardexception newexception
sqlstate data_slot_not_on_page
}
return slot
}
/**
get a overflow page that potentially can handle a new overflowed record.
@exception standardexception standard derby error policy
*/
public basepage getoverflowpageforinsert
int                     currentslot
object   row
formatablebitset                 validcolumns
throws standardexception
return getoverflowpageforinsert currentslot  row  validcolumns  0
}
/**
@exception standardexception standard derby error policy
*/
public basepage getoverflowpageforinsert
int                     currentslot
object   row
formatablebitset                 validcolumns
int                     startcolumn
throws standardexception
// system.out.println("top of getoverflowpageforinsert");
// look at all the overflow pages that are in use on this page, up
// to a maximum of 5.
long pagelist   new long
int    pagecount   0
long   currentoverflowpagenumber   0
slotscan
for  int slot   0   slot < slotsinuse      pagecount < pagelist length   slot
storedrecordheader recordheader   getheaderatslot slot
if   recordheader hasoverflow
continue
long overflowpagenumber   recordheader getoverflowpage
if  slot    currentslot
currentoverflowpagenumber   overflowpagenumber
continue
}
for  int i   0  i < pagecount  i
if  pagelist    overflowpagenumber
continue slotscan
}
pagelist   overflowpagenumber
}
for  int i   0  i < pagecount  i
long pagenumber   pagelist
// don't look at the current overflow page
// used by this slot, because it the record is already
// overflowed then we reached here because the overflow
// page is full.
if  pagenumber    currentoverflowpagenumber
continue
storedpage overflowpage   null
int spaceneeded   0
try
overflowpage   getoverflowpage pagenumber
if   overflowpage spaceforinsert row  validcolumns
spaceneeded  startcolumn  100
// system.out.println("returning used page: " + pagenumber);
return overflowpage
}
spaceneeded     storedpage  overflowpage  getcurrentfreespace
overflowpage unlatch
overflowpage   null
catch  standardexception se
if  overflowpage    null
overflowpage unlatch
overflowpage   null
}
}
}
// if we get here then we have to allocate a new overflow page
// system.out.println("returning new page: ");
return getnewoverflowpage
}
/**
update an already overflowed record.
@param slot slot of the original record on its original page
@param row new version of the data
@exception standardexception standard derby error policy
*/
protected void updateoverflowed
rawtransaction          t
int                     slot
object   row
formatablebitset                 validcolumns
storedrecordheader      recordheader
throws standardexception
basepage overflowpage   getoverflowpage recordheader getoverflowpage
try
int overflowslot   getoverflowslot overflowpage  recordheader
overflowpage doupdateatslot t  overflowslot  recordheader getoverflowid    row  validcolumns
overflowpage unlatch
overflowpage   null
return
finally
if  overflowpage    null
overflowpage unlatch
overflowpage   null
}
}
}
/**
update a record handle to point to an overflowed record portion.
note that the record handle need not be the current page.
@exception standardexception standard derby error policy
*/
public void updateoverflowdetails recordhandle handle  recordhandle overflowhandle
throws standardexception
long handlepagenumber   handle getpagenumber
if  handlepagenumber    getpagenumber
updateoverflowdetails this  handle  overflowhandle
return
}
storedpage handlepage    storedpage  owner getpage handlepagenumber
updateoverflowdetails handlepage  handle  overflowhandle
handlepage unlatch
}
private void updateoverflowdetails storedpage handlepage  recordhandle handle  recordhandle overflowhandle
throws standardexception
// update the temp record header, this will be used in the log row ..
handlepage getoverflowrecordheader   setoverflowdetails overflowhandle
// use the slot interface as we don't need a lock since
// the initial insert/update holds the lock on the first
// portion of the record.
int slot   handlepage getslotnumber handle
// use doupdateatslot as it avoids unnecessary work in updateatslot the
// null indicates to this page that the record should become an
// overflow record
handlepage doupdateatslot
owner gettransaction    slot  handle getid
object  null   formatablebitset  null
}
/**
@exception standardexception standard derby error policy
*/
public void updatefieldoverflowdetails recordhandle handle  recordhandle overflowhandle
throws standardexception
// add an overflow field at the end of the previous record
// uses sparse rows
object row   new object
row   overflowhandle
// we are expanding the record to have 2 fields, the second field is the overflow pointer.
formatablebitset validcolumns   new formatablebitset 2
validcolumns set 1
// use the slot interface as we don't need a lock since
// the initial insert/update holds the lock on the first
// portion of the record.
int slot   getslotnumber handle
// use doupdateatslot as it avoids unnecessary work in updateatslot
doupdateatslot owner gettransaction    slot  handle getid    row  validcolumns
}
/**
@exception standardexception standard derby error policy
*/
public int appendoverflowfieldheader dynamicbytearrayoutputstream logbuffer  recordhandle overflowhandle
throws standardexception  ioexception
int fieldstatus   storedfieldheader setinitial
fieldstatus   storedfieldheader setoverflow fieldstatus  true
long overflowpage   overflowhandle getpagenumber
int overflowid   overflowhandle getid
int fielddatalength   compressednumber sizelong overflowpage
compressednumber sizeint overflowid
// write the field header to the log buffer
int lenwritten   storedfieldheader write logbuffer  fieldstatus  fielddatalength  slotfieldsize
// write the overflow details to the log buffer
lenwritten    compressednumber writelong logbuffer  overflowpage
lenwritten    compressednumber writeint logbuffer  overflowid
// this length is the same on page as in the log
return  lenwritten
}
protected int getslotsinuse
return slotsinuse
}
/**
return the max datalength allowed with the space available
*/
private int getmaxdatalength int spaceavailable  int overflowthreshold
if  sanitymanager debug
if  overflowthreshold    0
sanitymanager throwassert
}
// we need to take into considering of the overflowthreshold
// the overflowthreshold limits the max data length,
// whatever space we have left, we will not allow max data length
// to exceed the overflow threshold.
int maxthresholdspace   totalspace   overflowthreshold   100
int maxavailable   0
if  spaceavailable <  64   2
maxavailable   spaceavailable   2
else if  spaceavailable <  16383   3
maxavailable   spaceavailable   3
else
maxavailable   spaceavailable   5
return  maxavailable > maxthresholdspace ? maxthresholdspace   maxavailable
}
/**
return whether the field has exceeded the max threshold for this page
it compares the fieldsize with the largest possible field for this page
*/
private boolean islong int fieldsize  int overflowthreshold
if  sanitymanager debug
if  overflowthreshold    0
sanitymanager throwassert
}
// if a field size is over the threshold, then it becomes a long column
int maxthresholdsize   maxfieldsize   overflowthreshold   100
return  fieldsize > maxthresholdsize
}
/**
perform an update.
@exception standardexception standard derby policy
*/
public void doupdateatslot
rawtransaction          t
int                     slot
int                     id
object                row
formatablebitset                 validcolumns
throws standardexception
// if this is a head page, the recordhandle is the head row handle.
// if this is not a head page, we are calling updateatslot inside some
// convoluted loop that updates an overflow chain.  there is nothing we
// can doing about it anyway.
recordhandle headrowhandle
isoverflowpage   ? null   getrecordhandleatslot slot
// resolve: djd/yyz what does a null row means? (sku)
if  row    null
owner getactionset   actionupdate
t  this  slot  id  row  validcolumns   1
dynamicbytearrayoutputstream  null   1  headrowhandle
return
}
// startcolumn is the first column to be updated.
int startcolumn   rowutil nextcolumn row  validcolumns  0
if  startcolumn     1
return
if  sanitymanager debug
// make sure that if n bits are set in the validcolumns that
// exactly n columns are passed in via the row array.
if   isoverflowpage      validcolumns    null
if  rowutil getnumberofcolumns  1  validcolumns  > row length
sanitymanager throwassert     slot
getidentity
rowutil getnumberofcolumns  1  validcolumns
row length
}
}
// keep track of row shrinkage in the head row piece.  if any row piece
// shrinks, file a post commit work to clear all reserved space for the
// entire row chain.
boolean rowhasreservedspace   false
storedpage curpage   this
for
storedrecordheader rh   curpage getheaderatslot slot
int startfield            rh getfirstfield
int endfieldexclusive     startfield   rh getnumberfields
// curpage contains column[startfield] to column[endfieldexclusive-1]
// need to cope with an update that is increasing the number of
// columns.  if this occurs we want to make sure that we perform a
// single update to the last portion of a record, and not an update
// of the current columns and then an update to append a column.
long nextpage           1
int  realstartcolumn    1
int  realspaceonpage    1
if   rh hasoverflow
startcolumn >  startfield
startcolumn <  endfieldexclusive
boolean                 hitlongcolumn
int                     nextcolumn         1
object   savedfields       null
dynamicbytearrayoutputstream  logbuffer         null
do
try
// update this portion of the record.
// pass in headrowhandle in case we are to update any
// long column and they need to be cleaned up by post
// commit processing.  we don't want to purge the
// columns right now because in order to reclaim the
// page, we need to remove them.  but it would be bad
// to remove them now because the transaction may not
// commit for a long time.  we can do both purging of
// the long column and page removal together in the
// post commit.
nextcolumn
owner getactionset   actionupdate
t  curpage  slot  id  row  validcolumns
realstartcolumn  logbuffer
realspaceonpage  headrowhandle
hitlongcolumn   false
}
catch  longcolumnexception lce
if  lce getrealspaceonpage       1
// an update that has caused the row to increase
// in size *and* push some fields off the page
// that need to be inserted in an overflow page
// no need to make a copy as we are going to use
// this buffer right away
logbuffer   lce getlogbuffer
savedfields
object  lce getcolumn
realstartcolumn   lce getnextcolumn
realspaceonpage    1
hitlongcolumn     true
continue
}
// we caught a real long column exception
// three things should happen here:
// 1. insert the long column into overflow pages.
// 2. append the overflow field header in the main chain.
// 3. continue the update in the main data chain.
logbuffer
new dynamicbytearrayoutputstream lce getlogbuffer
// step 1: insert the long column ... if this update
// operation rolls back, purge the after image column
// chain and reclaim the overflow page because the
// whole chain will be orphaned anyway.
recordhandle longcolumnhandle
insertlongcolumn
curpage  lce  page insert_undo_with_purge
// step 2: append overflow field header to log buffer
int overflowfieldlen   0
try
overflowfieldlen
appendoverflowfieldheader
logbuffer  longcolumnhandle
}
catch  ioexception ioe
throw standardexception newexception
sqlstate data_unexpected_exception  ioe
}
// step 3: continue the insert in the main data chain
// need to pass the log buffer, and start column to the
// next insert.
realstartcolumn   lce getnextcolumn     1
realspaceonpage   lce getrealspaceonpage     overflowfieldlen
hitlongcolumn   true
}
while  hitlongcolumn
// see if we completed all the columns that are on this page.
int validcolumnssize
validcolumns    null  ? 0   validcolumns getlength
if  nextcolumn     1
if  sanitymanager debug
// note nextcolumn might be less than the the first
// column we started updating. this is because the
// update might force the record header to grow and
// push fields before the one we are updating off the
// page and into this insert.
if   nextcolumn < startfield
rh hasoverflow       nextcolumn >  endfieldexclusive
sanitymanager throwassert
nextcolumn
startfield       endfieldexclusive
}
}
// need to insert rows from nextcolumn to endfieldexclusive
// onto a new overflow page.
// if the column is not being updated we
// pick it up from the current page. if it is being updated
// we take it from the new value.
int possiblelastfieldexclusive   endfieldexclusive
if   rh hasoverflow
// we might be adding a field here
if  validcolumns    null
if  row length > possiblelastfieldexclusive
possiblelastfieldexclusive   row length
}
else
if  validcolumnssize > possiblelastfieldexclusive
possiblelastfieldexclusive   validcolumnssize
}
}
// use a sparse row
object newrow
new object
formatablebitset  newcolumnlist
new formatablebitset possiblelastfieldexclusive
bytearrayoutputstream fieldstream   null
for  int i   nextcolumn  i < possiblelastfieldexclusive  i
if   validcolumns    null
validcolumnssize > i    validcolumns isset i
newcolumnlist set i
// use the new value
newrow   rowutil getcolumn row  validcolumns  i
}
else if  i < endfieldexclusive
newcolumnlist set i
// use the old value
newrow   savedfields
}
}
recordhandle handle   curpage getrecordhandleatslot slot
// if the portion we just updated is the last portion then
// there cannot be any updates to do.
if  rh hasoverflow
// we have to carry across the overflow information
// from the current record, if any.
nextpage   rh getoverflowpage
id   rh getoverflowid
// find the next starting column before unlatching page
startcolumn
rowutil nextcolumn
row  validcolumns  endfieldexclusive
}
else
startcolumn    1
nextpage   0
}
// after the update is done, see if this row piece has
// shrunk in curpage if no other row pieces have shrunk so
// far.  in head page, need to respect minimumrecordsize.
// in overflow page, only need to respect
// rawstorefactory.minimum_record_size_default
// don't bother with temp container.
if   rowhasreservedspace    headrowhandle    null
curpage    null     owner istemporarycontainer
rowhasreservedspace
curpage checkrowreservedspace slot
}
// insert the record portion on a new overflow page at slot
// 0 this will automatically handle any overflows in
// this new portion
// basepage op = getnewoverflowpage();
basepage op
curpage getoverflowpageforinsert
slot
newrow
newcolumnlist
nextcolumn
// we have all the information from this page so unlatch it
if  curpage    this
curpage unlatch
curpage   null
}
byte mode   page insert_overflow
if  nextpage    0
mode    page insert_for_split
recordhandle nextportionhandle
nextpage    0 ? null
owner makerecordhandle nextpage  id
// resolved (sku):  even though we would like to roll back
// these inserts with purge rather than with delete,
// we have to delete because if we purge the last row
// from an overflow page, the purge will queue a post
// commit to remove the page.
// while this is ok with long columns, we cannot do this
// for long rows because long row overflow pages can be
// shared by more than one long rows, and thus it is unsafe
// to remove the page without first latching the head page.
// however, the insert log record do not have the head
// row's page number so the rollback cannot put that
// information into the post commit work.
recordhandle portionhandle
op insertallowoverflow
0  newrow  newcolumnlist  nextcolumn  mode  100
nextportionhandle
// update the previous record header to point to new portion
if  curpage    this
updateoverflowdetails this  handle  portionhandle
else
updateoverflowdetails handle  portionhandle
op unlatch
}
else
// see earlier comments on checking row reserved space.
if   rowhasreservedspace
headrowhandle    null
curpage    null
owner istemporarycontainer
rowhasreservedspace
curpage checkrowreservedspace slot
}
// find the next starting column before we unlatch the page
startcolumn
rh hasoverflow   ?
rowutil nextcolumn
row  validcolumns  endfieldexclusive     1
}
// have we completed this update?
if  startcolumn     1
if   curpage    this      curpage    null
curpage unlatch
break 		   break out of the for loop
}
}
if  nextpage     1
if  sanitymanager debug
sanitymanager assert
curpage    null
}
// get the next page info while we still have the page
// latched.
nextpage   rh getoverflowpage
id   rh getoverflowid
}
if   curpage    this      curpage    null
curpage unlatch
// get the next portion page and find the correct slot
curpage    storedpage  owner getpage nextpage
if  sanitymanager debug
sanitymanager assert
curpage isoverflowpage
}
slot   curpage findrecordbyid id  first_slot_number
}
// back to the head page.  get rid of all reserved space in the entire
// row post commit.
if  rowhasreservedspace
rawtransaction rxact    rawtransaction owner gettransaction
reclaimspace work
new reclaimspace reclaimspace row_reserve
headrowhandle
rxact getdatafactory    true
rxact addpostcommitwork work
}
}
/**
see if the row on this page has reserved space that can be shrunk once
the update commits.
*/
private boolean checkrowreservedspace int slot  throws standardexception
boolean rowhasreservedspace   false
try
int shrinkage   getreservedcount slot
// only reclaim reserved space if it is
// "reasonably" sized, i.e., we can reclaim at
// least mininum_record_size_default
int reclaimthreshold   rawstorefactory minimum_record_size_default
if  shrinkage > reclaimthreshold
int totalspace   getrecordportionlength slot    shrinkage
if  isoverflowpage
if  totalspace >
rawstorefactory minimum_record_size_default reclaimthreshold
rowhasreservedspace   true
// otherwise, i can at most reclaim less than
// minimum_record_size_default, forget about that.
else
// this is a head page
if  totalspace >  minimumrecordsize
rawstorefactory minimum_record_size_default
rowhasreservedspace   true
// otherwise, i can at most reclaim less than
// minimum_record_size_default, forget about that.
}
}
catch  ioexception ioe
throw standardexception newexception
sqlstate data_unexpected_exception  ioe
}
return rowhasreservedspace
}
/**
@see basepage#compactrecord
@exception standardexception standard derby error policy
*/
protected void compactrecord rawtransaction t  int slot  int id
throws standardexception
// if this is a head row piece, first take care of the entire overflow
// row chain.  don't need to worry about long column because they are
// not in place updatable.
if  isoverflowpage      false
storedrecordheader recordheader   getheaderatslot slot
while  recordheader hasoverflow
storedpage nextpageinrowchain
getoverflowpage recordheader getoverflowpage
if  sanitymanager debug
sanitymanager assert nextpageinrowchain    null
try
int nextid   recordheader getoverflowid
int nextslot   getoverflowslot nextpageinrowchain  recordheader
nextpageinrowchain compactrecord t  nextslot  nextid
// follow the next long row pointer.
recordheader   nextpageinrowchain getheaderatslot nextslot
finally
nextpageinrowchain unlatch
}
}
}
// lastly, see if this row has anything sizable that can be freed.
// try to only reclaim space larger than minimum_record_size_default
// because otherwise it is probably not worth the effort.
int reclaimthreshold   rawstorefactory minimum_record_size_default
try
int reserve   getreservedcount slot
if  reserve > reclaimthreshold
int recordlength   getrecordportionlength slot
int correctreservedspace   reserve
if  isoverflowpage
if   reserve   recordlength  >
rawstorefactory minimum_record_size_default reclaimthreshold
// calculate what the correct reserved space is
if  recordlength >  rawstorefactory minimum_record_size_default
correctreservedspace   0
else	   make sure record takes up minimum_record_size
correctreservedspace
rawstorefactory minimum_record_size_default   recordlength
}
else
// this is a head page
if   reserve   recordlength  >
minimumrecordsize reclaimthreshold
// calculate what the correct reserved space is
if  recordlength >  minimumrecordsize
correctreservedspace   0
else
correctreservedspace   minimumrecordsize   recordlength
}
}
if  sanitymanager debug
sanitymanager assert correctreservedspace <  reserve
}
// a shrinkage has occured.
if  correctreservedspace < reserve
owner getactionset
actionshrinkreservedspace t  this  slot  id
correctreservedspace  reserve
}
}
catch  ioexception ioe
throw standardexception newexception
sqlstate data_unexpected_exception  ioe
}
}
}