/*
derby - class org.apache.derby.impl.sql.compile.updatenode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services context contextmanager
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services compiler methodbuilder
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi sql conn authorizer
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby impl sql execute fkinfo
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary constraintdescriptorlist
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi sql dictionary checkconstraintdescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary indexrowgenerator
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary genericdescriptorlist
import org apache derby iapi reference sqlstate
import org apache derby iapi sql execute constantaction
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql execute execpreparedstatement
import org apache derby iapi sql execute execrow
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi sql statementtype
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby vti defermodification
import org apache derby iapi services io formatablebitset
import org apache derby iapi reference classname
import org apache derby iapi util reusefactory
import org apache derby iapi services classfile vmopcode
import java lang reflect modifier
import java sql sqlexception
import java util properties
import java util vector
/**
* an updatenode represents an update statement.  it is the top node of the
* query tree for that statement.
* for positioned update, there may be no from table specified.
* the from table will be derived from the cursor specification of
* the named cursor.
*
*/
public final class updatenode extends dmlmodstatementnode
//note: these are public so they will be visible to
//the repupdatenode.
public int				changedcolumnids
public execrow				emptyheaprow
public boolean				deferred
public valuenode			checkconstraints
public fkinfo				fkinfo
protected fromtable			targettable
protected formatablebitset 			readcolsbitset
protected boolean 			positionedupdate
/* column name for the rowlocation in the resultset */
public static final string columnname
/**
* initializer for an updatenode.
*
* @param targettablename	the name of the table to update
* @param resultset		the resultset that will generate
*				the rows to update from the given table
*/
public void init
object targettablename
object resultset
super init resultset
this targettablename    tablename  targettablename
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return targettablename tostring
super tostring
else
return
public string statementtostring
return
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  targettablename    null
printlabel depth
targettablename treeprint depth   1
/* resolve - need to print out targettabledescriptor */
/**
* bind this updatenode.  this means looking up tables and columns and
* getting their types, and figuring out the result types of all
* expressions, as well as doing view resolution, permissions checking,
* etc.
* <p>
* binding an update will also massage the tree so that
* the resultsetnode has a set of columns to contain the old row
* value, followed by a set of columns to contain the new row
* value, followed by a column to contain the rowlocation of the
* row to be updated.
*
*
* @exception standardexception		thrown on error
*/
public void bindstatement   throws standardexception
// we just need select privilege on the expressions
getcompilercontext   pushcurrentprivtype  authorizer select_priv
fromlist	fromlist    fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
resultcolumn				rowlocationcolumn   null
valuenode		            rowlocationnode   null
tablename					cursortargettablename   null
currentofnode       		currentofnode   null
fromlist					resultfromlist
resultcolumnlist			aftercolumns   null
datadictionary datadictionary   getdatadictionary
// check if targettable is a synonym
if  targettablename    null
tablename synonymtab   resolvetabletosynonym this targettablename
if  synonymtab    null
this synonymtablename   targettablename
this targettablename    synonymtab
bindtables datadictionary
// wait to bind named target table until the cursor
// binding is done, so that we can get it from the
// cursor if this is a positioned update.
// for positioned update, get the cursor's target table.
if  sanitymanager debug
sanitymanager assert  resultset  null    resultset instanceof selectnode
selectnode sel
sel    selectnode resultset
targettable    fromtable  sel fromlist elementat 0
if  targettable instanceof currentofnode
positionedupdate   true
currentofnode    currentofnode  targettable
cursortargettablename   currentofnode getbasecursortargettablename
// instead of an assert, we might say the cursor is not updatable.
if  sanitymanager debug
sanitymanager assert cursortargettablename    null
if  targettable instanceof fromvti
targetvti    fromvti  targettable
targetvti settarget
else
// positioned update can leave off the target table.
// we get it from the cursor supplying the position.
if  targettablename    null
// verify we have current of
if  sanitymanager debug
sanitymanager assert cursortargettablename  null
targettablename   cursortargettablename
// for positioned update, we need to verify that
// the named table is the same as the cursor's target.
else if  cursortargettablename    null
// this match requires that the named table in the update
// be the same as a correlation name in the cursor.
if    targettablename equals cursortargettablename
throw standardexception newexception sqlstate lang_cursor_update_mismatch
targettablename
currentofnode getcursorname
// because we verified that the tables match
// and we already bound the cursor or the select,
// the table descriptor should always be found.
verifytargettable
/* overview - we generate a new resultcolumn, currentrowlocation(), and
* prepend it to the beginning of the source resultcolumnlist.  this
* will tell us which row(s) to update at execution time.  however,
* we must defer prepending this generated column until the other
* resultcolumns are bound since there will be no columndescriptor
* for the generated column.  thus, the sequence of actions is:
*
*		o  bind existing resultcolumnlist (columns in set clause)
*		o  if this is a positioned update with a for update of list,
*		   then verify that all of the target columns are in the
*		   for update of list.
*		o  get the list of indexes that need to be updated.
*		o  create a resultcolumnlist of all the columns in the target
*		   table - this represents the old row.
*		o  if we don't know which columns are being updated,
*		   expand the original resultcolumnlist to include all the
*		   columns in the target table, and sort it to be in the
*		   order of the columns in the target table.  this represents
*		   the new row.  append it to the resultcolumnlist representing
*		   the old row.
*		o  construct the changedcolumnids array sorted by column position.
*		o  generate the read column bit map and append any columns
*		   needed for index maint, etc.
*		o  generate a new resultcolumn for currentrowlocation() and
*		   mark it as a generated column.
*		o  append the new resultcolumn to the resultcolumnlist
*		   (this must be done before binding the expressions, so
*		   that the proper type info gets propagated to the new
*		   resultcolumn.)
*		o  bind the expressions.
*		o  bind the generated resultcolumn.
*/
/* verify that all underlying resultsets reclaimed their fromlist */
if  sanitymanager debug
sanitymanager assert fromlist size      0
fromlist size
/*
** the current result column list is the one supplied by the user.
** mark these columns as "updated", so we can tell later which
** columns are really being updated, and which have been added
** but are not really being updated.
*/
resultset getresultcolumns   markupdated
/* prepend currentrowlocation() to the select's result column list. */
if  sanitymanager debug
sanitymanager assert  resultset resultcolumns    null
/*
** get the result fromtable, which should be the only table in the
** from list.
*/
resultfromlist   resultset getfromlist
if  sanitymanager debug
sanitymanager assert resultfromlist size      1
/* normalize the set clause's result column list for synonym */
if  synonymtablename    null
normalizesynonymcolumns  resultset resultcolumns  targettable
/* bind the original result columns by column name */
normalizecorrelatedcolumns  resultset resultcolumns  targettable
getcompilercontext   pushcurrentprivtype getprivtype        update privilege
resultset bindresultcolumns targettabledescriptor
targetvti
resultset resultcolumns  this
fromlist
getcompilercontext   popcurrentprivtype
languageconnectioncontext lcc   getlanguageconnectioncontext
if  lcc getautoincrementupdate      false
resultset getresultcolumns   checkautoincrement null
/*
** mark the columns in this updatenode's result column list as
** updateable in the resultcolumnlist of the table being updated.
** only do this for frombasetables - if the result table is a
** currentofnode, it already knows what columns in its cursor
** are updateable.
*/
boolean allcolumns   false
if  targettable instanceof frombasetable
frombasetable  targettable  markupdated
resultset getresultcolumns
else if  targettable instanceof fromvti
resultcolumnlist   resultset getresultcolumns
else
/*
** positioned update: where current of
*/
if  sanitymanager debug
sanitymanager assert currentofnode    null
execpreparedstatement	 cursorstmt   currentofnode getcursorstatement
string ucl   cursorstmt getupdatecolumns
/*
** if there is no update column list, we need to build
** out the result column list to have all columns.
*/
if  ucl    null     ucl length    0
/*
** get the resultcolumnlist representing all of the columns in the
** base table.  this is the "before" portion of the result row.
*/
getresultcolumnlist
/*
** add the "after" portion of the result row.  this is the update
** list augmented to include every column in the target table.
** those columns that are not being updated are set to themselves.
** the expanded list will be in the order of the columns in the base
** table.
*/
aftercolumns   resultset getresultcolumns   expandtoall
targettabledescriptor
targettable gettablename
/*
** need to get all indexes here since we aren't calling
** getreadmap().
*/
getaffectedindexes targettabledescriptor
resultcolumnlist null   formatablebitset null
allcolumns   true
else
/* check the updatability */
resultset getresultcolumns   checkcolumnupdateability ucl
currentofnode getcursorname
changedcolumnids   getchangedcolumnids resultset getresultcolumns
/*
** we need to add in all the columns that are needed
** by the constraints on this table.
*/
if   allcolumns    targetvti    null
getcompilercontext   pushcurrentprivtype  authorizer null_priv
try
readcolsbitset   new formatablebitset
frombasetable fbt   getresultcolumnlist resultset getresultcolumns
aftercolumns   resultset getresultcolumns   copylistandobjects
readcolsbitset   getreadmap datadictionary
targettabledescriptor
aftercolumns
aftercolumns   fbt addcolstolist aftercolumns  readcolsbitset
resultcolumnlist   fbt addcolstolist resultcolumnlist  readcolsbitset
/*
** if all bits are set, then behave as if we chose all
** in the first place
*/
int i   1
int size   targettabledescriptor getmaxcolumnid
for    i <  size  i
if   readcolsbitset get i
break
if  i > size
readcolsbitset   null
allcolumns   true
finally
getcompilercontext   popcurrentprivtype
if  targetvti    null
/*
** construct an empty heap row for use in our constant action.
*/
emptyheaprow   targettabledescriptor getemptyexecrow
/* append the list of "after" columns to the list of "before" columns,
* preserving the aftercolumns list.  (necessary for binding
* check constraints.)
*/
resultcolumnlist appendresultcolumns aftercolumns  false
/* generate the rowlocation column */
rowlocationnode    currentrowlocationnode  getnodefactory   getnode
c_nodetypes current_row_location_node
getcontextmanager
else
rowlocationnode    numericconstantnode  getnodefactory   getnode
c_nodetypes int_constant_node
reusefactory getinteger  0
getcontextmanager
rowlocationcolumn
resultcolumn  getnodefactory   getnode
c_nodetypes result_column
columnname
rowlocationnode
getcontextmanager
rowlocationcolumn markgenerated
/* append to the resultcolumnlist */
resultcolumnlist addresultcolumn rowlocationcolumn
/*
* the last thing that we do to the generated rcl is to clear
* the table name out from each rc. see comment on
* checktablenameandscrubresultcolumns().
*/
checktablenameandscrubresultcolumns resultcolumnlist
/* set the new result column list in the result set */
resultset setresultcolumns resultcolumnlist
/* bind the expressions */
getcompilercontext   pushcurrentprivtype getprivtype        update privilege
super bindexpressions
getcompilercontext   popcurrentprivtype
/* bind untyped nulls directly under the result columns */
resultset
getresultcolumns
binduntypednullstoresultcolumns resultcolumnlist
if  null    rowlocationcolumn
/* bind the new resultcolumn */
rowlocationcolumn bindresultcolumntoexpression
resultcolumnlist checkstorableexpressions
/* insert a normalizeresultsetnode above the source if the source
* and target column types and lengths do not match.
*/
if    resultcolumnlist columntypesandlengthsmatch
resultset   resultset gennormalizeresultsetnode resultset  true
resultcolumnlist copytypesandlengthstosource resultset getresultcolumns
if  hascheckconstraints datadictionary  targettabledescriptor
/* get and bind all check constraints on the columns
* being updated.  we want to bind the check constraints against
* the after columns.  we need to bind against the portion of the
* resultcolumns in the new normalizeresultset that point to
* aftercolumns.  create an rcl composed of just those rcs in
* order to bind the check constraints.
*/
int aftercolumnssize   aftercolumns size
aftercolumns    resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
resultcolumnlist normalizedrcs   resultset getresultcolumns
for  int index   0  index < aftercolumnssize  index
aftercolumns addelement normalizedrcs elementat index   aftercolumnssize
if  null    targetvti
deferred   vtidefermodpolicy deferit  defermodification update_statement
targetvti
resultcolumnlist getcolumnnames
sel getwhereclause
else    not vti
/* we always include triggers in core language */
boolean hastriggers    getallrelevanttriggers datadictionary  targettabledescriptor
changedcolumnids  true  size   > 0
/* get and bind all constraints on the columns being updated */
checkconstraints   bindconstraints  datadictionary
getnodefactory
targettabledescriptor

hastriggers ? resultcolumnlist   aftercolumns
changedcolumnids
readcolsbitset
false
true      we always include triggers in core language
/* if the target table is also a source table, then
* the update will have to be in deferred mode
* for updates, this means that the target table appears in a
* subquery.  also, self referencing foreign keys are
* deferred.  and triggers cause an update to be deferred.
*/
if  resultset subqueryreferencestarget
targettabledescriptor getname    true
requiresdeferredprocessing
deferred   true
getcompilercontext   popcurrentprivtype
end of bind
int getprivtype
return authorizer update_priv
/**
* return true if the node references session schema tables (temporary or permanent)
*
* @return	true if references session schema tables, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencessessionschema
throws standardexception
//if this node references a session schema table, then return true.
return resultset referencessessionschema
/**
* compile constants that execution will use
*
* @exception standardexception		thrown on failure
*/
public constantaction	makeconstantaction   throws standardexception
/*
** updates are also deferred if they update a column in the index
** used to scan the table being updated.
*/
if    deferred
conglomeratedescriptor updatecd
targettable
gettrulythebestaccesspath
getconglomeratedescriptor
if  updatecd    null    updatecd isindex
int  basecolumns
updatecd getindexdescriptor   basecolumnpositions
if  resultset
getresultcolumns
updateoverlaps basecolumns
deferred   true
if  null    targettabledescriptor
/* return constant action for vti
* note: constantaction responsible for preserving instantiated
* vtis for in-memory queries and for only preserving vtis
* that implement serializable for spss.
*/
return	getgenericconstantactionfactory   getupdatablevticonstantaction  defermodification update_statement
deferred  changedcolumnids
int lockmode   resultset updatetargetlockmode
long heapconglomid   targettabledescriptor getheapconglomerateid
transactioncontroller tc
getlanguageconnectioncontext   gettransactioncompile
staticcompiledopenconglominfo indexscocis
new staticcompiledopenconglominfo
for  int index   0  index < indexscocis length  index
indexscocis   tc getstaticcompiledconglominfo indexconglomeratenumbers
/*
** do table locking if the table's lock granularity is
** set to table.
*/
if  targettabledescriptor getlockgranularity      tabledescriptor table_lock_granularity
lockmode   transactioncontroller mode_table
return	getgenericconstantactionfactory   getupdateconstantaction
heapconglomid
targettabledescriptor gettabletype
tc getstaticcompiledconglominfo heapconglomid
indicestomaintain
indexconglomeratenumbers
indexscocis
indexnames
emptyheaprow
deferred
targettabledescriptor getuuid
lockmode
false
changedcolumnids  null  null
getfkinfo
gettriggerinfo
readcolsbitset    null  ?  formatablebitset null   new formatablebitset readcolsbitset
getreadcolmap targettabledescriptor getnumberofcolumns   readcolsbitset
resultcolumnlist getstreamstorablecolids targettabledescriptor getnumberofcolumns
readcolsbitset    null  ?
targettabledescriptor getnumberofcolumns
readcolsbitset getnumbitsset
positionedupdate
resultset isonerowresultset
/**
* updates are deferred if they update a column in the index
* used to scan the table being updated.
*/
protected void setdeferredforupdateofindexcolumn
/* don't bother checking if we're already deferred */
if    deferred
/* get the conglomerate descriptor for the target table */
conglomeratedescriptor updatecd
targettable
gettrulythebestaccesspath
getconglomeratedescriptor
/* if it an index? */
if  updatecd    null    updatecd isindex
int  basecolumns
updatecd getindexdescriptor   basecolumnpositions
/* are any of the index columns updated? */
if  resultset
getresultcolumns
updateoverlaps basecolumns
deferred   true
/**
* code generation for update.
* the generated code will contain:
*		o  a static member for the (xxx)resultset with the rowlocations	and
*		   new update values
*		o  the static member will be assigned the appropriate resultset within
*		   the nested calls to get the resultsets.  (the appropriate cast to the
*		   (xxx)resultset will be generated.)
*		o  the currentrowlocation() in selectnode's select list will generate
*		   a new method for returning the rowlocation as well as a call to
*		   that method when generating the (xxx)resultset.
*
* @param acb	the activationclassbuilder for the class being built
* @param mb	the method for the execute() method to be built
*
*
* @exception standardexception		thrown on error
*/
public void generate activationclassbuilder acb
methodbuilder mb
throws standardexception
// if the dml is on the temporary table, generate the code to
// mark temporary table as modified in the current uow. after
// derby-827 this must be done in execute() since
// fillresultset() will only be called once.
generatecodefortemporarytable acb  acb getexecutemethod
/* generate the parameters */
if  isdependenttable
generateparametervalueset acb
/* create the static declaration for the scan resultset which generates the
* rowlocations to be updated
* resolve - need to deal with the type of the static member.
*/
acb newfielddeclaration modifier private
classname cursorresultset
acb newrowlocationscanresultsetname
/*
** generate the update result set, giving it either the original
** source or the normalize result set, the constant action.
*/
acb pushgetresultsetfactoryexpression mb
resultset generate acb  mb      arg 1
if  null    targetvti
targetvti assigncostestimate resultset getnewcostestimate
mb callmethod vmopcode invokeinterface   string  null     classname resultset  1
else
// generate code to evaluate check constraints
generatecheckconstraints  checkconstraints  acb  mb       arg 2
if isdependenttable
mb push acb additem makeconstantaction
mb push acb additem makeresultdescription
mb callmethod vmopcode invokeinterface   string  null
classname resultset  4
else
mb callmethod vmopcode invokeinterface   string  null
classname resultset  2
/**
* return the type of statement, something from
* statementtype.
*
* @return the type of statement
*/
protected final int getstatementtype
return statementtype update
/**
* gets the map of all columns which must be read out of the base table.
* these are the columns needed to<ul>:
*		<li>maintain indices</li>
*		<li>maintain foreign keys</li>
*		<li>support replication's delta optimization</li></ul>
* <p>
* the returned map is a formatablebitset with 1 bit for each column in the
* table plus an extra, unsued 0-bit. if a 1-based column id must
* be read from the base table, then the corresponding 1-based bit
* is turned on in the returned formatablebitset.
* <p>
* <b>note</b>: this method is not expected to be called when
* all columns are being updated (i.e. updatecolumnlist is null).
*
* @param dd				the data dictionary to look in
* @param basetable		the base table descriptor
* @param updatecolumnlist the rcl for the update. cannot be null
*
* @return a formatablebitset of columns to be read out of the base table
*
* @exception standardexception		thrown on error
*/
public	formatablebitset	getreadmap
datadictionary		dd
tabledescriptor		basetable
resultcolumnlist	updatecolumnlist
throws standardexception
boolean	needsdeferredprocessing   new boolean
needsdeferredprocessing   requiresdeferredprocessing
vector		conglomvector   new vector
relevantcdl   new constraintdescriptorlist
relevanttriggers    new genericdescriptorlist
formatablebitset	columnmap   updatenode getupdatereadmap basetable
updatecolumnlist  conglomvector  relevantcdl  relevanttriggers  needsdeferredprocessing
markaffectedindexes  conglomvector
adjustdeferredflag  needsdeferredprocessing
return	columnmap
/**
* construct the changedcolumnids array. note we sort its entries by
* columnid.
*/
private int getchangedcolumnids resultcolumnlist rcl
if  rcl    null    return  int null
else   return rcl sortme
/**
*	builds a bitmap of all columns which should be read from the
*	store in order to satisfy an update statement.
*
*	is passed a list of updated columns. does the following:
*
*	1)	finds all indices which overlap the updated columns
*	2)	adds the index columns to a bitmap of affected columns
*	3)	adds the index descriptors to a list of conglomerate
*		descriptors.
*	4)	finds all constraints which overlap the updated columns
*		and adds the constrained columns to the bitmap
*	5)	finds all triggers which overlap the updated columns.
*	6)	if there are any triggers, marks all columns in the bitmap
*	7)	adds the triggers to an evolving list of triggers
*
*	@param	updatecolumnlist	a list of updated columns
*	@param	conglomvector		out: vector of affected indices
*	@param	relevantconstraints	in/out. empty list is passed in. we hang constraints on it as we go.
*	@param	relevanttriggers	in/out. passed in as an empty list. filled in as we go.
*	@param	needsdeferredprocessing	in/out. true if the statement already needs
*									deferred processing. set while evaluating this
*									routine if a trigger or constraint requires
*									deferred processing
*
* @return a formatablebitset of columns to be read out of the base table
*
* @exception standardexception		thrown on error
*/
public static formatablebitset getupdatereadmap
tabledescriptor				basetable
resultcolumnlist			updatecolumnlist
vector						conglomvector
constraintdescriptorlist	relevantconstraints
genericdescriptorlist		relevanttriggers
boolean					needsdeferredprocessing
throws standardexception
if  sanitymanager debug
sanitymanager assert updatecolumnlist    null
int		columncount   basetable getmaxcolumnid
formatablebitset	columnmap   new formatablebitset columncount   1
/*
** add all the changed columns.  we don't strictly
** need the before image of the changed column in all cases,
** but it makes life much easier since things are set
** up around the assumption that we have the before
** and after image of the column.
*/
int	changedcolumnids   updatecolumnlist sortme
for  int ix   0  ix < changedcolumnids length  ix
columnmap set changedcolumnids
/*
** get a list of the indexes that need to be
** updated.  columnmap contains all indexed
** columns where 1 or more columns in the index
** are going to be modified.
*/
dmlmodstatementnode getxaffectedindexes basetable  updatecolumnlist  columnmap  conglomvector
/*
** add all columns needed for constraints.  we don't
** need to bother with foreign key/primary key constraints
** because they are added as a side effect of adding
** their indexes above.
*/
basetable getallrelevantconstraints
statementtype update  false  changedcolumnids  needsdeferredprocessing  relevantconstraints
int rclsize   relevantconstraints size
for  int index   0  index < rclsize  index
constraintdescriptor cd   relevantconstraints elementat index
if  cd getconstrainttype      datadictionary check_constraint
continue
int refcolumns     checkconstraintdescriptor cd  getreferencedcolumns
for  int i   0  i < refcolumns length  i
columnmap set refcolumns
/*
** if we have any triggers, then get all the columns
** because we don't know what the user will ultimately
** reference.
*/
basetable getallrelevanttriggers  statementtype update  changedcolumnids  relevanttriggers
if   relevanttriggers size   > 0     needsdeferredprocessing   true
if  relevanttriggers size   > 0
for  int i   1  i <  columncount  i
columnmap set i
return	columnmap
/*
* force correlated column references in the set clause to have the
* name of the base table. this dances around the problem alluded to
* in scrubresultcolumn().
*/
private	void	normalizecorrelatedcolumns  resultcolumnlist rcl  fromtable fromtable
throws standardexception
string		correlationname   fromtable getcorrelationname
if   correlationname    null     return
tablename	tablenamenode
if   fromtable instanceof currentofnode
tablenamenode     currentofnode  fromtable  getbasecursortargettablename
else   tablenamenode   maketablename  null  fromtable getbasetablename
int			count   rcl size
for   int i   0  i < count  i
resultcolumn	column    resultcolumn  rcl elementat  i
columnreference	reference   column getreference
if    reference    null     correlationname equals  reference gettablename
reference settablenamenode  tablenamenode
/**
* check table name and then clear it from the result set columns.
*
* @exception standardexcepion if invalid column/table is specified.
*/
private void checktablenameandscrubresultcolumns resultcolumnlist rcl
throws standardexception
int columncount   rcl size
int tablecount     selectnode resultset  fromlist size
for   int i   0  i < columncount  i
boolean foundmatchingtable   false
resultcolumn	column    resultcolumn  rcl elementat  i
if  column gettablename      null
for  int j   0  j < tablecount  j
fromtable fromtable    fromtable    selectnode resultset
fromlist elementat j
final string tablename
if   fromtable instanceof currentofnode
tablename     currentofnode fromtable
getbasecursortargettablename   gettablename
else
tablename   fromtable getbasetablename
if  column gettablename   equals tablename
foundmatchingtable   true
break
if   foundmatchingtable
throw standardexception newexception
sqlstate lang_column_not_found
column gettablename         column getname
/* the table name is
* unnecessary for an update.  more importantly, though, it
* creates a problem in the degenerate case with a positioned
* update.  the user must specify the base table name for a
* positioned update.  if a correlation name was specified for
* the cursor, then a match for the columnreference would not
* be found if we didn't null out the name.  (aren't you
* glad you asked?)
*/
column cleartablename
/**
* normalize synonym column references to have the name of the base table.
*
* @param rcl	    the result column list of the target table
* @param fromtable the table name to set the column refs to
*
* @exception standardexception		thrown on error
*/
private	void normalizesynonymcolumns
resultcolumnlist    rcl
fromtable           fromtable
throws standardexception
if  fromtable getcorrelationname      null
return
tablename tablenamenode
if  fromtable instanceof currentofnode
tablenamenode
currentofnode  fromtable  getbasecursortargettablename
else
tablenamenode   maketablename null  fromtable getbasetablename
super normalizesynonymcolumns rcl  tablenamenode
end of updatenode