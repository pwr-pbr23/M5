/*
derby - class org.apache.derby.impl.sql.compile.createtablenode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi reference property
import org apache derby iapi reference sqlstate
import org apache derby iapi reference limits
import org apache derby iapi services property propertyutil
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql execute constantaction
import org apache derby iapi sql depend providerlist
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql conn authorizer
import org apache derby iapi error standardexception
import org apache derby impl sql execute columninfo
import org apache derby impl sql execute createconstraintconstantaction
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types stringdatavalue
import java util properties
/**
* a createtablenode is the root of a querytree that represents a create table or declare global temporary table
* statement.
*
*/
public class createtablenode extends ddlstatementnode
private char				lockgranularity
private boolean				oncommitdeleterows    if true  on commit delete rows else on commit preserve rows of temporary table
private boolean				onrollbackdeleterows    if true  on rollback delete rows from temp table if it was logically modified in that uow  true is the only supported value
private properties			properties
private tableelementlist	tableelementlist
protected int	tabletype    persistent table or global temporary table
private resultcolumnlist	resultcolumns
private resultsetnode		queryexpression
/**
* initializer for a createtablenode for a base table
*
* @param newobjectname		the name of the new object being created (ie base table)
* @param tableelementlist	the elements of the table: columns,
*				constraints, etc.
* @param properties		the optional list of properties associated with
*							the table.
* @param lockgranularity	the lock granularity.
*
* @exception standardexception		thrown on error
*/
public void init
object newobjectname
object tableelementlist
object properties
object lockgranularity
throws standardexception
tabletype   tabledescriptor base_table_type
this lockgranularity     character  lockgranularity  charvalue
implicitcreateschema   true
if  sanitymanager debug
if  this lockgranularity    tabledescriptor table_lock_granularity
this lockgranularity    tabledescriptor row_lock_granularity
sanitymanager throwassert
this lockgranularity
initandcheck newobjectname
this tableelementlist    tableelementlist  tableelementlist
this properties    properties  properties
/**
* initializer for a createtablenode for a global temporary table
*
* @param newobjectname		the name of the new object being declared (ie temporary table)
* @param tableelementlist	the elements of the table: columns,
*				constraints, etc.
* @param properties		the optional list of properties associated with
*							the table.
* @param oncommitdeleterows	if true, on commit delete rows else on commit preserve rows of temporary table.
* @param onrollbackdeleterows	if true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
*
* @exception standardexception		thrown on error
*/
public void init
object newobjectname
object tableelementlist
object properties
object oncommitdeleterows
object onrollbackdeleterows
throws standardexception
tabletype   tabledescriptor global_temporary_table_type
newobjectname   temptableschemanamecheck newobjectname
this oncommitdeleterows     boolean  oncommitdeleterows  booleanvalue
this onrollbackdeleterows     boolean  onrollbackdeleterows  booleanvalue
initandcheck newobjectname
this tableelementlist    tableelementlist  tableelementlist
this properties    properties  properties
if  sanitymanager debug
if  this onrollbackdeleterows    false
sanitymanager throwassert
this onrollbackdeleterows
/**
* initializer for a createtablenode for a base table create from a query
*
* @param newobjectname		the name of the new object being created
* 	                        (ie base table).
* @param resultcolumns		the optional column list.
* @param queryexpression	the query expression for the table.
*/
public void init
object newobjectname
object resultcolumns
object queryexpression
throws standardexception
tabletype   tabledescriptor base_table_type
lockgranularity   tabledescriptor default_lock_granularity
implicitcreateschema   true
initandcheck newobjectname
this resultcolumns    resultcolumnlist  resultcolumns
this queryexpression    resultsetnode  queryexpression
/**
* if no schema name specified for global temporary table, session is the implicit schema.
* otherwise, make sure the specified schema name for global temporary table is session.
* @param objectname		the name of the new object being declared (ie temporary table)
*/
private object temptableschemanamecheck object objectname
throws standardexception
tablename	temptablename    tablename  objectname
if  temptablename    null
if  temptablename getschemaname      null
temptablename setschemaname schemadescriptor std_declared_global_temporary_tables_schema_name     if no schema specified  session is the implicit schema
else if    issessionschema temptablename getschemaname
throw standardexception newexception sqlstate lang_declared_global_temp_table_only_in_session_schema
return temptablename
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
string tempstring           tableelementlist
if  tabletype    tabledescriptor global_temporary_table_type
tempstring   tempstring           oncommitdeleterows
tempstring   tempstring           onrollbackdeleterows
else
tempstring   tempstring           properties               lockgranularity
return super tostring      tempstring
else
return
public string statementtostring
if  tabletype    tabledescriptor global_temporary_table_type
return
else
return
// we inherit the generate() method from ddlstatementnode.
/**
* bind this createtablenode.  this means doing any static error checking that can be
* done before actually creating the base table or declaring the global temporary table.
* for eg, verifying that the tableelementlist does not contain any duplicate column names.
*
*
* @exception standardexception		thrown on error
*/
public void bindstatement   throws standardexception
datadictionary	datadictionary   getdatadictionary
int numprimarykeys   0
int numcheckconstraints   0
int numreferenceconstraints   0
int numuniqueconstraints   0
if  queryexpression    null
fromlist fromlist    fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
compilercontext cc   getcompilercontext
providerlist prevapl   cc getcurrentauxiliaryproviderlist
providerlist apl   new providerlist
try
cc setcurrentauxiliaryproviderlist apl
cc pushcurrentprivtype authorizer select_priv
/* bind the tables in the queryexpression */
queryexpression
queryexpression bindnonvtitables datadictionary  fromlist
queryexpression   queryexpression bindvtitables fromlist
/* bind the expressions under the resultset */
queryexpression bindexpressions fromlist
/* bind the query expression */
queryexpression bindresultcolumns fromlist
/* reject any untyped nulls in the rcl */
/* e.g. create table t1 (x) as values null with no data */
queryexpression binduntypednullstoresultcolumns null
finally
cc popcurrentprivtype
cc setcurrentauxiliaryproviderlist prevapl
/* if there is an rcl for the table definition then copy the
* names to the queryexpression's rcl after verifying that
* they both have the same size.
*/
resultcolumnlist qercl   queryexpression getresultcolumns
if  resultcolumns    null
if  resultcolumns size      qercl visiblesize
throw standardexception newexception
sqlstate lang_table_definition_r_c_l_mismatch
getfullname
qercl copyresultcolumnnames resultcolumns
schemadescriptor sd   getschemadescriptor
int schemacollationtype   sd getcollationtype
/* create table element list from columns in query expression */
tableelementlist   new tableelementlist
for  int index   0  index < qercl size    index
resultcolumn rc    resultcolumn  qercl elementat index
if  rc isgenerated
continue
/* raise error if column name is system generated. */
if  rc isnamegenerated
throw standardexception newexception
sqlstate lang_table_requires_column_names
datatypedescriptor dtd   rc getexpressiontype
if   dtd    null      dtd isusercreatabletype
throw standardexception newexception
sqlstate lang_invalid_column_type_create_table
dtd getfullsqltypename
rc getname
//derby-2879  create table as <subquery> does not maintain the
//collation for character types.
//eg for a territory based collation database
//create table t as select tablename from sys.systables with no data;
//derby at this point does not support for a table's character
//columns to have a collation different from it's schema's
//collation. which means that in a territory based database,
//the query above will cause table t's character columns to
//have collation of ucs_basic but the containing schema of t
//has collation of territory based. this is not supported and
//hence we will throw an exception below for the query above in
//a territory based database.
if  dtd gettypeid   isstringtypeid
dtd getcollationtype      schemacollationtype
string schemacollationname
schemacollationtype
stringdatavalue collation_type_ucs_basic ?
property ucs_basic_collation
property territory_based_collation
throw standardexception newexception
sqlstate lang_can_not_create_table
dtd getcollationname
schemacollationname
columndefinitionnode column   new columndefinitionnode
column init rc getname    null  rc gettype    null
tableelementlist addtableelement column
else
//set the collation type and collation derivation of all the
//character type columns. their collation type will be same as the
//collation of the schema they belong to. their collation
//derivation will be "implicit".
//earlier we did this in makeconstantaction but that is little too
//late (derby-2955)
//eg
//create table staff9 (empname char(20),
//  constraint staff9_empname check (empname not like 't%'))
//for the query above, when run in a territory based db, we need
//to have the correct collation set in bind phase of create table
//so that when like is handled in likeescapeoperatornode, we have
//the correct collation set for empname otherwise it will throw an
//exception for 't%' having collation of territory based and
//empname having the default collation of ucs_basic
tableelementlist setcollationtypesoncharacterstringcolumns
getschemadescriptor
tableelementlist validate this  datadictionary   tabledescriptor  null
/* only 1012 columns allowed per table */
if  tableelementlist countnumberofcolumns   > limits db2_max_columns_in_table
throw standardexception newexception sqlstate lang_too_many_columns_in_table_or_view
string valueof tableelementlist countnumberofcolumns
getrelativename
string valueof limits db2_max_columns_in_table
numprimarykeys   tableelementlist countconstraints
datadictionary primarykey_constraint
/* only 1 primary key allowed per table */
if  numprimarykeys > 1
throw standardexception newexception sqlstate lang_too_many_primary_key_constraints  getrelativename
/* check the validity of all check constraints */
numcheckconstraints   tableelementlist countconstraints
datadictionary check_constraint
numreferenceconstraints   tableelementlist countconstraints
datadictionary foreignkey_constraint
numuniqueconstraints   tableelementlist countconstraints
datadictionary unique_constraint
//temp tables can't have primary key or check or foreign key or unique constraints defined on them
if   tabletype    tabledescriptor global_temporary_table_type
numprimarykeys > 0    numcheckconstraints > 0    numreferenceconstraints > 0    numuniqueconstraints > 0
throw standardexception newexception sqlstate lang_not_allowed_for_declared_global_temp_table
//each of these constraints have a backing index in the back. we need to make sure that a table never has more
//more than 32767 indexes on it and that is why this check.
if   numprimarykeys   numreferenceconstraints   numuniqueconstraints  > limits db2_max_indexes_on_table
throw standardexception newexception sqlstate lang_too_many_indexes_on_table
string valueof numprimarykeys   numreferenceconstraints   numuniqueconstraints
getrelativename
string valueof limits db2_max_indexes_on_table
if  numcheckconstraints > 0
/* in order to check the validity of the check constraints
* we must goober up a fromlist containing a single table,
* the table being created, with an rcl containing the
* new columns and their types.  this will allow us to
* bind the constraint definition trees against that
* fromlist.  when doing this, we verify that there are
* no nodes which can return non-deterministic results.
*/
fromlist fromlist    fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
frombasetable table    frombasetable
getnodefactory   getnode
c_nodetypes from_base_table
getobjectname



getcontextmanager
table settablenumber 0
fromlist addfromtable table
table setresultcolumns  resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
tableelementlist appendnewcolumnstorcl table
/* now that we've finally goobered stuff up, bind and validate
* the check constraints.
*/
tableelementlist bindandvalidatecheckconstraints fromlist
/**
* return true if the node references session schema tables (temporary or permanent)
*
* @return	true if references session schema tables, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencessessionschema
throws standardexception
//if table being created/declared is in session schema, then return true.
return issessionschema getschemadescriptor
/**
* create the constant information that will drive the guts of execution.
*
* @exception standardexception		thrown on failure
*/
public constantaction	makeconstantaction   throws standardexception
tableelementlist		coldefs   tableelementlist
// for each column, stuff system.column
columninfo colinfos   new columninfo
int numconstraints   coldefs gencolumninfos colinfos
/* if we've seen a constraint, then build a constraint list */
createconstraintconstantaction conactions   null
schemadescriptor sd   getschemadescriptor
if  numconstraints > 0
conactions
new createconstraintconstantaction
coldefs genconstraintactions
conactions  getrelativename    sd  getdatadictionary
// if the any of columns are "long" and user has not specified a
// page size, set the pagesize to 32k.
// also in case where the approximate sum of the column sizes is
// greater than the bump threshold , bump the pagesize to 32k
boolean table_has_long_column   false
int approxlength   0
for  int i   0  i < colinfos length  i
datatypedescriptor dts   colinfos datatype
if  dts gettypeid   islongconcatabletypeid
table_has_long_column   true
break
approxlength    dts gettypeid   getapproximatelengthinbytes dts
if  table_has_long_column     approxlength > property tbl_page_size_bump_threshold
if    properties    null
properties get property page_size_parameter     null
propertyutil getserviceproperty
getlanguageconnectioncontext   gettransactioncompile
property page_size_parameter     null
// do not override the user's choice of page size, whether it
// is set for the whole database or just set on this statement.
if  properties    null
properties   new properties
properties put
property page_size_parameter
property page_size_default_long
return
getgenericconstantactionfactory   getcreatetableconstantaction
sd getschemaname
getrelativename
tabletype
colinfos
conactions
properties
lockgranularity
oncommitdeleterows
onrollbackdeleterows