/*
derby - class org.apache.derby.impl.sql.execute.multiprobetablescanresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services loader generatedmethod
import org apache derby iapi store access qualifier
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby iapi sql activation
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql execute execrow
import org apache derby iapi types datavaluedescriptor
// these are for javadoc "@see" tags.
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql execute resultsetfactory
/**
* result set that fetches rows from a scan by "probing" the underlying
* table with a given list of values.  repeated calls to getnextrowcore()
* will first return all rows matching probevalues[0], then all rows matching
* probevalues[1], and so on (duplicate probe values are ignored).  once all
* matching rows for all values in probevalues have been returned, the call
* to getnextrowcore() will return null, thereby ending the scan. the
* expectation is that this kind of result set only ever appears beneath
* some other top-level result set (esp. indexrowtobaserowresultset), in
* which case all result sets higher up in the result set tree will just
* see a stream of rows satisfying the list of probe values.
*
* currently this type of result is used for evaluation of in lists, where
* the user wants to retrieve all rows for which some target column has a
* value that equals one of values in the in list.  in that case the in list
* values are represented by the probevalues array.
*
* most of the work for this class is inherited from tablescanresultset.
* this class overrides four public methods and two protected methods
* from tablescanresultset.  in all cases the methods here set probing
* state and then call the corresponding methods on "super".
*/
class multiprobetablescanresultset extends tablescanresultset
implements cursorresultset
/** the values with which we will probe the table. */
protected datavaluedescriptor  probevalues
/**
* the values with which we will probe the table, as they were passed to
* the constructor. we need to keep them unchanged in case the result set
* is reused when a statement is re-executed (see derby-827).
*/
protected datavaluedescriptor  origprobevalues
/**
* 0-based position of the <b>next</b> value to lookup w.r.t. the probe
* values list.
*/
protected int probevalindex
/**
* whether or not we need to sort the values.  if all values were
* specified as literals (as opposed to parameters) then we did the
* sort at compile time and so we do not need to do it here.
*/
private boolean needsort
/**
* constructor.  just save off the relevant probing state and pass
* everything else up to tablescanresultset.
*
* @see resultsetfactory#getmultiprobetablescanresultset
* @exception standardexception thrown on failure to open
*/
multiprobetablescanresultset long conglomid
staticcompiledopenconglominfo scoci  activation activation
generatedmethod resultrowallocator
int resultsetnumber
generatedmethod startkeygetter  int startsearchoperator
generatedmethod stopkeygetter  int stopsearchoperator
boolean samestartstopposition
qualifier qualifiers
datavaluedescriptor  probingvals
boolean probevalsaresorted
string tablename
string usersuppliedoptimizeroverrides
string indexname
boolean isconstraint
boolean forupdate
int colrefitem
int indexcolitem
int lockmode
boolean tablelocked
int isolationlevel
boolean onerowscan
double optimizerestimatedrowcount
double optimizerestimatedcost
throws standardexception
/* note: we use '1' as rows per read because we do not currently
* allow bulk fetching when multi-probing.  if that changes in
* the future then we will need to update rowsperread accordingly.
*/
super conglomid
scoci
activation
resultrowallocator
resultsetnumber
startkeygetter
startsearchoperator
stopkeygetter
stopsearchoperator
samestartstopposition
qualifiers
tablename
usersuppliedoptimizeroverrides
indexname
isconstraint
forupdate
colrefitem
indexcolitem
lockmode
tablelocked
isolationlevel
1     rowsperread
onerowscan
optimizerestimatedrowcount
optimizerestimatedcost
if  sanitymanager debug
sanitymanager assert
probingvals    null      probingvals length > 0
this origprobevalues   probingvals
this needsort    probevalsaresorted
/**
* @see noputresultset#opencore
*/
public void opencore   throws standardexception
/* if the probe values are not already sorted then sort them now.  this
* allows us to skip over duplicate probe values (otherwise we could
* end up with duplicate rows in the result set).
*
* note: if all of the probe values were provided as constants then we
* sorted them at compile time (during preprocessing) so we don't have
* to do it now. but if one or more was specified as a param then we
* have to do the sort here, at execution time, because this is the
* only point at which we know what values the parameters have.
*/
if  needsort
/* resolve: for some reason sorting the probevalues array
* directly leads to incorrect parameter value assignment when
* executing a prepared statement multiple times.  need to figure
* out why (maybe related to derby-827?).  in the meantime, if
* we're going to sort the values we use clones.  this is not
* ideal, but it works for now.
*/
datavaluedescriptor  pvals
new datavaluedescriptor
for  int i   0  i < pvals length  i
pvals   origprobevalues getclone
java util arrays sort pvals
probevalues   pvals
else
probevalues   origprobevalues
probevalindex   0
super opencore
/**
* open the scan controller
*
* @param tc transaction controller; will open one if null.
* @exception standardexception thrown on failure to open
*/
protected void openscancontroller transactioncontroller tc
throws standardexception
/* if we're opening the scan controller for the first time then
* we want to use the first value in the (now sorted) list as
* the start/stop key.  that's what we pass in here.
*/
openscancontroller tc  probevalues
/* probevalindex should be the index of the *next* value to
* use.  since we just positioned ourselves at the 0th probe
* value with the above call, the next value we want is the
* one at index "1".
*/
probevalindex   1
/**
* @see noputresultset#reopencore
*/
public void reopencore   throws standardexception
/* there are two scenarios for which we reopen this kind of scan:
*
*   a - the first is for join processing.  in this case we have
* a(nother) row from some outer table and we want to reopen this
* scan to look for rows matching the new outer row.
*
*   b - the second is for multi-probing.  here we want to reopen
* the scan on this table to look for rows matching the next value
* in the probe list.
*
* if we are reopening the scan for scenario a (join processing)
* then we need to reset our position within the probe list.
* if we are reopening the scan for scenario b then we do *not*
* want to reset our position within the probe list because that
* position tells us where to find the next probe value.
*
* the way we tell the difference between the two scenarios is
* by looking at our current position in the probe list (i.e. the
* value of probevalindex): if our current position is beyond the
* length of the probe list then we know that we are reopening the
* scan for scenario a.  or put another away, we should never get
* here for scenario b if probevalindex is greater than or equal
* to the length of the probe list.  the reason is that the call
* to reopencore() for scenario b will only ever happen when
* moreinlistvals() returns true--and in that case we know that
* probevalindex will be less than the length of the probevalues.
*/
if  probevalindex >  probevalues length
probevalindex   0
super reopencore
/**
* reopen the scan controller
*
* @exception standardexception thrown on failure to open
*/
protected void reopenscancontroller   throws standardexception
/* if we're looking for the first value in the probe list, then
* reset the row scan count.  otherwise leave it unchanged since
* we're just continuing an already-opened scan.  note that we
* have to do this check *before* we call getnextprobevalue()
* because that method will increment probevalindex.
*/
if  probevalindex    0
rowsthisscan   0
datavaluedescriptor pv   null
if  moreinlistvals
pv   getnextprobevalue
if  pv    null
/* we'll get here when we've exhausted the probe list. in
* that case leave the scan as it is, which effectively
* means we are done.
*/
return
reopenscancontroller pv
/**
* return the next row (if any) from the scan (if open).
*
* more specifically we do the following:
*
*  1 - see if we have a row to read from the current scan position.
*    if so, return that row (done).
*
*  2 - if there are no more rows to read from the current scan
*    position and if there are more probe values to look at,
*    then a) reposition the scan using the next probe value
*    as the start/stop key and b) go back to step 1.  otherwise
*    proceed to step 3.
*
*  3 - return null (no more rows).
*
* note that step 1 is important for cases where multiple rows in this
* table match a single probe value.  in such a scenario we have to
* be sure that we do *not* move on to the next probe value until
* we have returned all of the rows for the _current_ probe value.
*
* @exception standardexception thrown on failure to get next row
*/
public execrow getnextrowcore   throws standardexception
checkcancellationflag
// step 1.
execrow result   super getnextrowcore
// steps 2, 1, 2, 1, 2, ...
while   result    null     moreinlistvals
/* repositioning the scan (if needed) is simply a matter of
* reopening the core scan again. as part of that method we will
* figure out what the next probe value should be (and thus
* where to position the scan).
*/
reopencore
result   super getnextrowcore
// step 3: result will be null if there are no more rows.
return result
/**
* @see noputresultset#close
*/
public void close   throws standardexception
/* we'll let tablescanresultset track the time it takes to close up,
* so no timing here.
*/
super close
/* note: we can't set probevalues == null here because we may end
* up reopening this scan again later, in which case we'll need the
* list of probe values.
*/
/**
* figure out whether or not we can (re-)position the scan
* controller based on the next value in probevalues.  this
* will return false when we have exhausted the probe list
* (i.e. when we've gone through all of the values).
*/
private boolean moreinlistvals
return  probevalindex < probevalues length
/**
* return the next non-duplicate value from the probe list.
* assumption is that the list is sorted in ascending order
* and that probevalindex is the index of the next value.
* if we've exhausted the probe list then just return null.
*/
private datavaluedescriptor getnextprobevalue
throws standardexception
int ctr   probevalindex
// skip over duplicate values.
while   ctr > 0      ctr < probevalues length
probevalues equals probevalues
ctr
probevalindex   ctr
if  probevalindex < probevalues length
return probevalues
return null