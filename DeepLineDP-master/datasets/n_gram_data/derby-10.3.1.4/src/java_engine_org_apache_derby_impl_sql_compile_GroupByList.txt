/*
derby - class org.apache.derby.impl.sql.compile.groupbylist
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi reference sqlstate
import org apache derby iapi reference limits
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi util reusefactory
import java util vector
/**
* a groupbylist represents the list of expressions in a group by clause in
* a select statement.
*
*/
public class groupbylist extends orderedcolumnlist
int		numgroupingcolsadded   0
/**
add a column to the list
@param column	the column to add to the list
*/
public void addgroupbycolumn groupbycolumn column
addelement column
/**
get a column from the list
@param position	the column to get from the list
*/
public groupbycolumn getgroupbycolumn int position
if  sanitymanager debug
sanitymanager assert position > 0    position < size
position
size
return  groupbycolumn  elementat position
/**
print the list.
@param depth		the depth at which to indent the sub-nodes
*/
public void printsubnodes int depth
if  sanitymanager debug
for  int index   0  index < size    index
groupbycolumn  elementat index    treeprint depth
/**
* get the number of grouping columns that need to be added to the select list.
*
* @return int	the number of grouping columns that need to be added to
*				the select list.
*/
public int getnumneedtoaddgroupingcols
return numgroupingcolsadded
/**
*  bind the group by list.  verify:
*		o  number of grouping columns matches number of non-aggregates in
*		   select's rcl.
*		o  names in the group by list are unique
*		o  names of grouping columns match names of non-aggregate
*		   expressions in select's rcl.
*
* @param select		the selectnode
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @exception standardexception		thrown on error
*/
public void bindgroupbycolumns selectnode select
vector	aggregatevector
throws standardexception
fromlist		 fromlist   select getfromlist
resultcolumnlist selectrcl   select getresultcolumns
subquerylist	 dummysubquerylist
subquerylist  getnodefactory   getnode
c_nodetypes subquery_list
getcontextmanager
int				 numcolsaddedhere   0
int				 size   size
/* only 32677 columns allowed in group by clause */
if  size > limits db2_max_elements_in_group_by
throw standardexception newexception sqlstate lang_too_many_elements
/* bind the grouping column */
for  int index   0  index < size  index
groupbycolumn groupbycol    groupbycolumn  elementat index
groupbycol bindexpression fromlist
dummysubquerylist  aggregatevector
int				rclsize   selectrcl size
for  int index   0  index < size  index
boolean				matchfound   false
groupbycolumn		groupingcol    groupbycolumn  elementat index
/* verify that this entry in the group by list matches a
* grouping column in the select list.
*/
for  int inner   0  inner < rclsize  inner
resultcolumn selectlistrc    resultcolumn  selectrcl elementat inner
if    selectlistrc getexpression   instanceof columnreference
continue
columnreference selectlistcr    columnreference  selectlistrc getexpression
if  selectlistcr isequivalent groupingcol getcolumnexpression
/* column positions for grouping columns are 0-based */
groupingcol setcolumnposition inner   1
/* mark the rc in the select list as a grouping column */
selectlistrc markasgroupingcolumn
matchfound   true
break
/* if no match found in the select list, then add a matching
* resultcolumn/columnreference pair to the selectnode's rcl.
*/
if    matchfound
groupingcol getcolumnexpression   instanceof columnreference
// only add matching columns for column references not
// expressions yet. see derby-883 for details.
resultcolumn newrc
/* get a new resultcolumn */
newrc    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
groupingcol getcolumnname
groupingcol getcolumnexpression   getclone
getcontextmanager
newrc setvirtualcolumnid selectrcl size     1
newrc markgenerated
newrc markasgroupingcolumn
/* add the new rc/cr to the rcl */
selectrcl addelement newrc
/* set the columnposition in the groupbycolumn, now that it
* has a matching entry in the select list.
*/
groupingcol setcolumnposition selectrcl size
// a new hidden or generated column is added to this rcl
// i.e. that the size() of the rcl != visiblesize().
// error checking done later should be aware of this
// special case.
selectrcl setcountmismatchallowed true
/*
** track the number of columns that we have added
** in this routine.  we track this separately
** than the total number of columns added by this
** object (numgroupingcolsadded) because we
** might be bound (though not gagged) more than
** once (in which case numgroupingcolsadded will
** already be set).
*/
numcolsaddedhere
/* verify that no subqueries got added to the dummy list */
if  sanitymanager debug
sanitymanager assert dummysubquerylist size      0
numgroupingcolsadded   numcolsaddedhere
/**
* find the matching grouping column if any for the given expression
*
* @param node an expression for which we are trying to find a match
* in the group by list.
*
* @return the matching groupbycolumn if one exists, null otherwise.
*
* @throws standardexception
*/
public groupbycolumn findgroupingcolumn valuenode node
throws standardexception
int sz   size
for  int i   0  i < sz  i
groupbycolumn gbc    groupbycolumn elementat i
if  gbc getcolumnexpression   isequivalent node
return gbc
return null
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @exception standardexception			thrown on error
*/
public void remapcolumnreferencestoexpressions   throws standardexception
groupbycolumn	gbc
int				size   size
/* this method is called when flattening a fromtable.  we should
* not be flattening a fromtable if the underlying expression that
* will get returned out, after chopping out the redundant resultcolumns,
* is not a columnreference.  (see assert below.)
*/
for  int index   0  index < size  index
valuenode	retvn
gbc    groupbycolumn  elementat index
retvn   gbc getcolumnexpression   remapcolumnreferencestoexpressions
if  sanitymanager debug
sanitymanager assert retvn instanceof columnreference
retvn getclass   getname
gbc setcolumnexpression retvn
/**
* print it out, baby
*/
public string tostring
if  sanitymanager debug
stringbuffer	buf   new stringbuffer
for  int index   0  index < size    index
groupbycolumn	groupingcol    groupbycolumn  elementat index
buf append groupingcol tostring
return buf tostring
else
return
public void preprocess
int numtables  fromlist fromlist  subquerylist wheresubquerys
predicatelist wherepredicates  throws standardexception
for  int index   0  index < size    index
groupbycolumn	groupingcol    groupbycolumn  elementat index
groupingcol setcolumnexpression
groupingcol getcolumnexpression   preprocess
numtables  fromlist  wheresubquerys  wherepredicates