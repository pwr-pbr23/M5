/*
derby - class org.apache.derby.impl.sql.compile.tableelementlist
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types stringdatavalue
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql depend providerinfo
import org apache derby iapi sql depend providerlist
import org apache derby iapi reference sqlstate
import org apache derby impl sql execute columninfo
import org apache derby impl sql execute constraintinfo
import org apache derby impl sql execute constraintconstantaction
import org apache derby impl sql execute indexconstantaction
import	org apache derby iapi sql dictionary constraintdescriptorlist
import org apache derby iapi sql dictionary columndescriptor
import org apache derby catalog uuid
import java util hashtable
import java util vector
/**
* a tableelementlist represents the list of columns and other table elements
* such as constraints in a create table or alter table statement.
*
*/
public class tableelementlist extends querytreenodevector
private int				numcolumns
private tabledescriptor td
/**
* add a tableelementnode to this tableelementlist
*
* @param tableelement	the tableelementnode to add to this list
*/
public void addtableelement tableelementnode tableelement
addelement tableelement
if   tableelement instanceof columndefinitionnode
tableelement getelementtype      tableelementnode at_drop_column
numcolumns
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
stringbuffer	buffer   new stringbuffer
for  int index   0  index < size    index
buffer append elementat index  tostring    append
return buffer tostring
else
return
/**
* use the passed schema descriptor's collation type to set the collation
* of the character string types in create table node
* @param sd
*/
void setcollationtypesoncharacterstringcolumns schemadescriptor sd
int			size   size
int collationtype   sd getcollationtype
for  int index   0  index < size  index
tableelementnode tableelement    tableelementnode  elementat index
if  tableelement instanceof columndefinitionnode
columndefinitionnode cdn    columndefinitionnode  elementat index
if  cdn getdatatypeservices   gettypeid   isstringtypeid
cdn getdatatypeservices   setcollationtype collationtype
cdn getdatatypeservices   setcollationderivation stringdatavalue collation_derivation_implicit
/**
* validate this tableelementlist.  this includes checking for
* duplicate columns names, and checking that user types really exist.
*
* @param ddlstmt	ddlstatementnode which contains this list
* @param dd		datadictionary to use
* @param td		tabledescriptor for table, if existing table.
*
* @exception standardexception		thrown on error
*/
void validate ddlstatementnode ddlstmt
datadictionary dd
tabledescriptor td
throws standardexception
this td   td
int numautocols   0
int			size   size
hashtable	columnht   new hashtable size   2   float   999
hashtable	constraintht   new hashtable size   2   float   999
//all the primary key/unique key constraints for this table
vector constraintsvector   new vector
//special case for alter table (td is not null in case of alter table)
if  td    null
//in case of alter table, get the already existing primary key and unique
//key constraints for this table. and then we will compare them with  new
//primary key/unique key constraint column lists.
constraintdescriptorlist cdl   dd getconstraintdescriptors td
constraintdescriptor cd
if  cdl    null    table does have some pre existing constraints defined on it
for  int i 0  i<cdl size   i
cd   cdl elementat i
//if the constraint type is not primary key or unique key, ignore it.
if  cd getconstrainttype      datadictionary primarykey_constraint
cd getconstrainttype      datadictionary unique_constraint
constraintsvector addelement cd
int tabletype   tabledescriptor base_table_type
if  ddlstmt instanceof createtablenode
tabletype     createtablenode ddlstmt  tabletype
for  int index   0  index < size  index
tableelementnode tableelement    tableelementnode  elementat index
if  tableelement instanceof columndefinitionnode
columndefinitionnode cdn    columndefinitionnode  elementat index
if  tabletype    tabledescriptor global_temporary_table_type
cdn getdatatypeservices   gettypeid   islongconcatabletypeid
cdn getdatatypeservices   gettypeid   isuserdefinedtypeid
throw standardexception newexception sqlstate lang_long_data_type_not_allowed  cdn getcolumnname
checkforduplicatecolumns ddlstmt  columnht  cdn getcolumnname
cdn checkusertype td
cdn bindandvalidatedefault dd  td
cdn validateautoincrement dd  td  tabletype
if  tableelement instanceof modifycolumnnode
modifycolumnnode mcdn    modifycolumnnode cdn
mcdn checkexistingconstraints td
mcdn useexistingcollation td
else if  cdn isautoincrementcolumn
numautocols
else if  tableelement getelementtype      tableelementnode at_drop_column
string colname   tableelement getname
if  td getcolumndescriptor colname     null
throw standardexception newexception
sqlstate lang_column_not_found_in_table
colname
td getqualifiedname
break
/* the rest of this method deals with validating constraints */
if     tableelement hasconstraint
continue
constraintdefinitionnode cdn    constraintdefinitionnode  tableelement
cdn bind ddlstmt  dd
//if constraint is primary key or unique key, add it to the vector
if  cdn getconstrainttype      datadictionary primarykey_constraint
cdn getconstrainttype      datadictionary unique_constraint
/* in case of create table, the vector can have only constraintdefinitionnode
* elements. in case of alter table, it can have both constraintdefinitionnode
* (for new constraints) and constraintdescriptor(for pre-existing constraints).
*/
object destconstraint
string destname   null
string destcolumnnames   null
for  int i 0  i<constraintsvector size   i
destconstraint   constraintsvector elementat i
if  destconstraint instanceof constraintdefinitionnode
constraintdefinitionnode destcdn    constraintdefinitionnode destconstraint
destname   destcdn getconstraintmoniker
destcolumnnames   destcdn getcolumnlist   getcolumnnames
else if  destconstraint instanceof constraintdescriptor
//will come here only for pre-existing constraints in case of alter table
constraintdescriptor destcd    constraintdescriptor destconstraint
destname   destcd getconstraintname
destcolumnnames   destcd getcolumndescriptors   getcolumnnames
//check if there are multiple constraints with same set of columns
if  columnsmatch cdn getcolumnlist   getcolumnnames    destcolumnnames
throw standardexception newexception sqlstate lang_multiple_constraints_with_same_columns
cdn getconstraintmoniker    destname
constraintsvector addelement cdn
/* make sure that there are no duplicate constraint names in the list */
if  cdn instanceof constraintdefinitionnode
checkforduplicateconstraintnames ddlstmt  constraintht  cdn getconstraintmoniker
/* make sure that the constraint we are trying to drop exists */
if  cdn getconstrainttype      datadictionary drop_constraint
/*
** if no schema descriptor, then must be an invalid
** schema name.
*/
string dropconstraintname   cdn getconstraintmoniker
if  dropconstraintname    null
string dropschemaname   cdn getdropschemaname
schemadescriptor sd   dropschemaname    null ? td getschemadescriptor
getschemadescriptor dropschemaname
constraintdescriptor cd
dd getconstraintdescriptorbyname
td  sd  dropconstraintname
false
if  cd    null
throw standardexception newexception sqlstate lang_drop_non_existent_constraint
sd getschemaname        dropconstraintname
td getqualifiedname
/* statement is dependendent on the constraintdescriptor */
getcompilercontext   createdependency cd
if  cdn hasprimarykeyconstraint
// for primary key, check that columns are unique
verifyuniquecolumnlist ddlstmt  cdn
if  td    null
// in create table so set primary key columns to not null
setcolumnlisttonotnull cdn
else
// in alter table so raise error if any columns are nullable
checkfornullcolumns cdn  td
else if  cdn hasuniquekeyconstraint
// for unique, check that columns are unique and not null
verifyuniquecolumnlist ddlstmt  cdn
checkfornullcolumns cdn  td
else if  cdn hasforeignkeyconstraint
// for foreign key, check that columns are unique
verifyuniquecolumnlist ddlstmt  cdn
/* can have only one autoincrement column in db2 mode */
if  numautocols > 1
throw standardexception newexception sqlstate lang_multiple_autoincrement_columns
/**
* count the number of constraints of the specified type.
*
* @param constrainttype	the constraint type to search for.
*
* @return int	the number of constraints of the specified type.
*/
public int countconstraints int constrainttype
int	numconstraints   0
int size   size
for  int index   0  index < size  index
constraintdefinitionnode cdn
tableelementnode element    tableelementnode  elementat index
if     element instanceof constraintdefinitionnode
continue
cdn    constraintdefinitionnode  element
if  constrainttype    cdn getconstrainttype
numconstraints
return numconstraints
/**
* count the number of columns.
*
* @return int	the number of columns.
*/
public int countnumberofcolumns
return numcolumns
/**
* fill in the columninfo[] for this table element list.
*
* @param colinfos	the columninfo[] to be filled in.
*
* @return int		the number of constraints in the create table.
*/
public int gencolumninfos columninfo colinfos
int	numconstraints   0
int size   size
for  int index   0  index < size  index
if    tableelementnode  elementat index   getelementtype      tableelementnode at_drop_column
colinfos   new columninfo
tableelementnode  elementat index   getname
null  null  null  null  null
columninfo drop  0  0  0
break
if     elementat index  instanceof columndefinitionnode
if  sanitymanager debug
sanitymanager assert  elementat index  instanceof constraintdefinitionnode
/* remember how many constraints that we've seen */
numconstraints
continue
columndefinitionnode coldef    columndefinitionnode  elementat index
colinfos
new columninfo coldef getcolumnname
coldef getdatatypeservices
coldef getdefaultvalue
coldef getdefaultinfo
uuid  null
coldef getolddefaultuuid
coldef getaction
coldef isautoincrementcolumn   ?
coldef getautoincrementstart     0
coldef isautoincrementcolumn   ?
coldef getautoincrementincrement     0
coldef isautoincrementcolumn   ?
coldef getautoinc_create_or_modify_start_increment      1
/* remember how many constraints that we've seen */
if  coldef hasconstraint
numconstraints
return numconstraints
/**
* append goobered up resultcolumns to the table's rcl.
* this is useful for binding check constraints for create and alter table.
*
* @param table		the table in question.
*
* @exception standardexception		thrown on error
*/
public void appendnewcolumnstorcl frombasetable table
throws standardexception
int				 size   size
resultcolumnlist rcl   table getresultcolumns
tablename		 exposedname   table gettablename
for  int index   0  index < size  index
if  elementat index  instanceof columndefinitionnode
columndefinitionnode cdn    columndefinitionnode  elementat index
resultcolumn	resultcolumn
valuenode		valuenode
/* build a resultcolumn/basecolumnnode pair for the column */
valuenode    valuenode  getnodefactory   getnode
c_nodetypes base_column_node
cdn getcolumnname
exposedname
cdn getdatatypeservices
getcontextmanager
resultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
cdn getdatatypeservices
valuenode
getcontextmanager
resultcolumn setname cdn getcolumnname
rcl addelement resultcolumn
/**
* bind and validate all of the check constraints in this list against
* the specified fromlist.
*
* @param fromlist		the fromlist in question.
*
* @exception standardexception		thrown on error
*/
void bindandvalidatecheckconstraints fromlist fromlist
throws standardexception
compilercontext cc
frombasetable				table    frombasetable  fromlist elementat 0
int						  size   size
cc   getcompilercontext
vector aggregatevector   new vector
for  int index   0  index < size  index
constraintdefinitionnode cdn
tableelementnode element    tableelementnode  elementat index
valuenode	checktree
if     element instanceof constraintdefinitionnode
continue
cdn    constraintdefinitionnode  element
if  cdn getconstrainttype      datadictionary check_constraint
continue
checktree   cdn getcheckcondition
// bind the check condition
// verify that it evaluates to a boolean
final int previousreliability   cc getreliability
try
/* each check constraint can have its own set of dependencies.
* these dependencies need to be shared with the prepared
* statement as well.  we create a new auxiliary provider list
* for the check constraint, "push" it on the compiler context
* by swapping it with the current auxiliary provider list
* and the "pop" it when we're done by restoring the old
* auxiliary provider list.
*/
providerlist apl   new providerlist
providerlist prevapl   cc getcurrentauxiliaryproviderlist
cc setcurrentauxiliaryproviderlist apl
// tell the compiler context to only allow deterministic nodes
cc setreliability  compilercontext check_constraint
checktree   checktree bindexpression fromlist   subquerylist  null
aggregatevector
// no aggregates, please
if  aggregatevector size      0
throw standardexception newexception sqlstate lang_invalid_check_constraint  cdn getconstrainttext
checktree   checktree checkisboolean
cdn setcheckcondition checktree
/* save the apl off in the constraint node */
if  apl size   > 0
cdn setauxiliaryproviderlist apl
// restore the previous auxiliaryproviderlist
cc setcurrentauxiliaryproviderlist prevapl
finally
cc setreliability previousreliability
/* we have a valid check constraint, now build an array of
* 1-based columnids that the constraint references.
*/
resultcolumnlist rcl   table getresultcolumns
int		numreferenced   rcl countreferencedcolumns
int	checkcolumnreferences   new int
rcl recordcolumnreferences checkcolumnreferences  1
cdn setcheckcolumnreferences checkcolumnreferences
/* now we build a list with only the referenced columns and
* copy it to the cdn.  thus we can build the array of
* column names for the referenced columns during generate().
*/
resultcolumnlist refrcl
resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
rcl copyreferencedcolumnstonewlist refrcl
/* a column check constraint can only refer to that column. if this is a
* column constraint, we should have an rcl with that column
*/
if  cdn getcolumnlist      null
string colname     resultcolumn  cdn getcolumnlist   elementat 0    getname
if  numreferenced > 1
colname equals   resultcolumn  refrcl elementat 0    getname
throw standardexception newexception sqlstate lang_db2_invalid_check_constraint  colname
cdn setcolumnlist refrcl
/* clear the column references in the rcl so each check constraint
* starts with a clean list.
*/
rcl clearcolumnreferences
/**
* fill in the constraintconstantaction[] for this create/alter table.
*
* @param conactions	the constraintconstantaction[] to be filled in.
* @param tablename		the name of the table being created.
* @param tablesd		the schema for that table.
* @param dd	    	the datadictionary
*
* @exception standardexception		thrown on failure
*/
void genconstraintactions
constraintconstantaction conactions
string tablename
schemadescriptor tablesd
datadictionary dd
throws standardexception
int size   size
int conactionindex   0
for  int index   0  index < size  index
string	columnnames   null
tableelementnode ten    tableelementnode  elementat index
indexconstantaction indexaction   null
if    ten hasconstraint
continue
if  ten instanceof columndefinitionnode
continue
constraintdefinitionnode constraintdn    constraintdefinitionnode  ten
if  constraintdn getcolumnlist      null
columnnames   new string
constraintdn getcolumnlist   exportnames columnnames
int constrainttype   constraintdn getconstrainttype
string constrainttext   constraintdn getconstrainttext
/*
** if the constraint is not named (e.g.
** create table x (x int primary key)), then
** the constraintsd is the same as the table.
*/
string constraintname   constraintdn getconstraintmoniker
/* at execution time, we will generate a unique name for the backing
* index (for create constraint) and we will look up the conglomerate
* name (for drop constraint).
*/
if  constraintdn requiresbackingindex
indexaction   genindexaction constraintdn requiresuniqueindex
null  constraintdn
columnnames  true  tablesd  tablename
constrainttype  dd
if  constrainttype    datadictionary drop_constraint
conactions
getgenericconstantactionfactory
getdropconstraintconstantaction
constraintname
constraintdn getdropschemaname        fix
tablename
td getuuid
tablesd getschemaname
indexaction
constraintdn getdropbehavior
constraintdn getverifytype
else
providerlist apl   constraintdn getauxiliaryproviderlist
constraintinfo refinfo   null
providerinfo	providerinfos   null
if  constraintdn instanceof fkconstraintdefinitionnode
refinfo     fkconstraintdefinitionnode constraintdn  getreferencedconstraintinfo
/* create the providerinfos, if the constraint is dependent on any providers */
if  apl    null    apl size   > 0
/* get all the dependencies for the current statement and transfer
* them to this view.
*/
dependencymanager dm   dd getdependencymanager
providerinfos   dm getpersistentproviderinfos apl
else
providerinfos   new providerinfo
// system.out.println("table element list empty");
conactions
getgenericconstantactionfactory
getcreateconstraintconstantaction
constraintname
constrainttype
tablename
td    null  ? td getuuid      uuid  null
tablesd getschemaname
columnnames
indexaction
constrainttext
true  		   enabled
refinfo
providerinfos
//check if one array is same as another
private boolean columnsmatch string columnnames1  string columnnames2
int srccount  srcsize  destcount destsize
boolean match   true
if  columnnames1 length    columnnames2 length
return false
srcsize   columnnames1 length
destsize   columnnames2 length
for  srccount   0  srccount < srcsize  srccount
match   false
for  destcount   0  destcount < destsize  destcount
if  columnnames1 equals columnnames2
match   true
break
if  match    false
return false
return true
private indexconstantaction genindexaction
boolean	isunique
string indexname
constraintdefinitionnode cdn
string columnnames
boolean isconstraint
schemadescriptor sd
string tablename
int constrainttype
datadictionary dd
throws standardexception
if   indexname    null     indexname   cdn getbackingindexname dd
if  constrainttype    datadictionary drop_constraint
return	getgenericconstantactionfactory   getdropindexconstantaction

indexname
tablename
sd getschemaname
td getuuid
td getheapconglomerateid
else
boolean	isascending   new boolean
for  int i   0  i < isascending length  i
isascending   true
return	getgenericconstantactionfactory   getcreateindexconstantaction
isunique
indextype
sd getschemaname
indexname
tablename
td    null  ? td getuuid      uuid  null
columnnames
isascending
isconstraint
cdn getbackingindexuuid
cdn getproperties
/**
* check to make sure that there are no duplicate column names
* in the list.  (the comparison here is case sensitive.
* the work of converting column names that are not quoted
* identifiers to upper case is handled by the parser.)
* resolve: this check will also be performed by alter table.
*
* @param ddlstmt	ddlstatementnode which contains this list
* @param ht		hashtable for enforcing uniqueness.
* @param colname	column name to check for.
*
* @exception standardexception		thrown on error
*/
private void checkforduplicatecolumns ddlstatementnode ddlstmt
hashtable ht
string colname
throws standardexception
object object   ht put colname  colname
if  object    null
/* resolve - different error messages for create and alter table */
if  ddlstmt instanceof createtablenode
throw standardexception newexception sqlstate lang_duplicate_column_name_create  colname
/**
* check to make sure that there are no duplicate constraint names
* in the list.  (the comparison here is case sensitive.
* the work of converting column names that are not quoted
* identifiers to upper case is handled by the parser.)
* resolve: this check will also be performed by alter table.
*
* @param ddlstmt	ddlstatementnode which contains this list
*
* @exception standardexception		thrown on error
*/
private void checkforduplicateconstraintnames ddlstatementnode ddlstmt
hashtable ht
string constraintname
throws standardexception
if  constraintname    null
return
object object   ht put constraintname  constraintname
if  object    null
/* resolve - different error messages for create and alter table */
if  ddlstmt instanceof createtablenode
/* resolve - new error message */
throw standardexception newexception sqlstate lang_duplicate_constraint_name_create
constraintname
/**
* verify that a primary/unique table constraint has a valid column list.
* (all columns in table and no duplicates.)
*
* @param ddlstmt	the outer ddlstatementnode
* @param cdn		the constraintdefinitionnode
*
* @exception	standardexception	thrown if the column list is invalid
*/
private void verifyuniquecolumnlist ddlstatementnode ddlstmt
constraintdefinitionnode cdn
throws standardexception
string invalidcolname
/* verify that every column in the list appears in the table's list of columns */
if  ddlstmt instanceof createtablenode
invalidcolname   cdn getcolumnlist   verifycreateconstraintcolumnlist this
if  invalidcolname    null
throw standardexception newexception sqlstate lang_invalid_create_constraint_column_list
ddlstmt getrelativename
invalidcolname
else
/* resolve - alter table will need to get table descriptor */
/* check the uniqueness of the column names within the list */
invalidcolname   cdn getcolumnlist   verifyuniquenames false
if  invalidcolname    null
throw standardexception newexception sqlstate lang_duplicate_constraint_column_name  invalidcolname
/**
* set all columns in that appear in a primary key constraint in a create table statement to not null.
*
* @param cdn		the constraintdefinitionnode for a primary key constraint
*/
private void setcolumnlisttonotnull constraintdefinitionnode cdn
resultcolumnlist rcl   cdn getcolumnlist
int rclsize   rcl size
for  int index   0  index < rclsize  index
string colname     resultcolumn  rcl elementat index   getname
datatypedescriptor dtd   getcolumndatatypedescriptor colname
dtd setnullability false
private void checkfornullcolumns constraintdefinitionnode cdn  tabledescriptor td  throws standardexception
resultcolumnlist rcl   cdn getcolumnlist
int rclsize   rcl size
for  int index   0  index < rclsize  index
string colname     resultcolumn  rcl elementat index   getname
datatypedescriptor dtd
if  td    null
dtd   getcolumndatatypedescriptor colname
else
dtd   getcolumndatatypedescriptor colname  td
// todo dtd may be null if the column does not exist, we should check that first
if  dtd    null    dtd isnullable
throw standardexception newexception sqlstate lang_db2_add_unique_or_primary_key_on_null_cols  colname
private datatypedescriptor getcolumndatatypedescriptor string colname
int size   size
for  int index   0  index < size  index
tableelementnode tableelement    tableelementnode  elementat index
if  tableelement instanceof columndefinitionnode
columndefinitionnode cdn    columndefinitionnode  tableelement
if  colname equals cdn getcolumnname
return cdn getdatatypeservices
return null
private datatypedescriptor getcolumndatatypedescriptor string colname  tabledescriptor td
// check existing columns
columndescriptor cd   td getcolumndescriptor colname
if  cd    null
return cd gettype
// check for new columns
return getcolumndatatypedescriptor colname
/**
* determine whether or not the parameter matches a column name in this list.
*
* @param colname	the column name to search for.
*
* @return boolean  whether or not a match is found.
*/
public boolean containscolumnname string colname
int size   size
for  int index   0  index < size  index
tableelementnode tableelement    tableelementnode  elementat index
if  tableelement instanceof columndefinitionnode
if  colname equals   columndefinitionnode  tableelement  getname
return true
return false