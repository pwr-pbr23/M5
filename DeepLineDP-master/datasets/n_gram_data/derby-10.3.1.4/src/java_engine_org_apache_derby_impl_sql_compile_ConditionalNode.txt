/*
derby - class org.apache.derby.impl.sql.compile.conditionalnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi types typeid
import org apache derby iapi types booleandatavalue
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluefactory
import org apache derby iapi reference sqlstate
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi services loader classinspector
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi reference classname
import org apache derby iapi util jbitset
import org apache derby iapi services classfile vmopcode
import java util vector
/**
* a conditionalnode represents an if/then/else operator with a single
* boolean expression on the "left" of the operator and a list of expressions on
* the "right". this is used to represent the java conditional (aka immediate if).
*
*/
public class conditionalnode extends valuenode
valuenode		testcondition
valuenodelist	thenelselist
//true means we are here for nullif(v1,v2), false means we are here for following
//case when booleanexpression then thenexpression else elseexpression end
boolean	thisisnullifnode
/**
* initializer for a conditionalnode
*
* @param testcondition		the boolean test condition
* @param thenelselist		valuenodelist with then and else expressions
*/
public void init object testcondition  object thenelselist  object thisisnullifnode
this testcondition    valuenode  testcondition
this thenelselist    valuenodelist  thenelselist
this thisisnullifnode     boolean  thisisnullifnode  booleanvalue
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  testcondition    null
printlabel depth
testcondition treeprint depth   1
if  thenelselist    null
printlabel depth
thenelselist treeprint depth   1
/**
* checks if the provided node is a castnode.
*
* @param node	the node to check.
* @return 		true if this node is a castnode, false otherwise.
*/
private boolean iscastnode valuenode node
if  node getnodetype      c_nodetypes cast_node
return true
else
return false
/**
* checks if the provided castnode is cast to a sql char type.
*
* @param node	the castnode to check.
* @return		true if this castnode's target type is char,
*              false otherwise.
* @throws standardexception
*/
private boolean iscasttochar valuenode node  throws standardexception
if  node gettypeservices   gettypename   equals typeid char_name
return true
else
return false
/**
* checks to see if the provided node represents
* a parsing of an sql null.
*
* @param node  the node to check.
* @return      true if this node represents a sql null, false otherwise.
*/
private boolean isnullnode valuenode node
if  iscastnode node
castnode node  castoperand instanceof untypednullconstantnode
return true
else
return false
/**
* checks to see if the provided node represents
* a conditionalnode.
*
* @param node    the node to check.
* @return        true if this node is a condtionalnode, false otherwise.
*/
private boolean isconditionalnode valuenode node
if  node getnodetype      c_nodetypes conditional_node
return true
else
return false
/**
* checks to see if oldtype should be casted to the newtype.
* returns true if the two datatypedescriptors have different
* typeid's or if the oldtype is null.  returns false if the newtype is
* null or if the two types are identical.
*
* @param newtype    the type to cast oldtype to if they're different.
* @param oldtype    the type that should be casted to the newtype if
*                   they're different.
* @return           false if the newtype is null or they have the same
*                   typeid, true otherwise.
*/
private boolean shouldcast datatypedescriptor newtype
datatypedescriptor oldtype  throws standardexception
if   newtype    null
oldtype    null
oldtype gettypeid   equals newtype gettypeid
return true
else
return false
/**
* this method is a 'prebind.'  we need to determine what the types of
* the nodes are going to be before we can set all the sqlparsed null's
* to the appropriate type.  after we bind, however, we want to ignore
* the sqlparsed null's which will be bound to char.  also, we might
* have to delve into the case expression tree.
*
* @param thenelselist    the thenelselist (recursive method)
* @param fromlist        the fromlist (required for column references).
*
* @exception             standardexception thrown on error.
*/
private datatypedescriptor findtype valuenodelist thenelselist
fromlist fromlist  throws standardexception
/* we need to "prebind" because we want the types.  provide
* dummy subquerylist and aggreatelist (we don't care)
*/
valuenode thennode
valuenode thenelselist elementat 0   bindexpression
fromlist  new subquerylist    new vector
valuenode elsenode
valuenode thenelselist elementat 1   bindexpression
fromlist  new subquerylist    new vector
datatypedescriptor thentype   thennode gettypeservices
datatypedescriptor elsetype   elsenode gettypeservices
datatypedescriptor thetype   null
/* if it's not a cast node or a conditional node, then we'll
* use this type.
*/
if   thentype    null      iscastnode thennode
isconditionalnode thennode
return thentype
/* if it's not cast to char it isn't a sql parsed null, so
* we can use it.
*/
if  iscastnode thennode      iscasttochar thennode
return thennode gettypeservices
/* if we get here, we can't use the then node type, so we'll
* use the else node type
*/
if   elsetype    null      iscastnode elsenode
isconditionalnode elsenode
return elsetype
if  iscastnode elsenode      iscasttochar elsenode
return elsenode gettypeservices
/* if we get here, it means that we've got a conditional and a
* sql parsed null or two conditionals.
*/
if  isconditionalnode thennode
thetype
findtype   conditionalnode thennode  thenelselist  fromlist
if  thetype    null  return thetype
// two conditionals and the first one was all sql parsed nulls.
if  isconditionalnode elsenode
thetype
findtype   conditionalnode elsenode  thenelselist  fromlist
if  thetype    null  return thetype
return null
/**
* this recursive method will hunt through the valuenodelist thenelselist
* looking for sql null's.  if it finds any, it casts them to the provided
* casttype.
*
* @param thenelselist    the thenelselist to update.
* @param casttype        the type to cast sql parsed null's too.
*
* @exception             standardexception thrown on error.
*/
private void recastnullnodes valuenodelist thenelselist
datatypedescriptor casttype
throws standardexception
// don't do anything if we couldn't find a casttype.
if  casttype    null  return
valuenode thennode    valuenode thenelselist elementat 0
valuenode elsenode    valuenode thenelselist elementat 1
// first check if the "then" node is null
if  isnullnode thennode
shouldcast casttype  thennode gettypeservices
thenelselist setelementat recastnullnode thennode  casttype   0
// otherwise recurse on thennode, but only if it's a conditional
else if  isconditionalnode thennode
recastnullnodes   conditionalnode thennode  thenelselist
casttype
// lastly, check if the "else" node is null
if  isnullnode elsenode
shouldcast casttype  elsenode gettypeservices
thenelselist setelementat recastnullnode elsenode  casttype   1
// otherwise recurse on elsenode, but only if it's a conditional
else if  isconditionalnode elsenode
recastnullnodes   conditionalnode elsenode  thenelselist
casttype
/**
* recastnullnode casts the nodetocast node to the typetouse.
*
* recastnullnode is called by recastnullnodes.  it is called when the
* nodetocast is an untypednullconstantnode that's been cast by the
* sqlparser to a char.  the node needs to be recasted to the same type
* of the other nodes in order to prevent the type compatibility error
* 42x89 from occuring.  sql standard requires that:
*
*  values case when 1=2 then 3 else null end
*
* returns null and not an error message.
*
* @param nodetocast    the node that represents a sql null value.
* @param typetouse     the type which the nodetocast should be
*                      recasted too.
*
* @exception standardexception thrown on error.
*/
private querytreenode recastnullnode valuenode nodetocast
datatypedescriptor typetouse  throws standardexception
querytreenode cast   getnodefactory   getnode
c_nodetypes cast_node
castnode nodetocast  castoperand
typetouse
getcontextmanager
return cast
/**
* bind this expression.  this means binding the sub-expressions,
* as well as figuring out what the return type is for this expression.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
testcondition   testcondition bindexpression fromlist
subquerylist
aggregatevector
if  thisisnullifnode
//for nullif(v1,v2), parser binds thenelselist.elementat(0) to untyped null
//at bind phase, we should bind it to the type of v1 since now we know the
//type of v1
binarycomparisonoperatornode bcon    binarycomparisonoperatornode testcondition
/*
* nullif(v1,v2) is equivalent to:
*
*    case when v1=v2 then null else v1 end
*
* the untyped null should have a data type descriptor
* that allows its value to be nullable.
*/
querytreenode cast   getnodefactory   getnode
c_nodetypes cast_node
thenelselist elementat 0
bcon getleftoperand   gettypeservices   getnullabilitytype true
getcontextmanager
thenelselist setelementat cast 0
else
recastnullnodes thenelselist  findtype thenelselist  fromlist
thenelselist bindexpression fromlist
subquerylist
aggregatevector
// can't get the then and else expressions until after they've been bound
valuenode thenexpression    valuenode  thenelselist elementat 0
valuenode elseexpression    valuenode  thenelselist elementat 1
/* testcondition must be a boolean expression.
* if it is a ? parameter on the left, then set type to boolean,
* otherwise verify that the result type is boolean.
*/
if  testcondition requirestypefromcontext
testcondition settype
new datatypedescriptor
typeid boolean_id
true
else
if     testcondition gettypeservices   gettypeid   equals
typeid boolean_id
throw standardexception newexception sqlstate lang_conditional_non_boolean
/* we can't determine the type for the result expression if
* all result expressions are ?s.
*/
if  thenelselist containsallparameternodes
throw standardexception newexception sqlstate lang_all_result_expressions_params
else if  thenelselist containsparameternode
/* set the parameter's type to be the same as the other element in
* the list
*/
datatypedescriptor dts
valuenode typeexpression
if  thenexpression requirestypefromcontext
dts   elseexpression gettypeservices
else
dts   thenexpression gettypeservices
thenelselist setparameterdescriptor dts
/* the then and else expressions must be type compatible */
classinspector cu   getclassfactory   getclassinspector
/*
** if it is comparable, then we are ok.  note that we
** could in fact allow any expressions that are convertible()
** since we are going to generate a cast node, but that might
** be confusing to users...
*/
// resolve djdoi - this looks wrong, why should the then expression
// be comparable to the then expression ??
if    thenexpression gettypeservices
comparable elseexpression gettypeservices    false  getclassfactory
cu assignableto thenexpression gettypeid   getcorrespondingjavatypename
elseexpression gettypeid   getcorrespondingjavatypename
cu assignableto elseexpression gettypeid   getcorrespondingjavatypename
thenexpression gettypeid   getcorrespondingjavatypename
throw standardexception newexception sqlstate lang_not_type_compatible
thenexpression gettypeid   getsqltypename
elseexpression gettypeid   getsqltypename
/*
** set the result type of this conditional to be the dominant type
** of the result expressions.
*/
settype thenelselist getdominanttypeservices
/*
** generate a castnode if necessary and
** stick it over the original expression
*/
typeid condtypeid   gettypeid
typeid thentypeid     valuenode  thenelselist elementat 0   gettypeid
typeid elsetypeid     valuenode  thenelselist elementat 1   gettypeid
/* need to generate conversion if thenexpr or elseexpr is not of
* dominant type.  (at least 1 of them must be of the dominant type.)
*/
if  thentypeid typeprecedence      condtypeid typeprecedence
valuenode cast    valuenode  getnodefactory   getnode
c_nodetypes cast_node
thenelselist elementat 0
gettypeservices   	   cast to dominant type
getcontextmanager
cast   cast bindexpression fromlist
subquerylist
aggregatevector
thenelselist setelementat cast  0
else if  elsetypeid typeprecedence      condtypeid typeprecedence
valuenode cast    valuenode  getnodefactory   getnode
c_nodetypes cast_node
thenelselist elementat 1
gettypeservices   	   cast to dominant type
getcontextmanager
cast   cast bindexpression fromlist
subquerylist
aggregatevector
thenelselist setelementat cast  1
return this
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
testcondition   testcondition preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
thenelselist preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
return this
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode.
* @exception standardexception			thrown on error
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
throws standardexception
/* we stop here when only considering simple predicates
*  as we don't consider conditional operators when looking
* for null invariant predicates.
*/
if  simplepredsonly
return false
boolean pushable
pushable   testcondition categorize referencedtabs  simplepredsonly
pushable    thenelselist categorize referencedtabs  simplepredsonly     pushable
return pushable
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @return valuenode			the remapped expression tree.
*
* @exception standardexception			thrown on error
*/
public valuenode remapcolumnreferencestoexpressions
throws standardexception
testcondition   testcondition remapcolumnreferencestoexpressions
thenelselist   thenelselist remapcolumnreferencestoexpressions
return this
/**
* return whether or not this expression tree represents a constant expression.
*
* @return	whether or not this expression tree represents a constant expression.
*/
public boolean isconstantexpression
return  testcondition isconstantexpression
thenelselist isconstantexpression
/** @see valuenode#constantexpression */
public boolean constantexpression predicatelist whereclause
return  testcondition constantexpression whereclause
thenelselist constantexpression whereclause
/**
* eliminate notnodes in the current query block.  we traverse the tree,
* inverting ands and ors and eliminating nots as we go.  we stop at
* comparisonoperators and boolean expressions.  we invert
* comparisonoperators and replace boolean expressions with
* boolean expression = false.
* note: since we do not recurse under comparisonoperators, there
* still could be notnodes left in the tree.
*
* @param	undernotnode		whether or not we are under a notnode.
*
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
valuenode eliminatenots boolean undernotnode
throws standardexception
valuenode thenexpression
valuenode elseexpression
if    undernotnode
return this
/* simply swap the then and else expressions */
thenexpression    valuenode  thenelselist elementat 0
elseexpression    valuenode  thenelselist elementat 1
thenelselist setelementat elseexpression  0
thenelselist setelementat thenexpression  1
return this
/**
* do code generation for this conditional expression.
*
* @param acb	the expressionclassbuilder for the class we're generating
* @param mb	the method the expression will go into
*
* @exception standardexception		thrown on error
*/
public void generateexpression expressionclassbuilder acb
methodbuilder mb
throws standardexception
testcondition generateexpression acb  mb
mb cast classname booleandatavalue
mb push true
mb callmethod vmopcode invokeinterface   string  null        1
mb conditionalif
valuenode  thenelselist elementat 0   generateexpression acb  mb
mb startelsecode
valuenode  thenelselist elementat 1   generateexpression acb  mb
mb completeconditional
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
visitable returnnode   v visit this
if  v skipchildren this
return returnnode
if  testcondition    null     v stoptraversal
testcondition    valuenode testcondition accept v
if  thenelselist    null     v stoptraversal
thenelselist    valuenodelist thenelselist accept v
return returnnode
/**
* {@inheritdoc}
*/
protected boolean isequivalent valuenode o  throws standardexception
if  issamenodetype o
conditionalnode other    conditionalnode o
if  thenelselist size      other thenelselist size
testcondition isequivalent other testcondition
int sz   thenelselist size
for  int i   0  i < sz  i
valuenode v1    valuenode thenelselist elementat i
valuenode v2    valuenode other thenelselist elementat i
if   v1 isequivalent v2
return false
return true
return false