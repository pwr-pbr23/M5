/*
derby - class org.apache.derby.impl.sql.genericstatement
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql
import java sql timestamp
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services loader generatedclass
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi sql preparedstatement
import org apache derby iapi sql statement
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile parser
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn statementcontext
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql execute executioncontext
import org apache derby impl sql compile statementnode
import org apache derby impl sql conn genericlanguageconnectioncontext
public class genericstatement
implements statement
// these fields define the identity of the statement
private final schemadescriptor compilationschema
private final string			statementtext
private final boolean isforreadonly
private int                      prepareisolationlevel
private genericpreparedstatement preparedstmt
/**
* constructor for a statement given the text of the statement in a string
* @param compilationschema schema
* @param statementtext	the text of the statement
* @param isforreadonly if the statement is opened with level concur_read_only
*/
public genericstatement schemadescriptor compilationschema  string statementtext  boolean isforreadonly
this compilationschema   compilationschema
this statementtext   statementtext
this isforreadonly   isforreadonly
/*
* statement interface
*/
/* resolve: may need error checking, debugging code here */
public preparedstatement prepare languageconnectioncontext lcc  throws standardexception
/*
** note: don't reset state since this might be
** a recompilation of an already prepared statement.
*/
return prepminion lcc  true   object  null   schemadescriptor  null  false
public preparedstatement prepare languageconnectioncontext lcc  boolean formetadata  throws standardexception
/*
** note: don't reset state since this might be
** a recompilation of an already prepared statement.
*/
return prepminion lcc  true   object  null   schemadescriptor  null  formetadata
private preparedstatement prepminion languageconnectioncontext lcc  boolean cacheme  object paramdefaults
schemadescriptor spsschema  boolean internalsql
throws standardexception
long				begintime   0
long				parsetime   0
long				bindtime   0
long				optimizetime   0
long				generatetime   0
timestamp			begintimestamp   null
timestamp			endtimestamp   null
statementcontext	statementcontext   null
// verify it isn't already prepared...
// if it is, and is valid, simply return that tree.
// if it is invalid, we will recompile now.
if  preparedstmt    null
if  preparedstmt uptodate
return preparedstmt
// clear the optimizer trace from the last statement
if  lcc getoptimizertrace
lcc setoptimizertraceoutput getsource
begintime   getcurrenttimemillis lcc
/* begintimestamp only meaningful if begintime is meaningful.
* begintime is meaningful if statistics timing is on.
*/
if  begintime    0
begintimestamp   new timestamp begintime
/** set the prepare isolaton from the languageconnectioncontext now as
* we need to consider it in caching decisions
*/
prepareisolationlevel   lcc getprepareisolationlevel
/* a note on statement caching:
*
* a genericpreparedstatement (gps) is only added it to the cache if the
* parameter cacheme is set to true when the gps is created.
*
* earlier only cachestatement (cs) looked in the statement cache for a
* prepared statement when prepare was called. now the functionality
* of cs has been folded into genericstatement (gs). so we search the
* cache for an existing preparedstatement only when cacheme is true.
* i.e if the user calls prepare with cacheme set to true:
* then we
*         a) look for the prepared statement in the cache.
*         b) add the prepared statement to the cache.
*
* in cases where the statement cache has been disabled (by setting the
* relevant derby property) then the value of cacheme is irrelevant.
*/
boolean foundincache   false
if  preparedstmt    null
if  cacheme
preparedstmt    genericpreparedstatement   genericlanguageconnectioncontext lcc  lookupstatement this
if  preparedstmt    null
preparedstmt   new genericpreparedstatement this
else
foundincache   true
// if anyone else also has this prepared statement,
// we don't want them trying to compile with it while
// we are.  so, we synchronize on it and re-check
// its validity first.
// this is a no-op if and until there is a central
// cache of prepared statement objects...
synchronized  preparedstmt
for
if  foundincache
if  preparedstmt referencessessionschema
// cannot use this state since it is private to a connection.
// switch to a new statement.
foundincache   false
preparedstmt   new genericpreparedstatement this
break
// did it get updated while we waited for the lock on it?
if  preparedstmt uptodate
return preparedstmt
if   preparedstmt compilingstatement
break
try
preparedstmt wait
catch  interruptedexception ie
throw standardexception interrupt ie
preparedstmt compilingstatement   true
preparedstmt setactivationclass null
try
headerprintwriter istream   lcc getlogstatementtext   ? monitor getstream     null
/*
** for stored prepared statements, we want all
** errors, etc in the context of the underlying
** execute statement statement, so don't push/pop
** another statement context unless we don't have
** one.  we won't have one if it is an internal
** sps (e.g. jdbcmetadata).
*/
if   preparedstmt isstorable      lcc getstatementdepth      0
// since this is for compilation only, set atomic
// param to true and timeout param to 0
statementcontext   lcc pushstatementcontext true  isforreadonly  getsource
null  false  0l
/*
** resolve: we may ultimately wish to pass in
** whether we are a jdbc metadata query or not to
** get the compilercontext to make the createdependency()
** call a noop.
*/
compilercontext cc   lcc pushcompilercontext compilationschema
if  prepareisolationlevel
executioncontext unspecified_isolation_level
cc setscanisolationlevel prepareisolationlevel
// look for stored statements that are in a system schema
// and with a match compilation schema. if so, allow them
// to compile using internal sql constructs.
if  internalsql
spsschema    null      spsschema issystemschema
spsschema equals compilationschema
cc setreliability compilercontext internal_sql_legal
try
// statement logging if lcc.getlogstatementtext() is true
if  istream    null
string xactid   lcc gettransactionexecute   getactivestatetxidstring
istream printlnwithheader languageconnectioncontext xidstr
xactid
languageconnectioncontext lccstr
lcc getinstancenumber
languageconnectioncontext dbnamestr
lcc getdbname
languageconnectioncontext drdastr
lcc getdrdaid
getsource
parser p   cc getparser
cc setcurrentdependent preparedstmt
//only top level statements go through here, nested statement
//will invoke this method from other places
statementnode qt   p parsestatement statementtext  paramdefaults
parsetime   getcurrenttimemillis lcc
if  sanitymanager debug
if  sanitymanager debug_on
qt treeprint
if  sanitymanager debug_on
throw standardexception newexception sqlstate lang_stop_after_parsing
/*
** tell the data dictionary that we are about to do
** a bunch of "get" operations that must be consistent with
** each other.
*/
datadictionary datadictionary   lcc getdatadictionary
int ddmode   datadictionary    null ? 0   datadictionary startreading lcc
try
// start a nested transaction -- all locks acquired by bind
// and optimize will be released when we end the nested
// transaction.
lcc beginnestedtransaction true
qt bindstatement
bindtime   getcurrenttimemillis lcc
if  sanitymanager debug
if  sanitymanager debug_on
qt treeprint
if  sanitymanager debug_on
throw standardexception newexception sqlstate lang_stop_after_binding
//derby424 - in order to avoid caching select statements referencing
// any session schema objects (including statements referencing views
// in session schema), we need to do the session schema object check
// here.
//a specific eg for statement referencing a view in session schema
//create table t28a (c28 int)
//insert into t28a values (280),(281)
//create view session.t28v1 as select * from t28a
//select * from session.t28v1 should show contents of view and we
// should not cache this statement because a user can later define
// a global temporary table with the same name as the view name.
//following demonstrates that
//declare global temporary table session.t28v1(c21 int, c22 int) not
//     logged
//insert into session.t28v1 values (280,1),(281,2)
//select * from session.t28v1 should show contents of global temporary
//table and not the view.  since this select statement was not cached
// earlier, it will be compiled again and will go to global temporary
// table to fetch data. this plan will not be cached either because
// select statement is using session schema object.
//
//following if statement makes sure that if the statement is
// referencing session schema objects, then we do not want to cache it.
// we will remove the entry that was made into the cache for
//this statement at the beginning of the compile phase.
//the reason we do this check here rather than later in the compile
// phase is because for a view, later on, we loose the information that
// it was referencing session schema because the reference
//view gets replaced with the actual view definition. right after
// binding, we still have the information on the view and that is why
// we do the check here.
if  preparedstmt referencessessionschema qt
if  foundincache
genericlanguageconnectioncontext lcc  removestatement this
qt optimizestatement
optimizetime   getcurrenttimemillis lcc
// statement logging if lcc.getlogstatementtext() is true
if  istream    null
string xactid   lcc gettransactionexecute   getactivestatetxidstring
istream printlnwithheader languageconnectioncontext xidstr
xactid
languageconnectioncontext lccstr
lcc getinstancenumber
languageconnectioncontext dbnamestr
lcc getdbname
languageconnectioncontext drdastr
lcc getdrdaid
getsource
catch  standardexception se
lcc commitnestedtransaction
// statement logging if lcc.getlogstatementtext() is true
if  istream    null
string xactid   lcc gettransactionexecute   getactivestatetxidstring
istream printlnwithheader languageconnectioncontext xidstr
xactid
languageconnectioncontext lccstr
lcc getinstancenumber
languageconnectioncontext dbnamestr
lcc getdbname
languageconnectioncontext drdastr
lcc getdrdaid
getsource
throw se
finally
/* tell the data dictionary that we are done reading */
if  datadictionary    null
datadictionary donereading ddmode  lcc
/* we need to move the commit of nested sub-transaction
* after we mark ps valid, during compilation, we might need
* to get some lock to synchronize with another thread's ddl
* execution, in particular, the compilation of insert/update/
* delete vs. create index/constraint (see beetle 3976).  we
* can't release such lock until after we mark the ps valid.
* otherwise we would just erase the ddl's invalidation when
* we mark it valid.
*/
try		   put in try block  commit sub transaction if bad
if  sanitymanager debug
if  sanitymanager debug_on
qt treeprint
if  sanitymanager debug_on
throw standardexception newexception sqlstate lang_stop_after_optimizing
generatedclass ac   qt generate preparedstmt getbytecodesaver
generatetime   getcurrenttimemillis lcc
/* endtimestamp only meaningful if generatetime is meaningful.
* generatetime is meaningful if statistics timing is on.
*/
if  generatetime    0
endtimestamp   new timestamp generatetime
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception sqlstate lang_stop_after_generating
/*
copy over the compile-time created objects
to the prepared statement.  this always happens
at the end of a compile, so there is no need
to erase the previous entries on a re-compile --
this erases as it replaces.  set the activation
class in case it came from a storablepreparedstatement
*/
preparedstmt setconstantaction  qt makeconstantaction
preparedstmt setsavedobjects  cc getsavedobjects
preparedstmt setrequiredpermissionslist cc getrequiredpermissionslist
preparedstmt setactivationclass ac
preparedstmt setneedssavepoint qt needssavepoint
preparedstmt setcursorinfo  cursorinfo cc getcursorinfo
preparedstmt setisatomic qt isatomic
preparedstmt setexecutestatementnameandschema
qt executestatementname
qt executeschemaname
preparedstmt setspsname qt getspsname
preparedstmt completecompile qt
preparedstmt setcompiletimewarnings cc getwarnings
catch  standardexception e  	   hold it  throw it
lcc commitnestedtransaction
throw e
if  lcc getruntimestatisticsmode
preparedstmt setcompiletimemillis
parsetime   begintime    parse time
bindtime   parsetime    bind time
optimizetime   bindtime    optimize time
generatetime   optimizetime    generate time
getelapsedtimemillis begintime
begintimestamp
endtimestamp
finally    for block introduced by pushcompilercontext
lcc popcompilercontext  cc
catch  standardexception se
if  foundincache
genericlanguageconnectioncontext lcc  removestatement this
throw se
finally
synchronized  preparedstmt
preparedstmt compilingstatement   false
preparedstmt notifyall
lcc commitnestedtransaction
if  statementcontext    null
lcc popstatementcontext statementcontext  null
return preparedstmt
/**
* generates an execution plan given a set of named parameters.
* does so for a storable prepared statement.
*
* @param	paramdefaults		parameter defaults
*
* @return a preparedstatement that allows execution of the execution
*	   plan.
* @exception standardexception	thrown if this is an
*	   execution-only version of the module (the prepare() method
*	   relies on compilation).
*/
public	preparedstatement preparestorable
languageconnectioncontext lcc
preparedstatement ps
object			paramdefaults
schemadescriptor	spsschema
boolean internalsql
throws standardexception
if  ps    null
ps   new genericstorablepreparedstatement this
else
genericpreparedstatement  ps  statement   this
this preparedstmt    genericpreparedstatement  ps
return prepminion lcc  false  paramdefaults  spsschema  internalsql
public string getsource
return statementtext
public string getcompilationschema
return compilationschema getdescriptorname
private static long getcurrenttimemillis languageconnectioncontext lcc
if  lcc getstatisticstiming
return system currenttimemillis
else
return 0
private static long getelapsedtimemillis long begintime
if  begintime    0
return system currenttimemillis     begintime
else
return 0
/*
** identity
*/
public boolean equals object other
if  other instanceof genericstatement
genericstatement os    genericstatement  other
return statementtext equals os statementtext     isforreadonly  os isforreadonly
compilationschema equals os compilationschema
prepareisolationlevel    os prepareisolationlevel
return false
public int hashcode
return statementtext hashcode