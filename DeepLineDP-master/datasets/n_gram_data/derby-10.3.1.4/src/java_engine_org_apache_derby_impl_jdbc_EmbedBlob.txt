/*
derby - class org.apache.derby.impl.jdbc.embedblob
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl jdbc
import org apache derby iapi reference sqlstate
import org apache derby iapi error standardexception
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types resetable
import org apache derby impl jdbc connectionchild
import org apache derby impl jdbc embedconnection
import org apache derby impl jdbc util
import org apache derby iapi services io newbytearrayinputstream
import org apache derby iapi services io inputstreamutil
import org apache derby iapi services io arrayinputstream
import java sql sqlexception
import java sql blob
import java io inputstream
import java io eofexception
import java io ioexception
/**
implements java.sql.blob (see the jdbc 2.0 spec).
a blob sits on top of a binary, varbinary or long varbinary column.
if its data is small (less than 1 page) it is a byte array taken from
the sqlbit class. if it is large (more than 1 page) it is a long column
in the database. the long column is accessed as a stream, and is implemented
in store as an overflowinputstream.  the resetable interface allows sending
messages to that stream to initialize itself (reopen its container and
lock the corresponding row) and to reset itself to the beginning.
note: in the case that the data is large, it is represented as a stream.
this stream is returned to the user in the getbinarystream() method.
this means that we have limited control over the state of the stream,
since the user can read bytes from it at any time.  thus all methods
here reset the stream to the beginning before doing any work.
caveat: the methods may not behave correctly if a user sets up
multiple threads and sucks data from the stream (returned from
getbinarystream()) at the same time as calling the blob methods.
<p><b>supports</b>
<ul>
<li> jsr169 - no subsetting for java.sql.blob
<li> jdbc 2.0
<li> jdbc 3.0 - no new dependencies on new jdbc 3.0 or jdk 1.4 classes,
new update methods can safely be added into implementation.
</ul>
*/
final class embedblob extends connectionchild implements blob
// blob is either materialized or still in stream
private boolean         materialized
private inputstream     mystream
/*
* length of the blob if known. set to -1 if
* the current length of the blob is not known.
*/
private long mylength    1
// note: cannot control position of the stream since user can do a getbinarystream
private long            pos
// this stream sits on top of mystream
private binarytorawstream bistream
// buffer for reading in blobs from a stream (long column)
// and trashing them (to set the position of the stream etc.)
private static int blob_buf_size   4096
private byte buf
//this boolean variable indicates whether the blob object has
//been invalidated by calling free() on it
private boolean isvalid   true
private lobstreamcontrol control
/**
* this constructor is used to create a empty blob object. it is used by the
* connection interface method createblob().
*
* @param blobbytes a byte array containing the data to be stores in the
*        blob.
*
* @param con the embedconnection object associated with this blob object.
*
*/
embedblob byte  blobbytes embedconnection con  throws sqlexception
super con
try
control   new lobstreamcontrol  con getdbname    blobbytes
materialized   true
//add entry in connection so it can be cleared
//when transaction is not valid
con addlobmapping  this
catch  ioexception e
throw util setstreamfailure  e
catch  standardexception se
throw util generatecssqlexception  se
/*
this constructor should only be called by embedresultset.getblob
*/
protected embedblob datavaluedescriptor dvd  embedconnection con
throws standardexception
super con
// if the underlying column is null, resultset.getblob will return null,
// never should get this far
if  sanitymanager debug
sanitymanager assert  dvd isnull
mystream   dvd getstream
if  mystream    null
materialized   true
// copy bytes into memory so that blob can live after result set
// is closed
byte dvdbytes   dvd getbytes
if  sanitymanager debug
sanitymanager assert dvdbytes    null
try
control   new lobstreamcontrol
getembedconnection   getdbname    dvdbytes
catch  sqlexception e
throw standardexception newexception  e getsqlstate
catch  ioexception e
throw standardexception newexception
sqlstate set_stream_failure  e
else
materialized   false
/*
we are expecting this stream to be a formatidinputstream with an
overflowinputstream inside. formatidinputstream implements
resetable. this should be the case when retrieving
data from a long column. however, sqlbit, which is the class
implementing the getstream() method for dvd.getstream(), does not
guarantee this for us
*/
if  sanitymanager debug
sanitymanager assert mystream instanceof resetable
//make mystream a position aware stream
mystream   new positionedstorestream  mystream
try
resetable  mystream  initstream
catch  standardexception se
if  se getmessageid   equals sqlstate data_container_closed
throw standardexception
newexception sqlstate blob_accessed_after_commit
// set up the buffer for trashing the bytes to set the position of
// the
// stream, only need a buffer when we have a long column
buf   new byte
pos   0
//add entry in connection so it can be cleared
//when transaction is not valid
con addlobmapping  this
/*
sets the position of the stream to position newpos, where position 0 is
the beginning of the stream.
@param newpos the position to set to
@exception standardexception (blob_setposition_failed) throws this if
the stream runs out before we get to newpos
*/
private void setposition long newpos
throws standardexception  ioexception
if  sanitymanager debug
sanitymanager assert newpos >  0
if  materialized
pos   newpos
else
// always resets the stream to the beginning first, because user can
// influence the state of the stream without letting us know.
resetable mystream  resetstream
// pt could try to save creating a new object each time
bistream   new binarytorawstream mystream  this
pos   0
while  pos < newpos
int size   bistream read
buf 0  int  math min  newpos pos    long  blob_buf_size
if  size <  0       ran out of stream
throw standardexception newexception sqlstate blob_length_too_long
pos    size
/*
reads one byte, either from the byte array or else from the stream.
*/
private int read   throws ioexception  sqlexception
int c
if  materialized
try
if  pos >  control getlength
return  1
else
c   control read  pos
catch  standardexception se
throw util generatecssqlexception  se
else
c   bistream read
pos
return c
/**
* returns the number of bytes in the <code>blob</code> value
* designated by this <code>blob</code> object.
* @return length of the <code>blob</code> in bytes
* @exception sqlexception if there is an error accessing the
* length of the <code>blob</code>
*/
// pt stream part may get pushed to store
public long length
throws sqlexception
//call checkvalidity to exit by throwing a sqlexception if
//the blob object has been freed by calling free() on it
checkvalidity
try
if  materialized
return control getlength
catch  ioexception e
throw util setstreamfailure  e
if  mylength     1
return mylength
boolean pushstack   false
try
// we have a stream
synchronized  getconnectionsynchronization
pushstack    getembedconnection   isclosed
if  pushstack
setupcontextstack
setposition 0
// if possible get the length from the encoded
// length at the front of the raw stream.
if   mylength   bistream getlength        1
bistream close
return mylength
// otherwise have to read the entire stream!
for
int size   bistream read buf
if  size     1
break
pos    size
// save for future uses.
mylength   pos
bistream close
return pos
catch  throwable t
throw handlemyexceptions t
finally
if  pushstack
restorecontextstack
/**
* returns as an array of bytes part or all of the <code>blob</code>
* value that this <code>blob</code> object designates.  the byte
* array contains up to <code>length</code> consecutive bytes
* starting at position <code>startpos</code>.
* the starting position must be between 1 and the length
* of the blob plus 1. this allows for zero-length blob values, from
* which only zero-length byte arrays can be returned.
* if a larger length is requested than there are bytes available,
* characters from the start position to the end of the blob are returned.
* @param startpos the ordinal position of the first byte in the
* <code>blob</code> value to be extracted; the first byte is at
* position 1
* @param length is the number of consecutive bytes to be copied
* @return a byte array containing up to <code>length</code>
* consecutive bytes from the <code>blob</code> value designated
* by this <code>blob</code> object, starting with the
* byte at position <code>startpos</code>.
* @exception sqlexception if there is an error accessing the
* <code>blob</code>
* note: if the starting position is the length of the blob plus 1,
* zero bytess are returned regardless of the length requested.
*/
public byte getbytes long startpos  int length
throws sqlexception
//call checkvalidity to exit by throwing a sqlexception if
//the blob object has been freed by calling free() on it
checkvalidity
boolean pushstack   false
try
if  startpos < 1
throw standardexception newexception
sqlstate blob_bad_position  new long startpos
if  length < 0
throw standardexception newexception
sqlstate blob_nonpositive_length  new integer length
byte result
// if the blob is materialized
if  materialized
result   new byte
int sz   control read  result  0  result length  startpos   1
if  sz     1
return new byte
if  sz < length
byte  tmparray   new byte
system arraycopy  result  0  tmparray  0  sz
result   tmparray
else    we have a stream
synchronized  getconnectionsynchronization
pushstack    getembedconnection   isclosed
if  pushstack
setupcontextstack
setposition startpos 1
// read length bytes into a string
result   new byte
int n   inputstreamutil readloop bistream result 0 length
pos    n
/*
according to the spec, if there are only n < length bytes
to return, we should just return these bytes. rather than
return them in an array of size length, where the trailing
bytes are not initialized, and the user cannot tell how
many bytes were actually returned, we should return an
array of n bytes.
*/
if  n < length
byte result2   new byte
system arraycopy result 0 result2 0 n
return result2
return result
catch  standardexception e
if this is a setposition exception then we ran out of blob
if  e getmessageid   equals sqlstate blob_length_too_long
e   standardexception newexception
sqlstate blob_position_too_large  new long startpos
throw handlemyexceptions e
catch  throwable t
throw handlemyexceptions t
finally
if  pushstack
restorecontextstack
/**
* retrieves the <code>blob</code> designated by this
* <code>blob</code> instance as a stream.
* @return a stream containing the <code>blob</code> data
* @exception sqlexception if there is an error accessing the
* <code>blob</code>
*/
public java io inputstream getbinarystream
throws sqlexception
//call checkvalidity to exit by throwing a sqlexception if
//the blob object has been freed by calling free() on it
checkvalidity
boolean pushstack   false
try
// if we have byte array, not a stream
if  materialized
return control getinputstream 0
else
// have a stream
synchronized  getconnectionsynchronization
pushstack    getembedconnection   isclosed
if  pushstack
setupcontextstack
resetable mystream  resetstream
return new updatableblobstream  this
new autopositioningstream  this  mystream  this
catch  throwable t
throw handlemyexceptions t
finally
if  pushstack
restorecontextstack
/**
* determines the byte position at which the specified byte
* <code>pattern</code> begins within the <code>blob</code>
* value that this <code>blob</code> object represents.  the
* search for <code>pattern</code. begins at position
* <code>start</code>
* @param pattern the byte array for which to search
* @param start the position at which to begin searching; the
*        first position is 1
* @return the position at which the pattern appears, else -1.
* @exception sqlexception if there is an error accessing the
* <code>blob</code>
*/
public long position byte pattern  long start
throws sqlexception
//call checkvalidity to exit by throwing a sqlexception if
//the blob object has been freed by calling free() on it
checkvalidity
boolean pushstack   false
try
if  start < 1
throw standardexception newexception
sqlstate blob_bad_position  new long start
if  pattern    null
throw standardexception newexception sqlstate blob_null_pattern_or_search_str
if  pattern length    0
return start     match db2's sql locate function
synchronized  getconnectionsynchronization
pushstack    getembedconnection   isclosed
if  pushstack
setupcontextstack
setposition start 1
// look for first character
int lookfor   pattern
long curpos
int c
while  true
c   read
if  c     1      run out of stream
return  1
if  c    lookfor
curpos   pos
if  checkmatch pattern
return curpos
else
setposition curpos
catch  standardexception e
if this is a setposition exception then not found
if  e getmessageid   equals sqlstate blob_length_too_long
return  1
else
throw handlemyexceptions e
catch  throwable t
throw handlemyexceptions t
finally
if  pushstack
restorecontextstack
/*
check whether pattern (starting from the second byte) appears inside
posstream (at the current position)
@param posstream the stream to search inside
@param pattern the byte array passed in by the user to search with
@return true if match, false otherwise
*/
private boolean checkmatch byte pattern
throws ioexception  sqlexception
// check whether rest matches
// might improve performance by reading more
for  int i   1  i < pattern length  i
int b   read
if   b < 0      b    pattern       mismatch or stream runs out
return false
return true
/**
* determines the byte position in the <code>blob</code> value
* designated by this <code>blob</code> object at which
* <code>pattern</code> begins.  the search begins at position
* <code>start</code>.
* @param pattern the <code>blob</code> object designating
* the <code>blob</code> value for which to search
* @param start the position in the <code>blob</code> value
*        at which to begin searching; the first position is 1
* @return the position at which the pattern begins, else -1
* @exception sqlexception if there is an error accessing the
* <code>blob</code>
*/
public long position blob pattern  long start
throws sqlexception
//call checkvalidity to exit by throwing a sqlexception if
//the blob object has been freed by calling free() on it
checkvalidity
boolean pushstack   false
try
if  start < 1
throw standardexception newexception
sqlstate blob_bad_position  new long start
if  pattern    null
throw standardexception newexception sqlstate blob_null_pattern_or_search_str
synchronized  getconnectionsynchronization
pushstack    getembedconnection   isclosed
if  pushstack
setupcontextstack
setposition start 1
// look for first character
byte b
try
pattern is not necessarily a derby blob
b   pattern getbytes 1 1
catch  sqlexception e
throw standardexception newexception sqlstate blob_unable_to_read_pattern
if  b    null    b length < 1      the   blob
return start     match db2's sql locate function
int lookfor   b
int c
long curpos
while  true
c   read
if  c     1      run out of stream
return  1
if  c    lookfor
curpos   pos
if  checkmatch pattern
return curpos
else
setposition curpos
catch  standardexception e
if this is a setposition exception then not found
if  e getmessageid   equals sqlstate blob_length_too_long
return  1
else
throw handlemyexceptions e
catch  throwable t
throw handlemyexceptions t
finally
if  pushstack
restorecontextstack
/*
check whether pattern (starting from the second byte) appears inside
posstream (at the current position)
@param posstream the stream to search inside
@param pattern the blob passed in by the user to search with
@return true if match, false otherwise
*/
private boolean checkmatch blob pattern
throws ioexception  sqlexception
// check whether rest matches
// might improve performance by reading buffer at a time
inputstream pstream
try
pstream   pattern getbinarystream
catch  sqlexception e
return false
if  pstream    null
return false
// throw away first character since we already read it in the calling
// method
int b1   pstream read
if  b1 < 0
return false
while  true
b1   pstream read
if  b1 < 0      search blob runs out
return true
int b2   read
if   b1    b2      b2 < 0       mismatch or stream runs out
return false
/*
convert exceptions where needed before calling handleexception to convert
them to sqlexceptions.
*/
private sqlexception handlemyexceptions throwable t
throws sqlexception
if  t instanceof standardexception
// container closed means the blob or clob was accessed after commit
if    standardexception  t  getmessageid   equals sqlstate data_container_closed
t   standardexception newexception sqlstate blob_accessed_after_commit
return handleexception t
/*
if we have a stream, release the resources associated with it.
*/
protected void finalize
if   materialized
resetable mystream  closestream
/**
following methods are for the new jdbc 3.0 methods in java.sql.blob
(see the jdbc 3.0 spec). we have the jdbc 3.0 methods in local20
package, so we don't have to have a new class in local30.
the new jdbc 3.0 methods don't make use of any new jdbc3.0 classes and
so this will work fine in jdbc2.0 configuration.
*/
/////////////////////////////////////////////////////////////////////////
//
//	jdbc 3.0	-	new public methods
//
/////////////////////////////////////////////////////////////////////////
/**
* jdbc 3.0
*
* writes the given array of bytes to the blob value that this blob object
* represents, starting at position pos, and returns the number of bytes written.
*
* @param pos - the position in the blob object at which to start writing
* @param bytes - the array of bytes to be written to the blob value that this
* blob object represents
* @return the number of bytes written
* @exception sqlexception feature not implemented for now.
*/
public int setbytes long pos  byte bytes  throws sqlexception
return setbytes pos  bytes  0  bytes length
/**
* jdbc 3.0
*
* writes all or part of the given array of byte array to the blob value that
* this blob object represents and returns the number of bytes written.
* writing starts at position pos in the blob value; len bytes from the given
* byte array are written.
*
* @param pos - the position in the blob object at which to start writing
* @param bytes - the array of bytes to be written to the blob value that this
* blob object represents
* @param offset - the offset into the array bytes at which to start reading
* the bytes to be set
* @param len - the number of bytes to be written to the blob value from the
* array of bytes bytes
* @return the number of bytes written
* @exception sqlexception feature not implemented for now.
*/
public int setbytes long pos
byte bytes
int offset
int len  throws sqlexception
checkvalidity
try
if  materialized
if  pos   1 > length
throw util generatecssqlexception
sqlstate blob_position_too_large  new long pos
if  pos < 1
throw util generatecssqlexception
sqlstate blob_bad_position  new long pos
len    int  control write  bytes  offset  len  pos   1
else
control   new lobstreamcontrol  getembedconnection   getdbname
control copydata  mystream  length
len    int  control write bytes  offset  len  pos   1
mystream close
materialized   true
return len
catch  ioexception e
throw util setstreamfailure  e
catch  standardexception se
throw util generatecssqlexception  se
/**
* jdbc 3.0
*
* retrieves a stream that can be used to write to the blob value that this
* blob object represents. the stream begins at position pos.
*
* @param pos - the position in the blob object at which to start writing
* @return a java.io.outputstream object to which data can be written
* @exception sqlexception feature not implemented for now.
*/
public java io outputstream setbinarystream  long pos
throws sqlexception
checkvalidity
if  pos   1 > length
throw util generatecssqlexception
sqlstate blob_position_too_large  new long pos
if  pos < 1
throw util generatecssqlexception
sqlstate blob_bad_position  new long pos
try
if  materialized
return control getoutputstream  pos   1
else
control   new lobstreamcontrol
getembedconnection   getdbname
control copydata  mystream  pos   1
mystream close
materialized   true
return control getoutputstream pos   1
catch  ioexception e
throw util setstreamfailure  e
catch  standardexception se
throw util generatecssqlexception  se
/**
* jdbc 3.0
*
* truncates the blob value that this blob object represents to be len bytes
* in length.
*
* @param len - the length, in bytes, to which the blob value that this blob
* object represents should be truncated
* @exception sqlexception feature not implemented for now.
*/
public void truncate long len
throws sqlexception
if  len > length
throw util generatecssqlexception
sqlstate blob_length_too_long  new long pos
try
if  materialized
control truncate  len
else
control   new lobstreamcontrol  getembedconnection   getdbname
control copydata  mystream  len
mystream close
materialized   true
catch  ioexception e
throw util setstreamfailure  e
catch  standardexception se
throw util generatecssqlexception  se
/////////////////////////////////////////////////////////////////////////
//
//	jdbc 4.0	-	new public methods
//
/////////////////////////////////////////////////////////////////////////
/**
* this method frees the <code>blob</code> object and releases the resources that
* it holds. the object is invalid once the <code>free</code>
* method is called. if <code>free</code> is called multiple times, the subsequent
* calls to <code>free</code> are treated as a no-op.
*
* @throws sqlexception if an error occurs releasing
* the blob's resources
*/
public void free
throws sqlexception
//calling free() on a already freed object is treated as a no-op
if   isvalid  return
//now that free has been called the blob object is no longer
//valid
isvalid   false
//initialialize length to default value -1
mylength    1
//if it is a stream then close it.
//if a array of bytes then initialize it to null
//to free up space
if   materialized
resetable mystream  closestream
else
try
control free
control   null
catch  ioexception e
throw util setstreamfailure  e
/**
* returns an <code>inputstream</code> object that contains a partial
* <code>blob</code> value, starting with the byte specified by pos,
* which is length bytes in length.
*
* @param pos the offset to the first byte of the partial value to be
*      retrieved. the first byte in the <code>blob</code> is at
*      position 1
* @param length the length in bytes of the partial value to be retrieved
* @return through which the partial <code>blob</code> value can be read.
* @throws sqlexception if pos is less than 1 or if pos is greater than
*      the number of bytes in the <code>blob</code> or if pos + length is
*      greater than the number of bytes in the <code>blob</code>
*/
public inputstream getbinarystream long pos  long length
throws sqlexception
//call checkvalidity to exit by throwing a sqlexception if
//the blob object has been freed by calling free() on it
checkvalidity
if  pos <  0
throw util generatecssqlexception
sqlstate blob_bad_position
new long pos
if  length < 0
throw util generatecssqlexception
sqlstate blob_nonpositive_length
new long length
if  length >  this length     pos
throw util generatecssqlexception
sqlstate pos_and_length_greater_than_lob
new long pos   new long length
try
return new updatableblobstream this
getbinarystream
pos 1
length
catch  ioexception ioe
throw util setstreamfailure ioe
/*
* checks is isvalid is true. if it is not true throws
* a sqlexception stating that a method has been called on
* an invalid lob object
*
* throws sqlexception if isvalid is not true.
*/
private void checkvalidity   throws sqlexception
//check for connection to maintain sqlcode for closed
//connection
getembedconnection   checkifclosed
if  isvalid
throw newsqlexception sqlstate lob_object_invalid
/**
* returns if blob data is stored locally (using lobstreamcontrol).
* @return true if materialized else false
*/
boolean ismaterialized
return materialized