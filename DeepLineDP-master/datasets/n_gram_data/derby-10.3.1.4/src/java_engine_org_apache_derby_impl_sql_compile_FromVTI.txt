/*
derby - class org.apache.derby.impl.sql.compile.fromvti
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services loader classinspector
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services context contextmanager
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services compiler localfield
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql compile optimizablepredicatelist
import org apache derby iapi sql compile optimizer
import org apache derby iapi sql compile optimizablepredicate
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql compile costestimate
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile rowordering
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary columndescriptorlist
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi reference classname
import org apache derby iapi reference jdbc20translation
import org apache derby iapi reference sqlstate
import org apache derby iapi sql activation
import org apache derby catalog uuid
import org apache derby vti defermodification
import org apache derby vti vticosting
import org apache derby vti vtienvironment
import org apache derby iapi util jbitset
import org apache derby iapi services io formatablebitset
import org apache derby iapi services classfile vmopcode
import org apache derby iapi services info jvminfo
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi sql execute executioncontext
import java lang reflect constructor
import java lang reflect invocationtargetexception
import java sql preparedstatement
import java sql resultset
import java sql resultsetmetadata
import java sql sqlexception
import java sql types
import java util enumeration
import java util properties
import java util vector
import org apache derby iapi services io formatablehashtable
import java lang reflect modifier
/**
* a fromvti represents a vti in the from list of a dml statement.
*
*/
public class fromvti extends fromtable implements vtienvironment
jbitset				correlationmap
jbitset				dependencymap
newinvocationnode	newinvocation
tablename			exposedname
subquerylist subquerylist
boolean				implementsvticosting
boolean				optimized
boolean				materializable
boolean				istarget
resultset			rs
private	formatablehashtable	compiletimeconstants
// number of columns returned by the vti
protected int numvticols
private predicatelist restrictionlist
/**
was a for update clause specified in a select statement.
*/
private boolean forupdatepresent
/**
was the for update clause empty (no columns specified).
*/
private boolean emptyforupdate
/*
** we don't know how expensive a virtual table will be.
** let's say it has 10000 rows with a cost of 100000.
*/
double estimatedcost   vticosting defaultestimatedcost
double estimatedrowcount   vticosting defaultestimatedrowcount
boolean supportsmultipleinstantiations   true
boolean vticosted
/* version 1 or 2 vti*/
protected boolean			version2
private boolean				implementspushable
private preparedstatement	ps
private javavaluenode methodparms
private boolean controlsdeferral
private boolean isinsensitive
private int resultsettype   resultset type_forward_only
/**
* @param newinvocation		the constructor for the vti
* @param correlationname	the correlation name
* @param derivedrcl		the derived column list
* @param tableproperties	properties list associated with the table
*
* @exception standardexception		thrown on error
*/
public void init
object newinvocation
object correlationname
object derivedrcl
object tableproperties
throws standardexception
init  newinvocation
correlationname
derivedrcl
tableproperties
maketablename null   string  correlationname
/**
* @param newinvocation		the constructor for the vti
* @param correlationname	the correlation name
* @param derivedrcl		the derived column list
* @param tableproperties	properties list associated with the table
* @param exposedtablename  the table name (tablename class)
*
* @exception standardexception		thrown on error
*/
public void init
object newinvocation
object correlationname
object derivedrcl
object tableproperties
object exposedtablename
throws standardexception
super init correlationname  tableproperties
this newinvocation    newinvocationnode  newinvocation
resultcolumns    resultcolumnlist  derivedrcl
subquerylist    subquerylist  getnodefactory   getnode
c_nodetypes subquery_list
getcontextmanager
/* cache exposed name for this table.
* the exposed name becomes the qualifier for each column
* in the expanded list.
*/
this exposedname    tablename  exposedtablename
// optimizable interface
/**
* @see optimizable#estimatecost
*
* @exception standardexception		thrown on error
*/
public costestimate estimatecost
optimizablepredicatelist predlist
conglomeratedescriptor cd
costestimate outercost
optimizer optimizer
rowordering rowordering
throws standardexception
costestimate   getcostestimate optimizer
/* cost the vti if it implements vticosting.
* otherwise we use the defaults.
* note: we only cost the vti once.
*/
if  implementsvticosting      vticosted
try
vticosting vtic    version2  ?  vticosting  ps    vticosting  rs
estimatedcost   vtic getestimatedcostperinstantiation this
estimatedrowcount   vtic getestimatedrowcount this
supportsmultipleinstantiations   vtic supportsmultipleinstantiations this
if  ps    null
ps close
ps   null
if  rs    null
rs close
rs   null
catch  sqlexception sqle
throw standardexception unexpecteduserexception sqle
vticosted   true
costestimate setcost estimatedcost  estimatedrowcount  estimatedrowcount
/*
** let the join strategy decide whether the cost of the base
** scan is a single scan, or a scan per outer row.
** note: the multiplication should only be done against the
** total row count, not the singlescanrowcount.
** resolve - if the join strategy does not do materialization,
** the vti does not support multiple instantiations and the
** outer row count is not exactly 1 row, then we need to change
** the costing formula to take into account the cost of creating
** the temp conglomerate, writing to it and reading from it
** outercost.rowcount() - 1 times.
*/
if  getcurrentaccesspath
getjoinstrategy
multiplybasecostbyouterrows
costestimate multiply outercost rowcount    costestimate
if     optimized
subquerylist optimize optimizer getdatadictionary
costestimate rowcount
subquerylist modifyaccesspaths
optimized   true
return costestimate
/**
* @see optimizable#legaljoinorder
*/
public boolean legaljoinorder jbitset assignedtablemap
/* in order to tell if this is a legal join order, we
* need to see if the assignedtablemap, ored with the
* outer tables that we are correlated with, contains
* our dependency map.
*/
jbitset tempbitset    jbitset  assignedtablemap
tempbitset or correlationmap
/* have all of our dependencies been satisified? */
return tempbitset contains dependencymap
/** @see optimizable#ismaterializable
*
*/
public boolean ismaterializable
return materializable
/** @see optimizable#supportsmultipleinstantiations */
public boolean supportsmultipleinstantiations
return supportsmultipleinstantiations
/**
* @see resultsetnode#adjustforsortelimination()
*/
public void adjustforsortelimination
/* it's possible that we have an order by on the columns for this
* vti but that the sort was eliminated during preprocessing (see
* esp. selectnode.preprocess()).  take as an example the following
* query:
*
*   select distinct * from
*      table(syscs_diag.space_table('t1')) x order by 3
*
* for this query we will merge the order by and the distinct and
* thereby eliminate the sort for the order by.  as a result we
* will end up here--but we don't need to do anything special to
* return vti rows in the correct order, so this method is a no-op.
* derby-2805.
*/
/**
* @see optimizable#modifyaccesspath
*
* @exception standardexception		thrown on error
*/
public optimizable modifyaccesspath jbitset outertables  throws standardexception
/* close the rs if one was instantiated */
if  rs    null
try
rs close
rs   null
catch throwable t
throw standardexception unexpecteduserexception t
return super modifyaccesspath outertables
public boolean pushoptpredicate optimizablepredicate optimizablepredicate
throws standardexception
if   implementspushable
return false
// do not push down join predicates: those referencing more than one table.
if    optimizablepredicate getreferencedmap   hassinglebitset
return false
if  restrictionlist    null
restrictionlist    predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
restrictionlist addpredicate  predicate  optimizablepredicate
return true
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return     materializable
super tostring
else
return
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  newinvocation    null
printlabel depth
newinvocation treeprint depth   1
if  exposedname    null
printlabel depth
exposedname treeprint depth   1
if  subquerylist    null
printlabel depth
subquerylist treeprint depth   1
/**
* return the new invocation from this node.
*
* @return resultsetnode	the new invocation from this node.
*/
public newinvocationnode getnewinvocation
return newinvocation
/**
* get the exposed name for this table, which is the name that can
* be used to refer to it in the rest of the query.
*
* @return	the exposed name for this table.
*/
public string getexposedname
return correlationname
/**
* @return the table name used for matching with column references.
*
*/
public tablename getexposedtablename
return exposedname
/**
* mark this vti as the target of a delete or update.
*/
void settarget
istarget   true
version2   true
/**
* bind the non vti tables in this resultsetnode.  this includes getting their
* descriptors from the data dictionary and numbering them.
*
* @param datadictionary	the datadictionary to use for binding
* @param fromlistparam		fromlist to use/append to.
*
* @return	resultsetnode
*
* @exception standardexception		thrown on error
*/
public resultsetnode bindnonvtitables datadictionary datadictionary
fromlist fromlistparam
throws standardexception
/* assign the tablenumber.  (all other work done in bindvtitables() */
if  tablenumber     1      allow re bind  in which case use old number
tablenumber   getcompilercontext   getnexttablenumber
return this
/**
* @return the name of the vti, mainly for debugging and error messages.
*/
string getvtiname
return newinvocation getjavaclassname
end of getvtiname
/**
* bind this vti that appears in the from list.
*
* @param fromlistparam		fromlist to use/append to.
*
* @return	resultsetnode		the bound fromvti.
*
* @exception standardexception		thrown on error
*/
public resultsetnode bindvtitables fromlist fromlistparam
throws standardexception
resultcolumnlist	derivedrcl   resultcolumns
languageconnectioncontext lcc   getlanguageconnectioncontext
/* note - setting of table number moved to fromlist.bindtables()
* in order to avoid an ordering problem with join columns in
* parameters.
*/
/* bind the constructor - does basic error checking.
* correlated subqueries are not allowed as parameters to
* a vti, so pass an empty fromlist.
*/
vector aggregatevector   new vector
newinvocation bindexpression fromlistparam
subquerylist
aggregatevector
/* we have a valid constructor.  does class implement the correct interface?
* if version2 is true, then it must implement preparedstatement, otherwise
* it can implement either preparedstatement or resultset.  (we check for
* preparedstatement first.)
*/
if   newinvocation assignableto
if  version2
throw standardexception newexception sqlstate lang_does_not_implement
getvtiname
else if    newinvocation assignableto
throw standardexception newexception sqlstate lang_does_not_implement
getvtiname
else
version2   true
/* if this is a version 2 vti */
if  version2
// does it support predicates
implementspushable   newinvocation assignableto
// remember whether or not the vti implements the vticosting interface
implementsvticosting   newinvocation assignableto classname vticosting
// is the parameter list to the constructor valid for a vti?
methodparms   newinvocation getmethodparms
/* build the rcl for this vti.  we instantiate an object in order
* to get the resultsetmetadata.
*
* if we have a special trigger vti, then we branch off and get
* its rcl from the trigger table that is waiting for us in
* the compiler context.
*/
uuid triggertableid
if   triggertableid   getspecialtriggervtitablename lcc  newinvocation getjavaclassname        null
tabledescriptor td   getdatadictionary   gettabledescriptor triggertableid
resultcolumns   genresultcollist td
// costing info
vticosted   true
estimatedcost   50d
estimatedrowcount   5d
supportsmultipleinstantiations   true
else
resultsetmetadata rsmd   getresultsetmetadata
/* wouldn't it be nice if we knew that the class/object would never
* return a null resultsetmetadata.
*/
if  rsmd    null
throw standardexception newexception sqlstate lang_null_result_set_meta_data
getvtiname
// remember how many columns vti returns for partial row calculation
try
numvticols   rsmd getcolumncount
catch  sqlexception sqle
numvticols   0
resultcolumns    resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
resultcolumns createlistfromresultsetmetadata rsmd  exposedname
newinvocation getjavaclassname
numvticols   resultcolumns size
/* propagate the name info from the derived column list */
if  derivedrcl    null
resultcolumns propagatedclinfo derivedrcl  correlationname
return this
/**
* get the resultsetmetadata for the class/object.  we first look for
* the optional static method which has the same signature as the constructor.
* if it doesn't exist, then we instantiate an object and get the resultsetmetadata
* from that object.
*
* @return the resultsetmetadata from the class/object.
*
* @exception standardexception		thrown on error
*/
public resultsetmetadata getresultsetmetadata
throws standardexception
// get the actual
resultsetmetadata rsmd   null
try
if  version2
ps    preparedstatement  getnewinstance
if  ps getresultsetconcurrency      jdbc20translation concur_updatable
throw standardexception newexception sqlstate lang_updatable_vti_non_updatable_rs
getvtiname
rsmd   ps getmetadata
controlsdeferral    ps instanceof defermodification
/* see if the result set is known to be insensitive or not.
*
* some older vti implementations do not implement getresultsettype(). updatablevtitemplate
* does not implement it at all. updatablevtitemplate.getresultsettype throws an
* exception. in either of these cases make the conservative assumption that the result set is sensitive.
*/
try
resultsettype   ps getresultsettype
catch  sqlexception sqle
catch  java lang abstractmethoderror ame
catch  java lang nosuchmethoderror nsme
isinsensitive    resultsettype    resultset type_scroll_insensitive
if   implementsvticosting
ps close
ps   null
else
rs    resultset  getnewinstance
rsmd   rs getmetadata
if   implementsvticosting
rs close
rs   null
catch throwable t
throw standardexception unexpecteduserexception t
return rsmd
private object getnewinstance
throws standardexception
class  paramtypeclasses   newinvocation getmethodparameterclasses
object paramobjects   null
if  paramtypeclasses    null
paramobjects   new object
for  int index   0  index < paramtypeclasses length  index
class paramclass   paramtypeclasses
paramobjects   methodparms getconstantvalueasobject
// as-per the jdbc spec smallint and tinyint map to java.lang.integer
// as objects. this means if getconstantvalueasobject() has returned an
// integer obejct in these cases, whereas java method calling requires
// short or byte object.
if   paramobjects    null     paramclass isprimitive
if  paramclass equals short type
paramobjects
new short   integer  paramobjects  shortvalue
else if  paramclass equals byte type
paramobjects
new byte   integer  paramobjects  bytevalue
// pass defaults for unknown primitive values
if  paramobjects    null
paramclass isprimitive
if  paramclass equals integer type
paramobjects   new integer 0
else if  paramclass equals short type
paramobjects   new short  short  0
else if  paramclass equals byte type
paramobjects   new byte  byte  0
else if  paramclass equals long type
paramobjects   new long  long  0
else if  paramclass equals float type
paramobjects   new float  float  0
else if  paramclass equals double type
paramobjects   new double  double  0
else if  paramclass equals boolean type
paramobjects   boolean false
else if  paramclass equals character type
paramobjects   new character character min_value
else
paramtypeclasses   new class
paramobjects   new object
try
classinspector classinspector   getclassfactory   getclassinspector
string javaclassname   newinvocation getjavaclassname
constructor constructor   classinspector getclass javaclassname  getconstructor paramtypeclasses
return constructor newinstance paramobjects
catch throwable t
if  t instanceof invocationtargetexception
invocationtargetexception ite    invocationtargetexception  t
throwable wrappedthrowable   ite gettargetexception
if  wrappedthrowable instanceof standardexception
throw  standardexception  wrappedthrowable
throw standardexception unexpecteduserexception t
end of getnewinstance
/**
* get the defermodification interface associated with this vti
*
* @return null if the vti uses the default modification deferral
*/
public defermodification getdeferralcontrol
throws standardexception
if    controlsdeferral
return null
try
return  defermodification  getnewinstance
catch throwable t
throw standardexception unexpecteduserexception t
end of getdeferralcontrol
/**
* @return the resultset type of the vti, type_forward_only if the getresultsettype() method
*         of the vti class throws an exception.
*/
public int getresultsettype
return resultsettype
/**
* bind the expressions in this vti.  this means
* binding the sub-expressions, as well as figuring out what the return
* type is for each expression.
*
*
* @exception standardexception		thrown on error
*/
public void bindexpressions fromlist fromlistparam
throws standardexception
resultcolumnlist	derivedrcl   resultcolumns
/* figure out if the vtis parameters are query_invariant.  if so,
* then the vti is a candidate for materialization at execution time
* if it is the inner table of a join or in a subquery.
*/
materializable   newinvocation areparametersqueryinvariant
/* note: we need to rebind any columnreferences that are parameters and are
* from other vtis that appear after this one in the from list.
* these crs will have uninitialized column and table numbers.
*/
vector colrefs   getnodesfromparameters columnreference class
vector aggregatevector   null
for  enumeration e   colrefs elements    e hasmoreelements
columnreference ref    columnreference e nextelement
// rebind the cr if the tablenumber is uninitialized
if  ref gettablenumber       1
// we need a fake agg list
if  aggregatevector    null
aggregatevector   new vector
ref bindexpression fromlistparam
subquerylist
aggregatevector
/**
* get all of the nodes of the specified class
* from the parameters to this vti.
*
* @param nodeclass	the class of interest.
*
* @return a vector containing all of the nodes of interest.
*
* @exception standardexception		thrown on error
*/
vector getnodesfromparameters class nodeclass
throws standardexception
collectnodesvisitor getcrs   new collectnodesvisitor nodeclass
newinvocation accept getcrs
return getcrs getlist
/**
* expand a "*" into a resultcolumnlist with all of the
* result columns from the subquery.
* @exception standardexception		thrown on error
*/
public resultcolumnlist getallresultcolumns tablename alltablename
throws standardexception
resultcolumnlist rclist   null
resultcolumn	 resultcolumn
valuenode		 valuenode
string			 columnname
tablename        tocompare
if alltablename    null
tocompare   maketablename alltablename getschemaname   correlationname
else
tocompare   maketablename null correlationname
if   alltablename    null
alltablename equals tocompare
return null
rclist    resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
/* build a new result column list based off of resultcolumns.
* note: this method will capture any column renaming due to
* a derived column list.
*/
int rclsize   resultcolumns size
for  int index   0  index < rclsize  index
resultcolumn    resultcolumn  resultcolumns elementat index
if  resultcolumn isgenerated
continue
// build a resultcolumn/columnreference pair for the column //
columnname   resultcolumn getname
valuenode    valuenode  getnodefactory   getnode
c_nodetypes column_reference
columnname
exposedname
getcontextmanager
resultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
columnname
valuenode
getcontextmanager
// build the resultcolumnlist to return //
rclist addresultcolumn resultcolumn
return rclist
/**
* try to find a resultcolumn in the table represented by this frombasetable
* that matches the name in the given columnreference.
*
* @param columnreference	the columnreference whose name we're looking
*				for in the given table.
*
* @return	a resultcolumn whose expression is the columnnode
*			that matches the columnreference.
*		returns null if there is no match.
*
* @exception standardexception		thrown on error
*/
public resultcolumn getmatchingcolumn columnreference columnreference  throws standardexception
/* we could get called before our rcl is built.  that's okay, we'll
* just say that we don't match.
*/
if  resultcolumns    null
return null
resultcolumn	resultcolumn   null
tablename		columnstablename
tablename		exposedtablename
columnstablename   columnreference gettablenamenode
/*
** if the column did not specify a name, or the specified name
** matches the table we're looking at, see whether the column
** is in this table.
*/
if  columnstablename    null    columnstablename equals exposedname
resultcolumn   resultcolumns getresultcolumn columnreference getcolumnname
/* did we find a match? */
if  resultcolumn    null
columnreference settablenumber tablenumber
return resultcolumn
/**
* preprocess a resultsetnode - this currently means:
*	o  generating a referenced table map for each resultsetnode.
*  o  putting the where and having clauses in conjunctive normal form (cnf).
*  o  converting the where and having clauses into predicatelists and
*	   classifying them.
*  o  ensuring that a projectrestrictnode is generated on top of every
*     frombasetable and generated in place of every fromsubquery.
*  o  pushing single table predicates down to the new projectrestrictnodes.
*
* @param numtables			the number of tables in the dml statement
* @param gbl				the group by list, if any
* @param fromlist			the from list, if any
*
* @return resultsetnode at top of preprocessed tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode preprocess int numtables
groupbylist gbl
fromlist fromlist
throws standardexception
newinvocation preprocess
numtables
fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
subquerylist  getnodefactory   getnode
c_nodetypes subquery_list
getcontextmanager
predicatelist  getnodefactory   getnode
c_nodetypes predicate_list
getcontextmanager
/* generate the referenced table map */
referencedtablemap   new jbitset numtables
referencedtablemap set tablenumber
newinvocation categorize referencedtablemap  false
// create the dependency map
dependencymap   new jbitset numtables
for  int index   0  index < numtables  index
if   index    tablenumber     referencedtablemap get index
dependencymap set index
// get a jbitset of the outer tables represented in the parameter list
correlationmap   new jbitset numtables
newinvocation getcorrelationtables correlationmap
return genprojectrestrict numtables
/**
* put a projectrestrictnode on top of each fromtable in the fromlist.
* columnreferences must continue to point to the same resultcolumn, so
* that resultcolumn must percolate up to the new prn.  however,
* that resultcolumn will point to a new expression, a virtualcolumnnode,
* which points to the fromtable and the resultcolumn that is the source for
* the columnreference.
* (the new prn will have the original of the resultcolumnlist and
* the resultcolumns from that list.  the fromtable will get shallow copies
* of the resultcolumnlist and its resultcolumns.  resultcolumn.expression
* will remain at the fromtable, with the prn getting a new
* virtualcolumnnode for each resultcolumn.expression.)
* we then project out the non-referenced columns.  if there are no referenced
* columns, then the prn's resultcolumnlist will consist of a single resultcolumn
* whose expression is 1.
*
* @param numtables			number of tables in the dml statement
*
* @return the generated projectrestrictnode atop the original fromtable.
*
* @exception standardexception		thrown on error
*/
protected resultsetnode genprojectrestrict int numtables
throws standardexception
resultcolumnlist	prrclist
/* we get a shallow copy of the resultcolumnlist and its
* resultcolumns.  (copy maintains resultcolumn.expression for now.)
*/
prrclist   resultcolumns
resultcolumns   resultcolumns copylistandobjects
/* replace resultcolumn.expression with new virtualcolumnnodes
* in the projectrestrictnode's resultcolumnlist.  (virtualcolumnnodes include
* pointers to source resultsetnode, this, and source resultcolumn.)
* note: we don't want to mark the underlying rcs as referenced, otherwise
* we won't be able to project out any of them.
*/
prrclist genvirtualcolumnnodes this  resultcolumns  false
/* project out any unreferenced columns.  if there are no referenced
* columns, generate and bind a single resultcolumn whose expression is 1.
*/
prrclist doprojection
/* finally, we create the new projectrestrictnode */
return  resultsetnode  getnodefactory   getnode
c_nodetypes project_restrict_node
this
prrclist
null 	   restriction
null       restriction as predicatelist
null 	   project subquery list
null 	   restrict subquery list
tableproperties
getcontextmanager
/**
* return whether or not to materialize this resultset tree.
*
* @return whether or not to materialize this resultset tree.
*			would return valid results.
*
* @exception standardexception		thrown on error
*/
public boolean performmaterialization jbitset outertables
throws standardexception
/* we need to materialize the vti iff:
*	o  it is an inner table.
*	o  the vti can be materialized.
*	o  the vti cannot be instantiated multiple times.
*	o  the join strategy does not do materialization.
* resolve - we don't have to materialize if all of the
* outer tables are 1 row tables.
*/
return  outertables getfirstsetbit       1
outertables hassinglebitset         not the outer table
gettrulythebestaccesspath
getjoinstrategy
doesmaterialization      		   join strategy does not do materialization
ismaterializable     					   vti can be materialized
supportsmultipleinstantiations		   vti does not support multiple instantiations
/**
* generation on a fromvti creates a wrapper around
* the user's java.sql.resultset
*
* @param acb	the activationclassbuilder for the class being built
* @param mb the methodbuilder for the execute() method to be built
*
* @exception standardexception		thrown on error
*/
public void generate activationclassbuilder acb
methodbuilder mb
throws standardexception
/* note: we need to remap any crs within the parameters
* so that we get their values from the right source
* row.  for example, if a cr is a join column, we need
* to get the value from the source table and not the
* join row since the join row hasn't been filled in yet.
*/
remapcrsvisitor rcrv   new remapcrsvisitor true
newinvocation accept rcrv
/* get the next resultset #, so that we can number this resultsetnode, its
* resultcolumnlist and resultset.
*/
assignresultsetnumber
acb pushgetresultsetfactoryexpression mb
int nargs   getscanarguments acb  mb
mb callmethod vmopcode invokeinterface   string  null    classname noputresultset  nargs
private int getscanarguments activationclassbuilder acb
methodbuilder mb
throws standardexception
int				rclsize   resultcolumns size
formatablebitset			referencedcols   new formatablebitset rclsize
int				erdnumber    1
int				numset   0
// get our final cost estimate.
costestimate   getfinalcostestimate
for  int index   0  index < rclsize  index
resultcolumn rc    resultcolumn  resultcolumns elementat index
if  rc isreferenced
referencedcols set index
numset
// only add referencedcols if not all columns are accessed
if  numset    numvticols
erdnumber   acb additem referencedcols
// compiletimeconstants can be null
int ctcnumber   acb additem compiletimeconstants
acb pushthisasactivation mb      arg 1
// get a function to allocate scan rows of the right shape and size
resultcolumns generateholder acb  mb      arg 2
// for a version 2 vti we never maintain the java.sql.preparedstatement
// from compile time to execute time. this would rquire the preparedstatement
// to be shareable across multiple connections, which is not the model for
// java.sql.preparedstatement.
// for a version 2 vti we do pass onto the resultset the re-useability
// of the java.sql.preparedstatement at runtime. the java.sql.preparedstatement
// is re-uesable if
//
// o  no ? or columnreferences in parameters
boolean reuseableps   version2
getnodesfromparameters parameternode class  size      0
getnodesfromparameters columnreference class  size      0
mb push resultsetnumber      arg 3
// the generated method for the constructor
generateconstructor acb  mb  reuseableps      arg 4
// pass in the class name
mb push newinvocation getjavaclassname        arg 5
if  restrictionlist    null
restrictionlist generatequalifiers acb  mb  this  true
else
mb pushnull classname qualifier
// pass in the erdnumber for the referenced column formatablebitset
mb push erdnumber      arg 6
// whether or not this is a version 2 vti
mb push version2
mb push reuseableps
mb push ctcnumber
// whether or not this is a target vti
mb push istarget
// isolation level of the scan (if specified)
mb push getcompilercontext   getscanisolationlevel
// estimated row count
mb push costestimate rowcount
// estimated cost
mb push costestimate getestimatedcost
return 14
private void generateconstructor activationclassbuilder acb
methodbuilder mb  boolean reuseableps
throws standardexception
string vtitype   version2 ?
// this sets up the method and the static field.
// generates:
// 	java.sql.resultset userexprfun { }
methodbuilder userexprfun   acb newgeneratedfun
vtitype  modifier public
userexprfun addthrownexception
// if it's a re-useable preparedstatement then hold onto it.
localfield psholder   reuseableps ? acb newfielddeclaration modifier private       null
if  reuseableps
userexprfun getfield psholder
userexprfun conditionalifnull
newinvocation generateexpression acb  userexprfun
userexprfun upcast vtitype
if  reuseableps
userexprfun putfield psholder
userexprfun startelsecode
userexprfun getfield psholder
userexprfun completeconditional
userexprfun methodreturn
// newinvocation knows it is returning its value;
/* generates:
*    return <newinvocation.generate(acb)>;
*/
// we are done modifying userexprfun, complete it.
userexprfun complete
// constructor is used in the final result set as an access of the new static
// field holding a reference to this new method.
// generates:
//	activationclass.userexprfun
// which is the static field that "points" to the userexprfun
// that evaluates the where clause.
acb pushmethodreference mb  userexprfun
// now add in code to close the reusable preparedstatement when
// the activation is closed.
if  reuseableps
methodbuilder closeactivationmethod   acb getcloseactivationmethod
closeactivationmethod getfield psholder
closeactivationmethod conditionalifnull
// do nothing
closeactivationmethod push 0      work around for no support for real if statements
closeactivationmethod startelsecode
closeactivationmethod getfield psholder
closeactivationmethod callmethod vmopcode invokeinterface
0
closeactivationmethod push 0
closeactivationmethod completeconditional
closeactivationmethod endstatement
/**
* search to see if a query references the specifed table name.
*
* @param name		table name (string) to search for.
* @param basetable	whether or not name is for a base table
*
* @return	true if found, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencestarget string name  boolean basetable
throws standardexception
return    basetable     name equals newinvocation getjavaclassname
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
if  v skipchildren this
return v visit this
visitable returnnode   super accept v
if   v stoptraversal
newinvocation    newinvocationnode  newinvocation accept v
return returnnode
/**
* check and see if we have a special trigger vti.
* if it cannot be bound (because we aren't actually
* compiling or executing a trigger), then throw
* an exception.
*
* @return null if not a special trigger vti, or the table
* id if it is
*/
private uuid getspecialtriggervtitablename languageconnectioncontext lcc  string classname
throws standardexception
if  classname equals classname triggernewtransitionrows
classname equals classname triggeroldtransitionrows
// if there isn't an active trigger being compiled, error
if  lcc gettriggertable      null
return lcc gettriggertable   getuuid
else if  lcc gettriggerexecutioncontext      null
return lcc gettriggerexecutioncontext   gettargettableid
else
throw standardexception newexception sqlstate lang_cannot_bind_trigger_v_t_i  classname
return  uuid null
private resultcolumnlist genresultcollist tabledescriptor td
throws standardexception
resultcolumnlist 			rclist   null
resultcolumn	 			resultcolumn
valuenode		 			valuenode
columndescriptor 			coldesc   null
tablename tablename   maketablename td getschemaname
td getname
/* add all of the columns in the table */
rclist    resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
columndescriptorlist cdl   td getcolumndescriptorlist
int					 cdlsize   cdl size
for  int index   0  index < cdlsize  index
/* build a resultcolumn/basecolumnnode pair for the column */
coldesc    columndescriptor  cdl elementat index
valuenode    valuenode  getnodefactory   getnode
c_nodetypes base_column_node
coldesc getcolumnname
exposedname
coldesc gettype
getcontextmanager
resultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
coldesc
valuenode
getcontextmanager
/* build the resultcolumnlist to return */
rclist addresultcolumn resultcolumn
return rclist
public boolean needsspecialrclbinding
return true
boolean isupdatablecursor   throws standardexception
return true
protected void markupdatablebycursor vector updatecolumns
super markupdatablebycursor updatecolumns
forupdatepresent   true
emptyforupdate     updatecolumns    null      updatecolumns size      0
private int getforupdatecolumnlist
int templist   new int
int offset   0
for  int col   0  col < templist length  col
if  resultcolumns updatablebycursor col
templist   col   1     jdbc id
int list
if  offset    templist length
list   templist
else
list   new int
system arraycopy templist  0  list  0  offset
return list
/*
** vtienvironment
*/
public final boolean iscompiletime
return true
public string getoriginalsql
return getcompilercontext   getparser   getsqltext
public final int getstatementisolationlevel
return executioncontext cs_to_jdbc_isolation_level_map
public void setsharedstate string key  java io serializable value
if  key    null
return
if  compiletimeconstants    null
compiletimeconstants   new formatablehashtable
compiletimeconstants put key  value
public object getsharedstate string key
if   key    null      compiletimeconstants    null
return null
return compiletimeconstants get key