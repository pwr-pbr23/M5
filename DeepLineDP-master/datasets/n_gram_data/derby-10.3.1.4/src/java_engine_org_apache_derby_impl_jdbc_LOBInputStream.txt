/*
derby - class org.apache.derby.impl.jdbc.lobinputstream
licensed to the apache software foundation (asf) under one
or more contributor license agreements.  see the notice file
distributed with this work for additional information
regarding copyright ownership.  the asf licenses this file
to you under the apache license, version 2.0 (the
"license"); you may not use this file except in compliance
with the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing,
software distributed under the license is distributed on an
"as is" basis, without warranties or conditions of any
kind, either express or implied.  see the license for the
specific language governing permissions and limitations
under the license.
*/
package org apache derby impl jdbc
import java io ioexception
import java io inputstream
import java sql sqlexception
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services i18n messageservice
import org apache derby shared common error exceptionutil
/**
* this input stream is built on top of {@link lobstreamcontrol}.
* <p>
* all the read methods are routed to {@link lobstreamcontrol}.
*/
public class lobinputstream extends inputstream
private boolean closed
private final lobstreamcontrol control
private long pos
private long updatecount
lobinputstream lobstreamcontrol control  long position
closed   false
this control   control
pos   position
updatecount   control getupdatecount
/**
* reads up to <code>len</code> bytes of data from the input stream into
* an array of bytes.  an attempt is made to read as many as
* <code>len</code> bytes, but a smaller number may be read.
* the number of bytes actually read is returned as an integer.
*
* <p> this method blocks until input data is available, end of file is
* detected, or an exception is thrown.
*
* <p> if <code>b</code> is <code>null</code>, a
* <code>nullpointerexception</code> is thrown.
*
* <p> if <code>off</code> is negative, or <code>len</code> is negative, or
* <code>off+len</code> is greater than the length of the array
* <code>b</code>, then an <code>indexoutofboundsexception</code> is
* thrown.
*
* <p> if <code>len</code> is zero, then no bytes are read and
* <code>0</code> is returned; otherwise, there is an attempt to read at
* least one byte. if no byte is available because the stream is at end of
* file, the value <code>-1</code> is returned; otherwise, at least one
* byte is read and stored into <code>b</code>.
*
* <p> the first byte read is stored into element <code>b[off]</code>, the
* next one into <code>b[off+1]</code>, and so on. the number of bytes read
* is, at most, equal to <code>len</code>. let <i>k</i> be the number of
* bytes actually read; these bytes will be stored in elements
* <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,
* leaving elements <code>b[off+</code><i>k</i><code>]</code> through
* <code>b[off+len-1]</code> unaffected.
*
* <p> in every case, elements <code>b[0]</code> through
* <code>b[off]</code> and elements <code>b[off+len]</code> through
* <code>b[b.length-1]</code> are unaffected.
*
* <p> if the first byte cannot be read for any reason other than end of
* file, then an <code>ioexception</code> is thrown. in particular, an
* <code>ioexception</code> is thrown if the input stream has been closed.
*
* <p> the <code>read(b,</code> <code>off,</code> <code>len)</code> method
* for class <code>inputstream</code> simply calls the method
* <code>read()</code> repeatedly. if the first such call results in an
* <code>ioexception</code>, that exception is returned from the call to
* the <code>read(b,</code> <code>off,</code> <code>len)</code> method.  if
* any subsequent call to <code>read()</code> results in a
* <code>ioexception</code>, the exception is caught and treated as if it
* were end of file; the bytes read up to that point are stored into
* <code>b</code> and the number of bytes read before the exception
* occurred is returned.  subclasses are encouraged to provide a more
* efficient implementation of this method.
*
* @param b     the buffer into which the data is read.
* @param off   the start offset in array <code>b</code>
*                   at which the data is written.
* @param len   the maximum number of bytes to read.
* @return the total number of bytes read into the buffer, or
*             <code>-1</code> if there is no more data because the end of
*             the stream has been reached.
* @exception ioexception  if an i/o error occurs.
* @exception nullpointerexception  if <code>b</code> is <code>null</code>.
* @see java.io.inputstream#read()
*/
public int read byte b  int off  int len  throws ioexception
if  closed
throw new ioexception
messageservice gettextmessage sqlstate lang_stream_closed
try
int ret   control read b  off  len  pos
if  ret     1
pos    ret
return ret
return  1
catch  sqlexception e
return handlesqlexception  e
catch  standardexception se
throw new ioexception  se getmessage
/**
* closes this input stream and releases any system resources associated
* with the stream.
*
* <p> the <code>close</code> method of <code>inputstream</code> does
* nothing.
*
* @exception ioexception  if an i/o error occurs.
*/
public void close   throws ioexception
closed   true
/**
* reads the next byte of data from the input stream. the value byte is
* returned as an <code>int</code> in the range <code>0</code> to
* <code>255</code>. if no byte is available because the end of the stream
* has been reached, the value <code>-1</code> is returned. this method
* blocks until input data is available, the end of the stream is detected,
* or an exception is thrown.
*
* <p> a subclass must provide an implementation of this method.
*
* @return the next byte of data, or <code>-1</code> if the end of the
*             stream is reached.
* @exception ioexception  if an i/o error occurs.
*/
public int read   throws ioexception
if  closed
throw new ioexception
messageservice gettextmessage  sqlstate lang_stream_closed
try
int ret   control read pos
if  ret     1
pos    1
return ret
catch  sqlexception e
throw new ioexception e getmessage
catch  standardexception se
throw new ioexception  se getmessage
private int handlesqlexception  sqlexception e  throws ioexception
if  e getsqlstate   equals
exceptionutil getsqlstatefromidentifier
sqlstate blob_position_too_large
return  1
if  e getsqlstate   equals
exceptionutil getsqlstatefromidentifier
sqlstate blob_invalid_offset
throw new arrayindexoutofboundsexception  e getmessage
throw new ioexception e getmessage
/**
* checks if underlying streamcontrol has been updated.
* @return if stream is modified since created
*/
boolean isobsolete
return updatecount    control getupdatecount
/**
* reinitializes the stream and sets the current pointer to zero.
*/
void reinitialize
updatecount   control getupdatecount
pos   0
/**
* returns size of stream in bytes.
* @return size of stream.
*/
long length    throws ioexception
return control getlength