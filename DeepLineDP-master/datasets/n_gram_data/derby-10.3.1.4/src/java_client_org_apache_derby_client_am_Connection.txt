/*
derby - class org.apache.derby.client.am.connection
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client am
import org apache derby jdbc clientbasedatasource
import org apache derby jdbc clientdatasource
import org apache derby shared common reference jdbc30translation
import org apache derby shared common reference sqlstate
import java sql sqlexception
public abstract class connection implements java sql connection
connectioncallbackinterface
//---------------------navigational members-----------------------------------
public agent agent_
public databasemetadata databasemetadata_
// derby-210 -  weakhashmap is used to store references to objects to avoid
// memory leaks. when there are no other references to the keys in a
// weakhashmap, they will get removed from the map and can thus get
// garbage-collected. they do not have to wait till the connection object
// is collected.
// in connection.markstatementsclosed() method, this list is traversed to get a
// list of open statements, which are marked closed and removed from the list.
final java util weakhashmap openstatements_   new java util weakhashmap
// some statuses of derby objects may be invalid on server
// after both commit and rollback. for example,
// (1) prepared statements need to be re-prepared
//     after both commit and rollback
// (2) result set will be unpositioned on server after both commit and rollback.
// if they depend on both commit and rollback, they need to get on commitandrollbacklisteners_.
final java util weakhashmap commitandrollbacklisteners_   new java util weakhashmap
private sqlwarning warnings_   null
//constant representing an invalid locator value
private static final int invalid_locator    1
// ------------------------properties set for life of connection--------------
// see clientdatasource pre-connect settings
public transient string user_
public boolean retrievemessagetext_
protected boolean jdbcreadonly_
/**
* holdabilty for created statements.
* only access through the holdability method
* to ensure the correct value is returned for an
* xa connection.
*/
private int holdability   jdbc30translation hold_cursors_over_commit
public string databasename_
// holds the product-specific identifier which specifies
// the product release level of a ddm server.
// the max length is 8.
public string productid_
// used to get the public key and encrypt password and/or userid
protected encryptionmanager encryptionmanager_
// used to set transaction isolation level
private statement settransactionisolationstmt   null
// used to get transaction isolation level
private statement gettransactionisolationstmt   null
// ------------------------dynamic properties---------------------------------
protected boolean open_   true
protected boolean availableforreuse_   false
public int isolation_   configuration defaultisolation
public boolean autocommit_   true
protected boolean inunitofwork_   false     this means a transaction is in progress
private boolean accumulated440formessageprocfailure_   false
private boolean accumulated444formessageprocfailure_   false
private boolean accumulatedsetreadonlywarning_   false
//---------------------xa-----------------------------------------------------
protected boolean isxaconnection_   false     indicates an xa connection
// xa states
// the client needs to keep track of the connection's transaction branch association
// per table 2.6 in the xa+ specification in order to determine if commits should flow in
// autocommit mode.  there is no need to keep track of suspended transactions separately from
// xa_to_not_associated.
//
/**
* <code>xa_t0_not_associated</code>
* this connection is not currently associated with an xa transaction
* in this state commits will flow in autocommit mode.
*/
public static final int xa_t0_not_associated   0
/**
* <code>xa_t1_associated</code>
* in this state commits will not flow in autocommit mode.
*/
public static final int xa_t1_associated   1
//todo: remove xa_recover entirely once indoubtlist is gone.
//public static final int xa_recover = 14;
private int xastate_   xa_t0_not_associated
// xa host type
public int xahostversion_   0
public int logintimeout_
public org apache derby jdbc clientbasedatasource datasource_
public string servernameip_
public int portnumber_
public int clientsslmode_   clientbasedatasource ssl_off
public java util hashtable clientcursornamecache_   new java util hashtable
public boolean canusecachedconnectbytes_   false
public int commbuffersize_   32767
// indicates if a deferred reset connection is required
public boolean resetconnectionatfirstsql_   false
//---------------------constructors/finalizer---------------------------------
// for jdbc 2 connections
protected connection org apache derby client am logwriter logwriter
string user
string password
org apache derby jdbc clientbasedatasource datasource
throws sqlexception
initconnection logwriter  user  datasource
protected connection org apache derby client am logwriter logwriter
string user
string password
boolean isxaconn
org apache derby jdbc clientbasedatasource datasource
throws sqlexception
isxaconnection_   isxaconn
initconnection logwriter  user  datasource
// for jdbc 2 connections
protected void initconnection org apache derby client am logwriter logwriter
string user
org apache derby jdbc clientbasedatasource
datasource  throws sqlexception
if  logwriter    null
logwriter traceconnectentry datasource
user_   user
// extract common properties.
// derby-409 fix - append connectionattributes only if it is non-null.
// derby-1130 - append connectionattributes only if database name is
// non-null. this will prevent use of database name set using
// "setconnectionattributes" method.
databasename_   datasource getdatabasename
string connatrrs   datasource getconnectionattributes
if  datasource getcreatedatabase      null     can be   or null
if  connatrrs    null
connatrrs
else
connatrrs   connatrrs
if  datasource getshutdowndatabase      null       or null
if  connatrrs    null
connatrrs
else
connatrrs   connatrrs
if databasename_    null    connatrrs    null
databasename_   databasename_       connatrrs
retrievemessagetext_   datasource getretrievemessagetext
logintimeout_   datasource getlogintimeout
datasource_   datasource
servernameip_   datasource getservername
portnumber_   datasource getportnumber
clientsslmode_
clientbasedatasource getsslmodefromstring datasource getssl
agent_   newagent_ logwriter
logintimeout_
servernameip_
portnumber_
clientsslmode_
// for jdbc 2 connections
protected connection org apache derby client am logwriter logwriter
boolean isxaconn
org apache derby jdbc clientbasedatasource datasource
throws sqlexception
if  logwriter    null
logwriter traceconnectentry datasource
isxaconnection_   isxaconn
user_   clientdatasource propertydefault_user
// extract common properties.
databasename_   datasource getdatabasename
retrievemessagetext_   datasource getretrievemessagetext
logintimeout_   datasource getlogintimeout
datasource_   datasource
servernameip_   datasource getservername
portnumber_   datasource getportnumber
clientsslmode_
clientbasedatasource getsslmodefromstring datasource getssl
agent_   newagent_ logwriter
logintimeout_
servernameip_
portnumber_
clientsslmode_
// this is a callback method, called by subsystem - netconnection
protected void resetconnection logwriter logwriter
string user
clientbasedatasource ds
boolean recomputefromdatasource  throws sqlexception
// clearwarningsx() will re-initialize the following properties
clearwarningsx
user_    user    null  ? user   user_
if  ds    null    recomputefromdatasource       no need to reinitialize connection state if ds hasn't changed
user_    user    null  ? user   ds getuser
retrievemessagetext_   ds getretrievemessagetext
// property encryptionmanager_
// if needed this will later be initialized by net calls to initializepublickeyforencryption()
encryptionmanager_   null
// property: open_
// this should already be true
isolation_   configuration defaultisolation
autocommit_   true
inunitofwork_   false
logintimeout_   ds getlogintimeout
datasource_   ds
holdability   jdbc30translation hold_cursors_over_commit
if  recomputefromdatasource
this agent_ resetagent this  logwriter  logintimeout_  servernameip_  portnumber_
protected void resetconnection logwriter logwriter
string databasename
java util properties properties  throws sqlexception
// clearwarningsx() will re-initialize the following properties
// warnings_, accumulated440formessageprocfailure_,
// accumulated444formessageprocfailure_, and accumulatedsetreadonlywarning_
clearwarningsx
databasename_   databasename
user_   clientdatasource getuser properties
retrievemessagetext_   clientdatasource getretrievemessagetext properties
// property encryptionmanager_
// if needed this will later be initialized by net calls to initializepublickeyforencryption()
encryptionmanager_   null
// property: open_
// this should already be true
isolation_   configuration defaultisolation
autocommit_   true
inunitofwork_   false
this agent_ resetagent this  logwriter  logintimeout_  servernameip_  portnumber_
// for jdbc 1 connections
protected connection logwriter logwriter
int drivermanagerlogintimeout
string servername
int portnumber
string databasename
java util properties properties  throws sqlexception
if  logwriter    null
logwriter traceconnectentry servername  portnumber  databasename  properties
databasename_   databasename
// extract common properties.
user_   clientdatasource getuser properties
retrievemessagetext_   clientdatasource getretrievemessagetext properties
logintimeout_   drivermanagerlogintimeout
servernameip_   servername
portnumber_   portnumber
clientsslmode_   clientdatasource getclientsslmode properties
agent_   newagent_ logwriter
logintimeout_
servernameip_
portnumber_
clientsslmode_
// users are advised to call the method close() on statement and connection objects when they are done with them.
// however, some users will forget, and some code may get killed before it can close these objects.
// therefore, if jdbc drivers have state associated with jdbc objects that need to get
// explicitly cleared up, they should provide finalize methods to take care of them.
// the garbage collector will call these finalize methods when the objects are found to be garbage,
// and this will give the driver a chance to close (or otherwise clean up) the objects.
// note, however, that there is no guarantee that the garbage collector will ever run.
// if that is the case, the finalizers will not be called.
protected void finalize   throws java lang throwable
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
// finalize() differs from close() in that it will not throw an
// exception if a transaction is in progress.
// finalize() also differs from close() in that it will not drive
// an auto-commit before disconnecting.
//
// if a transaction is in progress, a close() request will throw an sqlexception.
// however, if a connection with an incomplete transaction is finalized,
// or is abruptly terminated by application exit,
// the normal rollback semantics imposed by the derby server are adopted.
// so we just pull the plug and let the server handle this default semantic.
if   open_
return
agent_ disconnectevent
super finalize
// ---------------------------jdbc 1------------------------------------------
synchronized public java sql statement createstatement   throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
statement s   createstatementx java sql resultset type_forward_only  java sql resultset concur_read_only  holdability
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     s
return s
catch   sqlexception se
throw se getsqlexception
synchronized public java sql preparedstatement preparestatement string sql  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql
preparedstatement ps   preparestatementx sql
java sql resultset type_forward_only
java sql resultset concur_read_only
holdability
java sql statement no_generated_keys

if  agent_ loggingenabled
agent_ logwriter_ traceexit this     ps
return ps
catch   sqlexception se
throw se getsqlexception
// for internal use only.  use by updatable result set code.
synchronized public preparedstatement preparepositionedupdatestatement string sql  section querysection  throws sqlexception
checkforclosedconnection
// create a net material prepared statement.
preparedstatement preparedstatement   newpositionedupdatepreparedstatement_ sql  querysection
preparedstatement flowpreparedescribeinputoutput
// the positioned update statement is not added to the list of open statements,
// because this would cause a java.util.concurrentmodificationexception when
// iterating thru the list of open statements to call completerollback().
// an updatable result set is marked closed on a call to completerollback(),
// and would therefore need to close the positioned update statement associated with the result set which would cause
// it to be removed from the open statements list. resulting in concurrent modification
// on the open statements list.
// notice that ordinary statement.closex() is never called on the positioned update statement,
// rather markclosed() is called to avoid trying to remove the statement from the openstatements_ list.
return preparedstatement
synchronized public java sql callablestatement preparecall string sql  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql
callablestatement cs   preparecallx sql  java sql resultset type_forward_only  java sql resultset concur_read_only  holdability
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     cs
return cs
catch   sqlexception se
throw se getsqlexception
synchronized preparedstatement preparedynamiccatalogquery string sql  throws sqlexception
preparedstatement ps   newpreparedstatement_ sql  java sql resultset type_forward_only  java sql resultset concur_read_only  holdability    java sql statement no_generated_keys  null
ps iscatalogquery_   true
ps prepare
openstatements_ put ps  null
return ps
public string nativesql string sql  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql
string nativesql   nativesqlx sql
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     nativesql
return nativesql
catch   sqlexception se
throw se getsqlexception
synchronized public string nativesqlx string sql  throws sqlexception
checkforclosedconnection
if  sql    null
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate null_sql_text
// derby can handle the escape syntax directly so only needs escape
// processing for { ? = call  ....}
string trimsql   sql trim
if  trimsql startswith
if  trimsql lastindexof    >  0
return trimsql substring 1  trimsql lastindexof
return trimsql
// driver-specific determination if local commit/rollback is allowed;
// primary usage is distinction between local and global trans. envs.;
protected abstract boolean allowlocalcommitrollback_   throws org apache derby client am sqlexception
synchronized public void setautocommit boolean autocommit  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     autocommit
checkforclosedconnection
if    allowlocalcommitrollback_
if  autocommit       can't toggle to autocommit mode when between xars start   and xars end
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate drda_no_autocommit_under_xa
else
if  autocommit    autocommit_
return     don't flow a commit if nothing changed
if  inunitofwork_
flowcommit       we are not between xars start   and xars end    can flow commit
autocommit_   autocommit
catch   sqlexception se
throw se getsqlexception
public boolean getautocommit   throws sqlexception
try
checkforclosedconnection
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     autocommit_
if    allowlocalcommitrollback_         autocommit is always false between xars start   and xars end
return false
return autocommit_
catch   sqlexception se
throw se getsqlexception
synchronized public void commit   throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
checkforclosedconnection
// the following xa state check must be in commit instead of commitx since
// external application call commit, the sqlexception should be thrown
// only if an external application calls commit during a global transaction,
// internal code will call commitx which will ignore the commit request
// while in a global transaction
checkforinvalidxastateoncommitorrollback
flowcommit
catch   sqlexception se
throw se getsqlexception
private void checkforinvalidxastateoncommitorrollback   throws sqlexception
if    allowlocalcommitrollback_
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate drda_invalid_xa_state_on_commit_or_rollback
public void flowcommit   throws sqlexception
// per jdbc specification (see javadoc for connection.commit()):
//   "this method should be used only when auto-commit mode has been disabled."
// however, some applications do this anyway, it is harmless, so
// if they ask to commit, we could go ahead and flow a commit.
// but note that rollback() is less harmless, rollback() shouldn't be used in auto-commit mode.
// this behavior is subject to further review.
//   if (!this.inunitofwork)
//     return;
// we won't try to be "too smart", if the user requests a commit, we'll flow a commit,
// regardless of whether or not we're in a unit of work or in auto-commit mode.
//
if  isxaconnection_
agent_ beginwritechainoutsideuow
writecommit
agent_ flowoutsideuow
readcommit       this will invoke the commitevent   callback from the material layer
agent_ endreadchain
else
agent_ beginwritechain null
writecommit
agent_ flow null
readcommit       this will invoke the commitevent   callback from the material layer
agent_ endreadchain
// precondition: autocommit_ is true
public boolean flowautocommit   throws sqlexception
if  willautocommitgenerateflow
flowcommit
return true
return false
public boolean willautocommitgenerateflow   throws org apache derby client am sqlexception
if   autocommit_
return false
if    allowlocalcommitrollback_
return false
return true
// precondition: autocommit_ is true
void writeautocommit   throws sqlexception
if  willautocommitgenerateflow
writecommit
public void writecommit   throws sqlexception
if  isxaconnection_
writexacommit_
else
writelocalcommit_
// precondition: autocommit_ is true
void readautocommit   throws sqlexception
if  willautocommitgenerateflow
readcommit
public void readcommit   throws sqlexception
if  isxaconnection_
readxacommit_
else
readlocalcommit_
synchronized public void rollback   throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
checkforclosedconnection
checkforinvalidxastateoncommitorrollback
flowrollback
catch   sqlexception se
throw se getsqlexception
// even if we're not in a transaction, all open result sets will be closed.
// so we could probably just return if we're not in a transaction
// using the following code:
//     if (!this.inunitofwork)
//       return;
// but we'll just play it safe, and blindly flow the rollback.
// we won't try to be "too smart", if the user requests a rollback, we'll flow a rollback,
// regardless of whether or not we're in a unit of work or in auto-commit mode.
//
// per jdbc specification (see javadoc for connection.rollback()):
//   "this method should be used only when auto-commit mode has been disabled."
// however, rather than trying to be too smart, we'll just flow the rollback anyway
// before throwing an exception.
// as a side-effect of invoking rollback() in auto-commit mode,
// we'll close all open result sets on this connection in the rollbackevent().
//
protected void flowrollback   throws sqlexception
if  isxaconnection_
agent_ beginwritechainoutsideuow
writerollback
agent_ flowoutsideuow
readrollback       this method will invoke the rollbackevent   callback from the material layer
agent_ endreadchain
else
agent_ beginwritechain null
writerollback
agent_ flow null
readrollback       this method will invoke the rollbackevent   callback from the material layer
agent_ endreadchain
public void writerollback   throws sqlexception
if  isxaconnection_
writexarollback_
else
writelocalrollback_
public void readrollback   throws sqlexception
if  isxaconnection_
readlocalxarollback_
else
readlocalrollback_
synchronized public void close   throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
closex
void checkfortransactioninprogress   throws sqlexception
// the following precondition matches cli semantics, see sqldisconnect()
if  transactioninprogress       allowcloseinuow_
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate cannot_close_active_connection
public boolean transactioninprogress
return  autocommit_    inunitofwork_
// this is a no-op if the connection is already closed.
synchronized public void closex   throws sqlexception
if   open_
return
closeresourcesx
// close physical socket or attachment even if connection is marked close.
// used by clientpooledconnection.close().
synchronized public void closeresources   throws sqlexception
if  open_      open_    availableforreuse_
availableforreuse_   false
closeresourcesx
private void closeresourcesx   throws sqlexception
try
checkfortransactioninprogress
catch   sqlexception e
throw e getsqlexception
resetconnectionatfirstsql_   false     unset indicator of deferred reset
sqlexception accumulatedexceptions   null
if  settransactionisolationstmt    null
try
settransactionisolationstmt close
catch  sqlexception se
accumulatedexceptions   se
settransactionisolationstmt   null
if  gettransactionisolationstmt    null
try
gettransactionisolationstmt close
catch  sqlexception se
accumulatedexceptions   utils accumulatesqlexception
se  accumulatedexceptions
gettransactionisolationstmt   null
try
flowclose
catch  sqlexception e
accumulatedexceptions
utils accumulatesqlexception
e getsqlexception    accumulatedexceptions
markclosed
try
agent_ close
catch  sqlexception e
throw utils accumulatesqlexception e getsqlexception
accumulatedexceptions
protected abstract boolean isglobalpending_
// just like closex except the socket is not pulled.
// physical resources are not closed.
synchronized public void closeforreuse   throws sqlexception
if   open_
return
resetconnectionatfirstsql_   false     unset indicator of deferred reset
sqlexception accumulatedexceptions   null
try
flowclose
catch  sqlexception e
accumulatedexceptions   e
if  open_
markclosedforreuse
if  accumulatedexceptions    null
throw accumulatedexceptions
private void flowclose   throws sqlexception
agent_ beginwritechainoutsideuow
if  doclosestatementsonclose_
writeclosestatements
if  autocommit_
writeautocommit
agent_ flowoutsideuow
if  doclosestatementsonclose_
readclosestatements
if  autocommit_
readautocommit
agent_ endreadchain
protected abstract void markclosed_
public void markclosed      called by logicalconnection close
open_   false
inunitofwork_   false
markstatementsclosed
commitandrollbacklisteners_ clear
markclosed_
private void markclosedforreuse
availableforreuse_   true
markclosed
private void markstatementsclosed
java util set keyset   openstatements_ keyset
for  java util iterator i   keyset iterator    i hasnext
statement stmt    statement  i next
stmt markclosed
i remove
private void writeclosestatements   throws sqlexception
java util set keyset   openstatements_ keyset
for  java util iterator i   keyset iterator    i hasnext
statement  i next    writeclose false       false means don't permit auto commits
private void readclosestatements   throws sqlexception
java util set keyset   openstatements_ keyset
for  java util iterator i   keyset iterator    i hasnext
statement  i next    readclose false       false means don't permit auto commits
/**
* 	return true if the physical connection is still open.
* 	might be logically closed but available for reuse.
*   @return true if physical connection still open
*/
public boolean isphysicalconnclosed
return  open_     availableforreuse_
public boolean isclosed
if  agent_ loggingenabled
agent_ logwriter_ traceexit this      open_
return  open_
public boolean isclosedx
return  open_
private static string derby_transaction_repeatable_read
private static string derby_transaction_serializable
private static string derby_transaction_read_committed
private static string derby_transaction_read_uncommitted
synchronized public void settransactionisolation int level  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     level
// per jdbc spec (see java.sql.connection.close() javadoc).
checkforclosedconnection
// javadoc for this method:
//   if this method is called during a transaction, the result is implementation-defined.
//
//
// repeatable_read = jdbc: transaction_serializable, derby: rr, protocol: repeatable read
// read_stability = jdbc: transaction_repeatable_read, derby: rs, protocol: all
// cursor_stability = jdbc: transaction_read_committed, derby: cs, protocol: cursor stability
// uncommitted_read = jdbc: transaction_read_uncommitted, derby: ur , protocol: change
// no_commit = jdbc: transaction_none, derby: nc, protocol: no commit
//
string levelstring   null
switch  level
case java sql connection transaction_repeatable_read
levelstring   derby_transaction_repeatable_read
break
case java sql connection transaction_read_committed
levelstring   derby_transaction_read_committed
break
case java sql connection transaction_serializable
levelstring   derby_transaction_serializable
break
case java sql connection transaction_read_uncommitted
levelstring   derby_transaction_read_uncommitted
break
// per javadoc:
//   note that connection.transaction_none cannot be used because it specifies that transactions are not supported.
case java sql connection transaction_none
default
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate unimplemented_isolation_level
new integer level
if  settransactionisolationstmt    null
settransactionisolationstmt openonclient_
settransactionisolationstmt openonserver_
settransactionisolationstmt
createstatementx java sql resultset type_forward_only
java sql resultset concur_read_only
holdability
settransactionisolationstmt executeupdate     levelstring
// the server has now implicitely committed the
// transaction so we have to clean up locally.
completelocalcommit
isolation_   level
catch   sqlexception se
throw se getsqlexception
public int gettransactionisolation   throws sqlexception
// store the current auto-commit value and use it to restore
// at the end of this method.
boolean currentautocommit   autocommit_
java sql resultset rs   null
try
checkforclosedconnection
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     isolation_
// set auto-commit to false when executing the statement as we do not want to
// cause an auto-commit from gettransactionisolation() method.
autocommit_   false
// derby-1148 - client reports wrong isolation level. we need to get the isolation
// level from the server. 'isolation_' maintained in the client's connection object
// can be out of sync with the real isolation when in an xa transaction. this can
// also happen when isolation is set using sql instead of jdbc. so we try to get the
// value from the server by calling the "current isolation" function. if we fail to
// get the value, return the value stored in the client's connection object.
if  gettransactionisolationstmt    null
gettransactionisolationstmt openonclient_
gettransactionisolationstmt openonserver_
gettransactionisolationstmt
createstatementx java sql resultset type_forward_only
java sql resultset concur_read_only
holdability
boolean savedinunitofwork   inunitofwork_
rs   gettransactionisolationstmt executequery
rs next
string isolationstr   rs getstring 1
isolation_   translateisolation isolationstr
rs close
// so... of we did not have an active transaction before
// the query, we pretend to still not have an open
// transaction. the result set is closed, so this should
// not be problematic. derby-2084
inunitofwork_   savedinunitofwork
catch   sqlexception se
throw se getsqlexception
finally
// restore auto-commit value
autocommit_   currentautocommit
if rs    null
rs close
return isolation_
/**
* translates the isolation level from a sql string to the jdbc int value
*
* @param isolationstr sql isolation string
* @return isolation level as a jdbc integer value
*/
private int translateisolation string isolationstr
if isolationstr compareto derby_transaction_repeatable_read     0
return java sql connection transaction_repeatable_read
else if  isolationstr compareto derby_transaction_serializable     0
return java sql connection transaction_serializable
else if  isolationstr compareto derby_transaction_read_committed     0
return java sql connection transaction_read_committed
else if  isolationstr compareto derby_transaction_read_uncommitted     0
return java sql connection transaction_read_uncommitted
else
return java sql connection transaction_none
public java sql sqlwarning getwarnings   throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     warnings_
try
checkforclosedconnection
catch  sqlexception se
throw se getsqlexception
return warnings_    null ? null   warnings_ getsqlwarning
synchronized public void clearwarnings   throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
checkforclosedconnection
clearwarningsx
catch   sqlexception se
throw se getsqlexception
// an untraced version of clearwarnings()
public void clearwarningsx   throws sqlexception
warnings_   null
accumulated440formessageprocfailure_   false
accumulated444formessageprocfailure_   false
accumulatedsetreadonlywarning_   false
//======================================================================
// advanced features:
public java sql databasemetadata getmetadata   throws sqlexception
try
checkforclosedconnection
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     databasemetadata_
return databasemetadata_
catch   sqlexception se
throw se getsqlexception
synchronized public void setreadonly boolean readonly  throws sqlexception
try
// this is a hint to the driver only, so this request is silently ignored.
// protocol can only flow a set-read-only before the connection is established.
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     readonly
checkforclosedconnection
catch   sqlexception se
throw se getsqlexception
public boolean isreadonly   throws sqlexception
try
checkforclosedconnection
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     jdbcreadonly_
return false
catch   sqlexception se
throw se getsqlexception
synchronized public void setcatalog string catalog  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     catalog
checkforclosedconnection
// per jdbc spec: if the driver does not support catalogs, it will silently ignore this request.
catch   sqlexception se
throw se getsqlexception
public string getcatalog   throws sqlexception
try
checkforclosedconnection
if  agent_ loggingenabled
agent_ logwriter_ traceexit this      string  null
return null
catch   sqlexception se
throw se getsqlexception
//--------------------------jdbc 2.0-----------------------------
synchronized public java sql statement createstatement int resultsettype
int resultsetconcurrency  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     resultsettype  resultsetconcurrency
statement s   createstatementx resultsettype  resultsetconcurrency  holdability
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     s
return s
catch   sqlexception se
throw se getsqlexception
synchronized public java sql preparedstatement preparestatement string sql
int resultsettype
int resultsetconcurrency  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  resultsettype  resultsetconcurrency
preparedstatement ps   preparestatementx sql
resultsettype
resultsetconcurrency
holdability
java sql statement no_generated_keys

if  agent_ loggingenabled
agent_ logwriter_ traceexit this     ps
return ps
catch   sqlexception se
throw se getsqlexception
synchronized public java sql callablestatement preparecall string sql
int resultsettype
int resultsetconcurrency  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  resultsettype  resultsetconcurrency
callablestatement cs   preparecallx sql  resultsettype  resultsetconcurrency  holdability
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     cs
return cs
catch   sqlexception se
throw se getsqlexception
synchronized public callablestatement preparemessageproc string sql  throws sqlexception
checkforclosedconnection
callablestatement cs   preparecallx sql  java sql resultset type_forward_only  java sql resultset concur_read_only  holdability
return cs
// per jdbc spec, when a result set type is unsupported, we downgrade and
// issue a warning rather than to throw an exception.
private int downgraderesultsettype int resultsettype
if  resultsettype    java sql resultset type_scroll_sensitive
accumulatewarning new sqlwarning agent_ logwriter_
new clientmessageid sqlstate scroll_sensitive_not_supported
return java sql resultset type_scroll_insensitive
return resultsettype
public java util map gettypemap   throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
checkforclosedconnection
java util map map   new java util hashmap
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     map
return map
catch   sqlexception se
throw se getsqlexception
synchronized public void settypemap java util map map  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     map
checkforclosedconnection
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate not_implemented
catch   sqlexception se
throw se getsqlexception
//--------------------------jdbc 3.0-----------------------------
synchronized public void setholdability int holdability  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     holdability
checkforclosedconnection
// in an xa global transaction do not allow the
// holdability to be set to hold cursors across
// commits, as the engine does not support it.
if  this isxaconnection_    this xastate_    xa_t1_associated
if  holdability    jdbc30translation hold_cursors_over_commit
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate cannot_hold_cursor_xa
this holdability   holdability
catch   sqlexception se
throw se getsqlexception
public int getholdability   throws sqlexception
try
checkforclosedconnection
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     holdability
return holdability
catch   sqlexception se
throw se getsqlexception
public int dncgeneratedsavepointid_
// generated name used internally for unnamed savepoints
public static final string dncgeneratedsavepointnameprefix__
synchronized public java sql savepoint setsavepoint   throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
checkforclosedconnection
if  autocommit_     throw exception if auto commit is on
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate no_savepoint_when_auto
// create an un-named savepoint.
if     dncgeneratedsavepointid_  < 0
dncgeneratedsavepointid_   1     restart from 1 when overflow
object s   setsavepointx new savepoint agent_  dncgeneratedsavepointid_
return  java sql savepoint  s
catch   sqlexception se
throw se getsqlexception
synchronized public java sql savepoint setsavepoint string name  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     name
checkforclosedconnection
if  name    null     throw exception if savepoint name is null
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate null_name_for_savepoint
else if  autocommit_     throw exception if auto commit is on
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate no_savepoint_when_auto
// create a named savepoint.
object s   setsavepointx new savepoint agent_  name
return  java sql savepoint  s
catch   sqlexception se
throw se getsqlexception
private savepoint setsavepointx savepoint savepoint  throws sqlexception
// construct and flow a savepoint statement to server.
statement stmt   null
try
stmt    statement  createstatementx java sql resultset type_forward_only
java sql resultset concur_read_only
holdability
string savepointname
try
savepointname   savepoint getsavepointname
catch  sqlexception e
// generate the name for an un-named savepoint.
savepointname   dncgeneratedsavepointnameprefix__
savepoint getsavepointid
string sql
stmt executex sql
catch   sqlexception se
throw se getsqlexception
finally
if  stmt    null
try
stmt closex
catch  sqlexception donothing
return savepoint
synchronized public void rollback java sql savepoint savepoint  throws sqlexception
try
int savexastate   xastate_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     savepoint
checkforclosedconnection
if  savepoint    null     throw exception if savepoint is null
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate xact_savepoint_release_rollback_fail
else if  autocommit_     throw exception if auto commit is on
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate no_savepoint_rollback_or_release_when_auto
// only allow to rollback to a savepoint from the connection that create the savepoint.
try
if  this      savepoint  savepoint  agent_ connection_
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate savepoint_not_created_by_connection
catch  java lang classcastexception e       savepoint is not an instance of am savepoint
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate savepoint_not_created_by_connection
// construct and flow a savepoint rollback statement to server.
statement stmt   null
try
stmt   createstatementx java sql resultset type_forward_only
java sql resultset concur_read_only
holdability
string savepointname
try
savepointname     savepoint  savepoint  getsavepointname
catch  sqlexception e
// generate the name for an un-named savepoint.
savepointname   dncgeneratedsavepointnameprefix__
savepoint  savepoint  getsavepointid
string sql
stmt executex sql
finally
if  stmt    null
try
stmt closex
catch  sqlexception donothing
xastate_   savexastate
catch   sqlexception se
throw se getsqlexception
synchronized public void releasesavepoint java sql savepoint savepoint  throws sqlexception
try
int savexastate   xastate_
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     savepoint
checkforclosedconnection
if  savepoint    null     throw exception if savepoint is null
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate xact_savepoint_release_rollback_fail
else if  autocommit_     throw exception if auto commit is on
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate no_savepoint_rollback_or_release_when_auto
// only allow to release a savepoint from the connection that create the savepoint.
try
if  this      savepoint  savepoint  agent_ connection_
throw new sqlexception agent_ logwriter_  new clientmessageid
sqlstate savepoint_not_created_by_connection
catch  java lang classcastexception e       savepoint is not an instance of am savepoint
throw new sqlexception agent_ logwriter_  new clientmessageid
sqlstate savepoint_not_created_by_connection
// construct and flow a savepoint release statement to server.
statement stmt   null
try
stmt    statement  createstatementx java sql resultset type_forward_only
java sql resultset concur_read_only
holdability
string savepointname
try
savepointname     savepoint  savepoint  getsavepointname
catch  sqlexception e
// generate the name for an un-named savepoint.
savepointname   dncgeneratedsavepointnameprefix__
savepoint  savepoint  getsavepointid
string sql
stmt executex sql
finally
if  stmt    null
try
stmt closex
catch  sqlexception donothing
xastate_   savexastate
catch   sqlexception se
throw se getsqlexception
synchronized public java sql statement createstatement int resultsettype
int resultsetconcurrency
int resultsetholdability  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     resultsettype  resultsetconcurrency  resultsetholdability
statement s   createstatementx resultsettype  resultsetconcurrency  resultsetholdability
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     s
return s
catch   sqlexception se
throw se getsqlexception
private statement createstatementx int resultsettype
int resultsetconcurrency
int resultsetholdability  throws sqlexception
checkforclosedconnection
resultsettype   downgraderesultsettype resultsettype
// in an xa global transaction do not allow the
// holdability to be set to hold cursors across
// commits, as the engine does not support it.
// downgrade the holdability to close_cursors_at_commit
// and attach a warning. this is specified in
// jdbc 4.0 (proposed final draft) section 16.1.3.1
// similar code is not needed for preparedstatement
// as the holdability gets pushed all the way to the
// engine and handled there.
if  this isxaconnection_    this xastate_    xa_t1_associated
if  resultsetholdability    jdbc30translation hold_cursors_over_commit
resultsetholdability   jdbc30translation close_cursors_at_commit
accumulatewarning new sqlwarning agent_ logwriter_
new clientmessageid sqlstate holdable_result_set_not_available
statement s   newstatement_ resultsettype  resultsetconcurrency  resultsetholdability
s cursorattributestosendonprepare_   s cachecursorattributestosendonprepare
openstatements_ put s  null
return s
// not sure if holding on to cursorattributestosendonprepare and restoring it is the
// right thing to do here... because if property on the datasource changes, we may have
// to send different attributes, i.e. sensitive dynamic, instead of sensitive static.
protected void resetstatement statement s  throws sqlexception
string cursorattributestosendonprepare   s cursorattributestosendonprepare_
resetstatement_ s  s resultsettype_  s resultsetconcurrency_  s resultsetholdability_
s cursorattributestosendonprepare_   cursorattributestosendonprepare
synchronized public java sql preparedstatement preparestatement string sql
int resultsettype
int resultsetconcurrency
int resultsetholdability  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  resultsettype  resultsetconcurrency  resultsetholdability
preparedstatement ps   preparestatementx sql
resultsettype
resultsetconcurrency
resultsetholdability
java sql statement no_generated_keys

if  agent_ loggingenabled
agent_ logwriter_ traceexit this     ps
return ps
catch   sqlexception se
throw se getsqlexception
// used by dbmd
preparedstatement preparestatementx string sql
int resultsettype
int resultsetconcurrency
int resultsetholdability
int autogeneratedkeys
string columnnames  throws sqlexception
checkforclosedconnection
checkautogeneratedkeysparameters autogeneratedkeys  columnnames
resultsettype   downgraderesultsettype resultsettype
preparedstatement ps   newpreparedstatement_ sql  resultsettype  resultsetconcurrency  resultsetholdability  autogeneratedkeys  columnnames
ps cursorattributestosendonprepare_   ps cachecursorattributestosendonprepare
ps prepare
openstatements_ put ps null
return ps
// not sure if holding on to cursorattributestosendonprepare and restoring it is the
// right thing to do here... because if property on the datasource changes, we may have
// to send different attributes, i.e. sensitive dynamic, instead of sensitive static.
protected void resetpreparestatement preparedstatement ps  throws sqlexception
string cursorattributestosendonprepare   ps cursorattributestosendonprepare_
resetpreparedstatement_ ps  ps sql_  ps resultsettype_  ps resultsetconcurrency_  ps resultsetholdability_  ps autogeneratedkeys_  ps generatedkeyscolumnnames_
ps cursorattributestosendonprepare_   cursorattributestosendonprepare
ps prepare
synchronized public java sql callablestatement preparecall string sql
int resultsettype
int resultsetconcurrency
int resultsetholdability  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  resultsettype  resultsetconcurrency  resultsetholdability
callablestatement cs   preparecallx sql  resultsettype  resultsetconcurrency  resultsetholdability
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     cs
return cs
catch   sqlexception se
throw se getsqlexception
callablestatement preparecallx string sql
int resultsettype
int resultsetconcurrency
int resultsetholdability  throws sqlexception
checkforclosedconnection
resultsettype   downgraderesultsettype resultsettype
callablestatement cs   newcallablestatement_ sql  resultsettype  resultsetconcurrency  resultsetholdability
cs cursorattributestosendonprepare_   cs cachecursorattributestosendonprepare
cs prepare
openstatements_ put cs null
return cs
protected void resetpreparecall callablestatement cs  throws sqlexception
string cursorattributestosendonprepare   cs cursorattributestosendonprepare_
resetcallablestatement_ cs  cs sql_  cs resultsettype_  cs resultsetconcurrency_  cs resultsetholdability_
cs cursorattributestosendonprepare_   cursorattributestosendonprepare
cs prepare
public java sql preparedstatement preparestatement string sql  int autogeneratedkeys  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  autogeneratedkeys
preparedstatement ps   preparestatementx sql
java sql resultset type_forward_only
java sql resultset concur_read_only
holdability
autogeneratedkeys

if  agent_ loggingenabled
agent_ logwriter_ traceexit this     ps
return ps
catch   sqlexception se
throw se getsqlexception
public java sql preparedstatement preparestatement string sql  int columnindexes  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  columnindexes
checkforclosedconnection
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate not_implemented
catch   sqlexception se
throw se getsqlexception
public java sql preparedstatement preparestatement string sql  string columnnames  throws sqlexception
try
if  agent_ loggingenabled
agent_ logwriter_ traceentry this     sql  columnnames
preparedstatement ps   preparestatementx sql
java sql resultset type_forward_only
java sql resultset concur_read_only
holdability
java sql statement return_generated_keys
columnnames
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     ps
return ps
catch   sqlexception se
throw se getsqlexception
// ---------------------------------------------------------------------------
protected abstract boolean allowcloseinuow_
protected abstract boolean doclosestatementsonclose_
public abstract sectionmanager newsectionmanager string collection
agent agent
string databasename
//--------------------abstract material factory methods-----------------
protected abstract agent newagent_ logwriter logwriter  int logintimeout  string servername  int portnumber  int clientsslmode  throws sqlexception
protected abstract databasemetadata newdatabasemetadata_
protected abstract statement newstatement_ int type
int concurrency
int holdability  throws sqlexception
protected abstract void resetstatement_ statement statement
int type
int concurrency
int holdability  throws sqlexception
protected abstract preparedstatement newpositionedupdatepreparedstatement_ string sql  section section  throws sqlexception
protected abstract preparedstatement newpreparedstatement_ string sql
int type
int concurrency
int holdability
int autogeneratedkeys
string columnnames  throws sqlexception
protected abstract void resetpreparedstatement_ preparedstatement ps
string sql
int resultsettype
int resultsetconcurrency
int resultsetholdability
int autogeneratedkeys
string columnnames  throws sqlexception
protected abstract callablestatement newcallablestatement_ string sql
int type
int concurrency
int holdability  throws sqlexception
protected abstract void resetcallablestatement_ callablestatement cs
string sql
int resultsettype
int resultsetconcurrency
int resultsetholdability  throws sqlexception
// ----------------------- abstract box car and callback methods ---------------------
// all callbacks must be client-side only operations.
public void completeconnect   throws sqlexception
open_   true
databasemetadata_   newdatabasemetadata_
agent_ sectionmanager_
newsectionmanager
agent_
databasename_
if  agent_ loggingenabled
agent_ logwriter_ traceconnectexit this
public abstract void writecommitsubstitute_   throws sqlexception
public abstract void readcommitsubstitute_   throws sqlexception
public abstract void writelocalxastart_   throws sqlexception
public abstract void readlocalxastart_   throws sqlexception
public abstract void writelocalxacommit_   throws sqlexception
protected abstract void writexacommit_   throws sqlexception
public abstract void readlocalxacommit_   throws sqlexception
protected abstract void readxacommit_   throws sqlexception
public abstract void writelocalcommit_   throws sqlexception
public abstract void readlocalcommit_   throws sqlexception
protected abstract void writexatransactionstart statement statement
throws sqlexception
public void completelocalcommit
java util set keyset   commitandrollbacklisteners_ keyset
for  java util iterator i   keyset iterator    i hasnext
unitofworklistener listener    unitofworklistener  i next
listener completelocalcommit i
inunitofwork_   false
public abstract void writelocalrollback_   throws sqlexception
public abstract void readlocalrollback_   throws sqlexception
// a callback for certain non-fatal exceptions that occur when parsing error replies.
// this is a client-side only operation.
// this method will only throw an exception on bug check.
public void completelocalrollback
java util set keyset   commitandrollbacklisteners_ keyset
for  java util iterator i   keyset iterator    i hasnext
unitofworklistener listener    unitofworklistener  i next
listener completelocalrollback i
inunitofwork_   false
/**
*
* rollback the specific unitofworklistener.
* @param uwl the unitofworklitener to be rolled back
*
*/
public void completespecificrollback unitofworklistener uwl
java util set keyset   commitandrollbacklisteners_ keyset
for  java util iterator i   keyset iterator    i hasnext
unitofworklistener listener    unitofworklistener  i next
if listener    uwl
listener completelocalrollback i
break
inunitofwork_   false
public abstract void writelocalxarollback_   throws sqlexception
protected abstract void writexarollback_   throws sqlexception
public abstract void readlocalxarollback_   throws sqlexception
protected abstract void readxarollback_   throws sqlexception
public void writetransactionstart statement statement  throws sqlexception
if  isxaconnection_
writexatransactionstart  statement
public void readtransactionstart   throws sqlexception
completetransactionstart
void completetransactionstart
inunitofwork_   true
// occurs autonomously
public void completeabnormalunitofwork
completelocalrollback
/**
*
* rollback the unitofworklistener specifically.
* @param uwl the unitofworklistener to be rolled back.
*
*/
public void completeabnormalunitofwork unitofworklistener uwl
completespecificrollback uwl
// called by connection.close(), netconnection.errorrollbackdisconnect().
// the agent's client-side resources associated with database connection are reclaimed (eg. socket).
// and this connection and all associated statements and result sets are marked closed.
// this is a client-side only operation.
// this method will only throw an exception if the agent cannot be closed.
public void completechainbreakingdisconnect
open_   false
completelocalrollback
markstatementsclosed
public void completesqlca sqlca sqlca
if  sqlca    null
else if  sqlca getsqlcode   > 0
accumulatewarning new sqlwarning agent_ logwriter_  sqlca
else if  sqlca getsqlcode   < 0
agent_ accumulatereadexception new sqlexception agent_ logwriter_  sqlca
public abstract void addspecialregisters string s
// can this only be called by the pooledconnection
// can this be called on a closed connection
// can this be called in a unit of work
// can this be called from within a stored procedure
//
synchronized public void reset logwriter logwriter  string user
string password  clientbasedatasource ds
boolean recomputefromdatasource  throws sqlexception
if  logwriter    null
logwriter traceconnectresetentry this  logwriter  user
ds    null  ? ds   datasource_
try
reset_ logwriter  user  password  ds  recomputefromdatasource
catch  sqlexception sqle
disconnectexception de   new disconnectexception agent_
new clientmessageid sqlstate connection_failed_on_reset
de setnextexception sqle
throw de
synchronized public void reset logwriter logwriter  clientbasedatasource ds
boolean recomputefromdatasource  throws sqlexception
if  logwriter    null
logwriter traceconnectresetentry this  logwriter  null   ds    null  ? ds   datasource_
try
reset_ logwriter  ds  recomputefromdatasource
catch  sqlexception sqle
disconnectexception de   new disconnectexception agent_
new clientmessageid sqlstate connection_failed_on_reset
de setnextexception sqle
throw de
synchronized public void lightreset   throws sqlexception
if   open_     availableforreuse_
return
open_   true
availableforreuse_   false
abstract protected void reset_ logwriter logwriter  string user
string password  clientbasedatasource ds
boolean recomputerfromdatasource  throws sqlexception
abstract protected void reset_ logwriter logwriter
clientbasedatasource ds
boolean recomputerfromdatasource  throws sqlexception
protected void completereset boolean isdeferredreset  boolean recomputefromdatasource  throws sqlexception
open_   true
completelocalrollback       this will close the cursors if the physical connection hadn't been closed for reuse properly
// reopen physical statement resources associated with previous uses of this physical connection.
// notice that these physical statements may not belong to this logical connection.
// iterate through the physical statements and re-enable them for reuse.
java util set keyset   openstatements_ keyset
for  java util iterator i   keyset iterator    i hasnext
object o   i next
statement  o  reset recomputefromdatasource
if   isdeferredreset    agent_ loggingenabled
agent_ logwriter_ traceconnectresetexit this
/**
* reference to object with prepared statements for calling the locator
* procedures. makes it possible to reuse prepared statements within
* the connection.
*/
private callablelocatorprocedures lobprocs
/**
* get handle to the object that contains prepared statements for calling
* locator procedures for this connection.  the object will be created on
* the first invocation.
*
* an example of how to call a stored procedure via this method:
* <pre> <code>
*    connection.locatorprocedurecall().blobreleaselocator(locator);
* </code> </pre>
*
* @return object with prepared statements for calling locator procedures
*/
callablelocatorprocedures locatorprocedurecall
if  lobprocs    null
lobprocs   new callablelocatorprocedures this
return lobprocs
//-------------------------------helper methods-------------------------------
protected void checkforclosedconnection   throws sqlexception
if   open_
agent_ checkfordeferredexceptions
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate no_current_connection
else
agent_ checkfordeferredexceptions
void checkautogeneratedkeysparameters int autogeneratedkeys  string columnnames  throws sqlexception
if  autogeneratedkeys    java sql statement no_generated_keys
autogeneratedkeys    java sql statement return_generated_keys
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate bad_auto_gen_key_value
new integer  autogeneratedkeys
if  columnnames    null
throw new sqlexception agent_ logwriter_
new clientmessageid  sqlstate not_implemented
public boolean isxaconnection
return isxaconnection_
public int getxastate
return xastate_
public void setxastate int state
xastate_   state
public void accumulatewarning sqlwarning e
if  warnings_    null
warnings_   e
else
warnings_ setnextexception e
public void accumulate440warningformessageprocfailure sqlwarning e
if   accumulated440formessageprocfailure_
accumulatewarning e
accumulated440formessageprocfailure_   true
public void accumulate444warningformessageprocfailure sqlwarning e
if   accumulated444formessageprocfailure_
accumulatewarning e
accumulated444formessageprocfailure_   true
// get the server version
public int getserverversion
return databasemetadata_ productlevel_ versionlevel_
public void setinunitofwork boolean inunitofwork
inunitofwork_   inunitofwork
/**
* return the holdabilty for the connection. matches the
* embedded driver in the restriction that while in a
* global (xa) transaction the holdability is close_cursors_at_commit.
* otherwise return the holdability set by the user.
*/
final int holdability
if  this isxaconnection_    this xastate_    xa_t1_associated
return jdbc30translation close_cursors_at_commit
return holdability
/**
* constructs an object that implements the <code>clob</code> interface.
* the object returned initially contains no data.
*
* @return an object that implements the <code>clob</code> interface
* @throws java.sql.sqlexception if an object that implements the
* <code>clob</code> interface can not be constructed.
*/
public clob createclob   throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
try
checkforclosedconnection
catch  sqlexception se
throw se getsqlexception
//stores a locator value obtained by calling the
//stored procedure clobcreatelocator.
int locator   invalid_locator
//stores the clob instance that is returned.
org apache derby client am clob clob   null
//call the clobcreatelocator stored procedure
//that will return a locator value.
try
locator   locatorprocedurecall   clobcreatelocator
catch sqlexception sqle
throw sqle getsqlexception
//if the locator value is -1 it means that we do not
//have locator support on the server.
//the code here has been disabled because the lob implementations
//have still not been completely converted to use locators. once
//the lob implementations are completed then this code can be enabled.
if  locator    invalid_locator
//a valid locator value has been obtained.
clob   new org apache derby client am clob this agent_  locator
else
//a valid locator value could not be obtained.
clob   new org apache derby client am clob
this agent_
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     clob
return clob
/**
* constructs an object that implements the <code>blob</code> interface.
* the object returned initially contains no data.
*
* @return an object that implements the <code>blob</code> interface
* @throws sqlexception if an object that implements the
* </code>blob</code> interface can not be constructed.
*
*/
public blob createblob   throws sqlexception
if  agent_ loggingenabled
agent_ logwriter_ traceentry this
try
checkforclosedconnection
catch  sqlexception se
throw se getsqlexception
//stores a locator value obtained by calling the
//stored procedure blobcreatelocator.
int locator   invalid_locator
//stores the blob instance that is returned.
org apache derby client am blob blob   null
//call the blobcreatelocator stored procedure
//that will return a locator value.
try
locator   locatorprocedurecall   blobcreatelocator
catch sqlexception sqle
throw sqle getsqlexception
//if the locator value is -1 it means that we do not
//have locator support on the server.
if  locator    invalid_locator
//a valid locator value has been obtained.
blob   new org apache derby client am blob this agent_  locator
else
//a valid locator value could not be obtained.
blob   new org apache derby client am blob
new byte this agent_  0
if  agent_ loggingenabled
agent_ logwriter_ traceexit this     blob
return blob