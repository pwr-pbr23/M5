/*
derby - class org.apache.derby.impl.services.locks.lockset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services locks
import org apache derby iapi services locks compatibilityspace
import org apache derby iapi services locks latch
import org apache derby iapi services locks lockable
import org apache derby iapi services locks c_lockfactory
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services diag diagnosticutil
import org apache derby iapi reference property
import org apache derby iapi reference sqlstate
import java util hashmap
import java util enumeration
import java util iterator
import java util map
/**
a lockset is a complete lock table.	a lock table is a hash table
keyed by a lockable and with a lockcontrol as the data element.
<p>
a lockcontrol contains information about the locks held on a lockable.
<br>
mt - mutable - container object : all non-private methods of this class are
thread safe unless otherwise stated by their javadoc comments.
<br>
all searching of
the hashtable is performed using java synchroization(this).
<br>
the class creates activelock and lockcontrol objects.
lockcontrol objects are never passed out of this class, all the methods of
lockcontrol are called while being synchronized on this, thus providing the
single threading that lockcontrol required.
methods of lockables are only called by this class or lockcontrol, and
always while being synchronized on this, thus providing the single
threading that lockable requires.
@see lockcontrol
*/
final class lockset implements locktable
/*
** fields
*/
private final singlepool factory
/** hash table which maps <code>lockable</code> objects to
* <code>lock</code>s. */
private final hashmap locks
/**
timeout for deadlocks, in ms.
<br>
mt - immutable
*/
private int deadlocktimeout   property deadlock_timeout_default   1000
private int waittimeout   property wait_timeout_default   1000
//exclude-start-lockdiag-
// this varible is set and get without synchronization.
// only one thread should be setting it at one time.
private boolean deadlocktrace
//exclude-end-lockdiag-
// the number of waiters for locks
private int blockcount
/*
** constructor
*/
protected lockset singlepool factory
this factory   factory
locks   new hashmap
/*
** public methods
*/
/**
*	lock an object within a specific compatibility space.
*
*	@param	compatibilityspace compatibility space.
*	@param	ref lockable reference.
*	@param	qualifier qualifier.
*	@param	timeout timeout in milli-seconds
*
*	@return	object that represents the lock.
*
*	@exception	standardexception standard derby policy.
*/
public lock lockobject compatibilityspace compatibilityspace  lockable ref
object qualifier  int timeout
throws standardexception
if  sanitymanager debug
if  sanitymanager debug_on
if  locks size   > 1000
system out println
locks size
control gc
lockcontrol control
lock lockitem
string  lockdebug   null
synchronized  this
gc   getcontrol ref
if  gc    null
// object is not locked, can be granted
lock gl   new lock compatibilityspace  ref  qualifier
gl grant
locks put ref  gl
return gl
control   gc getlockcontrol
if  control    gc
locks put ref  control
if  sanitymanager debug
sanitymanager assert ref equals control getlockable
// assert item is in the list
if  getcontrol control getlockable       control
sanitymanager throwassert
getcontrol control getlockable          control
lockitem   control addlock this  compatibilityspace  qualifier
if  lockitem getcount      0
return lockitem
if  timeout    c_lockfactory no_wait
// remove all trace of lock
control giveupwait lockitem  this
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager showtrace new throwable
// the following dumps the lock table as it
// exists at the time a timeout is about to
// cause a deadlock exception to be thrown.
lockdebug
diagnosticutil todiagstring lockitem
this todebugstring
return null
synchronized block
boolean deadlockwait   false
int actualtimeout
if  timeout    c_lockfactory wait_forever
// always check for deadlocks as there should not be any
deadlockwait   true
if   actualtimeout   deadlocktimeout     c_lockfactory wait_forever
actualtimeout   property deadlock_timeout_default   1000
else
if  timeout    c_lockfactory timed_wait
timeout   actualtimeout   waittimeout
else
actualtimeout   timeout
// five posible cases
// i)   timeout -1, deadlock -1         ->
//          just wait forever, no deadlock check
// ii)  timeout >= 0, deadlock -1       ->
//          just wait for timeout, no deadlock check
// iii) timeout -1, deadlock >= 0       ->
//          wait for deadlock, then deadlock check,
//          then infinite timeout
// iv)  timeout >=0, deadlock < timeout ->
//          wait for deadlock, then deadlock check,
//          then wait for (timeout - deadlock)
// v)   timeout >=0, deadlock >= timeout ->
//          just wait for timeout, no deadlock check
if  deadlocktimeout >  0
if  actualtimeout < 0
// infinite wait but perform a deadlock check first
deadlockwait   true
actualtimeout   deadlocktimeout
else if  deadlocktimeout < actualtimeout
// deadlock wait followed by a timeout wait
deadlockwait   true
actualtimeout   deadlocktimeout
// leave timeout as the remaining time
timeout    deadlocktimeout
activelock waitinglock    activelock  lockitem
lockitem   null
int earlywakeupcount   0
long startwaittime   0
forever 	for
byte wakeupreason   waitinglock waitforgrant actualtimeout
activelock nextwaitinglock   null
object deadlockdata   null
try
boolean willquitwait
enumeration timeoutlocktable   null
long currenttime   0
synchronized  this
if  control isgrantable
control firstwaiter      waitinglock
compatibilityspace
qualifier
// yes, we are granted, put us on the granted queue.
control grant waitinglock
// remove from the waiting queue & get next waiter
nextwaitinglock
control getnextwaiter waitinglock  true  this
return waitinglock
// try again later
waitinglock clearpotentiallygranted
willquitwait
wakeupreason    constants waiting_lock_grant
if    wakeupreason    constants waiting_lock_in_wait
deadlockwait
wakeupreason    constants waiting_lock_deadlock
// check for a deadlock, even if we were woken up
// because we were selected as a victim we still
// check because the situation may have changed.
deadlockdata
deadlock look
factory  this  control  waitinglock
wakeupreason
if  deadlockdata    null
// we don't have a deadlock
deadlockwait   false
actualtimeout   timeout
startwaittime   0
willquitwait   false
else
willquitwait   true
nextwaitinglock
control getnextwaiter
waitinglock  willquitwait  this
// if we were not woken by another then we have
// timed out. either deadlock out or timeout
if  willquitwait
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager showtrace new throwable
// the following dumps the lock table as it
// exists at the time a timeout is about to
// cause a deadlock exception to be thrown.
lockdebug
diagnosticutil todiagstring waitinglock
this todebugstring
if  deadlocktrace     deadlockdata    null
// if ending lock request due to lock timeout
// want a copy of the locktable and the time,
// in case of deadlock deadlockdata has the
// info we need.
currenttime   system currenttimemillis
timeoutlocktable
factory makevirtuallocktable
synchronized block
// need to do this outside of the synchronized block as the
// message text building (timeouts and deadlocks) may
// involve getting locks to look up table names from
// identifiers.
if  willquitwait
if  sanitymanager debug
if  lockdebug    null
string type
deadlockdata    null  ?
sanitymanager debug_print
type
type
lockdebug
if  deadlockdata    null
// ending wait because of lock timeout.
if  deadlocktrace
// turn on derby.locks.deadlocktrace to build
// the locktable.
throw timeout buildexception
waitinglock  timeoutlocktable  currenttime
else
standardexception se
standardexception newexception
sqlstate lock_timeout
throw se
else
// ending wait because of lock deadlock.
throw deadlock buildexception
factory  deadlockdata
finally
if  nextwaitinglock    null
nextwaitinglock wakeup constants waiting_lock_grant
nextwaitinglock   null
if  actualtimeout    c_lockfactory wait_forever
if  wakeupreason    constants waiting_lock_in_wait
earlywakeupcount
if  earlywakeupcount > 5
long now   system currenttimemillis
if  startwaittime    0
long sleeptime   now   startwaittime
actualtimeout    sleeptime
startwaittime   now
for
/**
unlock an object, previously locked by lockobject().
if unlockcount is not zero then the lock will be unlocked
that many times, otherwise the unlock count is taken from
item.
*/
public void unlock latch item  int unlockcount
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
/*
** i don't like checking the trace flag twice, but sanitymanager
** doesn't provide a way to get to the debug trace stream
** directly.
*/
sanitymanager debug
constants lock_trace
diagnosticutil todiagstring item
boolean trygrant   false
activelock nextgrant   null
synchronized  this
control control   getcontrol item getlockable
if  sanitymanager debug
// only valid lock's expected
if  item getlockable      null
sanitymanager throwassert
unlockcount
diagnosticutil todiagstring item
// only valid lock's expected
if  control    null
sanitymanager throwassert
unlockcount
diagnosticutil todiagstring item
if  getcontrol control getlockable       control
sanitymanager throwassert
getcontrol control getlockable          control
if   unlockcount    0      unlockcount > item getcount
sanitymanager throwassert     unlockcount
item getcount         item
trygrant   control unlock item  unlockcount
item   null
boolean maybeempty   true
if  trygrant
nextgrant   control firstwaiter
if  nextgrant    null
maybeempty   false
if   nextgrant setpotentiallygranted
nextgrant   null
if  maybeempty
if  control isempty
// no-one granted, no-one waiting, remove lock control
locks remove control getlockable
return
synchronized  this
if  trygrant     nextgrant    null
nextgrant wakeup constants waiting_lock_grant
/**
* unlock an object once if it is present in the specified group. also
* remove the object from the group.
*
* @param space the compatibility space
* @param ref a reference to the locked object
* @param qualifier qualifier of the lock
* @param group a map representing the locks in a group
* @return the corresponding lock in the group map, or <code>null</code> if
* the object was not unlocked
*/
public synchronized lock unlockreference compatibilityspace space
lockable ref  object qualifier
map group
control control   getcontrol ref
if  control    null
return null
lock setlock   control getlock space  qualifier
if  setlock    null
return null
lock lockingroup    lock  group remove setlock
if  lockingroup    null
unlock lockingroup  1
return lockingroup
/**
* lock an object and release the lock immediately. equivalent to
* <pre>
* lock lock = locktable.lockobject(space, ref, qualifier, timeout);
* locktable.unlock(lock, 1);
* </pre>
* except that the implementation is more efficient.
*
* @param space the compatibility space
* @param ref a reference to the locked object
* @param qualifier qualifier of the lock
* @param timeout maximum time to wait in milliseconds
* (<code>lockfactory.no_wait</code> means don't wait)
* @return <code>true</code> if the object was locked, or
* <code>false</code>if the timeout was <code>no_wait</code> and the lock
* couldn't be obtained immediately
* @exception standardexception if the lock could not be obtained
*/
public boolean zerodurationlockobject
compatibilityspace space  lockable ref  object qualifier  int timeout
throws standardexception
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
space  null  ref  qualifier  timeout
if  sanitymanager debug_on constants lock_stack_trace
// the following will print the stack trace of the lock
// request to the log.
throwable t   new throwable
java io printwriter istream
sanitymanager get_debug_stream
istream println
t printstacktrace istream
// very fast zerodurationlockobject() for unlocked objects.
// if no entry exists in the lock manager for this reference
// then it must be unlocked.
// if the object is locked then we perform a grantable
// check, skipping over any waiters.
// if the caller wants to wait and the lock cannot
// be granted then we do the slow join the queue and
// release the lock method.
synchronized  this
control control   getcontrol ref
if  control    null
return true
// if we are grantable, ignoring waiting locks then
// we can also grant this request now, as skipping
// over the waiters won't block them as we release
// the lock rightway.
if  control isgrantable true  space  qualifier
return true
// can't be granted and are not willing to wait.
if  timeout    c_lockfactory no_wait
return false
lock lock   lockobject space  ref  qualifier  timeout
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
space  null  ref  qualifier  timeout
// and simply unlock it once
unlock lock  1
return true
/**
* set the deadlock timeout.
*
* @param timeout deadlock timeout in milliseconds
*/
public void setdeadlocktimeout int timeout
deadlocktimeout   timeout
/**
* set the wait timeout.
*
* @param timeout wait timeout in milliseconds
*/
public void setwaittimeout int timeout
waittimeout   timeout
/*
** non public methods
*/
//exclude-start-lockdiag-
public void setdeadlocktrace boolean val
// set this without synchronization
deadlocktrace   val
//exclude-end-lockdiag-
public string todebugstring
if  sanitymanager debug
string str   new string
int i   0
for  iterator it   locks values   iterator    it hasnext
str        i
diagnosticutil todiagstring it next
return str
else
return null
/**
* add all waiters in this lock table to a <code>map</code> object.
* <br>
* mt - must be synchronized on this <code>lockset</code> object.
*/
public void addwaiters map waiters
for  iterator it   locks values   iterator    it hasnext
control control    control  it next
control addwaiters waiters
//exclude-start-lockdiag-
/**
* make a shallow clone of myself and my lock controls
*/
public synchronized map shallowclone
hashmap clone   new hashmap
for  iterator it   locks keyset   iterator    it hasnext
lockable lockable    lockable  it next
control control   getcontrol lockable
clone put lockable  control shallowclone
return clone
//exclude-end-lockdiag-
/*
** support for anyoneblocked(). these methods assume that caller
** is synchronized on this lockset object.
*/
/**
* increase blockcount by one.
* <br>
* mt - must be synchronized on this <code>lockset</code> object.
*/
public void onemorewaiter
blockcount
/**
* decrease blockcount by one.
* <br>
* mt - must be synchronized on this <code>lockset</code> object.
*/
public void onelesswaiter
blockcount
public synchronized boolean anyoneblocked
if  sanitymanager debug
sanitymanager assert
blockcount >  0
return blockcount    0
/**
* get the <code>control</code> for an object in the lock table.
* <br>
* mt - must be synchronized on this <code>lockset</code> object.
*/
private final control getcontrol lockable ref
return  control  locks get ref