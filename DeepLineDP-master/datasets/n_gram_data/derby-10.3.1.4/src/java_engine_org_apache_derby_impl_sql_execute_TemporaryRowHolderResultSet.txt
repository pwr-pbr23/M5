/*
derby - class org.apache.derby.impl.sql.execute.temporaryrowholderresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import java sql timestamp
import org apache derby iapi error standardexception
import org apache derby iapi services io formatablebitset
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql activation
import org apache derby iapi sql resultdescription
import org apache derby iapi sql resultset
import org apache derby iapi sql row
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute executionfactory
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql execute targetresultset
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access scancontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi types sqllongint
/**
* a result set to scan temporary row holders.  ultimately, this
* may be returned to users, hence the extra junk from the resultset
* interface.
*
*/
class temporaryrowholderresultset implements cursorresultset  noputresultset  cloneable
{
private execrow 				rowarray
private int						numrowsout
private scancontroller			scan
private transactioncontroller	tc
private boolean 				isopen
private boolean 				finished
private execrow					currentrow
private resultdescription		resultdescription
private executionfactory		ef
private boolean                 isappendable   false
private long                    positionindexconglomid
private boolean 				isvirtualmemheap
private boolean 				currrowfrommem
private temporaryrowholderimpl	holder
// the following is used by position based scan, as well as virtual memory style heap
conglomeratecontroller			heapcc
private rowlocation				baserowlocation
/**
* constructor
*
* @param tc the xact controller
* @param rowarray the row array
* @param resultdescription value returned by getresultdescription()
*/
public temporaryrowholderresultset
transactioncontroller		tc
execrow					rowarray
resultdescription			resultdescription
boolean						isvirtualmemheap
temporaryrowholderimpl		holder
{
this tc  rowarray  resultdescription  isvirtualmemheap  false  0  holder
}
/**
* constructor
*
* @param tc the xact controller
* @param rowarray the row array
* @param resultdescription value returned by getresultdescription()
* @param isappendable true,if we can insert rows after this result is created
* @param positionindexconglomid conglomid of the index which has order rows
*                               are inserted and their row location
*/
public temporaryrowholderresultset
transactioncontroller		tc
execrow					rowarray
resultdescription			resultdescription
boolean						isvirtualmemheap
boolean                     isappendable
long                        positionindexconglomid
temporaryrowholderimpl		holder
{
this tc   tc
this rowarray   rowarray
this resultdescription   resultdescription
this numrowsout   0
isopen   false
finished   false
this isvirtualmemheap   isvirtualmemheap
this isappendable   isappendable
this positionindexconglomid   positionindexconglomid
if  sanitymanager debug
{
sanitymanager assert rowarray    null
sanitymanager assert rowarray length > 0
}
this holder   holder
}
/**
* reset the exec row array and reinitialize
*
* @param rowarray the row array
*/
public void reset execrow	rowarray
{
this rowarray   rowarray
this numrowsout   0
isopen   false
finished   false
if  sanitymanager debug
{
sanitymanager assert rowarray    null
sanitymanager assert rowarray length > 0
}
}
/**
* postion scan to start from after where we stopped earlier
*/
public void restartscan long currentconglomid  long pconglomid  throws  standardexception
{
if isappendable
{
holder cid   currentconglomid
positionindexconglomid   pconglomid
setuppositionbasedscan numrowsout
else
{
numrowsout
}
}
/**
* whip up a new temp resultset that has a single
* row, the current row of this result set.
*
* @param activation the activation
* @param rs the result set
*
* @return a single row result set
*
* @exception standardexception on error
*/
public static temporaryrowholderresultset getnewrsoncurrentrow
activation				activation
cursorresultset 		rs
throws standardexception
{
temporaryrowholderimpl singlerow
new temporaryrowholderimpl activation  null
rs getresultdescription
singlerow insert rs getcurrentrow
return  temporaryrowholderresultset  singlerow getresultset
}
/////////////////////////////////////////////////////////
//
// noputresultset
//
/////////////////////////////////////////////////////////
/**
* mark the resultset as the topmost one in the resultset tree.
* useful for closing down the resultset on an error.
*/
public void markastopresultset
/**
* open the scan and evaluate qualifiers and the like.
* for us, there are no qualifiers, this is really a
* noop.
*/
public void opencore   throws standardexception
{
this numrowsout   0
isopen   true
currentrow   null
if isappendable
setuppositionbasedscan numrowsout
}
/**
* reopen the scan.  typically faster than open()/close()
*
* @exception standardexception on error
*/
public void reopencore   throws standardexception
{
numrowsout   0
isopen   true
currentrow   null
if isappendable
{
setuppositionbasedscan numrowsout
return
}
if  scan    null
{
scan reopenscan
datavaluedescriptor  null 		   start key value
0 						   start operator
null 					   qualifier
datavaluedescriptor  null 		   stop key value
0  						   stop operator
}
}
/**
* get the next row.
*
* @return the next row, or null if none
*
* @exception standardexception on error
*/
public execrow getnextrowcore
throws standardexception
{
if   isopen
{
return  execrow null
}
if isappendable
{
return getnextappendedrow
}
if  isvirtualmemheap    holder lastarrayslot >  0
{
numrowsout
currentrow   rowarray
currrowfrommem   true
return currentrow
}
else if  numrowsout   <  holder lastarrayslot
{
currentrow   rowarray
return currentrow
}
if  holder cid    0
{
return  execrow null
}
/*
** advance in the temporary conglomerate
*/
if  scan    null
{
scan
tc openscan
holder cid
false 					   hold
0  		   open read only
transactioncontroller mode_table
transactioncontroller isolation_serializable
formatablebitset  null
datavaluedescriptor  null 		   start key value
0 						   start operator
null 					   qualifier
datavaluedescriptor  null 		   stop key value
0  						   stop operator
}
else if  isvirtualmemheap    holder state    temporaryrowholderimpl state_insert
{
holder state   temporaryrowholderimpl state_drain
scan reopenscan
datavaluedescriptor  null 		   start key value
0 						   start operator
null 					   qualifier
datavaluedescriptor  null 		   stop key value
0  						   stop operator
}
if  scan next
{
currentrow   rowarray getnewnullrow
scan fetch currentrow getrowarray
currrowfrommem   false
return currentrow
}
return  execrow null
}
public void deletecurrentrow
throws standardexception
{
if  sanitymanager debug
{
sanitymanager assert isvirtualmemheap
}
if  currrowfrommem
{
if  holder lastarrayslot > 0 				   0 is kept for template
rowarray   null      erase reference
holder lastarrayslot
}
else
{
if  baserowlocation    null
baserowlocation   scan newrowlocationtemplate
scan fetchlocation baserowlocation
if heapcc    null
{
heapcc   tc openconglomerate  holder cid
false
transactioncontroller openmode_forupdate
transactioncontroller mode_table
transactioncontroller isolation_serializable
}
heapcc delete baserowlocation
}
}
//following variables are specific to the position based scans.
datavaluedescriptor indexrow
scancontroller indexsc
//open the scan of the temporary heap and the position index
private void setuppositionbasedscan long position  throws standardexception
{
//incase nothing is inserted yet into the temporary row holder
if holder cid   0
return
if heapcc    null
{
heapcc   tc openconglomerate  holder cid
false
0
transactioncontroller mode_table
transactioncontroller isolation_serializable
}
currentrow   rowarray getnewnullrow
indexrow   new datavaluedescriptor
indexrow   new sqllongint position
indexrow   	heapcc newrowlocationtemplate
datavaluedescriptor searchrow    new datavaluedescriptor
searchrow   new sqllongint position
if indexsc    null
{
indexsc   tc openscan positionindexconglomid
false                               don't hold open across commit
0                                   for read
transactioncontroller mode_table
transactioncontroller isolation_serializable
formatablebitset  null                      all fields as objects
searchrow             	             start position   first row
scancontroller ge                   startsearchoperation
null                               scanqualifier
null                               stop position   through last row
scancontroller gt                   stopsearchoperation
else
{
indexsc reopenscan
searchrow                       	   startkeyvalue
scancontroller ge             		   startsearchop
null                          		   qualifier
null  		                           stopkeyvalue
scancontroller gt             		   stopsearchop
}
}
//get the next row inserted into the temporary holder
private execrow getnextappendedrow   throws standardexception
{
if  indexsc    null  return null
if   indexsc fetchnext indexrow
{
return null
}
rowlocation baserowlocation     rowlocation  indexrow
boolean base_row_exists
heapcc fetch
baserowlocation  currentrow getrowarray     formatablebitset  null
if  sanitymanager debug
{
sanitymanager assert base_row_exists
}
numrowsout
return currentrow
}
/**
* return the point of attachment for this subquery.
* (only meaningful for any and once resultsets, which can and will only
* be at the top of a resultset for a subquery.)
*
* @return int	point of attachment (result set number) for this
*			    subquery.  (-1 if not a subquery - also sanity violation)
*/
public int getpointofattachment
{
return  1
}
/**
* return the isolation level of the scan in the result set.
* only expected to be called for those resultsets that
* contain a scan.
*
* @return the isolation level of the scan (in transactioncontroller constants).
*/
public int getscanisolationlevel
{
return transactioncontroller isolation_serializable
}
/**
* notify a nprs that it is the source for the specified
* targetresultset.  this is useful when doing bulk insert.
*
* @param trs	the targetresultset.
*/
public void settargetresultset targetresultset trs
{
}
/**
* set whether or not the nprs need the row location when acting
* as a row source.  (the target result set determines this.)
*
*/
public void setneedsrowlocation boolean needsrowlocation
{
}
/**
* get the estimated row count from this result set.
*
* @return	the estimated row count (as a double) from this result set.
*/
public double getestimatedrowcount
{
return 0d
}
/**
* get the number of this resultset, which is guaranteed to be unique
* within a statement.
*/
public int resultsetnumber
{
return 0
}
/**
* set the current row to the row passed in.
*
* @param row the new current row
*
*/
public void setcurrentrow execrow row
{
currentrow   row
}
/**
* clear the current row
*
*/
public void clearcurrentrow
{
currentrow   null
}
/**
* this result set has its row from the last fetch done.
* if the cursor is closed, a null is returned.
*
* @see cursorresultset
*
* @return the last row returned;
* @exception standardexception thrown on failure.
*/
public execrow getcurrentrow   throws standardexception
{
if  sanitymanager debug
{
sanitymanager assert isopen
}
return currentrow
}
/**
* returns the row location of the current base table row of the cursor.
* if this cursor's row is composed of multiple base tables' rows,
* i.e. due to a join, then a null is returned.  for
* a temporary row holder, we always return null.
*
* @return the row location of the current cursor row.
*/
public rowlocation getrowlocation
{
if  sanitymanager debug
{
sanitymanager assert isopen
}
return  rowlocation null
}
/**
* clean up
*
* @exception standardexception thrown on error
*/
public void	close   throws standardexception
{
isopen   false
numrowsout   0
currentrow   null
if  scan    null
{
scan close
scan   null
}
}
//////////////////////////////////////////////////////////////////////////
//
// misc from result set
//
/////////////////////////////////////////////////////////////////////////
/**
* returns true if the statement returns rows (i.e. is a select
* or fetch statement), false if it returns no rows.
*
* @return	true if the statement returns rows, false if not.
*/
public boolean	returnsrows
{
return true
}
public int modifiedrowcount     return 0
/**
* returns a resultdescription object, which describes the results
* of the statement this resultset is in. this will *not* be a
* description of this particular resultset, if this is not the
* outermost resultset.
*
* @return	a resultdescription describing the results of the
*		statement.
*/
public resultdescription	getresultdescription
{
return resultdescription
}
/**
* tells the system that there will be calls to getnextrow().
*
* @exception standardexception		thrown on failure
*/
public void open   throws standardexception
{
opencore
}
/**
* returns the row at the absolute position from the query,
* and returns null when there is no such position.
* (negative position means from the end of the result set.)
* moving the cursor to an invalid position leaves the cursor
* positioned either before the first row (negative position)
* or after the last row (positive position).
* note: an exception will be thrown on 0.
*
* @param row	the position.
* @return	the row at the absolute position, or null if no such position.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getabsoluterow int row  throws standardexception
{
if  sanitymanager debug
{
sanitymanager throwassert
}
return null
}
/**
* returns the row at the relative position from the current
* cursor position, and returns null when there is no such position.
* (negative position means toward the beginning of the result set.)
* moving the cursor to an invalid position leaves the cursor
* positioned either before the first row (negative position)
* or after the last row (positive position).
* note: 0 is valid.
* note: an exception is thrown if the cursor is not currently
* positioned on a row.
*
* @param row	the position.
* @return	the row at the relative position, or null if no such position.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getrelativerow int row  throws standardexception
{
if  sanitymanager debug
{
sanitymanager throwassert
}
return null
}
/**
* sets the current position to before the first row and returns null
* because there is no current row.
*
* @return	null.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	setbeforefirstrow
throws standardexception
{
if  sanitymanager debug
{
sanitymanager throwassert
}
return null
}
/**
* returns the first row from the query, and returns null when there
* are no rows.
*
* @return	the first row, or null if no rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getfirstrow
throws standardexception
{
if  sanitymanager debug
{
sanitymanager throwassert
}
return null
}
/**
* returns the next row from the query, and returns null when there
* are no more rows.
*
* @return	the next row, or null if no more rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getnextrow   throws standardexception
{
return getnextrowcore
}
/**
* returns the previous row from the query, and returns null when there
* are no more previous rows.
*
* @return	the previous row, or null if no more previous rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getpreviousrow
throws standardexception
{
if  sanitymanager debug
{
sanitymanager throwassert
}
return null
}
/**
* returns the last row from the query, and returns null when there
* are no rows.
*
* @return	the last row, or null if no rows.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	getlastrow
throws standardexception
{
if  sanitymanager debug
{
sanitymanager throwassert
}
return null
}
/**
* sets the current position to after the last row and returns null
* because there is no current row.
*
* @return	null.
*
* @exception standardexception		thrown on failure
* @see row
*/
public execrow	setafterlastrow
throws standardexception
{
if  sanitymanager debug
{
sanitymanager throwassert
}
return null
}
/**
* determine if the cursor is before the first row in the result
* set.
*
* @return true if before the first row, false otherwise. returns
* false when the result set contains no rows.
*/
public boolean checkrowposition int istype
{
return false
}
/**
* returns the row number of the current row.  row
* numbers start from 1 and go to 'n'.  corresponds
* to row numbering used to position current row
* in the result set (as per jdbc).
*
* @return	the row number, or 0 if not on a row
*
*/
public int getrownumber
{
return 0
}
/**
* tells the system to clean up on an error.
*
* @exception standardexception		thrown on error.
*/
public void	cleanup   throws standardexception
{
close
}
/**
find out if the resultset is closed or not.
will report true for result sets that do not return rows.
@return true if the resultset has been closed.
*/
public boolean isclosed
{
return  isopen
}
/**
* tells the system that there will be no more access
* to any database information via this result set;
* in particular, no more calls to open().
* will close the result set if it is not already closed.
*
* @exception standardexception	on error
*/
public void finish   throws standardexception
{
finished   true
close
}
/**
* get the execution time in milliseconds.
*
* @return long		the execution time in milliseconds.
*/
public long getexecutetime
{
return 0l
}
/**
* @see resultset#getautogeneratedkeysresultset
*/
public resultset getautogeneratedkeysresultset
{
//a non-null resultset would be returned only for an insert statement
return  resultset null
}
/**
* get the timestamp for the beginning of execution.
*
* @return timestamp		the timestamp for the beginning of execution.
*/
public timestamp getbeginexecutiontimestamp
{
return  timestamp null
}
/**
* get the timestamp for the end of execution.
*
* @return timestamp		the timestamp for the end of execution.
*/
public timestamp getendexecutiontimestamp
{
return  timestamp null
}
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
{
return 0l
}
/**
* get the subquery resultset tracking array from the top resultset.
* (used for tracking open subqueries when closing down on an error.)
*
* @param numsubqueries		the size of the array (for allocation on demand.)
*
* @return noputresultset[]	array of noputresultsets for subqueries.
*/
public noputresultset getsubquerytrackingarray int numsubqueries
{
return  noputresultset null
}
/**
* returns the name of the cursor, if this is cursor statement of some
* type (declare, open, fetch, positioned update, positioned delete,
* close).
*
* @return	a string with the name of the cursor, if any. returns
*		null if this is not a cursor statement.
*/
public string	getcursorname
{
return  string  null
}
/**
* @see noputresultset#requiresrelocking
*/
public boolean requiresrelocking
{
if  sanitymanager debug
{
sanitymanager throwassert
getclass   getname
}
return false
}
/////////////////////////////////////////////////////////
//
// access/rowsource -- not implemented
//
/////////////////////////////////////////////////////////
/**
get the next row as an array of column objects. the column objects can
be a jbms storable or any
serializable/externalizable/formattable/streaming type.
<br>
a return of null indicates that the complete set of rows has been read.
<p>
a null column can be specified by leaving the object null, or indicated
by returning a non-null getvalidcolumns.  on streaming columns, it can
be indicated by returning a non-null get fieldstates.
<p>
if rowsource.needtoclone() is true then the returned row (the
datavaluedescriptor[]) is guaranteed not to be modified by drainer of
the rowsource (except that the input stream will be read, of course)
and drainer will keep no reference to it before making the subsequent
nextrow call.  so it is safe to return the same datavaluedescriptor[]
in subsequent nextrow calls if that is desirable for performance
reasons.
<p>
if rowsource.needtoclone() is false then the returned row (the
datavaluedescriptor[]) may be be modified by drainer of the rowsource,
and the drainer may keep a reference to it after making the subsequent
nextrow call.  in this case the client should severe all references to
the row after returning it from getnextrowfromrowsource().
@exception standardexception standard derby error policy
*/
public datavaluedescriptor getnextrowfromrowsource   throws standardexception
{
return null
}
/**
does the caller of getnextrowfromrowsource() need to clone the row
in order to keep a reference to the row past the
getnextrowfromrowsource() call which returned the row.  this call
must always return the same for all rows in a rowsource (ie. the
caller will call this once per scan from a rowsource and assume the
behavior is true for all rows in the rowsource).
*/
public boolean needstoclone
{
return false
}
/**
getvalidcolumns describes the datavaluedescriptor[] returned by all
calls to the getnextrowfromrowsource() call.
if getvalidcolumns returns null, the number of columns is given by the
datavaluedescriptor.length where datavaluedescriptor[] is returned by the
preceeding getnextrowfromrowsource() call.  column n maps to
datavaluedescriptor[n], where column numbers start at zero.
if getvalidcolumns return a non null validcolumns formatablebitset the number of
columns is given by the number of bits set in validcolumns.  column n is
not in the partial row if validcolumns.get(n) returns false.  column n is
in the partial row if validcolumns.get(n) returns true.  if column n is
in the partial row then it maps to datavaluedescriptor[m] where m is the
count of calls to validcolumns.get(i) that return true where i < n.  if
datavaluedescriptor.length is greater than the number of columns
indicated by validcolumns the extra entries are ignored.
*/
public formatablebitset getvalidcolumns
{
return null
}
/**
closerowsource tells the rowsource that it will no longer need to
return any rows and it can release any resource it may have.
subsequent call to any method on the rowsource will result in undefined
behavior.  a closed rowsource can be closed again.
*/
public void closerowsource
/////////////////////////////////////////////////////////
//
// access/rowlocationretrowsource -- not implemented
//
/////////////////////////////////////////////////////////
/**
needsrowlocation returns true iff this the row source expects the
drainer of the row source to call rowlocation after getting a row from
getnextrowfromrowsource.
@return true iff this row source expects some row location to be
returned
@see #rowlocation
*/
public boolean needsrowlocation
{
return false
}
/**
rowlocation is a callback for the drainer of the row source to return
the rowlocation of the current row, i.e, the row that is being returned
by getnextrowfromrowsource.  this interface is for the purpose of
loading a base table with index.  in that case, the indices can be
built at the same time the base table is laid down once the row
location of the base row is known.  this is an example pseudo code on
how this call is expected to be used:
<br><pre>
boolean needsrl = rowsource.needsrowlocation();
datavaluedescriptor[] row;
while((row = rowsource.getnextrowfromrowsource()) != null)
{
rowlocation rl = heapconglomerate.insertrow(row);
if (needsrl)
rowsource.rowlocation(rl);
}
</pre><br>
needsrowlocation and rowlocation will only be called by a drainer of
the row source which can return a row location.  drainer of row source
which cannot return rowlocation will guarentee to not call either
callbacks. conversely, if needsrowlocation is called and it returns
true, then for every row return by getnextrowfromrowsource, a
rowlocation callback must also be issued with the row location of the
row.  implementor of both the source and the drain of the row source
must be aware of this protocol.
<br>
the rowlocation object is own by the caller of rowlocation, in other
words, the drainer of the rowsource.  this is so that we don't need to
new a row location for every row.  if the row source wants to keep the
row location, it needs to clone it (rowlocation is a clonableobject).
@exception standardexception on error
*/
public void rowlocation rowlocation rl  throws standardexception
/**
* @see noputresultset#positionscanatrowlocation
*
* this method is result sets used for scroll insensitive updatable
* result sets for other result set it is a no-op.
*/
public void positionscanatrowlocation rowlocation rl
throws standardexception
{
// only used for scrollable insensitive result sets otherwise no-op
}
// class implementation
/**
* is this resultset or it's source result set for update
* this method will be overriden in the inherited classes
* if it is true
* @return whether or not the result set is for update.
*/
public boolean isforupdate
{
return false
}
/**
* shallow clone this result set.  used in trigger reference.
* beetle 4373.
*/
public object clone
{
object clo   null
try
clo   super clone
}
catch  clonenotsupportedexception e
return clo
}
public java sql sqlwarning getwarnings
return null
}
/**
* @see noputresultset#updaterow
*
* this method is result sets used for scroll insensitive updatable
* result sets for other result set it is a no-op.
*/
public void updaterow execrow row  throws standardexception
// only resultsets of type scroll insensitive implement
// detectability, so for other result sets this method
// is a no-op
}
/**
* @see noputresultset#markrowasdeleted
*
* this method is result sets used for scroll insensitive updatable
* result sets for other result set it is a no-op.
*/
public void markrowasdeleted   throws standardexception
// only resultsets of type scroll insensitive implement
// detectability, so for other result sets this method
// is a no-op
}
/**
* return the <code>activation</code> for this result set.
*
* @return activation
*/
public final activation getactivation
return holder activation
}
}