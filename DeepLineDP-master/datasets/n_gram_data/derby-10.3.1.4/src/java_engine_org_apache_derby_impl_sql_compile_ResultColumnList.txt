/*
derby - class org.apache.derby.impl.sql.compile.resultcolumnlist
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import java lang reflect modifier
import java sql resultsetmetadata
import java sql types
import java util hashtable
import java util vector
import org apache derby catalog types defaultinfoimpl
import org apache derby iapi error standardexception
import org apache derby iapi reference classname
import org apache derby iapi reference sqlstate
import org apache derby iapi services classfile vmopcode
import org apache derby iapi services compiler localfield
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services context contextmanager
import org apache derby iapi services io formatablebitset
import org apache derby iapi services loader classfactory
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql resultcolumndescriptor
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile nodefactory
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary columndescriptorlist
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary defaultdescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql execute execrow
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access storecostcontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi types typeid
import org apache derby iapi util jbitset
import org apache derby iapi util reusefactory
/**
* a resultcolumnlist is the target list of a select, insert, or update.
*
* @see resultcolumn
*/
public class resultcolumnlist extends querytreenodevector
/* is this the resultcolumnlist for an index row? */
protected boolean indexrow
protected long	conglomerateid
int			orderbyselect   0     the number of result columns pulled up
// from orderby list
/*
* a comment on 'orderbyselect'. when we encounter a select .. order by
* statement, the columns (or expressions) in the order by clause may
* or may not have been explicitly mentioned in the select column list.
* if the columns were not explicitly mentioned in the select column
* list, then the parsing of the order by clause implicitly generates
* them into the result column list, because we'll need to have those
* columns present at execution time in order to sort by them. those
* generated columns are added to the *end* of the resultcolumnlist, and
* we keep track of the *number* of those columns in 'orderbyselect',
* so we can tell whether we are looking at a generated column by seeing
* whether its position in the resultcolumnlist is in the last
* 'orderbyselect' number of columns. if the select .. order by
* statement uses the "*" token to select all the columns from a table,
* then during order by parsing we redundantly generate the columns
* mentioned in the order by clause into the resultcolumnlist, but then
* later in getorderbycolumntobind we determine that these are
* duplicates and we take them back out again.
*/
/*
** is this resultcolumnlist for a frombasetable for an index
** that is to be updated?
*/
protected boolean forupdate
// is a count mismatch allowed - see set/get methods for details.
private boolean countmismatchallowed
// number of rcs in this rcl at "init" time, before additional
// ones were added internally.
private int initiallistsize   0
public resultcolumnlist
/**
* add a resultcolumn (at this point, resultcolumn or
* allresultcolumn) to the list
*
* @param resultcolumn	the resultcolumn to add to the list
*/
public void addresultcolumn resultcolumn resultcolumn
/* vectors are 0-based, resultcolumns are 1-based */
resultcolumn setvirtualcolumnid size     1
addelement resultcolumn
/**
* append a given resultcolumnlist to this one, resetting the virtual
* column ids in the appended portion.
*
* @param resultcolumns		the resultcolumnlist to be appended
* @param destructivecopy	whether or not this is a descructive copy
*							from resultcolumns
*/
public void appendresultcolumns resultcolumnlist resultcolumns
boolean destructivecopy
int	oldsize   size
int	newid   oldsize   1
/*
** set the virtual column ids in the list being appended.
** vectors are zero-based, and virtual column ids are one-based,
** so the new virtual column ids start at the original size
** of this list, plus one.
*/
int othersize   resultcolumns size
for  int index   0  index < othersize  index
/* resultcolumns are 1-based */
resultcolumn  resultcolumns elementat index   setvirtualcolumnid newid
newid
if  destructivecopy
destructiveappend resultcolumns
else
nondestructiveappend resultcolumns
/**
* get a resultcolumn from a column position (1-based) in the list
*
* @param position	the resultcolumn to get from the list (1-based)
*
* @return	the column at that position.
*/
public resultcolumn getresultcolumn int position
/*
** first see if it falls in position x.  if not,
** search the whole shebang
*/
if  position <  size
// this wraps the cast needed,
// and the 0-based nature of the vectors.
resultcolumn rc    resultcolumn elementat position 1
if  rc getcolumnposition      position
return rc
/*
** check each column
*/
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc getcolumnposition      position
return rc
return null
/**
* take a column position and a resultsetnode and find the resultcolumn
* in this rcl whose source result set is the same as the received
* rsn and whose column position is the same as the received column
* position.
*
* @param colnum the column position (w.r.t rsn) for which we're searching
* @param rsn the result set node for which we're searching.
* @return the resultcolumn in this rcl whose source is column colnum
*  in result set rsn.  that resultcolumn's position w.r.t to this rcl
*  is also returned via the whichrc parameter.  if no match is found,
*  return null and leave whichrc untouched.
*/
public resultcolumn getresultcolumn int colnum  resultsetnode rsn
int  whichrc  throws standardexception
if  colnum     1
return null
resultcolumn rc   null
columnreference colref   null
int  crcolnum   new int    1
for  int index   size     1  index >  0  index
rc    resultcolumn  elementat index
if    rc getexpression   instanceof columnreference
// if the rc's expression isn't a column reference then
// it can't be pointing to rsn, so just skip it.
continue
colref    columnreference rc getexpression
if   rsn    colref getsourceresultset crcolnum
crcolnum    colnum
// found a match.
whichrc   index 1
return rc
return null
/**
* get a resultcolumn from a column position (1-based) in the list,
* null if out of range (for order by).
*
* @param position	the resultcolumn to get from the list (1-based)
*
* @return	the column at that position, null if out of range
*/
public resultcolumn getorderbycolumn int position
// this wraps the cast needed, and the 0-based nature of the vectors.
if  position    0
return null
return getresultcolumn position
/**
* get a resultcolumn that matches the specified columnname and
* mark the resultcolumn as being referenced.
*
* @param columnname	the resultcolumn to get from the list
*
* @return	the column that matches that name.
*/
public resultcolumn getresultcolumn string columnname
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
if  columnname equals  resultcolumn getname
/* mark resultcolumn as referenced and return it */
resultcolumn setreferenced
return resultcolumn
return null
/**
* get a resultcolumn that matches the specified columnname and
* mark the resultcolumn as being referenced.
*
* @param columnstablename	qualifying name for the column
* @param columnname		the resultcolumn to get from the list
*
* @return	the column that matches that name.
*/
public resultcolumn getresultcolumn string columnstablename  string columnname
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
/* if the column's table name is non-null, then we have found a match
* only if the rc's table name is non-null and the same as the
* the cr's table name.
*/
if  columnstablename    null
if  resultcolumn gettablename      null
continue
if    columnstablename equals resultcolumn gettablename
continue
if  columnname equals  resultcolumn getname
/* mark resultcolumn as referenced and return it */
resultcolumn setreferenced
return resultcolumn
return null
/**
* get a resultcolumn that matches the specified columnname and
* mark the resultcolumn as being referenced.
* note - this flavor enforces no ambiguity (at most 1 match)
*		  only fromsubquery needs to call this flavor since
*		  it can have ambiguous references in its own list.
*
* @param cr					   the columnreference to resolve
* @param exposedtablename		   exposed table name for fromtable
* @param considergeneratedcolumns also consider columns that are generated.
*   one example of this is group by where columns are added to the select list
*   if they are referenced in the group by but are not present in the select
*   list.
* @return	the column that matches that name.
*
* @exception standardexception	thrown on error
*/
public resultcolumn getatmostoneresultcolumn
columnreference cr
string exposedtablename
boolean considergeneratedcolumns
throws standardexception
int				size   size
resultcolumn	retrc   null
string			columnname   cr getcolumnname
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
if  columnname equals  resultcolumn getname
if  resultcolumn isgenerated       considergeneratedcolumns
continue
/* we should get at most 1 match */
if  retrc    null
throw standardexception newexception sqlstate lang_ambiguous_column_name_in_table
columnname  exposedtablename
/* mark resultcolumn as referenced and return it */
resultcolumn setreferenced
retrc   resultcolumn
return retrc
/**
* for order by column bind, get a resultcolumn that matches the specified
* columnname.
*
* this method is called during bind processing, in the special
* "bind the order by" call that is made by cursornode.bindstatement().
* the orderbylist has a special set of bind processing routines
* that analyzes the columns in the order by list and verifies that
* each column is one of:
* - a direct reference to a column explicitly mentioned in
*   the select list
* - a direct reference to a column implicitly mentioned as "select *"
* - a direct reference to a column "pulled up" into the result
*   column list
* - or a valid and fully-bound expression ("c+2", "year(hire_date)", etc.)
*
* at this point in the processing, it is possible that we'll find
* the column present in the rcl twice: once because it was pulled
* up during statement compilation, and once because it was added
* when "select *" was expanded into the table's actual column list.
* if we find such a duplicated column, we can, and do, remove the
* pulled-up copy of the column and point the orderbycolumn
* to the actual resultcolumn from the *-expansion.
*
* note that the association of the orderbycolumn with the
* corresponding resultcolumn in the rcl occurs in
* orderbycolumn.resolveaddedcolumn.
*
* @param columnname	the resultcolumn to get from the list
* @param tablename	the table name on the orderbycolumn, if any
* @param tablenumber	the tablenumber corresponding to the fromtable with the
*						exposed name of tablename, if tablename != null.
* @param obc           the orderbycolumn we're binding.
*
* @return	the column that matches that name.
* @exception standardexception thrown on ambiguity
*/
public resultcolumn getorderbycolumntobind
string columnname
tablename tablename
int tablenumber
orderbycolumn obc
throws standardexception
int				size   size
resultcolumn	retval   null  resultcolumn
for  int index   0  index < size  index
resultcolumn    resultcolumn  elementat index
/* the order by column is qualified, then it is okay to consider
* this rc if:
*	o  the rc is qualified and the qualifiers on the order by column
*	   and the rc are equal().
*	o  the rc is not qualified, but its expression is a columnreference
*	   from the same table (as determined by the tablenumbers).
*/
if  tablename    null
valuenode rcexpr   resultcolumn getexpression
if     rcexpr instanceof columnreference
continue
columnreference cr    columnreference  rcexpr
if     tablename equals  cr gettablenamenode        tablenumber    cr gettablenumber
continue
/* we finally got past the qualifiers, now see if the column
* names are equal. if they are, then we appear to have found
* our order by column. if we find our order by column multiple
* times, make sure that they are truly duplicates, otherwise
* we have an ambiguous situation. for example, the query
*   select b+c as a, d+e as a from t order by a
* is ambiguous because we don't know which "a" is meant. but
*   select t.a, t.* from t order by a
* is not ambiguous, even though column "a" is selected twice.
* if we find our order by column at the end of the
* select column list, in the last 'orderbyselect' number
* of columns, then this column was not explicitly mentioned
* by the user in their select column list, but was implicitly
* added by the parsing of the order by clause, and it
* should be removed from the resultcolumnlist and returned
* to the caller.
*/
if  columnname equals  resultcolumn getname
if  retval    null
retval   resultcolumn
else if    retval isequivalent resultcolumn
throw standardexception newexception sqlstate lang_duplicate_column_for_order_by  columnname
else if  index >  size   orderbyselect
remove the column due to pullup of orderby item
removeelement resultcolumn
decorderbyselect
obc clearaddedcolumnoffset
collapsevirtualcolumnidgap
resultcolumn getcolumnposition
break
return retval
/**
* adjust virtualcolumnid values due to result column removal
*
* this method is called when a duplicate column has been detected and
* removed from the list. we iterate through each of the other columns
* in the list and notify them of the column removal so they can adjust
* their virtual column id if necessary.
*
* @param gap   id of the column which was just removed.
*/
private void collapsevirtualcolumnidgap int gap
for  int index   0  index < size    index
resultcolumn  elementat index   collapsevirtualcolumnidgap gap
/**
* for order by, get a resultcolumn that matches the specified
* columnname.
*
* this method is called during pull-up processing, at the very
* start of bind processing, as part of
* orderbylist.pulluporderbycolumns. its job is to figure out
* whether the provided column (from the order by list) already
* exists in the resultcolumnlist or not. if the column does
* not exist in the rcl, we return null, which signifies that
* a new resultcolumn should be generated and added ("pulled up")
* to the rcl by our caller.
*
* note that at this point in the processing, we should never
* find this column present in the rcl multiple times; if the
* column is already present in the rcl, then we don't need to,
* and won't, pull a new resultcolumn up into the rcl.
*
* if the caller specified "select *", then the rcl at this
* point contains a special allresultcolumn object. this object
* will later be expanded and replaced by the actual set of
* columns in the table, but at this point we don't know what
* those columns are, so we may pull up an orderbycolumn
* which duplicates a column in the *-expansion; such
* duplicates will be removed at the end of bind processing
* by orderbylist.bindorderbycolumns.
*
* @param columnname	the resultcolumn to get from the list
* @param tablename	the table name on the orderbycolumn, if any
*
* @return	the column that matches that name, or null if pull-up needed
* @exception standardexception thrown on ambiguity
*/
public resultcolumn findresultcolumnfororderby
string columnname  tablename tablename
throws standardexception
int				size   size
resultcolumn	retval   null  resultcolumn
for  int index   0  index < size  index
resultcolumn    resultcolumn  elementat index
// we may be checking on "order by t.a" against "select *".
// exposedname will not be null and "*" will not have an expression
// or tablename.
// we may be checking on "order by t.a" against "select t.b, t.a".
if  tablename    null
valuenode rcexpr   resultcolumn getexpression
if  rcexpr    null       rcexpr instanceof columnreference
continue
columnreference cr    columnreference  rcexpr
if    tablename equals  cr gettablenamenode
continue
/* we finally got past the qualifiers, now see if the column
* names are equal.
*/
if  columnname equals  resultcolumn getname
if  retval    null
retval   resultcolumn
else if    retval isequivalent resultcolumn
throw standardexception newexception sqlstate lang_duplicate_column_for_order_by  columnname
else if  index >  size   orderbyselect
if  sanitymanager debug
sanitymanager throwassert
columnname      index
return retval
/**
* copy the result column names from the given resultcolumnlist
* to this resultcolumnlist.  this is useful for insert-select,
* where the columns being inserted into may be different from
* the columns being selected from.  the result column list for
* an insert is supposed to have the column names being inserted
* into.
*
* @param namelist	the resultcolumnlist from which to copy
*			the column names
*/
void copyresultcolumnnames resultcolumnlist namelist
/* list checking is done during bind().  lists should be the
* same size when we are called.
*/
if  sanitymanager debug
if     countmismatchallowed     size      namelist size
sanitymanager throwassert
size         namelist size
int size    countmismatchallowed  ? namelist size     size
for  int index   0  index < size  index
resultcolumn thisresultcolumn    resultcolumn  elementat index
resultcolumn namelistresultcolumn
resultcolumn  namelist elementat index
thisresultcolumn setname namelistresultcolumn getname
thisresultcolumn setnamegenerated namelistresultcolumn isnamegenerated
/**
* this class needs a treeprint method, even though it is not a
* descendant of querytreenode, because its members contain tree
* nodes, and these have to be printed and indented properly.
*
* @param depth		the depth at which to indent the sub-nodes
*/
public void treeprint int depth
if  sanitymanager debug
for  int index   0  index < size    index
resultcolumn  elementat index    treeprint depth
/**
* bind the expressions in this resultcolumnlist.  this means binding
* the expression under each resultcolumn node.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @exception standardexception		thrown on error
*/
public void bindexpressions
fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
/* first we expand the *'s in the result column list */
expandallsandnamecolumns fromlist
/* now we bind each result column */
int size   size
for  int index   0  index < size  index
valuenode vn    valuenode  elementat index
vn     resultcolumn  vn   bindexpression
fromlist  subquerylist
aggregatevector
setelementat vn  index
/**
* bind the result columns to the expressions that live under them.
* all this does is copy the datatype information to from each expression
* to each result column.  this is useful for select statements, where
* the result type of each column is the type of the column's expression.
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumnstoexpressions
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn  elementat index    bindresultcolumntoexpression
/**
* bind the result columns by their names.  this is useful for grant and revoke statements
* like "grant select on t(c1,c1,c3) to george", where the user specified a column list.
* this method does not check for duplicate column names.
*
* @param targettabledescriptor	the descriptor for the table
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumnsbyname tabledescriptor targettabledescriptor
throws standardexception
int			size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
rc bindresultcolumnbyname
targettabledescriptor
index   1
end of bindresultcolumnsbyname  tabledescriptor
/**
* bind the result columns by their names.  this is useful for update, grant, and revoke
* statements, and for insert statements like "insert into t (a, b, c)
* values (1, 2, 3)" where the user specified a column list.
* if the statment is an insert or update verify that the result column list does not contain any duplicates.
* note: we pass the resultcolumns position in the resultcolumnlist so
* that the virtualcolumnid gets set.
*
* @param targettabledescriptor	the descriptor for the table being
*				updated or inserted into
* @param statement			dmlstatementnode containing this list, null if no duplicate checking is to be done
*
* @return a formatablebitset representing the set of columns with respect to the table
*
* @exception standardexception		thrown on error
*/
public formatablebitset bindresultcolumnsbyname tabledescriptor targettabledescriptor
dmlstatementnode statement
throws standardexception
int			size   size
formatablebitset columnbitset   new formatablebitset  targettabledescriptor getnumberofcolumns
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
rc bindresultcolumnbyname
targettabledescriptor
index   1
int colidx   rc getcolumnposition     1
if  sanitymanager debug
sanitymanager assert  colidx >  0    colidx < targettabledescriptor getnumberofcolumns
rc getname
/* verify that this column's name is unique within the list if requested */
if  statement    null    columnbitset isset  colidx
string colname   rc getname
if  statement instanceof updatenode
throw standardexception newexception sqlstate lang_duplicate_column_name_update  colname
else
throw standardexception newexception sqlstate lang_duplicate_column_name_insert  colname
columnbitset set  colidx
return columnbitset
/**
* bind the result columns by their names.  this is useful for update
* vti statements, and for insert statements like "insert into new t() (a, b, c)
* values (1, 2, 3)" where the user specified a column list.
* also, verify that the result column list does not contain any duplicates.
* note: we pass the resultcolumns position in the resultcolumnlist so
* that the virtualcolumnid gets set.
*
* @param fullrcl	the full rcl for the target table
* @param statement			dmlstatementnode containing this list
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumnsbyname resultcolumnlist fullrcl
fromvti targetvti
dmlstatementnode statement
throws standardexception
int			size   size
hashtable	ht   new hashtable size   2   float   999
for  int index   0  index < size  index
resultcolumn matchrc
resultcolumn rc    resultcolumn  elementat index
/* verify that this column's name is unique within the list */
string colname   rc getname
object object   ht put colname  colname
if  object    null
string  object  equals colname
if  sanitymanager debug
sanitymanager assert  statement instanceof updatenode
statement instanceof insertnode
if  statement instanceof updatenode
throw standardexception newexception sqlstate lang_duplicate_column_name_update  colname
else
throw standardexception newexception sqlstate lang_duplicate_column_name_insert  colname
matchrc   fullrcl getresultcolumn null  rc getname
if  matchrc    null
throw standardexception newexception sqlstate lang_column_not_found_in_table
rc getname
targetvti getnewinvocation   getjavaclassname
/* we have a match.  we need to create a dummy columndescriptor
* since calling code expects one to get column info.
*/
columndescriptor cd   new columndescriptor
rc getname
matchrc getvirtualcolumnid
matchrc gettype


tabledescriptor  null

0  0
rc setcolumndescriptor null  cd
rc setvirtualcolumnid index   1
/**
* bind the result columns by ordinal position.  this is useful for
* insert statements like "insert into t values (1, 2, 3)", where the
* user did not specify a column list.
*
* @param targettabledescriptor	the descriptor for the table being
*				inserted into
*
* @exception standardexception		thrown on error
*/
public void bindresultcolumnsbyposition tabledescriptor targettabledescriptor
throws standardexception
int size   size
for  int index   0  index < size  index
/*
** add one to the iterator index, because iterator indexes start at zero,
** and column numbers start at one.
*/
resultcolumn  elementat index    bindresultcolumnbyposition
targettabledescriptor
index   1
/**
* preprocess the expression trees under the rcl.
* we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @exception standardexception		thrown on error
*/
public void preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
setelementat resultcolumn preprocess numtables
outerfromlist
outersubquerylist
outerpredicatelist
index
/**
verify that all the result columns have expressions that
are storable for them.  check versus the given resultcolumnlist.
@exception standardexception	thrown on error
*/
void checkstorableexpressions resultcolumnlist tostore
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn	otherrc    resultcolumn  tostore elementat index
resultcolumn  elementat index    checkstorableexpression otherrc
/**
return an array holding the 0 based heap offsets of
the streamstorable columns in this resultcolumnlist.
this returns null if this list does not contain any
streamstorablecolumns. the list this returns does not
contain duplicates. this should only be used for
a resultcolumnlist the refers to a single heap
such as the target for an insert, update or delete.
@param heapcolcount the number of heap columns
@exception standardexception	thrown on error
*/
public int getstreamstorablecolids int heapcolcount  throws standardexception
//@#$
//system.out.println("getstreamstorablecolids");
int sscount   0
boolean isss   new boolean   should be table length
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc gettypeid   streamstorable
//system.out.println("    streamstorable=true");
columndescriptor cd   rc gettablecolumndescriptor
isss   true
for  int ix 0 ix<isss length ix    if  isss  sscount
if  sscount  0 return null
int result   new int
int resultoffset 0
for  int heapoffset 0 heapoffset<isss length heapoffset
if  isss
result heapoffset
return result
/**
verify that all the result columns have expressions that
are storable for them.  check versus the expressions under the
resultcolumns.
@exception standardexception	thrown on error
*/
void checkstorableexpressions
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn  elementat index    checkstorableexpression
/**
* generate the code to place the columns' values into
* a row variable named "r". this wrapper is here
* rather than in resultcolumn, because that class does
* not know about the position of the columns in the list.
*
* @exception standardexception		thrown on error
*/
public void generate activationclassbuilder acb  methodbuilder mb
throws standardexception
generatecore acb  mb  false
/**
* generate the code to place the columns' values into
* a row variable named "r". this wrapper is here
* rather than in resultcolumn, because that class does
* not know about the position of the columns in the list.
*
* @exception standardexception		thrown on error
*/
void generatenulls activationclassbuilder acb
methodbuilder mb
throws standardexception
generatecore acb  mb  true
/**
* generate the code to place the columns' values into
* a row variable named "r". this wrapper is here
* rather than in resultcolumn, because that class does
* not know about the position of the columns in the list.
*
* this is the method that does the work.
*/
void generatecore expressionclassbuilder acb
methodbuilder mb
boolean gennulls
throws standardexception
// generate the function and initializer:
// private execrow fieldx;
// in the constructor:
//	 fieldx = getexecutionfactory().getvaluerow(# cols);
// private execrow exprn()
// {
//   fieldx.setcolumn(1, col(1).generatecolumn(ps)));
//   ... and so on for each column ...
//   return fieldx;
// }
// static method exprn = method pointer to exprn;
// this sets up the method and the static field.
methodbuilder userexprfun   acb newuserexprfun
/* declare the field */
localfield field   acb newfielddeclaration modifier private  classname execrow
// generate the code to create the row in the constructor
gencreaterow acb  field     classname execrow  size
resultcolumn rc
int size   size
methodbuilder cb   acb getconstructor
for  int index   0  index < size  index
// generate statements of the form
// fieldx.setcolumn(columnnumber, (datavaluedescriptor) columnexpr);
// and add them to exprfun.
rc    resultcolumn  elementat index
/* if we are not generating nulls, then we can skip this rc if
* it is simply propagating a column from the source result set.
*/
if   gennulls
valuenode sourceexpr   rc getexpression
if  sourceexpr instanceof virtualcolumnnode          virtualcolumnnode  sourceexpr  getcorrelated
continue
if  sourceexpr instanceof columnreference          columnreference  sourceexpr  getcorrelated
continue
// row add is 1-based, and iterator index is 0-based
if  sanitymanager debug
if  index   1    rc getvirtualcolumnid
sanitymanager throwassert
rc getvirtualcolumnid
index   1
// we need the expressions to be columns exactly.
/* special case:  expression is a non-null constant.
*	generate the setcolumn() call in the constructor
*  so that it will only be executed once per instantiation.
*
* increase the statement counter in constructor.  code size in
* constructor can become too big (more than 64k) for java compiler
* to handle (beetle 4293).  we set constant columns in other
* methods if constructor has too many statements already.
*/
if      gennulls
rc getexpression   instanceof constantnode
constantnode  rc getexpression    isnull
cb statementnumhitlimit 1
cb getfield field      instance
cb push index   1      first arg
rc generateexpression acb  cb
cb cast classname datavaluedescriptor      second arg
cb callmethod vmopcode invokeinterface  classname row        2
continue
userexprfun getfield field      instance
userexprfun push index   1      arg1
/* we want to reuse the null values instead of doing a new each time
* if the caller said to generate nulls or the underlying expression
* is a typed null value.
*/
boolean needdvdcast   true
if  rc isautoincrementgenerated
// (com.ibm.db2j.impl... datavaluedescriptor)
// this.getsetautoincvalue(column_number)
userexprfun pushthis
userexprfun push rc getcolumnposition
userexprfun push rc gettablecolumndescriptor   getautoincinc
userexprfun callmethod vmopcode invokevirtual  classname baseactivation
classname datavaluedescriptor  2
needdvdcast   false
else if  gennulls
rc getexpression   instanceof constantnode
constantnode  rc getexpression    isnull
userexprfun getfield field
userexprfun push index   1
userexprfun callmethod vmopcode invokeinterface  classname row
classname datavaluedescriptor  1      the express
acb generatenullwithexpress userexprfun  rc gettypecompiler
rc gettypeservices   getcollationtype
else
rc generateexpression acb  userexprfun
if  needdvdcast
userexprfun cast classname datavaluedescriptor
userexprfun callmethod vmopcode invokeinterface  classname row        2
userexprfun getfield field
userexprfun methodreturn
// we are now done modifying userexprfun
userexprfun complete
// what we return is the access of the field, i.e. the pointer to the method.
acb pushmethodreference mb  userexprfun
/**
*	build an empty row with the size and shape of the resultcolumnlist.
*
*	@return	an empty row of the correct size and shape.
* @exception standardexception		thrown on error
*/
public	execrow	buildemptyrow
throws standardexception
int					columncount   size
execrow				row   getexecutionfactory   getvaluerow  columncount
int					position   1
for  int index   0  index < columncount  index
resultcolumn rc    resultcolumn  elementat index
datatypedescriptor datatype   rc gettypeservices
datavaluedescriptor datavalue   datatype getnull
row setcolumn  position    datavalue
return	row
/**
*	build an empty index row for the given conglomerate.
*
*	@return	an empty row of the correct size and shape.
* @exception standardexception		thrown on error
*/
public	execrow	buildemptyindexrow tabledescriptor td
conglomeratedescriptor cd
storecostcontroller scc
datadictionary dd
throws standardexception
resultcolumn		rc
if  sanitymanager debug
if    cd isindex
sanitymanager throwassert     cd
int basecols   cd getindexdescriptor   basecolumnpositions
execrow row   getexecutionfactory   getvaluerow basecols length   1
for  int i   0  i < basecols length  i
columndescriptor coldes   td getcolumndescriptor basecols
datatypedescriptor datatype   coldes gettype
// rc = getresultcolumn(basecols[i]);
// rc = (resultcolumn) at(basecols[i] - 1);
// datatype = rc.gettypeservices();
datavaluedescriptor datavalue   datatype getnull
row setcolumn i   1  datavalue
rowlocation rltemplate   scc newrowlocationtemplate
row setcolumn basecols length   1  rltemplate
return	row
/**
generates a row with the size and shape of the resultcolumnlist.
some structures, like frombasetable and distinctnode,
need to generate rowallocator functions to get a row
the size and shape of their resultcolumnlist.
we return the method pointer, which is a field access
in the generated class.
@exception standardexception
*/
void generateholder expressionclassbuilder acb
methodbuilder mb
throws standardexception
generateholder acb  mb   formatablebitset  null   formatablebitset  null
/**
generates a row with the size and shape of the resultcolumnlist.
some structures, like frombasetable and distinctnode,
need to generate rowallocator functions to get a row
the size and shape of their resultcolumnlist.
we return the method pointer, which is a field access
in the generated class.
@exception standardexception
*/
void generateholder expressionclassbuilder acb
methodbuilder mb
formatablebitset referencedcols
formatablebitset propagatedcols
throws standardexception
// what we return is a pointer to the method.
acb pushmethodreference mb  generateholdermethod acb  referencedcols  propagatedcols
methodbuilder generateholdermethod expressionclassbuilder acb
formatablebitset referencedcols
formatablebitset propagatedcols
throws standardexception
int			numcols
string		rowallocatormethod
string		rowallocatortype
int			highestcolumnnumber    1
if  referencedcols    null
// find the number of the last column referenced in the table
for  int i   referencedcols anysetbit
i     1
i   referencedcols anysetbit i
highestcolumnnumber   i
else
highestcolumnnumber   size     1
// within the constructor:
//	 fieldx = getexecutionfactory().getvaluerow(# cols);
// the body of the new method:
// {
//   fieldx.setcolumn(1, col(1).generatecolumn(ps)));
//   ... and so on for each column ...
//   return fieldx;
// }
// static method exprn = method pointer to exprn;
// this sets up the method and the static field
methodbuilder exprfun   acb newexprfun
// allocate the right type of row, depending on
// whether we're scanning an index or a heap.
if  indexrow
rowallocatormethod
rowallocatortype   classname execindexrow
else
rowallocatormethod
rowallocatortype   classname execrow
numcols   size
/* declare the field */
localfield lf   acb newfielddeclaration modifier private  classname execrow
// generate the code to create the row in the constructor
gencreaterow acb  lf  rowallocatormethod  rowallocatortype  highestcolumnnumber   1
// now we fill in the body of the function
int colnum
// if there is a referenced column map, the first column to fill
// in is the first one in the bit map - otherwise, it is
// column 0.
if  referencedcols    null
colnum   referencedcols anysetbit
else
colnum   0
for  int index   0  index < numcols  index
resultcolumn rc     resultcolumn  elementat index
/* special code generation for rid since expression is currentrowlocationnode.
* really need yet another node type that does its own code generation.
*/
if  rc getexpression   instanceof currentrowlocationnode
conglomeratecontroller cc   null
int saveditem
rowlocation rl
cc   getlanguageconnectioncontext
gettransactioncompile   openconglomerate
conglomerateid
false
0
transactioncontroller mode_record
transactioncontroller isolation_read_committed
try
rl   cc newrowlocationtemplate
finally
if  cc    null
cc close
saveditem   acb additem rl
// get the rowlocation template
exprfun getfield lf      instance for setcolumn
exprfun push highestcolumnnumber   1      first arg
exprfun pushthis       instance for getrowlocationtemplate
exprfun push saveditem      first arg
exprfun callmethod vmopcode invokeinterface  classname activation
classname rowlocation  1
exprfun upcast classname datavaluedescriptor
exprfun callmethod vmopcode invokeinterface  classname row
2
continue
/* skip over those columns whose source is the immediate
* child result set.  (no need to generate a wrapper
* for a sql null when we are smart enough not to pass
* that wrapper to the store.)
* note: believe it or not, we have to check for the case
* where referencedcols is not null, but no bits are set.
* this can happen when we need to get all of the columns
* from the heap due to a check constraint.
*/
if  propagatedcols    null
propagatedcols getnumbitsset      0
/* we can skip this rc if it is simply propagating
* a column from the source result set.
*/
valuenode sourceexpr   rc getexpression
if  sourceexpr instanceof virtualcolumnnode
// there is a referenced columns bit set, so use
// it to figure out what the next column number is.
// colnum = referencedcols.anysetbit(colnum);
continue
// generate the column space creation call
// generate statements of the form
// r.setcolumn(columnnumber, columnshape);
//
// this assumes that there are no "holes" in the column positions,
// and that column positions reflect the stored format/order
exprfun getfield lf      instance
exprfun push colnum   1      first arg
rc generateholder acb  exprfun
exprfun callmethod vmopcode invokeinterface  classname row        2
// if there is a bit map of referenced columns, use it to
// figure out what the next column is, otherwise just go
// to the next column.
if  referencedcols    null
colnum   referencedcols anysetbit colnum
else
colnum
// generate:
// return fieldx;
// and add to the end of exprfun's body.
exprfun getfield lf
exprfun methodreturn
// we are done putting stuff in exprfun:
exprfun complete
return exprfun
/**
* generate the code to create an empty row in the constructor.
*
* @param acb					the acb.
* @param field					the field for the new row.
* @param rowallocatormethod	the method to call.
* @param rowallocatortype		the row type.
* @param numcols				the number of columns in the row.
*
* @exception standardexception		thrown on error
*/
private void gencreaterow expressionclassbuilder acb
localfield field
string rowallocatormethod
string rowallocatortype
int numcols
throws standardexception
// create the row in the constructor
//	 fieldx = getexecutionfactory().getvaluerow(# cols);
methodbuilder cb   acb getconstructor
acb pushgetexecutionfactoryexpression cb      instance
cb push numcols
cb callmethod vmopcode invokeinterface   string  null
rowallocatormethod  rowallocatortype  1
cb setfield field
/* increase the statement counter in constructor.  code size in
* constructor can become too big (more than 64k) for java compiler
* to handle (beetle 4293).  we set constant columns in other
* methods if constructor has too many statements already.
*/
cb statementnumhitlimit 1  		   ignore return value
/**
* make a resultdescription for use in a resultset.
* this is useful when generating/executing a normalizeresultset, since
* it can appear anywhere in the tree.
*
* @return	a resultdescription for this resultsetnode.
*/
public resultcolumndescriptor makeresultdescriptors
resultcolumndescriptor coldescs   new resultcolumndescriptor
int size   size
for  int index   0  index < size  index
// the resultcolumn nodes are descriptors, so take 'em...
coldescs   getexecutionfactory   getresultcolumndescriptor   resultcolumndescriptor  elementat index
return coldescs
/**
* expand any *'s in the resultcolumnlist.  in addition, we will guarantee that
* each resultcolumn has a name.  (all generated names will be unique across the
* entire statement.)
*
*
* @exception standardexception		thrown on error
*/
public void expandallsandnamecolumns fromlist fromlist
throws standardexception
boolean			expanded   false
resultcolumnlist allexpansion
tablename			fulltablename
/* first walk result column list looking for *'s to expand */
for  int index   0  index < size    index
resultcolumn rc    resultcolumn  elementat index
if  rc instanceof allresultcolumn
expanded   true
//fulltablename = ((allresultcolumn) rc).getfulltablename();
tablename temp   rc gettablenameobject
if temp    null
string sname   temp getschemaname
string tname   temp gettablename
fulltablename   maketablename sname tname
else
fulltablename   null
allexpansion   fromlist expandall fulltablename
/* make sure that every column has a name */
allexpansion nameallresultcolumns
/* replace the allresultcolumn with the expanded list.
* we will update the virtualcolumnids once below.
*/
removeelementat index
for  int inner   0  inner < allexpansion size    inner
insertelementat allexpansion elementat inner   index   inner
// if the rc was a "*", we need to set the initial list size
// to the number of columns that are actually returned to
// the user.
markinitialsize
else
/* make sure that every column has a name */
rc guaranteecolumnname
/* go back and update the virtualcolumnids if we expanded any *'s */
if  expanded
int size   size
for  int index   0  index < size  index
/* vectors are 0-based, virtualcolumnids are 1-based. */
resultcolumn  elementat index   setvirtualcolumnid index   1
/**
* generate (unique across the entire statement) column names for those
* resultcolumns in this list which are not named.
*
* @exception standardexception		thrown on error
*/
public void nameallresultcolumns
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
resultcolumn guaranteecolumnname
/**
* copy the types and lengths for this rcl (the target)
* to another rcl (the source).
* this is useful when adding a normalizeresultsetnode.
*
* @param sourcercl	the source rcl
*/
public void copytypesandlengthstosource resultcolumnlist sourcercl  throws standardexception
/* source and target can have different lengths. */
int size   math min size    sourcercl size
for  int index   0  index < size  index
resultcolumn sourcerc    resultcolumn  sourcercl elementat index
resultcolumn resultcolumn    resultcolumn  elementat index
sourcerc settype resultcolumn gettypeservices
sourcerc getexpression   settype resultcolumn gettypeservices
/*
** check whether the column lengths and types of the result columns
** match the expressions under those columns.  this is useful for
** insert and update statements.  for select statements this method
** should always return true.  there is no need to call this for a
** delete statement.
** note: we skip over generated columns since they won't have a
** column descriptor.
**
** @return	true means all the columns match their expressions,
**		false means at least one column does not match its
**		expression
*/
boolean columntypesandlengthsmatch
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
/* skip over generated columns */
if  resultcolumn isgenerated
continue
if    resultcolumn columntypeandlengthmatch
return false
return true
boolean columntypesandlengthsmatch resultcolumnlist otherrcl
throws standardexception
boolean			retval   true
/* we check every rc, even after finding 1 that requires
* normalization, because the conversion of constants to
* the appropriate type occurs under this loop.
*/
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
resultcolumn otherresultcolumn    resultcolumn  otherrcl elementat index
/* skip over generated columns */
if  resultcolumn isgenerated      otherresultcolumn isgenerated
continue
if    resultcolumn columntypeandlengthmatch otherresultcolumn
retval   false
return retval
/**
* determine whether this rcl is a no-op projection of the given rcl.
* it only makes sense to do this if the given rcl is from the child
* result set of the projectrestrict that this rcl is from.
*
* @param childrcl	the resultcolumnlist of the child result set.
*
* @return	true if this rcl is a no-op projection of the given rcl.
*/
public boolean nopprojection resultcolumnlist childrcl
/*
** this rcl is a useless projection if each column in the child
** if the same as the column in this rcl.  this is impossible
** if the two rcls have different numbers of columns.
*/
if  this size      childrcl size
return false
/*
** the two lists have the same numbers of elements.  are the lists
** identical?  in other words, is the expression in every resultcolumn
** in the prn's rcl a columnreference that points to the corresponding
** column in the child?
*/
int size   size
for  int index   0  index < size  index
resultcolumn thiscolumn    resultcolumn  elementat index
resultcolumn referencedcolumn   null
/*
** a no-op projection can point to a virtualcolumnnode or a
** columnreference.
*/
if  thiscolumn getexpression   instanceof virtualcolumnnode
referencedcolumn
virtualcolumnnode   thiscolumn getexpression
getsourcecolumn
else if  thiscolumn getexpression   instanceof columnreference
referencedcolumn
columnreference   thiscolumn getexpression
getsource
else
return false
resultcolumn childcolumn    resultcolumn  childrcl elementat index
if  referencedcolumn    childcolumn
return false
return true
/**
*  create a shallow copy of a resultcolumnlist and its resultcolumns.
*  (all other pointers are preserved.)
*  useful for building new resultsetnodes during preprocessing.
*
*  @return none.
*
* @exception standardexception		thrown on error
*/
public resultcolumnlist copylistandobjects
throws standardexception
resultcolumn	 newresultcolumn
resultcolumn	 origresultcolumn
resultcolumnlist newlist
/* create the new resultcolumnlist */
newlist    resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
/* walk the current list - for each resultcolumn in the list, make a copy
* and add it to the new list.
*/
int size   size
for  int index   0  index < size  index
origresultcolumn    resultcolumn  elementat index
newresultcolumn   origresultcolumn cloneme
newlist addresultcolumn newresultcolumn
newlist copyorderbyselect this
return newlist
/**
* remove any columns that may have been added for an order by clause.
* in a query like:
* <pre>select a from t order by b</pre> b is added to the select list
* however in the final projection, after the sort is complete, b will have
* to be removed.
*
*/
public void removeorderbycolumns
int idx   size     1
for  int i   0  i < orderbyselect  i    idx
removeelementat idx
orderbyselect   0
/**
* walk the list and replace resultcolumn.expression with a new
* virtualcolumnnode.  this is useful when propagating a resultcolumnlist
* up the query tree.
* note: this flavor marks all of the underlying rcs as referenced.
*
* @param sourceresultset		resultsetnode that is source of value
*
* @exception standardexception		thrown on error
*/
public void genvirtualcolumnnodes resultsetnode sourceresultset
resultcolumnlist sourceresultcolumnlist
throws standardexception
genvirtualcolumnnodes sourceresultset  sourceresultcolumnlist  true
/**
* walk the list and replace resultcolumn.expression with a new
* virtualcolumnnode.  this is useful when propagating a resultcolumnlist
* up the query tree.
*
* @param sourceresultset		resultsetnode that is source of value
* @param markreferenced		whether or not to mark the underlying rcs
*								as referenced
*
* @exception standardexception		thrown on error
*/
public void genvirtualcolumnnodes resultsetnode sourceresultset
resultcolumnlist sourceresultcolumnlist
boolean markreferenced
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
/* dts = resultcolumn.getexpression().gettypeservices(); */
datatypedescriptor dts   resultcolumn gettypeservices
/* vectors are 0-based, virtualcolumnids are 1-based */
resultcolumn expression    valuenode  getnodefactory   getnode
c_nodetypes virtual_column_node
sourceresultset
sourceresultcolumnlist elementat index
reusefactory getinteger index   1
getcontextmanager
/* mark the resultcolumn as being referenced */
if  markreferenced
resultcolumn setreferenced
/**
* walk the list and adjust the virtualcolumnids in the resultcolumns
* by the specified amount.  if resultcolumn.expression is a virtualcolumnnode,
* then we adjust the columnid there as well.
*
* @param adjust		the size of the increment.
*/
public void adjustvirtualcolumnids int adjust
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
resultcolumn adjustvirtualcolumnid adjust
if  sanitymanager debug
if
resultcolumn getexpression   instanceof virtualcolumnnode
sanitymanager throwassert
resultcolumn getexpression   getclass   getname
virtualcolumnnode  resultcolumn getexpression    columnid    adjust
/**
* project out any unreferenced resultcolumns from the list and
* reset the virtual column ids in the referenced resultcolumns.
* if all resultcolumns are projected out, then the list is not empty.
*
* @exception standardexception		thrown on error
*/
public void	doprojection   throws standardexception
int				numdeleted   0
int size   size
resultcolumnlist deletedrcl   new resultcolumnlist
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
/* rc's for frombasetables are marked as referenced during binding.
* for other nodes, namely joinnodes, we need to go 1 level
* down the rc/vcn chain to see if the rc is referenced.  this is
* because we propagate the referencing info from the bottom up.
*/
if     resultcolumn isreferenced
resultcolumn getexpression   instanceof virtualcolumnnode
virtualcolumnnode  resultcolumn getexpression    getsourcecolumn   isreferenced
// remember the rc to delete when done
deletedrcl addelement resultcolumn
/* remember how many we have deleted and decrement the
* virtualcolumnids for all nodes which appear after us
* in the list.
*/
numdeleted
else
/* decrement the virtualcolumnid for each node in the list
* after the 1st deleted one.
*/
if  numdeleted >  1
resultcolumn adjustvirtualcolumnid    numdeleted
/* make sure that the rc is marked as referenced! */
resultcolumn setreferenced
// go back and delete the rcs to be delete from the list
for  int index   0  index < deletedrcl size    index
removeelement  resultcolumn  deletedrcl elementat index
/**
* check the uniqueness of the column names within a column list.
*
* @param errforgencols	raise an error for any generated column names.
*
* @return string	the first duplicate column name, if any.
*/
public string verifyuniquenames boolean errforgencols
throws standardexception
int size   size
hashtable	ht   new hashtable size   2   float   999
resultcolumn rc
for  int index   0  index < size  index
rc    resultcolumn  elementat index
if  errforgencols    rc isnamegenerated
throw standardexception newexception sqlstate lang_db2_view_requires_column_names
/* verify that this column's name is unique within the list */
string colname     resultcolumn  elementat index   getname
object object   ht put colname  colname
if  object    null
string  object  equals colname
return colname
/* no duplicate column names */
return null
/**
* validate the derived column list (dcl) and propagate the info
* from the list to the final resultcolumnlist.
*
* @param derivedrcl	the derived column list
* @param tablename		the table name for the fromtable
*
* @exception standardexception	thrown on error
*/
public void propagatedclinfo resultcolumnlist derivedrcl  string tablename
throws standardexception
string duplicatecolname
/* do both lists, if supplied by user, have the same degree? */
if  derivedrcl size      size
derivedrcl getcountmismatchallowed
if  visiblesize      derivedrcl size
throw standardexception newexception sqlstate lang_derived_column_list_mismatch  tablename
/* check the uniqueness of the column names within the derived list */
duplicatecolname   derivedrcl verifyuniquenames false
if  duplicatecolname    null
throw standardexception newexception sqlstate lang_duplicate_column_name_derived  duplicatecolname
/* we can finally copy the derived names into the final list */
copyresultcolumnnames derivedrcl
/**
* look for and reject ? parameters under resultcolumns.  this is done for
* select statements.
*
* @exception standardexception		thrown if a ? parameter found directly
*									under a resultcolumn
*/
void rejectparameters   throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
rc rejectparameter
/**
* check for (and reject) xml values directly under the resultcolumns.
* this is done for select/values statements.  we reject values
* in this case because jdbc does not define an xml type/binding
* and thus there's no standard way to pass such a type back
* to a jdbc application.
*
* note that we do allow an xml column in a top-level rcl
* if that column was added to the rcl by _us_ instead of
* by the user.  for example, if we have a table:
*
* create table t1 (i int, x xml)
*
* and the user query is:
*
* select i from t1 order by x
*
* the "x" column will be added (internally) to the rcl
* as part of order by processing--and so we need to
* allow that xml column to be bound without throwing
* an error.  if, as in this case, the xml column reference
* is invalid (we can't use order by on an xml column because
* xml values aren't ordered), a more appropriate error
* message should be returned to the user in later processing.
* if we didn't allow for this, the user would get an
* error saying that xml columns are not valid as part
* of the result set--but as far as s/he knows, there
* isn't such a column: only "i" is supposed to be returned
* (the rc for "x" was added to the rcl by _us_ as part of
* order by processing).
*
* assumption: any rcs that are generated internally and
* added to this rcl (before this rcl is bound) are added
* at the _end_ of the list.  if that's true, then any
* rc with an index greater than the size of the initial
* (user-specified) list must have been added internally
* and will not be returned to the user.
*
* @exception standardexception		thrown if an xml value found
*									directly under a resultcolumn
*/
void rejectxmlvalues   throws standardexception
int sz   size
resultcolumn rc   null
for  int i   1  i <  sz  i
if  i > initiallistsize
// this rc was generated internally and will not
// be returned to the user, so don't throw error.
continue
rc   getresultcolumn i
if   rc    null      rc gettype      null
rc gettype   gettypeid   isxmltypeid
disallow it
throw standardexception newexception
sqlstate lang_attempt_to_select_xml
/**
* set the resultsetnumber in all of the resultcolumns.
*
* @param resultsetnumber	the resultsetnumber
*/
public void setresultsetnumber int resultsetnumber
int size   size
for  int index   0  index < size  index
resultcolumn  elementat index   setresultsetnumber resultsetnumber
/**
* mark all of the resultcolumns as redundant.
* useful when chopping a resultsetnode out of a tree when there are
* still references to its rcl.
*/
public void setredundant
int size   size
for  int index   0  index < size  index
resultcolumn  elementat index   setredundant
/**
* verify that all of the columns in the set clause of a positioned update
* appear in the cursor's for update of list.
*
* @param ucl			the cursor's for update of list.  (may be null.)
* @param cursorname	the cursor's name.
*
* @exception standardexception			thrown on error
*/
public void checkcolumnupdateability string ucl  string cursorname
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
if  resultcolumn updated
resultcolumn foundinlist ucl
throw standardexception newexception sqlstate lang_column_not_updatable_in_cursor
resultcolumn getname
cursorname
/**
* set up the result expressions for a union, intersect, or except:
*	o verify union type compatiblity
*	o get dominant type for result (type + max length + nullability)
*  o create a new columnreference with dominant type and name of from this
*    rcl and make that the new expression.
*  o set the type info for in the resultcolumn to the dominant type
*
* note - we are assuming that caller has generated a new rcl for the union
* with the same names as the left side's rcl and copies of the expressions.
*
* @param otherrcl	rcl from other side of the union.
* @param tablenumber	the tablenumber for the union.
* @param level		the nesting level for the union.
* @param operatorname "union", "intersect", or "except"
*
* @exception standardexception			thrown on error
*/
public void	setunionresultexpression resultcolumnlist otherrcl
int tablenumber
int level
string operatorname
throws standardexception
tablename		dummytn
if  sanitymanager debug
if  visiblesize      otherrcl visiblesize
sanitymanager throwassert
size
otherrcl size
/* make a dummy tablename to be shared by all new crs */
dummytn    tablename  getnodefactory   getnode
c_nodetypes table_name


getcontextmanager
contextmanager cm   getcontextmanager
int size   size
for  int index   0  index < size  index
boolean		 nullableresult
columnreference newcr
resultcolumn thisrc    resultcolumn  elementat index
resultcolumn otherrc    resultcolumn  otherrcl elementat index
valuenode	 thisexpr   thisrc getexpression
valuenode	 otherexpr   otherrc getexpression
// if there is one row that is not 'autoincrement', the union should
// not be 'autoincrement'.
if   otherrc isautoincrementgenerated      thisrc isautoincrementgenerated
thisrc resetautoincrementgenerated
/*
** if there are ? parameters in the resultcolumnlist of a row
** in a table constructor, their types will not be set.  just skip
** these - their types will be set later.  each ? parameter will
** get the type of the first non-? in its column, so it can't
** affect the final dominant type.  it's possible that all the
** rows for a particular column will have ? parameters - this is
** an error condition that will be caught later.
*/
typeid thistypeid   thisexpr gettypeid
if  thistypeid    null
continue
typeid othertypeid   otherexpr gettypeid
if  othertypeid    null
continue
/*
** check type compatability.  we want to make sure that
** the types are assignable in either direction
** and they are comparable.
*/
classfactory cf   getclassfactory
if
thisexpr gettypecompiler   storable othertypeid  cf
otherexpr gettypecompiler   storable thistypeid  cf
throw standardexception newexception sqlstate lang_not_union_compatible
thistypeid getsqltypename
othertypeid getsqltypename
operatorname
datatypedescriptor resulttype   thisexpr gettypeservices   getdominanttype
otherexpr gettypeservices
cf
newcr    columnreference  getnodefactory   getnode
c_nodetypes column_reference
thisrc getname
dummytn
getcontextmanager
newcr settype resulttype
/* set the tablenumber and nesting levels in newcr.
* if thisexpr is not a cr, then newcr cannot be
* correlated, hence source and nesting levels are
* the same.
*/
if  thisexpr instanceof columnreference
newcr copyfields  columnreference  thisexpr
else
newcr setnestinglevel level
newcr setsourcelevel level
newcr settablenumber tablenumber
thisrc setexpression newcr
thisrc settype
thisrc gettypeservices   getdominanttype
otherrc gettypeservices    cf
/* db2 requires both sides of union to have same name for the result to
* have that name. otherwise, leave it or set it to a generated name */
if  thisrc getname      null     thisrc isnamegenerated
otherrc getname      null
/* result name needs to be changed */
if  otherrc isnamegenerated
thisrc setname otherrc getname
thisrc setnamegenerated true
else if   thisrc getname   equals otherrc getname
/* both sides have user specified names that don't match */
thisrc setname null
thisrc guaranteecolumnname
thisrc setnamegenerated true
/**
* do the 2 rcls have the same type & length.
* this is useful for unions when deciding whether a normalizeresultset is required.
*
* @param otherrcl	the other rcl.
*
* @return boolean	whether or not there is an exact union type match on the 2 rcls.
*/
public boolean isexacttypeandlengthmatch resultcolumnlist otherrcl  throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn thisrc    resultcolumn  elementat index
resultcolumn otherrc    resultcolumn  otherrcl elementat index
if    thisrc gettypeservices   isexacttypeandlengthmatch
otherrc gettypeservices
return false
return true
/**
* does the column list contain any of the given column positions
* that are updated? implements same named routine in updatelist.
*
* @param columns	an array of column positions
*
* @return	true if this column list contains any of the given columns
*/
public	boolean updateoverlaps int columns
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if     rc updated
continue
int	column   rc getcolumnposition
for  int i   0  i < columns length  i
if  columns    column
return true
return false
/**
* return an array that contains references to the columns in this list
* sorted by position.
*
* @return	the sorted array.
*/
resultcolumn getsortedbyposition
int				size   size
resultcolumn	result
/*
** form an array of the original resultcolumns
*/
result   new resultcolumn
/*
** put the resultcolumns in the array
*/
for  int index   0  index < size  index
result    resultcolumn  elementat index
/*
** sort the array by column position
*/
java util arrays sort result
return result
/**
*	return an array of all my column positions, sorted in
*	ascending order.
*
*	@return	a sorted array
*/
public	int	sortme
resultcolumn sortedresultcolumns   getsortedbyposition
int sortedcolumnids   new int
for  int ix   0  ix < sortedresultcolumns length  ix
sortedcolumnids   sortedresultcolumns getcolumnposition
return sortedcolumnids
/**
* expand this resultcolumnlist by adding all columns from the given
* table that are not in this list.  the result is sorted by column
* position.
*
* @param td	the tabledescriptor for the table in question
* @param tablename	the name of the table as given in the query
*
* @return	a new resultcolumnlist expanded to include all columns in
*			the given table.
*
* @exception standardexception		thrown on error
*/
public resultcolumnlist expandtoall tabledescriptor td
tablename tablename
throws standardexception
resultcolumn				rc
columndescriptor			cd
resultcolumnlist			retval
resultcolumn				originalrcs
int							posn
/* get a new resultcolumnlist */
retval    resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
/*
** form a sorted array of the resultcolumns
*/
originalrcs   getsortedbyposition
posn   0
/* iterate through the columndescriptors for the given table */
columndescriptorlist cdl   td getcolumndescriptorlist
int					 cdlsize   cdl size
for  int index   0  index < cdlsize  index
cd    columndescriptor  cdl elementat index
if   posn < originalrcs length
cd getposition      originalrcs getcolumnposition
rc   originalrcs
posn
else
/* build a resultcolumn/columnreference pair for the column */
rc   makecolumnreferencefromname  tablename  cd getcolumnname
/* bind the new resultcolumn */
rc bindresultcolumnbyposition td  cd getposition
/* add the resultcolumn to the list */
retval addresultcolumn rc
if  sanitymanager debug
sanitymanager assert posn    originalrcs length
return retval
/**
* bind any untyped null nodes to the types in the given resultcolumnlist.
* nodes that don't know their type may pass down nulls to
* children nodes.  in the case of something like a union, it knows
* to try its right and left result sets against each other.
* but if a null reaches us, it means we have a null type that
* we don't know how to handle.
*
* @param bindingrcl	the resultcolumnlist with the types to bind to.
*
* @exception standardexception		thrown on error
*/
public void binduntypednullstoresultcolumns resultcolumnlist bindingrcl
throws standardexception
if  bindingrcl    null
throw standardexception newexception sqlstate lang_null_in_values_clause
if  sanitymanager debug
sanitymanager assert bindingrcl size   >  this size
int size   size
for  int index   0  index < size  index
resultcolumn	bindingrc    resultcolumn  bindingrcl elementat index
resultcolumn	thisrc    resultcolumn  elementat index
thisrc typeuntypednullexpression bindingrc
/**
* mark all the columns in this list as updated by an update statement.
*/
void markupdated
int size   size
for  int index   0  index < size  index
resultcolumn  elementat index   markupdated
/**
* mark all the (base) columns in this list as updatable by a positioned update
* statement.  this is necessary
* for positioned update statements, because we expand the column list
* to include all the columns in the base table, and we need to be able
* to tell which ones the user is really trying to update so we can
* determine correctly whether all the updated columns are in the
* "for update" list.
*/
void markupdatablebycursor
int size   size
for  int index   0  index < size  index
//determine if the column is a base column and not a derived column
if    resultcolumn  elementat index   getsourcetablename      null
resultcolumn  elementat index   markupdatablebycursor
/**
* @see querytreenode#disableprivilegecollection
*/
public void disableprivilegecollection
super disableprivilegecollection
int size   size
for  int index   0  index < size  index
resultcolumn  elementat index   disableprivilegecollection
/**
* verify that all of the column names in this list are contained
* within the columndefinitionnodes within the tableelementlist.
*
*
* @return string	the 1st column name, if any, that is not in the list.
*/
public string verifycreateconstraintcolumnlist tableelementlist tel
int size   size
for  int index   0  index < size  index
string colname     resultcolumn  elementat index   getname
if    tel containscolumnname colname
return colname
return null
/**
* export the result column names to the passed in string[].
*
* @param columnnames	string[] to hold the column names.
*/
public void exportnames string columnnames
if  sanitymanager debug
if  size      columnnames length
sanitymanager throwassert
size
columnnames length
int size   size
for  int index   0  index < size  index
columnnames     resultcolumn  elementat index   getname
/**
* given a resultcolumn at the next deepest level in the tree,
* search this rcl for its parent resultcolumn.
*
* @param childrc	the child resultcolumn
*
* @return resultcolumn	the parent resultcolumn
*/
public resultcolumn findparentresultcolumn resultcolumn childrc
resultcolumn	parentrc   null
int size   size
for  int index   0  index < size  index
resultcolumn	rc     resultcolumn  elementat index
if  rc getexpression   instanceof columnreference
columnreference	cr    columnreference  rc getexpression
if  cr getsource      childrc
parentrc   rc
break
else if  rc getexpression   instanceof virtualcolumnnode
virtualcolumnnode vcn    virtualcolumnnode  rc getexpression
if  vcn getsourcecolumn      childrc
parentrc   rc
break
return parentrc
/**
* mark as updatable all the columns in this result column list
* that match the columns in the given update column list.
*
* @param updatecolumns		a resultcolumnlist representing the columns
*							to be updated.
*/
void markupdated resultcolumnlist updatecolumns
resultcolumn	updatecolumn
resultcolumn	resultcolumn
int size   updatecolumns size
for  int index   0  index < size  index
updatecolumn    resultcolumn  updatecolumns elementat index
resultcolumn   getresultcolumn updatecolumn getname
/*
** this resultcolumnlist may not be bound yet - for update
** statements, we mark the updated columns *before* we bind
** the rcl.  this ordering is important because we add columns
** to the rcl after marking the update columns and before
** binding.
**
** so, it can happen that there is an invalid column name in
** the list.  this condition will cause an exception when the
** rcl is bound.  just ignore it for now.
*/
if  resultcolumn    null
resultcolumn markupdated
/**
* mark all the columns in the select sql that this result column list represents
* as updatable if they match the columns in the given update column list.
*
* @param updatecolumns		a vector representing the columns
*							to be updated.
*/
void markcolumnsinselectlistupdatablebycursor vector updatecolumns
commoncodeforupdatablebycursor updatecolumns  true
/**
* dealingwithselectresultcolumnlist true means we are dealing with
* resultcolumnlist for a select sql. when dealing with resultcolumnlist for
* select sql, it is possible that not all the updatable columns are
* projected in the select column list and hence it is possible that we may
* not find the column to be updated in the resultcolumnlist and that is why
* special handling is required when dealingwithselectresultcolumnlist is true.
* eg select c11, c13 from t1 for update of c11, c12
* in the eg above, we will find updatable column c11 in the select column
* list but we will not find updatable column c12 in the select column list
*/
private void commoncodeforupdatablebycursor vector updatecolumns  boolean dealingwithselectresultcolumnlist
/*
** if there is no update column list, or the list is empty, then it means that
** all the columns which have a base table associated with them are updatable.
*/
if    updatecolumns    null      updatecolumns size      0
markupdatablebycursor
else
int				ucsize   updatecolumns size
resultcolumn	resultcolumn
string columnname
for  int index   0  index < ucsize  index
columnname    string  updatecolumns elementat index
resultcolumn   getresultcolumn columnname
if  sanitymanager debug
if  resultcolumn    null     dealingwithselectresultcolumnlist
sanitymanager throwassert
columnname
//following if means the column specified in for update clause is not
//part of the select list
if  resultcolumn    null    dealingwithselectresultcolumnlist
continue
resultcolumn markupdatablebycursor
/**
* mark as updatable all the columns in this result column list
* that match the columns in the given update column list
*
* @param updatecolumns		a vector representing the columns
*							to be updated.
*/
void markupdatablebycursor vector updatecolumns
commoncodeforupdatablebycursor updatecolumns  false
/**
* returns true if the given column position is for a column that will
* be or could be updated by the positioned update of a cursor.
*
* @param columnposition	the position of the column in question
*
* @return	true if the column is updatable
*/
boolean updatablebycursor int columnposition
return getresultcolumn columnposition  updatablebycursor
/**
* return whether or not this rcl can be flattened out of a tree.
* it can only be flattened if the expressions are all cloneable.
*
* @return boolean	whether or not this rcl can be flattened out of a tree.
*/
public boolean iscloneable
boolean retcode   true
int size   size
for  int index   0  index < size  index
resultcolumn	rc     resultcolumn  elementat index
if    rc getexpression   iscloneable
retcode   false
break
return retcode
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @exception standardexception			thrown on error
*/
public void remapcolumnreferencestoexpressions   throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
// the expression may be null if this column is an identity
// column generated always. if the expression is not null, it
// is a columnreference; we call through to the columnreference
// to give it a chance to remap itself from the outer query
// node to this one.
if  rc getexpression      null
rc setexpression
rc getexpression   remapcolumnreferencestoexpressions
/*
** indicate that the conglomerate is an index, so we need to generate a
** rowlocation as the last column of the result set.
**
** @param cid	the conglomerate id of the index
*/
void setindexrow long cid  boolean forupdate
indexrow   true
conglomerateid   cid
this forupdate   forupdate
/* debugging methods */
/**
* verify that all resultcolumns and their expressions have type information
* and that the type information between the respective rcs and
* expressions matches.
*
* @return boolean	whether or not the type information is consistent
*/
public boolean hasconsistenttypeinfo   throws standardexception
boolean isconsistent   true
if  sanitymanager debug
int size   size
for  int index   0  index < size  index
resultcolumn	rc    resultcolumn  elementat index
valuenode	 	expr   rc getexpression
datatypedescriptor rcdts   rc gettypeservices
datatypedescriptor exdts   expr gettypeservices
if  rcdts    null    exdts    null
isconsistent   false
break
if  rcdts getclass   getname
exdts getclass   getname
isconsistent   false
break
return isconsistent
/**
* return whether or not this rcl contains an allresultcolumn.
* this is useful when dealing with select * views which
* reference tables that may have had columns added to them via
* alter table since the view was created.
*
* @return whether or not this rcl contains an allresultcolumn.
*/
public boolean containsallresultcolumn
boolean	containsallresultcolumn   false
int size   size
for  int index   0  index < size  index
if  elementat index  instanceof allresultcolumn
containsallresultcolumn   true
break
return containsallresultcolumn
/**
* count the number of rcs in the list that are referenced.
*
* @return	the number of rcs in the list that are referenced.
*/
public int countreferencedcolumns
int numreferenced   0
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc isreferenced
numreferenced
return numreferenced
/**
* record the column ids of the referenced columns in the specified array.
*
* @param idarray	int[] for column ids
* @param basis		0 (for 0-based ids) or 1 (for 1-based ids)
*/
public void recordcolumnreferences int idarray  int basis
int currarrayelement   0
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc isreferenced
idarray   index   basis
/**
* record the top level columnreferences in the specified array
* and table map
* this is useful when checking for uniqueness conditions.
* note: all top level crs assumed to be from the same table.
*		 the size of the array is expected to be the # of columns
*		 in the table of interest + 1, so we use 1-base column #s.
*
* @param colarray1	boolean[] for columns
* @param tablecolmap	jbitset[] for tables
* @param tablenumber	table number of column references
*/
public void recordcolumnreferences boolean colarray1  jbitset tablecolmap
int tablenumber
int size   size
for  int index   0  index < size  index
int columnnumber
resultcolumn rc    resultcolumn  elementat index
if     rc getexpression   instanceof columnreference
continue
columnnumber     columnreference  rc getexpression    getcolumnnumber
colarray1   true
tablecolmap set columnnumber
/**
* return whether or not all of the rcs in the list whose
* expressions are columnreferences are
* from the same table.  one place this
* is useful for distinct elimination based on the existence
* of a uniqueness condition.
*
* @return	-1 if all of the top level crs in the rcl
*			are not columnreferences from the same table,
*			else the tablenumber
*/
int alltopcrsfromsametable
int tablenumber    1
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
valuenode vn   rc getexpression
if     vn instanceof columnreference
continue
// remember the tablenumber from the first cr
columnreference cr    columnreference  vn
if  tablenumber     1
tablenumber   cr gettablenumber
else if  tablenumber    cr gettablenumber
return  1
return tablenumber
/**
* clear the column references from the rcl. (restore rcl back to a state
* where none of the rcs are marked as referenced.)
*/
public void clearcolumnreferences
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc isreferenced
rc setunreferenced
/**
* copy the referenced rcs from this list to the supplied target list.
*
* @param targetlist	the list to copy to
*/
public void copyreferencedcolumnstonewlist resultcolumnlist targetlist
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc isreferenced
targetlist addelement rc
/**
* copy the rcs from this list to the supplied target list.
*
* @param targetlist	the list to copy to,
* @param copylist      1 based bitmap we copy columns associated with set bits.
*/
public void copycolumnstonewlist resultcolumnlist targetlist  formatablebitset copylist
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  copylist isset rc getcolumnposition
targetlist addelement rc
/**
* get a formatablebitset of the columns referenced in this rcl
*
* @return the formatablebitset
*/
public formatablebitset getcolumnreferencemap
formatablebitset colmap   new formatablebitset size
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc isreferenced
colmap set index
return colmap
/**
* or in any isreferenced booleans from the virtual column chain. that is the isreferenced bits on each
* resultcolumn on the list will be set if the resultcolumn is referenced or if any virtualcolumnnode in its
* expression chain refers to a referenced column.
*/
void pullvirtualisreferenced
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
rc pullvirtualisreferenced
end of pullvirtualisreferenced
public void cleartablenames
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
rc cleartablename
/**
* set the value of whether or not a count mismatch is allowed between
* this rcl, as a derived column list, and an underlying rcl.  this is allowed
* for select * views when an underlying table has had columns added to it
* via alter table.
*
* @param allowed	whether or not a mismatch is allowed.
*/
protected void setcountmismatchallowed boolean allowed
countmismatchallowed   allowed
/**
* return whether or not a count mismatch is allowed between this rcl,
* as a derived column list, and an underlying rcl.  this is allowed
* for select * views when an underlying table has had columns added to it
* via alter table.
*
* return whether or not a mismatch is allowed.
*/
protected boolean getcountmismatchallowed
return countmismatchallowed
/**
* get the size of all the columns added
* together.  does <b>not</b> include the
* column overhead that the store requires.
* also, will be a very rough estimate for
* user types.
*
* @return the size
*/
public int gettotalcolumnsize
int colsize   0
int size   size
for  int index   0  index < size  index
colsize      resultcolumn  elementat index   getmaximumcolumnsize
return colsize
/**
* generate an rcl to match the contents of a resultsetmetadata.
* this is useful when dealing with vtis.
*
* @param rsmd			the resultsetmetadata.
* @param tablename		the tablename for the bcns.
* @param javaclassname	the name of the vti
*
* @exception standardexception			thrown on error
*/
public void createlistfromresultsetmetadata resultsetmetadata rsmd
tablename tablename
string javaclassname
throws standardexception
try
// jdbc columns #s are 1-based
// check to make sure # of columns >= 1
int numcolumns   rsmd getcolumncount
if  numcolumns <  0
throw standardexception newexception sqlstate lang_invalid_v_t_i_column_count
javaclassname  string valueof numcolumns
for  int index   1  index <  numcolumns  index
boolean nullableresult
rsmd isnullable index     resultsetmetadata columnnonulls
typeid cti
int jdbccolumntype   rsmd getcolumntype index
switch  jdbccolumntype
case org apache derby iapi reference jdbc20translation sql_types_java_object
case types other
cti   typeid getuserdefinedtypeid rsmd getcolumntypename index   false
break
default
cti   typeid getbuiltintypeid jdbccolumntype
break
// handle the case where a vti returns a bad column type
if  cti    null
throw standardexception newexception sqlstate lang_bad_j_d_b_c_type_info  integer tostring index
// get the maximum byte storage for this column
int maxwidth
/* get maximum byte storage from rsmd for variable
* width types, set it to maxint for the long types,
* otherwise get it from the typeid
*/
if  cti variablelength
maxwidth   rsmd getcolumndisplaysize index
else if  jdbccolumntype    types longvarchar
jdbccolumntype    types longvarbinary
maxwidth   integer max_value
else
maxwidth   0
int precision   cti isdecimaltypeid   ? rsmd getprecision index    0
int scale   cti isdecimaltypeid   ? rsmd getscale index    0
datatypedescriptor dts   new datatypedescriptor cti
precision
scale
nullableresult
maxwidth
valuenode bcn    valuenode  getnodefactory   getnode
c_nodetypes base_column_node
rsmd getcolumnname index
tablename
dts
getcontextmanager
resultcolumn rc    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
rsmd getcolumnname index
bcn
getcontextmanager
rc settype dts
addresultcolumn rc
catch  throwable t
if  t instanceof standardexception
throw  standardexception  t
else
throw standardexception unexpecteduserexception t
/**
* add an rc to the end of the list for the rid from an index.
* note: rc.expression is a currentrowlocationnode.  this was previously only used
* for non-select dml.  we test for this node when generating the holder above
* and generate the expected code.  (we really should create yet another new node
* type with its own code generation.)
*
* @exception standardexception			thrown on error
*/
public void addrcforrid
throws standardexception
resultcolumn		rowlocationcolumn
currentrowlocationnode		rowlocationnode
/* generate the rowlocation column */
rowlocationnode    currentrowlocationnode  getnodefactory   getnode
c_nodetypes current_row_location_node
getcontextmanager
rowlocationcolumn
resultcolumn  getnodefactory   getnode
c_nodetypes result_column
rowlocationnode
getcontextmanager
rowlocationcolumn markgenerated
/* append to the resultcolumnlist */
addresultcolumn rowlocationcolumn
/**
* walk the list and mark all rcs as unreferenced.  this is useful
* when recalculating which rcs are referenced at what level like
* when deciding which columns need to be returned from a non-matching
* index scan (as opposed to those returned from the base table).
*
* @exception standardexception		thrown on error
*/
public void markallunreferenced
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
resultcolumn setunreferenced
/**
* determine if all of the rc.expressions are columns in the source result set.
* this is useful for determining if we need to do reflection
* at execution time.
*
* @param sourcers	the source resultset.
*
* @return whether or not all of the rc.expressions are columns in the source result set.
*/
boolean allexpressionsarecolumns resultsetnode sourcers
int size   size
for  int index   0  index < size  index
resultcolumn	resultcolumn
valuenode		expr
resultcolumn    resultcolumn  elementat index
expr   resultcolumn getexpression
if     expr instanceof virtualcolumnnode
expr instanceof columnreference
return false
/* if the expression is a virtualcolumnnode, make sure that the column
* is coming from the source result set, ie, that it is not a correlated
* column.
*/
if  expr instanceof virtualcolumnnode
virtualcolumnnode vcn    virtualcolumnnode  expr
if  vcn getsourceresultset      sourcers
vcn setcorrelated
return false
/* make sure this is not a correlated cr */
if  expr instanceof columnreference
columnreference cr    columnreference  expr
if  cr getcorrelated
return false
return true
/**
* map the source columns to these columns.  build an array to represent the mapping.
* for each rc, if the expression is simply a vcn or a cr then set the array element to be
* the virtual column number of the source rc.  otherwise, set the array element to
* -1.
* this is useful for determining if we need to do reflection
* at execution time.
*
* @return	array representiong mapping of rcs to source rcs.
*/
int mapsourcecolumns
int			maparray   new int
resultcolumn	resultcolumn
int size   size
for  int index   0  index < size  index
resultcolumn    resultcolumn  elementat index
if  resultcolumn getexpression   instanceof virtualcolumnnode
virtualcolumnnode vcn    virtualcolumnnode  resultcolumn getexpression
// can't deal with correlated vcns
if  vcn getcorrelated
maparray    1
else
// virtual column #s are 1-based
maparray   vcn getsourcecolumn   getvirtualcolumnid
else if  resultcolumn getexpression   instanceof columnreference
columnreference cr    columnreference  resultcolumn getexpression
// can't deal with correlated crs
if  cr getcorrelated
maparray    1
else
// virtual column #s are 1-based
maparray   cr getsource   getvirtualcolumnid
else
maparray    1
return maparray
/** set the nullability of every resultcolumn in this list */
public void setnullability boolean nullability
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
resultcolumn setnullability nullability
/**
* generate a formatablebitset representing the columns that are referenced in this rcl.
* the caller decides if they want this formatablebitset if every rc is referenced.
*
* @param positionedupdate whether or not the scan that the rcl
*						belongs to is for update w/o a column list
* @param always		whether or not caller always wants a non-null formatablebitset if
*						all rcs are referenced.
* @param onlybcns		if true, only set bit if expression is a basecolumnnode,
*						otherwise set bit for all referenced rcs.
*
* @return the formatablebitset representing the referenced rcs.
*/
formatablebitset getreferencedformatablebitset boolean positionedupdate  boolean always  boolean onlybcns
int	index
int colsadded   0
int size   size
formatablebitset newreferencedcols   new formatablebitset size
/*
** for an updatable cursor, we need
** all columns.
*/
if  positionedupdate
if  always
/* set all bits in the bit map */
for  index   0  index < size  index
newreferencedcols set index
return newreferencedcols
else
return null
for  index   0  index < size  index
resultcolumn oldcol    resultcolumn  elementat index
if  oldcol isreferenced
/* skip rcs whose expression is not a bcn
* when requested to do so.
*/
if  onlybcns       oldcol getexpression   instanceof basecolumnnode
continue
newreferencedcols set index
colsadded
/* return the formatablebitset if not all rcs are referenced or if
* the caller always wants the formatablebitset returned.
*/
if  colsadded    index    always
return newreferencedcols
else
return null
/**
* create a new, compacted rcl based on the referenced rcs
* in this list.  if the rcl being compacted is for an
* updatable scan, then we simply return this.
*
* the caller tells us whether or not they want a new list
* if there is no compaction because all rcs are referenced.
* this is useful in the case where the caller needs a new
* rcl for existing rcs so that it can augment the new list.
*
* @param positionedupdate whether or not the scan that the rcl
*						belongs to is for update w/o a column list
* @param always		whether or not caller always wants a new rcl
*
* @return the compacted rcl if compaction occurred, otherwise return this rcl.
*
* @exception standardexception		thrown on error
*/
resultcolumnlist compactcolumns boolean positionedupdate  boolean always
throws standardexception
int	index
int colsadded   0
/*
** for an updatable cursor, we need
** all columns.
*/
if  positionedupdate
return this
resultcolumnlist newcols    resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
int size   size
for  index   0  index < size  index
resultcolumn oldcol    resultcolumn  elementat index
if  oldcol isreferenced
newcols addresultcolumn oldcol
colsadded
/* return new rcl if we found unreferenced columns or if
* the caller always wants a new list.
*/
if  colsadded    index    always
return newcols
else
return this
/**
* remove the columns which are join columns (in the
* joincolumns rcl) from this list.  this is useful
* for a join with a using clause.
*
* @param joincolumns	the list of join columns
*/
void removejoincolumns resultcolumnlist joincolumns
int jcsize   joincolumns size
for  int index   0  index < jcsize  index
resultcolumn joinrc    resultcolumn  joincolumns elementat index
string columnname   joinrc getname
// columnname should always be non-null
if  sanitymanager debug
sanitymanager assert columnname    null
resultcolumn rightrc   getresultcolumn columnname
// remove the rc from this list.
if  rightrc    null
removeelement rightrc
/**
* get the join columns from this list.
* this is useful for a join with a using clause.
* (ansi specifies that the join columns appear 1st.)
*
* @param joincolumns	a list of the join columns.
*
* @return a list of the join columns from this list
*/
resultcolumnlist getjoincolumns resultcolumnlist joincolumns
resultcolumnlist	newrcl   new resultcolumnlist
/* find all of the join columns and put them 1st on the
* new rcl.
*/
int jcsize   joincolumns size
for  int index   0  index < jcsize  index
resultcolumn joinrc    resultcolumn  joincolumns elementat index
string columnname   joinrc getname
// columnname should always be non-null
if  sanitymanager debug
sanitymanager assert columnname    null
resultcolumn xferrc   getresultcolumn columnname
// add the rc to the new list.
newrcl addelement xferrc
return newrcl
/**
* reset the virtual column ids for all of the
* underlying rcs.  (virtual column ids are 1-based.)
*/
void resetvirtualcolumnids
int size   size
for  int index   0  index < size  index
/* resultcolumns are 1-based */
resultcolumn  elementat index   setvirtualcolumnid index   1
/**
* return whether or not the same result row can be used for all
* rows returned by the associated resultset.  this is possible
* if all entries in the list are constants or aggregatenodes.
*
* @return whether or not the same result row can be used for all
* rows returned by the associated resultset.
*/
boolean reusableresult
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if   rc getexpression   instanceof constantnode
rc getexpression   instanceof aggregatenode
continue
return false
return true
/**
* get an array of column positions (1-based) for all the columns
* in this rcl. assumes that all the columns are in the passed-in
* table
*
* @return the array of strings
*
*	@exception	throws standardexception on error
*/
public int getcolumnpositions  tabledescriptor td
throws standardexception
int 				size   size
int				mypositions   new int
string				columnname
columndescriptor	cd
for   int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat  index
columnname   resultcolumn getname
cd   td getcolumndescriptor  columnname
if   cd    null
throw standardexception newexception
sqlstate lang_column_not_found_in_table  columnname  td getqualifiedname
mypositions   cd getposition
return mypositions
/**
* get an array of strings for all the columns
* in this rcl.
*
* @return the array of strings
*/
public string getcolumnnames
string strings   new string
int size   size
for  int index   0  index < size  index
resultcolumn resultcolumn    resultcolumn  elementat index
strings   resultcolumn getname
return strings
/**
* replace any defaults with the associated tree for the default.
*
* @param ttd	the tabledescriptor for the target table.
* @param tcl	the rcl for the target table.
*
* @exception standardexception		thrown on error
*/
void replacedefaults tabledescriptor ttd  resultcolumnlist tcl
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc isdefaultcolumn
//				defaultnode defaultnode = (defaultnode) rc.getexpression();
// get columndescriptor by name or by position?
columndescriptor cd
if  tcl    null
cd   ttd getcolumndescriptor index   1
else
resultcolumn trc    resultcolumn  tcl elementat index
cd   ttd getcolumndescriptor trc getname
// too many rcs if no columndescriptor
if  cd    null
throw standardexception newexception sqlstate lang_too_many_result_columns
ttd getqualifiedname
if  cd isautoincrement
rc setautoincrementgenerated
end of if
defaultinfoimpl defaultinfo    defaultinfoimpl  cd getdefaultinfo
if  defaultinfo    null
/* query is dependent on the defaultdescriptor */
defaultdescriptor defaultdescriptor   cd getdefaultdescriptor getdatadictionary
getcompilercontext   createdependency defaultdescriptor
rc setexpression
defaultnode parsedefault
defaultinfo getdefaulttext
getlanguageconnectioncontext
getcompilercontext
else
rc setexpression
valuenode  getnodefactory   getnode
c_nodetypes untyped_null_constant_node
getcontextmanager
rc setdefaultcolumn false
/**
* walk the rcl and check for defaults.  defaults
* are invalid at the time that this method is called,
* so we throw an exception if found.
* note: the grammar allows:
*		values default;
*
* @exception standardexception		thrown on error
*/
void checkforinvaliddefaults
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
if  rc isautoincrementgenerated
continue
if  rc isdefaultcolumn
throw standardexception newexception sqlstate lang_invalid_use_of_default
/**
* verify that all of the rcs in this list are comparable.
*
* @exception standardexception		thrown on error
*/
void verifyallorderable
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
rc verifyorderable
/**
*	build this resultcolumnlist from a table description and
*	an array of column ids.
*
*	@param	table		describes the table
*	@param	columnids	column positions in that table (1-based)
*
* @exception standardexception		thrown on error
*/
public	void	populate
tabledescriptor	table
int			columnids
throws standardexception
if   columnids    null     return
int						count   columnids length
tablename				tablename   maketablename  table getschemaname    table getname
string					columnname
int						columnposition
resultcolumn			rc
for   int i   0  i < count  i
columnposition   columnids
columnname   table getcolumndescriptor  columnposition   getcolumnname
rc   makecolumnfromname  columnname
addresultcolumn  rc
private	resultcolumn	makecolumnfromname  string columnname
throws standardexception
resultcolumn	resultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
columnname

getcontextmanager
return resultcolumn
private	resultcolumn	makecolumnreferencefromname
tablename	tablename
string		columnname
throws standardexception
contextmanager	cm   getcontextmanager
nodefactory		nodefactory   getnodefactory
resultcolumn	rc    resultcolumn  nodefactory getnode
c_nodetypes result_column

nodefactory getnode
c_nodetypes column_reference
columnname
tablename
cm
cm
return	rc
/**
* check if any autoincrement columns exist in the result column list.
* called from insert or update where you cannot insert/update the value
* of an autoincrement column.
*
* @exception standardexception		if the column is an ai column
*/
public void checkautoincrement resultcolumnlist sourcersrcl
throws standardexception
int size   size
for  int index   0  index < size  index
resultcolumn rc    resultcolumn  elementat index
resultcolumn sourcerc
resultcolumn   sourcersrcl    null  ? null   sourcersrcl elementat index
columndescriptor cd   rc gettablecolumndescriptor
if   cd    null      cd isautoincrement
if   sourcerc    null
sourcerc isautoincrementgenerated
sourcerc setcolumndescriptor cd gettabledescriptor    cd
else
if cd isautoincalways
throw standardexception newexception sqlstate lang_ai_cannot_modify_ai
rc getname
public void incorderbyselect
orderbyselect
private void decorderbyselect
orderbyselect
public int getorderbyselect
return orderbyselect
public void copyorderbyselect  resultcolumnlist src
orderbyselect   src orderbyselect
/* ****
* take note of the size of this rcl _before_ we start
* processing/binding it.  this is so that, at bind time,
* we can tell if any columns in the rcl were added
* internally by us (i.e. they were not specified by the
* user and thus will not be returned to the user).
*/
protected void markinitialsize
initiallistsize   size
private int numgeneratedcolumns
int numgenerated   0
int sz   size
for  int i   sz   1  i >  0  i
resultcolumn rc    resultcolumn  elementat i
if  rc isgenerated
numgenerated
return numgenerated
/**
* @return the number of generated columns in this rcl.
*/
int numgeneratedcolumnsforgroupby
int numgenerated   0
int sz   size
for  int i   sz   1  i >  0  i
resultcolumn rc    resultcolumn  elementat i
if  rc isgenerated      rc isgroupingcolumn
numgenerated
return numgenerated
/**
* remove any generated columns from this rcl.
*/
void removegeneratedgroupingcolumns
int sz   size
for  int i   sz   1  i >  0  i
resultcolumn rc    resultcolumn  elementat i
if  rc isgenerated      rc isgroupingcolumn
removeelementat i
/**
* @return the number of columns that will be visible during execution.
* during compilation we can add columns for a group by/order by but these
* to an rcl but these are projected out during query execution.
*/
public int visiblesize
return size     orderbyselect   numgeneratedcolumns