/*
derby - class org.apache.derby.impl.sql.compile.concatenationoperatornode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql compile
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi types typeid
import org apache derby iapi sql compile typecompiler
import org apache derby iapi types stringdatavalue
import org apache derby iapi types datatypedescriptor
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services compiler localfield
import org apache derby impl sql compile expressionclassbuilder
import org apache derby iapi reference limits
import org apache derby iapi reference sqlstate
import org apache derby iapi reference classname
import java sql types
import java util vector
/**
* this node represents a concatenation comparison operator
*
* varying.
*/
public class concatenationoperatornode extends binaryoperatornode
/**
* initializer for a concatenationoperatornode
*
* @param leftoperand
*            the left operand of the concatenation
* @param rightoperand
*            the right operand of the concatenation
*/
public void init object leftoperand  object rightoperand
super init leftoperand  rightoperand
classname concatabledatavalue  classname concatabledatavalue
/**
* overrides bindoperatornode.bindexpression because concatenation has
* special requirements for parameter binding.
*
* @exception standardexception
*                thrown on failure
*/
public valuenode bindexpression fromlist fromlist
subquerylist subquerylist  vector aggregatevector
throws standardexception
// deal with binding operands
leftoperand   leftoperand bindexpression fromlist  subquerylist
aggregatevector
rightoperand   rightoperand bindexpression fromlist  subquerylist
aggregatevector
// deal with operand parameters
/*
* is there a ? parameter on the left? if so, it's type is the type of
* the other parameter, with maximum length for that type.
*/
if  leftoperand requirestypefromcontext
if  rightoperand requirestypefromcontext
throw standardexception newexception
sqlstate lang_binary_operands_both_parms  operator
typeid lefttype
/*
* * a ? on the left gets its type from the right. there are eight *
* legal types for the concatenation operator: char, varchar, * long
* varchar, clob, bit, bit varying, long bit varying, and blob. * if
* the right type is blob, set the parameter type to blob with max
* length. * if the right type is one of the other bit types, set
* the parameter type to * bit varying with maximum length. * * if
* the right type is clob, set parameter type to clob with max
* length. * if the right type is anything else, set it to varchar
* with * maximum length. we count on the resolveconcatoperation
* method to * catch an illegal type. * * note: when i added the
* long types, i could have changed the * resulting parameter types
* to long varchar and long bit varying, * but they were already
* varchar and bit varying, and it wasn't * clear to me what effect
* it would have to change it. - jeff
*/
if  rightoperand gettypeid   isbittypeid
if  rightoperand gettypeid   isblobtypeid
lefttype   typeid getbuiltintypeid types blob
else
lefttype   typeid getbuiltintypeid types varbinary
else
if  rightoperand gettypeid   isclobtypeid
lefttype   typeid getbuiltintypeid types clob
else
lefttype   typeid getbuiltintypeid types varchar
leftoperand settype new datatypedescriptor lefttype  true
if  rightoperand gettypeid   isstringtypeid
//collation of ? operand should be picked from the context
leftoperand gettypeservices   setcollationderivation
rightoperand gettypeservices   getcollationderivation
leftoperand gettypeservices   setcollationtype
rightoperand gettypeservices   getcollationtype
/*
* is there a ? parameter on the right?
*/
if  rightoperand requirestypefromcontext
typeid righttype
/*
* * a ? on the right gets its type from the left. there are eight *
* legal types for the concatenation operator: char, varchar, * long
* varchar, clob, bit, bit varying, long bit varying, and blob. * if
* the left type is blob, set the parameter type to blob with max
* length. * if the left type is one of the other bit types, set the
* parameter type to * bit varying with maximum length. * * if the
* left type is clob, set parameter type to clob with max length. *
* if the left type is anything else, set it to varchar with *
* maximum length. we count on the resolveconcatoperation method to *
* catch an illegal type. * * note: when i added the long types, i
* could have changed the * resulting parameter types to long
* varchar and long bit varying, * but they were already varchar and
* bit varying, and it wasn't * clear to me what effect it would
* have to change it. - jeff
*/
if  leftoperand gettypeid   isbittypeid
if  leftoperand gettypeid   isblobtypeid
righttype   typeid getbuiltintypeid types blob
else
righttype   typeid getbuiltintypeid types varbinary
else
if  leftoperand gettypeid   isclobtypeid
righttype   typeid getbuiltintypeid types clob
else
righttype   typeid getbuiltintypeid types varchar
rightoperand settype new datatypedescriptor righttype  true
if  leftoperand gettypeid   isstringtypeid
//collation of ? operand should be picked from the context
rightoperand gettypeservices   setcollationderivation
leftoperand gettypeservices   getcollationderivation
rightoperand gettypeservices   setcollationtype
leftoperand gettypeservices   getcollationtype
/*
* if the left operand is not a built-in type, then generate a bound
* conversion tree to a built-in type.
*/
if  leftoperand gettypeid   usertype
leftoperand   leftoperand gensqljavasqltree
/*
* if the right operand is not a built-in type, then generate a bound
* conversion tree to a built-in type.
*/
if  rightoperand gettypeid   usertype
rightoperand   rightoperand gensqljavasqltree
/*
* if either the left or right operands are non-string, non-bit types,
* then we generate an implicit cast to varchar.
*/
typecompiler tc   leftoperand gettypecompiler
if    leftoperand gettypeid   isstringtypeid      leftoperand
gettypeid   isbittypeid
leftoperand    valuenode  getnodefactory   getnode
c_nodetypes cast_node
leftoperand
datatypedescriptor getbuiltindatatypedescriptor
types varchar  true  tc
getcasttocharwidth leftoperand
gettypeservices
getcontextmanager
castnode  leftoperand  bindcastnodeonly
tc   rightoperand gettypecompiler
if    rightoperand gettypeid   isstringtypeid      rightoperand
gettypeid   isbittypeid
rightoperand    valuenode  getnodefactory   getnode
c_nodetypes cast_node
rightoperand
datatypedescriptor getbuiltindatatypedescriptor
types varchar  true  tc
getcasttocharwidth rightoperand
gettypeservices
getcontextmanager
castnode  rightoperand  bindcastnodeonly
/*
* * set the result type of this operator based on the operands. * by
* convention, the left operand gets to decide the result type * of a
* binary operator.
*/
tc   leftoperand gettypecompiler
settype resolveconcatoperation leftoperand gettypeservices
rightoperand gettypeservices
/*
* * make sure the maximum width set for the result doesn't exceed the
* result type's maximum width
*/
if  sanitymanager debug
if  gettypeservices   getmaximumwidth   > gettypeid
getmaximummaximumwidth
sanitymanager
throwassert
gettypeservices   getmaximumwidth
gettypeid   getsqltypename
gettypeid   getmaximummaximumwidth
/*
* * now that we know the target interface type, set it. this assumes *
* that both operands have the same interface type, which is a safe *
* assumption for the concatenation operator.
*/
this setleftrightinterfacetype tc interfacename
return this
/**
* resolve a concatenation operator
*
* @param lefttype
*            the datatypedescriptor of the left operand
* @param righttype
*            the datatypedescriptor of the right operand
*
* @return a datatypedescriptor telling the result type of the concatenate
*         operation
*
* @exception standardexception
*                binaryoperatornotsupported thrown when a binaryoperator is
*                not supported on the operand types.
*/
private datatypedescriptor resolveconcatoperation
datatypedescriptor lefttype  datatypedescriptor righttype
throws standardexception
typeid lefttypeid
typeid righttypeid
string highertype
int resultlength
boolean nullable
lefttypeid   lefttype gettypeid
righttypeid   righttype gettypeid
/*
* * check the right type to be sure it's a concatable. by convention, *
* we call this method off the typeid of the left operand, so if * we
* get here, we know the left operand is a concatable.
*/
/*
* * make sure we haven't been given a char and a * bit to concatenate.
*/
if   lefttypeid isconcatabletypeid
righttypeid isconcatabletypeid
righttypeid isbittypeid      lefttypeid isstringtypeid
lefttypeid isbittypeid      righttypeid isstringtypeid
throw standardexception newexception
sqlstate lang_db2_function_incompatible
/*
* * the types aren't the same. the result of the operation is the *
* type of higher precedence.
*/
highertype    lefttypeid typeprecedence   >  righttypeid
typeprecedence    ? lefttype gettypename     righttype
gettypename
/* get the length of the result */
resultlength   lefttype getmaximumwidth     righttype getmaximumwidth
/*
* * use following chart to handle overflow * operands char(a) char(b)
* and a+b <255 then result is char(a+b) * operands char for bit data(a)
* char for bit data(b) and a+b <255 then result is char for bit
* data(a+b) * * operands char(a) char(b) and a+b>254 then result is
* varchar(a+b) * operands char for bit data(a) char for bit data(b) and
* a+b>254 then result is varchar for bit data(a+b) * * operands char(a)
* varchar(b) and a+b <4001 then result is varchar(a+b) * operands char
* for bit data(a) varchar for bit data(b) and a+b <4001 then result is
* varchar for bit data(a+b) * * operands char(a) varchar(b) and
* a+b>4000 then result is long varchar * operands char for bit data(a)
* varchar for bit data(b) and a+b>4000 then result is long varchar for
* bit data * * operands char(a) long varchar then result is long
* varchar * operands char for bit data(a) long varchar for bit data
* then result is long varchar for bit data * * operands varchar(a)
* varchar(b) and a+b <4001 then result is varchar(a+b) * operands
* varchar for bit data(a) varchar for bit data(b) and a+b <4001 then
* result is varchar for bit data(a+b) * * operands varchar(a)
* varchar(b) and a+b>4000 then result is long varchar * operands
* varchar for bit data(a) varchar for bit data(b) and a+b>4000 then
* result is long varchar for bit data * * operands varchar(a) long
* varchar then result is long varchar * operands varchar for bit
* data(a) long varchar for bit data then result is long varchar for bit
* data * * operands long varchar, long varchar then result is long
* varchar * operands long varchar for bit data, long varchar for bit
* data then result is long varchar for bit data * * operands clob(a),
* char(b) then result is clob(min(a+b,2g)) * operands clob(a),
* varchar(b) then result is clob(min(a+b,2g)) * operands clob(a), long
* varchar then result is clob(min(a+32k,2g)) * operands clob(a),
* clob(b) then result is clob(min(a+b,2g)) * * operands blob(a), char
* for bit data(b) then result is blob(min(a+b,2g)) * operands blob(a),
* varchar for bit data(b) then result is blob(min(a+b,2g)) * operands
* blob(a), long varchar for bit data then result is blob(min(a+32k,2g)) *
* operands blob(a), blob(b) then result is blob(min(a+b,2g)) * *
* operands char(a)/varchar(a)/longvarchar, longvarchar and
* "concatenated string length">32700 does not cause automatic
* escalation * to lob for compatibility with previous releases. any
* such cases would result in an error at runtime *
*/
//in the following code, i can assume that left and right operands both
// will be either char kind
//of datatypes or they will be both binary kind of datatypes. that's
// because operand datatypes
//mismatch has already been handled earlier
if  lefttypeid getjdbctypeid      types char
lefttypeid getjdbctypeid      types binary
switch  righttypeid getjdbctypeid
case types char
case types binary
if  resultlength > limits db2_char_maxwidth
if  righttypeid getjdbctypeid      types char
//operands char(a) char(b) and a+b>254 then result is
// varchar(a+b)
highertype   typeid varchar_name
else
//operands char for bit data(a) char for bit data(b)
// and a+b>254 then result is varchar for bit data(a+b)
highertype   typeid varbit_name
break
case types varchar
case types varbinary
if  resultlength > limits db2_concat_varchar_length
if  righttypeid getjdbctypeid      types varchar
//operands char(a) varchar(b) and a+b>4000 then result
// is long varchar
highertype   typeid longvarchar_name
else
//operands char for bit data(a) varchar for bit data(b)
// and a+b>4000 then result is long varchar for bit data
highertype   typeid longvarbit_name
break
case types clob
case types blob
//operands char(a), clob(b) then result is clob(min(a+b,2g))
//operands char for bit data(a), blob(b) then result is
// blob(min(a+b,2g))
resultlength   clobblobhandling righttype  lefttype
break
else if  lefttypeid getjdbctypeid      types varchar
switch  righttypeid getjdbctypeid
case types char    operands char a  varchar b  and a b>4000 then
// result is long varchar
case types varchar    operands varchar a  varchar b  and a b>4000
// then result is long varchar
if  resultlength > limits db2_concat_varchar_length
highertype   typeid longvarchar_name
break
case types clob
//operands varchar(a), clob(b) then result is clob(min(a+b,2g))
resultlength   clobblobhandling righttype  lefttype
break
else if  lefttypeid getjdbctypeid      types varbinary
switch  righttypeid getjdbctypeid
case types binary    operands char for bit data a  varchar for bit
// data(b) and a+b>4000 then result is long
// varchar for bit data
case types varbinary   operands varchar for bit data a  varchar for
// bit data(b) and a+b>4000 then result is long
// varchar for bit data
if  resultlength > limits db2_concat_varchar_length
highertype   typeid longvarbit_name
break
case types blob
//operands varchar for bit data(a), blob(b) then result is
// blob(min(a+b,2g))
resultlength   clobblobhandling righttype  lefttype
break
else if  lefttypeid getjdbctypeid      types clob
lefttypeid getjdbctypeid      types blob
//operands clob(a), char(b) then result is clob(min(a+b,2g))
//operands clob(a), varchar(b) then result is clob(min(a+b,2g))
//operands clob(a), long varchar then result is clob(min(a+32k,2g))
//operands clob(a), clob(b) then result is clob(min(a+b,2g))
//operands blob(a), char for bit data(b) then result is
// blob(min(a+b,2g))
//operands blob(a), varchar for bit data(b) then result is
// blob(min(a+b,2g))
//operands blob(a), long varchar for bit data then result is
// blob(min(a+32k,2g))
//operands blob(a), blob(b) then result is blob(min(a+b,2g))
resultlength   clobblobhandling lefttype  righttype
else if  righttypeid getjdbctypeid      types clob
righttypeid getjdbctypeid      types blob
//operands long varchar, clob(a) then result is clob(min(a+32k,2g))
//operands long varchar for bit data, blob(a) then result is
// blob(min(a+32k,2g))
resultlength   clobblobhandling righttype  lefttype
//bug - 5837. long varchar and long binary can't hold more data than
// their specific limits. if this length is violated by resulting
//concatenated string, an exception will be thrown at execute time.
if  highertype equals typeid longvarchar_name
resultlength   typeid longvarchar_maxwidth
else if  highertype equals typeid longvarbit_name
resultlength   typeid longvarbit_maxwidth
/*
* * result length can't be negative
*/
if  sanitymanager debug
if  resultlength < 0
sanitymanager
throwassert
/* the result is nullable if either side is nullable */
nullable   lefttype isnullable      righttype isnullable
/*
* * create a new datatypedescriptor that has the correct * type and
* nullability. * * it's ok to call the implementation of the
* datatypedescriptorfactory * here, because we're in the same package.
*/
datatypedescriptor returndtd   new datatypedescriptor typeid
getbuiltintypeid highertype   nullable  resultlength
//check if collation derivations and collation types of 2 operands
//match?
//if they do, then the result of the concatenation will get the smae
//collation information. but if not, then the collation derivation of
//the result will be none.
if  lefttype getcollationderivation      righttype
getcollationderivation
lefttype getcollationtype      righttype getcollationtype
returndtd
setcollationderivation stringdatavalue collation_derivation_none
else
returndtd setcollationderivation lefttype getcollationderivation
returndtd setcollationtype lefttype getcollationtype
return returndtd
/*
* for conatenation operator, we generate code as follows field = method(p1,
* p2, field); what we are ensuring here is if field is null then initialize
* it to null sqlxxx type. because of the following, at execution time,
* sqlxxx concatenate method do not have to worry about field coming in as
* null
*/
protected void initializeresultfield expressionclassbuilder acb
methodbuilder mb  localfield resultfield  throws standardexception
mb conditionalifnull     get the field on the stack and if it is null
acb generatenull mb  gettypecompiler    gettypeservices
getcollationtype       yes  it is  hence create a null sqlxxx
// type object and put that on stack
mb startelsecode      no  it is not null
mb getfield resultfield     so put it back on the stack
mb completeconditional      complete if else block
private static int clobblobhandling datatypedescriptor clobblobtype
datatypedescriptor othertype  throws standardexception
int resultlength
if  othertype gettypeid   getjdbctypeid      types longvarchar
othertype gettypeid   getjdbctypeid      types longvarbinary
//operands clob(a), long varchar then result is clob(min(a+32k,2g))
//operands blob(a), long varchar for bit data then result is
// blob(min(a+32k,2g))
resultlength   clobblobtype getmaximumwidth     32768
else
//operands clob(a), char(b) then result is clob(min(a+b,2g))
//operands clob(a), varchar(b) then result is clob(min(a+b,2g))
//operands clob(a), clob(b) then result is clob(min(a+b,2g))
//operands blob(a), char for bit data(b) then result is
// blob(min(a+b,2g))
//operands blob(a), varchar for bit data(b) then result is
// blob(min(a+b,2g))
//operands blob(a), blob(b) then result is blob(min(a+b,2g))
resultlength   clobblobtype getmaximumwidth
othertype getmaximumwidth
if  resultlength < 1    this mean a b or a 32k is bigger than 2g
return  integer max_value
else
return  resultlength