/*
derby - class org.apache.derby.impl.jdbc.lobstreamcontrol
licensed to the apache software foundation (asf) under one
or more contributor license agreements.  see the notice file
distributed with this work for additional information
regarding copyright ownership.  the asf licenses this file
to you under the apache license, version 2.0 (the
"license"); you may not use this file except in compliance
with the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing,
software distributed under the license is distributed on an
"as is" basis, without warranties or conditions of any
kind, either express or implied.  see the license for the
specific language governing permissions and limitations
under the license.
*/
package org apache derby impl jdbc
import java io eofexception
import java io file
import java io ioexception
import java io inputstream
import java io outputstream
import java io randomaccessfile
import java security accesscontrolexception
import java security accesscontroller
import java security privilegedaction
import java security privilegedactionexception
import java security privilegedexceptionaction
import java sql sqlexception
import org apache derby iapi error standardexception
import org apache derby iapi reference property
import org apache derby iapi reference sqlstate
import org apache derby iapi services monitor monitor
import org apache derby iapi store raw data datafactory
import org apache derby io storagefile
import org apache derby io storagerandomaccessfile
import org apache derby shared common error exceptionutil
/**
* this class acts as a layer of blob/clob repository (in memory or file).
* the max bytes of data stored in memory depends on the way this
* class is created. if the class is created with initial data, the buffer
* size is set to the size of the byte array supplied. if no initial data
* is supplied or if the initial data size is less than default_max_buf_size,
* the buffer size is set to default_max_buf_size.
* when write increases the data beyond this value a temporary file is created
* and data is moved into that. if truncate reduces the size of the file below
* initial buffer size (max of default_max_buf_size and initial byte array size)
* the data moved into memory.
*
* this class also creates inputstream and outputstream which can be used to access
* blob data irrespective of if its in memory or in file.
*/
class lobstreamcontrol
private lobfile tmpfile
private storagefile lobfile
private byte  databytes   new byte
private boolean isbytes   true
private final int buffersize
private string dbname
private long updatecount
private static final int default_max_buf_size   4096
/**
* creates an empty lobstreamcontrol.
* @param dbname database name
*/
lobstreamcontrol  string dbname
this dbname   dbname
updatecount   0
//default buffer size
buffersize   default_max_buf_size
/**
* creates a lobstreamcontrol and initializes with a bytes array.
* @param dbname database name
* @param data initial value
*/
lobstreamcontrol  string dbname  byte  data
throws ioexception  sqlexception  standardexception
this dbname   dbname
updatecount   0
buffersize   math max  default_max_buf_size  data length
write  data  0  data length  0
private void init byte  b  long len
throws ioexception  sqlexception  standardexception
try
accesscontroller doprivileged  new privilegedexceptionaction
public object run   throws ioexception  standardexception
object monitor   monitor findservice
property database_module  dbname
datafactory df     datafactory  monitor findservicemodule
monitor  datafactory module
//create a temporary file
lobfile
df getstoragefactory   createtemporaryfile    null
if  df databaseencrypted
tmpfile   new encryptedlobfile  lobfile  df
else
tmpfile   new lobfile  lobfile
return null
catch  privilegedactionexception pae
exception e   pae getexception
if  e instanceof standardexception
throw util generatecssqlexception   standardexception  e
if  e instanceof ioexception
throw  ioexception  e
if  e instanceof runtimeexception
throw  runtimeexception  e
ioexception ioe   new ioexception  e getmessage
ioe initcause  e
throw ioe
isbytes   false
//now this call will write into the file
if  len    0
write b  0   int  len  0
databytes   null
private long updatedata byte bytes  int offset  int len  long pos
throws sqlexception
if  databytes    null
if   int  pos    0
databytes   new byte
system arraycopy bytes  offset  databytes   int  pos  len
return len
else
//invalid postion
throw util generatecssqlexception
sqlstate blob_position_too_large  new long pos
else
if  pos > databytes length
//invalid postion
throw util generatecssqlexception
sqlstate blob_position_too_large  new long pos
else
if  pos   len < databytes length
system arraycopy bytes  offset  databytes   int  pos  len
else
byte  tmpbytes   new byte
system arraycopy databytes  0   tmpbytes  0   int  pos
system arraycopy bytes  offset  tmpbytes   int  pos  len
databytes   tmpbytes
return pos   len
private void isvalidpostion long pos
throws sqlexception  ioexception
if  pos < 0
throw util generatecssqlexception
sqlstate blob_nonpositive_length  new long pos   1
if  pos > integer max_value
throw util generatecssqlexception
sqlstate blob_position_too_large  new long pos   1
if  isbytes
if  databytes    null
if  pos    0
throw util generatecssqlexception
sqlstate blob_position_too_large  new long pos   1
else if  databytes length < pos
throw util generatecssqlexception
sqlstate blob_position_too_large  new long pos   1
else
if  pos > tmpfile length
throw util generatecssqlexception
sqlstate blob_position_too_large  new long pos   1
private void isvalidoffset int off  int length  throws sqlexception
if  off < 0    off > length
throw util generatecssqlexception
sqlstate blob_invalid_offset  new integer off
/**
* writes one byte.
* @param b byte
* @param pos
* @return new postion
* @throws ioexception, sqlexception, standardexception
*/
synchronized long write int b  long pos
throws ioexception  sqlexception  standardexception
isvalidpostion pos
updatecount
if  isbytes
if  pos < buffersize
byte  bytes     byte  b
updatedata bytes  0  1  pos
return pos   1
else
init databytes  pos
tmpfile seek pos
tmpfile write b
return tmpfile getfilepointer
/**
* writes part of the byte array.
* @param b byte array
* @param off offset from where to read from the byte array
* @param len number of bytes to be copied
* @param pos starting postion
* @return new postion
* @throws ioexception, sqlexception, standardexception
*/
synchronized long write byte b  int off  int len  long pos
throws ioexception  sqlexception  standardexception
try
isvalidpostion pos
isvalidoffset off  b length
catch  sqlexception e
if  e getsqlstate   equals
exceptionutil getsqlstatefromidentifier
sqlstate blob_invalid_offset
throw new arrayindexoutofboundsexception  e getmessage
throw e
updatecount
if  isbytes
if  pos   len <  buffersize
return updatedata b  off  len  pos
else
init databytes  pos
tmpfile seek pos
tmpfile write b  off  len
return tmpfile getfilepointer
/**
* reads one byte.
* @param pos postion from where to read
* @return byte
* @throws ioexception, sqlexception, standardexception
*/
synchronized int read long pos
throws ioexception  sqlexception  standardexception
isvalidpostion pos
if  isbytes
if  databytes length    pos
return  1
return databytes    0xff
if  tmpfile getfilepointer      pos
tmpfile seek pos
try
return tmpfile readbyte     0xff
catch  eofexception eof
return  1
private int readbytes byte  b  int off  int len  long pos
if  pos >  databytes length
return  1
int lengthfrompos   databytes length    int  pos
int actuallength   len > lengthfrompos ? lengthfrompos   len
byte  result   new byte
system arraycopy databytes   int  pos  b  off  actuallength
return actuallength
/**
* reads bytes starting from 'position' into bytes array.
* starting from 'offset'
* @param buff array into the bytes will be copied
* @param off offset from where the array has to be populated
* @param len number of bytes to read
* @param pos initial postion before reading
* @return number new postion
* @throws ioexception, sqlexception, standardexception
*/
synchronized int read byte buff  int off  int len  long pos
throws ioexception  sqlexception  standardexception
isvalidpostion pos
isvalidoffset off  buff length
if  isbytes
return readbytes buff  off  len  pos
tmpfile seek pos
return tmpfile read  buff  off  len
/**
* returns input stream linked with this object.
* @param pos initial postion
* @return inputstream
*/
inputstream getinputstream long pos
return new lobinputstream this  pos
/**
* returns output stream linked with this object
* @param pos initial postion
* @return outputstream
*/
outputstream getoutputstream long pos
return new loboutputstream this  pos
/**
* returns length of data.
* @return length
* @throws ioexception
*/
long getlength   throws ioexception
if  isbytes
return databytes length
return tmpfile length
/**
* resets the size.
* @param size new size should be smaller than exisiting size
* @throws ioexception, sqlexception
*/
synchronized void truncate long size
throws ioexception  sqlexception  standardexception
isvalidpostion size
if  isbytes
byte  tmpbyte   new byte
system arraycopy databytes  0  tmpbyte  0   int  size
databytes   tmpbyte
else
if  size < buffersize
databytes   new byte
read databytes  0  databytes length  0
isbytes   true
tmpfile close
tmpfile   null
else
try
tmpfile setlength size
catch  standardexception se
util generatecssqlexception  se
/**
* copies bytes from stream to local storage.
* @param instream
* @param length length to be copied
* @throws ioexception, sqlexception, standardexception
*/
synchronized void copydata inputstream instream
long length  throws ioexception  sqlexception  standardexception
byte  data   new byte
long sz   0
while  sz < length
int len    int  math min  length   sz  buffersize
len   instream read data  0  len
if  len < 0
throw new eofexception
sz
write data  0  len  sz
sz    len
protected void finalize   throws throwable
free
private void deletefile  storagefile file  throws ioexception
try
final storagefile sf   file
accesscontroller doprivileged new privilegedexceptionaction
public object run   throws ioexception
sf delete
return null
catch  privilegedactionexception pae
exception e   pae getexception
if  e instanceof ioexception
throw  ioexception  e
if  e instanceof runtimeexception
throw  runtimeexception  e
ioexception ioe   new ioexception e getmessage
ioe initcause e
throw ioe
/**
* invalidates all the variables and closes file handle if open.
* @throws ioexception
*/
void free   throws ioexception
databytes   null
if  tmpfile    null
tmpfile close
deletefile lobfile
tmpfile   null
/**
* replaces a block of bytes in the middle of the lob with a another block
* of bytes, which may be of a different size.
* <p>
* the new byte array may not be be of same length as the original,
* thus it may result in resizing the total lob.
*
* @param buf byte array which will be written inplace of old block
* @param stpos inclusive starting position of current block
* @param endpos exclusive end position of current block
* @return current position after write.
* @throws ioexcepton if writing to temporary file fails
* @throws standardexception
* @throws sqlexception
*/
synchronized long replacebytes  byte  buf  long stpos  long endpos
throws ioexception  sqlexception  standardexception
long length   getlength
long finallength   length   endpos   stpos   buf length
if  isbytes
if  finallength > buffersize
byte  tmpbytes   databytes
init  tmpbytes  stpos
write  buf  0  buf length  getlength
if  endpos < length
write  tmpbytes   int  endpos
int   length   endpos   getlength
else
byte  tmpbyte   new byte
system arraycopy  databytes  0  tmpbyte  0   int  stpos
system arraycopy  buf  0  tmpbyte   int  stpos   int  buf length
if  endpos < length
system arraycopy  databytes   int  endpos  tmpbyte
int   stpos   buf length    int   length   endpos
databytes   tmpbyte
else
//save over file handle and
//create new file with 0 size
byte tmp    new byte
lobfile oldfile   tmpfile
storagefile oldstorefile   lobfile
init  tmp  0
byte  tmpbyte   new byte
long sz   stpos
oldfile seek 0
while  sz    0
int readlen    int  math min  1024  sz
int actuallength   oldfile read  tmpbyte  0  readlen
if  actuallength     1
break
tmpfile write  tmpbyte  0  actuallength
sz    actuallength
tmpfile write  buf
oldfile seek  endpos
int rdlen
if  endpos < length
do
rdlen   oldfile read  tmpbyte  0  1024
if  rdlen     1
break
tmpfile write  tmpbyte  0  rdlen
while  true
oldfile close
deletefile oldstorefile
updatecount
return stpos   buf length
/**
* returns the running secquence number to check if the lob is updated since
* last access.
*
* @return the current update sequence number.
*/
long getupdatecount
return updatecount