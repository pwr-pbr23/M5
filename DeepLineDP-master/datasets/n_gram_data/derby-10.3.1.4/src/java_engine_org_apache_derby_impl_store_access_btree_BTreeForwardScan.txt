/*
derby - class org.apache.derby.impl.store.access.btree.btreeforwardscan
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access scancontroller
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi store access backingstorehashtable
/**
a b-tree scan controller corresponds to an instance of an open b-tree scan.
<p>
<b>concurrency notes<\b>
<p>
the concurrency rules are derived from openbtree.
<p>
@see openbtree
**/
public class btreeforwardscan extends btreescan
/*
** private/protected methods of this class, sorted alphabetically
*/
/**
position scan at "start" position.
<p>
positions the scan to the slot just before the first record to be returned
from the scan.  returns the start page latched, and sets "current_slot" to
the slot number.
@exception  standardexception  standard exception policy.
**/
protected void positionatstartposition
btreerowposition    pos
throws standardexception
positionatstartforforwardscan pos
/**
* fetch the next n rows from the table.
* <p>
* utility routine used by both fetchset() and fetchnextgroup().
*
* @exception  standardexception  standard exception policy.
**/
protected int fetchrows
btreerowposition        pos
datavaluedescriptor row_array
rowlocation           rowloc_array
backingstorehashtable   hash_table
long                    max_rowcnt
int                   key_column_numbers
throws standardexception
int                     ret_row_count       0
datavaluedescriptor   fetch_row           null
recordhandle            rh
if  max_rowcnt     1
max_rowcnt   long max_value
if  this scan_state    btreescan scan_inprogress
// reposition the scan at the row just before the next one to
// return.
// this routine handles the mess of repositioning if the row or
// the page has disappeared. this can happen if a lock was not
// held on the row while not holding the latch (can happen if
// this scan is read uncommitted).
//
// code path tested by readuncommitted.sql:test 1
//
if   reposition pos  true
if  sanitymanager debug
sanitymanager throwassert
else if  this scan_state    scan_init
// 1st positioning of scan (delayed from openscan).
positionatstartposition pos
else if  this scan_state    scan_hold_inprogress
reopen
this scan_state   scan_inprogress
if  sanitymanager debug
sanitymanager assert scan_position current_positionkey    null
// reposition the scan at the row just before the next one to
// return.
// this routine handles the mess of repositioning if the row or
// the page has disappeared. this can happen if a lock was not
// held on the row while not holding the latch.
//
// code path tested by holdcursor.sql: test 9
if   reposition pos  true
if  sanitymanager debug
sanitymanager throwassert
else if  this scan_state    scan_hold_init
reopen
positionatstartforforwardscan scan_position
else
if  sanitymanager debug
sanitymanager assert this scan_state    scan_done
return 0
if  sanitymanager debug
sanitymanager assert
init_template    null
if  sanitymanager debug
sanitymanager assert this container    null
if  row_array    null
sanitymanager assert row_array    null
// btree's don't support rowlocations yet.
if  rowloc_array    null
throw standardexception newexception
sqlstate btree_unimplemented_feature
// system.out.println("top of fetchrows, fetch_row = " + fetch_row);
// at this point:
// current_page is latched.  current_slot is the slot on current_page
// just before the "next" record this routine should process.
// loop through successive leaf pages and successive slots on those
// leaf pages.  stop when either the last leaf is reached (current_page
// will be null), or when stopkeyvalue is reached/passed.  along the
// way apply qualifiers to skip rows which don't qualify.
while  pos current_leaf    null
// system.out.println(
//   "1 of fetchset loop, ret_row_count = " + ret_row_count +
// "fetch_row = " + fetch_row);
while   pos current_slot   1  < pos current_leaf page recordcount
// system.out.println(
// "2 of fetchset loop, ret_row_count = " + ret_row_count +
// "fetch_row = " + fetch_row +
// "hash_table = " + hash_table);
// unlock the previous row if doing read.
if  pos current_rh    null
this getlockingpolicy   unlockscanrecordafterread
pos  init_forupdate
// current_rh is used to track which row we need to unlock,
// at this point no row needs to be unlocked.
pos current_rh   null
// allocate a new row to read the row into.
if  fetch_row    null
if  hash_table    null
// point at allocated row in array if one exists.
if  row_array    null
row_array
runtime_mem get_row_for_export getrawtran
fetch_row   row_array
else
// get a brand new row.
fetch_row
runtime_mem get_row_for_export getrawtran
// move scan current position forward.
pos current_slot
this stat_numrows_visited
rh
pos current_leaf page fetchfromslot
recordhandle  null
pos current_slot  fetch_row
init_fetchdesc
true
pos current_rh_qualified   true
// see if this is the stop row.
if  init_stopkeyvalue    null
// see if current row is the >= the stopkeyvalue.
//
// ret >  0: key is greater than row on page.
// ret == 0: key is exactly the row on page if full key,
//           or partial match if partial key.
// ret <  0: key is less    than row on page.
//
int ret   controlrow compareindexrowtokey
fetch_row
init_stopkeyvalue
fetch_row length
0  this getconglomerate   ascdescinfo
if   ret    0
init_stopsearchoperator    scancontroller ge
// if (partial) matched and stop is ge, end the scan.
ret   1
if  ret > 0
// this is the first non-qualifying row. we're done.
pos current_leaf release
pos current_leaf   null
positionatdonescan pos
return ret_row_count
// only lock rows that are < the stopkeyvalue.  no need to
// requalify against stop position after losing the latch
// as the only change that could have happened is that the
// row was marked deleted - the key value cannot change.
boolean latch_released
this getlockingpolicy   lockscanrow
this  this getconglomerate    pos
false
init_lock_fetch_desc
pos current_lock_template
pos current_lock_row_loc
false  init_forupdate  lock_operation
// special test to see if latch release code works
if  sanitymanager debug
latch_released
test_errors
this
false
this getlockingpolicy
pos current_leaf  latch_released
// at this point we have successfully locked this record, so
// remember the record handle so that it can be unlocked if
// necessary.  if the above lock deadlocks, we will not try
// to unlock a lock we never got in close(), because current_rh
// is null until after the lock is granted.
pos current_rh   rh
if  latch_released
// lost latch on page in order to wait for row lock.
// because we have scan lock on page, we need only
// call reposition() which will use the saved record
// handle to reposition to the same spot on the page.
// we don't have to search the
// tree again, as we have the a scan lock on the page
// which means the current_rh is valid to reposition on.
if  this getconglomerate   isunique
// handle row location changing since lock request was
// initiated.
// in unique indexes, there is one case where an index
// row can have it's data lock key change (this usually
// cannot happen because only inserts and deletes are
// allowed - no updates).  this case is an insert of a
// key, that exactly matches a committed deleted row,
// in a unique index.  in that case the code updates
// the rowlocation column and flips the deleted bit to
// mark the row valid.  the problem is that if this
// happens while we are waiting on a lock on the old
// rowlocation then when we wake up we have the wrong
// lock, and the row location we fetched earlier in
// this loop is invalid.
while  latch_released
if   reposition pos  false
if  sanitymanager debug
// can't fail while with scan lock
sanitymanager throwassert
// reposition will set pos.current_leaf to
// null, if it returns false so if the this
// ever does fail in delivered code, expect
// a null pointer exception on the next line,
// trying to call fetchfromslot().
pos current_leaf page fetchfromslot
recordhandle  null
pos current_slot  fetch_row
init_fetchdesc
true
latch_released
this getlockingpolicy   lockscanrow
this
this getconglomerate
pos
false
init_lock_fetch_desc
pos current_lock_template
pos current_lock_row_loc
false  init_forupdate  lock_operation
else
if   reposition pos  false
if  sanitymanager debug
// can't fail while with scan lock
sanitymanager throwassert
// reposition will set pos.current_leaf to
// null, if it returns false so if the this
// ever does fail in delivered code, expect
// a null pointer exception on the next line,
// trying to call isdeletedatslot().
if  pos current_leaf page isdeletedatslot pos current_slot
this stat_numdeleted_rows_visited
pos current_rh_qualified   false
else if  init_qualifier    null
// apply qualifiers if there are any.
pos current_rh_qualified
this process_qualifier fetch_row
if  pos current_rh_qualified
// qualifying row.  save position, release latch and return.
// this.current_rh is save position of scan while latch is
// not held.  it currently points at the current_slot in
// search (while latch is held).
if  sanitymanager debug
sanitymanager assert
pos current_leaf page getslotnumber pos current_rh
pos current_slot
// found qualifying row.  are we done fetching rows for the
// group?
ret_row_count
stat_numrows_qualified
if  hash_table    null
if  hash_table putrow false  fetch_row
fetch_row   null
else
fetch_row   null
if  max_rowcnt <  ret_row_count
// current_slot is invalid after releasing latch
pos current_slot   page invalid_slot_number
// exit fetch row loop and return to the client.
pos current_leaf release
pos current_leaf   null
return ret_row_count
// move position of the scan to slot 0 of the next page.  if there
// is no next page current_page will be null.
positionatnextpage pos
this stat_numpages_visited
// reached last leaf of tree.
positionatdonescan pos
// we need to decrement when we stop scan at the end of the table.
this stat_numpages_visited
return ret_row_count