/*
derby - class org.apache.derby.impl.sql.compile.altertablenode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi reference sqlstate
import org apache derby iapi reference limits
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql execute constantaction
import org apache derby iapi types stringdatavalue
import org apache derby impl sql execute columninfo
import org apache derby impl sql execute constraintconstantaction
/**
* a altertablenode represents a ddl statement that alters a table.
* it contains the name of the object to be created.
*
*/
public class altertablenode extends ddlstatementnode
// the alter table action
public	tableelementlist	tableelementlist   null
public  char				lockgranularity
public	boolean				compresstable   false
public	boolean				sequential   false
public	int					behavior 	   currently for drop column
public	tabledescriptor		basetable
protected	int						numconstraints
private		int				changetype   unknown_type
private boolean             truncatetable   false
// constant action arguments
protected	schemadescriptor			schemadescriptor   null
protected	columninfo 				colinfos   null
protected	constraintconstantaction	conactions   null
/**
* initializer for a truncate table
*
* @param objectname		the name of the table being truncated
* @exception standardexception		thrown on error
*/
public void init object objectname
throws standardexception
//truncate table is not suppotted in this release
//semantics are not yet clearly defined by sql council yet
//truncate will be allowed only in debug builds for testing purposes.
if  sanitymanager debug
initandcheck objectname
/* for now, this init() only called for truncate table */
truncatetable   true
schemadescriptor   getschemadescriptor
else
throw standardexception newexception sqlstate not_implemented
/**
* initializer for a altertablenode for compress
*
* @param objectname		the name of the table being altered
* @param sequential		whether or not the compress is sequential
*
* @exception standardexception		thrown on error
*/
public void init object objectname
object sequential
throws standardexception
initandcheck objectname
this sequential     boolean  sequential  booleanvalue
/* for now, this init() only called for compress table */
compresstable   true
schemadescriptor   getschemadescriptor
/**
* initializer for a altertablenode
*
* @param objectname		the name of the table being altered
* @param tableelementlist	the alter table action
* @param lockgranularity	the new lock granularity, if any
* @param changetype		add_type or drop_type
*
* @exception standardexception		thrown on error
*/
public void init
object objectname
object tableelementlist
object lockgranularity
object changetype
object behavior
object sequential
throws standardexception
initandcheck objectname
this tableelementlist    tableelementlist  tableelementlist
this lockgranularity     character  lockgranularity  charvalue
int	ct    int  changetype  bh    int  behavior
this changetype   ct
this behavior   bh
boolean	seq    boolean  sequential
this sequential   seq
switch   this changetype
case add_type
case drop_type
case modify_type
case locking_type
break
default
throw standardexception newexception sqlstate not_implemented
schemadescriptor   getschemadescriptor
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return super tostring
getobjectname
tableelementlist
lockgranularity
compresstable
sequential
truncatetable
else
return
public string statementtostring
if truncatetable
return
else
return
public	int	getchangetype     return changetype
// we inherit the generate() method from ddlstatementnode.
/**
* bind this altertablenode.  this means doing any static error
* checking that can be done before actually creating the table.
* for example, verifying that the user is not trying to add a
* non-nullable column.
*
*
* @exception standardexception		thrown on error
*/
public void bindstatement   throws standardexception
datadictionary	dd   getdatadictionary
int					numcheckconstraints   0
int numbackingindexes   0
/*
** get the table descriptor.  checks the schema
** and the table.
*/
basetable   gettabledescriptor
//throw an exception if user is attempting to alter a temporary table
if  basetable gettabletype      tabledescriptor global_temporary_table_type
throw standardexception newexception sqlstate lang_not_allowed_for_declared_global_temp_table
/* statement is dependent on the tabledescriptor */
getcompilercontext   createdependency basetable
//if we are dealing with add column character type, then set that
//column's collation type to be the collation type of the schema.
//the collation derivation of such a column would be "implicit".
if  changetype    add_type     the action is of type add
if  tableelementlist    null     check if is is add column
for  int i 0  i<tableelementlist size   i
if  tableelementlist elementat i  instanceof columndefinitionnode
columndefinitionnode cdn    columndefinitionnode  tableelementlist elementat i
//check if we are dealing with add character column
if  cdn getdatatypeservices   gettypeid   isstringtypeid
//we found what we are looking for. set the
//collation type of this column to be the same as
//schema descriptor's collation. set the collation
//derivation as implicit
cdn getdatatypeservices   setcollationtype schemadescriptor getcollationtype
cdn getdatatypeservices   setcollationderivation stringdatavalue collation_derivation_implicit
if  tableelementlist    null
tableelementlist validate this  dd  basetable
/* only 1012 columns allowed per table */
if   tableelementlist countnumberofcolumns     basetable getnumberofcolumns    > limits db2_max_columns_in_table
throw standardexception newexception sqlstate lang_too_many_columns_in_table_or_view
string valueof tableelementlist countnumberofcolumns     basetable getnumberofcolumns
getrelativename
string valueof limits db2_max_columns_in_table
/* number of backing indexes in the alter table statment */
numbackingindexes   tableelementlist countconstraints datadictionary primarykey_constraint
tableelementlist countconstraints datadictionary foreignkey_constraint
tableelementlist countconstraints datadictionary unique_constraint
/* check the validity of all check constraints */
numcheckconstraints   tableelementlist countconstraints
datadictionary check_constraint
//if the sum of backing indexes for constraints in alter table statement and total number of indexes on the table
//so far is more than 32767, then we need to throw an exception
if   numbackingindexes   basetable gettotalnumberofindexes    > limits db2_max_indexes_on_table
throw standardexception newexception sqlstate lang_too_many_indexes_on_table
string valueof numbackingindexes   basetable gettotalnumberofindexes
getrelativename
string valueof limits db2_max_indexes_on_table
if  numcheckconstraints > 0
/* in order to check the validity of the check constraints
* we must goober up a fromlist containing a single table,
* the table being alter, with an rcl containing the existing and
* new columns and their types.  this will allow us to
* bind the constraint definition trees against that
* fromlist.  when doing this, we verify that there are
* no nodes which can return non-deterministic results.
*/
fromlist fromlist    fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
frombasetable table    frombasetable
getnodefactory   getnode
c_nodetypes from_base_table
getobjectname



getcontextmanager
fromlist addfromtable table
fromlist bindtables dd
fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
tableelementlist appendnewcolumnstorcl table
/* now that we've finally goobered stuff up, bind and validate
* the check constraints.
*/
tableelementlist bindandvalidatecheckconstraints fromlist
/* unlike most other ddl, we will make this alter table statement
* dependent on the table being altered.  in general, we try to
* avoid this for ddl, but we are already requiring the table to
* exist at bind time (not required for create index) and we don't
* want the column ids to change out from under us before
* execution.
*/
getcompilercontext   createdependency basetable
/**
* return true if the node references session schema tables (temporary or permanent)
*
* @return	true if references session schema tables, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencessessionschema
throws standardexception
//if alter table is on a session schema table, then return true.
return issessionschema basetable getschemaname
/**
* create the constant information that will drive the guts of execution.
*
* @exception standardexception		thrown on failure
*/
public constantaction	makeconstantaction   throws standardexception
prepconstantaction
return	getgenericconstantactionfactory   getaltertableconstantaction schemadescriptor
getrelativename
basetable getuuid
basetable getheapconglomerateid
tabledescriptor base_table_type
colinfos
conactions
lockgranularity
compresstable
behavior
sequential
truncatetable
/**
*	generate arguments to constant action. called by makeconstantaction() in this class and in
*	our subclass repaltertablenode.
*
*
* @exception standardexception		thrown on failure
*/
public void	prepconstantaction   throws standardexception
if  tableelementlist    null
gencolumninfo
/* if we've seen a constraint, then build a constraint list */
if  numconstraints > 0
conactions   new constraintconstantaction
tableelementlist genconstraintactions conactions  getrelativename    schemadescriptor
getdatadictionary
/**
*	generate the columninfo argument for the constant action. return the number of constraints.
*/
public	void	gencolumninfo
// for each column, stuff system.column
colinfos   new columninfo
numconstraints   tableelementlist gencolumninfos colinfos
/*
* class interface
*/