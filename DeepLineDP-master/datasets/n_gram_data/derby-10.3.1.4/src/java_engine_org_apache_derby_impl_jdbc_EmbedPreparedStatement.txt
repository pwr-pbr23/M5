/*
derby - class org.apache.derby.impl.jdbc.embedpreparedstatement
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl jdbc
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi types variablesizedatavalue
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql preparedstatement
import org apache derby iapi sql execute execpreparedstatement
import org apache derby iapi sql resultset
import org apache derby iapi sql activation
import org apache derby iapi sql parametervalueset
import org apache derby iapi sql resultdescription
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rawtobinaryformatstream
import org apache derby iapi types readertoutf8stream
import org apache derby iapi error standardexception
import org apache derby iapi services io limitreader
import org apache derby iapi reference sqlstate
import org apache derby iapi reference jdbc40translation
import org apache derby iapi reference jdbc30translation
import org apache derby iapi reference jdbc20translation
import java util calendar
import java util vector
/*
we would import these, but have name-overlap
import java.sql.preparedstatement;
import java.sql.resultset;
*/
import java sql resultsetmetadata
import java sql sqlexception
import java sql date
import java sql time
import java sql timestamp
import java sql clob
import java sql blob
import java io inputstream
import java io datainputstream
import java io ioexception
import java io eofexception
import java io reader
import java sql types
import org apache derby iapi jdbc brokeredconnectioncontrol
import org apache derby iapi jdbc engineparametermetadata
import org apache derby iapi jdbc enginepreparedstatement
/**
*
* embedpreparedstatement is a local jdbc statement.
<p><b>supports</b>
<ul>
<li> jsr169
</ul>
*/
public abstract class embedpreparedstatement
extends embedstatement
implements enginepreparedstatement
//moving jdbc2.0 batch related code in this class because callablestatement in jdbc 20 needs
//this code too and it doesn't derive from prepared statement in jdbc 20 in our implementation.
protected resultsetmetadata rmetadata
//bug 4579-if the prepared statement was revalidated after doing getmetadata(), we
//should get the metadata info again on next getmetadata(). we store the generated
//class name in following variable during getmetadata() call. if it differs from the
//current generated class name, then that indicates a refetch of metadata is required.
private string			gcduringgetmetadata
protected preparedstatement	preparedstatement
private activation			activation
private brokeredconnectioncontrol bcc null
/*
constructor assumes caller will setup context stack
and restore it.
*/
public embedpreparedstatement  embedconnection conn  string sql  boolean formetadata
int resultsettype  int resultsetconcurrency
int resultsetholdability
int autogeneratedkeys
int columnindexes
string columnnames
throws sqlexception
super conn  formetadata  resultsettype  resultsetconcurrency  resultsetholdability
// preparedstatement is poolable by default
ispoolable   true
// if the sql string is null, raise an error
if  sql    null
throw newsqlexception sqlstate null_sql_text
// set up the sqltext in embedstatement
sqltext   sql
try
preparedstatement   lcc prepareinternalstatement
lcc getdefaultschema    sql  resultsetconcurrency  jdbc20translation concur_read_only  formetadata
addwarning preparedstatement getcompiletimewarnings
activation   preparedstatement getactivation lcc  resultsettype    jdbc20translation type_scroll_insensitive
checkrequirescallablestatement activation
//bug 4838 - save the auto-generated key information in activation. keeping this
//information in lcc will not work work as it can be tampered by a nested trasaction
if  autogeneratedkeys    jdbc30translation return_generated_keys
activation setautogeneratedkeysresultsetinfo columnindexes  columnnames
catch  throwable t
throw handleexception t
/**
jdbc states that a statement is closed when garbage collected.
@exception throwable allows any exception to be thrown during finalize
*/
protected void finalize   throws throwable
super finalize
/*
** we mark the activation as not being used and
** that is it.  we rely on the connection to sweep
** through the activations to find the ones that
** aren't in use, and to close them.  we cannot
** do a activation.close() here because there are
** synchronized methods under close that cannot
** be called during finalization.
*/
if  activation    null
activation markunused
/*
* statement interface
we override all statement methods that take a sql
string as they must thrown an exception in a preparedstatement.
see the jdbc 3.0 spec.
*/
public final boolean execute string sql  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final boolean execute string sql  int autogenkeys  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final boolean execute string sql  int columnindexes  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final boolean execute string sql  string columnnames  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final java sql resultset executequery string sql  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final int executeupdate string sql  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final int executeupdate string sql  int autogenkeys  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final int executeupdate string sql  int columnindexes  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final int executeupdate string sql  string columnnames  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
public final void addbatch string sql  throws sqlexception
throw newsqlexception sqlstate not_for_prepared_statement
/**
* additional close to close our activation.
* in the case that a xaconnection is involved in the creation of this
* preparedstatement for e.g in the following case
*
*      <code>
*      xaconnection xaconn = xadatasource.getxaconnection();//where xadatasource is an object of xadatasource
*      connection conn = xaconnection.getconnection();
*      preparedstatement ps = conn.preparedstatement("values 1");
*      </code>
*
* in the above case the preparedstatement will actually be a
* brokeredpreparedstatement40 object. hence when we call
* bcc.onstatementclose and pass the preparedstatement that caused it
* applicationstatement will be the appropriate choice since it will
* contain the appropriate instance of preparedstatement in each case
*
* @throws sqlexception upon failure
*
*/
void closeactions   throws sqlexception
if  bcc  null
java sql preparedstatement ps_app
java sql preparedstatement applicationstatement
bcc onstatementclose ps_app
//we release the resource for preparedstatement
preparedstatement   null
try
setupcontextstack
catch  sqlexception se
//we may have already committed the transaction in which case
//setupcontextstack will fail, the close should just return
return
try
activation close
activation   null
catch  throwable t
throw handleexception t
finally
restorecontextstack
/*
* preparedstatement interface; we have inherited from
* embedstatement to get the statement interface for
* embedpreparedstatement (needed by preparedstatement)
* these are the jdbc interface comments, so we know
* what to do.
*/
/**
* a prepared sql query is executed and its resultset is returned.
*
* @return a resultset that contains the data produced by the
* query; never null
* @exception sqlexception thrown on failure.
*/
public final java sql resultset executequery   throws sqlexception
try
executestatement activation  true  false
catch sqlexception sqle
checkstatementvalidity sqle
if  sanitymanager debug
if  results    null
sanitymanager throwassert
return results
/**
* execute a sql insert, update or delete statement. in addition,
* sql statements that return nothing such as sql ddl statements
* can be executed.
*
* @return either the row count for insert, update or delete; or 0
* for sql statements that return nothing
* @exception sqlexception thrown on failure.
*/
public final int executeupdate   throws sqlexception
try
executestatement activation  false  true
catch sqlexception sqle
checkstatementvalidity sqle
return updatecount
/**
* set a parameter to sql null.
*
* <p><b>note:</b> you must specify the parameter's sql type.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param sqltype sql type code defined by java.sql.types
* @exception sqlexception thrown on failure.
*/
public void setnull int parameterindex  int sqltype  throws sqlexception
checkforsupporteddatatype sqltype
checkstatus
int jdbctypeid   getparameterjdbctype parameterindex
if   datatypedescriptor isjdbctypeequivalent jdbctypeid  sqltype
throw datatypeconversion parameterindex  util typename sqltype
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  settonull
catch  standardexception t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java boolean value.  according to the jdbc api spec,
* the driver converts this to a sql bit value when it sends it to the
* database. but we don't have to do this, since the database engine
* supports a boolean type.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setboolean int parameterindex  boolean x  throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x
catch  standardexception t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java byte value.  the driver converts this
* to a sql tinyint value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setbyte int parameterindex  byte x  throws sqlexception
checkstatus
try
getparms   getparameterforset parameterindex   1  setvalue x
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java short value.  the driver converts this
* to a sql smallint value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setshort int parameterindex  short x  throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java int value.  the driver converts this
* to a sql integer value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setint int parameterindex  int x  throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java long value.  the driver converts this
* to a sql bigint value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setlong int parameterindex  long x  throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java float value.  the driver converts this
* to a sql float value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setfloat int parameterindex  float x  throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java double value.  the driver converts this
* to a sql double value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setdouble int parameterindex  double x  throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java string value.  the driver converts this
* to a sql varchar or longvarchar value (depending on the arguments
* size relative to the driver's limits on varchars) when it sends
* it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setstring int parameterindex  string x  throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java array of bytes.  the driver converts
* this to a sql varbinary or longvarbinary (depending on the
* argument's size relative to the driver's limits on varbinarys)
* when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setbytes int parameterindex  byte x  throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java.sql.date value.  the driver converts this
* to a sql date value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void setdate int parameterindex  date x  throws sqlexception
setdate  parameterindex  x   calendar  null
/**
* set a parameter to a java.sql.time value.  the driver converts this
* to a sql time value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void settime int parameterindex  time x  throws sqlexception
settime  parameterindex  x   calendar  null
/**
* set a parameter to a java.sql.timestamp value.  the driver
* converts this to a sql timestamp value when it sends it to the
* database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception thrown on failure.
*/
public void settimestamp int parameterindex  timestamp x
throws sqlexception
settimestamp  parameterindex  x   calendar  null
/**
* we do this inefficiently and read it all in here. the target type
* is assumed to be a string.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the ascii parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public final void setasciistream int parameterindex  inputstream x  long length
throws sqlexception
checkasciistreamconditions parameterindex
java io reader r   null
if  x    null
// use iso-8859-1 and not us-ascii as jdbc seems to define
// ascii as 8 bits. us-ascii is 7.
try
r   new java io inputstreamreader x
catch  java io unsupportedencodingexception uee
throw new sqlexception uee getmessage
setcharacterstreaminternal parameterindex  r  false  length
/**
* we do this inefficiently and read it all in here. the target type
* is assumed to be a string.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the ascii parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public final void setasciistream int parameterindex  inputstream x  int length
throws sqlexception
setasciistream parameterindex x  long length
/**
deprecated in jdbc 3.0
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the
* unicode parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public void setunicodestream int parameterindex  inputstream x  int length
throws sqlexception
throw util notimplemented
/**
* when a very large unicode value is input to a longvarchar
* parameter, it may be more practical to send it via a
* java.io.reader. jdbc will read the data from the stream
* as needed, until it reaches end-of-file.  the jdbc driver will
* do any necessary conversion from unicode to the database char format.
*
* <p><b>note:</b> this stream object can either be a standard
* java stream object or your own subclass that implements the
* standard interface.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param reader the java reader which contains the unicode data
* @param length the number of characters in the stream
* @exception sqlexception if a database-access error occurs.
*/
public final void setcharacterstream int parameterindex
java io reader reader
long length  throws sqlexception
checkcharacterstreamconditions parameterindex
setcharacterstreaminternal parameterindex  reader  false  length
/**
* when a very large unicode value is input to a longvarchar
* parameter, it may be more practical to send it via a
* java.io.reader. jdbc will read the data from the stream
* as needed, until it reaches end-of-file.  the jdbc driver will
* do any necessary conversion from unicode to the database char format.
*
* <p><b>note:</b> this stream object can either be a standard
* java stream object or your own subclass that implements the
* standard interface.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param reader the java reader which contains the unicode data
* @param length the number of characters in the stream
* @exception sqlexception if a database-access error occurs.
*/
public final void setcharacterstream int parameterindex
java io reader reader
int length  throws sqlexception
setcharacterstream parameterindex reader  long length
/**
* check general preconditions for setcharacterstream methods.
*
* @param parameterindex 1-based index of the parameter.
*/
private final void checkcharacterstreamconditions int parameterindex
throws sqlexception
checkstatus
int jdbctypeid   getparameterjdbctype parameterindex
if   datatypedescriptor ischaracterstreamassignable jdbctypeid
throw datatypeconversion parameterindex
/**
* check general preconditions for setasciistream methods.
*
* @param parameterindex 1-based index of the parameter.
*/
private final void checkasciistreamconditions int parameterindex
throws sqlexception
checkstatus
int jdbctypeid   getparameterjdbctype parameterindex
if   datatypedescriptor isasciistreamassignable jdbctypeid
throw datatypeconversion parameterindex
/**
* set the given character stream for the specified parameter.
*
* if <code>lengthless</code> is <code>true</code>, the following
* conditions are either not checked or verified at the execution time
* of the prepared statement:
* <ol><li>if the stream length is negative.
*     <li>if the stream's actual length equals the specified length.</ol>
* the <code>lengthless</code> variable was added to differentiate between
* streams with invalid lengths and streams without known lengths.
*
* @param parameterindex the 1-based index of the parameter to set.
* @param reader the data.
* @param lengthless tells whether we know the length of the data or not.
* @param length the length of the data. ignored if <code>lengthless</code>
*          is <code>true</code>.
*/
private void setcharacterstreaminternal int parameterindex
reader reader
final boolean lengthless
long length
throws sqlexception
// check for negative length if length is specified.
if   lengthless    length < 0
throw newsqlexception sqlstate negative_stream_length
int jdbctypeid   getparameterjdbctype parameterindex
if  reader    null
setnull parameterindex  jdbctypeid
return
/*
the value stored should not exceed the maximum value that can be
stored in an integer
this checking needs to be done because currently derby does not
support clob sizes greater than 2g-1
*/
if   lengthless    length > integer max_value
throw newsqlexception sqlstate lang_outside_range_for_datatype
getparametersqltype parameterindex
try
readertoutf8stream utfin
parametervalueset pvs   getparms
// need column width to figure out if truncation is needed
datatypedescriptor dtd   preparedstatement
getparametertypes
int colwidth   dtd getmaximumwidth
// default to max column width. this will be used to limit the
// amount of data read when operating on "lengthless" streams.
int usablelength   colwidth
if   lengthless
// we cast the length from long to int. this wouldn't be
// appropriate if the limit of 2g-1 is decided to be increased
// at a later stage.
int intlength    int length
int truncationlength   0
usablelength   intlength
// currently long varchar does not allow for truncation of
// trailing blanks.
// for char and varchar types, current mechanism of
// materializing when using streams seems fine given their max
// limits.
// this change is fix for derby-352: insert of clobs using
// streams should not materialize the entire stream into memory
// in case of clobs, the truncation of trailing blanks is
// factored in when reading from the stream without
// materializing the entire stream, and so the special casing
// for clob below.
if  jdbctypeid    types clob
// it is possible that the length of the stream passed in
// is greater than the column width, in which case the data
// from the stream needs to be truncated.
// usablelength is the length of the data from stream that
// can be inserted which is min(colwidth,length) provided
// length - colwidth has trailing blanks only
// we have used intlength into which the length variable had
// been cast to an int and stored
if  intlength > colwidth
usablelength   colwidth
truncationlength   intlength   usablelength
// create a stream with truncation.
utfin   new readertoutf8stream reader  usablelength
truncationlength  getparametersqltype parameterindex
else
// create a stream without exactness checks,
// but with a maximum limit.
utfin   new readertoutf8stream reader  colwidth
getparametersqltype parameterindex
// jdbc is one-based, dbms is zero-based.
// note that for lengthless stream, usablelength will be
// the maximum length for the column.
// this is okay, based on the observation that
// setvalue does not use the value for anything at all.
pvs getparameterforset
parameterindex   1  setvalue utfin  usablelength
catch  standardexception t
throw embedresultset nostatechangeexception t
/**
* sets the designated parameter to the given input stream.
* when a very large binary value is input to a <code>longvarbinary</code>
* parameter, it may be more practical to send it via a
* <code>java.io.inputstream</code> object. the data will be read from the
* stream as needed until end-of-file is reached.
*
* <em>note:</em> this stream object can either be a standard java stream
* object or your own subclass that implements the standard interface.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the binary parameter value
* @throws sqlexception if a database access error occurs or this method is
*      called on a closed <code>preparedstatement</code>
*/
public void setbinarystream int parameterindex  inputstream x
throws sqlexception
checkbinarystreamconditions parameterindex
setbinarystreaminternal parameterindex  x  true   1
/**
* sets the parameter to the binary stream
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the binary parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public final void setbinarystream int parameterindex  inputstream x  long length
throws sqlexception
checkbinarystreamconditions parameterindex
setbinarystreaminternal parameterindex  x  false  length
/**
* sets the parameter to the binary stream
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream which contains the binary parameter value
* @param length the number of bytes in the stream
* @exception sqlexception thrown on failure.
*/
public final void setbinarystream int parameterindex  inputstream x  int length
throws sqlexception
setbinarystream parameterindex x  long length
/**
* set the given stream for the specified parameter.
*
* if <code>lengthless</code> is <code>true</code>, the following
* conditions are either not checked or verified at the execution time
* of the prepared statement:
* <ol><li>if the stream length is negative.
*     <li>if the stream's actual length equals the specified length.</ol>
* the <code>lengthless</code> variable was added to differentiate between
* streams with invalid lengths and streams without known lengths.
*
* @param parameterindex the 1-based index of the parameter to set.
* @param x the data.
* @param lengthless tells whether we know the length of the data or not.
* @param length the length of the data. ignored if <code>lengthless</code>
*          is <code>true</code>.
*/
private void setbinarystreaminternal int parameterindex  inputstream x
final boolean lengthless  long length
throws sqlexception
if    lengthless    length < 0
throw newsqlexception sqlstate negative_stream_length
int jdbctypeid   getparameterjdbctype parameterindex
if  x    null
setnull parameterindex  jdbctypeid
return
// max number of bytes that can be set to be inserted
// in derby is 2gb-1 (ie integer.max_value).
// (e.g into a blob column).
// for now, we cast the length from long to int as a result.
// if we ever decide to increase these limits for lets say blobs,
// in that case the cast to int would not be appropriate.
if    lengthless    length > integer max_value
throw newsqlexception sqlstate lang_outside_range_for_datatype
getembedparametersetmetadata   getparametertypename
parameterindex
try
rawtobinaryformatstream rawstream
if  lengthless
// force length to -1 for good measure.
length    1
datatypedescriptor dtd
preparedstatement getparametertypes
rawstream   new rawtobinaryformatstream x
dtd getmaximumwidth
dtd gettypename
else
rawstream   new rawtobinaryformatstream x   int length
getparms   getparameterforset parameterindex   1  setvalue
rawstream   int length
catch  standardexception t
throw embedresultset nostatechangeexception t
/**
* check general preconditions for setbinarystream methods.
*
* @param parameterindex 1-based index of the parameter.
*/
private final void checkbinarystreamconditions int parameterindex
throws sqlexception
checkstatus
int jdbctypeid   getparameterjdbctype parameterindex
if   datatypedescriptor isbinarystreamassignable jdbctypeid
throw datatypeconversion parameterindex
/////////////////////////////////////////////////////////////////////////
//
//	jdbc 2.0	-	new public methods
//
/////////////////////////////////////////////////////////////////////////
/**
*
* jdbc 2.0
*
* sets the designated parameter to sql <code>null</code>.
* this version of the method <code>setnull</code> should
* be used for user-defined types and ref type parameters.  examples
* of user-defined types include: struct, distinct, java_object, and
* named array types.
*
* @param paramindex the first parameter is 1, the second is 2, ...
* @param sqltype a value from <code>java.sql.types</code>
* @param typename the fully-qualified name of an sql user-defined type;
*  ignored if the parameter is not a user-defined type or ref
* @exception sqlexception if a database access error occurs or
* this method is called on a closed <code>preparedstatement</code>
* @exception sqlfeaturenotsupportedexception if <code>sqltype</code> is
* a <code>array</code>, <code>blob</code>, <code>clob</code>,
* <code>datalink</code>, <code>java_object</code>, <code>nchar</code>,
* <code>nclob</code>, <code>nvarchar</code>, <code>longnvarchar</code>,
*  <code>ref</code>, <code>rowid</code>, <code>sqlxml</code>
* or  <code>struct</code> data type and the jdbc driver does not support
* this data type or if the jdbc driver does not support this method
*
*/
public void setnull int paramindex
int sqltype
string typename
throws sqlexception
setnull paramindex sqltype
/**
* jdbc 2.0
*
* add a set of parameters to the batch.
*
* @exception sqlexception if a database-access error occurs.
*/
public void addbatch   throws sqlexception
checkstatus
// need to synchronized to ensure that two threads
// don't both create a vector at the same time. this
// would lead to one of the set of parameters being thrown
// away
synchronized  getconnectionsynchronization
if  batchstatements    null
batchstatements   new vector
//get a clone of the parametervalueset and save it in the vector
//which will be used later on at the time of batch execution.
//this way we will get a copy of the current statement's parameter
//values rather than a pointer to the statement's parameter value
//set which will change with every new statement in the batch.
batchstatements addelement getparms   getclone
clearparameters
boolean executebatchelement object batchelement  throws sqlexception  standardexception
parametervalueset temp    parametervalueset  batchelement
int numberofparameters   temp getparametercount
for  int j 0  j<numberofparameters  j
temp getparameter j  setinto this  j   1
return super executestatement activation  false  true
/**
* <p>in general, parameter values remain in force for repeated use of a
* statement. setting a parameter value automatically clears its
* previous value.  however, in some cases it is useful to immediately
* release the resources used by the current parameter values; this can
* be done by calling clearparameters.
* @exception sqlexception thrown on failure.
*/
public void clearparameters   throws sqlexception
checkstatus
parametervalueset pvs   getparms
if  pvs    null
pvs clearparameters
/**
* jdbc 2.0
*
* the number, types and properties of a resultset's columns
* are provided by the getmetadata method.
*
* @return the description of a resultset's columns
* @exception sqlexception feature not implemented for now.
*/
public java sql resultsetmetadata getmetadata   throws sqlexception
checkexecstatus
synchronized  getconnectionsynchronization
//reason for casting is getactivationclass is not available on preparedstatement
execpreparedstatement execp    execpreparedstatement preparedstatement
setupcontextstack       make sure there's context
try
//bug 4579 - if the statement is invalid, regenerate the metadata info
if  preparedstatement isvalid      false
//need to revalidate the statement here, otherwise getresultdescription would
//still have info from previous valid statement
preparedstatement reprepare lcc
rmetadata   null
//bug 4579 - gcduringgetmetadata will be null if this is the first time
//getmetadata call is made.
//second check - if the statement was revalidated since last getmetadata call,
//then gcduringgetmetadata wouldn't match with current generated class name
if  gcduringgetmetadata    null    gcduringgetmetadata equals execp getactivationclass   getname       false
rmetadata   null
gcduringgetmetadata   execp getactivationclass   getname
if  rmetadata    null
resultdescription resd   preparedstatement getresultdescription
if  resd    null
// internally, the result description has information
// which is used for insert, update and delete statements
// externally, we decided that statements which don't
// produce result sets such as insert, update and delete
// should not return resultsetmetadata.  this is enforced
// here
string statementtype   resd getstatementtype
if  statementtype equals
statementtype equals
statementtype equals
rmetadata   null
else
rmetadata   newembedresultsetmetadata resd
catch  throwable t
throw handleexception t
finally
restorecontextstack
return rmetadata
//----------------------------------------------------------------------
// advanced features:
/**
* the interface says that the type of the object parameter must
* be compatible with the type of the targetsqltype. we check that,
* and if it flies, we expect the underlying engine to do the
* required conversion once we pass in the value using its type.
* so, an integer converting to a char is done via setinteger()
* support on the underlying char type.
*
* <p>if x is null, it won't tell us its type, so we pass it on to setnull
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the object containing the input parameter value
* @param targetsqltype the sql type (as defined in java.sql.types) to be
* sent to the database. the scale argument may further qualify this type.
* @param scale for java.sql.types.decimal or java.sql.types.numeric types
*          this is the number of digits after the decimal.  for all other
*          types this value will be ignored,
* @exception sqlexception thrown on failure.
*/
public final void setobject int parameterindex  object x  int targetsqltype  int scale
throws sqlexception
if  x    null
setnull parameterindex  targetsqltype
return
checkforsupporteddatatype targetsqltype
int paramjdbctype   getparameterjdbctype parameterindex
if  paramjdbctype    java sql types java_object
if   datatypedescriptor isjdbctypeequivalent paramjdbctype  targetsqltype
throw datatypeconversion parameterindex  util typename targetsqltype
setobject parameterindex  x
/*
* if the parameter type is decimal or numeric, then
* we need to set the correct scale  or set it
* to the default which is zero for setobject.
*/
if   paramjdbctype    types decimal
paramjdbctype    types numeric
setscale parameterindex  scale
/**
* this method is like setobject above, but assumes a scale of zero.
* @exception sqlexception thrown on failure.
*/
public final void setobject int parameterindex  object x  int targetsqltype
throws sqlexception
setobject parameterindex  x  targetsqltype  0
/**
* <p>set the value of a parameter using an object; use the
* java.lang equivalent objects for integral values.
*
* <p>the jdbc specification specifies a standard mapping from
* java object types to sql types.  the given argument java object
* will be converted to the corresponding sql type before being
* sent to the database.
*
* <p>note that this method may be used to pass datatabase
* specific abstract data types, by using a driver specific java
* type.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the object containing the input parameter value
* @exception sqlexception thrown on failure.
*/
public final void setobject int parameterindex  object x  throws sqlexception
checkstatus
int coltype   getparameterjdbctype parameterindex
// jdbc tutorial and reference books states in the preparedstatement
// overview, that passing a untyped null into setobject() is not allowed.
// jcc disallows this, basically sql can not handle a untyped null.
// section 25.1.6 (third edition), 24.1.5 (second edition)
if  x    null
//setnull(parameterindex, coltype);
//return;
throw datatypeconversion parameterindex
if  coltype    org apache derby iapi reference jdbc20translation sql_types_java_object
try
/* jdbc is one-based, dbms is zero-based */
getparms   setparameterasobject parameterindex   1  x
return
catch  throwable t
throw embedresultset nostatechangeexception t
// need to do instanceof checks here so that the behaviour
// for these calls is consistent with the matching setxxx() value.
// these are the supported setobject conversions from jdbc 3.0 table b5
// byte and short were added to the table in jdbc 4.0.
if  x instanceof string
setstring parameterindex   string  x
return
if  x instanceof boolean
setboolean parameterindex    boolean  x  booleanvalue
return
if  x instanceof byte
setbyte parameterindex    byte  x  bytevalue
return
if  x instanceof short
setshort parameterindex    short  x  shortvalue
return
if  x instanceof integer
setint parameterindex    integer  x  intvalue
return
if  x instanceof long
setlong parameterindex    long  x  longvalue
return
if  x instanceof float
setfloat parameterindex    float  x  floatvalue
return
if  x instanceof double
setdouble parameterindex    double  x  doublevalue
return
if  x instanceof byte
setbytes parameterindex   byte  x
return
if  x instanceof date
setdate parameterindex   date  x
return
if  x instanceof time
settime parameterindex   time  x
return
if  x instanceof timestamp
settimestamp parameterindex   timestamp  x
return
if  x instanceof blob
setblob parameterindex   blob  x
return
if  x instanceof clob
setclob parameterindex   clob  x
return
if  setobjectconvert parameterindex  x
return
throw datatypeconversion parameterindex  x getclass   getname
/**
allow explict setobject conversions by sub-classes for classes
not supported by this variant. e.g. bigdecimal
this top-level implementation always returns false.
@return true if the object was set successfully, false if no valid
conversion exists.
@exception sqlexception value could not be set.
*/
boolean setobjectconvert int parameterindex  object x  throws sqlexception
return false
/**
* @see java.sql.statement#execute
* @exception sqlexception thrown on failure.
*/
public final boolean execute   throws sqlexception
boolean ret false
try
ret   executestatement activation  false  false
catch sqlexception sqle
checkstatementvalidity sqle
return ret
/**
* set a parameter to a java.sql.date value.  the driver converts this
* to a sql date value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception feature not implemented for now.
*/
public final void setdate int parameterindex  java sql date x  calendar cal
throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x  cal
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java.sql.time value.  the driver converts this
* to a sql time value when it sends it to the database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception feature not implemented for now.
*/
public final void settime int parameterindex  java sql time x  calendar cal
throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x  cal
catch  throwable t
throw embedresultset nostatechangeexception t
/**
* set a parameter to a java.sql.timestamp value.  the driver
* converts this to a sql timestamp value when it sends it to the
* database.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the parameter value
* @exception sqlexception feature not implemented for now.
*/
public final void settimestamp int parameterindex  java sql timestamp x  calendar cal
throws sqlexception
checkstatus
try
/* jdbc is one-based, dbms is zero-based */
getparms   getparameterforset parameterindex   1  setvalue x  cal
catch  standardexception t
throw embedresultset nostatechangeexception t
/**
* jdbc 2.0
*
* set a blob parameter.
*
* @param i the first parameter is 1, the second is 2, ...
* @param x an object representing a blob
*/
public void setblob  int i  blob x
throws sqlexception
checkblobconditions i
if  x    null
setnull i  types blob
else
// note, x.length() needs to be called before retrieving the
// stream using x.getbinarystream() because embedblob.length()
// will read from the stream and drain some part of the stream
// hence the need to declare this local variable - streamlength
long streamlength   x length
setbinarystreaminternal i  x getbinarystream    false
streamlength
/**
* check general (pre)conditions for setclob methods.
*
* @param parameterindex 1-based index of the parameter.
*/
private final void checkclobconditions int parameterindex
throws sqlexception
checkstatus
if  getparameterjdbctype parameterindex     types clob
throw datatypeconversion parameterindex
/**
* jdbc 2.0
*
* set a clob parameter.
*
* @param i the first parameter is 1, the second is 2, ...
* @param x an object representing a clob
*/
public void setclob  int i  clob x
throws sqlexception
checkclobconditions i
if  x    null
setnull i  types clob
else
// 1. max number of characters that can be inserted into a clob column
// is 2gb-1 which is integer.max_int.
// this means that we do not allow any inserts of clobs where
// clob.length() > integer.max_int. for now, we cast the x.length()
// to int as a result. this will work ok for valid clob values that
// derby supports. if we ever decide to increase these limits for clobs, in that
// case the cast of x.length() to int would not be appropriate.
// 2. note, x.length() needs to be called before retrieving the
// stream using x.getcharacterstream() because embedclob.length()
// will read from the stream and drain the stream.
// hence the need to declare this local variable - streamlength
long streamlength   x length
setcharacterstreaminternal i  x getcharacterstream
false  streamlength
/**
* get the parametervalueset from the activation.
*
* the caller of this method should be aware that the
* activation associated with a statement can change
* and hence the parametervalueset returned by this
* call should not be hold onto. an example of this
* can be seen in embedcallablestatement.executestatement
* where at the beginning of the method, we check the
* validity of the parameters. but we donot keep the
* parameters in a local variable to use later. the reason
* for this is that the next call in the method,
* super.executestatement can recompile the statement and
* create a new activation if the statement plan has been
* invalidated. to account for this possibility,
* embedcallablestatement.executestatement makes
* another call to get the parametervalueset before stuffing
* the output parameter value into the parametervalueset
* object.
*
*
* @return	the parametervalueset for the activation
*
*/
public final parametervalueset getparms
return activation getparametervalueset
/**
check the parameterindex is in range and return the
array of type descriptors.
@exception sqlexception parameter is out of range
*/
protected final datatypedescriptor gettypes int parameterindex
throws sqlexception
datatypedescriptor types   preparedstatement getparametertypes
if  types    null
throw newsqlexception sqlstate no_input_parameters
/* check that the parameterindex is in range. */
if  parameterindex < 1
parameterindex > types length
/* this message matches the one used by the dbms */
throw newsqlexception sqlstate lang_invalid_param_position
new integer parameterindex   new integer types length
return types
/**
get the target jdbc type for a parameter. will throw exceptions
if the parameter index is out of range
@exception sqlexception parameter is out of range
*/
protected int getparameterjdbctype int parameterindex
throws sqlexception
datatypedescriptor types   gettypes parameterindex
int type   types    null ?
types other
types gettypeid   getjdbctypeid
if  sanitymanager debug
//int pmtype = getembedparametersetmetadata().getparametertype(parameterindex);
//if (type != pmtype) {
//sanitymanager.throwassert("mismatch parameter meta data param " + parameterindex + " types " + type + " != " + pmtype + "\n" + sqltext);
//}
return type
/**
* return the sql type name for the parameter.
*
* @param parameterindex the 1-based index of the parameter
* @return sql name of the parameter
* @throws sqlexception if parameter is out of range
*/
protected final string getparametersqltype int parameterindex
throws sqlexception
datatypedescriptor ptypes   gettypes parameterindex
return ptypes gettypename
/**
* set the scale of a parameter.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param scale	the scale
* @exception sqlexception thrown on failure.
*/
private void setscale int parameterindex  int scale
throws sqlexception
checkstatus
if  scale < 0
throw newsqlexception sqlstate bad_scale_value  new integer scale
try
parametervalueset pvs   getparms
/* jdbc is one-based, dbms is zero-based */
datavaluedescriptor value   pvs getparameter parameterindex   1
int origvaluelen   value getlength
variablesizedatavalue
value  setwidth variablesizedatavalue ignore_precision
scale
false
if  value getlength   < origvaluelen
activation addwarning standardexception newwarning sqlstate lang_value_truncated  value getstring
catch  standardexception t
throw embedresultset nostatechangeexception t
/**
* immitate the function in jdbc 3.0
*
* retrieves the number, types and properties of this preparedstatement
* object's parameters.
*
* @return a engineparametermetadata object that contains information about the
* number, types and properties of this preparedstatement object's parameters.
* @exception sqlexception if a database access error occurs
*/
private engineparametermetadata getembedparametersetmetadata
throws sqlexception
checkexecstatus
return new embedparametersetmetadata
getparms    preparedstatement getparametertypes
/**
* jdbc 3.0
*
* sets the designated parameter to the given java.net.url value. the driver
* converts this to an sql datalink value when it sends it to the database.
*
* @param parameterindex - the first parameter is 1, the second is 2, ...
* @param x - the java.net.url object to be set
* @exception sqlexception feature not implemented for now.
*/
public final void seturl int parameterindex  java net url x
throws sqlexception
throw util notimplemented
//
// methods to be overridden in subimplementations
// that want to stay within their subimplementation.
//
protected embedresultsetmetadata newembedresultsetmetadata resultdescription resultdesc
return factory newembedresultsetmetadata resultdesc getcolumninfo
public string tostring
if  activation    null
return activation getpreparedstatement   getobjectname
return super tostring
/*
**
*/
public void transferparameters embedpreparedstatement newstatement  throws sqlexception
try
newstatement activation setparameters getparms    preparedstatement getparametertypes
catch  standardexception se
throw embedresultset nostatechangeexception se
boolean executestatement activation a
boolean executequery  boolean executeupdate
throws sqlexception
checkexecstatus
checkifinmiddleofbatch
clearresultsets
return super executestatement a  executequery  executeupdate
final sqlexception datatypeconversion int column  string sourcetype
throws sqlexception
sqlexception se   newsqlexception sqlstate lang_data_type_get_mismatch  getembedparametersetmetadata   getparametertypename column
sourcetype
return se
/*
* this method is used to initialize the brokeredconnectioncontrol
* variable with its implementation. this method will be called in the
* brokeredconnectioncontrol class
*
* @param control used to call the onstatementclose and
* onstatementerroroccurred methods that have logic to
* raise statementevents for the close and error events
* on the preparedstatement
*
*/
public void setbrokeredconnectioncontrol brokeredconnectioncontrol control
bcc   control
/*
* method calls onstatementerror occurred on the
* brokeredconnectioncontrol class after checking the
* sqlstate of the sqlexception thrown.
*
* in the case that a xaconnection is involved in the creation of this
* preparedstatement for e.g in the following case
*
*      <code>
*      xaconnection xaconn = xadatasource.getxaconnection();//where xadatasource is an object of xadatasource
*      connection conn = xaconnection.getconnection();
*      preparedstatement ps = conn.preparedstatement("values 1");
*      </code>
*
* in the above case the preparedstatement will actually be a
* brokeredpreparedstatement40 object. hence when we call
* bcc.onstatementclose and pass the preparedstatement that caused it
* applicationstatement will be the appropriate choice since it will
* contain the appropriate instance of preparedstatement in each case
*
*/
private void checkstatementvalidity sqlexception sqle  throws sqlexception
/*
* check if the exception has occurred because the connection
* associated with the preparedstatement has been closed
*/
if bcc    null    isclosed
//call the brokeredconnectioncontrol interface method
//onstatementerroroccurred
bcc onstatementerroroccurred  java sql preparedstatement
applicationstatement sqle
throw sqle
/**
* checks whether a data type is supported for
* <code>setobject(int, object, int)</code> and
* <code>setobject(int, object, int, int)</code>.
*
* @param datatype the data type to check
* @exception sqlexception if the type is not supported
*/
private void checkforsupporteddatatype int datatype  throws sqlexception
// jdbc 4.0 javadoc for setobject() says:
//
// throws: (...) sqlfeaturenotsupportedexception - if
// targetsqltype is a array, blob, clob, datalink,
// java_object, nchar, nclob, nvarchar, longnvarchar, ref,
// rowid, sqlxml or struct data type and the jdbc driver does
// not support this data type
//
// of these types, we only support blob, clob and
// (sort of) java_object.
switch  datatype
case types array
case jdbc30translation datalink
case jdbc40translation nchar
case jdbc40translation nclob
case jdbc40translation nvarchar
case jdbc40translation longnvarchar
case types ref
case jdbc40translation rowid
case jdbc40translation sqlxml
case types struct
throw newsqlexception sqlstate data_type_not_supported
util typename datatype
//jdbc 4.0 methods
/**
* sets the designated parameter to the given input stream.
* when a very large ascii value is input to a <code>longvarchar</code>
* parameter, it may be more practical to send it via a
* <code>java.io.inputstream</code>. data will be read from the stream as
* needed until end-of-file is reached. the jdbc driver will do any
* necessary conversion from ascii to the database char format.
*
* <em>note:</em> this stream object can either be a standard java stream
* object or your own subclass that implements the standard interface.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param x the java input stream that contains the ascii parameter value
* @throws sqlexception if a database access error occurs or this method is
*      called on a closed <code>preparedstatement</code>
*/
public void setasciistream int parameterindex  inputstream x
throws sqlexception
checkasciistreamconditions parameterindex
java io reader asciistream   null
if  x    null
// use iso-8859-1 and not us-ascii as jdbc seems to define
// ascii as 8 bits. us-ascii is 7.
try
asciistream   new java io inputstreamreader x
catch  java io unsupportedencodingexception uee
throw new sqlexception uee getmessage
setcharacterstreaminternal parameterindex  asciistream  true   1
/**
* sets the designated parameter to the given <code>reader</code> object.
* when a very large unicode value is input to a longvarchar parameter, it
* may be more practical to send it via a <code>java.io.reader</code>
* object. the data will be read from the stream as needed until
* end-of-file is reached. the jdbc driver will do any necessary conversion
* from unicode to the database char format.
*
* <em>note:</em> this stream object can either be a standard java stream
* object or your own subclass that implements the standard interface.
*
* using this lengthless overload is not less effective than using one
* where the stream length is specified, but since there is no length
* specified, the exact length check will not be performed.
*
* @param parameterindex the first parameter is 1, the second is 2, ...
* @param reader the <code>java.io.reader</code> object that contains the
*      unicode data
* @throws sqlexception if a database access error occurs or this method is
*      called on a closed <code>preparedstatement</code>
*/
public void setcharacterstream int parameterindex  reader reader
throws sqlexception
checkcharacterstreamconditions parameterindex
setcharacterstreaminternal parameterindex  reader
true   1
/**
* sets the designated parameter to a <code>reader</code> object.
* this method differs from the <code>setcharacterstream(int,reader)</code>
* method because it informs the driver that the parameter value should be
* sent to the server as a <code>clob</code>. when the
* <code>setcharacterstream</code> method is used, the driver may have to
* do extra work to determine whether the parameter data should be sent to
* the server as a <code>longvarchar</code> or a <code>clob</code>.
*
* @param parameterindex index of the first parameter is 1, the second is
*      2, ...
* @param reader an object that contains the data to set the parameter
*      value to.
* @throws sqlexception if a database access error occurs, this method is
*      called on a closed preparedstatementor if parameterindex does not
*      correspond to a parameter marker in the sql statement
*/
public void setclob int parameterindex  reader reader
throws sqlexception
checkclobconditions parameterindex
setcharacterstreaminternal parameterindex  reader  true   1
/**
* sets the designated parameter to a reader object.
*
* @param parameterindex index of the first parameter is 1, the second is 2, ...
* @param reader an object that contains the data to set the parameter value to.
* @param length the number of characters in the parameter data.
* @throws sqlexception if parameterindex does not correspond to a parameter
* marker in the sql statement, or if the length specified is less than zero.
*
*/
public void setclob int parameterindex  reader reader  long length
throws sqlexception
checkclobconditions parameterindex
setcharacterstreaminternal parameterindex  reader  false  length
/**
* sets the designated parameter to a <code>inputstream</code> object.
* this method differs from the <code>setbinarystream(int, inputstream)
* </code>  method because it informs the driver that the parameter value
* should be sent to the server as a <code>blob</code>. when the
* <code>setbinarystream</code> method is used, the driver may have to do
* extra work to determine whether the parameter data should be sent to the
* server as a <code>longvarbinary</code> or a <code>blob</code>
*
* @param parameterindex index of the first parameter is 1, the second is
*      2, ...
* @param inputstream an object that contains the data to set the parameter
*      value to.
* @throws sqlexception if a database access error occurs, this method is
*      called on a closed <code>preparedstatement</code> or if
*      <code>parameterindex</code> does not correspond to a parameter
*      marker in the sql statement
*/
public void setblob int parameterindex  inputstream inputstream
throws sqlexception
checkblobconditions parameterindex
setbinarystreaminternal parameterindex  inputstream  true   1
/**
* sets the designated parameter to a inputstream object.
*
* @param parameterindex index of the first parameter is 1,
* the second is 2, ...
* @param inputstream an object that contains the data to set the parameter
* value to.
* @param length the number of bytes in the parameter data.
* @throws sqlexception if parameterindex does not correspond
* to a parameter marker in the sql statement,  if the length specified
* is less than zero or if the number of bytes in the inputstream does not match
* the specfied length.
*/
public void setblob int parameterindex  inputstream inputstream  long length
throws sqlexception
checkblobconditions parameterindex
setbinarystreaminternal parameterindex  inputstream  false  length
/**
* check general (pre)conditions for setblob methods.
*
* @param parameterindex 1-based index of the parameter.
*/
private final void checkblobconditions int parameterindex
throws sqlexception
checkstatus
if  getparameterjdbctype parameterindex     types blob
throw datatypeconversion parameterindex