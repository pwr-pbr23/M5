/*
derby - class org.apache.derby.impl.sql.compile.binaryrelationaloperatornode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi reference classname
import org apache derby iapi reference jdbc30translation
import org apache derby iapi util jbitset
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql compile optimizable
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types orderable
import org apache derby impl sql compile expressionclassbuilder
import java sql types
/**
* this class represents the 6 binary operators: lessthan, lessthanequals,
* equals, notequals, greaterthan and greaterthanequals.
*
*/
public class binaryrelationaloperatornode
extends binarycomparisonoperatornode
implements relationaloperator
private int operatortype
/* relationaloperator interface */
// visitor for finding base tables beneath optimizables and column
// references.  created once and re-used thereafter.
private basetablenumbersvisitor btnvis
// bit sets for holding base tables beneath optimizables and
// column references.  created once and re-used thereafter.
jbitset optbasetables
jbitset valnodebasetables
/* if this binrelop was created for an in-list "probe predicate"
* then we keep a pointer to the original in-list.  this serves
* two purposes: 1) if this field is non-null then we know that
* this binrelop is for an in-list probe predicate; 2) if the
* optimizer chooses a plan for which the probe predicate is
* not usable as a start/stop key then we'll "revert" the pred
* back to the inlistoperatornode referenced here.
*/
inlistoperatornode inlistprobesource   null
public void init object leftoperand  object rightoperand
string methodname
string operatorname
switch  getnodetype
case c_nodetypes binary_equals_operator_node
methodname
operatorname
operatortype   relationaloperator equals_relop
break
case c_nodetypes binary_greater_equals_operator_node
methodname
operatorname
operatortype   relationaloperator greater_equals_relop
break
case c_nodetypes binary_greater_than_operator_node
methodname
operatorname
operatortype   relationaloperator greater_than_relop
break
case c_nodetypes binary_less_equals_operator_node
methodname
operatorname
operatortype    relationaloperator less_equals_relop
break
case c_nodetypes binary_less_than_operator_node
methodname
operatorname
operatortype   relationaloperator less_than_relop
break
case c_nodetypes binary_not_equals_operator_node
methodname
operatorname
operatortype   relationaloperator not_equals_relop
break
default
if  sanitymanager debug
sanitymanager throwassert     getnodetype
break
super init leftoperand  rightoperand  operatorname  methodname
btnvis   null
/**
* same as init() above except takes a third argument that is
* an inlistoperatornode.  this version is used during in-list
* preprocessing to create a "probe predicate" for the in-list.
* see inlistoperatornode.preprocess() for more.
*/
public void init object leftoperand  object rightoperand  object inlistop
init leftoperand  rightoperand
this inlistprobesource    inlistoperatornode inlistop
/**
* if this rel op was created for an in-list probe predicate then return
* the underlying inlistoperatornode.  will return null if this rel
* op is a "legitimate" relational operator (as opposed to a disguised
* in-list).
*/
protected inlistoperatornode getinlistop
return inlistprobesource
/** @see relationaloperator#getcolumnoperand */
public columnreference getcolumnoperand
optimizable opttable
int columnposition
fromtable	ft    fromtable  opttable
// when searching for a matching column operand, we search
// the entire subtree (if there is one) beneath opttable
// to see if we can find any fromtables that correspond to
// either of this op's column references.
columnreference	cr
boolean walksubtree   true
if  leftoperand instanceof columnreference
/*
** the left operand is a column reference.
** is it the correct column?
*/
cr    columnreference  leftoperand
if  valnodereferencesopttable cr  ft  false  walksubtree
/*
** the table is correct, how about the column position?
*/
if  cr getsource   getcolumnposition      columnposition
/* we've found the correct column - return it */
return cr
walksubtree   false
if  rightoperand instanceof columnreference
/*
** the right operand is a column reference.
** is it the correct column?
*/
cr    columnreference  rightoperand
if  valnodereferencesopttable cr  ft  false  walksubtree
/*
** the table is correct, how about the column position?
*/
if  cr getsource   getcolumnposition      columnposition
/* we've found the correct column - return it */
return cr
/* neither side is the column we're looking for */
return null
/** @see relationaloperator#getcolumnoperand */
public columnreference getcolumnoperand optimizable opttable
columnreference	cr
boolean walksubtree   true
if  leftoperand instanceof columnreference
/*
** the left operand is a column reference.
** is it the correct column?
*/
cr    columnreference  leftoperand
if  valnodereferencesopttable
cr   fromtable opttable  false  walksubtree
/*
** the table is correct.
*/
return cr
walksubtree   false
if  rightoperand instanceof columnreference
/*
** the right operand is a column reference.
** is it the correct column?
*/
cr    columnreference  rightoperand
if  valnodereferencesopttable cr
fromtable opttable  false  walksubtree
/*
** the table is correct
*/
return cr
/* neither side is the column we're looking for */
return null
/**
* @see relationaloperator#getexpressionoperand
*/
public valuenode getexpressionoperand
int tablenumber
int columnposition
fromtable ft
columnreference	cr
boolean walksubtree   true
if  leftoperand instanceof columnreference
/*
** the left operand is a column reference.
** is it the correct column?
*/
cr    columnreference  leftoperand
if  valnodereferencesopttable cr  ft  false  walksubtree
/*
** the table is correct, how about the column position?
*/
if  cr getsource   getcolumnposition      columnposition
/*
** we've found the correct column -
** return the other side
*/
return rightoperand
walksubtree   false
if  rightoperand instanceof columnreference
/*
** the right operand is a column reference.
** is it the correct column?
*/
cr    columnreference  rightoperand
if  valnodereferencesopttable cr  ft  false  walksubtree
/*
** the table is correct, how about the column position?
*/
if  cr getsource   getcolumnposition      columnposition
/*
** we've found the correct column -
** return the other side
*/
return leftoperand
return null
/**
* @see relationaloperator#getoperand
*/
public valuenode getoperand columnreference cref
int refsetsize  boolean otherside
// following call will initialize/reset the btnvis,
// valnodebasetables, and optbasetables fields of this object.
initbasetablevisitor refsetsize  true
// we search for the column reference by getting the *base*
// table number for each operand and checking to see if
// that matches the *base* table number for the cref
// that we're looking for.  if so, then we the two
// reference the same table so we go on to check
// column position.
try
// use optbasetables for cref's base table numbers.
btnvis settablemap optbasetables
cref accept btnvis
// use valnodebasetables for operand base table nums.
btnvis settablemap valnodebasetables
columnreference	cr
if  leftoperand instanceof columnreference
/*
** the left operand is a column reference.
** is it the correct column?
*/
cr    columnreference  leftoperand
cr accept btnvis
valnodebasetables and optbasetables
if  valnodebasetables getfirstsetbit       1
/*
** the table is correct, how about the column position?
*/
if  cr getsource   getcolumnposition
cref getcolumnnumber
/*
** we've found the correct column -
** return the appropriate side.
*/
if  otherside
return rightoperand
return leftoperand
if  rightoperand instanceof columnreference
/*
** the right operand is a column reference.
** is it the correct column?
*/
valnodebasetables clearall
cr    columnreference  rightoperand
cr accept btnvis
valnodebasetables and optbasetables
if  valnodebasetables getfirstsetbit       1
/*
** the table is correct, how about the column position?
*/
if  cr getsource   getcolumnposition
cref getcolumnnumber
/*
** we've found the correct column -
** return the appropriate side
*/
if  otherside
return leftoperand
return rightoperand
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert
se
return null
/**
* @see relationaloperator#generateexpressionoperand
*
* @exception standardexception		thrown on error
*/
public void generateexpressionoperand
optimizable opttable
int columnposition
expressionclassbuilder acb
methodbuilder mb
throws standardexception
columnreference	cr
frombasetable	ft
if  sanitymanager debug
sanitymanager assert opttable instanceof frombasetable
ft    frombasetable  opttable
valuenode exprop   getexpressionoperand
ft gettablenumber    columnposition  ft
if  sanitymanager debug
if  exprop    null
sanitymanager throwassert
columnposition
ft getexposedname
exprop generateexpression acb  mb
/** @see relationaloperator#selfcomparison
*
* @exception standardexception		thrown on error
*/
public boolean selfcomparison columnreference cr
throws standardexception
valuenode	otherside
jbitset		tablesreferenced
/*
** figure out which side the given columnreference is on,
** and look for the same table on the other side.
*/
if  leftoperand    cr
otherside   rightoperand
else if  rightoperand    cr
otherside   leftoperand
else
otherside   null
if  sanitymanager debug
sanitymanager throwassert
tablesreferenced   otherside gettablesreferenced
/* return true if the table we're looking for is in the bit map */
return tablesreferenced get cr gettablenumber
/** @see relationaloperator#usefulstartkey */
public boolean usefulstartkey optimizable opttable
/*
** determine whether this operator is a useful start operator
** with knowledge of whether the key column is on the left or right.
*/
int	columnside   columnononeside opttable
if  columnside    neither
return false
else
return usefulstartkey columnside    left
/**
* return true if a key column for the given table is found on the
* left side of this operator, false if it is found on the right
* side of this operator.
*
* note: this method assumes that a key column will be found on one
* side or the other.  if you don't know whether a key column exists,
* use the columnononeside() method (below).
*
* @param opttable	the optimizable table that we're looking for a key
*					column on.
*
* @return true if a key column for the given table is on the left
*			side of this operator, false if one is found on the right
*			side of this operator.
*/
protected boolean keycolumnonleft optimizable opttable
columnreference	cr
boolean			left   false
/* is the key column on the left or the right? */
if  leftoperand instanceof columnreference
/*
** the left operand is a column reference.
** is it the correct column?
*/
cr    columnreference  leftoperand
if  valnodereferencesopttable
cr   fromtable opttable  false  true
/* the left operand is the key column */
left   true
// else the right operand must be the key column.
if  sanitymanager debug
if   left
sanitymanager assert
rightoperand instanceof columnreference
valnodereferencesopttable  columnreference rightoperand
fromtable opttable  false  true
return left
/* return values for columnononeside */
protected static final int left    1
protected static final int neither   0
protected static final int right   1
/**
* determine whether there is a column from the given table on one side
* of this operator, and if so, which side is it on?
*
* @param opttable	the optimizable table that we're looking for a key
*					column on.
*
* @return	left if there is a column on the left, right if there is
*			a column on the right, neither if no column found on either
*			side.
*/
protected int columnononeside optimizable opttable
columnreference	cr
boolean			left   false
boolean			walksubtree   true
/* is a column on the left */
if  leftoperand instanceof columnreference
/*
** the left operand is a column reference.
** is it the correct column?
*/
cr    columnreference  leftoperand
if  valnodereferencesopttable
cr   fromtable opttable  false  walksubtree
/* key column found on left */
return left
walksubtree   false
if  rightoperand instanceof columnreference
/*
** the right operand is a column reference.
** is it the correct column?
*/
cr    columnreference  rightoperand
if  valnodereferencesopttable
cr   fromtable opttable  false  walksubtree
/* key column found on right */
return right
return neither
/** @see relationaloperator#usefulstopkey */
public boolean usefulstopkey optimizable opttable
/*
** determine whether this operator is a useful start operator
** with knowledge of whether the key column is on the left or right.
*/
int	columnside   columnononeside opttable
if  columnside    neither
return false
else
return usefulstopkey columnside    left
/**
* determine whether this comparison operator is a useful stop key
* with knowledge of whether the key column is on the left or right.
*
* @param left	true means the key column is on the left, false means
*				it is on the right.
*
* @return	true if this is a useful stop key
*/
/** @see relationaloperator#generateabsolutecolumnid */
public void generateabsolutecolumnid methodbuilder mb
optimizable opttable
// get the absolute column position for the column
int columnposition   getabsolutecolumnposition opttable
mb push columnposition
/** @see relationaloperator#generaterelativecolumnid */
public void generaterelativecolumnid methodbuilder mb
optimizable opttable
// get the absolute column position for the column
int columnposition   getabsolutecolumnposition opttable
// convert the absolute to the relative 0-based column position
columnposition   opttable convertabsolutetorelativecolumnposition
columnposition
mb push columnposition
/**
* get the absolute 0-based column position of the columnreference from
* the conglomerate for this optimizable.
*
* @param opttable	the optimizable
*
* @return the absolute 0-based column position of the columnreference
*/
private int getabsolutecolumnposition optimizable opttable
columnreference	cr
conglomeratedescriptor bestcd
int columnposition
if  keycolumnonleft opttable
cr    columnreference  leftoperand
else
cr    columnreference  rightoperand
bestcd   opttable gettrulythebestaccesspath
getconglomeratedescriptor
/*
** column positions are one-based, store is zero-based.
*/
columnposition   cr getsource   getcolumnposition
/*
** if it's an index, find the base column position in the index
** and translate it to an index column position.
*/
if  bestcd    null    bestcd isindex
columnposition   bestcd getindexdescriptor
getkeycolumnposition columnposition
if  sanitymanager debug
sanitymanager assert columnposition > 0
// return the 0-based column position
return columnposition   1
/**
* @exception standardexception		thrown on error
*/
public void generatequalmethod expressionclassbuilder acb
methodbuilder mb
optimizable opttable
throws standardexception
/* generate a method that returns the expression */
methodbuilder qualmethod   acb newuserexprfun
/*
** generate the expression that's on the opposite side
** of the key column
*/
if  keycolumnonleft opttable
rightoperand generateexpression acb  qualmethod
else
leftoperand generateexpression acb  qualmethod
qualmethod methodreturn
qualmethod complete
/* push an expression that evaluates to the generatedmethod */
acb pushmethodreference mb  qualmethod
/** @see relationaloperator#generateorderednulls */
public void generateorderednulls methodbuilder mb
mb push false
/** @see relationaloperator#orderednulls */
public boolean orderednulls
return false
/** @see relationaloperator#isqualifier
*
* @exception standardexception		thrown on error
*/
public boolean isqualifier optimizable opttable  boolean forpush
throws standardexception
/* if this rel op is for an in-list probe predicate then we never
* treat it as a qualifer.  the reason is that if we treat it as
* a qualifier then we could end up generating it as a qualifier,
* which would lead to the generation of an equality qualifier
* of the form "col = <val>" (where <val> is the first value in
* the in-list).  that would lead to wrong results (missing rows)
* because that restriction is incorrect.
*/
if  inlistprobesource    null
return false
fromtable	ft
valuenode	otherside   null
jbitset		tablesreferenced
columnreference	cr   null
boolean	found   false
boolean walksubtree   true
ft    fromtable  opttable
if  leftoperand instanceof columnreference
/*
** the left operand is a column reference.
** is it the correct column?
*/
cr    columnreference  leftoperand
if  valnodereferencesopttable cr  ft  forpush  walksubtree
otherside   rightoperand
found   true
walksubtree   false
if       found      rightoperand instanceof columnreference
/*
** the right operand is a column reference.
** is it the correct column?
*/
cr    columnreference  rightoperand
if  valnodereferencesopttable cr  ft  forpush  walksubtree
otherside   leftoperand
found   true
/* have we found a columnreference on either side? */
if     found
/*
** neither side is a columnreference to the table we're looking
** for, so it can't be a qualifier
*/
return false
/*
** one side is a columnreference to the correct table.  it is a
** qualifier if the other side does not refer to the table we are
** optimizing.
*/
return  valnodereferencesopttable otherside  ft  forpush  true
/**
* @see relationaloperator#getorderablevarianttype
*
* @exception standardexception	thrown on error
*/
public int getorderablevarianttype optimizable opttable
throws standardexception
/* the qualifier's orderable is on the opposite side from
* the key column.
*/
if  keycolumnonleft opttable
return rightoperand getorderablevarianttype
else
return leftoperand getorderablevarianttype
/** @see relationaloperator#comparewithknownconstant */
public boolean comparewithknownconstant optimizable opttable  boolean considerparameters
valuenode	node   null
node   keycolumnonleft opttable  ? rightoperand   leftoperand
if  considerparameters
return  node instanceof constantnode
node requirestypefromcontext
parameternode node  getdefaultvalue      null
else
return node instanceof constantnode
/**
* @see relationaloperator#getcomparevalue
*
* @exception standardexception		thrown on error
*/
public datavaluedescriptor getcomparevalue optimizable opttable
throws standardexception
valuenode	node   null
/* the value being compared to is on the opposite side from
** the key column.
*/
node   keycolumnonleft opttable  ? rightoperand   leftoperand
if  node instanceof constantnode
return   constantnode node  getvalue
else if  node requirestypefromcontext
parameternode pn
if  node instanceof unaryoperatornode
pn     unaryoperatornode node  getparameteroperand
else
pn    parameternode   node
return pn getdefaultvalue
else
return null
/**
* return 50% if this is a comparison with a boolean column, a negative
* selectivity otherwise.
*/
protected double booleanselectivity optimizable opttable
throws standardexception
typeid	typeid   null
double				retval    1 0d
int					columnside
columnside   columnononeside opttable
if  columnside    left
typeid   leftoperand gettypeid
else if  columnside    right
typeid   rightoperand gettypeid
if  typeid    null     typeid getjdbctypeid      types bit
typeid getjdbctypeid      jdbc30translation sql_types_boolean
retval   0 5d
return retval
/**
* the methods generated for this node all are on orderable.
* overrides this method
* in booleanoperatornode for code generation purposes.
*/
public string getreceiverinterfacename
return classname datavaluedescriptor
/**
* returns the negation of this operator; negation of equals is notequals.
*/
binaryoperatornode getnegation valuenode leftoperand
valuenode rightoperand
throws standardexception
binaryoperatornode negation
if  sanitymanager debug
sanitymanager assert gettypeservices      null
/* xxxresolve: look into doing this in place instead of allocating a new node */
negation    binaryoperatornode
getnodefactory   getnode getnegationnode
leftoperand  rightoperand
getcontextmanager
negation settype gettypeservices
return negation
/* map current node to its negation */
private int getnegationnode
switch  getnodetype
case c_nodetypes binary_equals_operator_node
return c_nodetypes binary_not_equals_operator_node
case c_nodetypes binary_greater_equals_operator_node
return c_nodetypes binary_less_than_operator_node
case c_nodetypes binary_greater_than_operator_node
return c_nodetypes binary_less_equals_operator_node
case c_nodetypes binary_less_than_operator_node
return c_nodetypes binary_greater_equals_operator_node
case c_nodetypes binary_less_equals_operator_node
return c_nodetypes binary_greater_than_operator_node
case c_nodetypes binary_not_equals_operator_node
return c_nodetypes binary_equals_operator_node
if  sanitymanager debug
sanitymanager throwassert     getnodetype
return  1
/**
* is this is useful start key? for example a predicate of the from
* <em>column lessthan 5</em> is not a useful start key but is a useful stop
* key. however <em>5 lessthan column </em> is a useful start key.
*
* @param columnonleft 	is true if the column is the left hand side of the
* binary operator.
*/
protected boolean usefulstartkey boolean columnonleft
switch  operatortype
case relationaloperator equals_relop
return true
case relationaloperator not_equals_relop
return false
case relationaloperator greater_than_relop
case relationaloperator greater_equals_relop
// col > 1
return columnonleft
case relationaloperator less_than_relop
case relationaloperator less_equals_relop
// col < 1
return  columnonleft
default
return false
/** @see relationaloperator#usefulstopkey */
protected boolean usefulstopkey boolean columnonleft
switch  operatortype
case relationaloperator equals_relop
return true
case relationaloperator not_equals_relop
return false
case relationaloperator greater_than_relop
case relationaloperator greater_equals_relop
// col > 1
return  columnonleft
case relationaloperator less_equals_relop
case relationaloperator less_than_relop
// col < 1
return columnonleft
default
return false
/** @see relationaloperator#getstartoperator */
public int getstartoperator optimizable opttable
switch  operatortype
case relationaloperator equals_relop
case relationaloperator less_equals_relop
case relationaloperator greater_equals_relop
return scancontroller ge
case relationaloperator less_than_relop
case relationaloperator greater_than_relop
return scancontroller gt
case relationaloperator not_equals_relop
if  sanitymanager debug
sanitymanager throwassert
return scancontroller na
default
return scancontroller na
/** @see relationaloperator#getstopoperator */
public int getstopoperator optimizable opttable
switch  operatortype
case relationaloperator equals_relop
case relationaloperator greater_equals_relop
case relationaloperator less_equals_relop
return scancontroller gt
case relationaloperator less_than_relop
case relationaloperator greater_than_relop
return scancontroller ge
case relationaloperator not_equals_relop
if  sanitymanager debug
sanitymanager throwassert
return scancontroller na
default
return scancontroller na
/** @see relationaloperator#generateoperator */
public void generateoperator methodbuilder mb
optimizable opttable
switch  operatortype
case relationaloperator equals_relop
mb push orderable order_op_equals
break
case relationaloperator not_equals_relop
mb push orderable order_op_equals
break
case relationaloperator less_than_relop
case relationaloperator greater_equals_relop
mb push keycolumnonleft opttable  ?
orderable order_op_lessthan   orderable order_op_lessorequals
break
case relationaloperator less_equals_relop
case relationaloperator greater_than_relop
mb push keycolumnonleft opttable  ?
orderable order_op_lessorequals   orderable order_op_lessthan
/** @see relationaloperator#generatenegate */
public void generatenegate methodbuilder mb  optimizable opttable
switch  operatortype
case relationaloperator equals_relop
mb push false
break
case relationaloperator not_equals_relop
mb push true
break
case relationaloperator less_than_relop
case relationaloperator less_equals_relop
mb push  keycolumnonleft opttable
break
case relationaloperator greater_than_relop
case relationaloperator greater_equals_relop
mb push keycolumnonleft opttable
break
return
/** @see relationaloperator#getoperator */
public int getoperator
return operatortype
/** return the selectivity of this predicate.
*/
public double selectivity optimizable opttable
throws standardexception
double retval   booleanselectivity opttable
if  retval >  0 0d
return retval
switch  operatortype
case relationaloperator equals_relop
return 0 1
case relationaloperator not_equals_relop
case relationaloperator less_than_relop
case relationaloperator less_equals_relop
case relationaloperator greater_equals_relop
if  getbetweenselectivity
return 0 5d
/* fallthrough -- only */
case relationaloperator greater_than_relop
return 0 33
return 0 0
/** @see relationaloperator#gettransitivesearchclause */
public relationaloperator gettransitivesearchclause columnreference othercr
throws standardexception
return  relationaloperator getnodefactory   getnode getnodetype
othercr
rightoperand
getcontextmanager
public boolean equalscomparisonwithconstantexpression optimizable opttable
if  operatortype    equals_relop
return false
boolean retval   false
valuenode comparand   null
int side   columnononeside opttable
if  side    left
retval   rightoperand isconstantexpression
else if  side    right
retval   leftoperand isconstantexpression
return retval
/** @see valuenode#isrelationaloperator */
public boolean isrelationaloperator
/* if this rel op is for a probe predicate then we do not call
* it a "relational operator"; it's actually a disguised in-list
* operator.
*/
return  inlistprobesource    null
/** @see valuenode#isbinaryequalsoperatornode */
public boolean isbinaryequalsoperatornode
/* if this rel op is for a probe predicate then we do not treat
* it as an "equals operator"; it's actually a disguised in-list
* operator.
*/
return  inlistprobesource    null
operatortype    relationaloperator equals_relop
/** @see valuenode#isinlistprobenode */
public boolean isinlistprobenode
return  inlistprobesource    null
/** @see valuenode#optimizableequalitynode */
public boolean optimizableequalitynode optimizable opttable
int columnnumber
boolean isnullokay
throws standardexception
if  operatortype    equals_relop
return false
/* if this rel op is for a probe predicate then we do not treat
* it as an equality node; it's actually a disguised in-list node.
*/
if  inlistprobesource    null
return false
columnreference cr   getcolumnoperand opttable
columnnumber
if  cr    null
return false
if  selfcomparison cr
return false
if  implicitvarcharcomparison
return false
return true
/**
* return whether or not this binary relational predicate requires an implicit
* (var)char conversion.  this is important when considering
* hash join since this type of equality predicate is not currently
* supported for a hash join.
*
* @return	whether or not an implicit (var)char conversion is required for
*			this binary relational operator.
*
* @exception standardexception		thrown on error
*/
private boolean implicitvarcharcomparison
throws standardexception
typeid lefttype   leftoperand gettypeid
typeid righttype   rightoperand gettypeid
if  lefttype isstringtypeid       righttype isstringtypeid
return true
if  righttype isstringtypeid        lefttype isstringtypeid
return true
return false
/* @see binaryoperatornode#gensqljavasqltree
* @see binarycomparisonoperatornode#gensqljavasqltree
*/
public valuenode gensqljavasqltree   throws standardexception
if  operatortype    equals_relop
return this
return super gensqljavasqltree
/**
* take a resultsetnode and return a column reference that is scoped for
* for the received resultsetnode, where "scoped" means that the column
* reference points to a specific column in the rsn.  this is used for
* remapping predicates from an outer query down to a subquery.
*
* for example, assume we have the following query:
*
*  select * from
*    (select i,j from t1 union select i,j from t2) x1,
*    (select a,b from t3 union select a,b from t4) x2
*  where x1.j = x2.b;
*
* then assume that this binaryrelationaloperatornode represents the
* "x1.j = x2.b" predicate and that the childrsn we received as a
* parameter represents one of the subqueries to which we want to push
* the predicate; let's say it's:
*
*    select i,j from t1
*
* then what we want to do in this method is map one of the operands
* x1.j or x2.b (depending on the 'whichside' parameter) to the childrsn,
* if possible.  note that in our example, "x2.b" should _not_ be mapped
* because it doesn't apply to the childrsn for the subquery "select i,j
* from t1"; thus we should leave it as it is.  "x1.j", however, _does_
* need to be scoped, and so this method will return a columnreference
* pointing to "t1.j" (or whatever the corresponding column in t1 is).
*
* assumption: we should only get to this method if we know that
* exactly one operand in the predicate to which this operator belongs
* can and should be mapped to the received childrsn.
*
* @param whichside the operand are we trying to scope (left or right)
* @param parentrsnstables set of all table numbers referenced by
*  the resultsetnode that is _parent_ to the received childrsn.
*  we need this to make sure we don't scope the operand to a
*  resultsetnode to which it doesn't apply.
* @param childrsn the result set node to which we want to create
*  a scoped predicate.
* @param whichrc if not -1 then this tells us which resultcolumn
*  in the received childrsn we need to use for the scoped predicate;
*  if -1 then the column position of the scoped column reference
*  will be stored in this array and passed back to the caller.
* @return a column reference scoped to the received childrsn, if possible.
*  if the operand is a columnreference that is not supposed to be scoped,
*  we return a _clone_ of the reference--this is necessary because the
*  reference is going to be pushed to two places (left and right children
*  of the parentrsn) and if both children are referencing the same
*  instance of the column reference, they'll interfere with each other
*  during optimization.
*/
public valuenode getscopedoperand int whichside
jbitset parentrsnstables  resultsetnode childrsn
int  whichrc  throws standardexception
resultcolumn rc   null
columnreference cr
whichside    left
?  columnreference leftoperand
columnreference rightoperand
/* when we scope a predicate we only scope one side of it--the
* side that is to be evaluated against childrsn.  we figure out
* if "cr" is that side by using table numbers, as seen below.
* this means that for every scoped predicate there will be one
* operand that is scoped and one operand that is not scoped.
* when we get here for the operand that will not be scoped,
* we'll just return a clone of that operand.  so in the example
* mentioned above, the scoped predicate for the left child of
* x1 would be
*
*   t1.j <scoped> = x2.b <clone>
*
* that said, the first thing we need to do is see if this
* columnreference is supposed to be scoped for childrsn.  we
* do that by figuring out what underlying base table the column
* reference is pointing to and then seeing if that base table
* is included in the list of table numbers from the parentrsn.
*/
jbitset crtables   new jbitset parentrsnstables size
basetablenumbersvisitor btnvis
new basetablenumbersvisitor crtables
cr accept btnvis
/* if the column reference in question is not intended for
* the received result set node, just leave the operand as
* it is (i.e. return a clone).  in the example mentioned at
* the start of this method, this will happen when the operand
* is x2.b and childrsn is either "select i,j from t1" or
* "select i,j from t2", in which case the operand does not
* apply to childrsn.  when we get here and try to map the
* "x1.j" operand, though, the following "contains" check will
* return true and thus we can go ahead and return a scoped
* version of that operand.
*/
if   parentrsnstables contains crtables
return  columnreference cr getclone
/* find the target resultcolumn in the received result set.  at
* this point we know that we do in fact need to scope the column
* reference for childrsn, so go ahead and do it.  the way in
* which we get the scope target column differs depending on
* if childrsn corresponds to the left or right child of the
* union node.  before explaining that, though, note that it's
* not good enough to just search for the target column by
* name.  the reason is that it's possible the name provided
* for the column reference to be scoped doesn't match the
* name of the actual underlying column.  ex.
*
*  select * from
*    (select i,j from t1 union select i,j from t2) x1 (x,y),
*    (select a,b from t3 union select a,b from t4) x2
*  where x1.x = x2.b;
*
* if we were scoping "x1.x" and we searched for "x" in the
* childrsn "select i,j from t1" we wouldn't find it.
*
* it is similarly incorrect to search for the target column
* by position (derby-1633).  this is a bit more subtle, but
* if the child to which we're scoping is a subquery whose rcl
* does not match the column ordering of the rcl for cr's source
* result set, then searching by column position can yield the
* wrong results, as well.  for a detailed example of how this
* can happen, see the fix description attached to derby-1633.
*
* so how do we find the target column, then? as mentioned
* above, the way in which we get the scope target column
* differs depending on if childrsn corresponds to the left
* or right child of the parent union node.  and that said,
* we can tell if we're scoping a left child by looking at
* "whichrc" argument: if it is -1 then we know we're scoping
* to the left child of a union; otherwise we're scoping to
* the right child.
*/
if  whichrc     1
/*
* for the left side we start by figuring out what the source
* result set and column position for "cr" are.  then, since
* a) cr must be pointing to a result column in the parentrsn's
* resultcolumnlist,  b) we know that the parent rsn is a
* setoperatornode (at least for now, since we only get here
* for union nodes), and c) setopnode's rcls are built from the
* left child's rcl (see bindresultcolumns() in setoperatornode),
* we know that if we search the child's rcl for a reference
* whose source result column is the same as cr's source result
* column, we'll find a match.  once found, the position of the
* matching column w.r.t childrsn's rcl will be stored in the
* whichrc parameter.
*/
// find the source result set and source column position of cr.
int  sourcecolpos   new int   1
resultsetnode sourcersn   cr getsourceresultset sourcecolpos
if  sanitymanager debug
/* we assumed that if we made it here "cr" was pointing
* to a base table somewhere down the tree.  if that's
* true then sourcersn won't be null.  make sure our
* assumption was correct.
*/
sanitymanager assert sourcersn    null
cr gettablename
cr getcolumnname
// now search for the corresponding resultcolumn in childrsn.
rc   childrsn getresultcolumns
getresultcolumn sourcecolpos  sourcersn  whichrc
else
/*
* for the right side the story is slightly different.  if we were
* to search the right child's rcl for a reference whose source
* result column was the same as cr's, we wouldn't find it.  this
* is because cr's source result column comes from the left child's
* rcl and thus the right child doesn't know about it.  that said,
* though, for set operations like union, the left and right rcl's
* are correlated by position--i.e. the operation occurs between
* the nth column in the left rcl and the nth column in the right
* rcl.  so given that we will already have found the scope target
* in the left child's rcl at the position in whichrc, we know that
* that scope target for the right child's rcl is simply the
* whichrc'th column in that rcl.
*/
rc   childrsn getresultcolumns   getresultcolumn whichrc
// rc shouldn't be null; if there was no matching resultcolumn at all,
// then we shouldn't have made it this far.
if  sanitymanager debug
sanitymanager assert rc    null
cr gettablename
cr getcolumnname
/* if the resultcolumn we found has an expression that is a
* columnreference, then that column reference has all of the
* info we need.
*
* it is, however, possible that the resultcolumn's expression
* is not a columnreference.  for example, the expression would
* be a constant expression if childrsn represented something
* like:
*
*   select 1, 1 from t1
*
* in this case the expression does not directly reference a
* column in the underlying result set and is therefore
* "scoped" as far as it can go.  this means that the scoped
* predicate will not necessarily have column references on
* both sides, even though the predicate that we're scoping
* will.  that's not a problem, though, since a predicate with
* a column reference on one side and a non-columnreference
* on the other is still valid.
*/
if  rc getexpression   instanceof columnreference
/* we create a clone of the column reference and mark
* the clone as "scoped" so that we can do the right
* thing when it comes time to remap the predicate;
* see predicate.remapscopedpred() for more.
*/
columnreference cref    columnreference
columnreference rc getexpression    getclone
cref markasscoped
return cref
/* else just return rc's expression.  this means the scoped
* predicate will have one operand that is _not_ a column
* reference--but that's okay, so long as we account for
* that when pushing/remapping the scoped predicate down
* the query tree (see esp. "isscopedtosourceresultset()"
* in predicate.java).
*/
return rc getexpression
/**
* determine whether or not the received valuenode (which will
* usually be a columnreference) references either the received
* opttable or else a base table in the subtree beneath that
* opttable.
*
* @param valnode the valuenode that has the reference(s).
* @param opttable the table/subtree node to which we're trying
*  to find a reference.
* @param forpush whether or not we are searching with the intent
*  to push this operator to the target table.
* @param walkopttablesubtree should we walk the subtree beneath
*  opttable to find base tables, or not?  will be false if we've
*  already done it for the left operand and now we're here
*  for the right operand.
* @return true if valnode contains a reference to opttable or
*  to a base table in the subtree beneath opttable; false
*  otherwise.
*/
private boolean valnodereferencesopttable valuenode valnode
fromtable opttable  boolean forpush  boolean walkopttablesubtree
// following call will initialize/reset the btnvis,
// valnodebasetables, and optbasetables fields of this object.
initbasetablevisitor opttable getreferencedtablemap   size
walkopttablesubtree
boolean found   false
try
// find all base tables beneath opttable and load them
// into this object's optbasetables map.  this is the
// list of table numbers we'll search to see if the
// value node references any tables in the subtree at
// or beneath opttable.
if  walkopttablesubtree
buildtablenumlist opttable  forpush
// now get the base table numbers that are in valnode's
// subtree.  in most cases valnode will be a columnreference
// and this will return a single base table number.
btnvis settablemap valnodebasetables
valnode accept btnvis
// and finally, see if there's anything in common.
valnodebasetables and optbasetables
found    valnodebasetables getfirstsetbit       1
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert
se
return found
/**
* initialize the fields used for retrieving base tables in
* subtrees, which allows us to do a more extensive search
* for table references.  if the fields have already been
* created, then just reset their values.
*
* @param numtablesinquery used for creating jbitsets that
*  can hold table numbers for the query.
* @param initoptbasetables whether or not we should clear out
*  or initialize the optbasetables bit set.
*/
private void initbasetablevisitor int numtablesinquery
boolean initoptbasetables
if  valnodebasetables    null
valnodebasetables   new jbitset numtablesinquery
else
valnodebasetables clearall
if  initoptbasetables
if  optbasetables    null
optbasetables   new jbitset numtablesinquery
else
optbasetables clearall
// now create the visitor.  we give it valnodebasetables
// here for sake of creation, but this can be overridden
// (namely, by optbasetables) by the caller of this method.
if  btnvis    null
btnvis   new basetablenumbersvisitor valnodebasetables
/**
* create a set of table numbers to search when trying to find
* which (if either) of this operator's operands reference the
* received target table.  at the minimum this set should contain
* the target table's own table number.  after that, if we're
* _not_ attempting to push this operator (or more specifically,
* the predicate to which this operator belongs) to the target
* table, we go on to search the subtree beneath the target
* table and add any base table numbers to the searchable list.
*
* @param ft target table for which we're building the search
*  list.
* @param forpush whether or not we are searching with the intent
*  to push this operator to the target table.
*/
private void buildtablenumlist fromtable ft  boolean forpush
throws standardexception
// start with the target table's own table number.  note
// that if ft is an instanceof singlechildresultset, its
// table number could be negative.
if  ft gettablenumber   >  0
optbasetables set ft gettablenumber
if  forpush
// nothing else to do.
return
// add any table numbers from the target table's
// reference map.
optbasetables or ft getreferencedtablemap
// the table's reference map is not guaranteed to have
// all of the tables that are actually used--for example,
// if the table is a projectrestrictnode or a joinnode
// with a subquery as a child, the ref map will contain
// the number for the prn above the subquery, but it
// won't contain the table numbers referenced by the
// subquery.  so here we go through and find all base
// table numbers beneath the target node.
btnvis settablemap optbasetables
ft accept btnvis
return