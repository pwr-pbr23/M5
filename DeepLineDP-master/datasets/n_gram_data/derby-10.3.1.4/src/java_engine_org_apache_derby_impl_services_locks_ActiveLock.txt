/*
derby - class org.apache.derby.impl.services.locks.activelock
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services locks
import org apache derby iapi services locks compatibilityspace
import org apache derby iapi services locks lockable
import org apache derby iapi services locks c_lockfactory
import org apache derby iapi error standardexception
/**
a lock represents a granted or waiting lock request.
<br>
mt - mutable - immutable identity : thread aware
*/
public final class activelock extends lock
/**
set to true if the object waiting on this thread should wake up,
mt - mutable - java synchronized(this)
*/
byte wakeupnow
/**
set to true if the lock potentially could be granted.
mt - mutable - single thread required
*/
boolean potentiallygranted
/**
if true then this lock can be granted even if
it is not the first lock request on the wait queue.
this can occur if the compatibility space already holds
a lock on the object.
*/
protected boolean canskip
/**
initialize the lock, should be seen as part of the constructor. a future
version of this class may become mutable - mutable identity.
mt - single thread required
*/
protected activelock compatibilityspace space  lockable ref
object qualifier
super space  ref  qualifier
/**
set the potentially granted flag, returns true if the
flag changed its state.
mt - single thread required
*/
protected boolean setpotentiallygranted
if   potentiallygranted
potentiallygranted   true
return true
return false
/**
clear the potentially granted flag.
mt - single thread required
*/
protected void clearpotentiallygranted
potentiallygranted   false
/**
wait for a lock to be granted, returns when the lock is granted.
<p>
the sleep wakeup scheme depends on the two booleans wakeupnow & potentiallygranted.
mt - single thread required - and assumed to be the thread requesting the lock.
@return true if the wait ended early (ie. someone else woke us up).
@exception standardexception timeout, deadlock or thread interrupted
*/
protected synchronized byte waitforgrant int timeout
throws standardexception
if  wakeupnow    constants waiting_lock_in_wait
try
if  timeout    c_lockfactory wait_forever
wait
else if  timeout > 0
wait timeout
catch  interruptedexception ie
throw standardexception interrupt ie
byte why   wakeupnow
wakeupnow   constants waiting_lock_in_wait
return why
/**
wake up anyone sleeping on this lock.
mt - thread safe
*/
protected synchronized void wakeup byte why
// if we were picked as a deadlock victim then don't
// override the wakeup reason with another one.
if  wakeupnow    constants waiting_lock_deadlock
wakeupnow   why
notify