/*
derby - class org.apache.derby.impl.store.access.btree.btreemaxscan
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access rowutil
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby iapi store raw fetchdescriptor
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi store access backingstorehashtable
/**
a b-tree scan controller corresponds to an instance of an open b-tree scan.
<p>
<b>concurrency notes<\b>
<p>
the concurrency rules are derived from openbtree.
<p>
@see openbtree
**/
/**
a btreescan implementation that provides the 90% solution to the max on
btree problem.  if the row is the last row in the btree it works very
efficiently.  this implementation will be removed once backward scan is
fully functional.
**/
public class btreemaxscan extends btreescan
/**************************************************************************
* private methods of this class:
**************************************************************************
*/
/**
* fetch the maximum non-deleted row from the table.
*
* @exception  standardexception  standard exception policy.
**/
private boolean fetchmaxrowfrombeginning
btreerowposition        pos
datavaluedescriptor   fetch_row
throws standardexception
int                 ret_row_count       0
recordhandle        max_rh              null
// we need to scan until we hit the end of the table or until we
// run into a null.  use this template to probe the "next" row so
// that if we need to finish, fetch_row will have the right value.
datavaluedescriptor check_row_template   new datavaluedescriptor
check_row_template   fetch_row getclone
fetchdescriptor check_row_desc   rowutil getfetchdescriptorconstant 1
// reopen the scan for reading from the beginning of the table.
reopenscan
datavaluedescriptor  null
scancontroller na
qualifier  null
datavaluedescriptor  null
scancontroller na
positionatstartforforwardscan pos
// at this point:
// current_page is latched.  current_slot is the slot on current_page
// just before the "next" record this routine should process.
// loop through successive leaf pages and successive slots on those
// leaf pages.  stop when either the last leaf is reached. at any
// time in the scan fetch_row will contain "last" non-deleted row
// seen.
boolean nulls_not_reached   true
while   pos current_leaf    null     nulls_not_reached
while   pos current_slot   1  < pos current_leaf page recordcount
// unlock the previous row if doing read.
if  pos current_rh    null
this getlockingpolicy   unlockscanrecordafterread
pos  init_forupdate
// current_rh is used to track which row we need to unlock,
// at this point no row needs to be unlocked.
pos current_rh   null
// move scan current position forward.
pos current_slot
this stat_numrows_visited
// get current record handle for positioning but don't read
// data until we verify it is not deleted.  rh is needed
// for repositioning if we lose the latch.
recordhandle rh
pos current_leaf page fetchfromslot
recordhandle  null
pos current_slot
check_row_template

true
// lock the row.
boolean latch_released
this getlockingpolicy   lockscanrow
this  this getconglomerate    pos
false
init_lock_fetch_desc
pos current_lock_template
pos current_lock_row_loc
false  init_forupdate  lock_operation
// special test to see if latch release code works
if  sanitymanager debug
latch_released
test_errors
this
false
this getlockingpolicy
pos current_leaf  latch_released
// at this point we have successfully locked this record, so
// remember the record handle so that it can be unlocked if
// necessary.  if the above lock deadlocks, we will not try
// to unlock a lock we never got in close(), because current_rh
// is null until after the lock is granted.
pos current_rh   rh
if  latch_released
// lost latch on page in order to wait for row lock.
// because we have scan lock on page, we need only
// call reposition() which will use the saved record
// handle to reposition to the same spot on the page.
// we don't have to search the
// tree again, as we have the a scan lock on the page
// which means the current_rh is valid to reposition on.
if   reposition pos  false
if  sanitymanager debug
// can't fail while with scan lock
sanitymanager throwassert
if  pos current_leaf page isdeletedatslot pos current_slot
this stat_numdeleted_rows_visited
if  check_row_template isnull
// nulls sort at high end and are not to be returned
// by max scan, so search is over, return whatever is
// in fetch_row.
nulls_not_reached   false
break
else if  check_row_template isnull
nulls_not_reached   false
break
else
pos current_leaf page fetchfromslot
pos current_rh
pos current_slot  fetch_row  init_fetchdesc
true
stat_numrows_qualified
max_rh   pos current_rh
// move position of the scan to slot 0 of the next page.  if there
// is no next page current_page will be null.
positionatnextpage pos
this stat_numpages_visited
// reached last leaf of tree.
positionatdonescan pos
// we need to decrement when we stop scan at the end of the table.
this stat_numpages_visited
return max_rh    null
/**************************************************************************
* protected implementation of abstract methods of btreescan class:
**************************************************************************
*/
/**
* disallow fetchrows on this scan type.
* <p>
* @exception  standardexception  standard exception policy.
**/
protected int fetchrows
btreerowposition        pos
datavaluedescriptor row_array
rowlocation           rowloc_array
backingstorehashtable   hash_table
long                    max_rowcnt
int                   key_column_numbers
throws standardexception
throw standardexception newexception
sqlstate btree_unimplemented_feature
/**
* position scan at "start" position of the scan.
* <p>
* positions the scan to the slot just after the first record to be
* returned from the backward scan.  returns the start page latched, and
* sets "current_slot" to the slot number just right of the first slot
* to return.
* <p>
*
* @exception  standardexception  standard exception policy.
**/
protected void positionatstartposition
btreerowposition    pos
throws standardexception
boolean         exact
// this routine should only be called from first next() call //
if  sanitymanager debug
sanitymanager assert this scan_state             scan_init
sanitymanager assert pos current_rh             null
sanitymanager assert pos current_positionkey            null
sanitymanager assert pos current_scan_pageno    0
// loop until you can lock the row previous to the first row to be
// returned by the scan, while holding the page latched, without
// waiting.  if you have to wait, drop the latch, wait for the lock -
// which makes it likely if you wait for the lock you will loop just
// once, find the same lock satisfies the search and since you already
// have the lock it will be granted.
while  true
// find the starting page and row slot, must start at root and
// search either for leftmost leaf, or search for specific key.
controlrow root   controlrow get this  btree rootpageid
// include search of tree in page visited stats.
stat_numpages_visited    root getlevel     1
if  init_startkeyvalue    null
// no start given, position at last slot + 1 of rightmost leaf
pos current_leaf    leafcontrolrow  root searchright this
pos current_slot   pos current_leaf page recordcount
exact       false
else
// only max needed, no start position supported.
throw standardexception newexception
sqlstate btree_unimplemented_feature
// backward scan initial positioning will request a previous
// key lock for initial positioning.  the actual scan will have
// to make 2 lock requests per row fetch, one for a previous key
// and one for lock on row it is positioned on.  optimizations
// can be made depending on isolation level.
//
// note that this is not a "previous key" lock as the row we are
// locking is the max row to return.  get the scan lock at the
// same time.
pos current_slot
boolean latch_released
this getlockingpolicy   lockscanrow
this  this getconglomerate    pos
true
init_lock_fetch_desc
pos current_lock_template
pos current_lock_row_loc
false  init_forupdate  lock_operation
pos current_slot
// special test to see if latch release code works
if  sanitymanager debug
latch_released
test_errors
this
true
this getlockingpolicy    pos current_leaf  latch_released
if  latch_released
// lost latch on pos.current_leaf, search the tree again.
pos current_leaf   null
continue
else
// success! got all the locks, while holding the latch.
break
this scan_state            scan_inprogress
pos current_scan_pageno   pos current_leaf page getpagenumber
if  sanitymanager debug
sanitymanager assert pos current_leaf    null
/**************************************************************************
* public methods of this class:
**************************************************************************
*/
/**
* fetch the maximum row in the table.
* <p>
* utility routine used by both fetchset() and fetchnextgroup().
*
* @exception  standardexception  standard exception policy.
**/
public boolean fetchmax
datavaluedescriptor   fetch_row
throws standardexception
btreerowposition    pos             scan_position
int                 ret_row_count   0
if  sanitymanager debug
sanitymanager assert this container    null
if  this scan_state    btreescan scan_inprogress
// get current page of scan, with latch
// reposition the scan at the row just before the next one to
// return.
// this routine handles the mess of repositioning if the row or
// the page has disappeared. this can happen if a lock was not
// held on the row while not holding the latch (can happen if
// this scan is read uncommitted).
if   reposition scan_position  true
if  sanitymanager debug
sanitymanager throwassert
else if  this scan_state    scan_init
// 1st positioning of scan (delayed from openscan).
positionatstartposition scan_position
else
if  sanitymanager debug
sanitymanager assert this scan_state    scan_done
return false
// at this point:
// current_page is latched.  current_slot is the slot on current_page
// just "right" of the "next" record this routine should process.
boolean max_found   false
// if we can find a non-deleted row on this page then it is easy.
if   pos current_slot   1  > 0
// move scan current position forward.
pos current_slot
while  pos current_slot > 0
this stat_numrows_visited
// get current record handle for positioning but don't read
// data until we verify it is not deleted.  rh is needed
// for repositioning if we lose the latch.
recordhandle rh
pos current_leaf page fetchfromslot
recordhandle  null
pos current_slot  fetch_row  init_fetchdesc
true
boolean latch_released
this getlockingpolicy   lockscanrow
this  this getconglomerate    pos
false
init_lock_fetch_desc
pos current_lock_template
pos current_lock_row_loc
false  init_forupdate  lock_operation
// at this point we have successfully locked this record, so
// remember the record handle so that it can be unlocked if
// necessary.  if the above lock deadlocks, we will not try
// to unlock a lock we never got in close(), because current_rh
// is null until after the lock is granted.
pos current_rh   rh
if  latch_released
// had to wait on lock while lost latch, now last page of
// index may have changed, give up on "easy/fast" max scan.
pos current_leaf   null
break
if  pos current_leaf page isdeletedatslot pos current_slot
this stat_numdeleted_rows_visited
pos current_rh_qualified   false
else if  fetch_row isnull
pos current_rh_qualified   false
else
pos current_rh_qualified   true
if  pos current_rh_qualified
// return the qualifying max row.
// found qualifying row.  are we done fetching rows for the
// group?
ret_row_count
stat_numrows_qualified
// current_slot is invalid after releasing latch
pos current_slot   page invalid_slot_number
max_found   true
break
else
pos current_slot
if  pos current_leaf    null
// done with "last" page in table.
pos current_leaf release
pos current_leaf   null
// reached last leaf of tree.
positionatdonescan scan_position
if   max_found
// max row in table was not last row in table
max_found   fetchmaxrowfrombeginning scan_position  fetch_row
return max_found