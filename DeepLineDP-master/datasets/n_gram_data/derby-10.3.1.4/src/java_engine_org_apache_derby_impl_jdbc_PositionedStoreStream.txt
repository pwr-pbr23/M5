/*
derby - org.apache.derby.impl.jdbc.positionedstorestream
licensed to the apache software foundation (asf) under one
or more contributor license agreements.  see the notice file
distributed with this work for additional information
regarding copyright ownership.  the asf licenses this file
to you under the apache license, version 2.0 (the
"license"); you may not use this file except in compliance
with the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing,
software distributed under the license is distributed on an
"as is" basis, without warranties or conditions of any
kind, either express or implied.  see the license for the
specific language governing permissions and limitations
under the license.
*/
package org apache derby impl jdbc
import java io eofexception
import java io ioexception
import java io inputstream
import org apache derby iapi error standardexception
import org apache derby iapi types resetable
/**
* a wrapper-stream able to reposition the underlying store stream.
* <p>
* where a user expects the underlying stream to be at a given position,
* {@link #reposition} must be called with the expected position first. a use
* case for this scenario is the lob objects, where you can request a stream and
* at the same time (this does not mean concurrently) query the lob about its
* length or ask to get a part of the lob returned. such multiplexed operations
* must result in consistent and valid data, and to achieve this the underlying
* store stream must be able to reposition itself.
*
* <em>synchronization</em>: access to instances of this class must be
* externally synchronized on the connection synchronization object. there are
* two reasons for this:
* <ul> <li>access to store must be single threaded.
*      <li>this class is not thread safe, and calling the various methods from
*          different threads concurrently can result in inconsistent position
*          values. to avoid redundant internal synchronization, this class
*          assumes and <b>requires</b> external synchronization (also called
*          client-side locking).
* </ul>
* @see embedconnection#getconnectionsynchronization
*/
//@notthreadsafe
public class positionedstorestream
extends inputstream
implements resetable
/** underlying store stream serving bytes. */
//@guardedby("embedconnection.getconnectionsynchronization()")
private final inputstream stream
/** convenience reference to the stream as a resettable stream. */
//@guardedby("embedconnection.getconnectionsynchronization()")
private final resetable resettable
/**
* position of the underlying store stream.
* note that the position is maintained by this class, not the underlying
* store stream itself.
* <em>future improvement</em>: add this functionality to the underlying
* store stream itself to avoid another level in the stream stack.
*/
//@guardedby("embedconnection.getconnectionsynchronization()")
private long pos   0l
/**
* creates a positioned store stream on top of the specified resettable
* stream.
*
* @param in a {@link resetable}-stream
* @throws classcastexception if the inputstream does not implement
*      {@link resetable}
*/
public positionedstorestream inputstream in
this stream   in
this resettable    resetable in
/**
* reads a number of bytes from the underlying stream and stores them in the
* specified byte array.
*
* @return the actual number of bytes read, or -1 if the end of the stream
*      is reached.
* @throws ioexception if an i/o error occurs
*/
public int read byte b
throws ioexception
int ret   this stream read b
this pos    ret
return ret
/**
* reads a number of bytes from the underlying stream and stores them in the
* specified byte array at the specified offset.
*
* @return the actual number of bytes read, or -1 if the end of the stream
*      is reached.
* @throws ioexception if an i/o error occurs
*/
public int read byte b  int off  int len
throws ioexception
int ret   this stream read b  off  len
this pos    ret
return ret
/**
* reads a single byte from the underlying stream.
*
* @return the next byte of data, or -1 if the end of the stream is reached.
* @throws ioexception if an i/o error occurs
*/
public int read
throws ioexception
int ret   this stream read
if  ret >  1
this pos
return ret
/**
* skips up to the specified number of bytes from the underlying stream.
*
* @return the actual number of bytes skipped.
* @throws ioexception if an i/o error occurs
*/
public long skip long toskip
throws ioexception
long ret   this stream skip toskip
this pos    ret
return ret
/**
* resets the resettable stream.
*
* @throws ioexception
* @throws standardexception if resetting the stream in store fails
* @see resetable#resetstream
*/
public void resetstream
throws ioexception  standardexception
this resettable resetstream
this pos   0l
/**
* initialize the resettable stream for use.
*
* @throws standardexception if initializing the store in stream fails
* @see resetable#initstream
*/
public void initstream
throws standardexception
this resettable initstream
this pos   0l
/**
* closes the resettable stream.
*
* @see resetable#closestream
*/
public void closestream
this resettable closestream
/**
* repositions the underlying store stream to the requested position.
* <p>
* repositioning is required because there can be several uses of the store
* stream, which changes the position of it. if a class is dependent on the
* underlying stream not changing its position, it must call reposition with
* the position it expects before using the stream again.
*
* @throws ioexception if reading from the store stream fails
* @throws standardexception if resetting the store in stream fails, or
*      some other exception happens in store
* @see #getposition
*/
public void reposition long requestedpos
throws ioexception  standardexception
if  this pos < requestedpos
// reposition from current position.
skipfully requestedpos   this pos
this pos   requestedpos
else if  this pos > requestedpos
// reposition from start.
this resettable resetstream
skipfully requestedpos
this pos   requestedpos
/**
* returns the current position of the underlying store stream.
*
* @return current byte position of the store stream.
*/
public long getposition
return this pos
/**
* skip exactly the requested number of bytes.
*
* @throws eofexception if eof is reached before all bytes are skipped
* @throws ioexception if reading from the stream fails
*/
private void skipfully long toskip
throws ioexception
long remaining   toskip
while  remaining > 0
long skippednow   this stream skip remaining
if  skippednow    0
if  this stream read       1
throw new eofexception
remaining
else
skippednow   1
remaining    skippednow
end class positionedstorestream