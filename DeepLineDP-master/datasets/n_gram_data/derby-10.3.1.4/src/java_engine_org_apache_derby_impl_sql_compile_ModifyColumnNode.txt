/*
derby - class org.apache.derby.impl.sql.compile.modifycolumnnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary defaultdescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary constraintdescriptorlist
import org apache derby iapi sql dictionary keyconstraintdescriptor
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi types typeid
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types stringdatavalue
import org apache derby iapi reference sqlstate
import org apache derby impl sql execute columninfo
import org apache derby catalog typedescriptor
import org apache derby catalog uuid
import org apache derby catalog types defaultinfoimpl
/**
* a modifycolumnnode represents a modify column in an alter table statement.
*
*/
public class modifycolumnnode extends columndefinitionnode
int		columnposition    1
uuid	olddefaultuuid
/**
* get the uuid of the old column default.
*
* @return the uuid of the old column default.
*/
uuid getolddefaultuuid
return olddefaultuuid
/**
* get the column position for the column.
*
* @return the column position for the column.
*/
public int getcolumnposition
if  sanitymanager debug
sanitymanager assert columnposition > 0
return columnposition
/**
* check the validity of a user type.  checks that
* 1. the column type is either varchar, ....
* 2. is the same type after the alter.
* 3. length is greater than the old length.
*
* @exception standardexception		thrown on error
*/
public void checkusertype tabledescriptor td
throws standardexception
if  getnodetype      c_nodetypes modify_column_type_node
return 				   nothing to do if user not changing length
columndescriptor cd   td getcolumndescriptor name
if  cd    null
throw standardexception newexception
sqlstate lang_column_not_found_in_table  name  td getname
datatypedescriptor oldtype   cd gettype
datatypeservices
getdatatypeservices   getnullabilitytype oldtype isnullable
// can't change types yet.
if    oldtype gettypeid   equals getdatatypeservices   gettypeid
throw standardexception newexception
sqlstate lang_modify_column_change_type  name
// can only alter the length of varchar, nvarchar, bitvarying columns
string typename   getdatatypeservices   gettypename
if    typename equals typeid national_varchar_name
typename equals typeid varchar_name
typename equals typeid varbit_name
throw standardexception newexception
sqlstate lang_modify_column_invalid_type
// cannot decrease the length of a column
if  getdatatypeservices   getmaximumwidth   < oldtype getmaximumwidth
throw standardexception newexception
sqlstate lang_modify_column_invalid_length  name
/**
* if the type of a column is being changed (for mulan, the length of the
* column is being increased then make sure that this does not violate
* any key constraints;
* the column being altered is
*   1. part of foreign key constraint
*         ==> error. this references a primary key constraint and the
*             type & lengths of the pkey/fkey must match exactly.
*   2. part of a unique/primary key constraint
*         ==> ok if no fkey references this constraint.
*         ==> error if any fkey in the system references this constraint.
*
* @param td		the table descriptor on which the alter is being done.
*
* @exception standardexception		thrown on error.
*
*/
public void checkexistingconstraints tabledescriptor td
throws standardexception
if   getnodetype      c_nodetypes modify_column_type_node
getnodetype      c_nodetypes modify_column_constraint_node
getnodetype      c_nodetypes modify_column_constraint_not_null_node
return
datadictionary dd   getdatadictionary
constraintdescriptorlist cdl   dd getconstraintdescriptors td
int intarray   new int
intarray   columnposition
for  int index   0  index < cdl size    index
constraintdescriptor existingconstraint
cdl elementat index
if    existingconstraint instanceof keyconstraintdescriptor
continue
if   existingconstraint columnintersects intarray
continue
int constrainttype   existingconstraint getconstrainttype
// cannot change the length of a column that is part of a
// foreign key constraint. must be an exact match between pkey
// and fkey columns.
if   constrainttype    datadictionary foreignkey_constraint
getnodetype      c_nodetypes modify_column_type_node
throw standardexception newexception
sqlstate lang_modify_column_fkey_constraint  name  existingconstraint getconstraintname
else
// a column that is part of a primary key or unique constraint
// is being made nullable; can't be done.
if   getnodetype
c_nodetypes modify_column_constraint_node
existingconstraint getconstrainttype
datadictionary primarykey_constraint
existingconstraint getconstrainttype
datadictionary unique_constraint
throw standardexception newexception
sqlstate lang_modify_column_existing_constraint  name
// unique key or primary key.
constraintdescriptorlist
refcdl   dd getforeignkeys existingconstraint getuuid
if  refcdl size   > 0
throw standardexception newexception
sqlstate lang_modify_column_referenced  name  refcdl elementat 0  getconstraintname
// make the statement dependent on the primary key constraint.
getcompilercontext   createdependency existingconstraint
/**
* if the column being modified is of character string type, then it should
* get it's collation from the corresponding column in the tabledescriptor.
* this will ensure that at alter table time, the existing character string
* type columns do not loose their collation type. if the alter table is
* doing a drop column, then we do not need to worry about collation info.
*
* @param td table descriptor that holds the column which is being altered
* @throws standardexception
*/
public void useexistingcollation tabledescriptor td
throws standardexception
columndescriptor cd
// first verify that the column exists
cd   td getcolumndescriptor name
if  cd    null
throw standardexception newexception sqlstate lang_column_not_found_in_table  name  td getname
//gettype() == null means we are dealing with drop column and hence
//no need to worry about collation info
if  getdatatypeservices      null
if  getdatatypeservices   gettypeid   isstringtypeid
this getdatatypeservices   setcollationtype cd gettype   getcollationtype
this getdatatypeservices   setcollationderivation stringdatavalue collation_derivation_implicit
/**
* get the action associated with this node.
*
* @return the action associated with this node.
*/
int getaction
switch  getnodetype
case c_nodetypes modify_column_default_node
if  autoinc_create_or_modify_start_increment    columndefinitionnode modify_autoincrement_restart_value
return columninfo modify_column_default_restart
else if  autoinc_create_or_modify_start_increment
columndefinitionnode modify_autoincrement_inc_value
return columninfo modify_column_default_increment
else
return columninfo modify_column_default_value
case c_nodetypes modify_column_type_node
return columninfo modify_column_type
case c_nodetypes modify_column_constraint_node
return columninfo modify_column_constraint
case c_nodetypes modify_column_constraint_not_null_node
return columninfo modify_column_constraint_not_null
case c_nodetypes drop_column_node
return columninfo drop
default
if  sanitymanager debug
sanitymanager throwassert
getnodetype
return 0
/**
* check the validity of the default, if any, for this node.
*
* @param dd		the datadictionary.
* @param td		the tabledescriptor.
*
* @exception standardexception		thrown on error
*/
void bindandvalidatedefault datadictionary dd  tabledescriptor td
throws standardexception
columndescriptor cd
// first verify that the column exists
cd   td getcolumndescriptor name
if  cd    null
throw standardexception newexception sqlstate lang_column_not_found_in_table  name  td getname
// get the uuid for the old default
defaultdescriptor defaultdescriptor   cd getdefaultdescriptor dd
olddefaultuuid    defaultdescriptor    null  ? null   defaultdescriptor getuuid
// remember the column position
columnposition   cd getposition
// no other work to do if no user specified default
if  getnodetype      c_nodetypes modify_column_default_node
return
// if the statement is not setting the column's default, then
// recover the old default and re-use it. if the statement is
// changing the start value for the auto-increment, then recover
// the old increment-by value and re-use it. if the statement is
// changing the increment-by value, then recover the old start value
// and re-use it. this way, the column alteration only changes the
// aspects of the autoincrement settings that it intends to change,
// and does not lose the other aspecs.
if  defaultnode    null
defaultinfo    defaultinfoimpl cd getdefaultinfo
if  autoinc_create_or_modify_start_increment
columndefinitionnode modify_autoincrement_restart_value
autoincrementincrement   cd getautoincinc
if  autoinc_create_or_modify_start_increment
columndefinitionnode modify_autoincrement_inc_value
autoincrementstart   cd getautoincstart
/* fill in the datatypeservices from the datadictionary */
datatypeservices   cd gettype
// now validate the default
validatedefault dd  td
private columndescriptor getlocalcolumndescriptor string name  tabledescriptor td
throws standardexception
columndescriptor cd
// first verify that the column exists
cd   td getcolumndescriptor name
if  cd    null
throw standardexception newexception
sqlstate lang_column_not_found_in_table  name  td getname
return cd
/**
* check the validity of autoincrement values in the case that we are
* modifying an existing column (includes checking if autoincrement is set
* when making a column nullable)
*/
public void validateautoincrement datadictionary dd  tabledescriptor td  int tabletype
throws standardexception
columndescriptor cd
// a column that has an autoincrement default can't be made nullable
if  getnodetype      c_nodetypes modify_column_constraint_node
cd   getlocalcolumndescriptor name  td
if  cd isautoincrement
throw standardexception newexception sqlstate lang_ai_cannot_null_ai
getcolumnname
if  autoincrementverify
cd   getlocalcolumndescriptor name  td
if   cd isautoincrement
throw standardexception newexception sqlstate lang_invalid_alter_table_attributes
td getqualifiedname    name
if  isautoincrement    false
return
super validateautoincrement dd  td  tabletype
if  getdatatypeservices   isnullable
throw standardexception newexception sqlstate lang_ai_cannot_add_ai_to_nullable
getcolumnname