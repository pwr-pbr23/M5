/*
derby - class org.apache.derby.iapi.sql.dictionary.spsdescriptor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import java sql timestamp
import java util enumeration
import java util vector
import org apache derby catalog dependable
import org apache derby catalog dependablefinder
import org apache derby catalog uuid
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services context contextmanager
import org apache derby iapi services context contextservice
import org apache derby iapi services io storedformatids
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services uuid uuidfactory
import org apache derby iapi sql statement
import org apache derby iapi sql storablepreparedstatement
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn languageconnectionfactory
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql depend dependent
import org apache derby iapi sql depend provider
import org apache derby iapi sql depend providerinfo
import org apache derby iapi sql execute execpreparedstatement
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datatypedescriptor
/**
* a spsdescriptor describes a stored prepared statement.
* it correlates to a row in sys.sysstatements.
*
* <b>synchronization</b>: stored prepared statements
* may be cached.  thus they may be shared by multiple
* threads.  it is very hard for two threads to try
* to muck with an sps simultaeously because all ddl
* (including sps recompilation) clears out the sps
* cache and invalidates whatever statement held a
* cached sps.  but it is possible for two statements
* to do a prepare execute statment <x> at the exact
* same time, so both try to do an sps.prepare() at the
* same time during code generation, so we synchronize
* most everything except getters on immutable objects
* just to be on the safe side.
*
*
*/
public class spsdescriptor extends tupledescriptor
implements uniquesqlobjectdescriptor  dependent  provider
/**
* statement types.
* <ul>
* <li> sps_type_trigger	- trigger (<b>not implemented</b>) </li>
* <li> sps_type_explain	- explain (<b>not implemented</b>) </li>
* <li> sps_type_regular	- catchall</li>
* </ul>
*/
public static final char sps_type_trigger
public static final char sps_type_regular
public static final char sps_type_explain
/**
interface to this class is:
<ol>
<li>public void prepare() throws standardexception;
<li>public void prepareandrelease(languageconnectioncontext lcc)
throws standardexception;
<li>public void prepareandrelease(...);
<li>public string	getqualifiedname();
<li>public char	gettype();
<li>public string gettypeasstring();
<li>public boolean isvalid();
<li>public boolean initiallycompilable();
<li>public java.sql.timestamp getcompiletime();
<li>public void setcompiletime();
<li>public string gettext();
<li>public string getusingtext();
<li>public void setusingtext(string usingtext);
<li>public void	setuuid(uuid uuid);
<li>public datatypedescriptor[] getparams() throws standardexception;
<li>public void setparams(datatypedescriptor[] params);
<li>object[] getparameterdefaults()	throws standardexception;
<li>void setparameterdefaults(object[] values);
<li>public uuid getcompschemaid();
<li>public execpreparedstatement getpreparedstatement()
throws standardexception;
<li>public execpreparedstatement getpreparedstatement(boolean recompifinvalid)
throws standardexception;
<li>public void revalidate(languageconnectioncontext lcc)
throws standardexception;
</ol>
*/
private static final int recompile   1
private static final int invalidate   0
// class contents
private schemadescriptor		sd
private string					name
private uuid					uuid
private uuid					compschemaid
private char					type
private	boolean					valid
private	string					text
private	string					usingtext
private	execpreparedstatement	preparedstatement
private	datatypedescriptor		params
private	timestamp				compiletime
/**
* old code - never used.
*/
private object			paramdefaults
private	boolean					initiallycompilable
private	boolean					lookedupparams
private uuidfactory				uuidfactory
// constructors
/**
* constructor for a sps descriptor
*
* @param datadictionary		the data dictionary that this descriptor lives in
* @param 	name 	the sps name
* @param 	uuid	the uuid
* @param 	suuid	the schema uuid
* @param 	compschemauuid	the schema uuid at compilation time
* @param	type	type
* @param 	valid	is the sps valid
* @param 	text	the text for this statement
* @param	initiallycompilable	is the statement initially compilable?
*
* @exception standardexception on error
*/
public spsdescriptor
datadictionary		datadictionary
string				name
uuid				uuid
uuid				suuid
uuid				compschemauuid
char				type
boolean				valid
string				text
boolean				initiallycompilable   throws standardexception
this  datadictionary  name  uuid  suuid  compschemauuid
type  valid  text   string  null  null  null  initiallycompilable
/**
* constructor for a sps descriptor.  used when
* constructing an sps descriptor from a row
* in sysstatements.
*
* @param	datadictionary		the data dictionary that this descriptor lives in
* @param 	name 	the sps name
* @param 	uuid	the uuid
* @param 	suuid	the schema uuid
* @param 	compschemauuid	the schema uuid at compilation time
* @param	type	type
* @param 	valid	is the sps valid
* @param 	text	the text for this statement
* @param 	usingtext	the text for the using clause supplied to
*					create or alter statement
* @param 	compiletime	the time this was compiled
* @param 	preparedstatement	the preparedstatement
* @param	initiallycompilable	is the statement initially compilable?
*
* @exception standardexception on error
*/
public spsdescriptor
datadictionary	datadictionary
string		name
uuid		uuid
uuid		suuid
uuid		compschemauuid
char		type
boolean		valid
string		text
string 		usingtext
timestamp	compiletime
execpreparedstatement	preparedstatement
boolean		initiallycompilable   throws standardexception
super  datadictionary
this name   name
this uuid   uuid
this type   type
this text   text
this usingtext   usingtext
this valid   valid
this compiletime   compiletime
this sd   datadictionary getschemadescriptor suuid  null
this preparedstatement   preparedstatement
this compschemaid   compschemauuid
this initiallycompilable   initiallycompilable
/**
* for triggers only
* <p>
* generate the class for this sps and immediately
* release it.  this is useful for cases where we
* don't want to immediately execute the statement
* corresponding to this sps (e.g. create statement).
* <p>
* <i>side effects</i>: will update and sysdepends
* with the prepared statement dependency info.
*
* @param lcc the language connection context
* @param triggertable the table descriptor to bind against.  had
* 	better be null if this isn't a trigger sps.
* @param tc the transaction controller
*
* @exception standardexception on error
*/
public final synchronized void prepareandrelease
languageconnectioncontext	lcc
tabledescriptor				triggertable
transactioncontroller       tc
throws standardexception
if  sanitymanager debug
if  triggertable    null
sanitymanager assert type    sps_type_trigger
compilestatement lcc  triggertable  tc
preparedstatement makeinvalid dependencymanager prepared_statement_release  lcc
/**
* for triggers only
* <p>
* generate the class for this sps and immediately
* release it.  this is useful for cases where we
* don't want to immediately execute the statement
* corresponding to this sps (e.g. create statement).
* <p>
* <i>side effects</i>: will update and sysdepends
* with the prepared statement dependency info.
*
* @param lcc the language connection context
* @param triggertable the table descriptor to bind against.  had
* 	better be null if this isn't a trigger sps.
*
* @exception standardexception on error
*/
public final synchronized void prepareandrelease
languageconnectioncontext	lcc
tabledescriptor				triggertable
throws standardexception
prepareandrelease lcc  triggertable   transactioncontroller null
/**
* generate the class for this sps and immediately
* release it.  this is useful for cases where we
* don't want to immediately execute the statement
* corresponding to this sps (e.g. create statement).
* <p>
* <i>side effects</i>: will update and sysdepends
* with the prepared statement dependency info.
*
* @param lcc the language connection context
*
* @exception standardexception on error
*/
public final synchronized void prepareandrelease languageconnectioncontext lcc  throws standardexception
prepareandrelease lcc   tabledescriptor null   transactioncontroller null
private void compilestatement
languageconnectioncontext	lcc
tabledescriptor				triggertable
transactioncontroller       tc
throws standardexception
contextmanager cm   lcc getcontextmanager
dependencymanager dm
providerinfo providerinfo
languageconnectionfactory	lcf   lcc getlanguageconnectionfactory
datadictionary dd   getdatadictionary
/*
** if we are a trigger, then we have to go ahead
** and locate the trigger's table descriptor and
** push it on the lcc.  this is expensive, but
** pretty atypical since trigger actions aren't
** likely to be invalidated too often.  also, when
** possible, we already have the triggertable.
*/
if  type    sps_type_trigger    triggertable    null
string uuidstr   name substring 49
triggertable   dd gettabledescriptor recreateuuid uuidstr
if  sanitymanager debug
if  triggertable    null
sanitymanager throwassert   name
if  triggertable    null
lcc pushtriggertable triggertable
// stored statements always stored as unicode.
statement 			stmt   lcf getstatement dd getschemadescriptor compschemaid  null   text  true
try
preparedstatement    execpreparedstatement  stmt preparestorable
lcc
preparedstatement
getparameterdefaults
getschemadescriptor
type    sps_type_trigger
finally
if  triggertable    null
lcc poptriggertable triggertable
//if this references a session schema table (temporary or permanent), then throw an exception
//this is if execute statement executing a statement that was created with nocompile. because
//of nocompile, we could not catch session schema table reference by the statement at
//create statement time. and hence need to catch such statements at execute statement time
//when the query is getting compiled.
if  preparedstatement referencessessionschema
throw standardexception newexception sqlstate lang_operation_not_allowed_on_session_schema_tables
setcompiletime
setparams preparedstatement getparametertypes
if     org apache derby impl sql catalog datadictionaryimpl  dd  readonlyupgrade
/*
** indicate that we are going to write the data
** dictionary.  we have probably already done this
** but it is ok to call startwriting more than once.
*/
dd startwriting lcc
dm   dd getdependencymanager
/*
** clear out all the dependencies that exist
** before we recreate them so we don't grow
** sys.sysdepends forever.
*/
dm cleardependencies lcc  this  tc
/*
** copy over all the dependencies to me
*/
dm copydependencies preparedstatement  	   from
this  	   to
false 	   persistent only
cm
tc
// mark it as valid
valid   true
/**
* gets the name of the sps.
*
* @return	a string containing the name of the statement.
*/
public final string	getname
return name
/**
* gets the full, qualified name of the statement.
*
* @return	a string containing the name of the statement.
*/
public final string	getqualifiedname
return sd getschemaname         name
/**
* gets the schemadescriptor for this sps descriptor.
*
* @return schemadescriptor	the schemadescriptor.
*/
public final schemadescriptor getschemadescriptor
return sd
/**
* gets an identifier telling what type of table this is.
* types match final ints in this interface.  currently
* returns sps_type_regular or sps_type_trigger.
*
* @return	an identifier telling what type of statement
* we are.
*/
public final char gettype
return type
/**
* simple little helper function to convert your type
* to a string, which is easier to use.
*
* @return type as a string
*/
public final string gettypeasstring
char chararray   new char
chararray   type
return new string chararray
/**
* is the statement initially compilable?
*
* @return	false if statement was created with the nocompile flag
*			true otherwise
*/
public boolean initiallycompilable     return initiallycompilable
/**
* validate the type. <b>note</b>: only sps_type_regular
* and sps_type_trigger are currently valid.
*
* @param type the type
*
* @return true/false
*/
public final static boolean validtype char type
return  type    spsdescriptor sps_type_regular
type    spsdescriptor sps_type_trigger
/**
* the time this prepared statement was compiled
*
* @return the time this class was last compiled
*/
public final synchronized timestamp getcompiletime
return compiletime
/**
* set the compile time to now
*
*/
public final synchronized void setcompiletime
compiletime   new timestamp system currenttimemillis
/**
* get the text used to create this statement.
* returns original text in a cleartext string.
*
* @return the text
*/
public final string gettext
return text
/**
* get the text of the using clause used on create
* or alter statement.
*
* @return the text
*/
public final synchronized string getusingtext
return usingtext
/**
* sets the uuid of the sps.
*
* @param uuid	the uuid of the sps to be set in the descriptor
*/
public final synchronized void setuuid uuid uuid
this uuid   uuid
/**
* gets the uuid of the sps.
*
* @return	the uuid
*/
public final uuid	getuuid
return uuid
/**
* get the array of date type descriptors for
* this statement.  currently, we do a lookup
* if we don't already have the parameters saved.
* when spses are cached, the parameters should
* be set up when the sps is constructed.
*
* @return the array of data type descriptors
*
* @exception standardexception on error
*/
public final synchronized datatypedescriptor getparams
throws standardexception
if  params    null     lookedupparams
vector v   new vector
params   getdatadictionary   getspsparams this  v
paramdefaults   new object
enumeration iterator   v elements
for  int i   0  iterator hasmoreelements    i
paramdefaults   iterator nextelement
lookedupparams   true
return params
/**
* set the list of parameters for this statement
*
* @param params	the parameter list
*/
public final synchronized void setparams datatypedescriptor params
this params   params
/**
* get the default parameter values for this
* statement.  default parameter values are
* supplied by a using clause on either a
* create or alter statement statement.
*
* @return the default parameter values
*
* @exception standardexception on error
*/
public final synchronized object getparameterdefaults
throws standardexception
if  paramdefaults    null
getparams
return paramdefaults
/**
* set the parameter defaults for this statement.
*
* @param values	the parameter defaults
*/
public final synchronized void setparameterdefaults object values
this paramdefaults   values
/**
* get the constant action for this statement
*
* @return the constant action
*/
//public final synchronized constantaction getconstantaction()
//{
//	return preparedstatement.getconstantaction();
//}
/**
* get the preparedstatement for this statement.
* if stmt is invalid or hasn't been compiled yet,
* it will be recompiled.
*
* @return the preparedstatement
*
* @exception standardexception on error
*/
public final execpreparedstatement getpreparedstatement
throws standardexception
return getpreparedstatement true
/**
* get the preparedstatement for this statement.
* expects the prepared statement to have already
* been added to sys.sysstatements.
* <p>
* side effects: will update sys.sysstatements with
* the new plan if it needs to be recompiled.
*
* @param recompifinvalid if false, never recompile even
*	if statement is invalid
*
* @return the preparedstatement
*
* @exception standardexception on error
*/
public final synchronized execpreparedstatement getpreparedstatement boolean recompifinvalid
throws standardexception
//system.out.println("preparedstatement = " + preparedstatement);
/*
** recompile if we are invalid, we don't have
** a prepared statement, or the statements activation
** has been cleared and cannot be reconstituted.
*/
if  recompifinvalid
valid
preparedstatement    null
contextmanager cm   contextservice getfactory   getcurrentcontextmanager
/*
** find the language connection context.  get
** it each time in case a connection is dropped.
*/
languageconnectioncontext lcc    languageconnectioncontext
cm getcontext languageconnectioncontext context_id
if     org apache derby impl sql catalog datadictionaryimpl   lcc getdatadictionary     readonlyupgrade
//bug 4821 - first try compiling on a nested transaction so we can release
//the locks after the compilation. but if we get lock time out on the
//nested transaction, then go ahead and do the compilation on the user
//transaction. when doing the compilation on user transaction, the locks
//acquired for recompilation will be released at the end of the user transaction.
transactioncontroller nestedtc
try
nestedtc   lcc gettransactioncompile   startnestedusertransaction false
catch  standardexception se
// if i cannot start a nested user transaction use the parent
// transaction to do all the work.
nestedtc   null
// derby-2584: if the first attempt to compile the query fails,
// we need to reset initiallycompilable to make sure the
// prepared plan is fully stored to disk. save the initial
// value here.
final boolean compilable   initiallycompilable
try
prepareandrelease lcc  null  nestedtc
updatesysstatements lcc  recompile  nestedtc
catch  standardexception se
if  se getmessageid   equals sqlstate lock_timeout
if  nestedtc    null
nestedtc commit
nestedtc destroy
nestedtc   null
// if we couldn't do this with a nested xaction, retry with
// parent-- we need to wait this time!
initiallycompilable   compilable
prepareandrelease lcc  null  null
updatesysstatements lcc  recompile  null
else throw se
finally
// no matter what, commit the nested transaction; if something
// bad happened in the child xaction lets not abort the parent
// here.
if  nestedtc    null
nestedtc commit
nestedtc destroy
return preparedstatement
/**
* get the compilation type schema id when this view
* was first bound.
*
* @return the schema uuid
*/
public final uuid getcompschemaid
return compschemaid
/**
* prints the contents of the tabledescriptor
*
* @return the contents as a string
*/
public final string tostring
if  sanitymanager debug
return
sd getschemaname     name
uuid
text
valid  ?
preparedstatement
else
return
//////////////////////////////////////////////////////
//
// provider interface
//
//////////////////////////////////////////////////////
/**
* return the stored form of this provider
*
* @see dependable#getdependablefinder
*/
public final dependablefinder getdependablefinder
return	getdependablefinder storedformatids sps_descriptor_finder_v01_id
/**
* return the name of this provider.  (useful for errors.)
*
* @return string	the name of this provider.
*/
public final string getobjectname
return name
/**
* get the provider's uuid
*
* @return string	the provider's uuid
*/
public final uuid getobjectid
return uuid
/**
* get the provider's type.
*
* @return string the provider's type.
*/
public final string getclasstype
return dependable stored_prepared_statement
//////////////////////////////////////////////////////
//
// dependent interface
//
//////////////////////////////////////////////////////
/**
* check that all of the dependent's dependencies are valid.
*
* @return true if the dependent is currently valid
*/
public final synchronized boolean isvalid
return valid
/**
* prepare to mark the dependent as invalid (due to at least one of
* its dependencies being invalid).
*
* @param action	the action causing the invalidation
* @param p		the provider
*
* @exception standardexception thrown if unable to make it invalid
*/
public final synchronized void preparetoinvalidate
provider p  int action
languageconnectioncontext lcc
throws standardexception
switch  action
/*
** things that don't affect us
*/
case dependencymanager create_view
/*
** things that force a recompile, but are
** allowed.
*/
case dependencymanager create_index
case dependencymanager create_constraint
case dependencymanager drop_constraint
case dependencymanager drop_index
case dependencymanager drop_table
case dependencymanager drop_view
case dependencymanager drop_method_alias
case dependencymanager drop_synonym
case dependencymanager alter_table
case dependencymanager rename
case dependencymanager rename_index
case dependencymanager prepared_statement_release
case dependencymanager user_recompile_request
case dependencymanager changed_cursor
case dependencymanager bulk_insert
case dependencymanager compress_table
case dependencymanager set_constraints_enable
case dependencymanager set_constraints_disable
case dependencymanager set_triggers_enable
case dependencymanager set_triggers_disable
case dependencymanager rollback
case dependencymanager internal_recompile_request
case dependencymanager create_trigger
case dependencymanager drop_trigger
case dependencymanager drop_column
case dependencymanager drop_column_restrict
case dependencymanager update_statistics
case dependencymanager drop_statistics
case dependencymanager truncate_table
break
/*
** the rest are errors
*/
default
dependencymanager dm
dm   getdatadictionary   getdependencymanager
throw standardexception newexception sqlstate lang_provider_has_dependent_s_p_s
dm getactionstring action
p getobjectname    name
/**
* mark the dependent as invalid (due to at least one of
* its dependencies being invalid).
*
* @param	action	the action causing the invalidation
*
* @exception standardexception thrown if unable to make it invalid
*/
public final synchronized void makeinvalid int action
languageconnectioncontext lcc
throws standardexception
dependencymanager dm
dm   getdatadictionary   getdependencymanager
switch  action
/*
** some things that don't affect stored prepared
** statements.
*/
case dependencymanager prepared_statement_release
case dependencymanager create_view
break
/*
** things that can invalidate a stored
** prepared statement.
*/
case dependencymanager create_index
case dependencymanager create_constraint
case dependencymanager drop_constraint
case dependencymanager drop_table
case dependencymanager drop_index
case dependencymanager drop_view
case dependencymanager drop_method_alias
case dependencymanager drop_synonym
case dependencymanager alter_table
case dependencymanager rename
case dependencymanager rename_index
case dependencymanager user_recompile_request
case dependencymanager changed_cursor
case dependencymanager bulk_insert
case dependencymanager compress_table
case dependencymanager set_constraints_enable
case dependencymanager set_constraints_disable
case dependencymanager set_triggers_enable
case dependencymanager set_triggers_disable
case dependencymanager rollback
case dependencymanager internal_recompile_request
case dependencymanager create_trigger
case dependencymanager drop_trigger
case dependencymanager drop_column
case dependencymanager drop_column_restrict
case dependencymanager update_statistics
case dependencymanager drop_statistics
case dependencymanager truncate_table
/*
** if we are already invalid, don't write ourselves
** out.  just to be safe, we'll send out an invalidate
** to our dependents either way.
*/
if  valid    true
valid   false
updatesysstatements lcc  invalidate  null
dm invalidatefor this  dm user_recompile_request  lcc
break
case dependencymanager drop_sps
//system.out.println("spsd " + preparedstatement);
dm cleardependencies lcc  this
break
default
/*
** we should never get here, since we can't have dangling references
*/
if  sanitymanager debug
sanitymanager throwassert
dm getactionstring action
break
/**
* invalidate and revalidate.  the functional equivalent
* of calling makeinvalid() and makevalid(), except it
* is optimized.
*
* @exception standardexception on error
*/
public final synchronized void revalidate languageconnectioncontext lcc
throws standardexception
/*
** mark it as invalid first to ensure that
** we don't write sysstatements 2x.
*/
valid   false
makeinvalid dependencymanager user_recompile_request  lcc
prepareandrelease lcc
updatesysstatements lcc  recompile  null
/**
* load the underlying generatd class.  this is not expected
* to be used outside of the datadictionary package.  it
* is used for optimizing class loading for sps
* cacheing.
*
* @exception standardexception on error
*/
public void loadgeneratedclass   throws standardexception
/*
** on upgrade, we null out the statement body,
** so handle that here.
*/
if  preparedstatement    null
storablepreparedstatement preparedstatement  loadgeneratedclass
/*
** update sysstatements with the changed the descriptor.
** always done in the user xact.
** <p>
** ideally, the changes to sysstatements would be made
** in a separate xact as the current user xact, but this
** is painful (you'ld need to get a new contextmanager
** and then push all of the usual langauge contexts
** onto it and then call accessmanager.gettransaction()),
** and it wont work, because the xact is in a different
** compatibility space and will self deadlock (e.g.
** in the process of call dependencymanager.makeinvalid()
** we first did a dddependablefinder.getdependable()
** which called datadictionaryimpl.getspsdescriptor()
** so we hold a lock on sys.sysstatements by the
** time we get a 2nd xact and try to drop the statement).
*/
private void updatesysstatements languageconnectioncontext lcc  int mode  transactioncontroller tc
throws standardexception
int 					colstoupdate
boolean					updatesyscolumns   recompile
//bug 4821 - we want to wait for locks if updating sysstatements on parent transaction
boolean wait   false
boolean firstcompilation   false
if  mode    recompile
recompile   true
updatesyscolumns   true
if  initiallycompilable
firstcompilation   true
initiallycompilable   true
else
recompile   false
updatesyscolumns   false
datadictionary dd   getdatadictionary
if    org apache derby impl sql catalog datadictionaryimpl  dd  readonlyupgrade
return
/*
** get busy time
*/
dd startwriting lcc
if  tc    null      bug 4821   tc will passed null if we want to use the user transaction
tc   lcc gettransactionexecute
wait   true
dd updatesps this
tc
recompile
updatesyscolumns
wait
firstcompilation
/**
* get the uuid for the given string
*
* @param idstring	the string
*
* @return the uuid
*/
private uuid recreateuuid string idstring
if  uuidfactory    null
uuidfactory   monitor getmonitor   getuuidfactory
return uuidfactory recreateuuid idstring
/** @see tupledescriptor#getdescriptortype */
public string getdescriptortype     return
/** @see tupledescriptor#getdescriptorname */
// resolve: some descriptors have getname.  some descriptors have
// gettablename, getcolumnname whatever! try and unify all of this to one
// getdescriptorname!
public string getdescriptorname     return name