/*
derby - class org.apache.derby.impl.sql.compile.basetypecompiler
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql compile
import org apache derby iapi reference sqlstate
import org apache derby iapi services loader classfactory
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql compile typecompiler
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types datavaluefactory
import org apache derby iapi types numberdatavalue
import org apache derby iapi types sqlinteger
import org apache derby iapi types typeid
import org apache derby iapi types datatypedescriptor
import org apache derby iapi services compiler localfield
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services classfile vmopcode
/**
* this is the base implementation of typecompiler
*
*/
abstract class basetypecompiler implements typecompiler
private typeid correspondingtypeid
/**
* get the method name for getting out the corresponding primitive
* java type.
*
* @return string		the method call name for getting the
*						corresponding primitive java type.
*/
public string getprimitivemethodname
if  sanitymanager debug
sanitymanager throwassert
getclass   tostring
return null
/** @see typecompiler#getmatchingnationalchartypename */
public string getmatchingnationalchartypename
return typeid national_char_name
/**
* @see typecompiler#resolvearithmeticoperation
*
* @exception standardexception		thrown on error
*/
public datatypedescriptor
resolvearithmeticoperation datatypedescriptor lefttype
datatypedescriptor righttype
string operator
throws standardexception
throw standardexception newexception sqlstate lang_binary_operator_not_supported
operator
lefttype gettypeid   getsqltypename
righttype gettypeid   getsqltypename
/**
* the caller will have pushed a datavaluefactory and a null or a value
* of the correct type (interfacename()). thus upon entry the
* stack looks like on of:
* ...,dvf,ref
* ...,dvf,null
*
* this method then sets up to call the required method
* on datavaluefactory using the nullmethodname().
* the value left on the stack will be a datavaluedescriptor
* of the correct type:
*
* ...,dvd
*
* @see typecompiler#generatenull(methodbuilder, int)
*/
public void generatenull methodbuilder mb  int collationtype
int argcount
if  pushcollationfordatavalue collationtype
mb push collationtype
argcount   2
else
argcount   1
mb callmethod vmopcode invokeinterface   string  null
nullmethodname
interfacename
argcount
/**
* the caller will have pushed a datavaluefactory and  value
* of that can be converted to the correct type, e.g. int
* for a sql integer.
*
* thus upon entry the
* stack looks like:
* ...,dvf,value
*
* if field is not null then it is used as the holder
* of the generated datavaluedescriptor to avoid object
* creations on multiple passes through this code.
* the field may contain null or a valid value.
*
* this method then sets up to call the required method
* on datavaluefactory using the datavaluemethodname().
* the value left on the stack will be a datavaluedescriptor
* of the correct type:
*
* if the field contained a valid value then generated
* code will return that value rather than a newly created
* object. if field was not-null then the generated code
* will set the value of field to be the return from
* the datavaluefactory method call. thus if the field
* was empty (set to null) when this code is executed it
* will contain the newly generated value, otherwise it
* will be reset to the same value.
*
* ...,dvd
*
* @see typecompiler#generatedatavalue(methodbuilder, int, localfield)
*/
public void generatedatavalue methodbuilder mb  int collationtype
localfield field
string				interfacename   interfacename
// push the second argument
/* if fieldname is null, then there is no
* reusable wrapper (null), else we
* reuse the field.
*/
if  field    null
mb pushnull interfacename
else
mb getfield field
int argcount
if  pushcollationfordatavalue collationtype
mb push collationtype
argcount   3
else
argcount   2
mb callmethod vmopcode invokeinterface   string  null
datavaluemethodname
interfacename
argcount
if  field    null
/* store the result of the method call in the field,
* so we can re-use the wrapper.
*/
mb putfield field
/**
return the method name to get a derby datavaluedescriptor
object of the correct type set to sql null. the method named will
be called with one argument: a holder object if pushcollationfordatavalue()
returns false, otherwise two arguments, the second being the
collationtype.
*/
abstract string nullmethodname
/**
return the method name to get a derby datavaluedescriptor
object of the correct type and set it to a specific value.
the method named will be called with two arguments, a value to set the
returned value to and a holder object if pushcollationfordatavalue()
returns false. otherwise three arguments, the third being the
collationtype.
this implementation returns "getdatavalue" to map
to the overloaded methods
datavaluefactory.getdatavalue(type, dvd type)
*/
string datavaluemethodname
return
/**
* return true if the collationtype is to be passed
* to the methods generated by generatenull and
* generatedatavalue.
*
* @param collationtype collation type of character values.
* @return true collationtype will be pushed, false collationtype will be ignored.
*/
boolean pushcollationfordatavalue int collationtype
return false
/**
* determine whether thistype is storable in othertype due to othertype
* being a user type.
*
* @param thistype	the typeid of the value to be stored
* @param othertype	the typeid of the value to be stored in
*
* @return	true if thistype is storable in othertype
*/
protected boolean usertypestorable typeid thistype
typeid othertype
classfactory cf
/*
** if the other type is user-defined, use the java types to determine
** assignability.
*/
if  othertype usertype
return cf getclassinspector   assignableto
thistype getcorrespondingjavatypename
othertype getcorrespondingjavatypename
return false
/**
* tell whether this numeric type can be converted to the given type.
*
* @param othertype	the typeid of the other type.
* @param fordatatypefunction  was this called from a scalarfunction like
*                             char() or double()
*/
public boolean numberconvertible typeid othertype
boolean fordatatypefunction
// can't convert numbers to long types
if  othertype islongconcatabletypeid
return false
// numbers can only be converted to other numbers,
// and char, (not varchars or longvarchar).
// only with the char() or varchar()function can they be converted.
boolean retval    othertype isnumerictypeid
othertype isbooleantypeid
othertype usertype
// for char  conversions, function can convert
// floating types
if  fordatatypefunction
retval   retval
othertype isfixedstringtypeid
gettypeid   isfloatingpointtypeid
retval   retval
othertype isfixedstringtypeid
gettypeid   isfloatingpointtypeid
return retval
/**
* tell whether this numeric type can be stored into from the given type.
*
* @param thistype	the typeid of this type
* @param othertype	the typeid of the other type.
* @param cf		a classfactory
*/
public boolean numberstorable typeid thistype
typeid othertype
classfactory cf
/*
** numbers can be stored into from other number types.
** also, user types with compatible classes can be stored into numbers.
*/
if   othertype isnumerictypeid
othertype isbooleantypeid
return true
/*
** if the other type is user-defined, use the java types to determine
** assignability.
*/
return usertypestorable thistype  othertype  cf
/**
* get the typeid that corresponds to this typecompiler.
*/
protected typeid gettypeid
return correspondingtypeid
/**
* get the typecompiler that corresponds to the given typeid.
*/
protected typecompiler gettypecompiler typeid typeid
return typecompilerfactoryimpl staticgettypecompiler typeid
/**
* set the typecompiler that corresponds to the given typeid.
*/
void settypeid typeid typeid
correspondingtypeid   typeid
/**
* get the storedformatid from the corresponding
* typeid.
*
* @return the storedformatid from the corresponding
* typeid.
*/
protected int getstoredformatidfromtypeid
return gettypeid   gettypeformatid
private static datavaluedescriptor gnn datavaluefactory dvf
return dvf getnullinteger  numberdatavalue  null
private static datavaluedescriptor gnn2 datavaluefactory dvf
return new sqlinteger