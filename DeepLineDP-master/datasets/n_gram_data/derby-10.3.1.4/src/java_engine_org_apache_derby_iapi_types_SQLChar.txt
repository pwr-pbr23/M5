/*
derby - class org.apache.derby.iapi.types.sqlchar
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi types
import org apache derby iapi services context contextservice
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io storable
import org apache derby iapi services io storedformatids
import org apache derby iapi services io streamstorable
import org apache derby iapi services io formatidinputstream
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi types stringdatavalue
import org apache derby iapi types numberdatavalue
import org apache derby iapi types booleandatavalue
import org apache derby iapi types concatabledatavalue
import org apache derby iapi reference sqlstate
import org apache derby iapi error standardexception
import org apache derby iapi services cache classsize
import org apache derby iapi services io arrayinputstream
import org apache derby iapi util stringutil
import org apache derby iapi services i18n localefinder
import org apache derby iapi db databasecontext
import org apache derby iapi types sqlinteger
import org apache derby iapi types sqldate
import org apache derby iapi types sqltime
import org apache derby iapi types sqltimestamp
import java io inputstream
import java io objectoutput
import java io objectinput
import java io ioexception
import java io utfdataformatexception
import java io eofexception
import java sql date
import java sql resultset
import java sql preparedstatement
import java sql sqlexception
import java sql time
import java sql timestamp
import java text collationelementiterator
import java text rulebasedcollator
import java text collationkey
import java text dateformat
import java util locale
import java util calendar
/**
* sqlchar represents a char value with ucs_basic collation.
* sqlchar may be used directly by any code when it is guaranteed
* that the required collation is ucs_basic, e.g. system columns.
*/
public class sqlchar
extends datatype implements stringdatavalue  streamstorable
/**
* threshold, that decides when we return space back to the vm
* see getstring() where it is used
*/
protected final static int return_space_threshold   4096
/**
* when we know that the array needs to grow by at least
* one byte, it is not performant to grow by just one byte
* instead this amount is used to provide a reasonable growby size.
*/
private final static int growby_for_char   64
/**
static array that can be used for blank padding.
*/
private static final char blanks   new char
static
for  int i   0  i < blanks length  i
blanks
private static void appendblanks char ca  int offset  int howmany
while  howmany > 0
int count   howmany > blanks length ? blanks length   howmany
system arraycopy blanks  0  ca  offset  count
howmany    count
offset    count
/*
* datavaluedescriptor interface
* (mostly implemented in datatype)
* casts to the
* numeric and date/time types as well, "for valid strings"
*/
/**
* @see datavaluedescriptor#getboolean
*
* @exception standardexception		thrown on error
*/
public boolean getboolean
throws standardexception
if  isnull    return false
// match jcc, match only "0" or "false" for false. no case insensitivity.
// everything else is true.
string cleanedvalue   getstring   trim
return   cleanedvalue equals       cleanedvalue equals
/**
* @see datavaluedescriptor#getbyte
* @exception standardexception thrown on failure to convert
*/
public byte	getbyte   throws standardexception
if  isnull    return  byte 0
try
return byte parsebyte getstring   trim
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_format_exception
/**
* @see datavaluedescriptor#getshort
* @exception standardexception thrown on failure to convert
*/
public short	getshort   throws standardexception
if  isnull    return  short 0
try
return short parseshort getstring   trim
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_format_exception
/**
* @see datavaluedescriptor#getint
* @exception standardexception thrown on failure to convert
*/
public int	getint   throws standardexception
if  isnull    return 0
try
return integer parseint getstring   trim
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_format_exception
/**
* @see datavaluedescriptor#getlong
* @exception standardexception thrown on failure to convert
*/
public long	getlong   throws standardexception
if  isnull    return 0
try
return long parselong getstring   trim
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_format_exception
/**
* @see datavaluedescriptor#getfloat
* @exception standardexception thrown on failure to convert
*/
public float	getfloat   throws standardexception
if  isnull    return 0
try
return new float getstring   trim    floatvalue
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_format_exception
/**
* @see datavaluedescriptor#getdouble
* @exception standardexception thrown on failure to convert
*/
public double	getdouble   throws standardexception
if  isnull    return 0
try
return new double getstring   trim    doublevalue
catch  numberformatexception nfe
throw standardexception newexception sqlstate lang_format_exception
/**
* char/varchar/long varchar implementation. convert to a bigdecimal using getstring.
*/
public int typetobigdecimal    throws standardexception
return java sql types char
/**
* @see datavaluedescriptor#getdate
* @exception standardexception thrown on failure to convert
*/
public date	getdate  calendar cal  throws standardexception
return getdate  cal  getstring    getlocalefinder
public static date getdate java util calendar cal  string str  localefinder localefinder  throws standardexception
if  str    null
return null
sqldate internaldate   new sqldate  str  false  localefinder
return internaldate getdate  cal
/**
* @see datavaluedescriptor#gettime
* @exception standardexception thrown on failure to convert
*/
public time	gettime calendar cal  throws standardexception
return gettime  cal  getstring    getlocalefinder
/**
* @exception standardexception thrown on failure to convert
*/
public static time gettime  calendar cal  string str  localefinder localefinder  throws standardexception
if  str    null
return null
sqltime internaltime   new sqltime  str  false  localefinder  cal
return internaltime gettime  cal
/**
* @see datavaluedescriptor#gettimestamp
* @exception standardexception thrown on failure to convert
*/
public timestamp gettimestamp  calendar cal  throws standardexception
return gettimestamp  cal  getstring    getlocalefinder
/**
* @see datavaluedescriptor#gettimestamp
* @exception standardexception thrown on failure to convert
*/
public static timestamp	gettimestamp java util calendar cal  string str  localefinder localefinder
throws standardexception
if  str    null
return null
sqltimestamp internaltimestamp   new sqltimestamp  str  false  localefinder  cal
return internaltimestamp gettimestamp  cal
/**
* @exception standardexception		thrown on error
*/
public object	getobject   throws standardexception
return getstring
/**
* @exception standardexception		thrown on error
*/
public inputstream	getstream   throws standardexception
return stream
/**
* @exception standardexception		thrown on error
*/
public int	getlength   throws standardexception
if  rawlength     1
return rawlength
string tmpstring   getstring
return  tmpstring    null  ?
0   tmpstring length
public string gettypename
return typeid char_name
/**
* if possible, use getchararray() if you don't really
* need a string.  getstring() will cause an extra
* char array to be allocated when it calls the the string()
* constructor (the first time through), so may be
* cheaper to use getchararray().
*
* @exception standardexception		thrown on error
*/
public string getstring   throws standardexception
if  value    null
int len   rawlength
if  len     1
// data is stored in the char[] array
value   new string rawdata  0  len
if  len > return_space_threshold
// free up this char[] array to reduce memory usage
rawdata   null
rawlength    1
// clear out the int array as well, so it will stay current
intarray   null
intlength   0
ckey   null
else if  stream    null
// data stored as a stream
try
if  stream instanceof formatidinputstream
readexternal  formatidinputstream  stream
else
readexternal new formatidinputstream stream
stream   null
// at this point the value is only in the char[]
// so call again to convert to a string
return getstring
catch  ioexception ioe
throw standardexception newexception
sqlstate lang_streaming_column_i_o_exception
ioe
return value
/**
* get a char array.  typically, this is a simple
* getter that is cheaper than getstring() because
* we always need to create a char array when
* doing i/o.  use this instead of getstring() where
* reasonable.
* <p>
* <b>warning</b>: may return a character array that has spare
* characters at the end.  must be used in conjunction
* with getlength() to be safe.
*
* @exception standardexception		thrown on error
*/
public char getchararray   throws standardexception
if  isnull
return  char null
else if  rawlength     1
return rawdata
else
// this is expensive -- we are getting a
// copy of the char array that the
// string wrapper uses.
getstring
rawdata   value tochararray
rawlength   rawdata length
// clear out the int array as well, so it will stay current
intarray   null
intlength   0
ckey   null
return rawdata
/*
* streamstorable interface :
*/
public inputstream returnstream
return stream
/**
* set this value to the on-disk format stream.
*/
public final void setstream inputstream newstream
this value   null
this rawlength    1
this stream   newstream
// clear out the int array as well, so it will stay current
intarray   null
intlength   0
ckey   null
public void loadstream   throws standardexception
getstring
/*
* storable interface, implies externalizable, typedformat
*/
/**
return my format identifier.
@see org.apache.derby.iapi.services.io.typedformat#gettypeformatid
*/
public int gettypeformatid
return storedformatids sql_char_id
/**
* see if the string value is null.
@see storable#isnull
*/
public boolean isnull
return   value    null      rawlength     1      stream    null
/**
the maximum stored size is based upon the utf format
used to stored the string. the format consists of
a two byte length field and a maximum number of three
bytes for each character.
<br>
this puts an upper limit on the length of a stored
string. the maximum stored length is 65535, these leads to
the worse case of a maximum string length of 21844 ((65535 - 2) / 3).
<br>
strings with stored length longer than 64k is handled with
the following format:
(1) 2 byte length: will be assigned 0.
(2) utf formated string data.
(3) terminate the string with the following 3 bytes:
first byte is:
+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+
second byte is:
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+
third byte is:
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+
the utf format:
writes a string to the underlying output stream using utf-8
encoding in a machine-independent manner.
<p>
first, two bytes are written to the output stream as if by the
<code>writeshort</code> method giving the number of bytes to
follow. this value is the number of bytes actually written out,
not the length of the string. following the length, each character
of the string is output, in sequence, using the utf-8 encoding
for the character.
@exception  ioexception  if an i/o error occurs.
@since      jdk1.0
@exception ioexception thrown by writeutf
@see java.io.datainputstream
*/
public void writeexternal objectoutput out  throws ioexception
// never called when value is null
if  sanitymanager debug
sanitymanager assert  isnull
string lvalue   null
char data   null
int strlen   rawlength
boolean israw
if  strlen < 0
lvalue   value
strlen   lvalue length
israw   false
else
data   rawdata
israw   true
// byte length will always be at least string length
int utflen   strlen
for  int i   0    i < strlen      utflen <  65535   i
int c   israw ? data   lvalue charat i
if   c >  0x0001      c <  0x007f
// 1 byte for character
else if  c > 0x07ff
utflen    2     3 bytes for character
else
utflen    1     2 bytes for character
boolean islongutf   false
// for length than 64k, see format description above
if  utflen > 65535
islongutf   true
utflen   0
out write  utflen >>> 8    0xff
out write  utflen >>> 0    0xff
for  int i   0   i < strlen   i
int c   israw ? data   lvalue charat i
if   c >  0x0001      c <  0x007f
out write c
else if  c > 0x07ff
out write 0xe0     c >> 12    0x0f
out write 0x80     c >>  6    0x3f
out write 0x80     c >>  0    0x3f
else
out write 0xc0     c >>  6    0x1f
out write 0x80     c >>  0    0x3f
if  islongutf
// write the following 3 bytes to terminate the string:
// (11100000, 00000000, 00000000)
out write 0xe0
out write 0
out write 0
/**
* reads in a string from the specified data input stream. the
* string has been encoded using a modified utf-8 format.
* <p>
* the first two bytes are read as if by
* <code>readunsignedshort</code>. this value gives the number of
* following bytes that are in the encoded string, not
* the length of the resulting string. the following bytes are then
* interpreted as bytes encoding characters in the utf-8 format
* and are converted into characters.
* <p>
* this method blocks until all the bytes are read, the end of the
* stream is detected, or an exception is thrown.
*
* @param      in   a data input stream.
* @exception  eofexception            if the input stream reaches the end
*               before all the bytes.
* @exception  ioexception             if an i/o error occurs.
* @exception  utfdataformatexception  if the bytes do not represent a
*               valid utf-8 encoding of a unicode string.
* @see        java.io.datainputstream#readunsignedshort()
* @see java.io.externalizable#readexternal
*/
public void readexternalfromarray arrayinputstream in
throws ioexception
arg_passer          rawdata
rawlength   in readderbyutf arg_passer
rawdata   arg_passer
// restoretonull();
value    null
stream   null
// clear out the int array, so it will stay current
intarray   null
intlength   0
ckey   null
char arg_passer   new char
public void readexternal objectinput in  throws ioexception
// if in.available() blocked at 0, use this default string size
int utflen   in readunsignedshort
int requiredlength
// minimum amount that is reasonable to grow the array
// when we know the array needs to growby at least one
// byte but we dont want to grow by one byte as that
// is not performant
int mingrowby   growby
if  utflen    0
// the object was not stored as a streaming column
// we know exactly how long it is
requiredlength   utflen
else
// the object was stored as a streaming column
// and we have a clue how much we can read unblocked
// or
// the original string was a 0 length string.
requiredlength   in available
if  requiredlength < mingrowby
requiredlength   mingrowby
char str
if   rawdata    null      requiredlength > rawdata length
str   new char
else
str   rawdata
int arraylength   str length
// set these to null to allow gc of the array if required.
rawdata   null
restoretonull
int count   0
int strlen   0
readingloop
while     count < utflen      utflen    0
int c
try
c   in readunsignedbyte
catch  eofexception eof
if  utflen    0
throw new eofexception
// this is the case for a 0 length string.
// or the string was originally streamed in
// which puts a 0 for utflen but no trailing
// e0,0,0 markers.
break readingloop
//if (c == -1)		// read eof
//{
//	if (utflen != 0)
//		throw new eofexception();
//	break;
//}
// change it to an unsigned byte
//c &= 0xff;
if  strlen >  arraylength     the char array needs to be grown
int growby   in available
// we know that the array needs to be grown by at least one.
// however, even if the input stream wants to block on every
// byte, we don't want to grow by a byte at a time.
// note, for large data (clob > 32k), it is performant
// to grow the array by atleast 4k rather than a small amount
// even better maybe to grow by 32k but then may be
// a little excess(?) for small data.
// hopefully in.available() will give a fair
// estimate of how much data can be read to grow the
// array by larger and necessary chunks.
// this performance issue due to
// the slow growth of this array was noticed since inserts
// on clobs was taking a really long time as
// the array here grew previously by 64 bytes each time
// till stream was drained.  (derby-302)
// for char, growby 64 seems reasonable, but for varchar
// clob 4k or 32k is performant and hence
// growby() is override correctly to ensure this
if  growby < mingrowby
growby   mingrowby
int newstrlength   arraylength   growby
char oldstr   str
str   new char
system arraycopy oldstr  0  str  0  arraylength
arraylength   newstrlength
/// top fours bits of the first unsigned byte that maps to a
//  1,2 or 3 byte character
//
// 0000xxxx	- 0 - 1 byte char
// 0001xxxx - 1 - 1 byte char
// 0010xxxx - 2 - 1 byte char
// 0011xxxx - 3 - 1 byte char
// 0100xxxx - 4 - 1 byte char
// 0101xxxx - 5 - 1 byte char
// 0110xxxx - 6 - 1 byte char
// 0111xxxx - 7 - 1 byte char
// 1000xxxx - 8 - error
// 1001xxxx - 9 - error
// 1010xxxx - 10 - error
// 1011xxxx - 11 - error
// 1100xxxx - 12 - 2 byte char
// 1101xxxx - 13 - 2 byte char
// 1110xxxx - 14 - 3 byte char
// 1111xxxx - 15 - error
int char2  char3
char actualchar
if   c   0x80     0x00
// one byte character
count
actualchar    char  c
else if   c   0x60     0x40     we know the top bit is set here
// two byte character
count    2
if  utflen    0    count > utflen
throw new utfdataformatexception
char2   in readunsignedbyte
if   char2   0xc0     0x80
throw new utfdataformatexception
actualchar    char    c   0x1f  << 6     char2   0x3f
else if   c   0x70     0x60     we know the top bit is set here
// three byte character
count    3
if  utflen    0    count > utflen
throw new utfdataformatexception
char2   in readunsignedbyte
char3   in readunsignedbyte
if   c    0xe0      char2    0      char3    0
utflen    0
// we reached the end of a long string,
// that was terminated with
// (11100000, 00000000, 00000000)
break readingloop
if    char2   0xc0     0x80       char3   0xc0     0x80
throw new utfdataformatexception
actualchar    char    c   0x0f  << 12
char2   0x3f  << 6
char3   0x3f  << 0
else
throw new utfdataformatexception
str   actualchar
rawdata   str
rawlength   strlen
// clear out the int array, so it will stay current
intarray   null
intlength   0
ckey   null
/**
* returns the reasonable minimum amount by
* which the array can grow . see readexternal.
* when we know that the array needs to grow by at least
* one byte, it is not performant to grow by just one byte
* instead this amount is used to provide a resonable growby size.
* @return minimum reasonable growby size
*/
protected int growby
return growby_for_char     seems reasonable for a char
/**
* @see storable#restoretonull
*
*/
public void restoretonull
value   null
stream   null
rawlength    1
// clear out the int array as well, so it will stay current
intarray   null
intlength   0
ckey   null
/**
@exception standardexception thrown on error
*/
public boolean compare int op
datavaluedescriptor other
boolean orderednulls
boolean unknownrv
throws standardexception
if   orderednulls 		   nulls are unordered
if  this isnull        datavaluedescriptor  other  isnull
return unknownrv
/* when comparing string types to non-string types, we always
* convert the string type to the non-string type.
*/
if     other instanceof sqlchar
return other compare flip op   this  orderednulls  unknownrv
/* do the comparison */
return super compare op  other  orderednulls  unknownrv
/**
@exception standardexception thrown on error
*/
public int compare datavaluedescriptor other  throws standardexception
/* use compare method from dominant type, negating result
* to reflect flipping of sides.
*/
if  typeprecedence   < other typeprecedence
return    other compare this
// stringcompare deals with null as comparable and smallest
return stringcompare this   sqlchar other
/*
* cloneableobject interface
*/
/** from cloneableobject
*	shallow clone a streamstorable without objectifying.  this is used to avoid
*	unnecessary objectifying of a stream object.  the only difference of this method
*  from getclone is this method does not objectify a stream.  beetle 4896
*/
public object cloneobject
if  stream    null
return getclone
sqlchar self    sqlchar  getnewnull
self copystate this
return self
/*
* datavaluedescriptor interface
*/
/** @see datavaluedescriptor#getclone */
public datavaluedescriptor getclone
try
return new sqlchar getstring
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert    se
return null
/**
* @see datavaluedescriptor#getnewnull
*
*/
public datavaluedescriptor getnewnull
return new sqlchar
/** @see stringdatavalue#getvalue(rulebasedcollator) */
public stringdatavalue getvalue rulebasedcollator collatorforcomparison
if  collatorforcomparison    null
null collatorforcomparison means use ucs_basic for collation
return this
else
//non-null collatorforcomparison means use collator sensitive
//implementation of sqlchar
collatorsqlchar s   new collatorsqlchar collatorforcomparison
s copystate this
return s
/**
* @see datavaluedescriptor#setvaluefromresultset
*
* @exception sqlexception		thrown on error
*/
public final void setvaluefromresultset resultset resultset  int colnumber
boolean isnullable
throws sqlexception
setvalue resultset getstring colnumber
/**
set the value into a preparedstatement.
*/
public final void setinto preparedstatement ps  int position  throws sqlexception  standardexception
ps setstring position  getstring
/*
* class interface
*/
/*
* constructors
*/
/**
no-arg constructor, required by formattable.
*/
public sqlchar
public sqlchar string val
value   val
public void setvalue string thevalue
stream   null
rawlength    1
// clear out the int array as well, so it will stay current
intarray   null
intlength   0
ckey   null
value   thevalue
public void setvalue boolean thevalue  throws standardexception
// match jcc.
setvalue thevalue ?
public void setvalue int thevalue   throws standardexception
setvalue integer tostring thevalue
public void setvalue double thevalue   throws standardexception
setvalue double tostring thevalue
public void setvalue float thevalue   throws standardexception
setvalue float tostring thevalue
public void setvalue short thevalue   throws standardexception
setvalue short tostring thevalue
public void setvalue long thevalue   throws standardexception
setvalue long tostring thevalue
public void setvalue byte thevalue   throws standardexception
setvalue byte tostring thevalue
public void setvalue byte thevalue  throws standardexception
if  thevalue    null
restoretonull
return
/*
** we can't just do a new string(thevalue)
** because that method assumes we are converting
** ascii and it will take on char per byte.
** so we need to convert the byte array to a
** char array and go from there.
**
** if we have an odd number of bytes pad out.
*/
int mod    thevalue length % 2
int len    thevalue length 2    mod
char carray   new char
int cindex   0
int bindex   0
/*
** if we have a left over byte, then get
** that now.
*/
if  mod    1
carray    char  thevalue << 8
for    cindex < len  bindex  2  cindex
carray    char   thevalue << 8
thevalue   0x00ff
setvalue new string carray
/**
only to be called when an application through jdbc is setting a
sqlchar to a java.math.bigdecimal.
*/
public void setbigdecimal number bigdecimal   throws standardexception
if  bigdecimal    null
settonull
else
setvalue bigdecimal tostring
/** @exception standardexception		thrown on error */
public void setvalue date thevalue  calendar cal  throws standardexception
string strvalue   null
if  thevalue    null
if  cal    null
strvalue   thevalue tostring
else
cal settime  thevalue
stringbuffer sb   new stringbuffer
formatjdbcdate  cal  sb
strvalue  sb tostring
setvalue  strvalue
/** @exception standardexception		thrown on error */
public void setvalue time thevalue  calendar cal  throws standardexception
string strvalue   null
if  thevalue    null
if  cal    null
strvalue   thevalue tostring
else
cal settime  thevalue
stringbuffer sb   new stringbuffer
formatjdbctime  cal  sb
strvalue  sb tostring
setvalue  strvalue
/** @exception standardexception		thrown on error */
public void setvalue timestamp thevalue  calendar cal  throws standardexception
string strvalue   null
if  thevalue    null
if  cal    null
strvalue   thevalue tostring
else
cal settime  thevalue
stringbuffer sb   new stringbuffer
formatjdbcdate  cal  sb
sb append
formatjdbctime  cal  sb
int micros    thevalue getnanos     sqltimestamp fraction_to_nano 2  sqltimestamp fraction_to_nano
if  micros > 0
sb append
string microsstr   integer tostring  micros
if  microsstr length   > sqltimestamp max_fraction_digits
sb append  microsstr substring  0  sqltimestamp max_fraction_digits
else
for  int i   microsstr length    i < sqltimestamp max_fraction_digits   i
sb append
sb append  microsstr
strvalue  sb tostring
setvalue  strvalue
private void formatjdbcdate  calendar cal  stringbuffer sb
sqldate datetostring  cal get  calendar year
cal get  calendar month    calendar january   1
cal get  calendar day_of_month
sb
private void formatjdbctime  calendar cal  stringbuffer sb
sqltime timetostring  cal get  calendar hour   cal get  calendar minute   cal get  calendar second   sb
/**
* set the value from the stream which is in the on-disk format.
* @param thestream on disk format of the stream
* @param valuelength length of the logical value in characters.
*/
public final void setvalue inputstream thestream  int valuelength
setstream thestream
/**
* allow any java type to be cast to a character type using
* object.tostring.
* @see datavaluedescriptor#setobjectforcast
*
* @exception standardexception
*                thrown on failure
*/
public void setobjectforcast object thevalue  boolean instanceofresulttype
string resulttypeclassname  throws standardexception
if  thevalue    null
settonull
return
if    equals resulttypeclassname
setvalue thevalue tostring
else
super setobjectforcast thevalue  instanceofresulttype  resulttypeclassname
protected void setfrom datavaluedescriptor thevalue  throws standardexception
setvalue thevalue getstring
/**
* normalization method - this method may be called when putting
* a value into a sqlchar, for example, when inserting into a sqlchar
* column.  see normalizeresultset in execution.
*
* @param desiredtype	the type to normalize the source column to
* @param source		the value to normalize
*
*
* @exception standardexception				thrown for null into
*											non-nullable column, and for
*											truncation error
*/
public void normalize
datatypedescriptor desiredtype
datavaluedescriptor source
throws standardexception
normalize desiredtype  source getstring
protected void normalize datatypedescriptor desiredtype  string sourcevalue
throws standardexception
int	desiredwidth   desiredtype getmaximumwidth
int sourcewidth   sourcevalue length
/*
** if the input is already the right length, no normalization is
** necessary - just return the source.
*/
if  sourcewidth    desiredwidth
setvalue sourcevalue
return
/*
** if the input is shorter than the desired type, construct a new
** sqlchar padded with blanks to the right length.
*/
if  sourcewidth < desiredwidth
settonull
char ca
if   rawdata    null      desiredwidth > rawdata length
ca   rawdata   new char
else
ca   rawdata
sourcevalue getchars 0  sourcewidth  ca  0
sqlchar appendblanks ca  sourcewidth  desiredwidth   sourcewidth
rawlength   desiredwidth
return
/*
** check whether any non-blank characters will be truncated.
*/
hasnonblankchars sourcevalue  desiredwidth  sourcewidth
/*
** no non-blank characters will be truncated.  truncate the blanks
** to the desired width.
*/
string truncatedstring   sourcevalue substring 0  desiredwidth
setvalue truncatedstring
/*
** method to check for truncation of non blank chars.
*/
protected final void hasnonblankchars string source  int start  int end
throws standardexception
/*
** check whether any non-blank characters will be truncated.
*/
for  int posn   start  posn < end  posn
if  source charat posn
throw standardexception newexception sqlstate lang_string_truncation  gettypename    stringutil formatforprint source   string valueof start
///////////////////////////////////////////////////////////////
//
// variablesizedatavalue interface
//
///////////////////////////////////////////////////////////////
/**
* set the width of the to the desired value.  used
* when casting.  ideally we'd recycle normalize(), but
* the behavior is different (we issue a warning instead
* of an error, and we aren't interested in nullability).
*
* @param desiredwidth	the desired length
* @param desiredscale	the desired scale (ignored)
* @param errorontrunc	throw an error on truncation
*
* @exception standardexception		thrown when errorontrunc
*		is true and when a shrink will truncate non-white
*		spaces.
*/
public void setwidth int desiredwidth
int desiredscale     ignored
boolean errorontrunc
throws standardexception
int sourcewidth
/*
** if the input is null, nothing to do.
*/
if  getstring      null
return
sourcewidth   getlength
/*
** if the input is shorter than the desired type, construct a new
** sqlchar padded with blanks to the right length.  only
** do this if we have a sqlchar -- sqlvarchars don't
** pad.
*/
if  sourcewidth < desiredwidth
if    this instanceof sqlvarchar
stringbuffer	strbuf
strbuf   new stringbuffer getstring
for     sourcewidth < desiredwidth  sourcewidth
strbuf append
setvalue new string strbuf
else if  sourcewidth > desiredwidth    desiredwidth > 0
/*
** check whether any non-blank characters will be truncated.
*/
if  errorontrunc
hasnonblankchars getstring    desiredwidth  sourcewidth
//resolve: should issue a warning instead
/*
** truncate to the desired width.
*/
setvalue getstring   substring 0  desiredwidth
return
/*
** sql operators
*/
/**
* the = operator as called from the language module, as opposed to
* the storage module.
*
* @param left			the value on the left side of the =
* @param right			the value on the right side of the =
*
* @return	a sql boolean value telling whether the two parameters are equal
*
* @exception standardexception		thrown on error
*/
public booleandatavalue equals datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right     0
else
comparison   stringcompare left getstring
right getstring       0
return sqlboolean truthvalue left
right
comparison
/**
* the <> operator as called from the language module, as opposed to
* the storage module.
*
* @param left			the value on the left side of the <>
* @param right			the value on the right side of the <>
*
* @return	a sql boolean value telling whether the two parameters
* are not equal
*
* @exception standardexception		thrown on error
*/
public booleandatavalue notequals datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right     0
else
comparison   stringcompare left getstring
right getstring       0
return sqlboolean truthvalue left
right
comparison
/**
* the < operator as called from the language module, as opposed to
* the storage module.
*
* @param left			the value on the left side of the <
* @param right			the value on the right side of the <
*
* @return	a sql boolean value telling whether the first operand is
*			less than the second operand
*
* @exception standardexception		thrown on error
*/
public booleandatavalue lessthan datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right  < 0
else
comparison   stringcompare left getstring
right getstring    < 0
return sqlboolean truthvalue left
right
comparison
/**
* the > operator as called from the language module, as opposed to
* the storage module.
*
* @param left			the value on the left side of the >
* @param right			the value on the right side of the >
*
* @return	a sql boolean value telling whether the first operand is
*			greater than the second operand
*
* @exception standardexception		thrown on error
*/
public booleandatavalue greaterthan datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right  > 0
else
comparison   stringcompare left getstring
right getstring    > 0
return sqlboolean truthvalue left
right
comparison
/**
* the <= operator as called from the language module, as opposed to
* the storage module.
*
* @param left			the value on the left side of the <=
* @param right			the value on the right side of the <=
*
* @return	a sql boolean value telling whether the first operand is
*			less than or equal to the second operand
*
* @exception standardexception		thrown on error
*/
public booleandatavalue lessorequals datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right  <  0
else
comparison   stringcompare left getstring
right getstring    <  0
return sqlboolean truthvalue left
right
comparison
/**
* the >= operator as called from the language module, as opposed to
* the storage module.
*
* @param left			the value on the left side of the >=
* @param right			the value on the right side of the >=
*
* @return	a sql boolean value telling whether the first operand is
*			greater than or equal to the second operand
*
* @exception standardexception		thrown on error
*/
public booleandatavalue greaterorequals datavaluedescriptor left
datavaluedescriptor right
throws standardexception
boolean comparison
if   left instanceof sqlchar      right instanceof sqlchar
comparison   stringcompare  sqlchar  left   sqlchar  right  >  0
else
comparison   stringcompare left getstring
right getstring    >  0
return sqlboolean truthvalue left
right
comparison
/*
** concatable interface
*/
/**
* this method implements the char_length function for char.
*
* @param result	the result of a previous call to this method, null
*					if not called yet
*
* @return	a sqlinteger containing the length of the char value
*
* @exception standardexception		thrown on error
*
* @see concatabledatavalue#charlength(numberdatavalue)
*/
public numberdatavalue charlength numberdatavalue result
throws standardexception
if  result    null
result   new sqlinteger
if  this isnull
result settonull
return result
result setvalue this getlength
return result
/**
* @see stringdatavalue#concatenate
*
* @exception standardexception		thrown on error
*/
public stringdatavalue concatenate
stringdatavalue leftoperand
stringdatavalue rightoperand
stringdatavalue result
throws standardexception
if  leftoperand isnull      leftoperand getstring      null
rightoperand isnull      rightoperand getstring      null
result settonull
return result
result setvalue leftoperand getstring   concat rightoperand getstring
return result
/**
* this method implements the like function for char (with no escape value).
*
* @param pattern		the pattern to use
*
* @return	a sql boolean value telling whether the first operand is
*			like the second operand
*
* @exception standardexception		thrown on error
*/
public booleandatavalue like datavaluedescriptor pattern
throws standardexception
boolean likeresult
if    isnationalstring
// note that we call getlength() because the length
// of the char array may be different than the
// length we should be using (i.e. getlength()).
// see getchararray() for more info
char evalchararray   getchararray
char patternchararray     sqlchar pattern  getchararray
likeresult   like like evalchararray
getlength
patternchararray
pattern getlength
else
sqlchar patternsqlchar    sqlchar  pattern
likeresult   like like getintarray
getintlength
patternsqlchar getintarray
patternsqlchar getintlength
getlocalefinder   getcollator
return sqlboolean truthvalue this
pattern
likeresult
/**
* this method implements the like function for char with an escape value.
*
* @param pattern		the pattern to use
*
* @return	a sql boolean value telling whether the first operand is
*			like the second operand
*
* @exception standardexception		thrown on error
*/
public booleandatavalue like
datavaluedescriptor pattern
datavaluedescriptor escape
throws standardexception
boolean likeresult
if  sanitymanager debug
sanitymanager assert
pattern instanceof stringdatavalue
escape instanceof stringdatavalue
// ansi states a null escape yields 'unknown' results
//
// this method is only called when we have an escape clause, so this
// test is valid
if  escape isnull
throw standardexception newexception sqlstate lang_escape_is_null
if    isnationalstring
// note that we call getlength() because the length
// of the char array may be different than the
// length we should be using (i.e. getlength()).
// see getchararray() for more info
char evalchararray   getchararray
char patternchararray     sqlchar pattern  getchararray
char escapechararray      sqlchar  escape  getchararray
int escapelength   escape getlength
if  escapechararray    null    escapelength    1
throw standardexception newexception sqlstate lang_invalid_escape_character
new string escapechararray
else
// make sure we fail for both varchar an nvarchar
// for multiple collation characters.
sqlchar escapesqlchar    sqlchar  escape
int escapeintarray   escapesqlchar getintarray
if  escapeintarray    null     escapeintarray length    1
throw standardexception newexception sqlstate lang_invalid_escape_character new string escapesqlchar getchararray
likeresult   like like evalchararray
getlength
patternchararray
pattern getlength
escapechararray
escapelength
else
sqlchar patternsqlchar    sqlchar  pattern
sqlchar escapesqlchar    sqlchar  escape
int escapeintarray   escapesqlchar getintarray
int escapelength   escapesqlchar getintlength
if  escapeintarray    null     escapeintarray length    1
throw standardexception newexception sqlstate lang_invalid_escape_character
new string escapesqlchar getchararray
likeresult   like like getintarray
getintlength
patternsqlchar getintarray
patternsqlchar getintlength
escapeintarray
escapelength
getlocalefinder   getcollator
return sqlboolean truthvalue this
pattern
likeresult
/**
* this method implements the locate function for char.
* @param searchfrom    - the string to search from
* @param start         - the position to search from in string searchfrom
* @param result        - the object to return
*
* note: use getstring() to get the string to search for.
*
* @return  the position in searchfrom the fist occurrence of this.value.
*              0 is returned if searchfrom does not contain this.value.
* @exception standardexception     thrown on error
*/
public numberdatavalue locate   stringdatavalue searchfrom
numberdatavalue start
numberdatavalue result
throws standardexception
int startval
if  result    null
result   new sqlinteger
if  start isnull
startval   1
else
startval   start getint
if  isnull      searchfrom isnull
result settonull
return result
string mysearchfrom   searchfrom getstring
string mysearchfor   this getstring
/* the below 2 if conditions are to emulate db2's behavior */
if  startval < 1
throw standardexception newexception
sqlstate lang_invalid_parameter_for_search_position
new string getstring     new string mysearchfrom
new integer startval
if  mysearchfor length      0
result setvalue  startval
return result
result setvalue  mysearchfrom indexof mysearchfor  startval   1    1
return result
/**
* the sql substr() function.
*
* @param start		start of substr
* @param length	length of substr
* @param result	the result of a previous call to this method,
*					null if not called yet.
* @param maxlen	maximum length of the result
*
* @return	a concatabledatavalue containing the result of the substr()
*
* @exception standardexception		thrown on error
*/
public concatabledatavalue substring
numberdatavalue start
numberdatavalue length
concatabledatavalue result
int maxlen
throws standardexception
int startint
int lengthint
stringdatavalue stringresult
if  result    null
result   getnewvarchar
stringresult    stringdatavalue  result
/* the result is null if the receiver (this) is null or if the length is negative.
* we will return null, which is the only sensible thing to do.
* (if the user did not specify a length then length is not a user null.)
*/
if  this isnull      start isnull       length    null    length isnull
stringresult settonull
return stringresult
startint   start getint
// if length is not specified, make it till end of the string
if  length    null
lengthint   length getint
else lengthint   maxlen   startint   1
/* db2 compatibility: added these checks to match db2. we currently enforce these
* limits in both modes. we could do these checks in db2 mode only, if needed, so
* leaving earlier code for out of range in for now, though will not be exercised
*/
if   startint <  0    lengthint < 0    startint > maxlen
lengthint > maxlen   startint   1
throw standardexception newexception sqlstate lang_substr_start_or_len_out_of_range
// return null if length is non-positive
if  lengthint < 0
stringresult settonull
return stringresult
/* if startint < 0 then we count from the right of the string */
if  startint < 0
// return '' if window is to left of string.
if  startint   getlength   < 0
startint   getlength     lengthint <  0
stringresult setvalue
return stringresult
// convert startint to positive to get substring from right
startint    getlength
while  startint < 0
startint
lengthint
else if  startint > 0
/* java substring() is 0 based */
startint
/* oracle docs don't say what happens if the window is to the
* left of the string.  return "" if the window
* is to the left or right.
*/
if  lengthint    0
lengthint <  0   startint
startint > getlength
stringresult setvalue
return stringresult
if  lengthint >  getlength     startint
stringresult setvalue getstring   substring startint
else
stringresult setvalue getstring   substring startint  startint   lengthint
return stringresult
/**
* the sql trim(), ltrim() and rtrim() functions.
*
* @param trimtype	type of trim
* @param result	the result of a previous call to this method,
*					null if not called yet.
*
* @return	a stringdatavalue containing the result of the trim()
*
* @exception standardexception		thrown on error
*/
public stringdatavalue trim
int trimtype
stringdatavalue result
throws standardexception
if  result    null
result   getnewvarchar
/* the result is null if any of the parameters is a user null */
if  this isnull
result settonull
return result
char trimchars
string tmpvalue   getstring
// trim leading characters if appropriate
if  trimtype    leading
int start   0
// find the 1st character which doesn't get trimmed
for     start < tmpvalue length    start
boolean found   false
for  int index   0  index < trimchars length  index
if  tmpvalue charat start     trimchars
found   true
break
if    found
break
// trim if appropriate
if  start    tmpvalue length
tmpvalue
else if  start > 0
tmpvalue   tmpvalue substring start
// trim trailing characters if appropriate
if  trimtype    trailing
int start   tmpvalue length
// find the 1st character which doesn't get trimmed
for     start > 0  start
boolean found   false
for  int index   0  index < trimchars length  index
if  tmpvalue charat start   1     trimchars
found   true
break
if    found
break
// trim if appropriate
if  start    0
tmpvalue
else if  start < tmpvalue length
tmpvalue   tmpvalue substring 0  start
result setvalue tmpvalue
return result
/**
* this function public for testing purposes.
*
* @param trimtype  type of trim (leading, trailing, or both)
* @param trimchar  character to trim
* @param source    string from which to trim trimchar
*
* @return a string containing the result of the trim.
*/
private string triminternal int trimtype  char trimchar  string source
if  source    null
return null
int len   source length
int start   0
if  trimtype    leading    trimtype    both
for    start < len  start
if  trimchar    source charat start
break
if  start    len
return
int end   len   1
if  trimtype    trailing    trimtype    both
for    end >  0  end
if  trimchar    source charat end
break
if  end     1
return
return source substring start  end   1
/**
* @param trimtype  type of trim (leading, trailing, or both)
* @param trimchar  character to trim from this sqlchar (may be null)
* @param result    the result of a previous call to this method,
*                  null if not called yet.
*
* @return a stringdatavalue containing the result of the trim.
*/
public stringdatavalue ansitrim int trimtype  stringdatavalue trimchar  stringdatavalue result
throws standardexception
if  result    null
result   getnewvarchar
if  trimchar    null    trimchar getstring      null
result settonull
return result
if  trimchar getstring   length      1
throw standardexception newexception sqlstate lang_invalid_trim_character  trimchar getstring
char trimcharacter   trimchar getstring   charat 0
result setvalue triminternal trimtype  trimcharacter  getstring
return result
/** @see stringdatavalue#upper
*
* @exception standardexception		thrown on error
*/
public stringdatavalue upper stringdatavalue result
throws standardexception
if  result    null
result    stringdatavalue  getnewnull
if  this isnull
result settonull
return result
string upper   getstring
upper   upper touppercase getlocale
result setvalue upper
return result
/** @see stringdatavalue#lower
*
* @exception standardexception		thrown on error
*/
public stringdatavalue lower stringdatavalue result
throws standardexception
if  result    null
result    stringdatavalue  getnewnull
if  this isnull
result settonull
return result
string lower   getstring
lower   lower tolowercase getlocale
result setvalue lower
return result
/*
* datavaluedescriptor interface
*/
/** @see datavaluedescriptor#typeprecedence */
public int typeprecedence
return typeid char_precedence
/**
* compare two strings using standard sql semantics.
*
* @param op1				the first string
* @param op2				the second string
*
* @return  -1 - op1 <  op2
* 			 0 - op1 == op2
*			 1 - op1 > op2
*/
protected static int stringcompare string op1  string op2
int			posn
char		leftchar
char		rightchar
int			leftlen
int			rightlen
int			retvalifltspace
string		remainingstring
int			remaininglen
/*
** by convention, nulls sort high, and null == null
*/
if  op1    null    op2    null
if  op1    null 	   op2    null
return  1
if  op2    null 	   op1    null
return 1
return 0 			   both null
/*
** compare characters until we find one that isn't equal, or until
** one string or the other runs out of characters.
*/
leftlen   op1 length
rightlen   op2 length
int shorterlen   leftlen < rightlen ? leftlen   rightlen
for  posn   0  posn < shorterlen  posn
leftchar   op1 charat posn
rightchar   op2 charat posn
if  leftchar    rightchar
if  leftchar < rightchar
return  1
else
return 1
/*
** all the characters are equal up to the length of the shorter
** string.  if the two strings are of equal length, the values are
** equal.
*/
if  leftlen    rightlen
return 0
/*
** one string is shorter than the other.  compare the remaining
** characters in the longer string to spaces (the sql standard says
** that in this case the comparison is as if the shorter string is
** padded with blanks to the length of the longer string.
*/
if  leftlen > rightlen
/*
** remaining characters are on the left.
*/
/* if a remaining character is less than a space, return -1 (op1 < op2) */
retvalifltspace    1
remainingstring   op1
posn   rightlen
remaininglen   leftlen
else
/*
** remaining characters are on the right.
*/
/* if a remaining character is less than a space, return 1 (op1 > op2) */
retvalifltspace   1
remainingstring   op2
posn   leftlen
remaininglen   rightlen
/* look at the remaining characters in the longer string */
for     posn < remaininglen  posn
char	remainingchar
/*
** compare the characters to spaces, and return the appropriate
** value, depending on which is the longer string.
*/
remainingchar   remainingstring charat posn
if  remainingchar <
return retvalifltspace
else if  remainingchar >
return  retvalifltspace
/* the remaining characters in the longer string were all spaces,
** so the strings are equal.
*/
return 0
/**
* compare two sqlchars.  this method will be overriden in the
* national char wrappers so that the appropriate comparison
* is done.
*
* @exception standardexception		thrown on error
*/
protected int stringcompare sqlchar char1  sqlchar char2
throws standardexception
return stringcompare char1 getchararray    char1 getlength
char2 getchararray    char2 getlength
/**
* compare two strings using standard sql semantics.
*
* @param op1				the first string
* @param op2				the second string
*
* @return  -1 - op1 <  op2
* 			 0 - op1 == op2
*			 1 - op1 > op2
*/
protected static int stringcompare char op1  int leftlen  char op2  int rightlen
int			posn
char		leftchar
char		rightchar
int			retvalifltspace
char		remainingstring
int			remaininglen
/*
** by convention, nulls sort high, and null == null
*/
if  op1    null    op2    null
if  op1    null 	   op2    null
return  1
if  op2    null 	   op1    null
return 1
return 0 			   both null
/*
** compare characters until we find one that isn't equal, or until
** one string or the other runs out of characters.
*/
int shorterlen   leftlen < rightlen ? leftlen   rightlen
for  posn   0  posn < shorterlen  posn
leftchar   op1
rightchar   op2
if  leftchar    rightchar
if  leftchar < rightchar
return  1
else
return 1
/*
** all the characters are equal up to the length of the shorter
** string.  if the two strings are of equal length, the values are
** equal.
*/
if  leftlen    rightlen
return 0
/*
** one string is shorter than the other.  compare the remaining
** characters in the longer string to spaces (the sql standard says
** that in this case the comparison is as if the shorter string is
** padded with blanks to the length of the longer string.
*/
if  leftlen > rightlen
/*
** remaining characters are on the left.
*/
/* if a remaining character is less than a space, return -1 (op1 < op2) */
retvalifltspace    1
remainingstring   op1
posn   rightlen
remaininglen   leftlen
else
/*
** remaining characters are on the right.
*/
/* if a remaining character is less than a space, return 1 (op1 > op2) */
retvalifltspace   1
remainingstring   op2
posn   leftlen
remaininglen   rightlen
/* look at the remaining characters in the longer string */
for     posn < remaininglen  posn
char	remainingchar
/*
** compare the characters to spaces, and return the appropriate
** value, depending on which is the longer string.
*/
remainingchar   remainingstring
if  remainingchar <
return retvalifltspace
else if  remainingchar >
return  retvalifltspace
/* the remaining characters in the longer string were all spaces,
** so the strings are equal.
*/
return 0
/**
* compare a localized string with this one.
*
* @param str2              the other string
*
* @return  -1 - this <  str2
* 			 0 - this == str2
*			 1 - this > str2
*/
protected int stringcollatorcompare sqlchar str2
throws standardexception
collationkey ckey1   this getcollationkey
collationkey ckey2   str2 getcollationkey
/*
** by convention, nulls sort high, and null == null
*/
if  ckey1    null    ckey2    null
if  ckey1    null 	   str2    null
return  1
if  ckey2    null 	   this    null
return 1
return 0 			   both    null
return ckey1 compareto ckey2
protected collationkey getcollationkey   throws standardexception
char tmpchararray
if  ckey    null
return ckey
if  rawlength     1
/* materialize the string if input is a stream */
tmpchararray   getchararray
if  tmpchararray    null
return null
int lastnonspacechar   rawlength
while  lastnonspacechar > 0
rawdata
lastnonspacechar   			   count off the trailing spaces
rulebasedcollator rbc   getlocalefinder   getcollator
ckey   rbc getcollationkey new string rawdata  0  lastnonspacechar
return ckey
/*
* string display of value
*/
public string tostring
if  isnull
return
if   value    null      rawlength     1
return new string rawdata  0  rawlength
if  stream    null
try
return getstring
catch  exception e
return e tostring
return value
/*
* hash code
*/
public int hashcode
try
if  getstring      null
return 0
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert    se
return 0
/* value.hashcode() doesn't work because of the sql blank padding behavior
* we want the hash code to be based on the value after the
* trailing blanks have been trimmed.  calling trim() is too expensive
* since it will create a new object, so here's what we do:
*		o  walk from the right until we've found the 1st
*		   non-blank character.
*		o  add up the characters from that character to the 1st in
*		   the string and return that as the hash code.
*/
int index
int hashcode   0
// value will have been set by the getstring() above
string lvalue   value
// find 1st non-blank from the right
for  index   lvalue length     1
index >  0    lvalue charat index
index
// build the hash code
for     index >  0  index
hashcode    lvalue charat index
return hashcode
/**
* implementation of hashcode() for the national character types,
* put here to make it accessible to all the national types.
*/
protected int nationalhashcode
collationkey tmpckey   null
try
tmpckey   getcollationkey
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert    se
if  tmpckey    null
return 0
return tmpckey hashcode
private int getintarray
throws standardexception
if  isnull
return  int  null
if  intarray    null
return intarray
// intlength should always be 0 when intarray is null
if  sanitymanager debug
if  intlength    0
sanitymanager throwassert
intlength
intarray   new int
rulebasedcollator rbc   getlocalefinder   getcollator
collationelementiterator cei   rbc getcollationelementiterator getstring
int nextint
while   nextint   cei next       collationelementiterator nullorder
/* believe it or not, a string might have more
* collation elements than characters.
* so, we handle that case by increasing the int array
* by 5 and copying array elements.
*/
if  intlength    intarray length
int temparray   intarray
intarray   new int
for  int index   0  index < temparray length  index
intarray   temparray
intarray   nextint
return intarray
private int getintlength
return intlength
/**
* get a sqlvarchar for a built-in string function.
* (could be either a sqlvarchar or sqlnationalvarchar.)
*
* @return a sqlvarchar or sqlnationalvarchar.
*
* @exception standardexception		thrown on error
*/
protected stringdatavalue getnewvarchar   throws standardexception
return new sqlvarchar
/**
* return whether or not this is a national character datatype.
*/
protected boolean isnationalstring
return false
/**
* this implements getdate() for the national types. it lives
* here so it can be shared between all the national types.
*
* @exception standardexception thrown on failure to convert
*/
protected date	nationalgetdate  calendar cal  throws standardexception
if  isnull
return null
sqldate internaldate   new sqldate  getstring    false  getlocalefinder    cal
return internaldate getdate  cal
/**
* this implements gettime() for the national types. it lives
* here so it can be shared between all the national types.
*
* @exception standardexception thrown on failure to convert
*/
protected time nationalgettime  calendar cal  throws standardexception
if  isnull
return null
sqltime internaltime   new sqltime  getstring    false  getlocalefinder    cal
return internaltime gettime  cal
/**
* this implements gettimestamp() for the national types. it lives
* here so it can be shared between all the national types.
*
* @exception standardexception thrown on failure to convert
*/
protected timestamp	nationalgettimestamp  calendar cal  throws standardexception
// db2 does not support internationalized timestamps
return gettimestamp  cal  getstring    getlocalefinder
protected void setlocalefinder localefinder localefinder
this localefinder   localefinder
/** @exception standardexception		thrown on error */
private locale getlocale   throws standardexception
return getlocalefinder   getcurrentlocale
protected localefinder getlocalefinder
// this is not very satisfactory, as it creates a dependency on
// the databasecontext. it's the best i could do on short notice,
// though.  -  jeff
if  localefinder    null
databasecontext dc    databasecontext  contextservice getcontext databasecontext context_id
if  dc    null
localefinder   dc getdatabase
return localefinder
protected dateformat getdateformat   throws standardexception
return getlocalefinder   getdateformat
protected dateformat gettimeformat   throws standardexception
return getlocalefinder   gettimeformat
protected dateformat gettimestampformat   throws standardexception
return getlocalefinder   gettimestampformat
protected dateformat getdateformat  calendar cal  throws standardexception
return setdateformatcalendar  getlocalefinder   getdateformat    cal
protected dateformat gettimeformat  calendar cal  throws standardexception
return setdateformatcalendar  getlocalefinder   gettimeformat    cal
protected dateformat gettimestampformat  calendar cal  throws standardexception
return setdateformatcalendar  getlocalefinder   gettimestampformat    cal
private dateformat setdateformatcalendar  dateformat df  calendar cal
if  cal    null    df gettimezone      cal gettimezone
// the dateformat returned by getdateformat may be cached and used by other threads.
// therefore we cannot change its calendar.
df    dateformat  df clone
df setcalendar  cal
return df
/*
* object state
*/
// don't use value directly in most situations. use getstring()
// or use the rawdata array if rawlength != -1.
private		string	value
// rawdata holds the reusable array for reading in
// sqlchars. it contains a valid value if rawlength
// is greater than or equal to 0. see getstring() to see how it is
// converted to a string. even when converted to a string
// object the rawdata array remains for potential future
// use, unless  rawlength is > 4096. in this case the
// rawdata is set to null to avoid huge memory use.
private		char	rawdata
private		int		rawlength    1
// for null strings, ckey = null.
private collationkey ckey
/**
* the value as a stream in the on-disk format.
*/
inputstream stream
/* comparison info for national subclasses) */
private int	intarray
private int		intlength
/* locale info (for international support) */
private localefinder localefinder
private static final int base_memory_usage   classsize estimatebasefromcatalog  sqlchar class
public int estimatememoryusage
int sz   base_memory_usage   classsize estimatememoryusage  value
if  null    rawdata
sz    2 rawdata length
// assume that ckey, stream, and localfinder are shared, so do not count their memory usage
if  null    intarray
sz    intarray length classsize getintsize
return sz
end of estimatememoryusage
protected void copystate sqlchar other
this value   other value
this rawdata   other rawdata
this rawlength   other rawlength
this ckey   other ckey
this stream   other stream
this intarray   intarray
this intlength   intlength
this localefinder   localefinder
/**
* gets a trace representation for debugging.
*
* @return a trace representation of this sql type.
*/
public string gettracestring   throws standardexception
// check if the value is sql null.
if  isnull
return
return  tostring