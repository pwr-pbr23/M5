/*
derby - class org.apache.derby.impl.sql.compile.createtriggernode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import java sql timestamp
import java util enumeration
import java util hashtable
import java util vector
import org apache derby catalog uuid
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql conn authorizer
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary triggerdescriptor
import org apache derby iapi sql execute constantaction
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types typeid
/**
* a createtriggernode is the root of a querytree
* that represents a create trigger
* statement.
*
*/
public class createtriggernode extends ddlstatementnode
{
private	tablename			triggername
private	tablename			tablename
private	int					triggereventmask
private resultcolumnlist	triggercols
private	boolean				isbefore
private	boolean				isrow
private	boolean				isenabled
private	vector				refclause
private	valuenode		    whenclause
private	string				whentext
private	int					whenoffset
private	statementnode		actionnode
private	string				actiontext
private	string				originalactiontext     text w o trim of spaces
private	int					actionoffset
private schemadescriptor	triggerschemadescriptor
private schemadescriptor	compschemadescriptor
private int				referencedcolints
private tabledescriptor		triggertabledescriptor
private	uuid				actioncompschemaid
/*
** names of old and new table.  by default we have
** old/old and new/new.  the casing is dependent on
** the language connection context casing as the rest
** of other code. therefore we will set the value of the
** string at the init() time.
** however, if there is a referencing clause
** we will reset these values to be whatever the user
** wants.
*/
private string oldtablename
private string newtablename
private boolean oldtableinreferencingclause
private boolean newtableinreferencingclause
/**
* initializer for a createtriggernode
*
* @param triggername			name of the trigger
* @param tablename				name of the table which the trigger is declared upon
* @param triggereventmask		triggerdescriptor.trigger_event_xxx
* @param triggercols			columns trigger is to fire upon.  valid
*								for update case only.
* @param isbefore				is before trigger (false for after)
* @param isrow					true for row trigger, false for statement
* @param isenabled				true if enabled
* @param refclause				the referencing clause
* @param whenclause			the when clause tree
* @param whentext				the text of the when clause
* @param whenoffset			offset of start of when clause
* @param actionnode			the trigger action tree
* @param actiontext			the text of the trigger action
* @param actionoffset			offset of start of action clause
*
* @exception standardexception		thrown on error
*/
public void init
object		triggername
object		tablename
object				triggereventmask
object triggercols
object			isbefore
object			isrow
object			isenabled
object			refclause
object	whenclause
object			whentext
object				whenoffset
object	actionnode
object			actiontext
object				actionoffset
throws standardexception
{
initandcheck triggername
this triggername    tablename  triggername
this tablename    tablename  tablename
this triggereventmask     integer  triggereventmask  intvalue
this triggercols    resultcolumnlist  triggercols
this isbefore     boolean  isbefore  booleanvalue
this isrow     boolean  isrow  booleanvalue
this isenabled     boolean  isenabled  booleanvalue
this refclause    vector  refclause
this whenclause    valuenode  whenclause
this whentext    whentext    null  ? null     string  whentext  trim
this whenoffset     integer  whenoffset  intvalue
this actionnode    statementnode  actionnode
this originalactiontext    string  actiontext
this actiontext
actiontext    null  ? null     string  actiontext  trim
this actionoffset     integer  actionoffset  intvalue
implicitcreateschema   true
}
public string statementtostring
{
return
}
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
{
if  sanitymanager debug
{
super printsubnodes depth
if  triggercols    null
{
printlabel depth
triggercols treeprint depth   1
}
if (whenclause != null)
{
printlabel depth
whenclause treeprint depth   1
}
if  actionnode    null
{
printlabel depth
actionnode treeprint depth   1
}
}
}
// accessors
// we inherit the generate() method from ddlstatementnode.
/**
* bind this createtriggernode.  this means doing any static error
* checking that can be done before actually creating the table.
*
*
* @exception standardexception		thrown on error
*/
public void bindstatement   throws standardexception
{
compilercontext compilercontext   getcompilercontext
datadictionary	dd   getdatadictionary
/*
** grab the current schema.  we will use that for
** sps compilation
*/
languageconnectioncontext lcc   getlanguageconnectioncontext
compschemadescriptor   lcc getdefaultschema
/*
** get and check the schema descriptor for this
** trigger.  this check will throw the proper exception
** if someone tries to create a trigger in the sys
** schema.
*/
triggerschemadescriptor   getschemadescriptor
/*
** get the trigger table.
*/
triggertabledescriptor   gettabledescriptor tablename
//throw an exception if user is attempting to create a trigger on a temporary table
if  issessionschema triggertabledescriptor getschemadescriptor
{
throw standardexception newexception sqlstate lang_operation_not_allowed_on_session_schema_tables
}
if  isprivilegecollectionrequired
{
compilercontext pushcurrentprivtype authorizer trigger_priv
compilercontext addrequiredtablepriv triggertabledescriptor
compilercontext popcurrentprivtype
}
/*
** regenerates the actiontext and actionnode if necessary.
*/
boolean needinternalsql   bindreferencesclause dd
lcc pushtriggertable triggertabledescriptor
try
{
/*
** bind the trigger action and the trigger
** when clause to make sure that they are
** ok.  note that we have already substituted
** in various replacements for old/new transition
** tables/variables and reparsed if necessary.
*/
if  needinternalsql
compilercontext setreliability compilercontext internal_sql_legal
// for before triggers, the action statement cannot contain calls
// to procedures that modify sql data. if the action statement
// contains a procedure call, this reliability will be used during
// bind of the call statement node.
if isbefore
compilercontext setreliability compilercontext modifies_sql_data_procedure_illegal
actionnode bindstatement
/* when clause is always null
if (whenclause != null)
{
whenclause.bind();
}
*/
}
finally
{
lcc poptriggertable triggertabledescriptor
}
/*
** statement is dependent on the tabledescriptor
*/
compilercontext createdependency triggertabledescriptor
/*
** if there is a list of columns, then no duplicate columns,
** and all columns must be found.
*/
if  triggercols    null    triggercols size      0
{
referencedcolints   new int
hashtable columnnames   new hashtable
int tcsize   triggercols size
for  int i   0  i < tcsize  i
{
resultcolumn rc     resultcolumn  triggercols elementat i
if  columnnames put rc getname    rc     null
{
throw standardexception newexception sqlstate lang_duplicate_column_in_trigger_update
rc getname
triggername
}
columndescriptor cd   triggertabledescriptor getcolumndescriptor rc getname
if  cd    null
{
throw standardexception newexception sqlstate lang_column_not_found_in_table
rc getname
tablename
}
referencedcolints   cd getposition
}
// sort the list
java util arrays sort referencedcolints
}
//if attempting to reference a session schema table (temporary or permanent) in the trigger action, throw an exception
if  actionnode referencessessionschema
throw standardexception newexception sqlstate lang_operation_not_allowed_on_session_schema_tables
}
/**
* return true if the node references session schema tables (temporary or permanent)
*
* @return	true if references session schema tables, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencessessionschema
throws standardexception
{
//if create trigger is part of create statement and the trigger is defined on or it references session schema tables,
//it will get caught in the bind phase of trigger and exception will be thrown by the trigger bind.
return  issessionschema triggertabledescriptor getschemaname       actionnode referencessessionschema
}
/*
** bind old/new transition tables/variables
**
** 1) validate the referencing clause (if any)
**
** 2) convert trigger action text.  e.g.
**		delete from t where c = old.c
** turns into
**		delete from t where c = org.apache.derby.iapi.db.factory::
**					gettriggerexecutioncontext().getoldrow().getint('c');
** or
**		delete from t where c in (select c from old)
** turns into
**		delete from t where c in (select c from new triggeroldtransitiontable old)
**
** 3) check all column references against new/old transition
**	variables (since they are no longer 'normal' column references
** 	that will be checked during bind)
**
** 4) reparse the new action text
**
** you might be wondering why we regenerate the text and reparse
** instead of just reworking the tree to have the nodes we want.
** well, the primary reason is that if we screwed with the tree,
** then we would have a major headache if this trigger action
** was ever recompiled -- spses don't really know that they are
** triggers so it would be quite arduous to figure out that an
** sps is a trigger and munge up its query tree after figuring
** out what its old/new tables are, etc.  also, it is just plain
** easier to just generate the sql and rebind.
*/
private boolean bindreferencesclause datadictionary dd  throws standardexception
{
validatereferencesclause dd
stringbuffer newtext   new stringbuffer
boolean regennode   false
int start   0
if  isrow
{
/*
** for a row trigger, we find all column references.  if
** they are referencing new or old we turn them into
** gettriggerexecutioncontext().getoldrow().getint('c');
*/
collectnodesvisitor visitor   new collectnodesvisitor columnreference class
actionnode accept visitor
vector refs   visitor getlist
/* we need to sort on position in string, beetle 4324
*/
querytreenode cols   sortrefs refs  true
for  int i   0  i < cols length  i
{
columnreference ref    columnreference  cols
/*
** only occurrences of those old/new transition tables/variables
** are of interest here.  there may be intermediate nodes in the
** parse tree that have its own rcl which contains copy of
** column references(cr) from other nodes. e.g.:
**
** create trigger tt
** after insert on x
** referencing new as n
** for each row
**    insert into y values (n.i), (999), (333);
**
** the above trigger action will result in insertnode that
** contains a unionnode of rowresultsetnodes.  the unionnode
** will have a copy of the crs from its left child and those crs
** will not have its beginoffset set which indicates they are
** not relevant for the conversion processing here, so we can
** safely skip them.
*/
if  ref getbeginoffset       1
{
continue
}
tablename tablename   ref gettablenamenode
if   tablename    null
oldtablename    null     oldtablename equals tablename gettablename
newtablename    null     newtablename equals tablename gettablename
{
continue
}
int tokbeginoffset   tablename getbeginoffset
int tokendoffset   tablename getendoffset
if  tokbeginoffset     1
{
continue
}
regennode   true
checkinvalidtriggerreference tablename gettablename
string colname   ref getcolumnname
int columnlength   ref getendoffset     ref getbeginoffset     1
newtext append originalactiontext substring start  tokbeginoffset actionoffset
newtext append gencolumnreferencesql dd  colname  tablename gettablename    tablename gettablename   equals oldtablename
start   tokendoffset  actionoffset   columnlength   2
}
}
else
{
/*
** for a statement trigger, we find all frombasetable nodes.  if
** the from table is new or old (or user designated alternates
** referencing), we turn them into a trigger table vti.
*/
collectnodesvisitor visitor   new collectnodesvisitor frombasetable class
actionnode accept visitor
vector refs   visitor getlist
querytreenode tabs   sortrefs refs  false
for  int i   0  i < tabs length  i
{
frombasetable fromtable    frombasetable  tabs
string reftablename   fromtable gettablename   gettablename
string basetablename   fromtable getbasetablename
if   basetablename    null
oldtablename    null     oldtablename equals basetablename
newtablename    null     newtablename equals basetablename
{
continue
}
int tokbeginoffset   fromtable gettablenamefield   getbeginoffset
int tokendoffset   fromtable gettablenamefield   getendoffset
if  tokbeginoffset     1
{
continue
}
checkinvalidtriggerreference basetablename
regennode   true
newtext append originalactiontext substring start  tokbeginoffset actionoffset
newtext append basetablename equals oldtablename  ?
/*
** if the user supplied a correlation, then just
** pick it up automatically; otherwise, supply
** the default.
*/
if  reftablename equals basetablename
{
newtext append basetablename  append
}
start tokendoffset actionoffset 1
}
}
/*
** parse the new action text with the substitutions.
** also, we reset the actiontext to this new value.  this
** is what we are going to stick in the system tables.
*/
if  regennode
{
if  start < originalactiontext length
{
newtext append originalactiontext substring start
}
actiontext   newtext tostring
actionnode   parsestatement actiontext  true
}
return regennode
}
/*
** sort the refs into array.
*/
private querytreenode sortrefs vector refs  boolean isrow
{
int size   refs size
querytreenode sorted   new querytreenode
int i   0
for  enumeration e   refs elements    e hasmoreelements
{
if  isrow
sorted    columnreference e nextelement
else
sorted    frombasetable e nextelement
}
/* bubble sort
*/
querytreenode temp
for  i   0  i < size   1  i
{
temp   null
for  int j   0  j < size   i   1  j
{
if   isrow
sorted getbeginoffset   >
sorted getbeginoffset
isrow
frombasetable  sorted  gettablenamefield   getbeginoffset   >
frombasetable  sorted  gettablenamefield   getbeginoffset
{
temp   sorted
sorted   sorted
sorted   temp
}
}
if  temp    null 		   sorted
break
}
return sorted
}
/*
** make sure the given column name is found in the trigger
** target table.  generate the appropriate sql to get it.
**
** @return a string that is used to get the column using
** getobject() on the desired result set and cast it back
** to the proper type in the sql domain.
**
** @exception standardexception on invalid column name
*/
private string gencolumnreferencesql
datadictionary	dd
string			colname
string			tabname
boolean			isoldtable
throws standardexception
{
columndescriptor coldesc   null
if   coldesc   triggertabledescriptor getcolumndescriptor colname

{
throw standardexception newexception
sqlstate lang_column_not_found  tabname   colname
}
/*
** generate something like this:
**
** 		cast (org.apache.derby.iapi.db.factory::
**			gettriggerexecutioncontext().getnewrow().
**				getobject(<colposition>) as decimal(6,2))
**
** column position is used to avoid the wrong column being
** selected problem (derby-1258) caused by the case insensitive
** jdbc rules for fetching a column by name.
**
** the cast back to the sql domain may seem redundant
** but we need it to make the column reference appear
** exactly like a regular column reference, so we need
** the object in the sql domain and we need to have the
** type information.  thus a user should be able to do
** something like
**
**		create trigger ... insert into t length(column), ...
**
*/
datatypedescriptor  dts       coldesc gettype
typeid              typeid    dts gettypeid
if   typeid isxmltypeid
{
stringbuffer methodcall   new stringbuffer
methodcall append
methodcall append isoldtable ?
methodcall append
methodcall append coldesc getposition
methodcall append
/*
** getsqlstring() returns <typename>
** for user types, so call getsqltypename in that
** case.
*/
methodcall append
typeid usertype   ?
typeid getsqltypename     dts getsqlstring
methodcall append
return methodcall tostring
}
else
{
/*  derby-2350
**
**  triggers currently use jdbc 1.2 to access columns.  the default
**  uses getobject() which is not supported for an xml type until
**  jdbc 4.  in the meantime use getstring() and then call
**  xmlparse() on the string to get the type.  see derby issue and
**  http://wiki.apache.org/db-derby/triggerimplementation , for
**  better long term solutions.  long term i think changing the
**  trigger architecture to not rely on jdbc, but instead on an
**  internal direct access interface to execution nodes would be
**  best future direction, but believe such a change appropriate
**  for a major release, not a bug fix.
**
**  rather than the above described code generation, use the
**  following for xml types to generate an xml column from the
**  old or new row.
**
**          xmlparse(document
**              cast (org.apache.derby.iapi.db.factory::
**                  gettriggerexecutioncontext().getnewrow().
**                      getstring(<colposition>) as clob)
**                        preserve whitespace)
*/
stringbuffer methodcall   new stringbuffer
methodcall append
methodcall append
methodcall append isoldtable ?
methodcall append
methodcall append coldesc getposition
methodcall append
return methodcall tostring
}
}
/*
** check for illegal combinations here: insert & old or
** delete and new
*/
private void checkinvalidtriggerreference string tablename  throws standardexception
{
if  tablename equals oldtablename
triggereventmask   triggerdescriptor trigger_event_insert     triggerdescriptor trigger_event_insert
{
throw standardexception newexception sqlstate lang_trigger_bad_ref_mismatch
}
else if  tablename equals newtablename
triggereventmask   triggerdescriptor trigger_event_delete     triggerdescriptor trigger_event_delete
{
throw standardexception newexception sqlstate lang_trigger_bad_ref_mismatch
}
}
/*
** make sure that the referencing clause is legitimate.
** while we are at it we set the new/oldtablename to
** be whatever the user wants.
*/
private void validatereferencesclause datadictionary dd  throws standardexception
{
if   refclause    null      refclause size      0
{
return
}
for  enumeration e   refclause elements    e hasmoreelements
{
triggerreferencingstruct trn    triggerreferencingstruct e nextelement
/*
** 1) make sure that we don't try to refer
** to a table for a row trigger or a row for
** a table trigger.
*/
if  isrow     trn isrow
{
throw standardexception newexception sqlstate lang_trigger_bad_ref_mismatch
}
else if   isrow    trn isrow
{
throw standardexception newexception sqlstate lang_trigger_bad_ref_mismatch
}
/*
** 2) make sure we have no dups
*/
if  trn isnew
{
if  newtableinreferencingclause
{
throw standardexception newexception sqlstate lang_trigger_bad_ref_clause_dups
}
/*
** 3a) no new reference in delete trigger
*/
if   triggereventmask   triggerdescriptor trigger_event_delete     triggerdescriptor trigger_event_delete
{
throw standardexception newexception sqlstate lang_trigger_bad_ref_mismatch
}
newtablename   trn identifier
newtableinreferencingclause   true
}
else
{
if  oldtableinreferencingclause
{
throw standardexception newexception sqlstate lang_trigger_bad_ref_clause_dups
}
/*
** 3b) no old reference in insert trigger
*/
if   triggereventmask   triggerdescriptor trigger_event_insert     triggerdescriptor trigger_event_insert
{
throw standardexception newexception sqlstate lang_trigger_bad_ref_mismatch
}
oldtablename   trn identifier
oldtableinreferencingclause   true
}
/*
** 4) additional restriction on before triggers
*/
if  this isbefore     trn isrow
// old_table and new_table not allowed for before triggers.
throw standardexception newexception sqlstate lang_trigger_bad_ref_mismatch
}
}
}
/**
* create the constant information that will drive the guts of execution.
*
* @exception standardexception		thrown on failure
*/
public constantaction makeconstantaction   throws standardexception
{
string oldreferencingname    oldtableinreferencingclause  ? oldtablename   null
string newreferencingname    newtableinreferencingclause  ? newtablename   null
return	getgenericconstantactionfactory   getcreatetriggerconstantaction
triggerschemadescriptor getschemaname
getrelativename
triggereventmask
isbefore
isrow
isenabled
triggertabledescriptor
uuid null 			   when spsid
whentext
uuid null 			   action spsid
actiontext
actioncompschemaid    null  ?
compschemadescriptor getuuid
actioncompschemaid
timestamp null 	   creation time
referencedcolints
originalactiontext
oldtableinreferencingclause
newtableinreferencingclause
oldreferencingname
newreferencingname
}
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
{
if  sanitymanager debug
{
string refstring
if  refclause    null
{
stringbuffer buf   new stringbuffer
for  enumeration e   refclause elements    e hasmoreelements
{
buf append
triggerreferencingstruct trn
triggerreferencingstruct e nextelement
buf append trn tostring
buf append
}
refstring   buf tostring
}
return super tostring
tablename
triggereventmask
isbefore
isrow
isenabled
whentext
refstring
actiontext
}
else
{
return
}
}
}