/*
derby - class org.apache.derby.iapi.sql.dictionary.conglomeratedescriptor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql depend provider
import org apache derby catalog uuid
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql statementtype
import org apache derby iapi store access transactioncontroller
import org apache derby catalog dependablefinder
import org apache derby catalog dependable
import org apache derby iapi services io storedformatids
import org apache derby iapi services uuid uuidfactory
import org apache derby iapi services monitor monitor
/**
* the conglomeratedescriptor class is used to get information about
* conglomerates for the purpose of optimization.
*
* a conglomeratedescriptor can map to a base table, an index
* or a index backing a constraint. multiple conglomeratedescriptors
* can map to a single underlying store conglomerate, such as when
* multiple index definitions share a physical file.
*
* note: the language module does not have to know much about conglomerates
* with this architecture. to get the cost of using a conglomerate, all it
* has to do is pass the conglomeratedescriptor to the access methods, along
* with the predicate. what the access methods need from a
* conglomeratedescriptor remains to be seen.
*
*
*
* @version 0.1
*/
public final class conglomeratedescriptor extends tupledescriptor
implements uniquetupledescriptor  provider
// implementation
private long	conglomeratenumber
private string	name
private transient string	columnnames
private final boolean	indexable
private final boolean	forconstraint
private final indexrowgenerator	indexrowgenerator
private final uuid	uuid
private final uuid	tableid
private final uuid	schemaid
/**
* constructor for a conglomerate descriptor.
*
* @param datadictionary		the data dictionary that this descriptor lives in
* @param conglomeratenumber	the number for the conglomerate
*				we're interested in
* @param name			the name of the conglomerate, if any
* @param indexable		true means the conglomerate is indexable,
*				false means it isn't
* @param indexrowgenerator	the descriptor of the index if it's not a
*							heap
* @param forconstraint		true means the conglomerate is an index backing up
*							a constraint, false means it isn't
* @param uuid		uuid  for this conglomerate
* @param tableid	uuid for the table that this conglomerate belongs to
* @param schemaid	uuid for the schema that this conglomerate belongs to
*/
conglomeratedescriptor datadictionary datadictionary
long conglomeratenumber
string name
boolean indexable
indexrowgenerator indexrowgenerator
boolean forconstraint
uuid uuid
uuid tableid
uuid schemaid
super  datadictionary
this conglomeratenumber   conglomeratenumber
this name   name
this indexable   indexable
this indexrowgenerator   indexrowgenerator
this forconstraint   forconstraint
if  uuid    null
uuidfactory uuidfactory   monitor getmonitor   getuuidfactory
uuid   uuidfactory createuuid
this uuid   uuid
this tableid   tableid
this schemaid   schemaid
/**
* gets the number for the conglomerate.
*
* @return	a long identifier for the conglomerate
*/
public long	getconglomeratenumber
return conglomeratenumber
/**
* set the conglomerate number.
* this is useful when swapping conglomerates, like for bulkinsert.
*
* @param conglomeratenumber	the new conglomerate number.
*/
public void setconglomeratenumber long conglomeratenumber
this conglomeratenumber   conglomeratenumber
/**
* gets the uuid string for the conglomerate.
*
* @return	the uuid string for the conglomerate
*/
public uuid getuuid
return uuid
/**
* gets the uuid for the table that the conglomerate belongs to.
*
* @return	the uuid string for the conglomerate
*/
public uuid	gettableid
return	tableid
/**
* gets the uuid for the schema that the conglomerate belongs to.
*
* @return	the uuid string for the schema that the conglomerate belongs to
*/
public uuid	getschemaid
return schemaid
/**
* tells whether the conglomerate can be used as an index.
*
* @return	true if the conglomerate can be used as an index, false if not
*/
public boolean	isindex
return indexable
/**
* tells whether the conglomerate is an index backing up a constraint.
*
* @return	true if the conglomerate is an index backing up a constraint, false if not
*/
public boolean	isconstraint
return forconstraint
/**
* gets the name of the conglomerate.  for heaps, this is null.  for
* indexes, it is the index name.
*
* @return	the name of the conglomerate, null if it's the heap for a table.
*/
public string getconglomeratename
return name
/**
* set the name of the conglomerate.  used only by rename index.
*
* @param	newname the new name of the conglomerate.
*/
public void	setconglomeratename string newname
name   newname
/**
* gets the index row generator for this conglomerate, null if the
* conglomerate is not an index.
*
* @return	the index descriptor for this conglomerate, if any.
*/
public indexrowgenerator getindexdescriptor
return indexrowgenerator
/**
* set the column names for this conglomerate descriptor.
* this is useful for tracing the optimizer.
*
* @param columnnames	0-based array of column names.
*/
public void setcolumnnames string columnnames
this columnnames   columnnames
/**
* get the column names for this conglomerate descriptor.
* this is useful for tracing the optimizer.
*
* @return the column names for the conglomerate descriptor.
*/
public string getcolumnnames
return columnnames
//
// provider interface
//
/**
@return the stored form of this provider
*/
public dependablefinder getdependablefinder
return	getdependablefinder storedformatids conglomerate_descriptor_finder_v01_id
/**
* return the name of this provider.  (useful for errors.)
*
* @return string	the name of this provider.
*/
public string getobjectname
if  sanitymanager debug
sanitymanager assert name    null
return name
/**
* get the provider's uuid
*
* @return 	the provider's uuid
*/
public uuid getobjectid
return uuid
/**
* get the provider's type.
*
* @return char		the provider's type.
*/
public string getclasstype
if  indexable
return dependable index
else
return dependable heap
/**
* convert the conglomerate descriptor to a string
*
* @return	the conglomerate descriptor as a string
*/
public string tostring
if  sanitymanager debug
string keystring
if  indexable    columnnames    null
int keycolumns   indexrowgenerator basecolumnpositions
keystring       columnnames   1]
for  int index   1  index < keycolumns length  index
keystring   keystring       columnnames   1]
keystring   keystring
return     conglomeratenumber
name
uuid
indexable   keystring
else
return
/** @see tupledescriptor#getdescriptortype */
public string getdescriptortype
if  indexable
return
else
return
/** @see tupledescriptor#getdescriptorname */
public string getdescriptorname     return name
/**
* drop this conglomeratedescriptor when it represents
* an index. if this is the last desciptor for
* a physical index then the physical index (conglomerate)
* and its descriptor will be dropped.
*
* @param lcc
* @param td
* @throws standardexception
*/
public void drop languageconnectioncontext lcc
tabledescriptor td
throws standardexception
datadictionary dd   getdatadictionary
dependencymanager dm   dd getdependencymanager
transactioncontroller tc   lcc gettransactionexecute
// invalidate any prepared statements that
// depended on the index (including this one)
dm invalidatefor this  dependencymanager drop_index  lcc
// only drop the conglomerate if no similar index but with different
// name. get from dd in case we drop other dup indexes with a cascade operation
if  dd getconglomeratedescriptors getconglomeratenumber    length    1
/* drop statistics */
dd dropstatisticsdescriptors td getuuid    getuuid    tc
/* drop the conglomerate */
tc dropconglomerate getconglomeratenumber
/* drop the conglomerate descriptor */
dd dropconglomeratedescriptor this  tc
/*
** remove the conglomerate descriptor from the list hanging off of the
** table descriptor
*/
td removeconglomeratedescriptor this