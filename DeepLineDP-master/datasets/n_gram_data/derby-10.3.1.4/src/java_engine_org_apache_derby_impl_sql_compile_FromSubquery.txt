/*
derby - class org.apache.derby.impl.sql.compile.fromsubquery
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi error standardexception
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi util jbitset
/**
* a fromsubquery represents a subquery in the from list of a dml statement.
*
* the current implementation of this class is only
* sufficient for insert's need to push a new
* select on top of the one the user specified,
* to make the selected structure match that
* of the insert target table.
*
*/
public class fromsubquery extends fromtable
resultsetnode	subquery
/**
* intializer for a table in a from list.
*
* @param subquery		the subquery
* @param correlationname	the correlation name
* @param derivedrcl		the derived column list
* @param tableproperties	properties list associated with the table
*/
public void init
object subquery
object correlationname
object derivedrcl
object tableproperties
super init correlationname  tableproperties
this subquery    resultsetnode  subquery
resultcolumns    resultcolumnlist  derivedrcl
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return  super tostring
else
return
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  subquery    null
printlabel depth
subquery treeprint depth   1
/**
* return the "subquery" from this node.
*
* @return resultsetnode	the "subquery" from this node.
*/
public resultsetnode getsubquery
return subquery
/**
* determine whether or not the specified name is an exposed name in
* the current query block.
*
* @param name	the specified name to search for as an exposed name.
* @param schemaname	schema name, if non-null.
* @param exactmatch	whether or not we need an exact match on specified schema and table
*						names or match on table id.
*
* @return the fromtable, if any, with the exposed name.
*
* @exception standardexception		thrown on error
*/
protected fromtable getfromtablebyname string name  string schemaname  boolean exactmatch
throws standardexception
return super getfromtablebyname name  schemaname  exactmatch
/**
* bind this subquery that appears in the from list.
*
* @param datadictionary	the datadictionary to use for binding
* @param fromlistparam		fromlist to use/append to.
*
* @return	resultsetnode		the bound fromsubquery.
*
* @exception standardexception		thrown on error
*/
public resultsetnode bindnonvtitables datadictionary datadictionary
fromlist fromlistparam
throws standardexception
/* assign the tablenumber */
if  tablenumber     1      allow re bind  in which case use old number
tablenumber   getcompilercontext   getnexttablenumber
subquery   subquery bindnonvtitables datadictionary  fromlistparam
return this
/**
* bind this subquery that appears in the from list.
*
* @param fromlistparam		fromlist to use/append to.
*
* @return	resultsetnode		the bound fromsubquery.
*
* @exception standardexception		thrown on error
*/
public resultsetnode bindvtitables fromlist fromlistparam
throws standardexception
subquery   subquery bindvtitables fromlistparam
return this
/**
* check for (and reject) ? parameters directly under the resultcolumns.
* this is done for select statements.  for fromsubquery, we
* simply pass the check through to the subquery.
*
* @exception standardexception		thrown if a ? parameter found
*									directly under a resultcolumn
*/
public void rejectparameters   throws standardexception
subquery rejectparameters
/**
* bind the expressions in this fromsubquery.  this means
* binding the sub-expressions, as well as figuring out what the return
* type is for each expression.
*
* @exception standardexception		thrown on error
*/
public void bindexpressions fromlist fromlistparam
throws standardexception
fromlist			emptyfromlist
fromlist  getnodefactory   getnode
c_nodetypes from_list
getnodefactory   dojoinorderoptimization
getcontextmanager
resultcolumnlist	derivedrcl   resultcolumns
resultcolumnlist	subqueryrcl
fromlist			nestedfromlist
/* from subqueries cannot be correlated, so we pass an empty fromlist
* to subquery.bindexpressions() and .bindresultcolumns()
*/
nestedfromlist   emptyfromlist
subquery bindexpressions nestedfromlist
subquery bindresultcolumns nestedfromlist
/* now that we've bound the expressions in the subquery, we
* can propagate the subquery's rcl up to the fromsubquery.
* get the subquery's rcl, assign shallow copy back to
* it and create new virtualcolumnnodes for the original's
* resultcolumn.expressions.
* note: if the size of the derived column list is less than
* the size of the subquery's rcl and the derived column list is marked
* for allowing a size mismatch, then we have a select * view
* on top of a table that has had columns added to it via alter table.
* in this case, we trim out the columns that have been added to
* the table since the view was created.
*/
subqueryrcl   subquery getresultcolumns
if  resultcolumns    null    resultcolumns getcountmismatchallowed
resultcolumns size   < subqueryrcl size
for  int index   subqueryrcl size     1
index >  resultcolumns size
index
subqueryrcl removeelementat index
subquery setresultcolumns subqueryrcl copylistandobjects
subqueryrcl genvirtualcolumnnodes subquery  subquery getresultcolumns
resultcolumns   subqueryrcl
/* propagate the name info from the derived column list */
if  derivedrcl    null
resultcolumns propagatedclinfo derivedrcl  correlationname
/**
* try to find a resultcolumn in the table represented by this frombasetable
* that matches the name in the given columnreference.
*
* @param columnreference	the columnreference whose name we're looking
*				for in the given table.
*
* @return	a resultcolumn whose expression is the columnnode
*			that matches the columnreference.
*		returns null if there is no match.
*
* @exception standardexception		thrown on error
*/
public resultcolumn getmatchingcolumn columnreference columnreference  throws standardexception
resultcolumn	resultcolumn   null
string			columnstablename
/*
** resolve: when we add support for schemas, check to see if
** the column name specifies a schema, and if so, if this
** table is in that schema.
*/
columnstablename   columnreference gettablename
// post 681, 1 may be no longer needed. 5 is the default case
// now but what happens if the condition is false? investigate.
if  columnreference getgeneratedtoreplaceaggregate       1
resultcolumn   resultcolumns getresultcolumn columnreference getcolumnname
else if  columnstablename    null    columnstablename equals correlationname      5?
resultcolumn   resultcolumns getatmostoneresultcolumn columnreference  correlationname  false
if  resultcolumn    null
columnreference settablenumber tablenumber
return resultcolumn
/**
* preprocess a resultsetnode - this currently means:
*	o  generating a referenced table map for each resultsetnode.
*  o  putting the where and having clauses in conjunctive normal form (cnf).
*  o  converting the where and having clauses into predicatelists and
*	   classifying them.
*  o  ensuring that a projectrestrictnode is generated on top of every
*     frombasetable and generated in place of every fromsubquery.
*  o  pushing single table predicates down to the new projectrestrictnodes.
*
* @param numtables			the number of tables in the dml statement
* @param gbl				the group by list, if any
* @param fromlist			the from list, if any
*
* @return resultsetnode at top of preprocessed tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode preprocess int numtables
groupbylist gbl
fromlist fromlist
throws standardexception
/* we want to chop out the fromsubquery from the tree and replace it
* with a projectrestrictnode.  one complication is that there may be
* columnreferences above us which point to the fromsubquery's rcl.
* what we want to return is a tree with a prn with the
* fromsubquery's rcl on top.  (in addition, we don't want to be
* introducing any redundant projectrestrictnodes.)
* another complication is that we want to be able to only only push
* projections and restrictions down to this projectrestrict, but
* we want to be able to push them through as well.
* so, we:
*		o call subquery.preprocess() which returns a tree with
*		  a selectnode or a rowresultsetnode on top.
*		o if the fsqry is flattenable(), then we return (so that the
*		  caller can then call flatten()), otherwise we:
*		o generate a prn, whose rcl is the fsqry's rcl, on top of the result.
*		o create a referencedtablemap for the prn which represents
*		  the fsqry's tablenumber, since columnreferences in the outer
*		  query block would be referring to that one.
*		  (this will allow us to push restrictions down to the prn.)
*/
subquery   subquery preprocess numtables  gbl  fromlist
/* return if the fsqry is flattenable()
* note: we can't flatten a fromsubquery if there is a group by list
* because the group by list must be columnreferences.  for:
*	select c1 from v1 group by c1,
*	where v1 is select 1 from t1
* the expression under the last redundant resultcolumn is an intconstantnode,
* not a columnreference.
* we also do not flatten a subquery if tableproperties is non-null,
* as the user is specifying 1 or more properties for the derived table,
* which could potentially be lost on the flattening.
* resolve - this is too restrictive.
*/
if   gbl    null    gbl size      0
tableproperties    null
subquery flattenableinfromsubquery fromlist
/* set our table map to the subquery's table map. */
setreferencedtablemap subquery getreferencedtablemap
return this
return extractsubquery numtables
/**
* extract out and return the subquery, with a prn on top.
* (see fromsubquery.preprocess() for more details.)
*
* @param numtables			the number of tables in the dml statement
*
* @return resultsetnode at top of extracted tree.
*
* @exception standardexception		thrown on error
*/
public resultsetnode extractsubquery int numtables
throws standardexception
jbitset		  newjbs
resultsetnode newprn
newprn    resultsetnode  getnodefactory   getnode
c_nodetypes project_restrict_node
subquery 		   child resultset
resultcolumns 	   projection
null 			   restriction
null 			   restriction as predicatelist
null 			   subquerys in projection
null 			   subquerys in restriction
tableproperties
getcontextmanager
/* set up the prn's referencedtablemap */
newjbs   new jbitset numtables
newjbs set tablenumber
newprn setreferencedtablemap newjbs
fromtable  newprn  settablenumber tablenumber
return newprn
/**
* flatten this fsqry into the outer query block. the steps in
* flattening are:
*	o  mark all resultcolumns as redundant, so that they are "skipped over"
*	   at generate().
*	o  append the wherepredicates to the outer list.
*	o  return the fromlist so that the caller will merge the 2 lists
*  resolve - fsqrys with subqueries are currently not flattenable.  some of
*  them can be flattened, however.  we need to merge the subquery list when
*  we relax this restriction.
*
* note: this method returns null when flattening rowresultsetnodes
* (the node for a values clause).  the reason is that no reference
* is left to the rowresultsetnode after flattening is done - the
* expressions point directly to the valuenodes in the rowresultsetnode's
* resultcolumnlist.
*
* @param rcl				the rcl from the outer query
* @param outerplist	predicatelist to append wherepredicates to.
* @param sql				the subquerylist from the outer query
* @param gbl				the group by list, if any
*
* @return fromlist		the fromlist from the underlying selectnode.
*
* @exception standardexception		thrown on error
*/
public fromlist flatten resultcolumnlist rcl
predicatelist outerplist
subquerylist sql
groupbylist gbl
throws standardexception
fromlist	fromlist   null
selectnode	selectnode
resultcolumns setredundant
subquery getresultcolumns   setredundant
/*
** resolve: each type of result set should know how to remap itself.
*/
if  subquery instanceof selectnode
selectnode    selectnode  subquery
fromlist   selectnode getfromlist
// selectnode.getresultcolumns().setredundant();
if  selectnode getwherepredicates   size   > 0
outerplist destructiveappend selectnode getwherepredicates
if  selectnode getwheresubquerys   size   > 0
sql destructiveappend selectnode getwheresubquerys
else if      subquery instanceof rowresultsetnode
if  sanitymanager debug
sanitymanager throwassert     subquery getclass   getname
/* remap all columnreferences from the outer query to this node.
* (we replace those columnreferences with clones of the matching
* expression in the select's rcl.
*/
rcl remapcolumnreferencestoexpressions
outerplist remapcolumnreferencestoexpressions
if  gbl    null
gbl remapcolumnreferencestoexpressions
return fromlist
/**
* get the exposed name for this table, which is the name that can
* be used to refer to it in the rest of the query.
*
* @return	the exposed name for this table.
*/
public string getexposedname
return correlationname
/**
* expand a "*" into a resultcolumnlist with all of the
* result columns from the subquery.
* @exception standardexception		thrown on error
*/
public resultcolumnlist getallresultcolumns tablename alltablename
throws standardexception
resultcolumnlist rclist   null
tablename		 exposedname
tablename        tocompare
if alltablename    null
tocompare   maketablename alltablename getschemaname   correlationname
else
tocompare   maketablename null correlationname
if   alltablename    null
alltablename equals tocompare
return null
/* cache exposed name for this table.
* the exposed name becomes the qualifier for each column
* in the expanded list.
*/
exposedname   maketablename null  correlationname
rclist    resultcolumnlist  getnodefactory   getnode
c_nodetypes result_column_list
getcontextmanager
/* build a new result column list based off of resultcolumns.
* note: this method will capture any column renaming due to
* a derived column list.
*/
int rclsize   resultcolumns size
for  int index   0  index < rclsize  index
resultcolumn resultcolumn    resultcolumn  resultcolumns elementat index
valuenode		 valuenode
string			 columnname
if  resultcolumn isgenerated
continue
// build a resultcolumn/columnreference pair for the column //
columnname   resultcolumn getname
boolean isnamegenerated   resultcolumn isnamegenerated
/* if this node was generated for a group by, then tablename for the cr, if any,
* comes from the source rc.
*/
tablename tablename
tablename   exposedname
valuenode    valuenode  getnodefactory   getnode
c_nodetypes column_reference
columnname
tablename
getcontextmanager
resultcolumn    resultcolumn  getnodefactory   getnode
c_nodetypes result_column
columnname
valuenode
getcontextmanager
resultcolumn setnamegenerated isnamegenerated
// build the resultcolumnlist to return //
rclist addresultcolumn resultcolumn
return rclist
/**
* @see querytreenode#disableprivilegecollection
*/
public void disableprivilegecollection
super disableprivilegecollection
subquery disableprivilegecollection
/**
* search to see if a query references the specifed table name.
*
* @param name		table name (string) to search for.
* @param basetable	whether or not name is for a base table
*
* @return	true if found, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencestarget string name  boolean basetable
throws standardexception
return subquery referencestarget name  basetable
/**
* return true if the node references session schema tables (temporary or permanent)
*
* @return	true if references session schema tables, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencessessionschema
throws standardexception
return subquery referencessessionschema
/**
* bind any untyped null nodes to the types in the given resultcolumnlist.
*
* @param bindingrcl	the resultcolumnlist with the types to bind to.
*
* @exception standardexception		thrown on error
*/
public void binduntypednullstoresultcolumns resultcolumnlist bindingrcl
throws standardexception
subquery binduntypednullstoresultcolumns bindingrcl
/**
* decrement (query block) level (0-based) for this fromtable.
* this is useful when flattening a subquery.
*
* @param decrement	the amount to decrement by.
*/
void decrementlevel int decrement
super decrementlevel decrement
subquery decrementlevel decrement