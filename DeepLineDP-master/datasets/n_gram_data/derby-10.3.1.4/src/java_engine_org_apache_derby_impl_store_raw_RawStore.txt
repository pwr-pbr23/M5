/*
derby - class org.apache.derby.impl.store.raw.rawstore
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw
import org apache derby iapi services daemon daemonfactory
import org apache derby iapi services daemon daemonservice
import org apache derby iapi services context contextmanager
import org apache derby iapi services context contextservice
import org apache derby iapi services crypto cipherfactorybuilder
import org apache derby iapi services crypto cipherfactory
import org apache derby iapi services crypto cipherprovider
import org apache derby iapi services locks compatibilityspace
import org apache derby iapi services locks lockfactory
import org apache derby iapi services monitor monitor
import org apache derby iapi services monitor modulecontrol
import org apache derby iapi services monitor modulesupportable
import org apache derby iapi services monitor persistentservice
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi services i18n messageservice
import org apache derby iapi services property persistentset
import org apache derby iapi store access transactioninfo
import org apache derby iapi store access accessfactoryglobals
import org apache derby iapi store access fileresource
import org apache derby iapi store raw scanhandle
import org apache derby iapi store raw rawstorefactory
import org apache derby iapi store raw transaction
import org apache derby iapi store raw xact rawtransaction
import org apache derby iapi store raw xact transactionfactory
import org apache derby iapi store raw data datafactory
import org apache derby iapi store raw log logfactory
import org apache derby iapi store raw log loginstant
import org apache derby impl services monitor updateserviceproperties
import org apache derby io storagefactory
import org apache derby io writablestoragefactory
import org apache derby io storagefile
import org apache derby iapi store access databaseinstant
import org apache derby catalog uuid
import org apache derby iapi services property propertyutil
import org apache derby iapi services io fileutil
import org apache derby iapi util reusefactory
import org apache derby iapi util stringutil
import org apache derby iapi reference attribute
import org apache derby iapi reference sqlstate
import org apache derby iapi reference messageid
import org apache derby iapi reference property
import java security accesscontroller
import java security privilegedactionexception
import java security privilegedexceptionaction
import java security securerandom
import java util date
import java util properties
import java io serializable
import java io file
import java io fileoutputstream
import java io fileinputstream
import java io ioexception
import java io filenotfoundexception
import java io outputstreamwriter
import java net malformedurlexception
import java net url
import java security privilegedexceptionaction
import java lang securityexception
/**
a raw store that implements the rawstorefactory module by delegating all the
work to the lower modules transactionfactory, logfactory and datafactory.
<pre>
string transactionfactoryid=<moduleidentifier>
</pre>
<p>
class is final as it has methods with privilege blocks
and implements privilegedexceptionaction.
*/
public final class rawstore implements rawstorefactory  modulecontrol  modulesupportable  privilegedexceptionaction
private static final string backup_history
protected transactionfactory	xactfactory
protected datafactory			datafactory
protected logfactory			logfactory
private storagefactory storagefactory
private securerandom random
private boolean databaseencrypted
private boolean encryptdatabase
private cipherprovider encryptionengine
private cipherprovider decryptionengine
private cipherprovider newencryptionengine
private cipherprovider newdecryptionengine
private cipherfactory  currentcipherfactory
private cipherfactory newcipherfactory   null
private int counter_encrypt
private int counter_decrypt
private int encryptionblocksize   rawstorefactory default_encryption_blocksize
string datadirectory  					   where files are stored
// this daemon takes care of all daemon work for this raw store
protected daemonservice			rawstoredaemon
private int actioncode
private static final int file_writer_action   1
private storagefile actionstoragefile
private storagefile actiontostoragefile
private boolean actionappend
private static final int regular_file_exists_action   2
private file actionregularfile
private static final int storage_file_exists_action   3
private static final int regular_file_delete_action   4
private static final int regular_file_mkdirs_action   5
private static final int regular_file_is_directory_action   6
private static final int regular_file_remove_directory_action   7
private static final int regular_file_rename_to_action   8
private file actionregularfile2
private static final int copy_storage_directory_to_regular_action   9
private byte actionbuffer
private string actionfilter
private boolean actioncopysubdirs
private static final int copy_regular_directory_to_storage_action   10
private static final int copy_regular_file_to_storage_action   11
private static final int regular_file_list_directory_action   12
private static final int storage_file_list_directory_action   13
private static final int copy_storage_file_to_regular_action   14
private static final int regular_file_get_canonicalpath_action   15
private static final int storage_file_get_canonicalpath_action   16
private static final int copy_storage_file_to_storage_action   17
private static final int storage_file_delete_action   18
public rawstore
/*
** methods of modulecontrol
*/
/**
we use this rawstore for all databases.
*/
public boolean cansupport properties startparams
return true
public void	boot boolean create  properties properties
throws standardexception
datadirectory   properties getproperty persistentservice root
daemonfactory daemonfactory
daemonfactory monitor startsystemmodule org apache derby iapi reference module daemonfactory
rawstoredaemon   daemonfactory createnewdaemon
xactfactory    transactionfactory
monitor bootservicemodule
create  this  gettransactionfactorymodule    properties
datafactory    datafactory
monitor bootservicemodule
create  this  getdatafactorymodule    properties
storagefactory   datafactory getstoragefactory
string restorefrombackup   null
if  properties    null
// check if this is a restore from a backup copy.
restorefrombackup   properties getproperty attribute create_from
if restorefrombackup    null
restorefrombackup   properties getproperty attribute restore_from
if restorefrombackup    null
restorefrombackup
properties getproperty attribute roll_forward_recovery_from
// setup database encryption engines.
if  create
setupencryptionengines create  properties
// let everyone knows who their rawstorefactory is and they can use it
// to get to other modules
// pass in create and properties to datafactory so it can boot the log
// factory
datafactory setrawstorefactory this  create  properties
xactfactory setrawstorefactory this
if  properties instanceof updateserviceproperties
if  storagefactory instanceof writablestoragefactory
updateserviceproperties properties  setstoragefactory   writablestoragefactory  storagefactory
// log factory is booted by the data factory
logfactory   logfactory  monitor findservicemodule this  getlogfactorymodule
// if this is a restore from backup, restore the jar files.
if restorefrombackup   null
restoreremainingfrombackup restorefrombackup
// if the log is at another location, make sure  service.properties
// file has it.
string logdevice   properties getproperty attribute log_device
if  logdevice   null
if   isreadonly      we do not care about log location if read only
create
logdevice equals logfactory getcanonicallogpath
restorefrombackup  null
// get the real location from the log factory
properties put attribute log_device  logfactory getcanonicallogpath
//make the log device param stored in backup is same as current log device.
properties put property log_device_at_backup  logfactory getcanonicallogpath
else
//when we restore from a backup logdevice param does not exists
//in service.properties to support restore using os commands to work.
//instead of logdevice, we user logdevicewhenbackedup parameter to
//identify the log location while restoring createfrom/restorefrom/rollforwardrecoveryfrom
//attribute , following make sures the logdevice parameter gets
//into service.propertues in such cases.
if restorefrombackup  null    logfactory getcanonicallogpath    null
//logdevice might have got changed because of backup restore.
properties put attribute log_device   logfactory getcanonicallogpath
else
//might have been os copy restore. we default log to db home
properties remove property log_device_at_backup
// save the service properties to a file if we are doing a
// restore from. this marks the end of restore from backup.
if  restorefrombackup   null
updateserviceproperties properties  saveserviceproperties
/**
* note: service.properties file acts as flags to indicate
* that the copy from backup is successful.
* if we reached so far while restoring from backup means
* we copied all the necessary data from backup. only thing
* that remains is roll forwarding the logs. incase if we crash at this
* point and user re boots the datbase again without any restore flags
* it shoud boot without any problem.
**/
// setup database encryption engine
if   create
// check if the engine crashed while re-encrypting an
// encrypted database or while encryption and
// existing database.
if properties getproperty
rawstorefactory db_encryption_status    null
handleincompletedatabaseencryption properties
setupencryptionengines create  properties
if  databaseencrypted
// let log factory know if the database is encrypted .
logfactory setdatabaseencrypted false
// let data factory know if the database is encrypted.
datafactory setdatabaseencrypted
// no need to tell log factory which raw store factory it belongs to
// since this is passed into the log factory for recovery
// after the factories are loaded, recover the database
logfactory recover this  datafactory  xactfactory
// if user requested to encrpty an unecrypted database or encrypt with
// new alogorithm then do that now.
if  encryptdatabase
configuredatabaseforencryption properties
newcipherfactory
public void	stop
if  sanitymanager debug
if  databaseencrypted
sanitymanager debug_print
counter_encrypt
counter_decrypt
if  rawstoredaemon    null
rawstoredaemon stop
if  logfactory    null
return
try
if  logfactory checkpoint this  datafactory  xactfactory  false
if  datafactory    null
datafactory removestubsok
catch  standardexception se
// checkpoint failed, stop all factory from shutting down normally
markcorrupt se
/*
** methods of rawstorefactory
*/
/**
is the store read-only.
@see rawstorefactory#isreadonly
*/
public boolean isreadonly
return datafactory isreadonly
public lockfactory getlockfactory
return xactfactory getlockfactory
/**
get the transaction factory to use with this store.
*/
public transactionfactory getxactfactory
return xactfactory
/*
* return the module providing xaresource interface to the transaction
* table.
*
* @exception standardexception standard derby exception policy.
*/
public    xaresourcemanager    object getxaresourcemanager
throws standardexception
return xactfactory getxaresourcemanager
public transaction startglobaltransaction
contextmanager  contextmgr
int             format_id
byte          global_id
byte          branch_id
throws standardexception
return xactfactory startglobaltransaction
this  contextmgr  format_id  global_id  branch_id
public transaction starttransaction contextmanager contextmgr  string transname
throws standardexception
return xactfactory starttransaction this  contextmgr  transname
public transaction startnestedreadonlyusertransaction
compatibilityspace compatibilityspace
contextmanager  contextmgr
string          transname
throws standardexception
return
xactfactory startnestedreadonlyusertransaction
this  compatibilityspace  contextmgr  transname
public transaction startnestedupdateusertransaction
contextmanager  contextmgr
string          transname
throws standardexception
return
xactfactory startnestedupdateusertransaction
this  contextmgr  transname
public transaction findusertransaction
contextmanager contextmgr
string transname
throws standardexception
return xactfactory findusertransaction this  contextmgr  transname
public transaction startinternaltransaction contextmanager contextmgr  throws standardexception
return xactfactory startinternaltransaction this  contextmgr
public void checkpoint   throws standardexception
logfactory checkpoint this  datafactory  xactfactory  false
public void freeze   throws standardexception
logfactory checkpoint this  datafactory  xactfactory  true
datafactory freezepersistentstore
logfactory freezepersistentstore
public void unfreeze   throws standardexception
logfactory unfreezepersistentstore
datafactory unfreezepersistentstore
/**
* backup the database to a backup directory.
*
* @param backupdir the name of the directory where the backup should be
*                  stored. this directory will be created if it
*                  does not exist.
* @param wait if <tt>true</tt>, waits for  all the backup blocking
*             operations in progress to finish.
* @exception standardexception thrown on error
*/
public void backup string backupdir  boolean wait
throws standardexception
if  backupdir    null    backupdir equals
throw standardexception newexception
sqlstate rawstore_cannot_create_backup_directory   file null
// in case this is an url form
string backupdirurl   null
try
url url   new url backupdir
backupdirurl   url getfile
catch  malformedurlexception ex
if  backupdirurl    null
backupdir   backupdirurl
// find the user transaction, it is necessary for online backup
// to open the container through page cache
rawtransaction t
xactfactory findusertransaction this
contextservice getfactory   getcurrentcontextmanager
accessfactoryglobals user_trans_name
try
// check if  any backup blocking operations are in progress
// in the same transaction backup is being executed? backup is
// not allowed if the transaction has uncommitted
// unlogged operations that are blocking the backup.
if  t isblockingbackup
throw standardexception newexception
sqlstate backup_operations_not_allowed
// check if any backup blocking operations are in progress
// and stop new ones from starting until the backup is completed.
if   xactfactory blockbackupblockingoperations wait
throw standardexception newexception
sqlstate backup_blocking_operations_in_progress
// perform backup
backup t  new file backupdir
finally
// let the xactfatory know that backup is done, so that
// it can allow backup blocking operations.
xactfactory unblockbackupblockingoperations
/*
* backup the database.
* online backup copies all the database files (log, seg0  ...etc) to the
* specified backup location without blocking any user operation for the
* duration of the backup. stable copy is made of each page using
* page level latches and in some cases with the help of monitors.
* transaction log is also backed up, this is used to bring the database to
* the consistent state on restore.
*
* <p> mt- only one thread  is allowed to perform backup at any given time.
*  synchronized on this. parallel backups are not supported.
*/
public synchronized void backup transaction t  file backupdir
throws standardexception
if   privexists backupdir
// if backup dir does not exist, go ahead and create it.
if   privmkdirs backupdir
throw standardexception newexception
sqlstate rawstore_cannot_create_backup_directory
file  backupdir
else
// entity with backup name exists, make sure it is a directory.
if   privisdirectory backupdir
throw standardexception newexception
sqlstate rawstore_cannot_backup_to_nondirectory
file  backupdir
// check if a user has given the backup as a database directory by
// mistake, backup path can not be a derby database directory.
// if a directory contains persistentservice.properties_name, it
// is assumed to be a derby database directory because derby
// databases always have this file.
if  privexists
new file backupdir  persistentservice properties_name
throw standardexception newexception
sqlstate rawstore_cannot_backup_into_database_directory
file  backupdir
boolean error   true
boolean renamed   false
boolean renamefailed   false
file oldbackup   null
file backupcopy   null
outputstreamwriter historyfile   null
storagefile dbhistoryfile   null
file backuphistoryfile   null
loginstant backupinstant   logfactory getfirstunflushedinstant
try
// get name of the current db, ie. database directory of current db.
storagefile dbase             storagefactory newstoragefile null
string      canonicaldbname   storagefactory getcanonicalname
int         lastsep
canonicaldbname lastindexof storagefactory getseparator
string      dbname
canonicaldbname substring lastsep   1
// append to end of history file
historyfile
privfilewriter
storagefactory newstoragefile backup_history   true
backupcopy   new file backupdir  dbname
loghistory
historyfile
messageservice gettextmessage
messageid store_backup_started
canonicaldbname
getfilepath backupcopy
// check if a backup copy of this database already exists,
if  privexists backupcopy
// first make a backup of the backup
oldbackup   new file backupdir  dbname
if  privexists oldbackup
if  privisdirectory oldbackup
privremovedirectory oldbackup
else
privdelete oldbackup
if   privrenameto backupcopy oldbackup
renamefailed   true
throw standardexception
newexception sqlstate rawstore_error_renaming_file
backupcopy  oldbackup
else
loghistory
historyfile
messageservice gettextmessage
messageid store_moved_backup
getfilepath backupcopy
getfilepath oldbackup
renamed   true
// create the backup database directory
if   privmkdirs backupcopy
throw standardexception newexception
sqlstate rawstore_cannot_create_backup_directory
file  backupcopy
dbhistoryfile   storagefactory newstoragefile backup_history
backuphistoryfile   new file backupcopy  backup_history
// copy the history file into the backup.
if  privcopyfile dbhistoryfile  backuphistoryfile
throw standardexception
newexception sqlstate rawstore_error_copying_file
dbhistoryfile  backuphistoryfile
// if they are any jar file stored in the database, copy them into
// the backup.
storagefile jardir
storagefactory newstoragefile fileresource jar_directory_name
if  privexists jardir
// find the list of schema directories under the jar dir and
// then copy only the plain files under those directories. one
// could just use the recursive copy of directory to copy all
// the files under the jar dir, but the problem with that is if
// a user gives jar directory as the backup path by mistake,
// copy will fail while copying the backup dir onto itself in
// recursion
string  jarschemalist   privlist jardir
file backupjardir   new file backupcopy
fileresource jar_directory_name
// create the backup jar directory
if   privmkdirs backupjardir
throw standardexception newexception
sqlstate rawstore_cannot_create_backup_directory
file  backupjardir
for  int i   0  i < jarschemalist length  i
storagefile jarschemadir
storagefactory newstoragefile jardir  jarschemalist
file backupjarschemadir
new file backupjardir  jarschemalist
if   privcopydirectory jarschemadir  backupjarschemadir
byte null  null  false
throw standardexception
newexception sqlstate rawstore_error_copying_file
jarschemadir  backupjarschemadir
// save service properties into the backup, read in property
// from service.properties file, remove logdevice from it,
// then write it to the backup.
storagefile logdir   logfactory getlogdirectory
try
string name   monitor getmonitor   getservicename this
persistentservice ps
monitor getmonitor   getservicetype this
string fullname   ps getcanonicalservicename name
properties prop
ps getserviceproperties fullname   properties null
storagefile defaultlogdir
storagefactory newstoragefile
logfactory log_directory_name
if   logdir equals defaultlogdir
prop remove attribute log_device
if  sanitymanager debug
sanitymanager assert
prop getproperty attribute log_device     null
loghistory historyfile
messageservice gettextmessage
messageid store_edited_serviceprops
// save the service properties into the backup.
ps saveserviceproperties backupcopy getpath    prop  false
catch standardexception se
loghistory
historyfile
messageservice gettextmessage
messageid store_error_edit_serviceprops    se
return     skip the rest and let finally block clean up
// incase of encrypted database and the key is an external
// encryption key, there is an extra file with name
// attribute.crypto_external_key_verify_file, this file should be
// copied in to the backup.
storagefile verifykeyfile
storagefactory newstoragefile
attribute crypto_external_key_verify_file
if  privexists verifykeyfile
file backupverifykeyfile
new file
backupcopy  attribute crypto_external_key_verify_file
if  privcopyfile verifykeyfile  backupverifykeyfile
throw standardexception
newexception sqlstate rawstore_error_copying_file
verifykeyfile  backupverifykeyfile
file logbackup
new file backupcopy  logfactory log_directory_name
// this is wierd, delete it
if  privexists logbackup
privremovedirectory logbackup
// create the log directory
if   privmkdirs logbackup
throw standardexception newexception
sqlstate rawstore_cannot_create_backup_directory
file  logbackup
// do a checkpoint to get the persistent store up to date.
logfactory checkpoint this  datafactory  xactfactory  true
// start the transaction log  backup.
logfactory startlogbackup logbackup
file segbackup   new file backupcopy
// create the data segment directory
if   privmkdirs segbackup
throw standardexception newexception
sqlstate rawstore_cannot_create_backup_directory
file  segbackup
// backup all the information in the data segment.
datafactory backupdatafiles t  segbackup
loghistory historyfile
messageservice gettextmessage
messageid store_data_seg_backup_completed
getfilepath segbackup
// copy the log that got generated after the backup started to
// backup location and tell the logfactory that backup has come
// to end.
logfactory endlogbackup logbackup
loghistory historyfile
messageservice gettextmessage
messageid store_copied_log
getfilepath logdir
getfilepath logbackup
error   false
catch  ioexception ioe
throw standardexception newexception
sqlstate rawstore_unexpected_exception  ioe
finally
try
if  error
// abort all activity related to backup in the log factory.
logfactory abortlogbackup
// remove the half backed up copy
// unless the error occured during  rename process;
// inwhich case 'backupcopy' refers to the previous backup
// not an half backed one.
if  renamefailed
privremovedirectory backupcopy
if  renamed
// recover the old backup
privrenameto oldbackup backupcopy
loghistory historyfile
messageservice gettextmessage
messageid store_backup_aborted
else
// success, remove the old backup copy
if  renamed    privexists oldbackup
// get rid of the old backup
privremovedirectory oldbackup
loghistory historyfile
messageservice gettextmessage
messageid store_removed_backup
getfilepath oldbackup
loghistory historyfile
messageservice gettextmessage
messageid store_backup_completed
backupinstant
// copy the updated version of history file with current
// backup information into the backup.
if  privcopyfile dbhistoryfile  backuphistoryfile
throw standardexception
newexception sqlstate rawstore_error_copying_file
dbhistoryfile  backuphistoryfile
historyfile close
catch  ioexception ioe
try
historyfile close
catch  ioexception ioe2
throw standardexception newexception
sqlstate rawstore_unexpected_exception  ioe
/**
* backup the database to a backup directory and enable the log archive
* mode that will keep the archived log files required for roll-forward
* from this version backup.
*
* @param backupdir the name of the directory where the backup should be
*                  stored. this directory will be created if it
*                  does not exist.
*
* @param deleteonlinearchivedlogfiles
*                  if true deletes online archived
*                  log files that exist before this backup, delete
*                  will occur  only after the backup is  complete.
*
* @param wait      if <tt>true</tt>, waits for  all the backup blocking
*                  operations in progress to finish.
*
* @exception standardexception thrown on error.
*/
public void backupandenablelogarchivemode
string backupdir
boolean deleteonlinearchivedlogfiles
boolean wait
throws standardexception
boolean enabledlogarchive   false
try
// enable the log archive mode, if it is not already enabled.
if  logfactory logarchived
logfactory enablelogarchivemode
enabledlogarchive   true
backup backupdir  wait
// after successful backup delete the archived log files
// that are not necessary to do a roll-forward recovery
// from this backup if requested.
if  deleteonlinearchivedlogfiles
logfactory deleteonlinearchivedlogfiles
catch  throwable error
// on any errors , disable the log archive, if it
// is enabled on this call.
if  enabledlogarchive
logfactory disablelogarchivemode
throw standardexception plainwrapexception error
/*
* disable the log archive mode and delete the archived log files
* if requested.
*
* @param deleteonlinearchivedlogfiles
*              if true deletes online archived
*              log files that exist before this backup, delete
*              will occur  only after the backup is  complete.
* @exception standardexception thrown on error.
*/
public void disablelogarchivemode boolean deleteonlinearchivedlogfiles
throws standardexception
logfactory disablelogarchivemode
if deleteonlinearchivedlogfiles
logfactory deleteonlinearchivedlogfiles
/*
* restore any remaining files from backup that are not
* restored by the individual factories.
*  1) copy jar files from backup..
*  2) copy backup history file.
*/
private void restoreremainingfrombackup string backuppath
throws standardexception
// if they are any jar files in the backup copy,
// copy them into the database directory, if they
// are not already there.
file backupjardir   new file backuppath
fileresource jar_directory_name
storagefile dbjardir
storagefactory newstoragefile fileresource jar_directory_name
if   privexists dbjardir     privexists backupjardir
if   privcopydirectory backupjardir  dbjardir
throw standardexception newexception
sqlstate unable_to_copy_file_from_backup
backupjardir  dbjardir
// copy the backup history file from the backup.
storagefile dbhistoryfile
storagefactory newstoragefile backup_history
file backuphistoryfile   new file backuppath  backup_history
// if this is a roll-forward recovery, backup history file
// will already there in the database and will be the latest
// copy; if it exists, do not copy from backup.
if   privexists dbhistoryfile
if   privcopyfile backuphistoryfile  dbhistoryfile
throw standardexception
newexception sqlstate rawstore_error_copying_file
backuphistoryfile  dbhistoryfile
public void idle   throws standardexception
datafactory idle
public transactioninfo gettransactioninfo
return xactfactory gettransactioninfo
public scanhandle openflushedscan databaseinstant start  int groupsiwant
throws standardexception
return logfactory openflushedscan start groupsiwant
public daemonservice getdaemon
return rawstoredaemon
public void createfinished   throws standardexception
xactfactory createfinished
datafactory createfinished
/**
* get jbms properties relavent to raw store
* @exception standardexception standard derby error policy
*/
public void getrawstoreproperties persistentset set
throws standardexception
logfactory getlogfactoryproperties set
/*
** backup restore
*/
/**
freeze persistent store.  reads can still happen, only cannot write.
@exception standardexception standard derby error policy
*/
public void freezepersistentstore   throws standardexception
// do a checkpoint to get the persistent store up to date.
logfactory checkpoint this  datafactory  xactfactory true
logfactory freezepersistentstore
/**
freeze persistent store.  reads can still happen, only cannot write.
@exception standardexception standard derby error policy
*/
public void unfreezepersistentstore   throws standardexception
logfactory unfreezepersistentstore
/*
** data encryption/decryption support
*/
/*
* setup encryption engines.
*/
private void setupencryptionengines boolean create  properties properties
throws standardexception
// check if user has requested to encrypt the database or it is an
// encrypted database.
string dataencryption
properties getproperty attribute data_encryption
databaseencrypted   boolean valueof dataencryption  booleanvalue
boolean reencrypt   false
if   create
// check if database is already encrypted, by directly peeking at the
// database service propertes instead of the properties passed
// to this method. by looking at properties to the boot method ,
// one can not differentiate if user is requesting for database
// encryption or the database is already encrypted because
// attribute.data_encryption is used  to store in the
// service properties to indicate that database
// is encrypted and also users can specify it as url attribute
// to encrypt and existing database.
string name   monitor getmonitor   getservicename this
persistentservice ps   monitor getmonitor   getservicetype this
string canonicalname   ps getcanonicalservicename name
properties serviceprops   ps getserviceproperties canonicalname
properties null
dataencryption   serviceprops getproperty attribute data_encryption
boolean encrypteddatabase   boolean valueof dataencryption  booleanvalue
if   encrypteddatabase     databaseencrypted
// it it not an encrypted database, user is asking to
// encrypt an un-encrypted database.
encryptdatabase   true
// set database as un-encrypted, we will set it as encrypted
// after encrypting the existing data.
databaseencrypted   false
else
// check if the user has requested to renecrypt  an
// encrypted datbase with new encryption password/key.
if  encrypteddatabase
if  properties getproperty
attribute new_boot_password     null
reencrypt   true
else if  properties getproperty
attribute new_crypto_external_key     null
reencrypt   true
encryptdatabase   reencrypt
// note: if user specifies attribute.data_encryption on the
// connection url by mistake on an already encrypted database,
// it is ignored.
// prevent attempt to (re)encrypt of a read-only database
if  encryptdatabase
if  isreadonly
if  reencrypt
throw standardexception newexception
sqlstate cannot_reencrypt_readonly_database
else
throw standardexception newexception
sqlstate cannot_encrypt_readonly_database
// setup encryption engines.
if  databaseencrypted    encryptdatabase
// check if database is configured for encryption, during
// configuration  some of the properties database; so that
// user does not have to specify them on the url everytime.
// incase of re-encryption of an already of encrypted database
// only some information needs to updated; it is not treated
// like the configuring the database for encryption first time.
boolean setupencryption   create     encryptdatabase      reencrypt
// start the cipher factory module, that is is used to create
// instances of the cipher factory with specific enctyption
// properties.
cipherfactorybuilder cb     cipherfactorybuilder
monitor startsystemmodule org apache derby iapi reference module cipherfactorybuilder
// create instance of the cipher factory with the
// specified encryption properties.
currentcipherfactory   cb createcipherfactory setupencryption
properties
false
// the database can be encrypted using an encryption key that is given at
// connection url. for security reasons, this key is not made persistent
// in the database. but it is necessary to verify the encryption key
// whenever booting the database if it is similar to the key that was used
// during creation time. this needs to happen before we access the data/logs to
// avoid the risk of corrupting the database because of a wrong encryption key.
// please note this verification process does not provide any added security
// but is intended to allow to fail gracefully if a wrong encryption key
// is used during boot time
currentcipherfactory verifykey setupencryption  storagefactory  properties
// initializes the encryption and decryption engines
encryptionengine   currentcipherfactory
createnewcipher cipherfactory encrypt
// at creation time of an encrypted database, store the encryption block size
// for the algorithm. store this value as property given by
// rawstorefactory.encryption_blocksize. this value
// is made persistent by storing it in service.properties
// to connect to an existing database, retrieve the value and use it for
// appropriate padding.
// the  default value of encryption block size is 8,
// to allow for downgrade issues
// before support for aes (beetle6023), default encryption block size supported
// was 8
if setupencryption
encryptionblocksize   encryptionengine getencryptionblocksize
// in case of database create, store the encryption block
// size. incase of reconfiguring the existing datbase, this
// will be saved after encrypting the exisiting data.
if  create
properties put rawstorefactory encryption_blocksize
string valueof encryptionblocksize
else
if properties getproperty rawstorefactory encryption_blocksize     null
encryptionblocksize   integer parseint properties getproperty
rawstorefactory encryption_blocksize
else
encryptionblocksize   encryptionengine getencryptionblocksize
decryptionengine   currentcipherfactory
createnewcipher cipherfactory decrypt
random   currentcipherfactory getsecurerandom
if  encryptdatabase
if  reencrypt
// create new cipher factory with the new encrytpion
// properties specified by the user. this cipher factory
// is used to create the new encryption/decryption
// engines to reencrypt the database with the new
// encryption keys.
newcipherfactory
cb createcipherfactory setupencryption
properties
true
newdecryptionengine
newcipherfactory createnewcipher cipherfactory decrypt
newencryptionengine
newcipherfactory createnewcipher cipherfactory encrypt
else
// there is only one engine when configuring an
// unencrypted database for encryption
newdecryptionengine   decryptionengine
newencryptionengine   encryptionengine
// save the encryption properties if encryption is enabled
// at database creation time.
if create
currentcipherfactory saveproperties properties
/**
encrypt cleartext into ciphertext.
@see cipherprovider#encrypt
@exception standardexception standard derby error policy
*/
public int encrypt byte cleartext  int offset  int length
byte ciphertext  int outputoffset
boolean newengine
throws standardexception
if   databaseencrypted    false    encryptdatabase    false
encryptionengine    null    newencryptionengine    null
throw standardexception newexception
sqlstate store_feature_not_implemented
counter_encrypt
if  newengine
return newencryptionengine encrypt cleartext  offset  length
ciphertext  outputoffset
else
return encryptionengine encrypt cleartext  offset  length
ciphertext  outputoffset
/**
decrypt cleartext from ciphertext.
@see cipherprovider#decrypt
@exception standardexception standard derby error policy
*/
public int decrypt byte ciphertext  int offset  int length
byte cleartext  int outputoffset
throws standardexception
if  databaseencrypted    false    decryptionengine    null
throw standardexception newexception
sqlstate store_feature_not_implemented
counter_decrypt
return decryptionengine decrypt ciphertext  offset  length
cleartext  outputoffset
/**
returns the encryption block size used by the algorithm at time of
creation of an encrypted database
*/
public int getencryptionblocksize
return encryptionblocksize
public int random
// don't synchronize it, the more random the better.
return databaseencrypted ? random nextint     0
public serializable changebootpassword properties properties  serializable changepassword
throws standardexception
if  isreadonly
throw standardexception newexception sqlstate database_read_only
if   databaseencrypted
throw standardexception newexception sqlstate database_not_encrypted
if  changepassword    null
throw standardexception newexception sqlstate null_boot_password
if    changepassword instanceof string
throw standardexception newexception sqlstate non_string_bp
// the new bootpassword is expected to be of the form
// oldkey , newkey.
string changestring    string changepassword
return currentcipherfactory changebootpassword  string changepassword  properties  encryptionengine
/**
* (re) encryption testing debug flags that are used to
* simulate error/crash conditions for testing purposes.
* when any one of the following flags are set to true
* in the debug mode, re-encryption will fail at that point.
*/
public static final string test_reencrypt_crash_before_commt
sanitymanager debug ?     null
public static final string test_reencrypt_crash_after_commt
sanitymanager debug ?     null
public static final string test_reencrypt_crash_after_switch_to_newkey
sanitymanager debug ?     null
public static final string test_reencrypt_crash_after_checkpoint
sanitymanager debug ?     null
public static final string
test_reencrypt_crash_after_recovery_undo_logfile_delete
sanitymanager debug ?

public static final string
test_reencrypt_crash_after_recovery_undo_reverting_key
sanitymanager debug ?

public static final string
test_reencrypt_crash_before_recovery_final_cleanup
sanitymanager debug ?

/**
* when the input debug flag is set, an expception
* is throw when run in the debug mode.
*/
private void crashondebugflag string debugflag
boolean reencrypt
throws standardexception
if  sanitymanager debug
// if the test debug flag is set, throw an
// exception to simulate error cases.
if  sanitymanager debug_on debugflag
standardexception se   standardexception newexception
reencrypt ? sqlstate database_reencryption_failed
sqlstate database_encryption_failed
debugflag
markcorrupt se
throw se
/*
* configure the database for encryption, with the  specified
* encryption  properties.
*
* basic idea is to encrypt all the containers with new password/key
* specified by the user and keep old versions of the data to
* rollback the database to the state before the configuration of database
* with new encryption attributes. users can configure the database with
* new encryption  attributes at boot time only; advantage of this approach
* is that there will not be any concurrency issues to handle because
* no users will be modifying the data.
*
* first step is to encrypt the existing data with new encryption
* attributes  and then update the encryption properties for
* the database. configuring  an un-encrypted database for
* encryption problem is a minor variation of  re-encrypting an
* encrypted database with new encryption key. the database
* reconfiguration with new encryption attributes is done under one
* transaction, if there is a crash/error before it is committed,
* then it  is rolled back and the database will be brought back to the
* state it was before the encryption.
*
* one trickey case in (re) encrypion of database is
* unlike standard protocol transaction  commit means all done,
* database (re) encryption process has to perform a checkpoint
*  with a newly generated key then only database  (re) encrption
* is complete, otherwise the problem  is recovery has to deal
* with transaction log that is encrypted with old encryption key and
* the new encryption key. this probelm is avoided  writing commit
* and new  checkpoint log record  to a new log file and encrypt the
* with a new key, if there is  crash before checkpoint records
* are updated , then on next boot the log file after the checkpoint
* is deleted before reovery,  which will be the one that is
* written with new encryption key and also contains commit record,
* so the commit record is also gone when  log file is deleted.
* recovery will not see the commit , so it will  rollback the (re)
* encryption and revert all the containers to the
* original versions.
*
* old container versions are deleted only when the check point
* with new encryption key is successful, not on post-commit.
*
* @param properties  properties related to this database.
* @exception standardexception standard derby error policy
*/
public void configuredatabaseforencryption properties properties
cipherfactory newcipherfactory
throws standardexception
boolean reencrypt    databaseencrypted    encryptdatabase
// check if the database can be encrypted.
canencryptdatabase reencrypt
boolean externalkeyencryption   false
if  properties getproperty attribute crypto_external_key     null
externalkeyencryption   true
// check point the datase, so that encryption does not have
// to encrypt the existing transactions logs.
logfactory checkpoint this  datafactory  xactfactory  true
// start a transaction that is to be used for encryting the database
rawtransaction transaction
xactfactory starttransaction
this
contextservice getfactory   getcurrentcontextmanager
accessfactoryglobals user_trans_name
try
datafactory encryptallcontainers transaction
// all the containers are (re) encrypted, now mark the database as
// encrypted if a plain database is getting configured for encryption
// or update the encryption the properties, in the
// service.properties ..etc.
if  sanitymanager debug
crashondebugflag test_reencrypt_crash_before_commt  reencrypt
// check if the checkpoint is currently in the last log file,
// otherwise force a checkpoint and then do a log switch,
// after setting up a new encryption key
if   logfactory ischeckpointinlastlogfile
// perfrom a checkpoint, this is a reference checkpoint
// to find if the re(encryption) is complete.
logfactory checkpoint this  datafactory  xactfactory  true
encryptdatabase   false
// let the log factory know that database is
// (re) encrypted and ask it to flush the log,
// before enabling encryption of the log with
// the new key.
logfactory setdatabaseencrypted true
// let the log factory and data factory know that
// database is encrypted.
if   reencrypt
// mark in the raw store that the database is
// encrypted.
databaseencrypted   true
datafactory setdatabaseencrypted
else
// switch the encryption/decryption engine to the new ones.
decryptionengine   newdecryptionengine
encryptionengine   newencryptionengine
currentcipherfactory   newcipherfactory
// make the log factory ready to encrypt
// the transaction log with the new encryption
// key by switching to a new log file.
// if re-encryption is aborted for any reason,
// this new log file will be deleted, during
// recovery.
logfactory startnewlogfile
// mark that re-encryption is in progress in the
// service.properties, so that (re) encryption
// changes that can not be undone using the transaction
// log can be un-done before recovery starts.
// (like the changes to service.properties and
// any log files the can not be understood by the
// old encryption key), incase engine crashes
// after this point.
// if the crash occurs before this point, recovery
// will rollback the changes using the transaction
// log.
properties put rawstorefactory db_encryption_status
string valueof
rawstorefactory db_encryption_in_progress
if  reencrypt
// incase re-encryption, save the old
// encryption related properties, before
// doing updates with new values.
if  externalkeyencryption
// save the current copy of verify key file.
storagefile verifykeyfile
storagefactory newstoragefile
attribute crypto_external_key_verify_file
storagefile oldverifykeyfile
storagefactory newstoragefile
rawstorefactory crypto_old_external_key_verify_file
if  privcopyfile verifykeyfile  oldverifykeyfile
throw standardexception
newexception sqlstate rawstore_error_copying_file
verifykeyfile  oldverifykeyfile
// update the verify key file with the new key info.
currentcipherfactory verifykey reencrypt
storagefactory
properties
else
// save the current generated encryption key
string keystring
properties getproperty
rawstorefactory encrypted_key
if  keystring    null
properties put rawstorefactory old_encrypted_key
keystring
else
// save the encryption block size;
properties put rawstorefactory encryption_blocksize
string valueof encryptionblocksize
// save the new encryption properties into service.properties
currentcipherfactory saveproperties properties
if  sanitymanager debug
crashondebugflag
test_reencrypt_crash_after_switch_to_newkey
reencrypt
// commit the transaction that is used to
// (re) encrypt the database. note that
// this will be logged with newly generated
// encryption key in the new log file created
// above.
transaction commit
if  sanitymanager debug
crashondebugflag test_reencrypt_crash_after_commt
reencrypt
// force the checkpoint with new encryption key.
logfactory checkpoint this  datafactory  xactfactory  true
if  sanitymanager debug
crashondebugflag test_reencrypt_crash_after_checkpoint
reencrypt
// once the checkpont makes it to the log, re-encrption
// is complete. only cleanup is remaining ; update the
// re-encryption status flag to cleanup.
properties put rawstorefactory db_encryption_status
string valueof
rawstorefactory db_encryption_in_cleanup
// database is (re)encrypted successfuly,
// remove the old version of the container files.
datafactory removeoldversionofcontainers false
if  reencrypt
if  externalkeyencryption
// remove the saved copy of the verify.key file
storagefile oldverifykeyfile
storagefactory newstoragefile
rawstorefactory crypto_old_external_key_verify_file
if   privdelete oldverifykeyfile
throw standardexception newexception
sqlstate unable_to_delete_file
oldverifykeyfile
else
// remove the old encryption key property.
properties remove rawstorefactory old_encrypted_key
// (re) encrypion is done,  remove the (re)
// encryption status property.
properties remove rawstorefactory db_encryption_status
// close the transaction.
transaction close
catch  standardexception se
throw standardexception newexception
reencrypt ? sqlstate database_reencryption_failed
sqlstate database_encryption_failed
se
se getmessage
finally
// clear the new encryption engines.
newdecryptionengine   null
newencryptionengine   null
/**
* engine might have crashed during encryption of un-encrypted datbase
* or while re-encryptin an already encrypted database with a new key
* after all the containers or (re) encrypted. if crash has occured
* before all containers are encrypted, recovery wil un-do re-encryption
* using the transaction log, nothing to be done here.
*
* if crash has occured after database encryption status flag
* (rawstorefactory.db_encryption_status) is set, this method
* will do any cleanup necessary for the recovery to correctly
* perform the rollback if required.
*
*
*
* @param properties  properties related to this database.
* @exception standardexception standard derby error policy
*
*/
public void handleincompletedatabaseencryption properties properties
throws standardexception
// find what was the encryption status before database crashed.
int dbencryptionstatus   0
string dbencryptionstatusstr
properties getproperty rawstorefactory db_encryption_status
if   dbencryptionstatusstr    null
dbencryptionstatus   integer parseint dbencryptionstatusstr
boolean reencryption   false
// check if engine crashed when (re) encryption was in progress.
if  dbencryptionstatus    rawstorefactory db_encryption_in_progress
// check if it crashed immediately after completion or
// before. if the checkpoint is in the last log file
// encrypted with new encryption key, it is as good
// as complete. in this case just cleanup any uncleared
// flags and mark that database is encrypted.
if logfactory ischeckpointinlastlogfile
// database (re)encryption was successful, only
// cleanup is remaining. change the status to cleanup.
dbencryptionstatus   rawstorefactory db_encryption_in_cleanup
else
// crash occured before re-encrytion was completed.
// update the db re-encryption status and write to
// the service.properties that re-encryption
// needs to be undone. the reason this status need
// to be made persistent, it will help to correctly
// handle a crash in this routine after the log file
// encrypted with new key is deleted. if this flag
// is not set, on next reboot, above check
// will find checkpoint in the last log file and
// incorrecly assume (re) encryption is
// successful.
dbencryptionstatus    rawstorefactory db_encryption_in_undo
properties put rawstorefactory db_encryption_status
string valueof dbencryptionstatus
if  dbencryptionstatus    rawstorefactory db_encryption_in_undo
// delete the log file after the log file that has the checkpoint ,
// it has the data encrypted with the new key, including the commit
// record for the transaction that was used to (re)encrypt
// the database. by deleting the log file, we are forcing the
// recovery to rollback the (re)encryption of the database.
logfactory deletelogfileaftercheckpointlogfile
if  sanitymanager debug
crashondebugflag
test_reencrypt_crash_after_recovery_undo_logfile_delete
reencryption
// note : if a crash occurs at this point, then on reboot
// it will again be in the db_enryption_in__undo state,
// there will not be a file after the checkpoint log file,
// so no file will be deleted.
// check if this is a external key encryption and
// if it replace the current verify key file with
// the old copy.
storagefile verifykeyfile
storagefactory newstoragefile
attribute crypto_external_key_verify_file
if  privexists verifykeyfile
storagefile oldverifykeyfile
storagefactory newstoragefile
rawstorefactory crypto_old_external_key_verify_file
if  privexists oldverifykeyfile
if  privcopyfile oldverifykeyfile  verifykeyfile
throw standardexception
newexception sqlstate rawstore_error_copying_file
oldverifykeyfile  verifykeyfile
// only incase of re-encryption there should
// be old verify key file.
reencryption   true
else
// remove the verify key file.
if   privdelete verifykeyfile
throw standardexception newexception
sqlstate unable_to_delete_file
verifykeyfile
else
// database enrypted with boot password.
// replace the current encryption key with the old key
// in the service.properties file.
// retreive the old encryption key
string oldkeystring
properties getproperty rawstorefactory old_encrypted_key
if  oldkeystring    null
// set the current encrypted key to the old one.
properties put rawstorefactory encrypted_key
oldkeystring
// only incase of re-encryption there should
// be old encryted key .
reencryption   true
if   reencryption
// crash occured when database was getting reconfigured
// for encryption , all encryption properties should be
// removed from service.properties
// common props for external key or password.
properties remove attribute data_encryption
properties remove rawstorefactory log_encrypt_algorithm_version
properties remove rawstorefactory data_encrypt_algorithm_version
properties remove rawstorefactory encryption_blocksize
// properties specific to password based encryption.
properties remove attribute crypto_key_length
properties remove attribute crypto_provider
properties remove attribute crypto_algorithm
properties remove rawstorefactory encrypted_key
if  sanitymanager debug
crashondebugflag
test_reencrypt_crash_after_recovery_undo_reverting_key
reencryption
end of undo
if  dbencryptionstatus    rawstorefactory db_encryption_in_cleanup
// remove all the old versions of the  containers.
datafactory removeoldversionofcontainers true
if  sanitymanager debug
crashondebugflag
test_reencrypt_crash_before_recovery_final_cleanup
reencryption
// either the (re) encryption was complete ,
// or undone (except for rollback that needs to be
// done by the recovery). remove re-encryption specific
// flags from the service.properties and old copy
// of the verify key file.
// delete the old verify key file , if it exists.
storagefile oldverifykeyfile
storagefactory newstoragefile
rawstorefactory crypto_old_external_key_verify_file
if  privexists oldverifykeyfile
if   privdelete oldverifykeyfile
throw standardexception newexception
sqlstate unable_to_delete_file
oldverifykeyfile
else
// remove the old encryption key property.
properties remove rawstorefactory old_encrypted_key
// remove the re-encryptin status flag.
properties remove rawstorefactory db_encryption_status
/**
* checks if the database is in the right state to (re)encrypt it.
*
* @param  reencrypt true if the database getting encrypted
*                   with new password/key.
* @exception  standardexception
*             if there is global transaction in the prepared state or
*             if the database is not at the version 10.2 or above, this
*             feature is not supported or
*             if the log is archived for the database.
*/
private void canencryptdatabase boolean reencrypt
throws standardexception
string feature    reencrypt ?
// check if the database version is at 10.2 or above.
// encrytpion or re-encryption of the database
// is supported  only in version 10.2 or above.
logfactory checkversion
rawstorefactory derby_store_major_version_10
rawstorefactory derby_store_minor_version_2
feature
// database can not be (re)encrypted if there
// are any global transactions in the prepared state
// after the recovery. the reason for this restriction
// is that any transaction log before the encryption can not
// be read once database is reconfigure with new encryption
// key.
if  xactfactory haspreparedxact
if reencrypt
throw standardexception newexception
sqlstate reencryption_prepared_xact_exist
else
throw standardexception newexception
sqlstate encryption_prepared_xact_exist
// check if the database has the log archived.
// database can not be congured of encryption or
// or re-encrypt it with a new key when the database
// log is being archived. the reason for this restriction is
// it will create a scenarion where users will
// have some logs encrypted with new key and some with old key
// when rollforward recovery is performed.
if  logfactory logarchived
if reencrypt
throw standardexception newexception
sqlstate cannot_reencrypt_log_archived_database
else
throw standardexception newexception
sqlstate cannot_encrypt_log_archived_database
/*
**
*/
public standardexception markcorrupt standardexception originalerror
logfactory markcorrupt originalerror
datafactory markcorrupt originalerror
xactfactory markcorrupt originalerror
return originalerror
/*
* class specific methods
*/
/* subclass can override this method to load different submodules */
public string gettransactionfactorymodule
return transactionfactory module
public string getdatafactorymodule
return datafactory module
public string getlogfactorymodule
return logfactory module
private void loghistory outputstreamwriter historyfile  string msg  throws ioexception
date d   new date
historyfile write d tostring         msg
historyfile flush
/*
* get the file path. if the canonical path can be obtained then return the
* canonical path, otherwise just return the abstract path. typically if
* there are no permission to read user.dir when  running under security
* manager canonical path can not be obtained.
*
* this method is used to a write path name to error/status log file, where it
* would be nice to print full paths but not esstential that the user
* grant permissions to read user.dir property.
*/
private string getfilepath storagefile file
string path   privgetcanonicalpath file
if path    null
return path
else
//can not get the canoncal path,
// return the abstract path
return file getpath
/*
* get the file path.  if the canonical path can be obtained then return the
* canonical path, otherwise just return the abstract path. typically if
* there are no permission to read user.dir when  running under security
* manager canonical path can not be obtained.
*
* this method is used to a write a file path name to error/status log file,
* where it would be nice to print full paths but not esstential that the user
* grant permissions to read user.dir property.
*
*/
private string getfilepath file file
string path   privgetcanonicalpath file
if path    null
return path
else
// can not get the canoncal path,
// return the abstract path
return file getpath
protected boolean privcopydirectory storagefile from  file to
return privcopydirectory from  to   byte null
string null  true
protected boolean privcopydirectory file from  storagefile to
return privcopydirectory from  to   byte null   string null
/**
* return an id which can be used to create a container.
* <p>
* return an id number with is greater than any existing container
* in the current database.  caller will use this to allocate future
* container numbers - most likely caching the value and then incrementing
* it as it is used.
* <p>
*
* @return the an id which can be used to create a container.
*
* @exception  standardexception  standard exception policy.
**/
public long getmaxcontainerid
throws standardexception
return datafactory getmaxcontainerid
/**
*  check to see if a database has been upgraded to the required
*  level in order to use a store feature.
*
* @param requiredmajorversion  required database engine major version
* @param requiredminorversion  required database engine minor version
* @param feature               non-null to throw an exception, null to
*                              return the state of the version match.
*
* @return <code> true </code> if the database has been upgraded to
*         the required level, <code> false </code> otherwise.
*
* @exception  standardexception
*             if the database is not at the require version
*             when <code>feature</code> feature is
*             not <code> null </code>.
*/
public boolean checkversion
int     requiredmajorversion
int     requiredminorversion
string  feature
throws standardexception
return
logfactory checkversion
requiredmajorversion  requiredminorversion  feature
/*
these methods require priv blocks when run under a security manager.
*/
private synchronized outputstreamwriter privfilewriter  storagefile filename  boolean append  throws ioexception
actioncode   file_writer_action
actionstoragefile   filename
actionappend   append
try
return  outputstreamwriter  java security accesscontroller doprivileged  this
catch  java security privilegedactionexception pae
throw  ioexception  pae getexception
finally
actionstoragefile   null
private synchronized boolean privexists  file file
actioncode   regular_file_exists_action
actionregularfile   file
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionregularfile   null
private synchronized boolean privexists final storagefile file
actioncode   storage_file_exists_action
actionstoragefile   file
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionstoragefile   null
private synchronized boolean privdelete  file file
actioncode   regular_file_delete_action
actionregularfile   file
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionregularfile   null
private synchronized boolean privdelete storagefile file
actioncode   storage_file_delete_action
actionstoragefile   file
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionstoragefile   null
private synchronized boolean privmkdirs  file file
actioncode   regular_file_mkdirs_action
actionregularfile   file
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionregularfile   null
private synchronized boolean privisdirectory  file file
actioncode   regular_file_is_directory_action
actionregularfile   file
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionregularfile   null
private synchronized boolean privremovedirectory  file file
actioncode   regular_file_remove_directory_action
actionregularfile   file
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionregularfile   null
private synchronized boolean privrenameto  file file1  file file2
actioncode   regular_file_rename_to_action
actionregularfile   file1
actionregularfile2   file2
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionregularfile   null
actionregularfile2   null
private synchronized boolean privcopydirectory storagefile from
file to
byte buffer
string filter
boolean copysubdirs
actioncode   copy_storage_directory_to_regular_action
actionstoragefile   from
actionregularfile   to
actionbuffer   buffer
actionfilter   filter
actioncopysubdirs   copysubdirs
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionstoragefile   null
actionregularfile   null
actionbuffer   null
actionfilter   null
private synchronized boolean privcopydirectory  file from  storagefile to  byte buffer  string filter
actioncode   copy_regular_directory_to_storage_action
actionstoragefile   to
actionregularfile   from
actionbuffer   buffer
actionfilter   filter
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionstoragefile   null
actionregularfile   null
actionbuffer   null
actionfilter   null
private synchronized boolean privcopyfile  file from  storagefile to
actioncode   copy_regular_file_to_storage_action
actionstoragefile   to
actionregularfile   from
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionstoragefile   null
actionregularfile   null
private synchronized boolean privcopyfile  storagefile from  file to
actioncode   copy_storage_file_to_regular_action
actionstoragefile   from
actionregularfile   to
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionstoragefile   null
actionregularfile   null
private synchronized boolean privcopyfile  storagefile from  storagefile to
actioncode   copy_storage_file_to_storage_action
actionstoragefile   from
actiontostoragefile   to
try
object ret   accesscontroller doprivileged  this
return   boolean  ret  booleanvalue
catch  privilegedactionexception pae    return false      does not throw an exception
finally
actionstoragefile   null
actiontostoragefile   null
private synchronized string privlist final file file
actioncode   regular_file_list_directory_action
actionregularfile   file
try
return  string  accesscontroller doprivileged  this
catch  privilegedactionexception pae    return null      does not throw an exception
finally
actionregularfile   null
private synchronized string privlist final storagefile file
actioncode   storage_file_list_directory_action
actionstoragefile   file
try
return  string  accesscontroller doprivileged  this
catch  privilegedactionexception pae    return null      does not throw an exception
finally
actionstoragefile   null
private synchronized string privgetcanonicalpath final storagefile file
actioncode   storage_file_get_canonicalpath_action
actionstoragefile   file
try
return  string  accesscontroller doprivileged  this
catch  privilegedactionexception pae
return null
does not throw an exception
catch securityexception se
// there are no permission to get canonical path
// just return null.
return null
finally
actionstoragefile   null
private synchronized string privgetcanonicalpath final file file
actioncode   regular_file_get_canonicalpath_action
actionregularfile   file
try
return  string  accesscontroller doprivileged  this
catch  privilegedactionexception pae
return null
does not throw an exception
catch securityexception se
// there are no permission to get canonical path
// just return null.
return null
finally
actionregularfile   null
// privilegedexceptionaction method
public final object run   throws ioexception
switch actioncode
case file_writer_action
// security permission - mp1
return new outputstreamwriter  actionstoragefile getoutputstream  actionappend
case regular_file_exists_action
return reusefactory getboolean actionregularfile exists
case storage_file_exists_action
return reusefactory getboolean actionstoragefile exists
case regular_file_delete_action
return reusefactory getboolean actionregularfile delete
case storage_file_delete_action
return reusefactory getboolean actionstoragefile delete
case regular_file_mkdirs_action
// security permission - op4
return reusefactory getboolean actionregularfile mkdirs
case regular_file_is_directory_action
// security permission - mp1
return reusefactory getboolean actionregularfile isdirectory
case regular_file_remove_directory_action
// security permission - mp1, op5
return reusefactory getboolean fileutil removedirectory actionregularfile
case regular_file_rename_to_action
// security permission - op4
return reusefactory getboolean actionregularfile renameto actionregularfile2
case copy_storage_directory_to_regular_action
// security permission - mp1, op4
return reusefactory getboolean fileutil copydirectory storagefactory
actionstoragefile
actionregularfile
actionbuffer
actionfilter
actioncopysubdirs
case copy_regular_directory_to_storage_action
// security permission - mp1, op4
return reusefactory getboolean fileutil copydirectory  writablestoragefactory storagefactory
actionregularfile
actionstoragefile
actionbuffer
actionfilter
case copy_regular_file_to_storage_action
// security permission - mp1, op4
return reusefactory getboolean fileutil copyfile  writablestoragefactory  storagefactory
actionregularfile
actionstoragefile
case regular_file_list_directory_action
// security permission - mp1
return  string  actionregularfile list
case storage_file_list_directory_action
// security permission - mp1
return  string  actionstoragefile list
case copy_storage_file_to_regular_action
// security permission - mp1, op4
return reusefactory getboolean fileutil copyfile
writablestoragefactory  storagefactory
actionstoragefile
actionregularfile
case copy_storage_file_to_storage_action
// security permission - mp1, op4
return reusefactory getboolean fileutil copyfile
writablestoragefactory  storagefactory
actionstoragefile
actiontostoragefile
case regular_file_get_canonicalpath_action
// security permission - mp1
return  string  actionregularfile getcanonicalpath
case storage_file_get_canonicalpath_action
// security permission - mp1
return  string  actionstoragefile getcanonicalpath
return null
end of run