/*
derby - class org.apache.derby.impl.jdbc.transactionresourceimpl
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl jdbc
import org apache derby jdbc internaldriver
import org apache derby iapi services context context
import org apache derby iapi services context contextservice
import org apache derby iapi services context contextmanager
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi db database
import org apache derby iapi error standardexception
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi error exceptionseverity
import org apache derby iapi reference attribute
import org apache derby iapi reference sqlstate
import org apache derby iapi reference property
import org apache derby iapi util stringutil
import org apache derby iapi util idutil
import java util properties
import java sql sqlexception
/**
*	an instance of a transactionresourceimpl is a bundle of things that
*	connects a connection to the database - it is the transaction "context" in
*	a generic sense.  it is also the object of synchronization used by the
*	connection object to make sure only one thread is accessing the underlying
*	transaction and context.
*
*  <p>transactionresourceimpl not only serves as a transaction "context", it
*	also takes care of: <ol>
*	<li>context management: the pushing and popping of the context manager in
*		and out of the global context service</li>
*	<li>transaction demarcation: all calls to commit/abort/prepare/close a
*		transaction must route thru the transaction resource.
*	<li>error handling</li>
*	</ol>
*
*  <p>the only connection that have access to the transactionresource is the
*  root connection, all other nested connections (called proxyconnection)
*  accesses the transactionresource via the root connection.  the root
*  connection may be a plain embedconnection, or a detachableconnection (in
*  case of a xatransaction).  a nested connection must be a proxyconnection.
*  a proxyconnection is not detachable and can itself be a xa connection -
*  although an xatransaction may start nested local (proxy) connections.
*
*	<p> this is an example of how all the objects in this package relate to each
*		other.  in this example, the connection is nested 3 deep.
*		detachableconnection.
*	<p><pre>
*
*      lcc  cm   database  jdbcdriver
*       ^    ^    ^         ^
*       |    |    |         |
*      |======================|
*      | transactionresource  |
*      |======================|
*             ^  |
*             |  |
*             |  |      |---------------rootconnection----------|
*             |  |      |                                       |
*             |  |      |- rootconnection-|                     |
*             |  |      |                 |                     |
*             |  v      v                 |                     |
*|========================|      |=================|      |=================|
*|    embedconnection     |      | embedconnection |      | embedconnection |
*|                        |<-----|                 |<-----|                 |
*| (detachableconnection) |      | proxyconnection |      | proxyconnection |
*|========================|      |=================|      |=================|
*   ^                 | ^             ^                        ^
*   |                 | |             |                        |
*   ---rootconnection-- |             |                        |
*                       |             |                        |
*                       |             |                        |
* |======================|  |======================|  |======================|
* | connectionchild |  | connectionchild |  | connectionchild |
* |                      |  |                      |  |                      |
* |  (embedstatement)    |  |  (embedresultset)    |  |  (...)               |
* |======================|  |======================|  |======================|
*
* </pre>
* <p>a plain local connection <b>must</b> be attached (doubly linked with) to a
* transactionresource at all times.  a detachable connection can be without a
* transactionresource, and a transactionresource for an xatransaction
* (called  xatransactionresource) can be without a connection.
*
*
*/
public final class transactionresourceimpl
/*
** instance variables set up in the constructor.
*/
// conn is only present if tr is attached to a connection
protected contextmanager cm
protected contextservice csf
protected string username
private string dbname
private internaldriver driver
private string url
private string drdaid
// set these up after constructor, called by embedconnection
protected database database
protected languageconnectioncontext lcc
/**
* create a brand new connection for a brand new transaction
*/
transactionresourceimpl
internaldriver driver
string url
properties info  throws sqlexception
this driver   driver
csf   driver getcontextservicefactory
dbname   internaldriver getdatabasename url  info
this url   url
// the driver manager will push a user name
// into the properties if its getconnection(url, string, string)
// interface is used.  thus, we look there first.
// default to app.
username   idutil getusernamefromurlprops info
drdaid   info getproperty attribute drdaid_attr  null
// make a new context manager for this transactionresource
// note that the database api requires that the
// getcurrentcontextmanager call return the context manager
// associated with this session.  the jdbc driver assumes
// responsibility (for now) for tracking and installing
// this context manager for the thread, each time a database
// call is made.
cm   csf newcontextmanager
/**
* called only in embedconnection construtor.
* the local connection sets up the database in its constructor and sets it
* here.
*/
void setdatabase database db
if  sanitymanager debug
sanitymanager assert database    null
database   db
/*
* called only in embedconnection constructor.  create a new transaction
* by creating a lcc.
*
* the arguments are not used by this object, it is used by
* xatransactionresoruceimpl.  put them here so that there is only one
* routine to start a local connection.
*/
void starttransaction   throws standardexception  sqlexception
// setting up local connection
lcc   database setupconnection cm  username  drdaid  dbname
/**
* return instance variables to embedconnection.  resolve: given time, we
* should perhaps stop giving out reference to these things but instead use
* the transaction resource itself.
*/
internaldriver getdriver
return driver
contextservice getcsf
return  csf
/**
* need to be public because it is in the xatransactionresource interface
*/
contextmanager getcontextmanager
return  cm
languageconnectioncontext getlcc
return  lcc
string getdbname
return  dbname
string geturl
return  url
database getdatabase
return  database
standardexception shutdowndatabaseexception
standardexception se   standardexception newexception sqlstate shutdown_database  getdbname
se setreport standardexception report_never
return se
/**
* local transaction demarcation - note that global or xa transaction
* cannot commit thru the connection, they can only commit thru the
* xaresource, which uses the xa_commit or xa_rollback interface as a
* safeguard.
*/
void commit   throws standardexception
lcc usercommit
void rollback   throws standardexception
// lcc may be null if this is called in close.
if  lcc    null
lcc userrollback
/*
* context management
*/
/**
* an error happens in the constructor, pop the context.
*/
void clearcontextinerror
csf resetcurrentcontextmanager cm
cm   null
/**
* resolve: probably superfluous
*/
void clearlcc
lcc   null
final void setupcontextstack
if  sanitymanager debug
sanitymanager assert cm    null
csf setcurrentcontextmanager cm
final void restorecontextstack
if   csf    null      cm    null
return
csf resetcurrentcontextmanager cm
/*
* exception handling
*/
/**
* clean up the error and wrap the real exception in some sqlexception.
*/
final sqlexception handleexception throwable thrownexception
boolean autocommit
boolean rollbackonautocommit
throws sqlexception
try
if  sanitymanager debug
sanitymanager assert thrownexception    null
/*
just pass sql exceptions right back. we assume that jdbc driver
code has cleaned up sufficiently. not passing them through would mean
that all cleanuponerror methods would require knowledge of utils.
*/
if  thrownexception instanceof sqlexception
return  sqlexception  thrownexception
boolean checkforshutdown   false
if  thrownexception instanceof standardexception
standardexception se    standardexception  thrownexception
int severity   se getseverity
if  severity <  exceptionseverity statement_severity
/*
** if autocommit is on, then do a rollback
** to release locks if requested.  we did a stmt
** rollback in the cleanuponerror above, but we still
** may hold locks from the stmt.
*/
if  autocommit    rollbackonautocommit
se setseverity exceptionseverity transaction_severity
else if  sqlstate conn_interrupt equals se getmessageid
// an interrupt closed the connection.
checkforshutdown   true
// if cm is null, we don't have a connection context left,
// it was already removed.  all that's left to cleanup is
// jdbc objects.
if  cm  null
boolean isshutdown   cleanuponerror thrownexception
if  checkforshutdown    isshutdown
// change the error message to be a known shutdown.
thrownexception   shutdowndatabaseexception
return wrapinsqlexception thrownexception
catch  throwable t
if  cm  null       something to let us cleanup?
cm cleanuponerror t
/*
we'd rather throw the throwable,
but then javac complains...
we assume if we are in this degenerate
case that it is actually a java exception
*/
throw wrapinsqlexception t
//throw t;
/**
* wrap a <code>throwable</code> in an <code>sqlexception</code>.
*
* @param thrownexception a <code>throwable</code>
* @return <code>thrownexception</code>, if it is an
* <code>sqlexception</code>; otherwise, an <code>sqlexception</code> which
* wraps <code>thrownexception</code>
*/
public static sqlexception wrapinsqlexception throwable thrownexception
if  thrownexception    null
return null
if  thrownexception instanceof sqlexception
// server side jdbc can end up with a sqlexception in the nested
// stack. return the exception with no wrapper.
return  sqlexception  thrownexception
if  thrownexception instanceof standardexception
standardexception se    standardexception  thrownexception
if  se getcause      null
// se is a single, unchained exception. just convert it to an
// sqlexception.
return util generatecssqlexception se
// se contains a non-empty exception chain. we want to put all of
// the exceptions (including java exceptions) in the next-exception
// chain. therefore, call wrapinsqlexception() recursively to
// convert the cause chain into a chain of sqlexceptions.
return util seenextexception se getmessageid
se getarguments    wrapinsqlexception se getcause
// thrownexception is a java exception
return util javaexception thrownexception
/*
* transactionresource methods
*/
string getusername
return  username
boolean cleanuponerror throwable e
if  sanitymanager debug
sanitymanager assert cm    null
return cm cleanuponerror e
boolean isidle
// if no lcc, there is no transaction.
return  lcc    null    lcc gettransactionexecute   isidle
/*
* class specific methods
*/
/*
* is the underlaying database still active?
*/
boolean isactive
// database is null at connection open time
return  driver isactive        database    null     database isactive