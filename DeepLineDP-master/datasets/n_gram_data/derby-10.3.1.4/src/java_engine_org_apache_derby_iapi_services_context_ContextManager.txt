/*
derby - class org.apache.derby.iapi.services.context.contextmanager
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services context
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi error passthroughexception
import org apache derby iapi error standardexception
import org apache derby iapi services monitor monitor
import org apache derby iapi reference property
import org apache derby iapi services property propertyutil
import org apache derby iapi error exceptionseverity
import org apache derby iapi services i18n localefinder
import java util hashmap
import java util arraylist
import java util list
import java util collections
import java util locale
/**
*
* the contextmanager collects contexts as they are
* created. it maintains stacks of contexts by
* named ids, so that the top context of a given
* type can be returned. it also maintains a global
* stack so that contexts can be traversed in the
* order they were created.
* <p>
* the first implementation of the context manager
* assumes there is only one thread to worry about
* and that the user(s) of the class only create one
* instance of contextmanager.
*/
public class contextmanager
/**
* the ctxstack implement a stack on top of an arraylist (to avoid
* the inherent overhead associated with java.util.stack which is
* built on top of java.util.vector, which is fully
* synchronized).
*/
private static final class ctxstack
private arraylist stack_   new arraylist
// keeping a reference to the top element on the stack
// optimizes the frequent accesses to this element. the
// tradeoff is that pushing and popping becomes more
// expensive, but those operations are infrequent.
private context top_   null
void push context context
stack_ add context
top_   context
void pop
stack_ remove stack_ size   1
top_   stack_ isempty   ?
null    context  stack_ get stack_ size   1
void remove context context
if  context    top_
pop
return
stack_ remove stack_ lastindexof context
context top
return top_
boolean isempty     return stack_ isempty
list getunmodifiablelist
return collections unmodifiablelist stack_
/**
* empty arraylist to use as void value
*/
//private final arraylist voidarraylist_ = new arraylist(0);
/**
* hashmap that holds the context objects. the contexts are stored
* with a string key.
* @see contextmanager#pushcontext(context)
*/
private final hashmap ctxtable   new hashmap
/**
* list of all contexts
*/
private final arraylist holder   new arraylist
/**
* add a context object to the contextmanager. the object is added
* both to the holder list and to a stack for the specific type of
* context.
* @param newcontext the new context object
*/
public void pushcontext context newcontext
checkinterrupt
final string contextid   newcontext getidname
ctxstack idstack    ctxstack  ctxtable get contextid
// if the stack is null, create a new one.
if  idstack    null
idstack   new ctxstack
ctxtable put contextid  idstack
// add to top of id's stack
idstack push newcontext
// add to top of global stack too
holder add newcontext
/**
* obtain the last pushed context object of the type indicated by
* the contextid argument.
* @param contextid a string identifying the type of context
* @return the context object with the corresponding contextid, or null if not found
*/
public context getcontext string contextid
checkinterrupt
final ctxstack idstack    ctxstack  ctxtable get contextid
if  sanitymanager debug
sanitymanager assert  idstack    null
idstack isempty
idstack top   getidname      contextid
return  idstack  null?null idstack top
/**
* remove the last pushed context object, regardless of type. if
* there are no context objects, no action is taken.
*/
public void popcontext
checkinterrupt
// no contexts to remove, so we're done.
if  holder isempty
return
// remove the top context from the global stack
context thecontext    context  holder remove holder size   1
// now find its id and remove it from there, too
final string contextid   thecontext getidname
final ctxstack idstack    ctxstack  ctxtable get contextid
if  sanitymanager debug
sanitymanager assert  idstack    null
idstack isempty
idstack top   getidname      contextid
idstack pop
/**
* removes the specified context object. if
* the specified context object does not exist, the call will fail.
* @param thecontext the context object to remove.
*/
void popcontext context thecontext
checkinterrupt
if  sanitymanager debug
sanitymanager assert  holder isempty
// first, remove it from the global stack.
holder remove holder lastindexof thecontext
final string contextid   thecontext getidname
final ctxstack idstack    ctxstack  ctxtable get contextid
// now remove it from its id's stack.
idstack remove thecontext
/**
* is the contextmanager empty containing no contexts.
*/
final boolean isempty
return holder isempty
/**
* return an unmodifiable list reference to the arraylist backing
* ctxstack object for this type of contexts. this method allows
* fast traversal of all contexts on that stack. the first element
* in the list corresponds to the bottom of the stack. the
* assumption is that the stack will not be modified while it is
* being traversed.
* @param contextid the type of context stack to return.
* @return an unmodifiable "view" of the arraylist backing the stack
* @see org.apache.derby.impl.sql.conn.genericlanguageconnectioncontext#resetsavepoints()
* @see org.apache.derby.iapi.sql.conn.statementcontext#resetsavepoint()
*/
public final list getcontextstack string contextid
final ctxstack cs    ctxstack  ctxtable get contextid
return  cs  null?collections empty_list cs getunmodifiablelist
/**
@return true if the context manager is shutdown, false otherwise.
*/
public boolean cleanuponerror throwable error
if  shutdown
return true
if  errorstringbuilder    null
errorstringbuilder   new errorstringbuilder errorstream getheader
threaddeath seenthreaddeath   null
if  error instanceof threaddeath
seenthreaddeath    threaddeath  error
if  error instanceof passthroughexception
error     passthroughexception  error  getexception
boolean reporterror   reporterror error
if  reporterror
contextimpl lcc   null
stringbuffer sb   null
if    shutdown
// report an id for the message if possible
lcc    contextimpl  getcontext org apache derby iapi reference contextid lang_connection
if  lcc    null
sb   lcc appenderrorinfo
string cleanup
if  sb    null
sb append cleanup
cleanup   sb tostring
errorstringbuilder appendln cleanup
if   shutdown 		   do this only during normal processing
contextimpl sc    contextimpl  getcontext org apache derby iapi reference contextid lang_statement
// output the sql statement that failed in the log file.
if  sc    null
sb   sc appenderrorinfo
if  sb    null
errorstringbuilder appendln sb tostring
/*
revisit resolve
ensure that the traversal of the stack works in all
cases where contexts can  pop themselves *and*
contexts can pop other contexts off the stack.
*/
forever  for
int errorseverity   error instanceof standardexception ?
standardexception  error  getseverity
exceptionseverity no_applicable_severity
if  reporterror
errorstringbuilder stacktrace error
flusherrorstring
boolean	lasthandler   false
/*
walk down the stack, calling
cleanup on each context. we use
the vector interface to do this.
*/
cleanup 	for  int index   holder size     1  index >  0  index
try
if  lasthandler
break
context ctx     context  holder get index
lasthandler   ctx islasthandler errorseverity
ctx cleanuponerror error
catch  standardexception se
if  error instanceof standardexception
if  se getseverity   >   standardexception  error  getseverity
// ok, error handling raised a more severe error,
// restart with the more severe error
error   se
reporterror   reporterror se
if  reporterror
errorstream println     error getmessage
errorstream flush
continue forever
if  reporterror se
errorstringbuilder appendln     se getmessage
errorstringbuilder stacktrace se
flusherrorstring
/*
for a less severe error, keep with the last error
*/
continue cleanup
catch  throwable t
reporterror   reporterror t
if  error instanceof standardexception
/*
ok, error handling raised a more severe error,
restart with the more severe error
a throwable after a standardexception is always
more severe.
*/
error   t
if  reporterror
errorstream println     error getmessage
errorstream flush
continue forever
if  reporterror
errorstringbuilder appendln     t getmessage
errorstringbuilder stacktrace t
flusherrorstring
if  t instanceof threaddeath
if  seenthreaddeath    null
throw seenthreaddeath
seenthreaddeath    threaddeath  t
/*
for a less severe error, just continue with the last
error
*/
continue cleanup
if  reporterror
errorstream println
errorstream flush
if  seenthreaddeath    null
throw seenthreaddeath
return false
synchronized boolean  setinterrupted context c
boolean interruptme    c    null     holder contains c
if  interruptme
this shutdown   true
return interruptme
/**
check to see if we have been interrupted. if we have then
a shutdownexception will be thrown. this will be either the
one passed to interrupt or a generic one if some outside
source interrupted the thread.
*/
private void checkinterrupt
if  shutdown
// system must have changed underneath us
throw new shutdownexception
/**
set the locale for this context.
*/
public void setlocalefinder localefinder finder
this finder   finder
private locale messagelocale
public void setmessagelocale string localeid  throws standardexception
this messagelocale   monitor getlocalefromstring localeid
public locale getmessagelocale
if  messagelocale    null
return messagelocale
else if  finder    null
try
return finder getcurrentlocale
catch  standardexception se
return locale getdefault
/**
* flush the built up error string to whereever
* it is supposed to go, and reset the error string
*/
private void flusherrorstring
errorstream print errorstringbuilder get   tostring
errorstream flush
errorstringbuilder reset
/*
** class methods
*/
private boolean reporterror throwable t
if  t instanceof standardexception
standardexception se    standardexception  t
switch  se report
case standardexception report_default
int level   se getseverity
return  level >  logseveritylevel
level    exceptionseverity no_applicable_severity
case standardexception report_never
return false
case standardexception report_always
default
return true
return   t instanceof shutdownexception
/**
* constructs a new instance. no ctxstacks are inserted into the
* hashmap as they will be allocated on demand.
* @param csf the contextservice owning this contextmanager
* @param stream error stream for reporting errors
*/
contextmanager contextservice csf  headerprintwriter stream
errorstream   stream
owningcsf   csf
logseveritylevel   propertyutil getsystemint property log_severity_level
sanitymanager debug ? 0   exceptionseverity session_severity
final contextservice owningcsf
private int		logseveritylevel
private headerprintwriter errorstream
private errorstringbuilder errorstringbuilder
private boolean shutdown
private localefinder finder
/**
* the thread that owns this contextmanager, set by
* contextservice.setcurrentcontextmanager and reset
* by resetcurrentcontextmanager. only a single
* thread can be active in a contextmanager at any time,
* and the thread only "owns" the contextmanager while
* it is executing code within derby. in the jdbc case
* setcurrentcontextmanager is called at the start of
* a jbdc method and resetcurrentcontextmanager on completion.
* nesting within the same thread is supported, such as server-side
* jdbc calls in a java routine or procedure. in that case
* the activecount will represent the level of nesting, in
* some situations.
* <br>
* @see contextservice#setcurrentcontextmanager(contextmanager)
* @see contextservice#resetcurrentcontextmanager(contextmanager)
* @see #activecount
*/
thread	activethread
/**
* count of the number of setcurrentcontextmanager calls
* by a single thread, for nesting situations with a single
* active contextmanager. if nesting is occuring with multiple
* different contextmanagers then this value is set to -1
* and nesting is represented by entries in a stack in the
* threadlocal variable, threadcontextlist.
*
* @see contextservice#threadcontextlist
*/
int		activecount