/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy runtime
import groovy lang closure
import groovy lang gstring
import groovy lang groovyruntimeexception
import groovy lang metamethod
import org codehaus groovy reflection cachedclass
import org codehaus groovy reflection fastarray
import org codehaus groovy reflection parametertypes
import org codehaus groovy reflection reflectioncache
import org codehaus groovy runtime wrappers wrapper
import java lang reflect array
import java lang reflect constructor
import java lang reflect modifier
import java math bigdecimal
import java math biginteger
import java util iterator
import java util list
import java util logging level
import java util logging logger
/**
* @author john wilson
* @author jochen theodorou
*/
public class metaclasshelper
public static final object empty_array
public static final class empty_type_array
public static final object array_with_null    null
protected static final logger log   logger getlogger metaclasshelper class getname
private static final int max_arg_len   12
private static final int vargs_shift   28
public static final class empty_class_array   new class
public static boolean accessibletoconstructor final class at  final constructor constructor
boolean accessible   false
final int modifiers   constructor getmodifiers
if  modifier ispublic modifiers
accessible   true
else if  modifier isprivate modifiers
accessible   at getname   equals constructor getname
else if  modifier isprotected modifiers
boolean isaccessible   checkcompatiblepackages at  constructor
if  isaccessible    null
accessible   isaccessible booleanvalue
else
boolean flag   false
class clazz   at
while   flag    clazz    null
if  clazz equals constructor getdeclaringclass
flag   true
break
if  clazz equals object class
break
clazz   clazz getsuperclass
accessible   flag
else
boolean isaccessible   checkcompatiblepackages at  constructor
if  isaccessible    null
accessible   isaccessible booleanvalue
return accessible
private static boolean checkcompatiblepackages class at  constructor constructor
if  at getpackage      null    constructor getdeclaringclass   getpackage      null
return boolean true
if  at getpackage      null    constructor getdeclaringclass   getpackage      null
return boolean false
if  at getpackage      null    constructor getdeclaringclass   getpackage      null
return boolean false
if  at getpackage   equals constructor getdeclaringclass   getpackage
return boolean true
return null
public static object aswrapperarray object parameters  class componenttype
object ret   null
if  componenttype    boolean class
boolean array    boolean  parameters
ret   new object
for  int i   0  i < array length  i
ret   new boolean array
else if  componenttype    char class
char array    char  parameters
ret   new object
for  int i   0  i < array length  i
ret   new character array
else if  componenttype    byte class
byte array    byte  parameters
ret   new object
for  int i   0  i < array length  i
ret   new byte array
else if  componenttype    int class
int array    int  parameters
ret   new object
for  int i   0  i < array length  i
ret   integer valueof array
else if  componenttype    short class
short array    short  parameters
ret   new object
for  int i   0  i < array length  i
ret   new short array
else if  componenttype    long class
long array    long  parameters
ret   new object
for  int i   0  i < array length  i
ret   new long array
else if  componenttype    double class
double array    double  parameters
ret   new object
for  int i   0  i < array length  i
ret   new double array
else if  componenttype    float class
float array    float  parameters
ret   new object
for  int i   0  i < array length  i
ret   new float array
return ret
/**
* @param list          the original list
* @param parametertype the resulting array type
* @return the constructed array
*/
public static object asprimitivearray list list  class parametertype
class arraytype   parametertype getcomponenttype
object objarray   array newinstance arraytype  list size
for  int i   0  i < list size    i
object obj   list get i
if  arraytype isprimitive
if  obj instanceof integer
array setint objarray  i    integer  obj  intvalue
else if  obj instanceof double
array setdouble objarray  i    double  obj  doublevalue
else if  obj instanceof boolean
array setboolean objarray  i    boolean  obj  booleanvalue
else if  obj instanceof long
array setlong objarray  i    long  obj  longvalue
else if  obj instanceof float
array setfloat objarray  i    float  obj  floatvalue
else if  obj instanceof character
array setchar objarray  i    character  obj  charvalue
else if  obj instanceof byte
array setbyte objarray  i    byte  obj  bytevalue
else if  obj instanceof short
array setshort objarray  i    short  obj  shortvalue
else
array set objarray  i  obj
return objarray
private static final class primitives
byte class  byte class  short class  short class
int class  integer class  long class  long class
biginteger class  float class  float class
double class  double class  bigdecimal class
number class  object class
private static final int primitive_distance_table
//              byte    byte    short   short   int     integer     long    long    biginteger  float   float   double  double  bigdecimal, number, object
byte   0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15
byte   1  0  2  3  4  5  6  7  8  9  10  11  12  13  14  15
short   14  15  0  1  2  3  4  5  6  7  8  9  10  11  12  13
short   14  15  1  0  2  3  4  5  6  7  8  9  10  11  12  13
int   14  15  12  13  0  1  2  3  4  5  6  7  8  9  10  11
integer   14  15  12  13  1  0  2  3  4  5  6  7  8  9  10  11
long   14  15  12  13  10  11  0  1  2  3  4  5  6  7  8  9
long   14  15  12  13  10  11  1  0  2  3  4  5  6  7  8  9
biginteger   14  15  12  13  10  11  8  9  0  1  2  3  4  5  6  7
float   14  15  12  13  10  11  8  9  7  0  1  2  3  4  5  6
float   14  15  12  13  10  11  8  9  7  1  0  2  3  4  5  6
double   14  15  12  13  10  11  8  9  7  5  6  0  1  2  3  4
double   14  15  12  13  10  11  8  9  7  5  6  1  0  2  3  4
bigdecimal   14  15  12  13  10  11  8  9  7  5  6  3  4  0  1  2
numer   14  15  12  13  10  11  8  9  7  5  6  3  4  2  0  1
object   14  15  12  13  10  11  8  9  7  5  6  3  4  2  1  0
private static int getprimitiveindex class c
for  byte i   0  i < primitives length  i
if  primitives    c  return i
return  1
private static int getprimitivedistance class from  class to
// we know here that from!=to, so a distance of 0 is never valid
// get primitive type indexes
int fromindex   getprimitiveindex from
int toindex   getprimitiveindex to
if  fromindex     1    toindex     1  return  1
return primitive_distance_table
private static int getmaximuminterfacedistance class c  class interfaceclass
// -1 means a mismatch
if  c    null  return  1
// 0 means a direct match
if  c    interfaceclass  return 0
class interfaces   c getinterfaces
int max    1
for  int i   0  i < interfaces length  i
int sub   getmaximuminterfacedistance interfaces  interfaceclass
// we need to keep the -1 to track the mismatch, a +1
// by any means could let it look like a direct match
// we want to add one, because there is an interface between
// the interface we search for and the interface we are in.
if  sub   1  sub
// we are interested in the longest path only
max   math max max  sub
// we do not add one for super classes, only for interfaces
int superclassmax   getmaximuminterfacedistance c getsuperclass    interfaceclass
return math max max  superclassmax
private static long calculateparameterdistance class argument  cachedclass parameter
/**
* note: when shifting with 32 bit, you should only shift on a long. if you do
*       that with an int, then i==(i<<32), which means you loose the shift
*       information
*/
if  parameter gettheclass      argument  return 0
if  parameter isinterface
return getmaximuminterfacedistance argument  parameter gettheclass   <<1
long objectdistance   0
if  argument    null
long pd   getprimitivedistance parameter gettheclass    argument
if  pd     1  return pd << 32
// add one to dist to be sure interfaces are prefered
objectdistance    primitives length   1
class clazz   reflectioncache autoboxtype argument
while  clazz    null
if  clazz    parameter gettheclass    break
if  clazz    gstring class    parameter gettheclass      string class
objectdistance    2
break
clazz   clazz getsuperclass
objectdistance    3
else
// choose the distance to object if a parameter is null
// this will mean that object is prefered over a more
// specific type
// remove one to dist to be sure object is prefered
objectdistance
class clazz   parameter gettheclass
if  clazz isprimitive
objectdistance    2
else
while  clazz    object class
clazz   clazz getsuperclass
objectdistance    2
return objectdistance << 32
public static long calculateparameterdistance class arguments  parametertypes pt
cachedclass  parameters   pt getparametertypes
if  parameters length    0  return 0
long ret   0
int novargslength   parameters length 1
// if the number of parameters does not match we have
// a vargs usage
//
// case a: arguments.length<parameters.length
//
//         in this case arguments.length is always equal to
//         novargslength because only the last parameter
//         might be a optional vargs parameter
//
// case b: arguments.lenth>parameters.length
//
//         in this case all arguments with a index bigger than
//         paramminus1 are part of the vargs, so a
//         distance calculaion needs to be done against
//         parameters[novargslength].getcomponenttype()
//
// case c: arguments.length==parameters.length &&
//         isassignablefrom( parameters[novargslength],
//                           arguments[novargslength] )
//
//         in this case we have no vargs, so calculate directly
//
// case d: arguments.length==parameters.length &&
//         !isassignablefrom( parameters[novargslength],
//                            arguments[novargslength] )
//
//         in this case we have a vargs case again, we need
//         to calculate arguments[novargslength] against
//         parameters[novargslength].getcomponenttype
// first we calculate all arguments, that are for sure not part
// of vargs.  since the minimum for arguments is novargslength
// we can safely iterate to this point
for  int i   0  i < novargslength  i
ret    calculateparameterdistance arguments  parameters
if  arguments length  parameters length
// case c&d, we use basetype to calculate and set it
// to the value we need according to case c and d
cachedclass basetype   parameters     case c
if   parameters isassignablefrom arguments
basetype  reflectioncache getcachedclass basetype gettheclass   getcomponenttype        case d
ret  2l<<vargs_shift     penalty for vargs
ret    calculateparameterdistance arguments  basetype
else if  arguments length>parameters length
// case b
// we give our a vargs penalty for each exceeding argument and iterate
// by using parameters[novargslength].getcomponenttype()
ret     2 arguments length parameters length <<vargs_shift
cachedclass vargstype   reflectioncache getcachedclass parameters gettheclass   getcomponenttype
for  int i   novargslength  i < arguments length  i
ret    calculateparameterdistance arguments  vargstype
else
// case a
// we give a penalty for vargs, since we have no direct
// match for the last argument
ret  1l<<vargs_shift
return ret
public static string capitalize string property
return property substring 0  1  touppercase     property substring 1  property length
/**
* @param methods the methods to choose from
* @return the method with 1 parameter which takes the most general type of
*         object (e.g. object)
*/
public static object chooseemptymethodparams fastarray methods
object vargsmethod   null
final int len   methods size
final object data   methods getarray
for  int i   0  i    len    i
object method   data
final parametertypes pt    parametertypes  method
cachedclass paramtypes   pt getparametertypes
int paramlength   paramtypes length
if  paramlength    0
return method
else if  paramlength    1    pt isvargsmethod empty_array
vargsmethod   method
return vargsmethod
/**
* @param methods the methods to choose from
* @return the method with 1 parameter which takes the most general type of
*         object (e.g. object) ignoring primitve types
*/
public static object choosemostgeneralmethodwith1nullparam fastarray methods
// let's look for methods with 1 argument which matches the type of the
// arguments
cachedclass closestclass   null
cachedclass closestvargsclass   null
object answer   null
int closestdist    1
final int len   methods size
for  int i   0  i    len    i
final object data   methods getarray
object method   data
final parametertypes pt    parametertypes  method
cachedclass paramtypes   pt getparametertypes
int paramlength   paramtypes length
if  paramlength    0    paramlength > 2  continue
cachedclass thetype   paramtypes
if  thetype isprimitive  continue
if  paramlength    2
if   pt isvargsmethod array_with_null   continue
if  closestclass    null
closestvargsclass   paramtypes
closestclass   thetype
answer   method
else if  closestclass gettheclass      thetype gettheclass
if  closestvargsclass    null  continue
cachedclass newvargsclass   paramtypes
if  closestvargsclass    null    isassignablefrom newvargsclass gettheclass    closestvargsclass gettheclass
closestvargsclass   newvargsclass
answer   method
else if  isassignablefrom thetype gettheclass    closestclass gettheclass
closestvargsclass   paramtypes
closestclass   thetype
answer   method
else
if  closestclass    null    isassignablefrom thetype gettheclass    closestclass gettheclass
closestvargsclass   null
closestclass   thetype
answer   method
closestdist    1
else
// closestclass and thetype are not in a subtype relation, we need
// to check the distance to object
if  closestdist     1  closestdist   closestclass getsuperclassdistance
int newdist   thetype getsuperclassdistance
if  newdist < closestdist
closestdist   newdist
closestvargsclass   null
closestclass   thetype
answer   method
return answer
//
private static int calculatesimplifiedclassdistancetoobject class clazz
int objectdistance   0
while  clazz    null
clazz   clazz getsuperclass
objectdistance
return objectdistance
/**
* @param list   a list of metamethods
* @param method the metamethod of interest
* @return true if a method of the same matching prototype was found in the
*         list
*/
public static boolean containsmatchingmethod list list  metamethod method
for  iterator iter   list iterator    iter hasnext
metamethod amethod    metamethod  iter next
cachedclass params1   amethod getparametertypes
cachedclass params2   method getparametertypes
if  params1 length    params2 length
boolean matches   true
for  int i   0  i < params1 length  i
if  params1    params2
matches   false
break
if  matches
return true
return false
/**
* param instance array to the type array
*
* @param args the arguments
* @return the types of the arguments
*/
public static class converttotypearray object args
if  args    null
return null
int s   args length
class ans   new class
for  int i   0  i < s  i
object o   args
if  o    null
ans   null
else if  o instanceof wrapper
ans     wrapper  o  gettype
else
ans   o getclass
return ans
public static object makecommonarray object arguments  int offset  class fallback
// arguments.leght>0 && !=null
class baseclass   null
for  int i   offset  i < arguments length  i
if  arguments    null  continue
class argclass   arguments getclass
if  baseclass    null
baseclass   argclass
else
for    baseclass    object class  baseclass   baseclass getsuperclass
if  baseclass isassignablefrom argclass   break
if  baseclass    null
// all arguments were null
baseclass   fallback
object result   makearray null  baseclass  arguments length   offset
system arraycopy arguments  offset  result  0  arguments length   offset
return result
public static object makearray object obj  class secondary  int length
class baseclass   secondary
if  obj    null
baseclass   obj getclass
/*if (gstring.class.isassignablefrom(baseclass)) {
baseclass = gstring.class;
}*/
return array newinstance baseclass  length
public static groovyruntimeexception createexceptiontext string init  metamethod method  object object  object args  throwable reason  boolean setreason
return new groovyruntimeexception
init
method
object
invokerhelper tostring args
reason
setreason ? reason   null
protected static string getclassname object object
if  object    null  return null
return  object instanceof class  ?   class  object  getname     object getclass   getname
/**
* returns a callable object for the given method name on the object.
* the object acts like a closure in that it can be called, like a closure
* and passed around - though really its a method pointer, not a closure per se.
*
* @param object the object containing the method
* @param methodname the method of interest
* @return the resulting closure-like method pointer
*/
public static closure getmethodpointer object object  string methodname
return new methodclosure object  methodname
public static boolean isassignablefrom class classtotransformto  class classtotransformfrom
if  classtotransformto    classtotransformfrom  return true
if  classtotransformfrom    null  return true
if  classtotransformto    object class  return true
classtotransformto   reflectioncache autoboxtype classtotransformto
classtotransformfrom   reflectioncache autoboxtype classtotransformfrom
if  classtotransformto    classtotransformfrom  return true
// note: there is no coercion for boolean and char. range matters, precision doesn't
if  classtotransformto    integer class
if  classtotransformfrom    integer class
classtotransformfrom    short class
classtotransformfrom    byte class
classtotransformfrom    biginteger class
return true
else if  classtotransformto    double class
if  classtotransformfrom    double class
classtotransformfrom    integer class
classtotransformfrom    long class
classtotransformfrom    short class
classtotransformfrom    byte class
classtotransformfrom    float class
classtotransformfrom    bigdecimal class
classtotransformfrom    biginteger class
return true
else if  classtotransformto    bigdecimal class
if  classtotransformfrom    double class
classtotransformfrom    integer class
classtotransformfrom    long class
classtotransformfrom    short class
classtotransformfrom    byte class
classtotransformfrom    float class
classtotransformfrom    bigdecimal class
classtotransformfrom    biginteger class
return true
else if  classtotransformto    biginteger class
if  classtotransformfrom    integer class
classtotransformfrom    long class
classtotransformfrom    short class
classtotransformfrom    byte class
classtotransformfrom    biginteger class
return true
else if  classtotransformto    long class
if  classtotransformfrom    long class
classtotransformfrom    integer class
classtotransformfrom    short class
classtotransformfrom    byte class
return true
else if  classtotransformto    float class
if  classtotransformfrom    float class
classtotransformfrom    integer class
classtotransformfrom    long class
classtotransformfrom    short class
classtotransformfrom    byte class
return true
else if  classtotransformto    short class
if  classtotransformfrom    short class
classtotransformfrom    byte class
return true
else if  classtotransformto    string class
if  classtotransformfrom    string class
gstring class isassignablefrom classtotransformfrom
return true
return reflectioncache isassignablefrom classtotransformto  classtotransformfrom
public static boolean isgenericsetmethod metamethod method
return  method getname   equals
method getparametertypes   length    2
protected static boolean issuperclass class claszz  class superclass
while  claszz    null
if  claszz    superclass  return true
claszz   claszz getsuperclass
return false
public static boolean parametersarecompatible class arguments  class parameters
if  arguments length    parameters length  return false
for  int i   0  i < arguments length  i
if   isassignablefrom parameters  arguments   return false
return true
public static void logmethodcall object object  string methodname  object arguments
string classname   getclassname object
string logname       classname       methodname
logger objlog   logger getlogger logname
if   objlog isloggable level finer   return
stringbuffer msg   new stringbuffer methodname
msg append
if  arguments    null
for  int i   0  i < arguments length
msg append normalizedvalue arguments
if    i < arguments length
msg append
msg append
objlog logp level finer  classname  msg tostring
protected static string normalizedvalue object argument
string value
try
value   argument tostring
if  value length   > max_arg_len
value   value substring 0  max_arg_len   2
if  argument instanceof string
value       value
catch  exception e
value   shortname argument
return value
protected static string shortname object object
if  object    null    object getclass      null  return
string name   getclassname object
if  name    null  return        very  defensive
int lastdotpos   name lastindexof
if  lastdotpos < 0    lastdotpos >  name length     1  return name
return name substring lastdotpos   1
public static class wrap class classes
class wrappedarguments   new class
for  int i   0  i < wrappedarguments length  i
class c   classes
if  c    null  continue
if  c isprimitive
if  c    integer type
c   integer class
else if  c    byte type
c   byte class
else if  c    long type
c   long class
else if  c    double type
c   double class
else if  c    float type
c   float class
else if  issuperclass c  gstring class
c   string class
wrappedarguments   c
return wrappedarguments
public static boolean sameclasses class params  object arguments  boolean weaknullcheck
if  params length    arguments length
return false
for  int i   params length 1  i >  0  i
object arg   arguments
if  arg    null
if   weaknullcheck
return false
else
if  params    arg getclass
arg instanceof wrapper     params      wrapper arg  gettype
return false
return true
public static boolean sameclasses class params  object arguments
if  params length    arguments length
return false
for  int i   params length 1  i >  0  i
object arg   arguments
if  arg    null
params    arg getclass
arg instanceof wrapper
params      wrapper arg  gettype
return false
return true
public static boolean sameclass class params  object arg
return   arg    null
params    arg getclass
arg instanceof wrapper
params      wrapper  arg  gettype
public static class castargumentstoclassarray object argtypes
if  argtypes    null  return empty_class_array
class classes   new class
for  int i   0  i < argtypes length  i
object argtype   argtypes
if  argtype instanceof class
classes    class  argtype
else if  argtype    null
classes   null
else
//                throw new illegalargumentexception("arguments to method [respondsto] must be of type java.lang.class!");
classes   argtype getclass
return classes
public static void unwrap object arguments
//
// temp code to ignore wrapped parameters
// the new mop will deal with these properly
//
for  int i   0  i    arguments length  i
if  arguments instanceof wrapper
arguments     wrapper  arguments  unwrap