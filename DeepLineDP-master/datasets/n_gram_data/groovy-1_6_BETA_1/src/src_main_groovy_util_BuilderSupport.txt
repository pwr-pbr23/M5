/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package groovy util
import groovy lang closure
import groovy lang groovyobjectsupport
import groovy lang missingmethodexception
import java util list
import java util map
import org codehaus groovy runtime invokerhelper
/**
* an abstract base class for creating arbitrary nested trees of objects
* or events
*
* @author <a href="mailto:james@coredevelopers.net">james strachan</a>
* @version $revision$
*/
public abstract class buildersupport extends groovyobjectsupport
private object current
private closure namemappingclosure
private final buildersupport proxybuilder
public buildersupport
this proxybuilder   this
public buildersupport buildersupport proxybuilder
this null  proxybuilder
public buildersupport closure namemappingclosure  buildersupport proxybuilder
this namemappingclosure   namemappingclosure
this proxybuilder   proxybuilder
/**
* convenience method when no arguments are required
* @return the result of the call
* @param methodname the name of the method to invoke
*/
public object invokemethod string methodname
return invokemethod methodname  null
public object invokemethod string methodname  object args
object name   getname methodname
return doinvokemethod methodname  name  args
protected object doinvokemethod string methodname  object name  object args
object node   null
closure closure   null
list list   invokerhelper aslist args
//system.out.println("called invokemethod with name: " + name + " arguments: " + list);
switch  list size
case 0
node   proxybuilder createnode name
break
case 1
object object   list get 0
if  object instanceof map
node   proxybuilder createnode name   map  object
else if  object instanceof closure
closure    closure  object
node   proxybuilder createnode name
else
node   proxybuilder createnode name  object
break
case 2
object object1   list get 0
object object2   list get 1
if  object1 instanceof map
if  object2 instanceof closure
closure    closure  object2
node   proxybuilder createnode name   map  object1
else
node   proxybuilder createnode name   map  object1  object2
else
if  object2 instanceof closure
closure    closure  object2
node   proxybuilder createnode name  object1
else if  object2 instanceof map
node   proxybuilder createnode name   map  object2  object1
else
throw new missingmethodexception name tostring    getclass    list toarray    false
break
case 3
object arg0   list get 0
object arg1   list get 1
object arg2   list get 2
if  arg0 instanceof map    arg2 instanceof closure
closure    closure  arg2
node   proxybuilder createnode name   map  arg0  arg1
else if  arg1 instanceof map    arg2 instanceof closure
closure    closure  arg2
node   proxybuilder createnode name   map  arg1  arg0
else
throw new missingmethodexception name tostring    getclass    list toarray    false
break
default
throw new missingmethodexception name tostring    getclass    list toarray    false
if  current    null
proxybuilder setparent current  node
if  closure    null
// push new node on stack
object oldcurrent   current
current   node
// lets register the builder as the delegate
setclosuredelegate closure  node
closure call
current   oldcurrent
proxybuilder nodecompleted current  node
return proxybuilder postnodecompletion current  node
/**
* a strategy method to allow derived builders to use
* builder-trees and switch in different kinds of builders.
* this method should call the setdelegate() method on the closure
* which by default passes in this but if node is-a builder
* we could pass that in instead (or do something wacky too)
*
* @param closure the closure on which to call setdelegate()
* @param node the node value that we've just created, which could be
* a builder
*/
protected void setclosuredelegate closure closure  object node
closure setdelegate this
protected abstract void setparent object parent  object child
protected abstract object createnode object name
protected abstract object createnode object name  object value
protected abstract object createnode object name  map attributes
protected abstract object createnode object name  map attributes  object value
/**
* a hook to allow names to be converted into some other object
* such as a qname in xml or objectname in jmx.
*
* @param methodname the name of the desired method
* @return the object representing the name
*/
protected object getname string methodname
if  namemappingclosure    null
return namemappingclosure call methodname
return methodname
/**
* a hook to allow nodes to be processed once they have had all of their
* children applied.
*
* @param node the current node being processed
* @param parent the parent of the node being processed
*/
protected void nodecompleted object parent  object node
/**
* a hook to allow nodes to be processed once they have had all of their
* children applied and allows the actual node object that represents
* the markup element to be changed
*
* @param node the current node being processed
* @param parent the parent of the node being processed
* @return the node, possibly new, that represents the markup element
*/
protected object postnodecompletion object parent  object node
return node
protected object getcurrent
return current
protected void setcurrent object current
this current   current