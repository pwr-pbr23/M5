/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy classgen
import groovy lang groovyclassloader
import groovy lang groovyobject
import groovy lang metaclass
import org codehaus groovy ast
import org codehaus groovy ast expr
import org codehaus groovy ast stmt blockstatement
import org codehaus groovy ast stmt expressionstatement
import org codehaus groovy ast stmt returnstatement
import org codehaus groovy ast stmt statement
import org codehaus groovy syntax runtimeparserexception
import org codehaus groovy syntax token
import org codehaus groovy syntax types
import org objectweb asm label
import org objectweb asm methodvisitor
import org objectweb asm opcodes
import java lang ref softreference
import java lang reflect field
import java lang reflect modifier
import java util
/**
* verifies the ast node and adds any defaulted ast code before
* bytecode generation occurs.
*
* @author <a href="mailto:james@coredevelopers.net">james strachan</a>
* @version $revision$
*/
public class verifier implements groovyclassvisitor  opcodes
public static final string __timestamp
public static final string __timestamp__
private classnode classnode
private methodnode methodnode
public classnode getclassnode
return classnode
public methodnode getmethodnode
return methodnode
/**
* add code to implement groovyobject
* @param node
*/
public void visitclass final classnode node
this classnode   node
if   classnode getmodifiers     opcodes acc_interface  >0
//interfaces have no constructors, but this code expects one,
//so create a dummy and don't add it to the class node
constructornode dummy   new constructornode 0 null
addinitialization node  dummy
node visitcontents this
return
classnode classnodes   classnode getinterfaces
list interfaces   new arraylist
for  int i   0  i < classnodes length  i
classnode classnode   classnodes
interfaces add classnode getname
set interfaceset   new hashset interfaces
if  interfaceset size      interfaces size
throw new runtimeparserexception     interfaces  classnode
adddefaultparametermethods node
adddefaultparameterconstructors node
string _myclassfieldname
while  node getfield _myclassfieldname     null
_myclassfieldname   _myclassfieldname
final string myclassfieldname   _myclassfieldname
final string classinternalname   bytecodehelper getclassinternalname node
//        fieldnode myclassfield = node.addfield(myclassfieldname, acc_private|acc_static, classhelper.class_type, new classexpression(node));
//        myclassfield.setsynthetic(true);
string _staticmetaclassfieldname
while  node getfield _staticmetaclassfieldname     null
_staticmetaclassfieldname   _staticmetaclassfieldname
final string staticmetaclassfieldname   _staticmetaclassfieldname
fieldnode staticmetaclassfield   node addfield staticmetaclassfieldname  acc_public acc_static  classhelper make softreference class false   null
staticmetaclassfield setsynthetic true
list getstaticmetaclasscode   new linkedlist
getstaticmetaclasscode add  new bytecodeinstruction
public void visit methodvisitor mv
mv visitfieldinsn getstatic  classinternalname  staticmetaclassfieldname
mv visitvarinsn astore  1
mv visitvarinsn aload  1
label l0   new label
mv visitjumpinsn ifnull  l0
mv visitvarinsn aload  1
mv visitmethodinsn invokevirtual
mv visittypeinsn checkcast
mv visitinsn dup
mv visitvarinsn astore  1
label l1   new label
mv visitjumpinsn ifnonnull  l1
mv visitlabel l0
mv visitvarinsn aload  0
mv visitmethodinsn invokestatic
mv visitvarinsn astore  1
mv visittypeinsn new
mv visitinsn dup
mv visitvarinsn aload  1
mv visitmethodinsn invokespecial
mv visitfieldinsn putstatic  classinternalname  staticmetaclassfieldname
mv visitlabel l1
mv visitvarinsn aload  1
mv visitinsn areturn
node addsyntheticmethod
acc_protected
classhelper make metaclass class
parameter empty_array
classnode empty_array
new bytecodesequence getstaticmetaclasscode
if   node isderivedfromgroovyobject
node addinterface classhelper make groovyobject class
propertynode metaclassproperty
node addproperty    acc_public  classhelper metaclass_type  new bytecodeexpression
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitinsn dup
mv visitmethodinsn invokevirtual classinternalname
mv visitfieldinsn putfield  classinternalname
mv visitvarinsn aload  0
mv visitfieldinsn getfield  classinternalname
public classnode gettype
return classhelper metaclass_type
null  null
metaclassproperty setsynthetic true
fieldnode metaclassfield   metaclassproperty getfield
metaclassfield setmodifiers metaclassfield getmodifiers     acc_transient
list getmetaclasscode   new linkedlist
getmetaclasscode add  new bytecodeinstruction
public void visit methodvisitor mv
label nulllabel   new label
mv visitvarinsn aload  0
mv visitfieldinsn getfield  classinternalname
mv visitinsn dup
mv visitjumpinsn ifnull  nulllabel
mv visitinsn areturn
mv visitlabel nulllabel
mv visitinsn pop
mv visitvarinsn aload  0
mv visitinsn dup
mv visitmethodinsn invokevirtual classinternalname
mv visitfieldinsn putfield  classinternalname
mv visitvarinsn aload  0
mv visitfieldinsn getfield  classinternalname
mv visitinsn areturn
node addsyntheticmethod
acc_public
classhelper make metaclass class
parameter empty_array
classnode empty_array
new bytecodesequence getmetaclasscode
// @todo we should check if the base class implements the invokemethod method
// let's add the invokemethod implementation
classnode superclass   node getsuperclass
boolean adddelegateobject
node instanceof innerclassnode    superclass equals classhelper closure_type
superclass equals classhelper gstring_type
// don't do anything as the base class implements the invokemethod
if   adddelegateobject
list invokemethodcode   new linkedlist
invokemethodcode add  new bytecodeinstruction
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitmethodinsn invokevirtual  classinternalname
mv visitvarinsn aload  0
mv visitvarinsn aload  1
mv visitvarinsn aload  2
mv visitmethodinsn invokeinterface
mv visitinsn areturn
node addsyntheticmethod
acc_public
classhelper object_type
new parameter
new parameter classhelper string_type
new parameter classhelper object_type
classnode empty_array
new bytecodesequence invokemethodcode
if   node isscript
list getpropertycode   new linkedlist
getpropertycode add  new bytecodeinstruction
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitmethodinsn invokevirtual  classinternalname
mv visitvarinsn aload  0
mv visitvarinsn aload  1
mv visitmethodinsn invokeinterface
mv visitinsn areturn
node addsyntheticmethod
acc_public acc_synthetic
classhelper object_type
new parameter   new parameter classhelper string_type
classnode empty_array
new bytecodesequence getpropertycode
list setpropertycode   new linkedlist
setpropertycode add  new bytecodeinstruction
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitmethodinsn invokevirtual  classinternalname
mv visitvarinsn aload  0
mv visitvarinsn aload  1
mv visitvarinsn aload  2
mv visitmethodinsn invokeinterface
mv visitinsn return
node addsyntheticmethod
acc_public
classhelper void_type
new parameter
new parameter classhelper string_type
new parameter classhelper object_type
classnode empty_array
new bytecodesequence setpropertycode
if  node getdeclaredconstructors   isempty
constructornode constructor   new constructornode acc_public  null
constructor setsynthetic true
node addconstructor constructor
if    node instanceof innerclassnode       add a static timestamp field to the class
addtimestamp node
addinitialization node
checkreturninobjectinitializer node getobjectinitializerstatements
node getobjectinitializerstatements   clear
addcovariantmethods node
node visitcontents this
protected void addtimestamp classnode node
fieldnode timetagfield   new fieldnode
verifier __timestamp
modifier public   modifier static
classhelper long_type
//"",
node
new constantexpression new long system currenttimemillis
// alternatively , fieldnode timetagfield = sourceunit.createfieldnode("public static final long __timestamp = " + system.currenttimemillis() + "l");
timetagfield setsynthetic true
node addfield timetagfield
timetagfield   new fieldnode
verifier __timestamp__   string valueof system currenttimemillis
modifier public   modifier static
classhelper long_type
//"",
node
new constantexpression new long 0
// alternatively , fieldnode timetagfield = sourceunit.createfieldnode("public static final long __timestamp = " + system.currenttimemillis() + "l");
timetagfield setsynthetic true
node addfield timetagfield
private void checkreturninobjectinitializer list init
codevisitorsupport cvs   new codevisitorsupport
public void visitreturnstatement returnstatement statement
throw new runtimeparserexception   statement
for  iterator iterator   init iterator    iterator hasnext
statement stm    statement  iterator next
stm visit cvs
public void visitconstructor constructornode node
codevisitorsupport checksuper   new codevisitorsupport
boolean firstmethodcall   true
string type null
public void visitmethodcallexpression methodcallexpression call
if   firstmethodcall  return
firstmethodcall   false
string name   call getmethodasstring
// the name might not be null if the method name is a gstring for example
if  name  null  return
if   name equals        name equals     return
type name
call getarguments   visit this
type null
public void visitvariableexpression variableexpression expression
if  type  null  return
string name   expression getname
if   name equals        name equals     return
throw new runtimeparserexception   name   type   expression
statement s   node getcode
//todo why can a statement can be null?
if  s    null  return
s visit checksuper
public void visitmethod methodnode node
this methodnode   node
statement statement   node getcode
if   node isvoidmethod
if  statement instanceof expressionstatement
expressionstatement expstmt    expressionstatement  statement
node setcode new returnstatement expstmt getexpression
else if  statement instanceof blockstatement
blockstatement block    blockstatement  statement
// let's copy the list so we create a new block
list list   new arraylist block getstatements
if   list isempty
int idx   list size     1
statement last    statement  list get idx
if  last instanceof expressionstatement
expressionstatement expstmt    expressionstatement  last
list set idx  new returnstatement expstmt
else if    last instanceof returnstatement
list add new returnstatement constantexpression null
else
list add new returnstatement constantexpression null
node setcode new blockstatement filterstatements list  block getvariablescope
else if   node isabstract
blockstatement newblock   new blockstatement
if  statement instanceof blockstatement
newblock addstatements filterstatements   blockstatement statement  getstatements
else
newblock addstatement filterstatement statement
newblock addstatement returnstatement return_null_or_void
node setcode newblock
if  node getname   equals       node isstatic
parameter params   node getparameters
if  params length    1
parameter param   params
if  param gettype      null    param gettype    classhelper object_type
param settype classhelper string_type makearray
statement   node getcode
if  statement  null  statement visit new verifiercodevisitor this
public void visitfield fieldnode node
private boolean methodneedsreplacement methodnode m
// no method found, we need to replace
if  m  null  return true
// method is in current class, nothing to be done
if  m getdeclaringclass    this getclassnode    return false
// do not overwrite final
if   m getmodifiers   acc_final   0  return false
return true
public void visitproperty propertynode node
string name   node getname
fieldnode field   node getfield
string gettername       capitalize name
string settername       capitalize name
statement getterblock   node getgetterblock
if  getterblock    null
methodnode getter   classnode getgettermethod gettername
if   node isprivate      methodneedsreplacement getter
getterblock   creategetterblock node  field
statement setterblock   node getsetterblock
if  setterblock    null
methodnode setter   classnode getsettermethod settername
if    node isprivate
node getmodifiers   acc_final   0
methodneedsreplacement setter
setterblock   createsetterblock node  field
if  getterblock    null
methodnode getter
new methodnode gettername  node getmodifiers    node gettype    parameter empty_array  classnode empty_array  getterblock
getter setsynthetic true
classnode addmethod getter
visitmethod getter
if  classhelper boolean_type  node gettype      classhelper boolean_type  node gettype
string secondgettername       capitalize name
methodnode secondgetter
new methodnode secondgettername  node getmodifiers    node gettype    parameter empty_array  classnode empty_array  getterblock
secondgetter setsynthetic true
classnode addmethod secondgetter
visitmethod secondgetter
if  setterblock    null
parameter setterparametertypes     new parameter node gettype
methodnode setter
new methodnode settername  node getmodifiers    classhelper void_type  setterparametertypes  classnode empty_array  setterblock
setter setsynthetic true
classnode addmethod setter
visitmethod setter
// implementation methods
//-------------------------------------------------------------------------
private interface defaultargsaction
void call argumentlistexpression arguments  parameter newparams  methodnode method
/**
* creates a new helper method for each combination of default parameter expressions
*/
protected void adddefaultparametermethods final classnode node
list methods   new arraylist node getmethods
adddefaultparameters methods  new defaultargsaction
public void call argumentlistexpression arguments  parameter newparams  methodnode method
methodcallexpression expression   new methodcallexpression variableexpression this_expression  method getname    arguments
expression setimplicitthis true
statement code   null
if  method isvoidmethod
code   new expressionstatement expression
else
code   new returnstatement expression
node addmethod method getname    method getmodifiers    method getreturntype    newparams  method getexceptions    code
protected void adddefaultparameterconstructors final classnode node
list methods   new arraylist node getdeclaredconstructors
adddefaultparameters methods  new defaultargsaction
public void call argumentlistexpression arguments  parameter newparams  methodnode method
constructornode ctor    constructornode  method
constructorcallexpression expression   new constructorcallexpression classnode this  arguments
statement code   new expressionstatement expression
node addconstructor ctor getmodifiers    newparams  ctor getexceptions    code
/**
* creates a new helper method for each combination of default parameter expressions
*/
protected void adddefaultparameters list methods  defaultargsaction action
for  iterator iter   methods iterator    iter hasnext
methodnode method    methodnode  iter next
if  method hasdefaultvalue
parameter parameters   method getparameters
int counter   0
list paramvalues   new arraylist
int size   parameters length
for  int i   size   1  i >  0  i
parameter parameter   parameters
if  parameter    null    parameter hasinitialexpression
paramvalues add integer valueof i
paramvalues add parameter getinitialexpression
counter
for  int j   1  j <  counter  j
parameter newparams    new parameter
argumentlistexpression arguments   new argumentlistexpression
int index   0
int k   1
for  int i   0  i < parameters length  i
if  k > counter   j    parameters    null    parameters hasinitialexpression
arguments addexpression parameters getinitialexpression
k
else if  parameters    null    parameters hasinitialexpression
newparams   parameters
arguments addexpression new variableexpression parameters getname
k
else
newparams   parameters
arguments addexpression new variableexpression parameters getname
if  parameters length>0    parameters gettype   isarray
// vargs call... better expand the argument:
expression exp   arguments getexpression parameters length 1
spreadexpression se   new spreadexpression exp
arguments getexpressions   set parameters length 1  se
action call arguments newparams method
for  int i   0  i < parameters length  i
// remove default expression
parameters setinitialexpression null
protected void addclosurecode innerclassnode node
// add a new invoke
protected void addinitialization classnode node
for  iterator iter   node getdeclaredconstructors   iterator    iter hasnext
addinitialization node   constructornode  iter next
protected void addinitialization classnode node  constructornode constructornode
statement firststatement   constructornode getfirststatement
constructorcallexpression first   getfirstifspecialconstructorcall firststatement
// in case of this(...) let the other constructor do the intit
if  first  null    first isthiscall    return
list statements   new arraylist
list staticstatements   new arraylist
for  iterator iter   node getfields   iterator    iter hasnext
addfieldinitialization statements  staticstatements   fieldnode  iter next
statements addall node getobjectinitializerstatements
if   statements isempty
statement code   constructornode getcode
blockstatement block   new blockstatement
list otherstatements   block getstatements
if  code instanceof blockstatement
block    blockstatement  code
otherstatements block getstatements
else if  code    null
otherstatements add code
if   otherstatements isempty
if  first  null
// it is super(..) since this(..) is already covered
otherstatements remove 0
statements add 0  firststatement
statements addall otherstatements
constructornode setcode new blockstatement statements  block getvariablescope
if   staticstatements isempty
node addstaticinitializerstatements staticstatements true
private constructorcallexpression getfirstifspecialconstructorcall statement code
if  code    null      code instanceof expressionstatement   return null
expression expression     expressionstatement code  getexpression
if    expression instanceof constructorcallexpression   return null
constructorcallexpression cce    constructorcallexpression  expression
if  cce isspecialcall    return cce
return null
protected void addfieldinitialization
list list
list staticlist
fieldnode fieldnode
expression expression   fieldnode getinitialexpression
if  expression    null
expressionstatement statement
new expressionstatement
new binaryexpression
new fieldexpression fieldnode
token newsymbol types equal  fieldnode getlinenumber    fieldnode getcolumnnumber
expression
if  fieldnode isstatic
staticlist add statement
else
list add statement
/**
* capitalizes the start of the given bean property name
*/
public static string capitalize string name
return name substring 0  1  touppercase     name substring 1  name length
protected statement creategetterblock propertynode propertynode  fieldnode field
expression expression   new fieldexpression field
return new returnstatement expression
protected statement createsetterblock propertynode propertynode  fieldnode field
expression expression   new fieldexpression field
return new expressionstatement
new binaryexpression expression  token newsymbol types equal  0  0   new variableexpression
/**
* filters the given statements
*/
protected list filterstatements list list
list answer   new arraylist list size
for  iterator iter   list iterator    iter hasnext
answer add filterstatement  statement  iter next
return answer
protected statement filterstatement statement statement
if  statement instanceof expressionstatement
expressionstatement expstmt    expressionstatement  statement
expression expression   expstmt getexpression
if  expression instanceof closureexpression
closureexpression closureexp    closureexpression  expression
if   closureexp isparameterspecified
return closureexp getcode
return statement
public void visitgenerictype genericstype genericstype
public static long gettimestamp  class clazz
if  clazz getclassloader   instanceof groovyclassloader innerloader
groovyclassloader innerloader innerloader    groovyclassloader innerloader  clazz getclassloader
return innerloader gettimestamp
final field fields   clazz getfields
for  int i   0  i    fields length    i
if  modifier isstatic fields getmodifiers
final string name   fields getname
if  name startswith __timestamp__
try
return long decode name substring __timestamp__ length     longvalue
catch  numberformatexception e
return long max_value
return long max_value
protected void addcovariantmethods classnode classnode
map methodstoadd   new hashmap
list declaredmethods   new arraylist classnode getmethods
map genericsspec   new hashmap
// remove staic methods from declaredmethods
for  iterator methodsiterator   declaredmethods iterator    methodsiterator hasnext
methodnode m    methodnode  methodsiterator next
if  m isstatic    methodsiterator remove
addcovariantmethods classnode  declaredmethods  methodstoadd  genericsspec
for  iterator it   methodstoadd values   iterator    it hasnext
methodnode method    methodnode  it next
classnode addmethod method
private void addcovariantmethods classnode classnode  list declaredmethods  map methodstoadd  map oldgenericsspec
classnode sn   classnode getunresolvedsuperclass false
if  sn  null
map genericsspec   creategenericsspec sn oldgenericsspec
for  iterator it   declaredmethods iterator    it hasnext
methodnode method    methodnode  it next
if  method isstatic    continue
storemissingcovariantmethods sn method methodstoadd genericsspec
addcovariantmethods sn redirect   declaredmethods methodstoadd genericsspec
classnode interfaces   classnode getinterfaces
for  int i 0  i<interfaces length  i
map genericsspec   creategenericsspec interfaces oldgenericsspec
for  iterator it   declaredmethods iterator    it hasnext
methodnode method    methodnode  it next
if  method isstatic    continue
storemissingcovariantmethods interfaces method methodstoadd genericsspec
addcovariantmethods interfaces declaredmethods methodstoadd genericsspec
private methodnode getcovariantimplementation final methodnode oldmethod  final methodnode overridingmethod  map genericsspec
// method name
if   oldmethod getname   equals overridingmethod getname     return null
// parameters
boolean normalequalparamerters   equalparametersnormal overridingmethod oldmethod
boolean genericequalparamerters   equalparameterswithgenerics overridingmethod oldmethod genericsspec
if   normalequalparamerters     genericequalparamerters  return null
// return type
classnode mr   overridingmethod getreturntype
classnode omr   oldmethod getreturntype
boolean equalreturntype   mr equals omr
if  equalreturntype    normalequalparamerters  return null
// if we reach this point we have at last one parameter or return type, that
// is different in its specified form. that means we have to create a bridge method!
classnode testmr   correcttogenericsspec genericsspec omr
if   mr isderivedfrom testmr
throw new runtimeparserexception
oldmethod gettypedescriptor
oldmethod getdeclaringclass   getname
overridingmethod
if   oldmethod getmodifiers   acc_final   0
throw new runtimeparserexception
oldmethod gettypedescriptor
oldmethod getdeclaringclass   getname
overridingmethod
if  oldmethod isstatic      overridingmethod isstatic
throw new runtimeparserexception
oldmethod gettypedescriptor
oldmethod getdeclaringclass   getname
overridingmethod
methodnode newmethod   new methodnode
oldmethod getname
overridingmethod getmodifiers     acc_synthetic   acc_bridge
oldmethod getreturntype   getplainnodereference
cleanparameters oldmethod getparameters
oldmethod getexceptions

list instructions   new arraylist 1
instructions add
new bytecodeinstruction
public void visit methodvisitor mv
bytecodehelper helper   new bytecodehelper mv
mv visitvarinsn aload 0
parameter para   oldmethod getparameters
parameter goal   overridingmethod getparameters
for  int i   0  i < para length  i
helper load para gettype    i 1
if   para gettype   equals goal gettype
helper docast goal gettype
mv visitmethodinsn
invokevirtual
bytecodehelper getclassinternalname classnode
overridingmethod getname
bytecodehelper getmethoddescriptor overridingmethod getreturntype    overridingmethod getparameters
helper doreturn oldmethod getreturntype
newmethod setcode new bytecodesequence instructions
return newmethod
private parameter cleanparameters parameter parameters
parameter params   new parameter
for  int i   0  i < params length  i
params   new parameter parameters gettype   getplainnodereference   parameters getname
return params
private void storemissingcovariantmethods classnode current  methodnode method  map methodstoadd  map genericsspec
list methods   current getmethods
for  iterator sit   methods iterator    sit hasnext
methodnode tooverride    methodnode  sit next
methodnode bridgemethod   getcovariantimplementation tooverride method genericsspec
if  bridgemethod  null  continue
methodstoadd put  bridgemethod gettypedescriptor   bridgemethod
return
private classnode correcttogenericsspec map genericsspec  genericstype type
classnode ret   null
if  type isplaceholder
string name   type getname
ret    classnode  genericsspec get name
if  ret  null  ret   type gettype
return ret
private classnode correcttogenericsspec map genericsspec  classnode type
if  type isgenericsplaceholder
string name   type getgenericstypes   getname
type    classnode  genericsspec get name
if  type  null  type   classhelper object_type
return type
private boolean equalparametersnormal methodnode m1  methodnode m2
parameter p1   m1 getparameters
parameter p2   m2 getparameters
if  p1 length  p2 length  return false
for  int i   0  i < p2 length  i
classnode type   p2 gettype
classnode parametertype   p1 gettype
if   parametertype equals type   return false
return true
private boolean equalparameterswithgenerics methodnode m1  methodnode m2  map genericsspec
parameter p1   m1 getparameters
parameter p2   m2 getparameters
if  p1 length  p2 length  return false
for  int i   0  i < p2 length  i
classnode type   p2 gettype
classnode genericstype   correcttogenericsspec genericsspec type
classnode parametertype   p1 gettype
if   parametertype equals genericstype   return false
return true
private map creategenericsspec classnode current  map oldspec
map ret   new hashmap oldspec
// ret contains the type specs, what we now need is the type spec for the
// current class. to get that we first apply the type parameters to the
// current class and then use the type names of the current class to reset
// the map. example:
//   class a<v,w,x>{}
//   class b<t extends number> extends a<t,long,string> {}
// first we have:    t->number
// we apply it to a<t,long,string> -> a<number,long,string>
// resulting in:     v->number,w->long,x->string
genericstype sgts   current getgenericstypes
if  sgts  null
classnode spec   new classnode
for  int i   0  i < spec length  i
spec correcttogenericsspec ret  sgts
genericstype newgts   current redirect   getgenericstypes
if  newgts  null  return ret
ret clear
for  int i   0  i < spec length  i
ret put newgts getname    spec
return ret