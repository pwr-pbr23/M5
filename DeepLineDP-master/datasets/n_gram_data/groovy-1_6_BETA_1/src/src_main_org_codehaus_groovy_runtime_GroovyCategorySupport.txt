/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy runtime
import groovy lang closure
import org codehaus groovy reflection cachedclass
import org codehaus groovy reflection cachedmethod
import org codehaus groovy reflection reflectioncache
import org codehaus groovy runtime metaclass newinstancemetamethod
import java util
import java util concurrent concurrenthashmap
import java util concurrent atomic atomicinteger
/**
* @author sam
* @author paul king
* @author alex tkachman
*/
public class groovycategorysupport
private static atomicinteger categoriesinuse   new atomicinteger
public static class categorymethodlist extends arraylist<categorymethod>
public final int level
final categorymethodlist previous
final atomicinteger usage
public categorymethodlist string name  int level  categorymethodlist previous
this level   level
this previous   previous
if  previous    null
addall previous
usage   previous usage
else
usage   getcategorynameusage  name
public boolean add categorymethod o
usage incrementandget
return super add o
public static class threadcategoryinfo extends hashmap<string  categorymethodlist>
int level
private void newscope
categoriesinuse incrementandget
level
private void endscope
for  iterator<map entry<string  categorymethodlist>> it   entryset   iterator    it hasnext
final map entry<string  categorymethodlist> e   it next
final categorymethodlist list   e getvalue
if  list level    level
final categorymethodlist prev   list previous
if  prev    null
it remove
list usage addandget  list size
else
e setvalue prev
list usage addandget prev size   list size
level
categoriesinuse getanddecrement
private object use class categoryclass  closure closure
newscope
try
use categoryclass
return closure call
finally
endscope
public object use list<class> categoryclasses  closure closure
newscope
try
for  iterator i   categoryclasses iterator    i hasnext
class clazz    class  i next
use clazz
return closure call
finally
endscope
private void use class categoryclass
cachedclass cachedclass   reflectioncache getcachedclass categoryclass
cachedmethod methods   cachedclass getmethods
for  int i   0  i < methods length  i
cachedmethod cachedmethod   methods
if  cachedmethod isstatic      cachedmethod ispublic
cachedclass paramtypes   cachedmethod getparametertypes
if  paramtypes length > 0
cachedclass metaclass   paramtypes
categorymethod mmethod   new categorymethod cachedmethod  metaclass gettheclass
final string name   cachedmethod getname
categorymethodlist list   get name
if  list    null    list level    level
list   new categorymethodlist name level list
put  name  list
list add mmethod
collections sort list
public categorymethodlist getcategorymethods string name
return level    0 ? null   get name
private static final mythreadlocal threadinfo   new mythreadlocal
private static class categorymethod extends newinstancemetamethod implements comparable
private final class metaclass
public categorymethod cachedmethod metamethod  class metaclass
super metamethod
this metaclass   metaclass
public boolean iscacheable     return false
/**
* sort by most specific to least specific.
*
* @param o the object to compare against
*/
public int compareto object o
categorymethod thatmethod    categorymethod  o
class thisclass   metaclass
class thatclass   thatmethod metaclass
if  thisclass    thatclass  return 0
class loop   thisclass
while loop    null    loop    object class
loop   thisclass getsuperclass
if  loop    thatclass
return  1
loop   thatclass
while  loop    null    loop    object class
loop   thatclass getsuperclass
if  loop    thisclass
return 1
return 0
public static atomicinteger getcategorynameusage  string name
return threadinfo getusage  name
/**
* create a scope based on given categoryclass and invoke closure within that scope.
*
* @param categoryclass the class containing category methods
* @param closure the closure during which to make the category class methods available
* @return the value returned from the closure
*/
public static object use class categoryclass  closure closure
return threadinfo get   use categoryclass  closure
/**
* create a scope based on given categoryclasses and invoke closure within that scope.
*
* @param categoryclasses the list of classes containing category methods
* @param closure the closure during which to make the category class methods available
* @return the value returned from the closure
*/
public static object use list<class> categoryclasses  closure closure
return threadinfo get   use categoryclasses  closure
public static boolean hascategoryincurrentthread
return categoriesinuse get      0    threadinfo get   level    0
public static boolean hascategoryinanythread
return categoriesinuse get      0
/**
* this method is used to pull all the new methods out of the local thread context with a particular name.
*
* @param name the method name of interest
* @return the list of methods
*/
public static categorymethodlist getcategorymethods string name
return threadinfo get   getcategorymethods name
private static class mythreadlocal extends threadlocal<threadcategoryinfo>
concurrenthashmap<string atomicinteger> usage   new concurrenthashmap<string atomicinteger>
protected threadcategoryinfo initialvalue
return new threadcategoryinfo
public atomicinteger getusage  string name
atomicinteger u   usage get name
if  u    null
return u
final atomicinteger ai   new atomicinteger
final atomicinteger prev   usage putifabsent name  ai
return prev    null ? ai   prev