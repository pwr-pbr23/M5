/*
* copyright 2003-2008 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy runtime
import groovy lang
import groovy util
import groovy io encodingawarebufferedwriter
import org codehaus groovy reflection cachedclass
import org codehaus groovy reflection cachedmethod
import org codehaus groovy reflection reflectioncache
import org codehaus groovy runtime dgmimpl numbernumberdiv
import org codehaus groovy runtime dgmimpl numbernumberminus
import org codehaus groovy runtime dgmimpl numbernumbermultiply
import org codehaus groovy runtime dgmimpl numbernumberplus
import org codehaus groovy runtime dgmimpl arrays
import org codehaus groovy runtime metaclass missingpropertyexceptionnostack
import org codehaus groovy runtime metaclass newinstancemetamethod
import org codehaus groovy runtime typehandling defaulttypetransformation
import org codehaus groovy runtime typehandling groovycastexception
import org codehaus groovy runtime typehandling numbermath
import org codehaus groovy tools rootloader
import org w3c dom nodelist
import java io
import java lang reflect array
import java lang reflect field
import java lang reflect modifier
import java lang reflect proxy
import java math bigdecimal
import java math biginteger
import java net
import java security accesscontroller
import java security privilegedaction
import java util
import java util logging logger
import java util regex matcher
import java util regex pattern
/**
* this class defines all the new groovy methods which appear on normal jdk
* classes inside the groovy environment. static methods are used with the
* first parameter the destination class.
*
* @author <a href="mailto:james@coredevelopers.net">james strachan</a>
* @author jeremy rayner
* @author sam pullara
* @author rod cope
* @author guillaume laforge
* @author john wilson
* @author hein meling
* @author dierk koenig
* @author pilho kim
* @author marc guillemot
* @author russel winder
* @author bing ran
* @author jochen theodorou
* @author paul king
* @author michael baehr
* @author joachim baumann
* @author alex tkachman
* @version $revision$
*/
public class defaultgroovymethods extends defaultgroovymethodssupport
private static final logger log   logger getlogger defaultgroovymethods class getname
private static final integer one   integer valueof 1
public static final class  additionals
numbernumberplus class
numbernumbermultiply class
numbernumberminus class
numbernumberdiv class
objectarraygetatmetamethod class
objectarrayputatmetamethod class
booleanarraygetatmetamethod class
booleanarrayputatmetamethod class
bytearraygetatmetamethod class
bytearrayputatmetamethod class
characterarraygetatmetamethod class
characterarrayputatmetamethod class
shortarraygetatmetamethod class
shortarrayputatmetamethod class
integerarraygetatmetamethod class
integerarrayputatmetamethod class
longarraygetatmetamethod class
longarrayputatmetamethod class
floatarraygetatmetamethod class
floatarrayputatmetamethod class
doublearraygetatmetamethod class
doublearrayputatmetamethod class
/**
* identity check. since == is overridden in groovy with the meaning of equality
* we need some fallback to check for object identity.  invoke using the
* 'is' operator, like so: <code>def same = (this is that)</code>
*
* @param self  an object
* @param other an object to compare identity with
* @return true if self and other are both references to the same
*         instance, false otherwise
*/
public static boolean is object self  object other
return self    other
}
/**
* allows the closure to be called for the object reference self
* synonym for 'with()'.
*
* @param self    the object to have a closure act upon
* @param closure the closure to call on the object
* @return result of calling the closure
*/
public static object identity object self  closure closure
return defaultgroovymethods with self  closure
}
/**
* allows the closure to be called for the object reference self
*
* @param self    the object to have a closure act upon
* @param closure the closure to call on the object
* @return result of calling the closure
*/
public static object with object self  closure closure
final closure clonedclosure    closure  closure clone
clonedclosure setdelegate self
return clonedclosure call self
}
/**
* allows the subscript operator to be used to lookup dynamic property values.
* <code>bean[somepropertynameexpression]</code>. the normal property notation
* of groovy is neater and more concise but only works with compile-time known
* property names.
*
* @param self     the object to act upon
* @param property the property name of interest
* @return the property value
*/
public static object getat object self  string property
return invokerhelper getproperty self  property
}
/**
* allows the subscript operator to be used to set dynamically named property values.
* <code>bean[somepropertynameexpression] = foo</code>. the normal property notation
* of groovy is neater and more concise but only works with property names which
* are known at compile time.
*
* @param self     the object to act upon
* @param property the name of the property to set
* @param newvalue the value to set
*/
public static void putat object self  string property  object newvalue
invokerhelper setproperty self  property  newvalue
}
/**
* generates a detailed dump string of an object showing its class,
* hashcode and fields.
*
* @param self an object
* @return the dump representation
*/
public static string dump object self
if (self == null) {
return
}
stringbuffer buffer   new stringbuffer
class klass   self getclass
buffer append klass getname
buffer append
buffer append integer tohexstring self hashcode
boolean groovyobject   self instanceof groovyobject
/*jes this may be rewritten to use the new getproperties() stuff
* but the original pulls out private variables, whereas getproperties()
* does not. what's the real use of dump() here?
*/
while  klass    null
field fields   klass getdeclaredfields
for  int i   0  i < fields length  i
final field field   fields
if   field getmodifiers     modifier static     0
if  groovyobject    field getname   equals
continue
}
accesscontroller doprivileged new privilegedaction
public object run
field setaccessible true
return null
}
buffer.append(" ");
buffer append field getname
buffer.append("=");
try {
buffer append invokerhelper tostring field get self
catch  exception e
buffer.append(e);
}
}
}
klass   klass getsuperclass
}
/* here is a different implementation that uses getproperties(). i have left
* it commented out because it returns a slightly different list of properties;
* i.e. it does not return privates. i don't know what dump() really should be doing,
* although imo showing private fields is a no-no
*/
/*
list props = getproperties(self);
for(iterator itr = props.keyset().iterator(); itr.hasnext(); ) {
string propname = itr.next().tostring();
// the original skipped this, so i will too
if(pv.getname().equals("class")) continue;
if(pv.getname().equals("metaclass")) continue;
buffer.append(" ");
buffer.append(propname);
buffer.append("=");
try {
buffer.append(invokerhelper.tostring(props.get(propname)));
}
catch (exception e) {
buffer.append(e);
}
}
*/
buffer append
return buffer tostring
}
/**
* retrieves the list of {@link metaproperty} objects for 'self' and wraps it
* in a list of {@link propertyvalue} objects that additionally provide
* the value for each property of 'self'.
*
* @param self the receiver object
* @return list of {@link propertyvalue} objects
* @see groovy.util.expando#getmetapropertyvalues()
*/
public static list getmetapropertyvalues object self
metaclass metaclass   invokerhelper getmetaclass self
list mps   metaclass getproperties
list props   new arraylist mps size
for  iterator itr   mps iterator    itr hasnext
metaproperty mp    metaproperty  itr next
propertyvalue pv   new propertyvalue self  mp
props add pv
}
return props
}
/**
* convenience method that calls {@link #getmetapropertyvalues(object)}(self)
* and provides the data in form of simple key/value pairs, i.e.&nsbp;without
* type() information.
*
* @param self the receiver object
* @return meta properties as map of key/value pairs
*/
public static map getproperties object self
list metaprops   getmetapropertyvalues self
map props   new hashmap metaprops size
for  iterator itr   metaprops iterator    itr hasnext
propertyvalue pv    propertyvalue  itr next
try {
props put pv getname    pv getvalue
catch  exception e
log throwing self getclass   getname        pv getname        e
}
}
return props
}
/**
* scoped use method
*
* @param self          any object
* @param categoryclass a category class to use
* @param closure       the closure to invoke with the category in place
* @return the value returned from the closure
*/
public static object use object self  class categoryclass  closure closure
return groovycategorysupport use categoryclass  closure
}
/**
* extend class globally with category methods.
* all methods for given class and all super classes will be added to the class.
*
* @param self          any class
* @param categoryclasses a category classes to use
*/
public static void mixin class self  list categoryclasses
final cachedclass selfcached
selfcached   reflectioncache getcachedclass self
arraylist arr   findcategorymethods self  categoryclasses
selfcached addnewmopmethods arr
}
/**
* extend groovy object with category methods.
* all methods for given class and all super classes will be added to the object.
*
* @param self          any class
* @param categoryclasses a category classes to use
*/
public static void mixin groovyobject self  list categoryclasses
final class selfclass   self getclass
arraylist arr   findcategorymethods selfclass  categoryclasses
metaclass metaclass   self getmetaclass
if  metaclass getclass      metaclassimpl class
metaclassimpl mc    metaclassimpl metaclass
metamethod mm    mc getadditionalmetamethods
arr addall 0  arrays aslist mm
final metaclassimpl newmetaclass   new metaclassimpl mc gettheclass     metamethod  arr toarray new metamethod
newmetaclass initialize
self setmetaclass newmetaclass
return
}
if  metaclass getclass      expandometaclass class
expandometaclass mc    expandometaclass metaclass
metamethod mm    mc getadditionalmetamethods
arr addall 0  arrays aslist mm
final expandometaclass newmetaclass   new expandometaclass mc gettheclass     metamethod  arr toarray new metamethod
for  iterator it   mc getexpandomethods   iterator    it hasnext
newmetaclass registerinstancemethod  metamethod  it next
}
newmetaclass initialize
self setmetaclass newmetaclass
return
}
throw new groovyruntimeexception      selfclass       metaclass
}
private static arraylist findcategorymethods class self  list categoryclasses
arraylist arr   new arraylist 4
for  iterator it   categoryclasses iterator    it hasnext
class categoryclass    class  it next
cachedmethod methods   reflectioncache getcachedclass categoryclass  getmethods
for  int i   0  i < methods length  i
cachedmethod method   methods
final int mod   method getmodifiers
if  modifier isstatic mod     modifier ispublic mod
cachedclass paramtypes   method getparametertypes
if  paramtypes length    0
continue
if  paramtypes isassignablefrom self
final newinstancemetamethod metamethod   new newinstancemetamethod method
arr add metamethod
}
}
}
}
return arr
}
/**
* extend class globally with category methods.
*
* @param self          any class
* @param categoryclass a category class to use
*/
public static void mixin class self  class categoryclass
arraylist ar   new arraylist 1
ar add categoryclass
mixin self  ar
}
/**
* extend class globally with category methods.
*
* @param self          any class
* @param categoryclass a category class to use
*/
public static void mixin class self  class  categoryclass
mixin self  arrays aslist categoryclass
}
/**
* extend class globally with category methods.
*
* @param self          any class
* @param categoryclass a category class to use
*/
public static void mixin groovyobject self  class categoryclass
arraylist ar   new arraylist 1
ar add categoryclass
mixin self  ar
}
/**
* extend class globally with category methods.
*
* @param self          any class
* @param categoryclass a category class to use
*/
public static void mixin groovyobject self  class  categoryclass
mixin self  arrays aslist categoryclass
}
/**
* scoped use method with list of categories.
*
* @param self              any object
* @param categoryclasslist a list of category classes
* @param closure           the closure to invoke with the categories in place
* @return the value returned from the closure
*/
public static object use object self  list categoryclasslist  closure closure
return groovycategorysupport use categoryclasslist  closure
}
/**
* allows the usage of addshutdownhook without getting the runtime first.
*
* @param self    the object the method is called on (ignored)
* @param closure the shutdown hook action
*/
public static void addshutdownhook object self  closure closure
runtime getruntime   addshutdownhook new thread closure
}
/**
* allows you to use a list of categories, specifying the list as varargs.
* <code>use(categoryclass1, categoryclass2) { ... }</code>
* this method saves having to wrap the the category
* classes in a list.
*
* @param self  any object
* @param array a list of category classes and a closure
* @return the value returned from the closure
*/
public static object use object self  object array
if  array length < 2
throw new illegalargumentexception
closure closure
try {
closure    closure  array
} catch (classcastexception e) {
throw new illegalargumentexception
}
list list   new arraylist array length   1
for  int i   0  i < array length   1    i
list add array
return groovycategorysupport use list  closure
}
/**
* print a value to the standard output stream.
*
* @param self  any object
* @param value the value to print
*/
public static void print object self  object value
// we won't get here if we are a printwriter
if  self instanceof writer
printwriter pw   null
try {
pw   new printwriter  writer self
pw print invokerhelper tostring value
finally
try {
pw close
catch  exception ex
// ignore
}
}
} else {
system out print invokerhelper tostring value
}
}
/**
* print a value to the standard output stream.
* this method delegates to the owner to execute the method.
*
* @param self  a generated closure
* @param value the value to print
*/
public static void print closure self  object value
object owner   getclosureowner self
invokerhelper invokemethod owner     new object value
}
/**
* print a linebreak to the standard output stream.
*
* @param self any object
*/
public static void println object self
// we won't get here if we are a printwriter
if  self instanceof writer
printwriter pw   null
try {
pw   new printwriter  writer self
pw println
finally
try {
pw close
catch  exception ex
// ignore
}
}
} else {
system out println
}
}
/**
* print a linebreak to the standard output stream.
* this method delegates to the owner to execute the method.
*
* @param self  a closure
*/
public static void println closure self
object owner   getclosureowner self
invokerhelper invokemethod owner     new object
}
private static object getclosureowner closure cls
object owner    cls getowner
while  owner instanceof generatedclosure
owner     closure  owner  getowner
}
return owner
}
/**
* print a value (followed by a newline) to the standard output stream.
*
* @param self  any object
* @param value the value to print
*/
public static void println object self  object value
// we won't get here if we are a printwriter
if  self instanceof writer
printwriter pw   null
try {
pw   new printwriter  writer self
pw println invokerhelper tostring value
finally
try {
pw close
catch  exception ex
// ignore
}
}
} else {
system out println invokerhelper tostring value
}
}
/**
* print a value (followed by a newline) to the standard output stream.
* this method delegates to the owner to execute the method.
*
* @param self  a closure
* @param value the value to print
*/
public static void println closure self  object value
object owner   getclosureowner self
invokerhelper invokemethod owner     new object value
}
/**
* printf to a console (only works with jdk1.5 or later).
*
* @param self   any object
* @param format a format string
* @param values values referenced by the format specifiers in the format string.
*/
public static void printf object self  string format  object values
if  self instanceof printstream
printf  printstream  self  format  values
else
printf system out  format  values
}
/**
* sprintf to a string (only works with jdk1.5 or later).
*
* @param self   any object
* @param format a format string
* @param values values referenced by the format specifiers in the format string.
* @return the resulting formatted string
*/
public static string sprintf object self  string format  object values
bytearrayoutputstream outputstream   new bytearrayoutputstream
printstream out   new printstream outputstream
printf out  format  values
return outputstream tostring
}
/**
* printf to a printstream (only works with jdk1.5 or later).
*
* @param out    a printstream object
* @param format a format string
* @param values values referenced by the format specifiers in the format string.
*/
private static void printf printstream out  string format  object values
char version   system getproperty    charat 2
if  version >
//
//  cannot just do:
//
//        system.out.printf(format, values) ;
//
//  because this fails to compile on jdk1.4.x and earlier.  so until the entire world is using
//  jdk1.5 or later then we have to do things by reflection so as to hide the use of printf
//  from the compiler.  in jdk1.5 you might try:
//
//        system.out.getclass().getmethod("printf", string.class, object[].class).invoke(system.out, format, values) ;
//
//  but of course this doesn't work on jdk1.4 as it relies on varargs.  argh.  so we are
//  forced into:
//
try {
out getclass   getmethod    new class string class  object class   invoke out  new object format  values
catch  nosuchmethodexception nsme
throw new runtimeexception
catch  illegalaccessexception iae
throw new runtimeexception
catch  java lang reflect invocationtargetexception ite
throw new invokerinvocationexception ite
}
} else {
throw new runtimeexception
}
}
/**
* prints a formatted string using the specified format string and
* arguments (only works with jdk1.5 or later).
* <p/>
* <p/>
* for examples, <pre>
*     printf ( "hello, %s!\n" , [ "world" ] as string[] )
*     printf ( "hello, %s!\n" , [ "groovy" ])
*     printf ( "%d + %d = %d\n" , [ 1 , 2 , 1+2 ] as integer[] )
*     printf ( "%d + %d = %d\n" , [ 3 , 3 , 3+3 ])
* <p/>
*     ( 1..5 ).each { printf ( "-- %d\n" , [ it ] as integer[] ) }
*     ( 1..5 ).each { printf ( "-- %d\n" , [ it ] as int[] ) }
*     ( 0x41..0x45 ).each { printf ( "-- %c\n" , [ it ] as char[] ) }
*     ( 07..011 ).each { printf ( "-- %d\n" , [ it ] as byte[] ) }
*     ( 7..11 ).each { printf ( "-- %d\n" , [ it ] as short[] ) }
*     ( 7..11 ).each { printf ( "-- %d\n" , [ it ] as long[] ) }
*     ( 7..11 ).each { printf ( "-- %5.2f\n" , [ it ] as float[] ) }
*     ( 7..11 ).each { printf ( "-- %5.2g\n" , [ it ] as double[] ) }
* </pre>
* <p/>
*
* @param self   any object
* @param format a format string
* @param arg    argument which is referenced by the format specifiers in the format
*               string.  the type of <code>arg</code> should be one of object[], list,
*               int[], short[], byte[], char[], boolean[], long[], float[], or double[].
*/
public static void printf object self  string format  object arg
if  self instanceof printstream
printf  printstream  self  format  arg
else
printf system out  format  arg
}
private static void printf printstream self  string format  object arg
if  arg instanceof object
printf self  format   object  arg
return
}
if  arg instanceof list
printf self  format    list  arg  toarray
return
}
if   arg getclass   isarray
object o    object  java lang reflect array newinstance arg getclass    1
o   arg
printf self  format  o
return
}
object ans
string elemtype   arg getclass   getname
if  elemtype equals
int ia    int  arg
ans   new integer
for  int i   0  i < ia length  i
ans   integer valueof ia
}
else if  elemtype equals
char ia    char  arg
ans   new character
for  int i   0  i < ia length  i
ans   new character ia
}
else if  elemtype equals
boolean ia    boolean  arg
ans   new boolean
for  int i   0  i < ia length  i
ans   new boolean ia
}
else if  elemtype equals
byte ia    byte  arg
ans   new byte
for  int i   0  i < ia length  i
ans   new byte ia
}
else if  elemtype equals
short ia    short  arg
ans   new short
for  int i   0  i < ia length  i
ans   new short ia
}
else if  elemtype equals
float ia    float  arg
ans   new float
for  int i   0  i < ia length  i
ans   new float ia
}
else if  elemtype equals
long ia    long  arg
ans   new long
for  int i   0  i < ia length  i
ans   new long ia
}
else if  elemtype equals
double ia    double  arg
ans   new double
for  int i   0  i < ia length  i
ans   new double ia
}
} else {
throw new runtimeexception     arg
}
printf self  format  ans
}
/**
* returns a formatted string using the specified format string and
* arguments.
* <p/>
* todo: remove duplication with printf
*
* @param self   any object
* @param format a format string
* @param arg    argument which is referenced by the format specifiers in the format
*               string.  the type of <code>arg</code> should be one of object[], list,
*               int[], short[], byte[], char[], boolean[], long[], float[], or double[].
* @return the resulting printf'd string
*/
public static string sprintf object self  string format  object arg
if  arg instanceof object
return sprintf self  format   object  arg
}
if  arg instanceof list
return sprintf self  format    list  arg  toarray
}
if   arg getclass   isarray
object o    object  java lang reflect array newinstance arg getclass    1
o   arg
return sprintf self  format  o
}
object ans
string elemtype   arg getclass   getname
if  elemtype equals
int ia    int  arg
ans   new integer
for  int i   0  i < ia length  i
ans   integer valueof ia
}
else if  elemtype equals
char ia    char  arg
ans   new character
for  int i   0  i < ia length  i
ans   new character ia
}
else if  elemtype equals
boolean ia    boolean  arg
ans   new boolean
for  int i   0  i < ia length  i
ans   new boolean ia
}
else if  elemtype equals
byte ia    byte  arg
ans   new byte
for  int i   0  i < ia length  i
ans   new byte ia
}
else if  elemtype equals
short ia    short  arg
ans   new short
for  int i   0  i < ia length  i
ans   new short ia
}
else if  elemtype equals
float ia    float  arg
ans   new float
for  int i   0  i < ia length  i
ans   new float ia
}
else if  elemtype equals
long ia    long  arg
ans   new long
for  int i   0  i < ia length  i
ans   new long ia
}
else if  elemtype equals
double ia    double  arg
ans   new double
for  int i   0  i < ia length  i
ans   new double ia
}
} else {
throw new runtimeexception     arg
}
return sprintf self  format   object  ans
}
/**
* inspects returns the string that matches what would be typed into a
* terminal to create this object.
*
* @param self any object
* @return a string that matches what would be typed into a terminal to
*         create this object. e.g. [1, 'hello'].inspect() -> [1, "hello"]
*/
public static string inspect object self
return invokerhelper inspect self
}
/**
* print to a console in interactive format.
*
* @param self any object
* @param out  the printwriter used for printing
*/
public static void print object self  printwriter out
if  out    null
out   new printwriter system out
}
out print invokerhelper tostring self
}
/**
* print to a console in interactive format.
*
* @param self any object
* @param out  the printwriter used for printing
*/
public static void println object self  printwriter out
if  out    null
out   new printwriter system out
}
invokerhelper invokemethod self     out
out println
}
/**
* provide a dynamic method invocation method which can be overloaded in
* classes to implement dynamic proxies easily.
*
* @param object    any object
* @param method    the name of the method to call
* @param arguments the arguments to use
* @return the result of the method call
*/
public static object invokemethod object object  string method  object arguments
return invokerhelper invokemethod object  method  arguments
}
// iscase methods
//-------------------------------------------------------------------------
/**
* method for overloading the behavior of the 'case' method in switch statements.
* the default implementation handles arrays types but otherwise simply delegates
* to object#equals, but this may be overridden for other types. in this example:
* <pre> switch( a ) {
*   case b: //some code
* }</pre>
* "some code" is called when <code>b.iscase( a )</code> returns
* <code>true</code>.
*
* @param casevalue   the case value
* @param switchvalue the switch value
* @return true if the switchvalue is deemed to be equal to the casevalue
*/
public static boolean iscase object casevalue  object switchvalue
if  casevalue getclass   isarray
return iscase defaulttypetransformation ascollection casevalue   switchvalue
}
return casevalue equals switchvalue
}
/**
* 'case' implementation for a string, which uses string#equals(object)
* in order to allow strings to be used in switch statements.
* for example:
* <pre>switch( str ) {
*   case 'one' :
*   // etc...
* }</pre>
* note that this returns <code>true</code> for the case where both the
* 'switch' and 'case' operand is <code>null</code>.
*
* @param casevalue   the case value
* @param switchvalue the switch value
* @return true if the switchvalue's tostring() equals the casevalue
*/
public static boolean iscase string casevalue  object switchvalue
if  switchvalue    null
return casevalue    null
}
return casevalue equals switchvalue tostring
}
/**
* special 'case' implementation for class, which allows testing
* for a certain class in a switch statement.
* for example:
* <pre>switch( obj ) {
*   case list :
*     // obj is a list
*     break;
*   case set :
*     // etc
* }<pre>
*
* @param casevalue   the case value
* @param switchvalue the switch value
* @return true if the switchvalue is deemed to be assignable from the given class
*/
public static boolean iscase class casevalue  object switchvalue
if  switchvalue instanceof class
class val    class  switchvalue
return casevalue isassignablefrom val
}
return casevalue isinstance switchvalue
}
/**
* 'case' implementation for collections which tests if the 'switch'
* operand is contained in any of the 'case' values.
* for example:
* <pre>switch( item ) {
*   case firstlist :
*     // item is contained in this list
*     // etc
* }</pre>
*
* @param casevalue   the case value
* @param switchvalue the switch value
* @return true if the casevalue is deemed to contain the switchvalue
* @see java.util.collection#contains(object)
*/
public static boolean iscase collection casevalue  object switchvalue
return casevalue contains switchvalue
}
/**
* 'case' implementation for the {@link pattern} class, which allows
* testing a string against a number of regular expressions.
* for example:
* <pre>switch( str ) {
*   case ~/one/ :
*     // the regex 'one' matches the value of str
* }
* </pre>
* note that this returns true for the case where both the pattern and
* the 'switch' values are <code>null</code>.
*
* @param casevalue   the case value
* @param switchvalue the switch value
* @return true if the switchvalue is deemed to match the casevalue
*/
public static boolean iscase pattern casevalue  object switchvalue
if  switchvalue    null
return casevalue    null
}
final matcher matcher   casevalue matcher switchvalue tostring
if  matcher matches
regexsupport setlastmatcher matcher
return true
} else {
return false;
}
}
/**
* special 'case' implementation for all numbers, which delegates to the
* <code>compareto()</code> method for comparing numbers of different
* types.
*
* @param casevalue   the case value
* @param switchvalue the switch value
* @return true if the numbers are deemed equal
*/
public static boolean iscase number casevalue  number switchvalue
return numbermath compareto casevalue  switchvalue     0
}
/**
* returns an iterator equivalent to this iterator all duplicated items removed
* by using the default comparator. the original iterator will become
* exhausted of elements after determining the unique values. a new iterator
* for the unique values will be returned.
*
* @param self an iterator
* @return the modified iterator
*/
public static iterator unique iterator self
return tolist unique tolist self    listiterator
}
/**
* modifies this collection to remove all duplicated items, using the
* default comparator.
*
* @param self a collection
* @return the now modified collection
*/
public static collection unique collection self
if  self instanceof set
return self
list answer   new arraylist
numberawarecomparator numberawarecomparator   new numberawarecomparator
for  iterator it   self iterator    it hasnext
object o   it next
boolean duplicated   false
for  iterator it2   answer iterator    it2 hasnext
object o2   it2 next
if  numberawarecomparator compare o  o2     0
duplicated   true
break
}
}
if   duplicated
answer add o
}
self clear
self addall answer
return self
}
/**
* returns an iterator equivalent to this iterator all duplicated items
* removed by using a closure as a comparator.  if the closure takes a
* single parameter, the argument passed will be each element, and the
* closure should return a value used for comparison (either using
* {@link comparable#compareto(object)} or object#equals() ).
*
* @param self an iterator
* @param closure a closure used as a comparator
* @return the modified iterator
*/
public static iterator unique iterator self  closure closure
return tolist unique tolist self   closure   listiterator
}
/**
* a convenience method for making a collection unique using a closure
* as a comparator.  if the closure takes a single parameter, the
* argument passed will be each element, and the closure
* should return a value used for comparison (either using
* {@link comparable#compareto(object)} or object#equals() ).  if the
* closure takes two parameters, two items from the collection
* will be passed as arguments, and the closure should return an
* int value (with 0 indicating the items are not unique).
*
* @param self    a collection
* @param closure a closure used as a comparator
* @return self   without any duplicates
*/
public static collection unique collection self  closure closure
if  self instanceof set
return self
// use a comparator of one item or two
int params   closure getmaximumnumberofparameters
if  params    1
unique self  new orderby closure
} else {
unique self  new closurecomparator closure
}
return self
}
/**
* returns an iterator equivalent to this iterator with all duplicated
* items removed by using the supplied comparator.
*
* @param self an iterator
* @param comparator a comparator
* @return the modified iterator
*/
public static iterator unique iterator self  comparator comparator
return tolist unique tolist self   comparator   listiterator
}
/**
* remove all duplicates from a given collection.
* works on the receiver object and returns it.
* the order of members in the collection are compared by the given comparator.
* for each duplicate, the first member which is returned
* by the given collection's iterator is retained, but all other ones are removed.
* the given collection's original order is preserved.
* <p/>
* <code><pre>
*     class person {
*         def fname, lname
*         public string tostring() {
*             return fname + " " + lname
*         }
*     }
* <p/>
*     class personcomparator implements comparator {
*         public int compare(object o1, object o2) {
*             person p1 = (person) o1
*             person p2 = (person) o2
*             if (p1.lname != p2.lname)
*                 return p1.lname.compareto(p2.lname)
*             else
*                 return p1.fname.compareto(p2.fname)
*         }
* <p/>
*         public boolean equals(object obj) {
*             return this.equals(obj)
*         }
*     }
* <p/>
*     person a = new person(fname:"john", lname:"taylor")
*     person b = new person(fname:"clark", lname:"taylor")
*     person c = new person(fname:"tom", lname:"cruz")
*     person d = new person(fname:"clark", lname:"taylor")
* <p/>
*     def list = [a, b, c, d]
*     list list2 = list.unique(new personcomparator())
*     assert( list2 == list && list == [a, b, c] )
* <p/>
* </pre></code>
*
* @param self       a collection
* @param comparator a comparator
* @return self       the now modified collection without duplicates
*/
public static collection unique collection self  comparator comparator
if  self instanceof set
return self
list answer   new arraylist
for  iterator it   self iterator    it hasnext
object o   it next
boolean duplicated   false
for  iterator it2   answer iterator    it2 hasnext
object o2   it2 next
if  comparator compare o  o2     0
duplicated   true
break
}
}
if   duplicated
answer add o
}
self clear
self addall answer
return self
}
/**
* iterates through an aggregate type or data structure,
* passing each item to the given closure.  custom types may utilize this
* method by simply providing an "iterator()" method.  the items returned
* from the resulting iterator will be passed to the closure.
*
* @param self    the object over which we iterate
* @param closure the closure applied on each element found
* @return the self object
*/
public static object each object self  closure closure
each invokerhelper asiterator self   closure
return self
}
/**
* iterates through an aggregate type or data structure,
* passing each item and the item's index (a counter starting at
* zero) to the given closure.
*
* @param self    an object
* @param closure a closure to operate on each item
* @return the self object
*/
public static object eachwithindex object self  closure closure
int counter   0
for  iterator iter   invokerhelper asiterator self   iter hasnext
closure call new object iter next    integer valueof counter
}
return self
}
private static iterator each iterator iter  closure closure
while  iter hasnext
closure call iter next
}
return iter
}
/**
* allows a map to be iterated through using a closure. if the
* closure takes one parameter then it will be passed the map.entry
* otherwise if the closure takes two parameters then it will be
* passed the key and the value.
*
* @param self    the map over which we iterate
* @param closure the closure applied on each entry of the map
* @return returns the self parameter
*/
public static map each map self  closure closure
for  iterator iter   self entryset   iterator    iter hasnext
map entry entry    map entry  iter next
callclosureformapentry closure  entry
}
return self
}
/**
* allows a map to be iterated through using a closure. if the
* closure takes two parameters then it will be passed the map.entry and
* the item's index (a counter starting at zero) otherwise if the closure
* takes three parameters then it will be passed the key, the value, and
* the index.
*
* @param self    the map over which we iterate
* @param closure a closure to operate on each item
* @return the self object
*/
public static object eachwithindex map self  closure closure
int counter   0
for  iterator iter   self entryset   iterator    iter hasnext
map entry entry    map entry  iter next
callclosureformapentryandcounter closure  entry  counter
}
return self
}
/**
* iterate over each element of the list in the reverse order.
*
* @param self    a list
* @param closure a closure to which each item is passed.
* @return the original list
*/
public static list reverseeach list self  closure closure
each new reverselistiterator self   closure
return self
}
/**
* iterate over each element of the array in the reverse order.
*
* @param self    an object array
* @param closure a closure to which each item is passed
* @return the original array
*/
public static object reverseeach object self  closure closure
each new reverselistiterator arrays aslist self    closure
return self
}
/**
* reverse the items in an object array.
*
* @param self    an object array
* @return an array containing the reversed items
*/
public static object reverse object self
return tolist new reverselistiterator arrays aslist self    toarray
}
/**
* used to determine if the given predicate closure is valid (i.e.&nsbp;returns
* <code>true</code> for all items in this data structure).
* a simple example for a list:
* <pre>def list = [3,4,5]
* def greaterthantwo = list.every { it > 2 }
* </pre>
*
* @param self    the object over which we iterate
* @param closure the closure predicate used for matching
* @return true if every iteration of the object matches the closure predicate
*/
public static boolean every object self  closure closure
for  iterator iter   invokerhelper asiterator self   iter hasnext
if   defaulttypetransformation casttoboolean closure call iter next
return false;
}
}
return true
}
/**
* iterates over the entries of a map, and checks whether a predicate is
* valid for all entries.
*
* @param self    the map over which we iterate
* @param closure the closure predicate used for matching
* @return true if every entry of the map matches the closure predicate
*/
public static boolean every map self  closure closure
for  iterator iter   self entryset   iterator    iter hasnext
map entry entry    map entry  iter next
if   defaulttypetransformation casttoboolean callclosureformapentry closure  entry
return false;
}
}
return true
}
/**
* iterates over every element of a collection, and checks whether all
* elements are <code>true</code> according to the groovy truth.
* equivalent to <code>self.every({element -> element})</code>
*
* @param self the object over which we iterate
* @return true if every item in the collection matches the closure
*         predicate
*/
public static boolean every object self
for  iterator iter   invokerhelper asiterator self   iter hasnext
if   defaulttypetransformation casttoboolean iter next
return false;
}
}
return true
}
/**
* iterates over the contents of an object or collection, and checks whether a
* predicate is valid for at least one element.
*
* @param self    the object over which we iterate
* @param closure the closure predicate used for matching
* @return true   if any iteration for the object matches the closure predicate
*/
public static boolean any object self  closure closure
for  iterator iter   invokerhelper asiterator self   iter hasnext
if  defaulttypetransformation casttoboolean closure call iter next
return true
}
}
return false;
}
/**
* iterates over the entries of a map, and checks whether a predicate is
* valid for at least one entry
*
* @param self    the map over which we iterate
* @param closure the closure predicate used for matching
* @return true if any entry in the map matches the closure predicate
*/
public static boolean any map self  closure closure
for  iterator iter   self entryset   iterator    iter hasnext
map entry entry    map entry  iter next
if  defaulttypetransformation casttoboolean callclosureformapentry closure  entry
return true
}
}
return false;
}
/**
* iterates over the elements of a collection, and checks whether at least
* one element is true according to the groovy truth.
* equivalent to self.any({element -> element})
*
* @param self the object over which we iterate
* @return true if any item in the collection matches the closure predicate
*/
public static boolean any object self
for  iterator iter   invokerhelper asiterator self   iter hasnext
if  defaulttypetransformation casttoboolean iter next
return true
}
}
return false;
}
/**
* iterates over every element of the collection and returns each item that matches
* the given filter - calling the <code>{@link #iscase(object,object)}</code>
* method used by switch statements.  this method can be used with different
* kinds of filters like regular expressions, classes, ranges etc.
* example:
* <pre>def list = ['a', 'b', 'aa', 'bc' ]
* def filtered = list.grep( ~/a+/ ) //contains 'a' and 'aa'
* </pre>
*
* @param self   the object over which we iterate
* @param filter the filter to perform on the collection (using the iscase(object) method)
* @return a collection of objects which match the filter
*/
public static collection grep object self  object filter
collection answer   createsimilarordefaultcollection self
metaclass metaclass   invokerhelper getmetaclass filter
for  iterator iter   invokerhelper asiterator self   iter hasnext
object object   iter next
if  defaulttypetransformation casttoboolean metaclass invokemethod filter     object
answer add object
}
}
return answer
}
/**
* counts the number of occurrences of the given value from the
* items within this iterator.
* comparison is done using groovy's == operator (using
* <code>compareto(value) == 0</code> or <code>equals(value)</code> ).
* the iterator will become exhausted of elements after determining the count value.
*
* @param self  the iterator from which we count the number of matching occurrences
* @param value the value being searched for
* @return the number of occurrences
*/
public static int count iterator self  object value
return count tolist self   value
}
/**
* counts the number of occurrences of the given value inside this collection.
* comparison is done using groovy's == operator (using
* <code>compareto(value) == 0</code> or <code>equals(value)</code> ).
*
* @param self  the collection within which we count the number of occurrences
* @param value the value being searched for
* @return the number of occurrences
*/
public static int count collection self  object value
int answer   0
for  iterator iter   self iterator    iter hasnext
if  defaulttypetransformation compareequal iter next    value
answer
}
}
return answer
}
/**
* convert a collection to a list.
*
* @param self a collection
* @return a list
*/
public static list tolist collection self
list answer   new arraylist self size
answer addall self
return answer
}
/**
* convert an iterator to a list. the iterator will become
* exhausted of elements after making this conversion.
*
* @param self an iterator
* @return a list
*/
public static list tolist iterator self
list answer   new arraylist
while  self hasnext
answer add self next
}
return answer
}
/**
* convert an enumeration to a list.
*
* @param self an enumeration
* @return a list
*/
public static list tolist enumeration self
list answer   new arraylist
while  self hasmoreelements
answer add self nextelement
}
return answer
}
/**
* iterates through this object transforming each value into a new value using the
* closure as a transformer, returning a list of transformed values.
* example:
* <pre>def list = [1, 'a', 1.23, true ]
* def types = list.collect { it.class }
* </pre>
*
* @param self    the values of the object to transform
* @param closure the closure used to transform each element of the collection
* @return a list of the transformed values
*/
public static list collect object self  closure closure
return  list  collect self  new arraylist    closure
}
/**
* iterates through this object transforming each object into a new value using the closure
* as a transformer and adding it to the collection, returning the resulting collection.
*
* @param self       the values of the object to transform
* @param collection the collection to which the transformed values are added
* @param closure    the closure used to map each element of the collection
* @return the given collection after the transformed values are added
*/
public static collection collect object self  collection collection  closure closure
for  iterator iter   invokerhelper asiterator self   iter hasnext
collection add closure call iter next
}
return collection
}
/**
* iterates through this collection transforming each entry into a new value using the closure
* as a transformer, returning a list of transformed values.
*
* @param self    a collection
* @param closure the closure used for mapping
* @return a list of the transformed values
*/
public static list collect collection self  closure closure
return  list  collect self  new arraylist self size     closure
}
/**
* iterates through this collection transforming each value into a new value using the closure
* as a transformer, returning an initial collection plus the transformed values.
*
* @param self       a collection
* @param collection an initial collection to which the transformed values are added
* @param closure    the closure used to transform each element of the collection
* @return the resulting collection of transformed values
*/
public static collection collect collection self  collection collection  closure closure
for  iterator iter   self iterator    iter hasnext
collection add closure call iter next
if  closure getdirective      closure done
break
}
}
return collection
}
/**
* recursively iterates through this collection transforming each non-collection value
* into a new value using the closure as a transformer. returns a potentially nested
* list of transformed values.
*
* @param self       a collection
* @param closure    the closure used to transform each element of the collection
* @return the resultant collection
*/
public static list collectall collection self  closure closure
return  list  collectall self  new arraylist self size     closure
}
/**
* recursively iterates through this collection transforming each non-collection value
* into a new value using the closure as a transformer. returns a potentially nested
* collection of transformed values.
*
* @param self       a collection
* @param collection an initial collection to which the transformed values are added
* @param closure    the closure used to transform each element of the collection
* @return the resultant collection
*/
public static collection collectall collection self  collection collection  closure closure
for  iterator iter   self iterator    iter hasnext
final object o   iter next
if  o instanceof collection
collection c    collection  o
collection add collectall c  createsimilarcollection collection  c size     closure
} else {
collection add closure call o
}
if  closure getdirective      closure done
break
}
}
return collection
}
/**
* iterates through this map transforming each entry into a new value using the closure
* as a transformer, returning a list of transformed values.
*
* @param self       a map
* @param collection the collection to which the mapped values are added
* @param closure    the closure used for mapping, which can take one (map.entry) or two (key, value) parameters
* @return a list of the mapped values
*/
public static collection collect map self  collection collection  closure closure
boolean istwoparams    closure getparametertypes   length    2
for  iterator iter   self entryset   iterator    iter hasnext
if  istwoparams
map entry entry    map entry  iter next
collection add closure call new object entry getkey    entry getvalue
} else {
collection add closure call iter next
}
}
return collection
}
/**
* iterates through this map transforming each entry into a new value using the closure
* as a transformer, returning a list of transformed values.
*
* @param self    a map
* @param closure the closure used to map each element of the collection
* @return the resultant collection
*/
public static list collect map self  closure closure
return  list  collect self  new arraylist self size     closure
}
/**
* finds the first value matching the closure condition
*
* @param self    an object with an iterator returning its values
* @param closure a closure condition
* @return the first object found
*/
public static object find object self  closure closure
for  iterator iter   invokerhelper asiterator self   iter hasnext
object value   iter next
if  defaulttypetransformation casttoboolean closure call value
return value
}
}
return null
}
/**
* finds the first value matching the closure condition.  example:
* <pre>def list = [1,2,3]
* list.find { it > 1 } // returns 2
* </pre>
*
* @param self    a collection
* @param closure a closure condition
* @return the first object found
*/
public static object find collection self  closure closure
for  iterator iter   self iterator    iter hasnext
object value   iter next
if  defaulttypetransformation casttoboolean closure call value
return value
}
}
return null
}
/**
* finds the first entry matching the closure condition.  if the closure takes
* two parameters, the entry key and value are passed.  if the closure takes
* one parameter, the map.entry object is passed.
*
* @param self    a map
* @param closure a closure condition
* @return the first object found
*/
public static object find map self  closure closure
for  iterator iter   self entryset   iterator    iter hasnext
map entry entry    map entry  iter next
if  defaulttypetransformation casttoboolean callclosureformapentry closure  entry
return entry
}
}
return null
}
/**
* finds all items matching the closure condition.
*
* @param self    an object with an iterator returning its values
* @param closure a closure condition
* @return a list of the values found
*/
public static list findall object self  closure closure
list answer   new arraylist
for  iterator iter   invokerhelper asiterator self   iter hasnext
object value   iter next
if  defaulttypetransformation casttoboolean closure call value
answer add value
}
}
return answer
}
/**
* finds all values matching the closure condition.
*
* @param self    a collection
* @param closure a closure condition
* @return a collection of matching values
*/
public static collection findall collection self  closure closure
collection answer   createsimilarcollection self
for  iterator iter   self iterator    iter hasnext
object value   iter next
if  defaulttypetransformation casttoboolean closure call value
answer add value
}
}
return answer
}
/**
* adds groovycollections#combinations(collection) as a method on collections.
*
* @param self a collection of lists
* @return a list of the combinations found
* @see groovy.util.groovycollections#combinations(java.util.collection)
*/
public static list combinations collection self
return groovycollections combinations self
}
/**
* adds groovycollections#transpose(collection) as a method on collections.
*
* @param self a collection of lists
* @return a list of the transposed lists
* @see groovy.util.groovycollections#transpose(java.util.collection)
*/
public static list transpose collection self
return groovycollections transpose self
}
/**
* finds all entries matching the closure condition. if the
* closure takes one parameter then it will be passed the map.entry.
* otherwise if the closure should take two parameters, which will be
* the key and the value.
*
* @param self    a map
* @param closure a closure condition applying on the entries
* @return a new submap
*/
public static map findall map self  closure closure
map answer   new hashmap self size
for  iterator iter   self entryset   iterator    iter hasnext
map entry entry    map entry  iter next
if  defaulttypetransformation casttoboolean callclosureformapentry closure  entry
answer put entry getkey    entry getvalue
}
}
return answer
}
/**
* sorts all collection members into groups determined by the
* supplied mapping closure.  the closure should return the key that this
* item should be grouped by.  the returned map will have an entry for each
* distinct key returned from the closure, with each value being a list of
* items for that group.
*
* @param self    a collection to group (no map)
* @param closure a closure mapping entries on keys
* @return a new map grouped by keys
*/
public static map groupby collection self  closure closure
map answer   new hashmap
for  iterator iter   self iterator    iter hasnext
object element   iter next
object value   closure call element
groupanswer answer  element  value
}
return answer
}
/**
* groups all map entries into groups determined by the
* supplied mapping closure. the closure will be passed a map.entry or
* key and value (depending on the number of parameters the closure accepts)
* and should return the key that each item should be grouped under.  the
* resulting map will have an entry for each 'group' key returned by the
* closure, with values being the list of map entries that belong to each
* group.
*
* @param self    a map to group
* @param closure a closure mapping entries on keys
* @return a new map grouped by keys
*/
public static map groupentriesby map self  closure closure
final map answer   new hashmap
for  final iterator iter   self entryset   iterator    iter hasnext
map entry entry    map entry  iter next
object value   callclosureformapentry closure  entry
groupanswer answer  entry  value
}
return answer
}
/**
* groups the members of a map into sub maps determined by the
* supplied mapping closure. the closure will be passed a map.entry or
* key and value (depending on the number of parameters the closure accepts)
* and should return the key that each item should be grouped under.  the
* resulting map will have an entry for each 'group' key returned by the
* closure, with values being the map members from the original map that
* belong to each group.
*
* @param self    a map to group
* @param closure a closure mapping entries on keys
* @return a new map grouped by keys
*/
public static map groupby map self  closure closure
final map initial   groupentriesby self  closure
final map answer   new hashmap
iterator iterator   initial entryset   iterator
while  iterator hasnext
map entry outer    map entry  iterator next
object key   outer getkey
list entries    list  outer getvalue
map target   new hashmap
for  int i   0  i < entries size    i
map entry inner    map entry  entries get i
target put inner getkey    inner getvalue
}
answer put key  target
}
return answer
}
/**
* groups the current element according to the value
*
* @param answer  the map containing the results
* @param element the element to be placed
* @param value   the value according to which the element will be placed
*/
protected static void groupanswer final map answer  object element  object value
if  answer containskey value
list  answer get value   add element
} else {
list groupedelements   new arraylist
groupedelements add element
answer put value  groupedelements
}
}
// internal helper method
protected static object callclosureformapentry closure closure  map entry entry
if  closure getmaximumnumberofparameters      2
return closure call new object entry getkey    entry getvalue
}
return closure call entry
}
// internal helper method
protected static object callclosureforline closure closure  string line  int counter
if  closure getmaximumnumberofparameters      2
return closure call new object line  integer valueof counter
}
return closure call line
}
protected static object callclosureformapentryandcounter closure closure  map entry entry  int counter
if  closure getmaximumnumberofparameters      3
return closure call new object entry getkey    entry getvalue    integer valueof counter
}
if  closure getmaximumnumberofparameters      2
return closure call new object entry  integer valueof counter
}
return closure call entry
}
/**
* iterates through the given collection, passing in the initial value to
* the closure along with the current iterated item then passing into the
* next iteration the value of the previous closure.
*
* @param self    a collection
* @param value   a value
* @param closure a closure
* @return the last value of the last iteration
*/
public static object inject collection self  object value  closure closure
return inject self iterator    value  closure
}
/**
* iterates through the given iterator, passing in the initial value to
* the closure along with the current iterated item then passing into the
* next iteration the value of the previous closure.
*
* @param self    a collection
* @param value   a value
* @param closure a closure
* @return the last value of the last iteration
*/
public static object inject iterator self  object value  closure closure
object params   new object
while  self hasnext
object item   self next
params   value
params   item
value   closure call params
}
return value
}
/**
* iterates through the given object, passing in the initial value to
* the closure along with the current iterated item then passing into the
* next iteration the value of the previous closure.
*
* @param self    a collection
* @param value   a value
* @param closure a closure
* @return the last value of the last iteration
*/
public static object inject object self  object value  closure closure
iterator iter   invokerhelper asiterator self
return inject iter  value  closure
}
/**
* iterates through the given array of objects, passing in the initial value to
* the closure along with the current iterated item then passing into the
* next iteration the value of the previous closure.
*
* @param self         an object[]
* @param initialvalue an initialvalue
* @param closure      a closure
* @return the last value of the last iteration
*/
public static object inject object self  object initialvalue  closure closure
object params   new object
object value   initialvalue
for  int i   0  i < self length  i
params   value
params   self
value   closure call params
}
return value
}
/**
* sums the items in a collection.  this is equivalent to invoking the
* "plus" method on all items in the collection.
*
* @param self collection of values to add together
* @return the sum of all of the items
*/
public static object sum collection self
return sum self  null  true
}
/**
* sums the items from an iterator.  this is equivalent to invoking the
* "plus" method on all items from the iterator. the iterator will become
* exhausted of elements after determining the sum value.
*
* @param self an iterator for the values to add together
* @return the sum of all of the items
*/
public static object sum iterator self
return sum tolist self   null  true
}
/**
* sums the items in a collection, adding the result to some initial value.
*
* @param self         a collection of values to sum
* @param initialvalue the items in the collection will be summed to this initial value
* @return the sum of all of the collection items.
*/
public static object sum collection self  object initialvalue
return sum self  initialvalue  false
}
/**
* sums the items from an iterator.  this is equivalent to invoking the
* "plus" method on all items from the iterator.
*
* @param self         an iterator for the values to add together
* @param initialvalue the items in the collection will be summed to this initial value
* @return the sum of all of the items
*/
public static object sum iterator self  object initialvalue
return sum tolist self   initialvalue  false
}
private static object sum collection self  object initialvalue  boolean first
object result   initialvalue
object param   new object
for  iterator iter   self iterator    iter hasnext
param   iter next
if  first
result   param
first   false
continue
}
metaclass metaclass   invokerhelper getmetaclass result
result   metaclass invokemethod result     param
}
return result
}
/**
* sums the result of apply a closure to each item of a collection.
* <code>coll.sum(closure)</code> is equivalent to:
* <code>coll.collect(closure).sum()</code>.
*
* @param self    a collection
* @param closure a single parameter closure that returns a numeric value.
* @return the sum of the values returned by applying the closure to each
*         item of the list.
*/
public static object sum collection self  closure closure
return sum self  null  closure  true
}
/**
* sums the result of apply a closure to each item of a collection to sum intial value.
* <code>coll.sum(closure)</code> is equivalent to:
* <code>coll.collect(closure).sum()</code>.
*
* @param self         a collection
* @param closure      a single parameter closure that returns a numeric value.
* @param initialvalue the closure results will be summed to this initial value
* @return the sum of the values returned by applying the closure to each
*         item of the list.
*/
public static object sum collection self  object initialvalue  closure closure
return sum self  initialvalue  closure  false
}
private static object sum collection self  object initialvalue  closure closure  boolean first
object result   initialvalue
object closureparam   new object
object plusparam   new object
for  iterator iter   self iterator    iter hasnext
closureparam   iter next
plusparam   closure call closureparam
if  first
result   plusparam
first   false
continue
}
metaclass metaclass   invokerhelper getmetaclass result
result   metaclass invokemethod result     plusparam
}
return result
}
/**
* concatenates the <code>tostring()</code> representation of each
* item from the iterator, with the given string as a separator between
* each item. the iterator will become exhausted of elements after
* determining the resulting conjoined value.
*
* @param self      an iterator of items
* @param separator a string separator
* @return the joined string
*/
public static string join iterator self  string separator
return join tolist self   separator
}
/**
* concatenates the <code>tostring()</code> representation of each
* item in this collection, with the given string as a separator between
* each item.
*
* @param self      a collection of objects
* @param separator a string separator
* @return the joined string
*/
public static string join collection self  string separator
stringbuffer buffer   new stringbuffer
boolean first   true
if  separator    null  separator
for  iterator iter   self iterator    iter hasnext
object value   iter next
if  first
first   false
} else {
buffer append separator
}
buffer append invokerhelper tostring value
}
return buffer tostring
}
/**
* concatenates the <code>tostring()</code> representation of each
* items in this array, with the given string as a separator between each
* item.
*
* @param self      an array of object
* @param separator a string separator
* @return the joined string
*/
public static string join object self  string separator
stringbuffer buffer   new stringbuffer
boolean first   true
if  separator    null  separator
for  int i   0  i < self length  i
string value   invokerhelper tostring self
if  first
first   false
} else {
buffer append separator
}
buffer append value
}
return buffer tostring
}
/**
* adds min() method to collection objects.
*
* @param self a collection
* @return the minimum value
* @see groovy.util.groovycollections#min(java.util.collection)
*/
public static object min collection self
return groovycollections min self
}
/**
* adds min() method to iterator objects. the iterator will become
* exhausted of elements after determining the minimum value.
*
* @param self an iterator
* @return the minimum value
* @see #min(java.util.collection)
*/
public static object min iterator self
return min tolist self
}
/**
* adds min() method to object arrays.
*
* @param self an object array
* @return the minimum value
* @see #min(java.util.collection)
*/
public static object min object self
return min tolist self
}
/**
* selects the minimum value found in the collection using the given comparator.
*
* @param self       a collection
* @param comparator a comparator
* @return the minimum value
*/
public static object min collection self  comparator comparator
object answer   null
for  iterator iter   self iterator    iter hasnext
object value   iter next
if  answer    null    comparator compare value  answer  < 0
answer   value
}
}
return answer
}
/**
* selects the minimum value found from the iterator using the given comparator.
*
* @param self       an iterator
* @param comparator a comparator
* @return the minimum value
* @see #min(java.util.collection, java.util.comparator)
*/
public static object min iterator self  comparator comparator
return min tolist self   comparator
}
/**
* selects the minimum value found from the object array using the given comparator.
*
* @param self       an object array
* @param comparator a comparator
* @return the minimum value
* @see #min(java.util.collection, java.util.comparator)
*/
public static object min object self  comparator comparator
return min tolist self   comparator
}
/**
* selects the minimum value found in the collection using the given closure
* as a comparator.  the closure should return a comparable value (i.e. a
* number) for each item passed.  the collection item for which the closure
* returns the smallest comparable value will be returned from this method
* as the minimum.
*
* @param self    a collection
* @param closure a closure used as a comparator
* @return the minimum value
*/
public static object min collection self  closure closure
int params   closure getmaximumnumberofparameters
if  params    1
return min self  new closurecomparator closure
}
object answer   null
object answer_value   null
for  iterator iter   self iterator    iter hasnext
object item   iter next
object value   closure call item
if  answer    null    scriptbytecodeadapter comparelessthan value  answer_value
answer   item
answer_value   value
}
}
return answer
}
/**
* selects the minimum value found from the iterator using the given closure
* as a comparator.  the closure should return a comparable value (i.e. a
* number) for each item passed. the iterator will become
* exhausted of elements after this operation.
*
* @param self    an iterator
* @param closure a closure used as a comparator
* @return the minimum value
* @see #min(java.util.collection, groovy.lang.closure)
*/
public static object min iterator self  closure closure
return min tolist self   closure
}
/**
* selects the minimum value found from the object array using the given closure
* as a comparator.  the closure should return a comparable value (i.e. a
* number) for each item passed.
*
* @param self    an object array
* @param closure a closure used as a comparator
* @return the minimum value
* @see #min(java.util.collection, groovy.lang.closure)
*/
public static object min object self  closure closure
return min tolist self   closure
}
/**
* adds max() method to collection objects.
*
* @param self a collection
* @return the maximum value
* @see groovy.util.groovycollections#max(java.util.collection)
*/
public static object max collection self
return groovycollections max self
}
/**
* adds max() method to iterator objects. the iterator will become
* exhausted of elements after determining the maximum value.
*
* @param self an iterator
* @return the maximum value
* @see groovy.util.groovycollections#max(java.util.collection)
*/
public static object max iterator self
return max tolist self
}
/**
* adds max() method to object arrays.
*
* @param self an object array
* @return the maximum value
* @see #max(java.util.collection)
*/
public static object max object self
return max tolist self
}
/**
* selects the maximum value found in the collection using the given closure
* as a comparator.  the closure should return a comparable value (i.e. a
* number) for each item passed.  the collection item for which the closure
* returns the largest comparable value will be returned from this method
* as the maximum.
*
* @param self    a collection
* @param closure a closure used as a comparator
* @return the maximum value
*/
public static object max collection self  closure closure
int params   closure getmaximumnumberofparameters
if  params    1
return max self  new closurecomparator closure
}
object answer   null
object answervalue   null
for  iterator iter   self iterator    iter hasnext
object item   iter next
object value   closure call item
if  answer    null    scriptbytecodeadapter comparelessthan answervalue  value
answer   item
answervalue   value
}
}
return answer
}
/**
* selects the maximum value found from the iterator using the given closure
* as a comparator.  the closure should return a comparable value (i.e. a
* number) for each item passed. the iterator will become
* exhausted of elements after this operation.
*
* @param self    an iterator
* @param closure a closure used as a comparator
* @return the maximum value
* @see #max(java.util.collection, groovy.lang.closure)
*/
public static object max iterator self  closure closure
return max tolist self   closure
}
/**
* selects the maximum value found from the object array using the given closure
* as a comparator.  the closure should return a comparable value (i.e. a
* number) for each item passed.
*
* @param self    an object array
* @param closure a closure used as a comparator
* @return the maximum value
* @see #max(java.util.collection, groovy.lang.closure)
*/
public static object max object self  closure closure
return max tolist self   closure
}
/**
* selects the maximum value found in the collection using the given comparator.
*
* @param self       a collection
* @param comparator a comparator
* @return the maximum value
*/
public static object max collection self  comparator comparator
object answer   null
for  iterator iter   self iterator    iter hasnext
object value   iter next
if  answer    null    comparator compare value  answer  > 0
answer   value
}
}
return answer
}
/**
* selects the maximum value found from the iterator using the given comparator.
*
* @param self       an iterator
* @param comparator a comparator
* @return the maximum value
*/
public static object max iterator self  comparator comparator
return max tolist self   comparator
}
/**
* selects the maximum value found from the object array using the given comparator.
*
* @param self       an object array
* @param comparator a comparator
* @return the maximum value
*/
public static object max object self  comparator comparator
return max tolist self   comparator
}
/**
* provide the standard groovy <code>size()</code> method for <code>iterator</code>.
* the iterator will become exhausted of elements after determining the size value.
*
* @param self an iterator
* @return the length of the iterator
*/
public static int size iterator self
int count   0
while  self hasnext
self next
count
}
return count
}
/**
* provide the standard groovy <code>size()</code> method for <code>string</code>.
*
* @param text a string
* @return the length of the string
*/
public static int size string text
return text length
}
/**
* provide the standard groovy <code>size()</code> method for <code>stringbuffer</code>.
*
* @param buffer a stringbuffer
* @return the length of the stringbuffer
*/
public static int size stringbuffer buffer
return buffer length
}
/**
* provide the standard groovy <code>size()</code> method for <code>file</code>.
*
* @param self a file object
* @return the file's size (length)
*/
public static long size file self
return self length
}
/**
* provide the standard groovy <code>size()</code> method for <code>matcher</code>.
*
* @param self a matcher object
* @return the matcher's size (count)
*/
public static long size matcher self
return getcount self
}
/**
* provide the standard groovy <code>size()</code> method for an array.
*
* @param self an array of objects
* @return the size (length) of the array
*/
public static int size object self
return self length
}
/**
* support the subscript operator for charsequence.
*
* @param text  a charsequence
* @param index the index of the character to get
* @return the character at the given index
*/
public static charsequence getat charsequence text  int index
index   normaliseindex index  text length
return text subsequence index  index   1
}
/**
* support the subscript operator for string.
*
* @param text  a string
* @param index the index of the character to get
* @return the character at the given index
*/
public static string getat string text  int index
index   normaliseindex index  text length
return text substring index  index   1
}
/**
* support the range subscript operator for charsequence
*
* @param text  a charsequence
* @param range a range
* @return the subsequence charsequence
*/
public static charsequence getat charsequence text  range range
int from   normaliseindex defaulttypetransformation intunbox range getfrom     text length
int to   normaliseindex defaulttypetransformation intunbox range getto     text length
boolean reverse   range isreverse
// if this is a backwards range, reverse the arguments to substring.
if  from > to
int tmp   from
from   to
to   tmp
reverse    reverse
}
charsequence sequence   text subsequence from  to   1
return reverse ? reverse  string  sequence    sequence
}
/**
* support the range subscript operator for charsequence or stringbuffer with intrange
*
* @param text  a charsequence
* @param range an intrange
* @return the subsequence charsequence
*/
public static charsequence getat charsequence text  intrange range
return getat text   range  range
}
/**
* support the range subscript operator for charsequence or stringbuffer with emptyrange
*
* @param text  a charsequence
* @param range an emptyrange
* @return the subsequence charsequence
*/
public static charsequence getat charsequence text  emptyrange range
return
}
/**
* support the range subscript operator for string with intrange
*
* @param text  a string
* @param range an intrange
* @return the resulting string
*/
public static string getat string text  intrange range
return getat text   range  range
}
/**
* support the range subscript operator for string with emptyrange
*
* @param text  a string
* @param range an emptyrange
* @return the resulting string
*/
public static string getat string text  emptyrange range
return
}
/**
* support the range subscript operator for string
*
* @param text  a string
* @param range a range
* @return a substring corresponding to the range
*/
public static string getat string text  range range
int from   normaliseindex defaulttypetransformation intunbox range getfrom     text length
int to   normaliseindex defaulttypetransformation intunbox range getto     text length
// if this is a backwards range, reverse the arguments to substring.
boolean reverse   range isreverse
if  from > to
int tmp   to
to   from
from   tmp
reverse    reverse
}
string answer   text substring from  to   1
if  reverse
answer   reverse answer
}
return answer
}
/**
* creates a new string which is the reverse (backwards) of this string
*
* @param self a string
* @return a new string with all the characters reversed.
*/
public static string reverse string self
int size   self length
stringbuffer buffer   new stringbuffer size
for  int i   size   1  i >  0  i
buffer append self charat i
}
return buffer tostring
}
/**
* transforms a string representing a url into a url object.
*
* @param self the string representing a url
* @return a url
* @throws malformedurlexception is thrown if the url is not well formed.
*/
public static url tourl string self  throws malformedurlexception
return new url self
}
/**
* transforms a string representing a uri into a uri object.
*
* @param self the string representing a uri
* @return a uri
* @throws urisyntaxexception is thrown if the uri is not well formed.
*/
public static uri touri string self  throws urisyntaxexception
return new uri self
}
/**
* turns a string into a regular expression pattern
*
* @param self a string to convert into a regular expression
* @return the regular expression pattern
*/
public static pattern bitwisenegate string self
return pattern compile self
}
/**
* replaces all occurrencies of a captured group by the result of a closure on that text.
* <p/>
* <p> for examples,
* <pre>
*     assert "foobar-foobar-" == "foobar-foobar-".replaceall("(([ff][oo]{2})[bb]ar)", { object[] it -> it[0].touppercase() })
* <p/>
*     here,
*          it[0] is the global string of the matched group
*          it[1] is the first string in the matched group
*          it[2] is the second string in the matched group
* <p/>
* <p/>
*     assert "foo-foo-" == "foobar-foobar-".replaceall("(([ff][oo]{2})[bb]ar)", { x, y, z -> z.touppercase() })
* <p/>
*     here,
*          x is the global string of the matched group
*          y is the first string in the matched group
*          z is the second string in the matched group
* </pre>
*
* @param self    a string
* @param regex   the capturing regex
* @param closure the closure to apply on each captured group
* @return a string with replaced content
*/
public static string replaceall string self  string regex  closure closure
matcher matcher   pattern compile regex  matcher self
if  matcher find
matcher reset
stringbuffer sb   new stringbuffer
while  matcher find
int count   matcher groupcount
list groups   new arraylist
for  int i   0  i <  count  i
groups add matcher group i
}
matcher appendreplacement sb  string valueof closure call groups toarray
}
matcher appendtail sb
return sb tostring
} else {
return self
}
}
private static string getpadding string padding  int length
if  padding length   < length
return multiply padding  integer valueof length   padding length     1   substring 0  length
} else {
return padding substring 0  length
}
}
/**
* pad a string with the characters appended to the left
*
* @param self          a string object
* @param numberofchars the total number of characters
* @param padding       the charaters used for padding
* @return the string padded to the left
*/
public static string padleft string self  number numberofchars  string padding
int numchars   numberofchars intvalue
if  numchars <  self length
return self
} else {
return getpadding padding  numchars   self length      self
}
}
/**
* pad a string with the spaces appended to the left
*
* @param self          a string object
* @param numberofchars the total number of characters
* @return the string padded to the left
*/
public static string padleft string self  number numberofchars
return padleft self  numberofchars
}
/**
* pad a string with the characters appended to the right
*
* @param self          a string object
* @param numberofchars the total number of characters
* @param padding       the charaters used for padding
* @return the string padded to the right
*/
public static string padright string self  number numberofchars  string padding
int numchars   numberofchars intvalue
if  numchars <  self length
return self
} else {
return self   getpadding padding  numchars   self length
}
}
/**
* pad a string with the spaces appended to the right
*
* @param self          a string object
* @param numberofchars the total number of characters
* @return the string padded to the right
*/
public static string padright string self  number numberofchars
return padright self  numberofchars
}
/**
* center a string and padd it with the characters appended around it
*
* @param self          a string object
* @param numberofchars the total number of characters
* @param padding       the charaters used for padding
* @return the string centered with padded character around
*/
public static string center string self  number numberofchars  string padding
int numchars   numberofchars intvalue
if  numchars <  self length
return self
} else {
int charstoadd   numchars   self length
string semipad   charstoadd % 2    1 ?
getpadding padding  charstoadd   2   1
getpadding padding  charstoadd   2
if  charstoadd % 2    0
return semipad   self   semipad
else
return semipad substring 0  charstoadd   2    self   semipad
}
}
/**
* center a string and padd it with spaces appended around it
*
* @param self          a string object
* @param numberofchars the total number of characters
* @return the string centered with padded character around
*/
public static string center string self  number numberofchars
return center self  numberofchars
}
/**
* support the subscript operator, e.g.&nbsp;matcher[index], for a regex matcher.
* <p/>
* for an example using no group match, <code><pre>
*    def p = /ab[d|f]/
*    def m = "abcabdabeabf" =~ p
*    for (i in 0..<m.count) {
*        println( "m.groupcount() = " + m.groupcount())
*        println( "  " + i + ": " + m[i] )   // m[i] is a string
*    }
* </pre></code>
* <p/>
* for an example using group matches, <code><pre>
*    def p = /(?:ab([c|d|e|f]))/
*    def m = "abcabdabeabf" =~ p
*    for (i in 0..<m.count) {
*        println( "m.groupcount() = " + m.groupcount())
*        println( "  " + i + ": " + m[i] )   // m[i] is a list
*    }
* </pre></code>
* <p/>
* for another example using group matches, <code><pre>
*    def m = "abcabdabeabfabxyzabx" =~ /(?:ab([d|x-z]+))/
*    m.count.times {
*        println( "m.groupcount() = " + m.groupcount())
*        println( "  " + it + ": " + m[it] )   // m[it] is a list
*    }
* </pre></code>
*
* @param matcher a matcher
* @param idx     an index
* @return object a matched string if no groups matched, list of matched groups otherwise.
*/
public static object getat matcher matcher  int idx
try {
int count   getcount matcher
if  idx <  count    idx >  count
throw new indexoutofboundsexception       count         count   1        idx
}
idx   normaliseindex idx  count
matcher reset
for  int i   0  i <  idx  i
matcher find
}
if  hasgroup matcher
// are we using groups?
// yes, so return the specified group as list
list list   new arraylist matcher groupcount
for  int i   0  i <  matcher groupcount    i
list add matcher group i
}
return list
} else {
// not using groups, so return the nth
// occurrence of the pattern
return matcher group
}
}
catch  illegalstateexception ex
return null
}
}
/**
* set the position of the given matcher to the given index.
*
* @param matcher a matcher
* @param idx     the index number
*/
public static void setindex matcher matcher  int idx
int count   getcount matcher
if  idx <  count    idx >  count
throw new indexoutofboundsexception       count         count   1        idx
}
if  idx    0
matcher reset
else if  idx > 0
matcher reset
for  int i   0  i < idx  i
matcher find
}
else if  idx < 0
matcher reset
idx    getcount matcher
for  int i   0  i < idx  i
matcher find
}
}
}
/**
* find the number of strings matched to the given matcher.
*
* @param matcher a matcher
* @return int  the number of strings matched to the given matcher.
*/
public static int getcount matcher matcher
int counter   0
matcher reset
while  matcher find
counter
}
return counter
}
/**
* check whether a matcher contains a group or not.
*
* @param matcher a matcher
* @return boolean  <code>true</code> if matcher contains at least one group.
*/
public static boolean hasgroup matcher matcher
return matcher groupcount   > 0
}
/**
* support the range subscript operator for a list
*
* @param self  a list
* @param range a range indicating the items to get
* @return a sublist based on range borders or a new list if range is reversed
* @see java.util.list#sublist(int,int)
*/
public static list getat list self  intrange range
rangeinfo info   sublistborders self size    range
list answer   self sublist info from  info to       sublist is always exclusive  but ranges are not
if  info reverse
answer   reverse answer
}
return answer
}
/**
* allows a list to be used as the indices to be used on a list
*
* @param self    a list
* @param indices a collection of indices
* @return a new list of the values at the given indices
*/
public static list getat list self  collection indices
list answer   new arraylist indices size
for  iterator iter   indices iterator    iter hasnext
object value   iter next
if  value instanceof range
answer addall getat self   range  value
else if  value instanceof list
answer addall getat self   list  value
} else {
int idx   defaulttypetransformation intunbox value
answer add getat self  idx
}
}
return answer
}
/**
* allows a list to be used as the indices to be used on a list
*
* @param self    an array of objects
* @param indices a collection of indices
* @return a new list of the values at the given indices
*/
public static list getat object self  collection indices
list answer   new arraylist indices size
for  iterator iter   indices iterator    iter hasnext
object value   iter next
if  value instanceof range
answer addall getat self   range  value
else if  value instanceof collection
answer addall getat self   collection  value
} else {
int idx   defaulttypetransformation intunbox value
answer add getatimpl self  idx
}
}
return answer
}
/**
* allows a list to be used as the indices to be used on a charsequence
*
* @param self    a charsequence
* @param indices a collection of indices
* @return a string of the values at the given indices
*/
public static charsequence getat charsequence self  collection indices
stringbuffer answer   new stringbuffer
for  iterator iter   indices iterator    iter hasnext
object value   iter next
if  value instanceof range
answer append getat self   range  value
else if  value instanceof collection
answer append getat self   collection  value
} else {
int idx   defaulttypetransformation intunbox value
answer append getat self  idx
}
}
return answer tostring
}
/**
* allows a list to be used as the indices to be used on a string
*
* @param self    a string
* @param indices a collection of indices
* @return a string of the values at the given indices
*/
public static string getat string self  collection indices
return  string  getat  charsequence  self  indices
}
/**
* allows a list to be used as the indices to be used on a matcher
*
* @param self    a matcher
* @param indices a collection of indices
* @return a string of the values at the given indices
*/
public static string getat matcher self  collection indices
stringbuffer answer   new stringbuffer
for  iterator iter   indices iterator    iter hasnext
object value   iter next
if  value instanceof range
answer append getat self   range  value
else if  value instanceof collection
answer append getat self   collection  value
} else {
int idx   defaulttypetransformation intunbox value
answer append getat self  idx
}
}
return answer tostring
}
/**
* creates a sub-map containing the given keys. this method is similar to
* list.sublist() but uses keys rather than index ranges.
*
* @param map  a map
* @param keys a collection of keys
* @return a new map containing the given keys
*/
public static map submap map map  collection keys
map answer   new linkedhashmap keys size
for  iterator iter   keys iterator    iter hasnext
object key   iter next
answer put key  map get key
}
return answer
}
/**
* looks up an item in a map for the given key and returns the value - unless
* there is no entry for the given key in which case add the default value
* to the map and return that.
*
* @param map          a map
* @param key          the key to lookup the value of
* @param defaultvalue the value to return and add to the map for this key if
*                     there is no entry for the given key
* @return the value of the given key or the default value, added to the map if the
*         key did not exist
*/
public static object get map map  object key  object defaultvalue
object answer   map get key
if  answer    null
answer   defaultvalue
map put key  answer
}
return answer
}
/**
* support the range subscript operator for an array
*
* @param array an array of objects
* @param range a range
* @return a range of a list from the range's from index up to but not
*         including the ranges's to value
*/
public static list getat object array  range range
list list   arrays aslist array
return getat list  range
}
public static list getat object array  intrange range
list list   arrays aslist array
return getat list  range
}
public static list getat object array  emptyrange range
return new arraylist
}
public static list getat object array  objectrange range
list list   arrays aslist array
return getat list  range
}
private static object getatimpl object array  int idx
return array
}
/**
* allows conversion of arrays into a mutable list.
*
* @param array an array of objects
* @return the array as a list
*/
public static list tolist object array
return new arraylist arrays aslist array
}
/**
* support the subscript operator for a list.
*
* @param self a list
* @param idx  an index
* @return the value at the given index
*/
public static object getat list self  int idx
int size   self size
int i   normaliseindex idx  size
if  i < size
return self get i
} else {
return null
}
}
/**
* support the subscript operator for a date.
*
* @param self  a date
* @param field a calendar field, e.g. month
* @return the value for the given field, e.g. february
* @see java.util.calendar
*/
public static int getat date self  int field
calendar cal   calendar getinstance
cal settime self
return cal get field
}
/**
* a helper method to allow lists to work with subscript operators.
*
* @param self  a list
* @param idx   an index
* @param value the value to put at the given index
*/
public static void putat list self  int idx  object value
int size   self size
idx   normaliseindex idx  size
if  idx < size
self set idx  value
} else {
while  size < idx
self add size    null
}
self add idx  value
}
}
/**
* support the range subscript operator for stringbuffer.  index values are
* treated as characters within the buffer.
*
* @param self  a stringbuffer
* @param range a range
* @param value the object that's tostring() will be inserted
*/
public static void putat stringbuffer self  intrange range  object value
rangeinfo info   sublistborders self length    range
self replace info from  info to  value tostring
}
/**
* support the range subscript operator for stringbuffer.
*
* @param self  a stringbuffer
* @param range a range
* @param value the object that's tostring() will be inserted
*/
public static void putat stringbuffer self  emptyrange range  object value
rangeinfo info   sublistborders self length    range
self replace info from  info to  value tostring
}
/**
* a helper method to allow lists to work with subscript operators.
*
* @param self  a list
* @param range the subset of the list to set
* @param value the values to put at the given sublist or a collection of values
*/
public static void putat list self  emptyrange range  object value
rangeinfo info   sublistborders self size    range
list sublist   self sublist info from  info to
sublist clear
if  value instanceof collection
collection col    collection  value
if  col isempty    return
sublist addall col
} else {
sublist add value
}
}
private static list resizelistwithrangeandgetsublist list self  intrange range
rangeinfo info   sublistborders self size    range
int size   self size
if  info to >  size
while  size < info to
self add size    null
}
}
list sublist   self sublist info from  info to
sublist clear
return sublist
}
/**
* list subscript assignment operator when given a range as the index and
* the assignment operand is a collection.
* example: <code>mylist[3..5] = anotherlist</code>.  items in the given
* range are relaced with items from the collection.
*
* @param self  a list
* @param range the subset of the list to set
* @param col   the collection of values to put at the given sublist
*/
public static void putat list self  intrange range  collection col
list sublist   resizelistwithrangeandgetsublist self  range
if  col isempty    return
sublist addall col
}
/**
* list subscript assignment operator when given a range as the index.
* example: <code>mylist[3..5] = newitem</code>.  items in the given
* range are relaced with the operand.  the <code>value</code> operand is
* always treated as a single value.
*
* @param self  a list
* @param range the subset of the list to set
* @param value the value to put at the given sublist
*/
public static void putat list self  intrange range  object value
list sublist   resizelistwithrangeandgetsublist self  range
sublist add value
}
/**
* a helper method to allow lists to work with subscript operators.
*
* @param self   a list
* @param splice the subset of the list to set
* @param values the value to put at the given sublist
* @deprecated replace with putat(list self, range range, list value)
*/
public static void putat list self  list splice  list values
list sublist   getsublist self  splice
sublist clear
sublist addall values
}
/**
* a helper method to allow lists to work with subscript operators.
*
* @param self   a list
* @param splice the subset of the list to set
* @param value  the value to put at the given sublist
* @deprecated replace with putat(list self, range range, object value)
*/
public static void putat list self  list splice  object value
list sublist   getsublist self  splice
sublist clear
sublist add value
}
// helper method for putat(splice)
// todo: remove after putat(splice) gets deleted
protected static list getsublist list self  list splice
int left      0
int right   0
boolean emptyrange   false
if  splice size      2
left   defaulttypetransformation intunbox splice get 0
right   defaulttypetransformation intunbox splice get 1
else if  splice instanceof intrange
intrange range    intrange  splice
left   range getfromint
right   range gettoint
else if  splice instanceof emptyrange
rangeinfo info   sublistborders self size     emptyrange  splice
left   info from
emptyrange   true
} else {
throw new illegalargumentexception
}
int size   self size
left   normaliseindex left  size
right   normaliseindex right  size
list sublist      null
if   emptyrange
sublist   self sublist left  right   1
} else {
sublist   self sublist left  left
}
return sublist
}
/**
* support the subscript operator for a map.
*
* @param self a map
* @param key  an object as a key for the map
* @return the value corresponding to the given key
*/
public static object getat map self  object key
return self get key
}
/**
* <p/>
* returns a new map containing all entries from <code>left</code> and <code>right</code>,
* giving precedence to <code>right</code>.  any keys appearing in both maps
* will appear in the resultant map with values from the <code>right</code>
* operand. if the <code>left</code> map is one of treemap, linkedhashmap, hashtable
* or properties, the returned map will preserve that type, otherwise a hashmap will
* be returned.
* </p>
* <p/>
* roughly equivalent to <code>map m = new hashmap(); m.putall(left); m.putall(right); return m;</code>
* but with some additional logic to preserve the <code>left</code> map type for common cases as
* described above.
* </p>
*
* @param left  a map
* @param right a map
* @return a new map containing all entries from left and right
*/
public static map plus map left  map right
map map   clonesimilarmap left
map putall right
return map
}
/**
* a helper method to allow lists to work with subscript operators
*
* @param self  a map
* @param key   an object as a key for the map
* @param value the value to put into the map
* @return the value corresponding to the given key
*/
public static object putat map self  object key  object value
self put key  value
return value
}
/**
* support the subscript operator for list
*
* @param coll     a collection
* @param property a string
* @return a list
*/
public static list getat collection coll  string property
list answer   new arraylist coll size
for  iterator iter   coll iterator    iter hasnext
object item   iter next
object value
try {
value   invokerhelper getproperty item  property
catch  missingpropertyexceptionnostack mpe
string causestring   new missingpropertyexception mpe getproperty    mpe gettype    tostring
throw new missingpropertyexception     property
coll getclass   getname         causestring
}
answer add value
}
return answer
}
/**
* a convenience method for creating an immutable map.
*
* @param self a map
* @return an immutable map
* @see java.util.collections#unmodifiablemap(java.util.map)
*/
public static map asimmutable map self
return collections unmodifiablemap self
}
/**
* a convenience method for creating an immutable sorted map.
*
* @param self a sortedmap
* @return an immutable sortedmap
* @see java.util.collections#unmodifiablesortedmap(java.util.sortedmap)
*/
public static sortedmap asimmutable sortedmap self
return collections unmodifiablesortedmap self
}
/**
* a convenience method for creating an immutable list
*
* @param self a list
* @return an immutable list
* @see java.util.collections#unmodifiablelist(java.util.list)
*/
public static list asimmutable list self
return collections unmodifiablelist self
}
/**
* a convenience method for creating an immutable list.
*
* @param self a set
* @return an immutable set
* @see java.util.collections#unmodifiableset(java.util.set)
*/
public static set asimmutable set self
return collections unmodifiableset self
}
/**
* a convenience method for creating an immutable sorted set.
*
* @param self a sortedset
* @return an immutable sortedset
* @see java.util.collections#unmodifiablesortedset(java.util.sortedset)
*/
public static sortedset asimmutable sortedset self
return collections unmodifiablesortedset self
}
/**
* a convenience method for creating an immutable collection.
*
* @param self a collection
* @return an immutable collection
* @see java.util.collections#unmodifiablecollection(java.util.collection)
*/
public static collection asimmutable collection self
return collections unmodifiablecollection self
}
/**
* a convenience method for creating a synchronized map.
*
* @param self a map
* @return a synchronized map
* @see java.util.collections#synchronizedmap(java.util.map)
*/
public static map assynchronized map self
return collections synchronizedmap self
}
/**
* a convenience method for creating a synchronized sortedmap.
*
* @param self a sortedmap
* @return a synchronized sortedmap
* @see java.util.collections#synchronizedsortedmap(java.util.sortedmap)
*/
public static sortedmap assynchronized sortedmap self
return collections synchronizedsortedmap self
}
/**
* a convenience method for creating a synchronized collection.
*
* @param self a collection
* @return a synchronized collection
* @see java.util.collections#synchronizedcollection(java.util.collection)
*/
public static collection assynchronized collection self
return collections synchronizedcollection self
}
/**
* a convenience method for creating a synchronized list.
*
* @param self a list
* @return a synchronized list
* @see java.util.collections#synchronizedlist(java.util.list)
*/
public static list assynchronized list self
return collections synchronizedlist self
}
/**
* a convenience method for creating a synchronized set.
*
* @param self a set
* @return a synchronized set
* @see java.util.collections#synchronizedset(java.util.set)
*/
public static set assynchronized set self
return collections synchronizedset self
}
/**
* a convenience method for creating a synchronized sortedset.
*
* @param self a sortedset
* @return a synchronized sortedset
* @see java.util.collections#synchronizedsortedset(java.util.sortedset)
*/
public static sortedset assynchronized sortedset self
return collections synchronizedsortedset self
}
/**
* synonym for {@link #tospreadmap(map)}.
* @param self a map
* @return a newly created spreadmap
*/
public static spreadmap spread map self
return tospreadmap self
}
/**
* returns a new <code>spreadmap</code> from this map.
* <p/>
* for examples, if there is defined a function like as
* <blockquote><pre>
*     def fn(a, b, c, d) { return a + b + c + d }
* </pre></blockquote>, then all of the following three have the same meaning.
* <blockquote><pre>
*     println fn(a:1, [b:2, c:3].tospreadmap(), d:4)
*     println fn(a:1, *:[b:2, c:3], d:4)
*     println fn(a:1, b:2, c:3, d:4)
* </pre></blockquote>
* <p/>
*
* @param self a list to be converted into a spreadmap
* @return a newly created spreadmap if this list is not null and its size is positive.
* @see groovy.lang.spreadmap#spreadmap(java.util.map)
*/
public static spreadmap tospreadmap map self
if  self    null
throw new groovyruntimeexception
else
return new spreadmap self
}
/**
* creates a spreadable map from this array.
* @param self an object array
* @return a newly created spreadmap
* @see groovy.lang.spreadmap#spreadmap(java.lang.object[])
*/
public static spreadmap tospreadmap object self
if  self    null
throw new groovyruntimeexception
else if  self length % 2    0
throw new groovyruntimeexception
else
return new spreadmap self
}
/**
* sorts the given collection into a sorted list.  the collection items are
* assumed to be comparable.
*
* @param self the collection to be sorted
* @return the sorted collection as a list
*/
public static list sort collection self
list answer   aslist self
collections sort answer  new numberawarecomparator
return answer
}
/**
* sorts the given object array into sorted order.  the array items are
* assumed to be comparable.
*
* @param self the array to be sorted
* @return the sorted array
*/
public static object sort object self
arrays sort self  new numberawarecomparator
return self
}
/**
* sorts the given iterator items into a sorted iterator.  the items are
* assumed to be comparable.  the original iterator will become
* exhausted of elements after completing this method call. a new iterator
* is produced that traverses the items in sorted order.
*
* @param self the iterator to be sorted
* @return the sorted items as an iterator
*/
public static iterator sort iterator self
return sort tolist self   listiterator
}
/**
* sorts the given iterator items into a sorted iterator using
* the comparator.
*
* @param self       the iterator to be sorted
* @param comparator a comparator used for comparing items
* @return the sorted items as an iterator
*/
public static iterator sort iterator self  comparator comparator
return sort tolist self   comparator  listiterator
}
/**
* sorts the collection using the given comparator.  the elements are
* sorted into a new list, and the existing collection is unchanged.
*
* @param self       a collection to be sorted
* @param comparator a comparator used for the comparison
* @return a newly created sorted list
*/
public static list sort collection self  comparator comparator
list list   aslist self
collections sort list  comparator
return list
}
/**
* sorts the given object array into sorted order using the given comparator.
*
* @param self the array to be sorted
* @param comparator a comparator used for the comparison
* @return the sorted array
*/
public static object sort object self  comparator comparator
arrays sort self  comparator
return self
}
/**
* sorts the given iterator items into a sorted iterator using
* the closure as a comparator.
*
* @param self       the iterator to be sorted
* @param closure a closure used as a comparator
* @return the sorted items as an iterator
*/
public static iterator sort iterator self  closure closure
return sort tolist self   closure  listiterator
}
/**
* sorts the given object array into a newly created array using the given comparator.
*
* @param self the array to be sorted
* @param closure a closure used as a comparator
* @return the sorted array
*/
public static object sort object self  closure closure
return sort tolist self   closure  toarray
}
/**
* sorts this collection using the given closure as a comparator.  the
* closure is passed each item from the collection, and is assumed to
* return a comparable value (i.e. an int).
*
* @param self    a collection to be sorted
* @param closure a closure used as a comparator
* @return a newly created sorted list
*/
public static list sort collection self  closure closure
list list   aslist self
// use a comparator of one item or two
int params   closure getmaximumnumberofparameters
if  params    1
collections sort list  new orderby closure
} else {
collections sort list  new closurecomparator closure
}
return list
}
/**
* avoids doing unnecessary work when sorting an already sorted set.
*
* @param self an identity function for an already sorted set
* @return the sorted set
*/
public static sortedset sort sortedset self
return self
}
/**
* removes the last item from the list. using add() and pop()
* is similar to push and pop on a stack.
*
* @param self a list
* @return the item removed from the list
* @throws nosuchelementexception if the list is empty and you try to pop() it.
*/
public static object pop list self
if  self isempty
throw new nosuchelementexception
}
return self remove self size     1
}
/**
* appends an item to the list. synonym for add().
*
* @param self a list
* @param value element to be appended to this list.
* @return <tt>true</tt> (as per the general contract of the
*            <tt>collection.add</tt> method).
* @throws nosuchelementexception if the list is empty and you try to pop() it.
*/
public static boolean push list self  object value
return self add value
}
/**
* returns the last item from the list.
*
* @param self a list
* @return the last item from the list
* @throws nosuchelementexception if the list is empty and you try to access the last() item.
*/
public static object last list self
if  self isempty
throw new nosuchelementexception
}
return self get self size     1
}
/**
* returns the first item from the list.
*
* @param self a list
* @return the first item from the list
* @throws nosuchelementexception if the list is empty and you try to access the first() item.
*/
public static object first list self
if  self isempty
throw new nosuchelementexception
}
return self get 0
}
/**
* returns the first item from the list.
*
* @param self a list
* @return the first item from the list
* @throws nosuchelementexception if the list is empty and you try to access the head() item.
*/
public static object head list self
return first self
}
/**
* returns the items from the list excluding the first item.
*
* @param self a list
* @return a list without its first element
* @throws nosuchelementexception if the list is empty and you try to access the tail() item.
*/
public static list tail list self
if  self isempty
throw new nosuchelementexception
}
list result   new arraylist self
result remove 0
return result
}
/**
* converts this collection to a list.
*
* @param self a collection to be converted into a list
* @return a newly created list if this collection is not already a list
*/
public static list aslist collection self
if  self instanceof list
return  list  self
} else {
return new arraylist self
}
}
/**
* converts the given collection to another type. a default concrete
* type is used for list, set, or sortedset. if the given type has
* a constructor taking a collection, that is used. otherwise, the
* call is deferred to {link #astype(object,class)}.  if this
* collection is already of the given type, the same instance is
* returned.
*
* @param col   a collection
* @param clazz the desired class
* @return the object resulting from this type conversion
* @see #astype(object,class)
*/
public static object astype collection col  class clazz
if  col getclass      clazz
return col
}
if  clazz    list class
return aslist col
}
if  clazz    set class
if  col instanceof set  return col
return new hashset col
}
if  clazz    sortedset class
if  col instanceof sortedset  return col
return new treeset col
}
if  clazz    queue class
if  col instanceof queue  return col
return new linkedlist col
}
if  clazz    stack class
if  col instanceof stack  return col
final stack stack   new stack
stack addall col
return stack
}
object args    col
try {
return invokerhelper invokeconstructorof clazz  args
catch  exception e
// ignore
}
return astype  object  col  clazz
}
/**
* converts the given array to either a list, set, or
* sortedset.  if the given class is something else, the
* call is deferred to {link #astype(object,class)}.
*
* @param ary   an array
* @param clazz the desired class
* @return the object resulting from this type conversion
* @see #astype(object,class)
*/
public static object astype object ary  class clazz
if  clazz    list class
return new arraylist arrays aslist ary
else if  clazz    set class
return new hashset arrays aslist ary
else if  clazz    sortedset class
return new treeset arrays aslist ary
}
return astype  object  ary  clazz
}
/**
* coerces the closure to an implementation of the given class.  the class
* is assumed to be an interface or class with a single method definition.
* the closure is used as the implementation of that single method.
*
* @param cl    the implementation of the single method
* @param clazz the target type
* @return a proxy of the given type which wraps this closure.
*/
public static object astype closure cl  class clazz
if  clazz isinterface        clazz isinstance cl
return proxy newproxyinstance
clazz getclassloader
new class clazz
new convertedclosure cl
}
return astype  object  cl  clazz
}
/**
* coerces this map to the given type, using the map's keys as the public
* method names, and values as the implementation.  typically the value
* would be a closure which behaves like the method implementation.
*
* @param map   this map
* @param clazz the target type
* @return a proxy of the given type, which defers calls to this map's elements.
*/
public static object astype map map  class clazz
if    clazz isinstance map      clazz isinterface
return proxy newproxyinstance
clazz getclassloader
new class clazz
new convertedmap map
}
try {
return astype  object  map  clazz
catch  groovycastexception ce
try {
return proxygenerator instance instantiateaggregatefrombaseclass map  clazz
catch  groovyruntimeexception cause
throw new groovycastexception     clazz getname
cause getmessage
}
}
}
/**
* reverses the list.  the result is a new list with the identical contents
* in reverse order.
*
* @param self a list
* @return a reversed list
*/
public static list reverse list self
int size   self size
list answer   new arraylist size
listiterator iter   self listiterator size
while  iter hasprevious
answer add iter previous
}
return answer
}
/**
* reverses the iterator. the original iterator will become
* exhausted of elements after determining the reversed values.
* a new iterator for iterating through the reversed values is returned.
*
* @param self an iterator
* @return a reversed iterator
*/
public static iterator reverse iterator self
return new reverselistiterator tolist self
}
/**
* create a collection as a union of two collections. if the left collection
* is a set, then the returned collection will be a set otherwise a list.
* this operation will always create a new object for the result,
* while the operands remain unchanged.
*
* @param left  the left collection
* @param right the right collection
* @return the merged collection
*/
public static collection plus collection left  collection right
final collection answer   clonesimilarcollection left  left size     right size
answer addall right
return answer
}
/**
* create a collection as a union of a collection and an object. if the collection
* is a set, then the returned collection will be a set otherwise a list.
* this operation will always create a new object for the result,
* while the operands remain unchanged.
*
* @param left  a collection
* @param right an object to add/append
* @return the resulting collection
*/
public static collection plus collection left  object right
final collection answer   clonesimilarcollection left  left size     1
answer add right
return answer
}
/**
* create a list composed of the elements of this list, repeated
* a certain number of times.  note that for non-primitive
* elements, multiple references to the same instance will be added.
*
* @param self   a collection
* @param factor the number of times to append
* @return the multiplied list
*/
public static list multiply collection self  number factor
int size   factor intvalue
list answer   new arraylist self size     size
for  int i   0  i < size  i
answer addall self
}
return answer
}
/**
* create a collection composed of the intersection of both collections.  any
* elements that exist in both collections are added to the resultant collection.
*
* @param left  a collection
* @param right a collection
* @return a collection as an intersection of both collections
*/
public static collection intersect collection left  collection right
if  left isempty
return createsimilarcollection left  0
if  left size   < right size
collection swaptemp   left
left   right
right   swaptemp
}
// todo optimise if same type?
// boolean nlgnsort = sametype(new collection[]{left, right});
collection result   createsimilarcollection left  left size
//creates the collection to look for values.
collection pickfrom   new treeset new numberawarecomparator
pickfrom addall left
for  iterator iter   right iterator    iter hasnext
final object o   iter next
if  pickfrom contains o
result add o
}
return result
}
/**
* returns <code>true</code> if the intersection of two collections is empty.
*
* @param left  a collection
* @param right a collection
* @return boolean   <code>true</code> if the intersection of two collections
*         is empty, <code>false</code> otherwise.
*/
public static boolean disjoint collection left  collection right
if  left isempty      right isempty
return true
collection pickfrom   new treeset new numberawarecomparator
pickfrom addall right
for  iterator iter   left iterator    iter hasnext
final object o   iter next
if  pickfrom contains o
return false;
}
return true
}
// default comparator for objects accounting for numbers of different types.
// also handles nulls. null is less than everything else.
private static class numberawarecomparator implements comparator
public int compare object o1  object o2
try {
return defaulttypetransformation compareto o1  o2
catch  classcastexception cce
catch  groovyruntimeexception gre
int x1   o1 hashcode
int x2   o2 hashcode
return  x1   x2
}
public boolean equals object obj
return this equals obj
}
}
/**
* compare the contents of this array to the contents of the given array.
*
* @param left an int array
* @param right the operand array.
* @return true if the contents of both arrays are equal.
*/
public static boolean equals int left  int right
if  left    null
return right    null
}
if  right    null
return false;
}
if  left length    right length
return false;
}
for  int i   0  i < left length  i
if  left    right  return false
}
return true
}
/**
* determines if the contents of this array are equal to the
* contents of the given list, in the same order.  this returns
* <code>false</code> if either collection is <code>null</code>.
*
* @param left  this array
* @param right the list being compared
* @return true if the contents of both collections are equal
*/
public static boolean equals object left  list right
return coercedequals left  right
}
/**
* determines if the contents of this list are equal to the
* contents of the given array in the same order.  this returns
* <code>false</code> if either collection is <code>null</code>.
*
* @param left  this list
* @param right this object[] being compared to
* @return true if the contents of both collections are equal
*/
public static boolean equals list left  object right
return coercedequals right  left
}
private static boolean coercedequals object left  list right
if  left    null
return right    null
}
if  right    null
return false;
}
if  left length    right size
return false;
}
final numberawarecomparator numberawarecomparator = new numberawarecomparator();
for  int i   left length   1  i >  0  i
final object o1   left
final object o2   right get i
if  o1    null
if  o2    null  return false
} else {
if (o1 instanceof number) {
if    o2 instanceof number    numberawarecomparator compare o1  o2     0
return false;
}
} else {
if   defaulttypetransformation compareequal o1  o2   return false
}
}
}
return true
}
/**
* compare the contents of two lists.  order matters.
* if numbers exist in the lists, then they are compared as numbers,
* for example 2 == 2l.  if either list is <code>null</code>, the result
* is <code>false</code>.
*
* @param left  this list
* @param right the list being compared to.
* @return boolean   <code>true</code> if the contents of both lists are identical,
*         <code>false</code> otherwise.
*/
public static boolean equals list left  list right
if  left    null
return right    null
}
if  right    null
return false;
}
if  left size      right size
return false;
}
final numberawarecomparator numberawarecomparator = new numberawarecomparator();
final iterator it1   left iterator    it2   right iterator
while (it1.hasnext()) {
final object o1 = it1.next();
final object o2 = it2.next();
if  o1    null
if  o2    null  return false
} else {
if (o1 instanceof number) {
if    o2 instanceof number    numberawarecomparator compare o1  o2     0
return false;
}
} else {
if   defaulttypetransformation compareequal o1  o2   return false
}
}
}
return true
}
/**
* compare the contents of two sets for equality using groovy's coercion rules.
* warning: may not be included in 1.1
* <p/>
* returns <tt>true</tt> if the two sets have the same size, and every member
* of the specified set is contained in this set (or equivalently, every member
* of this set is contained in the specified set).
* if numbers exist in the lists, then they are compared as numbers,
* for example 2 == 2l.  if either list is <code>null</code>, the result
* is <code>false</code>.
*
* @param self  this list
* @param other the list being compared to
* @return <tt>true</tt> if the contents of both lists are identical
*/
/*
public static boolean coercedequals(set self, set other) {
if (self == null) {
return other == null;
}
if (other == null) {
return false;
}
if (self.size() != other.size()) {
return false;
}
final numberawarecomparator numberawarecomparator = new numberawarecomparator();
final iterator it1 = self.iterator();
collection otheritems = new hashset(other);
while (it1.hasnext()) {
final object o1 = it1.next();
if (o1 == null && !other.contains(null)) return false;
final iterator it2 = otheritems.iterator();
object founditem = null;
while (it2.hasnext() && founditem == null) {
final object o2 = it2.next();
if (o1 instanceof number) {
if (o2 instanceof number && numberawarecomparator.compare(o1, o2) == 0) {
founditem = o2;
}
} else {
try {
if (defaulttypetransformation.compareequal(o1, o2)) {
founditem = o2;
}
} catch (classcastexception e) {
// ignore
}
}
}
if (founditem == null) return false;
otheritems.remove(founditem);
}
return otheritems.size() == 0;
}
*/
/**
* create a set composed of the elements of the first set minus the
* elements of the given collection.
* <p/>
* todo: remove using number comparator?
*
* @param self     a set object
* @param operands the items to remove from the set
* @return the resulting set
*/
public static set minus set self  collection operands
final set ansset   createsimilarset self
ansset addall self
if  self size   > 0
ansset removeall operands
}
return ansset
}
/**
* create a set composed of the elements of the first set minus the operand.
*
* @param self    a set object
* @param operand the operand to remove from the set
* @return the resulting set
*/
public static set minus set self  object operand
final set ansset   createsimilarset self
comparator numbercomparator   new numberawarecomparator
for  iterator it   self iterator    it hasnext
object o   it next
if  numbercomparator compare o  operand     0  ansset add o
}
return ansset
}
/**
* create an array composed of the elements of the first array minus the
* elements of the given collection.
*
* @param self     an object array
* @param removeme a collection of elements to remove
* @return an array with the supplied elements removed
*/
public static object minus object self  collection removeme
return minus tolist self   removeme  toarray
}
/**
* create an array composed of the elements of the first array minus the
* elements of the given array.
*
* @param self     an object array
* @param removeme an array of elements to remove
* @return an array with the supplied elements removed
*/
public static object minus object self  object removeme
return minus tolist self   tolist removeme   toarray
}
/**
* create a list composed of the elements of the first list minus the
* elements of the given collection.
*
* @param self     a list
* @param removeme a collection of elements to remove
* @return a list with the supplied elements removed
*/
public static list minus list self  collection removeme
if  self size      0
return new arraylist
boolean nlgnsort   sametype new collection self  removeme
// we can't use the same tactic as for intersection
// since abstractcollection only does a remove on the first
// element it encounters.
comparator numbercomparator   new numberawarecomparator
if  nlgnsort     self get 0  instanceof comparable
//n*log(n) version
set answer
if  number class isinstance self get 0
answer   new treeset numbercomparator
answer addall self
for  iterator it   self iterator    it hasnext
object o   it next
if  number class isinstance o
for  iterator it2   removeme iterator    it2 hasnext
object o2   it2 next
if  number class isinstance o2
if  numbercomparator compare o  o2     0
answer remove o
}
}
} else {
if  removeme contains o
answer remove o
}
}
} else {
answer   new treeset numbercomparator
answer addall self
answer removeall removeme
}
list anslist   new arraylist
for  iterator it   self iterator    it hasnext
object o   it next
if  answer contains o
anslist add o
}
return anslist
} else {
//n*n version
list tmpanswer   new linkedlist self
for  iterator iter   tmpanswer iterator    iter hasnext
object element   iter next
boolean elementremoved   false
for  iterator iterator   removeme iterator    iterator hasnext       elementremoved
object elt   iterator next
if  numbercomparator compare element  elt     0
iter remove
elementremoved   true
}
}
}
//remove duplicates
//can't use treeset since the base classes are different
return new arraylist tmpanswer
}
}
/**
* create a new list composed of the elements of the first list minus the
* operand.
*
* @param self    a list object
* @param operand an element to remove from the list
* @return the resulting list with the operand removed
*/
public static list minus list self  object operand
comparator numbercomparator   new numberawarecomparator
list anslist   new arraylist
for  iterator it   self iterator    it hasnext
object o   it next
if  numbercomparator compare o  operand     0  anslist add o
}
return anslist
}
/**
* create a new object array composed of the elements of the first array
* minus the operand.
*
* @param self    an object array
* @param operand an element to remove from the array
* @return a new array with the operand removed
*/
public static object minus object self  object operand
return minus tolist self   operand  toarray
}
/**
* flatten a list.  this collection and any nested collections have their
* contents (recursively) added to the new collection.
*
* @param self a list
* @return a flattened list
*/
public static list flatten list self
return new arraylist flatten self  new linkedlist
}
/**
* flatten a set.  this collection and any nested collections have their
* contents (recursively) added to the new collection.
*
* @param self a set
* @return a flattened set
*/
public static set flatten set self
return new hashset flatten self  new linkedlist
}
private static list flatten collection elements  list addto
iterator iter   elements iterator
while  iter hasnext
object element   iter next
if  element instanceof collection
flatten  collection  element  addto
else if  element instanceof map
flatten   map  element  values    addto
} else {
addto add element
}
}
return addto
}
/**
* overloads the left shift operator to provide an easy way to append
* objects to a collection.
*
* @param self  a collection
* @param value an object to be added to the collection.
* @return same collection, after the value was added to it.
*/
public static collection leftshift collection self  object value
self add value
return self
}
/**
* overloads the left shift operator to provide an easy way to append multiple
* objects as string representations to a string.
*
* @param self  a string
* @param value an obect
* @return a stringbuffer built from this string
*/
public static stringbuffer leftshift string self  object value
return new stringbuffer self  append value
}
protected static stringwriter createstringwriter string self
stringwriter answer   new stringwriter
answer write self
return answer
}
protected static stringbufferwriter createstringbufferwriter stringbuffer self
return new stringbufferwriter self
}
/**
* overloads the left shift operator to provide an easy way to append multiple
* objects as string representations to a stringbuffer.
*
* @param self  a stringbuffer
* @param value a value to append
* @return the stringbuffer on which this operation was invoked
*/
public static stringbuffer leftshift stringbuffer self  object value
self append value
return self
}
/**
* overloads the left shift operator to provide a mechanism to append
* values to a writer.
*
* @param self  a writer
* @param value a value to append
* @return the writer on which this operation was invoked
* @throws ioexception if an i/o error occurs.
*/
public static writer leftshift writer self  object value  throws ioexception
invokerhelper write self  value
return self
}
/**
* implementation of the left shift operator for integral types.  non integral
* number types throw unsupportedoperationexception.
*
* @param self    a number object
* @param operand the shift distance by which to left shift the number
* @return the resulting number
*/
public static number leftshift number self  number operand
return numbermath leftshift self  operand
}
/**
* implementation of the right shift operator for integral types.  non integral
* number types throw unsupportedoperationexception.
*
* @param self    a number object
* @param operand the shift distance by which to right shift the number
* @return the resulting number
*/
public static number rightshift number self  number operand
return numbermath rightshift self  operand
}
/**
* implementation of the right shift (unsigned) operator for integral types.  non integral
* number types throw unsupportedoperationexception.
*
* @param self    a number object
* @param operand the shift distance by which to right shift (unsigned) the number
* @return the resulting number
*/
public static number rightshiftunsigned number self  number operand
return numbermath rightshiftunsigned self  operand
}
/**
* a helper method so that dynamic dispatch of the writer.write(object) method
* will always use the more efficient writable.writeto(writer) mechanism if the
* object implements the writable interface.
*
* @param self     a writer
* @param writable an object implementing the writable interface
* @throws ioexception if an i/o error occurs.
*/
public static void write writer self  writable writable  throws ioexception
writable writeto self
}
/**
* overloads the leftshift operator to provide an append mechanism to add values to a stream.
*
* @param self  an outputstream
* @param value a value to append
* @return a writer
* @throws ioexception if an i/o error occurs.
*/
public static writer leftshift outputstream self  object value  throws ioexception
outputstreamwriter writer   new flushingstreamwriter self
leftshift writer  value
return writer
}
/**
* overloads the leftshift operator to add objects to an objectoutputstream.
*
* @param self  an objectoutputstream
* @param value an object to write to the stream
* @throws ioexception if an i/o error occurs.
* @since 1.1 beta 2
*/
public static void leftshift objectoutputstream self  object value  throws ioexception
self writeobject value
}
/**
* pipe an inputstream into an outputstream for efficient stream copying.
*
* @param self stream on which to write
* @param in   stream to read from
* @return the outputstream itself
* @throws ioexception if an i/o error occurs.
*/
public static outputstream leftshift outputstream self  inputstream in  throws ioexception
byte buf   new byte
while  true
int count   in read buf  0  buf length
if  count     1  break
if  count    0
thread yield
continue
}
self write buf  0  count
}
self flush
return self
}
/**
* overloads the leftshift operator to provide an append mechanism to add bytes to a stream.
*
* @param self  an outputstream
* @param value a value to append
* @return an outputstream
* @throws ioexception if an i/o error occurs.
*/
public static outputstream leftshift outputstream self  byte value  throws ioexception
self write value
self flush
return self
}
// primitive type array methods
//-------------------------------------------------------------------------
/**
* support the subscript operator with a range for a byte array
*
* @param array a byte array
* @param range a range indicating the indices for the items to retrieve
* @return list of the retrieved bytes
*/
public static object getat byte array  range range
return primitivearrayget array  range
}
/**
* support the subscript operator with a range for a char array
*
* @param array a char array
* @param range a range indicating the indices for the items to retrieve
* @return list of the retrieved chars
*/
public static object getat char array  range range
return primitivearrayget array  range
}
/**
* support the subscript operator with a range for a short array
*
* @param array a short array
* @param range a range indicating the indices for the items to retrieve
* @return list of the retrieved shorts
*/
public static object getat short array  range range
return primitivearrayget array  range
}
/**
* support the subscript operator with a range for an int array
*
* @param array an int array
* @param range a range indicating the indices for the items to retrieve
* @return list of the ints at the given indices
*/
public static object getat int array  range range
return primitivearrayget array  range
}
/**
* support the subscript operator with a range for a long array
*
* @param array a long array
* @param range a range indicating the indices for the items to retrieve
* @return list of the retrieved longs
*/
public static object getat long array  range range
return primitivearrayget array  range
}
/**
* support the subscript operator with a range for a float array
*
* @param array a float array
* @param range a range indicating the indices for the items to retrieve
* @return list of the retrieved floats
*/
public static object getat float array  range range
return primitivearrayget array  range
}
/**
* support the subscript operator with a range for a double array
*
* @param array a double array
* @param range a range indicating the indices for the items to retrieve
* @return list of the retrieved doubles
*/
public static object getat double array  range range
return primitivearrayget array  range
}
/**
* support the subscript operator with a range for a boolean array
*
* @param array a boolean array
* @param range a range indicating the indices for the items to retrieve
* @return list of the retrieved booleans
*/
public static object getat boolean array  range range
return primitivearrayget array  range
}
/**
* support the subscript operator with an intrange for a byte array
*
* @param array a byte array
* @param range an intrange indicating the indices for the items to retrieve
* @return list of the retrieved bytes
*/
public static object getat byte array  intrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an intrange for a char array
*
* @param array a char array
* @param range an intrange indicating the indices for the items to retrieve
* @return list of the retrieved chars
*/
public static object getat char array  intrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an intrange for a short array
*
* @param array a short array
* @param range an intrange indicating the indices for the items to retrieve
* @return list of the retrieved shorts
*/
public static object getat short array  intrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an intrange for an int array
*
* @param array an int array
* @param range an intrange indicating the indices for the items to retrieve
* @return list of the retrieved ints
*/
public static object getat int array  intrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an intrange for a long array
*
* @param array a long array
* @param range an intrange indicating the indices for the items to retrieve
* @return list of the retrieved longs
*/
public static object getat long array  intrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an intrange for a float array
*
* @param array a float array
* @param range an intrange indicating the indices for the items to retrieve
* @return list of the retrieved floats
*/
public static object getat float array  intrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an intrange for a double array
*
* @param array a double array
* @param range an intrange indicating the indices for the items to retrieve
* @return list of the retrieved doubles
*/
public static object getat double array  intrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an intrange for a boolean array
*
* @param array a boolean array
* @param range an intrange indicating the indices for the items to retrieve
* @return list of the retrieved booleans
*/
public static object getat boolean array  intrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an objectrange for a byte array
*
* @param array a byte array
* @param range an objectrange indicating the indices for the items to retrieve
* @return list of the retrieved bytes
*/
public static object getat byte array  objectrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an objectrange for a char array
*
* @param array a char array
* @param range an objectrange indicating the indices for the items to retrieve
* @return list of the retrieved chars
*/
public static object getat char array  objectrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an objectrange for a short array
*
* @param array a short array
* @param range an objectrange indicating the indices for the items to retrieve
* @return list of the retrieved shorts
*/
public static object getat short array  objectrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an objectrange for an int array
*
* @param array an int array
* @param range an objectrange indicating the indices for the items to retrieve
* @return list of the retrieved ints
*/
public static object getat int array  objectrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an objectrange for a long array
*
* @param array a long array
* @param range an objectrange indicating the indices for the items to retrieve
* @return list of the retrieved longs
*/
public static object getat long array  objectrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an objectrange for a float array
*
* @param array a float array
* @param range an objectrange indicating the indices for the items to retrieve
* @return list of the retrieved floats
*/
public static object getat float array  objectrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an objectrange for a double array
*
* @param array a double array
* @param range an objectrange indicating the indices for the items to retrieve
* @return list of the retrieved doubles
*/
public static object getat double array  objectrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with an objectrange for a byte array
*
* @param array a byte array
* @param range an objectrange indicating the indices for the items to retrieve
* @return list of the retrieved bytes
*/
public static object getat boolean array  objectrange range
return primitivearrayget array  range
}
/**
* support the subscript operator with a collection for a byte array
*
* @param array a byte array
* @param indices a collection of indices for the items to retrieve
* @return list of the bytes at the given indices
*/
public static object getat byte array  collection indices
return primitivearrayget array  indices
}
/**
* support the subscript operator with a collection for a char array
*
* @param array a char array
* @param indices a collection of indices for the items to retrieve
* @return list of the chars at the given indices
*/
public static object getat char array  collection indices
return primitivearrayget array  indices
}
/**
* support the subscript operator with a collection for a short array
*
* @param array a short array
* @param indices a collection of indices for the items to retrieve
* @return list of the shorts at the given indices
*/
public static object getat short array  collection indices
return primitivearrayget array  indices
}
/**
* support the subscript operator with a collection for an int array
*
* @param array an int array
* @param indices a collection of indices for the items to retrieve
* @return list of the ints at the given indices
*/
public static object getat int array  collection indices
return primitivearrayget array  indices
}
/**
* support the subscript operator with a collection for a long array
*
* @param array a long array
* @param indices a collection of indices for the items to retrieve
* @return list of the longs at the given indices
*/
public static object getat long array  collection indices
return primitivearrayget array  indices
}
/**
* support the subscript operator with a collection for a float array
*
* @param array a float array
* @param indices a collection of indices for the items to retrieve
* @return list of the floats at the given indices
*/
public static object getat float array  collection indices
return primitivearrayget array  indices
}
/**
* support the subscript operator with a collection for a double array
*
* @param array a double array
* @param indices a collection of indices for the items to retrieve
* @return list of the doubles at the given indices
*/
public static object getat double array  collection indices
return primitivearrayget array  indices
}
/**
* support the subscript operator with a collection for a boolean array
*
* @param array a boolean array
* @param indices a collection of indices for the items to retrieve
* @return list of the booleans at the given indices
*/
public static object getat boolean array  collection indices
return primitivearrayget array  indices
}
/**
* support the subscript operator for a bitset
*
* @param self  a bitset
* @param index index to retrieve
* @return value of the bit at the given index
* @see java.util.bitset
*/
public static boolean getat bitset self  int index
return self get index
}
/**
* support retrieving a subset of a bitset using a range
*
* @param self  a bitset
* @param range a range defining the desired subset
* @return a new bitset that represents the requested subset
* @see java.util.bitset
* @see groovy.lang.intrange
*/
public static bitset getat bitset self  intrange range
int from   defaulttypetransformation intunbox range getfrom
int to   defaulttypetransformation intunbox range getto
bitset result   new bitset
int numberofbits   to   from   1
int adjuster   1
int offset   from
if  range isreverse
adjuster    1
offset   to
}
for  int i   0  i < numberofbits  i
result set i  self get offset    adjuster   i
}
return result
}
//    public static boolean putat(boolean[] array, int idx, boolean newvalue) {
//        return (boolean) primitivearrayput(array, idx, newvalue);
//    }
//
//    public static byte putat(byte[] array, int idx, object newvalue) {
//        if (!(newvalue instanceof byte)) {
//            number n = (number) newvalue;
//            newvalue = new byte(n.bytevalue());
//        }
//        return (byte) primitivearrayput(array, idx, newvalue);
//    }
//
//    public static character putat(char[] array, int idx, object newvalue) {
//        if (newvalue instanceof string) {
//            string s = (string) newvalue;
//            if (s.length() != 1) throw new illegalargumentexception("string of length 1 expected but got a bigger one");
//            char c = s.charat(0);
//            newvalue = new character(c);
//        }
//        return (character) primitivearrayput(array, idx, newvalue);
//    }
//
//    public static short putat(short[] array, int idx, object newvalue) {
//        if (!(newvalue instanceof short)) {
//            number n = (number) newvalue;
//            newvalue = new short(n.shortvalue());
//        }
//        return (short) primitivearrayput(array, idx, newvalue);
//    }
//
//    public static integer putat(int[] array, int idx, object newvalue) {
//        if (!(newvalue instanceof integer)) {
//            number n = (number) newvalue;
//            newvalue = integer.valueof(n.intvalue());
//        }
//        array [normaliseindex(idx,array.length)] = ((integer)newvalue).intvalue();
//        return (integer) newvalue;
//    }
//
//    public static long putat(long[] array, int idx, object newvalue) {
//        if (!(newvalue instanceof long)) {
//            number n = (number) newvalue;
//            newvalue = new long(n.longvalue());
//        }
//        return (long) primitivearrayput(array, idx, newvalue);
//    }
//
//    public static float putat(float[] array, int idx, object newvalue) {
//        if (!(newvalue instanceof float)) {
//            number n = (number) newvalue;
//            newvalue = new float(n.floatvalue());
//        }
//        return (float) primitivearrayput(array, idx, newvalue);
//    }
//
//    public static double putat(double[] array, int idx, object newvalue) {
//        if (!(newvalue instanceof double)) {
//            number n = (number) newvalue;
//            newvalue = new double(n.doublevalue());
//        }
//        return (double) primitivearrayput(array, idx, newvalue);
//    }
/**
* support assigning a range of values with a single assignment statement.
*
* @param self  a bitset
* @param range the range of values to set
* @param value value
* @see java.util.bitset
* @see groovy.lang.range
*/
public static void putat bitset self  intrange range  boolean value
int from   defaulttypetransformation intunbox range getfrom
int to   defaulttypetransformation intunbox range getto
// if this is a backwards range, reverse the arguments to set.
if  from > to
int tmp   to
to   from
from   tmp
}
self set from  to   1  value
}
/**
* support subscript-style assignment for a bitset.
*
* @param self  a bitset
* @param index index of the entry to set
* @param value value
* @see java.util.bitset
*/
public static void putat bitset self  int index  boolean value
self set index  value
}
/**
* allows arrays to behave similar to collections.
* @param array a boolean array
* @return the length of the array
* @see array#getlength(object)
*/
public static int size boolean array
return array getlength array
}
/**
* allows arrays to behave similar to collections.
* @param array a byte array
* @return the length of the array
* @see array#getlength(object)
*/
public static int size byte array
return array getlength array
}
/**
* allows arrays to behave similar to collections.
* @param array a char array
* @return the length of the array
* @see array#getlength(object)
*/
public static int size char array
return array getlength array
}
/**
* allows arrays to behave similar to collections.
* @param array a short array
* @return the length of the array
* @see array#getlength(object)
*/
public static int size short array
return array getlength array
}
/**
* allows arrays to behave similar to collections.
* @param array an int array
* @return the length of the array
* @see array#getlength(object)
*/
public static int size int array
return array getlength array
}
/**
* allows arrays to behave similar to collections.
* @param array a long array
* @return the length of the array
* @see array#getlength(object)
*/
public static int size long array
return array getlength array
}
/**
* allows arrays to behave similar to collections.
* @param array a float array
* @return the length of the array
* @see array#getlength(object)
*/
public static int size float array
return array getlength array
}
/**
* allows arrays to behave similar to collections.
* @param array a double array
* @return the length of the array
* @see array#getlength(object)
*/
public static int size double array
return array getlength array
}
/**
* converts this array to a list of the same size, with each element
* added to the list.
*
* @param array an array
* @return a list containing the contents of this array.
*/
public static list tolist byte array
return defaulttypetransformation primitivearraytolist array
}
/**
* converts this array to a list of the same size, with each element
* added to the list.
*
* @param array an array
* @return a list containing the contents of this array.
*/
public static list tolist char array
return defaulttypetransformation primitivearraytolist array
}
/**
* converts this array to a list of the same size, with each element
* added to the list.
*
* @param array an array
* @return a list containing the contents of this array.
*/
public static list tolist short array
return defaulttypetransformation primitivearraytolist array
}
/**
* converts this array to a list of the same size, with each element
* added to the list.
*
* @param array an array
* @return a list containing the contents of this array.
*/
public static list tolist int array
return defaulttypetransformation primitivearraytolist array
}
/**
* converts this array to a list of the same size, with each element
* added to the list.
*
* @param array an array
* @return a list containing the contents of this array.
*/
public static list tolist long array
return defaulttypetransformation primitivearraytolist array
}
/**
* converts this array to a list of the same size, with each element
* added to the list.
*
* @param array an array
* @return a list containing the contents of this array.
*/
public static list tolist float array
return defaulttypetransformation primitivearraytolist array
}
/**
* converts this array to a list of the same size, with each element
* added to the list.
*
* @param array an array
* @return a list containing the contents of this array.
*/
public static list tolist double array
return defaulttypetransformation primitivearraytolist array
}
private static final char t_table     tochararray
public static writable encodebase64 byte data
return encodebase64 defaulttypetransformation converttobytearray data
}
/**
* produce a writable object which writes the base64 encoding of the byte array.
* calling tostring() on the result rerurns the encoding as a string
*
* @param data byte array to be encoded
* @return object which will write the base64 encoding of the byte array
*/
public static writable encodebase64 final byte data
return new writable
public writer writeto final writer writer  throws ioexception
int charcount   0
final int dlimit    data length   3    3
for  int dindex   0  dindex    dlimit  dindex    3
int d     data   0xff  << 16      data   0xff  << 8     data   0xff
writer write t_table
writer write t_table
writer write t_table
writer write t_table
if    charcount    18
writer write
charcount   0
}
}
if  dlimit    data length
int d    data   0xff  << 16
if  dlimit   1    data length
d     data   0xff  << 8
}
writer write t_table
writer write t_table
writer write  dlimit   1 < data length  ? t_table
writer write
}
return writer
}
public string tostring
stringwriter buffer   new stringwriter
try {
writeto buffer
catch  ioexception e
throw new stringwriterioexception e
}
return buffer tostring
}
}
private static final byte translate_table
//
//                    \t    \n                \r
//
//
//        sp    !     "     #     $     %     &     '
//         (    )     *     +     ,     -     .     /
//         0    1     2     3     4     5     6     7
//         8    9     :     ;     <     =     >     ?
//         @    a     b     c     d     e     f     g
//         h    i   j k   l     m   n   o
//         p    q     r     s     t     u     v    w
//         x    y     z     [     \     ]     ^    _
//         '    a     b     c     d     e     f     g
//        h   i   j     k     l     m     n     o    p
u0023 u0024 u0025 u0026 u0027 u0028"
//        p     q     r     s     t     u     v     w
//        x     y     z
getbytes
/**
* decode the sting from base64 into a byte array.
*
* @param value the string to be decoded
* @return the decoded bytes as an array
*/
public static byte decodebase64 string value
int byteshift   4
int tmp   0
boolean done   false
final stringbuffer buffer   new stringbuffer
for  int i   0  i    value length    i
final char c   value charat i
final int sixbit    c < 123  ? translate_table   66
if  sixbit < 64
if  done
throw new runtimeexception        todo  change this exception type
tmp    tmp << 6    sixbit
if  byteshift      4
buffer append  char    tmp >>  byteshift   2     0xff
}
else if  sixbit    64
byteshift
done   true
else if  sixbit    66
// rfc 2045 says that i'm allowed to take the presence of
// these characters as evedence of data corruption
// so i will
throw new runtimeexception        todo  change this exception type
}
if  byteshift    0  byteshift   4
}
try {
return buffer tostring   getbytes
catch  unsupportedencodingexception e
throw new runtimeexception        todo  change this exception type
}
}
/**
* implements the getat(int) method for primitve type arrays.
*
* @param self an array object
* @param idx  the index of interest
* @return the returned value from the array
*/
protected static object primitivearrayget object self  int idx
return array get self  normaliseindex idx  array getlength self
}
/**
* implements the getat(range) method for primitve type arrays.
*
* @param self  an array object
* @param range the range of indices of interest
* @return the returned values from the array corresponding to the range
*/
protected static list primitivearrayget object self  range range
list answer   new arraylist
for  iterator iter   range iterator    iter hasnext
int idx   defaulttypetransformation intunbox iter next
answer add primitivearrayget self  idx
}
return answer
}
/**
* implements the getat(collection) method for primitve type arrays.  each
* value in the collection argument is assumed to be a valid array index.
* the value at each index is then added to a list which is returned.
*
* @param self    an array object
* @param indices the indices of interest
* @return the returned values from the array
*/
protected static list primitivearrayget object self  collection indices
list answer   new arraylist
for  iterator iter   indices iterator    iter hasnext
object value   iter next
if  value instanceof range
answer addall primitivearrayget self   range  value
else if  value instanceof list
answer addall primitivearrayget self   list  value
} else {
int idx   defaulttypetransformation intunbox value
answer add primitivearrayget self  idx
}
}
return answer
}
/**
* implements the setat(int idx) method for primitve type arrays.
*
* @param self     an object
* @param idx      the index of interest
* @param newvalue the new value to be put into the index of interest
* @return the added value
*/
protected static object primitivearrayput object self  int idx  object newvalue
array set self  normaliseindex idx  array getlength self    newvalue
return newvalue
}
// string methods
//-------------------------------------------------------------------------
/**
* converts the given string into a character object
* using the first character in the string.
*
* @param self a string
* @return the first character
*/
public static character tocharacter string self
/** @todo use cache? */
return new character self charat 0
}
/**
* converts the given string into a boolean object.
* if the trimmed string is "true", "y" or "1" (ignoring case)
* then the result is true othewrwise it is false.
*
* @param self a string
* @return the boolean value
*/
public static boolean toboolean string self
final string trimmed   self trim
if    equalsignorecase trimmed       equalsignorecase trimmed       equals trimmed
return boolean true
} else {
return boolean false
}
}
/**
* convenience method to split a string (with whitespace as delimiter)
* like tokenize, but returns an array of strings instead of a list
*
* @param self the string to split
* @return string[] result of split
*/
public static string split string self
stringtokenizer st   new stringtokenizer self
string strings   new string
for  int i   0  i < strings length  i
strings   st nexttoken
}
return strings
}
/**
* tokenize a string based on the given string delimiter.
*
* @param self  a string
* @param token the delimiter
* @return a list of tokens
* @see java.util.stringtokenizer#stringtokenizer(java.lang.string, java.lang.string)
*/
public static list tokenize string self  string token
return invokerhelper aslist new stringtokenizer self  token
}
/**
* tokenize a string (with a whitespace as the delimiter).
*
* @param self a string
* @return a list of tokens
* @see stringtokenizer#stringtokenizer(java.lang.string)
*/
public static list tokenize string self
return invokerhelper aslist new stringtokenizer self
}
/**
* appends the string representation of the given operand to this string.
*
* @param left  a string
* @param value any object
* @return the new string with the object appended
*/
public static string plus string left  object value
return left   tostring value
}
/**
* appends a string to the string representation of this number.
*
* @param value a number
* @param right a string
* @return a string
*/
public static string plus number value  string right
return tostring value    right
}
/**
* appends a string to this stringbuffer.
*
* @param left  a stringbuffer
* @param value a string
* @return a string
*/
public static string plus stringbuffer left  string value
return left   value
}
/**
* remove a part of a string. this replaces the first occurrence
* of target within self with '' and returns the result. if
* target is a regex pattern, the first occurrence of that
* pattern will be removed (using regex matching), otherwise
* the first occurrence of target.tostring() will be removed.
*
* @param self   a string
* @param target an object representing the part to remove
* @return a string minus the part to be removed
*/
public static string minus string self  object target
if  target instanceof pattern
return   pattern target  matcher self  replacefirst
}
string text   tostring target
int index   self indexof text
if  index     1  return self
int end   index   text length
if  self length   > end
return self substring 0  index    self substring end
}
return self substring 0  index
}
/**
* provide an implementation of contains() like
* {@link collection#contains(object)} to make strings more polymorphic.
* this method is not required on jdk 1.5 onwards
*
* @param self a string
* @param text a string to look for
* @return true if this string contains the given text
*/
public static boolean contains string self  string text
int idx   self indexof text
return idx >  0
}
/**
* count the number of occurencies of a substring.
*
* @param self a string
* @param text a substring
* @return the number of occurrencies of the given string inside this string
*/
public static int count string self  string text
int answer   0
for  int idx   0  true  idx
idx   self indexof text  idx
if  idx >  0
answer
} else {
break
}
}
return answer
}
/**
* this method is called by the ++ operator for the class string.
* it increments the last character in the given string. if the
* character in the string is character.max_value a character.min_value
* will be appended. the empty string is incremented to a string
* consisting of the character character.min_value.
*
* @param self a string
* @return an incremented string
*/
public static string next string self
stringbuffer buffer   new stringbuffer self
if  buffer length      0
buffer append character min_value
} else {
char last   buffer charat buffer length     1
if  last    character max_value
buffer append character min_value
} else {
char next   last
next
buffer setcharat buffer length     1  next
}
}
return buffer tostring
}
/**
* this method is called by the -- operator for the class string.
* it decrements the last character in the given string. if the
* character in the string is character.min_value it will be deleted.
* the empty string can't be decremented.
*
* @param self a string
* @return a string with a decremented digit at the end
*/
public static string previous string self
stringbuffer buffer   new stringbuffer self
if  buffer length      0  throw new illegalargumentexception
char last   buffer charat buffer length     1
if  last    character min_value
buffer deletecharat buffer length     1
} else {
char next   last
next
buffer setcharat buffer length     1  next
}
return buffer tostring
}
/**
* executes the given string as a command line process. for more control
* over the process mechanism in jdk 1.5 you can use java.lang.processbuilder.
*
* @param self a command line string
* @return the process which has just started for this command line string
* @throws ioexception if an ioexception occurs.
*/
public static process execute string self  throws ioexception
return runtime getruntime   exec self
}
/**
* executes the command specified by the <code>string</code> array that is the parameter.
* the first item in the array is the command the others are the parameters. for more
* control over the process mechanism in jdk 1.5 you can use
* <code>java.lang.processbuilder</code>.
*
* @param commandarray an array of <code>string<code> containing the command name and
*                     parameters as separate items in the array.
* @return the process which has just started for this command line string.
* @throws ioexception if an ioexception occurs.
*/
public static process execute string commandarray  throws ioexception
return runtime getruntime   exec commandarray
}
/**
* executes the command specified by the <code>self</code> with environments <code>envp</code>
* under the working directory <code>dir</code>.
* for more control over the process mechanism in jdk 1.5 you can use <code>java.lang.processbuilder</code>.
*
* @param self a command line string to be executed.
* @param envp an array of strings, each element of which
*             has environment variable settings in the format
*             <i>name</i>=<i>value</i>, or
*             <tt>null</tt> if the subprocess should inherit
*             the environment of the current process.
* @param dir  the working directory of the subprocess, or
*             <tt>null</tt> if the subprocess should inherit
*             the working directory of the current process.
* @return the process which has just started for this command line string.
* @throws ioexception if an ioexception occurs.
*/
public static process execute string self  final string envp  file dir  throws ioexception
return runtime getruntime   exec self  envp  dir
}
/**
* executes the command specified by the <code>string</code> list that is the parameter.
* the first item in the array is the command the others are the parameters. all entries
* must be <code>string</code>s.  for more control over the process mechanism in jdk 1.5 you
* can use <code>java.lang.processbuilder</code>.
*
* @param commandlist a list of <code>string<code> containing the command name and
*                    parameters as separate items in the list.
* @return the process which has just started for this command line string.
* @throws ioexception if an ioexception occurs.
*/
public static process execute list commandlist  throws ioexception
final string commandarray   new string
iterator it   commandlist iterator
for  int i   0  it hasnext      i
commandarray   it next   tostring
}
return execute commandarray
}
/**
* executes the command specified by the <code>self</code> with environments <code>envp</code>
* under the working directory <code>dir</code>.
* for more control over the process mechanism in jdk 1.5 you can use <code>java.lang.processbuilder</code>.
*
* @param self a command line string to be executed.
* @param envp a list of strings, each member of which
*             has environment variable settings in the format
*             <i>name</i>=<i>value</i>, or
*             <tt>null</tt> if the subprocess should inherit
*             the environment of the current process.
* @param dir  the working directory of the subprocess, or
*             <tt>null</tt> if the subprocess should inherit
*             the working directory of the current process.
* @return the process which has just started for this command line string.
* @throws ioexception if an ioexception occurs.
*/
public static process execute string self  list envp  file dir  throws ioexception
if  envp    null
return execute self   string  null  dir
}
string commandarray   new string
iterator it   envp iterator
for  int i   0  it hasnext      i
commandarray   it next   tostring
}
return execute self  commandarray  dir
}
/**
* repeat a string a certain number of times.
*
* @param self   a string to be repeated
* @param factor the number of times the string should be repeated
* @return a string composed of a repetition
* @throws illegalargumentexception if the number of repeatition is &lt; 0
*/
public static string multiply string self  number factor
int size   factor intvalue
if  size    0
return
else if  size < 0
throw new illegalargumentexception     size
}
stringbuffer answer   new stringbuffer self
for  int i   1  i < size  i
answer append self
}
return answer tostring
}
/**
* returns the string representation of the given map.
*
* @param self a map
* @return the string representation
* @see #tomapstring(map)
*/
public static string tostring map self
return tomapstring self
}
/**
* returns the string representation of this map.  the string displays the
* contents of the map, i.e. <code>{one=1, two=2, three=3}</code>.
*
* @param self a map
* @return the string representation
*/
public static string tomapstring map self
return  self    null  ?     invokerhelper tomapstring self
}
/**
* returns the string representation of the given collection.  the string
* displays the contents of the collection, i.e.
* <code>[1, 2, a]</code>.
*
* @param self a collection
* @return the string representation
* @see #toliststring(collection)
*/
public static string tostring collection self
return toliststring self
}
/**
* returns the string representation of the given list.  the string
* displays the contents of the list, similar to a list literal, i.e.
* <code>[1, 2, a]</code>.
*
* @param self a collection
* @return the string representation
*/
public static string toliststring collection self
return  self    null  ?     invokerhelper toliststring self
}
/**
* returns the string representation of this array's contents.
*
* @param self an object[]
* @return the string representation
* @see #toarraystring(object[])
*/
public static string tostring object self
return toarraystring self
}
/**
* returns the string representation of the given array.  the string
* displays the contents of the array, similar to an array literal, i.e.
* <code>{1, 2, "a"}</code>.
*
* @param self an object[]
* @return the string representation
*/
public static string toarraystring object self
return  self    null  ?     invokerhelper toarraystring self
}
/**
* create a string representation of this object.
* @param value an object
* @return a string.
*/
protected static string tostring object value
if  value instanceof map
return tomapstring  map  value
else if  value instanceof collection
return toliststring  collection  value
else if  value instanceof object
return toarraystring  object  value
else
return invokerhelper tostring value
}
// number based methods
//-------------------------------------------------------------------------
/**
* increment a character by one.
*
* @param self a character
* @return an incremented number
*/
public static number next character self
return plus self  one
}
/**
* increment a number by one.
*
* @param self a number
* @return an incremented number
*/
public static number next number self
return numbernumberplus plus self  one
}
/**
* decrement a character by one.
*
* @param self a character
* @return a decremented number
*/
public static number previous character self
return minus self  one
}
/**
* decrement a number by one.
*
* @param self a number
* @return a decremented number
*/
public static number previous number self
return numbernumberminus minus self  one
}
/**
* add a character and a number.
* this operation will always create a new object for the result,
* while the operands remain unchanged.
*
* @param left  a character
* @param right a number
* @return the addition of the character and the number
*/
public static number plus character left  number right
return numbernumberplus plus integer valueof left charvalue     right
}
/**
* add a number and a character.
*
* @param left  a number
* @param right a character
* @return the addition of the character and the number
*/
public static number plus number left  character right
return numbernumberplus plus left  integer valueof right charvalue
}
/**
* add two characters.
* this operation will always create a new object for the result,
* while the operands remain unchanged.
*
* @param left  a character
* @param right a character
* @return the addition of both characters
*/
public static number plus character left  character right
return plus integer valueof left charvalue     right
}
/**
* compare a character and a number.
*
* @param left  a character
* @param right a number
* @return the result of the comparison
*/
public static int compareto character left  number right
return compareto integer valueof left charvalue     right
}
/**
* compare a number and a character.
*
* @param left  a number
* @param right a character
* @return the result of the comparison
*/
public static int compareto number left  character right
return compareto left  integer valueof right charvalue
}
/**
* compare two characters.
*
* @param left  a character
* @param right a character
* @return the result of the comparison
*/
public static int compareto character left  character right
return compareto integer valueof left charvalue     right
}
/**
* compare two numbers.  equality (==) for numbers dispatches to this.
*
* @param left  a number
* @param right another number to compare to
* @return the comparision of both numbers
*/
public static int compareto number left  number right
/** @todo maybe a double dispatch thing to handle new large numbers? */
return numbermath compareto left  right
}
/**
* subtract a number from a character.
*
* @param left  a character
* @param right a number
* @return the addition of the character and the number
*/
public static number minus character left  number right
return numbernumberminus minus integer valueof left charvalue     right
}
/**
* subtract a character from a number.
*
* @param left  a number
* @param right a character
* @return the addition of the character and the number
*/
public static number minus number left  character right
return numbernumberminus minus left  integer valueof right charvalue
}
/**
* subtraction two characters.
*
* @param left  a character
* @param right a character
* @return the addition of both characters
*/
public static number minus character left  character right
return minus integer valueof left charvalue     right
}
/**
* multiply a character by a number.
*
* @param left  a character
* @param right a number
* @return the multiplication of both
*/
public static number multiply character left  number right
return numbernumbermultiply multiply integer valueof left charvalue     right
}
/**
* multiply a number by a character.
*
* @param left  a number
* @param right a character
* @return the multiplication of both
*/
public static number multiply number left  character right
return numbernumbermultiply multiply left  integer valueof right charvalue
}
/**
* multiply two characters.
*
* @param left  a character
* @param right another character
* @return the multiplication of both
*/
public static number multiply character left  character right
return multiply integer valueof left charvalue     right
}
/**
* multiply a bigdecimal and a double.
* note: this method was added to enforce the groovy rule of
* bigdecimal*double == double. without this method, the
* multiply(bigdecimal) method in bigdecimal would respond
* and return a bigdecimal instead. since bigdecimal is prefered
* over number, the number*number method is not choosen as in older
* versions of groovy.
*
* @param left  a bigdecimal
* @param right a double
* @return the multiplication of both
*/
public static number multiply bigdecimal left  double right
return numbermath multiply left  right
}
/**
* multiply a bigdecimal and a biginteger.
* note: this method was added to enforce the groovy rule of
* bigdecimal*long == long. without this method, the
* multiply(bigdecimal) method in bigdecimal would respond
* and return a bigdecimal instead. since bigdecimal is prefered
* over number, the number*number method is not choosen as in older
* versions of groovy. biginteger is the fallback for all integer
* types in groovy
*
* @param left  a bigdecimal
* @param right a biginteger
* @return the multiplication of both
*/
public static number multiply bigdecimal left  biginteger right
return numbermath multiply left  right
}
/**
* power of a number to a certain exponent.  called by the '**' operator.
*
* @param self     a number
* @param exponent a number exponent
* @return a number to the power of a certain exponent
*/
public static number power number self  number exponent
double base  exp  answer
base   self doublevalue
exp   exponent doublevalue
answer   math pow base  exp
if   double    int  answer     answer
return integer valueof  int  answer
else if   double    long  answer     answer
return new long  long  answer
} else {
return new double answer
}
}
/**
* divide a character by a number.
*
* @param left  a character
* @param right a number
* @return the multiplication of both
*/
public static number div character left  number right
return numbernumberdiv div integer valueof left charvalue     right
}
/**
* divide a number by a character.
*
* @param left  a number
* @param right a character
* @return the multiplication of both
*/
public static number div number left  character right
return numbernumberdiv div left  integer valueof right charvalue
}
/**
* divide two characters.
*
* @param left  a character
* @param right another character
* @return the multiplication of both
*/
public static number div character left  character right
return div integer valueof left charvalue     right
}
/**
* integer divide a character by a number.
*
* @param left  a character
* @param right a number
* @return the integer division of both
*/
public static number intdiv character left  number right
return intdiv integer valueof left charvalue     right
}
/**
* integer divide a number by a character.
*
* @param left  a number
* @param right a character
* @return the integer division of both
*/
public static number intdiv number left  character right
return intdiv left  integer valueof right charvalue
}
/**
* integer divide two characters.
*
* @param left  a character
* @param right another character
* @return the integer division of both
*/
public static number intdiv character left  character right
return intdiv integer valueof left charvalue     right
}
/**
* integer divide two numbers.
*
* @param left  a number
* @param right another number
* @return a number (an integer) resulting of the integer division operation
*/
public static number intdiv number left  number right
return numbermath intdiv left  right
}
/**
* bitwise or together two numbers.
*
* @param left  a number
* @param right another number to bitwise or
* @return the bitwise or of both numbers
*/
public static number or number left  number right
return numbermath or left  right
}
/**
* bitwise and together two numbers.
*
* @param left  a number
* @param right another number to bitwise and
* @return the bitwise and of both numbers
*/
public static number and number left  number right
return numbermath and left  right
}
/**
* bitwise and together two bitsets.
*
* @param left  a bitset
* @param right another bitset to bitwise and
* @return the bitwise and of both bitsets
*/
public static bitset and bitset left  bitset right
bitset result    bitset  left clone
result and right
return result
}
/**
* bitwise xor together two bitsets.  called when the '^' operator is used
* between two bit sets.
*
* @param left  a bitset
* @param right another bitset to bitwise and
* @return the bitwise xor of both bitsets
*/
public static bitset xor bitset left  bitset right
bitset result    bitset  left clone
result xor right
return result
}
/**
* bitwise negate a bitset.
*
* @param self a bitset
* @return the bitwise negate of the bitset
*/
public static bitset bitwisenegate bitset self
bitset result    bitset  self clone
result flip 0  result size     1
return result
}
/**
* bitwise or together two bitsets.  called when the '|' operator is used
* between two bit sets.
*
* @param left  a bitset
* @param right another bitset to bitwise and
* @return the bitwise or of both bitsets
*/
public static bitset or bitset left  bitset right
bitset result    bitset  left clone
result or right
return result
}
/**
* bitwise xor together two numbers.  called when the '|' operator is used.
*
* @param left  a number
* @param right another number to bitwse xor
* @return the bitwise xor of both numbers
*/
public static number xor number left  number right
return numbermath xor left  right
}
/**
* performs a division modulus operation.  called by the '%' operator.
*
* @param left  a number
* @param right another number to mod
* @return the modulus result
*/
public static number mod number left  number right
return numbermath mod left  right
}
/**
* negates the number.  equivalent to the '-' operator when it preceeds
* a single operand, i.e. <code>-10</code>
*
* @param left a number
* @return the negation of the number
*/
public static number unaryminus number left
return numbermath unaryminus left
}
/**
* executes the closure this many times, starting from zero.  the current
* index is passed to the closure each time.
* example:
* <pre>10.times {
*   println it
* }</pre>
* prints the numbers 0 through 9.
*
* @param self    a number
* @param closure the closure to call a number of times
*/
public static void times number self  closure closure
for  int i   0  size   self intvalue    i < size  i
closure call integer valueof i
if  closure getdirective      closure done
break
}
}
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.
*
* @param self    a number
* @param to      another number to go up to
* @param closure the closure to call
*/
public static void upto number self  number to  closure closure
int self1   self intvalue
int to1   to intvalue
if  self1 <  to1
for  int i   self1  i <  to1  i
closure call integer valueof i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.
*
* @param self    a long
* @param to the end number
* @param closure the code to execute for each number
*/
public static void upto long self  number to  closure closure
long to1   to longvalue
if  self <  to1
for  long i   self  i <  to1  i
closure call new long i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.
*
* @param self    a long
* @param to the end number
* @param closure the code to execute for each number
*/
public static void upto long self  number to  closure closure
long self1   self longvalue
long to1   to longvalue
if  self1 <  to1
for  long i   self1  i <  to1  i
closure call new long i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.
*
* @param self    a float
* @param to the end number
* @param closure the code to execute for each number
*/
public static void upto float self  number to  closure closure
float to1   to floatvalue
if  self <  to1
for  float i   self  i <  to1  i
closure call new float i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.
*
* @param self    a float
* @param to the end number
* @param closure the code to execute for each number
*/
public static void upto float self  number to  closure closure
float self1   self floatvalue
float to1   to floatvalue
if  self1 <  to1
for  float i   self1  i <  to1  i
closure call new float i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.
*
* @param self    a double
* @param to the end number
* @param closure the code to execute for each number
*/
public static void upto double self  number to  closure closure
double to1   to doublevalue
if  self <  to1
for  double i   self  i <  to1  i
closure call new double i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.
*
* @param self    a double
* @param to the end number
* @param closure the code to execute for each number
*/
public static void upto double self  number to  closure closure
double self1   self doublevalue
double to1   to doublevalue
if  self1 <  to1
for  double i   self1  i <  to1  i
closure call new double i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.  example:
* <pre>0.upto( 10 ) {
*   println it
* }</pre>
* prints numbers 0 to 10
*
* @param self    a biginteger
* @param to the end number
* @param closure the code to execute for each number
*/
public static void upto biginteger self  number to  closure closure
if  to instanceof bigdecimal
final bigdecimal one   new bigdecimal
bigdecimal self1   new bigdecimal self
bigdecimal to1    bigdecimal  to
if  self1 compareto to1  <  0
for  bigdecimal i   self1  i compareto to1  <  0  i   i add one
closure call i
}
else
throw new groovyruntimeexception     self       to
else if  to instanceof biginteger
final biginteger one   new biginteger
biginteger to1    biginteger  to
if  self compareto to1  <  0
for  biginteger i   self  i compareto to1  <  0  i   i add one
closure call i
}
else
throw new groovyruntimeexception     self       to
} else {
final biginteger one   new biginteger
biginteger to1   new biginteger     to
if  self compareto to1  <  0
for  biginteger i   self  i compareto to1  <  0  i   i add one
closure call i
}
else
throw new groovyruntimeexception     self       to
}
}
/**
* iterates from this number up to the given number, inclusive,
* incrementing by one each time.
* <pre>0.upto( 10 ) {
*   println it
* }</pre>
* prints numbers 0.1, 1.1, 2.1... to 9.1
*
* @param self    a bigdecimal
* @param to the end number
* @param closure the code to execute for each number
*/
public static void upto bigdecimal self  number to  closure closure
final bigdecimal one   new bigdecimal
if  to instanceof bigdecimal
bigdecimal to1    bigdecimal  to
if  self compareto to1  <  0
for  bigdecimal i   self  i compareto to1  <  0  i   i add one
closure call i
}
else
throw new groovyruntimeexception     self       to
else if  to instanceof biginteger
bigdecimal to1   new bigdecimal  biginteger  to
if  self compareto to1  <  0
for  bigdecimal i   self  i compareto to1  <  0  i   i add one
closure call i
}
else
throw new groovyruntimeexception     self       to
} else {
bigdecimal to1   new bigdecimal     to
if  self compareto to1  <  0
for  bigdecimal i   self  i compareto to1  <  0  i   i add one
closure call i
}
else
throw new groovyruntimeexception     self       to
}
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.
*
* @param self    a number
* @param to      another number to go down to
* @param closure the closure to call
*/
public static void downto number self  number to  closure closure
int self1   self intvalue
int to1   to intvalue
if  self1 >  to1
for  int i   self1  i >  to1  i
closure call integer valueof i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.
*
* @param self    a long
* @param to the end number
* @param closure the code to execute for each number
*/
public static void downto long self  number to  closure closure
long to1   to longvalue
if  self >  to1
for  long i   self  i >  to1  i
closure call new long i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.
*
* @param self    a long
* @param to the end number
* @param closure the code to execute for each number
*/
public static void downto long self  number to  closure closure
long self1   self longvalue
long to1   to longvalue
if  self1 >  to1
for  long i   self1  i >  to1  i
closure call new long i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.
*
* @param self    a float
* @param to the end number
* @param closure the code to execute for each number
*/
public static void downto float self  number to  closure closure
float to1   to floatvalue
if  self >  to1
for  float i   self  i >  to1  i
closure call new float i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.
*
* @param self    a float
* @param to the end number
* @param closure the code to execute for each number
*/
public static void downto float self  number to  closure closure
float self1   self floatvalue
float to1   to floatvalue
if  self1 >  to1
for  float i   self1  i >  to1  i
closure call new float i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.
*
* @param self    a double
* @param to the end number
* @param closure the code to execute for each number
*/
public static void downto double self  number to  closure closure
double to1   to doublevalue
if  self >  to1
for  double i   self  i >  to1  i
closure call new double i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.
*
* @param self    a double
* @param to the end number
* @param closure the code to execute for each number
*/
public static void downto double self  number to  closure closure
double self1   self doublevalue
double to1   to doublevalue
if  self1 >  to1
for  double i   self1  i >  to1  i
closure call new double i
}
else
throw new groovyruntimeexception     self       to
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.
*
* @param self    a biginteger
* @param to the end number
* @param closure the code to execute for each number
*/
public static void downto biginteger self  number to  closure closure
if  to instanceof bigdecimal
final bigdecimal one   new bigdecimal
final bigdecimal to1    bigdecimal  to
final bigdecimal selfd   new bigdecimal self
if  selfd compareto to1  >  0
for  bigdecimal i   selfd  i compareto to1  >  0  i   i subtract one
closure call i tobiginteger
}
else
throw new groovyruntimeexception     self       to
else if  to instanceof biginteger
final biginteger one   new biginteger
final biginteger to1    biginteger  to
if  self compareto to1  >  0
for  biginteger i   self  i compareto to1  >  0  i   i subtract one
closure call i
}
else
throw new groovyruntimeexception     self       to
} else {
final biginteger one   new biginteger
final biginteger to1   new biginteger     to
if  self compareto to1  >  0
for  biginteger i   self  i compareto to1  >  0  i   i subtract one
closure call i
}
else
throw new groovyruntimeexception     self       to
}
}
/**
* iterates from this number down to the given number, inclusive,
* decrementing by one each time.  each number is passed to the closure.
* example:
* <pre>10.5.downto(0) {
*   println it
* }</pre>
* prints numbers 10.5, 9.5 ... to 0.5.
*
* @param self    a bigdecimal
* @param to the end number
* @param closure the code to execute for each number
*/
public static void downto bigdecimal self  number to  closure closure
final bigdecimal one   new bigdecimal
if  to instanceof bigdecimal
bigdecimal to1    bigdecimal  to
if  self compareto to1  >  0
for  bigdecimal i   self  i compareto to1  >  0  i   i subtract one
closure call i
}
else
throw new groovyruntimeexception     self       to
else if  to instanceof biginteger
bigdecimal to1   new bigdecimal  biginteger  to
if  self compareto to1  >  0
for  bigdecimal i   self  i compareto to1  >  0  i   i subtract one
closure call i
}
else
throw new groovyruntimeexception     self       to
} else {
bigdecimal to1   new bigdecimal     to
if  self compareto to1  >  0
for  bigdecimal i   self  i compareto to1  >  0  i   i subtract one
closure call i
}
else
throw new groovyruntimeexception     self       to
}
}
/**
* iterates from this number up to the given number using a step increment.
* each intermediate number is passed to the given closure.  example:
* <pre>0.step( 10, 2 ) {
*   println it
* }</pre>
* prints even numbers 0 through 8.
*
* @param self       a number to start with
* @param to         a number to go up to, exclusive
* @param stepnumber a number representing the step increment
* @param closure    the closure to call
*/
public static void step number self  number to  number stepnumber  closure closure
if  self instanceof bigdecimal    to instanceof bigdecimal    stepnumber instanceof bigdecimal
final bigdecimal zero   new bigdecimal
bigdecimal self1    self instanceof bigdecimal  ?  bigdecimal  self   new bigdecimal     self
bigdecimal to1    to instanceof bigdecimal  ?  bigdecimal  to   new bigdecimal     to
bigdecimal stepnumber1    stepnumber instanceof bigdecimal  ?  bigdecimal  stepnumber   new bigdecimal     stepnumber
if  stepnumber1 compareto zero  > 0    to1 compareto self1  > 0
for  bigdecimal i   self1  i compareto to1  < 0  i   i add stepnumber1
closure call i
}
else if  stepnumber1 compareto zero  < 0    to1 compareto self1  < 0
for  bigdecimal i   self1  i compareto to1  > 0  i   i add stepnumber1
closure call i
}
else
throw new groovyruntimeexception     self1       to1       stepnumber1
else if  self instanceof biginteger    to instanceof biginteger    stepnumber instanceof biginteger
final biginteger zero   new biginteger
biginteger self1    self instanceof biginteger  ?  biginteger  self   new biginteger     self
biginteger to1    to instanceof biginteger  ?  biginteger  to   new biginteger     to
biginteger stepnumber1    stepnumber instanceof biginteger  ?  biginteger  stepnumber   new biginteger     stepnumber
if  stepnumber1 compareto zero  > 0    to1 compareto self1  > 0
for  biginteger i   self1  i compareto to1  < 0  i   i add stepnumber1
closure call i
}
else if  stepnumber1 compareto zero  < 0    to1 compareto self1  < 0
for  biginteger i   self1  i compareto to1  > 0  i   i add stepnumber1
closure call i
}
else
throw new groovyruntimeexception     self1       to1       stepnumber1
} else {
int self1   self intvalue
int to1   to intvalue
int stepnumber1   stepnumber intvalue
if  stepnumber1 > 0    to1 > self1
for  int i   self1  i < to1  i    stepnumber1
closure call integer valueof i
}
else if  stepnumber1 < 0    to1 < self1
for  int i   self1  i > to1  i    stepnumber1
closure call integer valueof i
}
else
throw new groovyruntimeexception     self1       to1       stepnumber1
}
}
/**
* get the absolute value
*
* @param number a number
* @return the absolute value of that number
*/
//note:  this method is not called if number is a biginteger or bigdecimal because
//those classes implement a method with a better exact match.
public static int abs number number
return math abs number intvalue
}
/**
* get the absolute value
*
* @param number a long
* @return the absolute value of that long
*/
public static long abs long number
return math abs number longvalue
}
/**
* get the absolute value
*
* @param number a float
* @return the absolute value of that float
*/
public static float abs float number
return math abs number floatvalue
}
/**
* get the absolute value
*
* @param number a double
* @return the absolute value of that double
*/
public static double abs double number
return math abs number doublevalue
}
/**
* get the absolute value
*
* @param number a float
* @return the absolute value of that float
*/
public static int round float number
return math round number floatvalue
}
/**
* round the value
*
* @param number a double
* @return the absolute value of that double
*/
public static long round double number
return math round number doublevalue
}
/**
* parse a string into an integer
*
* @param self a string
* @return an integer
*/
public static integer tointeger string self
return integer valueof self trim
}
/**
* parse a string into a long
*
* @param self a string
* @return a long
*/
public static long tolong string self
return long valueof self trim
}
/**
* parse a string into a float
*
* @param self a string
* @return a float
*/
public static float tofloat string self
return float valueof self trim
}
/**
* parse a string into a double
*
* @param self a string
* @return a double
*/
public static double todouble string self
return double valueof self trim
}
/**
* parse a string into a biginteger
*
* @param self a string
* @return a biginteger
*/
public static biginteger tobiginteger string self
return new biginteger self trim
}
/**
* parse a string into a bigdecimal
*
* @param self a string
* @return a bigdecimal
*/
public static bigdecimal tobigdecimal string self
return new bigdecimal self trim
}
/**
* determine if a string can be parsed into an integer.
*
* @param self a string
* @return true if the string can be parsed
*/
public static boolean isinteger string self
try {
integer valueof self trim
return true
catch  numberformatexception nfe
return false;
}
}
/**
* determine if a string can be parsed into a long.
*
* @param self a string
* @return true if the string can be parsed
*/
public static boolean islong string self
try {
long valueof self trim
return true
catch  numberformatexception nfe
return false;
}
}
/**
* determine if a string can be parsed into a float.
*
* @param self a string
* @return true if the string can be parsed
*/
public static boolean isfloat string self
try {
float valueof self trim
return true
catch  numberformatexception nfe
return false;
}
}
/**
* determine if a string can be parsed into a double.
*
* @param self a string
* @return true if the string can be parsed
*/
public static boolean isdouble string self
try {
double valueof self trim
return true
catch  numberformatexception nfe
return false;
}
}
/**
* determine if a string can be parsed into a biginteger.
*
* @param self a string
* @return true if the string can be parsed
*/
public static boolean isbiginteger string self
try {
new biginteger self trim
return true
catch  numberformatexception nfe
return false;
}
}
/**
* determine if a string can be parsed into a bigdecimal.
*
* @param self a string
* @return true if the string can be parsed
*/
public static boolean isbigdecimal string self
try {
new bigdecimal self trim
return true
catch  numberformatexception nfe
return false;
}
}
/**
* determine if a string can be parsed into a number.
* synonym for 'isbigdecimal()'.
*
* @param self a string
* @return true if the string can be parsed
* @see #isbigdecimal(string)
*/
public static boolean isnumber string self
return isbigdecimal self
}
/**
* transform a number into an integer
*
* @param self a number
* @return an integer
*/
public static integer tointeger number self
return integer valueof self intvalue
}
/**
* transform a number into a long
*
* @param self a number
* @return an long
*/
public static long tolong number self
return new long self longvalue
}
/**
* transform a number into a float
*
* @param self a number
* @return an float
*/
public static float tofloat number self
return new float self floatvalue
}
/**
* transform a number into a double
*
* @param self a number
* @return an double
*/
public static double todouble number self
return new double self doublevalue
}
/**
* transform a number into a bigdecimal
*
* @param self a number
* @return an bigdecimal
*/
public static bigdecimal tobigdecimal number self
return new bigdecimal self doublevalue
}
/**
* transform this number to a the given type, using the 'as' operator.  the
* following types are supported in addition to the default
* {@link #astype(object,class)}:
* <ul>
*  <li>bigdecimal</li>
*  <li>biginteger</li>
*  <li>double</li>
*  <li>float</li>
* </ul>
* @param self this number
* @param c the desired type of the transformed result
* @return an instance of the given type
*/
public static object astype number self  class c
if  c    bigdecimal class
return tobigdecimal self
else if  c    biginteger class
return tobiginteger self
else if  c    double class
return todouble self
else if  c    float class
return tofloat self
}
return astype  object  self  c
}
/**
* transform this number into a biginteger.
*
* @param self a number
* @return an biginteger
*/
public static biginteger tobiginteger number self
return new biginteger long tostring self longvalue
}
// date methods
//-------------------------------------------------------------------------
/**
* increment a date by one day.
*
* @param self a date
* @return the next days date
*/
public static date next date self
return plus self  1
}
/**
* increment a java.sql.date by one day.
*
* @param self a java.sql.date
* @return the next days date
*/
public static java sql date next java sql date self
return new java sql date next  date  self  gettime
}
/**
* decrement a date by one day.
*
* @param self a date
* @return the previous days date
*/
public static date previous date self
return minus self  1
}
/**
* decrement a java.sql.date by one day.
*
* @param self a java.sql.date
* @return the previous days date
*/
public static java sql date previous java sql date self
return new java sql date previous  date  self  gettime
}
/**
* add a number of days to this date and returns the new date.
*
* @param self a date
* @param days the number of days to increase
* @return the new date
*/
public static date plus date self  int days
calendar calendar    calendar  calendar getinstance   clone
calendar settime self
calendar add calendar day_of_year  days
return calendar gettime
}
/**
* add a number of days to this date and returns the new date.
*
* @param self a java.sql.date
* @param days the number of days to increase
* @return the new date
*/
public static java sql date plus java sql date self  int days
return new java sql date plus  date  self  days  gettime
}
/**
* subtract a number of days from this date and returns the new date.
*
* @param self a date
* @param days the number of days to subtract
* @return the new date
*/
public static date minus date self  int days
return plus self   days
}
/**
* subtract a number of days from this date and returns the new date.
*
* @param self a java.sql.date
* @param days the number of days to subtract
* @return the new date
*/
public static java sql date minus java sql date self  int days
return new java sql date minus  date  self  days  gettime
}
// boolean based methods
//-------------------------------------------------------------------------
public static boolean and boolean left  boolean right
return boolean valueof left booleanvalue      right booleanvalue
}
public static boolean or boolean left  boolean right
return boolean valueof left booleanvalue      right booleanvalue
}
public static boolean xor boolean left  boolean right
return boolean valueof left booleanvalue   ^ right booleanvalue
}
//    public static boolean negate(boolean left) {
//        return boolean.valueof(!left.booleanvalue());
//    }
// file and stream based methods
//-------------------------------------------------------------------------
/**
* create an object input stream for this file.
*
* @param file a file
* @return an object input stream
* @throws ioexception if an ioexception occurs.
*/
public static objectinputstream newobjectinputstream file file  throws ioexception
return new objectinputstream new fileinputstream file
}
/**
* create an object output stream for this file.
*
* @param file a file
* @return an object output stream
* @throws ioexception if an ioexception occurs.
*/
public static objectoutputstream newobjectoutputstream file file  throws ioexception
return new objectoutputstream new fileoutputstream file
}
/**
* iterates through the given file object by object.
*
* @param self    a file
* @param closure a closure
* @throws ioexception            if an ioexception occurs.
* @throws classnotfoundexception if the class  is not found.
* @see #eachobject(objectinputstream,closure)
*/
public static void eachobject file self  closure closure  throws ioexception  classnotfoundexception
eachobject newobjectinputstream self   closure
}
/**
* iterates through the given object stream object by object. the
* objectinputstream is closed afterwards.
*
* @param ois     an objectinputstream, closed after the operation
* @param closure a closure
* @throws ioexception            if an ioexception occurs.
* @throws classnotfoundexception if the class  is not found.
*/
public static void eachobject objectinputstream ois  closure closure  throws ioexception  classnotfoundexception
try {
while  true
try {
object obj   ois readobject
// we allow null objects in the object stream
closure call obj
catch  eofexception e
break
}
}
inputstream temp   ois
ois   null
temp close
finally
if  ois    null
try {
ois close
}
catch (exception e) {
// ignore this exception since there
// has to be another already
log warning     e
}
}
}
}
/**
* create a new objectinputstream for this file and pass it to the closure.
* this method ensures the stream is closed after the closure returns.
*
* @param file    a file
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withstream(inputstream,closure)
*/
public static object withobjectinputstream file file  closure closure  throws ioexception
return withstream newobjectinputstream file   closure
}
/**
* create a new objectoutputstream for this file and then pass it to the
* closure.  this method ensures the stream is closed after the closure
* returns.
*
* @param file    a file
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withstream(outputstream,closure)
*/
public static object withobjectoutputstream file file  closure closure  throws ioexception
return withstream newobjectoutputstream file   closure
}
/**
* iterates through this file line by line.  each line is passed
* to the given closure.  the file reader is closed before this method
* returns.
*
* @param self    a file
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @return the last value returned by the closure
* @see #eachline(reader,closure)
*/
public static object eachline file self  closure closure  throws ioexception
return eachline newreader self   closure
}
/**
* iterates through this string line by line.  each line is passed
* to the given closure.
*
* @param self    a string
* @param closure a closure
* @return the self object
*/
public static object eachline string self  closure closure
each readlines self   closure
return self
}
/**
* iterates through this stream reading with the provided charset, passing each line to the closure.  the
* stream is closed after the closure returns.
*
* @param stream  a stream
* @param charset opens the stream with a specified charset
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @return the last value returned by the closure
* @see #eachline(reader,closure)
*/
public static object eachline inputstream stream  string charset  closure closure  throws ioexception
return eachline new inputstreamreader stream  charset   closure
}
/**
* iterates through this stream, passing each line to the closure.  the
* stream is closed after the closure returns.
*
* @param stream  a stream
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @return the last value returned by the closure
* @see #eachline(reader,closure)
*/
public static object eachline inputstream stream  closure closure  throws ioexception
return eachline new inputstreamreader stream   closure
}
/**
* iterates through the lines read from the url's associated input stream
*
* @param url     a url to open and read
* @param closure a closure to apply on each line
* @return the last value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object eachline url url  closure closure  throws ioexception
return eachline url openconnection   getinputstream    closure
}
/**
* iterates through the lines read from the url's associated input stream
*
* @param url     a url to open and read
* @param charset opens the stream with a specified charset
* @param closure a closure to apply on each line
* @return the last value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object eachline url url  string charset  closure closure  throws ioexception
return eachline new inputstreamreader url openconnection   getinputstream    charset   closure
}
/**
* iterates through the given reader line by line.  each line is passed
* to the given closure.  the reader is closed before this method returns.
*
* @param self    a reader, closed after the method returns
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @return the last value returned by the closure
*/
public static object eachline reader self  closure closure  throws ioexception
bufferedreader br
int count   0
object result   null
if  self instanceof bufferedreader
br    bufferedreader  self
else
br   new bufferedreader self
try {
while  true
string line   br readline
if  line    null
break
} else {
count
result   callclosureforline closure  line  count
}
}
reader temp   self
self   null
temp close
return result
finally
closereaderwithwarning self
closereaderwithwarning br
}
}
/**
* iterates through this file line by line, splitting on the seperator.
* the list of tokens for each line is then passed to the given closure.
*
* @param self    a file
* @param sep     a string separator
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @return the last value returned by the closure
* @see #spliteachline(reader,string,closure)
*/
public static object spliteachline file self  string sep  closure closure  throws ioexception
return spliteachline newreader self   sep  closure
}
/**
* iterates through the given reader line by line, splitting each line using
* the given separator.  the list of tokens for each line is then passed to
* the given closure.  the reader is closed afterwards.
*
* @param self    a reader, closed after the method returns
* @param sep     a string separator
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @return the last value returned by the closure
* @see string#split(string)
*/
public static object spliteachline reader self  string sep  closure closure  throws ioexception
bufferedreader br      null
object result   null
if  self instanceof bufferedreader
br    bufferedreader  self
else
br   new bufferedreader self
try {
while  true
string line   br readline
if  line    null
break
} else {
list vals   arrays aslist line split sep
result   closure call vals
}
}
reader temp   self
self   null
temp close
return result
finally
closereaderwithwarning self
closereaderwithwarning br
}
}
/**
* iterates through the given inputstream line by line using the specified
* encoding, splitting each line using the given separator.  the list of tokens
* for each line is then passed to the given closure.
*
* @param stream  an inputstream
* @param sep     a string separator
* @param charset opens the stream with a specified charset
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @return the last value returned by the closure
* @see #spliteachline(reader,string,closure)
*/
public static object spliteachline inputstream stream  string sep  string charset  closure closure  throws ioexception
return spliteachline new bufferedreader new inputstreamreader stream  charset    sep  closure
}
/**
* iterates through the given inputstream line by line, splitting each line using
* the given separator.  the list of tokens for each line is then passed to
* the given closure.
*
* @param stream  an inputstream
* @param sep     a string separator
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @return the last value returned by the closure
* @see #spliteachline(reader,string,closure)
*/
public static object spliteachline inputstream stream  string sep  closure closure  throws ioexception
return spliteachline new bufferedreader new inputstreamreader stream    sep  closure
}
/**
* iterates through the given string line by line, splitting each line using
* the given separator.  the list of tokens for each line is then passed to
* the given closure.
*
* @param self    a string
* @param sep     a string separator
* @param closure a closure
* @return the last value returned by the closure
* @see string#split(string)
*/
public static object spliteachline string self  string sep  closure closure
final list list   readlines self
object result   null
for  int i   0  i < list size    i
string line    string  list get i
list vals   arrays aslist line split sep
result   closure call vals
}
return result
}
/**
* read a single, whole line from the given reader.
*
* @param self a reader
* @return a line
* @throws ioexception if an ioexception occurs.
*/
public static string readline reader self  throws ioexception
if  self instanceof bufferedreader
bufferedreader br    bufferedreader  self
return br readline
}
if  self marksupported
return readlinefromreaderwithmark self
}
return readlinefromreaderwithoutmark self
}
private static int charbuffersize   4096         half the default stream buffer size
private static int expectedlinelength   160      double the default line length
private static int eof    1                      end of file
/*
* this method tries to read subsequent buffers from the reader using a mark
*/
private static string readlinefromreaderwithmark final reader input
throws ioexception
char cbuf   new char
try {
input mark charbuffersize
catch  ioexception e
// this should never happen
log warning     e
// fallback
return readlinefromreaderwithoutmark input
}
// could be changed into do..while, but then
// we might create an additional stringbuffer
// instance at the end of the stream
int count   input read cbuf
if  count    eof     we are at the end of the input data
return null
stringbuffer line   new stringbuffer expectedlinelength
// now work on the buffer(s)
int ls   lineseparatorindex cbuf  count
while  ls     1
line append cbuf  0  count
count   input read cbuf
if  count    eof
// we are at the end of the input data
return line tostring
}
ls   lineseparatorindex cbuf  count
}
line append cbuf  0  ls
// correct ls if we have \r\n
int skipls   1
if  ls   1 < count
// we are not at the end of the buffer
if  cbuf         cbuf
skipls
}
} else {
if  cbuf         input read
skipls
}
}
//reset() and skip over last linesep
input reset
input skip line length     skipls
return line tostring
}
/*
* this method reads without a buffer.
* it returns too many empty lines if \r\n combinations
* are used. nothing can be done because we can't push
* back the character we have just read.
*/
private static string readlinefromreaderwithoutmark reader input
throws ioexception
int c   input read
if  c     1
return null
stringbuffer line   new stringbuffer expectedlinelength
while  c    eof    c         c
char ch    char  c
line append ch
c   input read
}
return line tostring
}
/*
* searches for \n or \r
* returns -1 if not found.
*/
private static int lineseparatorindex char array  int length
for  int k   0  k < length  k
if  islineseparator array
return k
}
}
return  1
}
/*
* true if either \n or \r
*/
private static boolean islineseparator char c
return c         c
}
/**
* just throws a deprecationexception.  do not use.  it used to read a single, whole line from the given inputstream.
*
* @param stream an inputstream
* @return a line
* @throws ioexception if an ioexception occurs.
* @deprecated use reader#readline instead please
*/
public static string readline inputstream stream  throws ioexception
throw new deprecationexception
}
/**
* return the lines of a string as a list of strings.
*
* @param self a string object
* @return a list of lines
*/
public static list readlines string self
return tokenize self
}
/**
* reads the file into a list of strings, with one item for each line.
*
* @param file a file
* @return a list of lines
* @throws ioexception if an ioexception occurs.
*/
public static list readlines file file  throws ioexception
iteratorclosureadapter closure   new iteratorclosureadapter file
eachline file  closure
return closure aslist
}
/**
* read the content of the file using the specified encoding and return it
* as a string.
*
* @param file    the file whose content we want to read
* @param charset the charset used to read the content of the file
* @return a string containing the content of the file
* @throws ioexception if an ioexception occurs.
*/
public static string gettext file file  string charset  throws ioexception
bufferedreader reader   newreader file  charset
return gettext reader
}
/**
* read the content of the file and returns it as a string.
*
* @param file the file whose content we want to read
* @return a string containing the content of the file
* @throws ioexception if an ioexception occurs.
*/
public static string gettext file file  throws ioexception
bufferedreader reader   newreader file
return gettext reader
}
/**
* read the content of this url and returns it as a string.
*
* @param url url to read content from
* @return the text from that url
* @throws ioexception if an ioexception occurs.
*/
public static string gettext url url  throws ioexception
return gettext url  charsettoolkit getdefaultsystemcharset   tostring
}
/**
* read the data from this url and return it as a string.  the connection
* stream is closed before this method returns.
*
* @param url     url to read content from
* @param charset opens the stream with a specified charset
* @return the text from that url
* @throws ioexception if an ioexception occurs.
* @see urlconnection#getinputstream()
*/
public static string gettext url url  string charset  throws ioexception
bufferedreader reader   new bufferedreader new inputstreamreader url openconnection   getinputstream    charset
return gettext reader
}
/**
* read the content of this inputstream and return it as a string.
* the stream is closed before this method returns.
*
* @param is an input stream
* @return the text from that url
* @throws ioexception if an ioexception occurs.
*/
public static string gettext inputstream is  throws ioexception
bufferedreader reader   new bufferedreader new inputstreamreader is
return gettext reader
}
/**
* read the content of this inputstream using specified charset and return
* it as a string.  the stream is closed before this method returns.
*
* @param is      an input stream
* @param charset opens the stream with a specified charset
* @return the text from that url
* @throws ioexception if an ioexception occurs.
*/
public static string gettext inputstream is  string charset  throws ioexception
bufferedreader reader   new bufferedreader new inputstreamreader is  charset
return gettext reader
}
/**
* read the content of the reader and return it as a string.  the reader
* is closed before this method returns.
*
* @param reader a reader whose content we want to read
* @return a string containing the content of the buffered reader
* @throws ioexception if an ioexception occurs.
* @see #gettext(bufferedreader)
*/
public static string gettext reader reader  throws ioexception
bufferedreader bufferedreader   new bufferedreader reader
return gettext bufferedreader
}
/**
* read the content of the bufferedreader and return it as a string.
* the bufferedreader is closed afterwards.
*
* @param reader a bufferedreader whose content we want to read
* @return a string containing the content of the buffered reader
* @throws ioexception if an ioexception occurs.
*/
public static string gettext bufferedreader reader  throws ioexception
stringbuffer answer   new stringbuffer
// reading the content of the file within a char buffer
// allow to keep the correct line endings
char charbuffer   new char
int nbcharread      0
try {
while   nbcharread   reader read charbuffer       1
// appends buffer
answer append charbuffer  0  nbcharread
}
reader temp   reader
reader   null
temp close
finally
closereaderwithwarning reader
}
return answer tostring
}
/**
* write the text and append a newline (using the platform's line-ending).
*
* @param writer a bufferedwriter
* @param line   the line to write
* @throws ioexception if an ioexception occurs.
*/
public static void writeline bufferedwriter writer  string line  throws ioexception
writer write line
writer newline
}
/**
* write the text to the file.
*
* @param file a file
* @param text the text to write to the file
* @throws ioexception if an ioexception occurs.
*/
public static void write file file  string text  throws ioexception
bufferedwriter writer   null
try {
writer   newwriter file
writer write text
writer flush
writer temp   writer
writer   null
temp close
finally
closewriterwithwarning writer
}
}
/**
* synonym for write(text) allowing file.text = 'foo'.
*
* @param file a file
* @param text the text to write to the file
* @throws ioexception if an ioexception occurs.
* @see #write(file, string)
*/
public static void settext file file  string text  throws ioexception
write file  text
}
/**
* write the text to the file.
*
* @param file a file
* @param text the text to write to the file
* @return the original file
* @throws ioexception if an ioexception occurs.
*/
public static file leftshift file file  object text  throws ioexception
append file  text
return file
}
/**
* write the text to the file, using the specified encoding.
*
* @param file    a file
* @param text    the text to write to the file
* @param charset the charset used
* @throws ioexception if an ioexception occurs.
*/
public static void write file file  string text  string charset  throws ioexception
bufferedwriter writer   null
try {
writer   newwriter file  charset
writer write text
writer flush
writer temp   writer
writer   null
temp close
finally
closewriterwithwarning writer
}
}
/**
* append the text at the end of the file.
*
* @param file a file
* @param text the text to append at the end of the file
* @throws ioexception if an ioexception occurs.
*/
public static void append file file  object text  throws ioexception
bufferedwriter writer   null
try {
writer   newwriter file  true
invokerhelper write writer  text
writer flush
writer temp   writer
writer   null
temp close
finally
closewriterwithwarning writer
}
}
/**
* append the text at the end of the file, using a specified encoding.
*
* @param file    a file
* @param text    the text to append at the end of the file
* @param charset the charset used
* @throws ioexception if an ioexception occurs.
*/
public static void append file file  object text  string charset  throws ioexception
bufferedwriter writer   null
try {
writer   newwriter file  charset  true
invokerhelper write writer  text
writer flush
writer temp   writer
writer   null
temp close
finally
closewriterwithwarning writer
}
}
/**
* reads the reader into a list of strings, with one entry for each line.
* the reader is closed before this method returns.
*
* @param reader a reader
* @return a list of lines
* @throws ioexception if an ioexception occurs.
*/
public static list readlines reader reader  throws ioexception
iteratorclosureadapter closure   new iteratorclosureadapter reader
eachline reader  closure
return closure aslist
}
/**
* this method is used to throw useful exceptions when the eachfile* and eachdir closure methods
* are used incorrectly.
*
* @param dir the directory to check
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
*/
private static void checkdir file dir  throws filenotfoundexception  illegalargumentexception
if   dir exists
throw new filenotfoundexception dir getabsolutepath
if   dir isdirectory
throw new illegalargumentexception     dir getabsolutepath
}
/**
* common code for {@link #eachfile(file,closure)} and {@link #eachdir(file,closure)}
*
* @param self    a file object
* @param closure the closure to invoke
* @param onlydir if normal file should be skipped
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
*/
private static void eachfile final file self  final closure closure  final boolean onlydir
throws filenotfoundexception  illegalargumentexception
checkdir self
final file files   self listfiles
// null check because of http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4803836
if  files    null  return
for  int i   0  i < files length  i
if   onlydir    files isdirectory
closure call files
}
}
}
/**
* invokes the closure for each file in the given directory
*
* @param self    a file
* @param closure a closure
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
* @see file#listfiles()
*/
public static void eachfile final file self  final closure closure  throws filenotfoundexception  illegalargumentexception
eachfile self  closure  false
}
/**
* invokes the closure for each directory in this directory,
* ignoring regular files.
*
* @param self    a directory
* @param closure a closure
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
*/
public static void eachdir file self  closure closure  throws filenotfoundexception  illegalargumentexception
eachfile self  closure  true
}
/**
* common code for {@link #eachfilerecurse(file,closure)} and {@link #eachdirrecurse(file,closure)}
*
* @param self    a file object
* @param closure the closure to invoke on each file
* @param onlydir if normal file should be skipped
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
*/
private static void eachfilerecurse final file self  final closure closure  final boolean onlydir
throws filenotfoundexception  illegalargumentexception
checkdir self
final file files   self listfiles
// null check because of http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4803836
if  files    null  return
for  int i   0  i < files length  i
if  files isdirectory
closure call files
eachfilerecurse files  closure  onlydir
else if   onlydir
closure call files
}
}
}
/**
* invokes the closure for each descendant file in this directory.
* sub-directories are recursively searched in a depth-first fashion.
*
* @param self    a file
* @param closure a closure
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
*/
public static void eachfilerecurse file self  closure closure  throws filenotfoundexception  illegalargumentexception
eachfilerecurse self  closure  false
}
/**
* invokes the closure for each descendant directory of this directory.
* sub-directories are recursively searched in a depth-first fashion.
* only directories are passed to the closure; regular files are ignored.
*
* @param self    a directory
* @param closure a closure
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
* @since 1.1 beta 1
* @see #eachfilerecurse(file,closure,boolean)
*/
public static void eachdirrecurse final file self  final closure closure  throws filenotfoundexception  illegalargumentexception
eachfilerecurse self  closure  true
}
/**
* common code for {@link #eachfilematch(file,object,closure)} and {@link #eachdirmatch(file,object,closure)}
*
* @param self    a file
* @param filter  the filter to perform on the file/directory (using the iscase(object) method)
* @param closure the closure to invoke
* @param onlydir if normal file should be skipped
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
*/
private static void eachfilematch final file self  final object filter  final closure closure  final boolean onlydir
throws filenotfoundexception  illegalargumentexception
checkdir self
final file files   self listfiles
// null check because of http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4803836
if  files    null  return
final metaclass metaclass   invokerhelper getmetaclass filter
for  int i   0  i < files length  i
final file currentfile   files
if    onlydir    currentfile isdirectory
defaulttypetransformation casttoboolean metaclass invokemethod filter     currentfile getname
closure call currentfile
}
}
}
/**
* invokes the closure for each file whose name (file.name) matches the given filter in the given directory
* - calling the iscase() method to determine if a match occurs.  this method can be used
* with different kinds of filters like regular expressions, classes, ranges etc.
*
* @param self    a file
* @param filter  the filter to perform on the directory (using the iscase(object) method)
* @param closure the closure to invoke
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
*/
public static void eachfilematch final file self  final object filter  final closure closure
throws filenotfoundexception  illegalargumentexception
eachfilematch self  filter  closure  false
}
/**
* invokes the closure for each directory whose name (dir.name) matches the given filter in the given directory
* - calling the iscase() method to determine if a match occurs.  this method can be used
* with different kinds of filters like regular expressions, classes, ranges etc.
*
* @param self    a file
* @param filter  the filter to perform on the directory (using the iscase(object) method)
* @param closure the closure to invoke
* @throws filenotfoundexception    if the given directory does not exist
* @throws illegalargumentexception if the provided file object does not represent a directory
* @since 1.1 beta 1
*/
public static void eachdirmatch final file self  final object filter  final closure closure  throws filenotfoundexception  illegalargumentexception
eachfilematch self  filter  closure  true
}
/**
* allows a simple syntax for using timers.  this timer will execute the
* given closure after the given delay.
*
* @param timer   a timer object
* @param delay   the delay in milliseconds before running the closure code
* @param closure the closure to invoke
* @return the timer task which has been scheduled.
*/
public static timertask runafter timer timer  int delay  final closure closure
timertask timertask   new timertask
public void run
closure call
}
timer schedule timertask  delay
return timertask
}
/**
* create a buffered reader for this file.
*
* @param file a file
* @return a bufferedreader
* @throws ioexception if an ioexception occurs.
*/
public static bufferedreader newreader file file  throws ioexception
charsettoolkit toolkit   new charsettoolkit file
return toolkit getreader
}
/**
* create a buffered reader for this file, using the specified
* charset as the encoding.
*
* @param file    a file
* @param charset the charset for this file
* @return a bufferedreader
* @throws filenotfoundexception        if the file was not found
* @throws unsupportedencodingexception if the encoding specified is not supported
*/
public static bufferedreader newreader file file  string charset
throws filenotfoundexception  unsupportedencodingexception
return new bufferedreader new inputstreamreader new fileinputstream file   charset
}
/**
* creates a reader for this input stream.
*
* @param self an input stream
* @return a reader
*/
public static bufferedreader newreader inputstream self
return new bufferedreader new inputstreamreader self
}
/**
* creates a reader for this input stream, using the specified
* charset as the encoding.
*
* @param self an input stream
* @param charset the charset for this input stream
* @return a reader
* @throws unsupportedencodingexception if the encoding specified is not supported
*/
public static bufferedreader newreader inputstream self  string charset  throws unsupportedencodingexception
return new bufferedreader new inputstreamreader self  charset
}
/**
* create a new bufferedreader for this file and then
* passes it into the closure, ensuring the reader is closed after the
* closure returns.
*
* @param file    a file object
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withreader file file  closure closure  throws ioexception
return withreader newreader file   closure
}
/**
* create a buffered output stream for this file.
*
* @param file a file object
* @return the created outputstream
* @throws ioexception if an ioexception occurs.
*/
public static bufferedoutputstream newoutputstream file file  throws ioexception
return new bufferedoutputstream new fileoutputstream file
}
/**
* creates a new data output stream for this file.
*
* @param file a file object
* @return the created dataoutputstream
* @throws ioexception if an ioexception occurs.
*/
public static dataoutputstream newdataoutputstream file file  throws ioexception
return new dataoutputstream new fileoutputstream file
}
/**
* creates a new outputstream for this file and passes it into the closure.
* this method ensures the stream is closed after the closure returns.
*
* @param file    a file
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withstream(outputstream,closure)
*/
public static object withoutputstream file file  closure closure  throws ioexception
return withstream newoutputstream file   closure
}
/**
* create a new inputstream for this file and passes it into the closure.
* this method ensures the stream is closed after the closure returns.
*
* @param file    a file
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withstream(inputstream,closure)
*/
public static object withinputstream file file  closure closure  throws ioexception
return withstream newinputstream file   closure
}
/**
* creates a new inputstream for this url and passes it into the closure.
* this method ensures the stream is closed after the closure returns.
*
* @param url     a url
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withstream(inputstream,closure)
*/
public static object withinputstream url url  closure closure  throws ioexception
return withstream newinputstream url   closure
}
/**
* create a new dataoutputstream for this file and passes it into the closure.
* this method ensures the stream is closed after the closure returns.
*
* @param file    a file
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withstream(outputstream,closure)
*/
public static object withdataoutputstream file file  closure closure  throws ioexception
return withstream newdataoutputstream file   closure
}
/**
* create a new datainputstream for this file and passes it into the closure.
* this method ensures the stream is closed after the closure returns.
*
* @param file    a file
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withstream(inputstream,closure)
*/
public static object withdatainputstream file file  closure closure  throws ioexception
return withstream newdatainputstream file   closure
}
/**
* create a buffered writer for this file.
*
* @param file a file
* @return a bufferedwriter
* @throws ioexception if an ioexception occurs.
*/
public static bufferedwriter newwriter file file  throws ioexception
return new bufferedwriter new filewriter file
}
/**
* creates a buffered writer for this file, optionally appending to the
* existing file content.
*
* @param file   a file
* @param append true if data should be appended to the file
* @return a bufferedwriter
* @throws ioexception if an ioexception occurs.
*/
public static bufferedwriter newwriter file file  boolean append  throws ioexception
return new bufferedwriter new filewriter file  append
}
/**
* helper method to create a buffered writer for a file.  if the given
* charset is "utf-16be" or "utf-16le", the requisite byte order mark is
* written to the stream before the writer is returned.
*
* @param file    a file
* @param charset the name of the encoding used to write in this file
* @param append  true if in append mode
* @return a bufferedwriter
* @throws ioexception if an ioexception occurs.
*/
public static bufferedwriter newwriter file file  string charset  boolean append  throws ioexception
if  append
return new encodingawarebufferedwriter new outputstreamwriter new fileoutputstream file  append   charset
} else {
// first write the byte order mark for unicode encodings
fileoutputstream stream   new fileoutputstream file
if    equals charset
writeutf16bom stream  true
else if    equals charset
writeutf16bom stream  false
}
return new encodingawarebufferedwriter new outputstreamwriter stream  charset
}
}
/**
* creates a buffered writer for this file, writing data using the given
* encoding.
*
* @param file    a file
* @param charset the name of the encoding used to write in this file
* @return a bufferedwriter
* @throws ioexception if an ioexception occurs.
*/
public static bufferedwriter newwriter file file  string charset  throws ioexception
return newwriter file  charset  false
}
/**
* write a byte order mark at the begining of the file
*
* @param stream    the fileouputstream to write the bom to
* @param bigendian true if utf 16 big endian or false if low endian
* @throws ioexception if an ioexception occurs.
*/
private static void writeutf16bom fileoutputstream stream  boolean bigendian  throws ioexception
if  bigendian
stream write  2
stream write  1
} else {
stream write  1
stream write  2
}
}
/**
* creates a new bufferedwriter for this file, passes it to the closure, and
* ensures the stream is flushed and closed after the closure returns.
*
* @param file    a file
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withwriter file file  closure closure  throws ioexception
return withwriter newwriter file   closure
}
/**
* creates a new bufferedwriter for this file, passes it to the closure, and
* ensures the stream is flushed and closed after the closure returns.
* the writer will use the given charset encoding.
*
* @param file    a file
* @param charset the charset used
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withwriter file file  string charset  closure closure  throws ioexception
return withwriter newwriter file  charset   closure
}
/**
* create a new bufferedwriter which will append to this
* file.  the writer is passed to the closure and will be closed before
* this method returns.
*
* @param file    a file
* @param charset the charset used
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withwriterappend file file  string charset  closure closure  throws ioexception
return withwriter newwriter file  charset  true   closure
}
/**
* create a new bufferedwriter for this file in append mode.  the writer
* is passed to the closure and is closed after the closure returns.
*
* @param file    a file
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withwriterappend file file  closure closure  throws ioexception
return withwriter newwriter file  true   closure
}
/**
* create a new printwriter for this file.
*
* @param file a file
* @return the created printwriter
* @throws ioexception if an ioexception occurs.
*/
public static printwriter newprintwriter file file  throws ioexception
return new printwriter newwriter file
}
/**
* create a new printwriter for this file, using specified
* charset.
*
* @param file    a file
* @param charset the charset
* @return a printwriter
* @throws ioexception if an ioexception occurs.
*/
public static printwriter newprintwriter file file  string charset  throws ioexception
return new printwriter newwriter file  charset
}
/**
* create a new printwriter for this file which is then
* passed it into the given closure.  this method ensures its the writer
* is closed after the closure returns.
*
* @param file    a file
* @param closure the closure to invoke with the printwriter
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withprintwriter file file  closure closure  throws ioexception
return withwriter newprintwriter file   closure
}
/**
* create a new printwriter with a specified charset for
* this file.  the writer is passed to the closure, and will be closed
* before this method returns.
*
* @param file    a file
* @param charset the charset
* @param closure the closure to invoke with the printwriter
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withprintwriter file file  string charset  closure closure  throws ioexception
return withwriter newprintwriter file  charset   closure
}
/**
* allows this writer to be used within the closure, ensuring that it
* is flushed and closed before this method returns.
*
* @param writer  the writer which is used and then closed
* @param closure the closure that the writer is passed into
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withwriter writer writer  closure closure  throws ioexception
try {
object result   closure call writer
try {
writer flush
catch  ioexception e
// try to continue even in case of error
}
writer temp   writer
writer   null
temp close
return result
finally
closewriterwithwarning writer
}
}
/**
* allows this reader to be used within the closure, ensuring that it
* is closed before this method returns.
*
* @param reader  the reader which is used and then closed
* @param closure the closure that the writer is passed into
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withreader reader reader  closure closure  throws ioexception
try {
object result   closure call reader
reader temp   reader
reader   null
temp close
return result
finally
closereaderwithwarning reader
}
}
/**
* allows this input stream to be used within the closure, ensuring that it
* is flushed and closed before this method returns.
*
* @param stream  the stream which is used and then closed
* @param closure the closure that the stream is passed into
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withstream inputstream stream  closure closure  throws ioexception
try {
object result   closure call stream
inputstream temp   stream
stream   null
temp close
return result
finally
closeinputstreamwithwarning stream
}
}
/**
* reads the stream into a list, with one element for each line.
*
* @param stream a stream
* @return a list of lines
* @throws ioexception if an ioexception occurs.
* @see #readlines(reader)
*/
public static list readlines inputstream stream  throws ioexception
return readlines new bufferedreader new inputstreamreader stream
}
/**
* helper method to create a new bufferedreader for a url and then
* passes it to the closure.  the reader is closed after the closure returns.
*
* @param url     a url
* @param closure the closure to invoke with the reader
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withreader url url  closure closure  throws ioexception
return withreader url openconnection   getinputstream    closure
}
/**
* helper method to create a new bufferedreader for a url and then
* passes it to the closure.  the reader is closed after the closure returns.
*
* @param url     a url
* @param charset the charset used
* @param closure the closure to invoke with the reader
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withreader url url  string charset  closure closure  throws ioexception
return withreader url openconnection   getinputstream    charset  closure
}
/**
* helper method to create a new bufferedreader for a stream and then
* passes it into the closure.  the reader is closed after the closure returns.
*
* @param in      a stream
* @param closure the closure to invoke with the inputstream
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withreader inputstream in  closure closure  throws ioexception
return withreader new inputstreamreader in   closure
}
/**
* helper method to create a new bufferedreader for a stream and then
* passes it into the closure.  the reader is closed after the closure returns.
*
* @param in      a stream
* @param charset the charset used
* @param closure the closure to invoke with the inputstream
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withreader inputstream in  string charset  closure closure  throws ioexception
return withreader new inputstreamreader in  charset   closure
}
/**
* creates a writer from this stream, passing it to the given closure.
* this method ensures the stream is closed after the closure returns.
*
* @param stream  the stream which is used and then closed
* @param closure the closure that the writer is passed into
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withwriter(writer,closure)
*/
public static object withwriter outputstream stream  closure closure  throws ioexception
return withwriter new outputstreamwriter stream   closure
}
/**
* creates a writer from this stream, passing it to the given closure.
* this method ensures the stream is closed after the closure returns.
*
* @param stream  the stream which is used and then closed
* @param charset the charset used
* @param closure the closure that the writer is passed into
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @see #withwriter(writer,closure)
*/
public static object withwriter outputstream stream  string charset  closure closure  throws ioexception
return withwriter new outputstreamwriter stream  charset   closure
}
/**
* passes this outputstream to the closure, ensuring that the stream
* is closed after the closure returns, regardless of errors.
*
* @param os      the stream which is used and then closed
* @param closure the closure that the stream is passed into
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withstream outputstream os  closure closure  throws ioexception
try {
object result   closure call os
os flush
outputstream temp   os
os   null
temp close
return result
finally
closeoutputstreamwithwarning os
}
}
/**
* creates a buffered input stream for this file.
*
* @param file a file
* @return a bufferedinputstream of the file
* @throws filenotfoundexception if the file is not found.
*/
public static bufferedinputstream newinputstream file file  throws filenotfoundexception
return new bufferedinputstream new fileinputstream file
}
/**
* creates a buffered input stream for this url.
*
* @param url a url
* @return a bufferedinputstream for the url
* @throws malformedurlexception is thrown if the url is not well formed
* @throws ioexception if an i/o error occurs while creating the input stream
*/
public static bufferedinputstream newinputstream url url  throws malformedurlexception  ioexception
return new bufferedinputstream url openconnection   getinputstream
}
/**
* creates a buffered reader for this url.
*
* @param url a url
* @return a bufferedreader for the url
* @throws malformedurlexception is thrown if the url is not well formed
* @throws ioexception if an i/o error occurs while creating the input stream
*/
public static bufferedreader newreader url url  throws malformedurlexception  ioexception
return newreader url openconnection   getinputstream
}
/**
* creates a buffered reader for this url using the given encoding.
*
* @param url a url
* @param charset opens the stream with a specified charset
* @return a bufferedreader for the url
* @throws malformedurlexception is thrown if the url is not well formed
* @throws ioexception if an i/o error occurs while creating the input stream
*/
public static bufferedreader newreader url url  string charset  throws malformedurlexception  ioexception
return new bufferedreader new inputstreamreader url openconnection   getinputstream    charset
}
/**
* create a data input stream for this file
*
* @param file a file
* @return a datainputstream of the file
* @throws filenotfoundexception if the file is not found.
*/
public static datainputstream newdatainputstream file file  throws filenotfoundexception
return new datainputstream new fileinputstream file
}
/**
* traverse through each byte of this file
*
* @param self    a file
* @param closure a closure
* @throws ioexception if an ioexception occurs.
* @see #eachbyte(inputstream,closure)
*/
public static void eachbyte file self  closure closure  throws ioexception
bufferedinputstream is   newinputstream self
eachbyte is  closure
}
/**
* traverse through each byte of this byte array. alias for each.
*
* @param self    a byte array
* @param closure a closure
* @see #each(object,closure)
*/
public static void eachbyte byte self  closure closure
each self  closure
}
/**
* traverse through each byte of this byte array. alias for each.
*
* @param self    a byte array
* @param closure a closure
* @see #each(object,closure)
*/
public static void eachbyte byte self  closure closure
each self  closure
}
/**
* traverse through each byte of the specified stream. the
* stream is closed after the closure returns.
*
* @param is      stream to iterate over, closed after the method call
* @param closure closure to apply to each byte
* @throws ioexception if an ioexception occurs.
*/
public static void eachbyte inputstream is  closure closure  throws ioexception
try {
while  true
int b   is read
if  b     1
break
} else {
closure call new byte  byte  b
}
}
inputstream temp   is
is   null
temp close
finally
closeinputstreamwithwarning is
}
}
/**
* reads the inputstream from this url, passing each byte to the given
* closure.  the url stream will be closed before this method returns.
*
* @param url     url to iterate over
* @param closure closure to apply to each byte
* @throws ioexception if an ioexception occurs.
* @see #eachbyte(inputstream,closure)
*/
public static void eachbyte url url  closure closure  throws ioexception
inputstream is   url openconnection   getinputstream
eachbyte is  closure
}
/**
* transforms each character from this reader by passing it to the given
* closure.  the closure should return each transformed character, which
* will be passed to the writer.  the reader and writer will be both be
* closed before this method returns.
*
* @param self    a reader object
* @param writer  a writer to receive the transformed characters
* @param closure a closure that performs the required transformation
* @throws ioexception if an ioexception occurs.
*/
public static void transformchar reader self  writer writer  closure closure  throws ioexception
int c
try {
char chars   new char
while   c   self read        1
chars    char  c
writer write  string  closure call new string chars
}
writer flush
writer temp2   writer
writer   null
temp2 close
reader temp1   self
self   null
temp1 close
finally
closereaderwithwarning self
closewriterwithwarning writer
}
}
/**
* transforms the lines from a reader with a closure and
* write them to a writer. both reader and writer are
* closed after the operation.
*
* @param reader  lines of text to be transformed. reader is closed afterwards.
* @param writer  where transformed lines are written. writer is closed afterwards.
* @param closure single parameter closure that is called to transform each line of
*                text from the reader, before writing it to the writer.
* @throws ioexception if an ioexception occurs.
*/
public static void transformline reader reader  writer writer  closure closure  throws ioexception
bufferedreader br   new bufferedreader reader
bufferedwriter bw   new bufferedwriter writer
string line
try {
while   line   br readline       null
object o   closure call line
if  o    null
bw write o tostring
bw newline
}
}
bw flush
writer temp2   writer
writer   null
temp2 close
reader temp1   reader
reader   null
temp1 close
finally
closereaderwithwarning br
closereaderwithwarning reader
closewriterwithwarning bw
closewriterwithwarning writer
}
}
/**
* filter the lines from a reader and write them on the writer,
* according to a closure which returns true if the line should be included.
* both reader and writer are closed after the operation.
*
* @param reader  a reader, closed after the call
* @param writer  a writer, closed after the call
* @param closure the closure which returns booleans
* @throws ioexception if an ioexception occurs.
*/
public static void filterline reader reader  writer writer  closure closure  throws ioexception
bufferedreader br   new bufferedreader reader
bufferedwriter bw   new bufferedwriter writer
string line
try {
while   line   br readline       null
if  defaulttypetransformation casttoboolean closure call line
bw write line
bw newline
}
}
bw flush
writer temp2   writer
writer   null
temp2 close
reader temp1   reader
reader   null
temp1 close
finally
closereaderwithwarning br
closereaderwithwarning reader
closewriterwithwarning bw
closewriterwithwarning writer
}
}
/**
* filters the lines of a file and creates a writeable in return to
* stream the filtered lines.
*
* @param self    a file
* @param closure a closure which returns a boolean indicating to filter
*                the line or not
* @return a writable closure
* @throws ioexception if <code>self</code> is not readable
* @see #filterline(reader,closure)
*/
public static writable filterline file self  closure closure  throws ioexception
return filterline newreader self   closure
}
/**
* filter the lines from this file, and write them to the given writer based
* on the given closure predicate.
*
* @param self    a file
* @param writer  a writer destination to write filtered lines to
* @param closure a closure which takes each line as a parameter and returns
*                <code>true</code> if the line should be written to this writer.
* @throws ioexception if <code>self</code> is not readable
* @see #filterline(reader,writer,closure)
*/
public static void filterline file self  writer writer  closure closure  throws ioexception
filterline newreader self   writer  closure
}
/**
* filter the lines from this reader, and return a writable which can be
* used to stream the filtered lines to a destination.  the closure should
* return <code>true</code> if the line should be passed to the writer.
*
* @param reader  this reader
* @param closure a closure used for filtering
* @return a writable which will use the closure to filter each line
*         from the reader when the writable#writeto(writer) is called.
*/
public static writable filterline reader reader  final closure closure
final bufferedreader br   new bufferedreader reader
return new writable
public writer writeto writer out  throws ioexception
bufferedwriter bw   new bufferedwriter out
string line
while   line   br readline       null
if  defaulttypetransformation casttoboolean closure call line
bw write line
bw newline
}
}
bw flush
return out
}
public string tostring
stringwriter buffer   new stringwriter
try {
writeto buffer
catch  ioexception e
throw new stringwriterioexception e
}
return buffer tostring
}
}
/**
* filter lines from an input stream using a closure predicate.  the closure
* will be passed each line as a string, and it should return
* <code>true</code> if the line should be passed to the writer.
*
* @param self      an input stream
* @param predicate a closure which returns boolean and takes a line
* @return a writable which writes out the filtered lines
* @see #filterline(reader, closure)
*/
public static writable filterline inputstream self  closure predicate
return filterline newreader self   predicate
}
/**
* uses a closure to filter lines from this inputstream and pass them to
* the given writer. the closure will be passed each line as a string, and
* it should return <code>true</code> if the line should be passed to the
* writer.
*
* @param self      the inputstream
* @param writer    a writer to write output to
* @param predicate a closure which returns true if a line should be accepted
* @throws ioexception if an ioexception occurs.
* @see #filterline(reader,writer,closure)
*/
public static void filterline inputstream self  writer writer  closure predicate
throws ioexception
filterline newreader self   writer  predicate
}
/**
* reads the content of the file into a byte array.
*
* @param file a file
* @return a byte array with the contents of the file.
* @throws ioexception if an ioexception occurs.
*/
public static byte readbytes file file  throws ioexception
byte bytes   new byte
fileinputstream fileinputstream   new fileinputstream file
datainputstream dis   new datainputstream fileinputstream
try {
dis readfully bytes
inputstream temp   dis
dis   null
temp close
finally
if  dis    null
try {
dis close
catch  ioexception e
log warning     e
}
}
}
return bytes
}
// ================================
// socket and serversocket methods
/**
* passes the socket's inputstream and outputstream to the closure.  the
* streams will be closed after the closure returns, even if an exception
* is thrown.
*
* @param socket  a socket
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
*/
public static object withstreams socket socket  closure closure  throws ioexception
inputstream input   socket getinputstream
outputstream output   socket getoutputstream
try {
object result   closure call new object input  output
inputstream temp1   input
input   null
temp1 close
outputstream temp2   output
output   null
temp2 close
return result
finally
closeinputstreamwithwarning input
closeoutputstreamwithwarning output
}
}
/**
* creates an inputobjectstream and an outputobjectstream from a socket, and
* passes them to the closure.  the streams will be closed after the closure
* returns, even if an exception is thrown.
*
* @param socket  this socket
* @param closure a closure
* @return the value returned by the closure
* @throws ioexception if an ioexception occurs.
* @since 1.1 beta 2
*/
public static object withobjectstreams socket socket  closure closure  throws ioexception
inputstream input   socket getinputstream
outputstream output   socket getoutputstream
objectoutputstream oos   new objectoutputstream output
objectinputstream ois   new objectinputstream input
try {
object result   closure call new object ois  oos
inputstream temp1   ois
ois   null
temp1 close
temp1   input
input   null
temp1 close
outputstream temp2   oos
oos   null
temp2 close
temp2   output
output   null
temp2 close
return result
finally
closeinputstreamwithwarning ois
closeinputstreamwithwarning input
closeoutputstreamwithwarning oos
closeoutputstreamwithwarning output
}
}
// todo reduce duplication by using closable if we raise minimum requirement to java 1.5
private static void closeinputstreamwithwarning inputstream input
if  input    null
try {
input close
catch  ioexception e
log warning     e
}
}
}
private static void closeoutputstreamwithwarning outputstream output
if  output    null
try {
output close
catch  ioexception e
log warning     e
}
}
}
private static void closereaderwithwarning reader reader
if  reader    null
try {
reader close
catch  exception e
// ignore this exception since this
// is only our internal problem
log warning     e
}
}
}
private static void closewriterwithwarning writer writer
if  writer    null
try {
writer close
catch  ioexception e
log warning     e
}
}
}
/**
* overloads the left shift operator to provide an append mechanism to
* add things to the output stream of a socket
*
* @param self  a socket
* @param value a value to append
* @return a writer
* @throws ioexception if an ioexception occurs.
*/
public static writer leftshift socket self  object value  throws ioexception
return leftshift self getoutputstream    value
}
/**
* overloads the left shift operator to provide an append mechanism
* to add bytes to the output stream of a socket
*
* @param self  a socket
* @param value a value to append
* @return an outputstream
* @throws ioexception if an ioexception occurs.
*/
public static outputstream leftshift socket self  byte value  throws ioexception
return leftshift self getoutputstream    value
}
/**
* accepts a connection and passes the resulting socket to the closure
* which runs in a new thread.
*
* @param serversocket a serversocket
* @param closure      a closure
* @return a socket
* @throws ioexception if an ioexception occurs.
* @see java.net.serversocket#accept()
*/
public static socket accept serversocket serversocket  final closure closure  throws ioexception
final socket socket   serversocket accept
new thread new runnable
public void run
try {
closure call socket
finally
try {
socket close
catch  ioexception e
log warning     e
}
}
}
start
return socket
}
/**
* converts this file to a {@link writable}.
*
* @param file a file
* @return a file which wraps the input file and which implements writable
*/
public static file aswritable file file
return new writablefile file
}
/**
* converts this file to a {@link writable} or delegates to default
* {@link #astype(object,class)}.
*
* @param f a file
* @param c the desired class
* @return the converted object
*/
public static object astype file f  class c
if  c    writable class
return aswritable f
}
return astype  object  f  c
}
/**
* allows a file to return a writable implementation that can output itself
* to a writer stream.
*
* @param file     a file
* @param encoding the encoding to be used when reading the file's contents
* @return file which wraps the input file and which implements writable
*/
public static file aswritable file file  string encoding
return new writablefile file  encoding
}
/**
* converts the given string into a list of strings of one character.
*
* @param self a string
* @return a list of characters (a 1-character string)
*/
public static list tolist string self
int size   self length
list answer   new arraylist size
for  int i   0  i < size  i
answer add self substring i  i   1
}
return answer
}
/**
* converts the gstring to a file, or delegates to the default
* {@link #astype(object,class)}
*
* @param self a gstring
* @param c    the desired class
* @return the converted object
*/
public static object astype gstring self  class c
if  c    file class
return new file self tostring
}
return astype  object  self  c
}
/**
* <p>provides a method to perform custom 'dynamic' type conversion
* to the given class using the <code>as</code> operator.</p>
* <strong>example:</strong> <code>'123' as double</code>
* <p>by default, the following types are supported:
* <ul>
* <li>list</li>
* <li>bigdecimal</li>
* <li>biginteger</li>
* <li>character</li>
* <li>character</li>
* <li>double</li>
* <li>float</li>
* <li>file</li>
* <li>subclasses of enum (java 5 and above)</li>
* </ul>
* if any other type is given, the call is delegated to
* {@link #astype(object,class)}.
*
* @param self a string
* @param c    the desired class
* @return the converted object
*/
public static object astype string self  class c
if  c    list class
return tolist self
else if  c    bigdecimal class
return tobigdecimal self
else if  c    biginteger class
return tobiginteger self
else if  c    character class
return tocharacter self
else if  c    double class
return todouble self
else if  c    float class
return tofloat self
else if  c    file class
return new file self
else if  defaulttypetransformation isenumsubclass c
return invokerhelper invokemethod c     new object  self
}
return astype  object  self  c
}
// process methods
//-------------------------------------------------------------------------
/**
* an alias method so that a process appears similar to system.out, system.in, system.err;
* you can use process.in, process.out, process.err in a similar fashion.
*
* @param self a process instance
* @return the inputstream for the process
*/
public static inputstream getin process self
return self getinputstream
}
/**
* read the text of the output stream of the process.
*
* @param self a process instance
* @return the text of the output
* @throws ioexception if an ioexception occurs.
*/
public static string gettext process self  throws ioexception
return gettext new bufferedreader new inputstreamreader self getinputstream
}
/**
* an alias method so that a process appears similar to system.out, system.in, system.err;
* you can use process.in, process.out, process.err in a similar fashion.
*
* @param self a process instance
* @return the error inputstream for the process
*/
public static inputstream geterr process self
return self geterrorstream
}
/**
* an alias method so that a process appears similar to system.out, system.in, system.err;
* you can use process.in, process.out, process.err in a similar fashion.
*
* @param self a process instance
* @return the outputstream for the process
*/
public static outputstream getout process self
return self getoutputstream
}
/**
* overloads the left shift operator (&lt;&lt;) to provide an append mechanism
* to pipe data to a process.
*
* @param self  a process instance
* @param value a value to append
* @return a writer
* @throws ioexception if an ioexception occurs.
*/
public static writer leftshift process self  object value  throws ioexception
return leftshift self getoutputstream    value
}
/**
* overloads the left shift operator to provide an append mechanism
* to pipe into a process
*
* @param self  a process instance
* @param value data to append
* @return an outputstream
* @throws ioexception if an ioexception occurs.
*/
public static outputstream leftshift process self  byte value  throws ioexception
return leftshift self getoutputstream    value
}
/**
* wait for the process to finish during a certain amount of time, otherwise stops the process.
*
* @param self           a process
* @param numberofmillis the number of milliseconds to wait before stopping the process
*/
public static void waitfororkill process self  long numberofmillis
processrunner runnable   new processrunner self
thread thread   new thread runnable
thread start
runnable waitfororkill numberofmillis
}
/**
* gets the output and error streams from a process and reads them
* to keep the process from blocking due to a full output buffer. for this,
* two threads are started, so this method will return immediately.
*
* @param self a process
*/
public static void consumeprocessoutput process self
consumeprocessoutput self   outputstream null   outputstream null
}
/**
* gets the output and error streams from a process and reads them
* to keep the process from blocking due to a full output buffer.
* the processed stream data is appended to the supplied stringbuffer.
* for this, two threads are started, so this method will return immediately.
*
* @param self a process
* @param output a stringbuffer to capture the process stdout
* @param error a stringbuffer to capture the process stderr
*/
public static void consumeprocessoutput process self  stringbuffer output  stringbuffer error
consumeprocessoutputstream self  output
consumeprocesserrorstream self  error
}
/**
* gets the output and error streams from a process and reads them
* to keep the process from blocking due to a full output buffer.
* the processed stream data is appended to the supplied outputstream.
* for this, two threads are started, so this method will return immediately.
*
* @param self a process
* @param output an outputstream to capture the process stdout
* @param error an outputstream to capture the process stderr
*/
public static void consumeprocessoutput process self  outputstream output  outputstream error
consumeprocessoutputstream self  output
consumeprocesserrorstream self  error
}
/**
* gets the error stream from a process and reads it
* to keep the process from blocking due to a full buffer.
* the processed stream data is appended to the supplied stringbuffer.
* a new thread is started, so this method will return immediately.
*
* @param self a process
* @param error a stringbuffer to capture the process stderr
*/
public static void consumeprocesserrorstream process self  stringbuffer error
new thread new textdumper self geterrorstream    error   start
}
/**
* gets the error stream from a process and reads it
* to keep the process from blocking due to a full buffer.
* the processed stream data is appended to the supplied outputstream.
* a new thread is started, so this method will return immediately.
*
* @param self a process
* @param err an outputstream to capture the process stderr
*/
public static void consumeprocesserrorstream process self  outputstream err
new thread new bytedumper self geterrorstream    err   start
}
/**
* gets the error stream from a process and reads it
* to keep the process from blocking due to a full buffer.
* the processed stream data is appended to the supplied writer.
* a new thread is started, so this method will return immediately.
*
* @param self a process
* @param err a writer to capture the process stderr
*/
public static void consumeprocesserrorstream process self  writer err
new thread new textdumper self geterrorstream    err   start
}
/**
* gets the output stream from a process and reads it
* to keep the process from blocking due to a full output buffer.
* the processed stream data is appended to the supplied stringbuffer.
* a new thread is started, so this method will return immediately.
*
* @param self a process
* @param output a stringbuffer to capture the process stdout
*/
public static void consumeprocessoutputstream process self  stringbuffer output
new thread new textdumper self getinputstream    output   start
}
/**
* gets the output stream from a process and reads it
* to keep the process from blocking due to a full output buffer.
* the processed stream data is appended to the supplied outputstream.
* a new thread is started, so this method will return immediately.
*
* @param self a process
* @param output an outputstream to capture the process stdout
*/
public static void consumeprocessoutputstream process self  outputstream output
new thread new bytedumper self getinputstream    output   start
}
/**
* gets the output stream from a process and reads it
* to keep the process from blocking due to a full output buffer.
* the processed stream data is appended to the supplied writer.
* a new thread is started, so this method will return immediately.
*
* @param self a process
* @param output a writer to capture the process stdout
*/
public static void consumeprocessoutputstream process self  writer output
new thread new textdumper self getinputstream    output   start
}
/**
* creates a new bufferedwriter as stdin for this process,
* passes it to the closure, and ensures the stream is flushed
* and closed after the closure returns.
* a new thread is started, so this method will return immediately.
*
* @param self a process
* @param closure a closure
*/
public static void withwriter final process self  final closure closure
new thread new runnable
public void run
try {
withwriter new bufferedoutputstream getout self    closure
catch  ioexception e
throw new groovyruntimeexception    e
}
}
start
}
/**
* creates a new buffered outputstream as stdin for this process,
* passes it to the closure, and ensures the stream is flushed
* and closed after the closure returns.
* a new thread is started, so this method will return immediately.
*
* @param self a process
* @param closure a closure
*/
public static void withoutputstream final process self  final closure closure
new thread new runnable
public void run
try {
withstream new bufferedoutputstream getout self    closure
catch  ioexception e
throw new groovyruntimeexception    e
}
}
start
}
/**
* allows one process to asynchronously pipe data to another process.
*
* @param left  a process instance
* @param right a process to pipe output to
* @return the second process to allow chaining
* @throws ioexception if an ioexception occurs.
*/
public static process pipeto final process left  final process right  throws ioexception
new thread new runnable
public void run
inputstream in   new bufferedinputstream getin left
outputstream out   new bufferedoutputstream getout right
byte buf   new byte
int next
try {
while   next   in read buf       1
out write buf  0  next
}
catch  ioexception e
throw new groovyruntimeexception    e
finally
closeoutputstreamwithwarning out
}
}
start
return right
}
/**
* overrides the or operator to allow one process to asynchronously
* pipe data to another process.
*
* @param left  a process instance
* @param right a process to pipe output to
* @return the second process to allow chaining
* @throws ioexception if an ioexception occurs.
*/
public static process or final process left  final process right  throws ioexception
return pipeto left  right
}
/**
* process each regex group matched substring of the given string. if the closure
* parameter takes one argument, an array with all match groups is passed to it.
* if the closure takes as many arguments as there are match groups, then each
* parameter will be one match group.
*
* @param self    the source string
* @param regex   a regex string
* @param closure a closure with one parameter or as much parameters as groups
* @return the source string
*/
public static string eachmatch string self  string regex  closure closure
pattern p   pattern compile regex
matcher m   p matcher self
each m  closure
return self
}
/**
* process each matched substring of the given group matcher. the object
* passed to the closure is an array of strings, matched per a successful match.
*
* @param self    the source matcher
* @param closure a closure
* @return the matcher
*/
public static matcher each matcher self  closure closure
self reset
while  self find
int closureparams   closure getmaximumnumberofparameters
int count   self groupcount
if  closureparams    1    closureparams    count   1
throw new groovyruntimeexception     count
count   1        closureparams
}
list groups   new arraylist
for  int i   0  i <  count  i
groups add self group i
}
if  count > 0    closureparams    1
// give a 1-arg closure all groups as a array
closure call  object  groups toarray
} else {
closure call groups toarray
}
}
return self
}
/**
* iterates over the elements of an iterable collection of items and returns
* the index of the first item that matches the condition specified in the closure.
*
* @param self    the iteration object over which to iterate
* @param closure the filter to perform a match on the collection
* @return an integer that is the index of the first matched object or -1 if no match was found
*/
public static int findindexof object self  closure closure
return findindexof self  0  closure
}
/**
* iterates over the elements of an iterable collection of items, starting from a
* specified startindex, and returns the index of the first item that matches the
* condition specified in the closure.
*
* @param self       the iteration object over which to iterate
* @param startindex start matching from this index
* @param closure    the filter to perform a match on the collection
* @return an integer that is the index of the first matched object or -1 if no match was found
*/
public static int findindexof object self  int startindex  closure closure
int result    1
int i   0
for  iterator iter   invokerhelper asiterator self   iter hasnext    i
object value   iter next
if  i < startindex
continue
}
if  defaulttypetransformation casttoboolean closure call value
result   i
break
}
}
return result
}
/**
* iterates over the elements of an iterable collection of items and returns
* the index of the last item that matches the condition specified in the closure.
*
* @param self    the iteration object over which to iterate
* @param closure the filter to perform a match on the collection
* @return an integer that is the index of the last matched object or -1 if no match was found
*/
public static int findlastindexof object self  closure closure
return findlastindexof self  0  closure
}
/**
* iterates over the elements of an iterable collection of items, starting
* from a specified startindex, and returns the index of the last item that
* matches the condition specified in the closure.
*
* @param self       the iteration object over which to iterate
* @param startindex start matching from this index
* @param closure    the filter to perform a match on the collection
* @return an integer that is the index of the last matched object or -1 if no match was found
*/
public static int findlastindexof object self  int startindex  closure closure
int result    1
int i   0
for  iterator iter   invokerhelper asiterator self   iter hasnext    i
object value   iter next
if  i < startindex
continue
}
if  defaulttypetransformation casttoboolean closure call value
result   i
}
}
return result
}
/**
* iterates over the elements of an iterable collection of items and returns
* the index values of the items that match the condition specified in the closure.
*
* @param self    the iteration object over which to iterate
* @param closure the filter to perform a match on the collection
* @return a list of integers corresponding to the index values of all matched objects
*/
public static list findindexvalues object self  closure closure
return findindexvalues self  0  closure
}
/**
* iterates over the elements of an iterable collection of items, starting from
* a specified startindex, and returns the index values of the items that match
* the condition specified in the closure.
*
* @param self       the iteration object over which to iterate
* @param startindex start matching from this index
* @param closure    the filter to perform a match on the collection
* @return a list of integers corresponding to the index values of all matched objects
*/
public static list findindexvalues object self  int startindex  closure closure
list result   new arraylist
int i   0
for  iterator iter   invokerhelper asiterator self   iter hasnext    i
object value   iter next
if  i < startindex
continue
}
if  defaulttypetransformation casttoboolean closure call value
result add integer valueof i
}
}
return result
}
/**
* iterates through the classloader parents until it finds a loader with a class
* named "org.codehaus.groovy.tools.rootloader". if there is no such class
* <code>null</code> will be returned. the name is used for comparison because
* a direct comparison using == may fail as the class may be loaded through
* different classloaders.
*
* @param self a classloader
* @return the rootloader for the classloader
* @see org.codehaus.groovy.tools.rootloader
*/
public static classloader getrootloader classloader self
while  true
if  self    null  return null
if  isrootloaderclassorsubclass self   return self
self   self getparent
}
}
private static boolean isrootloaderclassorsubclass classloader self
class current   self getclass
while  current getname   equals object class getname
if current getname   equals rootloader class getname     return true
current   current getsuperclass
}
return false;
}
/**
* converts a given object to a type. this method is used through
* the "as" operator and is overloadable as any other operator.
*
* @param obj  the object to convert
* @param type the goal type
* @return the resulting object
*/
public static object astype object obj  class type
return defaulttypetransformation casttotype obj  type
}
/**
* convenience method to dynamically create a new instance of this
* class.  calls the default constructor.
*
* @param c a class
* @return a new instance of this class
*/
public static object newinstance class c
return invokerhelper invokeconstructorof c  null
}
/**
* helper to construct a new instance from the given arguments.
* the constructor is called based on the number and types in the
* args array.  use <code>newinstance(null)</code> or simply
* <code>newinstance()</code> for the default (no-arg) constructor.
*
* @param c    a class
* @param args the constructor arguments
* @return a new instance of this class.
*/
public static object newinstance class c  object args
if  args    null  args   new object null
return invokerhelper invokeconstructorof c  args
}
/**
* adds a "metaclass" property to all class objects so you can use the syntax
* <code>string.metaclass.mymethod = { println "foo" }</code>
*
* @param c the java.lang.class instance
* @return an metaclass instance
*/
public static metaclass getmetaclass class c
metaclassregistry metaclassregistry   groovysystem getmetaclassregistry
metaclass mc   metaclassregistry getmetaclass c
if  mc instanceof expandometaclass
mc instanceof delegatingmetaclass      delegatingmetaclass  mc  getadaptee   instanceof expandometaclass
return mc
else
metaclass emc   expandometaclasscreationhandle instance create c  metaclassregistry
emc initialize
metaclassregistry setmetaclass c  emc
return emc
}
}
/**
* obtains a metaclass for an object either from the registry or in the case of
* a groovyobject from the object itself.
*
* @param obj the object in question
* @return the metaclass
*/
public static metaclass getmetaclass object obj
if  obj instanceof groovyobject
return   groovyobject  obj  getmetaclass
}
return groovysystem getmetaclassregistry   getmetaclass obj getclass
}
/**
* a runnable which waits for a process to complete together with a notification scheme
* allowing another thread to wait a maximum number of seconds for the process to complete
* before killing it.
*/
protected static class processrunner implements runnable
process process
private boolean finished
public processrunner process process
this process   process
}
public void run
try {
process waitfor
catch  interruptedexception e
// ignore
}
synchronized  this
notifyall
finished   true
}
}
public synchronized void waitfororkill long millis
if   finished
try {
wait millis
catch  interruptedexception e
// ignore
}
if   finished
process destroy
}
}
}
}
private static class textdumper implements runnable
inputstream in
stringbuffer sb
writer w
public textdumper inputstream in  stringbuffer sb
this in   in
this sb   sb
}
public textdumper inputstream in  writer w
this in   in
this w   w
}
public void run
inputstreamreader isr   new inputstreamreader in
bufferedreader br   new bufferedreader isr
string next
try {
while   next   br readline       null
if  sb    null
sb append next
sb append
} else {
w write next
w write
}
}
catch  ioexception e
throw new groovyruntimeexception    e
}
}
}
private static class bytedumper implements runnable
inputstream in
outputstream out
public bytedumper inputstream in  outputstream out
this in   new bufferedinputstream in
this out   out
}
public bytedumper inputstream in
this in   new bufferedinputstream in
}
public void run
byte buf   new byte
int next
try {
while   next   in read buf       1
if  out    null  out write buf  0  next
}
catch  ioexception e
throw new groovyruntimeexception    e
}
}
}
/**
* attempts to create an iterator for the given object by first
* converting it to a collection.
*
* @param o an object
* @return an iterator for the given object.
* @see defaulttypetransformation#ascollection(object)
*/
public static iterator iterator object o
return defaulttypetransformation ascollection o  iterator
}
/**
* allows an enumeration to behave like an iterator.  note that the
* {@link iterator#remove() remove()} method is unsupported since the
* underlying enumeration does not provide a mechanism for removing items.
*
* @param enumeration an enumeration object
* @return an iterator for the given enumeration
*/
public static iterator iterator final enumeration enumeration
return new iterator
private object last
public boolean hasnext
return enumeration hasmoreelements
}
public object next
last   enumeration nextelement
return last
}
public void remove
throw new unsupportedoperationexception
}
}
// todo move into domcategory once we can make use of optional categories transparent
/**
* makes nodelist iterable by returning a read-only iterator which traverses
* over each node.
*
* @param nodelist a nodelist
* @return an iterator for a nodelist
*/
public static iterator iterator final nodelist nodelist
return new iterator
private int current      0
public boolean hasnext
return current < nodelist getlength
}
public object next
return nodelist item current
}
public void remove
throw new unsupportedoperationexception
}
}
/**
* retuns an {@link iterator} which traverses each match.
*
* @param matcher a matcher object
* @return an iterator for a matcher
* @see matcher#group()
*/
public static iterator iterator final matcher matcher
matcher reset
return new iterator
private boolean found      false
private boolean done      false
public boolean hasnext
if  done
return false;
}
if   found
found   matcher find
if   found
done   true
}
}
return found
}
public object next
if   found
if   hasnext
throw new nosuchelementexception
}
}
found   false
return matcher group
}
public void remove
throw new unsupportedoperationexception
}
}
/**
* creates an iterator which will traverse through the reader a line at a time.
*
* @param self a reader object
* @return an iterator for the reader
* @see java.io.bufferedreader#readline()
*/
public static iterator iterator reader self
final bufferedreader bufferedreader
if  self instanceof bufferedreader
bufferedreader    bufferedreader  self
else
bufferedreader   new bufferedreader self
return new iterator
string nextval      null
boolean nextmustread   true
boolean hasnext   true
public boolean hasnext
if  nextmustread    hasnext
try {
nextval   readnext
nextmustread   false
catch  ioexception e
hasnext   false
}
}
return hasnext
}
public object next
string retval   null
if  nextmustread
try {
retval   readnext
catch  ioexception e
hasnext   false
}
else
retval   nextval
nextmustread   true
return retval
}
private string readnext   throws ioexception
string nv   bufferedreader readline
if  nv    null
hasnext   false
return nv
}
public void remove
throw new unsupportedoperationexception
}
}
/**
* standard iterator for a input stream which iterates through the stream
* content in a byte-based fashion.
*
* @param self an inputstream object
* @return an iterator for the inputstream
*/
public static iterator iterator inputstream self
return iterator new datainputstream self
}
/**
* standard iterator for a data input stream which iterates through the
* stream content a byte at a time.
*
* @param self a datainputstream object
* @return an iterator for the datainputstream
*/
public static iterator iterator final datainputstream self
return new iterator
byte nextval
boolean nextmustread   true
boolean hasnext   true
public boolean hasnext
if  nextmustread    hasnext
try {
byte bprimitive   self readbyte
nextval   new byte bprimitive
nextmustread   false
catch  ioexception e
hasnext   false
}
}
return hasnext
}
public object next
byte retval   null
if  nextmustread
try {
byte b   self readbyte
retval   new byte b
catch  ioexception e
hasnext   false
}
else
retval   nextval
nextmustread   true
return retval
}
public void remove
throw new unsupportedoperationexception
}
}
/**
* just throws a deprecationexception.  do not use.  it used to provide an iterator for text file content
* one line at a time.
*
* @param self a file object
* @return a line-based iterator
* @throws ioexception if there is a problem processing the file (e.g. file is not found)
* @deprecated use file#eachline instead please
*/
public static iterator iterator file self  throws ioexception
throw new deprecationexception
}
/**
* an identity function for iterators, supporting 'duck-typing' when trying to get an
* iterator for each object within a collection, some of which may already be iterators.
*
* @param self an iterator object
* @return itself
*/
public static iterator iterator iterator self
return self
}
}