/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy classgen
import org codehaus groovy groovybugerror
import org codehaus groovy ast
import org codehaus groovy ast variable
import org codehaus groovy ast expr
import org codehaus groovy ast stmt blockstatement
import org codehaus groovy ast stmt catchstatement
import org codehaus groovy ast stmt forstatement
import org codehaus groovy control sourceunit
import java util iterator
import java util linkedlist
import java util list
import java util map
/**
* goes through an ast and initializes the scopes
*
* @author jochen theodorou
*/
public class variablescopevisitor extends classcodevisitorsupport
private variablescope currentscope   null
private variablescope headscope   new variablescope
private classnode currentclass   null
private sourceunit source
private boolean inclosure   false
private boolean inpropertyexpression   false
private boolean isspecialconstructorcall   false
private linkedlist statestack   new linkedlist
private class statestackelement
variablescope scope
classnode clazz
boolean closure
statestackelement
scope   variablescopevisitor this currentscope
clazz   variablescopevisitor this currentclass
closure   variablescopevisitor this inclosure
public variablescopevisitor sourceunit source
this source   source
currentscope   headscope
// ------------------------------
// helper methods
//------------------------------
private void pushstate boolean isstatic
statestack add new statestackelement
currentscope   new variablescope currentscope
currentscope setinstaticcontext isstatic
private void pushstate
pushstate currentscope isinstaticcontext
private void popstate
// a scope in a closure is never really static
// the checking needs this to be as the surrounding
// method to correctly check the access to variables.
// but a closure and all nested scopes are a result
// of calling a non static method, so the context
// is not static.
if  inclosure  currentscope setinstaticcontext false
statestackelement element    statestackelement  statestack removelast
currentscope   element scope
currentclass   element clazz
inclosure   element closure
private void declare parameter parameters  astnode node
for  int i   0  i < parameters length  i
if  parameters hasinitialexpression
parameters getinitialexpression   visit this
declare parameters  node
private void declare variableexpression expr
declare expr  expr
private void declare variable var  astnode expr
string scopetype
string variabletype
if  expr getclass      fieldnode class
scopetype
variabletype
else if  expr getclass      propertynode class
scopetype
variabletype
stringbuffer msg   new stringbuffer
msg append    append scopetype
msg append    append variabletype
msg append    append var getname
if  currentscope getdeclaredvariable var getname       null
adderror msg tostring    expr
return
for  variablescope scope   currentscope getparent    scope    null  scope   scope getparent
// if we are in a class and no variable is declared until
// now, then we can break the loop, because we are allowed
// to declare a variable of the same name as a class member
if  scope getclassscope      null  break
if  scope getdeclaredvariable var getname       null
// variable already declared
adderror msg tostring    expr
break
// declare the variable even if there was an error to allow more checks
currentscope putdeclaredvariable var
protected sourceunit getsourceunit
return source
private variable findclassmember classnode cn  string name
if  cn    null  return null
if  cn isscript
return new dynamicvariable name  false
list l   cn getfields
for  iterator iter   l iterator    iter hasnext
fieldnode f    fieldnode  iter next
if  f getname   equals name   return f
l   cn getmethods
for  iterator iter   l iterator    iter hasnext
methodnode f    methodnode  iter next
string methodname   f getname
string pname   getpropertyname f
if  pname    null  continue
if   pname equals name   continue
propertynode var   new propertynode pname  f getmodifiers    getpropertytype f   cn  null  null  null
return var
l   cn getproperties
for  iterator iter   l iterator    iter hasnext
propertynode f    propertynode  iter next
if  f getname   equals name   return f
variable ret   findclassmember cn getsuperclass    name
if  ret    null  return ret
return findclassmember cn getouterclass    name
private classnode getpropertytype methodnode m
string name   m getname
if  m getreturntype      classhelper void_type
return m getreturntype
return m getparameters   gettype
private string getpropertyname methodnode m
string name   m getname
if    name startswith       name startswith      return null
string pname   name substring 3
if  pname length      0  return null
string s   pname substring 0  1  tolowercase
string rest   pname substring 1
pname   s   rest
if  name startswith       m getreturntype      classhelper void_type
return null
if  name startswith       m getparameters   length    1
return null
return pname
// -------------------------------
// different variable based checks
// -------------------------------
private variable checkvariablenamefordeclaration string name  expression expression
if    equals name       equals name   return null
variablescope scope   currentscope
variable var   new dynamicvariable name  currentscope isinstaticcontext
variable dummystart   var
// try to find a declaration of a variable
variablescope dynamicscope   null
while   scope isroot
if  dynamicscope    null    scope isresolvingdynamic
dynamicscope   scope
variable var1
var1   scope getdeclaredvariable var getname
if  var1    null
var   var1
break
var1    variable  scope getreferencedlocalvariable var getname
if  var1    null
var   var1
break
var1   scope getreferencedclassvariable var getname
if  var1    null
var   var1
break
classnode classscope   scope getclassscope
if  classscope    null
variable member   findclassmember classscope  var getname
if  member    null
boolean cc   currentscope isinstaticcontext      isspecialconstructorcall
boolean cm   member isinstaticcontext
//
// we don't allow access from dynamic context to static context
//
// cm==cc:
//   we always allow access if the context is in both cases static
//   or dynamic
// cm==true:
//   the member is static, which means access is always allowed
// cm||cm==cc:
//   is false only for the case cc==true and cm==false, which means
//   the member is a dynamic context, but the current scope is static.
//
// one example for (cm||cm==cc)==false is a static method trying to
// access a non static field.
//
if  cm    cm    cc  var   member
break
scope   scope getparent
variablescope end   scope
if  scope isroot      dynamicscope    null
// no matching scope found
declare var  expression
adderror     var getname
expression
else if  scope isroot      dynamicscope    null
// no matching scope found, but there was a scope that
// resolves dynamic
scope   dynamicscope
if   scope isroot
scope   currentscope
while  scope    end
map references   null
if  end isclassscope      end isroot
end isreferencedclassvariable name     end getdeclaredvariable name     null
scope putreferencedclassvariable var
else
var setclosuresharedvariable var isclosuresharedvariable      inclosure
scope putreferencedlocalvariable var
scope   scope getparent
if  end isresolvingdynamic
if  end getdeclaredvariable var getname       null
end putdeclaredvariable var
return var
/**
* a property on "this", like this.x is transformed to a
* direct field access, so we need to check the
* static context here
*/
private void checkpropertyonexplicitthis propertyexpression pe
if   currentscope isinstaticcontext    return
expression object   pe getobjectexpression
if    object instanceof variableexpression   return
variableexpression ve    variableexpression  object
if   ve getname   equals     return
string name   pe getpropertyasstring
if  name    null  return
variable member   findclassmember currentclass  name
if  member    null  return
checkvariablecontextaccess member  pe
private void checkvariablecontextaccess variable v  expression expr
if  inpropertyexpression    v isinstaticcontext       currentscope isinstaticcontext    return
string msg   v getname
adderror msg  expr
// declare a static variable to be able to continue the check
dynamicvariable v2   new dynamicvariable v getname    currentscope isinstaticcontext
currentscope putdeclaredvariable v2
// ------------------------------
// code visit
// ------------------------------
public void visitblockstatement blockstatement block
pushstate
block setvariablescope currentscope
super visitblockstatement block
popstate
public void visitforloop forstatement forloop
pushstate
forloop setvariablescope currentscope
parameter p    parameter  forloop getvariable
p setinstaticcontext currentscope isinstaticcontext
if  p    forstatement for_loop_dummy  declare p  forloop
super visitforloop forloop
popstate
public void visitdeclarationexpression declarationexpression expression
// visit right side first to avoid the usage of a
// variable before its declaration
expression getrightexpression   visit this
// no need to visit left side, just get the variable name
variableexpression vex   expression getvariableexpression
vex setinstaticcontext currentscope isinstaticcontext
declare vex
vex setaccessedvariable vex
public void visitvariableexpression variableexpression expression
string name   expression getname
variable v   checkvariablenamefordeclaration name  expression
if  v    null  return
expression setaccessedvariable v
checkvariablecontextaccess v  expression
public void visitpropertyexpression propertyexpression expression
boolean ipe   inpropertyexpression
inpropertyexpression   true
expression getobjectexpression   visit this
inpropertyexpression   false
expression getproperty   visit this
checkpropertyonexplicitthis expression
inpropertyexpression   ipe
public void visitclosureexpression closureexpression expression
pushstate
inclosure   true
// as result of the paris meeting closure resolves
// always dynamically
currentscope setdynamicresolving true
expression setvariablescope currentscope
if  expression isparameterspecified
parameter parameters   expression getparameters
for  int i   0  i < parameters length  i
parameters setinstaticcontext currentscope isinstaticcontext
if  parameters hasinitialexpression
parameters getinitialexpression   visit this
declare parameters  expression
else if  expression getparameters      null
dynamicvariable var   new dynamicvariable    currentscope isinstaticcontext
currentscope putdeclaredvariable var
super visitclosureexpression expression
popstate
public void visitcatchstatement catchstatement statement
pushstate
parameter p    parameter  statement getvariable
p setinstaticcontext currentscope isinstaticcontext
declare p  statement
super visitcatchstatement statement
popstate
public void visitfieldexpression fieldexpression expression
string name   expression getfieldname
//todo: change that to get the correct scope
variable v   checkvariablenamefordeclaration name  expression
checkvariablecontextaccess v  expression
// ------------------------------
// class visit
// ------------------------------
public void visitclass classnode node
pushstate
currentclass   node
boolean dynamicmode   node isscript
currentscope setdynamicresolving dynamicmode
currentscope setclassscope node
super visitclass node
popstate
protected void visitconstructorormethod methodnode node  boolean isconstructor
pushstate node isstatic
node setvariablescope currentscope
// groovy-2156
parameter parameters   node getparameters
for  int i   0  i < parameters length  i
parameter parameter   parameters
visitannotations parameter
declare node getparameters    node
super visitconstructorormethod node  isconstructor
popstate
public void visitmethodcallexpression methodcallexpression call
if  call isimplicitthis      call getmethod   instanceof constantexpression
object value     constantexpression  call getmethod    gettext
if    value instanceof string
throw new groovybugerror
string methodname    string  value
variable v   checkvariablenamefordeclaration methodname  call
if  v    null      v instanceof dynamicvariable
checkvariablecontextaccess v  call
super visitmethodcallexpression call
public void visitconstructorcallexpression constructorcallexpression call
isspecialconstructorcall   call isspecialcall
super visitconstructorcallexpression call
isspecialconstructorcall   false
public void visitproperty propertynode node
pushstate node isstatic
super visitproperty node
popstate
public void visitfield fieldnode node
pushstate node isstatic
super visitfield node
popstate