package org jruby java proxies
import java lang reflect constructor
import java lang reflect method
import org jruby ruby
import org jruby rubyarray
import org jruby rubyclass
import org jruby rubyinstanceconfig
import org jruby rubymodule
import org jruby anno jrubymethod
import org jruby exceptions raiseexception
import org jruby internal runtime methods dynamicmethod
import org jruby internal runtime methods javamethod javamethodn
import org jruby internal runtime methods javamethod javamethodone
import org jruby internal runtime methods javamethod javamethodoneblock
import org jruby internal runtime methods javamethod javamethodzero
import org jruby internal runtime methods undefinedmethod
import org jruby javasupport java
import org jruby javasupport javaclass
import org jruby javasupport javaobject
import org jruby javasupport javautilities
import org jruby javasupport util runtimehelpers
import org jruby runtime arity
import org jruby runtime block
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime visibility
import org jruby runtime builtin irubyobject
public class javainterfacetemplate
public static rubymodule createjavainterfacetemplatemodule threadcontext context
ruby runtime   context getruntime
rubymodule javainterfacetemplate   runtime definemodule
rubyclass singleton   javainterfacetemplate getsingletonclass
singleton addreadattribute context
singleton defineannotatedmethods javainterfacetemplate class
return javainterfacetemplate
// not intended to be called directly by users (private)
// old todo from ruby code:
// this should be implemented in javaclass.java, where we can
// check for reserved ruby names, conflicting methods, etc.
@jrubymethod visibility   visibility private
public static irubyobject implement threadcontext context  irubyobject self  irubyobject clazz
ruby runtime   context getruntime
if    clazz instanceof rubymodule
throw runtime newtypeerror clazz  runtime getmodule
rubymodule targetmodule    rubymodule clazz
javaclass javaclass    javaclass self getinstancevariables   getinstancevariable
method javainstancemethods   javaclass javaclass   getmethods
dynamicmethod dummymethod   new org jruby internal runtime methods javamethod targetmodule  visibility public
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject args  block block
// dummy bodies for default impls
return context getruntime   getnil
for  int i   0  i < javainstancemethods length  i
method method   javainstancemethods
string name   method getname
if  targetmodule searchmethod name     undefinedmethod instance  continue
targetmodule addmethod name  dummymethod
return runtime getnil
// framed for invokesuper
@jrubymethod frame   true
public static irubyobject append_features threadcontext context  irubyobject self  irubyobject clazz  block block
if  clazz instanceof rubyclass
appendfeaturestoclass context  self   rubyclass clazz
else if  clazz instanceof rubymodule
appendfeaturestomodule context  self   rubymodule clazz
else
throw context getruntime   newtypeerror     clazz
return runtimehelpers invokesuper context  self  clazz  block
private static void appendfeaturestoclass threadcontext context  irubyobject self  final rubyclass clazz
ruby runtime   context getruntime
checkalreadyreified clazz  runtime
irubyobject javaclassobj   runtimehelpers getinstancevariable self  runtime
irubyobject javainterfaces
if   clazz hasinstancevariable
javainterfaces   rubyarray newarray runtime  javaclassobj
runtimehelpers setinstancevariable javainterfaces  clazz
initinterfaceimplmethods context  clazz
else
javainterfaces   runtimehelpers getinstancevariable clazz  runtime
// we've already done the above priming logic, just add another interface
// to the list of intentions unless we're past the point of no return or
// already intend to implement the given interface
if    javainterfaces isfrozen        rubyarray javainterfaces  includes context  javaclassobj
rubyarray javainterfaces  append javaclassobj
private static void checkalreadyreified final rubyclass clazz  ruby runtime  throws raiseexception
// not allowed for original (non-generated) java classes
// note: not allowing for any previously created class right now;
// this restriction might be loosened later for generated classes
if   java new_style_extension    clazz getreifiedclass      null
clazz hasinstancevariable
clazz getinstancevariable    istrue
clazz getsingletonclass   ismethodbound    false
clazz hasinstancevariable
clazz getinstancevariable    istrue
throw runtime newargumenterror
private static void initinterfaceimplmethods threadcontext context  rubyclass clazz
// setup new, etc unless this is a concretejavaproxy subclass
// for jruby-4571, check both these, since javaproxy extension stuff adds the former and this code adds the latter
if    clazz ismethodbound    false     clazz ismethodbound    false
// first we make modifications to the class, to adapt it to being
// both a ruby class and a proxy for a java type
rubyclass singleton   clazz getsingletonclass
// list of interfaces we implement
singleton addreadattribute context
if
java new_style_extension    clazz getsuperclass   getrealclass   hasinstancevariable
rubyinstanceconfig interfaces_use_proxy
// superclass is a java class...use old style impl for now
// the replacement "new" allocates and inits the ruby object as before, but
// also instantiates our proxified java object by calling __jcreate!
final objectallocator proxyallocator   clazz getallocator
clazz setallocator new objectallocator
public irubyobject allocate ruby runtime  rubyclass klazz
irubyobject newobj   proxyallocator allocate runtime  klazz
runtimehelpers invoke runtime getcurrentcontext    newobj
return newobj
// jcreate instantiates the proxy object which implements all interfaces
// and which is wrapped and implemented by this object
clazz addmethod    new javamethodn clazz  visibility private
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject args
return jcreateproxy self
else
// the new "new" actually generates a real java class to use for the ruby class's
// backing store, instantiates that, and then calls initialize on it.
addrealimplclassnew clazz
// next, we define a few private methods that we'll use to manipulate
// the java object contained within this ruby object
// used by our duck-typification of proc into interface types, to allow
// coercing a simple proc into an interface parameter.
clazz addmethod    new javamethodn clazz  visibility private
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject args
irubyobject result   jcreateproxy self
return result
// if we hold a java object, we need a java_class accessor
clazz addmethod    new javamethodzero clazz  visibility public
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name
return   javaobject  self datagetstruct    java_class
// because we implement java interfaces now, we need a new === that's
// aware of those additional "virtual" supertypes
if   clazz searchmethod    isundefined
clazz definealias
clazz addmethod    new javamethodone clazz  visibility public
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject arg
// todo: wrong - get interfaces from class
if  arg respondsto
irubyobject interfaces   self getmetaclass   getinstancevariables   getinstancevariable
assert interfaces instanceof rubyarray
return context getruntime   newboolean   rubyarray  interfaces  op_diff
javaclass    javaobject  arg datagetstruct    java_class    interfaces    equals rubyarray newarray context getruntime
else
return runtimehelpers invoke context  self     arg
// now we add an "implement" and "implement_all" methods to the class
if   clazz ismethodbound    false
rubyclass singleton   clazz getsingletonclass
// implement is called to force this class to create stubs for all
// methods in the given interface, so they'll show up in the list
// of methods and be invocable without passing through method_missing
singleton addmethod    new javamethodone clazz  visibility private
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject arg
irubyobject javainterfaces   self getinstancevariables   getinstancevariable
if  javainterfaces    null      rubyarray  javainterfaces  includes context  arg
return runtimehelpers invoke context  arg     self
return context getruntime   getnil
// implement all forces implementation of all interfaces we intend
// for this class to implement
singleton addmethod    new javamethodone clazz  visibility private
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject arg
rubyarray javainterfaces    rubyarray  self getinstancevariables   getinstancevariable
for  int i   0  i < javainterfaces size    i
runtimehelpers invoke context  javautilities get_interface_module self  javainterfaces eltinternal i       self
return javainterfaces
public static void addrealimplclassnew rubyclass clazz
clazz setallocator new objectallocator
private constructor proxyconstructor
public irubyobject allocate ruby runtime  rubyclass klazz
// if we haven't been here before, reify the class
class reifiedclass   klazz getreifiedclass
if  proxyconstructor    null    proxyconstructor getdeclaringclass      reifiedclass
if  reifiedclass    null
reifiedclass   java generaterealclass klazz
proxyconstructor   java getrealclassconstructor runtime  reifiedclass
irubyobject newobj   java constructproxy runtime  proxyconstructor  klazz
return newobj
private static irubyobject jcreateproxy irubyobject self
rubyclass current   self getmetaclass
// construct the new interface impl and set it into the object
irubyobject newobject   java newinterfaceimpl self  java getinterfacesfromrubyclass current
return javautilities set_java_object self  self  newobject
private static void appendfeaturestomodule threadcontext context  irubyobject self  rubymodule module
// assuming the user wants a collection of interfaces that can be
// included together. make it so.
ruby runtime   context getruntime
// not allowed for existing java interface modules
if  module getinstancevariables   hasinstancevariable
module getinstancevariables   getinstancevariable    istrue
throw runtime newtypeerror
// to turn a module into an "interface collection" we add a class instance
// variable to hold the list of interfaces, and modify append_features
// for this module to call append_features on each of those interfaces as
// well
synchronized  module
if   module getinstancevariables   hasinstancevariable
rubyarray javainterfacemods   rubyarray newarray runtime  self
module getinstancevariables   setinstancevariable    javainterfacemods
rubyclass singleton   module getsingletonclass
singleton addmethod    new javamethodoneblock singleton  visibility public
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject arg  block block
if    arg instanceof rubyclass
throw context getruntime   newtypeerror
rubyclass target    rubyclass arg
rubyarray javainterfacemods    rubyarray self getinstancevariables   getinstancevariable
target include javainterfacemods tojavaarray
return runtimehelpers invokeas context  clazz getsuperclass    self  name  arg  block
else
// already set up append_features, just add the interface if we haven't already
rubyarray javainterfacemods   rubyarray module getinstancevariables   getinstancevariable
if   javainterfacemods includes context  self
javainterfacemods append self
@jrubymethod
public static irubyobject extended threadcontext context  irubyobject self  irubyobject object
if    self instanceof rubymodule
throw context getruntime   newtypeerror self  context getruntime   getmodule
rubyclass singleton   object getsingletonclass
singleton include new irubyobject  self
return singleton
@jrubymethod name      rest   true
public static irubyobject op_aref threadcontext context  irubyobject self  irubyobject args
return javaproxy op_aref context  self  args
@jrubymethod rest   true
public static irubyobject impl threadcontext context  irubyobject self  irubyobject args  final block implblock
ruby runtime   context getruntime
if   implblock isgiven    throw runtime newargumenterror
final rubyarray methodnames    args length > 0  ? runtime newarray args    null
rubyclass implclass   rubyclass newclass runtime  runtime getobject
implclass include new irubyobject  self
irubyobject implobject   implclass callmethod context
implclass addmethod
new org jruby internal runtime methods javamethod implclass  visibility public
@override
public irubyobject call threadcontext context  irubyobject self  rubymodule clazz  string name  irubyobject args  block block
arity checkargumentcount context getruntime    args length  1   1
if  methodnames    null    methodnames include_p context  args  istrue
return implblock call context  args
else
return clazz getsuperclass   callmethod context     args  block
return implobject
@jrubymethod name      rest   true
public static irubyobject rbnew threadcontext context  irubyobject self  irubyobject args  block block
ruby runtime   context getruntime
rubyclass implclass    rubyclass self getinstancevariables   getinstancevariable
if  implclass    null
implclass   rubyclass newclass runtime   rubyclass runtime getclass
implclass include new irubyobject  self
runtimehelpers setinstancevariable implclass  self
return runtimehelpers invoke context  implclass     args  block