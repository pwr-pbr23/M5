/***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2006, 2007 ola bini <ola@ologix.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby ext openssl
import java io ioexception
import java net socket
import java nio bytebuffer
import java nio channels selectablechannel
import java nio channels selectionkey
import java nio channels selector
import java nio channels socketchannel
import java security keymanagementexception
import java security nosuchalgorithmexception
import java security cert certificate
import java security cert certificateencodingexception
import java util set
import javax net ssl sslengine
import javax net ssl sslengineresult
import javax net ssl sslexception
import javax net ssl sslhandshakeexception
import javax net ssl sslpeerunverifiedexception
import javax net ssl sslsession
import org jruby ruby
import org jruby rubyarray
import org jruby rubyclass
import org jruby rubyio
import org jruby rubymodule
import org jruby rubynumeric
import org jruby rubyobject
import org jruby rubyobjectadapter
import org jruby rubystring
import org jruby rubythread
import org jruby anno jrubymethod
import org jruby exceptions raiseexception
import org jruby ext openssl x509store x509utils
import org jruby javasupport javaembedutils
import org jruby runtime arity
import org jruby runtime block
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import org jruby runtime builtin irubyobject
import org jruby util bytelist
/**
* @author <a href="mailto:ola.bini@ki.se">ola bini</a>
*/
public class sslsocket extends rubyobject
private static final long serialversionuid    2276327900350542644l
private static objectallocator sslsocket_allocator   new objectallocator
public irubyobject allocate ruby runtime  rubyclass klass
return new sslsocket runtime  klass
private static rubyobjectadapter api   javaembedutils newobjectadapter
public static void createsslsocket ruby runtime  rubymodule mssl
threadcontext context   runtime getcurrentcontext
rubyclass csslsocket   mssl defineclassunder   runtime getobject   sslsocket_allocator
csslsocket addreadwriteattribute context
csslsocket addreadwriteattribute context
csslsocket addreadwriteattribute context
csslsocket definealias
csslsocket defineannotatedmethods sslsocket class
public sslsocket ruby runtime  rubyclass type
super runtime type
verifyresult   x509utils v_ok
public static raiseexception newsslerror ruby runtime  string message
return utils newerror runtime     message  false
private org jruby ext openssl sslcontext rubyctx
private sslengine engine
private rubyio io   null
private bytebuffer peerappdata
private bytebuffer peernetdata
private bytebuffer netdata
private bytebuffer dummy
private boolean initialhandshake   false
private sslengineresult handshakestatus hsstatus
private sslengineresult status status   null
int verifyresult
@jrubymethod name      rest   true  frame   true
public irubyobject _initialize irubyobject args  block unused
if  arity checkargumentcount getruntime    args  1  2     1
rubyclass sslcontext   utils getclassfrompath getruntime
rubyctx    org jruby ext openssl sslcontext  api callmethod sslcontext
else
rubyctx    org jruby ext openssl sslcontext  args
utils checkkind getruntime    args
io    rubyio  args
api callmethod this     io
// this is a bit of a hack: sslsocket should share code with rubybasicsocket, which always sets sync to true.
// instead we set it here for now.
api callmethod io     getruntime   gettrue
api callmethod this     rubyctx
api callmethod this     getruntime   getfalse
rubyctx setup
return api callsuper this  args
private void ossl_ssl_setup   throws nosuchalgorithmexception  keymanagementexception  ioexception
if null    engine
socket socket   getsocketchannel   socket
string peerhost   socket getinetaddress   gethostname
int peerport   socket getport
engine   rubyctx createsslengine peerhost  peerport
sslsession session   engine getsession
peernetdata   bytebuffer allocate session getpacketbuffersize
peerappdata   bytebuffer allocate session getapplicationbuffersize
netdata   bytebuffer allocate session getpacketbuffersize
peernetdata limit 0
peerappdata limit 0
netdata limit 0
dummy   bytebuffer allocate 0
@jrubymethod
public irubyobject connect threadcontext context
ruby runtime   context getruntime
if   rubyctx isprotocolforclient
throw newsslerror runtime
try
ossl_ssl_setup
engine setuseclientmode true
engine beginhandshake
hsstatus   engine gethandshakestatus
initialhandshake   true
dohandshake
catch sslhandshakeexception e
// unlike server side, client should close outbound channel even if
// we have remaining data to be sent.
forceclose
throwable v   e
while v getcause      null     v instanceof sslhandshakeexception
v   v getcause
throw ssl newsslerror runtime  v
catch  nosuchalgorithmexception ex
forceclose
throw ssl newsslerror runtime  ex
catch  keymanagementexception ex
forceclose
throw ssl newsslerror runtime  ex
catch  ioexception ex
forceclose
throw ssl newsslerror runtime  ex
return this
@jrubymethod
public irubyobject accept threadcontext context
ruby runtime   context getruntime
if   rubyctx isprotocolforserver
throw newsslerror runtime
try
int vfy   0
ossl_ssl_setup
engine setuseclientmode false
if  rubyctx isnil       rubyctx callmethod context    isnil
vfy   rubynumeric fix2int rubyctx callmethod context
if vfy    0      verify_none
engine setneedclientauth false
engine setwantclientauth false
if  vfy   1     0      verify_peer
engine setwantclientauth true
if  vfy   2     0      verify_fail_if_no_peer_cert
engine setneedclientauth true
engine beginhandshake
hsstatus   engine gethandshakestatus
initialhandshake   true
dohandshake
catch sslhandshakeexception e
throw ssl newsslerror runtime  e
catch  nosuchalgorithmexception ex
throw ssl newsslerror runtime  ex
catch  keymanagementexception ex
throw ssl newsslerror runtime  ex
catch  ioexception ex
throw ssl newsslerror runtime  ex
return this
@jrubymethod
public irubyobject verify_result
if  engine    null
getruntime   getwarnings   warn
return getruntime   getnil
return getruntime   newfixnum verifyresult
// this select impl is a copy of rubythread.select, then blockinglock is
// removed. this impl just set
// selectablechannel.configureblocking(false) permanently instead of setting
// temporarily. sslsocket requires wrapping io to be selectable so it should
// be ok to set configureblocking(false) permanently.
private void waitselect int operations  throws ioexception
if    io getchannel   instanceof selectablechannel
return
ruby runtime   getruntime
rubythread thread   runtime getcurrentcontext   getthread
selectablechannel selectable    selectablechannel io getchannel
boolean oldblocking   selectable isblocking
selectable configureblocking false
try
io addblockingthread thread
thread select selectable  io  operations
// check for thread events, in case we've been woken up to die
thread pollthreadevents
finally
// remove this thread as a blocker against the given io
io removeblockingthread thread
selectable configureblocking oldblocking
private void dohandshake   throws ioexception
while  true
sslengineresult res
waitselect selectionkey op_read   selectionkey op_write
if hsstatus    sslengineresult handshakestatus finished
if  initialhandshake
finishinitialhandshake
return
else if hsstatus    sslengineresult handshakestatus need_task
dotasks
else if hsstatus    sslengineresult handshakestatus need_unwrap
if readandunwrap       1    hsstatus    sslengineresult handshakestatus finished
throw new sslhandshakeexception
// during initialhandshake, calling readandunwrap that results underflow
// does not mean writable. we explicitly wait for readable channel to avoid
// busy loop.
if  initialhandshake    status    sslengineresult status buffer_underflow
waitselect selectionkey op_read
else if hsstatus    sslengineresult handshakestatus need_wrap
if  netdata hasremaining
while flushdata
netdata clear
res   engine wrap dummy  netdata
hsstatus   res gethandshakestatus
netdata flip
flushdata
else
assert false
return
private void dotasks
runnable task
while   task   engine getdelegatedtask       null
task run
hsstatus   engine gethandshakestatus
verifyresult   rubyctx getlastverifyresult
private boolean flushdata   throws ioexception
try
writetochannel netdata
catch  ioexception ioe
netdata position netdata limit
throw ioe
if  netdata hasremaining
return false
else
return true
private int writetochannel bytebuffer buffer  throws ioexception
int totalwritten   0
while  buffer hasremaining
totalwritten    getsocketchannel   write buffer
return totalwritten
private void finishinitialhandshake
initialhandshake   false
public int write bytebuffer src  throws sslexception  ioexception
if initialhandshake
throw new ioexception
if netdata hasremaining
// todo; remove
// this protect should be propagated from
// http://www.javadocexamples.com/java_source/ssl/sslchannel.java.html
// to avoid io selecting problem under mt.
// we have different model of selecting so it's safe to be removed i think.
throw new ioexception
netdata clear
sslengineresult res   engine wrap src  netdata
netdata flip
flushdata
return res bytesconsumed
public int read bytebuffer dst  throws ioexception
if initialhandshake
return 0
if  engine isinbounddone
return  1
if   peerappdata hasremaining
int appbytesproduced   readandunwrap
if  appbytesproduced     1    appbytesproduced    0
return appbytesproduced
int limit   math min peerappdata remaining    dst remaining
peerappdata get dst array    dst arrayoffset    limit
dst position dst arrayoffset     limit
return limit
private int readandunwrap   throws ioexception
int bytesread   getsocketchannel   read peernetdata
if  bytesread     1
if   peernetdata hasremaining       status    sslengineresult status buffer_underflow
closeinbound
return  1
// inbound channel has been already closed but closeinbound() must
// be defered till the last engine.unwrap() call.
// peernetdata could not be empty.
peerappdata clear
peernetdata flip
sslengineresult res
do
res   engine unwrap peernetdata  peerappdata
while  res getstatus      sslengineresult status ok
res gethandshakestatus      sslengineresult handshakestatus need_unwrap
res bytesproduced      0
if res gethandshakestatus      sslengineresult handshakestatus finished
finishinitialhandshake
if peerappdata position      0
res getstatus      sslengineresult status ok
peernetdata hasremaining
res   engine unwrap peernetdata  peerappdata
status   res getstatus
hsstatus   res gethandshakestatus
if  bytesread     1     peernetdata hasremaining
// now it's safe to call closeinbound().
closeinbound
if status    sslengineresult status closed
doshutdown
return  1
peernetdata compact
peerappdata flip
if  initialhandshake     hsstatus    sslengineresult handshakestatus need_task
hsstatus    sslengineresult handshakestatus need_wrap
hsstatus    sslengineresult handshakestatus finished
dohandshake
return peerappdata remaining
private void closeinbound
try
engine closeinbound
catch  sslexception ssle
// ignore any error on close. possibly an error like this;
// inbound closed before receiving peer's close_notify: possible truncation attack?
private void doshutdown   throws ioexception
if  engine isoutbounddone
return
netdata clear
try
engine wrap dummy  netdata
catch exception e1
return
netdata flip
flushdata
@jrubymethod rest   true  required   1  optional   1
public irubyobject sysread threadcontext context  irubyobject args
ruby runtime   context getruntime
int len   rubynumeric fix2int args
rubystring str   null
if  args length    2     args isnil
str   args converttostring
else
str   getruntime   newstring
if len    0
str clear
return str
if  len < 0
throw runtime newargumenterror
try
// so we need to make sure to only block when there is no data left to process
if engine    null      peerappdata hasremaining      peernetdata position   > 0
waitselect selectionkey op_read
bytebuffer dst   bytebuffer allocate len
int rr    1
// ensure >0 bytes read; sysread is blocking read.
while  rr <  0
if  engine    null
rr   getsocketchannel   read dst
else
rr   read dst
if  rr     1
throw getruntime   neweoferror
byte bss   new byte
dst position dst position     rr
dst get bss
str setvalue new bytelist bss
return str
catch  ioexception ioe
throw getruntime   newioerror ioe getmessage
@jrubymethod
public irubyobject syswrite threadcontext context  irubyobject arg
ruby runtime   context getruntime
try
checkclosed
waitselect selectionkey op_write
byte bls   arg converttostring   getbytes
bytebuffer b1   bytebuffer wrap bls
int written
if engine    null
written   writetochannel b1
else
written   write b1
rubyio api callmethod this     flush
return getruntime   newfixnum written
catch  ioexception ioe
throw runtime newioerror ioe getmessage
private void checkclosed
if   getsocketchannel   isopen
throw getruntime   newioerror
// do shutdown even if we have remaining data to be sent.
// call this when you get an exception from client side.
private void forceclose
close true
private void close boolean force
if  engine    null  throw getruntime   neweoferror
engine closeoutbound
if   force    netdata hasremaining
return
else
try
doshutdown
catch  ioexception ex
// ignore?
@jrubymethod
public irubyobject sysclose
// no need to try shutdown when it's a server
close rubyctx isprotocolforclient
threadcontext tc   getruntime   getcurrentcontext
if callmethod tc    istrue
callmethod tc    callmethod tc
return getruntime   getnil
@jrubymethod
public irubyobject cert
try
certificate cert   engine getsession   getlocalcertificates
if  cert length > 0
return x509cert wrap getruntime    cert
catch  certificateencodingexception ex
throw x509cert newcertificateerror getruntime    ex
return getruntime   getnil
@jrubymethod
public irubyobject peer_cert
try
certificate cert   engine getsession   getpeercertificates
if  cert length > 0
return x509cert wrap getruntime    cert
catch  certificateencodingexception ex
throw x509cert newcertificateerror getruntime    ex
catch  sslpeerunverifiedexception ex
if  getruntime   isverbose
getruntime   getwarnings   warning string format    ex getclass   getname    ex getmessage
return getruntime   getnil
@jrubymethod
public irubyobject peer_cert_chain
try
javax security cert certificate certs   engine getsession   getpeercertificatechain
rubyarray arr   getruntime   newarray certs length
for int i   0   i < certs length  i
arr add x509cert wrap getruntime    certs
return arr
catch  javax security cert certificateencodingexception e
throw x509cert newcertificateerror getruntime    e
catch  sslpeerunverifiedexception ex
if  getruntime   isverbose
getruntime   getwarnings   warning string format    ex getclass   getname    ex getmessage
return getruntime   getnil
@jrubymethod
public irubyobject cipher
return getruntime   newstring engine getsession   getciphersuite
@jrubymethod
public irubyobject state
system err println
return getruntime   getnil
@jrubymethod
public irubyobject pending
system err println
return getruntime   getnil
private socketchannel getsocketchannel
return  socketchannel  io getchannel
sslsocket