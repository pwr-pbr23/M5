/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2002 benoit cerrina <b.cerrina@wanadoo.fr>
* copyright (c) 2002-2004 jan arne petersen <jpetersen@uni-bonn.de>
* copyright (c) 2002-2004 anders bengtsson <ndrsbngtssn@yahoo.se>
* copyright (c) 2003 joey gibson <joey@joeygibson.com>
* copyright (c) 2004-2007 thomas e enebo <enebo@acm.org>
* copyright (c) 2004-2007 charles o nutter <headius@headius.com>
* copyright (c) 2004 stefan matthias aust <sma@3plus4.de>
* copyright (c) 2006 miguel covarrubias <mlcovarrubias@gmail.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby
import jnr constants platform openflags
import org jcodings encoding
import org jruby util io modeflags
import org jruby util io openfile
import org jruby util io channeldescriptor
import java io file
import java io filenotfoundexception
import java io ioexception
import java io inputstream
import java io reader
import java net uri
import java net url
import java nio channels channels
import java nio channels filechannel
import java nio channels filelock
import java util enumeration
import java util regex matcher
import java util regex pattern
import java util zip zipentry
import java util zip zipfile
import org jcodings specific asciiencoding
import org jruby anno jrubyclass
import org jruby anno jrubymethod
import org jruby anno jrubymodule
import jnr posix filestat
import jnr posix util platform
import org jruby runtime block
import org jruby runtime classindex
import org jruby runtime objectallocator
import org jruby runtime threadcontext
import static org jruby runtime visibility
import org jruby runtime builtin irubyobject
import org jruby runtime encoding encodingcapable
import org jruby util bytelist
import org jruby util io directoryasfileexception
import org jruby util io permissiondeniedexception
import org jruby util io stream
import org jruby util io channelstream
import org jruby util io iooptions
import org jruby util fileresource
import org jruby util jrubyfile
import org jruby util typeconverter
import org jruby util io baddescriptorexception
import org jruby util io fileexistsexception
import org jruby util io invalidvalueexception
import org jruby util io pipeexception
import static org jruby compatversion
/**
* ruby file class equivalent in java.
**/
@jrubyclass name    parent    include
public class rubyfile extends rubyio implements encodingcapable
public static rubyclass createfileclass ruby runtime
threadcontext context   runtime getcurrentcontext
rubyclass fileclass   runtime defineclass    runtime getio    file_allocator
runtime setfile fileclass
fileclass defineannotatedmethods rubyfile class
fileclass index   classindex file
fileclass setreifiedclass rubyfile class
fileclass kindof   new rubymodule kindof
@override
public boolean iskindof irubyobject obj  rubymodule type
return obj instanceof rubyfile
// file separator constants
rubystring separator   runtime newstring
separator freeze context
fileclass defineconstant    separator
fileclass defineconstant    separator
if  file separatorchar
rubystring altseparator   runtime newstring
altseparator freeze context
fileclass defineconstant    altseparator
else
fileclass defineconstant    runtime getnil
// path separator
rubystring pathseparator   runtime newstring file pathseparator
pathseparator freeze context
fileclass defineconstant    pathseparator
// for jruby-5276, physically define filetest methods on file's singleton
fileclass getsingletonclass   defineannotatedmethods rubyfiletest filetestfilemethods class
// create constants class
rubymodule constants   fileclass definemoduleunder
// open flags
for  openflags f   openflags values
// strip off the o_ prefix, so they become file::rdonly, and so on
final string name   f name
if  name startswith
final string cname   name substring 2
// special case for handling accmode, since constantine will generate
// an invalid value if it is not defined by the platform.
final rubyfixnum cvalue   f    openflags o_accmode
? runtime newfixnum modeflags accmode
runtime newfixnum f intvalue
constants setconstant cname  cvalue
// case handling, escaping, path and dot matching
constants setconstant    runtime newfixnum fnm_noescape
constants setconstant    runtime newfixnum fnm_casefold
constants setconstant    runtime newfixnum fnm_syscase
constants setconstant    runtime newfixnum fnm_dotmatch
constants setconstant    runtime newfixnum fnm_pathname
// flock operations
constants setconstant    runtime newfixnum rubyfile lock_sh
constants setconstant    runtime newfixnum rubyfile lock_ex
constants setconstant    runtime newfixnum rubyfile lock_nb
constants setconstant    runtime newfixnum rubyfile lock_un
// file::constants module is included in io.
runtime getio   includemodule constants
return fileclass
private static objectallocator file_allocator   new objectallocator
public irubyobject allocate ruby runtime  rubyclass klass
rubyfile instance   new rubyfile runtime  klass
instance setmetaclass klass
return instance
public rubyfile ruby runtime  rubyclass type
super runtime  type
// xxx this constructor is a hack to implement the __end__ syntax.
//     converting a reader back into an inputstream doesn't generally work.
public rubyfile ruby runtime  string path  final reader reader
this runtime  path  new inputstream
public int read   throws ioexception
return reader read
public rubyfile ruby runtime  string path  inputstream in
super runtime  runtime getfile
this path   path
try
this openfile setmainstream channelstream open runtime  new channeldescriptor channels newchannel in
this openfile setmode openfile getmainstreamsafe   getmodes   getopenfileflags
catch  baddescriptorexception e
throw runtime newerrnoebadferror
catch  invalidvalueexception ex
throw runtime newerrnoeinvalerror
@jrubymethod
@override
public irubyobject close
// make sure any existing lock is released before we try and close the file
if  currentlock    null
try
currentlock release
catch  ioexception e
throw getruntime   newioerror e getmessage
return super close
@jrubymethod required   1
public irubyobject flock threadcontext context  irubyobject lockingconstant
ruby runtime   context runtime
// todo: port exact behavior from mri, and move most locking logic into channeldescriptor
// todo: for all lock_nb cases, return false if they would block
channeldescriptor descriptor
try
descriptor   openfile getmainstreamsafe   getdescriptor
catch  baddescriptorexception e
throw context runtime newerrnoebadferror
// null channel always succeeds for all locking operations
if  descriptor isnull    return rubyfixnum zero runtime
if  descriptor getchannel   instanceof filechannel
filechannel filechannel    filechannel descriptor getchannel
int lockmode   rubynumeric num2int lockingconstant
checksharedexclusive runtime  openfile  lockmode
if   lockstatechanges currentlock  lockmode   return rubyfixnum zero runtime
try
synchronized  filechannel
// check again, to avoid unnecessary overhead
if   lockstatechanges currentlock  lockmode   return rubyfixnum zero runtime
switch  lockmode
case lock_un
case lock_un   lock_nb
return unlock runtime
case lock_ex
return lock runtime  filechannel  true
case lock_ex   lock_nb
return trylock runtime  filechannel  true
case lock_sh
return lock runtime  filechannel  false
case lock_sh   lock_nb
return trylock runtime  filechannel  false
catch  ioexception ioe
if  runtime getdebug   istrue
ioe printstacktrace system err
catch  java nio channels overlappingfilelockexception ioe
if  runtime getdebug   istrue
ioe printstacktrace system err
return lockfailedreturn runtime  lockmode
else
// we're not actually a real file, so we can't flock
return runtime getfalse
@jrubymethod required   1  optional   2  visibility   private  compat   ruby1_8
@override
public irubyobject initialize irubyobject args  block block
if  openfile    null
throw getruntime   newruntimeerror
if  args length > 0    args length < 3
if  args instanceof rubyinteger
return super initialize args  block
return openfile args
@jrubymethod name      required   1  optional   2  visibility   private  compat   ruby1_9
public irubyobject initialize19 threadcontext context  irubyobject args  block block
if  openfile    null
throw context getruntime   newruntimeerror
if  args length > 0    args length <  3
irubyobject fd   typeconverter converttotypewithcheck args  context getruntime   getfixnum
if   fd isnil
args   fd
if  args length    1
return super initialize19 context  args  block
else if  args length    2
return super initialize19 context  args  args  block
return super initialize19 context  args  args  args  block
return openfile19 context  args
@jrubymethod required   1
public irubyobject chmod threadcontext context  irubyobject arg
checkclosed context
int mode    int  arg converttointeger   getlongvalue
if   new file path  exists
throw context getruntime   newerrnoenoenterror path
return context getruntime   newfixnum context getruntime   getposix   chmod path  mode
@jrubymethod required   2
public irubyobject chown threadcontext context  irubyobject arg1  irubyobject arg2
checkclosed context
int owner    1
if   arg1 isnil
owner   rubynumeric num2int arg1
int group    1
if   arg2 isnil
group   rubynumeric num2int arg2
if   new file path  exists
throw context getruntime   newerrnoenoenterror path
return context getruntime   newfixnum context getruntime   getposix   chown path  owner  group
@jrubymethod
public irubyobject atime threadcontext context
checkclosed context
return context getruntime   newfilestat path  false  atime
@jrubymethod
public irubyobject ctime threadcontext context
checkclosed context
return context getruntime   newfilestat path  false  ctime
@jrubymethod required   1
public irubyobject lchmod threadcontext context  irubyobject arg
int mode    int  arg converttointeger   getlongvalue
if   new file path  exists
throw context getruntime   newerrnoenoenterror path
return context getruntime   newfixnum context getruntime   getposix   lchmod path  mode
// todo: this method is not present in mri!
@jrubymethod required   2
public irubyobject lchown threadcontext context  irubyobject arg1  irubyobject arg2
int owner    1
if   arg1 isnil
owner   rubynumeric num2int arg1
int group    1
if   arg2 isnil
group   rubynumeric num2int arg2
if   new file path  exists
throw context getruntime   newerrnoenoenterror path
return context getruntime   newfixnum context getruntime   getposix   lchown path  owner  group
@jrubymethod
public irubyobject lstat threadcontext context
checkclosed context
return context getruntime   newfilestat path  true
@jrubymethod
public irubyobject mtime threadcontext context
checkclosed context
return context getruntime   newfilestat path  false  mtime
@jrubymethod meta   true  compat   ruby1_9
public static irubyobject path threadcontext context  irubyobject self  irubyobject str
return get_path context  str
@jrubymethod name
public irubyobject path threadcontext context
irubyobject newpath   context getruntime   getnil
if  path    null
newpath   context getruntime   newstring path
newpath settaint true
return newpath
@jrubymethod
@override
public irubyobject stat threadcontext context
checkclosed context
return context getruntime   newfilestat path  false
@jrubymethod required   1
public irubyobject truncate threadcontext context  irubyobject arg
rubyinteger newlength   arg converttointeger
if  newlength getlongvalue   < 0
throw context getruntime   newerrnoeinvalerror path
try
openfile checkwritable context getruntime
openfile getmainstreamsafe   ftruncate newlength getlongvalue
catch  baddescriptorexception e
throw context getruntime   newerrnoebadferror
catch  pipeexception e
throw context getruntime   newerrnoespipeerror
catch  invalidvalueexception ex
throw context getruntime   newerrnoeinvalerror
catch  ioexception e
// should we do anything?
return rubyfixnum zero context getruntime
@jrubymethod
@override
public irubyobject inspect
stringbuilder val   new stringbuilder
val append    append path
if  openfile isopen
val append
val append
return getruntime   newstring val tostring
/* file class methods */
@jrubymethod required   1  optional   1  meta   true
public static irubyobject basename threadcontext context  irubyobject recv  irubyobject args
string name   get_path context args  getunicodevalue
// mri-compatible basename handling for windows drive letter paths
if  platform is_windows
if  name length   > 1    name charat 1          character isletter name charat 0
switch  name length
case 2
return rubystring newemptystring context getruntime    infectby args
case 3
return context getruntime   newstring name substring 2   infectby args
default
switch  name charat 2
case
case
break
default
// strip c: away from relative-pathed name
name   name substring 2
break
break
while  name length   > 1    name charat name length     1
name   name substring 0  name length     1
// paths which end in "/" or "\\" must be stripped off.
int slashcount   0
int length   name length
for  int i   length   1  i >  0  i
char c   name charat i
if  c         c
break
slashcount
if  slashcount > 0    length > 1
name   name substring 0  name length     slashcount
int index   name lastindexof
if  index     1
// xxx actually only on windows...
index   name lastindexof
if   name equals       index     1
name   name substring index   1
if  args length    2
string ext   rubystring stringvalue args  tostring
if    equals ext
index   name lastindexof
if  index > 0         1 no match  0 it is dot file not extension
name   name substring 0  index
else if  name endswith ext
name   name substring 0  name length     ext length
return context getruntime   newstring name  infectby args
@jrubymethod required   2  rest   true  meta   true
public static irubyobject chmod threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int count   0
rubyinteger mode   args converttointeger
for  int i   1  i < args length  i
jrubyfile filename   file args
if   filename exists
throw runtime newerrnoenoenterror filename tostring
boolean result   0    runtime getposix   chmod filename getabsolutepath     int mode getlongvalue
if  result
count
return runtime newfixnum count
@jrubymethod required   3  rest   true  meta   true
public static irubyobject chown threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int count   0
int owner    1
if   args isnil
owner   rubynumeric num2int args
int group    1
if   args isnil
group   rubynumeric num2int args
for  int i   2  i < args length  i
jrubyfile filename   file args
if   filename exists
throw runtime newerrnoenoenterror filename tostring
boolean result   0    runtime getposix   chown filename getabsolutepath    owner  group
if  result
count
return runtime newfixnum count
@jrubymethod required   1  meta   true
public static irubyobject dirname threadcontext context  irubyobject recv  irubyobject arg
rubystring filename   get_path context  arg
string jfilename   filename asjavastring
string name   jfilename replace
int minpathlength   1
boolean trimmedslashes   false
boolean startswithdriveletteronwindows   startswithdriveletteronwindows name
if  startswithdriveletteronwindows
minpathlength   3
while  name length   > minpathlength    name charat name length     1
trimmedslashes   true
name   name substring 0  name length     1
string result
if  startswithdriveletteronwindows    name length      2
if  trimmedslashes
// c:\ is returned unchanged
result   jfilename substring 0  3
else
result   jfilename substring 0  2
else
//todo deal with unc names
int index   name lastindexof
if  index     1
if  startswithdriveletteronwindows
return context getruntime   newstring jfilename substring 0  2
else
return context getruntime   newstring
if  index    0  return context getruntime   newstring
if  startswithdriveletteronwindows    index    2
// include additional path separator
// (so that dirname of "c:\file.txt" is  "c:\", not "c:")
index
result   jfilename substring 0  index
char endchar
// trim trailing slashes
while  result length   > minpathlength
endchar   result charat result length     1
if  endchar         endchar
result   result substring 0  result length     1
else
break
return context getruntime   newstring result  infectby filename
/**
* returns the extension name of the file. an empty string is returned if
* the filename (not the entire path) starts or ends with a dot.
* @param recv
* @param arg path to get extension name of
* @return extension, including the dot, or an empty string
*/
@jrubymethod required   1  meta   true
public static irubyobject extname threadcontext context  irubyobject recv  irubyobject arg
irubyobject basefilename   basename context  recv  new irubyobject arg
string filename   rubystring stringvalue basefilename  getunicodevalue
string result
int dotindex   filename lastindexof
if  dotindex > 0    dotindex     filename length     1
// dot is not at beginning and not at end of filename.
result   filename substring dotindex
return context getruntime   newstring result
/**
* converts a pathname to an absolute pathname. relative paths are
* referenced from the current working directory of the process unless
* a second argument is given, in which case it will be used as the
* starting point. if the second argument is also relative, it will
* first be converted to an absolute pathname.
* @param recv
* @param args
* @return resulting absolute path as a string
*/
@jrubymethod required   1  optional   1  meta   true  compat   compatversion ruby1_8
public static irubyobject expand_path threadcontext context  irubyobject recv  irubyobject args
return expandpathinternal context  recv  args  true
@jrubymethod name      required   1  optional   1  meta   true  compat   compatversion ruby1_9
public static irubyobject expand_path19 threadcontext context  irubyobject recv  irubyobject args
rubystring path    rubystring  expandpathinternal context  recv  args  true
path force_encoding context  context getruntime   getencodingservice   getdefaultexternal
return path
/**
* ---------------------------------------------------- file::absolute_path
*      file.absolute_path(file_name [, dir_string] ) -> abs_file_name
*
*      from ruby 1.9.1
* ------------------------------------------------------------------------
*      converts a pathname to an absolute pathname. relative paths are
*      referenced from the current working directory of the process unless
*      _dir_string_ is given, in which case it will be used as the
*      starting point. if the given pathname starts with a ``+~+'' it is
*      not expanded, it is treated as a normal directory name.
*
*         file.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"
*
* @param context
* @param recv
* @param args
* @return
*/
@jrubymethod required   1  optional   1  meta   true  compat   ruby1_9
public static irubyobject absolute_path threadcontext context  irubyobject recv  irubyobject args
return expandpathinternal context  recv  args  false
@jrubymethod name        required   1  optional   1  meta   true  compat   ruby1_9
public static irubyobject realdirpath threadcontext context  irubyobject recv  irubyobject args
return expandpathinternal context  recv  args  false
@jrubymethod name        required   1  optional   1  meta   true  compat   ruby1_9
public static irubyobject realpath threadcontext context  irubyobject recv  irubyobject args
irubyobject file   expandpathinternal context  recv  args  false
if   rubyfiletest exist_p recv  file  istrue
throw context getruntime   newerrnoenoenterror file tostring
return file
/**
* returns true if path matches against pattern the pattern is not a regular expression;
* instead it follows rules similar to shell filename globbing. it may contain the following
* metacharacters:
*   *:  glob - match any sequence chars (re: .*).  if like begins with '.' then it doesn't.
*   ?:  matches a single char (re: .).
*   [set]:  matches a single char in a set (re: [...]).
*
*/
@jrubymethod name           required   2  optional   1  meta   true
public static irubyobject fnmatch threadcontext context  irubyobject recv  irubyobject args
int flags   args length    3 ? rubynumeric num2int args    0
bytelist pattern   args converttostring   getbytelist
bytelist path   get_path context  args  getbytelist
if  org jruby util dir fnmatch pattern getunsafebytes    pattern getbegin    pattern getbegin   pattern getrealsize    path getunsafebytes    path getbegin    path getbegin   path getrealsize    flags     0
return context getruntime   gettrue
return context getruntime   getfalse
@jrubymethod name      required   1  meta   true
public static irubyobject ftype threadcontext context  irubyobject recv  irubyobject filename
return context getruntime   newfilestat get_path context  filename  getunicodevalue    true  ftype
/*
* fixme:  this does not have exact same semantics as rubyarray.join, but they
* probably could be consolidated (perhaps as join(args[], sep, dochomp)).
*/
@jrubymethod rest   true  meta   true
public static rubystring join threadcontext context  irubyobject recv  irubyobject args
return join context  recv  rubyarray newarraynocopylight context getruntime    args
@jrubymethod name      required   1  meta   true
public static irubyobject lstat threadcontext context  irubyobject recv  irubyobject filename
string f   get_path context  filename  getunicodevalue
return context getruntime   newfilestat f  true
@jrubymethod name      required   1  meta   true
public static irubyobject stat threadcontext context  irubyobject recv  irubyobject filename
string f   get_path context  filename  getunicodevalue
return context getruntime   newfilestat f  false
@jrubymethod name      required   1  meta   true
public static irubyobject atime threadcontext context  irubyobject recv  irubyobject filename
string f   get_path context  filename  getunicodevalue
return context getruntime   newfilestat f  false  atime
@jrubymethod name      required   1  meta   true
public static irubyobject ctime threadcontext context  irubyobject recv  irubyobject filename
string f   get_path context  filename  getunicodevalue
return context getruntime   newfilestat f  false  ctime
@jrubymethod required   2  rest   true  meta   true
public static irubyobject lchmod threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int count   0
rubyinteger mode   args converttointeger
for  int i   1  i < args length  i
rubystring filename   get_path context  args
if   rubyfiletest exist_p filename  filename  istrue
throw runtime newerrnoenoenterror filename tostring
boolean result   0    runtime getposix   lchmod filename getunicodevalue     int mode getlongvalue
if  result
count
return runtime newfixnum count
@jrubymethod required   2  rest   true  meta   true
public static irubyobject lchown threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int owner    args isnil   ? rubynumeric num2int args     1
int group    args isnil   ? rubynumeric num2int args     1
int count   0
for  int i   2  i < args length  i
irubyobject filename   args
if  0    runtime getposix   lchown filename tostring    owner  group
throw runtime newerrnofromlastposixerrno
else
count
return runtime newfixnum count
@jrubymethod required   2  meta   true
public static irubyobject link threadcontext context  irubyobject recv  irubyobject from  irubyobject to
ruby runtime   context getruntime
rubystring fromstr   rubystring stringvalue from
rubystring tostr   rubystring stringvalue to
int ret   runtime getposix   link fromstr getunicodevalue    tostr getunicodevalue
if  ret    0
// in most cases, when there is an error during the call,
// the posix handler throws an exception, but not in case
// with pure java posix layer (when native support is disabled),
// so we deal with it like this:
throw runtime newerrnoeexisterror fromstr       tostr
return runtime newfixnum ret
@jrubymethod name      required   1  meta   true
public static irubyobject mtime threadcontext context  irubyobject recv  irubyobject filename
return context getruntime   newfilestat get_path context  filename  getunicodevalue    false  mtime
@jrubymethod required   2  meta   true
public static irubyobject rename threadcontext context  irubyobject recv  irubyobject oldname  irubyobject newname
ruby runtime   context getruntime
rubystring oldnamestring   rubystring stringvalue oldname
rubystring newnamestring   rubystring stringvalue newname
runtime checksafestring oldnamestring
runtime checksafestring newnamestring
string newnamejavastring   newnamestring getunicodevalue
string oldnamejavastring   oldnamestring getunicodevalue
jrubyfile oldfile   jrubyfile create runtime getcurrentdirectory    oldnamejavastring
jrubyfile newfile   jrubyfile create runtime getcurrentdirectory    newnamejavastring
if   oldfile exists       newfile getparentfile   exists
throw runtime newerrnoenoenterror oldnamejavastring       newnamejavastring
jrubyfile dest   jrubyfile create runtime getcurrentdirectory    newnamejavastring
if  oldfile renameto dest         rename is successful
return rubyfixnum zero runtime
// rename via java api call wasn't successful, let's try some tricks, similar to mri
if  newfile exists
runtime getposix   chmod newnamejavastring  0666
newfile delete
if  oldfile renameto dest        try to rename one more time
return rubyfixnum zero runtime
throw runtime newerrnoeacceserror oldnamejavastring       newnamejavastring
@jrubymethod required   1  meta   true
public static rubyarray split threadcontext context  irubyobject recv  irubyobject arg
rubystring filename   get_path context  arg
return context getruntime   newarray dirname context  recv  filename
basename context  recv  new irubyobject   filename
@jrubymethod required   2  meta   true
public static irubyobject symlink threadcontext context  irubyobject recv  irubyobject from  irubyobject to
ruby runtime   context getruntime
rubystring fromstr   get_path context  from
rubystring tostr   get_path context  to
string tovalue   tostr getunicodevalue
tovalue   jrubyfile create runtime getcurrentdirectory    tovalue  getabsolutepath
try
if  runtime getposix   symlink
fromstr getunicodevalue    tovalue      1
// fixme: when we get jna3 we need to properly write this to errno.
throw runtime newerrnoeexisterror fromstr       tostr
catch  java lang unsatisfiedlinkerror ule
throw runtime newnotimplementederror
return runtime newfixnum 0
@jrubymethod required   1  meta   true
public static irubyobject readlink threadcontext context  irubyobject recv  irubyobject path
ruby runtime   context getruntime
try
string realpath   runtime getposix   readlink path converttostring   getunicodevalue
if   rubyfiletest exist_p recv  path  istrue
throw runtime newerrnoenoenterror path tostring
if   rubyfiletest symlink_p recv  path  istrue
throw runtime newerrnoeinvalerror path tostring
if  realpath    null
//fixme: when we get jna3 we need to properly write this to errno.
return runtime newstring realpath
catch  ioexception e
throw runtime newioerror e getmessage
// can we produce ioerror which bypasses a close?
@jrubymethod required   2  meta   true  compat   ruby1_8
public static irubyobject truncate threadcontext context  irubyobject recv  irubyobject arg1  irubyobject arg2
return truncatecommon context  recv  arg1  arg2
@jrubymethod name      required   2  meta   true  compat   ruby1_9
public static irubyobject truncate19 threadcontext context  irubyobject recv  irubyobject arg1  irubyobject arg2
if    arg1 instanceof rubystring     arg1 respondsto
arg1   arg1 callmethod context
return truncatecommon context  recv  arg1  arg2
@jrubymethod meta   true  optional   1
public static irubyobject umask threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
int oldmask   0
if  args length    0
oldmask   getumasksafe  runtime
else if  args length    1
int newmask    int  args converttointeger   getlongvalue
synchronized  _umasklock
oldmask   runtime getposix   umask newmask
_cachedumask   newmask
else
runtime newargumenterror
return runtime newfixnum oldmask
@jrubymethod required   2  rest   true  meta   true
public static irubyobject utime threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
long atimeval   null
long mtimeval   null
if  args    runtime getnil      args    runtime getnil
atimeval   extracttimeval runtime  args
mtimeval   extracttimeval runtime  args
for  int i   2  j   args length  i < j  i
rubystring filename   get_path context  args
runtime checksafestring filename
jrubyfile filetotouch   jrubyfile create runtime getcurrentdirectory   filename getunicodevalue
if   filetotouch exists
throw runtime newerrnoenoenterror filename tostring
runtime getposix   utimes filetotouch getabsolutepath    atimeval  mtimeval
return runtime newfixnum args length   2
@jrubymethod name           rest   true  meta   true
public static irubyobject unlink threadcontext context  irubyobject recv  irubyobject args
ruby runtime   context getruntime
for  int i   0  i < args length  i
rubystring filename   get_path context  args
runtime checksafestring filename
jrubyfile ltodelete   jrubyfile create runtime getcurrentdirectory    filename getunicodevalue
boolean issymlink   rubyfiletest symlink_p recv  filename  istrue
// broken symlinks considered by exists() as non-existing,
// so we need to check for symlinks explicitly.
if   ltodelete exists       issymlink
throw runtime newerrnoenoenterror filename getunicodevalue
if  ltodelete isdirectory       issymlink
throw runtime newerrnoepermerror filename getunicodevalue
if   ltodelete delete
throw runtime newerrnoeacceserror filename getunicodevalue
return runtime newfixnum args length
@jrubymethod name      compat   ruby1_9
public irubyobject size threadcontext context
ruby runtime   context getruntime
if   openfile getmode     openfile writable     0
flush
try
filestat stat   runtime getposix   fstat
getopenfilechecked   getmainstreamsafe   getdescriptor   getfiledescriptor
if  stat    null
throw runtime newerrnoeacceserror path
return runtime newfixnum stat st_size
catch  baddescriptorexception e
throw runtime newerrnoebadferror
public string getpath
return path
public encoding getencoding
return null
public void setencoding encoding encoding
// :)
private irubyobject openfile19 threadcontext context  irubyobject args
ruby runtime   context getruntime
rubystring filename   get_path context  args
runtime checksafestring filename
path   adjustrootpathonwindows runtime  filename asjavastring    runtime getcurrentdirectory
string modestring
iooptions modes   newiooptions runtime  modestring
rubyhash options   null
int perm   0
if  args length > 1
if  args instanceof rubyhash
options    rubyhash args
else
modes   parseiooptions19 args
if  args instanceof rubyfixnum
perm   rubynumeric num2int args
else
modestring   args converttostring   tostring
else
modes   parseiooptions19 rubystring newstring runtime  modestring
if  args length > 2     args isnil
if  args instanceof rubyhash
options    rubyhash args
else
perm   getfilepermissions args
if  perm > 0
sysopeninternal19 context  path  options  modes  perm
else
openinternal19 context  path  options  modestring  modes
return this
private irubyobject openfile irubyobject args
ruby runtime   getruntime
rubystring filename   get_path runtime getcurrentcontext    args
runtime checksafestring filename
path   adjustrootpathonwindows runtime  filename asjavastring    runtime getcurrentdirectory
string modestring
iooptions modes
int perm
if   args length > 1    args instanceof rubyfixnum      args length > 2     args isnil
modes   parseiooptions args
perm   getfilepermissions args
sysopeninternal path  modes getmodeflags    perm
else
modestring
if  args length > 1     args isnil
modestring   args converttostring   tostring
openinternal path  modestring
return this
private int getfilepermissions irubyobject args
return  args length > 2     args isnil    ? rubynumeric num2int args    438
protected void sysopeninternal19 threadcontext context  string path  rubyhash options  iooptions iooptions  int perm
iooptions   updateiooptionsfromoptions context  options  iooptions
sysopeninternal path  iooptions getmodeflags    perm
setencodingfromoptions iooptions getencodingoption
protected void sysopeninternal string path  modeflags modes  int perm
openfile   new openfile
openfile setpath path
openfile setmode modes getopenfileflags
if  modes isbinary    externalencoding   asciiencoding instance
int umask   getumasksafe  getruntime
perm   perm    perm   umask
channeldescriptor descriptor   sysopen path  modes  perm
openfile setmainstream fdopen descriptor  modes
protected void openinternal19 threadcontext context  string path  rubyhash options  string modestring  iooptions iooptions
iooptions   updateiooptionsfromoptions context  options  iooptions
openinternal path  modestring  iooptions getmodeflags
setencodingfromoptions iooptions getencodingoption
protected void openinternal string path  string modestring  modeflags modes
if  path startswith
path   path substring 4
openfile   new openfile
openfile setmode modes getopenfileflags
if  modes isbinary    externalencoding   asciiencoding instance
openfile setpath path
openfile setmainstream fopen path  modestring
protected void openinternal string path  string modestring
if  path startswith
path   path substring 4
openfile   new openfile
iooptions modes   newiooptions getruntime    modestring
openfile setmode modes getmodeflags   getopenfileflags
if  modes getmodeflags   isbinary    externalencoding   asciiencoding instance
openfile setpath path
openfile setmainstream fopen path  modestring
private channeldescriptor sysopen string path  modeflags modes  int perm
try
channeldescriptor descriptor   channeldescriptor open
getruntime   getcurrentdirectory
path
modes
perm
getruntime   getposix
getruntime   getjrubyclassloader
// todo: check if too many open files, gc and try again
return descriptor
catch  permissiondeniedexception pde
// pdexception can be thrown only when creating the file and
// permission is denied.  see javadoc of permissiondeniedexception.
throw getruntime   newerrnoeacceserror path
catch  filenotfoundexception fnfe
// fnfexception can be thrown in both cases, when the file
// is not found, or when permission is denied.
if  ruby issecurityrestricted      new file path  exists
throw getruntime   newerrnoeacceserror path
throw getruntime   newerrnoenoenterror path
catch  directoryasfileexception dafe
throw getruntime   newerrnoeisdirerror
catch  fileexistsexception fee
throw getruntime   newerrnoeexisterror path
catch  ioexception ioe
throw getruntime   newioerrorfromexception ioe
private stream fopen string path  string modestring
try
stream stream   channelstream fopen
getruntime
path
newmodeflags getruntime    modestring
if  stream    null
// todo
//            if (errno == emfile || errno == enfile) {
//                rb_gc();
//                file = fopen(fname, mode);
//            }
//            if (!file) {
//                rb_sys_fail(fname);
//            }
// do we need to be in setvbuf mode for buffering to make sense? this comes up elsewhere.
//    #ifdef use_setvbuf
//        if (setvbuf(file, null, _iofbf, 0) != 0)
//            rb_warn("setvbuf() can't be honoured for %s", fname);
//    #endif
//    #ifdef __human68k__
//        fmode(file, _iotext);
//    #endif
return stream
catch  baddescriptorexception e
throw getruntime   newerrnoebadferror
catch  permissiondeniedexception pde
// pdexception can be thrown only when creating the file and
// permission is denied.  see javadoc of permissiondeniedexception.
throw getruntime   newerrnoeacceserror path
catch  filenotfoundexception ex
// fnfexception can be thrown in both cases, when the file
// is not found, or when permission is denied.
if  ruby issecurityrestricted      new file path  exists
throw getruntime   newerrnoeacceserror path
throw getruntime   newerrnoenoenterror path
catch  directoryasfileexception ex
throw getruntime   newerrnoeisdirerror
catch  fileexistsexception ex
throw getruntime   newerrnoeexisterror path
catch  ioexception ex
throw getruntime   newioerrorfromexception ex
catch  invalidvalueexception ex
throw getruntime   newerrnoeinvalerror
catch  pipeexception ex
throw getruntime   newerrnoepipeerror
catch  securityexception ex
throw getruntime   newerrnoeacceserror path
/**
* similar in spirit to rb_get_path from 1.9 source
* @param context
* @param obj
* @return
*/
public static rubystring get_path threadcontext context  irubyobject obj
if  context getruntime   is1_9
if  obj instanceof rubystring
return  rubystring obj
if  obj respondsto
obj   obj callmethod context
return obj converttostring
/**
* get the fully-qualified jrubyfile object for the path, taking into
* account the runtime's current directory.
*/
public static jrubyfile file irubyobject pathorfile
ruby runtime   pathorfile getruntime
if  pathorfile instanceof rubyfile
return jrubyfile create runtime getcurrentdirectory      rubyfile  pathorfile  getpath
else
rubystring pathstr   get_path runtime getcurrentcontext    pathorfile
string path   pathstr asjavastring
string pathparts   splituri path
if  pathparts    null    pathparts equals
path   pathparts
return jrubyfile create runtime getcurrentdirectory    path
@override
public string tostring
try
return     path       openfile getmode         getruntime   getfileno openfile getmainstreamsafe   getdescriptor
catch  baddescriptorexception e
throw getruntime   newerrnoebadferror
public static zipentry getfileentry zipfile zf  string path  throws ioexception
zipentry entry   zf getentry path
if  entry    null
// try canonicalizing the path to eliminate . and .. (jruby-4760, jruby-4879)
string prefix   new file    getcanonicalpath
entry   zf getentry new file path  getcanonicalpath   substring prefix length     1  replaceall
return entry
public static zipentry getdirorfileentry string jar  string path  throws ioexception
string dirpath   path
zipfile zf   ruby getglobalruntime   getcurrentcontext   getruntime   getloadservice   getjarfile jar
zipentry entry   zf getentry dirpath      first try as directory
if  entry    null
// try canonicalizing the path to eliminate . and .. (jruby-4760, jruby-4879)
string prefix   new file    getcanonicalpath
entry   zf getentry new file dirpath  getcanonicalpath   substring prefix length     1  replaceall
// jruby-6119
if  entry    null
enumeration<? extends zipentry> entries   zf entries
while  entries hasmoreelements
string zipentry   entries nextelement   getname
if  zipentry startswith dirpath
return new zipentry dirpath
if  entry    null
// try as file
entry   getfileentry zf  path
return entry
private static boolean startswithdriveletteronwindows string path
return  path    null
platform is_windows
path length  >1    path charat 0        ?
path length   > 2
iswindowsdriveletter path charat 1
path charat 2
path length   > 1
iswindowsdriveletter path charat 0
path charat 1
// adjusts paths started with '/' or '\\', on windows.
static string adjustrootpathonwindows ruby runtime  string path  string dir
if  path    null     platform is_windows  return path
// mri behavior on windows: it treats '/' as a root of
// a current drive (but only if single slash is present!):
// e.g., if current work directory is
// 'd:/home/directory', then '/' means 'd:/'.
//
// basically, '/path' is treated as a *relative* path,
// relative to the current drive. '//path' is treated
// as absolute one.
if   path startswith         path length   > 2    path charat 2            path startswith
if  path length   > 1     path charat 1          path charat 1
return path
// first try to use drive letter from supplied dir value,
// then try current work dir.
if   startswithdriveletteronwindows dir
dir   runtime getcurrentdirectory
if  dir length   >  2
path   dir substring 0  2    path
else if  startswithdriveletteronwindows path     path length      2
// compensate for missing slash after drive letter on windows
path
return path
/**
* joy of posix, only way to get the umask is to set the umask,
* then set it back. that's unsafe in a threaded program. we
* minimize but may not totally remove this race by caching the
* obtained or previously set (see umask() above) umask and using
* that as the initial set value which, cross fingers, is a
* no-op. the cache access is then synchronized. todo: better?
*/
private static int getumasksafe  ruby runtime
synchronized  _umasklock
final int umask   runtime getposix   umask _cachedumask
if  _cachedumask    umask
runtime getposix   umask umask
_cachedumask   umask
return umask
/**
* extract a timeval (an array of 2 longs: seconds and microseconds from epoch) from
* an irubyobject.
*/
private static long extracttimeval ruby runtime  irubyobject value
long timeval   new long
if  value instanceof rubyfloat
timeval   platform is_32_bit ? rubynumeric num2int value    rubynumeric num2long value
double fraction     rubyfloat  value  getdoublevalue   % 1 0
timeval    long  fraction   1e6   0 5
else if  value instanceof rubynumeric
timeval   platform is_32_bit ? rubynumeric num2int value    rubynumeric num2long value
timeval   0
else
rubytime time
if  value instanceof rubytime
time     rubytime  value
else
time    rubytime  typeconverter converttotype value  runtime gettime       true
timeval   platform is_32_bit ? rubynumeric num2int time to_i      rubynumeric num2long time to_i
timeval   platform is_32_bit ? rubynumeric num2int time usec      rubynumeric num2long time usec
return timeval
private void checkclosed threadcontext context
openfile checkclosed context getruntime
private static boolean iswindowsdriveletter char c
return  c >       c <         c >       c <
private static irubyobject expandpathinternal threadcontext context  irubyobject recv  irubyobject args  boolean expanduser
ruby runtime   context getruntime
string relativepath   get_path context  args  getunicodevalue
string uriparts   splituri relativepath
string cwd   null
// handle ~user paths
if  expanduser
relativepath   expanduserpath context  relativepath
if  uriparts    null
relativepath   uriparts
// if there's a second argument, it's the path to which the first
// argument is relative.
if  args length    2     args isnil
cwd   get_path context  args  getunicodevalue
// handle ~user paths.
if  expanduser
cwd   expanduserpath context  cwd
string cwduriparts   splituri cwd
if  uriparts    null    cwduriparts    null
uriparts   cwduriparts
cwd   cwduriparts
cwd   adjustrootpathonwindows runtime  cwd  null
boolean startswithslashnotonwindows    cwd    null
platform is_windows    cwd length   > 0
cwd charat 0
// todo: better detection when path is absolute or not.
// if the path isn't absolute, then prepend the current working
// directory to the path.
if   startswithslashnotonwindows     startswithdriveletteronwindows cwd
cwd   new file runtime getcurrentdirectory    cwd  getabsolutepath
else
// if there's no second argument, simply use the working directory
// of the runtime.
cwd   runtime getcurrentdirectory
// something wrong we don't know the cwd...
// todo: is this behavior really desirable? /mov
if  cwd    null  return runtime getnil
/* the counting of slashes that follows is simply a way to adhere to
* ruby's unc (or something) compatibility. when ruby's expand_path is
* called with "//foo//bar" it will return "//foo/bar". jruby uses
* java.io.file, and hence returns "/foo/bar". in order to retain
* java.io.file in the lower layers and provide full ruby
* compatibility, the number of extra slashes must be counted and
* prepended to the result.
*/
// todo: special handling on windows for some corner cases
//        if (is_windows) {
//            if (relativepath.startswith("//")) {
//                if (relativepath.length() > 2 && relativepath.charat(2) != '/') {
//                    int nextslash = relativepath.indexof('/', 3);
//                    if (nextslash != -1) {
//                        return runtime.newstring(
//                                relativepath.substring(0, nextslash)
//                                + canonicalize(relativepath.substring(nextslash)));
//                    } else {
//                        return runtime.newstring(relativepath);
//                    }
//                }
//            }
//        }
// find out which string to check.
string padslashes
if  uriparts    null
padslashes   uriparts
else if   platform is_windows
if  relativepath length   > 0    relativepath charat 0
padslashes   countslashes relativepath
else if  cwd length   > 0    cwd charat 0
padslashes   countslashes cwd
jrubyfile path
if  relativepath length      0
path   jrubyfile create relativepath  cwd
else
relativepath   adjustrootpathonwindows runtime  relativepath  cwd
path   jrubyfile create cwd  relativepath
return runtime newstring padslashes   canonicalize path getabsolutepath
public static string splituri string path
matcher m   uri_prefix matcher path
if  m find
if  m group 2  length      0
return new string  path
string pathwithoutjarprefix
if  m group 1     null
pathwithoutjarprefix   path substring 4
else
pathwithoutjarprefix   path
try
uri u   new uri pathwithoutjarprefix
string pathpart   u getpath
return new string  path substring 0  path indexof pathpart    pathpart
catch  exception e
try
url u   new url pathwithoutjarprefix
string pathpart   u getpath
return new string  path substring 0  path indexof pathpart    pathpart
catch  exception e2
return null
/**
* this method checks a path, and if it starts with ~, then it expands
* the path to the absolute path of the user's home directory. if the
* string does not begin with ~, then the string is simply returned.
* unaltered.
* @param context
* @param path path to check
* @return expanded path
*/
public static string expanduserpath threadcontext context  string path
int pathlength   path length
if  pathlength >  1    path charat 0
// enebo : should ~frogger\\foo work (it doesnt in linux ruby)?
int userend   path indexof
if  userend     1
if  pathlength    1
// single '~' as whole path to expand
checkhome context
path   rubydir gethomedirectorypath context  tostring
else
// no directory delimeter.  rest of string is username
userend   pathlength
if  userend    1
// '~/...' as path to expand
checkhome context
path   rubydir gethomedirectorypath context  tostring
path substring 1
else if  userend > 1
// '~user/...' as path to expand
string user   path substring 1  userend
irubyobject dir   rubydir gethomedirectorypath context  user
if  dir isnil
throw context getruntime   newargumenterror     user
path       dir    pathlength    userend ?     path substring userend
return path
/**
* returns a string consisting of <code>n-1</code> slashes, where
* <code>n</code> is the number of slashes at the beginning of the input
* string.
* @param stringtocheck
* @return
*/
private static string countslashes  string stringtocheck
// count number of extra slashes in the beginning of the string.
int slashcount   0
for  int i   0  i < stringtocheck length    i
if  stringtocheck charat i
slashcount
else
break
// if there are n slashes, then we want n-1.
if  slashcount > 0
slashcount
if  slashcount < slashes length
return slashes
// prepare a string with the same number of redundant slashes so that
// we easily can prepend it to the result.
char slashes   new char
for  int i   0  i < slashcount  i
slashes
return new string slashes
public static string canonicalize string path
return canonicalize null  path
private static string canonicalize string canonicalpath  string remaining
if  remaining    null
if    equals canonicalpath
return
else
// compensate for missing slash after drive letter on windows
if  startswithdriveletteronwindows canonicalpath
canonicalpath length      2
canonicalpath
return canonicalpath
string child
int slash   remaining indexof
if  slash     1
child   remaining
remaining   null
else
child   remaining substring 0  slash
remaining   remaining substring slash   1
if  child equals
// no canonical path yet or length is zero, and we have a / followed by a dot...
if  slash     1
// we don't have another slash after this, so replace /. with /
if  canonicalpath    null    canonicalpath length      0    slash     1  canonicalpath
else
// we do have another slash; omit both / and . (jruby-1606)
else if  child equals
if  canonicalpath    null  throw new illegalargumentexception
int lastdir   canonicalpath lastindexof
if  lastdir     1
if  startswithdriveletteronwindows canonicalpath
// do nothing, we should not delete the drive letter
else
canonicalpath
else
canonicalpath   canonicalpath substring 0  lastdir
else if  canonicalpath    null
canonicalpath   child
else
canonicalpath        child
return canonicalize canonicalpath  remaining
/**
* check if home environment variable is not nil nor empty
* @param context
*/
private static void checkhome threadcontext context
ruby runtime   context getruntime
rubyhash env   runtime getenv
string home    string  env get runtime newstring
if  home    null    home equals
throw runtime newargumenterror
private static string inspectjoin threadcontext context  irubyobject recv  rubyarray parent  rubyarray array
ruby runtime   context getruntime
// if already inspecting, there is no need to register/unregister again.
if  runtime isinspecting parent   return join context  recv  array  tostring
try
runtime registerinspecting parent
return join context  recv  array  tostring
finally
runtime unregisterinspecting parent
private static rubystring join threadcontext context  irubyobject recv  rubyarray ary
irubyobject args   ary tojavaarray
boolean istainted   false
stringbuilder buffer   new stringbuilder
ruby runtime   context getruntime
for  int i   0  i < args length  i
if  args istaint
istainted   true
string element
if  args instanceof rubystring
element   args converttostring   getunicodevalue
else if  args instanceof rubyarray
if  runtime isinspecting args
throw runtime newargumenterror
else
element   inspectjoin context  recv  ary    rubyarray args
else
rubystring path   get_path context  args
element   path getunicodevalue
chomp buffer
if  i > 0     element startswith        element startswith
buffer append
buffer append element
rubystring fixedstr   rubystring newstring runtime  buffer tostring
fixedstr settaint istainted
return fixedstr
private static void chomp stringbuilder buffer
int lastindex   buffer length     1
while  lastindex >  0     buffer lastindexof       lastindex    buffer lastindexof       lastindex
buffer setlength lastindex
lastindex
private static irubyobject truncatecommon threadcontext context  irubyobject recv  irubyobject arg1  irubyobject arg2
rubystring filename   arg1 converttostring       todo  safestringvalue here
ruby runtime   context getruntime
rubyinteger newlength   arg2 converttointeger
file testfile
file childfile   new file filename getunicodevalue
if   childfile isabsolute
testfile   childfile
else
testfile   new file runtime getcurrentdirectory    filename getbytelist   tostring
if   testfile exists
throw runtime newerrnoenoenterror filename getbytelist   tostring
if  newlength getlongvalue   < 0
throw runtime newerrnoeinvalerror filename tostring
irubyobject args   new irubyobject   filename  runtime newstring
rubyfile file    rubyfile  open context  recv  args  block null_block
file truncate context  newlength
file close
return rubyfixnum zero runtime
private static void checksharedexclusive ruby runtime  openfile openfile  int lockmode
// this logic used to attempt a shared lock instead of an exclusive
// lock, because lock_ex on some systems (as reported in jruby-1214)
// allow exclusively locking a read-only file. however, the jdk
// apis do not allow acquiring an exclusive lock on files that are
// not open for read, and there are other platforms (such as solaris,
// see jruby-5627) that refuse at an *os* level to exclusively lock
// files opened only for read. as a result, this behavior is platform-
// dependent, and so we will obey the jdk's policy of disallowing
// exclusive locks on files opened only for read.
if   openfile iswritable       lockmode   lock_ex  > 0
throw runtime newerrnoebadferror
// likewise, jdk does not allow acquiring a shared lock on files
// that have not been opened for read. we comply here.
if   openfile isreadable       lockmode   lock_sh  > 0
throw runtime newerrnoebadferror
private static irubyobject lockfailedreturn ruby runtime  int lockmode
return  lockmode   lock_ex     0 ? rubyfixnum zero runtime    runtime getfalse
private static boolean lockstatechanges filelock lock  int lockmode
if  lock    null
// no lock, only proceed if we are acquiring
switch  lockmode   0xf
case lock_un
case lock_un   lock_nb
return false
default
return true
else
// existing lock, only proceed if we are unlocking or changing
switch  lockmode   0xf
case lock_un
case lock_un   lock_nb
return true
case lock_ex
case lock_ex   lock_nb
return lock isshared
case lock_sh
case lock_sh   lock_nb
return  lock isshared
default
return false
private irubyobject unlock ruby runtime  throws ioexception
if  currentlock    null
currentlock release
currentlock   null
return rubyfixnum zero runtime
return runtime getfalse
private irubyobject lock ruby runtime  filechannel filechannel  boolean exclusive  throws ioexception
if  currentlock    null  currentlock release
currentlock   filechannel lock 0l  long max_value   exclusive
if  currentlock    null
return rubyfixnum zero runtime
return lockfailedreturn runtime  exclusive ? lock_ex   lock_sh
private irubyobject trylock ruby runtime  filechannel filechannel  boolean exclusive  throws ioexception
if  currentlock    null  currentlock release
currentlock   filechannel trylock 0l  long max_value   exclusive
if  currentlock    null
return rubyfixnum zero runtime
return lockfailedreturn runtime  exclusive ? lock_ex   lock_sh
private static final long serialversionuid   1l
public static final int lock_sh   1
public static final int lock_ex   2
public static final int lock_nb   4
public static final int lock_un   8
private static final int fnm_noescape   1
private static final int fnm_pathname   2
private static final int fnm_dotmatch   4
private static final int fnm_casefold   8
private static final int fnm_syscase   platform is_windows ? fnm_casefold   0
private static int _cachedumask   0
private static final object _umasklock   new object
private static final string slashes
private static pattern uri_prefix   pattern compile
protected string path
private volatile filelock currentlock