/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2006 charles o nutter <headius@headius.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby compiler
import java util arraylist
import java util hashmap
import java util iterator
import java util list
import java util map
import org jcodings encoding
import org jruby rubyclass
import org jruby rubyfixnum
import org jruby rubyfloat
import org jruby rubyinstanceconfig
import org jruby rubymatchdata
import org jruby ast aliasnode
import org jruby ast andnode
import org jruby ast argscatnode
import org jruby ast argsnode
import org jruby ast argspushnode
import org jruby ast arraynode
import org jruby ast attrassignnode
import org jruby ast backrefnode
import org jruby ast beginnode
import org jruby ast bignumnode
import org jruby ast binaryoperatornode
import org jruby ast blocknode
import org jruby ast blockpassnode
import org jruby ast breaknode
import org jruby ast callnode
import org jruby ast casenode
import org jruby ast classnode
import org jruby ast classvarasgnnode
import org jruby ast classvardeclnode
import org jruby ast classvarnode
import org jruby ast colon2constnode
import org jruby ast colon2methodnode
import org jruby ast colon2node
import org jruby ast colon3node
import org jruby ast constdeclnode
import org jruby ast constnode
import org jruby ast dasgnnode
import org jruby ast dregexpnode
import org jruby ast dstrnode
import org jruby ast dsymbolnode
import org jruby ast dvarnode
import org jruby ast dxstrnode
import org jruby ast definednode
import org jruby ast defnnode
import org jruby ast defsnode
import org jruby ast dotnode
import org jruby ast ensurenode
import org jruby ast evstrnode
import org jruby ast fcallnode
import org jruby ast filenode
import org jruby ast fixnumnode
import org jruby ast flipnode
import org jruby ast floatnode
import org jruby ast fornode
import org jruby ast globalasgnnode
import org jruby ast globalvarnode
import org jruby ast hashnode
import org jruby ast ifnode
import org jruby ast instasgnnode
import org jruby ast instvarnode
import org jruby ast iternode
import org jruby ast listnode
import org jruby ast literalnode
import org jruby ast localasgnnode
import org jruby ast localvarnode
import org jruby ast match2node
import org jruby ast match3node
import org jruby ast matchnode
import org jruby ast modulenode
import org jruby ast multipleasgnnode
import org jruby ast newlinenode
import org jruby ast nextnode
import org jruby ast nilnode
import org jruby ast node
import org jruby ast nodetype
import org jruby ast notnode
import org jruby ast nthrefnode
import org jruby ast opasgnnode
import org jruby ast opasgnornode
import org jruby ast opelementasgnnode
import org jruby ast ornode
import org jruby ast postexenode
import org jruby ast preexenode
import org jruby ast regexpnode
import org jruby ast rescuebodynode
import org jruby ast rescuenode
import org jruby ast returnnode
import org jruby ast rootnode
import org jruby ast sclassnode
import org jruby ast svaluenode
import org jruby ast selfnode
import org jruby ast specialargs
import org jruby ast splatnode
import org jruby ast starnode
import org jruby ast strnode
import org jruby ast supernode
import org jruby ast symbolnode
import org jruby ast toarynode
import org jruby ast undefnode
import org jruby ast untilnode
import org jruby ast valiasnode
import org jruby ast vcallnode
import org jruby ast whennode
import org jruby ast whenoneargnode
import org jruby ast whilenode
import org jruby ast xstrnode
import org jruby ast yieldnode
import org jruby ast zsupernode
import org jruby exceptions jumpexception
import org jruby internal runtime methods defaultmethod
import org jruby internal runtime methods dynamicmethod
import org jruby internal runtime methods dynamicmethod nativecall
import org jruby internal runtime methods interpretedmethod
import org jruby internal runtime methods jittedmethod
import org jruby javasupport util runtimehelpers
import org jruby parser staticscope
import org jruby runtime arity
import org jruby runtime blockbody
import org jruby runtime calltype
import org jruby runtime methodindex
import org jruby runtime callsite cacheentry
import org jruby runtime callsite cachingcallsite
import org jruby util bytelist
import org jruby util stringsupport
/**
*
* @author headius
*/
public class astcompiler
private boolean isatroot   true
protected boolean is1_9
return false
public void compilebody node node  bodycompiler context  boolean expr
node oldbodynode   currentbodynode
currentbodynode   node
compile node  context  expr
currentbodynode   oldbodynode
public void compile node node  bodycompiler context  boolean expr
if  node    null
if  expr  context loadnil
return
switch  node getnodetype
case aliasnode
compilealias  aliasnode  node  context  expr
break
case andnode
compileand node  context  expr
break
case argscatnode
compileargscat node  context  expr
break
case argspushnode
compileargspush node  context  expr
break
case arraynode
compilearray node  context  expr
break
case attrassignnode
compileattrassign node  context  expr
break
case backrefnode
compilebackref node  context  expr
break
case beginnode
compilebegin node  context  expr
break
case bignumnode
compilebignum node  context  expr
break
case blocknode
compileblock node  context  expr
break
case breaknode
compilebreak node  context  expr
break
case callnode
compilecall node  context  expr
break
case casenode
compilecase node  context  expr
break
case classnode
compileclass node  context  expr
break
case classvarnode
compileclassvar node  context  expr
break
case classvarasgnnode
compileclassvarasgn node  context  expr
break
case classvardeclnode
compileclassvardecl node  context  expr
break
case colon2node
compilecolon2 node  context  expr
break
case colon3node
compilecolon3 node  context  expr
break
case constdeclnode
compileconstdecl node  context  expr
break
case constnode
compileconst node  context  expr
break
case dasgnnode
compiledasgn node  context  expr
break
case definednode
compiledefined node  context  expr
break
case defnnode
compiledefn node  context  expr
break
case defsnode
compiledefs node  context  expr
break
case dotnode
compiledot node  context  expr
break
case dregexpnode
compiledregexp node  context  expr
break
case dstrnode
compiledstr node  context  expr
break
case dsymbolnode
compiledsymbol node  context  expr
break
case dvarnode
compiledvar node  context  expr
break
case dxstrnode
compiledxstr node  context  expr
break
case ensurenode
compileensurenode node  context  expr
break
case evstrnode
compileevstr node  context  expr
break
case falsenode
compilefalse node  context  expr
break
case fcallnode
compilefcall node  context  expr
break
case fixnumnode
compilefixnum node  context  expr
break
case flipnode
compileflip node  context  expr
break
case floatnode
compilefloat node  context  expr
break
case fornode
compilefor node  context  expr
break
case globalasgnnode
compileglobalasgn node  context  expr
break
case globalvarnode
compileglobalvar node  context  expr
break
case hashnode
compilehash node  context  expr
break
case ifnode
compileif node  context  expr
break
case instasgnnode
compileinstasgn node  context  expr
break
case instvarnode
compileinstvar node  context  expr
break
case iternode
compileiter node  context
break
case literalnode
compileliteral  literalnode  node  context
break
case localasgnnode
compilelocalasgn node  context  expr
break
case localvarnode
compilelocalvar node  context  expr
break
case match2node
compilematch2 node  context  expr
break
case match3node
compilematch3 node  context  expr
break
case matchnode
compilematch node  context  expr
break
case modulenode
compilemodule node  context  expr
break
case multipleasgnnode
compilemultipleasgn node  context  expr
break
case newlinenode
compilenewline node  context  expr
break
case nextnode
compilenext node  context  expr
break
case nthrefnode
compilenthref node  context  expr
break
case nilnode
compilenil node  context  expr
break
case notnode
compilenot node  context  expr
break
case opasgnandnode
compileopasgnand node  context  expr
break
case opasgnnode
compileopasgn node  context  expr
break
case opasgnornode
compileopasgnor node  context  expr
break
case opelementasgnnode
compileopelementasgn node  context  expr
break
case ornode
compileor node  context  expr
break
case postexenode
compilepostexe node  context  expr
break
case preexenode
compilepreexe node  context  expr
break
case redonode
compileredo node  context  expr
break
case regexpnode
compileregexp node  context  expr
break
case rescuebodynode
throw new notcompilableexception     node getposition
case rescuenode
compilerescue node  context  expr
break
case retrynode
compileretry node  context  expr
break
case returnnode
compilereturn node  context  expr
break
case rootnode
throw new notcompilableexception     node getposition
case sclassnode
compilesclass node  context  expr
break
case selfnode
compileself node  context  expr
break
case splatnode
compilesplat node  context  expr
break
case strnode
compilestr node  context  expr
break
case supernode
compilesuper node  context  expr
break
case svaluenode
compilesvalue node  context  expr
break
case symbolnode
compilesymbol node  context  expr
break
case toarynode
compiletoary node  context  expr
break
case truenode
compiletrue node  context  expr
break
case undefnode
compileundef  undefnode  node  context  expr
break
case untilnode
compileuntil node  context  expr
break
case valiasnode
compilevalias node  context  expr
break
case vcallnode
compilevcall node  context  expr
break
case whilenode
compilewhile node  context  expr
break
case whennode
assert false
break
case xstrnode
compilexstr node  context  expr
break
case yieldnode
compileyield node  context  expr
break
case zarraynode
compilezarray node  context  expr
break
case zsupernode
compilezsuper node  context  expr
break
default
throw new notcompilableexception     node
public void compilearguments node node  bodycompiler context
switch  node getnodetype
case argscatnode
compileargscatarguments node  context  true
break
case argspushnode
compileargspusharguments node  context  true
break
case arraynode
compilearrayarguments node  context  true
break
case splatnode
compilesplatarguments node  context  true
break
default
compile node  context  true
context converttojavaarray
public class variablearityarguments implements argumentscallback
private node node
public variablearityarguments node node
this node   node
public int getarity
return  1
public void call bodycompiler context
compilearguments node  context
public class specificarityarguments implements argumentscallback
private int arity
private node node
public specificarityarguments node node
if  node getnodetype      nodetype arraynode      arraynode node  islightweight
// only arrays that are "lightweight" are being used as args arrays
this arity     arraynode node  size
else
// otherwise, it's a literal array
this arity   1
this node   node
public int getarity
return arity
public void call bodycompiler context
if  node getnodetype      nodetype arraynode
arraynode arraynode    arraynode node
if  arraynode islightweight
// explode array, it's an internal "args" array
for  node n   arraynode childnodes
compile n  context true
else
// use array as-is, it's a literal array
compile arraynode  context true
else
compile node  context true
public argumentscallback getargscallback node node
if  node    null
return null
// unwrap newline nodes to get their actual type
while  node getnodetype      nodetype newlinenode
node     newlinenode node  getnextnode
switch  node getnodetype
case argscatnode
case argspushnode
case splatnode
return new variablearityarguments node
case arraynode
arraynode arraynode    arraynode node
if  arraynode size      0
return null
else if  arraynode size   > 3
return new variablearityarguments node
else
return new specificarityarguments node
default
return new specificarityarguments node
public void compileassignment node node  bodycompiler context  boolean expr
switch  node getnodetype
case attrassignnode
compileattrassignassignment node  context  expr
break
case dasgnnode
dasgnnode dasgnnode    dasgnnode node
context getvariablecompiler   assignlocalvariable dasgnnode getindex    dasgnnode getdepth    expr
break
case classvarasgnnode
compileclassvarasgnassignment node  context  expr
break
case classvardeclnode
compileclassvardeclassignment node  context  expr
break
case constdeclnode
compileconstdeclassignment node  context  expr
break
case globalasgnnode
compileglobalasgnassignment node  context  expr
break
case instasgnnode
compileinstasgnassignment node  context  expr
break
case localasgnnode
localasgnnode localasgnnode    localasgnnode node
context getvariablecompiler   assignlocalvariable localasgnnode getindex    localasgnnode getdepth    expr
break
case multipleasgnnode
compilemultipleasgnassignment node  context  expr
break
case zeroargnode
context consumecurrentvalue
break
default
throw new notcompilableexception     node
public void compilealias final aliasnode alias  bodycompiler context  boolean expr
compilercallback args   new compilercallback
public void call bodycompiler context
compile alias getnewname    context  true
compile alias getoldname    context  true
context definealias args
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileand node node  bodycompiler context  final boolean expr
final andnode andnode    andnode  node
if  andnode getfirstnode   getnodetype   alwaystrue
// compile first node as non-expr and then second node
compile andnode getfirstnode    context  false
compile andnode getsecondnode    context  expr
else if  andnode getfirstnode   getnodetype   alwaysfalse
// compile first node only
compile andnode getfirstnode    context  expr
else
compile andnode getfirstnode    context  true
branchcallback longcallback   new branchcallback
public void branch bodycompiler context
compile andnode getsecondnode    context  true
context performlogicaland longcallback
if   expr  context consumecurrentvalue
public void compilearray node node  bodycompiler context  boolean expr
arraynode arraynode    arraynode  node
if  expr
arraycallback callback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray  int index
node node    node    object  sourcearray
compile node  context  true
list<node> childnodes   arraynode childnodes
if  islistallliterals arraynode
context createnewliteralarray childnodes toarray    callback  arraynode islightweight
else
context createnewarray childnodes toarray    callback  arraynode islightweight
else
if  islistallliterals arraynode
// do nothing, no observable effect
else
for  iterator<node> iter   arraynode childnodes   iterator    iter hasnext
node nextnode   iter next
compile nextnode  context  false
private boolean islistallliterals listnode listnode
for  int i   0  i < listnode size    i
switch  listnode get i  getnodetype
case strnode
case floatnode
case fixnumnode
case bignumnode
case regexpnode
case zarraynode
case symbolnode
case nilnode
// simple literals, continue
continue
case arraynode
// scan contained array
if  islistallliterals  arraynode listnode get i
continue
else
return false
case hashnode
// scan contained hash
if  islistallliterals   hashnode listnode get i   getlistnode
continue
else
return false
default
return false
// all good!
return true
public void compileargscat node node  bodycompiler context  boolean expr
argscatnode argscatnode    argscatnode  node
compile argscatnode getfirstnode    context true
compile argscatnode getsecondnode    context true
context argscat
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileargspush node node  bodycompiler context  boolean expr
throw new notcompilableexception
private void compileattrassign node node  bodycompiler context  boolean expr
final attrassignnode attrassignnode    attrassignnode  node
compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile attrassignnode getreceivernode    context true
argumentscallback argscallback   getargscallback attrassignnode getargsnode
// ruby 1.8 and 1.9 only bypass visibility check when receiver is statically
// determined to be self.
boolean isself   attrassignnode getreceivernode   instanceof selfnode
context getinvocationcompiler   invokeattrassign attrassignnode getname    receivercallback  argscallback  isself  expr
public void compileattrassignassignment node node  bodycompiler context  boolean expr
final attrassignnode attrassignnode    attrassignnode  node
compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile attrassignnode getreceivernode    context true
argumentscallback argscallback   getargscallback attrassignnode getargsnode
// ruby 1.8 and 1.9 only bypass visibility check when receiver is statically
// determined to be self.
boolean isself   attrassignnode getreceivernode   instanceof selfnode
context getinvocationcompiler   invokeattrassignmasgn attrassignnode getname    receivercallback  argscallback  isself
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilebackref node node  bodycompiler context  boolean expr
backrefnode ivisited    backrefnode  node
context performbackref ivisited gettype
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilebegin node node  bodycompiler context  boolean expr
beginnode beginnode    beginnode  node
compile beginnode getbodynode    context  expr
public void compilebignum node node  bodycompiler context  boolean expr
if  expr  context createnewbignum   bignumnode  node  getvalue
public void compileblock node node  bodycompiler context  boolean expr
blocknode blocknode    blocknode  node
for  iterator<node> iter   blocknode childnodes   iterator    iter hasnext
node n   iter next
compile n  context  iter hasnext   ? false   expr
public void compilebreak node node  bodycompiler context  boolean expr
final breaknode breaknode    breaknode  node
compilercallback valuecallback   new compilercallback
public void call bodycompiler context
if  breaknode getvaluenode      null
compile breaknode getvaluenode    context  true
else
context loadnil
context issuebreakevent valuecallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilecall node node  bodycompiler context  boolean expr
final callnode callnode    callnode  node
compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile callnode getreceivernode    context  true
argumentscallback argscallback   getargscallback callnode getargsnode
compilercallback closurearg   getblock callnode getiternode
string name   callnode getname
calltype calltype   calltype normal
dynopt  if  rubyinstanceconfig dynopt_compile_enabled
// dynopt does not handle non-local block flow control yet, so we bail out
// if there's a closure.
if  callnode getiternode      null  break dynopt
if  callnode calladapter instanceof cachingcallsite
cachingcallsite cachesite    cachingcallsite callnode calladapter
if  cachesite isoptimizable
cacheentry entry   cachesite getcache
if  entry method getnativecall      null
nativecall nativecall   entry method getnativecall
// only do direct calls for specific arity
if  argscallback    null    argscallback getarity   >  0    argscallback getarity   <  3
if  compileintrinsic context  callnode  cachesite methodname  entry token  entry method  receivercallback  argscallback  closurearg
// intrinsic compilation worked, hooray!
return
else
// otherwise, normal straight-through native call
context getinvocationcompiler   invokenative
name  nativecall  entry token  receivercallback
argscallback  closurearg  calltype normal
callnode getiternode   instanceof iternode
return
// check for a recursive call
if  callnode getreceivernode   instanceof selfnode
// recursive calls
if  compilerecursivecall callnode getname    entry token  calltype normal  callnode getiternode   instanceof iternode  entry method  context  argscallback  closurearg  expr   return
if  argscallback    null    argscallback getarity      1
node argument   callnode getargsnode   childnodes   get 0
if  argument instanceof fixnumnode
if  methodindex hasfastfixnumops name
context getinvocationcompiler   invokebinaryfixnumrhs name  receivercallback    fixnumnode argument  getvalue
if   expr  context consumecurrentvalue
return
else if  argument instanceof floatnode
if  methodindex hasfastfloatops name
context getinvocationcompiler   invokebinaryfloatrhs name  receivercallback    floatnode argument  getvalue
if   expr  context consumecurrentvalue
return
// if __send__ with a literal symbol, compile it as a direct fcall
if  rubyinstanceconfig fastsend_compile_enabled
string literalsend   getliteralsend callnode
if  literalsend    null
name   literalsend
calltype   calltype functional
if  callnode instanceof specialargs
context getinvocationcompiler   invokedynamicvarargs
name  receivercallback  argscallback
calltype  closurearg  callnode getiternode   instanceof iternode
else
context getinvocationcompiler   invokedynamic
name  receivercallback  argscallback
calltype  closurearg  callnode getiternode   instanceof iternode
// todo: don't require pop
if   expr  context consumecurrentvalue
private static final map<class  map<class  map<string  string>>> intrinsics
static
intrinsics   new hashmap
map<class  map<string  string>> fixnumintrinsics   new hashmap
intrinsics put rubyfixnum class  fixnumintrinsics
map<string  string> fixnumlongintrinsics   new hashmap
fixnumintrinsics put fixnumnode class  fixnumlongintrinsics
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
fixnumlongintrinsics put
map<class  map<string  string>> floatintrinsics   new hashmap
intrinsics put rubyfloat class  floatintrinsics
map<string  string>floatdoubleintrinsics   new hashmap
floatintrinsics put floatnode class  floatdoubleintrinsics
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
floatdoubleintrinsics put
private boolean compilerecursivecall string name  int generation  calltype calltype  boolean iterator  dynamicmethod method  bodycompiler context  argumentscallback argscallback  compilercallback closure  boolean expr
if  currentbodynode    null    context issimpleroot
if  method instanceof interpretedmethod
interpretedmethod target    interpretedmethod method
if  target getbodynode      currentbodynode
context getinvocationcompiler   invokerecursive name  generation  argscallback  closure  calltype  iterator
if   expr  context consumecurrentvalue
return true
if  method instanceof defaultmethod
defaultmethod target    defaultmethod method
if  target getbodynode      currentbodynode
context getinvocationcompiler   invokerecursive name  generation  argscallback  closure  calltype  iterator
if   expr  context consumecurrentvalue
return true
if  method instanceof jittedmethod
defaultmethod target    defaultmethod   jittedmethod method  getrealmethod
if  target getbodynode      currentbodynode
context getinvocationcompiler   invokerecursive name  generation  argscallback  closure  calltype  iterator
if   expr  context consumecurrentvalue
return true
return false
private boolean compiletrivialcall string name  dynamicmethod method  int generation  bodycompiler context  boolean expr
node simplebody   null
if  method instanceof interpretedmethod
interpretedmethod target    interpretedmethod method
simplebody   target getbodynode
while  simplebody instanceof newlinenode  simplebody     newlinenode simplebody  getnextnode
if  method instanceof defaultmethod
defaultmethod target    defaultmethod method
simplebody   target getbodynode
while  simplebody instanceof newlinenode  simplebody     newlinenode simplebody  getnextnode
if  method instanceof jittedmethod
defaultmethod target    defaultmethod   jittedmethod method  getrealmethod
simplebody   target getbodynode
while  simplebody instanceof newlinenode  simplebody     newlinenode simplebody  getnextnode
if  simplebody    null
switch  simplebody getnodetype
case selfnode
case instvarnode
case nilnode
case fixnumnode
case floatnode
case strnode
case bignumnode
case falsenode
case truenode
case symbolnode
case xstrnode
final node simplebodyfinal   simplebody
context getinvocationcompiler   invoketrivial name  generation  new compilercallback
public void call bodycompiler context
compile simplebodyfinal  context  true
if   expr  context consumecurrentvalue
return true
return false
private boolean compileintrinsic bodycompiler context  callnode callnode  string name  int generation  dynamicmethod method  compilercallback receivercallback  argumentscallback argscallback  compilercallback closurecallback
if    method getimplementationclass   instanceof rubyclass   return false
rubyclass implclass    rubyclass method getimplementationclass
map<class  map<string  string>> typeintrinsics   intrinsics get implclass getreifiedclass
if  typeintrinsics    null
if  argscallback    null    argscallback getarity      1
node argument   callnode getargsnode   childnodes   get 0
if  argument instanceof fixnumnode
map<string  string> typelongintrinsics   typeintrinsics get fixnumnode class
if  typelongintrinsics    null    typelongintrinsics containskey name
context getinvocationcompiler   invokefixnumlong name  generation  receivercallback  typelongintrinsics get name     fixnumnode argument  getvalue
return true
if  argument instanceof floatnode
map<string  string> typedoubleintrinsics   typeintrinsics get floatnode class
if  typedoubleintrinsics    null    typedoubleintrinsics containskey name
context getinvocationcompiler   invokefloatdouble name  generation  receivercallback  typedoubleintrinsics get name     floatnode argument  getvalue
return true
return false
private string getliteralsend callnode callnode
if  callnode getname   equals
if  callnode getargsnode   instanceof arraynode
arraynode arraynode    arraynode callnode getargsnode
if  arraynode get 0  instanceof symbolnode
return   symbolnode arraynode get 0   getname
else if  arraynode get 0  instanceof strnode
return   strnode arraynode get 0   getvalue   tostring
return null
public void compilecase node node  bodycompiler context  boolean expr
casenode casenode    casenode  node
boolean hascase   casenode getcasenode      null
// aggregate when nodes into a list, unfortunately, this is no
list<node> cases   casenode getcases   childnodes
// last node, either !instanceof whennode or null, is the else
node elsenode   casenode getelsenode
compilewhen casenode getcasenode    cases  elsenode  context  expr  hascase
private fastswitchtype gethomogeneousswitchtype list<node> whennodes
fastswitchtype foundtype   null
outer  for  node node   whennodes
whennode whennode    whennode node
if  whennode getexpressionnodes   instanceof arraynode
arraynode arraynode    arraynode whennode getexpressionnodes
for  node maybefixnum   arraynode childnodes
if  maybefixnum instanceof fixnumnode
fixnumnode fixnumnode    fixnumnode maybefixnum
long value   fixnumnode getvalue
if  value <  integer max_value    value >  integer min_value
if  foundtype    null    foundtype    fastswitchtype fixnum  return null
if  foundtype    null  foundtype   fastswitchtype fixnum
continue
else
return null
else
return null
else if  whennode getexpressionnodes   instanceof fixnumnode
fixnumnode fixnumnode    fixnumnode whennode getexpressionnodes
long value   fixnumnode getvalue
if  value <  integer max_value    value >  integer min_value
if  foundtype    null    foundtype    fastswitchtype fixnum  return null
if  foundtype    null  foundtype   fastswitchtype fixnum
continue
else
return null
else if  whennode getexpressionnodes   instanceof strnode
strnode strnode    strnode whennode getexpressionnodes
if  strnode getvalue   length      1
if  foundtype    null    foundtype    fastswitchtype single_char_string  return null
if  foundtype    null  foundtype   fastswitchtype single_char_string
continue
else if  whennode getexpressionnodes   instanceof symbolnode
symbolnode symbolnode    symbolnode whennode getexpressionnodes
if  symbolnode getname   length      1
if  foundtype    null    foundtype    fastswitchtype single_char_symbol  return null
if  foundtype    null  foundtype   fastswitchtype single_char_symbol
continue
else
return null
return foundtype
public void compilewhen final node value  list<node> whennodes  final node elsenode  bodycompiler context  final boolean expr  final boolean hascase
compilercallback casevalue   null
if  value    null  casevalue   new compilercallback
public void call bodycompiler context
compile value  context  true
context pollthreadevents
list<argumentscallback> conditionals   new arraylist<argumentscallback>
list<compilercallback> bodies   new arraylist<compilercallback>
map<compilercallback  int> switchcases   null
fastswitchtype switchtype   gethomogeneousswitchtype whennodes
if  switchtype    null     rubyinstanceconfig full_trace_enabled
// note: currently this optimization is limited to the following scenarios:
// * all expressions are int-ranged literal fixnums
// * all expressions are single-character literal symbols
// * all expressions are single-character literal strings
// if the case value is not of the same type as the when values, the
// default === logic applies.
switchcases   new hashmap<compilercallback  int>
for  node node   whennodes
final whennode whennode    whennode node
compilercallback body   new compilercallback
public void call bodycompiler context
if  rubyinstanceconfig full_trace_enabled  context traceline
compile whennode getbodynode    context  expr
addconditionalforwhen whennode  conditionals  bodies  body
if  switchcases    null  switchcases put body  getoptimizedcases whennode
compilercallback fallback   new compilercallback
public void call bodycompiler context
compile elsenode  context  expr
context compilesequencedconditional casevalue  switchtype  switchcases  conditionals  bodies  fallback
private int getoptimizedcases whennode whennode
if  whennode getexpressionnodes   instanceof arraynode
arraynode expression    arraynode whennode getexpressionnodes
if  expression get expression size     1  instanceof whennode
// splatted when, can't do it yet
return null
int cases   new int
for  int i   0  i < cases length  i
switch  expression get i  getnodetype
case fixnumnode
cases    int   fixnumnode expression get i   getvalue
break
default
// can't do it
return null
return cases
else if  whennode getexpressionnodes   instanceof fixnumnode
fixnumnode fixnumnode    fixnumnode whennode getexpressionnodes
return new int   int fixnumnode getvalue
else if  whennode getexpressionnodes   instanceof strnode
strnode strnode    strnode whennode getexpressionnodes
if  strnode getvalue   length      1
return new int  strnode getvalue   get 0
else
return new int  strnode getvalue   hashcode
else if  whennode getexpressionnodes   instanceof symbolnode
symbolnode symbolnode    symbolnode whennode getexpressionnodes
if  symbolnode getname   length      1
return new int  symbolnode getname   charat 0
else
return new int  symbolnode getname   hashcode
return null
private void addconditionalforwhen final whennode whennode  list<argumentscallback> conditionals  list<compilercallback> bodies  compilercallback body
bodies add body
// if it's a single-arg when but contains an array, we know it's a real literal array
// fixme: this is a gross way to figure it out; parser help similar to yield argument passing (expandarguments) would be better
if  whennode getexpressionnodes   instanceof arraynode
if  whennode instanceof whenoneargnode
// one arg but it's an array, treat it as a proper array
conditionals add new argumentscallback
public int getarity
return 1
public void call bodycompiler context
compile whennode getexpressionnodes    context  true
return
// otherwise, use normal args compiler
conditionals add getargscallback whennode getexpressionnodes
public void compileclass node node  bodycompiler context  boolean expr
final classnode classnode    classnode  node
final node supernode   classnode getsupernode
final node cpathnode   classnode getcpath
compilercallback supercallback   new compilercallback
public void call bodycompiler context
compile supernode  context  true
if  supernode    null
supercallback   null
compilercallback bodycallback   new compilercallback
public void call bodycompiler context
boolean oldisatroot   isatroot
isatroot   false
if  classnode getbodynode      null
compile classnode getbodynode    context  true
else
context loadnil
isatroot   oldisatroot
compilercallback pathcallback   new compilercallback
public void call bodycompiler context
if  cpathnode instanceof colon2node
node leftnode     colon2node  cpathnode  getleftnode
if  leftnode    null
if  leftnode instanceof nilnode
context raisetypeerror
else
compile leftnode  context  true
else
context loadnil
else if  cpathnode instanceof colon3node
context loadobject
else
context loadnil
astinspector inspector   new astinspector
inspector inspect classnode getbodynode
context defineclass classnode getcpath   getname    classnode getscope    supercallback  pathcallback  bodycallback  null  inspector
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilesclass node node  bodycompiler context  boolean expr
final sclassnode sclassnode    sclassnode  node
compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile sclassnode getreceivernode    context  true
compilercallback bodycallback   new compilercallback
public void call bodycompiler context
boolean oldisatroot   isatroot
isatroot   false
if  sclassnode getbodynode      null
compile sclassnode getbodynode    context  true
else
context loadnil
isatroot   oldisatroot
astinspector inspector   new astinspector
inspector inspect sclassnode getbodynode
context defineclass    sclassnode getscope    null  null  bodycallback  receivercallback  inspector
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileclassvar node node  bodycompiler context  boolean expr
classvarnode classvarnode    classvarnode  node
context retrieveclassvariable classvarnode getname
if   expr  context consumecurrentvalue
public void compileclassvarasgn node node  bodycompiler context  boolean expr
final classvarasgnnode classvarasgnnode    classvarasgnnode  node
compilercallback value   new compilercallback
public void call bodycompiler context
compile classvarasgnnode getvaluenode    context  true
context assignclassvariable classvarasgnnode getname    value
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileclassvarasgnassignment node node  bodycompiler context  boolean expr
classvarasgnnode classvarasgnnode    classvarasgnnode  node
context assignclassvariable classvarasgnnode getname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileclassvardecl node node  bodycompiler context  boolean expr
final classvardeclnode classvardeclnode    classvardeclnode  node
compilercallback value   new compilercallback
public void call bodycompiler context
compile classvardeclnode getvaluenode    context  true
context declareclassvariable classvardeclnode getname    value
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileclassvardeclassignment node node  bodycompiler context  boolean expr
classvardeclnode classvardeclnode    classvardeclnode  node
context declareclassvariable classvardeclnode getname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileconstdecl node node  bodycompiler context  boolean expr
// todo: callback for value would be more efficient, but unlikely to be a big cost (constants are rarely assigned)
constdeclnode constdeclnode    constdeclnode  node
node constnode   constdeclnode getconstnode
if  constnode    null
compile constdeclnode getvaluenode    context true
context assignconstantincurrent constdeclnode getname
else if  constnode getnodetype      nodetype colon2node
compile constdeclnode getvaluenode    context true
compile   colon2node  constnode  getleftnode    context true
context assignconstantinmodule constdeclnode getname
else     colon3  assign in object
compile constdeclnode getvaluenode    context true
context assignconstantinobject constdeclnode getname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileconstdeclassignment node node  bodycompiler context  boolean expr
// todo: callback for value would be more efficient, but unlikely to be a big cost (constants are rarely assigned)
constdeclnode constdeclnode    constdeclnode  node
node constnode   constdeclnode getconstnode
if  constnode    null
context assignconstantincurrent constdeclnode getname
else if  constnode getnodetype      nodetype colon2node
compile   colon2node  constnode  getleftnode    context true
context assignconstantinmodule constdeclnode getname
else     colon3  assign in object
context assignconstantinobject constdeclnode getname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileconst node node  bodycompiler context  boolean expr
constnode constnode    constnode  node
context retrieveconstant constnode getname
// todo: don't require pop
if   expr  context consumecurrentvalue
// xxx: const lookup can trigger const_missing; is that enough to warrant it always being executed?
public void compilecolon2 node node  bodycompiler context  boolean expr
final colon2node ivisited    colon2node  node
node leftnode   ivisited getleftnode
final string name   ivisited getname
if  leftnode    null
context loadobject
context retrieveconstantfrommodule name
else
if  node instanceof colon2constnode
compile ivisited getleftnode    context  true
context retrieveconstantfrommodule name
else if  node instanceof colon2methodnode
final compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile ivisited getleftnode    context true
context getinvocationcompiler   invokedynamic name  receivercallback  null  calltype functional  null  false
else
compile ivisited getleftnode    context  true
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilecolon3 node node  bodycompiler context  boolean expr
colon3node ivisited    colon3node  node
string name   ivisited getname
context retrieveconstantfromobject name
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilegetdefinitionbase final node node  bodycompiler context
switch  node getnodetype
case classvarasgnnode
case classvardeclnode
case constdeclnode
case dasgnnode
case globalasgnnode
case localasgnnode
case multipleasgnnode
case opasgnnode
case opelementasgnnode
case dvarnode
case falsenode
case truenode
case localvarnode
case instvarnode
case backrefnode
case selfnode
case vcallnode
case yieldnode
case globalvarnode
case constnode
case fcallnode
case classvarnode
case colon2node
case colon3node
case callnode
// these are all simple cases that don't require the heavier defined logic
compilegetdefinition node  context
break
case newlinenode
compilegetdefinitionbase   newlinenode node  getnextnode    context
break
default
branchcallback reg   new branchcallback
public void branch bodycompiler context
context indefined
compilegetdefinition node  context
branchcallback out   new branchcallback
public void branch bodycompiler context
context outdefined
context protect reg  out  bytelist class
public void compiledefined final node node  bodycompiler context  boolean expr
if  expr
compilegetdefinitionbase   definednode  node  getexpressionnode    context
context stringornil
public void compilegetargumentdefinition final node node  bodycompiler context  string type
if  node    null
context pushbytelist bytelist create type
else if  node instanceof arraynode
object endtoken   context getnewending
for  int i   0  i <   arraynode  node  size    i
node iternode     arraynode  node  get i
compilegetdefinition iternode  context
context ifnull endtoken
context pushbytelist bytelist create type
object realtoken   context getnewending
context go realtoken
context setending endtoken
context pushnull
context setending realtoken
else
compilegetdefinition node  context
object endtoken   context getnewending
context ifnull endtoken
context pushbytelist bytelist create type
object realtoken   context getnewending
context go realtoken
context setending endtoken
context pushnull
context setending realtoken
public void compilegetdefinition final node node  bodycompiler context
switch  node getnodetype
case classvarasgnnode
case classvardeclnode
case constdeclnode
case dasgnnode
case globalasgnnode
case localasgnnode
case multipleasgnnode
case multipleasgn19node
case opasgnnode
case opasgnandnode
case opasgnornode
case opelementasgnnode
case instasgnnode     simple assignment cases
context pushbytelist node assignment_bytelist
break
case andnode     all these just evaluate and then do expression if there's no error
case ornode
case dstrnode
case dregexpnode
compiledefinedandordstrdregexp node  context
break
case notnode     evaluates  and under 1 9 flips to   if result is nonnull
context rescue new branchcallback
public void branch bodycompiler context
compile node  context  false
context pushbytelist node expression_bytelist
jumpexception class
new branchcallback
public void branch bodycompiler context
context pushnull
bytelist class
context definednot
break
case backrefnode
compiledefinedbackref node  context
break
case dvarnode
compiledefineddvar node  context
break
case falsenode
context pushbytelist node false_bytelist
break
case truenode
context pushbytelist node true_bytelist
break
case localvarnode
context pushbytelist node local_variable_bytelist
break
case match2node
case match3node
context pushbytelist node method_bytelist
break
case nilnode
context pushbytelist node nil_bytelist
break
case nthrefnode
compiledefinednthref node  context
break
case selfnode
context pushbytelist node self_bytelist
break
case vcallnode
context loadself
context ismethodbound   vcallnode  node  getname
new branchcallback
public void branch bodycompiler context
context pushbytelist node method_bytelist
new branchcallback
public void branch bodycompiler context
context pushnull
break
case yieldnode
context hasblock new branchcallback
public void branch bodycompiler context
context pushbytelist node yield_bytelist
new branchcallback
public void branch bodycompiler context
context pushnull
break
case globalvarnode
context isglobaldefined   globalvarnode  node  getname
new branchcallback
public void branch bodycompiler context
context pushbytelist node global_variable_bytelist
new branchcallback
public void branch bodycompiler context
context pushnull
break
case instvarnode
context isinstancevariabledefined   instvarnode  node  getname
new branchcallback
public void branch bodycompiler context
context pushbytelist node instance_variable_bytelist
new branchcallback
public void branch bodycompiler context
context pushnull
break
case constnode
context isconstantdefined   constnode  node  getname
new branchcallback
public void branch bodycompiler context
context pushbytelist node constant_bytelist
new branchcallback
public void branch bodycompiler context
context pushnull
break
case fcallnode
context loadself
context ismethodbound   fcallnode  node  getname
new branchcallback
public void branch bodycompiler context
compilegetargumentdefinition   fcallnode  node  getargsnode    context
new branchcallback
public void branch bodycompiler context
context pushnull
break
case colon3node
case colon2node
final colon3node ivisited    colon3node  node
final string name   ivisited getname
branchcallback setup   new branchcallback
public void branch bodycompiler context
if  ivisited instanceof colon2node
final node leftnode     colon2node  ivisited  getleftnode
compile leftnode  context true
else
context loadobject
context isconstantbranch setup  name
break
case callnode
compiledefinedcall node  context
break
case classvarnode
classvarnode ivisited    classvarnode  node
final object ending   context getnewending
final object failure   context getnewending
final object singleton   context getnewending
object second   context getnewending
object third   context getnewending
context loadcurrentmodule
context duplicatecurrentvalue
context ifnotnull second
context consumecurrentvalue
context loadself
context metaclass
context duplicatecurrentvalue
context isclassvardefined ivisited getname
new branchcallback
public void branch bodycompiler context
context consumecurrentvalue
context pushbytelist node class_variable_bytelist
context go ending
new branchcallback
public void branch bodycompiler context
context setending second
context duplicatecurrentvalue
context isclassvardefined ivisited getname
new branchcallback
public void branch bodycompiler context
context consumecurrentvalue
context pushbytelist node class_variable_bytelist
context go ending
new branchcallback
public void branch bodycompiler context
context setending third
context duplicatecurrentvalue
context ifsingleton singleton
context consumecurrentvalue
context go failure
context setending singleton
context attached
context notismoduleandclassvardefined ivisited getname    failure
context pushbytelist node class_variable_bytelist
context go ending
context setending failure
context pushnull
context setending ending
break
case zsupernode
object fail   context getnewending
object fail2   context getnewending
object fail_easy   context getnewending
object ending   context getnewending
context getframename
context duplicatecurrentvalue
context ifnull fail
context getframeklazz
context duplicatecurrentvalue
context ifnull fail2
context superclass
context ifnotsupermethodbound fail_easy
context pushbytelist node super_bytelist
context go ending
context setending fail2
context consumecurrentvalue
context setending fail
context consumecurrentvalue
context setending fail_easy
context pushnull
context setending ending
break
case supernode
object fail   context getnewending
object fail2   context getnewending
object fail_easy   context getnewending
object ending   context getnewending
context getframename
context duplicatecurrentvalue
context ifnull fail
context getframeklazz
context duplicatecurrentvalue
context ifnull fail2
context superclass
context ifnotsupermethodbound fail_easy
compilegetargumentdefinition   supernode  node  getargsnode    context
context go ending
context setending fail2
context consumecurrentvalue
context setending fail
context consumecurrentvalue
context setending fail_easy
context pushnull
context setending ending
break
case attrassignnode
final attrassignnode ivisited    attrassignnode  node
object isnull   context getnewending
object ending   context getnewending
compilegetdefinition ivisited getreceivernode    context
context ifnull isnull
context rescue new branchcallback
public void branch bodycompiler context
compile ivisited getreceivernode    context true
context duplicatecurrentvalue
context metaclass
context duplicatecurrentvalue
context getvisibilityfor ivisited getname
context duplicatecurrentvalue
final object isfalse   context getnewending
object isreal   context getnewending
object ending   context getnewending
context isprivate isfalse  3
context isnotprotected isreal  1
context selfiskindof isreal
context consumecurrentvalue
context go isfalse
context setending isreal
context ismethodbound ivisited getname    new branchcallback
public void branch bodycompiler context
compilegetargumentdefinition ivisited getargsnode    context
new branchcallback
public void branch bodycompiler context
context go isfalse
context go ending
context setending isfalse
context pushnull
context setending ending
jumpexception class
new branchcallback
public void branch bodycompiler context
context pushnull
bytelist class
context go ending
context setending isnull
context pushnull
context setending ending
break
default
context rescue new branchcallback
public void branch bodycompiler context
compile node  context true
context consumecurrentvalue
context pushnull
jumpexception class
new branchcallback
public void branch bodycompiler context
context pushnull
bytelist class
context consumecurrentvalue
context pushbytelist node expression_bytelist
protected void compiledefinedandordstrdregexp final node node  bodycompiler context
context rescue new branchcallback
public void branch bodycompiler context
compile node  context  false
context pushbytelist node expression_bytelist
jumpexception class
new branchcallback
public void branch bodycompiler context
context pushnull
bytelist class
protected void compiledefinedcall final node node  bodycompiler context
final callnode ivisited    callnode  node
object isnull   context getnewending
object ending   context getnewending
compilegetdefinition ivisited getreceivernode    context
context ifnull isnull
context rescue new branchcallback
public void branch bodycompiler context
compile ivisited getreceivernode    context  true
context definedcall ivisited getname
jumpexception class
new branchcallback
public void branch bodycompiler context
context pushnull
bytelist class
//          context.swapvalues();
//context.consumecurrentvalue();
context go ending
context setending isnull
context pushnull
context setending ending
protected void compiledefineddvar final node node  bodycompiler context
context pushbytelist node local_variable_in_block_bytelist
protected void compiledefinedbackref final node node  bodycompiler context
context backref
context isinstanceof rubymatchdata class
new branchcallback
public void branch bodycompiler context
context pushbytelist bytelist create       backrefnode  node  gettype
new branchcallback
public void branch bodycompiler context
context pushnull
protected void compiledefinednthref final node node  bodycompiler context
context iscaptured   nthrefnode  node  getmatchnumber
new branchcallback
public void branch bodycompiler context
context pushbytelist bytelist create       nthrefnode  node  getmatchnumber
new branchcallback
public void branch bodycompiler context
context pushnull
public void compiledasgn node node  bodycompiler context  boolean expr
final dasgnnode dasgnnode    dasgnnode  node
compilercallback value   new compilercallback
public void call bodycompiler context
compile dasgnnode getvaluenode    context  true
context getvariablecompiler   assignlocalvariable dasgnnode getindex    dasgnnode getdepth    value  expr
public void compiledasgnassignment node node  bodycompiler context  boolean expr
dasgnnode dasgnnode    dasgnnode  node
context getvariablecompiler   assignlocalvariable dasgnnode getindex    dasgnnode getdepth    expr
private node currentbodynode
public void compiledefn node node  bodycompiler context  boolean expr
final defnnode defnnode    defnnode  node
final argsnode argsnode   defnnode getargsnode
compilercallback body   new compilercallback
public void call bodycompiler context
if  defnnode getbodynode      null
node oldbodynode   currentbodynode
currentbodynode   defnnode getbodynode
if  defnnode getbodynode   instanceof rescuenode
// if root of method is rescue, compile as a light rescue
compilerescueinternal defnnode getbodynode    context  true
else
compile defnnode getbodynode    context  true
currentbodynode   oldbodynode
else
context loadnil
compilercallback args   new compilercallback
public void call bodycompiler context
compileargs argsnode  context  true
// inspect body and args
astinspector inspector   new astinspector
// check args first, since body inspection can depend on args
inspector inspect defnnode getargsnode
// if body is a rescue node, inspect its pieces separately to avoid it disabling all optz
// todo: this is gross.
if  defnnode getbodynode   instanceof rescuenode
rescuenode rescuenode    rescuenode defnnode getbodynode
inspector inspect rescuenode getbodynode
inspector inspect rescuenode getelsenode
inspector inspect rescuenode getrescuenode
else
inspector inspect defnnode getbodynode
context definenewmethod
defnnode getname    defnnode getargsnode   getarity   getvalue
defnnode getscope    body  args  null  inspector  isatroot
defnnode getposition   getfile    defnnode getposition   getstartline
runtimehelpers encodeparameterlist argsnode
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compiledefs node node  bodycompiler context  boolean expr
final defsnode defsnode    defsnode  node
final argsnode argsnode   defsnode getargsnode
compilercallback receiver   new compilercallback
public void call bodycompiler context
compile defsnode getreceivernode    context  true
compilercallback body   new compilercallback
public void call bodycompiler context
if  defsnode getbodynode      null
if  defsnode getbodynode   instanceof rescuenode
// if root of method is rescue, compile as light rescue
compilerescueinternal defsnode getbodynode    context  true
else
compile defsnode getbodynode    context  true
else
context loadnil
compilercallback args   new compilercallback
public void call bodycompiler context
compileargs argsnode  context  true
// inspect body and args
astinspector inspector   new astinspector
inspector inspect defsnode getargsnode
// if body is a rescue node, inspect its pieces separately to avoid it disabling all optz
// todo: this is gross.
if  defsnode getbodynode   instanceof rescuenode
rescuenode rescuenode    rescuenode defsnode getbodynode
inspector inspect rescuenode getbodynode
inspector inspect rescuenode getelsenode
inspector inspect rescuenode getrescuenode
else
inspector inspect defsnode getbodynode
context definenewmethod
defsnode getname    defsnode getargsnode   getarity   getvalue
defsnode getscope    body  args  receiver  inspector  false
defsnode getposition   getfile    defsnode getposition   getstartline
runtimehelpers encodeparameterlist argsnode
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileargs node node  bodycompiler context  boolean expr
final argsnode argsnode    argsnode  node
final int required   argsnode getrequiredargscount
final int opt   argsnode getoptionalargscount
final int rest   argsnode getrestarg
arraycallback requiredassignment   null
arraycallback optionalgiven   null
arraycallback optionalnotgiven   null
compilercallback restassignment   null
compilercallback blockassignment   null
if  required > 0
requiredassignment   new arraycallback
public void nextvalue bodycompiler context  object object  int index
// fixme: somehow i'd feel better if this could get the appropriate var index from the argumentnode
context getvariablecompiler   assignlocalvariable index  false
if  opt > 0
optionalgiven   new arraycallback
public void nextvalue bodycompiler context  object object  int index
node optarg     listnode  object  get index
compileassignment optarg  context  false
optionalnotgiven   new arraycallback
public void nextvalue bodycompiler context  object object  int index
node optarg     listnode  object  get index
compile optarg  context  false
if  rest >  1
restassignment   new compilercallback
public void call bodycompiler context
context getvariablecompiler   assignlocalvariable argsnode getrestarg    false
if  argsnode getblock      null
blockassignment   new compilercallback
public void call bodycompiler context
context getvariablecompiler   assignlocalvariable argsnode getblock   getcount    false
context getvariablecompiler   checkmethodarity required  opt  rest
context getvariablecompiler   assignmethodarguments argsnode getpre
argsnode getrequiredargscount
argsnode getoptargs
argsnode getoptionalargscount
requiredassignment
optionalgiven
optionalnotgiven
restassignment
blockassignment
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compiledot node node  bodycompiler context  boolean expr
final dotnode dotnode    dotnode  node
if  expr
compilercallback beginendcallback   new compilercallback
public void call bodycompiler context
compile dotnode getbeginnode    context  true
compile dotnode getendnode    context  true
context createnewrange beginendcallback  dotnode isexclusive
public void compiledregexp node node  bodycompiler context  boolean expr
final dregexpnode dregexpnode    dregexpnode  node
compilercallback createstringcallback   new compilercallback
public void call bodycompiler context
arraycallback dstrcallback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray
int index
compile dregexpnode get index   context  true
encoding enc   null
if  dregexpnode is19
enc   dregexpnode getencoding
context createnewstring dstrcallback  dregexpnode size    enc
if  expr
context createnewregexp createstringcallback  dregexpnode getoptions   toembeddedoptions
else
// not an expression, only compile the elements
for  node nextnode   dregexpnode childnodes
compile nextnode  context  false
public void compiledstr node node  bodycompiler context  boolean expr
final dstrnode dstrnode    dstrnode  node
arraycallback dstrcallback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray
int index
compile dstrnode get index   context  true
if  expr
encoding enc   null
if  dstrnode is19
enc   dstrnode getencoding
context createnewstring dstrcallback  dstrnode size    enc
else
// not an expression, only compile the elements
for  node nextnode   dstrnode childnodes
compile nextnode  context  false
public void compiledsymbol node node  bodycompiler context  boolean expr
final dsymbolnode dsymbolnode    dsymbolnode  node
arraycallback dstrcallback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray
int index
compile dsymbolnode get index   context  true
if  expr
encoding enc   null
if  dsymbolnode is19
enc   dsymbolnode getencoding
context createnewsymbol dstrcallback  dsymbolnode size    enc
else
// not an expression, only compile the elements
for  node nextnode   dsymbolnode childnodes
compile nextnode  context  false
public void compiledvar node node  bodycompiler context  boolean expr
dvarnode dvarnode    dvarnode  node
if  expr  context getvariablecompiler   retrievelocalvariable dvarnode getindex    dvarnode getdepth
public void compiledxstr node node  bodycompiler context  boolean expr
final dxstrnode dxstrnode    dxstrnode  node
final arraycallback dstrcallback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray
int index
compile dxstrnode get index   context true
argumentscallback argscallback   new argumentscallback
public int getarity
return 1
public void call bodycompiler context
encoding enc   null
if  dxstrnode is19
enc   dxstrnode getencoding
context createnewstring dstrcallback  dxstrnode size    enc
context getinvocationcompiler   invokedynamic    null  argscallback  calltype functional  null  false
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileensurenode node node  bodycompiler context  boolean expr
final ensurenode ensurenode    ensurenode  node
if  ensurenode getensurenode      null
context performensure new branchcallback
public void branch bodycompiler context
if  ensurenode getbodynode      null
compile ensurenode getbodynode    context  true
else
context loadnil
new branchcallback
public void branch bodycompiler context
compile ensurenode getensurenode    context  false
else
if  ensurenode getbodynode      null
compile ensurenode getbodynode    context true
else
context loadnil
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileevstr node node  bodycompiler context  boolean expr
final evstrnode evstrnode    evstrnode  node
compile evstrnode getbody    context true
context asstring
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilefalse node node  bodycompiler context  boolean expr
if  expr
context loadfalse
context pollthreadevents
public void compilefcall node node  bodycompiler context  boolean expr
final fcallnode fcallnode    fcallnode  node
argumentscallback argscallback   getargscallback fcallnode getargsnode
compilercallback closurearg   getblock fcallnode getiternode
dynopt  if  rubyinstanceconfig dynopt_compile_enabled
// dynopt does not handle non-local block flow control yet, so we bail out
if  fcallnode getiternode      null  break dynopt
if  fcallnode calladapter instanceof cachingcallsite
cachingcallsite cachesite    cachingcallsite fcallnode calladapter
if  cachesite isoptimizable
cacheentry entry   cachesite getcache
if  closurearg    null     argscallback    null     argscallback getarity   >  0    argscallback getarity   <  3
// recursive calls
if  compilerecursivecall fcallnode getname    entry token  calltype functional  fcallnode getiternode   instanceof iternode  entry method  context  argscallback  closurearg  expr   return
// peephole inlining for trivial targets
if  closurearg    null
argscallback    null
compiletrivialcall fcallnode getname    entry method  entry token  context  expr   return
if  fcallnode instanceof specialargs
context getinvocationcompiler   invokedynamicvarargs fcallnode getname    null  argscallback  calltype functional  closurearg  fcallnode getiternode   instanceof iternode
else
context getinvocationcompiler   invokedynamic fcallnode getname    null  argscallback  calltype functional  closurearg  fcallnode getiternode   instanceof iternode
// todo: don't require pop
if   expr  context consumecurrentvalue
private compilercallback getblock node node
if  node    null
return null
switch  node getnodetype
case iternode
final iternode iternode    iternode  node
return new compilercallback
public void call bodycompiler context
compile iternode  context true
case blockpassnode
final blockpassnode blockpassnode    blockpassnode  node
return new compilercallback
public void call bodycompiler context
compile blockpassnode getbodynode    context true
context unwrappassedblock
default
throw new notcompilableexception     node
public void compilefixnum node node  bodycompiler context  boolean expr
fixnumnode fixnumnode    fixnumnode  node
if  expr  context createnewfixnum fixnumnode getvalue
public void compileflip node node  bodycompiler context  boolean expr
final flipnode flipnode    flipnode  node
context getvariablecompiler   retrievelocalvariable flipnode getindex    flipnode getdepth
if  flipnode isexclusive
context performbooleanbranch new branchcallback
public void branch bodycompiler context
compile flipnode getendnode    context true
context performbooleanbranch new branchcallback
public void branch bodycompiler context
context loadfalse
context getvariablecompiler   assignlocalvariable flipnode getindex    flipnode getdepth    false
new branchcallback
public void branch bodycompiler context
context loadtrue
new branchcallback
public void branch bodycompiler context
compile flipnode getbeginnode    context true
becometrueorfalse context
context getvariablecompiler   assignlocalvariable flipnode getindex    flipnode getdepth    true
else
context performbooleanbranch new branchcallback
public void branch bodycompiler context
compile flipnode getendnode    context true
context performbooleanbranch new branchcallback
public void branch bodycompiler context
context loadfalse
context getvariablecompiler   assignlocalvariable flipnode getindex    flipnode getdepth    false
new branchcallback
public void branch bodycompiler context
context loadtrue
new branchcallback
public void branch bodycompiler context
compile flipnode getbeginnode    context true
context performbooleanbranch new branchcallback
public void branch bodycompiler context
compile flipnode getendnode    context true
fliptrueorfalse context
context getvariablecompiler   assignlocalvariable flipnode getindex    flipnode getdepth    false
context loadtrue
new branchcallback
public void branch bodycompiler context
context loadfalse
// todo: don't require pop
if   expr  context consumecurrentvalue
private void becometrueorfalse bodycompiler context
context performbooleanbranch new branchcallback
public void branch bodycompiler context
context loadtrue
new branchcallback
public void branch bodycompiler context
context loadfalse
private void fliptrueorfalse bodycompiler context
context performbooleanbranch new branchcallback
public void branch bodycompiler context
context loadfalse
new branchcallback
public void branch bodycompiler context
context loadtrue
public void compilefloat node node  bodycompiler context  boolean expr
floatnode floatnode    floatnode  node
if  expr  context createnewfloat floatnode getvalue
public void compilefor node node  bodycompiler context  boolean expr
final fornode fornode    fornode  node
compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile fornode getiternode    context  true
final compilercallback closurearg   new compilercallback
public void call bodycompiler context
compileforiter fornode  context
context getinvocationcompiler   invokedynamic    receivercallback  null  calltype normal  closurearg  true
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileforiter node node  bodycompiler context
final fornode fornode    fornode  node
// create the closure class and instantiate it
final compilercallback closurebody   new compilercallback
public void call bodycompiler context
if  fornode getbodynode      null
compile fornode getbodynode    context true
else
context loadnil
// create the closure class and instantiate it
final compilercallback closureargs   new compilercallback
public void call bodycompiler context
if  fornode getvarnode      null
compileassignment fornode getvarnode    context  false
// consume the block, since for loops can't receive block
context consumecurrentvalue
boolean hasmultipleargshead   false
if  fornode getvarnode   instanceof multipleasgnnode
hasmultipleargshead     multipleasgnnode  fornode getvarnode    getheadnode      null
nodetype argsnodeid   null
if  fornode getvarnode      null
argsnodeid   fornode getvarnode   getnodetype
astinspector inspector   new astinspector
inspector inspect fornode getbodynode
inspector inspect fornode getvarnode
// force heap-scope behavior, since it uses parent's scope
inspector setflag fornode  astinspector closure
context createnewforloop arity procarityof fornode getvarnode    getvalue
closurebody  closureargs  hasmultipleargshead  argsnodeid  inspector
public void compileglobalasgn node node  bodycompiler context  boolean expr
final globalasgnnode globalasgnnode    globalasgnnode  node
compilercallback value   new compilercallback
public void call bodycompiler context
compile globalasgnnode getvaluenode    context  true
if  globalasgnnode getname   length      2
switch  globalasgnnode getname   charat 1
case
context getvariablecompiler   assignlastline value
break
case
context getvariablecompiler   assignbackref value
break
default
context assignglobalvariable globalasgnnode getname    value
else
context assignglobalvariable globalasgnnode getname    value
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileglobalasgnassignment node node  bodycompiler context  boolean expr
globalasgnnode globalasgnnode    globalasgnnode  node
if  globalasgnnode getname   length      2
switch  globalasgnnode getname   charat 1
case
context getvariablecompiler   assignlastline
break
case
context getvariablecompiler   assignbackref
break
default
context assignglobalvariable globalasgnnode getname
else
context assignglobalvariable globalasgnnode getname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileglobalvar node node  bodycompiler context  boolean expr
globalvarnode globalvarnode    globalvarnode  node
if  expr
if  globalvarnode getname   length      2
switch  globalvarnode getname   charat 1
case
context getvariablecompiler   retrievelastline
break
case
context getvariablecompiler   retrievebackref
break
default
context retrieveglobalvariable globalvarnode getname
else
context retrieveglobalvariable globalvarnode getname
public void compilehash node node  bodycompiler context  boolean expr
compilehashcommon  hashnode  node  context  expr
protected void compilehashcommon hashnode hashnode  bodycompiler context  boolean expr
if  expr
if  hashnode getlistnode      null    hashnode getlistnode   size      0
context createemptyhash
return
arraycallback hashcallback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray
int index
listnode listnode    listnode  sourcearray
int keyindex   index   2
compile listnode get keyindex   context  true
compile listnode get keyindex   1   context  true
if  islistallliterals hashnode getlistnode
context createnewliteralhash hashnode getlistnode    hashcallback  hashnode getlistnode   size     2
else
context createnewhash hashnode getlistnode    hashcallback  hashnode getlistnode   size     2
else
for  node nextnode   hashnode getlistnode   childnodes
compile nextnode  context  false
protected void createnewhash bodycompiler context  hashnode hashnode  arraycallback hashcallback
context createnewhash hashnode getlistnode    hashcallback  hashnode getlistnode   size     2
public void compileif node node  bodycompiler context  final boolean expr
final ifnode ifnode    ifnode  node
// optimizations if we know ahead of time it will always be true or false
node actualcondition   ifnode getcondition
while  actualcondition instanceof newlinenode
actualcondition     newlinenode actualcondition  getnextnode
if  actualcondition getnodetype   alwaystrue
// compile condition as non-expr and just compile "then" body
compile actualcondition  context  false
compile ifnode getthenbody    context  expr
else if  actualcondition getnodetype   alwaysfalse
// always false or nil
compile ifnode getelsebody    context  expr
else
branchcallback truecallback   new branchcallback
public void branch bodycompiler context
if  ifnode getthenbody      null
compile ifnode getthenbody    context  expr
else
if  expr  context loadnil
branchcallback falsecallback   new branchcallback
public void branch bodycompiler context
if  ifnode getelsebody      null
compile ifnode getelsebody    context  expr
else
if  expr  context loadnil
// normal
compilecondition actualcondition  context  true
context performbooleanbranch2 truecallback  falsecallback
public void compilecondition node node  bodycompiler context  boolean expr
switch  node getnodetype
case callnode
final callnode callnode    callnode node
if  callnode getargsnode      null
list<node> args   callnode getargsnode   childnodes
if  args size      1    args get 0  instanceof fixnumnode
final fixnumnode fixnumnode    fixnumnode args get 0
if  callnode getname   equals
callnode getname   equals
callnode getname   equals
callnode getname   equals
callnode getname   equals
context getinvocationcompiler   invokebinarybooleanfixnumrhs
callnode getname
new compilercallback
public void call bodycompiler context
compile callnode getreceivernode    context  true
fixnumnode getvalue
return
// otherwise normal call
compile node  context  expr
context istrue
public void compileinstasgn node node  bodycompiler context  boolean expr
final instasgnnode instasgnnode    instasgnnode  node
compilercallback value   new compilercallback
public void call bodycompiler context
compile instasgnnode getvaluenode    context  true
context assigninstancevariable instasgnnode getname    value
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileinstasgnassignment node node  bodycompiler context  boolean expr
instasgnnode instasgnnode    instasgnnode  node
context assigninstancevariable instasgnnode getname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileinstvar node node  bodycompiler context  boolean expr
instvarnode instvarnode    instvarnode  node
if  expr  context retrieveinstancevariable instvarnode getname
public void compileiter node node  bodycompiler context
final iternode iternode    iternode  node
// create the closure class and instantiate it
final compilercallback closurebody   new compilercallback
public void call bodycompiler context
if  iternode getbodynode      null
compile iternode getbodynode    context  true
else
context loadnil
// create the closure class and instantiate it
final compilercallback closureargs   new compilercallback
public void call bodycompiler context
if  iternode getvarnode      null
compileassignment iternode getvarnode    context  false
else
context consumecurrentvalue
if  iternode getblockvarnode      null
compileassignment iternode getblockvarnode    context  false
else
context consumecurrentvalue
boolean hasmultipleargshead   false
if  iternode getvarnode   instanceof multipleasgnnode
hasmultipleargshead     multipleasgnnode  iternode getvarnode    getheadnode      null
nodetype argsnodeid   blockbody getargumenttypewackyhack iternode
astinspector inspector   new astinspector
inspector inspect iternode getbodynode
inspector inspect iternode getvarnode
context createnewclosure iternode getposition   getfile    iternode getposition   getstartline    iternode getscope    arity procarityof iternode getvarnode    getvalue
closurebody  closureargs  hasmultipleargshead  argsnodeid  inspector
public void compileliteral literalnode literal  bodycompiler context
context literal literal getname
public void compilelocalasgn node node  bodycompiler context  boolean expr
final localasgnnode localasgnnode    localasgnnode  node
// just push nil for pragmas
if  astinspector pragmas contains localasgnnode getname
if  expr  context loadnil
else
compilercallback value   new compilercallback
public void call bodycompiler context
compile localasgnnode getvaluenode    context true
context getvariablecompiler   assignlocalvariable localasgnnode getindex    localasgnnode getdepth    value  expr
public void compilelocalasgnassignment node node  bodycompiler context  boolean expr
// "assignment" means the value is already on the stack
localasgnnode localasgnnode    localasgnnode  node
context getvariablecompiler   assignlocalvariable localasgnnode getindex    localasgnnode getdepth    expr
public void compilelocalvar node node  bodycompiler context  boolean expr
localvarnode localvarnode    localvarnode  node
if  expr  context getvariablecompiler   retrievelocalvariable localvarnode getindex    localvarnode getdepth
public void compilematch node node  bodycompiler context  boolean expr
matchnode matchnode    matchnode  node
compile matchnode getregexpnode    context true
context match is1_9
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilematch2 node node  bodycompiler context  boolean expr
final match2node matchnode    match2node  node
compile matchnode getreceivernode    context true
compilercallback value   new compilercallback
public void call bodycompiler context
compile matchnode getvaluenode    context true
context match2 value  is1_9
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilematch3 node node  bodycompiler context  boolean expr
match3node matchnode    match3node  node
compile matchnode getreceivernode    context true
compile matchnode getvaluenode    context true
context match3 is1_9
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilemodule node node  bodycompiler context  boolean expr
final modulenode modulenode    modulenode  node
final node cpathnode   modulenode getcpath
compilercallback bodycallback   new compilercallback
public void call bodycompiler context
if  modulenode getbodynode      null
compile modulenode getbodynode    context true
context loadnil
compilercallback pathcallback   new compilercallback
public void call bodycompiler context
if  cpathnode instanceof colon2node
node leftnode     colon2node  cpathnode  getleftnode
if  leftnode    null
compile leftnode  context true
else
context loadnil
else if  cpathnode instanceof colon3node
context loadobject
else
context loadnil
astinspector inspector   new astinspector
inspector inspect modulenode getbodynode
context definemodule modulenode getcpath   getname    modulenode getscope    pathcallback  bodycallback  inspector
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilemultipleasgn node node  bodycompiler context  boolean expr
multipleasgnnode multipleasgnnode    multipleasgnnode  node
if  expr
if  rubyinstanceconfig fast_multiple_assignment
// optimized version, but expr so return true
compileoptimizedmultipleasgn multipleasgnnode  context  false
context loadtrue
else
// need the array, use unoptz version
compileunoptimizedmultipleasgn multipleasgnnode  context  expr
else
// try optz version
compileoptimizedmultipleasgn multipleasgnnode  context  expr
private void compileoptimizedmultipleasgn multipleasgnnode multipleasgnnode  bodycompiler context  boolean expr
// expect value to be an array of nodes
if  multipleasgnnode getvaluenode   instanceof arraynode
// head must not be null and there must be no "args" (like *arg)
if  multipleasgnnode getheadnode      null    multipleasgnnode getargsnode      null
// sizes must match
if  multipleasgnnode getheadnode   size        arraynode multipleasgnnode getvaluenode    size
// "head" must have no non-trivial assigns (array groupings, basically)
boolean normalassigns   true
for  node asgn   multipleasgnnode getheadnode   childnodes
if  asgn instanceof listnode
normalassigns   false
break
if  normalassigns
// only supports simple parallel assignment of up to 10 values to the same number of assignees
int size   multipleasgnnode getheadnode   size
if  size >  2    size <  10
arraynode values    arraynode multipleasgnnode getvaluenode
for  node value   values childnodes
compile value  context  true
context reversevalues size
for  node asgn   multipleasgnnode getheadnode   childnodes
compileassignment asgn  context  false
return
else
// special case for x, *y = whatever
if  multipleasgnnode getheadnode      null
multipleasgnnode getheadnode   size      1
multipleasgnnode getvaluenode   instanceof toarynode
multipleasgnnode getargsnode      null
// emit the value
compile multipleasgnnode getvaluenode   childnodes   get 0   context  true
if  multipleasgnnode getargsnode   instanceof starnode
// slice puts on stack in reverse order
context premultiassign 1  false
// assign
compileassignment multipleasgnnode getheadnode   childnodes   get 0   context  false
else
// slice puts on stack in reverse order
context premultiassign 1  true
// assign
compileassignment multipleasgnnode getheadnode   childnodes   get 0   context  false
compileassignment multipleasgnnode getargsnode    context  false
return
// if we get here, no optz cases work; fall back on unoptz.
compileunoptimizedmultipleasgn multipleasgnnode  context  expr
private void compileunoptimizedmultipleasgn multipleasgnnode multipleasgnnode  bodycompiler context  boolean expr
compile multipleasgnnode getvaluenode    context  true
compilemultipleasgnassignment multipleasgnnode  context  expr
public void compilemultipleasgnassignment node node  bodycompiler context  boolean expr
final multipleasgnnode multipleasgnnode    multipleasgnnode  node
// normal items at the "head" of the masgn
arraycallback headassigncallback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray
int index
listnode headnode    listnode  sourcearray
node assignnode   headnode get index
// perform assignment for the next node
compileassignment assignnode  context  false
compilercallback argscallback   new compilercallback
public void call bodycompiler context
node argsnode   multipleasgnnode getargsnode
if  argsnode instanceof starnode
// done processing args
context consumecurrentvalue
else
// assign to appropriate variable
compileassignment argsnode  context  false
if  multipleasgnnode getheadnode      null
if  multipleasgnnode getargsnode      null
throw new notcompilableexception     multipleasgnnode getposition
else
if  multipleasgnnode getargsnode   instanceof starnode
// do nothing
else
context ensuremultipleassignablerubyarray multipleasgnnode getheadnode      null
context foreachinvaluearray 0  0  null  null  argscallback
else
context ensuremultipleassignablerubyarray multipleasgnnode getheadnode      null
if  multipleasgnnode getargsnode      null
context foreachinvaluearray 0  multipleasgnnode getheadnode   size    multipleasgnnode getheadnode    headassigncallback  null
else
context foreachinvaluearray 0  multipleasgnnode getheadnode   size    multipleasgnnode getheadnode    headassigncallback  argscallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilenewline node node  bodycompiler context  boolean expr
context linenumber node getposition
context setlineposition node getposition
if  rubyinstanceconfig full_trace_enabled  context traceline
newlinenode newlinenode    newlinenode  node
compile newlinenode getnextnode    context  expr
public void compilenext node node  bodycompiler context  boolean expr
final nextnode nextnode    nextnode  node
compilercallback valuecallback   new compilercallback
public void call bodycompiler context
if  nextnode getvaluenode      null
compile nextnode getvaluenode    context true
else
context loadnil
context pollthreadevents
context issuenextevent valuecallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilenthref node node  bodycompiler context  boolean expr
nthrefnode nthrefnode    nthrefnode  node
if  expr  context nthref nthrefnode getmatchnumber
public void compilenil node node  bodycompiler context  boolean expr
if  expr
context loadnil
public void compilenot node node  bodycompiler context  boolean expr
notnode notnode    notnode  node
compile notnode getconditionnode    context  true
context negatecurrentvalue
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileopasgnand node node  bodycompiler context  boolean expr
final binaryoperatornode andnode    binaryoperatornode  node
compile andnode getfirstnode    context true
branchcallback longcallback   new branchcallback
public void branch bodycompiler context
compile andnode getsecondnode    context true
context performlogicaland longcallback
context pollthreadevents
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileopasgnor node node  bodycompiler context  boolean expr
final opasgnornode ornode    opasgnornode  node
if  needsdefinitioncheck ornode getfirstnode
compilegetdefinitionbase ornode getfirstnode    context
context isnull new branchcallback
public void branch bodycompiler context
compile ornode getsecondnode    context true
new branchcallback
public void branch bodycompiler context
compile ornode getfirstnode    context true
context duplicatecurrentvalue
context performbooleanbranch new branchcallback
public void branch bodycompiler context
//do nothing
new branchcallback
public void branch bodycompiler context
context consumecurrentvalue
compile ornode getsecondnode    context true
else
compile ornode getfirstnode    context true
context duplicatecurrentvalue
context performbooleanbranch new branchcallback
public void branch bodycompiler context
//do nothing
new branchcallback
public void branch bodycompiler context
context consumecurrentvalue
compile ornode getsecondnode    context true
context pollthreadevents
// todo: don't require pop
if   expr  context consumecurrentvalue
/**
* check whether the given node is considered always "defined" or whether it
* has some form of definition check.
*
* @param node then node to check
* @return whether the type of node represents a possibly undefined construct
*/
private boolean needsdefinitioncheck node node
switch  node getnodetype
case classvarasgnnode
case classvardeclnode
case constdeclnode
case dasgnnode
case globalasgnnode
case localasgnnode
case multipleasgnnode
case opasgnnode
case opelementasgnnode
case dvarnode
case falsenode
case truenode
case localvarnode
case match2node
case match3node
case nilnode
case selfnode
// all these types are immediately considered "defined"
return false
default
return true
public void compileopasgn node node  bodycompiler context  boolean expr
final opasgnnode opasgnnode    opasgnnode  node
if  opasgnnode getoperatorname   equals
compileopasgnwithor opasgnnode  context  true
else if  opasgnnode getoperatorname   equals
compileopasgnwithand opasgnnode  context  true
else
compileopasgnwithmethod opasgnnode  context  true
context pollthreadevents
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileopasgnwithor node node  bodycompiler context  boolean expr
final opasgnnode opasgnnode    opasgnnode  node
final compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile opasgnnode getreceivernode    context  true
argumentscallback argscallback   getargscallback opasgnnode getvaluenode
context getinvocationcompiler   invokeopasgnwithor opasgnnode getvariablename    opasgnnode getvariablenameasgn    receivercallback  argscallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileopasgnwithand node node  bodycompiler context  boolean expr
final opasgnnode opasgnnode    opasgnnode  node
final compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile opasgnnode getreceivernode    context  true
argumentscallback argscallback   getargscallback opasgnnode getvaluenode
context getinvocationcompiler   invokeopasgnwithand opasgnnode getvariablename    opasgnnode getvariablenameasgn    receivercallback  argscallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileopasgnwithmethod node node  bodycompiler context  boolean expr
final opasgnnode opasgnnode    opasgnnode  node
final compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile opasgnnode getreceivernode    context  true
// eval new value, call operator on old value, and assign
argumentscallback argscallback   new argumentscallback
public int getarity
return 1
public void call bodycompiler context
compile opasgnnode getvaluenode    context  true
context getinvocationcompiler   invokeopasgnwithmethod opasgnnode getoperatorname    opasgnnode getvariablename    opasgnnode getvariablenameasgn    receivercallback  argscallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileopelementasgn node node  bodycompiler context  boolean expr
final opelementasgnnode opelementasgnnode    opelementasgnnode  node
if  opelementasgnnode getoperatorname
compileopelementasgnwithor node  context  expr
else if  opelementasgnnode getoperatorname
compileopelementasgnwithand node  context  expr
else
compileopelementasgnwithmethod node  context  expr
private class opelementasgnargumentscallback implements argumentscallback
private node node
public opelementasgnargumentscallback node node
this node   node
public int getarity
switch  node getnodetype
case argscatnode
case argspushnode
case splatnode
return  1
case arraynode
arraynode arraynode    arraynode node
if  arraynode size      0
return 0
else if  arraynode size   > 3
return  1
else
return   arraynode node  size
default
return 1
public void call bodycompiler context
if  getarity      1
// if arity 1, just compile the one element to save us the array cost
compile   arraynode node  get 0   context true
else
// compile into array
compilearguments node  context
public void compileopelementasgnwithor node node  bodycompiler context  boolean expr
final opelementasgnnode opelementasgnnode    opelementasgnnode  node
compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile opelementasgnnode getreceivernode    context  true
argumentscallback argscallback   new opelementasgnargumentscallback opelementasgnnode getargsnode
compilercallback valuecallback   new compilercallback
public void call bodycompiler context
compile opelementasgnnode getvaluenode    context  true
context getinvocationcompiler   opelementasgnwithor receivercallback  argscallback  valuecallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileopelementasgnwithand node node  bodycompiler context  boolean expr
final opelementasgnnode opelementasgnnode    opelementasgnnode  node
compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile opelementasgnnode getreceivernode    context  true
argumentscallback argscallback   new opelementasgnargumentscallback opelementasgnnode getargsnode
compilercallback valuecallback   new compilercallback
public void call bodycompiler context
compile opelementasgnnode getvaluenode    context  true
context getinvocationcompiler   opelementasgnwithand receivercallback  argscallback  valuecallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileopelementasgnwithmethod node node  bodycompiler context  boolean expr
final opelementasgnnode opelementasgnnode    opelementasgnnode  node
compilercallback receivercallback   new compilercallback
public void call bodycompiler context
compile opelementasgnnode getreceivernode    context true
argumentscallback argscallback   getargscallback opelementasgnnode getargsnode
compilercallback valuecallback   new compilercallback
public void call bodycompiler context
compile opelementasgnnode getvaluenode    context true
context getinvocationcompiler   opelementasgnwithmethod receivercallback  argscallback  valuecallback  opelementasgnnode getoperatorname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileor node node  bodycompiler context  boolean expr
final ornode ornode    ornode  node
if  ornode getfirstnode   getnodetype   alwaystrue
// compile first node only
compile ornode getfirstnode    context  expr
else if  ornode getfirstnode   getnodetype   alwaysfalse
// compile first node as non-expr and compile second node
compile ornode getfirstnode    context  false
compile ornode getsecondnode    context  expr
else
compile ornode getfirstnode    context  true
branchcallback longcallback   new branchcallback
public void branch bodycompiler context
compile ornode getsecondnode    context  true
context performlogicalor longcallback
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilepostexe node node  bodycompiler context  boolean expr
final postexenode postexenode    postexenode  node
// create the closure class and instantiate it
final compilercallback closurebody   new compilercallback
public void call bodycompiler context
if  postexenode getbodynode      null
compile postexenode getbodynode    context  true
else
context loadnil
context createnewendblock closurebody
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilepreexe node node  bodycompiler context  boolean expr
final preexenode preexenode    preexenode  node
// create the closure class and instantiate it
final compilercallback closurebody   new compilercallback
public void call bodycompiler context
if  preexenode getbodynode      null
compile preexenode getbodynode    context true
else
context loadnil
context runbeginblock preexenode getscope    closurebody
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileredo node node  bodycompiler context  boolean expr
//redonode redonode = (redonode)node;
context issueredoevent
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileregexp node node  bodycompiler context  boolean expr
regexpnode renode    regexpnode  node
if  expr  context createnewregexp renode getvalue    renode getoptions   toembeddedoptions
public void compilerescue node node  bodycompiler context  boolean expr
compilerescueinternal node  context  false
// todo: don't require pop
if   expr  context consumecurrentvalue
private void compilerescueinternal node node  bodycompiler context  final boolean light
final rescuenode rescuenode    rescuenode  node
branchcallback body   new branchcallback
public void branch bodycompiler context
if  rescuenode getbodynode      null
compile rescuenode getbodynode    context  true
else
context loadnil
branchcallback elsebody   null
if  rescuenode getelsenode      null
elsebody   new branchcallback
public void branch bodycompiler context
context consumecurrentvalue
compile rescuenode getelsenode    context  true
branchcallback rubyhandler   new branchcallback
public void branch bodycompiler context
compilerescuebodyinternal rescuenode getrescuenode    context  light
astinspector rescueinspector   new astinspector
rescueinspector inspect rescuenode getrescuenode
if  light
context performrescuelight body  rubyhandler  elsebody  rescueinspector getflag astinspector retry
else
context performrescue body  rubyhandler  elsebody  rescueinspector getflag astinspector retry
private void compilerescuebodyinternal node node  bodycompiler context  final boolean light
final rescuebodynode rescuebodynode    rescuebodynode  node
context loadexception
final node exceptionlist   rescuebodynode getexceptionnodes
argumentscallback rescueargs   getargscallback exceptionlist
if  rescueargs    null  rescueargs   new argumentscallback
public int getarity
return 1
public void call bodycompiler context
context loadstandarderror
context checkisexceptionhandled rescueargs
branchcallback truebranch   new branchcallback
public void branch bodycompiler context
// check if it's an immediate, and don't outline
node realbody   rescuebodynode getbodynode
if  realbody instanceof newlinenode
context setlineposition realbody getposition
while  realbody instanceof newlinenode
realbody     newlinenode realbody  getnextnode
if  realbody getnodetype   isimmediate
compile realbody  context  true
context clearerrorinfo
else
// fixme
// this is using the static constant name being rescued to determine
// whether to lazily wrap, where the interpreter actually uses the
// runtime rescued type. this is a behavioral difference, but only
// visible if someone is rescuing nativeexception as some other name.
// it should be fixed to do it "right" but as rescuing nativeexception
// is largely deprecated, this may be a non-issue.
list<node> exceptionnodes   null
if  exceptionlist    null
exceptionnodes   exceptionlist childnodes
if  exceptionnodes    null
exceptionnodes size      1
exceptionnodes get 0  instanceof constnode
constnode  exceptionnodes get 0   getname   equals
context storenativeexceptioninerrorinfo
else
context storeexceptioninerrorinfo
if  light
compile rescuebodynode getbodynode    context  true
else
bodycompiler nestedbody   context outline     rescuebodynode getposition   getstartline
compile rescuebodynode getbodynode    nestedbody  true
nestedbody endbody
// fixme: this should reset to what it was before
context clearerrorinfo
branchcallback falsebranch   new branchcallback
public void branch bodycompiler context
if  rescuebodynode getoptrescuenode      null
compilerescuebodyinternal rescuebodynode getoptrescuenode    context  light
else
context rethrowexception
context performbooleanbranch truebranch  falsebranch
public void compileretry node node  bodycompiler context  boolean expr
context pollthreadevents
context issueretryevent
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilereturn node node  bodycompiler context  boolean expr
returnnode returnnode    returnnode  node
if  returnnode getvaluenode      null
compile returnnode getvaluenode    context true
else
context loadnil
context performreturn
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileroot node node  scriptcompiler context  astinspector inspector
compileroot node  context  inspector  true  true
public void compileroot node node  scriptcompiler context  astinspector inspector  boolean load  boolean main
rootnode rootnode    rootnode  node
staticscope staticscope   rootnode getstaticscope
context startscript staticscope
// force static scope to claim restarg at 0, so it only implements the [] version of __file__
staticscope setrestarg  2
// create method for toplevel of script
bodycompiler methodcompiler   context startfilemethod null  staticscope  inspector
node nextnode   rootnode getbodynode
if  nextnode    null
if  nextnode getnodetype      nodetype blocknode
// it's a multiple-statement body, iterate over all elements in turn and chain if it get too long
blocknode blocknode    blocknode  nextnode
for  int i   0  i < blocknode size    i
if   i   1  % rubyinstanceconfig chained_compile_line_count    0
methodcompiler   methodcompiler chaintomethod      i   1
compile blocknode get i   methodcompiler  i   1 >  blocknode size
else
// single-statement body, just compile it
compile nextnode  methodcompiler true
else
methodcompiler loadnil
methodcompiler endbody
context endscript load  main
public void compileself node node  bodycompiler context  boolean expr
if  expr  context retrieveself
public void compilesplat node node  bodycompiler context  boolean expr
splatnode splatnode    splatnode  node
compile splatnode getvalue    context  true
splatcurrentvalue context
// todo: don't require pop
if   expr  context consumecurrentvalue
protected void splatcurrentvalue bodycompiler context
context splatcurrentvalue
public void compilestr node node  bodycompiler context  boolean expr
strnode strnode    strnode  node
if  expr
if  strnode instanceof filenode
context loadfilename
else
context createnewstring strnode getvalue    strnode getcoderange
public void compilesuper node node  bodycompiler context  boolean expr
final supernode supernode    supernode  node
argumentscallback argscallback   getargscallback supernode getargsnode
compilercallback closurearg   getblock supernode getiternode
// this is a hacky check; would prefer arity-split super nodes like call and fcall
if  supernode getargsnode   instanceof argscatnode
context getinvocationcompiler   invokedynamicvarargs null  null  argscallback  calltype super  closurearg  supernode getiternode   instanceof iternode
else
context getinvocationcompiler   invokedynamic null  null  argscallback  calltype super  closurearg  supernode getiternode   instanceof iternode
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilesvalue node node  bodycompiler context  boolean expr
svaluenode svaluenode    svaluenode  node
compile svaluenode getvalue    context true
context singlifysplattedvalue
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilesymbol node node  bodycompiler context  boolean expr
context createnewsymbol   symbolnode  node  getname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compiletoary node node  bodycompiler context  boolean expr
toarynode toarynode    toarynode  node
compile toarynode getvalue    context true
context arytoary
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compiletrue node node  bodycompiler context  boolean expr
if  expr
context loadtrue
context pollthreadevents
public void compileundef final undefnode undef  bodycompiler context  boolean expr
compilercallback namearg   new compilercallback
public void call bodycompiler context
compile undef getname    context  true
context undefmethod namearg
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileuntil node node  bodycompiler context  boolean expr
final untilnode untilnode    untilnode  node
if  untilnode getconditionnode   getnodetype   alwaystrue
untilnode evaluateatstart
// condition is always true, just compile it and not body
compile untilnode getconditionnode    context  false
if  expr  context loadnil
else
branchcallback condition   new branchcallback
public void branch bodycompiler context
compile untilnode getconditionnode    context  true
context negatecurrentvalue
branchcallback body   new branchcallback
public void branch bodycompiler context
if  untilnode getbodynode      null
compile untilnode getbodynode    context  true
if  untilnode containsnonlocalflow
context performbooleanloopsafe condition  body  untilnode evaluateatstart
else
context performbooleanlooplight condition  body  untilnode evaluateatstart
context pollthreadevents
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilevalias node node  bodycompiler context  boolean expr
valiasnode valiasnode    valiasnode  node
context aliasglobal valiasnode getnewname    valiasnode getoldname
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilevcall node node  bodycompiler context  boolean expr
vcallnode vcallnode    vcallnode  node
if  rubyinstanceconfig dynopt_compile_enabled
if  vcallnode calladapter instanceof cachingcallsite
cachingcallsite cachesite    cachingcallsite vcallnode calladapter
if  cachesite isoptimizable
cacheentry entry   cachesite getcache
// recursive calls
if  compilerecursivecall vcallnode getname    entry token  calltype variable  false  entry method  context  null  null  expr   return
// peephole inlining for trivial targets
if  compiletrivialcall vcallnode getname    entry method  entry token  context  expr   return
context getinvocationcompiler   invokedynamic vcallnode getname    null  null  calltype variable  null  false
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilewhile node node  bodycompiler context  boolean expr
final whilenode whilenode    whilenode  node
if  whilenode getconditionnode   getnodetype   alwaysfalse
whilenode evaluateatstart
// do nothing
if  expr  context loadnil
else
branchcallback condition   new branchcallback
public void branch bodycompiler context
compile whilenode getconditionnode    context  true
branchcallback body   new branchcallback
public void branch bodycompiler context
if  whilenode getbodynode      null
compile whilenode getbodynode    context  true
if  whilenode containsnonlocalflow
context performbooleanloopsafe condition  body  whilenode evaluateatstart
else
context performbooleanlooplight condition  body  whilenode evaluateatstart
context pollthreadevents
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilexstr node node  bodycompiler context  boolean expr
final xstrnode xstrnode    xstrnode  node
argumentscallback argscallback   new argumentscallback
public int getarity
return 1
public void call bodycompiler context
// fixme: shouldn't this have coderange like strnode?
context createnewstring xstrnode getvalue    stringsupport cr_unknown
context getinvocationcompiler   invokedynamic    null  argscallback  calltype functional  null  false
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileyield node node  bodycompiler context  boolean expr
final yieldnode yieldnode    yieldnode  node
argumentscallback argscallback   getargscallback yieldnode getargsnode
// todo: this filtering is kind of gross...it would be nice to get some parser help here
if  argscallback    null    argscallback getarity      0
context getinvocationcompiler   yieldspecific argscallback
else if   argscallback getarity      1    argscallback getarity      2    argscallback getarity      3     yieldnode getexpandarguments
// send it along as arity-specific, we don't need the array
context getinvocationcompiler   yieldspecific argscallback
else
compilercallback argscallback2   null
if  yieldnode getargsnode      null
argscallback2   new compilercallback
public void call bodycompiler context
compile yieldnode getargsnode    context true
context getinvocationcompiler   yield argscallback2  yieldnode getexpandarguments
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilezarray node node  bodycompiler context  boolean expr
if  expr
context createemptyarray
public void compilezsuper node node  bodycompiler context  boolean expr
zsupernode zsupernode    zsupernode  node
compilercallback closure   getblock zsupernode getiternode
context callzsuper closure
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileargscatarguments node node  bodycompiler context  boolean expr
argscatnode argscatnode    argscatnode  node
// arguments compilers always create irubyobject[], but since we then combine
// with another irubyobject[] from coercing second node to array, this can
// be inefficient. escape analysis may help, though.
compilearguments argscatnode getfirstnode    context
compile argscatnode getsecondnode    context true
context argscattoarguments
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compileargspusharguments node node  bodycompiler context  boolean expr
argspushnode argspushnode    argspushnode  node
// this constructs one or more intermediate irubyobject[] because that's what
// arguments compilation produces, so it may be inefficient. escape
// analysis may help.
compilearguments argspushnode getfirstnode    context
compile argspushnode getsecondnode    context true
context appendtoobjectarray
// todo: don't require pop
if   expr  context consumecurrentvalue
public void compilearrayarguments node node  bodycompiler context  boolean expr
arraynode arraynode    arraynode  node
arraycallback callback   new arraycallback
public void nextvalue bodycompiler context  object sourcearray  int index
node node    node    object  sourcearray
compile node  context true
context setlineposition arraynode getposition
context createobjectarray arraynode childnodes   toarray    callback
// todo: don't require pop
if   expr  context consumecurrentvalue
// leave as a normal array
public void compilesplatarguments node node  bodycompiler context  boolean expr
splatnode splatnode    splatnode  node
compile splatnode getvalue    context true
context splattoarguments
// todo: don't require pop
if   expr  context consumecurrentvalue