/*
***** begin license block *****
* version: cpl 1.0/gpl 2.0/lgpl 2.1
*
* the contents of this file are subject to the common public
* license version 1.0 (the "license"); you may not use this file
* except in compliance with the license. you may obtain a copy of
* the license at http://www.eclipse.org/legal/cpl-v10.html
*
* software distributed under the license is distributed on an "as
* is" basis, without warranty of any kind, either express or
* implied. see the license for the specific language governing
* rights and limitations under the license.
*
* copyright (c) 2008 charles o nutter <headius@headius.com>
*
* alternatively, the contents of this file may be used under the terms of
* either of the gnu general public license version 2 or later (the "gpl"),
* or the gnu lesser general public license version 2.1 or later (the "lgpl"),
* in which case the provisions of the gpl or the lgpl are applicable instead
* of those above. if you wish to allow use of your version of this file only
* under the terms of either the gpl or the lgpl, and not to allow others to
* use your version of this file under the terms of the cpl, indicate your
* decision by deleting the provisions above and replace them with the notice
* and other provisions required by the gpl or the lgpl. if you do not delete
* the provisions above, a recipient may use your version of this file under
* the terms of any one of the cpl, the gpl or the lgpl.
***** end license block *****/
package org jruby util io
import static org jruby util io modeflags rdonly
import static org jruby util io modeflags rdwr
import static org jruby util io modeflags wronly
import java io file
import java io filedescriptor
import java io filenotfoundexception
import java io fileoutputstream
import java io ioexception
import java io inputstream
import java io randomaccessfile
import java net url
import java nio bytebuffer
import java nio channels channel
import java nio channels channels
import java nio channels filechannel
import java nio channels readablebytechannel
import java nio channels writablebytechannel
import java util map
import java util concurrent concurrenthashmap
import java util concurrent atomic atomicinteger
import java util jar jarfile
import java util zip zipentry
import org jruby rubyfile
import jnr posix posix
import org jruby util bytelist
import org jruby util jrubyfile
import org jruby util log logger
import org jruby util log loggerfactory
/**
* channeldescriptor provides an abstraction similar to the concept of a
* "file descriptor" on any posix system. in our case, it's a numbered object
* (fileno) enclosing a channel (@see java.nio.channels.channel), filedescriptor
* (@see java.io.filedescriptor), and flags under which the original open occured
* (@see org.jruby.util.io.modeflags). several operations you would normally
* expect to use with a posix file descriptor are implemented here and used by
* higher-level classes to implement higher-level io behavior.
*
* note that the channel specified when constructing a channeldescriptor will
* be reference-counted; that is, until all known references to it through this
* class have gone away, it will be left open. this is to support operations
* like "dup" which must produce two independent channeldescriptor instances
* that can be closed separately without affecting the other.
*
* at present there's no way to simulate the behavior on some platforms where
* posix dup also allows independent positioning information.
*/
public class channeldescriptor
private static final logger log   loggerfactory getlogger
/** whether to log debugging information */
private static final boolean debug   false
/** the java.nio.channels.channel this descriptor wraps. */
private channel channel
/**
* the file number (equivalent to the int file descriptor value in posix)
* for this descriptor. this is generated new for most channeldescriptor
* instances, except when they need to masquerade as another fileno.
*/
private int internalfileno
/** the java.io.filedescriptor object for this descriptor. */
private filedescriptor filedescriptor
/**
* the original org.jruby.util.io.modeflags with which the specified
* channel was opened.
*/
private modeflags originalmodes
/**
* the reference count for the provided channel.
* only counts references through channeldescriptor instances.
*/
private atomicinteger refcounter
/**
* used to work-around blocking problems with stdin. in most cases <code>null</code>.
* see {@link channeldescriptor#channeldescriptor(java.io.inputstream, modeflags, java.io.filedescriptor)}
* for more details. you probably should not use it.
*/
private inputstream baseinputstream
/**
* process streams get channel.newchannel()ed into filechannel but are not actually
* seekable. so instead of just the isseekable check doing instanceof filechannel,
* we must also add this boolean to check, which we set to false when it's known
* that the incoming channel is from a process.
*
* fixme: this is gross, and it's nio's fault for not providing a nice way to
* tell if a channel is "really" seekable.
*/
private boolean canbeseekable   true
/**
* if the incoming channel is already in append mode (i.e. it will do the
* requisite seeking), we don't want to do our own additional seeks.
*/
private boolean isinappendmode   false
/**
* whether the current channe is writable or not.
*/
private boolean readablechannel
/**
* whether the current channel is readable or not.
*/
private boolean writablechannel
/**
* whether the current channel is seekable or not.
*/
private boolean seekablechannel
/**
* construct a new channeldescriptor with the specified channel, file number,
* mode flags, file descriptor object and reference counter. this constructor
* is only used when constructing a new copy of an existing channeldescriptor
* with an existing reference count, to allow the two instances to safely
* share and appropriately close  a given channel.
*
* @param channel the channel for the new descriptor, which will be shared with another
* @param fileno the new file number for the new descriptor
* @param originalmodes the mode flags to use as the "origina" set for this descriptor
* @param filedescriptor the java.io.filedescriptor object to associate with this channeldescriptor
* @param refcounter the reference counter from another channeldescriptor being duped.
* @param canbeseekable if the underlying channel can be considered seekable.
* @param isinappendmode if the underlying channel is already in append mode.
*/
private channeldescriptor channel channel  int fileno  modeflags originalmodes  filedescriptor filedescriptor  atomicinteger refcounter  boolean canbeseekable  boolean isinappendmode
this refcounter   refcounter
this channel   channel
this internalfileno   fileno
this originalmodes   originalmodes
this filedescriptor   filedescriptor
this canbeseekable   canbeseekable
this isinappendmode   isinappendmode
this readablechannel   channel instanceof readablebytechannel
this writablechannel   channel instanceof writablebytechannel
this seekablechannel   channel instanceof filechannel
registerdescriptor this
private channeldescriptor channel channel  int fileno  modeflags originalmodes  filedescriptor filedescriptor
this channel  fileno  originalmodes  filedescriptor  new atomicinteger 1   true  false
/**
* construct a new channeldescriptor with the given channel, file number, mode flags,
* and file descriptor object. the channel will be kept open until all channeldescriptor
* references to it have been closed.
*
* @param channel the channel for the new descriptor
* @param originalmodes the mode flags for the new descriptor
* @param filedescriptor the java.io.filedescriptor object for the new descriptor
*/
public channeldescriptor channel channel  modeflags originalmodes  filedescriptor filedescriptor
this channel  getnewfileno    originalmodes  filedescriptor  new atomicinteger 1   true  false
/**
* construct a new channeldescriptor with the given channel, file number, mode flags,
* and file descriptor object. the channel will be kept open until all channeldescriptor
* references to it have been closed.
*
* @param channel the channel for the new descriptor
* @param originalmodes the mode flags for the new descriptor
* @param filedescriptor the java.io.filedescriptor object for the new descriptor
*/
public channeldescriptor channel channel  modeflags originalmodes  filedescriptor filedescriptor  boolean isinappendmode
this channel  getnewfileno    originalmodes  filedescriptor  new atomicinteger 1   true  isinappendmode
/**
* construct a new channeldescriptor with the given channel, file number, mode flags,
* and file descriptor object. the channel will be kept open until all channeldescriptor
* references to it have been closed.
*
* @param channel the channel for the new descriptor
* @param originalmodes the mode flags for the new descriptor
*/
public channeldescriptor channel channel  modeflags originalmodes
this channel  getnewfileno    originalmodes  new filedescriptor    new atomicinteger 1   true  false
/**
* special constructor to create the channeldescriptor out of the stream, file number,
* mode flags, and file descriptor object. the channel will be created from the
* provided stream. the channel will be kept open until all channeldescriptor
* references to it have been closed. <b>note:</b> in most cases, you should not
* use this constructor, it's reserved mostly for stdin.
*
* @param baseinputstream the stream to create the channel for the new descriptor
* @param originalmodes the mode flags for the new descriptor
* @param filedescriptor the java.io.filedescriptor object for the new descriptor
*/
public channeldescriptor inputstream baseinputstream  modeflags originalmodes  filedescriptor filedescriptor
// the reason why we need the stream is to be able to invoke available() on it.
// stdin in java is non-interruptible, non-selectable, and attempt to read
// on such stream might lead to thread being blocked without *any* way to unblock it.
// that's where available() comes it, so at least we could check whether
// anything is available to be read without blocking.
this channels newchannel baseinputstream   getnewfileno    originalmodes  filedescriptor  new atomicinteger 1   true  false
this baseinputstream   baseinputstream
/**
* special constructor to create the channeldescriptor out of the stream, file number,
* mode flags, and file descriptor object. the channel will be created from the
* provided stream. the channel will be kept open until all channeldescriptor
* references to it have been closed. <b>note:</b> in most cases, you should not
* use this constructor, it's reserved mostly for stdin.
*
* @param baseinputstream the stream to create the channel for the new descriptor
* @param originalmodes the mode flags for the new descriptor
*/
public channeldescriptor inputstream baseinputstream  modeflags originalmodes
// the reason why we need the stream is to be able to invoke available() on it.
// stdin in java is non-interruptible, non-selectable, and attempt to read
// on such stream might lead to thread being blocked without *any* way to unblock it.
// that's where available() comes it, so at least we could check whether
// anything is available to be read without blocking.
this channels newchannel baseinputstream   getnewfileno    originalmodes  new filedescriptor    new atomicinteger 1   true  false
this baseinputstream   baseinputstream
/**
* construct a new channeldescriptor with the given channel, file number,
* and file descriptor object. the channel will be kept open until all channeldescriptor
* references to it have been closed. the channel's capabilities will be used
* to determine the "original" set of mode flags.
*
* @param channel the channel for the new descriptor
* @param filedescriptor the java.io.filedescriptor object for the new descriptor
*/
public channeldescriptor channel channel  filedescriptor filedescriptor  throws invalidvalueexception
this channel  getmodesfromchannel channel   filedescriptor
@deprecated
public channeldescriptor channel channel  int fileno  filedescriptor filedescriptor  throws invalidvalueexception
this channel  getmodesfromchannel channel   filedescriptor
/**
* construct a new channeldescriptor with the given channel, file number,
* and file descriptor object. the channel will be kept open until all channeldescriptor
* references to it have been closed. the channel's capabilities will be used
* to determine the "original" set of mode flags. this version generates a
* new fileno.
*
* @param channel the channel for the new descriptor
*/
public channeldescriptor channel channel  throws invalidvalueexception
this channel  getmodesfromchannel channel   new filedescriptor
/**
* get this descriptor's file number.
*
* @return the fileno for this descriptor
*/
public int getfileno
return internalfileno
/**
* get the filedescriptor object associated with this descriptor. this is
* not guaranteed to be a "valid" descriptor in the terms of the java
* implementation, but is provided for completeness and for cases where it
* is possible to get a valid filedescriptor for a given channel.
*
* @return the java.io.filedescriptor object associated with this descriptor
*/
public filedescriptor getfiledescriptor
return filedescriptor
/**
* the channel associated with this descriptor. the channel will be reference
* counted through channeldescriptor and kept open until all channeldescriptor
* objects have been closed. references that leave channeldescriptor through
* this method will not be counted.
*
* @return the java.nio.channels.channel associated with this descriptor
*/
public channel getchannel
return channel
/**
* this is intentionally non-public, since it should not be really
* used outside of very limited use case (handling of stdin).
* see {@link channeldescriptor#channeldescriptor(java.io.inputstream, modeflags, java.io.filedescriptor)}
* for more info.
*/
package protected   inputstream getbaseinputstream
return baseinputstream
/**
* whether the channel associated with this descriptor is seekable (i.e.
* whether it is instanceof filechannel).
*
* @return true if the associated channel is seekable, false otherwise
*/
public boolean isseekable
return canbeseekable    seekablechannel
/**
* set the channel to be explicitly seekable or not, for streams that appear
* to be seekable with the instanceof filechannel check.
*
* @param canbeseekable whether the channel is seekable or not.
*/
public void setcanbeseekable boolean canbeseekable
this canbeseekable   canbeseekable
/**
* whether the channel associated with this descriptor is a nullchannel,
* for which many operations are simply noops.
*/
public boolean isnull
return channel instanceof nullchannel
/**
* whether the channel associated with this descriptor is writable (i.e.
* whether it is instanceof writablebytechannel).
*
* @return true if the associated channel is writable, false otherwise
*/
public boolean iswritable
return writablechannel
/**
* whether the channel associated with this descriptor is readable (i.e.
* whether it is instanceof readablebytechannel).
*
* @return true if the associated channel is readable, false otherwise
*/
public boolean isreadable
return readablechannel
/**
* whether the channel associated with this descriptor is open.
*
* @return true if the associated channel is open, false otherwise
*/
public boolean isopen
return channel isopen
/**
* check whether the isopen returns true, raising a baddescriptorexception if
* it returns false.
*
* @throws org.jruby.util.io.baddescriptorexception if isopen returns false
*/
public void checkopen   throws baddescriptorexception
if   isopen
throw new baddescriptorexception
/**
* get the original mode flags for the descriptor.
*
* @return the original mode flags for the descriptor
*/
public modeflags getoriginalmodes
return originalmodes
/**
* check whether a specified set of mode flags is a superset of this
* descriptor's original set of mode flags.
*
* @param newmodes the modes to confirm as superset
* @throws org.jruby.util.io.invalidvalueexception if the modes are not a superset
*/
public void checknewmodes modeflags newmodes  throws invalidvalueexception
if   newmodes issubsetof originalmodes
throw new invalidvalueexception
/**
* mimics the posix dup(2) function, returning a new descriptor that references
* the same open channel.
*
* @return a duplicate channeldescriptor based on this one
*/
public channeldescriptor dup
synchronized  refcounter
refcounter incrementandget
int newfileno   getnewfileno
if  debug  log info    newfileno  refcounter get
return new channeldescriptor channel  newfileno  originalmodes  filedescriptor  refcounter  canbeseekable  isinappendmode
/**
* mimics the posix dup2(2) function, returning a new descriptor that references
* the same open channel but with a specified fileno.
*
* @param fileno the fileno to use for the new descriptor
* @return a duplicate channeldescriptor based on this one
*/
public channeldescriptor dup2 int fileno
synchronized  refcounter
refcounter incrementandget
if  debug  log info    fileno  refcounter get
return new channeldescriptor channel  fileno  originalmodes  filedescriptor  refcounter  canbeseekable  isinappendmode
/**
* mimics the posix dup2(2) function, returning a new descriptor that references
* the same open channel but with a specified fileno. this differs from the fileno
* version by making the target descriptor into a new reference to the current
* descriptor's channel, closing what it originally pointed to and preserving
* its original fileno.
*
* @param other the descriptor to dup this one into
*/
public void dup2into channeldescriptor other  throws baddescriptorexception  ioexception
synchronized  refcounter
refcounter incrementandget
if  debug  log info    internalfileno  refcounter get
other close
other channel   channel
other originalmodes   originalmodes
other filedescriptor   filedescriptor
other refcounter   refcounter
other canbeseekable   canbeseekable
public channeldescriptor reopen channel channel  modeflags modes
return new channeldescriptor channel  internalfileno  modes  filedescriptor
public channeldescriptor reopen randomaccessfile file  modeflags modes  throws ioexception
return new channeldescriptor file getchannel    internalfileno  modes  file getfd
/**
* perform a low-level seek operation on the associated channel if it is
* instanceof filechannel, or raise pipeexception if it is not a filechannel.
* calls checkopen to confirm the target channel is open. this is equivalent
* to the lseek(2) posix function, and like that function it bypasses any
* buffer flushing or invalidation as in channelstream.fseek.
*
* @param offset the offset value to use
* @param whence whence to seek
* @throws java.io.ioexception if there is an exception while seeking
* @throws org.jruby.util.io.invalidvalueexception if the value specified for
* offset or whence is invalid
* @throws org.jruby.util.io.pipeexception if the target channel is not seekable
* @throws org.jruby.util.io.baddescriptorexception if the target channel is
* already closed.
* @return the new offset into the filechannel.
*/
public long lseek long offset  int whence  throws ioexception  invalidvalueexception  pipeexception  baddescriptorexception
if  seekablechannel
checkopen
filechannel filechannel    filechannel channel
try
long pos
switch  whence
case stream seek_set
pos   offset
filechannel position pos
break
case stream seek_cur
pos   filechannel position     offset
filechannel position pos
break
case stream seek_end
pos   filechannel size     offset
filechannel position pos
break
default
throw new invalidvalueexception
return pos
catch  illegalargumentexception e
throw new invalidvalueexception
catch  ioexception ioe
// "invalid seek" means it's an espipe, so we rethrow as a pipeexception()
if  ioe getmessage   equals
throw new pipeexception
throw ioe
else
throw new pipeexception
/**
* perform a low-level read of the specified number of bytes into the specified
* byte list. the incoming bytes will be appended to the byte list. this is
* equivalent to the read(2) posix function, and like that function it
* ignores read and write buffers defined elsewhere.
*
* @param number the number of bytes to read
* @param bytelist the byte list on which to append the incoming bytes
* @return the number of bytes actually read
* @throws java.io.ioexception if there is an exception during io
* @throws org.jruby.util.io.baddescriptorexception if the associated
* channel is already closed.
* @see org.jruby.util.bytelist
*/
public int read int number  bytelist bytelist  throws ioexception  baddescriptorexception
checkopen
bytelist ensure bytelist length     number
int bytesread   read bytebuffer wrap bytelist getunsafebytes
bytelist begin     bytelist length    number
if  bytesread > 0
bytelist length bytelist length     bytesread
return bytesread
/**
* perform a low-level read of the remaining number of bytes into the specified
* byte buffer. the incoming bytes will be used to fill the remaining space in
* the target byte buffer. this is equivalent to the read(2) posix function,
* and like that function it ignores read and write buffers defined elsewhere.
*
* @param buffer the java.nio.bytebuffer in which to put the incoming bytes
* @return the number of bytes actually read
* @throws java.io.ioexception if there is an exception during io
* @throws org.jruby.util.io.baddescriptorexception if the associated
* channel is already closed
* @see java.nio.bytebuffer
*/
public int read bytebuffer buffer  throws ioexception  baddescriptorexception
checkopen
// todo: it would be nice to throw a better error for this
if   isreadable
throw new baddescriptorexception
readablebytechannel readchannel    readablebytechannel  channel
int bytesread   0
bytesread   readchannel read buffer
return bytesread
/**
* write the bytes in the specified byte list to the associated channel.
*
* @param buffer the byte list containing the bytes to be written
* @return the number of bytes actually written
* @throws java.io.ioexception if there is an exception during io
* @throws org.jruby.util.io.baddescriptorexception if the associated
* channel is already closed
*/
public int internalwrite bytebuffer buffer  throws ioexception  baddescriptorexception
checkopen
// todo: it would be nice to throw a better error for this
if   iswritable
throw new baddescriptorexception
writablebytechannel writechannel    writablebytechannel channel
// if appendable, we always seek to the end before writing
if  isseekable      originalmodes isappendable
// if already in append mode, we don't do our own seeking
if   isinappendmode
filechannel filechannel    filechannel channel
filechannel position filechannel size
return writechannel write buffer
/**
* write the bytes in the specified byte list to the associated channel.
*
* @param buffer the byte list containing the bytes to be written
* @return the number of bytes actually written
* @throws java.io.ioexception if there is an exception during io
* @throws org.jruby.util.io.baddescriptorexception if the associated
* channel is already closed
*/
public int write bytebuffer buffer  throws ioexception  baddescriptorexception
checkopen
return internalwrite buffer
/**
* write the bytes in the specified byte list to the associated channel.
*
* @param buf the byte list containing the bytes to be written
* @return the number of bytes actually written
* @throws java.io.ioexception if there is an exception during io
* @throws org.jruby.util.io.baddescriptorexception if the associated
* channel is already closed
*/
public int write bytelist buf  throws ioexception  baddescriptorexception
checkopen
return internalwrite bytebuffer wrap buf getunsafebytes    buf begin    buf length
private final bytebuffer directbuffer   bytebuffer allocatedirect 8192
/**
* write the bytes in the specified byte list to the associated channel.
*
* @param buf the byte list containing the bytes to be written
* @param offset the offset to start at. this is relative to the begin variable in the but
* @param len the amount of bytes to write. this should not be longer than the buffer
* @return the number of bytes actually written
* @throws java.io.ioexception if there is an exception during io
* @throws org.jruby.util.io.baddescriptorexception if the associated
* channel is already closed
*/
public int write bytelist buf  int offset  int len  throws ioexception  baddescriptorexception
checkopen
return internalwrite bytebuffer wrap buf getunsafebytes    buf begin   offset  len
/**
* write the byte represented by the specified int to the associated channel.
*
* @param c the byte to write
* @return 1 if the byte was written, 0 if not and -1 if there was an error
* (@see java.nio.channels.writablebytechannel.write(java.nio.bytebuffer))
* @throws java.io.ioexception if there was an exception during io
* @throws org.jruby.util.io.baddescriptorexception if the associated
* channel is already closed
*/
public int write int c  throws ioexception  baddescriptorexception
checkopen
bytebuffer buf   bytebuffer allocate 1
buf put  byte c
buf flip
return internalwrite buf
/**
* open a new descriptor using the given working directory, file path,
* mode flags, and file permission. this is equivalent to the open(2)
* posix function. see org.jruby.util.io.channeldescriptor.open(string, string, modeflags, int, posix)
* for the version that also sets file permissions.
*
* @param cwd the "current working directory" to use when opening the file
* @param path the file path to open
* @param flags the mode flags to use for opening the file
* @return a new channeldescriptor based on the specified parameters
* @throws java.io.filenotfoundexception if the target file could not be found
* and the create flag was not specified
* @throws org.jruby.util.io.directoryasfileexception if the target file is
* a directory being opened as a file
* @throws org.jruby.util.io.fileexistsexception if the target file should
* be created anew, but already exists
* @throws java.io.ioexception if there is an exception during io
*/
public static channeldescriptor open string cwd  string path  modeflags flags  throws filenotfoundexception  directoryasfileexception  fileexistsexception  ioexception
return open cwd  path  flags  0  null  null
/**
* open a new descriptor using the given working directory, file path,
* mode flags, and file permission. this is equivalent to the open(2)
* posix function. see org.jruby.util.io.channeldescriptor.open(string, string, modeflags, int, posix)
* for the version that also sets file permissions.
*
* @param cwd the "current working directory" to use when opening the file
* @param path the file path to open
* @param flags the mode flags to use for opening the file
* @param classloader a classloader to use for classpath: resources
* @return a new channeldescriptor based on the specified parameters
* @throws java.io.filenotfoundexception if the target file could not be found
* and the create flag was not specified
* @throws org.jruby.util.io.directoryasfileexception if the target file is
* a directory being opened as a file
* @throws org.jruby.util.io.fileexistsexception if the target file should
* be created anew, but already exists
* @throws java.io.ioexception if there is an exception during io
*/
public static channeldescriptor open string cwd  string path  modeflags flags  classloader classloader  throws filenotfoundexception  directoryasfileexception  fileexistsexception  ioexception
return open cwd  path  flags  0  null  classloader
/**
* open a new descriptor using the given working directory, file path,
* mode flags, and file permission. this is equivalent to the open(2)
* posix function.
*
* @param cwd the "current working directory" to use when opening the file
* @param path the file path to open
* @param flags the mode flags to use for opening the file
* @param perm the file permissions to use when creating a new file (currently
* unobserved)
* @param posix a posix api implementation, used for setting permissions; if null, permissions are ignored
* @return a new channeldescriptor based on the specified parameters
* @throws java.io.filenotfoundexception if the target file could not be found
* and the create flag was not specified
* @throws org.jruby.util.io.directoryasfileexception if the target file is
* a directory being opened as a file
* @throws org.jruby.util.io.fileexistsexception if the target file should
* be created anew, but already exists
* @throws java.io.ioexception if there is an exception during io
*/
public static channeldescriptor open string cwd  string path  modeflags flags  int perm  posix posix  throws filenotfoundexception  directoryasfileexception  fileexistsexception  ioexception
return open cwd  path  flags  perm  posix  null
/**
* open a new descriptor using the given working directory, file path,
* mode flags, and file permission. this is equivalent to the open(2)
* posix function.
*
* @param cwd the "current working directory" to use when opening the file
* @param path the file path to open
* @param flags the mode flags to use for opening the file
* @param perm the file permissions to use when creating a new file (currently
* unobserved)
* @param posix a posix api implementation, used for setting permissions; if null, permissions are ignored
* @param classloader a classloader to use for classpath: resources
* @return a new channeldescriptor based on the specified parameters
* @throws java.io.filenotfoundexception if the target file could not be found
* and the create flag was not specified
* @throws org.jruby.util.io.directoryasfileexception if the target file is
* a directory being opened as a file
* @throws org.jruby.util.io.fileexistsexception if the target file should
* be created anew, but already exists
* @throws java.io.ioexception if there is an exception during io
*/
public static channeldescriptor open string cwd  string path  modeflags flags  int perm  posix posix  classloader classloader  throws filenotfoundexception  directoryasfileexception  fileexistsexception  ioexception
boolean filecreated   false
if  path equals       path equalsignorecase       path equalsignorecase
channel nullchannel   new nullchannel
// fixme: don't use rubyio for this
return new channeldescriptor nullchannel  flags
else if  path startswith
int bangindex   path indexof
if  bangindex > 0
string filepath   path substring 5  bangindex
string internalpath   path substring bangindex   2
if   new file filepath  exists
throw new filenotfoundexception path
jarfile jf   new jarfile filepath
zipentry entry   rubyfile getfileentry jf  internalpath
if  entry    null
throw new filenotfoundexception path
inputstream is   jf getinputstream entry
// fixme: don't use rubyio for this
return new channeldescriptor channels newchannel is   flags
else
// raw file url, just open directly
url url   new url path
inputstream is   url openstream
// fixme: don't use rubyio for this
return new channeldescriptor channels newchannel is   flags
else if  path startswith       classloader    null
path   path substring   length
inputstream is   classloader getresourceasstream path
// fixme: don't use rubyio for this
return new channeldescriptor channels newchannel is   flags
else
jrubyfile thefile   jrubyfile create cwd path
if  thefile isdirectory      flags iswritable
throw new directoryasfileexception
if  flags iscreate
if  thefile exists      flags isexclusive
throw new fileexistsexception path
try
filecreated   thefile createnewfile
catch  ioexception ioe
// see jruby-4380.
// mri behavior: raise errno::enoent in case
// when the directory for the file doesn't exist.
// java in such cases just throws ioexception.
file parent   thefile getparentfile
if  parent    null    parent    thefile     parent exists
throw new filenotfoundexception path
else if   thefile canwrite
throw new permissiondeniedexception path
else
// for all other io errors, just re-throw the original exception
throw ioe
else
if   thefile exists
throw new filenotfoundexception path
filedescriptor filedescriptor
filechannel filechannel
boolean isinappendmode
if  flags iswritable       flags isreadable
fileoutputstream fos   new fileoutputstream thefile  flags isappendable
filechannel   fos getchannel
filedescriptor   fos getfd
isinappendmode   true
else
randomaccessfile raf   new randomaccessfile thefile  flags tojavamodestring
filechannel   raf getchannel
filedescriptor   raf getfd
isinappendmode   false
// call chmod after we created the randomaccesfile
// because otherwise, the file could be read-only
if  filecreated
// attempt to set the permissions, if we have been passed a posix instance,
// and only if the file was created in this call.
if  posix    null    perm     1
posix chmod thefile getpath    perm
try
if  flags istruncate    filechannel truncate 0
catch  ioexception ioe
if  ioe getmessage   equals
// ignore; it's a pipe or fifo that can't be truncated
else
throw ioe
// todo: append should set the fd to end, no? but there is no seek(int) in libc!
//if (modes.isappendable()) seek(0, stream.seek_end);
return new channeldescriptor filechannel  flags  filedescriptor  isinappendmode
/**
* close this descriptor. if in closing the last channeldescriptor reference
* to the associate channel is closed, the channel itself will be closed.
*
* @throws org.jruby.util.io.baddescriptorexception if the associated
* channel is already closed
* @throws java.io.ioexception if there is an exception during io
*/
public void close   throws baddescriptorexception  ioexception
// tidy up
finish true
void finish boolean close  throws baddescriptorexception  ioexception
synchronized  refcounter
// if refcount is at or below zero, we're no longer valid
if  refcounter get   <  0
throw new baddescriptorexception
// if channel is already closed, we're no longer valid
if   channel isopen
throw new baddescriptorexception
// otherwise decrement and possibly close as normal
int count   refcounter decrementandget
if  debug  log info    internalfileno  count
if  count <  0
// if we're the last referrer, close the channel
try
if  close  channel close
finally
unregisterdescriptor internalfileno
/**
* build a set of mode flags using the specified channel's actual capabilities.
*
* @param channel the channel to examine for capabilities
* @return the mode flags
* @throws org.jruby.util.io.invalidvalueexception
*/
private static modeflags getmodesfromchannel channel channel  throws invalidvalueexception
modeflags modes
if  channel instanceof readablebytechannel
if  channel instanceof writablebytechannel
modes   new modeflags rdwr
else
modes   new modeflags rdonly
else if  channel instanceof writablebytechannel
modes   new modeflags wronly
else
// fixme: i don't like this
modes   new modeflags rdwr
return modes
// fixme shouldn't use static; would interfere with other runtimes in the same jvm
protected static final atomicinteger internalfilenoindex   new atomicinteger 2
public static int getnewfileno
return internalfilenoindex incrementandget
private static void registerdescriptor channeldescriptor descriptor
filenodescriptormap put descriptor getfileno    descriptor
private static void unregisterdescriptor int afileno
filenodescriptormap remove afileno
public static channeldescriptor getdescriptorbyfileno int afileno
return filenodescriptormap get afileno
private static final map<integer  channeldescriptor> filenodescriptormap   new concurrenthashmap<integer  channeldescriptor>