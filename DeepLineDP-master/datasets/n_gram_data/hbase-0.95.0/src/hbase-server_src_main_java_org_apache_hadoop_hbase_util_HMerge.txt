/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase util
import java io ioexception
import java util arraylist
import java util list
import java util nosuchelementexception
import java util random
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop conf configuration
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase keyvalue
import org apache hadoop hbase remoteexceptionhandler
import org apache hadoop hbase exceptions tablenotdisabledexception
import org apache hadoop hbase catalog metaeditor
import org apache hadoop hbase client delete
import org apache hadoop hbase client hbaseadmin
import org apache hadoop hbase client hconnection
import org apache hadoop hbase client hconnectionmanager
import org apache hadoop hbase client hconnectionmanager hconnectable
import org apache hadoop hbase client htable
import org apache hadoop hbase client put
import org apache hadoop hbase client result
import org apache hadoop hbase client resultscanner
import org apache hadoop hbase client scan
import org apache hadoop hbase regionserver hregion
import org apache hadoop hbase regionserver internalscanner
import org apache hadoop hbase regionserver wal hlog
import org apache hadoop hbase regionserver wal hlogfactory
/**
* a non-instantiable class that has a static method capable of compacting
* a table by merging adjacent regions.
*/
@interfaceaudience private
class hmerge
// todo: where is this class used?  how does it relate to merge in same package?
static final log log   logfactory getlog hmerge class
static final random rand   new random
/*
* not instantiable
*/
private hmerge
super
/**
* scans the table and merges two adjacent regions if they are small. this
* only happens when a lot of rows are deleted.
*
* when merging the meta region, the hbase instance must be offline.
* when merging a normal table, the hbase instance must be online, but the
* table must be disabled.
*
* @param conf        - configuration object for hbase
* @param fs          - filesystem where regions reside
* @param tablename   - table to be compacted
* @throws ioexception
*/
public static void merge configuration conf  filesystem fs
final byte  tablename
throws ioexception
merge conf  fs  tablename  true
/**
* scans the table and merges two adjacent regions if they are small. this
* only happens when a lot of rows are deleted.
*
* when merging the meta region, the hbase instance must be offline.
* when merging a normal table, the hbase instance must be online, but the
* table must be disabled.
*
* @param conf        - configuration object for hbase
* @param fs          - filesystem where regions reside
* @param tablename   - table to be compacted
* @param testmasterrunning true if we are to verify master is down before
* running merge
* @throws ioexception
*/
public static void merge configuration conf  filesystem fs
final byte  tablename  final boolean testmasterrunning
throws ioexception
boolean masterisrunning   false
if  testmasterrunning
masterisrunning   hconnectionmanager
execute new hconnectable<boolean> conf
@override
public boolean connect hconnection connection  throws ioexception
return connection ismasterrunning
if  bytes equals tablename  hconstants meta_table_name
if  masterisrunning
throw new illegalstateexception
// todo reenable new offlinemerger(conf, fs).process();
else
if  masterisrunning
throw new illegalstateexception
hbaseadmin admin   new hbaseadmin conf
if   admin istabledisabled tablename
throw new tablenotdisabledexception tablename
new onlinemerger conf  fs  tablename  process
private static abstract class merger
protected final configuration conf
protected final filesystem fs
protected final path rootdir
protected final htabledescriptor htd
protected final hlog hlog
private final long maxfilesize
protected merger configuration conf  filesystem fs  final byte  tablename
throws ioexception
this conf   conf
this fs   fs
this maxfilesize   conf getlong hconstants hregion_max_filesize
hconstants default_max_file_size
this rootdir   fsutils getrootdir conf
path tabledir   htabledescriptor gettabledir this rootdir  tablename
this htd   fstabledescriptors gettabledescriptor this fs  tabledir
string logname       system currenttimemillis     hconstants hregion_logdir_name
this hlog   hlogfactory createhlog fs  tabledir  logname  conf
void process   throws ioexception
try
for  hregioninfo regionstomerge   next
regionstomerge    null
regionstomerge   next
if   merge regionstomerge
return
finally
try
hlog closeanddelete
catch ioexception e
log error e
protected boolean merge final hregioninfo info  throws ioexception
if  info length < 2
log info
return false
hregion currentregion   null
long currentsize   0
hregion nextregion   null
long nextsize   0
for  int i   0  i < info length   1  i
if  currentregion    null
currentregion   hregion openhregion conf  fs  this rootdir  info  this htd  hlog
currentsize   currentregion getlargesthstoresize
nextregion   hregion openhregion conf  fs  this rootdir  info  this htd  hlog
nextsize   nextregion getlargesthstoresize
if   currentsize   nextsize  <   maxfilesize   2
// we merge two adjacent regions if their total size is less than
// one half of the desired maximum size
log info     currentregion getregionnameasstring
nextregion getregionnameasstring
hregion mergedregion
hregion mergeadjacent currentregion  nextregion
updatemeta currentregion getregionname    nextregion getregionname
mergedregion
break
log info     bytes tostringbinary currentregion getregionname
bytes tostringbinary nextregion getregionname
currentregion close
currentregion   nextregion
currentsize   nextsize
if currentregion    null
currentregion close
return true
protected abstract hregioninfo next   throws ioexception
protected abstract void updatemeta final byte  oldregion1
final byte  oldregion2  hregion newregion
throws ioexception
/** instantiated to compact a normal user table */
private static class onlinemerger extends merger
private final byte  tablename
private final htable table
private final resultscanner metascanner
private hregioninfo latestregion
onlinemerger configuration conf  filesystem fs
final byte  tablename
throws ioexception
super conf  fs  tablename
this tablename   tablename
this table   new htable conf  hconstants meta_table_name
this metascanner   table getscanner hconstants catalog_family
hconstants regioninfo_qualifier
this latestregion   null
private hregioninfo nextregion   throws ioexception
try
result results   getmetarow
if  results    null
return null
hregioninfo region   hregioninfo gethregioninfo results
if  region    null
throw new nosuchelementexception
bytes tostring hconstants catalog_family
bytes tostring hconstants regioninfo_qualifier
if   bytes equals region gettablename    this tablename
return null
return region
catch  ioexception e
e   remoteexceptionhandler checkioexception e
log error    e
metascanner close
throw e
/*
* check current row has a hregioninfo.  skip to next row if hri is empty.
* @return a map of the row content else null if we are off the end.
* @throws ioexception
*/
private result getmetarow   throws ioexception
result currentrow   metascanner next
boolean foundresult   false
while  currentrow    null
log info     bytes tostringbinary currentrow getrow
byte regioninfovalue   currentrow getvalue hconstants catalog_family
hconstants regioninfo_qualifier
if  regioninfovalue    null    regioninfovalue length    0
currentrow   metascanner next
continue
foundresult   true
break
return foundresult ? currentrow   null
@override
protected hregioninfo next   throws ioexception
list<hregioninfo> regions   new arraylist<hregioninfo>
if latestregion    null
latestregion   nextregion
if latestregion    null
regions add latestregion
latestregion   nextregion
if latestregion    null
regions add latestregion
return regions toarray new hregioninfo
@override
protected void updatemeta final byte  oldregion1
final byte  oldregion2
hregion newregion
throws ioexception
byte regionstodelete    oldregion1  oldregion2
for  int r   0  r < regionstodelete length  r
if bytes equals regionstodelete  latestregion getregionname
latestregion   null
delete delete   new delete regionstodelete
table delete delete
if log isdebugenabled
log debug     bytes tostringbinary regionstodelete
newregion getregioninfo   setoffline true
metaeditor addregiontometa table  newregion getregioninfo
if log isdebugenabled
log debug
bytes tostringbinary newregion getregionname