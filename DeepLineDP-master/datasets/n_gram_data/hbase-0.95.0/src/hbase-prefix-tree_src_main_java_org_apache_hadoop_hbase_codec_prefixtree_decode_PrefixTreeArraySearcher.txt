/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase codec prefixtree decode
import org apache hadoop classification interfaceaudience
import org apache hadoop hbase cell
import org apache hadoop hbase cellutil
import org apache hadoop hbase codec prefixtree prefixtreeblockmeta
import org apache hadoop hbase codec prefixtree scanner cellscannerposition
import org apache hadoop hbase codec prefixtree scanner cellsearcher
import com google common primitives unsignedbytes
/**
* searcher extends the capabilities of the scanner + reversiblescanner to add the ability to
* position itself on a requested cell without scanning through cells before it. the prefixtree is
* set up to be a trie of rows, so finding a particular row is extremely cheap.
* <p/>
* once it finds the row, it does a binary search through the cells inside the row, which is not as
* fast as the trie search, but faster than iterating through every cell like existing block
* formats
* do. for this reason, this implementation is targeted towards schemas where rows are narrow
* enough
* to have several or many per block, and where you are generally looking for the entire row or
* the
* first cell. it will still be fast for wide rows or point queries, but could be improved upon.
*/
@interfaceaudience private
public class prefixtreearraysearcher extends prefixtreearrayreversiblescanner implements
cellsearcher
/*************** construct ******************************/
public prefixtreearraysearcher prefixtreeblockmeta blockmeta  int rowtreedepth
int rowbufferlength  int qualifierbufferlength
super blockmeta  rowtreedepth  rowbufferlength  qualifierbufferlength
/********************* cellsearcher methods *******************/
@override
public boolean positionat cell key
return cellscannerposition at    positionatorafter key
@override
public cellscannerposition positionatorbefore cell key
reinitfirstnode
int fanindex    1
while true
//detect row mismatch.  break loop if mismatch
int currentnodedepth   rowlength
int rowtokencomparison   comparetocurrenttoken key
if rowtokencomparison    0
return fixrowtokenmissreverse rowtokencomparison
//exact row found, move on to qualifier & ts
if rowmatchesaftercurrentposition key
return positionatqualifiertimestamp key  true
//detect dead end (no fan to descend into)
if  currentrownode hasfan
if hasoccurrences      must be leaf or nub
populatelastnonrowfields
return cellscannerposition before
else
//todo i don't think this case is exercised by any tests
return fixrowfanmissreverse 0
//keep hunting for the rest of the row
byte searchforbyte   cellutil getrowbyte key  currentnodedepth
fanindex   currentrownode whichfannode searchforbyte
if fanindex < 0    no matching row   return early
int insertionpoint    fanindex
return fixrowfanmissreverse insertionpoint
//found a match, so dig deeper into the tree
followfan fanindex
/**
* identical workflow as positionatorbefore, but split them to avoid having ~10 extra
* if-statements. priority on readability and debugability.
*/
@override
public cellscannerposition positionatorafter cell key
reinitfirstnode
int fanindex    1
while true
//detect row mismatch.  break loop if mismatch
int currentnodedepth   rowlength
int rowtokencomparison   comparetocurrenttoken key
if rowtokencomparison    0
return fixrowtokenmissforward rowtokencomparison
//exact row found, move on to qualifier & ts
if rowmatchesaftercurrentposition key
return positionatqualifiertimestamp key  false
//detect dead end (no fan to descend into)
if  currentrownode hasfan
if hasoccurrences
populatefirstnonrowfields
return cellscannerposition after
else
//todo i don't think this case is exercised by any tests
return fixrowfanmissforward 0
//keep hunting for the rest of the row
byte searchforbyte   cellutil getrowbyte key  currentnodedepth
fanindex   currentrownode whichfannode searchforbyte
if fanindex < 0    no matching row   return early
int insertionpoint    fanindex
return fixrowfanmissforward insertionpoint
//found a match, so dig deeper into the tree
followfan fanindex
@override
public boolean seekforwardto cell key
if currentpositionisafter key
//our position is after the requested key, so can't do anything
return false
return positionat key
@override
public cellscannerposition seekforwardtoorbefore cell key
//do we even need this check or should upper layers avoid this situation.  it's relatively
//expensive compared to the rest of the seek operation.
if currentpositionisafter key
//our position is after the requested key, so can't do anything
return cellscannerposition after
return positionatorbefore key
@override
public cellscannerposition seekforwardtoorafter cell key
//do we even need this check or should upper layers avoid this situation.  it's relatively
//expensive compared to the rest of the seek operation.
if currentpositionisafter key
//our position is after the requested key, so can't do anything
return cellscannerposition after
return positionatorafter key
/**
* the content of the buffers doesn't matter here, only that afterlast=true and beforefirst=false
*/
@override
public void positionafterlastcell
resettobeforefirstentry
beforefirst   false
afterlast   true
/***************** object methods ***************************/
@override
public boolean equals object obj
//trivial override to confirm intent (findbugs)
return super equals obj
/****************** internal methods ************************/
protected boolean currentpositionisafter cell cell
return compareto cell  > 0
protected cellscannerposition positionatqualifiertimestamp cell key  boolean beforeonmiss
int minindex   0
int maxindex   currentrownode getlastcellindex
int diff
while  true
int midindex    maxindex   minindex    2   don't worry about overflow
diff   populatenonrowfieldsandcompareto midindex  key
if  diff    0      found exact match
return cellscannerposition at
else if  minindex    maxindex      even termination case
break
else if   minindex   1     maxindex      odd termination case
diff   populatenonrowfieldsandcompareto maxindex  key
if diff > 0
diff   populatenonrowfieldsandcompareto minindex  key
break
else if  diff < 0      keep going forward
minindex   currentcellindex
else     went past it  back up
maxindex   currentcellindex
if  diff    0
return cellscannerposition at
else if  diff < 0      we are before key
if  beforeonmiss
return cellscannerposition before
if  advance
return cellscannerposition after
return cellscannerposition after_last
else     we are after key
if   beforeonmiss
return cellscannerposition after
if  previous
return cellscannerposition before
return cellscannerposition before_first
/**
* compare this.row to key.row but starting at the current rowlength
* @param key cell being searched for
* @return true if row buffer contents match key.row
*/
protected boolean rowmatchesaftercurrentposition cell key
if   currentrownode hasoccurrences
return false
int thatrowlength   key getrowlength
if  rowlength    thatrowlength
return false
return true
// todo move part of this to cell comparator?
/**
* compare only the bytes within the window of the current token
* @param key
* @return return -1 if key is lessthan (before) this, 0 if equal, and 1 if key is after
*/
protected int comparetocurrenttoken cell key
int startindex   rowlength   currentrownode gettokenlength
int endindexexclusive   startindex   currentrownode gettokenlength
for  int i   startindex  i < endindexexclusive    i
if  i >  key getrowlength        key was shorter  so it's first
return  1
byte keybyte   cellutil getrowbyte key  i
byte thisbyte   rowbuffer
if  keybyte    thisbyte
continue
return unsignedbytes compare keybyte  thisbyte
return 0
protected void followlastfansuntilexhausted
while currentrownode hasfan
followlastfan
/****************** complete seek when token mismatch ******************/
/**
* @param searcherisafterinputkey <0: input key is before the searcher's position<br/>
*          >0: input key is after the searcher's position
*/
protected cellscannerposition fixrowtokenmissreverse int searcherisafterinputkey
if  searcherisafterinputkey < 0     searcher position is after the input key  so back up
boolean foundpreviousrow   previousrow true
if foundpreviousrow
populatelastnonrowfields
return cellscannerposition before
else
return cellscannerposition before_first
else   searcher position is before the input key
if currentrownode hasoccurrences
populatefirstnonrowfields
return cellscannerposition before
boolean foundnextrow   nextrow
if foundnextrow
return cellscannerposition after
else
return cellscannerposition after_last
/**
* @param searcherisafterinputkey <0: input key is before the searcher's position<br/>
*                   >0: input key is after the searcher's position
*/
protected cellscannerposition fixrowtokenmissforward int searcherisafterinputkey
if  searcherisafterinputkey < 0     searcher position is after the input key
if currentrownode hasoccurrences
populatefirstnonrowfields
return cellscannerposition after
boolean foundnextrow   nextrow
if foundnextrow
return cellscannerposition after
else
return cellscannerposition after_last
else   searcher position is before the input key  so go forward
discardcurrentrownode true
boolean foundnextrow   nextrow
if foundnextrow
return cellscannerposition after
else
return cellscannerposition after_last
/****************** complete seek when fan mismatch ******************/
protected cellscannerposition fixrowfanmissreverse int faninsertionpoint
if faninsertionpoint    0    we need to back up a row
boolean foundpreviousrow   previousrow true    true  > position on last cell in row
if foundpreviousrow
populatelastnonrowfields
return cellscannerposition before
return cellscannerposition before_first
//follow the previous fan, but then descend recursively forward
followfan faninsertionpoint   1
followlastfansuntilexhausted
populatelastnonrowfields
return cellscannerposition before
protected cellscannerposition fixrowfanmissforward int faninsertionpoint
if faninsertionpoint >  currentrownode getfanout
discardcurrentrownode true
if   nextrow
return cellscannerposition after_last
else
return cellscannerposition after
followfan faninsertionpoint
if hasoccurrences
populatefirstnonrowfields
return cellscannerposition after
if nextrowinternal
populatefirstnonrowfields
return cellscannerposition after
else
return cellscannerposition after_last