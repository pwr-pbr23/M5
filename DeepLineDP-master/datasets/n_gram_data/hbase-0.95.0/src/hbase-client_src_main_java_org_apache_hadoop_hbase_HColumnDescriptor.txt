/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase
import com google common base preconditions
import com google protobuf bytestring
import com google protobuf invalidprotocolbufferexception
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import org apache hadoop hbase exceptions deserializationexception
import org apache hadoop hbase io immutablebyteswritable
import org apache hadoop hbase io compress compression
import org apache hadoop hbase io encoding datablockencoding
import org apache hadoop hbase protobuf protobufutil
import org apache hadoop hbase protobuf generated hbaseprotos bytesbytespair
import org apache hadoop hbase protobuf generated hbaseprotos columnfamilyschema
import org apache hadoop hbase protobuf generated hbaseprotos namestringpair
import org apache hadoop hbase regionserver bloomtype
import org apache hadoop hbase util bytes
import org apache hadoop io text
import org apache hadoop io writablecomparable
import java io datainput
import java io dataoutput
import java io ioexception
import java util collections
import java util hashmap
import java util hashset
import java util map
import java util set
/**
* an hcolumndescriptor contains information about a column family such as the
* number of versions, compression settings, etc.
*
* it is used as input when creating a table or adding a column. once set, the
* parameters that specify a column cannot be changed without deleting the
* column and recreating it. if there is data stored in the column, it will be
* deleted when the column is deleted.
*/
@interfaceaudience public
@interfacestability evolving
public class hcolumndescriptor implements writablecomparable<hcolumndescriptor>
// for future backward compatibility
// version  3 was when column names become byte arrays and when we picked up
// time-to-live feature.  version 4 was when we moved to byte arrays, hbase-82.
// version  5 was when bloom filter descriptors were removed.
// version  6 adds metadata as a map where keys and values are byte[].
// version  7 -- add new compression and hfile blocksize to hcolumndescriptor (hbase-1217)
// version  8 -- reintroduction of bloom filters, changed from boolean to enum
// version  9 -- add data block encoding
// version 10 -- change metadata to standard type.
// version 11 -- add column family level configuration.
private static final byte column_descriptor_version    byte  11
// these constants are used as fileinfo keys
public static final string compression
public static final string compression_compact
public static final string encode_on_disk
public static final string data_block_encoding
public static final string blockcache
public static final string cache_data_on_write
public static final string cache_index_on_write
public static final string cache_blooms_on_write
public static final string evict_blocks_on_close
/**
* size of storefile/hfile 'blocks'.  default is {@link #default_blocksize}.
* use smaller block sizes for faster random-access at expense of larger
* indices (more memory consumption).
*/
public static final string blocksize
public static final string length
public static final string ttl
public static final string bloomfilter
public static final string forever
public static final string replication_scope
public static final string min_versions
public static final string keep_deleted_cells
/**
* default compression type.
*/
public static final string default_compression
compression algorithm none getname
/**
* default value of the flag that enables data block encoding on disk, as
* opposed to encoding in cache only. we encode blocks everywhere by default,
* as long as {@link #data_block_encoding} is not none.
*/
public static final boolean default_encode_on_disk   true
/** default data block encoding algorithm. */
public static final string default_data_block_encoding
datablockencoding none tostring
/**
* default number of versions of a record to keep.
*/
public static final int default_versions   3
/**
* default is not to keep a minimum of versions.
*/
public static final int default_min_versions   0
/*
* cache here the hcd value.
* question: its ok to cache since when we're reenable, we create a new hcd?
*/
private volatile integer blocksize   null
/**
* default setting for whether to serve from memory or not.
*/
public static final boolean default_in_memory   false
/**
* default setting for preventing deleted from being collected immediately.
*/
public static final boolean default_keep_deleted   false
/**
* default setting for whether to use a block cache or not.
*/
public static final boolean default_blockcache   true
/**
* default setting for whether to cache data blocks on write if block caching
* is enabled.
*/
public static final boolean default_cache_data_on_write   false
/**
* default setting for whether to cache index blocks on write if block
* caching is enabled.
*/
public static final boolean default_cache_index_on_write   false
/**
* default size of blocks in files stored to the filesytem (hfiles).
*/
public static final int default_blocksize   hconstants default_blocksize
/**
* default setting for whether or not to use bloomfilters.
*/
public static final string default_bloomfilter   bloomtype none tostring
/**
* default setting for whether to cache bloom filter blocks on write if block
* caching is enabled.
*/
public static final boolean default_cache_blooms_on_write   false
/**
* default time to live of cell contents.
*/
public static final int default_ttl   hconstants forever
/**
* default scope.
*/
public static final int default_replication_scope   hconstants replication_scope_local
/**
* default setting for whether to evict cached blocks from the blockcache on
* close.
*/
public static final boolean default_evict_blocks_on_close   false
private final static map<string  string> default_values
new hashmap<string  string>
private final static set<immutablebyteswritable> reserved_keywords
new hashset<immutablebyteswritable>
static
default_values put bloomfilter  default_bloomfilter
default_values put replication_scope  string valueof default_replication_scope
default_values put hconstants versions  string valueof default_versions
default_values put min_versions  string valueof default_min_versions
default_values put compression  default_compression
default_values put ttl  string valueof default_ttl
default_values put blocksize  string valueof default_blocksize
default_values put hconstants in_memory  string valueof default_in_memory
default_values put blockcache  string valueof default_blockcache
default_values put keep_deleted_cells  string valueof default_keep_deleted
default_values put encode_on_disk  string valueof default_encode_on_disk
default_values put data_block_encoding  string valueof default_data_block_encoding
default_values put cache_data_on_write  string valueof default_cache_data_on_write
default_values put cache_index_on_write  string valueof default_cache_index_on_write
default_values put cache_blooms_on_write  string valueof default_cache_blooms_on_write
default_values put evict_blocks_on_close  string valueof default_evict_blocks_on_close
for  string s   default_values keyset
reserved_keywords add new immutablebyteswritable bytes tobytes s
private static final int uninitialized    1
// column family name
private byte  name
// column metadata
private final map<immutablebyteswritable  immutablebyteswritable> values
new hashmap<immutablebyteswritable immutablebyteswritable>
/**
* a map which holds the configuration specific to the column family.
* the keys of the map have the same names as config keys and override the defaults with
* cf-specific settings. example usage may be for compactions, etc.
*/
private final map<string  string> configuration   new hashmap<string  string>
/*
* cache the max versions rather than calculate it every time.
*/
private int cachedmaxversions   uninitialized
/**
* default constructor. must be present for writable.
* @deprecated used by writables and writables are going away.
*/
@deprecated
// make this private rather than remove after deprecation period elapses.  its needed by pb
// deserializations.
public hcolumndescriptor
this name   null
/**
* construct a column descriptor specifying only the family name
* the other attributes are defaulted.
*
* @param familyname column family name. must be 'printable' -- digit or
* letter -- and may not contain a <code>:<code>
*/
public hcolumndescriptor final string familyname
this bytes tobytes familyname
/**
* construct a column descriptor specifying only the family name
* the other attributes are defaulted.
*
* @param familyname column family name. must be 'printable' -- digit or
* letter -- and may not contain a <code>:<code>
*/
public hcolumndescriptor final byte  familyname
this  familyname    null    familyname length <  0?
hconstants empty_byte_array  familyname  default_versions
default_compression  default_in_memory  default_blockcache
default_ttl  default_bloomfilter
/**
* constructor.
* makes a deep copy of the supplied descriptor.
* can make a modifiable descriptor from an unmodifyablehcolumndescriptor.
* @param desc the descriptor.
*/
public hcolumndescriptor hcolumndescriptor desc
super
this name   desc name clone
for  map entry<immutablebyteswritable  immutablebyteswritable> e
desc values entryset
this values put e getkey    e getvalue
for  map entry<string  string> e   desc configuration entryset
this configuration put e getkey    e getvalue
setmaxversions desc getmaxversions
/**
* constructor
* @param familyname column family name. must be 'printable' -- digit or
* letter -- and may not contain a <code>:<code>
* @param maxversions maximum number of versions to keep
* @param compression compression type
* @param inmemory if true, column data should be kept in an hregionserver's
* cache
* @param blockcacheenabled if true, mapfile blocks should be cached
* @param timetolive time-to-live of cell contents, in seconds
* (use hconstants.forever for unlimited ttl)
* @param bloomfilter bloom filter type for this column
*
* @throws illegalargumentexception if passed a family name that is made of
* other than 'word' characters: i.e. <code>[a-za-z_0-9]</code> or contains
* a <code>:</code>
* @throws illegalargumentexception if the number of versions is &lt;= 0
* @deprecated use {@link #hcolumndescriptor(string)} and setters
*/
@deprecated
public hcolumndescriptor final byte  familyname  final int maxversions
final string compression  final boolean inmemory
final boolean blockcacheenabled
final int timetolive  final string bloomfilter
this familyname  maxversions  compression  inmemory  blockcacheenabled
default_blocksize  timetolive  bloomfilter  default_replication_scope
/**
* constructor
* @param familyname column family name. must be 'printable' -- digit or
* letter -- and may not contain a <code>:<code>
* @param maxversions maximum number of versions to keep
* @param compression compression type
* @param inmemory if true, column data should be kept in an hregionserver's
* cache
* @param blockcacheenabled if true, mapfile blocks should be cached
* @param blocksize block size to use when writing out storefiles.  use
* smaller block sizes for faster random-access at expense of larger indices
* (more memory consumption).  default is usually 64k.
* @param timetolive time-to-live of cell contents, in seconds
* (use hconstants.forever for unlimited ttl)
* @param bloomfilter bloom filter type for this column
* @param scope the scope tag for this column
*
* @throws illegalargumentexception if passed a family name that is made of
* other than 'word' characters: i.e. <code>[a-za-z_0-9]</code> or contains
* a <code>:</code>
* @throws illegalargumentexception if the number of versions is &lt;= 0
* @deprecated use {@link #hcolumndescriptor(string)} and setters
*/
@deprecated
public hcolumndescriptor final byte  familyname  final int maxversions
final string compression  final boolean inmemory
final boolean blockcacheenabled  final int blocksize
final int timetolive  final string bloomfilter  final int scope
this familyname  default_min_versions  maxversions  default_keep_deleted
compression  default_encode_on_disk  default_data_block_encoding
inmemory  blockcacheenabled  blocksize  timetolive  bloomfilter
scope
/**
* constructor
* @param familyname column family name. must be 'printable' -- digit or
* letter -- and may not contain a <code>:<code>
* @param minversions minimum number of versions to keep
* @param maxversions maximum number of versions to keep
* @param keepdeletedcells whether to retain deleted cells until they expire
*        up to maxversions versions.
* @param compression compression type
* @param encodeondisk whether to use the specified data block encoding
*        on disk. if false, the encoding will be used in cache only.
* @param datablockencoding data block encoding
* @param inmemory if true, column data should be kept in an hregionserver's
* cache
* @param blockcacheenabled if true, mapfile blocks should be cached
* @param blocksize block size to use when writing out storefiles.  use
* smaller blocksizes for faster random-access at expense of larger indices
* (more memory consumption).  default is usually 64k.
* @param timetolive time-to-live of cell contents, in seconds
* (use hconstants.forever for unlimited ttl)
* @param bloomfilter bloom filter type for this column
* @param scope the scope tag for this column
*
* @throws illegalargumentexception if passed a family name that is made of
* other than 'word' characters: i.e. <code>[a-za-z_0-9]</code> or contains
* a <code>:</code>
* @throws illegalargumentexception if the number of versions is &lt;= 0
* @deprecated use {@link #hcolumndescriptor(string)} and setters
*/
@deprecated
public hcolumndescriptor final byte familyname  final int minversions
final int maxversions  final boolean keepdeletedcells
final string compression  final boolean encodeondisk
final string datablockencoding  final boolean inmemory
final boolean blockcacheenabled  final int blocksize
final int timetolive  final string bloomfilter  final int scope
islegalfamilyname familyname
this name   familyname
if  maxversions <  0
// todo: allow maxversion of 0 to be the way you say "keep all versions".
// until there is support, consider 0 or < 0 -- a configuration error.
throw new illegalargumentexception
if  minversions > 0
if  timetolive    hconstants forever
throw new illegalargumentexception
if  minversions >  maxversions
throw new illegalargumentexception
setmaxversions maxversions
setminversions minversions
setkeepdeletedcells keepdeletedcells
setinmemory inmemory
setblockcacheenabled blockcacheenabled
settimetolive timetolive
setcompressiontype compression algorithm
valueof compression touppercase
setencodeondisk encodeondisk
setdatablockencoding datablockencoding
valueof datablockencoding touppercase
setbloomfiltertype bloomtype
valueof bloomfilter touppercase
setblocksize blocksize
setscope scope
/**
* @param b family name.
* @return <code>b</code>
* @throws illegalargumentexception if not null and not a legitimate family
* name: i.e. 'printable' and ends in a ':' (null passes are allowed because
* <code>b</code> can be null when deserializing).  cannot start with a '.'
* either. also family can not be an empty value or equal "recovered.edits".
*/
public static byte  islegalfamilyname final byte  b
if  b    null
return b
preconditions checkargument b length    0
if  b
throw new illegalargumentexception
bytes tostring b
for  int i   0  i < b length  i
if  character isisocontrol b     b         b         b
throw new illegalargumentexception     b
bytes tostring b
byte recoverededit   bytes tobytes hconstants recovered_edits_dir
if  bytes equals recoverededit  b
throw new illegalargumentexception
hconstants recovered_edits_dir
return b
/**
* @return name of this column family
*/
public byte  getname
return name
/**
* @return name of this column family
*/
public string getnameasstring
return bytes tostring this name
/**
* @param key the key.
* @return the value.
*/
public byte getvalue byte key
immutablebyteswritable ibw   values get new immutablebyteswritable key
if  ibw    null
return null
return ibw get
/**
* @param key the key.
* @return the value as a string.
*/
public string getvalue string key
byte value   getvalue bytes tobytes key
if  value    null
return null
return bytes tostring value
/**
* @return all values.
*/
public map<immutablebyteswritable immutablebyteswritable> getvalues
// shallow pointer copy
return collections unmodifiablemap values
/**
* @param key the key.
* @param value the value.
* @return this (for chained invocation)
*/
public hcolumndescriptor setvalue byte key  byte value
values put new immutablebyteswritable key
new immutablebyteswritable value
return this
/**
* @param key key whose key and value we're to remove from hcd parameters.
*/
public void remove final byte  key
values remove new immutablebyteswritable key
/**
* @param key the key.
* @param value the value.
* @return this (for chained invocation)
*/
public hcolumndescriptor setvalue string key  string value
if  value    null
remove bytes tobytes key
else
setvalue bytes tobytes key   bytes tobytes value
return this
/** @return compression type being used for the column family */
public compression algorithm getcompression
string n   getvalue compression
if  n    null
return compression algorithm none
return compression algorithm valueof n touppercase
/** @return compression type being used for the column family for major
compression */
public compression algorithm getcompactioncompression
string n   getvalue compression_compact
if  n    null
return getcompression
return compression algorithm valueof n touppercase
/** @return maximum number of versions */
public int getmaxversions
if  this cachedmaxversions    uninitialized
string v   getvalue hconstants versions
this cachedmaxversions   integer parseint v
return this cachedmaxversions
/**
* @param maxversions maximum number of versions
* @return this (for chained invocation)
*/
public hcolumndescriptor setmaxversions int maxversions
setvalue hconstants versions  integer tostring maxversions
cachedmaxversions   maxversions
return this
/**
* @return the storefile/hfile blocksize for this column family.
*/
public synchronized int getblocksize
if  this blocksize    null
string value   getvalue blocksize
this blocksize    value    null ?
integer decode value   integer valueof default_blocksize
return this blocksize intvalue
/**
* @param s blocksize to use when writing out storefiles/hfiles on this
* column family.
* @return this (for chained invocation)
*/
public hcolumndescriptor setblocksize int s
setvalue blocksize  integer tostring s
this blocksize   null
return this
/**
* @return compression type setting.
*/
public compression algorithm getcompressiontype
return getcompression
/**
* compression types supported in hbase.
* lzo is not bundled as part of the hbase distribution.
* see <a href="http://wiki.apache.org/hadoop/usinglzocompression">lzo compression</a>
* for how to enable it.
* @param type compression type setting.
* @return this (for chained invocation)
*/
public hcolumndescriptor setcompressiontype compression algorithm type
return setvalue compression  type getname   touppercase
/** @return data block encoding algorithm used on disk */
public datablockencoding getdatablockencodingondisk
string encodeondiskstr   getvalue encode_on_disk
boolean encodeondisk
if  encodeondiskstr    null
encodeondisk   default_encode_on_disk
else
encodeondisk   boolean valueof encodeondiskstr
if   encodeondisk
// no encoding on disk.
return datablockencoding none
return getdatablockencoding
/**
* set the flag indicating that we only want to encode data block in cache
* but not on disk.
* @return this (for chained invocation)
*/
public hcolumndescriptor setencodeondisk boolean encodeondisk
return setvalue encode_on_disk  string valueof encodeondisk
/**
* @return the data block encoding algorithm used in block cache and
*         optionally on disk
*/
public datablockencoding getdatablockencoding
string type   getvalue data_block_encoding
if  type    null
type   default_data_block_encoding
return datablockencoding valueof type
/**
* set data block encoding algorithm used in block cache.
* @param type what kind of data block encoding will be used.
* @return this (for chained invocation)
*/
public hcolumndescriptor setdatablockencoding datablockencoding type
string name
if  type    null
name   type tostring
else
name   datablockencoding none tostring
return setvalue data_block_encoding  name
/**
* @return compression type setting.
*/
public compression algorithm getcompactioncompressiontype
return getcompactioncompression
/**
* compression types supported in hbase.
* lzo is not bundled as part of the hbase distribution.
* see <a href="http://wiki.apache.org/hadoop/usinglzocompression">lzo compression</a>
* for how to enable it.
* @param type compression type setting.
* @return this (for chained invocation)
*/
public hcolumndescriptor setcompactioncompressiontype
compression algorithm type
return setvalue compression_compact  type getname   touppercase
/**
* @return true if we are to keep all in use hregionserver cache.
*/
public boolean isinmemory
string value   getvalue hconstants in_memory
if  value    null
return boolean valueof value  booleanvalue
return default_in_memory
/**
* @param inmemory true if we are to keep all values in the hregionserver
* cache
* @return this (for chained invocation)
*/
public hcolumndescriptor setinmemory boolean inmemory
return setvalue hconstants in_memory  boolean tostring inmemory
public boolean getkeepdeletedcells
string value   getvalue keep_deleted_cells
if  value    null
return boolean valueof value  booleanvalue
return default_keep_deleted
/**
* @param keepdeletedcells true if deleted rows should not be collected
* immediately.
* @return this (for chained invocation)
*/
public hcolumndescriptor setkeepdeletedcells boolean keepdeletedcells
return setvalue keep_deleted_cells  boolean tostring keepdeletedcells
/**
* @return time-to-live of cell contents, in seconds.
*/
public int gettimetolive
string value   getvalue ttl
return  value    null ? integer valueof value  intvalue    default_ttl
/**
* @param timetolive time-to-live of cell contents, in seconds.
* @return this (for chained invocation)
*/
public hcolumndescriptor settimetolive int timetolive
return setvalue ttl  integer tostring timetolive
/**
* @return the minimum number of versions to keep.
*/
public int getminversions
string value   getvalue min_versions
return  value    null ? integer valueof value  intvalue    0
/**
* @param minversions the minimum number of versions to keep.
* (used when timetolive is set)
* @return this (for chained invocation)
*/
public hcolumndescriptor setminversions int minversions
return setvalue min_versions  integer tostring minversions
/**
* @return true if mapfile blocks should be cached.
*/
public boolean isblockcacheenabled
string value   getvalue blockcache
if  value    null
return boolean valueof value  booleanvalue
return default_blockcache
/**
* @param blockcacheenabled true if mapfile blocks should be cached.
* @return this (for chained invocation)
*/
public hcolumndescriptor setblockcacheenabled boolean blockcacheenabled
return setvalue blockcache  boolean tostring blockcacheenabled
/**
* @return bloom filter type used for new storefiles in columnfamily
*/
public bloomtype getbloomfiltertype
string n   getvalue bloomfilter
if  n    null
n   default_bloomfilter
return bloomtype valueof n touppercase
/**
* @param bt bloom filter type
* @return this (for chained invocation)
*/
public hcolumndescriptor setbloomfiltertype final bloomtype bt
return setvalue bloomfilter  bt tostring
/**
* @return the scope tag
*/
public int getscope
string value   getvalue replication_scope
if  value    null
return integer valueof value  intvalue
return default_replication_scope
/**
* @param scope the scope tag
* @return this (for chained invocation)
*/
public hcolumndescriptor setscope int scope
return setvalue replication_scope  integer tostring scope
/**
* @return true if we should cache data blocks on write
*/
public boolean shouldcachedataonwrite
string value   getvalue cache_data_on_write
if  value    null
return boolean valueof value  booleanvalue
return default_cache_data_on_write
/**
* @param value true if we should cache data blocks on write
* @return this (for chained invocation)
*/
public hcolumndescriptor setcachedataonwrite boolean value
return setvalue cache_data_on_write  boolean tostring value
/**
* @return true if we should cache index blocks on write
*/
public boolean shouldcacheindexesonwrite
string value   getvalue cache_index_on_write
if  value    null
return boolean valueof value  booleanvalue
return default_cache_index_on_write
/**
* @param value true if we should cache index blocks on write
* @return this (for chained invocation)
*/
public hcolumndescriptor setcacheindexesonwrite boolean value
return setvalue cache_index_on_write  boolean tostring value
/**
* @return true if we should cache bloomfilter blocks on write
*/
public boolean shouldcachebloomsonwrite
string value   getvalue cache_blooms_on_write
if  value    null
return boolean valueof value  booleanvalue
return default_cache_blooms_on_write
/**
* @param value true if we should cache bloomfilter blocks on write
* @return this (for chained invocation)
*/
public hcolumndescriptor setcachebloomsonwrite boolean value
return setvalue cache_blooms_on_write  boolean tostring value
/**
* @return true if we should evict cached blocks from the blockcache on
* close
*/
public boolean shouldevictblocksonclose
string value   getvalue evict_blocks_on_close
if  value    null
return boolean valueof value  booleanvalue
return default_evict_blocks_on_close
/**
* @param value true if we should evict cached blocks from the blockcache on
* close
* @return this (for chained invocation)
*/
public hcolumndescriptor setevictblocksonclose boolean value
return setvalue evict_blocks_on_close  boolean tostring value
/**
* @see java.lang.object#tostring()
*/
@override
public string tostring
stringbuilder s   new stringbuilder
s append
s append hconstants name
s append
s append bytes tostring name
s append
s append getvalues true
s append
return s tostring
/**
* @return column family descriptor with only the customized attributes.
*/
public string tostringcustomizedvalues
stringbuilder s   new stringbuilder
s append
s append hconstants name
s append
s append bytes tostring name
s append
s append getvalues false
s append
return s tostring
private stringbuilder getvalues boolean printdefaults
stringbuilder s   new stringbuilder
boolean hasconfigkeys   false
// print all reserved keys first
for  immutablebyteswritable k   values keyset
if   reserved_keywords contains k
hasconfigkeys   true
continue
string key   bytes tostring k get
string value   bytes tostring values get k  get
if  printdefaults
default_values containskey key
default_values get key  equalsignorecase value
s append
s append key
s append
s append    append value  append
// print all non-reserved, advanced config keys as a separate subset
if  hasconfigkeys
s append
s append hconstants metadata  append
s append
boolean printcomma   false
for  immutablebyteswritable k   values keyset
if  reserved_keywords contains k
continue
string key   bytes tostring k get
string value   bytes tostring values get k  get
if  printcomma
s append
printcomma   true
s append    append key  append
s append
s append    append value  append
s append
if   configuration isempty
s append
s append hconstants configuration  append
s append
boolean printcommaforconfiguration   false
for  map entry<string  string> e   configuration entryset
if  printcommaforconfiguration  s append
printcommaforconfiguration   true
s append    append e getkey    append
s append
s append    append e getvalue    append
s append
return s
public static map<string  string> getdefaultvalues
return collections unmodifiablemap default_values
/**
* @see java.lang.object#equals(java.lang.object)
*/
@override
public boolean equals object obj
if  this    obj
return true
if  obj    null
return false
if    obj instanceof hcolumndescriptor
return false
return compareto  hcolumndescriptor obj     0
/**
* @see java.lang.object#hashcode()
*/
@override
public int hashcode
int result   bytes hashcode this name
result ^  byte valueof column_descriptor_version  hashcode
result ^  values hashcode
result ^  configuration hashcode
return result
/**
* @deprecated writables are going away.  use pb {@link #parsefrom(byte[])} instead.
*/
@deprecated
public void readfields datainput in  throws ioexception
int version   in readbyte
if  version < 6
if  version <  2
text t   new text
t readfields in
this name   t getbytes
//        if(keyvalue.getfamilydelimiterindex(this.name, 0, this.name.length)
//            > 0) {
//          this.name = stripcolon(this.name);
//        }
else
this name   bytes readbytearray in
this values clear
setmaxversions in readint
int ordinal   in readint
setcompressiontype compression algorithm values
setinmemory in readboolean
setbloomfiltertype in readboolean   ? bloomtype row   bloomtype none
if  getbloomfiltertype      bloomtype none    version < 5
// if a bloomfilter is enabled and the column descriptor is less than
// version 5, we need to skip over it to read the rest of the column
// descriptor. there are no bloomfilterdescriptors written to disk for
// column descriptors with a version number >= 5
throw new unsupportedclassversionerror this getclass   getname
if  version > 1
setblockcacheenabled in readboolean
if  version > 2
settimetolive in readint
else
// version 6+
this name   bytes readbytearray in
this values clear
int numvalues   in readint
for  int i   0  i < numvalues  i
immutablebyteswritable key   new immutablebyteswritable
immutablebyteswritable value   new immutablebyteswritable
key readfields in
value readfields in
// in version 8, the bloomfilter setting changed from bool to enum
if  version < 8    bytes tostring key get    equals bloomfilter
value set bytes tobytes
boolean getboolean bytes tostring value get
? bloomtype row tostring
bloomtype none tostring
values put key  value
if  version    6
// convert old values.
setvalue compression  compression algorithm none getname
string value   getvalue hconstants versions
this cachedmaxversions    value    null ?
integer valueof value  intvalue    default_versions
if  version > 10
configuration clear
int numconfigs   in readint
for  int i   0  i < numconfigs  i
immutablebyteswritable key   new immutablebyteswritable
immutablebyteswritable val   new immutablebyteswritable
key readfields in
val readfields in
configuration put
bytes tostring key get    key getoffset    key getlength
bytes tostring val get    val getoffset    val getlength
/**
* @deprecated writables are going away.  use {@link #tobytearray()} instead.
*/
@deprecated
public void write dataoutput out  throws ioexception
out writebyte column_descriptor_version
bytes writebytearray out  this name
out writeint values size
for  map entry<immutablebyteswritable  immutablebyteswritable> e
values entryset
e getkey   write out
e getvalue   write out
out writeint configuration size
for  map entry<string  string> e   configuration entryset
new immutablebyteswritable bytes tobytes e getkey     write out
new immutablebyteswritable bytes tobytes e getvalue     write out
// comparable
public int compareto hcolumndescriptor o
int result   bytes compareto this name  o getname
if  result    0
// punt on comparison for ordering, just calculate difference
result   this values hashcode     o values hashcode
if  result < 0
result    1
else if  result > 0
result   1
if  result    0
result   this configuration hashcode     o configuration hashcode
if  result < 0
result    1
else if  result > 0
result   1
return result
/**
* @return this instance serialized with pb with pb magic prefix
* @see #parsefrom(byte[])
*/
public byte  tobytearray
return protobufutil prependpbmagic convert   tobytearray
/**
* @param bytes a pb serialized {@link hcolumndescriptor} instance with pb magic prefix
* @return an instance of {@link hcolumndescriptor} made from <code>bytes</code>
* @throws deserializationexception
* @see #tobytearray()
*/
public static hcolumndescriptor parsefrom final byte  bytes  throws deserializationexception
if   protobufutil ispbmagicprefix bytes   throw new deserializationexception
int pblen   protobufutil lengthofpbmagic
columnfamilyschema builder builder   columnfamilyschema newbuilder
columnfamilyschema cfs   null
try
cfs   builder mergefrom bytes  pblen  bytes length   pblen  build
catch  invalidprotocolbufferexception e
throw new deserializationexception e
return convert cfs
/**
* @param cfs
* @return an {@link hcolumndescriptor} made from the passed in <code>cfs</code>
*/
public static hcolumndescriptor convert final columnfamilyschema cfs
// use the empty constructor so we preserve the initial values set on construction for things
// like maxversion.  otherwise, we pick up wrong values on deserialization which makes for
// unrelated-looking test failures that are hard to trace back to here.
hcolumndescriptor hcd   new hcolumndescriptor
hcd name   cfs getname   tobytearray
for  bytesbytespair a  cfs getattributeslist
hcd setvalue a getfirst   tobytearray    a getsecond   tobytearray
for  namestringpair a  cfs getconfigurationlist
hcd setconfiguration a getname    a getvalue
return hcd
/**
* @return convert this instance to a the pb column family type
*/
public columnfamilyschema convert
columnfamilyschema builder builder   columnfamilyschema newbuilder
builder setname bytestring copyfrom getname
for  map entry<immutablebyteswritable  immutablebyteswritable> e  this values entryset
bytesbytespair builder abuilder   bytesbytespair newbuilder
abuilder setfirst bytestring copyfrom e getkey   get
abuilder setsecond bytestring copyfrom e getvalue   get
builder addattributes abuilder build
for  map entry<string  string> e   this configuration entryset
namestringpair builder abuilder   namestringpair newbuilder
abuilder setname e getkey
abuilder setvalue e getvalue
builder addconfiguration abuilder build
return builder build
/**
* getter for accessing the configuration value by key.
*/
public string getconfigurationvalue string key
return configuration get key
/**
* getter for fetching an unmodifiable {@link #configuration} map.
*/
public map<string  string> getconfiguration
// shallow pointer copy
return collections unmodifiablemap configuration
/**
* setter for storing a configuration setting in {@link #configuration} map.
* @param key config key. same as xml config key e.g. hbase.something.or.other.
* @param value string value. if null, removes the configuration.
*/
public void setconfiguration string key  string value
if  value    null
removeconfiguration key
else
configuration put key  value
/**
* remove a configuration setting represented by the key from the {@link #configuration} map.
*/
public void removeconfiguration final string key
configuration remove key