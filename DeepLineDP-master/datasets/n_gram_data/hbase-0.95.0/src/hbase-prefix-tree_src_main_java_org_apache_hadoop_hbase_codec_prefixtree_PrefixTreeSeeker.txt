/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase codec prefixtree
import java nio bytebuffer
import org apache hadoop classification interfaceaudience
import org apache hadoop hbase cell
import org apache hadoop hbase cellutil
import org apache hadoop hbase keyvalue
import org apache hadoop hbase keyvalueutil
import org apache hadoop hbase codec prefixtree decode decoderfactory
import org apache hadoop hbase codec prefixtree decode prefixtreearraysearcher
import org apache hadoop hbase codec prefixtree scanner cellscannerposition
import org apache hadoop hbase io encoding datablockencoder encodedseeker
/**
* these methods have the same definition as any implementation of the encodedseeker.
*
* in the future, the encodedseeker could be modified to work with the cell interface directly.  it
* currently returns a new keyvalue object each time getkeyvalue is called.  this is not horrible,
* but in order to create a new keyvalue object, we must first allocate a new byte[] and copy in
* the data from the prefixtreecell.  it is somewhat heavyweight right now.
*/
@interfaceaudience private
public class prefixtreeseeker implements encodedseeker
protected bytebuffer block
protected boolean includemvccversion
protected prefixtreearraysearcher ptsearcher
public prefixtreeseeker boolean includemvccversion
this includemvccversion   includemvccversion
@override
public void setcurrentbuffer bytebuffer fullblockbuffer
block   fullblockbuffer
ptsearcher   decoderfactory checkout block  includemvccversion
rewind
/**
* currently unused.
* <p/>
* todo performance leak. should reuse the searchers. hbase does not currently have a hook where
* this can be called
*/
public void releasecurrentsearcher
decoderfactory checkin ptsearcher
@override
public bytebuffer getkeydeepcopy
return keyvalueutil copykeytonewbytebuffer ptsearcher current
@override
public bytebuffer getvalueshallowcopy
return cellutil getvaluebuffershallowcopy ptsearcher current
/**
* currently must do deep copy into new array
*/
@override
public bytebuffer getkeyvaluebuffer
return keyvalueutil copytonewbytebuffer ptsearcher current
/**
* currently must do deep copy into new array
*/
@override
public keyvalue getkeyvalue
return keyvalueutil copytonewkeyvalue ptsearcher current
/**
* currently unused.
* <p/>
* a nice, lightweight reference, though the underlying cell is transient. this method may return
* the same reference to the backing prefixtreecell repeatedly, while other implementations may
* return a different reference for each cell.
* <p/>
* the goal will be to transition the upper layers of hbase, like filters and keyvalueheap, to
* use this method instead of the getkeyvalue() methods above.
*/
public cell get
return ptsearcher current
@override
public void rewind
ptsearcher positionatfirstcell
@override
public boolean next
return ptsearcher advance
//  @override
public boolean advance
return ptsearcher advance
private static final boolean use_position_before   false
/**
* seek forward only (should be called reseektokeyinblock?).
* <p/>
* if the exact key is found look at the seekbefore variable and:<br/>
* - if true: go to the previous key if it's true<br/>
* - if false: stay on the exact key
* <p/>
* if the exact key is not found, then go to the previous key *if possible*, but remember to
* leave the scanner in a valid state if possible.
* <p/>
* @param keyonlybytes keyvalue format of a cell's key at which to position the seeker
* @param offset offset into the keyonlybytes array
* @param length number of bytes of the keyonlybytes array to use
* @param forcebeforeonexactmatch if an exact match is found and seekbefore=true, back up 1 cell
* @return 0 if the seeker is on the exact key<br/>
*         1 if the seeker is not on the key for any reason, including seekbefore being true
*/
@override
public int seektokeyinblock byte keyonlybytes  int offset  int length
boolean forcebeforeonexactmatch
if  use_position_before
return seektoorbeforeusingpositionatorbefore keyonlybytes  offset  length
forcebeforeonexactmatch
else
return seektoorbeforeusingpositionatorafter keyonlybytes  offset  length
forcebeforeonexactmatch
/*
* support both of these options since the underlying prefixtree supports both.  possibly
* expand the encodedseeker to utilize them both.
*/
protected int seektoorbeforeusingpositionatorbefore byte keyonlybytes  int offset  int length
boolean forcebeforeonexactmatch
// this does a deep copy of the key byte[] because the cellsearcher interface wants a cell
keyvalue kv   keyvalue createkeyvaluefromkey keyonlybytes  offset  length
cellscannerposition position   ptsearcher seekforwardtoorbefore kv
if cellscannerposition at    position
if  forcebeforeonexactmatch
ptsearcher previous
return 1
return 0
return 1
protected int seektoorbeforeusingpositionatorafter byte keyonlybytes  int offset  int length
boolean forcebeforeonexactmatch
// this does a deep copy of the key byte[] because the cellsearcher interface wants a cell
keyvalue kv   keyvalue createkeyvaluefromkey keyonlybytes  offset  length
//should probably switch this to use the seekforwardtoorbefore method
cellscannerposition position   ptsearcher seekforwardtoorafter kv
if cellscannerposition at    position
if  forcebeforeonexactmatch
ptsearcher previous
return 1
return 0
if cellscannerposition after    position
if  ptsearcher isbeforefirst
ptsearcher previous
return 1
if position    cellscannerposition after_last
return 1
throw new runtimeexception   position