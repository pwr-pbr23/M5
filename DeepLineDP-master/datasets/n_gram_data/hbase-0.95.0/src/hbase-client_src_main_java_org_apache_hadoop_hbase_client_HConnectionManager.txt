/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import java io closeable
import java io ioexception
import java lang reflect invocationhandler
import java lang reflect invocationtargetexception
import java lang reflect method
import java lang reflect proxy
import java lang reflect undeclaredthrowableexception
import java net inetsocketaddress
import java util arraylist
import java util collections
import java util hashmap
import java util hashset
import java util iterator
import java util linkedhashmap
import java util linkedlist
import java util list
import java util map
import java util map entry
import java util navigablemap
import java util set
import java util concurrent callable
import java util concurrent concurrenthashmap
import java util concurrent copyonwritearrayset
import java util concurrent executionexception
import java util concurrent executorservice
import java util concurrent future
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomicinteger
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import org apache hadoop conf configuration
import org apache hadoop hbase chore
import org apache hadoop hbase hbaseconfiguration
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase hregionlocation
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase ipcprotocol
import org apache hadoop hbase keyvalue
import org apache hadoop hbase masteradminprotocol
import org apache hadoop hbase mastermonitorprotocol
import org apache hadoop hbase masterprotocol
import org apache hadoop hbase remoteexceptionhandler
import org apache hadoop hbase servername
import org apache hadoop hbase stoppable
import org apache hadoop hbase client metascanner metascannervisitor
import org apache hadoop hbase client metascanner metascannervisitorbase
import org apache hadoop hbase client coprocessor batch
import org apache hadoop hbase exceptions donotretryioexception
import org apache hadoop hbase exceptions masternotrunningexception
import org apache hadoop hbase exceptions regionmovedexception
import org apache hadoop hbase exceptions regionopeningexception
import org apache hadoop hbase exceptions regionserverstoppedexception
import org apache hadoop hbase exceptions tablenotfoundexception
import org apache hadoop hbase exceptions zookeeperconnectionexception
import org apache hadoop hbase ipc hbaseclientrpc
import org apache hadoop hbase ipc protobufrpcclientengine
import org apache hadoop hbase ipc rpcclientengine
import org apache hadoop hbase protobuf protobufutil
import org apache hadoop hbase protobuf requestconverter
import org apache hadoop hbase protobuf generated hbaseprotos tableschema
import org apache hadoop hbase protobuf generated mastermonitorprotos gettabledescriptorsrequest
import org apache hadoop hbase protobuf generated mastermonitorprotos gettabledescriptorsresponse
import org apache hadoop hbase security user
import org apache hadoop hbase util addressing
import org apache hadoop hbase util bytes
import org apache hadoop hbase util environmentedgemanager
import org apache hadoop hbase util pair
import org apache hadoop hbase util softvaluesortedmap
import org apache hadoop hbase util triple
import org apache hadoop hbase zookeeper
import org apache hadoop ipc remoteexception
import org apache zookeeper keeperexception
import com google protobuf serviceexception
/**
* a non-instantiable class that manages {@link hconnection}s.
* this class has a static map of {@link hconnection} instances keyed by
* {@link configuration}; all invocations of {@link #getconnection(configuration)}
* that pass the same {@link configuration} instance will be returned the same
* {@link  hconnection} instance (adding properties to a configuration
* instance does not change its object identity).  sharing {@link hconnection}
* instances is usually what you want; all clients of the {@link hconnection}
* instances share the hconnections' cache of region locations rather than each
* having to discover for itself the location of meta, etc.  it makes
* sense for the likes of the pool of htables class {@link htablepool}, for
* instance (if concerned that a single {@link hconnection} is insufficient
* for sharing amongst clients in say an heavily-multithreaded environment,
* in practise its not proven to be an issue.  besides, {@link hconnection} is
* implemented atop hadoop rpc and as of this writing, hadoop rpc does a
* connection per cluster-member, exclusively).
*
* <p>but sharing connections
* makes clean up of {@link hconnection} instances a little awkward.  currently,
* clients cleanup by calling
* {@link #deleteconnection(configuration)}.  this will shutdown the
* zookeeper connection the hconnection was using and clean up all
* hconnection resources as well as stopping proxies to servers out on the
* cluster. not running the cleanup will not end the world; it'll
* just stall the closeup some and spew some zookeeper connection failed
* messages into the log.  running the cleanup on a {@link hconnection} that is
* subsequently used by another will cause breakage so be careful running
* cleanup.
* <p>to create a {@link hconnection} that is not shared by others, you can
* create a new {@link configuration} instance, pass this new instance to
* {@link #getconnection(configuration)}, and then when done, close it up by
* doing something like the following:
* <pre>
* {@code
* configuration newconfig = new configuration(originalconf);
* hconnection connection = hconnectionmanager.getconnection(newconfig);
* // use the connection to your hearts' delight and then when done...
* hconnectionmanager.deleteconnection(newconfig, true);
* }
* </pre>
* <p>cleanup used to be done inside in a shutdown hook.  on startup we'd
* register a shutdown hook that called {@link #deleteallconnections()}
* on its way out but the order in which shutdown hooks run is not defined so
* were problematic for clients of hconnection that wanted to register their
* own shutdown hooks so we removed ours though this shifts the onus for
* cleanup to the client.
*/
@suppresswarnings
@interfaceaudience public
@interfacestability evolving
public class hconnectionmanager
// an lru map of hconnectionkey -> hconnection (tableserver).  all
// access must be synchronized.  this map is not private because tests
// need to be able to tinker with it.
static final map<hconnectionkey  hconnectionimplementation> hbase_instances
public static final int max_cached_hbase_instances
/** parameter name for what client protocol to use. */
public static final string client_protocol_class
/** default client protocol class name. */
public static final string default_client_protocol_class   clientprotocol class getname
/** parameter name for what admin protocol to use. */
public static final string region_protocol_class
/** default admin protocol class name. */
public static final string default_admin_protocol_class   adminprotocol class getname
private static final log log   logfactory getlog hconnectionmanager class
static
// we set instances to one more than the value specified for {@link
// hconstants#zookeeper_max_client_cnxns}. by default, the zk default max
// connections to the ensemble from the one client is 30, so in that case we
// should run into zk issues before the lru hit this value of 31.
max_cached_hbase_instances   hbaseconfiguration create   getint
hconstants zookeeper_max_client_cnxns
hconstants default_zookeper_max_client_cnxns    1
hbase_instances   new linkedhashmap<hconnectionkey  hconnectionimplementation>
int   max_cached_hbase_instances   0 75f    1  0 75f  true
@override
protected boolean removeeldestentry
map entry<hconnectionkey  hconnectionimplementation> eldest
return size   > max_cached_hbase_instances
/*
* non-instantiable.
*/
protected hconnectionmanager
super
/**
* get the connection that goes with the passed <code>conf</code>
* configuration instance.
* if no current connection exists, method creates a new connection for the
* passed <code>conf</code> instance.
* @param conf configuration
* @return hconnection object for <code>conf</code>
* @throws zookeeperconnectionexception
*/
public static hconnection getconnection configuration conf
throws ioexception
hconnectionkey connectionkey   new hconnectionkey conf
synchronized  hbase_instances
hconnectionimplementation connection   hbase_instances get connectionkey
if  connection    null
connection   new hconnectionimplementation conf  true
hbase_instances put connectionkey  connection
else if  connection isclosed
hconnectionmanager deleteconnection connectionkey  true
connection   new hconnectionimplementation conf  true
hbase_instances put connectionkey  connection
connection inccount
return connection
/**
* create a new hconnection instance using the passed <code>conf</code>
* instance.
* note: this bypasses the usual hconnection life cycle management!
* use this with caution, the caller is responsible for closing the
* created connection.
* @param conf configuration
* @return hconnection object for <code>conf</code>
* @throws zookeeperconnectionexception
*/
public static hconnection createconnection configuration conf
throws ioexception
return new hconnectionimplementation conf  false
/**
* delete connection information for the instance specified by configuration.
* if there are no more references to it, this will then close connection to
* the zookeeper ensemble and let go of all resources.
*
* @param conf
*          configuration whose identity is used to find {@link hconnection}
*          instance.
*/
public static void deleteconnection configuration conf
deleteconnection new hconnectionkey conf   false
/**
* delete stale connection information for the instance specified by configuration.
* this will then close connection to
* the zookeeper ensemble and let go of all resources.
*
* @param connection
*/
public static void deletestaleconnection hconnection connection
deleteconnection connection  true
/**
* delete information for all connections.
*/
public static void deleteallconnections
synchronized  hbase_instances
set<hconnectionkey> connectionkeys   new hashset<hconnectionkey>
connectionkeys addall hbase_instances keyset
for  hconnectionkey connectionkey   connectionkeys
deleteconnection connectionkey  false
hbase_instances clear
private static void deleteconnection hconnection connection  boolean staleconnection
synchronized  hbase_instances
for  entry<hconnectionkey  hconnectionimplementation> connectionentry   hbase_instances
entryset
if  connectionentry getvalue      connection
deleteconnection connectionentry getkey    staleconnection
break
private static void deleteconnection hconnectionkey connectionkey  boolean staleconnection
synchronized  hbase_instances
hconnectionimplementation connection   hbase_instances
get connectionkey
if  connection    null
connection deccount
if  connection iszeroreference      staleconnection
hbase_instances remove connectionkey
connection internalclose
else
log error
connectionkey
/**
* it is provided for unit test cases which verify the behavior of region
* location cache prefetch.
* @return number of cached regions for the table.
* @throws zookeeperconnectionexception
*/
static int getcachedregioncount configuration conf
final byte tablename
throws ioexception
return execute new hconnectable<integer> conf
@override
public integer connect hconnection connection
return   hconnectionimplementation  connection
getnumberofcachedregionlocations tablename
/**
* it's provided for unit test cases which verify the behavior of region
* location cache prefetch.
* @return true if the region where the table and row reside is cached.
* @throws zookeeperconnectionexception
*/
static boolean isregioncached configuration conf
final byte tablename  final byte row  throws ioexception
return execute new hconnectable<boolean> conf
@override
public boolean connect hconnection connection
return   hconnectionimplementation  connection  isregioncached tablename  row
/**
* this class makes it convenient for one to execute a command in the context
* of a {@link hconnection} instance based on the given {@link configuration}.
*
* <p>
* if you find yourself wanting to use a {@link hconnection} for a relatively
* short duration of time, and do not want to deal with the hassle of creating
* and cleaning up that resource, then you should consider using this
* convenience class.
*
* @param <t>
*          the return type of the {@link hconnectable#connect(hconnection)}
*          method.
*/
public static abstract class hconnectable<t>
public configuration conf
protected hconnectable configuration conf
this conf   conf
public abstract t connect hconnection connection  throws ioexception
/**
* this convenience method invokes the given {@link hconnectable#connect}
* implementation using a {@link hconnection} instance that lasts just for the
* duration of that invocation.
*
* @param <t> the return type of the connect method
* @param connectable the {@link hconnectable} instance
* @return the value returned by the connect method
* @throws ioexception
*/
public static <t> t execute hconnectable<t> connectable  throws ioexception
if  connectable    null    connectable conf    null
return null
configuration conf   connectable conf
hconnection connection   hconnectionmanager getconnection conf
boolean connectsucceeded   false
try
t returnvalue   connectable connect connection
connectsucceeded   true
return returnvalue
finally
try
connection close
catch  exception e
if  connectsucceeded
throw new ioexception     connection
e
/**
* denotes a unique key to a {@link hconnection} instance.
*
* in essence, this class captures the properties in {@link configuration}
* that may be used in the process of establishing a connection. in light of
* that, if any new such properties are introduced into the mix, they must be
* added to the {@link hconnectionkey#properties} list.
*
*/
public static class hconnectionkey
final static string connection_properties   new string
hconstants zookeeper_quorum  hconstants zookeeper_znode_parent
hconstants zookeeper_client_port
hconstants zookeeper_recoverable_waittime
hconstants hbase_client_pause  hconstants hbase_client_retries_number
hconstants hbase_client_rpc_maxattempts
hconstants hbase_rpc_timeout_key
hconstants hbase_client_prefetch_limit
hconstants hbase_meta_scanner_caching
hconstants hbase_client_instance_id
private map<string  string> properties
private string username
public hconnectionkey configuration conf
map<string  string> m   new hashmap<string  string>
if  conf    null
for  string property   connection_properties
string value   conf get property
if  value    null
m put property  value
this properties   collections unmodifiablemap m
try
user currentuser   user getcurrent
if  currentuser    null
username   currentuser getname
catch  ioexception ioe
log warn
ioe
@override
public int hashcode
final int prime   31
int result   1
if  username    null
result   username hashcode
for  string property   connection_properties
string value   properties get property
if  value    null
result   prime   result   value hashcode
return result
@edu umd cs findbugs annotations suppresswarnings  value
justification
@override
public boolean equals object obj
if  this    obj
return true
if  obj    null
return false
if  getclass      obj getclass
return false
hconnectionkey that    hconnectionkey  obj
if  this username    null     this username equals that username
return false
else if  this username    null    that username    null
return false
if  this properties    null
if  that properties    null
return false
else
if  that properties    null
return false
for  string property   connection_properties
string thisvalue   this properties get property
string thatvalue   that properties get property
//noinspection stringequality
if  thisvalue    thatvalue
continue
if  thisvalue    null     thisvalue equals thatvalue
return false
return true
@override
public string tostring
return
properties
username
/** encapsulates connection to zookeeper and regionservers.*/
static class hconnectionimplementation implements hconnection  closeable
static final log log   logfactory getlog hconnectionimplementation class
private final class<? extends adminprotocol> adminclass
private final class<? extends clientprotocol> clientclass
private final long pause
private final int numretries
private final int maxrpcattempts
private final int rpctimeout
private final int prefetchregionlimit
private volatile boolean closed
private volatile boolean aborted
// package protected for the tests
clusterstatuslistener clusterstatuslistener
private final object userregionlock   new object
// we have a single lock for master & zk to prevent deadlocks. having
//  one lock for zk and one lock for master is not possible:
//  when creating a connection to master, we need a connection to zk to get
//  its address. but another thread could have taken the zk lock, and could
//  be waiting for the master lock => deadlock.
private final object masterandzklock   new object
private long keepzookeeperwatcheraliveuntil   long max_value
private final delayedclosing delayedclosing
delayedclosing createandstart this
private final configuration conf
// client rpc
private rpcclientengine rpcengine
// known region servername.tostring() -> regionclient/admin
private final concurrenthashmap<string  map<string  ipcprotocol>> servers
new concurrenthashmap<string  map<string  ipcprotocol>>
private final concurrenthashmap<string  string> connectionlock
new concurrenthashmap<string  string>
/**
* map of table to table {@link hregionlocation}s.  the table key is made
* by doing a {@link bytes#mapkey(byte[])} of the table's name.
*/
private final map<integer  softvaluesortedmap<byte   hregionlocation>>
cachedregionlocations
new hashmap<integer  softvaluesortedmap<byte   hregionlocation>>
// the presence of a server in the map implies it's likely that there is an
// entry in cachedregionlocations that map to this server; but the absence
// of a server in this map guarentees that there is no entry in cache that
// maps to the absent server.
// the access to this attribute must be protected by a lock on cachedregionlocations
private final set<servername> cachedservers   new hashset<servername>
// region cache prefetch is enabled by default. this set contains all
// tables whose region cache prefetch are disabled.
private final set<integer> regioncacheprefetchdisabledtables
new copyonwritearrayset<integer>
private int refcount
// indicates whether this connection's life cycle is managed (by us)
private final boolean managed
/**
* constructor
* @param conf configuration object
*/
@suppresswarnings
public hconnectionimplementation configuration conf  boolean managed  throws ioexception
this conf   conf
this managed   managed
string adminclassname   conf get region_protocol_class
default_admin_protocol_class
this closed   false
try
this adminclass
class<? extends adminprotocol>  class forname adminclassname
catch  classnotfoundexception e
throw new unsupportedoperationexception
adminclassname  e
string clientclassname   conf get client_protocol_class
default_client_protocol_class
try
this clientclass
class<? extends clientprotocol>  class forname clientclassname
catch  classnotfoundexception e
throw new unsupportedoperationexception
clientclassname  e
this pause   conf getlong hconstants hbase_client_pause
hconstants default_hbase_client_pause
this numretries   conf getint hconstants hbase_client_retries_number
hconstants default_hbase_client_retries_number
this maxrpcattempts   conf getint
hconstants hbase_client_rpc_maxattempts
hconstants default_hbase_client_rpc_maxattempts
this rpctimeout   conf getint
hconstants hbase_rpc_timeout_key
hconstants default_hbase_rpc_timeout
this prefetchregionlimit   conf getint
hconstants hbase_client_prefetch_limit
hconstants default_hbase_client_prefetch_limit
retrieveclusterid
// protobufrpcclientengine is the main rpcclientengine implementation,
// but we maintain access through an interface to allow overriding for tests
// rpc engine setup must follow obtaining the cluster id for token authentication to work
this rpcengine   new protobufrpcclientengine this conf  this clusterid
// do we publish the status?
class<? extends clusterstatuslistener listener> listenerclass
conf getclass clusterstatuslistener status_listener_class
clusterstatuslistener default_status_listener_class
clusterstatuslistener listener class
if  listenerclass    null
clusterstatuslistener   new clusterstatuslistener
new clusterstatuslistener deadserverhandler
@override
public void newdead servername sn
clearcaches sn
rpcengine getclient   cancelconnections sn gethostname    sn getport    null
conf  listenerclass
/**
* an identifier that will remain the same for a given connection.
* @return
*/
public string tostring
return     integer tohexstring hashcode
private string clusterid   null
public final void retrieveclusterid
if  clusterid    null
return
// no synchronized here, worse case we will retrieve it twice, that's
//  not an issue.
zookeeperkeepaliveconnection zkw   null
try
zkw   getkeepalivezookeeperwatcher
clusterid   zkclusterid readclusteridznode zkw
if  clusterid    null
log info
catch  keeperexception e
log warn    e
catch  ioexception e
log warn    e
finally
if  zkw    null
zkw close
if  clusterid    null
clusterid   hconstants cluster_id_default
log info     clusterid
@override
public configuration getconfiguration
return this conf
private static class masterprotocolstate
public masterprotocol protocol
public int usercount
public long keepaliveuntil   long max_value
public final class<? extends masterprotocol> protocolclass
public masterprotocolstate
final class<? extends masterprotocol> protocolclass
this protocolclass   protocolclass
/**
* create a new master proxy. try once only.
*/
private masterprotocol createmasterinterface
masterprotocolstate masterprotocolstate
throws ioexception  keeperexception  serviceexception
zookeeperkeepaliveconnection zkw
try
zkw   getkeepalivezookeeperwatcher
catch  ioexception e
throw new zookeeperconnectionexception    e
try
checkifbasenodeavailable zkw
servername sn   masteraddresstracker getmasteraddress zkw
if  sn    null
string msg
log info msg
throw new masternotrunningexception msg
inetsocketaddress isa
new inetsocketaddress sn gethostname    sn getport
masterprotocol trymaster   rpcengine getproxy
masterprotocolstate protocolclass
isa  this conf  this rpctimeout
if  trymaster ismasterrunning
null  requestconverter buildismasterrunningrequest    getismasterrunning
return trymaster
else
string msg
log info msg
throw new masternotrunningexception msg
finally
zkw close
/**
* create a master, retries if necessary.
*/
@edu umd cs findbugs annotations suppresswarnings  value
private masterprotocol createmasterwithretries
masterprotocolstate masterprotocolstate  throws masternotrunningexception
// the lock must be at the beginning to prevent multiple master creation
//  (and leaks) in a multithread context
synchronized  this masterandzklock
exception exceptioncaught   null
masterprotocol master   null
int tries   0
while
this closed    master    null
tries
try
master   createmasterinterface masterprotocolstate
catch  ioexception e
exceptioncaught   e
catch  keeperexception e
exceptioncaught   e
catch  serviceexception e
exceptioncaught   e
if  exceptioncaught    null
// it failed. if it's not the last try, we're going to wait a little
if  tries < numretries
// tries at this point is 1 or more; decrement to start from 0.
long pausetime   connectionutils getpausetime this pause  tries   1
log info     tries       numretries
pausetime       exceptioncaught
try
thread sleep pausetime
catch  interruptedexception e
thread currentthread   interrupt
throw new runtimeexception
e
else
// enough tries, we stop now
log info     tries       numretries
exceptioncaught
throw new masternotrunningexception exceptioncaught
if  master    null
// implies this.closed true
throw new masternotrunningexception
return master
private void checkifbasenodeavailable zookeeperwatcher zkw
throws masternotrunningexception
string errormsg
try
if  zkutil checkexists zkw  zkw baseznode      1
errormsg       zkw baseznode
log error errormsg
throw new masternotrunningexception errormsg
catch  keeperexception e
errormsg       e getmessage
log error errormsg
throw new masternotrunningexception errormsg  e
/**
* @return true if the master is running, throws an exception otherwise
* @throws masternotrunningexception - if the master is not running
* @throws zookeeperconnectionexception
*/
@override
public boolean ismasterrunning
throws masternotrunningexception  zookeeperconnectionexception
// when getting the master proxy connection, we check it's running,
// so if there is no exception, it means we've been able to get a
// connection on a running master
getkeepalivemastermonitor   close
return true
@override
public hregionlocation getregionlocation final byte  name
final byte  row  boolean reload
throws ioexception
return reload? relocateregion name  row   locateregion name  row
@override
public boolean istableenabled byte tablename  throws ioexception
return testtableonlinestate tablename  true
@override
public boolean istabledisabled byte tablename  throws ioexception
return testtableonlinestate tablename  false
@override
public boolean istableavailable final byte tablename  throws ioexception
final atomicboolean available   new atomicboolean true
final atomicinteger regioncount   new atomicinteger 0
metascannervisitor visitor   new metascannervisitorbase
@override
public boolean processrow result row  throws ioexception
hregioninfo info   metascanner gethregioninfo row
if  info    null
if  bytes compareto tablename  info gettablename       0
servername server   hregioninfo getservername row
if  server    null
available set false
return false
regioncount incrementandget
else if  bytes compareto tablename  info gettablename    < 0
// return if we are done with the current table
return false
return true
metascanner metascan conf  visitor  tablename
return available get       regioncount get   > 0
@override
public boolean istableavailable final byte tablename  final byte splitkeys
throws ioexception
final atomicboolean available   new atomicboolean true
final atomicinteger regioncount   new atomicinteger 0
metascannervisitor visitor   new metascannervisitorbase
@override
public boolean processrow result row  throws ioexception
hregioninfo info   metascanner gethregioninfo row
if  info    null
if  bytes compareto tablename  info gettablename       0
servername server   hregioninfo getservername row
if  server    null
available set false
return false
if   bytes equals info getstartkey    hconstants empty_byte_array
for  byte splitkey   splitkeys
// just check if the splitkey is available
if  bytes equals info getstartkey    splitkey
regioncount incrementandget
break
else
// always empty start row should be counted
regioncount incrementandget
else if  bytes compareto tablename  info gettablename    < 0
// return if we are done with the current table
return false
return true
metascanner metascan conf  visitor  tablename
// +1 needs to be added so that the empty start row is also taken into account
return available get       regioncount get      splitkeys length   1
/*
* @param enabled true if table is enabled
*/
private boolean testtableonlinestate byte  tablename  boolean enabled
throws ioexception
string tablenamestr   bytes tostring tablename
zookeeperkeepaliveconnection zkw   getkeepalivezookeeperwatcher
try
if  enabled
return zktablereadonly isenabledtable zkw  tablenamestr
return zktablereadonly isdisabledtable zkw  tablenamestr
catch  keeperexception e
throw new ioexception    e
finally
zkw close
@override
public hregionlocation locateregion final byte regionname  throws ioexception
return locateregion hregioninfo gettablename regionname
hregioninfo getstartkey regionname   false  true
@override
public boolean isdeadserver servername sn
if  clusterstatuslistener    null
return false
else
return clusterstatuslistener isdeadserver sn
@override
public list<hregionlocation> locateregions final byte tablename
throws ioexception
return locateregions  tablename  false  true
@override
public list<hregionlocation> locateregions final byte tablename  final boolean usecache
final boolean offlined  throws ioexception
navigablemap<hregioninfo  servername> regions   metascanner alltableregions conf  tablename
offlined
final list<hregionlocation> locations   new arraylist<hregionlocation>
for  hregioninfo regioninfo   regions keyset
locations add locateregion tablename  regioninfo getstartkey    usecache  true
return locations
@override
public hregionlocation locateregion final byte  tablename
final byte  row
throws ioexception
return locateregion tablename  row  true  true
@override
public hregionlocation relocateregion final byte  tablename
final byte  row
throws ioexception
// since this is an explicit request not to use any caching, finding
// disabled tables should not be desirable.  this will ensure that an exception is thrown when
// the first time a disabled table is interacted with.
if  istabledisabled tablename
throw new donotretryioexception bytes tostring tablename
return locateregion tablename  row  false  true
private hregionlocation locateregion final byte  tablename
final byte  row  boolean usecache  boolean retry
throws ioexception
if  this closed  throw new ioexception tostring
if  tablename    null    tablename length    0
throw new illegalargumentexception
if  bytes equals tablename  hconstants meta_table_name
zookeeperkeepaliveconnection zkw   getkeepalivezookeeperwatcher
try
if  log istraceenabled
log trace         this
servername servername
metaregiontracker blockuntilavailable zkw  this rpctimeout
if  log istraceenabled
log debug     this
servername    null  ?     servername
if  servername    null  return null
return new hregionlocation hregioninfo first_meta_regioninfo  servername  0
catch  interruptedexception e
thread currentthread   interrupt
return null
finally
zkw close
else
// region not in the cache - have to go to the meta rs
return locateregioninmeta hconstants meta_table_name  tablename  row
usecache  userregionlock  retry
/*
* search .meta. for the hregionlocation info that contains the table and
* row we're seeking. it will prefetch certain number of regions info and
* save them to the global region cache.
*/
private void prefetchregioncache final byte tablename
final byte row
// implement a new visitor for metascanner, and use it to walk through
// the .meta.
metascannervisitor visitor   new metascannervisitorbase
public boolean processrow result result  throws ioexception
try
hregioninfo regioninfo   metascanner gethregioninfo result
if  regioninfo    null
return true
// possible we got a region of a different table...
if   bytes equals regioninfo gettablename    tablename
return false     stop scanning
if  regioninfo isoffline
// don't cache offline regions
return true
servername servername   hregioninfo getservername result
if  servername    null
return true     don't cache it
// instantiate the location
long seqnum   hregioninfo getseqnumduringopen result
hregionlocation loc   new hregionlocation regioninfo  servername  seqnum
// cache this meta entry
cachelocation tablename  null  loc
return true
catch  runtimeexception e
throw new ioexception e
try
// pre-fetch certain number of regions info at region cache.
metascanner metascan conf  visitor  tablename  row
this prefetchregionlimit
catch  ioexception e
log warn    e
/*
* search the .meta. table for the hregionlocation
* info that contains the table and row we're seeking.
*/
private hregionlocation locateregioninmeta final byte  parenttable
final byte  tablename  final byte  row  boolean usecache
object regionlockobject  boolean retry
throws ioexception
hregionlocation location
// if we are supposed to be using the cache, look in the cache to see if
// we already have the region.
if  usecache
location   getcachedlocation tablename  row
if  location    null
return location
int localnumretries   retry ? numretries   1
// build the key of the meta region we should be looking for.
// the extra 9's on the end are necessary to allow "exact" matches
// without knowing the precise region names.
byte  metakey   hregioninfo createregionname tablename  row
hconstants nines  false
for  int tries   0  true  tries
if  tries >  localnumretries
throw new noserverforregionexception
bytes tostringbinary row        numretries
hregionlocation metalocation   null
try
// locate the meta region
metalocation   locateregion parenttable  metakey  true  false
// if null still, go around again.
if  metalocation    null  continue
clientprotocol server   getclient metalocation getservername
result regioninforow
// this block guards against two threads trying to load the meta
// region at the same time. the first will load the meta region and
// the second will use the value that the first one found.
synchronized  regionlockobject
// if the parent table is meta, we may want to pre-fetch some
// region info into the global region cache for this table.
if  bytes equals parenttable  hconstants meta_table_name
getregioncacheprefetch tablename
prefetchregioncache tablename  row
// check the cache again for a hit in case some other thread made the
// same query while we were waiting on the lock. if not supposed to
// be using the cache, delete any existing cached location so it won't
// interfere.
if  usecache
location   getcachedlocation tablename  row
if  location    null
return location
else
forcedeletecachedlocation tablename  row
// query the meta region for the location of the meta region
regioninforow   protobufutil getroworbefore server
metalocation getregioninfo   getregionname    metakey
hconstants catalog_family
if  regioninforow    null
throw new tablenotfoundexception bytes tostring tablename
// convert the row result into the hregionlocation we need!
hregioninfo regioninfo   metascanner gethregioninfo regioninforow
if  regioninfo    null
throw new ioexception
bytes tostring parenttable        regioninforow
// possible we got a region of a different table...
if   bytes equals regioninfo gettablename    tablename
throw new tablenotfoundexception
bytes tostring tablename
bytes tostring regioninfo gettablename
if  regioninfo issplit
throw new regionofflineexception
regioninfo getregionnameasstring
if  regioninfo isoffline
throw new regionofflineexception
regioninfo getregionnameasstring
servername servername   hregioninfo getservername regioninforow
if  servername    null
throw new noserverforregionexception
bytes tostring parenttable
regioninfo getregionnameasstring
bytes tostringbinary row
if  isdeadserver servername
throw new regionserverstoppedexception
regioninfo getregionnameasstring       servername
// instantiate the location
location   new hregionlocation regioninfo  servername
hregioninfo getseqnumduringopen regioninforow
cachelocation tablename  null  location
return location
catch  tablenotfoundexception e
// if we got this error, probably means the table just plain doesn't
// exist. rethrow the error immediately. this should always be coming
// from the htable constructor.
throw e
catch  ioexception e
if  e instanceof remoteexception
e   remoteexceptionhandler decoderemoteexception  remoteexception  e
if  tries < numretries   1
if  log isdebugenabled
log debug
bytes tostring parenttable
metalocation    null ?        metalocation
tries
this numretries
connectionutils getpausetime this pause  tries        e getmessage
else
throw e
// only relocate the parent region if necessary
if   e instanceof regionofflineexception
e instanceof noserverforregionexception
relocateregion parenttable  metakey
try
thread sleep connectionutils getpausetime this pause  tries
catch  interruptedexception e
thread currentthread   interrupt
throw new ioexception
/*
* search the cache for a location that fits our table and row key.
* return null if no suitable region is located. todo: synchronization note
*
* <p>todo: this method during writing consumes 15% of cpu doing lookup
* into the soft reference sortedmap.  improve.
*
* @param tablename
* @param row
* @return null or region location found in cache.
*/
hregionlocation getcachedlocation final byte  tablename
final byte  row
softvaluesortedmap<byte   hregionlocation> tablelocations
gettablelocations tablename
// start to examine the cache. we can only do cache actions
// if there's something in the cache for this table.
if  tablelocations isempty
return null
hregionlocation possibleregion   tablelocations get row
if  possibleregion    null
return possibleregion
possibleregion   tablelocations lowervaluebykey row
if  possibleregion    null
return null
// make sure that the end key is greater than the row we're looking
// for, otherwise the row actually belongs in the next region, not
// this one. the exception case is when the endkey is
// hconstants.empty_end_row, signifying that the region we're
// checking is actually the last region in the table.
byte endkey   possibleregion getregioninfo   getendkey
if  bytes equals endkey  hconstants empty_end_row
keyvalue getrowcomparator tablename  comparerows
endkey  0  endkey length  row  0  row length  > 0
return possibleregion
// passed all the way through, so we got nothing - complete cache miss
return null
/**
* delete a cached location, no matter what it is. called when we were told to not use cache.
* @param tablename tablename
* @param row
*/
void forcedeletecachedlocation final byte  tablename  final byte  row
hregionlocation rl   null
synchronized  this cachedregionlocations
map<byte  hregionlocation> tablelocations   gettablelocations tablename
// start to examine the cache. we can only do cache actions
// if there's something in the cache for this table.
if   tablelocations isempty
rl   getcachedlocation tablename  row
if  rl    null
tablelocations remove rl getregioninfo   getstartkey
if   rl    null     log isdebugenabled
log debug     rl gethostname         rl getport
rl getregioninfo   getregionnameasstring
bytes tostring tablename
/*
* delete all cached entries of a table that maps to a specific location.
*/
@override
public void clearcaches final servername servername
boolean deletedsomething   false
synchronized  this cachedregionlocations
if   cachedservers contains servername
return
for  map<byte  hregionlocation> tablelocations
cachedregionlocations values
for  entry<byte  hregionlocation> e   tablelocations entryset
if  servername equals e getvalue   getservername
tablelocations remove e getkey
deletedsomething   true
cachedservers remove servername
if  deletedsomething    log isdebugenabled
log debug     servername
/*
* @param tablename
* @return map of cached locations for passed <code>tablename</code>
*/
private softvaluesortedmap<byte   hregionlocation> gettablelocations
final byte  tablename
// find the map of cached locations for this table
integer key   bytes mapkey tablename
softvaluesortedmap<byte   hregionlocation> result
synchronized  this cachedregionlocations
result   this cachedregionlocations get key
// if tablelocations for this table isn't built yet, make one
if  result    null
result   new softvaluesortedmap<byte   hregionlocation>
bytes bytes_comparator
this cachedregionlocations put key  result
return result
@override
public void clearregioncache
synchronized this cachedregionlocations
this cachedregionlocations clear
this cachedservers clear
@override
public void clearregioncache final byte  tablename
synchronized  this cachedregionlocations
this cachedregionlocations remove bytes mapkey tablename
/**
* put a newly discovered hregionlocation into the cache.
* @param tablename the table name.
* @param source the source of the new location, if it's not coming from meta
* @param location the new location
*/
private void cachelocation final byte  tablename  final hregionlocation source
final hregionlocation location
boolean isfrommeta    source    null
byte  startkey   location getregioninfo   getstartkey
map<byte   hregionlocation> tablelocations
gettablelocations tablename
boolean isnewcacheentry   false
boolean isstaleupdate   false
hregionlocation oldlocation   null
synchronized  this cachedregionlocations
cachedservers add location getservername
oldlocation   tablelocations get startkey
isnewcacheentry    oldlocation    null
// if the server in cache sends us a redirect, assume it's always valid.
if   isnewcacheentry     oldlocation equals source
long newlocationseqnum   location getseqnum
// meta record is stale - some (probably the same) server has closed the region
// with later seqnum and told us about the new location.
boolean isstalemetarecord   isfrommeta     oldlocation getseqnum   > newlocationseqnum
// same as above for redirect. however, in this case, if the number is equal to previous
// record, the most common case is that first the region was closed with seqnum, and then
// opened with the same seqnum; hence we will ignore the redirect.
// there are so many corner cases with various combinations of opens and closes that
// an additional counter on top of seqnum would be necessary to handle them all.
boolean isstaleredirect    isfrommeta     oldlocation getseqnum   >  newlocationseqnum
isstaleupdate    isstalemetarecord    isstaleredirect
if   isstaleupdate
tablelocations put startkey  location
if  isnewcacheentry
log debug
location getregioninfo   getregionnameasstring
location gethostnameport
else if  isstaleupdate     location equals oldlocation
log debug
location getregioninfo   getregionnameasstring
location gethostnameport         location getseqnum
oldlocation gethostnameport         oldlocation getseqnum
@override
@deprecated
public adminprotocol getadmin final string hostname  final int port  throws ioexception
return getadmin new servername hostname  port  0l
@override
public adminprotocol getadmin final servername servername
throws ioexception
return getadmin servername  false
@override
@deprecated
public clientprotocol getclient final string hostname  final int port
throws ioexception
return  clientprotocol getprotocol hostname  port  clientclass
@override
public clientprotocol getclient final servername servername
throws ioexception
if  isdeadserver servername
throw new regionserverstoppedexception     servername
return  clientprotocol
getprotocol servername gethostname    servername getport    clientclass
@override
@deprecated
public adminprotocol getadmin final string hostname  final int port
final boolean master
throws ioexception
return  adminprotocol getprotocol hostname  port  adminclass
@override
public adminprotocol getadmin final servername servername  final boolean master
throws ioexception
if  isdeadserver servername
throw new regionserverstoppedexception     servername
return  adminprotocol getprotocol
servername gethostname    servername getport    adminclass
/**
* either the passed <code>isa</code> is null or <code>hostname</code>
* can be but not both.
* @param hostname
* @param port
* @param protocolclass
* @return proxy.
* @throws ioexception
*/
ipcprotocol getprotocol final string hostname
final int port  final class <? extends ipcprotocol> protocolclass
throws ioexception
string rsname   addressing createhostandportstr hostname  port
// see if we already have a connection (common case)
map<string  ipcprotocol> protocols   this servers get rsname
if  protocols    null
protocols   new hashmap<string  ipcprotocol>
map<string  ipcprotocol> existingprotocols
this servers putifabsent rsname  protocols
if  existingprotocols    null
protocols   existingprotocols
string protocol   protocolclass getname
ipcprotocol server   protocols get protocol
if  server    null
// create a unique lock for this rs + protocol (if necessary)
string lockkey   protocol       rsname
this connectionlock putifabsent lockkey  lockkey
// get the rs lock
synchronized  this connectionlock get lockkey
// do one more lookup in case we were stalled above
server   protocols get protocol
if  server    null
try
// only create isa when we need to.
inetsocketaddress address   new inetsocketaddress hostname  port
// definitely a cache miss. establish an rpc for this rs
server   hbaseclientrpc waitforproxy rpcengine  protocolclass  address  this conf
this maxrpcattempts  this rpctimeout  this rpctimeout
protocols put protocol  server
catch  remoteexception e
log warn    e
// throw what the remoteexception was carrying.
throw e unwrapremoteexception
return server
@override
@deprecated
public zookeeperwatcher getzookeeperwatcher
throws zookeeperconnectionexception
canclosezkw   false
try
return getkeepalivezookeeperwatcher
catch  zookeeperconnectionexception e
throw e
catch  ioexception e
// encapsulate exception to keep interface
throw new zookeeperconnectionexception
e
private zookeeperkeepaliveconnection keepalivezookeeper
private int keepalivezookeeperusercount
private boolean canclosezkw   true
// keepalive time, in ms. no reason to make it configurable.
private static final long keepalive   5   60   1000
/**
* retrieve a shared zookeeperwatcher. you must close it it once you've have
*  finished with it.
* @return the shared instance. never returns null.
*/
public zookeeperkeepaliveconnection getkeepalivezookeeperwatcher
throws ioexception
synchronized  masterandzklock
if  keepalivezookeeper    null
// we don't check that our link to zookeeper is still valid
// but there is a retry mechanism in the zookeeperwatcher itself
keepalivezookeeper   new zookeeperkeepaliveconnection
conf  this tostring    this
keepalivezookeeperusercount
keepzookeeperwatcheraliveuntil   long max_value
return keepalivezookeeper
void releasezookeeperwatcher zookeeperwatcher zkw
if  zkw    null
return
synchronized  masterandzklock
keepalivezookeeperusercount
if  keepalivezookeeperusercount < 0
keepzookeeperwatcheraliveuntil
system currenttimemillis     keepalive
/**
* creates a chore thread to check the connections to master & zookeeper
*  and close them when they reach their closing time (
*  {@link masterprotocolstate#keepaliveuntil} and
*  {@link #keepzookeeperwatcheraliveuntil}). keep alive time is
*  managed by the release functions and the variable {@link #keepalive}
*/
private static class delayedclosing extends chore implements stoppable
private hconnectionimplementation hci
stoppable stoppable
private delayedclosing
hconnectionimplementation hci  stoppable stoppable
super
hci
60 1000     we check every minutes
stoppable
this hci   hci
this stoppable   stoppable
static delayedclosing createandstart hconnectionimplementation hci
stoppable stoppable   new stoppable
private volatile boolean isstopped   false
@override public void stop string why    isstopped   true
@override public boolean isstopped    return isstopped
return new delayedclosing hci  stoppable
protected void closemasterprotocol masterprotocolstate protocolstate
if  system currenttimemillis   > protocolstate keepaliveuntil
hci closemasterprotocol protocolstate
protocolstate keepaliveuntil   long max_value
@override
protected void chore
synchronized  hci masterandzklock
if  hci canclosezkw
if  system currenttimemillis   >
hci keepzookeeperwatcheraliveuntil
hci closezookeeperwatcher
hci keepzookeeperwatcheraliveuntil   long max_value
closemasterprotocol hci masteradminprotocol
closemasterprotocol hci mastermonitorprotocol
@override
public void stop string why
stoppable stop why
@override
public boolean isstopped
return stoppable isstopped
private void closezookeeperwatcher
synchronized  masterandzklock
if  keepalivezookeeper    null
log info
long tohexstring
keepalivezookeeper getrecoverablezookeeper   getsessionid
keepalivezookeeper internalclose
keepalivezookeeper   null
keepalivezookeeperusercount   0
private static class masterprotocolhandler implements invocationhandler
private hconnectionimplementation connection
private masterprotocolstate protocolstatetracker
protected masterprotocolhandler hconnectionimplementation connection
masterprotocolstate protocolstatetracker
this connection   connection
this protocolstatetracker   protocolstatetracker
@override
public object invoke object proxy  method method  object args
throws throwable
if  method getname   equals
method getparametertypes   length    0
release connection  protocolstatetracker
return null
else
try
return method invoke protocolstatetracker protocol  args
catch   invocationtargetexception e
// we will have this for all the exception, checked on not, sent
//  by any layer, including the functional exception
throwable cause   e getcause
if  cause    null
throw new runtimeexception
e
if  cause instanceof undeclaredthrowableexception
cause   cause getcause
throw cause
private void release
hconnectionimplementation connection
masterprotocolstate target
connection releasemaster target
masterprotocolstate masteradminprotocol
new masterprotocolstate masteradminprotocol class
masterprotocolstate mastermonitorprotocol
new masterprotocolstate mastermonitorprotocol class
/**
* this function allows hbaseadmin and potentially others
* to get a shared master connection.
*
* @return the shared instance. never returns null.
* @throws masternotrunningexception
*/
private object getkeepalivemasterprotocol
masterprotocolstate protocolstate  class connectionclass
throws masternotrunningexception
synchronized  masterandzklock
if   iskeepalivemasterconnectedandrunning protocolstate
protocolstate protocol   null
protocolstate protocol   createmasterwithretries protocolstate
protocolstate usercount
protocolstate keepaliveuntil   long max_value
return proxy newproxyinstance
connectionclass getclassloader
new class connectionclass
new masterprotocolhandler this  protocolstate
@override
public masteradminprotocol getmasteradmin   throws masternotrunningexception
return getkeepalivemasteradmin
@override
public mastermonitorprotocol getmastermonitor   throws masternotrunningexception
return getkeepalivemastermonitor
@override
public masteradminkeepaliveconnection getkeepalivemasteradmin
throws masternotrunningexception
return  masteradminkeepaliveconnection
getkeepalivemasterprotocol masteradminprotocol  masteradminkeepaliveconnection class
@override
public mastermonitorkeepaliveconnection getkeepalivemastermonitor
throws masternotrunningexception
return  mastermonitorkeepaliveconnection
getkeepalivemasterprotocol mastermonitorprotocol  mastermonitorkeepaliveconnection class
private boolean iskeepalivemasterconnectedandrunning masterprotocolstate protocolstate
if  protocolstate protocol    null
return false
try
return protocolstate protocol ismasterrunning
null  requestconverter buildismasterrunningrequest    getismasterrunning
catch  undeclaredthrowableexception e
// it's somehow messy, but we can receive exceptions such as
//  java.net.connectexception but they're not declared. so we catch
//  it...
log info
e getundeclaredthrowable
return false
catch  serviceexception se
log warn    se
return false
private void releasemaster masterprotocolstate protocolstate
if  protocolstate protocol    null
return
synchronized  masterandzklock
protocolstate usercount
if  protocolstate usercount <  0
protocolstate keepaliveuntil
system currenttimemillis     keepalive
private void closemasterprotocol masterprotocolstate protocolstate
if  protocolstate protocol    null
log info     protocolstate protocolclass getname
protocolstate protocol   null
protocolstate usercount   0
/**
* immediate close of the shared master. can be by the delayed close or
*  when closing the connection itself.
*/
private void closemaster
synchronized  masterandzklock
closemasterprotocol masteradminprotocol
closemasterprotocol mastermonitorprotocol
@override
public <t> t getregionserverwithretries servercallable<t> callable
throws ioexception  runtimeexception
return callable withretries
@override
public <t> t getregionserverwithoutretries servercallable<t> callable
throws ioexception  runtimeexception
return callable withoutretries
@deprecated
private <r> callable<multiresponse> createcallable final hregionlocation loc
final multiaction<r> multi  final byte tablename
// todo: this does not belong in here!!! st.ack hconnections should
// not be dealing in callables; callables have hconnections, not other
// way around.
final hconnection connection   this
return new callable<multiresponse>
@override
public multiresponse call   throws exception
servercallable<multiresponse> callable
new multiservercallable<r> connection  tablename  loc  multi
return callable withoutretries
void updatecachedlocation hregioninfo hri  hregionlocation source
servername servername  long seqnum
hregionlocation newhrl   new hregionlocation hri  servername  seqnum
synchronized  this cachedregionlocations
cachelocation hri gettablename    source  newhrl
/**
* deletes the cached location of the region if necessary, based on some error from source.
* @param hri the region in question.
* @param source the source of the error that prompts us to invalidate cache.
*/
void deletecachedlocation hregioninfo hri  hregionlocation source
boolean isstaledelete   false
hregionlocation oldlocation   null
synchronized  this cachedregionlocations
map<byte  hregionlocation> tablelocations
gettablelocations hri gettablename
oldlocation   tablelocations get hri getstartkey
if  oldlocation    null
// do not delete the cache entry if it's not for the same server that gave us the error.
isstaledelete    source    null      oldlocation equals source
if   isstaledelete
tablelocations remove hri getstartkey
if  isstaledelete
log debug     source gethostnameport
hri getregionnameasstring
oldlocation gethostnameport
/**
* update the location with the new value (if the exception is a regionmovedexception)
* or delete it from the cache.
* @param exception an object (to simplify user code) on which we will try to find a nested
*                  or wrapped or both regionmovedexception
* @param source server that is the source of the location update.
*/
private void updatecachedlocations final byte tablename  row row
final object exception  final hregionlocation source
if  row    null    tablename    null
log warn      row    null ?     row
tablename    null ?     bytes tostring tablename
return
// is it something we have already updated?
final hregionlocation oldlocation   getcachedlocation tablename  row getrow
if  oldlocation    null
// there is no such location in the cache => it's been removed already => nothing to do
return
hregioninfo regioninfo   oldlocation getregioninfo
final regionmovedexception rme   regionmovedexception find exception
if  rme    null
log info     regioninfo getregionnameasstring
rme gethostname         rme getport         source gethostnameport
updatecachedlocation
regioninfo  source  rme getservername    rme getlocationseqnum
else if  regionopeningexception find exception     null
log info     regioninfo getregionnameasstring
source gethostnameport
else
deletecachedlocation regioninfo  source
@override
@deprecated
public void processbatch list<? extends row> list
final byte tablename
executorservice pool
object results  throws ioexception  interruptedexception
// this belongs in htable!!! not in here.  st.ack
// results must be the same size as list
if  results length    list size
throw new illegalargumentexception
processbatchcallback list  tablename  pool  results  null
/**
* send the queries in parallel on the different region servers. retries on failures.
* if the method returns it means that there is no error, and the 'results' array will
* contain no exception. on error, an exception is thrown, and the 'results' array will
* contain results and exceptions.
* @deprecated since 0.96 - use {@link htable#processbatchcallback} instead
*/
@override
@deprecated
public <r> void processbatchcallback
list<? extends row> list
byte tablename
executorservice pool
object results
batch callback<r> callback
throws ioexception  interruptedexception
process<r> p   new process<r> this  list  tablename  pool  results  callback
p processbatchcallback
/**
* methods and attributes to manage a batch process are grouped into this single class.
* this allows, by creating a process<r> per batch process to ensure multithread safety.
*
* this code should be move to htable once processbatchcallback is not supported anymore in
* the hconnection interface.
*/
private static class process<r>
// info on the queries and their context
private final hconnectionimplementation hci
private final list<? extends row> rows
private final byte tablename
private final executorservice pool
private final object results
private final batch callback<r> callback
// used during the batch process
private final list<action<r>> toreplay
private final linkedlist<triple<multiaction<r>  hregionlocation  future<multiresponse>>>
inprogress
private int curnumretries
// notified when a tasks is done
private final list<multiaction<r>> finishedtasks   new arraylist<multiaction<r>>
private process hconnectionimplementation hci  list<? extends row> list
byte tablename  executorservice pool  object results
batch callback<r> callback
this hci   hci
this rows   list
this tablename   tablename
this pool   pool
this results   results
this callback   callback
this toreplay   new arraylist<action<r>>
this inprogress
new linkedlist<triple<multiaction<r>  hregionlocation  future<multiresponse>>>
this curnumretries   0
/**
* group a list of actions per region servers, and send them. the created multiactions are
*  added to the inprogress list.
* @param actionslist
* @param sleeptime - sleep time before actually executing the actions. can be zero.
* @throws ioexception - if we can't locate a region after multiple retries.
*/
private void submit list<action<r>> actionslist  final long sleeptime  throws ioexception
// group per location => regions server
final map<hregionlocation  multiaction<r>> actionsbyserver
new hashmap<hregionlocation  multiaction<r>>
for  action<r> aaction   actionslist
final row row   aaction getaction
if  row    null
final hregionlocation loc   hci locateregion this tablename  row getrow
if  loc    null
throw new ioexception
final byte regionname   loc getregioninfo   getregionname
multiaction<r> actions   actionsbyserver get loc
if  actions    null
actions   new multiaction<r>
actionsbyserver put loc  actions
actions add regionname  aaction
// send the queries and add them to the inprogress list
for  entry<hregionlocation  multiaction<r>> e   actionsbyserver entryset
callable<multiresponse> callable
createdelayedcallable sleeptime  e getkey    e getvalue
if  log istraceenabled       sleeptime > 0
stringbuilder sb   new stringbuilder
for  action<r> action   e getvalue   allactions
sb append bytes tostringbinary action getaction   getrow     append
log trace     e getkey   gethostnameport
sleeptime       sb tostring
triple<multiaction<r>  hregionlocation  future<multiresponse>> p
new triple<multiaction<r>  hregionlocation  future<multiresponse>>
e getvalue    e getkey    this pool submit callable
this inprogress addlast p
/**
* resubmit the actions which have failed, after a sleep time.
* @throws ioexception
*/
private void doretry   throws ioexception
// curnumretries at this point is 1 or more; decrement to start from 0.
final long sleeptime   connectionutils getpausetime hci pause  this curnumretries   1
submit this toreplay  sleeptime
this toreplay clear
/**
* parameterized batch processing, allowing varying return types for
* different {@link row} implementations.
* throws an exception on error. if there are no exceptions, it means that the 'results'
*  array is clean.
*/
private void processbatchcallback   throws ioexception  interruptedexception
if  this results length    this rows size
throw new illegalargumentexception
results length
this rows size
if  this rows isempty
return
boolean istraceenabled   log istraceenabled
batcherrors errors   new batcherrors
batcherrors retriederrors   null
if  istraceenabled
retriederrors   new batcherrors
// we keep the number of retry per action.
int nbretries   new int
// build the action list. this list won't change after being created, hence the
//  indexes will remain constant, allowing a direct lookup.
final list<action<r>> listactions   new arraylist<action<r>> this rows size
for  int i   0  i < this rows size    i
action<r> action   new action<r> this rows get i   i
listactions add action
// execute the actions. we will analyze and resubmit the actions in a 'while' loop.
submit listactions  0
// lastretry is true if, either:
//  we had an exception 'donotretry'
//  we had more than numretries for any action
//  in this case, we will finish the current retries but we won't start new ones.
boolean lastretry   false
// despite its name numretries means number of tries. so if numretries == 1 it means we
//  won't retry. and we compare vs. 2 in case someone set it to zero.
boolean noretry    hci numretries < 2
// analyze and resubmit until all actions are done successfully or failed after numretries
while   this inprogress isempty
// we need the original multi action to find out what actions to replay if
//  we have a 'total' failure of the future<multiresponse>
// we need the hregionlocation as we give it back if we go out of retries
triple<multiaction<r>  hregionlocation  future<multiresponse>> currenttask
removefirstdone
// get the answer, keep the exception if any as we will use it for the analysis
multiresponse responses   null
executionexception exception   null
try
responses   currenttask getthird   get
catch  executionexception e
exception   e
// error case: no result at all for this multi action. we need to redo all actions
if  responses    null
for  list<action<r>> actions   currenttask getfirst   actions values
for  action<r> action   actions
row row   action getaction
// do not use the exception for updating cache because it might be coming from
// any of the regions in the multiaction.
hci updatecachedlocations tablename  row  null  currenttask getsecond
if  noretry
errors add exception  row  currenttask
else
if  istraceenabled
retriederrors add exception  row  currenttask
lastretry   addtoreplay nbretries  action
else      success or partial success
// analyze detailed results. we can still have individual failures to be redo.
// two specific exceptions are managed:
//  - donotretryioexception: we continue to retry for other actions
//  - regionmovedexception: we update the cache with the new region location
for  entry<byte  list<pair<integer  object>>> resultsforrs
responses getresults   entryset
for  pair<integer  object> regionresult   resultsforrs getvalue
action<r> correspondingaction   listactions get regionresult getfirst
object result   regionresult getsecond
this results   result
// failure: retry if it's make sense else update the errors lists
if  result    null    result instanceof throwable
row row   correspondingaction getaction
hci updatecachedlocations this tablename  row  result  currenttask getsecond
if  result instanceof donotretryioexception    noretry
errors add  exception result  row  currenttask
else
if  istraceenabled
retriederrors add  exception result  row  currenttask
lastretry   addtoreplay nbretries  correspondingaction
else    success
if  callback    null
this callback update resultsforrs getkey
this rows get regionresult getfirst    getrow     r  result
// retry all actions in toreplay then clear it.
if   noretry     toreplay isempty
if  istraceenabled
log trace      lastretry ?
retriederrors getdescriptionandclear
doretry
if  lastretry
noretry   true
errors rethrowifany
private class batcherrors
private list<throwable> exceptions   new arraylist<throwable>
private list<row> actions   new arraylist<row>
private list<string> addresses   new arraylist<string>
public void add exception ex  row row
triple<multiaction<r>  hregionlocation  future<multiresponse>> obj
exceptions add ex
actions add row
addresses add obj getsecond   gethostnameport
public void rethrowifany   throws retriesexhaustedwithdetailsexception
if   exceptions isempty
throw makeexception
public string getdescriptionandclear
if  exceptions isempty
return
string result   makeexception   getexhaustivedescription
exceptions clear
actions clear
addresses clear
return result
private retriesexhaustedwithdetailsexception makeexception
return new retriesexhaustedwithdetailsexception exceptions  actions  addresses
/**
* put the action that has to be retried in the replay list.
* @return true if we're out of numretries and it's the last retry.
*/
private boolean addtoreplay int nbretries  action<r> action
this toreplay add action
nbretries
if  nbretries > this curnumretries
this curnumretries   nbretries
// numretries means number of tries, while curnumretries means current number of retries. so
//  we need to add 1 to make them comparable. and as we look for the last try we compare
//  with '>=' and no '>'. and we need curnumretries to means what it says as we don't want
//  to initialize it to 1.
return    this curnumretries  1  >  hci numretries
/**
* wait for one of tasks to be done, and remove it from the list.
* @return the tasks done.
*/
private triple<multiaction<r>  hregionlocation  future<multiresponse>>
removefirstdone   throws interruptedexception
while  true
synchronized  finishedtasks
if   finishedtasks isempty
multiaction<r> done   finishedtasks remove finishedtasks size     1
// we now need to remove it from the inprogress part.
iterator<triple<multiaction<r>  hregionlocation  future<multiresponse>>> it
inprogress iterator
while  it hasnext
triple<multiaction<r>  hregionlocation  future<multiresponse>> task   it next
if  task getfirst      done       we have the exact object  no java equals here
it remove
return task
log error
done getregions
finishedtasks wait 10
private callable<multiresponse> createdelayedcallable
final long delay  final hregionlocation loc  final multiaction<r> multi
final callable<multiresponse> delegate   hci createcallable loc  multi  tablename
return new callable<multiresponse>
private final long creationtime   system currenttimemillis
@override
public multiresponse call   throws exception
try
final long waitingtime   delay   creationtime   system currenttimemillis
if  waitingtime > 0
thread sleep waitingtime
return delegate call
finally
synchronized  finishedtasks
finishedtasks add multi
finishedtasks notifyall
/*
* return the number of cached region for a table. it will only be called
* from a unit test.
*/
int getnumberofcachedregionlocations final byte tablename
integer key   bytes mapkey tablename
synchronized  this cachedregionlocations
map<byte  hregionlocation> tablelocs   this cachedregionlocations get key
if  tablelocs    null
return 0
return tablelocs values   size
/**
* check the region cache to see whether a region is cached yet or not.
* called by unit tests.
* @param tablename tablename
* @param row row
* @return region cached or not.
*/
boolean isregioncached final byte tablename  final byte row
hregionlocation location   getcachedlocation tablename  row
return location    null
@override
public void setregioncacheprefetch final byte tablename
final boolean enable
if   enable
regioncacheprefetchdisabledtables add bytes mapkey tablename
else
regioncacheprefetchdisabledtables remove bytes mapkey tablename
@override
public boolean getregioncacheprefetch final byte tablename
return  regioncacheprefetchdisabledtables contains bytes mapkey tablename
@override
public void abort final string msg  throwable t
if  t instanceof keeperexception sessionexpiredexception
keepalivezookeeper    null
synchronized  masterandzklock
if  keepalivezookeeper    null
log warn
t
closezookeeperwatcher
else
if  t    null
log fatal msg  t
else
log fatal msg
this aborted   true
close
this closed   true
@override
public boolean isclosed
return this closed
@override
public boolean isaborted
return this aborted
@override
public int getcurrentnrhrs   throws ioexception
zookeeperkeepaliveconnection zkw   getkeepalivezookeeperwatcher
try
// we go to zk rather than to master to get count of regions to avoid
// htable having a master dependency.  see hbase-2828
return zkutil getnumberofchildren zkw  zkw rsznode
catch  keeperexception ke
throw new ioexception    ke
finally
zkw close
/**
* increment this client's reference count.
*/
void inccount
refcount
/**
* decrement this client's reference count.
*/
void deccount
if  refcount > 0
refcount
/**
* return if this client has no reference
*
* @return true if this client has no reference; false otherwise
*/
boolean iszeroreference
return refcount    0
void internalclose
if  this closed
return
delayedclosing stop
closemaster
closezookeeperwatcher
this servers clear
this rpcengine close
if  clusterstatuslistener    null
clusterstatuslistener close
this closed   true
@override
public void close
if  managed
if  aborted
hconnectionmanager deletestaleconnection this
else
hconnectionmanager deleteconnection this  false
else
internalclose
/**
* close the connection for good, regardless of what the current value of
* {@link #refcount} is. ideally, {@link #refcount} should be zero at this
* point, which would be the case if all of its consumers close the
* connection. however, on the off chance that someone is unable to close
* the connection, perhaps because it bailed out prematurely, the method
* below will ensure that this {@link hconnection} instance is cleaned up.
* caveat: the jvm may take an unknown amount of time to call finalize on an
* unreachable object, so our hope is that every consumer cleans up after
* itself, like any good citizen.
*/
@override
protected void finalize   throws throwable
super finalize
// pretend as if we are about to release the last remaining reference
refcount   1
close
@override
public htabledescriptor listtables   throws ioexception
mastermonitorkeepaliveconnection master   getkeepalivemastermonitor
try
gettabledescriptorsrequest req
requestconverter buildgettabledescriptorsrequest null
return protobufutil gethtabledescriptorarray master gettabledescriptors null  req
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
@override
public htabledescriptor gethtabledescriptors list<string> tablenames  throws ioexception
if  tablenames    null    tablenames isempty    return new htabledescriptor
mastermonitorkeepaliveconnection master   getkeepalivemastermonitor
try
gettabledescriptorsrequest req
requestconverter buildgettabledescriptorsrequest tablenames
return protobufutil gethtabledescriptorarray master gettabledescriptors null  req
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
/**
* connects to the master to get the table descriptor.
* @param tablename table name
* @return
* @throws ioexception if the connection to master fails or if the table
*  is not found.
*/
@override
public htabledescriptor gethtabledescriptor final byte tablename
throws ioexception
if  tablename    null    tablename length    0  return null
if  bytes equals tablename  hconstants meta_table_name
return htabledescriptor meta_tabledesc
mastermonitorkeepaliveconnection master   getkeepalivemastermonitor
gettabledescriptorsresponse htds
try
gettabledescriptorsrequest req
requestconverter buildgettabledescriptorsrequest null
htds   master gettabledescriptors null  req
catch  serviceexception se
throw protobufutil getremoteexception se
finally
master close
for  tableschema ts   htds gettableschemalist
if  bytes equals tablename  ts getname   tobytearray
return htabledescriptor convert ts
throw new tablenotfoundexception bytes tostring tablename
/**
* override the rpcclientengine implementation used by this connection.
* <strong>for testing purposes only!</strong>
*/
void setrpcengine rpcclientengine engine
this rpcengine   engine
/**
* set the number of retries to use serverside when trying to communicate
* with another server over {@link hconnection}.  used updating catalog
* tables, etc.  call this method before we create any connections.
* @param c the configuration instance to set the retries into.
* @param log used to log what we set in here.
*/
public static void setserversidehconnectionretries final configuration c
final log log
int hcretries   c getint hconstants hbase_client_retries_number
hconstants default_hbase_client_retries_number
// go big.  multiply by 10.  if we can't get to meta after this many retries
// then something seriously wrong.
int serversidemultiplier
c getint    10
int retries   hcretries   serversidemultiplier
c setint hconstants hbase_client_retries_number  retries
log debug     retries