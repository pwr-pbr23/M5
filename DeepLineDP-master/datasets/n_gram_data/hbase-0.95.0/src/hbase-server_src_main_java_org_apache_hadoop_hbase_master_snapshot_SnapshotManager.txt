/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase master snapshot
import java io filenotfoundexception
import java io ioexception
import java util arraylist
import java util collections
import java util hashmap
import java util hashset
import java util iterator
import java util list
import java util map
import java util set
import java util concurrent threadpoolexecutor
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import org apache hadoop conf configuration
import org apache hadoop fs fsdatainputstream
import org apache hadoop fs filestatus
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hbase hconstants
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase stoppable
import org apache hadoop hbase catalog metareader
import org apache hadoop hbase errorhandling foreignexception
import org apache hadoop hbase exceptions hbasesnapshotexception
import org apache hadoop hbase exceptions restoresnapshotexception
import org apache hadoop hbase exceptions snapshotcreationexception
import org apache hadoop hbase exceptions snapshotdoesnotexistexception
import org apache hadoop hbase exceptions snapshotexistsexception
import org apache hadoop hbase exceptions tablepartiallyopenexception
import org apache hadoop hbase exceptions unknownsnapshotexception
import org apache hadoop hbase executor executorservice
import org apache hadoop hbase master assignmentmanager
import org apache hadoop hbase master mastercoprocessorhost
import org apache hadoop hbase master masterfilesystem
import org apache hadoop hbase master masterservices
import org apache hadoop hbase master snapshotsentinel
import org apache hadoop hbase master cleaner hfilecleaner
import org apache hadoop hbase master cleaner hfilelinkcleaner
import org apache hadoop hbase procedure procedure
import org apache hadoop hbase procedure procedurecoordinator
import org apache hadoop hbase procedure procedurecoordinatorrpcs
import org apache hadoop hbase procedure zkprocedurecoordinatorrpcs
import org apache hadoop hbase protobuf generated hbaseprotos snapshotdescription
import org apache hadoop hbase protobuf generated hbaseprotos snapshotdescription type
import org apache hadoop hbase snapshot clientsnapshotdescriptionutils
import org apache hadoop hbase snapshot restoresnapshothelper
import org apache hadoop hbase snapshot snapshotdescriptionutils
import org apache hadoop hbase util bytes
import org apache hadoop hbase util fstabledescriptors
import org apache hadoop hbase util fsutils
import org apache zookeeper keeperexception
/**
* this class manages the procedure of taking and restoring snapshots. there is only one
* snapshotmanager for the master.
* <p>
* the class provides methods for monitoring in-progress snapshot actions.
* <p>
* note: currently there can only be one snapshot being taken at a time over the cluster. this is a
* simplification in the current implementation.
*/
@interfaceaudience private
@interfacestability unstable
public class snapshotmanager implements stoppable
private static final log log   logfactory getlog snapshotmanager class
/** by default, check to see if the snapshot is complete every wake millis (ms) */
private static final int snapshot_wake_millis_default   500
/** enable or disable snapshot support */
public static final string hbase_snapshot_enabled
/**
* conf key for # of ms elapsed between checks for snapshot errors while waiting for
* completion.
*/
private static final string snapshot_wake_millis_key
/** by default, check to see if the snapshot is complete (ms) */
private static final int snapshot_timeout_millis_default   5000
/**
* conf key for # of ms elapsed before injecting a snapshot timeout error when waiting for
* completion.
*/
private static final string snapshot_timeout_millis_key
/** name of the operation to use in the controller */
public static final string online_snapshot_controller_description
// todo - enable having multiple snapshots with multiple monitors/threads
// this needs to be configuration based when running multiple snapshots is implemented
/** number of current operations running on the master */
private static final int opthreads   1
private boolean stopped
private final long wakefrequency
private final masterservices master      needed by tableeventhandlers
private final procedurecoordinator coordinator
// is snapshot feature enabled?
private boolean issnapshotsupported   false
// a reference to a handler.  if the handler is non-null, then it is assumed that a snapshot is
// in progress currently
// todo: this is a bad smell;  likely replace with a collection in the future.  also this gets
// reset by every operation.
private takesnapshothandler handler
private final path rootdir
private final executorservice executorservice
// restore sentinels map, with table name as key
private map<string  snapshotsentinel> restorehandlers   new hashmap<string  snapshotsentinel>
/**
* construct a snapshot manager.
* @param master
*/
public snapshotmanager final masterservices master  throws keeperexception  ioexception
unsupportedoperationexception
this master   master
checksnapshotsupport master getconfiguration    master getmasterfilesystem
// get the configuration for the coordinator
configuration conf   master getconfiguration
this wakefrequency   conf getint snapshot_wake_millis_key  snapshot_wake_millis_default
long keepalivetime   conf getlong snapshot_timeout_millis_key  snapshot_timeout_millis_default
// setup the default procedure coordinator
string name   master getservername   tostring
threadpoolexecutor tpool   procedurecoordinator defaultpool name  keepalivetime  opthreads  wakefrequency
procedurecoordinatorrpcs comms   new zkprocedurecoordinatorrpcs
master getzookeeper    snapshotmanager online_snapshot_controller_description  name
this coordinator   new procedurecoordinator comms  tpool
this rootdir   master getmasterfilesystem   getrootdir
this executorservice   master getexecutorservice
resettempdir
/**
* fully specify all necessary components of a snapshot manager. exposed for testing.
* @param master services for the master where the manager is running
* @param coordinator procedure coordinator instance.  exposed for testing.
* @param pool hbase executorservcie instance, exposed for testing.
*/
public snapshotmanager final masterservices master  procedurecoordinator coordinator  executorservice pool
throws ioexception  unsupportedoperationexception
this master   master
checksnapshotsupport master getconfiguration    master getmasterfilesystem
this wakefrequency   master getconfiguration   getint snapshot_wake_millis_key
snapshot_wake_millis_default
this coordinator   coordinator
this rootdir   master getmasterfilesystem   getrootdir
this executorservice   pool
resettempdir
/**
* gets the list of all completed snapshots.
* @return list of snapshotdescriptions
* @throws ioexception file system exception
*/
public list<snapshotdescription> getcompletedsnapshots   throws ioexception
list<snapshotdescription> snapshotdescs   new arraylist<snapshotdescription>
// first create the snapshot root path and check to see if it exists
path snapshotdir   snapshotdescriptionutils getsnapshotsdir rootdir
filesystem fs   master getmasterfilesystem   getfilesystem
// if there are no snapshots, return an empty list
if   fs exists snapshotdir
return snapshotdescs
// ignore all the snapshots in progress
filestatus snapshots   fs liststatus snapshotdir
new snapshotdescriptionutils completedsnaphotdirectoriesfilter fs
// loop through all the completed snapshots
for  filestatus snapshot   snapshots
path info   new path snapshot getpath    snapshotdescriptionutils snapshotinfo_file
// if the snapshot is bad
if   fs exists info
log error     snapshot getpath
continue
fsdatainputstream in   null
try
in   fs open info
snapshotdescription desc   snapshotdescription parsefrom in
snapshotdescs add desc
catch  ioexception e
log warn     snapshot getpath    e
finally
if  in    null
in close
return snapshotdescs
/**
* cleans up any snapshots in the snapshot/.tmp directory that were left from failed
* snapshot attempts.
*
* @throws ioexception if we can't reach the filesystem
*/
void resettempdir   throws ioexception
// cleanup any existing snapshots.
path tmpdir   snapshotdescriptionutils getworkingsnapshotdir rootdir
if   master getmasterfilesystem   getfilesystem   delete tmpdir  true
log warn     tmpdir
/**
* delete the specified snapshot
* @param snapshot
* @throws snapshotdoesnotexistexception if the specified snapshot does not exist.
* @throws ioexception for filesystem ioexceptions
*/
public void deletesnapshot snapshotdescription snapshot  throws snapshotdoesnotexistexception  ioexception
// call coproc pre hook
mastercoprocessorhost cphost   master getcoprocessorhost
if  cphost    null
cphost predeletesnapshot snapshot
// check to see if it is completed
if   issnapshotcompleted snapshot
throw new snapshotdoesnotexistexception snapshot
string snapshotname   snapshot getname
log debug     snapshotname
// first create the snapshot description and check to see if it exists
masterfilesystem fs   master getmasterfilesystem
path snapshotdir   snapshotdescriptionutils getcompletedsnapshotdir snapshotname  rootdir
// delete the existing snapshot
if   fs getfilesystem   delete snapshotdir  true
throw new hbasesnapshotexception     snapshotdir
// call coproc post hook
if  cphost    null
cphost postdeletesnapshot snapshot
/**
* return the handler if it is currently running and has the same snapshot target name.
* @param snapshot
* @return null if doesn't match, else a live handler.
*/
private synchronized takesnapshothandler gettakesnapshothandler snapshotdescription snapshot
takesnapshothandler h   this handler
if  h    null
return null
if   h getsnapshot   getname   equals snapshot getname
// specified snapshot is to the one currently running
return null
return h
/**
* check if the specified snapshot is done
* @param expected
* @return true if snapshot is ready to be restored, false if it is still being taken.
* @throws ioexception ioexception if error from hdfs or rpc
* @throws unknownsnapshotexception if snapshot is invalid or does not exist.
*/
public boolean issnapshotdone snapshotdescription expected  throws ioexception
// check the request to make sure it has a snapshot
if  expected    null
throw new unknownsnapshotexception
string ssstring   clientsnapshotdescriptionutils tostring expected
// check to see if the sentinel exists
takesnapshothandler handler   gettakesnapshothandler expected
if  handler    null
// doesn't exist, check if it is already completely done.
if   issnapshotcompleted expected
throw new unknownsnapshotexception     ssstring
// was done, return true;
return true
// pass on any failure we find in the sentinel
try
handler rethrowexception
catch  foreignexception e
// give some procedure info on an exception.
string status
procedure p   coordinator getprocedure expected getname
if  p    null
status   p getstatus
else
status   expected getname         coordinator getprocedurenames
throw new hbasesnapshotexception     ssstring        status  e
expected
// check to see if we are done
if  handler isfinished
log debug     ssstring
return true
else if  log isdebugenabled
log debug     ssstring
return false
/**
* check to see if there are any snapshots in progress currently.  currently we have a
* limitation only allowing a single snapshot attempt at a time.
* @return <tt>true</tt> if there any snapshots in progress, <tt>false</tt> otherwise
* @throws snapshotcreationexception if the snapshot failed
*/
synchronized boolean istakingsnapshot   throws snapshotcreationexception
// todo later when we handle multiple there would be a map with ssname to handler.
return handler    null     handler isfinished
/**
* check to see if the specified table has a snapshot in progress.  currently we have a
* limitation only allowing a single snapshot attempt at a time.
* @param tablename name of the table being snapshotted.
* @return <tt>true</tt> if there is a snapshot in progress on the specified table.
*/
private boolean istakingsnapshot final string tablename
if  handler    null    handler getsnapshot   gettable   equals tablename
return  handler isfinished
return false
/**
* check to make sure that we are ok to run the passed snapshot. checks to make sure that we
* aren't already running a snapshot.
* @param snapshot description of the snapshot we want to start
* @throws hbasesnapshotexception if the filesystem could not be prepared to start the snapshot
*/
private synchronized void preparetotakesnapshot snapshotdescription snapshot
throws hbasesnapshotexception
filesystem fs   master getmasterfilesystem   getfilesystem
path workingdir   snapshotdescriptionutils getworkingsnapshotdir snapshot  rootdir
// make sure we aren't already running a snapshot
if  istakingsnapshot
throw new snapshotcreationexception
clientsnapshotdescriptionutils tostring snapshot
clientsnapshotdescriptionutils tostring this handler getsnapshot     snapshot
// make sure we aren't running a restore on the same table
if  isrestoringtable snapshot gettable
throw new snapshotcreationexception
clientsnapshotdescriptionutils tostring snapshot
clientsnapshotdescriptionutils tostring this handler getsnapshot     snapshot
try
// delete the working directory, since we aren't running the snapshot. likely leftovers
// from a failed attempt.
fs delete workingdir  true
// recreate the working directory for the snapshot
if   fs mkdirs workingdir
throw new snapshotcreationexception     workingdir
snapshot
catch  hbasesnapshotexception e
throw e
catch  ioexception e
throw new snapshotcreationexception
e  snapshot
/**
* take a snapshot of an enabled table.
* <p>
* the thread limitation on the executorservice's thread pool for snapshots ensures the
* snapshot won't be started if there is another snapshot already running. does
* <b>not</b> check to see if another snapshot of the same name already exists.
* @param snapshot description of the snapshot to take.
* @throws hbasesnapshotexception if the snapshot could not be started
*/
private synchronized void snapshotenabledtable snapshotdescription snapshot
throws hbasesnapshotexception
takesnapshothandler handler
try
handler   new enabledtablesnapshothandler snapshot  master  this  prepare
this executorservice submit handler
this handler   handler
catch  exception e
// cleanup the working directory by trying to delete it from the fs.
path workingdir   snapshotdescriptionutils getworkingsnapshotdir snapshot  rootdir
try
if   this master getmasterfilesystem   getfilesystem   delete workingdir  true
log warn     workingdir
clientsnapshotdescriptionutils tostring snapshot
catch  ioexception e1
log warn     workingdir
clientsnapshotdescriptionutils tostring snapshot
// fail the snapshot
throw new snapshotcreationexception    e  snapshot
/**
* take a snapshot based on the enabled/disabled state of the table.
*
* @param snapshot
* @throws hbasesnapshotexception when a snapshot specific exception occurs.
* @throws ioexception when some sort of generic io exception occurs.
*/
public void takesnapshot snapshotdescription snapshot  throws ioexception
// check to see if we already completed the snapshot
if  issnapshotcompleted snapshot
throw new snapshotexistsexception     snapshot getname
snapshot
log debug
// check to see if the table exists
htabledescriptor desc   null
try
desc   master gettabledescriptors   get snapshot gettable
catch  filenotfoundexception e
string msg       snapshot gettable
log error msg
throw new snapshotcreationexception msg  e  snapshot
catch  ioexception e
throw new snapshotcreationexception
snapshot gettable    e  snapshot
if  desc    null
throw new snapshotcreationexception     snapshot gettable
snapshot
// set the snapshot version, now that we are ready to take it
snapshot   snapshot tobuilder   setversion snapshotdescriptionutils snapshot_layout_version
build
// call pre coproc hook
mastercoprocessorhost cphost   master getcoprocessorhost
if  cphost    null
cphost presnapshot snapshot  desc
// setup the snapshot
preparetotakesnapshot snapshot
// if the table is enabled, then have the rs run actually the snapshot work
assignmentmanager assignmentmgr   master getassignmentmanager
if  assignmentmgr getzktable   isenabledtable snapshot gettable
log debug
snapshotenabledtable snapshot
log debug     clientsnapshotdescriptionutils tostring snapshot
// for disabled table, snapshot is created by the master
else if  assignmentmgr getzktable   isdisabledtable snapshot gettable
log debug
snapshotdisabledtable snapshot
log debug     clientsnapshotdescriptionutils tostring snapshot
else
log error     snapshot gettable
tablepartiallyopenexception tpoe   new tablepartiallyopenexception snapshot gettable
throw new snapshotcreationexception    tpoe  snapshot
// call post coproc hook
if  cphost    null
cphost postsnapshot snapshot  desc
/**
* take a snapshot of a disabled table.
* <p>
* the thread limitation on the executorservice's thread pool for snapshots ensures the
* snapshot won't be started if there is another snapshot already running. does
* <b>not</b> check to see if another snapshot of the same name already exists.
* @param snapshot description of the snapshot to take. modified to be {@link type#disabled}.
* @throws hbasesnapshotexception if the snapshot could not be started
*/
private synchronized void snapshotdisabledtable snapshotdescription snapshot
throws hbasesnapshotexception
// set the snapshot to be a disabled snapshot, since the client doesn't know about that
snapshot   snapshot tobuilder   settype type disabled  build
disabledtablesnapshothandler handler
try
handler   new disabledtablesnapshothandler snapshot  this master  prepare
this executorservice submit handler
this handler   handler
catch  exception e
// cleanup the working directory by trying to delete it from the fs.
path workingdir   snapshotdescriptionutils getworkingsnapshotdir snapshot  rootdir
try
if   this master getmasterfilesystem   getfilesystem   delete workingdir  true
log error     workingdir
clientsnapshotdescriptionutils tostring snapshot
catch  ioexception e1
log error     workingdir
clientsnapshotdescriptionutils tostring snapshot
// fail the snapshot
throw new snapshotcreationexception    e  snapshot
/**
* set the handler for the current snapshot
* <p>
* exposed for testing
* @param handler handler the master should use
*
* todo get rid of this if possible, repackaging, modify tests.
*/
public synchronized void setsnapshothandlerfortesting takesnapshothandler handler
this handler   handler
/**
* @return distributed commit coordinator for all running snapshots
*/
procedurecoordinator getcoordinator
return coordinator
/**
* check to see if the snapshot is one of the currently completed snapshots
* @param expected snapshot to check
* @return <tt>true</tt> if the snapshot is stored on the {@link filesystem}, <tt>false</tt> if is
*         not stored
* @throws ioexception if the filesystem throws an unexpected exception,
* @throws illegalargumentexception if snapshot name is invalid.
*/
private boolean issnapshotcompleted snapshotdescription snapshot  throws ioexception
try
final path snapshotdir   snapshotdescriptionutils getcompletedsnapshotdir snapshot  rootdir
filesystem fs   master getmasterfilesystem   getfilesystem
// check to see if the snapshot already exists
return fs exists snapshotdir
catch  illegalargumentexception iae
throw new unknownsnapshotexception    iae
/**
* clone the specified snapshot into a new table.
* the operation will fail if the destination table has a snapshot or restore in progress.
*
* @param snapshot snapshot descriptor
* @param htabledescriptor table descriptor of the table to create
* @param waittime timeout before considering the clone failed
*/
synchronized void clonesnapshot final snapshotdescription snapshot
final htabledescriptor htabledescriptor  throws hbasesnapshotexception
string tablename   htabledescriptor getnameasstring
// make sure we aren't running a snapshot on the same table
if  istakingsnapshot tablename
throw new restoresnapshotexception     tablename
// make sure we aren't running a restore on the same table
if  isrestoringtable tablename
throw new restoresnapshotexception     tablename
try
clonesnapshothandler handler
new clonesnapshothandler master  snapshot  htabledescriptor  prepare
this executorservice submit handler
restorehandlers put tablename  handler
catch  exception e
string msg       clientsnapshotdescriptionutils tostring snapshot
tablename
log error msg  e
throw new restoresnapshotexception msg  e
/**
* restore the specified snapshot
* @param reqsnapshot
* @throws ioexception
*/
public void restoresnapshot snapshotdescription reqsnapshot  throws ioexception
filesystem fs   master getmasterfilesystem   getfilesystem
path snapshotdir   snapshotdescriptionutils getcompletedsnapshotdir reqsnapshot  rootdir
mastercoprocessorhost cphost   master getcoprocessorhost
// check if the snapshot exists
if   fs exists snapshotdir
log error     reqsnapshot getname
throw new snapshotdoesnotexistexception reqsnapshot
// read snapshot information
snapshotdescription fssnapshot   snapshotdescriptionutils readsnapshotinfo fs  snapshotdir
htabledescriptor snapshottabledesc   fstabledescriptors gettabledescriptor fs  snapshotdir
string tablename   reqsnapshot gettable
// stop tracking completed restores
cleanuprestoresentinels
// execute the restore/clone operation
if  metareader tableexists master getcatalogtracker    tablename
if  master getassignmentmanager   getzktable   isenabledtable fssnapshot gettable
throw new unsupportedoperationexception
fssnapshot gettable
// call coproc pre hook
if  cphost    null
cphost prerestoresnapshot reqsnapshot  snapshottabledesc
restoresnapshot fssnapshot  snapshottabledesc
log info     fssnapshot getname         tablename
if  cphost    null
cphost postrestoresnapshot reqsnapshot  snapshottabledesc
else
htabledescriptor htd   restoresnapshothelper clonetableschema snapshottabledesc
bytes tobytes tablename
if  cphost    null
cphost preclonesnapshot reqsnapshot  htd
clonesnapshot fssnapshot  htd
log info     fssnapshot getname         tablename
if  cphost    null
cphost postclonesnapshot reqsnapshot  htd
/**
* restore the specified snapshot.
* the restore will fail if the destination table has a snapshot or restore in progress.
*
* @param snapshot snapshot descriptor
* @param htabledescriptor table descriptor
* @param waittime timeout before considering the restore failed
*/
private synchronized void restoresnapshot final snapshotdescription snapshot
final htabledescriptor htabledescriptor  throws hbasesnapshotexception
string tablename   htabledescriptor getnameasstring
// make sure we aren't running a snapshot on the same table
if  istakingsnapshot tablename
throw new restoresnapshotexception     tablename
// make sure we aren't running a restore on the same table
if  isrestoringtable tablename
throw new restoresnapshotexception     tablename
try
restoresnapshothandler handler
new restoresnapshothandler master  snapshot  htabledescriptor
this executorservice submit handler
restorehandlers put htabledescriptor getnameasstring    handler
catch  exception e
string msg       clientsnapshotdescriptionutils tostring
snapshot
tablename
log error msg  e
throw new restoresnapshotexception msg  e
/**
* verify if the restore of the specified table is in progress.
*
* @param tablename table under restore
* @return <tt>true</tt> if there is a restore in progress of the specified table.
*/
private boolean isrestoringtable final string tablename
snapshotsentinel sentinel   restorehandlers get tablename
return sentinel    null     sentinel isfinished
/**
* returns status of a restore request, specifically comparing source snapshot and target table
* names.  throws exception if not a known snapshot.
* @param snapshot
* @return true if in progress, false if snapshot is completed.
* @throws unknownsnapshotexception if specified source snapshot does not exit.
* @throws ioexception if there was some sort of io failure
*/
public boolean isrestoringtable final snapshotdescription snapshot  throws ioexception
// check to see if the snapshot is already on the fs
if   issnapshotcompleted snapshot
throw new unknownsnapshotexception     snapshot getname
snapshotsentinel sentinel   getrestoresnapshotsentinel snapshot gettable
if  sentinel    null
// there is no sentinel so restore is not in progress.
return false
if   sentinel getsnapshot   getname   equals snapshot getname
// another handler is trying to restore to the table, but it isn't the same snapshot source.
return false
log debug     snapshot getname
sentinel getsnapshot   getname         snapshot gettable
foreignexception e   sentinel getexceptioniffailed
if  e    null  throw e
// check to see if we are done
if  sentinel isfinished
log debug     clientsnapshotdescriptionutils tostring snapshot
return false
if  log isdebugenabled
log debug
clientsnapshotdescriptionutils tostring snapshot
return true
/**
* get the restore snapshot sentinel for the specified table
* @param tablename table under restore
* @return the restore snapshot handler
*/
private synchronized snapshotsentinel getrestoresnapshotsentinel final string tablename
try
return restorehandlers get tablename
finally
cleanuprestoresentinels
/**
* scan the restore handlers and remove the finished ones.
*/
private synchronized void cleanuprestoresentinels
iterator<map entry<string  snapshotsentinel>> it   restorehandlers entryset   iterator
while  it hasnext
map entry<string  snapshotsentinel> entry   it next
snapshotsentinel sentinel   entry getvalue
if  sentinel isfinished
it remove
//
// implementing stoppable interface
//
@override
public void stop string why
// short circuit
if  this stopped  return
// make sure we get stop
this stopped   true
// pass the stop onto take snapshot handlers
if  this handler    null  this handler cancel why
// pass the stop onto all the restore handlers
for  snapshotsentinel restorehandler  this restorehandlers values
restorehandler cancel why
@override
public boolean isstopped
return this stopped
/**
* throws an exception if snapshot operations (take a snapshot, restore, clone) are not supported.
* called at the beginning of snapshot() and restoresnapshot() methods.
* @throws unsupportedoperationexception if snapshot are not supported
*/
public void checksnapshotsupport   throws unsupportedoperationexception
if   this issnapshotsupported
throw new unsupportedoperationexception
hbase_snapshot_enabled
/**
* called at startup, to verify if snapshot operation is supported, and to avoid
* starting the master if there're snapshots present but the cleaners needed are missing.
* otherwise we can end up with snapshot data loss.
* @param conf the {@link configuration} object to use
* @param mfs the masterfilesystem to use
* @throws ioexception in case of file-system operation failure
* @throws unsupportedoperationexception in case cleaners are missing and
*         there're snapshot in the system
*/
private void checksnapshotsupport final configuration conf  final masterfilesystem mfs
throws ioexception  unsupportedoperationexception
// verify if snapshot is disabled by the user
string enabled   conf get hbase_snapshot_enabled
boolean snapshotenabled   conf getboolean hbase_snapshot_enabled  false
boolean userdisabled    enabled    null    enabled trim   length   > 0     snapshotenabled
// extract cleaners from conf
set<string> hfilecleaners   new hashset<string>
string cleaners   conf getstrings hfilecleaner master_hfile_cleaner_plugins
if  cleaners    null  collections addall hfilecleaners  cleaners
set<string> logcleaners   new hashset<string>
cleaners   conf getstrings hconstants hbase_master_logcleaner_plugins
if  cleaners    null  collections addall logcleaners  cleaners
// if the user has enabled the snapshot, we force the cleaners to be present
// otherwise we still need to check if cleaners are enabled or not and verify
// that there're no snapshot in the .snapshot folder.
if  snapshotenabled
// inject snapshot cleaners, if snapshot.enable is true
hfilecleaners add snapshothfilecleaner class getname
hfilecleaners add hfilelinkcleaner class getname
logcleaners add snapshotlogcleaner class getname
// set cleaners conf
conf setstrings hfilecleaner master_hfile_cleaner_plugins
hfilecleaners toarray new string
conf setstrings hconstants hbase_master_logcleaner_plugins
logcleaners toarray new string
else
// verify if cleaners are present
snapshotenabled   logcleaners contains snapshotlogcleaner class getname
hfilecleaners contains snapshothfilecleaner class getname
hfilecleaners contains hfilelinkcleaner class getname
// warn if the cleaners are enabled but the snapshot.enabled property is false/not set.
if  snapshotenabled
log warn
hbase_snapshot_enabled
userdisabled ?
// mark snapshot feature as enabled if cleaners are present and user has not disabled it.
this issnapshotsupported   snapshotenabled     userdisabled
// if cleaners are not enabled, verify that there're no snapshot in the .snapshot folder
// otherwise we end up with snapshot data loss.
if   snapshotenabled
log info
path snapshotdir   snapshotdescriptionutils getsnapshotsdir mfs getrootdir
filesystem fs   mfs getfilesystem
if  fs exists snapshotdir
filestatus snapshots   fsutils liststatus fs  snapshotdir
new snapshotdescriptionutils completedsnaphotdirectoriesfilter fs
if  snapshots    null
log error
checksnapshotsupport