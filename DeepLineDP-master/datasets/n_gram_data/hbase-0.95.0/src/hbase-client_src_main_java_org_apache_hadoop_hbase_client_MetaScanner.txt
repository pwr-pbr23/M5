/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase client
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop classification interfaceaudience
import org apache hadoop conf configuration
import org apache hadoop hbase hconstants
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase servername
import org apache hadoop hbase client hconnectionmanager hconnectable
import org apache hadoop hbase exceptions tablenotfoundexception
import org apache hadoop hbase util bytes
import org apache hadoop hbase util pairofsametype
import java io closeable
import java io ioexception
import java util arraylist
import java util list
import java util navigablemap
import java util treemap
/**
* scanner class that contains the <code>.meta.</code> table scanning logic
* and uses a retryable scanner. provided visitors will be called
* for each row.
*
* although public visibility, this is not a public-facing api and may evolve in
* minor releases.
*
* <p> note that during concurrent region splits, the scanner might not see
* meta changes across rows (for parent and daughter entries) consistently.
* see hbase-5986, and {@link defaultmetascannervisitor} for details. </p>
*/
@interfaceaudience private
public class metascanner
private static final log log   logfactory getlog metascanner class
/**
* scans the meta table and calls a visitor on each rowresult and uses a empty
* start row value as table name.
*
* @param configuration conf
* @param visitor a custom visitor
* @throws ioexception e
*/
public static void metascan configuration configuration
metascannervisitor visitor
throws ioexception
metascan configuration  visitor  null
/**
* scans the meta table and calls a visitor on each rowresult. uses a table
* name to locate meta regions.
*
* @param configuration config
* @param visitor visitor object
* @param usertablename user table name in meta table to start scan at.  pass
* null if not interested in a particular table.
* @throws ioexception e
*/
public static void metascan configuration configuration
metascannervisitor visitor  byte  usertablename
throws ioexception
metascan configuration  visitor  usertablename  null  integer max_value
/**
* scans the meta table and calls a visitor on each rowresult. uses a table
* name and a row name to locate meta regions. and it only scans at most
* <code>rowlimit</code> of rows.
*
* @param configuration hbase configuration.
* @param visitor visitor object.
* @param usertablename user table name in meta table to start scan at.  pass
* null if not interested in a particular table.
* @param row name of the row at the user table. the scan will start from
* the region row where the row resides.
* @param rowlimit max of processed rows. if it is less than 0, it
* will be set to default value <code>integer.max_value</code>.
* @throws ioexception e
*/
public static void metascan configuration configuration
metascannervisitor visitor  byte  usertablename  byte row
int rowlimit
throws ioexception
metascan configuration  visitor  usertablename  row  rowlimit
hconstants meta_table_name
/**
* scans the meta table and calls a visitor on each rowresult. uses a table
* name and a row name to locate meta regions. and it only scans at most
* <code>rowlimit</code> of rows.
*
* @param configuration hbase configuration.
* @param visitor visitor object. closes the visitor before returning.
* @param tablename user table name in meta table to start scan at.  pass
* null if not interested in a particular table.
* @param row name of the row at the user table. the scan will start from
* the region row where the row resides.
* @param rowlimit max of processed rows. if it is less than 0, it
* will be set to default value <code>integer.max_value</code>.
* @param metatablename meta table to scan, root or meta.
* @throws ioexception e
*/
public static void metascan configuration configuration
final metascannervisitor visitor  final byte tablename
final byte row  final int rowlimit  final byte metatablename
throws ioexception
try
hconnectionmanager execute new hconnectable<void> configuration
@override
public void connect hconnection connection  throws ioexception
metascan conf  connection  visitor  tablename  row  rowlimit
metatablename
return null
finally
visitor close
private static void metascan configuration configuration  hconnection connection
metascannervisitor visitor  byte  tablename  byte row
int rowlimit  final byte  metatablename
throws ioexception
int rowupperlimit   rowlimit > 0 ? rowlimit  integer max_value
// if row is not null, we want to use the startkey of the row's region as
// the startrow for the meta scan.
byte startrow
if  row    null
// scan starting at a particular row in a particular table
assert tablename    null
byte searchrow
hregioninfo createregionname tablename  row  hconstants nines
false
htable metatable   null
try
metatable   new htable configuration  hconstants meta_table_name
result startrowresult   metatable getroworbefore searchrow
hconstants catalog_family
if  startrowresult    null
throw new tablenotfoundexception
bytes tostring tablename        bytes tostringbinary searchrow
hregioninfo regioninfo   gethregioninfo startrowresult
if  regioninfo    null
throw new ioexception
bytes tostring tablename        bytes tostringbinary searchrow
byte rowbefore   regioninfo getstartkey
startrow   hregioninfo createregionname tablename  rowbefore
hconstants zeroes  false
finally
if  metatable    null
metatable close
else if  tablename    null    tablename length    0
// full meta scan
startrow   hconstants empty_start_row
else
// scan meta for an entire table
startrow   hregioninfo createregionname
tablename  hconstants empty_start_row  hconstants zeroes  false
// scan over each meta region
scannercallable callable
int rows   math min rowlimit  configuration getint
hconstants hbase_meta_scanner_caching
hconstants default_hbase_meta_scanner_caching
do
final scan scan   new scan startrow  addfamily hconstants catalog_family
if  log isdebugenabled
log debug     bytes tostring metatablename
bytes tostringbinary startrow
rowupperlimit       connection tostring
callable   new scannercallable connection  metatablename  scan  null
// open scanner
callable withretries
int processedrows   0
try
callable setcaching rows
done  do
if  processedrows >  rowupperlimit
break
//we have all the rows here
result  rrs   callable withretries
if  rrs    null    rrs length    0    rrs size      0
break    exit completely
for  result rr   rrs
if  processedrows >  rowupperlimit
break done
if   visitor processrow rr
break done    exit completely
processedrows
//here, we didn't break anywhere. check if we have more rows
while true
// advance the startrow to the end key of the current region
startrow   callable gethregioninfo   getendkey
finally
// close scanner
callable setclose
callable withretries
while  bytes compareto startrow  hconstants last_row     0
/**
* returns hregioninfo object from the column
* hconstants.catalog_family:hconstants.regioninfo_qualifier of the catalog
* table result.
* @param data a result object from the catalog table scan
* @return hregioninfo or null
*/
public static hregioninfo gethregioninfo result data
byte  bytes
data getvalue hconstants catalog_family  hconstants regioninfo_qualifier
if  bytes    null  return null
hregioninfo info   hregioninfo parsefromornull bytes
if  log isdebugenabled
log debug     info
return info
/**
* lists all of the regions currently in meta.
* @param conf
* @return list of all user-space regions.
* @throws ioexception
*/
public static list<hregioninfo> listallregions configuration conf
throws ioexception
return listallregions conf  true
/**
* lists all of the regions currently in meta.
* @param conf
* @param offlined true if we are to include offlined regions, false and we'll
* leave out offlined regions from returned list.
* @return list of all user-space regions.
* @throws ioexception
*/
public static list<hregioninfo> listallregions configuration conf  final boolean offlined
throws ioexception
final list<hregioninfo> regions   new arraylist<hregioninfo>
metascannervisitor visitor   new defaultmetascannervisitor conf
@override
public boolean processrowinternal result result  throws ioexception
if  result    null    result isempty
return true
hregioninfo regioninfo   gethregioninfo result
if  regioninfo    null
log warn     result
return true
// if region offline and we are not to include offlined regions, return.
if  regioninfo isoffline       offlined  return true
regions add regioninfo
return true
metascan conf  visitor
return regions
/**
* lists all of the table regions currently in meta.
* @param conf
* @param offlined true if we are to include offlined regions, false and we'll
* leave out offlined regions from returned list.
* @return map of all user-space regions to servers
* @throws ioexception
*/
public static navigablemap<hregioninfo  servername> alltableregions configuration conf
final byte  tablename  final boolean offlined  throws ioexception
final navigablemap<hregioninfo  servername> regions
new treemap<hregioninfo  servername>
metascannervisitor visitor   new tablemetascannervisitor conf  tablename
@override
public boolean processrowinternal result rowresult  throws ioexception
hregioninfo info   gethregioninfo rowresult
servername servername   hregioninfo getservername rowresult
regions put new unmodifyablehregioninfo info   servername
return true
metascan conf  visitor  tablename
return regions
/**
* visitor class called to process each row of the .meta. table
*/
public interface metascannervisitor extends closeable
/**
* visitor method that accepts a rowresult and the meta region location.
* implementations can return false to stop the region's loop if it becomes
* unnecessary for some reason.
*
* @param rowresult result
* @return a boolean to know if it should continue to loop in the region
* @throws ioexception e
*/
public boolean processrow result rowresult  throws ioexception
public static abstract class metascannervisitorbase implements metascannervisitor
@override
public void close   throws ioexception
/**
* a metascannervisitor that provides a consistent view of the table's
* meta entries during concurrent splits (see hbase-5986 for details). this class
* does not guarantee ordered traversal of meta entries, and can block until the
* meta entries for daughters are available during splits.
*/
public static abstract class defaultmetascannervisitor
extends metascannervisitorbase
protected configuration conf
public defaultmetascannervisitor configuration conf
this conf   conf
public abstract boolean processrowinternal result rowresult  throws ioexception
@override
public boolean processrow result rowresult  throws ioexception
hregioninfo info   gethregioninfo rowresult
if  info    null
return true
//skip over offline and split regions
if    info isoffline      info issplit
return processrowinternal rowresult
return true
/**
* a metascannervisitor for a table. provides a consistent view of the table's
* meta entries during concurrent splits (see hbase-5986 for details). this class
* does not guarantee ordered traversal of meta entries, and can block until the
* meta entries for daughters are available during splits.
*/
public static abstract class tablemetascannervisitor extends defaultmetascannervisitor
private byte tablename
public tablemetascannervisitor configuration conf  byte tablename
super conf
this tablename   tablename
@override
public final boolean processrow result rowresult  throws ioexception
hregioninfo info   gethregioninfo rowresult
if  info    null
return true
if    bytes equals info gettablename    tablename
return false
return super processrow rowresult