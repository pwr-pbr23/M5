/*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase
import java nio bytebuffer
import java util iterator
import java util list
import java util map entry
import java util navigablemap
import org apache hadoop classification interfaceaudience
import org apache hadoop classification interfacestability
import org apache hadoop hbase util byterange
/**
* utility methods helpful slinging {@link cell} instances.
*/
@interfaceaudience private
@interfacestability evolving
public final class cellutil
/******************* byterange *******************************/
public static byterange fillrowrange cell cell  byterange range
return range set cell getrowarray    cell getrowoffset    cell getrowlength
public static byterange fillfamilyrange cell cell  byterange range
return range set cell getfamilyarray    cell getfamilyoffset    cell getfamilylength
public static byterange fillqualifierrange cell cell  byterange range
return range set cell getqualifierarray    cell getqualifieroffset
cell getqualifierlength
/***************** get individual arrays for tests ************/
public static byte getrowarray cell cell
byte output   new byte
copyrowto cell  output  0
return output
public static byte getfamilyarray cell cell
byte output   new byte
copyfamilyto cell  output  0
return output
public static byte getqualifierarray cell cell
byte output   new byte
copyqualifierto cell  output  0
return output
public static byte getvaluearray cell cell
byte output   new byte
copyvalueto cell  output  0
return output
/******************** copyto **********************************/
public static int copyrowto cell cell  byte destination  int destinationoffset
system arraycopy cell getrowarray    cell getrowoffset    destination  destinationoffset
cell getrowlength
return destinationoffset   cell getrowlength
public static int copyfamilyto cell cell  byte destination  int destinationoffset
system arraycopy cell getfamilyarray    cell getfamilyoffset    destination  destinationoffset
cell getfamilylength
return destinationoffset   cell getfamilylength
public static int copyqualifierto cell cell  byte destination  int destinationoffset
system arraycopy cell getqualifierarray    cell getqualifieroffset    destination
destinationoffset  cell getqualifierlength
return destinationoffset   cell getqualifierlength
public static int copyvalueto cell cell  byte destination  int destinationoffset
system arraycopy cell getvaluearray    cell getvalueoffset    destination  destinationoffset
cell getvaluelength
return destinationoffset   cell getvaluelength
/********************* misc *************************************/
public static byte getrowbyte cell cell  int index
return cell getrowarray
public static bytebuffer getvaluebuffershallowcopy cell cell
bytebuffer buffer   bytebuffer wrap cell getvaluearray    cell getvalueoffset
cell getvaluelength
//    buffer.position(buffer.limit());//make it look as if value was appended
return buffer
public static cell createcell final byte  row  final byte  family  final byte  qualifier
final long timestamp  final byte type  final byte  value
// i need a cell factory here.  using keyvalue for now. todo.
// todo: make a new cell implementation that just carries these
// byte arrays.
return new keyvalue row  family  qualifier  timestamp
keyvalue type codetotype type   value
/**
* @param cellscannerables
* @return cellscanner interface over <code>celliterables</code>
*/
public static cellscanner createcellscanner final list<cellscannable> cellscannerables
return new cellscanner
private final iterator<cellscannable> iterator   cellscannerables iterator
private cellscanner cellscanner   null
@override
public cell current
return this cellscanner    null? this cellscanner current    null
@override
public boolean advance
if  this cellscanner    null
if   this iterator hasnext    return false
this cellscanner   this iterator next   cellscanner
if  this cellscanner advance    return true
this cellscanner   null
return advance
/**
* @param celliterable
* @return cellscanner interface over <code>celliterable</code>
*/
public static cellscanner createcellscanner final iterable<cell> celliterable
return createcellscanner celliterable iterator
/**
* @param cells
* @return cellscanner interface over <code>celliterable</code>
*/
public static cellscanner createcellscanner final iterator<cell> cells
return new cellscanner
private final iterator<cell> iterator   cells
private cell current   null
@override
public cell current
return this current
@override
public boolean advance
boolean hasnext   this iterator hasnext
this current   hasnext? this iterator next    null
return hasnext
/**
* @param cellarray
* @return cellscanner interface over <code>cellarray</code>
*/
public static cellscanner createcellscanner final cell cellarray
return new cellscanner
private final cell  cells   cellarray
private int index    1
@override
public cell current
return  index < 0 ? null  this cells
@override
public boolean advance
return   index < this cells length
/**
* flatten the map of cells out under the cellscanner
* @param map map of cell lists; for example, the map of families to cells that is used
* inside put, etc., keeping cells organized by family.
* @return cellscanner interface over <code>celliterable</code>
*/
public static cellscanner createcellscanner final navigablemap<byte
list<? extends cell>> map
return new cellscanner
private final iterator<entry<byte  list<? extends cell>>> entries
map entryset   iterator
private iterator<? extends cell> currentiterator   null
private cell currentcell
@override
public cell current
return this currentcell
@override
public boolean advance
if  this currentiterator    null
if   this entries hasnext    return false
this currentiterator   this entries next   getvalue   iterator
if  this currentiterator hasnext
this currentcell   this currentiterator next
return true
this currentcell   null
this currentiterator   null
return advance