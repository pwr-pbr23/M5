/**
*
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hbase regionserver wal
import java io datainput
import java io dataoutput
import java io ioexception
import java util uuid
import java util regex pattern
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hbase exceptions failedlogcloseexception
import org apache hadoop io writable
import org apache hadoop hbase hregioninfo
import org apache hadoop hbase htabledescriptor
import org apache hadoop hbase util bytes
import org apache hadoop classification interfaceaudience
@interfaceaudience private
public interface hlog
public static final log log   logfactory getlog hlog class
public static final byte metafamily   bytes tobytes
static final byte metarow   bytes tobytes
/** file extension used while splitting an hlog into regions (hbase-2312) */
public static final string splitting_ext
public static final boolean split_skip_errors_default   false
/** the meta region's hlog filename extension */
public static final string meta_hlog_file_extn
static final pattern editfiles_name_pattern   pattern compile
public static final string recovered_log_tmpfile_suffix
public interface reader
void init filesystem fs  path path  configuration c  throws ioexception
void close   throws ioexception
entry next   throws ioexception
entry next entry reuse  throws ioexception
void seek long pos  throws ioexception
long getposition   throws ioexception
void reset   throws ioexception
public interface writer
void init filesystem fs  path path  configuration c  throws ioexception
void close   throws ioexception
void sync   throws ioexception
void append entry entry  throws ioexception
long getlength   throws ioexception
/**
* utility class that lets us keep track of the edit with it's key only used
* when splitting logs
*/
public static class entry implements writable
private waledit edit
private hlogkey key
public entry
edit   new waledit
key   new hlogkey
/**
* constructor for both params
*
* @param edit
*          log's edit
* @param key
*          log's key
*/
public entry hlogkey key  waledit edit
super
this key   key
this edit   edit
/**
* gets the edit
*
* @return edit
*/
public waledit getedit
return edit
/**
* gets the key
*
* @return key
*/
public hlogkey getkey
return key
/**
* set compression context for this entry.
*
* @param compressioncontext
*          compression context
*/
public void setcompressioncontext compressioncontext compressioncontext
edit setcompressioncontext compressioncontext
key setcompressioncontext compressioncontext
@override
public string tostring
return this key       this edit
@override
public void write dataoutput dataoutput  throws ioexception
this key write dataoutput
this edit write dataoutput
@override
public void readfields datainput datainput  throws ioexception
this key readfields datainput
this edit readfields datainput
/**
* registers walactionslistener
*
* @param listener
*/
public void registerwalactionslistener final walactionslistener listener
/**
* unregisters walactionslistener
*
* @param listener
*/
public boolean unregisterwalactionslistener final walactionslistener listener
/**
* @return current state of the monotonically increasing file id.
*/
public long getfilenum
/**
* called by hregionserver when it opens a new region to ensure that log
* sequence numbers are always greater than the latest sequence number of the
* region being brought on-line.
*
* @param newvalue
*          we'll set log edit/sequence number to this value if it is greater
*          than the current value.
*/
public void setsequencenumber final long newvalue
/**
* @return log sequence number
*/
public long getsequencenumber
/**
* roll the log writer. that is, start writing log messages to a new file.
*
* <p>
* the implementation is synchronized in order to make sure there's one rollwriter
* running at any given time.
*
* @return if lots of logs, flush the returned regions so next time through we
*         can clean logs. returns null if nothing to flush. names are actual
*         region names as returned by {@link hregioninfo#getencodedname()}
* @throws org.apache.hadoop.hbase.exceptions.failedlogcloseexception
* @throws ioexception
*/
public byte rollwriter   throws failedlogcloseexception  ioexception
/**
* roll the log writer. that is, start writing log messages to a new file.
*
* <p>
* the implementation is synchronized in order to make sure there's one rollwriter
* running at any given time.
*
* @param force
*          if true, force creation of a new writer even if no entries have
*          been written to the current writer
* @return if lots of logs, flush the returned regions so next time through we
*         can clean logs. returns null if nothing to flush. names are actual
*         region names as returned by {@link hregioninfo#getencodedname()}
* @throws org.apache.hadoop.hbase.exceptions.failedlogcloseexception
* @throws ioexception
*/
public byte rollwriter boolean force  throws failedlogcloseexception
ioexception
/**
* shut down the log.
*
* @throws ioexception
*/
public void close   throws ioexception
/**
* shut down the log and delete the log directory
*
* @throws ioexception
*/
public void closeanddelete   throws ioexception
/**
* append an entry to the log.
*
* @param regioninfo
* @param logedit
* @param logkey
* @param dosync
*          shall we sync after writing the transaction
* @return the txid of this transaction
* @throws ioexception
*/
public long append hregioninfo regioninfo  hlogkey logkey  waledit logedit
htabledescriptor htd  boolean dosync  throws ioexception
/**
* only used in tests.
*
* @param info
* @param tablename
* @param edits
* @param now
* @param htd
* @throws ioexception
*/
public void append hregioninfo info  byte tablename  waledit edits
final long now  htabledescriptor htd  throws ioexception
/**
* append a set of edits to the log. log edits are keyed by (encoded)
* regionname, rowname, and log-sequence-id. the hlog is not flushed after
* this transaction is written to the log.
*
* @param info
* @param tablename
* @param edits
* @param clusterid
*          the originating clusterid for this edit (for replication)
* @param now
* @return txid of this transaction
* @throws ioexception
*/
public long appendnosync hregioninfo info  byte tablename  waledit edits
uuid clusterid  final long now  htabledescriptor htd  throws ioexception
/**
* append a set of edits to the log. log edits are keyed by (encoded)
* regionname, rowname, and log-sequence-id. the hlog is flushed after this
* transaction is written to the log.
*
* @param info
* @param tablename
* @param edits
* @param clusterid
*          the originating clusterid for this edit (for replication)
* @param now
* @param htd
* @return txid of this transaction
* @throws ioexception
*/
public long append hregioninfo info  byte tablename  waledit edits
uuid clusterid  final long now  htabledescriptor htd  throws ioexception
public void hsync   throws ioexception
public void hflush   throws ioexception
public void sync   throws ioexception
public void sync long txid  throws ioexception
/**
* obtain a log sequence number.
*/
public long obtainseqnum
/**
* wal keeps track of the sequence numbers that were not yet flushed from memstores
* in order to be able to do cleanup. this method tells wal that some region is about
* to flush memstore.
*
* we stash the oldest seqnum for the region, and let the the next edit inserted in this
* region be recorded in {@link #append(hregioninfo, byte[], waledit, long, htabledescriptor)}
* as new oldest seqnum. in case of flush being aborted, we put the stashed value back;
* in case of flush succeeding, the seqnum of that first edit after start becomes the
* valid oldest seqnum for this region.
*
* @return current seqnum, to pass on to flushers (who will put it into the metadata of
*         the resulting file as an upper-bound seqnum for that file), or null if flush
*         should not be started.
*/
public long startcacheflush final byte encodedregionname
/**
* complete the cache flush.
* @param encodedregionname encoded region name.
*/
public void completecacheflush final byte encodedregionname
/**
* abort a cache flush. call if the flush fails. note that the only recovery
* for an aborted flush currently is a restart of the regionserver so the
* snapshot content dropped by the failure gets restored to the memstore.v
* @param encodedregionname encoded region name.
*/
public void abortcacheflush byte encodedregionname
/**
* @return coprocessor host.
*/
public walcoprocessorhost getcoprocessorhost
/**
* get lowreplication-roller status
*
* @return lowreplicationrollenabled
*/
public boolean islowreplicationrollenabled
/** gets the earliest sequence number in the memstore for this particular region.
* this can serve as best-effort "recent" wal number for this region.
* @param encodedregionname the region to get the number for.
* @return the number if present, hconstants.no_seqnum if absent.
*/
public long getearliestmemstoreseqnum byte encodedregionname