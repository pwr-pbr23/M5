/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel util
import java io unsupportedencodingexception
import java net uri
import java net urisyntaxexception
import java net urldecoder
import java net urlencoder
import java util arraylist
import java util collections
import java util iterator
import java util linkedhashmap
import java util list
import java util map
import java util regex pattern
/**
* uri utilities.
*
* @version
*/
public final class urisupport
public static final string raw_token_start
public static final string raw_token_end
// match any key-value pair in the uri query string whose key contains
// "passphrase" or "password" or secret key (case-insensitive).
// first capture group is the key, second is the value.
private static final pattern secrets   pattern compile
pattern case_insensitive
// match the user password in the uri as second capture group
// (applies to uri with authority component and userinfo token in the form "user:password").
private static final pattern userinfo_password   pattern compile
// match the user password in the uri path as second capture group
// (applies to uri path with authority component and userinfo token in the form "user:password").
private static final pattern path_userinfo_password   pattern compile
private static final string charset
private urisupport
// helper class
/**
* removes detected sensitive information (such as passwords) from the uri and returns the result.
* @param uri the uri to sanitize.
* @see #secrets for the matched pattern
*
* @return returns null if the uri is null, otherwise the uri with the passphrase, password or secretkey sanitized.
*/
public static string sanitizeuri string uri
string sanitized   uri
if  uri    null
sanitized   secrets matcher sanitized  replaceall
sanitized   userinfo_password matcher sanitized  replacefirst
return sanitized
/**
* removes detected sensitive information (such as passwords) from the
* <em>path part</em> of an uri (that is, the part without the query
* parameters or component prefix) and returns the result.
*
* @param path the uri path to sanitize
* @return null if the path is null, otherwise the sanitized path
*/
public static string sanitizepath string path
string sanitized   path
if  path    null
sanitized   path_userinfo_password matcher sanitized  replacefirst
return sanitized
/**
* parses the query part of the uri (eg the parameters).
* <p/>
* the uri parameters will by default be uri encoded. however you can define a parameter
* values with the syntax: <tt>key=raw(value)</tt> which tells camel to not encode the value,
* and use the value as is (eg key=value) and the value has <b>not</b> been encoded.
*
* @param uri the uri
* @return the parameters, or an empty map if no parameters (eg never null)
* @throws urisyntaxexception is thrown if uri has invalid syntax.
* @see #raw_token_start
* @see #raw_token_end
*/
public static map<string  object> parsequery string uri  throws urisyntaxexception
return parsequery uri  false
/**
* parses the query part of the uri (eg the parameters).
* <p/>
* the uri parameters will by default be uri encoded. however you can define a parameter
* values with the syntax: <tt>key=raw(value)</tt> which tells camel to not encode the value,
* and use the value as is (eg key=value) and the value has <b>not</b> been encoded.
*
* @param uri the uri
* @param useraw whether to force using raw values
* @return the parameters, or an empty map if no parameters (eg never null)
* @throws urisyntaxexception is thrown if uri has invalid syntax.
* @see #raw_token_start
* @see #raw_token_end
*/
public static map<string  object> parsequery string uri  boolean useraw  throws urisyntaxexception
// must check for trailing & as the uri.split("&") will ignore those
if  uri    null    uri endswith
throw new urisyntaxexception uri
if  objecthelper isempty uri
// return an empty map
return new linkedhashmap<string  object> 0
// need to parse the uri query parameters manually as we cannot rely on splitting by &,
// as & can be used in a parameter value as well.
try
// use a linked map so the parameters is in the same order
map<string  object> rc   new linkedhashmap<string  object>
boolean iskey   true
boolean isvalue   false
boolean israw   false
stringbuilder key   new stringbuilder
stringbuilder value   new stringbuilder
// parse the uri parameters char by char
for  int i   0  i < uri length    i
// current char
char ch   uri charat i
// look ahead of the next char
char next
if  i < uri length     2
next   uri charat i   1
else
next
// are we a raw value
israw   value tostring   startswith raw_token_start
// if we are in raw mode, then we keep adding until we hit the end marker
if  israw
if  iskey
key append ch
else if  isvalue
value append ch
// we only end the raw marker if its )& or at the end of the value
boolean end   ch    raw_token_end charat 0      next         next
if  end
// raw value end, so add that as a parameter, and reset flags
addparameter key tostring    value tostring    rc  useraw    israw
key setlength 0
value setlength 0
iskey   true
isvalue   false
israw   false
// skip to next as we are in raw mode and have already added the value
i
continue
// if its a key and there is a = sign then the key ends and we are in value mode
if  iskey    ch
iskey   false
isvalue   true
israw   false
continue
// the & denote parameter is ended
if  ch
// parameter is ended, as we hit & separator
addparameter key tostring    value tostring    rc  useraw    israw
key setlength 0
value setlength 0
iskey   true
isvalue   false
israw   false
continue
// regular char so add it to the key or value
if  iskey
key append ch
else if  isvalue
value append ch
// any left over parameters, then add that
if  key length   > 0
addparameter key tostring    value tostring    rc  useraw    israw
return rc
catch  unsupportedencodingexception e
urisyntaxexception se   new urisyntaxexception e tostring
se initcause e
throw se
private static void addparameter string name  string value  map<string  object> map  boolean israw  throws unsupportedencodingexception
name   urldecoder decode name  charset
if   israw
// need to replace % with %25
value   urldecoder decode value replaceall        charset
// does the key already exist?
if  map containskey name
// yes it does, so make sure we can support multiple values, but using a list
// to hold the multiple values
object existing   map get name
list<string> list
if  existing instanceof list
list   castutils cast  list<?>  existing
else
// create a new list to hold the multiple values
list   new arraylist<string>
string s   existing    null ? existing tostring     null
if  s    null
list add s
list add value
map put name  list
else
map put name  value
/**
* parses the query parameters of the uri (eg the query part).
*
* @param uri the uri
* @return the parameters, or an empty map if no parameters (eg never null)
* @throws urisyntaxexception is thrown if uri has invalid syntax.
*/
public static map<string  object> parseparameters uri uri  throws urisyntaxexception
string query   uri getquery
if  query    null
string schemespecificpart   uri getschemespecificpart
int idx   schemespecificpart indexof
if  idx < 0
// return an empty map
return new linkedhashmap<string  object> 0
else
query   schemespecificpart substring idx   1
else
query   stripprefix query
return parsequery query
/**
* traverses the given parameters, and resolve any parameter values which uses the raw token
* syntax: <tt>key=raw(value)</tt>. this method will then remove the raw tokens, and replace
* the content of the value, with just the value.
*
* @param parameters the uri parameters
* @see #parsequery(string)
* @see #raw_token_start
* @see #raw_token_end
*/
public static void resolverawparametervalues map<string  object> parameters
for  map entry<string  object> entry   parameters entryset
if  entry getvalue      null
string value   entry getvalue   tostring
if  value startswith raw_token_start     value endswith raw_token_end
value   value substring 4  value length     1
entry setvalue value
/**
* creates a uri with the given query
*
* @param uri the uri
* @param query the query to append to the uri
* @return uri with the query appended
* @throws urisyntaxexception is thrown if uri has invalid syntax.
*/
public static uri createuriwithquery uri uri  string query  throws urisyntaxexception
objecthelper notnull uri
// assemble string as new uri and replace parameters with the query instead
string s   uri tostring
string before   objecthelper before s
if  before    null
s   before
if  query    null
s   s       query
if    s contains         uri getfragment      null
s   s       uri getfragment
return new uri s
/**
* strips the prefix from the value.
* <p/>
* returns the value as-is if not starting with the prefix.
*
* @param value  the value
* @param prefix the prefix to remove from value
* @return the value without the prefix
*/
public static string stripprefix string value  string prefix
if  value    null    value startswith prefix
return value substring prefix length
return value
/**
* assembles a query from the given map.
*
* @param options  the map with the options (eg key/value pairs)
* @return a query string with <tt>key1=value&key2=value2&...</tt>, or an empty string if there is no options.
* @throws urisyntaxexception is thrown if uri has invalid syntax.
*/
@suppresswarnings
public static string createquerystring map<string  object> options  throws urisyntaxexception
try
if  options size   > 0
stringbuilder rc   new stringbuilder
boolean first   true
for  object o   options keyset
if  first
first   false
else
rc append
string key    string  o
object value   options get key
// the value may be a list since the same key has multiple values
if  value instanceof list
list<string> list    list<string>  value
for  iterator<string> it   list iterator    it hasnext
string s   it next
appendquerystringparameter key  s  rc
// append & separator if there is more in the list to append
if  it hasnext
rc append
else
// use the value as a string
string s   value    null ? value tostring     null
appendquerystringparameter key  s  rc
return rc tostring
else
return
catch  unsupportedencodingexception e
urisyntaxexception se   new urisyntaxexception e tostring
se initcause e
throw se
private static void appendquerystringparameter string key  string value  stringbuilder rc  throws unsupportedencodingexception
rc append urlencoder encode key  charset
// only append if value is not null
if  value    null
rc append
if  value startswith raw_token_start     value endswith raw_token_end
// do not encode raw parameters
rc append value
else
rc append urlencoder encode value  charset
/**
* creates a uri from the original uri and the remaining parameters
* <p/>
* used by various camel components
*/
public static uri createremaininguri uri originaluri  map<string  object> params  throws urisyntaxexception
string s   createquerystring params
if  s length      0
s   null
return createuriwithquery originaluri  s
/**
* normalizes the uri by reordering the parameters so they are sorted and thus
* we can use the uris for endpoint matching.
* <p/>
* the uri parameters will by default be uri encoded. however you can define a parameter
* values with the syntax: <tt>key=raw(value)</tt> which tells camel to not encode the value,
* and use the value as is (eg key=value) and the value has <b>not</b> been encoded.
*
* @param uri the uri
* @return the normalized uri
* @throws urisyntaxexception in thrown if the uri syntax is invalid
* @throws unsupportedencodingexception is thrown if encoding error
* @see #raw_token_start
* @see #raw_token_end
*/
public static string normalizeuri string uri  throws urisyntaxexception  unsupportedencodingexception
uri u   new uri unsafeuricharactersencoder encode uri
string path   u getschemespecificpart
string scheme   u getscheme
// not possible to normalize
if  scheme    null    path    null
return uri
// lets trim off any query arguments
if  path startswith
path   path substring 2
int idx   path indexof
// when the path has ?
if  idx     1
path   path substring 0  idx
path   unsafeuricharactersencoder encode path
// okay if we have user info in the path and they use @ in username or password,
// then we need to encode them (but leave the last @ sign before the hostname)
// this is needed as camel end users may not encode their user info properly, but expect
// this to work out of the box with camel, and hence we need to fix it for them
string userinfopath   path
if  userinfopath contains
userinfopath   userinfopath substring 0  userinfopath indexof
if  stringhelper countchar userinfopath     > 1
int max   userinfopath lastindexof
string before   userinfopath substring 0  max
// after must be from original path
string after   path substring max
// replace the @ with %40
before   stringhelper replaceall before
path   before   after
// in case there are parameters we should reorder them
map<string  object> parameters   urisupport parseparameters u
if  parameters isempty
// no parameters then just return
return builduri scheme  path  null
else
// reorder parameters a..z
list<string> keys   new arraylist<string> parameters keyset
collections sort keys
map<string  object> sorted   new linkedhashmap<string  object> parameters size
for  string key   keys
sorted put key  parameters get key
// build uri object with sorted parameters
string query   urisupport createquerystring sorted
return builduri scheme  path  query
private static string builduri string scheme  string path  string query
// must include :// to do a correct uri all components can work with
return scheme       path    query    null ?     query