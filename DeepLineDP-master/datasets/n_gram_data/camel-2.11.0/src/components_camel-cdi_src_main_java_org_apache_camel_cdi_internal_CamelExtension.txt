/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel cdi internal
import java lang reflect field
import java lang reflect method
import java lang reflect modifier
import java util arraylist
import java util hashmap
import java util hashset
import java util list
import java util map
import java util set
import javax enterprise context spi creationalcontext
import javax enterprise event observes
import javax enterprise inject spi afterbeandiscovery
import javax enterprise inject spi afterdeploymentvalidation
import javax enterprise inject spi annotated
import javax enterprise inject spi annotatedtype
import javax enterprise inject spi bean
import javax enterprise inject spi beanmanager
import javax enterprise inject spi extension
import javax enterprise inject spi injectiontarget
import javax enterprise inject spi processannotatedtype
import javax enterprise inject spi processbean
import javax enterprise inject spi processinjectiontarget
import javax enterprise inject spi processproducermethod
import javax enterprise util annotationliteral
import javax inject inject
import org apache camel camelcontext
import org apache camel camelcontextaware
import org apache camel consume
import org apache camel endpointinject
import org apache camel produce
import org apache camel routesbuilder
import org apache camel builder routebuilder
import org apache camel cdi cdicamelcontext
import org apache camel cdi contextname
import org apache camel impl defaultcamelbeanpostprocessor
import org apache camel model routecontainer
import org apache camel util objecthelper
import org apache camel util reflectionhelper
import org apache deltaspike core api provider beanprovider
import org apache deltaspike core util metadata builder annotatedtypebuilder
/**
* set of camel specific hooks for cdi.
*/
public class camelextension implements extension
private static class injectliteral extends annotationliteral<inject> implements inject
camelcontextmap camelcontextmap
private final set<bean<?>> eagerbeans   new hashset<bean<?>>
private final map<string  camelcontextconfig> camelcontextconfigmap   new hashmap<string  camelcontextconfig>
private final list<camelcontextbean> camelcontextbeans   new arraylist<camelcontextbean>
public camelextension
/**
* if no context name is specified then default it to the value from
* the {@link org.apache.camel.cdi.contextname} annotation
*/
public static string getcamelcontextname string context  contextname annotation
if  objecthelper isempty context     annotation    null
return annotation value
return context
/**
* process camel context aware bean definitions.
*
* @param process annotated type.
* @throws exception in case of exceptions.
*/
protected void contextawareness @observes processannotatedtype<camelcontextaware> process
throws exception
annotatedtype<camelcontextaware> annotatedtype   process getannotatedtype
class<camelcontextaware> javaclass   annotatedtype getjavaclass
if  camelcontextaware class isassignablefrom javaclass
method method   javaclass getmethod    camelcontext class
annotatedtypebuilder<camelcontextaware> builder   new annotatedtypebuilder<camelcontextaware>
readfromtype javaclass
addtomethod method  new injectliteral
process setannotatedtype builder create
protected <t> void detectroutebuilders @observes processannotatedtype<t> process
throws exception
annotatedtype<t> annotatedtype   process getannotatedtype
contextname annotation   annotatedtype getannotation contextname class
class<t> javaclass   annotatedtype getjavaclass
if  annotation    null    isroutesbean javaclass
addroutebuilderbean process  annotation
private void addroutebuilderbean final processannotatedtype<?> process  contextname annotation
final camelcontextconfig config   getcamelconfig annotation value
config addroutebuilderbean process
/**
* disable creation of default camelcontext bean and rely on context created
* and managed by extension.
*
* @param process annotated type.
*/
protected void disabledefaultcontext @observes processannotatedtype<camelcontext> process
process veto
/**
* registers managed camel bean.
*
* @param abd     after bean discovery event.
* @param manager bean manager.
*/
protected void registermanagedcamelcontext @observes afterbeandiscovery abd  beanmanager manager
// lets ensure we have at least one camel context
if  camelcontextconfigmap isempty
abd addbean new camelcontextbean manager
else
set<map entry<string  camelcontextconfig>> entries   camelcontextconfigmap entryset
for  map entry<string  camelcontextconfig> entry   entries
string name   entry getkey
camelcontextconfig config   entry getvalue
camelcontextbean camelcontextbean   new camelcontextbean manager      name
name  config
camelcontextbeans add camelcontextbean
abd addbean camelcontextbean
/**
* lets detect all beans annotated with @consume and
* beans of type {@link routebuilder} which are annotated with {@link org.apache.camel.cdi.contextname}
* so they can be auto-registered
*/
public void detectconsumebeans @observes processbean<?> event
final bean<?> bean   event getbean
class<?> beanclass   bean getbeanclass
reflectionhelper dowithmethods beanclass  new reflectionhelper methodcallback
@override
public void dowith method method  throws illegalargumentexception  illegalaccessexception
consume consume   method getannotation consume class
if  consume    null
eagerbeans add bean
/**
* lets detect all beans annotated of type {@link routebuilder}
* which are annotated with {@link org.apache.camel.cdi.contextname}
* so they can be auto-registered
*/
public void detectroutebuilderbeans @observes processbean<?> event
final bean<?> bean   event getbean
class<?> beanclass   bean getbeanclass
if  isroutesbean beanclass
addroutebuilderbean bean  beanclass getannotation contextname class
private void addroutebuilderbean bean<?> bean  contextname annotation
if  annotation    null
string contextname   annotation value
camelcontextconfig config   getcamelconfig contextname
config addroutebuilderbean bean
private camelcontextconfig getcamelconfig final string contextname
camelcontextconfig config   camelcontextconfigmap get contextname
if  config    null
config   new camelcontextconfig
camelcontextconfigmap put contextname  config
return config
/**
* lets detect all producer methods createing instances of {@link routebuilder} which are annotated with {@link org.apache.camel.cdi.contextname}
* so they can be auto-registered
*/
public void detectproducerroutes @observes processproducermethod<?  ?> event
annotated annotated   event getannotated
contextname annotation   annotated getannotation contextname class
class<?> returntype   event getannotatedproducermethod   getjavamember   getreturntype
if  isroutesbean returntype
addroutebuilderbean event getbean    annotation
/**
* lets force the cdi container to create all beans annotated with @consume so that the consumer becomes active
*/
public void startconsumebeans @observes afterdeploymentvalidation event  beanmanager beanmanager
throws exception
for  camelcontextbean bean   camelcontextbeans
string name   bean getcamelcontextname
camelcontext context   getcamelcontext name
if  context    null
throw new illegalstateexception
name
bean configurecamelcontext  cdicamelcontext context
for  bean<?> bean   eagerbeans
// force lazy creation to start the consumer
creationalcontext<?> creationalcontext   beanmanager createcreationalcontext bean
beanmanager getreference bean  bean getbeanclass    creationalcontext
/**
* lets perform injection of all beans which use camel annotations
*/
public void oninjectiontarget @observes processinjectiontarget<object> event
final injectiontarget<object> injectiontarget   event getinjectiontarget
annotatedtype<object> annotatedtype   event getannotatedtype
final class<object> beanclass   annotatedtype getjavaclass
// todo this is a bit of a hack - what should the bean name be?
final string beanname   injectiontarget tostring
contextname contextname   annotatedtype getannotation contextname class
final beanadapter adapter   createbeanadapter beanclass  contextname
if   adapter isempty
delegateinjectiontarget newtarget   new delegateinjectiontarget injectiontarget
@override
public void postconstruct object instance
super postconstruct instance
// now lets do the post instruct to inject our camel injections
adapter inject camelextension this  instance  beanname
event setinjectiontarget newtarget
/**
* perform injection on an existing bean such as a test case which is created directly by a testing framework.
* <p/>
* this is because beanprovider.injectfields() does not invoke the oninjectiontarget() method so the injection
* of @produce / @endpointinject and processing of the @consume annotations are not performed.
*/
public void inject object bean
class<?> beanclass   bean getclass
contextname contextname   beanclass getannotation contextname class
final beanadapter adapter   createbeanadapter beanclass  contextname
if   adapter isempty
// todo this is a bit of a hack - what should the bean name be?
final string beanname   bean tostring
adapter inject this  bean  beanname
private beanadapter createbeanadapter class<?> beanclass  contextname contextname
final beanadapter adapter   new beanadapter contextname
reflectionhelper dowithfields beanclass  new reflectionhelper fieldcallback
@override
public void dowith field field  throws illegalargumentexception  illegalaccessexception
produce produce   field getannotation produce class
if  produce    null     injectannotatedfield field
adapter addproducefield field
endpointinject endpointinject   field getannotation endpointinject class
if  endpointinject    null
adapter addendpointfield field
reflectionhelper dowithmethods beanclass  new reflectionhelper methodcallback
@override
public void dowith method method  throws illegalargumentexception  illegalaccessexception
consume consume   method getannotation consume class
if  consume    null
adapter addconsumemethod method
produce produce   method getannotation produce class
if  produce    null
adapter addproducemethod method
endpointinject endpointinject   method getannotation endpointinject class
if  endpointinject    null
adapter addendpointmethod method
return adapter
protected defaultcamelbeanpostprocessor getpostprocessor string context
camelcontext camelcontext   getcamelcontext context
if  camelcontext    null
return new defaultcamelbeanpostprocessor camelcontext
else
throw new illegalargumentexception     context
protected camelcontext getcamelcontext string context
if  camelcontextmap    null
camelcontextmap   beanprovider getcontextualreference camelcontextmap class
objecthelper notnull camelcontextmap
return camelcontextmap getcamelcontext context
/**
* returns true if this field is annotated with @inject
*/
protected static boolean injectannotatedfield field field
return field getannotation inject class     null
protected boolean isroutesbean class<?> returntype
return  routesbuilder class isassignablefrom returntype     routecontainer class isassignablefrom returntype       modifier isabstract returntype getmodifiers