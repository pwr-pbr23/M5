/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel impl
import java io ioexception
import java io inputstream
import java util arraylist
import java util arrays
import java util collection
import java util collections
import java util date
import java util hashmap
import java util iterator
import java util linkedhashmap
import java util linkedhashset
import java util list
import java util map
import java util set
import java util treemap
import java util concurrent scheduledexecutorservice
import java util concurrent timeunit
import java util concurrent atomic atomicboolean
import java util concurrent atomic atomicinteger
import javax naming context
import javax xml bind jaxbcontext
import javax xml bind unmarshaller
import org apache camel camelcontext
import org apache camel camelcontextaware
import org apache camel component
import org apache camel consumer
import org apache camel consumertemplate
import org apache camel endpoint
import org apache camel errorhandlerfactory
import org apache camel failedtostartrouteexception
import org apache camel issingleton
import org apache camel multipleconsumerssupport
import org apache camel nofactoryavailableexception
import org apache camel nosuchendpointexception
import org apache camel processor
import org apache camel producer
import org apache camel producertemplate
import org apache camel resolveendpointfailedexception
import org apache camel route
import org apache camel routesbuilder
import org apache camel runtimecamelexception
import org apache camel service
import org apache camel servicestatus
import org apache camel shutdownroute
import org apache camel shutdownrunningtask
import org apache camel startuplistener
import org apache camel statefulservice
import org apache camel suspendableservice
import org apache camel typeconverter
import org apache camel vetocamelcontextstartexception
import org apache camel builder errorhandlerbuilder
import org apache camel component properties propertiescomponent
import org apache camel impl converter basetypeconverterregistry
import org apache camel impl converter defaulttypeconverter
import org apache camel impl converter lazyloadingtypeconverter
import org apache camel management defaultmanagementmbeanassembler
import org apache camel management jmxsystempropertykeys
import org apache camel management managementstrategyfactory
import org apache camel model constants
import org apache camel model dataformatdefinition
import org apache camel model modelcamelcontext
import org apache camel model routedefinition
import org apache camel model routedefinitionhelper
import org apache camel model routesdefinition
import org apache camel processor interceptor backlogtracer
import org apache camel processor interceptor debug
import org apache camel processor interceptor delayer
import org apache camel processor interceptor handlefault
import org apache camel processor interceptor streamcaching
import org apache camel processor interceptor tracer
import org apache camel spi camelcontextnamestrategy
import org apache camel spi classresolver
import org apache camel spi componentresolver
import org apache camel spi dataformat
import org apache camel spi dataformatresolver
import org apache camel spi debugger
import org apache camel spi endpointstrategy
import org apache camel spi eventnotifier
import org apache camel spi executorservicemanager
import org apache camel spi factoryfinder
import org apache camel spi factoryfinderresolver
import org apache camel spi inflightrepository
import org apache camel spi injector
import org apache camel spi interceptstrategy
import org apache camel spi language
import org apache camel spi languageresolver
import org apache camel spi lifecyclestrategy
import org apache camel spi managementmbeanassembler
import org apache camel spi managementnamestrategy
import org apache camel spi managementstrategy
import org apache camel spi nodeidfactory
import org apache camel spi packagescanclassresolver
import org apache camel spi processorfactory
import org apache camel spi registry
import org apache camel spi routecontext
import org apache camel spi routestartuporder
import org apache camel spi servicepool
import org apache camel spi shutdownstrategy
import org apache camel spi typeconverterregistry
import org apache camel spi uuidgenerator
import org apache camel support servicesupport
import org apache camel util camelcontexthelper
import org apache camel util endpointhelper
import org apache camel util eventhelper
import org apache camel util introspectionsupport
import org apache camel util objecthelper
import org apache camel util servicehelper
import org apache camel util stopwatch
import org apache camel util timeutils
import org apache camel util urisupport
import org slf4j logger
import org slf4j loggerfactory
/**
* represents the context used to configure routes and the policies to use.
*
* @version
*/
@suppresswarnings
public class defaultcamelcontext extends servicesupport implements modelcamelcontext  suspendableservice
private final transient logger log   loggerfactory getlogger getclass
private jaxbcontext jaxbcontext
private camelcontextnamestrategy namestrategy   new defaultcamelcontextnamestrategy
private managementnamestrategy managementnamestrategy   new defaultmanagementnamestrategy this
private string managementname
private classloader applicationcontextclassloader
private map<endpointkey  endpoint> endpoints
private final atomicinteger endpointkeycounter   new atomicinteger
private final list<endpointstrategy> endpointstrategies   new arraylist<endpointstrategy>
private final map<string  component> components   new hashmap<string  component>
private final set<route> routes   new linkedhashset<route>
private final list<service> servicestoclose   new arraylist<service>
private final set<startuplistener> startuplisteners   new linkedhashset<startuplistener>
private typeconverter typeconverter
private typeconverterregistry typeconverterregistry
private injector injector
private componentresolver componentresolver
private boolean autocreatecomponents   true
private languageresolver languageresolver   new defaultlanguageresolver
private final map<string  language> languages   new hashmap<string  language>
private registry registry
private list<lifecyclestrategy> lifecyclestrategies   new arraylist<lifecyclestrategy>
private managementstrategy managementstrategy
private managementmbeanassembler managementmbeanassembler
private atomicboolean managementstrategyinitialized   new atomicboolean false
private final list<routedefinition> routedefinitions   new arraylist<routedefinition>
private list<interceptstrategy> interceptstrategies   new arraylist<interceptstrategy>
// special flags to control the first startup which can are special
private volatile boolean firststartdone
private volatile boolean donotstartroutesonfirststart
private final threadlocal<boolean> isstartingroutes   new threadlocal<boolean>
private boolean autostartup   boolean true
private boolean trace   boolean false
private boolean streamcache   boolean false
private boolean handlefault   boolean false
private boolean disablejmx   boolean false
private boolean lazyloadtypeconverters   boolean false
private boolean typeconverterstatisticsenabled   boolean false
private boolean usemdclogging   boolean false
private boolean usebreadcrumb   boolean true
private long delay
private errorhandlerfactory errorhandlerbuilder
private scheduledexecutorservice errorhandlerexecutorservice
private map<string  dataformatdefinition> dataformats   new hashmap<string  dataformatdefinition>
private dataformatresolver dataformatresolver   new defaultdataformatresolver
private map<string  string> properties   new hashmap<string  string>
private factoryfinderresolver factoryfinderresolver   new defaultfactoryfinderresolver
private factoryfinder defaultfactoryfinder
private propertiescomponent propertiescomponent
private final map<string  factoryfinder> factories   new hashmap<string  factoryfinder>
private final map<string  routeservice> routeservices   new linkedhashmap<string  routeservice>
private final map<string  routeservice> suspendedrouteservices   new linkedhashmap<string  routeservice>
private classresolver classresolver   new defaultclassresolver
private packagescanclassresolver packagescanclassresolver
// we use a capacity of 100 per endpoint, so for the same endpoint we have at most 100 producers in the pool
// so if we have 6 endpoints in the pool, we can have 6 x 100 producers in total
private servicepool<endpoint  producer> producerservicepool   new sharedproducerservicepool 100
private nodeidfactory nodeidfactory   new defaultnodeidfactory
private processorfactory processorfactory
private interceptstrategy defaulttracer
private interceptstrategy defaultbacklogtracer
private inflightrepository inflightrepository   new defaultinflightrepository
private final list<routestartuporder> routestartuporder   new arraylist<routestartuporder>
// start auto assigning route ids using numbering 1000 and upwards
private int defaultroutestartuporder   1000
private shutdownstrategy shutdownstrategy   new defaultshutdownstrategy this
private shutdownroute shutdownroute   shutdownroute default
private shutdownrunningtask shutdownrunningtask   shutdownrunningtask completecurrenttaskonly
private executorservicemanager executorservicemanager
private debugger debugger
private uuidgenerator uuidgenerator   createdefaultuuidgenerator
private final stopwatch stopwatch   new stopwatch false
private date startdate
/**
* creates the {@link camelcontext} using {@link jndiregistry} as registry,
* but will silently fallback and use {@link simpleregistry} if jndi cannot be used.
* <p/>
* use one of the other constructors to force use an explicit registry / jndi.
*/
public defaultcamelcontext
this executorservicemanager   new defaultexecutorservicemanager this
// create endpoint registry at first since end users may access endpoints before camelcontext is started
this endpoints   new endpointregistry this
// use websphere specific resolver if running on websphere
if  webspherepackagescanclassresolver iswebsphereclassloader this getclass   getclassloader
log info
packagescanclassresolver   new webspherepackagescanclassresolver
else
packagescanclassresolver   new defaultpackagescanclassresolver
/**
* creates the {@link camelcontext} using the given jndi context as the registry
*
* @param jndicontext the jndi context
*/
public defaultcamelcontext context jndicontext
this
setjndicontext jndicontext
/**
* creates the {@link camelcontext} using the given registry
*
* @param registry the registry
*/
public defaultcamelcontext registry registry
this
setregistry registry
public string getname
return getnamestrategy   getname
/**
* sets the name of the this context.
*
* @param name the name
*/
public void setname string name
// use an explicit name strategy since an explicit name was provided to be used
this namestrategy   new explicitcamelcontextnamestrategy name
public camelcontextnamestrategy getnamestrategy
return namestrategy
public void setnamestrategy camelcontextnamestrategy namestrategy
this namestrategy   namestrategy
public managementnamestrategy getmanagementnamestrategy
return managementnamestrategy
public void setmanagementnamestrategy managementnamestrategy managementnamestrategy
this managementnamestrategy   managementnamestrategy
public string getmanagementname
return managementname
public void setmanagementname string managementname
this managementname   managementname
public component hascomponent string componentname
return components get componentname
public void addcomponent string componentname  final component component
objecthelper notnull component
synchronized  components
if  components containskey componentname
throw new illegalargumentexception     componentname
component setcamelcontext this
components put componentname  component
for  lifecyclestrategy strategy   lifecyclestrategies
strategy oncomponentadd componentname  component
// keep reference to properties component up to date
if  component instanceof propertiescomponent      equals componentname
propertiescomponent    propertiescomponent  component
public component getcomponent string name
// synchronize the look up and auto create so that 2 threads can't
// concurrently auto create the same component.
synchronized  components
component component   components get name
if  component    null    autocreatecomponents
try
if  log isdebugenabled
log debug    getcomponentresolver    name
component   getcomponentresolver   resolvecomponent name  this
if  component    null
addcomponent name  component
if  isstarted      isstarting
// if the component is looked up after the context is started, lets start it up.
if  component instanceof service
startservice  service component
catch  exception e
throw new runtimecamelexception     name  e
log trace    name  component
return component
public <t extends component> t getcomponent string name  class<t> componenttype
component component   getcomponent name
if  componenttype isinstance component
return componenttype cast component
else
string message
if  component    null
message       name
else
message       component getclass         componenttype
throw new illegalargumentexception message
public component removecomponent string componentname
synchronized  components
component oldcomponent   components remove componentname
if  oldcomponent    null
try
stopservices oldcomponent
catch  exception e
log warn     oldcomponent      e
for  lifecyclestrategy strategy   lifecyclestrategies
strategy oncomponentremove componentname  oldcomponent
// keep reference to properties component up to date
if  oldcomponent    null      equals componentname
propertiescomponent   null
return oldcomponent
// endpoint management methods
// -----------------------------------------------------------------------
public collection<endpoint> getendpoints
return new arraylist<endpoint> endpoints values
public map<string  endpoint> getendpointmap
treemap<string  endpoint> answer   new treemap<string  endpoint>
for  map entry<endpointkey  endpoint> entry   endpoints entryset
answer put entry getkey   get    entry getvalue
return answer
public endpoint hasendpoint string uri
return endpoints get getendpointkey uri
public endpoint addendpoint string uri  endpoint endpoint  throws exception
endpoint oldendpoint
startservice endpoint
oldendpoint   endpoints remove getendpointkey uri
for  lifecyclestrategy strategy   lifecyclestrategies
strategy onendpointadd endpoint
addendpointtoregistry uri  endpoint
if  oldendpoint    null
stopservices oldendpoint
return oldendpoint
public collection<endpoint> removeendpoints string uri  throws exception
collection<endpoint> answer   new arraylist<endpoint>
endpoint oldendpoint   endpoints remove getendpointkey uri
if  oldendpoint    null
answer add oldendpoint
stopservices oldendpoint
else
for  map entry<endpointkey  endpoint> entry   endpoints entryset
oldendpoint   entry getvalue
if  endpointhelper matchendpoint this  oldendpoint getendpointuri    uri
try
stopservices oldendpoint
catch  exception e
log warn     oldendpoint      e
answer add oldendpoint
endpoints remove entry getkey
// notify lifecycle its being removed
for  endpoint endpoint   answer
for  lifecyclestrategy strategy   lifecyclestrategies
strategy onendpointremove endpoint
return answer
public endpoint getendpoint string uri
objecthelper notempty uri
log trace    uri
// in case path has property placeholders then try to let property component resolve those
try
uri   resolvepropertyplaceholders uri
catch  exception e
throw new resolveendpointfailedexception uri  e
final string rawuri   uri
// normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order
uri   normalizeendpointuri uri
log trace    rawuri  uri
endpoint answer
string scheme   null
endpointkey key   getendpointkey uri
answer   endpoints get key
if  answer    null
try
// use the uri prefix to find the component.
string splituri   objecthelper splitoncharacter uri     2
if  splituri    null
scheme   splituri
log trace    uri  scheme
component component   getcomponent scheme
// ask the component to resolve the endpoint.
if  component    null
log trace    uri  component
// have the component create the endpoint if it can.
if  component userawuri
answer   component createendpoint rawuri
else
answer   component createendpoint uri
if  answer    null    log isdebugenabled
log debug    new object urisupport sanitizeuri uri   answer  component
if  answer    null
// no component then try in registry and elsewhere
answer   createendpoint uri
log trace    uri  answer
if  answer    null
addservice answer
answer   addendpointtoregistry uri  answer
catch  exception e
throw new resolveendpointfailedexception uri  e
// unknown scheme
if  answer    null    scheme    null
throw new resolveendpointfailedexception uri      scheme
return answer
public <t extends endpoint> t getendpoint string name  class<t> endpointtype
endpoint endpoint   getendpoint name
if  endpoint    null
throw new nosuchendpointexception name
if  endpoint instanceof interceptsendtoendpoint
endpoint     interceptsendtoendpoint  endpoint  getdelegate
if  endpointtype isinstance endpoint
return endpointtype cast endpoint
else
throw new illegalargumentexception     endpointtype
endpoint getclass   getcanonicalname
public void addregisterendpointcallback endpointstrategy strategy
if   endpointstrategies contains strategy
// let it be invoked for already registered endpoints so it can catch-up.
endpointstrategies add strategy
for  endpoint endpoint   getendpoints
endpoint newendpoint   strategy registerendpoint endpoint getendpointuri    endpoint
if  newendpoint    null
// put will replace existing endpoint with the new endpoint
endpoints put getendpointkey endpoint getendpointuri     newendpoint
/**
* strategy to add the given endpoint to the internal endpoint registry
*
* @param uri      uri of the endpoint
* @param endpoint the endpoint to add
* @return the added endpoint
*/
protected endpoint addendpointtoregistry string uri  endpoint endpoint
objecthelper notempty uri
objecthelper notnull endpoint
// if there is endpoint strategies, then use the endpoints they return
// as this allows to intercept endpoints etc.
for  endpointstrategy strategy   endpointstrategies
endpoint   strategy registerendpoint uri  endpoint
endpoints put getendpointkey uri  endpoint   endpoint
return endpoint
/**
* normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order.
*
* @param uri the uri
* @return normalized uri
* @throws resolveendpointfailedexception if uri cannot be normalized
*/
protected static string normalizeendpointuri string uri
try
uri   urisupport normalizeuri uri
catch  exception e
throw new resolveendpointfailedexception uri  e
return uri
/**
* gets the endpoint key to use for lookup or whe adding endpoints to the {@link endpointregistry}
*
* @param uri the endpoint uri
* @return the key
*/
protected endpointkey getendpointkey string uri
return new endpointkey uri
/**
* gets the endpoint key to use for lookup or whe adding endpoints to the {@link endpointregistry}
*
* @param uri      the endpoint uri
* @param endpoint the endpoint
* @return the key
*/
protected endpointkey getendpointkey string uri  endpoint endpoint
if  endpoint    null     endpoint issingleton
int counter   endpointkeycounter incrementandget
return new endpointkey uri       counter
else
return new endpointkey uri
// route management methods
// -----------------------------------------------------------------------
public list<routestartuporder> getroutestartuporder
return routestartuporder
public list<route> getroutes
// lets return a copy of the collection as objects are removed later when services are stopped
return new arraylist<route> routes
public route getroute string id
for  route route   getroutes
if  route getid   equals id
return route
return null
@deprecated
public void setroutes list<route> routes
throw new unsupportedoperationexception
synchronized void removeroutecollection collection<route> routes
this routes removeall routes
synchronized void addroutecollection collection<route> routes  throws exception
this routes addall routes
public void addroutes routesbuilder builder  throws exception
log debug    builder
// lets now add the routes from the builder
builder addroutestocamelcontext this
public synchronized routesdefinition loadroutesdefinition inputstream is  throws exception
// load routes using jaxb
if  jaxbcontext    null
// must use classloader from camelcontext to have jaxb working
jaxbcontext   jaxbcontext newinstance constants jaxb_context_packages  camelcontext class getclassloader
unmarshaller unmarshaller   jaxbcontext createunmarshaller
object result   unmarshaller unmarshal is
if  result    null
throw new ioexception     is
// can either be routes or a single route
routesdefinition answer   null
if  result instanceof routedefinition
routedefinition route    routedefinition  result
answer   new routesdefinition
answer getroutes   add route
else if  result instanceof routesdefinition
answer    routesdefinition  result
else
throw new illegalargumentexception     objecthelper classname result        result
return answer
public synchronized void addroutedefinitions collection<routedefinition> routedefinitions  throws exception
for  routedefinition routedefinition   routedefinitions
removeroutedefinition routedefinition
this routedefinitions addall routedefinitions
if  shouldstartroutes
startroutedefinitions routedefinitions
public void addroutedefinition routedefinition routedefinition  throws exception
addroutedefinitions arrays aslist routedefinition
/**
* removes the route definition with the given key.
*
* @return true if one or more routes was removed
*/
protected boolean removeroutedefinition string key
boolean answer   false
iterator<routedefinition> iter   routedefinitions iterator
while  iter hasnext
routedefinition route   iter next
if  route idorcreate nodeidfactory  equals key
iter remove
answer   true
return answer
public synchronized void removeroutedefinitions collection<routedefinition> routedefinitions  throws exception
for  routedefinition routedefinition   routedefinitions
removeroutedefinition routedefinition
public synchronized void removeroutedefinition routedefinition routedefinition  throws exception
string id   routedefinition idorcreate nodeidfactory
stoproute id
removeroute id
this routedefinitions remove routedefinition
public servicestatus getroutestatus string key
routeservice routeservice   routeservices get key
if  routeservice    null
return routeservice getstatus
return null
public void startroute routedefinition route  throws exception
// assign ids to the routes and validate that the id's is all unique
routedefinitionhelper forceassignids this  routedefinitions
string duplicate   routedefinitionhelper validateuniqueids route  routedefinitions
if  duplicate    null
throw new failedtostartrouteexception route getid        duplicate
// indicate we are staring the route using this thread so
// we are able to query this if needed
isstartingroutes set true
try
// must ensure route is prepared, before we can start it
route prepare this
list<route> routes   new arraylist<route>
list<routecontext> routecontexts   route addroutes this  routes
routeservice routeservice   new routeservice this  route  routecontexts  routes
startrouteservice routeservice  true
finally
// we are done staring routes
isstartingroutes remove
public boolean isstartingroutes
boolean answer   isstartingroutes get
return answer    null    answer
public void stoproute routedefinition route  throws exception
stoproute route idorcreate nodeidfactory
public synchronized void startroute string routeid  throws exception
routeservice routeservice   routeservices get routeid
if  routeservice    null
startrouteservice routeservice  false
public synchronized void resumeroute string routeid  throws exception
if   routesupportssuspension routeid
// start route if suspension is not supported
startroute routeid
return
routeservice routeservice   routeservices get routeid
if  routeservice    null
resumerouteservice routeservice
public synchronized boolean stoproute string routeid  long timeout  timeunit timeunit  boolean abortaftertimeout  throws exception
routeservice routeservice   routeservices get routeid
if  routeservice    null
routestartuporder route   new defaultroutestartuporder 1  routeservice getroutes   iterator   next    routeservice
boolean completed   getshutdownstrategy   shutdown this  route  timeout  timeunit  abortaftertimeout
if  completed
// must stop route service as well
stoprouteservice routeservice  false
else
// shutdown was aborted, make sure route is re-started properly
startrouteservice routeservice  false
return completed
return false
public synchronized void stoproute string routeid  throws exception
routeservice routeservice   routeservices get routeid
if  routeservice    null
list<routestartuporder> routes   new arraylist<routestartuporder> 1
routestartuporder order   new defaultroutestartuporder 1  routeservice getroutes   iterator   next    routeservice
routes add order
getshutdownstrategy   shutdown this  routes
// must stop route service as well
stoprouteservice routeservice  false
public synchronized void stoproute string routeid  long timeout  timeunit timeunit  throws exception
routeservice routeservice   routeservices get routeid
if  routeservice    null
list<routestartuporder> routes   new arraylist<routestartuporder> 1
routestartuporder order   new defaultroutestartuporder 1  routeservice getroutes   iterator   next    routeservice
routes add order
getshutdownstrategy   shutdown this  routes  timeout  timeunit
// must stop route service as well
stoprouteservice routeservice  false
public synchronized void shutdownroute string routeid  throws exception
routeservice routeservice   routeservices get routeid
if  routeservice    null
list<routestartuporder> routes   new arraylist<routestartuporder> 1
routestartuporder order   new defaultroutestartuporder 1  routeservice getroutes   iterator   next    routeservice
routes add order
getshutdownstrategy   shutdown this  routes
// must stop route service as well (and remove the routes from management)
stoprouteservice routeservice  true
public synchronized void shutdownroute string routeid  long timeout  timeunit timeunit  throws exception
routeservice routeservice   routeservices get routeid
if  routeservice    null
list<routestartuporder> routes   new arraylist<routestartuporder> 1
routestartuporder order   new defaultroutestartuporder 1  routeservice getroutes   iterator   next    routeservice
routes add order
getshutdownstrategy   shutdown this  routes  timeout  timeunit
// must stop route service as well (and remove the routes from management)
stoprouteservice routeservice  true
public synchronized boolean removeroute string routeid  throws exception
routeservice routeservice   routeservices get routeid
if  routeservice    null
if  getroutestatus routeid  isstopped
routeservice setremovingroutes true
shutdownrouteservice routeservice
removeroutedefinition routeid
routeservices remove routeid
// remove route from startup order as well, as it was removed
iterator<routestartuporder> it   routestartuporder iterator
while  it hasnext
routestartuporder order   it next
if  order getroute   getid   equals routeid
it remove
return true
else
return false
return false
public synchronized void suspendroute string routeid  throws exception
if   routesupportssuspension routeid
// stop if we suspend is not supported
stoproute routeid
return
routeservice routeservice   routeservices get routeid
if  routeservice    null
list<routestartuporder> routes   new arraylist<routestartuporder> 1
routestartuporder order   new defaultroutestartuporder 1  routeservice getroutes   iterator   next    routeservice
routes add order
getshutdownstrategy   suspend this  routes
// must suspend route service as well
suspendrouteservice routeservice
public synchronized void suspendroute string routeid  long timeout  timeunit timeunit  throws exception
if   routesupportssuspension routeid
stoproute routeid  timeout  timeunit
return
routeservice routeservice   routeservices get routeid
if  routeservice    null
list<routestartuporder> routes   new arraylist<routestartuporder> 1
routestartuporder order   new defaultroutestartuporder 1  routeservice getroutes   iterator   next    routeservice
routes add order
getshutdownstrategy   suspend this  routes  timeout  timeunit
// must suspend route service as well
suspendrouteservice routeservice
public void addservice object object  throws exception
doaddservice object  true
private void doaddservice object object  boolean closeonshutdown  throws exception
// inject camelcontext
if  object instanceof camelcontextaware
camelcontextaware aware    camelcontextaware  object
aware setcamelcontext this
if  object instanceof service
service service    service  object
for  lifecyclestrategy strategy   lifecyclestrategies
if  service instanceof endpoint
// use specialized endpoint add
strategy onendpointadd  endpoint  service
else
strategy onserviceadd this  service  null
// only add to services to close if its a singleton
// otherwise we could for example end up with a lot of prototype scope endpoints
boolean singleton   true     assume singleton by default
if  service instanceof issingleton
singleton     issingleton  service  issingleton
// do not add endpoints as they have their own list
if  singleton      service instanceof endpoint
// only add to list of services to close if its not already there
if  closeonshutdown     hasservice service
servicestoclose add service
// and then ensure service is started (as stated in the javadoc)
if  object instanceof service
startservice  service object
else if  object instanceof collection<?>
startservices  collection<?> object
public boolean removeservice object object  throws exception
if  object instanceof service
service service    service  object
for  lifecyclestrategy strategy   lifecyclestrategies
if  service instanceof endpoint
// use specialized endpoint remove
strategy onendpointremove  endpoint  service
else
strategy onserviceremove this  service  null
return servicestoclose remove service
return false
public boolean hasservice object object
if  object instanceof service
service service    service  object
return servicestoclose contains service
return false
public void addstartuplistener startuplistener listener  throws exception
// either add to listener so we can invoke then later when camelcontext has been started
// or invoke the callback right now
if  isstarted
listener oncamelcontextstarted this  true
else
startuplisteners add listener
// helper methods
// -----------------------------------------------------------------------
public language resolvelanguage string language
language answer
synchronized  languages
answer   languages get language
// check if the language is singleton, if so return the shared instance
if  answer instanceof issingleton
boolean singleton     issingleton  answer  issingleton
if  singleton
return answer
// language not known or not singleton, then use resolver
answer   getlanguageresolver   resolvelanguage language  this
// inject camelcontext if aware
if  answer    null    answer instanceof camelcontextaware
camelcontextaware  answer  setcamelcontext this
if  answer    null
languages put language  answer
// no language resolved
return answer
public string getpropertyprefixtoken
propertiescomponent pc   getpropertiescomponent
if  pc    null
return pc getprefixtoken
else
return null
public string getpropertysuffixtoken
propertiescomponent pc   getpropertiescomponent
if  pc    null
return pc getsuffixtoken
else
return null
public string resolvepropertyplaceholders string text  throws exception
// while it is more efficient to only do the lookup if we are sure we need the component,
// with custom tokens, we cannot know if the uri contains a property or not without having
// the component.  we also lose fail-fast behavior for the missing component with this change.
propertiescomponent pc   getpropertiescomponent
// do not parse uris that are designated for the properties component as it will handle that itself
if  text    null     text startswith
// no component, assume default tokens.
if  pc    null    text contains propertiescomponent default_prefix_token
throw new illegalargumentexception
// component available, use actual tokens
else if  pc    null    text contains pc getprefixtoken
// the parser will throw exception if property key was not found
string answer   pc parseuri text
log debug    text  answer
return answer
// return original text as is
return text
// properties
// -----------------------------------------------------------------------
public typeconverter gettypeconverter
if  typeconverter    null
synchronized  this
// we can synchronize on this as there is only one instance
// of the camel context (its the container)
typeconverter   createtypeconverter
try
addservice typeconverter
catch  exception e
throw objecthelper wrapruntimecamelexception e
return typeconverter
public void settypeconverter typeconverter typeconverter
this typeconverter   typeconverter
public typeconverterregistry gettypeconverterregistry
if  typeconverterregistry    null
// init type converter as its lazy
if  typeconverter    null
gettypeconverter
if  typeconverter instanceof typeconverterregistry
typeconverterregistry    typeconverterregistry  typeconverter
return typeconverterregistry
public void settypeconverterregistry typeconverterregistry typeconverterregistry
this typeconverterregistry   typeconverterregistry
public injector getinjector
if  injector    null
injector   createinjector
return injector
public void setinjector injector injector
this injector   injector
public managementmbeanassembler getmanagementmbeanassembler
if  managementmbeanassembler    null
managementmbeanassembler   createmanagementmbeanassembler
return managementmbeanassembler
public void setmanagementmbeanassembler managementmbeanassembler managementmbeanassembler
this managementmbeanassembler   managementmbeanassembler
public componentresolver getcomponentresolver
if  componentresolver    null
componentresolver   createcomponentresolver
return componentresolver
public void setcomponentresolver componentresolver componentresolver
this componentresolver   componentresolver
public languageresolver getlanguageresolver
if  languageresolver    null
languageresolver   new defaultlanguageresolver
return languageresolver
public void setlanguageresolver languageresolver languageresolver
this languageresolver   languageresolver
public boolean isautocreatecomponents
return autocreatecomponents
public void setautocreatecomponents boolean autocreatecomponents
this autocreatecomponents   autocreatecomponents
public registry getregistry
if  registry    null
registry   createregistry
setregistry registry
return registry
/**
* sets the registry to the given jndi context
*
* @param jndicontext is the jndi context to use as the registry
* @see #setregistry(org.apache.camel.spi.registry)
*/
public void setjndicontext context jndicontext
setregistry new jndiregistry jndicontext
public void setregistry registry registry
// wrap the registry so we always do property placeholder lookups
if    registry instanceof propertyplaceholderdelegateregistry
registry   new propertyplaceholderdelegateregistry this  registry
this registry   registry
public list<lifecyclestrategy> getlifecyclestrategies
return lifecyclestrategies
public void setlifecyclestrategies list<lifecyclestrategy> lifecyclestrategies
this lifecyclestrategies   lifecyclestrategies
public void addlifecyclestrategy lifecyclestrategy lifecyclestrategy
this lifecyclestrategies add lifecyclestrategy
public synchronized list<routedefinition> getroutedefinitions
return routedefinitions
public synchronized routedefinition getroutedefinition string id
for  routedefinition route   routedefinitions
if  route getid   equals id
return route
return null
public list<interceptstrategy> getinterceptstrategies
return interceptstrategies
public void setinterceptstrategies list<interceptstrategy> interceptstrategies
this interceptstrategies   interceptstrategies
public void addinterceptstrategy interceptstrategy interceptstrategy
getinterceptstrategies   add interceptstrategy
// for backwards compatible or if user add them here instead of the setxxx methods
if  interceptstrategy instanceof tracer
settracing true
else if  interceptstrategy instanceof handlefault
sethandlefault true
else if  interceptstrategy instanceof streamcaching
setstreamcaching true
else if  interceptstrategy instanceof delayer
setdelayer   delayer interceptstrategy  getdelay
public void setstreamcaching boolean cache
this streamcache   cache
public boolean isstreamcaching
return streamcache
public void settracing boolean tracing
this trace   tracing
public boolean istracing
return trace
public boolean ishandlefault
return handlefault
public void sethandlefault boolean handlefault
this handlefault   handlefault
public long getdelayer
return delay
public void setdelayer long delay
this delay   delay
public producertemplate createproducertemplate
int size   camelcontexthelper getmaximumcachepoolsize this
return createproducertemplate size
public producertemplate createproducertemplate int maximumcachesize
defaultproducertemplate answer   new defaultproducertemplate this
answer setmaximumcachesize maximumcachesize
// start it so its ready to use
try
startservice answer
catch  exception e
throw objecthelper wrapruntimecamelexception e
return answer
public consumertemplate createconsumertemplate
int size   camelcontexthelper getmaximumcachepoolsize this
return createconsumertemplate size
public consumertemplate createconsumertemplate int maximumcachesize
defaultconsumertemplate answer   new defaultconsumertemplate this
answer setmaximumcachesize maximumcachesize
// start it so its ready to use
try
startservice answer
catch  exception e
throw objecthelper wrapruntimecamelexception e
return answer
public errorhandlerbuilder geterrorhandlerbuilder
return  errorhandlerbuilder errorhandlerbuilder
public void seterrorhandlerbuilder errorhandlerfactory errorhandlerbuilder
this errorhandlerbuilder   errorhandlerbuilder
public synchronized scheduledexecutorservice geterrorhandlerexecutorservice
if  errorhandlerexecutorservice    null
// setup default thread pool for error handler
errorhandlerexecutorservice   getexecutorservicemanager   newdefaultscheduledthreadpool
return errorhandlerexecutorservice
public void setproducerservicepool servicepool<endpoint  producer> producerservicepool
this producerservicepool   producerservicepool
public servicepool<endpoint  producer> getproducerservicepool
return producerservicepool
public string getuptime
// compute and log uptime
if  startdate    null
return
long delta   new date   gettime     startdate gettime
return timeutils printduration delta
@override
protected void dosuspend   throws exception
eventhelper notifycamelcontextsuspending this
log info     getversion         getname
stopwatch watch   new stopwatch
// update list of started routes to be suspended
// because we only want to suspend started routes
// (so when we resume we only resume the routes which actually was suspended)
for  map entry<string  routeservice> entry   getrouteservices   entryset
if  entry getvalue   getstatus   isstarted
suspendedrouteservices put entry getkey    entry getvalue
// assemble list of startup ordering so routes can be shutdown accordingly
list<routestartuporder> orders   new arraylist<routestartuporder>
for  map entry<string  routeservice> entry   suspendedrouteservices entryset
route route   entry getvalue   getroutes   iterator   next
integer order   entry getvalue   getroutedefinition   getstartuporder
if  order    null
order   defaultroutestartuporder
orders add new defaultroutestartuporder order  route  entry getvalue
// suspend routes using the shutdown strategy so it can shutdown in correct order
// routes which doesn't support suspension will be stopped instead
getshutdownstrategy   suspend this  orders
// mark the route services as suspended or stopped
for  routeservice service   suspendedrouteservices values
if  routesupportssuspension service getid
service suspend
else
service stop
watch stop
if  log isinfoenabled
log info     getversion         getname         timeutils printduration watch taken
eventhelper notifycamelcontextsuspended this
@override
protected void doresume   throws exception
try
eventhelper notifycamelcontextresuming this
log info     getversion         getname
stopwatch watch   new stopwatch
// start the suspended routes (do not check for route clashes, and indicate)
dostartorresumeroutes suspendedrouteservices  false  true  true  false
// mark the route services as resumed (will be marked as started) as well
for  routeservice service   suspendedrouteservices values
if  routesupportssuspension service getid
service resume
else
service start
watch stop
if  log isinfoenabled
log info     suspendedrouteservices size
log info     getversion         getname         timeutils printduration watch taken
// and clear the list as they have been resumed
suspendedrouteservices clear
eventhelper notifycamelcontextresumed this
catch  exception e
eventhelper notifycamelcontextresumefailed this  e
throw e
public void start   throws exception
startdate   new date
stopwatch restart
log info     getversion         getname
donotstartroutesonfirststart    firststartdone     isautostartup
// if the context was configured with auto startup = false, and we are already started,
// then we may need to start the routes on the 2nd start call
if  firststartdone     isautostartup      isstarted
// invoke this logic to warm up the routes and if possible also start the routes
dostartorresumeroutes routeservices  true  true  false  true
// super will invoke dostart which will prepare internal services and start routes etc.
try
firststartdone   true
super start
catch  vetocamelcontextstartexception e
if  e isrethrowexception
throw e
else
log info    getname    e getmessage
// swallow exception and change state of this camel context to stopped
stop
return
stopwatch stop
if  log isinfoenabled
// count how many routes are actually started
int started   0
for  route route   getroutes
if  getroutestatus route getid    isstarted
started
log info     getroutes   size         started
log info     getversion         getname         timeutils printduration stopwatch taken
eventhelper notifycamelcontextstarted this
// implementation methods
// -----------------------------------------------------------------------
protected synchronized void dostart   throws exception
try
dostartcamel
catch  exception e
// fire event that we failed to start
eventhelper notifycamelcontextstartupfailed this  e
// rethrow cause
throw e
private void dostartcamel   throws exception
if  isstreamcaching
// only add a new stream cache if not already configured
if  streamcaching getstreamcaching this     null
log info     getname
addinterceptstrategy new streamcaching
if  istracing
// tracing is added in the defaultchannel so we can enable it on the fly
log info     getname
if  isusemdclogging
// log if mdc has been enabled
log info     getname
if  ishandlefault
// only add a new handle fault if not already configured
if  handlefault gethandlefault this     null
log info     getname
addinterceptstrategy new handlefault
if  getdelayer      null    getdelayer   > 0
// only add a new delayer if not already configured
if  delayer getdelayer this     null
long millis   getdelayer
log info     millis       getname
addinterceptstrategy new delayer millis
// register debugger
if  getdebugger      null
log info     getdebugger         getname
// register this camel context on the debugger
getdebugger   setcamelcontext this
startservice getdebugger
addinterceptstrategy new debug getdebugger
// start management strategy before lifecycles are started
managementstrategy managementstrategy   getmanagementstrategy
// inject camelcontext if aware
if  managementstrategy instanceof camelcontextaware
camelcontextaware  managementstrategy  setcamelcontext this
servicehelper startservice managementstrategy
// start lifecycle strategies
servicehelper startservices lifecyclestrategies
iterator<lifecyclestrategy> it   lifecyclestrategies iterator
while  it hasnext
lifecyclestrategy strategy   it next
try
strategy oncontextstart this
catch  vetocamelcontextstartexception e
// okay we should not start camel since it was vetoed
log warn    getname    e getmessage
throw e
catch  exception e
log warn     strategy      getname    e getmessage
throw e
// start notifiers as services
for  eventnotifier notifier   getmanagementstrategy   geteventnotifiers
if  notifier instanceof service
service service    service  notifier
for  lifecyclestrategy strategy   lifecyclestrategies
strategy onserviceadd this  service  null
if  notifier instanceof service
startservice  service notifier
// must let some bootstrap service be started before we can notify the starting event
eventhelper notifycamelcontextstarting this
forcelazyinitialization
// re-create endpoint registry as the cache size limit may be set after the constructor of this instance was called.
// and we needed to create endpoints up-front as it may be accessed before this context is started
endpoints   new endpointregistry this  endpoints
addservice endpoints
// special for executorservicemanager as want to stop it manually
doaddservice executorservicemanager  false
addservice producerservicepool
addservice inflightrepository
addservice shutdownstrategy
addservice packagescanclassresolver
// eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance
// due we use properties component for property placeholder resolution at runtime
component existing   hascomponent
if  existing    null
// no existing properties component so lookup and add as component if possible
propertiescomponent   getregistry   lookupbynameandtype    propertiescomponent class
if  propertiescomponent    null
addcomponent    propertiescomponent
else
// store reference to the existing properties component
if  existing instanceof propertiescomponent
propertiescomponent    propertiescomponent  existing
else
// properties component must be expected type
throw new illegalargumentexception     existing getclass         propertiescomponent class
// start components
startservices components values
// start the route definitions before the routes is started
startroutedefinitions routedefinitions
// start routes
if  donotstartroutesonfirststart
log debug
// invoke this logic to warmup the routes and if possible also start the routes
dostartorresumeroutes routeservices  true   donotstartroutesonfirststart  false  true
// starting will continue in the start method
protected synchronized void dostop   throws exception
stopwatch restart
log info     getversion         getname
eventhelper notifycamelcontextstopping this
// stop route inputs in the same order as they was started so we stop the very first inputs first
try
// force shutting down routes as they may otherwise cause shutdown to hang
shutdownstrategy shutdownforced this  getroutestartuporder
catch  throwable e
log warn    e
getroutestartuporder   clear
shutdownservices routeservices values
// do not clear route services or startup listeners as we can start camel again and get the route back as before
// but clear any suspend routes
suspendedrouteservices clear
// the stop order is important
// shutdown default error handler thread pool
if  errorhandlerexecutorservice    null
// force shutting down the thread pool
getexecutorservicemanager   shutdownnow errorhandlerexecutorservice
errorhandlerexecutorservice   null
// shutdown debugger
servicehelper stopandshutdownservice getdebugger
shutdownservices endpoints values
endpoints clear
shutdownservices components values
components clear
try
for  lifecyclestrategy strategy   lifecyclestrategies
strategy oncontextstop this
catch  throwable e
log warn    e
// shutdown services as late as possible
shutdownservices servicestoclose
servicestoclose clear
// must notify that we are stopped before stopping the management strategy
eventhelper notifycamelcontextstopped this
// stop the notifier service
for  eventnotifier notifier   getmanagementstrategy   geteventnotifiers
shutdownservices notifier
// shutdown executor service and management as the last one
shutdownservices executorservicemanager
shutdownservices managementstrategy
shutdownservices managementmbeanassembler
shutdownservices lifecyclestrategies
// do not clear lifecyclestrategies as we can start camel again and get the route back as before
// stop the lazy created so they can be re-created on restart
forcestoplazyinitialization
// stop to clear introspection cache
introspectionsupport stop
stopwatch stop
if  log isinfoenabled
log info    getuptime
log info     getversion         getname         timeutils printduration stopwatch taken
// and clear start date
startdate   null
/**
* starts or resumes the routes
*
* @param routeservices  the routes to start (will only start a route if its not already started)
* @param checkclash     whether to check for startup ordering clash
* @param startconsumer  whether the route consumer should be started. can be used to warmup the route without starting the consumer.
* @param resumeconsumer whether the route consumer should be resumed.
* @param addingroutes   whether we are adding new routes
* @throws exception is thrown if error starting routes
*/
protected void dostartorresumeroutes map<string  routeservice> routeservices  boolean checkclash
boolean startconsumer  boolean resumeconsumer  boolean addingroutes  throws exception
// filter out already started routes
map<string  routeservice> filtered   new linkedhashmap<string  routeservice>
for  map entry<string  routeservice> entry   routeservices entryset
boolean startable   false
consumer consumer   entry getvalue   getroutes   iterator   next   getconsumer
if  consumer instanceof suspendableservice
// consumer could be suspended, which is not reflected in the routeservice status
startable     suspendableservice  consumer  issuspended
if   startable    consumer instanceof statefulservice
// consumer could be stopped, which is not reflected in the routeservice status
startable     statefulservice  consumer  getstatus   isstartable
else if   startable
// no consumer so use state from route service
startable   entry getvalue   getstatus   isstartable
if  startable
filtered put entry getkey    entry getvalue
if   filtered isempty
// the context is now considered started (i.e. isstarted() == true))
// starting routes is done after, not during context startup
safelystartrouteservices checkclash  startconsumer  resumeconsumer  addingroutes  filtered values
// now notify any startup aware listeners as all the routes etc has been started,
// allowing the listeners to do custom work after routes has been started
for  startuplistener startup   startuplisteners
startup oncamelcontextstarted this  isstarted
protected boolean routesupportssuspension string routeid
routeservice routeservice   routeservices get routeid
if  routeservice    null
return routeservice getroutes   iterator   next   supportssuspension
return false
private void shutdownservices object service
// do not rethrow exception as we want to keep shutting down in case of problems
// allow us to do custom work before delegating to service helper
try
if  service instanceof service
servicehelper stopandshutdownservice service
else if  service instanceof collection
servicehelper stopandshutdownservices  collection<?> service
catch  throwable e
log warn     service      e
// fire event
eventhelper notifyservicestopfailure this  service  e
private void shutdownservices collection<?> services
// reverse stopping by default
shutdownservices services  true
private void shutdownservices collection<?> services  boolean reverse
collection<?> list   services
if  reverse
list<object> reverselist   new arraylist<object> services
collections reverse reverselist
list   reverselist
for  object service   list
shutdownservices service
private void startservice service service  throws exception
// and register startup aware so they can be notified when
// camel context has been started
if  service instanceof startuplistener
startuplistener listener    startuplistener  service
addstartuplistener listener
service start
private void startservices collection<?> services  throws exception
for  object element   services
if  element instanceof service
startservice  service element
private void stopservices object service  throws exception
// allow us to do custom work before delegating to service helper
try
servicehelper stopservice service
catch  exception e
// fire event
eventhelper notifyservicestopfailure this  service  e
// rethrow to signal error with stopping
throw e
protected void startroutedefinitions collection<routedefinition> list  throws exception
if  list    null
for  routedefinition route   list
startroute route
/**
* starts the given route service
*/
protected synchronized void startrouteservice routeservice routeservice  boolean addingroutes  throws exception
// we may already be starting routes so remember this, so we can unset accordingly in finally block
boolean alreadystartingroutes   isstartingroutes
if   alreadystartingroutes
isstartingroutes set true
try
// the route service could have been suspended, and if so then resume it instead
if  routeservice getstatus   issuspended
resumerouteservice routeservice
else
// start the route service
routeservices put routeservice getid    routeservice
if  shouldstartroutes
// this method will log the routes being started
safelystartrouteservices true  true  true  false  addingroutes  routeservice
// start route services if it was configured to auto startup and we are not adding routes
boolean autostartup   routeservice getroutedefinition   isautostartup this
if   addingroutes    autostartup
// start the route since auto start is enabled or we are starting a route (not adding new routes)
routeservice start
finally
if   alreadystartingroutes
isstartingroutes remove
/**
* resumes the given route service
*/
protected synchronized void resumerouteservice routeservice routeservice  throws exception
// the route service could have been stopped, and if so then start it instead
if   routeservice getstatus   issuspended
startrouteservice routeservice  false
else
// resume the route service
if  shouldstartroutes
// this method will log the routes being started
safelystartrouteservices true  false  true  true  false  routeservice
// must resume route service as well
routeservice resume
protected synchronized void stoprouteservice routeservice routeservice  boolean removingroutes  throws exception
routeservice setremovingroutes removingroutes
stoprouteservice routeservice
protected void logroutestate route route  string state
if  log isinfoenabled
if  route getconsumer      null
log info    new object route getid    state  route getconsumer   getendpoint
else
log info    route getid    state
protected synchronized void stoprouteservice routeservice routeservice  throws exception
routeservice stop
for  route route   routeservice getroutes
logroutestate route
protected synchronized void shutdownrouteservice routeservice routeservice  throws exception
routeservice shutdown
for  route route   routeservice getroutes
logroutestate route
protected synchronized void suspendrouteservice routeservice routeservice  throws exception
routeservice setremovingroutes false
routeservice suspend
for  route route   routeservice getroutes
logroutestate route
/**
* starts the routes services in a proper manner which ensures the routes will be started in correct order,
* check for clash and that the routes will also be shutdown in correct order as well.
* <p/>
* this method <b>must</b> be used to start routes in a safe manner.
*
* @param checkclash     whether to check for startup order clash
* @param startconsumer  whether the route consumer should be started. can be used to warmup the route without starting the consumer.
* @param resumeconsumer whether the route consumer should be resumed.
* @param addingroutes   whether we are adding new routes
* @param routeservices  the routes
* @throws exception is thrown if error starting the routes
*/
protected synchronized void safelystartrouteservices boolean checkclash  boolean startconsumer  boolean resumeconsumer
boolean addingroutes  collection<routeservice> routeservices  throws exception
// list of inputs to start when all the routes have been prepared for starting
// we use a tree map so the routes will be ordered according to startup order defined on the route
map<integer  defaultroutestartuporder> inputs   new treemap<integer  defaultroutestartuporder>
// figure out the order in which the routes should be started
for  routeservice routeservice   routeservices
defaultroutestartuporder order   doprepareroutetobestarted routeservice
// check for clash before we add it as input
if  checkclash
docheckstartuporderclash order  inputs
inputs put order getstartuporder    order
// warm up routes before we start them
dowarmuproutes inputs  startconsumer
if  startconsumer
if  resumeconsumer
// and now resume the routes
doresumerouteconsumers inputs  addingroutes
else
// and now start the routes
// and check for clash with multiple consumers of the same endpoints which is not allowed
dostartrouteconsumers inputs  addingroutes
// inputs no longer needed
inputs clear
/**
* @see #safelystartrouteservices(boolean,boolean,boolean,boolean,java.util.collection)
*/
protected synchronized void safelystartrouteservices boolean forceautostart  boolean checkclash  boolean startconsumer
boolean resumeconsumer  boolean addingroutes  routeservice    routeservices  throws exception
safelystartrouteservices checkclash  startconsumer  resumeconsumer  addingroutes  arrays aslist routeservices
private defaultroutestartuporder doprepareroutetobestarted routeservice routeservice
// add the inputs from this route service to the list to start afterwards
// should be ordered according to the startup number
integer startuporder   routeservice getroutedefinition   getstartuporder
if  startuporder    null
// auto assign a default startup order
startuporder   defaultroutestartuporder
// create holder object that contains information about this route to be started
route route   routeservice getroutes   iterator   next
return new defaultroutestartuporder startuporder  route  routeservice
private boolean docheckstartuporderclash defaultroutestartuporder answer  map<integer  defaultroutestartuporder> inputs  throws failedtostartrouteexception
// check for clash by startuporder id
defaultroutestartuporder other   inputs get answer getstartuporder
if  other    null    answer    other
string otherid   other getroute   getid
throw new failedtostartrouteexception answer getroute   getid        otherid
answer getstartuporder
// check in existing already started as well
for  routestartuporder order   routestartuporder
string otherid   order getroute   getid
if  answer getroute   getid   equals otherid
// its the same route id so skip clash check as its the same route (can happen when using suspend/resume)
else if  answer getstartuporder      order getstartuporder
throw new failedtostartrouteexception answer getroute   getid        otherid
answer getstartuporder
return true
private void dowarmuproutes map<integer  defaultroutestartuporder> inputs  boolean autostartup  throws exception
// now prepare the routes by starting its services before we start the input
for  map entry<integer  defaultroutestartuporder> entry   inputs entryset
// defer starting inputs till later as we want to prepare the routes by starting
// all their processors and child services etc.
// then later we open the floods to camel by starting the inputs
// what this does is to ensure camel is more robust on starting routes as all routes
// will then be prepared in time before we start inputs which will consume messages to be routed
routeservice routeservice   entry getvalue   getrouteservice
log debug    routeservice getid    autostartup
routeservice warmup
private void doresumerouteconsumers map<integer  defaultroutestartuporder> inputs  boolean addingroutes  throws exception
dostartorresumerouteconsumers inputs  true  addingroutes
private void dostartrouteconsumers map<integer  defaultroutestartuporder> inputs  boolean addingroutes  throws exception
dostartorresumerouteconsumers inputs  false  addingroutes
private void dostartorresumerouteconsumers map<integer  defaultroutestartuporder> inputs  boolean resumeonly  boolean addingroute  throws exception
list<endpoint> routeinputs   new arraylist<endpoint>
for  map entry<integer  defaultroutestartuporder> entry   inputs entryset
integer order   entry getkey
route route   entry getvalue   getroute
routeservice routeservice   entry getvalue   getrouteservice
// if we are starting camel, then skip routes which are configured to not be auto started
boolean autostartup   routeservice getroutedefinition   isautostartup this
if  addingroute     autostartup
log info     routeservice getid
continue
// start the service
for  consumer consumer   routeservice getinputs   values
endpoint endpoint   consumer getendpoint
// check multiple consumer violation, with the other routes to be started
if   docheckmultipleconsumersupportclash endpoint  routeinputs
throw new failedtostartrouteexception routeservice getid
endpoint
// check for multiple consumer violations with existing routes which
// have already been started, or is currently starting
list<endpoint> existingendpoints   new arraylist<endpoint>
for  route existingroute   getroutes
if  route getid   equals existingroute getid
// skip ourselves
continue
endpoint existing   existingroute getendpoint
servicestatus status   getroutestatus existingroute getid
if  status    null     status isstarted      status isstarting
existingendpoints add existing
if   docheckmultipleconsumersupportclash endpoint  existingendpoints
throw new failedtostartrouteexception routeservice getid
endpoint
// start the consumer on the route
log debug    route getid    route
if  resumeonly
log debug    order  route getid
else
log debug    order  route getid
if  resumeonly    route supportssuspension
// if we are resuming and the route can be resumed
servicehelper resumeservice consumer
log info     route getid         endpoint
else
// when starting we should invoke the lifecycle strategies
for  lifecyclestrategy strategy   lifecyclestrategies
strategy onserviceadd this  consumer  route
startservice consumer
log info     route getid         endpoint
routeinputs add endpoint
// add to the order which they was started, so we know how to stop them in reverse order
// but only add if we haven't already registered it before (we dont want to double add when restarting)
boolean found   false
for  routestartuporder other   routestartuporder
if  other getroute   getid      route getid
found   true
break
if   found
routestartuporder add entry getvalue
if  resumeonly
routeservice resume
else
// and start the route service (no need to start children as they are already warmed up)
routeservice start false
private boolean docheckmultipleconsumersupportclash endpoint endpoint  list<endpoint> routeinputs
// is multiple consumers supported
boolean multipleconsumerssupported   false
if  endpoint instanceof multipleconsumerssupport
multipleconsumerssupported     multipleconsumerssupport  endpoint  ismultipleconsumerssupported
if  multipleconsumerssupported
// multiple consumer allowed, so return true
return true
// check in progress list
if  routeinputs contains endpoint
return false
return true
/**
* force some lazy initialization to occur upfront before we start any
* components and create routes
*/
protected void forcelazyinitialization
getregistry
getinjector
getlanguageresolver
gettypeconverterregistry
gettypeconverter
if  istypeconverterstatisticsenabled      null
gettypeconverterregistry   getstatistics   setstatisticsenabled istypeconverterstatisticsenabled
/**
* force clear lazy initialization so they can be re-created on restart
*/
protected void forcestoplazyinitialization
injector   null
languageresolver   null
typeconverterregistry   null
typeconverter   null
/**
* lazily create a default implementation
*/
protected typeconverter createtypeconverter
basetypeconverterregistry answer
if  islazyloadtypeconverters
answer   new lazyloadingtypeconverter packagescanclassresolver  getinjector    getdefaultfactoryfinder
else
answer   new defaulttypeconverter packagescanclassresolver  getinjector    getdefaultfactoryfinder
settypeconverterregistry answer
return answer
/**
* lazily create a default implementation
*/
protected injector createinjector
factoryfinder finder   getdefaultfactoryfinder
try
return  injector  finder newinstance
catch  nofactoryavailableexception e
// lets use the default injector
return new defaultinjector this
/**
* lazily create a default implementation
*/
protected managementmbeanassembler createmanagementmbeanassembler
return new defaultmanagementmbeanassembler
/**
* lazily create a default implementation
*/
protected componentresolver createcomponentresolver
return new defaultcomponentresolver
/**
* lazily create a default implementation
*/
protected registry createregistry
jndiregistry jndi   new jndiregistry
try
// getcontext() will force setting up jndi
jndi getcontext
return jndi
catch  throwable e
log debug     e getmessage        e
return new simpleregistry
/**
* a pluggable strategy to allow an endpoint to be created without requiring
* a component to be its factory, such as for looking up the uri inside some
* {@link registry}
*
* @param uri the uri for the endpoint to be created
* @return the newly created endpoint or null if it could not be resolved
*/
protected endpoint createendpoint string uri
object value   getregistry   lookupbyname uri
if  value instanceof endpoint
return  endpoint  value
else if  value instanceof processor
return new processorendpoint uri  this   processor  value
else if  value    null
return convertbeantoendpoint uri  value
return null
/**
* strategy method for attempting to convert the bean from a {@link registry} to an endpoint using
* some kind of transformation or wrapper
*
* @param uri  the uri for the endpoint (and name in the registry)
* @param bean the bean to be converted to an endpoint, which will be not null
* @return a new endpoint
*/
protected endpoint convertbeantoendpoint string uri  object bean
throw new illegalargumentexception     uri       bean
/**
* should we start newly added routes?
*/
protected boolean shouldstartroutes
return isstarted       isstarting
/**
* gets the properties component in use.
* returns {@code null} if no properties component is in use.
*/
protected propertiescomponent getpropertiescomponent
return propertiescomponent
public void setdataformats map<string  dataformatdefinition> dataformats
this dataformats   dataformats
public map<string  dataformatdefinition> getdataformats
return dataformats
public map<string  string> getproperties
return properties
public void setproperties map<string  string> properties
this properties   properties
public factoryfinder getdefaultfactoryfinder
if  defaultfactoryfinder    null
defaultfactoryfinder   factoryfinderresolver resolvedefaultfactoryfinder getclassresolver
return defaultfactoryfinder
public void setfactoryfinderresolver factoryfinderresolver resolver
this factoryfinderresolver   resolver
public factoryfinder getfactoryfinder string path  throws nofactoryavailableexception
synchronized  factories
factoryfinder answer   factories get path
if  answer    null
answer   factoryfinderresolver resolvefactoryfinder getclassresolver    path
factories put path  answer
return answer
public classresolver getclassresolver
return classresolver
public void setclassresolver classresolver classresolver
this classresolver   classresolver
public packagescanclassresolver getpackagescanclassresolver
return packagescanclassresolver
public void setpackagescanclassresolver packagescanclassresolver packagescanclassresolver
this packagescanclassresolver   packagescanclassresolver
public list<string> getcomponentnames
synchronized  components
list<string> answer   new arraylist<string>
for  string name   components keyset
answer add name
return answer
public list<string> getlanguagenames
synchronized  languages
list<string> answer   new arraylist<string>
for  string name   languages keyset
answer add name
return answer
public nodeidfactory getnodeidfactory
return nodeidfactory
public void setnodeidfactory nodeidfactory idfactory
this nodeidfactory   idfactory
public managementstrategy getmanagementstrategy
synchronized  managementstrategyinitialized
if  managementstrategyinitialized compareandset false  true
managementstrategy   createmanagementstrategy
return managementstrategy
public void setmanagementstrategy managementstrategy managementstrategy
synchronized  managementstrategyinitialized
if  managementstrategyinitialized get
log warn     getname
this managementstrategy   managementstrategy
managementstrategyinitialized set true
public interceptstrategy getdefaulttracer
if  defaulttracer    null
defaulttracer   new tracer
return defaulttracer
public void setdefaulttracer interceptstrategy tracer
this defaulttracer   tracer
public interceptstrategy getdefaultbacklogtracer
if  defaultbacklogtracer    null
defaultbacklogtracer   new backlogtracer this
return defaultbacklogtracer
public void setdefaultbacklogtracer interceptstrategy backlogtracer
this defaultbacklogtracer   backlogtracer
public void disablejmx
disablejmx   true
public inflightrepository getinflightrepository
return inflightrepository
public void setinflightrepository inflightrepository repository
this inflightrepository   repository
public void setautostartup boolean autostartup
this autostartup   autostartup
public boolean isautostartup
return autostartup    null    autostartup
@deprecated
public boolean islazyloadtypeconverters
return lazyloadtypeconverters    null    lazyloadtypeconverters
@deprecated
public void setlazyloadtypeconverters boolean lazyloadtypeconverters
this lazyloadtypeconverters   lazyloadtypeconverters
public boolean istypeconverterstatisticsenabled
return typeconverterstatisticsenabled    null    typeconverterstatisticsenabled
public void settypeconverterstatisticsenabled boolean typeconverterstatisticsenabled
this typeconverterstatisticsenabled   typeconverterstatisticsenabled
public boolean isusemdclogging
return usemdclogging    null    usemdclogging
public void setusemdclogging boolean usemdclogging
this usemdclogging   usemdclogging
public boolean isusebreadcrumb
return usebreadcrumb    null    usebreadcrumb
public void setusebreadcrumb boolean usebreadcrumb
this usebreadcrumb   usebreadcrumb
public classloader getapplicationcontextclassloader
return applicationcontextclassloader
public void setapplicationcontextclassloader classloader classloader
applicationcontextclassloader   classloader
public dataformatresolver getdataformatresolver
return dataformatresolver
public void setdataformatresolver dataformatresolver dataformatresolver
this dataformatresolver   dataformatresolver
public dataformat resolvedataformat string name
dataformat answer   dataformatresolver resolvedataformat name  this
// inject camelcontext if aware
if  answer    null    answer instanceof camelcontextaware
camelcontextaware  answer  setcamelcontext this
return answer
public dataformatdefinition resolvedataformatdefinition string name
// lookup type and create the data format from it
dataformatdefinition type   lookup this  name  dataformatdefinition class
if  type    null    getdataformats      null
type   getdataformats   get name
return type
private static <t> t lookup camelcontext context  string ref  class<t> type
try
return context getregistry   lookupbynameandtype ref  type
catch  exception e
// need to ignore not same type and return it as null
return null
public shutdownstrategy getshutdownstrategy
return shutdownstrategy
public void setshutdownstrategy shutdownstrategy shutdownstrategy
this shutdownstrategy   shutdownstrategy
public shutdownroute getshutdownroute
return shutdownroute
public void setshutdownroute shutdownroute shutdownroute
this shutdownroute   shutdownroute
public shutdownrunningtask getshutdownrunningtask
return shutdownrunningtask
public void setshutdownrunningtask shutdownrunningtask shutdownrunningtask
this shutdownrunningtask   shutdownrunningtask
public executorservicemanager getexecutorservicemanager
return this executorservicemanager
@deprecated
public org apache camel spi executorservicestrategy getexecutorservicestrategy
// its okay to create a new instance as its stateless, and just delegate
// executorservicemanager which is the new api
return new defaultexecutorservicestrategy this
public void setexecutorservicemanager executorservicemanager executorservicemanager
this executorservicemanager   executorservicemanager
public processorfactory getprocessorfactory
return processorfactory
public void setprocessorfactory processorfactory processorfactory
this processorfactory   processorfactory
public debugger getdebugger
return debugger
public void setdebugger debugger debugger
this debugger   debugger
public uuidgenerator getuuidgenerator
return uuidgenerator
public void setuuidgenerator uuidgenerator uuidgenerator
this uuidgenerator   uuidgenerator
protected map<string  routeservice> getrouteservices
return routeservices
protected managementstrategy createmanagementstrategy
return new managementstrategyfactory   create this  disablejmx    boolean getboolean jmxsystempropertykeys disabled
@override
public string tostring
return     getname
/**
* reset context counter to a preset value. mostly used for tests to ensure a predictable getname()
*
* @param value new value for the context counter
*/
public static void setcontextcounter int value
defaultcamelcontextnamestrategy setcounter value
defaultmanagementnamestrategy setcounter value
private static uuidgenerator createdefaultuuidgenerator
if  system getproperty       null
// either "production" or "development"
return new javauuidgenerator
else
return new activemquuidgenerator
@override
public string getproperty string name
string value   getproperties   get name
if  objecthelper isnotempty value
try
value   resolvepropertyplaceholders value
catch  exception ex
// throw camelrutimeexception
throw new runtimecamelexception ex
return value