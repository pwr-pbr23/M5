/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel processor
import java io closeable
import java io ioexception
import java util arraylist
import java util collection
import java util collections
import java util iterator
import java util list
import java util scanner
import java util concurrent executorservice
import org apache camel asynccallback
import org apache camel asyncprocessor
import org apache camel camelcontext
import org apache camel exchange
import org apache camel expression
import org apache camel message
import org apache camel processor
import org apache camel runtimecamelexception
import org apache camel traceable
import org apache camel processor aggregate aggregationstrategy
import org apache camel processor aggregate useoriginalaggregationstrategy
import org apache camel spi routecontext
import org apache camel util exchangehelper
import org apache camel util iohelper
import org apache camel util objecthelper
import org slf4j logger
import org slf4j loggerfactory
import static org apache camel util objecthelper notnull
/**
* implements a dynamic <a
* href="http://camel.apache.org/splitter.html">splitter</a> pattern
* where an expression is evaluated to iterate through each of the parts of a
* message and then each part is then send to some endpoint.
*
* @version
*/
public class splitter extends multicastprocessor implements asyncprocessor  traceable
private static final transient logger log   loggerfactory getlogger splitter class
private final expression expression
public splitter camelcontext camelcontext  expression expression  processor destination  aggregationstrategy aggregationstrategy
this camelcontext  expression  destination  aggregationstrategy  false  null  false  false  false  0  null  false
public splitter camelcontext camelcontext  expression expression  processor destination  aggregationstrategy aggregationstrategy
boolean parallelprocessing  executorservice executorservice  boolean shutdownexecutorservice
boolean streaming  boolean stoponexception  long timeout  processor onprepare  boolean usesubunitofwork
super camelcontext  collections singleton destination   aggregationstrategy  parallelprocessing  executorservice
shutdownexecutorservice  streaming  stoponexception  timeout  onprepare  usesubunitofwork
this expression   expression
notnull expression
notnull destination
@override
public string tostring
return     expression       getprocessors   iterator   next         getaggregationstrategy
@override
public string gettracelabel
return     expression
@override
public boolean process exchange exchange  final asynccallback callback
final aggregationstrategy strategy   getaggregationstrategy
// if no custom aggregation strategy is being used then fallback to keep the original
// and propagate exceptions which is done by a per exchange specific aggregation strategy
// to ensure it supports async routing
if  strategy    null
useoriginalaggregationstrategy original   new useoriginalaggregationstrategy exchange  true
setaggregationstrategyonexchange exchange  original
return super process exchange  callback
@override
protected iterable<processorexchangepair> createprocessorexchangepairs exchange exchange  throws exception
object value   expression evaluate exchange  object class
if  exchange getexception      null
// force any exceptions occurred during evaluation to be thrown
throw exchange getexception
iterable<processorexchangepair> answer
if  isstreaming
answer   createprocessorexchangepairsiterable exchange  value
else
answer   createprocessorexchangepairslist exchange  value
if  exchange getexception      null
// force any exceptions occurred during creation of exchange paris to be thrown
// before returning the answer;
throw exchange getexception
return answer
private iterable<processorexchangepair> createprocessorexchangepairsiterable final exchange exchange  final object value
final iterator<?> iterator   objecthelper createiterator value
return new iterable<processorexchangepair>
// create a copy which we use as master to copy during splitting
// this avoids any side effect reflected upon the incoming exchange
private final exchange copy   copyexchangenoattachments exchange  true
private final routecontext routecontext   exchange getunitofwork      null ? exchange getunitofwork   getroutecontext     null
public iterator<processorexchangepair> iterator
return new iterator<processorexchangepair>
private int index
private boolean closed
public boolean hasnext
if  closed
return false
boolean answer   iterator hasnext
if   answer
// we are now closed
closed   true
// nothing more so we need to close the expression value in case it needs to be
if  value instanceof closeable
iohelper close  closeable  value  value getclass   getname    log
else if  value instanceof scanner
// special for scanner as it does not implement closeable
scanner scanner    scanner  value
scanner close
ioexception ioexception   scanner ioexception
if  ioexception    null
throw new runtimecamelexception    ioexception
return answer
public processorexchangepair next
object part   iterator next
// create a correlated copy as the new exchange to be routed in the splitter from the copy
// and do not share the unit of work
exchange newexchange   exchangehelper createcorrelatedcopy copy  false
// if we share unit of work, we need to prepare the child exchange
if  isshareunitofwork
preparesharedunitofwork newexchange  copy
if  part instanceof message
newexchange setin  message  part
else
message in   newexchange getin
in setbody part
return createprocessorexchangepair index    getprocessors   iterator   next    newexchange  routecontext
public void remove
throw new unsupportedoperationexception
private iterable<processorexchangepair> createprocessorexchangepairslist exchange exchange  object value
list<processorexchangepair> result   new arraylist<processorexchangepair>
// reuse iterable and add it to the result list
iterable<processorexchangepair> pairs   createprocessorexchangepairsiterable exchange  value
for  processorexchangepair pair   pairs
result add pair
return result
@override
protected void updatenewexchange exchange exchange  int index  iterable<processorexchangepair> allpairs
iterator<processorexchangepair> it
// do not share unit of work
exchange setunitofwork null
exchange setproperty exchange split_index  index
if  allpairs instanceof collection
// non streaming mode, so we know the total size already
exchange setproperty exchange split_size    collection<?>  allpairs  size
if  it hasnext
exchange setproperty exchange split_complete  boolean false
else
exchange setproperty exchange split_complete  boolean true
// streaming mode, so set total size when we are complete based on the index
exchange setproperty exchange split_size  index   1
@override
protected integer getexchangeindex exchange exchange
return exchange getproperty exchange split_index  integer class
public expression getexpression
return expression
private static exchange copyexchangenoattachments exchange exchange  boolean preserveexchangeid
exchange answer   exchangehelper createcopy exchange  preserveexchangeid
// we do not want attachments for the splitted sub-messages
answer getin   setattachments null
return answer