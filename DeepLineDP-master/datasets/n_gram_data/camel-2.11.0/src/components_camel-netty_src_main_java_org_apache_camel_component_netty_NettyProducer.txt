/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel component netty
import java net inetsocketaddress
import java util map
import java util concurrent executorservice
import java util concurrent rejectedexecutionexception
import org apache camel asynccallback
import org apache camel camelcontext
import org apache camel camelexception
import org apache camel camelexchangeexception
import org apache camel exchange
import org apache camel notypeconversionavailableexception
import org apache camel impl defaultasyncproducer
import org apache camel util camellogger
import org apache camel util exchangehelper
import org apache camel util iohelper
import org apache commons pool objectpool
import org apache commons pool poolableobjectfactory
import org apache commons pool impl genericobjectpool
import org jboss netty bootstrap clientbootstrap
import org jboss netty bootstrap connectionlessbootstrap
import org jboss netty channel channel
import org jboss netty channel channelfactory
import org jboss netty channel channelfuture
import org jboss netty channel channelfuturelistener
import org jboss netty channel group channelgroup
import org jboss netty channel group channelgroupfuture
import org jboss netty channel group defaultchannelgroup
import org jboss netty channel socket datagramchannelfactory
import org jboss netty channel socket nio nioclientsocketchannelfactory
import org jboss netty channel socket nio niodatagramchannelfactory
import org slf4j logger
import org slf4j loggerfactory
public class nettyproducer extends defaultasyncproducer
private static final transient logger log   loggerfactory getlogger nettyproducer class
private static final channelgroup all_channels   new defaultchannelgroup
private camelcontext context
private nettyconfiguration configuration
private channelfactory channelfactory
private datagramchannelfactory datagramchannelfactory
private clientpipelinefactory pipelinefactory
private camellogger noreplylogger
private executorservice bossexecutor
private executorservice workerexecutor
private objectpool<channel> pool
public nettyproducer nettyendpoint nettyendpoint  nettyconfiguration configuration
super nettyendpoint
this configuration   configuration
this context   this getendpoint   getcamelcontext
this noreplylogger   new camellogger log  configuration getnoreplyloglevel
@override
public nettyendpoint getendpoint
return  nettyendpoint  super getendpoint
@override
public boolean issingleton
return true
public camelcontext getcontext
return context
protected boolean istcp
return configuration getprotocol   equalsignorecase
@override
protected void dostart   throws exception
super dostart
if  configuration isproducerpoolenabled
// setup pool where we want an unbounded pool, which allows the pool to shrink on no demand
genericobjectpool config config   new genericobjectpool config
config maxactive   configuration getproducerpoolmaxactive
config minidle   configuration getproducerpoolminidle
config maxidle   configuration getproducerpoolmaxidle
// we should test on borrow to ensure the channel is still valid
config testonborrow   true
// only evict channels which are no longer valid
config testwhileidle   true
// run eviction every 30th second
config timebetweenevictionrunsmillis   30   1000l
config minevictableidletimemillis   configuration getproducerpoolminevictableidle
config whenexhaustedaction   genericobjectpool when_exhausted_fail
pool   new genericobjectpool<channel> new nettyproducerpoolableobjectfactory    config
if  log isdebugenabled
log debug
new object config maxactive  config minidle  config maxidle  config minevictableidletimemillis  pool
else
pool   new sharedsingletonobjectpool<channel> new nettyproducerpoolableobjectfactory
if  log isdebugenabled
log info    pool
// setup pipeline factory
clientpipelinefactory factory   configuration getclientpipelinefactory
if  factory    null
pipelinefactory   factory createpipelinefactory this
else
pipelinefactory   new defaultclientpipelinefactory this
if  istcp
setuptcpcommunication
else
setupudpcommunication
if   configuration islazychannelcreation
// ensure the connection can be established when we start up
channel channel   pool borrowobject
pool returnobject channel
@override
protected void dostop   throws exception
log debug    configuration getaddress
// close all channels
log trace    all_channels size
channelgroupfuture future   all_channels close
future awaituninterruptibly
// and then release other resources
if  channelfactory    null
channelfactory releaseexternalresources
// and then shutdown the thread pools
if  bossexecutor    null
context getexecutorservicemanager   shutdown bossexecutor
bossexecutor   null
if  workerexecutor    null
context getexecutorservicemanager   shutdown workerexecutor
workerexecutor   null
if  pool    null
if  log isdebugenabled
log debug    pool getnumactive    pool getnumidle
pool close
pool   null
super dostop
public boolean process final exchange exchange  asynccallback callback
if   isrunallowed
if  exchange getexception      null
exchange setexception new rejectedexecutionexception
callback done true
return true
object body   nettypayloadhelper getin getendpoint    exchange
if  body    null
noreplylogger log     exchange
callback done true
return true
// if textline enabled then covert to a string which must be used for textline
if  getconfiguration   istextline
try
body   nettyhelper gettextlinebody body  exchange  getconfiguration   getdelimiter    getconfiguration   isautoappenddelimiter
catch  notypeconversionavailableexception e
exchange setexception e
callback done true
return true
// set the exchange encoding property
if  getconfiguration   getcharsetname      null
exchange setproperty exchange charset_name  iohelper normalizecharset getconfiguration   getcharsetname
if  log istraceenabled
log trace    pool getnumactive    pool getnumidle
// get a channel from the pool
channel existing
try
existing   pool borrowobject
if  existing    null
log trace    existing
catch  exception e
exchange setexception e
callback done true
return true
// we must have a channel
if  existing    null
exchange setexception new camelexchangeexception    exchange
callback done true
return true
// need to declare as final
final channel channel   existing
final asynccallback producercallback   new nettyproducercallback channel  callback
// setup state as attachment on the channel, so we can access the state later when needed
channel setattachment new nettycamelstate producercallback  exchange
// write body
nettyhelper writebodyasync log  channel  null  body  exchange  new channelfuturelistener
public void operationcomplete channelfuture channelfuture  throws exception
log trace    channelfuture
if   channelfuture issuccess
// no success the set the caused exception and signal callback and break
exchange setexception channelfuture getcause
producercallback done false
return
// if we do not expect any reply then signal callback to continue routing
if   configuration issync
try
// should channel be closed after complete?
boolean close
if  exchangehelper isoutcapable exchange
close   exchange getout   getheader nettyconstants netty_close_channel_when_complete  boolean class
else
close   exchange getin   getheader nettyconstants netty_close_channel_when_complete  boolean class
// should we disconnect, the header can override the configuration
boolean disconnect   getconfiguration   isdisconnect
if  close    null
disconnect   close
if  disconnect
if  log istraceenabled
log trace    getendpoint   getconfiguration   getaddress
nettyhelper close channel
finally
// signal callback to continue routing
producercallback done false
// continue routing asynchronously
return false
/**
* to get the {@link nettycamelstate} from the given channel.
*/
public nettycamelstate getstate channel channel
return  nettycamelstate  channel getattachment
/**
* to remove the {@link nettycamelstate} stored on the channel,
* when no longer needed
*/
public void removestate channel channel
channel setattachment null
protected void setuptcpcommunication   throws exception
if  channelfactory    null
bossexecutor   context getexecutorservicemanager   newcachedthreadpool this
workerexecutor   context getexecutorservicemanager   newcachedthreadpool this
if  configuration getworkercount   <  0
channelfactory   new nioclientsocketchannelfactory bossexecutor  workerexecutor
else
channelfactory   new nioclientsocketchannelfactory bossexecutor  workerexecutor  configuration getworkercount
protected void setupudpcommunication   throws exception
if  datagramchannelfactory    null
workerexecutor   context getexecutorservicemanager   newcachedthreadpool this
if  configuration getworkercount   <  0
datagramchannelfactory   new niodatagramchannelfactory workerexecutor
else
datagramchannelfactory   new niodatagramchannelfactory workerexecutor  configuration getworkercount
protected channelfuture openconnection   throws exception
channelfuture answer
if  istcp
// its okay to create a new bootstrap for each new channel
clientbootstrap clientbootstrap   new clientbootstrap channelfactory
clientbootstrap setoption    configuration iskeepalive
clientbootstrap setoption    configuration istcpnodelay
clientbootstrap setoption    configuration isreuseaddress
clientbootstrap setoption    configuration getconnecttimeout
// set any additional netty options
if  configuration getoptions      null
for  map entry<string  object> entry   configuration getoptions   entryset
clientbootstrap setoption entry getkey    entry getvalue
// set the pipeline factory, which creates the pipeline for each newly created channels
clientbootstrap setpipelinefactory pipelinefactory
answer   clientbootstrap connect new inetsocketaddress configuration gethost    configuration getport
if  log isdebugenabled
log debug
new object configuration gethost    configuration getport    clientbootstrap getoptions
return answer
else
// its okay to create a new bootstrap for each new channel
connectionlessbootstrap connectionlessclientbootstrap   new connectionlessbootstrap datagramchannelfactory
connectionlessclientbootstrap setoption    configuration iskeepalive
connectionlessclientbootstrap setoption    configuration istcpnodelay
connectionlessclientbootstrap setoption    configuration isreuseaddress
connectionlessclientbootstrap setoption    configuration getconnecttimeout
connectionlessclientbootstrap setoption    configuration isbroadcast
connectionlessclientbootstrap setoption    configuration getsendbuffersize
connectionlessclientbootstrap setoption    configuration getreceivebuffersize
// set any additional netty options
if  configuration getoptions      null
for  map entry<string  object> entry   configuration getoptions   entryset
connectionlessclientbootstrap setoption entry getkey    entry getvalue
// set the pipeline factory, which creates the pipeline for each newly created channels
connectionlessclientbootstrap setpipelinefactory pipelinefactory
// bind and store channel so we can close it when stopping
channel channel   connectionlessclientbootstrap bind new inetsocketaddress 0
all_channels add channel
answer   connectionlessclientbootstrap connect new inetsocketaddress configuration gethost    configuration getport
if  log isdebugenabled
log debug
new object configuration gethost    configuration getport    connectionlessclientbootstrap getoptions
return answer
protected channel openchannel channelfuture channelfuture  throws exception
// blocking for channel to be done
if  log istraceenabled
log trace    channelfuture  configuration getconnecttimeout
channelfuture awaituninterruptibly configuration getconnecttimeout
if   channelfuture isdone       channelfuture issuccess
throw new camelexception     configuration getaddress    channelfuture getcause
channel answer   channelfuture getchannel
// to keep track of all channels in use
all_channels add answer
if  log isdebugenabled
log debug    configuration getaddress
return answer
public nettyconfiguration getconfiguration
return configuration
public void setconfiguration nettyconfiguration configuration
this configuration   configuration
public channelfactory getchannelfactory
return channelfactory
public void setchannelfactory channelfactory channelfactory
this channelfactory   channelfactory
public channelgroup getallchannels
return all_channels
/**
* callback that ensures the channel is returned to the pool when we are done.
*/
private final class nettyproducercallback implements asynccallback
private final channel channel
private final asynccallback callback
private nettyproducercallback channel channel  asynccallback callback
this channel   channel
this callback   callback
@override
public void done boolean donesync
// put back in pool
try
log trace    channel
pool returnobject channel
catch  exception e
log warn    channel
finally
// ensure we call the delegated callback
callback done donesync
/**
* object factory to create {@link channel} used by the pool.
*/
private final class nettyproducerpoolableobjectfactory implements poolableobjectfactory<channel>
@override
public channel makeobject   throws exception
channelfuture channelfuture   openconnection
channel answer   openchannel channelfuture
log trace    answer
return answer
@override
public void destroyobject channel channel  throws exception
log trace    channel
nettyhelper close channel
all_channels remove channel
@override
public boolean validateobject channel channel
// we need a connected channel to be valid
boolean answer   channel isconnected
log trace    channel  answer
return answer
@override
public void activateobject channel channel  throws exception
// noop
@override
public void passivateobject channel channel  throws exception
// noop