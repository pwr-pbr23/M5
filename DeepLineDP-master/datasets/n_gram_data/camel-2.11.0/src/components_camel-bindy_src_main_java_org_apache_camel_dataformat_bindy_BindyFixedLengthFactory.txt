/**
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache camel dataformat bindy
import java lang reflect field
import java util arraylist
import java util collection
import java util hashmap
import java util iterator
import java util linkedhashmap
import java util linkedlist
import java util list
import java util map
import java util map entry
import java util treemap
import org apache camel dataformat bindy annotation datafield
import org apache camel dataformat bindy annotation fixedlengthrecord
import org apache camel dataformat bindy annotation link
import org apache camel dataformat bindy format formatexception
import org apache camel spi packagescanclassresolver
import org apache camel spi packagescanfilter
import org slf4j logger
import org slf4j loggerfactory
/**
* the bindycsvfactory is the class who allows to : generate a model associated
* to a fixed length record, bind data from a record to the pojos, export data of pojos
* to a fixed length record and format data into string, date, double, ... according to
* the format/pattern defined
*/
public class bindyfixedlengthfactory extends bindyabstractfactory implements bindyfactory
private static final transient logger log   loggerfactory getlogger bindyfixedlengthfactory class
boolean isonetomany
private map<integer  datafield> datafields   new linkedhashmap<integer  datafield>
private map<integer  field> annotatedfields   new linkedhashmap<integer  field>
private int numberoptionalfields
private int numbermandatoryfields
private int totalfields
private boolean hasheader
private boolean skipheader
private boolean isheader
private boolean hasfooter
private boolean skipfooter
private boolean isfooter
private char paddingchar
private int recordlength
public bindyfixedlengthfactory packagescanclassresolver resolver  string    packagenames  throws exception
super resolver  packagenames
// initialize specific parameters of the fixed length model
initfixedlengthmodel
public bindyfixedlengthfactory packagescanclassresolver resolver  packagescanfilter scanfilter  string    packagenames  throws exception
super resolver  packagenames  scanfilter
initfixedlengthmodel
public bindyfixedlengthfactory packagescanclassresolver resolver  class<?> type  throws exception
super resolver  type
// initialize specific parameters of the fixed length model
initfixedlengthmodel
public bindyfixedlengthfactory packagescanclassresolver resolver  packagescanfilter scanfilter  class<?> type  throws exception
super resolver  type  scanfilter
initfixedlengthmodel
/**
* method uses to initialize the model representing the classes who will
* bind the data. this process will scan for classes according to the
* package name provided, check the annotated classes and fields
*/
public void initfixedlengthmodel   throws exception
// find annotated fields declared in the model classes
initannotatedfields
// initialize fixed length parameter(s)
// from @fixedlengthrecord annotation
initfixedlengthrecordparameters
public void initannotatedfields
for  class<?> cl   models
list<field> linkfields   new arraylist<field>
if  log isdebugenabled
log debug    cl getname
for  field field   cl getdeclaredfields
datafield datafield   field getannotation datafield class
if  datafield    null
if  log isdebugenabled
log debug    new object cl getname    datafield pos    datafield
if  datafield required
numbermandatoryfields
else
numberoptionalfields
datafields put datafield pos    datafield
annotatedfields put datafield pos    field
link linkfield   field getannotation link class
if  linkfield    null
if  log isdebugenabled
log debug    cl getname    field
linkfields add field
if   linkfields isempty
annotatedlinkfields put cl getname    linkfields
totalfields   numbermandatoryfields   numberoptionalfields
if  log isdebugenabled
log debug    numberoptionalfields
log debug    numbermandatoryfields
log debug    totalfields
// will not be used in the case of a fixed length record
// as we provide the content of the record and
// we don't split it as this is the case for a csv record
@override
public void bind list<string> data  map<string  object> model  int line  throws exception
// noop
public void bind string record  map<string  object> model  int line  throws exception
int pos   1
int countermandatoryfields   0
datafield datafield
string token
int offset   1
int length
string delimiter
field field
// iterate through the list of positions
// defined in the @datafield
// and grab the data from the line
collection<datafield> c   datafields values
iterator<datafield> itr   c iterator
// this iterator is for a link list that was built using items in order
while  itr hasnext
datafield   itr next
length   datafield length
delimiter   datafield delimiter
if  length    0    datafield lengthpos      0
field lengthfield   annotatedfields get datafield lengthpos
lengthfield setaccessible true
object modelobj   model get lengthfield getdeclaringclass   getname
object lengthobj     integer  lengthfield get modelobj
length     integer lengthobj  intvalue
if  length < 1    delimiter    null    datafield lengthpos      0
throw new illegalargumentexception     datafield tostring
if  offset   1 <   1
throw new illegalargumentexception     datafield tostring
if  length > 0
token   record substring offset   1  offset   length   1
offset    length
else if   delimiter equals
string temptoken   record substring offset   1  record length
token   temptoken substring 0  temptoken indexof delimiter
// include the delimiter in the offset calculation
offset    token length     1
else
// defined as a zero-length field
token
if  datafield trim
token   token trim
// check mandatory field
if  datafield required
// increment counter of mandatory fields
countermandatoryfields
// check if content of the field is empty
// this is not possible for mandatory fields
if  token equals
throw new illegalargumentexception     pos
line
// get field to be set
field   annotatedfields get datafield pos
field setaccessible true
if  log isdebugenabled
log debug    new object offset  token  field gettype
// create format object to format the field
format<?> format   formatfactory getformat field gettype    getlocale    datafield
// field object to be set
object modelfield   model get field getdeclaringclass   getname
// format the data received
object value   null
if   token equals
try
value   format parse token
catch  formatexception ie
throw new illegalargumentexception ie getmessage         offset       line  ie
catch  exception e
throw new illegalargumentexception     offset       line  e
else
value   getdefaultvalueforprimitive field gettype
field set modelfield  value
pos
// check for unmapped non-whitespace data at the end of the line
if  offset <  record length        record substring offset   1  record length     trim   equals
throw new illegalargumentexception     line
log debug    countermandatoryfields
if  pos < totalfields
throw new illegalargumentexception     line
if  countermandatoryfields < numbermandatoryfields
throw new illegalargumentexception     line
public string unbind map<string  object> model  throws exception
stringbuilder buffer   new stringbuilder
map<integer  list<string>> results   new hashmap<integer  list<string>>
for  class<?> clazz   models
if  model containskey clazz getname
object obj   model get clazz getname
if  log isdebugenabled
log debug    obj  obj getclass   getname
if  obj    null
// generate fixed length table
// containing the positions of the fields
generatefixedlengthpositionmap clazz  obj  results
// convert map<integer, list> into list<list>
treemap<integer  list<string>> sortvalues   new treemap<integer  list<string>> results
for  entry<integer  list<string>> entry   sortvalues entryset
// get list of values
list<string> val   entry getvalue
string value   val get 0
buffer append value
return buffer tostring
/**
*
* generate a table containing the data formatted and sorted with their position/offset
* the result is placed in the map<integer, list> results
*/
private void generatefixedlengthpositionmap class<?> clazz  object obj  map<integer  list<string>> results  throws exception
string result
for  field field   clazz getdeclaredfields
field setaccessible true
datafield datafield   field getannotation datafield class
if  datafield    null
if  obj    null
// retrieve the format, pattern and precision associated to the type
class<?> type   field gettype
// create format
format<?> format   formatfactory getformat type  getlocale    datafield
// get field value
object value   field get obj
result   formatstring format  value
// trim if enabled
if  datafield trim
result   result trim
int fieldlength   datafield length
if  fieldlength    0     datafield lengthpos   > 0
list<string> resultvals   results get datafield lengthpos
fieldlength   integer valueof resultvals get 0
if  fieldlength <  0    datafield delimiter   equals       datafield lengthpos      0
throw new illegalargumentexception
field getname
if   datafield delimiter   equals
result   result   datafield delimiter
else
// get length of the field, alignment (left or right), pad
string align   datafield align
char padcharfield   datafield paddingchar
char padchar
stringbuilder temp   new stringbuilder
// check if we must pad
if  result length   < fieldlength
// no padding defined for the field
if  padcharfield    0
// we use the padding defined for the record
padchar   paddingchar
else
padchar   padcharfield
if  align contains
temp append generatepaddingchars padchar  fieldlength  result length
temp append result
else if  align contains
temp append result
temp append generatepaddingchars padchar  fieldlength  result length
else
throw new illegalargumentexception     field getname
result   temp tostring
else if  result length   > fieldlength
// we are bigger than allowed
// is clipped enabled? if so clip the field
if  datafield clip
result   result substring 0  fieldlength
else
throw new illegalargumentexception     field getname
result length         fieldlength
if  log isdebugenabled
log debug    new object value  datafield pos    result
else
result
integer key
key   datafield pos
if   results containskey key
list<string> list   new linkedlist<string>
list add result
results put key  list
else
list<string> list   results get key
list add result
private string generatepaddingchars char pad  int lengthfield  int lengthstring
stringbuilder buffer   new stringbuilder
int size   lengthfield   lengthstring
for  int i   0  i < size  i
buffer append character tostring pad
return buffer tostring
/**
* get parameters defined in @fixedlengthrecord annotation
*/
private void initfixedlengthrecordparameters
for  class<?> cl   models
// get annotation @fixedlengthrecord from the class
fixedlengthrecord record   cl getannotation fixedlengthrecord class
if  record    null
log debug    record
// get carriage return parameter
crlf   record crlf
log debug    crlf
// get hasheader parameter
hasheader   record hasheader
log debug    hasheader
// get skipheader parameter
skipheader   record skipheader
// get hasfooter parameter
hasfooter   record hasfooter
log debug    hasfooter
// get skipfooter parameter
skipfooter   record skipfooter
// get isheader parameter
isheader   record isheader
// get isfooter parameter
isfooter   record isfooter
// get padding character
paddingchar   record paddingchar
log debug    paddingchar
// get length of the record
recordlength   record length
log debug    recordlength
// get length of the record
recordlength   record length
log debug    recordlength
if  hasheader    isheader
throw new java lang illegalargumentexception
if  hasfooter    isfooter
throw new java lang illegalargumentexception
if   isheader    isfooter      skipheader    skipfooter
throw new java lang illegalargumentexception
/**
* flag indicating if we have a header
*/
public boolean hasheader
return hasheader
/**
* flag indicating if we have a footer
*/
public boolean hasfooter
return hasfooter
/**
* flag indicating whether to skip the header parsing
*/
public boolean skipheader
return skipheader
/**
* flag indicating whether to skip the footer processing
*/
public boolean skipfooter
return skipfooter
/**
* flag indicating whether this factory is for a header
*/
public boolean isheader
return isheader
/**
* flag indicating whether this factory is for a footer
*/
public boolean isfooter
return isfooter
/**
* padding char used to fill the field
*/
public char paddingchar
return paddingchar
/**
*  expected fixed length of the record
*/
public int recordlength
return recordlength