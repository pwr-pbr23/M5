/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket markup repeater
import java util iterator
import org apache wicket markup repeater util modeliteratoradapter
import org apache wicket model imodel
import org apache wicket version undo change
/**
* an abstract repeater view that provides refreshing functionality to its
* subclasses. the view is refreshed every request, making it well suited for
* displaying dynamic data.
* <p>
* the view is populated by implementing {@link refreshingview#getitemmodels() }
* and {@link refreshingview#populateitem(item) } methods. refreshingview builds
* the items that will be rendered by looping over the models retrieved from
* {@link refreshingview#getitemmodels() } and calling the
* {@link refreshingview#newitem(string, int, imodel) } to generate the child
* item container followed by a call to
* {@link refreshingview#populateitem(item) } to let the user populate the newly
* created item container with custom components.
* </p>
* <p>
* the provided {@link modeliteratoradapter} can make implementing
* {@link refreshingview#getitemmodels() } easier if you have an iterator over
* item objects.
* </p>
*
* @see repeatingview
* @see modeliteratoradapter
*
* @author igor vaynberg (ivaynberg)
*
*/
public abstract class refreshingview extends repeatingview
private static final long serialversionuid   1l
/**
* the item reuse strategy that will be used to recycle items when the page
* is changed or the view is redrawn.
*
* @see iitemreusestrategy
*/
private iitemreusestrategy itemreusestrategy
/**
* constructor
*
* @param id
*            component id
*/
public refreshingview string id
super id
/**
* constructor
*
* @param id
*            component id
* @param model
*            model
*/
public refreshingview string id  imodel model
super id  model
/**
* refresh the items in the view. delegates the creation of items to the
* selected item reuse strategy
*/
protected void onbeforerender
super onbeforerender
if  isvisibleinhierarchy
iitemfactory itemfactory   new iitemfactory
public item newitem int index  imodel model
string id   refreshingview this newchildid
item item   refreshingview this newitem id  index  model
refreshingview this populateitem item
return item
iterator models   getitemmodels
iterator items   getitemreusestrategy   getitems itemfactory  models  getitems
removeall
additems items
/**
* returns an iterator over models for items that will be added to this view
*
* @return an iterator over models for items that will be added to this view
*/
protected abstract iterator getitemmodels
/**
* populate the given item container.
* <p>
* <b>be carefull</b> to add any components to the item and not the view
* itself. so, don't do:
*
* <pre>
* add(new label(&quot;foo&quot;, &quot;bar&quot;));
* </pre>
*
* but:
*
* <pre>
* item.add(new label(&quot;foo&quot;, &quot;bar&quot;));
* </pre>
*
* </p>
*
* @param item
*            the item to populate
*/
protected abstract void populateitem final item item
/**
* factory method for item container. item containers are simple
* markupcontainer used to aggregate the user added components for a row
* inside the view.
*
* @see item
* @param id
*            component id for the new data item
* @param index
*            the index of the new data item
* @param model
*            the model for the new data item
*
* @return dataitem created dataitem
*/
protected item newitem final string id  int index  final imodel model
return new item id  index  model
/**
* @return iterator over item instances that exist as children of this view
*/
public iterator getitems
return iterator
/**
* add items to the view. prior to this all items were removed so every
* request this function starts from a clean slate.
*
* @param items
*            item instances to be added to this view
*/
protected void additems iterator items
while  items hasnext
add  item items next
// /////////////////////////////////////////////////////////////////////////
// item generation
// /////////////////////////////////////////////////////////////////////////
/**
* @return currently set item reuse strategy. defaults to
*         <code>defaultitemreusestrategy</code> if none was set.
*
* @see defaultitemreusestrategy
*/
public iitemreusestrategy getitemreusestrategy
if  itemreusestrategy    null
return defaultitemreusestrategy getinstance
return itemreusestrategy
/**
* sets the item reuse strategy. this strategy controls the creation of
* {@link item}s.
*
* @see iitemreusestrategy
*
* @param strategy
*            item reuse strategy
* @return this for chaining
*/
public refreshingview setitemreusestrategy iitemreusestrategy strategy
if  strategy    null
throw new illegalargumentexception
if   strategy equals itemreusestrategy
if  isversioned
addstatechange new change
private static final long serialversionuid   1l
private final iitemreusestrategy old   itemreusestrategy
public void undo
itemreusestrategy   old
public string tostring
return     getpath
old
itemreusestrategy   strategy
return this