/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket markup html tree
import java io serializable
import java util arraylist
import java util collections
import java util enumeration
import java util hashmap
import java util iterator
import java util list
import java util map
import javax swing event treemodelevent
import javax swing event treemodellistener
import javax swing tree treemodel
import javax swing tree treenode
import org apache wicket component
import org apache wicket resourcereference
import org apache wicket ajax ajaxrequesttarget
import org apache wicket behavior headercontributor
import org apache wicket markup markupstream
import org apache wicket markup html webmarkupcontainer
import org apache wicket markup html internal htmlheadercontainer
import org apache wicket markup html panel panel
import org apache wicket markup html resources javascriptresourcereference
import org apache wicket model idetachable
import org apache wicket model imodel
import org apache wicket model model
import org apache wicket util string appendingstringbuffer
/**
* this class encapsulates the logic for displaying and (partial) updating the
* tree. actual presentation is out of scope of this class. user should derive
* they own tree (if needed) from {@link defaultabstracttree} or {@link tree}
* (recommended).
*
* @author matej knopp
*/
public abstract class abstracttree extends panel implements itreestatelistener  treemodellistener
/**
* interface for visiting individual tree items.
*/
private static interface iitemcallback
/**
* visits the tree item.
*
* @param item
*            the item to visit
*/
void visititem treeitem item
/**
* this class represents one row in rendered tree (treenode). only treenodes
* that are visible (all their parent are expanded) have treeitem created
* for them.
*/
private final class treeitem extends webmarkupcontainer
/**
* whether this tree item should also render it's children to response.
* this is set if we need the whole subtree rendered as one component in
* ajax response, so that we can replace it in one step (replacing
* individual rows is very slow in javascript, therefore we replace the
* whole subtree)
*/
private final static int flag_render_children   flag_reserved8
private static final long serialversionuid   1l
/**
* tree item children - we need this to traverse items in correct order
* when rendering
*/
private list children   null
/** tree item level - how deep is this item in tree */
private int level
/**
* construct.
*
* @param id
*            the component id
* @param node
*            tree node
* @param level
*            current level
*/
public treeitem string id  final treenode node  int level
super id  new model  serializable node
nodetoitemmap put node  this
this level   level
setoutputmarkupid true
// if this isn't a root item in rootless mode
if  level     1
populatetreeitem this  level
/**
* @return the children
*/
public list getchildren
return children
/**
* @return the current level
*/
public int getlevel
return level
/**
* @see org.apache.wicket.component#getmarkupid()
*/
public string getmarkupid
// this is overriden to produce id that begins with id of tree
// if the tree has set (shorter) id in markup, we can use it to
// shorten the id of individual treeitems
return abstracttree this getmarkupid         getid
/**
* @return parent item
*/
public treeitem getparentitem
return  treeitem nodetoitemmap get   treenode getmodelobject    getparent
/**
* sets the children.
*
* @param children
*            the children
*/
public void setchildren list children
this children   children
/**
* whether to render children.
*
* @return whether to render children
*/
protected final boolean isrenderchildren
return getflag flag_render_children
/**
* @see org.apache.wicket.markupcontainer#onrender(org.apache.wicket.markup.markupstream)
*/
protected void onrender final markupstream markupstream
// is this root and tree is in rootless mode?
if  this    rootitem    isrootless      true
// yes, write empty div with id
// this is necesary for createelement js to work correctly
getresponse   write
display none
markupstream skipcomponent
else
// remember current index
final int index   markupstream getcurrentindex
// render the item
super onrender markupstream
// should we also render children (ajax response)
if  isrenderchildren
// visit every child
visititemchildren this  new iitemcallback
public void visititem treeitem item
// rewind markupstream
markupstream setcurrentindex index
// render child
item onrender markupstream
//
public void renderhead final htmlheadercontainer container
super renderhead container
if  isrenderchildren
// visit every child
visititemchildren this  new iitemcallback
public void visititem treeitem item
// write header contributions from the children of item
item visitchildren new component ivisitor
public object component component component
if  component isvisible
component renderhead container
return continue_traversal
else
return continue_traversal_but_dont_go_deeper
protected final void setrenderchildren boolean value
setflag flag_render_children  value
protected void onattach
super onattach
if  isrenderchildren
// visit every child
visititemchildren this  new iitemcallback
public void visititem treeitem item
item attach
protected void ondetach
super ondetach
object object   getmodelobject
if  object instanceof idetachable
idetachable object  detach
if  isrenderchildren
// visit every child
visititemchildren this  new iitemcallback
public void visititem treeitem item
item detach
//children are rendered, clear the flag
setrenderchildren false
protected void onbeforerender
abstracttree this onbeforerender
super onbeforerender
if  isrenderchildren
// visit every child
visititemchildren this  new iitemcallback
public void visititem treeitem item
item beforerender
protected void onafterrender
super onafterrender
if  isrenderchildren
// visit every child
visititemchildren this  new iitemcallback
public void visititem treeitem item
item afterrender
/**
* components that holds tree items. this is similiar to listview, but it
* renders tree items in the right order.
*/
private class treeitemcontainer extends webmarkupcontainer
private static final long serialversionuid   1l
/**
* construct.
*
* @param id
*            the component id
*/
public treeitemcontainer string id
super id
/**
* @see org.apache.wicket.markupcontainer#remove(org.apache.wicket.component)
*/
public void remove component component
// when a treeitem is removed, remove reference to it from
// nodetoitemmap
if  component instanceof treeitem
nodetoitemmap remove   treeitem component  getmodelobject
super remove component
/**
* renders the tree items, making sure that items are rendered in the
* order they should be
*
* @param markupstream
*/
protected void onrender final markupstream markupstream
// save position in markup stream
final int markupstart   markupstream getcurrentindex
// have we rendered at least one item?
final class rendered
boolean rendered   false
final rendered rendered   new rendered
// is there a root item? (non-empty tree)
if  rootitem    null
iitemcallback callback   new iitemcallback
public void visititem treeitem item
// rewind markup stream
markupstream setcurrentindex markupstart
// render component
item render markupstream
rendered rendered   true
// visit item and it's children
visititemandchildren rootitem  callback
if  rendered rendered    false
// tree is empty, just move the markupstream
markupstream skipcomponent
/**
* returns an iterator that iterates trough the enumeration.
*
* @param enumeration
*            the enumeration to iterate through
* @return the iterator
*/
private static final iterator toiterator final enumeration enumeration
return new iterator
private enumeration e   enumeration
public boolean hasnext
return e hasmoreelements
public object next
return e nextelement
public void remove
throw new unsupportedoperationexception
private boolean attached   false
/** comma separated list of ids of elements to be deleted. */
private final appendingstringbuffer deleteids   new appendingstringbuffer
/**
* whether the whole tree is dirty (so the whole tree needs to be
* refreshed).
*/
private boolean dirtyall   false
/**
* list of dirty items. if children property of these items is null, the
* chilren will be rebuild.
*/
private final list dirtyitems   new arraylist
/**
* list of dirty items which need the dom structure to be created for them
* (added items)
*/
private final list dirtyitemscreatedom   new arraylist
/** counter for generating unique ids of every tree item. */
private int idcounter   0
/** component whose children are tree items. */
private treeitemcontainer itemcontainer
/**
* map that maps treenode to treeitem. treeitems only exists for treenodes,
* that are visibled (their parents are not collapsed).
*/
private final map nodetoitemmap   new hashmap
/**
* we need to track previous model. if the model changes, we unregister the
* tree from listeners of old model and register the tree as litener of new
* model.
*/
private treemodel previousmodel   null
/** root item of the tree. */
private treeitem rootitem   null
/** whether the tree root is shown. */
private boolean rootless   false
/** stores reference to tree state. */
private itreestate state
/**
* tree constructor
*
* @param id
*            the component id
*/
public abstracttree string id
super id
init
/**
* tree constructor
*
* @param id
*            the component id
* @param model
*            the tree model
*/
public abstracttree string id  imodel model
super id  model
init
/** called when all nodes are collapsed. */
public final void allnodescollapsed
invalidateall
/** called when all nodes are expaned. */
public final void allnodesexpanded
invalidateall
/**
* returns the treestate of this tree.
*
* @return tree state instance
*/
public itreestate gettreestate
if  state    null
state   newtreestate
// add this object as listener of the state
state addtreestatelistener this
// fixme: where should we remove the listener?
return state
/**
* this method is called before the onattach is called. code here gets
* executed before the items have been populated.
*/
protected void onbeforeattach
/**
* called at the beginning of the request (not ajax request, unless we are
* rendering the entire component)
*/
public void onbeforerender
super onbeforerender
if  attached    false
onbeforeattach
checkmodel
// do we have to rebuld the whole tree?
if  dirtyall    rootitem    null
clearallitem
else
// rebuild chilren of dirty nodes that need it
rebuilddirty
// is root item created? (root item is null if the items have not
// been created yet, or the whole tree was dirty and clearallitem
// has been called
if  rootitem    null
treenode rootnode    treenode   treemodel getmodelobject    getroot
if  rootnode    null
if  isrootless
rootitem   newtreeitem rootnode   1
else
rootitem   newtreeitem rootnode  0
itemcontainer add rootitem
builditemchildren rootitem
attached   true
/**
* @see org.apache.wicket.markupcontainer#ondetach()
*/
public void ondetach
attached   false
updatetreecalled   false
super ondetach
/**
* call to refresh the whole tree. this should only be called when the
* roodnode has been replaced or the entiry tree model changed.
*/
public final void invalidateall
updated
this dirtyall   true
/**
* @return whether the tree root is shown
*/
public final boolean isrootless
return rootless
/**
* @see org.apache.wicket.markup.html.tree.itreestatelistener#nodecollapsed(javax.swing.tree.treenode)
*/
public final void nodecollapsed treenode node
if  isnodevisible node     true
invalidatenodewithchildren node
/**
* @see org.apache.wicket.markup.html.tree.itreestatelistener#nodeexpanded(javax.swing.tree.treenode)
*/
public final void nodeexpanded treenode node
if  isnodevisible node     true
invalidatenodewithchildren node
/**
* @see org.apache.wicket.markup.html.tree.itreestatelistener#nodeselected(javax.swing.tree.treenode)
*/
public final void nodeselected treenode node
if  isnodevisible node
invalidatenode node  isforcerebuildonselectionchange
/**
* @see org.apache.wicket.markup.html.tree.itreestatelistener#nodeunselected(javax.swing.tree.treenode)
*/
public final void nodeunselected treenode node
if  isnodevisible node
invalidatenode node  isforcerebuildonselectionchange
/**
* determines whether the treenode needs to be rebuilt if it is selected
* or deselected
* @return true if the node should be rebuilt after (de)selection, false otherwise
*/
protected boolean isforcerebuildonselectionchange
return true
/**
* sets whether the root of the tree should be visible.
*
* @param rootless
*            whether the root should be visible
*/
public void setrootless boolean rootless
if  this rootless    rootless
this rootless   rootless
invalidateall
// if the tree is in rootless mode, make sure the root node is
// expanded
if  rootless    true    getmodelobject      null
gettreestate   expandnode  treenode   treemodel getmodelobject    getroot
/**
* @see javax.swing.event.treemodellistener#treenodeschanged(javax.swing.event.treemodelevent)
*/
public final void treenodeschanged treemodelevent e
// has root node changed?
if  e getchildren      null
if  rootitem    null
invalidatenode  treenode rootitem getmodelobject    true
else
// go through all changed nodes
object children   e getchildren
if  children    null
for  int i   0  i < children length  i
treenode node    treenode children
if  isnodevisible node
// if the nodes is visible invalidate it
invalidatenode node  true
/**
* marks the last but one visible child node of the given item as dirty, if
* give child is the last item of parent.
*
* we need this to refresh the previous visible item in case the inserted /
* deleteditem was last. the reason is that the line shape of previous item
* chages from l to |- .
*
* @param parent
* @param child
*/
private void markthelastbutonechilddirty treeitem parent  treeitem child
if  parent getchildren   indexof child     parent getchildren   size     1
// go through the childrend backwards, start at the last but one
// item
for  int i   parent getchildren   size     2  i >  0    i
treeitem item    treeitem parent getchildren   get i
// invalidate the node and it's children, so that they are
// redrawn
invalidatenodewithchildren  treenode item getmodelobject
/**
* @see javax.swing.event.treemodellistener#treenodesinserted(javax.swing.event.treemodelevent)
*/
public final void treenodesinserted treemodelevent e
// get the parent node of inserted nodes
treenode parent    treenode e gettreepath   getlastpathcomponent
if  isnodevisible parent     isnodeexpanded parent
treeitem parentitem    treeitem nodetoitemmap get parent
for  int i   0  i < e getchildren   length    i
treenode node    treenode e getchildren
int index   e getchildindices
treeitem item   newtreeitem node  parentitem getlevel     1
itemcontainer add item
parentitem getchildren   add index  item
markthelastbutonechilddirty parentitem  item
dirtyitems add item
dirtyitemscreatedom add item
/**
* @see javax.swing.event.treemodellistener#treenodesremoved(javax.swing.event.treemodelevent)
*/
public final void treenodesremoved treemodelevent e
// get the parent node of inserted nodes
treenode parent    treenode e gettreepath   getlastpathcomponent
treeitem parentitem    treeitem nodetoitemmap get parent
if  isnodevisible parent     isnodeexpanded parent
for  int i   0  i < e getchildren   length    i
treenode node    treenode e getchildren
treeitem item    treeitem nodetoitemmap get node
if  item    null
markthelastbutonechilddirty parentitem  item
parentitem getchildren   remove item
// go though item children and remove every one of them
visititemchildren item  new iitemcallback
public void visititem treeitem item
removeitem item
// unselect the node
gettreestate   selectnode  treenode item getmodelobject    false
removeitem item
/**
* @see javax.swing.event.treemodellistener#treestructurechanged(javax.swing.event.treemodelevent)
*/
public final void treestructurechanged treemodelevent e
// get the parent node of changed nodes
treenode node    treenode e gettreepath   getlastpathcomponent
// has the tree root changed?
if  e gettreepath   getpathcount      1    node equals rootitem getmodelobject
invalidateall
else
invalidatenodewithchildren node
private transient boolean updatetreecalled   false
/**
* updates the changed portions of the tree using given ajaxrequesttarget.
* call this method if you modified the tree model during an ajax request
* target and you want to partially update the component on page. make sure
* that the tree model has fired the proper listener functions.
* <p>
* <b>you can only call this method once in a request.</b>
*
* @param target
*            ajax request target used to send the update to the page
*/
public final void updatetree final ajaxrequesttarget target
if  target    null
return
updatetreecalled   true
// check whether the model hasn't changed
checkmodel
// is the whole tree dirty
if  dirtyall
// render entire tree component
target addcomponent this
else
// remove dom elements that need to be removed
if  deleteids length      0
string js   getelementsdeletejavascript
// add the javascript to target
target prependjavascript js
// we have to repeat this as long as there are any dirty items to be
// created.
// the reason why we can't do this in one pass is that some of the
// items
// may need to be inserted after items that has not been inserted
// yet, so we have
// to detect those and wait until the items they depend on are
// inserted.
while  dirtyitemscreatedom isempty      false
for  iterator i   dirtyitemscreatedom iterator    i hasnext
treeitem item    treeitem i next
treeitem parent   item getparentitem
int index   parent getchildren   indexof item
treeitem previous
// we need item before this (in dom structure)
if  index    0
previous   parent
else
previous    treeitem parent getchildren   get index   1
// get the last item of previous item subtree
while  previous getchildren      null    previous getchildren   size   > 0
previous    treeitem previous getchildren   get
previous getchildren   size     1
// check if the previous item isn't waiting to be inserted
if  dirtyitemscreatedom contains previous     false
// it's already in dom, so we can use it as point of
// insertion
target prependjavascript  "
item getmarkupid             previous getmarkupid
"
// remove the item so we don't process it again
i remove
else
// we don't do anything here, inserting this item will
// have to wait
// until the previous item gets inserted
// iterate through dirty items
for  iterator i   dirtyitems iterator    i hasnext
treeitem item    treeitem i next
// does the item need to rebuild children?
if  item getchildren      null
// rebuld the children
builditemchildren item
// set flag on item so that it renders itself together with
// it's children
item setrenderchildren true
// add the component to target
target addcomponent item
// clear dirty flags
updated
/**
* returns whether the given node is expanded.
*
* @param node
*            the node to inspect
* @return true if the node is expanded, false otherwise
*/
protected final boolean isnodeexpanded treenode node
// in root less mode the root node is always expanded
if  isrootless      rootitem    null    rootitem getmodelobject   equals node
return true
return gettreestate   isnodeexpanded node
/**
* creates the treestate, which is an object where the current state of tree
* (which nodes are expanded / collapsed, selected, ...) is stored.
*
* @return tree state instance
*/
protected itreestate newtreestate
return new defaulttreestate
/**
* called after the rendering of tree is complete. here we clear the dirty
* flags.
*/
protected void onafterrender
super onafterrender
// rendering is complete, clear all dirty flags and items
updated
/**
* this method is called after creating every treeitem. this is the place
* for adding components on item (junction links, labels, icons...)
*
* @param item
*            newly created tree item. the node can be obtained as
*            item.getmodelobject()
*
* @param level
*            how deep the component is in tree hierarchy (0 for root item)
*/
protected abstract void populatetreeitem webmarkupcontainer item  int level
/**
* builds the children for given treeitem. it recursively traverses children
* of it's treenode and creates treeitem for every visible treenode.
*
* @param item
*            the parent tree item
*/
private final void builditemchildren treeitem item
list items
// if the node is expanded
if  isnodeexpanded  treenode item getmodelobject
// build the items for children of the items' treenode.
items   buildtreeitems nodechildren  treenode item getmodelobject
item getlevel     1
else
// it's not expanded, just set children to an empty list
items   collections empty_list
item setchildren items
/**
* builds (recursively) treeitems for the given iterator of treenodes.
*
* @param nodes
*            the nodes to build tree items for
* @param level
*            the current level
* @return list with new tree items
*/
private final list buildtreeitems iterator nodes  int level
list result   new arraylist
// for each node
while  nodes hasnext
treenode node    treenode nodes next
// create tree item
treeitem item   newtreeitem node  level
itemcontainer add item
// builds it children (recursively)
builditemchildren item
// add item to result
result add item
return result
/**
* checks whether the model has been chaned, and if so unregister and
* register listeners.
*/
private final void checkmodel
// find out whether the model object (the treemodel) has been changed
treemodel model    treemodel getmodelobject
if  model    previousmodel
if  previousmodel    null
previousmodel removetreemodellistener this
previousmodel   model
if  model    null
model addtreemodellistener this
// model has been changed, redraw whole tree
invalidateall
/**
* removes all treeitem components.
*/
private final void clearallitem
visititemandchildren rootitem  new iitemcallback
public void visititem treeitem item
item remove
rootitem   null
/**
* returns the javascript used to delete removed elements.
*
* @return the javascript
*/
private string getelementsdeletejavascript
// build the javascript call
final appendingstringbuffer buffer   new appendingstringbuffer 100
buffer append  "
// first parameter is the markup id of tree (will be used as prefix to
// build ids of child items
buffer append getmarkupid       ["
// append the ids of elements to be deleted
buffer append deleteids
// does the buffer end if ','?
if  buffer endswith
// it does, trim it
buffer setlength buffer length     1
buffer append
return buffer tostring
//
// state and model callbacks
//
/**
* returns the short version of item id (just the number part).
*
* @param item
*            the tree item
* @return the id
*/
private string getshortitemid treeitem item
// show much of component id can we skip? (to minimize the length of
// javascript being sent)
final int skip   getmarkupid   length     1     the length of id of
// tree and '_'.
return item getmarkupid   substring skip
private final static resourcereference javascript   new javascriptresourcereference
abstracttree class
/**
* initialize the component.
*/
private final void init
setversioned false
// we need id when we are replacing the whole tree
setoutputmarkupid true
// create container for tree items
itemcontainer   new treeitemcontainer
add itemcontainer
add headercontributor forjavascript javascript
/**
* invalidates single node (without children). on the next render, this node
* will be updated. node will not be rebuilt, unless forcerebuild is true.
*
* @param node
*            the node to invalidate
* @param forcerebuild
*/
private final void invalidatenode treenode node  boolean forcerebuild
if  dirtyall    false
// get item for this node
treeitem item    treeitem nodetoitemmap get node
if  item    null
boolean createdom   false
if  forcerebuild
// recreate the item
int level   item getlevel
list children   item getchildren
string id   item getid
// store the parent of old item
treeitem parent   item getparentitem
// if the old item has a parent, store it's index
int index   parent    null ? parent getchildren   indexof item     1
createdom   dirtyitemscreatedom contains item
dirtyitems remove item
dirtyitemscreatedom remove item
item remove
item   newtreeitem node  level  id
itemcontainer add item
item setchildren children
// was the item an root item?
if  parent    null
rootitem   item
else
parent getchildren   set index  item
dirtyitems add item
if  createdom
dirtyitemscreatedom add item
/**
* invalidates node and it's children. on the next render, the node and
* children will be updated. node children will be rebuilt.
*
* @param node
*            the node to invalidate
*/
private final void invalidatenodewithchildren treenode node
if  dirtyall    false
// get item for this node
treeitem item    treeitem nodetoitemmap get node
// is the item visible?
if  item    null
// go though item children and remove every one of them
visititemchildren item  new iitemcallback
public void visititem treeitem item
removeitem item
// set children to null so that they get rebuild
item setchildren null
// add item to dirty items
dirtyitems add item
/**
* returns whether the given node is visibled, e.g. all it's parents are
* expanded.
*
* @param node
*            the node to inspect
* @return true if the node is visible, false otherwise
*/
private final boolean isnodevisible treenode node
while  node getparent      null
if  isnodeexpanded node getparent       false
return false
node   node getparent
return true
/**
* creates a tree item for given node.
*
* @param node
*            the tree node
* @param level
*            the level
* @return the new tree item
*/
private final treeitem newtreeitem treenode node  int level
return new treeitem     idcounter    node  level
/**
* creates a tree item for given node with specified id.
*
* @param node
*            the tree node
* @param level
*            the level
* @param id
*            the component id
* @return the new tree item
*/
private final treeitem newtreeitem treenode node  int level  string id
return new treeitem id  node  level
/**
* return the representation of node children as iterator interface.
*
* @param node
*            the tree node
* @return iterable presentation of node children
*/
private final iterator nodechildren treenode node
return toiterator node children
/**
* rebuilds children of every item in dirtyitems that needs it. this method
* is called for non-partial update.
*/
private final void rebuilddirty
// go through dirty items
for  iterator i   dirtyitems iterator    i hasnext
treeitem item    treeitem i next
// item chilren need to be rebuilt
if  item getchildren      null
builditemchildren item
/**
* removes the item, appends it's id to deleteids. this is called when a
* items parent is being deleted or rebuilt.
*
* @param item
*            the item to remove
*/
private void removeitem treeitem item
// even if the item is dirty it's no longer necessary to update id
dirtyitems remove item
// if the item was about to be created
if  dirtyitemscreatedom contains item
// we needed to create dom element, we no longer do
dirtyitemscreatedom remove item
else
// add items id (it's short version) to ids of dom elements that
// will be
// removed
deleteids append getshortitemid item
deleteids append
// remove the id
// note that this doesn't update item's parent's children list
item remove
/**
* calls after the tree has been rendered. clears all dirty flags.
*/
private final void updated
this dirtyall   false
this dirtyitems clear
this dirtyitemscreatedom clear
deleteids clear       fixme  recreate it to save some space?
/**
* call the callback#visititem method for the given item and all it's
* chilren.
*
* @param item
*            the tree item
* @param callback
*            item call back
*/
private final void visititemandchildren treeitem item  iitemcallback callback
callback visititem item
visititemchildren item  callback
/**
* call the callback#visititem method for every child of given item.
*
* @param item
*            the tree item
* @param callback
*            the callback
*/
private final void visititemchildren treeitem item  iitemcallback callback
if  item getchildren      null
for  iterator i   item getchildren   iterator    i hasnext
treeitem child    treeitem i next
visititemandchildren child  callback
/**
* returns the component associated with given node, or null, if node is not
* visible. this is useful in situations when you want to touch the node
* element in html.
*
* @param node
*            tree node
* @return component associated with given node, or null if node is not
*         visible.
*/
public component getnodecomponent treenode node
return  component nodetoitemmap get node