/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket
import java util arraylist
import java util arrays
import java util collections
import java util comparator
import java util iterator
import java util list
import org apache wicket markup componenttag
import org apache wicket markup markupelement
import org apache wicket markup markupexception
import org apache wicket markup markupnotfoundexception
import org apache wicket markup markupstream
import org apache wicket markup wickettag
import org apache wicket markup resolver icomponentresolver
import org apache wicket model icomponentinheritedmodel
import org apache wicket model imodel
import org apache wicket model iwrapmodel
import org apache wicket settings idebugsettings
import org apache wicket util resource iresourcestream
import org apache wicket util string strings
import org apache wicket version undo change
import org slf4j logger
import org slf4j loggerfactory
/**
* a markupcontainer holds a map of child components.
* <ul>
* <li><b>children </b>- children can be added by calling the add() method, and
* they can be looked up using a dotted path. for example, if a container called
* "a" held a nested container "b" which held a nested component "c", then
* a.get("b.c") would return the component with id "c". the number of children
* in a markupcontainer can be determined by calling size(), and the whole
* hierarchy of children held by a markupcontainer can be traversed by calling
* visitchildren(), passing in an implementation of component.ivisitor.
*
* <li><b>markup rendering </b>- a markupcontainer also holds/references
* associated markup which is used to render the container. as the markup stream
* for a container is rendered, component references in the markup are resolved
* by using the container to look up components in the container's component map
* by id. each component referenced by the markup stream is given an opportunity
* to render itself using the markup stream.
* <p>
* components may alter their referring tag, replace the tag's body or insert
* markup after the tag. but components cannot remove tags from the markup
* stream. this is an important guarantee because graphic designers may be
* setting attributes on component tags that affect visual presentation.
* <p>
* the type of markup held in a given container subclass can be determined by
* calling getmarkuptype(). markup is accessed via a markupstream object which
* allows a component to traverse componenttag and rawmarkup markupelements
* while rendering a response. markup in the stream may be html or some other
* kind of markup, such as vxml, as determined by the specific container
* subclass.
* <p>
* a markup stream may be directly associated with a container via
* setmarkupstream. however, a container which does not have a markup stream
* (its getmarkupstream() returns null) may inherit a markup stream from a
* container above it in the component hierarchy. the findmarkupstream() method
* will locate the first container at or above this container which has a markup
* stream.
* <p>
* all page containers set a markup stream before rendering by calling the
* method getassociatedmarkupstream() to load the markup associated with the
* page. since page is at the top of the container hierarchy, it is guaranteed
* that findmarkupstream will always return a valid markup stream.
*
* @see markupstream
* @author jonathan locke
*/
public abstract class markupcontainer extends component
private static final long serialversionuid   1l
/** log for reporting. */
private static final logger log   loggerfactory getlogger markupcontainer class
/** list of children or single child */
private object children
/**
* the markup stream for this container. this variable is used only during
* the render phase to provide access to the current element within the
* stream.
*/
private transient markupstream markupstream
/**
* @see org.apache.wicket.component#component(string)
*/
public markupcontainer final string id
super id
/**
* @see org.apache.wicket.component#component(string, imodel)
*/
public markupcontainer final string id  imodel model
super id  model
/**
* adds a child component to this container.
* <p>
* be careful when overriding this method, if not implemented properly it
* may lead to a java component hierarchy which no longer matches the
* template hierarchy, which in turn will lead to an error.
*
* @param child
*            the child
* @throws illegalargumentexception
*             thrown if a child with the same id is replaced by the add
*             operation.
* @return this
*/
public final markupcontainer add final component child
checkhierarchychange child
if  child    null
throw new illegalargumentexception
if  log isdebugenabled
log debug     child getid         this
// add to map
addedcomponent child
if  put child     null
throw new illegalargumentexception exceptionmessage     child getid
return this
/**
* replaces a child component of this container with another or just adds it
* in case no child with the same id existed yet.
*
* @param child
*            the child
* @return this
*/
public final markupcontainer addorreplace final component child
checkhierarchychange child
if  child    null
throw new illegalargumentexception
if  get child getid       null
add child
else
replace child
return this
/**
* this method allows a component to be added by an auto-resolver such as
* autocomponentresolver or autolinkresolver. while the component is being
* added, the component's flag_auto boolean is set. the isauto() method of
* component returns true if a component or any of its parents has this bit
* set. when a component is added via autoadd(), the logic in page that
* normally (a) checks for modifications during the rendering process, and
* (b) versions components, is bypassed if component.isauto() returns true.
* <p>
* the result of all this is that components added with autoadd() are free
* from versioning and can add their own children without the usual
* exception that would normally be thrown when the component hierarchy is
* modified during rendering.
*
* @param component
*            the component to add
* @return true, if component has been added
*/
public final boolean autoadd final component component
if  component    null
throw new illegalargumentexception
/* replace strategy */
component setauto true
if  get component getid       null
this remove component
add component
component beforerender
component render
return true
/**
* @param component
*            the component to check
* @param recurse
*            true if all descendents should be considered
* @return true if the component is contained in this container
*/
public final boolean contains final component component  final boolean recurse
if  component    null
throw new illegalargumentexception
if  recurse
// start at component and continue while we're not out of parents
for  component current   component  current    null
// get parent
final markupcontainer parent   current getparent
// if this container is the parent, then the component is
// recursively contained by this container
if  parent    this
// found it!
return true
// move up the chain to the next parent
current   parent
// failed to find this container in component's ancestry
return false
else
// is the component contained in this container?
return component getparent      this
/**
* get a child component by looking it up with the given path.
*
* @param path
*            path to component
* @return the component at the path
*/
public final component get final string path
// reference to this container
if  path    null    path trim   equals
return this
// get child's id, if any
final string id   strings firstpathcomponent path  component path_separator
// get child by id
component child   children_get id
// if the container is transparent, than ask its parent.
// parentresolver does something quite similar, but because of <head>,
// <body>, <wicket:panel> etc. it is quite common to have transparent
// components. hence, this is little short cut for a tiny performance
// optimization.
if   child    null     istransparentresolver       getparent      null
// special tags like "_body", "_panel" must implement
// icomponentresolver
// if they want to be transparent.
if  path startswith       false
child   getparent   get path
// found child?
if  child    null
final string path2   strings afterfirstpathcomponent path  component path_separator
// recurse on latter part of path
return child get path2
return child
/**
* gets a fresh markup stream that contains the (immutable) markup resource
* for this class.
*
* @param throwexception
*            if true, throw an exception, if markup could not be found
* @return a stream of markupelement elements
*/
public final markupstream getassociatedmarkupstream final boolean throwexception
try
return getapplication   getmarkupsettings   getmarkupcache   getmarkupstream this  false  throwexception
catch  markupexception ex
// re-throw it. the exception contains already all the information
// required.
throw ex
catch  wicketruntimeexception ex
// throw exception since there is no associated markup
throw new markupnotfoundexception
exceptionmessage
getmarkuptype
getclass   getname
ex
/**
* get the markup stream set on this container.
*
* @return returns the markup stream set on this container.
*/
public final markupstream getmarkupstream
return markupstream
/**
* get the type of associated markup for this component.
*
* @return the type of associated markup for this component (for example,
*         "html", "wml" or "vxml"). the markup type for a component is
*         independent of whether or not the component actually has an
*         associated markup resource file (which is determined at runtime).
*         if there is no markup type for a component, null may be returned,
*         but this means that no markup can be loaded for the class.
*/
public string getmarkuptype
throw new illegalstateexception
exceptionmessage
/**
* this method is not part of the wicket public api. do not use it.
*
* adds a child component to this container.
*
* @param child
*            the child
* @throws illegalargumentexception
*             thrown if a child with the same id is replaced by the add
*             operation.
*/
public void internaladd final component child
if  log isdebugenabled
log debug     child getid         this
// add to map
addedcomponent child
put child
/**
* some markupcontainers (e.g. htmlheadercontainer, bodyonloadcontainer)
* have to be transparent with respect to there child components. a
* transparent container gets its children from its parent container.
* <p>
*
* @see org.apache.wicket.markup.resolver.parentresolver
*
* @return false. by default a markupcontainer is not transparent.
*/
public boolean istransparentresolver
return false
/**
* @return iterator that iterates through children in the order they were
*         added
*/
public final iterator iterator
return new iterator
int index   0
public boolean hasnext
return index < children_size
public object next
return children_get index
public void remove
final component removed   children_remove   index
checkhierarchychange removed
removedcomponent removed
/**
* @param comparator
*            the comparator
* @return iterator that iterates over children in the order specified by
*         comparator
*/
public final iterator iterator comparator comparator
final list sorted
if  children    null
sorted   collections empty_list
else
if  children instanceof component
sorted   new arraylist 1
sorted add children
else
sorted   arrays aslist  component children
collections sort sorted  comparator
return sorted iterator
/**
* not used anymore; it's here for helping people migrate from wicket 1.2 to
* wicket 1.3
*
* @param containerclass
* @return nothing
* @throws always
*             throws an {@link illegalstateexception}
*/
// todo remove after release 1.3.0
public final iresourcestream newmarkupresourcestream class containerclass
throw new illegalstateexception
/**
* @param component
*            component to remove from this container
*/
public void remove final component component
checkhierarchychange component
if  component    null
throw new illegalargumentexception
children_remove component
removedcomponent component
/**
* removes the given component
*
* @param id
*            the id of the component to remove
*/
public final void remove final string id
if  id    null
throw new illegalargumentexception
final component component   get id
if  component    null
remove component
else
throw new wicketruntimeexception     id
/**
* removes all children from this container.
* <p>
* note: implementation does not call
* {@link markupcontainer#remove(component) } for each component.
*/
public final void removeall
if  children    null
addstatechange new change
private static final long serialversionuid   1l
final object removedchildren   markupcontainer this children
public string tostring
return     getpath
removedchildren
public void undo
markupcontainer this children   removedchildren
int size   children_size
for  int i   0  i < size  i
// get next child
final component child   children_get i
child setparent markupcontainer this
// loop through child components
int size   children_size
for  int i   0  i < size  i
// get next child
final component child   children_get i
// do not call remove() because the state change would than be
// recorded twice.
child detachmodel
child setparent null
this children   null
/**
* renders the entire associated markup stream for a container such as a
* border or panel. any leading or trailing raw markup in the associated
* markup is skipped.
*
* @param opentagname
*            the tag to render the associated markup for
* @param exceptionmessage
*            message that will be used for exceptions
*/
public final void renderassociatedmarkup final string opentagname  final string exceptionmessage
// get markup associated with border or panel component
final markupstream originalmarkupstream   getmarkupstream
final markupstream associatedmarkupstream   getassociatedmarkupstream true
// skip until the targetted tag is found
associatedmarkupstream skipuntil opentagname
setmarkupstream associatedmarkupstream
// get open tag in associated markup of border component
final componenttag associatedmarkupopentag   associatedmarkupstream gettag
// check for required open tag name
if     associatedmarkupopentag    null     associatedmarkupopentag isopen       associatedmarkupopentag instanceof wickettag
associatedmarkupstream throwmarkupexception exceptionmessage
try
setignoreattributemodifier true
rendercomponenttag associatedmarkupopentag
associatedmarkupstream next
if  getapplication   getdebugsettings   isoutputmarkupcontainerclassname
getresponse   write
getresponse   write getclass   getname
getresponse   write
rendercomponenttagbody associatedmarkupstream  associatedmarkupopentag
if  getapplication   getdebugsettings   isoutputmarkupcontainerclassname
getresponse   write
getresponse   write getclass   getname
getresponse   write
renderclosingcomponenttag associatedmarkupstream  associatedmarkupopentag  false
setmarkupstream originalmarkupstream
finally
setignoreattributemodifier false
/**
* replaces a child component of this container with another
*
* @param child
*            the child
* @throws illegalargumentexception
*             thrown if there was no child with the same id.
* @return this
*/
public final markupcontainer replace final component child
checkhierarchychange child
if  child    null
throw new illegalargumentexception
if  log isdebugenabled
log debug     child getid         this
if  child getparent      this
// add to map
final component replaced   put child
// look up to make sure it was already in the map
if  replaced    null
throw new wicketruntimeexception
exceptionmessage
child getid         child
// first remove the component.
removedcomponent replaced
// then add the other one.
addedcomponent child
// the position of the associated markup remains the same
child markupindex   replaced markupindex
// the generated markup id remains the same
string replacedid    replaced hasmarkupidmetadata    ? replaced getmarkupid     null
child setmarkupidmetadata replacedid
return this
/**
* @see org.apache.wicket.component#setmodel(org.apache.wicket.model.imodel)
*/
public component setmodel final imodel model
final imodel previous   this model
super setmodel model
if  previous instanceof icomponentinheritedmodel
visitchildren new ivisitor
public object component component component
imodel compmodel   component getmodel
if  compmodel instanceof iwrapmodel
compmodel     iwrapmodel compmodel  getwrappedmodel
if  compmodel    previous
component setmodel null
else if  compmodel    model
component modelchanged
return ivisitor continue_traversal
return this
/**
* get the number of children in this container.
*
* @return number of children in this container
*/
public final int size
return children_size
/**
* @see org.apache.wicket.component#tostring()
*/
public string tostring
return tostring false
/**
* @param detailed
*            true if a detailed string is desired
* @return string representation of this container
*/
public string tostring final boolean detailed
final stringbuffer buffer   new stringbuffer
buffer append
buffer append super tostring true
if  detailed
if  getmarkupstream      null
buffer append     getmarkupstream
if  children_size      0
buffer append
// loop through child components
final int size   children_size
for  int i   0  i < size  i
// get next child
final component child   children_get i
if  i    0
buffer append
buffer append child tostring
buffer append
return buffer tostring
/**
* traverses all child components of the given class in this container,
* calling the visitor's visit method at each one.
*
* @param clazz
*            the class of child to visit, or null to visit all children
* @param visitor
*            the visitor to call back to
* @return the return value from a visitor which halted the traversal, or
*         null if the entire traversal occurred
*/
public final object visitchildren final class clazz  final ivisitor visitor
if  visitor    null
throw new illegalargumentexception
// iterate through children of this container
for  int i   0  i < children_size    i
// get next child component
final component child   children_get i
object value   null
// is the child of the correct class (or was no class specified)?
if  clazz    null    clazz isinstance child
// call visitor
value   visitor component child
// if visitor returns a non-null value, it halts the traversal
if   value    ivisitor continue_traversal
value    ivisitor continue_traversal_but_dont_go_deeper
return value
// if child is a container
if   child instanceof markupcontainer
value    ivisitor continue_traversal_but_dont_go_deeper
// visit the children in the container
value     markupcontainer child  visitchildren clazz  visitor
// if visitor returns a non-null value, it halts the traversal
if   value    ivisitor continue_traversal
value    ivisitor continue_traversal_but_dont_go_deeper
return value
return null
/**
* traverses all child components in this container, calling the visitor's
* visit method at each one.
*
* @param visitor
*            the visitor to call back to
* @return the return value from a visitor which halted the traversal, or
*         null if the entire traversal occurred
*/
public final object visitchildren final ivisitor visitor
return visitchildren null  visitor
/**
* @param component
*            component being added
*/
private final void addedcomponent final component component
// check for degenerate case
if  component    this
throw new illegalargumentexception
markupcontainer parent   component getparent
if  parent    null
parent remove component
// set child's parent
component setparent this
final page page   findpage
if  page    null    page isattached
// if page is not null and the page has already been attached,
// attach the component. we only attach if the page has been
// attached because at some point the page must be attached and the
// call would cascade down anyways.
component attach
final idebugsettings debugsettings   application get   getdebugsettings
if  debugsettings getcomponentusecheck
component setmetadata added_at_key  strings tostring component  new markupexception
if  page    null
page componentadded component
/**
* @param child
*            child to add
*/
private final void children_add final component child
if  this children    null
this children   child
else
// get current list size
final int size   children_size
// create array that holds size + 1 elements
final component children   new component
// loop through existing children copying them
for  int i   0  i < size  i
children   children_get i
// add new child to the end
children   child
// save new children
this children   children
private final component children_get int index
if  index    0
if  children instanceof component
return  component children
else
return   component children
else
return   component children
private final component children_get final string id
if  children instanceof component
final component component    component children
if  component getid   equals id
return component
else
if  children    null
final component components    component children
for  int i   0  i < components length  i
if  components getid   equals id
return components
return null
private final int children_indexof component child
if  children instanceof component
if    component children  getid   equals child getid
return 0
else
if  children    null
final component components    component children
for  int i   0  i < components length  i
if  components getid   equals child getid
return i
return  1
private final component children_remove component component
int index   children_indexof component
if  index     1
return children_remove index
return null
private final component children_remove int index
if  children instanceof component
if  index    0
final component removed    component children
this children   null
return removed
else
throw new indexoutofboundsexception
else
component c     component children
final component removed   c
if  c length    2
if  index    0
this children   c
else if  index    1
this children   c
else
throw new indexoutofboundsexception
else
component newchildren   new component
int j   0
for  int i   0  i < c length  i
if  i    index
newchildren   c
this children   newchildren
return removed
private final component children_set int index  component child
final component replaced
if  index < children_size
if  children    null    children instanceof component
replaced    component children
children   child
else
final component children    component this children
replaced   children
children   child
else
throw new indexoutofboundsexception
return replaced
private final int children_size
if  children    null
return 0
else
if  children instanceof component
return 1
return   component children  length
/**
* ensure that there is space in childforid map for a new entry before
* adding it.
*
* @param child
*            the child to put into the map
* @return any component that was replaced
*/
private final component put final component child
int index   children_indexof child
if  index     1
children_add child
return null
else
return children_set index  child
/**
* @param component
*            component being removed
*/
private final void removedcomponent final component component
// notify page that component is being removed
final page page   component findpage
if  page    null
page componentremoved component
component detach
// component is removed
component setparent null
/**
* renders the next element of markup in the given markup stream.
*
* @param markupstream
*            the markup stream
*/
private final void rendernext final markupstream markupstream
// get the current markup element
final markupelement element   markupstream get
// if it a tag like <wicket..> or <span wicket:id="..." >
if   element instanceof componenttag      markupstream atclosetag
// get element as tag
final componenttag tag    componenttag element
// get component id
final string id   tag getid
// get the component for the id from the given container
final component component   get id
// failed to find it?
if  component    null
component render markupstream
else
// 2rd try: components like border and panel might implement
// the componentresolver interface as well.
markupcontainer container   this
while  container    null
if  container instanceof icomponentresolver
if    icomponentresolver container  resolve this  markupstream  tag
return
container   container findparent markupcontainer class
// 3rd try: try application's component resolvers
final list componentresolvers   this getapplication   getpagesettings
getcomponentresolvers
final iterator iterator   componentresolvers iterator
while  iterator hasnext
final icomponentresolver resolver    icomponentresolver iterator next
if  resolver resolve this  markupstream  tag
return
if  tag instanceof wickettag
if    wickettag tag  ischildtag
markupstream throwmarkupexception     tag tostring
else
markupstream throwmarkupexception     tag tostring
// no one was able to handle the component id
markupstream throwmarkupexception     id
this       id
else
// render as raw markup
if  log isdebugenabled
log debug
getresponse   write element tocharsequence
markupstream next
/**
* get the markup stream for this component.
*
* @return the markup stream for this component, or if it doesn't have one,
*         the markup stream for the nearest parent which does have one
*/
protected final markupstream findmarkupstream
// start here
markupcontainer c   this
// walk up hierarchy until markup found
while  c getmarkupstream      null
// check parent
c   c getparent
// are we at the top of the hierarchy?
if  c    null
// failed to find markup stream
throw new wicketruntimeexception exceptionmessage
return c getmarkupstream
/**
* handle the container's body. if your override of this method does not
* advance the markup stream to the close tag for the opentag, a runtime
* exception will be thrown by the framework.
*
* @param markupstream
*            the markup stream
* @param opentag
*            the open tag for the body
*/
protected void oncomponenttagbody final markupstream markupstream  final componenttag opentag
rendercomponenttagbody markupstream  opentag
/**
* renders this component. this implementation just calls rendercomponent.
*
* @param markupstream
*/
protected void onrender final markupstream markupstream
rendercomponent markupstream
/**
* renders this component and all sub-components using the given markup
* stream.
*
* @param markupstream
*            the markup stream
*/
protected void renderall final markupstream markupstream
// loop through the markup in this container
while  markupstream hasmore
// element rendering is responsible for advancing markup stream!
final int index   markupstream getcurrentindex
rendernext markupstream
if  index    markupstream getcurrentindex
markupstream throwmarkupexception     index
/**
* renders markup for the body of a componenttag from the current position
* in the given markup stream. if the open tag passed in does not require a
* close tag, nothing happens. markup is rendered until the closing tag for
* opentag is reached.
*
* @param markupstream
*            the markup stream
* @param opentag
*            the open tag
*/
protected final void rendercomponenttagbody final markupstream markupstream
final componenttag opentag
// if the open tag requires a close tag
boolean render   opentag requiresclosetag
if  render    false
// tags like <p> do not require a close tag, but they may have.
render    opentag hasnoclosetag
if  render    true
// loop through the markup in this container
while  markupstream hasmore       markupstream get   closes opentag
// render markup element. doing so must advance the markup
// stream
final int index   markupstream getcurrentindex
rendernext markupstream
if  index    markupstream getcurrentindex
markupstream throwmarkupexception     index
/**
* set markup stream for this container.
*
* @param markupstream
*            the markup stream
*/
protected final void setmarkupstream final markupstream markupstream
this markupstream   markupstream
final void internalattach2
if   getflag flag_attached
setflag flag_attaching  true
visitchildren new ivisitor
public object component component component
component setflag flag_attaching  true
return ivisitor continue_traversal
setflag flag_attach_super_call_verified  false
onattach
if   getflag flag_attach_super_call_verified
throw new illegalstateexception     this       getclass   getname
visitchildren new ivisitor
public object component component component
component setflag flag_attach_super_call_verified  false
component onattach
if   component getflag flag_attach_super_call_verified
throw new illegalstateexception     component       component getclass   getname
return ivisitor continue_traversal
visitchildren new ivisitor
public object component component component
component setflag flag_attaching  false
component setflag flag_attached  true
return ivisitor continue_traversal
setflag flag_attaching  false
setflag flag_attached  true
void detachchildren
// loop through child components
final iterator iter   iterator
while  iter hasnext
// get next child
final component child    component iter next
// call end request on the child
child detach
super detachchildren
void onbeforerenderchildren
super onbeforerenderchildren
try
// loop through child components
final int size   children_size
for  int i   0  i < size  i
// get next child
final component child   children_get i
// call begin request on the child
child beforerender
catch  runtimeexception ex
if  ex instanceof wicketruntimeexception
throw ex
else
throw new wicketruntimeexception
this  ex
void onafterrenderchildren
// loop through child components
final iterator iter   iterator
while  iter hasnext
// get next child
final component child    component iter next
// call end request on the child
child afterrender
super onafterrenderchildren
/**
* @return true if this markup container has associated markup
*/
final boolean hasassociatedmarkup
return getapplication   getmarkupsettings   getmarkupcache   hasassociatedmarkup this