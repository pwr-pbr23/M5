/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket
import java io serializable
import java util arraylist
import java util collections
import java util hashmap
import java util hashset
import java util iterator
import java util linkedlist
import java util list
import java util locale
import java util map
import java util set
import java util map entry
import org apache wicket application iclassresolver
import org apache wicket authorization iauthorizationstrategy
import org apache wicket feedback feedbackmessage
import org apache wicket feedback feedbackmessages
import org apache wicket feedback ifeedbackmessagefilter
import org apache wicket protocol http ignoreajaxrequestexception
import org apache wicket request clientinfo
import org apache wicket session isessionstore
import org apache wicket util lang objects
import org apache wicket util string strings
import org apache wicket util time duration
import org slf4j logger
import org slf4j loggerfactory
/**
* holds information about a user session, including some fixed number of most
* recent pages (and all their nested component information).
* <ul>
* <li><b>access via requestcycle </b>- the session for a {@link requestcycle}
* can be retrieved by calling {@link requestcycle#getsession()}.
*
* <li><b>access via component </b>- if a requestcycle object is not available,
* the session can be retrieved for a component by calling
* {@link component#getsession()}. as currently implemented, each component
* does not itself have a reference to the session that contains it. however,
* the page component at the root of the containment hierarchy does have a
* reference to the session that holds the page. so
* {@link component#getsession()} traverses the component hierarchy to the root
* page and then calls {@link page#getsession()}.
*
* <li><b>access via thread local </b>- in the odd case where neither a
* requestcycle nor a component is available, the currently active session for
* the calling thread can be retrieved by calling the static method
* session.get(). this last form should only be used if the first two forms
* cannot be used since thread local access can involve a potentially more
* expensive hash map lookup.
*
* <li><b>locale </b>- a session has a locale property to support localization.
* the locale for a session can be set by calling
* {@link session#setlocale(locale)}. the locale for a session determines how
* localized resources are found and loaded.
*
* <li><b>style </b>- besides having an appearance based on locale, resources
* can also have different looks in the same locale (a.k.a. "skins"). the style
* for a session determines the look which is used within the appopriate locale.
* the session style ("skin") can be set with the setstyle() method.
*
* <li><b>resource loading </b>- based on the session locale and style,
* searching for resources occurs in the following order (where sourcepath is
* set via the applicationsettings object for the current application, and style
* and locale are session properties):
* <ul>
* 1. [sourcepath]/name[style][locale].[extension] <br>
* 2. [sourcepath]/name[locale].[extension] <br>
* 3. [sourcepath]/name[style].[extension] <br>
* 4. [sourcepath]/name.[extension] <br>
* 5. [classpath]/name[style][locale].[extension] <br>
* 6. [classpath]/name[locale].[extension] <br>
* 7. [classpath]/name[style].[extension] <br>
* 8. [classpath]/name.[extension] <br>
* </ul>
*
* <li><b>session properties </b>- arbitrary objects can be attached to a
* session by installing a session factory on your application class which
* creates custom session subclasses that have typesafe properties specific to
* the application (see {@link application} for details). to discourage
* non-typesafe access to session properties, no setproperty() or getproperty()
* method is provided. in a clustered environment, you should take care to call
* the dirty() method when you change a property or youre own. this way the
* session will be reset again in the http session so that the http session
* knows the session is changed.
*
* <li><b>class resolver </b>- sessions have a class resolver (
* {@link iclassresolver}) implementation that is used to locate classes for
* components such as pages.
*
* <li><b>page factory </b>- a pluggable implementation of {@link ipagefactory}
* is used to instantiate pages for the session.
*
* <li><b>removal </b>- pages can be removed from the session forcibly by
* calling remove(page) or removeall(), although such an action should rarely be
* necessary.
*
* <li><b>flash messages</b>- flash messages are messages that are stored in
* session and are removed after they are displayed to the user. session acts as
* a store for these messages because they can last across requests.
*
* @author jonathan locke
* @author eelco hillenius
* @author igor vaynberg (ivaynberg)
*/
public abstract class session implements iclusterable
/**
* visitor interface for visiting page maps
*
* @author jonathan locke
*/
public static interface ipagemapvisitor
/**
* @param pagemap
*            the page map
*/
public void pagemap final ipagemap pagemap
/**
* meta data for recording map map access.
*/
public static final class pagemapaccessmetadata implements iclusterable
private static final long serialversionuid   1l
set pagemapnames   new hashset 2
/**
* @param pagemap
*            the pagemap to add as used.
* @return the boolean if it was added (didn't already contain the
*         pagemap)
*/
public boolean add ipagemap pagemap
return pagemapnames add pagemap getname
private static final class counter
private int count   0
/**
* filter that returns all component scoped messages ({@link feedbackmessage#getreporter()} !=
* null).
*/
public static final ifeedbackmessagefilter messages_for_components   new ifeedbackmessagefilter
private static final long serialversionuid   1l
public boolean accept feedbackmessage message
return message getreporter      null
/** meta data key for missing body tags logging. */
public static final metadatakey pagemap_access_mdk   new metadatakey
pagemapaccessmetadata class
private static final long serialversionuid   1l
/** name of session attribute under which this session is stored */
public static final string session_attribute_name
/** thread-local current session. */
private static final threadlocal current   new threadlocal
/** a store for dirty objects for one request */
private static final threadlocal dirtyobjects   new threadlocal
/** logging object */
private static final logger log   loggerfactory getlogger session class
/** attribute prefix for page maps stored in the session */
private static final string pagemapattributeprefix
/**
* filter that returns all session scoped messages ({@link feedbackmessage#getreporter()} ==
* null).
*/
private static final ifeedbackmessagefilter rendered_session_scoped_messages   new ifeedbackmessagefilter
private static final long serialversionuid   1l
public boolean accept feedbackmessage message
return message getreporter      null    message isrendered
private static final long serialversionuid   1l
/** a store for touched pages for one request */
private static final threadlocal touchedpages   new threadlocal
/** prefix for attributes holding page map entries */
static final string pagemapentryattributeprefix
/**
* checks if the <code>session</code> threadlocal is set in this thread
*
* @return true if {@link session#get()} can return the instance of session,
*         false otherwise
*/
public static boolean exists
return current get      null
/**
* locate the session for the client of this request in the
* {@link isessionstore} or create a new one and attach it when none could
* be located and sets it as the current instance for this thread.
* typically, clients never touch this method, but rather use
* {@link session#get()}, which does the locating implicitly when not yet
* set as a thread local.
*
* @return the session for the client of this request or a new, unbound
*/
public static final session findorcreate
requestcycle requestcycle   requestcycle get
if  requestcycle    null
throw new illegalstateexception
application application   application get
isessionstore sessionstore   application getsessionstore
session session   sessionstore lookup requestcycle getrequest
if  session    null
// create session using session factory
session   application newsession requestcycle getrequest    requestcycle getresponse
// set thread local
set session
return session
/**
* get the session for the calling thread.
*
* @return session for calling thread
*/
public static session get
session session    session current get
if  session    null
session   findorcreate
return session
/**
* this method is not part of the wicket public api. do not call it.
* <p>
* sets session for calling thread. also triggers {@link #attach()} being
* called.
*
* @param session
*            the session
*/
public static void set final session session
if  session    null
throw new illegalargumentexception
current set session
// execute any attach logic now
session attach
/**
* this method is not part of the wicket public api. do not call it.
* <p>
* clears the session for calling thread.
*
*/
public static void unset
current set null
/** a number to generate names for auto create pagemaps */
private int autocreatepagemapcounter   0
/**
* cached instance of agent info which is typically designated by calling
* {@link requestcycle#newclientinfo()}.
*/
private clientinfo clientinfo
/** true if session state has been changed */
private transient boolean dirty   false
/** feedback messages */
private feedbackmessages feedbackmessages   new feedbackmessages
/** cached id because you can't access the id after session unbound */
private string id   null
/** the locale to use when loading resources for this session. */
private locale locale
/** application level meta data. */
private metadataentry metadata
/**
* we need to know both thread that keeps the pagemap lock and the
* requestcycle
*/
private static class pagemapsusedinrequestentry
thread thread
requestcycle requestcycle
private transient map pagemapsusedinrequest
/** true, if session has been invalidated */
private transient boolean sessioninvalidated   false
/**
* temporary instance of the session store. should be set on each request as
* it is not supposed to go in the session.
*/
private transient isessionstore sessionstore
/** any special "skin" style to use when loading resources. */
private string style
/**
* holds attributes for sessions that are still temporary/ not bound to a
* session store. only used when {@link #istemporary()} is true.
* <p>
* note: this doesn't have to be synchronized, as the only time when this
* map is used is when a session is temporary, in which case it won't be
* shared between requests (it's a per request instance).
* </p>
*/
private transient map temporarysessionattributes
/** a linked list for last used pagemap queue */
private linkedlist   <ipagemap>   usedpagemaps   new linkedlist
/**
* constructor. note that {@link requestcycle} is not available until this
* constructor returns.
*
* @param application
*            the application that this is a session of
* @param request
*            the current request
* @param response
*            the current response
*/
protected session application application  request request
this locale   request getlocale
if  locale    null
throw new illegalargumentexception
/**
* force binding this session to the application's
* {@link isessionstore session store} if not already done so.
* <p>
* a wicket application can operate in a session-less mode as long as
* stateless pages are used. session objects will be then created for each
* request, but they will only live for that request. you can recognize
* temporary sessions by calling {@link #istemporary()} which basically
* checks whether the session's id is null. hence, temporary sessions have
* no session id.
* </p>
* <p>
* by calling this method, the session will be bound (made not-temporary) if
* it was not bound yet. it is useful for cases where you want to be
* absolutely sure this session object will be available in next requests.
* </p>
*/
public final void bind
isessionstore store   getsessionstore
request request   requestcycle get   getrequest
if  store lookup request     null
// explicitly create a session
this id   store getsessionid request  true
// bind it
store bind request  this
if  temporarysessionattributes    null
for  iterator i   temporarysessionattributes entryset   iterator    i hasnext
entry entry    entry i next
store setattribute request  string valueof entry getkey     entry getvalue
temporarysessionattributes   null
else
log warn
/**
* cleans up all rendered feedback messages and any unrendered, dangling
* feedback messages there may be left after that.
*/
public void cleanupfeedbackmessages
// if session scoped, rendered messages got indeed cleaned up, mark the
// session as dirty
if  feedbackmessages clear rendered_session_scoped_messages  > 0
dirty
// clean up all component related feedback messages
feedbackmessages clear messages_for_components
/**
* removes all pages from the session. although this method should rarely be
* needed, it is available (possibly for security reasons).
*/
public final void clear
visitpagemaps new ipagemapvisitor
public void pagemap ipagemap pagemap
pagemap clear
/**
* automatically creates a page map, giving it a session unique name.
*
* @return created pagemap
*/
public final ipagemap createautopagemap
return newpagemap createautopagemapname
/**
* with this call you can create a pagemap name but not create the pagemap
* itself already. it will give the first pagemap name where it couldn't
* find a current pagemap for.
*
* it will return the same name if you call it 2 times in a row.
*
* @return the created pagemap name
*/
public synchronized final string createautopagemapname
string name       autocreatepagemapcounter
ipagemap pm   pagemapforname name  false
while  pm    null
autocreatepagemapcounter
name       autocreatepagemapcounter
pm   pagemapforname name  false
return name
/**
* registers an error feedback message for this session
*
* @param message
*            the feedback message
*/
public final void error final string message
addfeedbackmessage message  feedbackmessage error
/**
* get the application that is currently working with this session.
*
* @return returns the application.
*/
public final application getapplication
return application get
/**
* @return the authorization strategy for this session
*/
public iauthorizationstrategy getauthorizationstrategy
return getapplication   getsecuritysettings   getauthorizationstrategy
/**
* @return the class resolver for this session
*/
public final iclassresolver getclassresolver
return getapplication   getapplicationsettings   getclassresolver
/**
* gets the client info object for this session. this method lazily gets the
* new agent info object for this session. it uses any cached or set ({@link #setclientinfo(clientinfo)})
* client info object or uses {@link requestcycle#newclientinfo()} to get
* the info object based on the current request when no client info object
* was set yet, and then caches the returned object; we can expect the
* client to stay the same for the whole session, and implementations of
* {@link requestcycle#newclientinfo()} might be relatively expensive.
*
* @return the client info object based on this request
*/
public clientinfo getclientinfo
if  clientinfo    null
this clientinfo   requestcycle get   newclientinfo
return clientinfo
/**
* @return the default page map
*/
public final ipagemap getdefaultpagemap
return pagemapforname pagemap default_name  true
/**
* gets feedback messages stored in session
*
* @return unmodifiable list of feedback messages
*/
public final feedbackmessages getfeedbackmessages
return feedbackmessages
/**
* gets the unique id for this session from the underlying sessionstore. may
* be null if a concrete session is not yet created.
*
* @return the unique id for this session or null if it is a temporary
*         session
*/
public final string getid
if  id    null
id   getsessionstore   getsessionid requestcycle get   getrequest    false
// we have one?
if  id    null
dirty
return id
/**
* get this session's locale.
*
* @return this session's locale
*/
public locale getlocale
return locale
/**
* gets metadata for this session using the given key.
*
* @param key
*            the key for the data
* @return the metadata
* @see metadatakey
*/
public final serializable getmetadata final metadatakey key
return key get metadata
/**
* when a regular request on certain page with certain version is being
* processed, we don't allow ajax requests to same page and version.
*
* @param lockedrequestcycle
* @return whether current request is valid or sould be discarded
*/
protected boolean iscurrentrequestvalid requestcycle lockedrequestcycle
return true
/**
* this method is not part of the wicket public api. do not call it.
*
* get the page for the given path.
*
* @param pagemapname
*            the name of the page map where the page is
* @param path
*            component path
* @param versionnumber
*            the version of the page required
* @return the page based on the first path component (the page id), or null
*         if the requested version of the page cannot be found.
*/
public final page getpage final string pagemapname  final string path  final int versionnumber
if  log isdebugenabled
log debug     path       versionnumber
// get page map by name, creating the default page map automatically
ipagemap pagemap   pagemapforname pagemapname  pagemapname    pagemap default_name
if  pagemap    null
synchronized  usedpagemaps     get a lock so be sure that only one
// is made
if  pagemapsusedinrequest    null
pagemapsusedinrequest   new hashmap 3
synchronized  pagemapsusedinrequest
long starttime   system currenttimemillis
// todo for now only use the setting. might be extended with
// something overridable on request/ page/ request target level
// later
duration timeout   application get   getrequestcyclesettings   gettimeout
pagemapsusedinrequestentry entry    pagemapsusedinrequestentry pagemapsusedinrequest
get pagemap
// get page entry for id and version
thread t   entry    null ? entry thread   null
while  t    null    t    thread currentthread
if  iscurrentrequestvalid entry requestcycle     false
// we need to ignore this request. that's because it is
// an ajax request
// while regular page request is being processed
throw new ignoreajaxrequestexception
try
pagemapsusedinrequest wait timeout getmilliseconds
catch  interruptedexception ex
throw new wicketruntimeexception ex
entry    pagemapsusedinrequestentry pagemapsusedinrequest get pagemap
t   entry    null ? entry thread   null
if  t    null    t    thread currentthread
starttime   timeout getmilliseconds    < system currenttimemillis
// if it is still not the right thread..
// this either points to long running code (a report
// page?) or a deadlock or such
throw new wicketruntimeexception     timeout
pagemapname       t
path
pagemapsusedinrequestentry newentry   new pagemapsusedinrequestentry
newentry thread   thread currentthread
newentry requestcycle   requestcycle get
pagemapsusedinrequest put pagemap  newentry
final string id   strings firstpathcomponent path  component path_separator
page page   pagemap get integer parseint id   versionnumber
if  page    null
pagemapsusedinrequest remove pagemap
pagemapsusedinrequest notifyall
else
// attach the page now.
page attach
touch page
return page
return null
/**
* @return the page factory for this session
*/
public final ipagefactory getpagefactory
return getapplication   getsessionsettings   getpagefactory
/**
* @param page
*            the page, or null if no page context is available
* @return the page factory for the page, or the default page factory if
*         page was null
*/
public final ipagefactory getpagefactory final page page
if  page    null
return page getpagefactory
return getpagefactory
/**
* @return a list of all pagemaps in this session.
*/
public final list getpagemaps
final list list   new arraylist
for  final iterator iterator   getattributenames   iterator    iterator hasnext
final string attribute    string iterator next
if  attribute startswith pagemapattributeprefix
list add getattribute attribute
return list
/**
* @return size of this session, including all the pagemaps it contains
*/
public final long getsizeinbytes
long size   objects sizeof this
for  final iterator iterator   getpagemaps   iterator    iterator hasnext
final ipagemap pagemap    ipagemap iterator next
size    pagemap getsizeinbytes
return size
/**
* get the style (see {@link org.apache.wicket.session}).
*
* @return returns the style (see {@link org.apache.wicket.session})
*/
public final string getstyle
return style
/**
* registers an informational feedback message for this session
*
* @param message
*            the feedback message
*/
public final void info final string message
addfeedbackmessage message  feedbackmessage info
/**
* invalidates this session at the end of the current request. if you need
* to invalidate the session immediately, you can do this by calling
* invalidatenow(), however this will remove all wicket components from this
* session, which means that you will no longer be able to work with them.
*/
public void invalidate
sessioninvalidated   true
/**
* invalidates this session immediately. calling this method will remove all
* wicket components from this session, which means that you will no longer
* be able to work with them.
*/
public void invalidatenow
sessioninvalidated   true     set this for issessioninvalidated
getsessionstore   invalidate requestcycle get   getrequest
/**
* whether the session is invalid now, or will be invalidated by the end of
* the request. clients should rarely need to use this method if ever.
*
* @return whether the session is invalid when the current request is done
*
* @see #invalidate()
* @see #invalidatenow()
*/
public final boolean issessioninvalidated
return sessioninvalidated
/**
* whether this session is temporary. a wicket application can operate in a
* session-less mode as long as stateless pages are used. if this session
* object is temporary, it will not be available on a next request.
*
* @return whether this session is temporary (which is the same as it's id
*         being null)
*/
public final boolean istemporary
return getid      null
/**
* creates a new page map with a given name
*
* @param name
*            the name for the new page map
* @return the newly created page map
*/
public final ipagemap newpagemap final string name
// check that session doesn't have too many page maps already
final int maxpagemaps   getapplication   getsessionsettings   getmaxpagemaps
synchronized  usedpagemaps
if  usedpagemaps size   >  maxpagemaps
ipagemap pm    ipagemap usedpagemaps getfirst
pm remove
// create new page map
final ipagemap pagemap   getsessionstore   createpagemap name
setattribute attributeforpagemapname name   pagemap
dirty
return pagemap
/**
* gets a page map for the given name, automatically creating it if need be.
*
* @param pagemapname
*            name of page map, or null for default page map
* @param autocreate
*            true if the page map should be automatically created if it
*            does not exist
* @return pagemap for name
*/
public final ipagemap pagemapforname string pagemapname  final boolean autocreate
ipagemap pagemap    ipagemap getattribute attributeforpagemapname pagemapname
if  pagemap    null    autocreate
pagemap   newpagemap pagemapname
return pagemap
/**
* @param pagemap
*            page map to remove
*/
public final void removepagemap final ipagemap pagemap
pagemapaccessmetadata pagemapmetadata    pagemapaccessmetadata getmetadata pagemap_access_mdk
if  pagemapmetadata    null
pagemapmetadata pagemapnames remove pagemap getname
synchronized  usedpagemaps
usedpagemaps remove pagemap
removeattribute attributeforpagemapname pagemap getname
dirty
/**
* this method is not part of the wicket public api. do not call it.
* <p>
* sets the application that this session is associated with.
*
* @param application
*            the application
*/
public final void setapplication final application application
/**
* this method is not part of the wicket public api. do not call it.
* <p>
* sets the client info object for this session. this will only work when
* {@link #getclientinfo()} is not overriden.
*
* @param clientinfo
*            the client info object
*/
public final void setclientinfo clientinfo clientinfo
this clientinfo   clientinfo
dirty
/**
* set the locale for this session.
*
* @param locale
*            new locale
*/
public final void setlocale final locale locale
if  locale    null
throw new illegalargumentexception
this locale   locale
dirty
/**
* sets the metadata for this session using the given key. if the metadata
* object is not of the correct type for the metadata key, an
* illegalargumentexception will be thrown. for information on creating
* metadatakeys, see {@link metadatakey}.
*
* @param key
*            the singleton key for the metadata
* @param object
*            the metadata object
* @throws illegalargumentexception
* @see metadatakey
*/
public final void setmetadata final metadatakey key  final serializable object
metadata   key set metadata  object
/**
* set the style (see {@link org.apache.wicket.session}).
*
* @param style
*            the style to set.
* @return the session object
*/
public final session setstyle final string style
this style   style
dirty
return this
/**
* this method is not part of the wicket public api. do not call it.
* <p>
* the page will be 'touched' in the session. if it wasn't added yet to the
* pagemap, it will be added to the page map else it will set this page to
* the front.
*
* if another page was removed because of this it will be cleaned up.
*
* @param page
*/
public final void touch page page
// store it in a list, so that the pages are really pushed
// to the pagemap when the session does it update/detaches.
// all the pages are then detached
list lst    list touchedpages get
if  lst    null
lst   new arraylist
touchedpages set lst
lst add page
else if   lst contains page
lst add page
/**
* @param visitor
*            the visitor to call at each page in this pagemap.
*/
public final void visitpagemaps final ipagemapvisitor visitor
for  final iterator iterator   getattributenames   iterator    iterator hasnext
final string attribute    string iterator next
if  attribute startswith pagemapattributeprefix
visitor pagemap  ipagemap getattribute attribute
/**
* registers a warning feedback message for this session
*
* @param message
*            the feedback message
*/
public final void warn final string message
addfeedbackmessage message  feedbackmessage warning
/**
* adds a feedback message to the list of messages
*
* @param message
* @param level
*
*/
private void addfeedbackmessage string message  int level
getfeedbackmessages   add null  message  level
dirty
/**
* @param pagemapname
*            name of page map
* @return session attribute holding page map
*/
private final string attributeforpagemapname final string pagemapname
return pagemapattributeprefix   pagemapname
/**
* any attach logic for session subclasses. called when a session is set for
* the thread.
*/
protected void attach
/**
* any detach logic for session subclasses. this is called on the end of
* handling a request, when the requestcycle is about to be detached from
* the current thread.
*/
protected void detach
if  sessioninvalidated
invalidatenow
/**
* marks session state as dirty
*/
protected final void dirty
this dirty   true
/**
* gets the attribute value with the given name
*
* @param name
*            the name of the attribute to store
* @return the value of the attribute
*/
protected final object getattribute final string name
if   istemporary
requestcycle cycle   requestcycle get
if  cycle    null
return getsessionstore   getattribute cycle getrequest    name
else
if  temporarysessionattributes    null
return temporarysessionattributes get name
return null
/**
* @return list of attributes for this session
*/
protected final list getattributenames
if   istemporary
requestcycle cycle   requestcycle get
if  cycle    null
return getsessionstore   getattributenames cycle getrequest
else
if  temporarysessionattributes    null
return new arraylist temporarysessionattributes keyset
return collections empty_list
/**
* gets the session store.
*
* @return the session store
*/
protected isessionstore getsessionstore
if  sessionstore    null
sessionstore   getapplication   getsessionstore
return sessionstore
/**
* removes the attribute with the given name.
*
* @param name
*            the name of the attribute to remove
*/
protected final void removeattribute string name
if   istemporary
requestcycle cycle   requestcycle get
if  cycle    null
getsessionstore   removeattribute cycle getrequest    name
else
if  temporarysessionattributes    null
temporarysessionattributes remove name
/**
* adds or replaces the attribute with the given name and value.
*
* @param name
*            the name of the attribute
* @param value
*            the value of the attribute
*/
protected final void setattribute string name  object value
if   istemporary
requestcycle cycle   requestcycle get
if  cycle    null
throw new illegalstateexception
isessionstore store   getsessionstore
request request   cycle getrequest
// extra check on session binding event
if  value    this
object current   store getattribute request  name
if  current    null
string id   store getsessionid request  false
if  id    null
// this is a new instance. wherever it came from, bind
// the session now
store bind request   session value
// set the actual attribute
store setattribute request  name  value
else
// we don't have to synchronize, as it is impossible a temporary
// session instance gets shared across threads
if  temporarysessionattributes    null
temporarysessionattributes   new hashmap 3
temporarysessionattributes put name  value
/**
* not to be called by framework users.
*
* @deprecated obsolete method (was meant for internal book keeping really).
*             clients should override {@link #detach()} instead.
*/
protected final void update
throw new unsupportedoperationexception
/**
* @param page
*            the page to add to dirty objects list
*/
void dirtypage final page page
list dirtyobjects   getdirtyobjectslist
if   dirtyobjects contains page
dirtyobjects add page
/**
* @param map
*            the page map to add to dirty objects list
*/
void dirtypagemap final ipagemap map
if   map isdefault
synchronized  usedpagemaps
usedpagemaps remove map
usedpagemaps addlast map
list dirtyobjects   getdirtyobjectslist
if   dirtyobjects contains map
dirtyobjects add map
/**
* @return the current thread dirty objects list
*/
list getdirtyobjectslist
list list    list dirtyobjects get
if  list    null
list   new arraylist 4
dirtyobjects set list
return list
// todo remove after deprecation release
/**
* internal api. the request cycle when detached will call this.
*
*/
final void requestdetached
list touchedpages    list session touchedpages get
session touchedpages set null
if  touchedpages    null
for  int i   0  i < touchedpages size    i
page page    page touchedpages get i
page getpagemap   put page
// if state is dirty
if  dirty
// state is no longer dirty
this dirty   false
// set attribute.
setattribute session_attribute_name  this
else
if  log isdebugenabled
log debug
list dirtyobjects    list session dirtyobjects get
session dirtyobjects set null
// go through all dirty entries, replicating any dirty objects
if  dirtyobjects    null
for  final iterator iterator   dirtyobjects iterator    iterator hasnext
string attribute   null
object object   iterator next
if  object instanceof page
final page page    page object
if  page isstateless
// check, can it be that stateless pages where added to
// the session?
// and should be removed now?
continue
attribute   page getpagemap   attributeforid page getnumericid
if  getattribute attribute     null
// page removed by another thread. don't add it again.
continue
object   page getpagemapentry
else if  object instanceof ipagemap
attribute   attributeforpagemapname   ipagemap object  getname
setattribute attribute  object
if  pagemapsusedinrequest    null
synchronized  pagemapsusedinrequest
thread t   thread currentthread
iterator it   pagemapsusedinrequest entryset   iterator
while  it hasnext
entry entry    entry it next
if    pagemapsusedinrequestentry entry getvalue    thread    t
it remove
pagemapsusedinrequest notifyall