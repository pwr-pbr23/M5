/*
* licensed to the apache software foundation (asf) under one or more
* contributor license agreements.  see the notice file distributed with
* this work for additional information regarding copyright ownership.
* the asf licenses this file to you under the apache license, version 2.0
* (the "license"); you may not use this file except in compliance with
* the license.  you may obtain a copy of the license at
*
*      http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache wicket
import java io serializable
import java util arraylist
import java util collections
import java util iterator
import java util list
import java util locale
import org apache wicket ajax ajaxrequesttarget
import org apache wicket authorization action
import org apache wicket authorization authorizationexception
import org apache wicket authorization iauthorizationstrategy
import org apache wicket authorization unauthorizedactionexception
import org apache wicket behavior ibehavior
import org apache wicket feedback feedbackmessage
import org apache wicket markup componenttag
import org apache wicket markup markupexception
import org apache wicket markup markupstream
import org apache wicket markup wickettag
import org apache wicket markup html iheadercontributor
import org apache wicket markup html internal htmlheadercontainer
import org apache wicket model icomponentassignedmodel
import org apache wicket model icomponentinheritedmodel
import org apache wicket model imodel
import org apache wicket model imodelcomparator
import org apache wicket model iwrapmodel
import org apache wicket settings idebugsettings
import org apache wicket util convert iconverter
import org apache wicket util lang classes
import org apache wicket util lang objects
import org apache wicket util string prependingstringbuffer
import org apache wicket util string strings
import org apache wicket util value valuemap
import org apache wicket version undo change
import org slf4j logger
import org slf4j loggerfactory
/**
* component serves as the highest level abstract base class for all components.
*
* <ul>
* <li><b>identity </b>- all components must have a non-null id which is
* retrieved by calling getid(). the id must be unique within the
* markupcontainer that holds the component, but does not have to be globally
* unique or unique within a page's component hierarchy.
*
* <li><b>hierarchy </b>- a component has a parent which can be retrieved with
* {@link #getparent()}. if a component is an instance of markupcontainer, it
* may have children. in this way it has a place in the hierarchy of components
* contained on a given page.
*
* <li><b>component paths </b>- the path from the page at the root of the
* component hierarchy to a given component is simply the concatenation with dot
* separators of each id along the way. for example, the path "a.b.c" would
* refer to the component named "c" inside the markupcontainer named "b" inside
* the container named "a". the path to a component can be retrieved by calling
* getpath(). this path is an absolute path beginning with the id of the page at
* the root. pages bear a pagemap/session-relative identifier as their id, so
* each absolute path will begin with a number, such as "0.a.b.c". to get a
* component path relative to the page that contains it, you can call
* getpagerelativepath().
*
* <li><b>lifecycle </b>- components participate in the following lifecycle
* phases:
* <ul>
* <li><b>construction </b>- a component is constructed with the java language
* new operator. children may be added during construction if the component is a
* markupcontainer.
*
* <li><b>request handling </b>- an incoming request is processed by a protocol
* request handler such as wicketservlet. an associated application object
* creates session, request and response objects for use by a given component in
* updating its model and rendering a response. these objects are stored inside
* a container called {@link requestcycle} which is accessible via
* {@link component#getrequestcycle()}. the convenience methods
* {@link component#getrequest()}, {@link component#getresponse()} and
* {@link component#getsession()} provide easy access to the contents of this
* container.
*
* <li><b>listener invocation </b>- if the request references a listener on an
* existing component, that listener is called, allowing arbitrary user code to
* handle events such as link clicks or form submits. although arbitrary
* listeners are supported in wicket, the need to implement a new class of
* listener is unlikely for a web application and even the need to implement a
* listener interface directly is highly discouraged. instead, calls to
* listeners are routed through logic specific to the event, resulting in calls
* to user code through other overridable methods. for example, the
* {@link org.apache.wicket.markup.html.form.iformsubmitlistener#onformsubmitted()}
* method implemented by the form class is really a private implementation
* detail of the form class that is not designed to be overridden (although
* unfortunately, it must be public since all interface methods in java must be
* public). instead, form subclasses should override user-oriented methods such
* as onvalidate(), onsubmit() and onerror() (although only the latter two are
* likely to be overridden in practice).
*
* <li><b>onbeginrequest </b>- the {@link component#onbeginrequest()} method is
* called.
*
* <li><b>form submit </b>- if a form has been submitted and the component is a
* formcomponent, the component's model is validated by a call to
* formcomponent.validate().
*
* <li><b>form model update </b>- if a valid form has been submitted and the
* component is a formcomponent, the component's model is updated by a call to
* formcomponent.updatemodel().
*
* <li><b>rendering </b>- a markup response is generated by the component via
* {@link component#render()}, which calls subclass implementation code
* contained in {@link component#onrender()}. once this phase begins, a
* component becomes immutable. attempts to alter the component will result in a
* wicketruntimeexception.
*
* <li><b>onendrequest </b>() - the {@link component#onendrequest()} method is
* called.
* </ul>
*
* <li><b>component models </b>- the primary responsibility of a component is
* to use its model (an object that implements imodel), which can be set via
* {@link component#setmodel(imodel model)} and retrieved via
* {@link component#getmodel()}, to render a response in an appropriate markup
* language, such as html. in addition, form components know how to update their
* models based on request information. since the imodel interface is a wrapper
* around an actual model object, a convenience method
* {@link component#getmodelobject()} is provided to retrieve the model object
* from its imodel wrapper. a further convenience method,
* {@link component#getmodelobjectasstring()}, is provided for the very common
* operation of converting the wrapped model object to a string.
*
* <li><b>visibility </b>- components which have setvisible(false) will return
* false from isvisible() and will not render a response (nor will their
* children).
*
* <li><b>page </b>- the page containing any given component can be retrieved
* by calling {@link component#getpage()}. if the component is not attached to
* a page, an illegalstateexception will be thrown. an equivalent method,
* {@link component#findpage()} is available for special circumstances where it
* might be desirable to get a null reference back instead.
*
* <li><b>session </b>- the page for a component points back to the session
* that contains the page. the session for a component can be accessed with the
* convenience method getsession(), which simply calls getpage().getsession().
*
* <li><b>locale </b>- the locale for a component is available through the
* convenience method getlocale(), which is equivalent to
* getsession().getlocale().
*
* <li><b>string resources </b>- components can have associated string
* resources via the application's localizer, which is available through the
* method {@link component#getlocalizer()}. the convenience methods
* {@link component#getstring(string key)} and
* {@link component#getstring(string key, imodel model)} wrap the identical
* methods on the application localizer for easy access in components.
*
* <li><b>style </b>- the style ("skin") for a component is available through
* {@link component#getstyle()}, which is equivalent to
* getsession().getstyle(). styles are intended to give a particular look to a
* component or resource that is independent of its locale. for example, a style
* might be a set of resources, including images and markup files, which gives
* the design look of "ocean" to the user. if the session's style is set to
* "ocean" and these resources are given names suffixed with "_ocean", wicket's
* resource management logic will prefer these resources to other resources,
* such as default resources, which are not as good of a match.
*
* <li><b>variation </b>- whereas styles are session (user) specific,
* variations are component specific. e.g. if the style is "ocean" and the
* variation is "northsea", than the resources are given the names suffixed with
* "_ocean_northsea".
*
* <li><b>attributemodifiers </b>- you can add one or more
* {@link attributemodifier}s to any component if you need to programmatically
* manipulate attributes of the markup tag to which a component is attached.
*
* <li><b>application, applicationsettings and applicationpages </b>- the
* getapplication() method provides convenient access to the application for a
* component via getsession().getapplication(). the getapplicationsettings()
* method is equivalent to getapplication().getsettings(). the
* getapplicationpages is equivalent to getapplication().getpages().
*
* <li><b>feedback messages </b>- the {@link component#debug(string)},
* {@link component#info(string)}, {@link component#warn(string)},
* {@link component#error(string)} and {@link component#fatal(string)} methods
* associate feedback messages with a component. it is generally not necessary
* to use these methods directly since wicket validators automatically register
* feedback messages on components. any feedback message for a given component
* can be retrieved with {@link component#getfeedbackmessage}.
*
* <li><b>page factory </b>- it is possible to change the way that pages are
* constructed by overriding the {@link component#getpagefactory()} method,
* returning your own implementation of {@link org.apache.wicket.ipagefactory}.
*
* <li><b>versioning </b>- pages are the unit of versioning in wicket, but
* fine-grained control of which components should participate in versioning is
* possible via the {@link component#setversioned(boolean)} method. the
* versioning participation of a given component can be retrieved with
* {@link component#isversioned()}.
*
* <li><b>ajax support</b>- components can be re-rendered after the whole page
* has been rendered at least once by calling dorender().
*
* @author jonathan locke
* @author chris turner
* @author eelco hillenius
* @author johan compagner
* @author juergen donnerstag
* @author igor vaynberg (ivaynberg)
*/
public abstract class component implements iclusterable  iconverterlocator
/**
* change record of a model.
*/
public class componentmodelchange extends change
private static final long serialversionuid   1l
/** former model. */
private imodel model
/**
* construct.
*
* @param model
*/
public componentmodelchange imodel model
super
this model   model
/**
* @see java.lang.object#tostring()
*/
public string tostring
return     getpath
/**
* @see org.apache.wicket.version.undo.change#undo()
*/
public void undo
setmodel this model
/**
* generic component visitor interface for component traversals.
*/
public static interface ivisitor
/**
* value to return to continue a traversal.
*/
public static final object continue_traversal   null
/**
* a generic value to return to contiue a traversal, but if the
* component is a container, don't visit its children.
*/
public static final object continue_traversal_but_dont_go_deeper   new object
/**
* a generic value to return to stop a traversal.
*/
public static final object stop_traversal   new object
/**
* called at each component in a traversal.
*
* @param component
*            the component
* @return continue_traversal (null) if the traversal should continue,
*         or a non-null return value for the traversal method if it
*         should stop. if no return value is useful, the generic
*         non-null value stop_traversal can be used.
*/
public object component component component
/**
* change object for undoing addition of behavior
*
* @author igor vaynberg (ivaynberg)
*/
private final class addedbehaviorchange extends change
private static final long serialversionuid   1l
private final ibehavior behavior
/**
* construct.
*
* @param behavior
*/
public addedbehaviorchange ibehavior behavior
this behavior   behavior
public string tostring
return     getclass   getname         behavior tostring
public void undo
behaviors remove behavior
if  behaviors size      0
behaviors   null
/**
* undo change for component border property
*
* @author ivaynberg
*/
private class componentborderchange extends change
private static final long serialversionuid   1l
private final icomponentborder old   getcomponentborder
public void undo
setcomponentborder old
/**
* change object for undoing removal of behavior
*
* @author igor vaynberg (ivaynberg)
*/
private final class removedbehaviorchange extends change
private static final long serialversionuid   1l
private final ibehavior behavior
/**
* construct.
*
* @param behavior
*/
public removedbehaviorchange ibehavior behavior
this behavior   behavior
public string tostring
return     getclass   getname         behavior tostring
public void undo
if  behaviors    null
behaviors   new arraylist 1
behaviors add behavior
/**
* a enabled change operation.
*/
protected final static class enabledchange extends change
private static final long serialversionuid   1l
/** subject. */
private final component component
/** former value. */
private final boolean enabled
/**
* construct.
*
* @param component
*/
enabledchange final component component
this component   component
this enabled   component getflag flag_enabled
/**
* @see java.lang.object#tostring()
*/
public string tostring
return     component getpath         enabled
/**
* @see org.apache.wicket.version.undo.change#undo()
*/
public void undo
component setenabled enabled
/**
* a visibility change operation.
*/
protected final static class visibilitychange extends change
private static final long serialversionuid   1l
/** subject. */
private final component component
/** former value. */
private final boolean visible
/**
* construct.
*
* @param component
*/
visibilitychange final component component
this component   component
this visible   component getflag flag_visible
/**
* @see java.lang.object#tostring()
*/
public string tostring
return     component getpath         visible
/**
* @see org.apache.wicket.version.undo.change#undo()
*/
public void undo
component setvisible visible
/**
* action used with iauthorizationstrategy to determine whether a component
* is allowed to be enabled.
* <p>
* if enabling is authorized, a component may decide by itself (typically
* using it's enabled property) whether it is enabled or not. if enabling is
* not authorized, the given component is marked disabled, regardless its
* enabled property.
* <p>
* when a component is not allowed to be enabled (in effect disabled through
* the implementation of this interface), wicket will try to prevent model
* updates too. this is not completely fail safe, as constructs like:
*
* <pre>
* user u = (user)getmodelobject();
* u.setname(&quot;got you there!&quot;);
* </pre>
*
* can't be prevented. indeed it can be argued that any model protection is
* best dealt with in your model objects to be completely secured. wicket
* will catch all normal framework-directed use though.
*/
public static final action enable   new action action enable
/** separator for component paths */
public static final char path_separator
/**
* action used with iauthorizationstrategy to determine whether a component
* and its children are allowed to be rendered.
* <p>
* there are two uses for this method:
* <ul>
* <li>the 'normal' use is for controlling whether a component is rendered
* without having any effect on the rest of the processing. if a strategy
* lets this method return 'false', then the target component and its
* children will not be rendered, in the same fashion as if that component
* had visibility property 'false'.</li>
* <li>the other use is when a component should block the rendering of the
* whole page. so instead of 'hiding' a component, what we generally want to
* achieve here is that we force the user to logon/give-credentials for a
* higher level of authorization. for this functionality, the strategy
* implementation should throw a {@link authorizationexception}, which will
* then be handled further by the framework.</li>
* </ul>
* </p>
*/
public static final action render   new action action render
/** meta data key for missing body tags logging. */
private static final metadatakey border_key   new metadatakey icomponentborder class
private static final long serialversionuid   1l
/** basic model imodelcomparator implementation for normal object models */
private static final imodelcomparator defaultmodelcomparator   new imodelcomparator
private static final long serialversionuid   1l
public boolean compare component component  object b
final object a   component getmodelobject
if  a    null    b    null
return true
if  a    null    b    null
return false
return a equals b
private static final int flag_after_rendering   0x8000000
/** true when a component is being auto-added */
private static final int flag_auto   0x0001
private static final int flag_before_rendering_super_call_verified   0x1000000
private static final int flag_detaching   0x80000000
/** true when a component is enabled for model updates and is reachable. */
private static final int flag_enabled   0x0080
/** flag for escaping html in model strings */
private static final int flag_escape_model_strings   0x0002
/**
* boolean whether this component was rendered at least once for tracking
* changes.
*/
private static final int flag_has_been_rendered   0x1000
/** ignore attribute modifiers */
private static final int flag_ignore_attribute_modifier   0x0040
/** flag for escaping html in model strings */
private static final int flag_inheritable_model   0x0004
/**
* internal indicator of whether this component may be rendered given the
* current context's authorization. it overrides the visible flag in case
* this is false. authorization is done before trying to render any
* component (otherwise we would end up with a half rendered page in the
* buffer)
*/
private static final int flag_is_render_allowed   0x2000
/**
* whether or not the component should print out its markup id into the id
* attribute
*/
private static final int flag_output_markup_id   0x4000
/**
* ouput a placeholder tag if the component is not visible. this is useful
* in ajax mode to go to visible(false) to visible(true) without the
* overhead of repaiting a visible parent container
*/
private static final int flag_placeholder   0x8000
/** render tag boolean */
private static final int flag_render_body_only   0x0020
private static final int flag_rendering   0x2000000
/** versioning boolean */
private static final int flag_versioned   0x0008
/** visibility boolean */
private static final int flag_visible   0x0010
/** log. */
private static final logger log   loggerfactory getlogger component class
/**
* the name of attribute that will hold markup id
*/
private static final string markup_id_attr_name
/**
* metadata key used to store/retrieve markup id
*/
private static metadatakey markup_id_key   new metadatakey string class
private static final long serialversionuid   1l
private static final long serialversionuid   1l
/** reserved subclass-definable flag bit */
protected static final int flag_reserved1   0x0100
/** reserved subclass-definable flag bit */
protected static final int flag_reserved2   0x0200
/** reserved subclass-definable flag bit */
protected static final int flag_reserved3   0x0400
/** reserved subclass-definable flag bit */
protected static final int flag_reserved4   0x0800
/** reserved subclass-definable flag bit */
protected static final int flag_reserved5   0x10000
/** reserved subclass-definable flag bit */
protected static final int flag_reserved6   0x20000
/** reserved subclass-definable flag bit */
protected static final int flag_reserved7   0x40000
/** reserved subclass-definable flag bit */
protected static final int flag_reserved8   0x80000
/**
* meta data key for line precise error logging for the moment of addition.
* made package private for access in {@link markupcontainer} and
* {@link page}
*/
static final metadatakey added_at_key   new metadatakey string class
private static final long serialversionuid   1l
/**
* meta data key for line precise error logging for the moment of
* construction. made package private for access in {@link page}
*/
static final metadatakey constructed_at_key   new metadatakey string class
private static final long serialversionuid   1l
static final int flag_attach_super_call_verified   0x10000000
static final int flag_attached   0x20000000
static final int flag_attaching   0x40000000
/** list of behaviors to be applied for this component */
private arraylist behaviors   null
/** component flags. see flag_* for possible non-exclusive flag values. */
private int flags   flag_visible   flag_escape_model_strings   flag_versioned   flag_enabled
flag_is_render_allowed
/** component id. */
private string id
/**
* metadataentry array.
*/
private metadataentry metadata
/** any parent container. */
private markupcontainer parent
/**
* i really dislike it, but for now we need it. reason: due to transparent
* containers and icomponentresolver there is guaranteed 1:1 mapping between
* component and markup
*/
int markupindex    1
/** the model for this component. */
imodel model
/**
* constructor. all components have names. a component's id cannot be null.
* this is the minimal constructor of component. it does not register a
* model.
*
* @param id
*            the non-null id of this component
* @throws wicketruntimeexception
*             thrown if the component has been given a null id.
*/
public component final string id
setid id
getapplication   notifycomponentinstantiationlisteners this
final idebugsettings debugsettings   application get   getdebugsettings
if  debugsettings getcomponentusecheck
setmetadata constructed_at_key  strings tostring this  new markupexception
/**
* constructor. all components have names. a component's id cannot be null.
* this constructor includes a model.
*
* @param id
*            the non-null id of this component
* @param model
*            the component's model
*
* @throws wicketruntimeexception
*             thrown if the component has been given a null id.
*/
public component final string id  final imodel model
setid id
getapplication   notifycomponentinstantiationlisteners this
this model   wrap model
final idebugsettings debugsettings   application get   getdebugsettings
if  debugsettings getcomponentusecheck
setmetadata constructed_at_key  strings tostring this  new markupexception
/**
* adds an behavior modifier to the component.
*
* <p>
* note: this method is override to enable users to do things like discussed
* in <a
* href="http://www.nabble.com/why-add%28ibehavior%29-is-final--tf2598263.html#a7248198">this
* thread</a>.
* </p>
*
* @param behavior
*            the behavior modifier to be added
* @return this (to allow method call chaining)
*/
public component add final ibehavior behavior
if  behavior    null
throw new illegalargumentexception
// lazy create
if  behaviors    null
behaviors   new arraylist 1
behaviors add behavior
if   behavior istemporary
addstatechange new addedbehaviorchange behavior
// give handler the opportunity to bind this component
behavior bind this
return this
/**
* called on very component after the page is renderd it will call
* onafterrender for it self and its childeren.
*/
public final void afterrender
// if the component has been previously attached via attach()
// detach it now
try
setflag flag_after_rendering  true
onafterrender
getapplication   notifycomponentonafterrenderlisteners this
if  getflag flag_after_rendering
throw new illegalstateexception
component class getname
getclass   getname
// always detach children because components can be attached
// independently of their parents
onafterrenderchildren
finally
// this flag must always be set to false.
setflag flag_rendering  false
/**
* attaches the component. this is called when the page is starting to be
* used for rendering or when a component listener call is executed on it.
*/
public final void attach
internalattach2
/**
* called for every component when the page is getting to be rendered. it
* will call onbeforerender for this component and all the child components
*/
public final void beforerender
if   getflag flag_rendering
setflag flag_before_rendering_super_call_verified  false
onbeforerender
getapplication   notifycomponentonbeforerenderlisteners this
if   getflag flag_before_rendering_super_call_verified
throw new illegalstateexception
component class getname
getclass   getname
onbeforerenderchildren
setflag flag_rendering  true
/**
* redirects to any intercept page previously specified by a call to
* redirecttointerceptpage.
*
* @return true if an original destination was redirected to
* @see component#redirecttointerceptpage(page)
*/
public final boolean continuetooriginaldestination
return getpage   getpagemap   continuetooriginaldestination
/**
* registers a debug feedback message for this component
*
* @param message
*            the feedback message
*/
public final void debug final string message
session get   getfeedbackmessages   debug this  message
/**
* detaches the component. this is called at the end of the request for all
* the pages that are touched in that request.
*/
public final void detach
// if the component has been previously attached via attach()
// detach it now
setflag flag_detaching  true
ondetach
if  getflag flag_detaching
throw new illegalstateexception component class getname
getclass   getname
setflag flag_attached  false
// always detach models because they can be attached without the
// component. eg component has a compoundpropertymodel and one of its
// children component's getmodelobject is called
detachmodels
// always detach children because components can be attached
// independently of their parents
detachchildren
// reset the model to null when the current model is a iwrapmodel and
// the model that created it/wrapped in it is a icomponentinheritedmodel
// the model will be created next time.
if  getflag flag_inheritable_model
model   null
setflag flag_inheritable_model  false
/**
* this is wicket internal only. do not use it.
*
* traverses all behaviors and calls detachmodel() on them. this is needed
* to cleanup behavior after render. this method is necessary for
* {@link ajaxrequesttarget} to be able to cleanup component's behaviors
* after header contribution has been done (which is separated from
* component render).
*/
public final void detachbehaviors
if  behaviors    null
for  iterator i   behaviors iterator    i hasnext
ibehavior behavior    ibehavior i next
// always detach models, 'accepted' or not. otherwise, if they
// are accepted during render, but not here - something can go
// undetached, and calling isenabled can also lead to nasty side
// effects. see for instance timo's comment on
// http://issues.apache.org/jira/browse/wicket-673
behavior detach this
if  behavior istemporary
i remove
/**
* detaches all models
*/
public void detachmodels
// detach any detachable model from this component
detachmodel
// detach any behaviors
detachbehaviors
/**
* registers an error feedback message for this component
*
* @param message
*            the feedback message
*/
public final void error final serializable message
session get   getfeedbackmessages   error this  message
/**
* registers an fatal error feedback message for this component
*
* @param message
*            the feedback message
*/
public final void fatal final string message
session get   getfeedbackmessages   fatal this  message
/**
* finds the first container parent of this component of the given class.
*
* @param c
*            markupcontainer class to search for
* @return first container parent that is an instance of the given class, or
*         null if none can be found
*/
public final markupcontainer findparent final class c
// start with immediate parent
markupcontainer current   parent
// walk up containment hierarchy
while  current    null
// is current an instance of this class?
if  c isinstance current
return current
// check parent
current   current getparent
// failed to find component
return null
/**
* @return the nearest markup container with associated markup
*/
public final markupcontainer findparentwithassociatedmarkup
markupcontainer container   parent
while  container    null
if  container hasassociatedmarkup
return container
container   container getparent
// this should never happen since page always has associated markup
throw new wicketruntimeexception
/**
* gets interface to application that this component is a part of.
*
* @return the application associated with the session that this component
*         is in.
* @see application
*/
public final application getapplication
return application get
/**
* gets the currently coupled {@link ibehavior}s as a unmodifiable list.
* returns an empty list rather than null if there are no behaviors coupled
* to this component.
*
* @return the currently coupled behaviors as a unmodifiable list
*/
public final list   <ibehavior>   getbehaviors
return getbehaviors null
/**
* @return a path of the form [page-class-name].[page-relative-path]
* @see component#getpagerelativepath()
*/
public final string getclassrelativepath
return getclass   getname     path_separator   getpagerelativepath
/**
* @return component border assigned to this component, or null if none
*/
public final icomponentborder getcomponentborder
return  icomponentborder getmetadata border_key
/**
* @return nothing, will always throw an exception. use
*         {@link #getconverter(class)} instead.
* @deprecated to be removed. please use/ override
*             {@link #getconverter(class)} instead.
*/
public final iconverter getconverter
throw new unsupportedoperationexception
/**
* gets the converter that should be used by this component.
*
* @param type
*            the type to convert to
*
* @return the converter that should be used by this component
*/
public iconverter getconverter class   <?>   type
return getapplication   getconverterlocator   getconverter type
/**
* gets whether model strings should be escaped.
*
* @return returns whether model strings should be escaped
*/
public final boolean getescapemodelstrings
return getflag flag_escape_model_strings
/**
* @return any feedback message for this component
*/
public final feedbackmessage getfeedbackmessage
return session get   getfeedbackmessages   messageforcomponent this
/**
* gets the id of this component.
*
* @return the id of this component
*/
public string getid
return id
/**
* @return innermost model for this component
*/
public final imodel getinnermostmodel
return getinnermostmodel getmodel
/**
* gets the locale for the session holding this component.
*
* @return the locale for the session holding this component
* @see component#getsession()
*/
public locale getlocale
return getsession   getlocale
/**
* convenience method to provide easy access to the localizer object within
* any component.
*
* @return the localizer object
*/
public final localizer getlocalizer
return getapplication   getresourcesettings   getlocalizer
/**
* this is wicket internal only. do not use it.
*
* get a copy of the markup's attributes which are associated with the
* component.
* <p>
* modifications to the map returned don't change the tags attributes. it is
* just a copy.
* <p>
* note: the component must have been added (directly or indirectly) to a
* container with an associated markup file (page, panel or border).
*
* @return markup attributes
*/
public final valuemap getmarkupattributes
markupstream markupstream   new markupfragmentfinder   find this
valuemap attrs   new valuemap markupstream gettag   getattributes
attrs makeimmutable
return attrs
/**
* retrieves id by which this component is represented within the markup.
* this is either the id attribute if it is set explicitly in the markup, or
* a generated id.
* <p>
* the point of this function is to generate a unique id to make it easy to
* locate this component in the generated markup for post-wicket processing
* such as javascript or an xslt transform in case no explicit id was set
* yet.
* <p>
* note: this method should only be called after the component or its parent
* have been added to the page.
*
* @return markup id of the component
*/
public string getmarkupid
string markupid    string getmetadata markup_id_key
if  markupid    null
page page   findpage
if  page    null
throw new wicketruntimeexception
// try to read from markup
// todo getting the id from markup doesn't work everywhere yet.
// unfortunately, we have to drop this until we have a good solution
// for issue http://issues.apache.org/jira/browse/wicket-694
// markupid = getmarkupattributes().getstring("id");
// if (markupid == null)
// {
// if not in the markup, generate one
markupid   getid     page getautoindex
// }
setmetadata markup_id_key  markupid
return markupid
/**
* gets metadata for this component using the given key.
*
* @param key
*            the key for the data
* @return the metadata or null of no metadata was found for the given key
* @see metadatakey
*/
public final serializable getmetadata final metadatakey key
return key get metadata
/**
* gets the model. it returns the object that wraps the backing model.
*
* @return the model
*/
public final imodel getmodel
// if model is null
if  model    null
// give subclass a chance to lazy-init model
this model   initmodel
return model
/**
* gets the backing model object; this is shorthand for
* getmodel().getobject().
*
* @return the backing model object
*/
public final object getmodelobject
final imodel model   getmodel
if  model    null
// get model value for this component.
return model getobject
else
return null
/**
* gets a model object as a string.
*
* @return model object for this component as a string
*/
public final string getmodelobjectasstring
return getmodelobjectasstring getmodelobject
/**
* @param modelobject
*            model object to convert to string
* @return the string
*/
public final string getmodelobjectasstring final object modelobject
if  modelobject    null
// get converter
final iconverter converter   getconverter modelobject getclass
// model string from property
final string modelstring   converter converttostring modelobject  getlocale
if  modelstring    null
// if we should escape the markup
if  getflag flag_escape_model_strings
// escape it
return strings escapemarkup modelstring  false  true  tostring
return modelstring
return
/**
* gets whether or not component will output id attribute into the markup.
* id attribute will be set to the value returned from
* {@link component#getmarkupid()}.
*
* @return whether or not component will output id attribute into the markup
*/
public final boolean getoutputmarkupid
return getflag flag_output_markup_id
/**
* gets the page holding this component.
*
* @return the page holding this component
* @throws illegalstateexception
*             thrown if component is not yet attached to a page.
*/
public final page getpage
// search for nearest page
final page page   findpage
// if no page was found
if  page    null
// give up with a nice exception
throw new illegalstateexception     this
return page
/**
* @return the page factory for the session that this component is in
*/
public final ipagefactory getpagefactory
return getsession   getpagefactory
/**
* gets the path to this component relative to the page it is in.
*
* @return the path to this component relative to the page it is in
*/
public final string getpagerelativepath
return strings afterfirstpathcomponent getpath    path_separator
/**
* gets any parent container, or null if there is none.
*
* @return any parent container, or null if there is none
*/
public final markupcontainer getparent
return parent
/**
* gets this component's path.
*
* @return colon separated path to this component in the component hierarchy
*/
public final string getpath
final prependingstringbuffer buffer   new prependingstringbuffer 32
for  component c   this  c    null  c   c getparent
if  buffer length   > 0
buffer prepend path_separator
buffer prepend c getid
return buffer tostring
/**
* if false the component's tag will be printed as well as its body (which
* is default). if true only the body will be printed, but not the
* component's tag.
*
* @return if true, the component tag will not be printed
*/
public final boolean getrenderbodyonly
return getflag flag_render_body_only
/**
* @return the request for this component's active request cycle
*/
public final request getrequest
requestcycle requestcycle   getrequestcycle
if  requestcycle    null
// happens often with wickettester when one forgets to call createrequestcycle()
throw new wicketruntimeexception
return requestcycle getrequest
/**
* gets the active request cycle for this component
*
* @return the request cycle
*/
public final requestcycle getrequestcycle
return requestcycle get
/**
* @return the response for this component's active request cycle
*/
public final response getresponse
return getrequestcycle   getresponse
/**
* gets the current session object.
*
* @return the session that this component is in
*/
public final session getsession
return session get
/**
* @return size of this component in bytes
*/
public long getsizeinbytes
final markupcontainer originalparent   this parent
this parent   null
long size    1
try
size   objects sizeof this
catch  exception e
log error     this  e
this parent   originalparent
return size
/**
* @param key
*            key of string resource in property file
* @return the string
* @see localizer
*/
public final string getstring final string key
return getstring key  null
/**
* @param key
*            the resource key
* @param model
*            the model
* @return the formatted string
* @see localizer
*/
public final string getstring final string key  final imodel model
return getlocalizer   getstring key  this  model
/**
* @param key
*            the resource key
* @param model
*            the model
* @param defaultvalue
*            a default value if the string cannot be found
* @return the formatted string
* @see localizer
*/
public final string getstring final string key  final imodel model  final string defaultvalue
return getlocalizer   getstring key  this  model  defaultvalue
/**
* gets the style of this component (see {@link org.apache.wicket.session}).
*
* @return the style of this component.
*
* @see org.apache.wicket.session
* @see org.apache.wicket.session#getstyle()
*/
public final string getstyle
string variation   getvariation
string style   getsession   getstyle
if  variation    null       equals variation
if  style    null       equals style
style   variation       style
else
style   variation
return style
/**
* gets the variation string of this component that will be used to look up
* markup for this component. subclasses can override this method to define
* by an instance what markup variation should be picked up. by default it
* will return null.
*
* @return the variation of this component.
*/
public string getvariation
return null
/**
* gets whether this component was rendered at least once.
*
* @return true if the component has been rendered before, false if it is
*         merely constructed
*/
public final boolean hasbeenrendered
return getflag flag_has_been_rendered
/**
* @return true if this component has an error message
*/
public final boolean haserrormessage
return session get   getfeedbackmessages   haserrormessagefor this
/**
* @return true if this component has some kind of feedback message
*/
public final boolean hasfeedbackmessage
return session get   getfeedbackmessages   hasmessagefor this
/**
* registers an informational feedback message for this component
*
* @param message
*            the feedback message
*/
public final void info final string message
session get   getfeedbackmessages   info this  message
/**
* @deprecated
*/
// todo remove after deprecation release
public final void internalattach
throw new unsupportedoperationexception
/**
* @deprecated
*/
// todo remove after deprecation release
public final void internaldetach
throw new unsupportedoperationexception
/**
* authorizes an action for a component.
*
* @param action
*            the action to authorize
* @return true if the action is allowed
* @throws authorizationexception
*             can be thrown by implementation if action is unauthorized
*/
public final boolean isactionauthorized action action
iauthorizationstrategy authorizationstrategy   getsession   getauthorizationstrategy
if  authorizationstrategy    null
return authorizationstrategy isactionauthorized this  action
return true
/**
* returns true if this component is an ancestor of the given component
*
* @param component
*            the component to check
* @return true if the given component has this component as an ancestor
* @deprecated use getparent().contains(component, false)
*/
public final boolean isancestorof final component component
return getparent   contains component  false
// // walk up containment hierarchy
// for (markupcontainer current = component.parent; current != null;
// current = current
// .getparent())
// {
// // is this an ancestor?
// if (current == this)
// {
// return true;
// }
// }
//
// // this component is not an ancestor of the given component
// return false;
/**
* @return true if this component is authorized to be enabled, false
*         otherwise
*/
public final boolean isenableallowed
return isactionauthorized enable
/**
* gets whether this component is enabled. specific components may decide to
* implement special behavior that uses this property, like web form
* components that add a disabled='disabled' attribute when enabled is
* false.
*
* @return whether this component is enabled.
*/
public boolean isenabled
return getflag flag_enabled
/**
* returns if the component is stateless or not. it checks the stateless
* hint if that is false it returns directly false. if that is still true it
* checks all its behaviours if they can be stateless.
*
* @return whether the component is stateless.
*/
public final boolean isstateless
if   getstatelesshint
return false
final iterator behaviors   getbehaviors   iterator
while  behaviors hasnext
ibehavior behavior    ibehavior behaviors next
if   behavior getstatelesshint this
return false
return true
/**
* @return true if this component is versioned
*/
public boolean isversioned
// is the component itself versioned?
if   getflag flag_versioned      getflag flag_has_been_rendered
return false
else
// if there's a parent and this component is versioned
if  parent    null
// check if the parent is unversioned. if any parent
// (recursively) is unversioned, then this component is too
if   parent isversioned
return false
return true
/**
* gets whether this component and any children are visible.
* <p>
* warning: this method can be called multiple times during a request. if
* you override this method, it is a good idea to keep it cheap in terms of
* processing. alternatively, you can call {@link #setvisible(boolean)}.
* <p>
*
* @return true if component and any children are visible
*/
public boolean isvisible
return getflag flag_visible
/**
* checks if the component itself and all its parents are visible.
*
* @return true if the component and all its parents are visible.
*/
public final boolean isvisibleinhierarchy
component component   this
while  component    null
if  component isrenderallowed      component isvisible
component   component getparent
else
return false
return true
/**
* called to indicate that the model content for this component has been
* changed
*/
public final void modelchanged
// call user code
internalonmodelchanged
onmodelchanged
/**
* called to indicate that the model content for this component is about to
* change
*/
public final void modelchanging
checkhierarchychange this
// call user code
onmodelchanging
// tell the page that our model changed
final page page   findpage
if  page    null
page componentmodelchanging this
/**
* creates a new page using the component's page factory
*
* @param c
*            the class of page to create
* @return the new page
*/
public final page newpage final class c
return getpagefactory   newpage c
/**
* creates a new page using the component's page factory
*
* @param c
*            the class of page to create
* @param parameters
*            any parameters to pass to the constructor
* @return the new page
*/
public final page newpage final class c  final pageparameters parameters
return getpagefactory   newpage c  parameters
/**
* redirects browser to an intermediate page such as a sign-in page. the
* current request's url is saved for future use by method
* continuetooriginaldestination(); only use this method when you plan to
* continue to the current url at some later time; otherwise just use
* setresponsepage or - when you are in a constructor or checkaccessmethod,
* call redirectto.
*
* @param page
*            the sign in page
*
* @see component#continuetooriginaldestination()
*/
public final void redirecttointerceptpage final page page
getpage   getpagemap   redirecttointerceptpage page
/**
* removes this component from its parent. it's important to remember that a
* component that is removed cannot be referenced from the markup still.
*/
public final void remove
if  parent    null
throw new illegalstateexception     this
parent remove this
/**
* removes behavior from component
*
* @param behavior
*            behavior to remove
*
* @return this (to allow method call chaining)
*/
public component remove final ibehavior behavior
if  behavior    null
throw new illegalargumentexception
if  behaviors    null     behaviors contains behavior
throw new illegalstateexception
behavior tostring
if   behavior istemporary
addstatechange new removedbehaviorchange behavior
behaviors remove behavior
if  behaviors size      0
behaviors   null
return this
/**
* performs a render of this component as part of a page level render
* process.
* <p>
* for component level re-render (e.g. ajax) please call
* {@link #rendercomponent()}. though render() does seem to work, it will
* fail for panel children.
*/
public final void render
// allow currently invisible components to be re-rendered as well
markupstream markupstream   null
if  getparent      null
markupstream   findmarkupstream
render markupstream
/**
* performs a render of this component as part of a page level render
* process.
* <p>
* for component level re-render (e.g. ajax) please call
* {@link #rendercomponent(markupstream)}. though render() does seem to
* work, it will fail for panel children.
*
* @param markupstream
*/
public final void render final markupstream markupstream
setmarkupstream markupstream
setflag flag_has_been_rendered  true
// determine if component is visible using it's authorization status
// and the isvisible property.
if  isrenderallowed      isvisible
// rendering is beginning
if  log isdebugenabled
log debug     this
try
// call implementation to render component
notifybehaviorscomponentbeforerender
final icomponentborder border   getcomponentborder
if  border    null
border renderbefore this
onrender markupstream
if  border    null
border renderafter this
// component has been rendered
rendered
catch  runtimeexception ex
// call each behaviors onexception() to allow the
// behavior to clean up
if  behaviors    null
for  iterator i   behaviors iterator    i hasnext
ibehavior behavior    ibehavior i next
if  isbehavioraccepted behavior
try
behavior exception this  ex
catch  throwable ex2
log error    ex2
// re-throw the exception
throw ex
if  log isdebugenabled
log debug     this
else
if  getflag flag_placeholder
// write out a placeholder tag into the markup
final componenttag tag   markupstream gettag
getresponse   write
getresponse   write tag getname
getresponse   write  "
getresponse   write getmarkupid
getresponse   write   style   >< "
getresponse   write tag getname
getresponse   write
markupstream skipcomponent
/**
* page.renderpage() is used to render a whole page. with ajax however it
* must be possible to render any one component contained in a page. that is
* what this method is for.
* <p>
* note: it is not necessary that the page has previously been rendered. but
* the component must have been added (directly or indirectly) to a
* container with an associated markup file (page, panel or border).
*/
public final void rendercomponent
// if this component is a page
if  this instanceof page
// render as page, with all the special logic that entails
page this  renderpage
else
// save the parent's markup stream to re-assign it at the end
markupcontainer parent   getparent
markupstream originalmarkupstream   parent getmarkupstream
markupstream markupstream   new markupfragmentfinder   find this
try
// make sure that while rendering the markup stream is found
parent setmarkupstream markupstream
beforerender
// check authorization
// first the component itself
// (after attach as otherwise list views etc wont work)
setrenderallowed isactionauthorized render
// check children if this is a container
if  this instanceof markupcontainer
markupcontainer container    markupcontainer this
container visitchildren new ivisitor
public object component final component component
// find out if this component can be rendered
final boolean renderallowed   component isactionauthorized render
// authorize rendering
component setrenderallowed renderallowed
return ivisitor continue_traversal
// render the component and all its children
render markupstream
finally
// make sure the original markup stream is back in place
parent setmarkupstream originalmarkupstream
afterrender
/**
* this method is not part of the wicket public api. do not use it.
* <p>
* renders the component at the current position in the given markup stream.
* the method oncomponenttag() is called to allow the component to mutate
* the start tag. the method oncomponenttagbody() is then called to permit
* the component to render its body.
*
* @param markupstream
*            the markup stream
*/
public final void rendercomponent final markupstream markupstream
this markupindex   markupstream getcurrentindex
// get mutable copy of next tag
final componenttag opentag   markupstream gettag
final componenttag tag   opentag mutable
// call any tag handler
oncomponenttag tag
// if we're an openclose tag
if   tag isopenclose       tag isopen
// we were something other than <tag> or <tag/>
markupstream
throwmarkupexception
tag
if  tag isopenclose      opentag isopen
markupstream
throwmarkupexception     tag
try
// render open tag
if  getrenderbodyonly      false
rendercomponenttag tag
markupstream next
// render the body only if open-body-close. do not render if
// open-close.
if  tag isopen
// render the body
oncomponenttagbody markupstream  tag
// render close tag
if  tag isopen
if  opentag isopen
renderclosingcomponenttag markupstream  tag  getrenderbodyonly
else
// if a open-close tag has been to modified to be
// open-body-close than a synthetic close tag must be
// rendered.
if  getrenderbodyonly      false
// close the manually opened panel tag.
getresponse   write opentag syntheticclosetagstring
catch  runtimeexception re
if  re instanceof wicketruntimeexception    re instanceof abortexception
throw re
throw new wicketruntimeexception     this  re
/**
* called to indicate that a component has been rendered. this method should
* only very rarely be called at all. one usage is in imagemap, which
* renders its link children its own special way (without calling render()
* on them). if imagemap did not call rendered() to indicate that its child
* components were actually rendered, the framework would think they had
* never been rendered, and in development mode this would result in a
* runtime exception.
*/
public final void rendered
notifybehaviorscomponentrendered
// tell the page that the component rendered
getpage   componentrendered this
/**
* print to the web response what ever the component wants to contribute to
* the head section. make sure that all attached behaviors are asked as
* well.
* <p>
* not intended for overriding by framework clients. rather, use
* {@link iheadercontributor#renderhead(org.apache.wicket.markup.html.iheaderresponse)}
* </p>
*
* @param container
*            the htmlheadercontainer
*/
public void renderhead final htmlheadercontainer container
if  isvisible
if  this instanceof iheadercontributor
iheadercontributor this  renderhead container getheaderresponse
// ask all behaviors if they have something to contribute to the
// header or body onload tag.
if  this behaviors    null
final iterator iter   this behaviors iterator
while  iter hasnext
ibehavior behavior    ibehavior iter next
if  behavior instanceof iheadercontributor    isbehavioraccepted behavior
iheadercontributor behavior  renderhead container getheaderresponse
/**
* replaces this component with another. the replacing component must have
* the same component id as this component. this method serves as a shortcut
* to <code>this.getparent().replace(replacement)</code> and provides a
* better context for errors.
*
* @since 1.2.1
*
* @param replacement
*            component to replace this one
*/
public void replacewith component replacement
if  replacement    null
throw new illegalargumentexception
if   getid   equals replacement getid
throw new illegalargumentexception
replacement getid         getid
if  parent    null
throw new illegalstateexception
parent replace replacement
/**
* @param component
*            the component to compare with
* @return true if the given component's model is the same as this
*         component's model.
*/
public final boolean sameinnermostmodel final component component
return sameinnermostmodel component getmodel
/**
* @param model
*            the model to compare with
* @return true if the given component's model is the same as this
*         component's model.
*/
public final boolean sameinnermostmodel final imodel model
// get the two models
imodel thismodel   getmodel
imodel thatmodel   model
// if both models are non-null they could be the same
if  thismodel    null    thatmodel    null
return getinnermostmodel thismodel     getinnermostmodel thatmodel
return false
/**
* assigns a component border to this component. if called with
* <code>null</code> any previous border will be cleared.
*
* @param border
*            componnet border to assign, or <code>null</code> to clear
*            any previous
* @return component for chaining
*/
public final component setcomponentborder final icomponentborder border
if   objects equal getcomponentborder    border
addstatechange new componentborderchange
setmetadata border_key  border
return this
/**
* sets whether this component is enabled. specific components may decide to
* implement special behavior that uses this property, like web form
* components that add a disabled='disabled' attribute when enabled is
* false. if it is not enabled, it will not be allowed to call any listener
* method on it (e.g. link.onclick) and the model object will be protected
* (for the common use cases, not for programmer's misuse)
*
* @param enabled
*            whether this component is enabled
* @return this
*/
public final component setenabled final boolean enabled
// is new enabled state a change?
if  enabled    getflag flag_enabled
// tell the page that this component's enabled was changed
if  isversioned
final page page   findpage
if  page    null
addstatechange new enabledchange this
// change visibility
setflag flag_enabled  enabled
return this
/**
* sets whether model strings should be escaped.
*
* @param escapemarkup
*            true is model strings should be escaped
* @return this
*/
public final component setescapemodelstrings final boolean escapemarkup
setflag flag_escape_model_strings  escapemarkup
return this
/**
* sets the metadata for this component using the given key. if the metadata
* object is not of the correct type for the metadata key, an
* illegalargumentexception will be thrown. for information on creating
* metadatakeys, see {@link metadatakey}.
*
* @param key
*            the singleton key for the metadata
* @param object
*            the metadata object
* @throws illegalargumentexception
* @see metadatakey
*/
public final void setmetadata final metadatakey key  final serializable object
metadata   key set metadata  object
/**
* sets the given model.
* <p>
* warning: do not override this method unless you have a very good reason
* for it. overriding this might open up security leaks and break
* back-button support.
* </p>
*
* @param model
*            the model
* @return this
*/
public component setmodel final imodel model
// detach current model
if  this model    null
this model detach
imodel prevmodel   this model
if  prevmodel instanceof iwrapmodel
prevmodel     iwrapmodel prevmodel  getwrappedmodel
// change model
if  prevmodel    model
if  prevmodel    null
addstatechange new componentmodelchange prevmodel
this model   wrap model
modelchanged
return this
/**
* sets the backing model object; shorthand for
* getmodel().setobject(object).
*
* @param object
*            the object to set
* @return this
*/
public final component setmodelobject final object object
final imodel model   getmodel
// check whether anything can be set at all
if  model    null
throw new illegalstateexception
getpagerelativepath
// check authorization
if   isactionauthorized enable
throw new unauthorizedactionexception this  enable
// check whether this will result in an actual change
if   getmodelcomparator   compare this  object
modelchanging
model setobject object
modelchanged
return this
/**
* sets whether or not component will output id attribute into the markup.
* id attribute will be set to the value returned from
* {@link component#getmarkupid()}.
*
* @param output
* @return this for chaining
*/
public final component setoutputmarkupid final boolean output
setflag flag_output_markup_id  output
return this
/**
* render a placeholder tag when the component is not visible. the tag is of
* form: &lt;componenttag style="display:none;" id="componentid"/&gt;. this
* method will also call <code>setoutputmarkupid(true)</code>.
*
* this is useful, for example, in ajax situations where the component
* starts out invisible and then becomes visible through an ajax update.
* with a placeholder tag already in the markup you do not need to repaint
* this component's parent, instead you can repaint the component directly.
*
* when this method is called with parameter <code>false</code> the
* outputmarkupid flag is not reverted to false.
*
* @param outputtag
* @return this for chaining
*/
public final component setoutputmarkupplaceholdertag final boolean outputtag
if  outputtag    getflag flag_placeholder
if  outputtag
setoutputmarkupid true
setflag flag_placeholder  true
else
setflag flag_placeholder  false
// i think it's better to not setoutputmarkupid to false...
// user can do it if we want
return this
/**
* @param redirect
*            true if the response should be redirected to
* @see requestcycle#setredirect(boolean)
*/
public final void setredirect final boolean redirect
getrequestcycle   setredirect redirect
/**
* if false the component's tag will be printed as well as its body (which
* is default). if true only the body will be printed, but not the
* component's tag.
*
* @param rendertag
*            if true, the component tag will not be printed
* @return this
*/
public final component setrenderbodyonly final boolean rendertag
this setflag flag_render_body_only  rendertag
return this
/**
* sets the page that will respond to this request
*
* @param cls
*            the response page class
* @see requestcycle#setresponsepage(class)
*/
public final void setresponsepage final class cls
getrequestcycle   setresponsepage cls
/**
* sets the page class and its parameters that will respond to this request
*
* @param cls
*            the response page class
* @param parameters
*            the parameters for thsi bookmarkable page.
* @see requestcycle#setresponsepage(class, pageparameters)
*/
public final void setresponsepage final class cls  pageparameters parameters
getrequestcycle   setresponsepage cls  parameters
/**
* sets the page that will respond to this request
*
* @param page
*            the response page
* @see requestcycle#setresponsepage(page)
*/
public final void setresponsepage final page page
getrequestcycle   setresponsepage page
/**
* @param versioned
*            true to turn on versioning for this component, false to turn
*            it off for this component and any children.
* @return this
*/
public component setversioned boolean versioned
setflag flag_versioned  versioned
return this
/**
* sets whether this component and any children are visible.
*
* @param visible
*            true if this component and any children should be visible
* @return this
*/
public final component setvisible final boolean visible
// is new visibility state a change?
if  visible    getflag flag_visible
// record component's visibility change
addstatechange new visibilitychange this
// change visibility
setflag flag_visible  visible
return this
/**
* gets the string representation of this component.
*
* @return the path to this component
*/
public string tostring
return tostring true
/**
* @param detailed
*            true if a detailed string is desired
* @return the string
*/
public string tostring final boolean detailed
if  detailed
final page page   findpage
if  page    null
return new stringbuffer    append getid    append
append getpath    append    append
classes simplename getclass     append    tostring
else
return new stringbuffer    append getid    append
append getpage   getclass   getname    append    append
getpath    append    append classes simplename getclass
append    append  isrenderallowed      isvisible
append    append isversioned    append    tostring
else
return     getid
/**
* returns a bookmarkable url that references a given page class using a
* given set of page parameters. since the url which is returned contains
* all information necessary to instantiate and render the page, it can be
* stored in a user's browser as a stable bookmark.
*
* @see requestcycle#urlfor(pagemap, class, pageparameters)
*
* @param pageclass
*            class of page
* @param parameters
*            parameters to page
* @return bookmarkable url to page
*/
public final charsequence urlfor final class pageclass  final pageparameters parameters
return getrequestcycle   urlfor getpage   getpagemap    pageclass  parameters
/**
* gets a url for the listener interface on a behaviour (e.g.
* ibehaviorlistener on ajaxpagingnavigationbehavior).
*
* @param behaviour
*            the behaviour that the url should point to
* @param listener
*            the listener interface that the url should call
* @return the url
*/
public final charsequence urlfor final ibehavior behaviour
final requestlistenerinterface listener
return getrequestcycle   urlfor this  behaviour  listener
/**
* returns a bookmarkable url that references a given page class using a
* given set of page parameters. since the url which is returned contains
* all information necessary to instantiate and render the page, it can be
* stored in a user's browser as a stable bookmark.
*
* @see requestcycle#urlfor(pagemap, class, pageparameters)
*
* @param pagemap
*            page map to use
* @param pageclass
*            class of page
* @param parameters
*            parameters to page
*
*
* @return bookmarkable url to page
*/
public final charsequence urlfor final ipagemap pagemap  final class pageclass
final pageparameters parameters
return getrequestcycle   urlfor pagemap  pageclass  parameters
/**
* returns a url that references the given request target.
*
* @see requestcycle#urlfor(irequesttarget)
*
* @param requesttarget
*            the request target to reference
*
* @return a url that references the given request target
*/
public final charsequence urlfor final irequesttarget requesttarget
return getrequestcycle   urlfor requesttarget
/**
* gets a url for the listener interface (e.g. ilinklistener).
*
* @param listener
*            the listener interface that the url should call
* @return the url
*/
public final charsequence urlfor final requestlistenerinterface listener
return getrequestcycle   urlfor this  listener
/**
* returns a url that references a shared resource through the provided
* resource reference.
*
* @see requestcycle#urlfor(resourcereference)
*
* @param resourcereference
*            the resource reference
* @return the url for the shared resource
*/
public final charsequence urlfor final resourcereference resourcereference
return getrequestcycle   urlfor resourcereference
/**
* traverses all parent components of the given class in this container,
* calling the visitor's visit method at each one.
*
* @param c
*            class
* @param visitor
*            the visitor to call at each parent of the given type
* @return first non-null value returned by visitor callback
*/
public final object visitparents final class c  final ivisitor visitor
// start here
component current   this
// walk up containment hierarchy
while  current    null
// is current an instance of this class?
if  c isinstance current
final object object   visitor component current
if  object    ivisitor continue_traversal
return object
// check parent
current   current getparent
return null
/**
* registers a warning feedback message for this component.
*
* @param message
*            the feedback message
*/
public final void warn final string message
session get   getfeedbackmessages   warn this  message
/**
* {@link ibehavior#beforerender(component)} notify all behaviors that are
* assigned to this component that the component is about to be rendered.
*/
private void notifybehaviorscomponentbeforerender
if  behaviors    null
for  iterator i   behaviors iterator    i hasnext
ibehavior behavior    ibehavior i next
if  isbehavioraccepted behavior
behavior beforerender this
/**
* {@link ibehavior#afterrender(component)} notify all behaviors that are
* assigned to this component that the component has rendered.
*/
private void notifybehaviorscomponentrendered
// notify the behaviors that component has been rendered
if  behaviors    null
for  iterator i   behaviors iterator    i hasnext
ibehavior behavior    ibehavior i next
if  isbehavioraccepted behavior
behavior afterrender this
/**
* adds state change to page.
*
* @param change
*            the change
*/
protected final void addstatechange final change change
checkhierarchychange this
final page page   findpage
if  page    null
page componentstatechanging this  change
/**
* checks whether the given type has the expected name.
*
* @param tag
*            the tag to check
* @param name
*            the expected tag name
* @throws markupexception
*             thrown if the tag is not of the right name
*/
protected final void checkcomponenttag final componenttag tag  final string name
if   tag getname   equalsignorecase name
findmarkupstream   throwmarkupexception
getid         name
tag touserdebugstring
/**
* checks that a given tag has a required attribute value.
*
* @param tag
*            the tag
* @param key
*            the attribute key
* @param value
*            the required value for the attribute key
* @throws markupexception
*             thrown if the tag does not have the required attribute value
*/
protected final void checkcomponenttagattribute final componenttag tag  final string key
final string value
if  key    null
final string tagattributevalue   tag getattributes   getstring key
if  tagattributevalue    null     value equalsignorecase tagattributevalue
findmarkupstream   throwmarkupexception
getid         key
value       tagattributevalue
/**
* checks whether the hierarchy may be changed at all, and throws an
* exception if this is not the case.
*
* @param component
*            the component which is about to be added or removed
*/
protected void checkhierarchychange final component component
// throw exception if modification is attempted during rendering
if   component isauto      getflag flag_rendering
throw new wicketruntimeexception
// throw exception if modification is attempted during attach
if  getflag flag_attaching
throw new wicketruntimeexception
/**
* detaches the model for this component if it is detachable.
*/
protected void detachmodel
if  model    null
model detach
/**
* prefixes an exception message with useful information about this.
* component.
*
* @param message
*            the message
* @return the modified message
*/
protected final string exceptionmessage final string message
return message       tostring
/**
* finds the markup stream for this component.
*
* @return the markup stream for this component. since a component cannot
*         have a markup stream, we ask this component's parent to search
*         for it.
*/
protected markupstream findmarkupstream
if  parent    null
throw new illegalstateexception     this
return parent findmarkupstream
/**
* if this component is a page, returns self. otherwise, searches for the
* nearest page parent in the component hierarchy. if no page parent can be
* found, null is returned.
*
* @return the page or null if none can be found
*/
protected final page findpage
// search for page
return  page  this instanceof page ? this   findparent page class
/**
* gets the subset of the currently coupled {@link ibehavior}s that are of
* the provided type as a unmodifiable list or null if there are no
* behaviors attached. returns an empty list rather than null if there are
* no behaviors coupled to this component.
*
* @param type
*            the type or null for all
*
* @return the subset of the currently coupled behaviors that are of the
*         provided type as a unmodifiable list or null
*/
protected list   <ibehavior>   getbehaviors class type
if  behaviors    null
return collections empty_list
list subset   new arraylist behaviors size        avoid growing
for  iterator i   behaviors iterator    i hasnext
object behavior   i next
if  type    null    type isassignablefrom behavior getclass
subset add behavior
return collections unmodifiablelist subset
/**
* this method is not part of the wicket public api. do not use it!
*
* @param flag
*            the flag to test
* @return true if the flag is set
*/
protected final boolean getflag final int flag
return  this flags   flag     0
/**
* this method is not part of the wicket public api. do not use it!
*
* @param flag
*            the flag to test
* @return true if the flag is set
*/
protected final boolean getflag final short flag
return getflag  int flag
/**
* finds the innermost imodel object for an imodel that might contain nested
* imodel(s).
*
* @param model
*            the model
* @return the innermost (most nested) model
*/
protected final imodel getinnermostmodel final imodel model
imodel nested   model
while  nested    null    nested instanceof iwrapmodel
final imodel next     iwrapmodel nested  getwrappedmodel
if  nested    next
throw new wicketruntimeexception     nested
nested   next
return nested
/**
* gets the value defaultmodelcomparator. implementations of this interface
* can be used in the component.getcomparator() for testing the current
* value of the components model data with the new value that is given.
*
* @return the value defaultmodelcomparator
*/
protected imodelcomparator getmodelcomparator
return defaultmodelcomparator
/**
* returns whether the component can be stateless. being able to be
* stateless doesn't necessary mean, that the component should be stateless.
* whether the component should be stateless depends on
*
* @return whether the component can be stateless
*/
protected boolean getstatelesshint
return true
/**
* called when a null model is about to be retrieved in order to allow a
* subclass to provide an initial model. this gives formcomponent, for
* example, an opportunity to instantiate a model on the fly using the
* containing form's model.
*
* @return the model
*/
protected imodel initmodel
// search parents for compoundpropertymodel
for  component current   getparent    current    null  current   current getparent
// get model
// dont call the getmodel() that could initialize many inbetween
// completely useless models.
// imodel model = current.getmodel();
imodel model   current model
if  model instanceof iwrapmodel
model     iwrapmodel model  getwrappedmodel
if  model instanceof icomponentinheritedmodel
// we turn off versioning as we share the model with another
// component that is the owner of the model (that component
// has to decide whether to version or not
// todo can we really do this?? model shouldn't versioned but
// all other things?? (add/remove)
setversioned false
// return the shared inherited
model     icomponentinheritedmodel model  wraponinheritance this
setflag flag_inheritable_model  true
return model
// no model for this component!
return null
/**
* this method is not part of the wicket public api. do not call or
* override.
*
* called when a request begins.
*
* @deprecated use {@link #onbeforerender()} instead
*/
protected final void internalonattach
/**
* this method is not part of the wicket public api. do not call or
* override.
*
* called when a request ends.
*
* @deprecated use {@link #onbeforerender()} instead
*
*/
protected final void internalondetach
/**
* this method is not part of the wicket public api. do not call or
* override.
*
* called anytime a model is changed via setmodel or setmodelobject.
*/
protected void internalonmodelchanged
/**
* @return true if this component is attached
*/
protected final boolean isattached
return getflag flag_attached
/**
* components are allowed to reject behavior modifiers.
*
* @param behavior
* @return false, if the component should not apply this behavior
*/
protected boolean isbehavioraccepted final ibehavior behavior
// ignore attributemodifiers when flag_ignore_attribute_modifier is set
if   behavior instanceof attributemodifier
getflag flag_ignore_attribute_modifier     false
return false
return behavior isenabled this
/**
* if true, all attribute modifiers will be ignored
*
* @return true, if attribute modifiers are to be ignored
*/
protected final boolean isignoreattributemodifier
return this getflag flag_ignore_attribute_modifier
protected final boolean isrenderallowed
return getflag flag_is_render_allowed
/**
* called just after a component is rendered.
*/
protected void onafterrender
setflag flag_after_rendering  false
/**
* called to allow a component to attach resources for use.
*
* overrides of this method must call the super implementation, the most
* logical place to do this is the first line of the override method.
*
*/
protected void onattach
setflag flag_attach_super_call_verified  true
/**
* called just before a component is rendered. if you override this, you
* *must* call super.onbeforerender() within your implementation.
*/
protected void onbeforerender
setflag flag_before_rendering_super_call_verified  true
/**
* @deprecated use onattach() instead
*/
// todo remove after the deprecation release
protected final void onbeginrequest
throw new unsupportedoperationexception
/**
* processes the component tag.
*
* @param tag
*            tag to modify
*/
protected void oncomponenttag final componenttag tag
if  getflag flag_output_markup_id      tag getattributes   containskey markup_id_attr_name
tag put markup_id_attr_name  getmarkupid
/**
* processes the body.
*
* @param markupstream
*            the markup stream
* @param opentag
*            the open tag for the body
*/
protected void oncomponenttagbody final markupstream markupstream  final componenttag opentag
/**
* called to allow a component to detach resources after use.
*
* overrides of this method must call the super implementation, the most
* logical place to do this is the last line of the override method.
*
*
*/
protected void ondetach
if  behaviors    null
behaviors trimtosize
setflag flag_detaching  false
/**
* @deprecated use ondetach() instead
*/
// todo remove after the deprecation release
protected final void onendrequest
throw new unsupportedoperationexception
/**
* called anytime a model is changed after the change has occurred
*/
protected void onmodelchanged
/**
* called anytime a model is changed, but before the change actually occurs
*/
protected void onmodelchanging
/**
* implementation that renders this component.
*
* @since wicket 1.2
* @param markupstream
*/
protected abstract void onrender final markupstream markupstream
/**
* writes a simple tag out to the response stream. any components that might
* be referenced by the tag are ignored. also undertakes any tag attribute
* modifications if they have been added to the component.
*
* @param tag
*            the tag to write
*/
protected final void rendercomponenttag componenttag tag
final boolean stripwickettags   application get   getmarkupsettings   getstripwickettags
if    tag instanceof wickettag      stripwickettags
// apply behavior modifiers
if   behaviors    null      behaviors isempty       tag isclose
isignoreattributemodifier      false
tag   tag mutable
for  iterator i   behaviors iterator    i hasnext
ibehavior behavior    ibehavior i next
// components may reject some behavior components
if  isbehavioraccepted behavior
behavior oncomponenttag this  tag
// apply behaviors that are attached to the component tag.
if  tag hasbehaviors
iterator behaviors   tag getbehaviors
while  behaviors hasnext
final ibehavior behavior    ibehavior behaviors next
behavior oncomponenttag this  tag
// write the tag
tag writeoutput getresponse    stripwickettags  this findmarkupstream
getwicketnamespace
/**
* replaces the body with the given one.
*
* @param markupstream
*            the markup stream to replace the tag body in
* @param tag
*            the tag
* @param body
*            the new markup
*/
protected final void replacecomponenttagbody final markupstream markupstream
final componenttag tag  final charsequence body
// the tag might have been changed from open-close to open. hence
// we'll need what was in the markup itself
componenttag markupopentag   null
// if tag has a body
if  tag isopen
// get what tag was in the markup; not what the user it might
// have changed it to.
markupstream setcurrentindex markupstream getcurrentindex     1
markupopentag   markupstream gettag
markupstream next
// if it was an open tag in the markup as well, than ...
if  markupopentag isopen
// skip any raw markup in the body
markupstream skiprawmarkup
if  body    null
// write the new body
getresponse   write body
// if we had an open tag (and not an openclose tag) and we found a
// close tag, we're good
if  tag isopen
// if it was an open tag in the markup, than there must be
// a close tag as well.
if   markupopentag    null     markupopentag isopen       markupstream atclosetag
// there must be a component in this discarded body
markupstream throwmarkupexception     markupopentag
markupstream get
/**
* @param auto
*            true to put component into auto-add mode
*/
protected final void setauto final boolean auto
setflag flag_auto  auto
/**
* this method is not part of the wicket public api. do not use it!
*
* @param flag
*            the flag to set
* @param set
*            true to turn the flag on, false to turn it off
*/
protected final void setflag final int flag  final boolean set
if  set
this flags    flag
else
this flags    ~flag
/**
* this method is not part of the wicket public api. do not use it!
*
* @param flag
*            the flag to set
* @param set
*            true to turn the flag on, false to turn it off
*/
protected final void setflag final short flag  final boolean set
setflag  int flag  set
/**
* if true, all attribute modifiers will be ignored
*
* @param ignore
*            if true, all attribute modifiers will be ignored
* @return this
*/
protected final component setignoreattributemodifier final boolean ignore
this setflag flag_ignore_attribute_modifier  ignore
return this
/**
* the markup stream will be assigned to the component at the beginning of
* the component render phase. it is temporary working variable only.
*
* @see #findmarkupstream()
* @see markupcontainer#getmarkupstream()
*
* @param markupstream
*            the current markup stream which should be applied by the
*            component to render itself
*/
protected void setmarkupstream final markupstream markupstream
/**
* @param model
*            the model to wrap if need be
* @return the wrapped model
*/
protected final imodel wrap final imodel model
if  model instanceof icomponentassignedmodel
return   icomponentassignedmodel model  wraponassignment this
else
return model
/**
* detaches any child components
*
* @see {@link #attachchildren()}
*/
void detachchildren
/**
* gets the component at the given path.
*
* @param path
*            path to component
* @return the component at the path
*/
component get final string path
// path to this component is an empty path
if  path equals
return this
throw new illegalargumentexception
exceptionmessage
path
final boolean hasmarkupidmetadata
return getmetadata markup_id_key     null
/**
* attaches any child components
*
* this method is here only for {@link markupcontainer}. it is broken out
* of {@link #onbeforerender()} so we can guarantee that it executes as the
* last in onattach() chain no matter where user places the
* <code>super.onattach()</code> call
*/
void internalattach2
if   getflag flag_attached
setflag flag_attaching  true
setflag flag_attach_super_call_verified  false
onattach
if   getflag flag_attach_super_call_verified
throw new illegalstateexception
this
getclass   getname
setflag flag_attaching  false
setflag flag_attached  true
/**
* @return true if this component or any of its parents is in auto-add mode
*/
final boolean isauto
// search up hierarchy for flag_auto
for  component current   this  current    null  current   current getparent
if  current getflag flag_auto
return true
return false
void onafterrenderchildren
/**
* this method is here for {@link markupcontainer}. it is broken out of
* {@link #onbeforerender()} so we can guarantee that it executes as the
* last in onbeforerender() chain no matter where user places the
* <code>super.onbeforerender()</code> call.
*/
void onbeforerenderchildren
/**
* renders the close tag at the current position in the markup stream.
*
* @param markupstream
*            the markup stream
* @param opentag
*            the tag to render
* @param rendertagonly
*            if true, the tag will not be written to the output
*/
final void renderclosingcomponenttag final markupstream markupstream
final componenttag opentag  final boolean rendertagonly
// tag should be open tag and not openclose tag
if  opentag isopen
// if we found a close tag and it closes the open tag, we're good
if  markupstream atclosetag      markupstream gettag   closes opentag
// get the close tag from the stream
componenttag closetag   markupstream gettag
// if the open tag had its id changed
if  opentag getnamechanged
// change the id of the close tag
closetag   closetag mutable
closetag setname opentag getname
// render the close tag
if  rendertagonly    false
rendercomponenttag closetag
markupstream next
else
if  opentag requiresclosetag
// missing close tag
markupstream throwmarkupexception     opentag
/**
* sets the id of this component. this method is private because the only
* time a component's id can be set is in its constructor.
*
* @param id
*            the non-null id of this component
*/
final void setid final string id
if  id    null      this instanceof page
throw new wicketruntimeexception
this id   id
final void setmarkupidmetadata string markupid
setmetadata markup_id_key  markupid
/**
* sets the parent of a component.
*
* @param parent
*            the parent container
*/
final void setparent final markupcontainer parent
if  this parent    null    log isdebugenabled
log debug     this parent       parent
this parent   parent
/**
* sets the render allowed flag.
*
* @param renderallowed
*/
final void setrenderallowed boolean renderallowed
setflag flag_is_render_allowed  renderallowed