/*
* copyright 2008 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package groovy beans
import org codehaus groovy ast
import org codehaus groovy ast expr
import org codehaus groovy ast stmt expressionstatement
import org codehaus groovy ast stmt returnstatement
import org codehaus groovy ast stmt statement
import org codehaus groovy control compilephase
import org codehaus groovy control sourceunit
import org codehaus groovy control messages syntaxerrormessage
import org codehaus groovy runtime metaclasshelper
import org codehaus groovy syntax syntaxexception
import org codehaus groovy syntax token
import org codehaus groovy syntax types
import org codehaus groovy transform asttransformation
import org codehaus groovy transform groovyasttransformation
import org objectweb asm opcodes
import java beans propertychangelistener
import java beans propertychangesupport
import java util collection
/**
* handles generation of code for the @bindable annotation when @vetoable
* is not present.
* <p/>
* generally, it adds (if needed) a propertychangesupport field and
* the needed add/removepropertychangelistener methods to support the
* listeners.
* <p/>
* it also generates the setter and wires the setter through the
* propertychangesupport.
* <p/>
* if a @{@link vetoable} annotaton is detected it does nothing and
* lets the {@link vetoableasttransformation} handle all the changes.
*
* @author danno ferrin (shemnon)
*/
@groovyasttransformation phase  compilephase canonicalization
public class bindableasttransformation implements asttransformation  opcodes
/**
* the found or created propertychangesupport field
*/
protected fieldnode pcsfield
protected static classnode boundclassnode   new classnode bindable class
protected classnode pcsclassnode   new classnode propertychangesupport class
/**
* convenience method to see if an annotated node is @bindable.
*
* @param node the node to check
* @return true if the node is bindable
*/
public static boolean hasbindableannotation annotatednode node
for  annotationnode annotation    collection<annotationnode>  node getannotations
if  boundclassnode equals annotation getclassnode
return true
return false
/**
* handles the bulk of the processing, mostly delegating to other methods.
*
* @param nodes   the ast nodes
* @param source  the source unit for the nodes
*/
public void visit astnode nodes  sourceunit source
if    nodes instanceof annotationnode       nodes instanceof annotatednode
throw new runtimeexception
annotationnode node    annotationnode  nodes
annotatednode parent    annotatednode  nodes
if  vetoableasttransformation hasvetoableannotation parent
// vetoableasttransformation will handle both @bindable and @vetoable
return
classnode declaringclass   parent getdeclaringclass
if  parent instanceof fieldnode
if  vetoableasttransformation hasvetoableannotation parent getdeclaringclass
// vetoableasttransformation will handle both @bindable and @vetoable
return
addlistenertoproperty source  node  declaringclass   fieldnode  parent
else if  parent instanceof classnode
addlistenertoclass source  node   classnode  parent
private void addlistenertoproperty sourceunit source  annotationnode node  classnode declaringclass  fieldnode field
string fieldname   field getname
for  propertynode propertynode    collection<propertynode>  declaringclass getproperties
if  propertynode getname   equals fieldname
if  field isstatic
//noinspection throwableinstanceneverthrown
source geterrorcollector   adderrorandcontinue
new syntaxerrormessage new syntaxexception
node getlinenumber
node getcolumnnumber
source
else
if  needspropertychangesupport declaringclass
addpropertychangesupport declaringclass
createlistenersetter source  node  declaringclass  propertynode
return
//noinspection throwableinstanceneverthrown
source geterrorcollector   adderrorandcontinue
new syntaxerrormessage new syntaxexception
node getlinenumber
node getcolumnnumber
source
private void addlistenertoclass sourceunit source  annotationnode node  classnode classnode
if  needspropertychangesupport classnode
addpropertychangesupport classnode
for  propertynode propertynode    collection<propertynode>  classnode getproperties
fieldnode field   propertynode getfield
// look to see if per-field handlers will catch this one...
if  hasbindableannotation field
field isstatic
vetoableasttransformation hasvetoableannotation field
// explicitly labeled properties are already handled,
// don't transform static properties
// vetoableasttransformation will handle both @bindable and @vetoable
continue
createlistenersetter source  node  classnode  propertynode
private void createlistenersetter sourceunit source  annotationnode node  classnode classnode  propertynode propertynode
string settername       metaclasshelper capitalize propertynode getname
if  classnode getmethods settername  isempty
expression fieldexpression   new fieldexpression propertynode getfield
statement setterblock   createbindablestatement propertynode  fieldexpression
// create method void <setter>(<type> fieldname)
createsettermethod classnode  propertynode  settername  setterblock
else
//noinspection throwableinstanceneverthrown
source geterrorcollector   adderrorandcontinue
new syntaxerrormessage new syntaxexception
node getlinenumber
node getcolumnnumber
source
/**
* creates a statement body similar to:
* <code>pcsfield.firepropertychange("field", field, field = value)</code>
*
* @param propertynode           the field node for the property
* @param fieldexpression a field expression for setting the property value
* @return the created statement
*/
protected statement createbindablestatement propertynode propertynode  expression fieldexpression
// create statementbody
return new expressionstatement
new methodcallexpression
new fieldexpression pcsfield
new argumentlistexpression
new expression
new constantexpression propertynode getname
fieldexpression
new binaryexpression
fieldexpression
token newsymbol types equal  0  0
new variableexpression
/**
* creates a setter method with the given body.
*
* @param declaringclass the class to which we will add the setter
* @param propertynode          the field to back the setter
* @param settername     the name of the setter
* @param setterblock    the statement representing the setter block
*/
protected void createsettermethod classnode declaringclass  propertynode propertynode  string settername  statement setterblock
parameter setterparametertypes    new parameter propertynode gettype
methodnode setter
new methodnode settername  propertynode getmodifiers    classhelper void_type  setterparametertypes  classnode empty_array  setterblock
setter setsynthetic true
// add it to the class
declaringclass addmethod setter
/**
* snoops through the declaring class and all parents looking for a field
* of type propertychangesupport.  remembers the field and returns false
* if found otherwise returns true to indicate that such support should
* be added.
*
* @param declaringclass the class to search
* @return true if property change support should be added
*/
protected boolean needspropertychangesupport classnode declaringclass
while  declaringclass    null
for  fieldnode field    collection<fieldnode>  declaringclass getfields
if  field gettype      null
continue
if  pcsclassnode equals field gettype
//pcsfieldname = field.getname();
pcsfield   field
return false
//todo check add/remove conflicts
declaringclass   declaringclass getsuperclass
return true
/**
* adds the necessary field and methods to support property change support.
* <p/>
* adds a new field:
* <code>protected final java.beans.propertychangesupport this$propertychangesupport = new java.beans.propertychangesupport(this)</code>"
* <p/>
* also adds support methods:
* <code>public void addpropertychangelistener(java.beans.propertychangelistener)</code>
* <code>public void addpropertychangelistener(string, java.beans.propertychangelistener)</code>
* <code>public void removepropertychangelistener(java.beans.propertychangelistener)</code>
* <code>public void removepropertychangelistener(string, java.beans.propertychangelistener)</code>
* <code>public java.beans.propertychangelistener[] getpropertychangelisteners()</code>
*
* @param declaringclass the class to which we add the support field and methods
*/
protected void addpropertychangesupport classnode declaringclass
classnode pcsclassnode   classhelper make propertychangesupport class
classnode pclclassnode   classhelper make propertychangelistener class
//string pcsfieldname = "this$propertychangesupport";
// add field:
// protected final propertychangesupport this$propertychangesupport = new java.beans.propertychangesupport(this)
pcsfield   declaringclass addfield
acc_final   acc_protected   acc_synthetic
pcsclassnode
new constructorcallexpression pcsclassnode
new argumentlistexpression new expression new variableexpression
// add method:
// void addpropertychangelistener(listener) {
//     this$propertychangesupport.addpropertychangelistner(listener)
//  }
declaringclass addmethod
new methodnode
acc_public   acc_synthetic
classhelper void_type
new parameter new parameter pclclassnode
classnode empty_array
new expressionstatement
new methodcallexpression
new fieldexpression pcsfield
new argumentlistexpression
new expression new variableexpression
// add method:
// void addpropertychangelistener(name, listener) {
//     this$propertychangesupport.addpropertychangelistner(name, listener)
//  }
declaringclass addmethod
new methodnode
acc_public   acc_synthetic
classhelper void_type
new parameter new parameter classhelper string_type      new parameter pclclassnode
classnode empty_array
new expressionstatement
new methodcallexpression
new fieldexpression pcsfield
new argumentlistexpression
new expression new variableexpression     new variableexpression
// add method:
// boolean removepropertychangelistener(listener) {
//    return this$propertychangesupport.removepropertychangelistener(listener);
// }
declaringclass addmethod
new methodnode
acc_public   acc_synthetic
classhelper void_type
new parameter new parameter pclclassnode
classnode empty_array
new expressionstatement
new methodcallexpression
new fieldexpression pcsfield
new argumentlistexpression
new expression new variableexpression
// add method: void removepropertychangelistener(name, listener)
declaringclass addmethod
new methodnode
acc_public   acc_synthetic
classhelper void_type
new parameter new parameter classhelper string_type      new parameter pclclassnode
classnode empty_array
new expressionstatement
new methodcallexpression
new fieldexpression pcsfield
new argumentlistexpression
new expression new variableexpression     new variableexpression
// add method:
// propertychangesupport[] getpropertychangelisteners() {
//   return this$propertychangesupport.getpropertychangelisteners
// }
declaringclass addmethod
new methodnode
acc_public   acc_synthetic
pclclassnode makearray
parameter empty_array
classnode empty_array
new returnstatement
new expressionstatement
new methodcallexpression
new fieldexpression pcsfield
argumentlistexpression empty_arguments