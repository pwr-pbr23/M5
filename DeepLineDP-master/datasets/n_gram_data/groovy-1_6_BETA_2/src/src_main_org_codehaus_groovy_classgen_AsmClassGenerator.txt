/*
* copyright 2003-2007 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy classgen
import groovy lang groovyruntimeexception
import org codehaus groovy groovybugerror
import org codehaus groovy ast
import org codehaus groovy ast expr
import org codehaus groovy ast stmt
import org codehaus groovy control compilerconfiguration
import org codehaus groovy control sourceunit
import org codehaus groovy runtime metaclasshelper
import org codehaus groovy runtime scriptbytecodeadapter
import org codehaus groovy runtime callsite callsite
import org codehaus groovy runtime typehandling defaulttypetransformation
import org codehaus groovy syntax runtimeparserexception
import org codehaus groovy syntax types
import org objectweb asm annotationvisitor
import org objectweb asm
import java util
/**
* generates java class versions of groovy classes using asm.
*
* @author <a href="mailto:james@coredevelopers.net">james strachan</a>
* @author <a href="mailto:b55r@sina.com">bing ran</a>
* @author <a href="mailto:blackdrag@gmx.org">jochen theodorou</a>
* @author <a href='mailto:the[dot]mindstorm[at]gmail[dot]com'>alex popescu</a>
* @author alex tkachman
* @version $revision$
*/
public class asmclassgenerator extends classgenerator
private final classvisitor cv
private methodvisitor mv
private generatorcontext context
private string sourcefile
// current class details
private classnode classnode
private classnode outermostclass
private string internalclassname
private string internalbaseclassname
/*
* maps the variable names to the jvm indices
*/
private compilestack compilestack
/*
* have we output a return statement yet
*/
private boolean outputreturn
/*
* are we on the left or right of an expression?
*
* the default is false, that means the right side is default.
* the right side means that variables are read and not written.
* any change of lefthandexpression to true, should be made carefully.
* if such a change is needed, then it should be set to false as soon as
* possible, but most important in the same method. setting
* lefthandexpression to false is needed for writing variables.
*/
private boolean lefthandexpression   false
// method invocation
static final methodcallermultiadapter invokemethodoncurrent   methodcallermultiadapter newstatic scriptbytecodeadapter class     true  false
static final methodcallermultiadapter invokemethodonsuper   methodcallermultiadapter newstatic scriptbytecodeadapter class     true  false
static final methodcallermultiadapter invokemethod   methodcallermultiadapter newstatic scriptbytecodeadapter class     true  false
static final methodcallermultiadapter invokestaticmethod   methodcallermultiadapter newstatic scriptbytecodeadapter class     true  true
static final methodcallermultiadapter invokenew   methodcallermultiadapter newstatic scriptbytecodeadapter class     true  true
// fields and properties
static final methodcallermultiadapter setfield   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter getfield   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter setgroovyobjectfield   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter getgroovyobjectfield   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter setfieldonsuper   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter getfieldonsuper   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter setproperty   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter getproperty   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter setgroovyobjectproperty   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter getgroovyobjectproperty   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter setpropertyonsuper   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
static final methodcallermultiadapter getpropertyonsuper   methodcallermultiadapter newstatic scriptbytecodeadapter class     false  false
// iterator
static final methodcaller iteratornextmethod   methodcaller newinterface iterator class
static final methodcaller iteratorhasnextmethod   methodcaller newinterface iterator class
// assert
static final methodcaller assertfailedmethod   methodcaller newstatic scriptbytecodeadapter class
// iscase
static final methodcaller iscasemethod   methodcaller newstatic scriptbytecodeadapter class
//compare
static final methodcaller compareidenticalmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller compareequalmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller comparenotequalmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller comparetomethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller comparelessthanmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller comparelessthanequalmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller comparegreaterthanmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller comparegreaterthanequalmethod   methodcaller newstatic scriptbytecodeadapter class
//regexpr
static final methodcaller findregexmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller matchregexmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller regexpattern   methodcaller newstatic scriptbytecodeadapter class
// spread expressions
static final methodcaller spreadmap   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller despreadlist   methodcaller newstatic scriptbytecodeadapter class
// closure
static final methodcaller getmethodpointer   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller invokeclosuremethod   methodcaller newstatic scriptbytecodeadapter class
// unary plus, unary minus, bitwise negation
static final methodcaller unaryplus   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller unaryminus   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller bitwisenegate   methodcaller newstatic scriptbytecodeadapter class
// type conversions
static final methodcaller astypemethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller casttotypemethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller createlistmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller createtuplemethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller createmapmethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller createrangemethod   methodcaller newstatic scriptbytecodeadapter class
// wrapper creation methods
static final methodcaller createpojowrappermethod   methodcaller newstatic scriptbytecodeadapter class
static final methodcaller creategroovyobjectwrappermethod   methodcaller newstatic scriptbytecodeadapter class
// constructor calls with this() and super()
static final methodcaller selectconstructorandtransformarguments   methodcaller newstatic scriptbytecodeadapter class
// exception blocks list
private list exceptionblocks   new arraylist
private set referencedclasses   new hashset
private boolean passingclosureparams
private constructornode constructornode
private methodnode methodnode
private bytecodehelper helper   new bytecodehelper null
public static final boolean create_debug_info   true
public static final boolean create_line_number_info   true
private static final boolean mark_start   true
public static final boolean asm_debug   false     add marker in the bytecode to show source byecode relationship
private int linenumber    1
private int columnnumber    1
private astnode currentastnode   null
private dummyclassgenerator dummygen   null
private classwriter dummyclasswriter   null
private classnode interfaceclassloadingclass
private boolean implicitthis   false
private map genericparameternames   null
private classnode righthandtype
private static final string constructor
private list callsites   new arraylist
private int callsitearrayvarindex
private static final string gre   bytecodehelper getclassinternalname classhelper make groovyruntimeexception class
private static final string dtt   bytecodehelper getclassinternalname defaulttypetransformation class getname
public asmclassgenerator
generatorcontext context  classvisitor classvisitor
classloader classloader  string sourcefile
super classloader
this context   context
this cv   classvisitor
this sourcefile   sourcefile
this dummyclasswriter   new classwriter true
dummygen   new dummyclassgenerator context  dummyclasswriter  classloader  sourcefile
compilestack   new compilestack
genericparameternames   new hashmap
protected sourceunit getsourceunit
return null
// groovyclassvisitor interface
//-------------------------------------------------------------------------
public void visitclass classnode classnode
try
callsites clear
referencedclasses clear
this classnode   classnode
this outermostclass   null
this internalclassname   bytecodehelper getclassinternalname classnode
this internalbaseclassname   bytecodehelper getclassinternalname classnode getsuperclass
cv visit
getbytecodeversion
classnode getmodifiers
internalclassname
bytecodehelper getgenericssignature classnode
internalbaseclassname
bytecodehelper getclassinternalnames classnode getinterfaces
cv visitsource sourcefile  null
visitannotations classnode  cv
if  classnode isinterface
classnode owner   classnode
if  owner instanceof innerclassnode
owner   owner getouterclass
string outerclassname   owner getname
string name   outerclassname       context getnextinnerclassidx
interfaceclassloadingclass   new innerclassnode owner  name  4128  classhelper object_type
super visitclass classnode
createinterfacesyntheticstaticfields
else
super visitclass classnode
if   classnode declaresinterface classhelper generated_closure_type
createmopmethods
createsyntheticstaticfields
for  iterator iter   innerclasses iterator    iter hasnext
classnode innerclass    classnode  iter next
string innerclassname   innerclass getname
string innerclassinternalname   bytecodehelper getclassinternalname innerclassname
int index   innerclassname lastindexof
if  index >  0  innerclassname   innerclassname substring index   1
string outerclassname   internalclassname     default for inner classes
methodnode enclosingmethod   innerclass getenclosingmethod
if  enclosingmethod    null
// local inner classes do not specify the outer class name
outerclassname   null
innerclassname   null
cv visitinnerclass
innerclassinternalname
outerclassname
innerclassname
innerclass getmodifiers
//todo: an inner class should have an entry of itself
generatecallsitearray
cv visitend
catch  groovyruntimeexception e
e setmodule classnode getmodule
throw e
private void generatecallsitearray
if   classnode isinterface
cv visitfield acc_private acc_static acc_synthetic        null  null
generatecreatecallsitearray
generategetcallsitearray
//            generatecallsitemethods();
//            generateadaptermethods ();
private void generategetcallsitearray
methodvisitor mv   cv visitmethod acc_private acc_synthetic acc_static       null  null
mv visitcode
mv visitfieldinsn getstatic  internalclassname
label l0   new label
mv visitjumpinsn ifnull  l0
mv visitfieldinsn getstatic  internalclassname
mv visitmethodinsn invokevirtual
mv visittypeinsn checkcast
mv visitinsn dup
mv visitvarinsn astore  0
label l1   new label
mv visitjumpinsn ifnonnull  l1
mv visitlabel l0
mv visitmethodinsn invokestatic  internalclassname
mv visitvarinsn astore  0
mv visittypeinsn new
mv visitinsn dup
mv visitvarinsn aload  0
mv visitmethodinsn invokespecial
mv visitfieldinsn putstatic  internalclassname
mv visitlabel l1
mv visitvarinsn aload  0
mv visitfieldinsn getfield
mv visitinsn areturn
mv visitmaxs 0 0
mv visitend
private void generatecreatecallsitearray
methodvisitor mv   cv visitmethod acc_private acc_synthetic acc_static       null  null
mv visitcode
mv visittypeinsn new
mv visitinsn dup
mv visitfieldinsn getstatic  internalclassname
final int size   callsites size
mv visitldcinsn size
mv visittypeinsn anewarray
for  int i   0  i < size  i
mv visitinsn dup
mv visitldcinsn i
mv visitldcinsn callsites get i
mv visitinsn aastore
mv visitmethodinsn invokespecial
mv visitinsn areturn
mv visitmaxs 0 0
mv visitend
public void visitgenerictype genericstype genericstype
classnode type   genericstype gettype
genericparameternames put type getname    genericstype
private void createmopmethods
visitmopmethodlist classnode getmethods    true
visitmopmethodlist classnode getsuperclass   getalldeclaredmethods    false
private string buildexceptions classnode exceptions
if  exceptions    null  return null
string ret   new string
for  int i   0  i < exceptions length  i
ret   bytecodehelper getclassinternalname exceptions
return ret
/**
* filters a list of method for mop methods. for all methods that are no
* mop methods a mop method is created if the method is not public and the
* call would be a call on "this" (isthis == true). if the call is not on
* "this", then the call is a call on "super" and all methods are used,
* unless they are already a mop method
*
* @param methods unfiltered list of methods for mop
* @param isthis  if true, then we are creating a mop method on "this", "super" else
* @see #generatemopcalls(linkedlist,boolean)
*/
private void visitmopmethodlist list methods  boolean isthis
hashmap mops   new hashmap
class key
int hash   0
string name
parameter params
key string name  parameter params
this name   name
this params   params
hash   name hashcode   << 2   params length
public int hashcode
return hash
public boolean equals object obj
key other    key  obj
return other name equals name     equalparametertypes other params params
linkedlist mopcalls   new linkedlist
for  iterator iter   methods iterator    iter hasnext
methodnode mn    methodnode  iter next
if   mn getmodifiers     acc_abstract     0  continue
// no this$ methods for protected/public isthis=true
// super$ method for protected/public isthis=false
// --> results in xor
if  isthis ^  mn getmodifiers      acc_public   acc_protected      0  continue
string methodname   mn getname
if  ismopmethod methodname
mops put new key methodname  mn getparameters     mn
continue
if  methodname startswith     continue
string name   getmopmethodname mn  isthis
key key   new key name  mn getparameters
if  mops containskey key   continue
mops put key  mn
mopcalls add mn
generatemopcalls mopcalls  isthis
mopcalls clear
mops clear
private boolean equalparametertypes parameter p1  parameter p2
if  p1 length  p2 length  return false
for  int i 0  i<p1 length  i
if   p1 gettype   equals p2 gettype     return false
return true
/**
* generates a meta object protocoll method, that is used to call a non public
* method, or to make a call to super.
*
* @param mopcalls list of methods a mop call method should be generated for
* @param usethis  true if "this" should be used for the naming
*/
private void generatemopcalls linkedlist mopcalls  boolean usethis
for  iterator iter   mopcalls iterator    iter hasnext
methodnode method    methodnode  iter next
string name   getmopmethodname method  usethis
parameter parameters   method getparameters
string methoddescriptor   bytecodehelper getmethoddescriptor method getreturntype    method getparameters
mv   cv visitmethod opcodes acc_public   opcodes acc_synthetic  name  methoddescriptor  null  null
mv visitvarinsn aload  0
bytecodehelper helper   new bytecodehelper mv
int newregister   1
for  int i   0  i < parameters length  i
classnode type   parameters gettype
helper load parameters gettype    newregister
// increment to next register, double/long are using two places
newregister
if  type    classhelper double_type    type    classhelper long_type  newregister
mv visitmethodinsn invokespecial  bytecodehelper getclassinternalname method getdeclaringclass     method getname    methoddescriptor
helper doreturn method getreturntype
mv visitmaxs 0  0
mv visitend
classnode addmethod name  opcodes acc_public   opcodes acc_synthetic  method getreturntype    parameters  null  null
/**
* creates a mop method name from a method
*
* @param method  the method to be called by the mop method
* @param usethis if true, then it is a call on "this", "super" else
* @return the mop method name
*/
public static string getmopmethodname methodnode method  boolean usethis
classnode declaringnode   method getdeclaringclass
int distance   0
for    declaringnode    null  declaringnode   declaringnode getsuperclass
distance
return  usethis ?              distance       method getname
/**
* method to determine if a method is a mop method. this is done by the
* method name. if the name starts with "this$" or "super$", then it is
* a mop method
*
* @param methodname name of the method to test
* @return true if the method is a mop method
*/
public static boolean ismopmethod string methodname
return methodname startswith
methodname startswith
protected void visitconstructorormethod methodnode node  boolean isconstructor
parameter parameters   node getparameters
string methodtype   bytecodehelper getmethoddescriptor node getreturntype    parameters
string signature   bytecodehelper getgenericsmethodsignature node
int modifiers   node getmodifiers
if  isvargs node getparameters     modifiers    opcodes acc_varargs
mv   cv visitmethod modifiers  node getname    methodtype  signature  buildexceptions node getexceptions
mv   new mymethodadapter
visitannotations node  mv
for  int i   0  i < parameters length  i
visitparameterannotations parameters  i  mv
helper   new bytecodehelper mv
if  classnode isannotationdefinition
visitannotationdefault node  mv
else if   node isabstract
statement code   node getcode
// fast path for getter/setters etc.
if  code instanceof bytecodesequence      bytecodesequence code  getinstructions   size      1      bytecodesequence code  getinstructions   get 0  instanceof bytecodeinstruction
bytecodeinstruction   bytecodesequence code  getinstructions   get 0   visit mv
else
visitstdmethod node  isconstructor  parameters  code
mv visitmaxs 0  0
mv visitend
private void visitstdmethod methodnode node  boolean isconstructor  parameter parameters  statement code
final label trystart   new label
mv visitlabel trystart
if  isconstructor     code    null       constructornode  node  firststatementisspecialconstructorcall
// invokes the super class constructor
mv visitvarinsn aload  0
mv visitmethodinsn invokespecial  bytecodehelper getclassinternalname classnode getsuperclass
compilestack init node getvariablescope    parameters  mv  classnode
if  isnotclinit
mv visitmethodinsn invokestatic internalclassname
callsitearrayvarindex   compilestack definetemporaryvariable    classhelper make callsite class   true
// handle body
super visitconstructorormethod node  isconstructor
if   outputreturn    node isvoidmethod
mv visitinsn return
compilestack clear
final label finallystart   new label
mv visitjumpinsn goto  finallystart
// marker needed for exception table
final label tryend   new label
mv visitlabel tryend
final label catchstart   new label
mv visitlabel catchstart
// handle catch body
mv visitmethodinsn invokestatic
mv visitinsn athrow
mv visitlabel finallystart
mv visitinsn nop
// add exception to table
exceptionblocks add new runnable
public void run
mv visittrycatchblock trystart  tryend  catchstart  gre
// let's do all the exception blocks
for  iterator iter   exceptionblocks iterator    iter hasnext
runnable runnable    runnable  iter next
runnable run
exceptionblocks clear
void visitannotationdefaultexpression annotationvisitor av  classnode type  expression exp
if  type isarray
listexpression list    listexpression  exp
annotationvisitor avl   av visitarray null
classnode componenttype   type getcomponenttype
for  iterator it   list getexpressions   iterator    it hasnext
expression lexp    expression  it next
visitannotationdefaultexpression avl componenttype  lexp
else if  classhelper isprimitivetype type     type equals classhelper string_type
constantexpression constexp    constantexpression  exp
av visit null  constexp getvalue
else if  classhelper class_type equals type
classnode clazz   exp gettype
type t   type gettype bytecodehelper gettypedescription clazz
av visit null  t
else if  type isderivedfrom classhelper enum_type
propertyexpression pexp    propertyexpression  exp
classexpression cexp    classexpression  pexp getobjectexpression
string desc   bytecodehelper gettypedescription cexp gettype
string name   pexp getpropertyasstring
av visitenum null  desc  name
else if  type implementsinterface classhelper annotation_type
annotationconstantexpression avexp    annotationconstantexpression  exp
annotationnode value    annotationnode  avexp getvalue
annotationvisitor avc   av visitannotation null  bytecodehelper gettypedescription avexp gettype
visitannotationattributes value avc
else
throw new groovybugerror     type getname
av visitend
private void visitannotationdefault methodnode node  methodvisitor mv
if   node hasannotationdefault    return
expression exp     returnstatement  node getcode    getexpression
annotationvisitor av   mv visitannotationdefault
visitannotationdefaultexpression av node getreturntype   exp
private boolean isnotclinit
return methodnode    null     methodnode getname   equals
private boolean isvargs parameter p
if  p length  0  return false
classnode clazz   p gettype
return  clazz isarray
public void visitconstructor constructornode node
this constructornode   node
this methodnode   null
outputreturn   false
super visitconstructor node
public void visitmethod methodnode node
this constructornode   null
this methodnode   node
outputreturn   false
super visitmethod node
public void visitfield fieldnode fieldnode
onlinenumber fieldnode      fieldnode getname
classnode t   fieldnode gettype
string signature   helper getgenericsbounds t
fieldvisitor fv   cv visitfield
fieldnode getmodifiers
fieldnode getname
bytecodehelper gettypedescription t
signature    fieldvalue     br  all the sudden that one cannot init the field here  init is done in static initilizer and instace intializer

visitannotations fieldnode  fv
fv visitend
public void visitproperty propertynode statement
// the verifyer created the field and the setter/getter methods, so here is
// not really something to do
onlinenumber statement      statement getfield   getname
this methodnode   null
// groovycodevisitor interface
//-------------------------------------------------------------------------
// statements
//-------------------------------------------------------------------------
protected void visitstatement statement statement
string name   statement getstatementlabel
if  name    null
label label   compilestack createlocallabel name
mv visitlabel label
public void visitblockstatement blockstatement block
onlinenumber block
visitstatement block
compilestack pushvariablescope block getvariablescope
super visitblockstatement block
compilestack pop
private void visitexpressionorstatement object o
if  o    emptyexpression instance  return
if  o instanceof expression
expression expr    expression  o
visitandautoboxboolean expr
if  ispoprequired expr   mv visitinsn pop
else
statement  o  visit this
private void visitforloopwithclosurelist forstatement loop
compilestack pushloop loop getvariablescope    loop getstatementlabel
closurelistexpression clexpr    closurelistexpression  loop getcollectionexpression
compilestack pushvariablescope clexpr getvariablescope
list expressions   clexpr getexpressions
int size   expressions size
// middle element is condition, lower half is init, higher half is increment
int condindex    size   1    2
// visit init
for  int i   0  i < condindex  i
visitexpressionorstatement expressions get i
label continuelabel   compilestack getcontinuelabel
label breaklabel   compilestack getbreaklabel
label cond   new label
mv visitlabel cond
// visit condition leave boolean on stack
expression condexpr    expression  expressions get condindex
if  condexpr    emptyexpression instance
mv visitintinsn bipush  0
else if  iscomparisonexpression condexpr
condexpr visit this
else
visitandautoboxboolean condexpr
helper unbox classhelper boolean_type
// jump if we don't want to continue
// note: ifeq tests for ==0, a boolean is 0 if it is false
mv visitjumpinsn ifeq  breaklabel
// generate the loop body
loop getloopblock   visit this
// visit increment
mv visitlabel continuelabel
for  int i   condindex   1  i < size  i
visitexpressionorstatement expressions get i
// jump to test the condition again
mv visitjumpinsn goto  cond
// loop end
mv visitlabel breaklabel
compilestack pop
compilestack pop
public void visitforloop forstatement loop
onlinenumber loop
visitstatement loop
parameter loopvar   loop getvariable
if  loopvar    forstatement for_loop_dummy
visitforloopwithclosurelist loop
return
compilestack pushloop loop getvariablescope    loop getstatementlabel
// declare the loop counter.
variable variable   compilestack definevariable loop getvariable    false
//
// then get the iterator and generate the loop control
methodcallexpression iterator   new methodcallexpression loop getcollectionexpression       new argumentlistexpression
iterator visit this
final int iteratoridx   compilestack definetemporaryvariable    classhelper make java util iterator class   true
label continuelabel   compilestack getcontinuelabel
label breaklabel   compilestack getbreaklabel
mv visitlabel continuelabel
mv visitvarinsn aload  iteratoridx
iteratorhasnextmethod call mv
// note: ifeq tests for ==0, a boolean is 0 if it is false
mv visitjumpinsn ifeq  breaklabel
mv visitvarinsn aload  iteratoridx
iteratornextmethod call mv
helper storevar variable
// generate the loop body
loop getloopblock   visit this
mv visitjumpinsn goto  continuelabel
mv visitlabel breaklabel
compilestack pop
public void visitwhileloop whilestatement loop
onlinenumber loop
visitstatement loop
compilestack pushloop loop getstatementlabel
label continuelabel   compilestack getcontinuelabel
label breaklabel   compilestack getbreaklabel
mv visitlabel continuelabel
loop getbooleanexpression   visit this
mv visitjumpinsn ifeq  breaklabel
loop getloopblock   visit this
mv visitjumpinsn goto  continuelabel
mv visitlabel breaklabel
compilestack pop
public void visitdowhileloop dowhilestatement loop
onlinenumber loop
visitstatement loop
compilestack pushloop loop getstatementlabel
label breaklabel   compilestack getbreaklabel
label continuelabel   compilestack getcontinuelabel
mv visitlabel continuelabel
loop getloopblock   visit this
loop getbooleanexpression   visit this
mv visitjumpinsn ifeq  continuelabel
mv visitlabel breaklabel
compilestack pop
public void visitifelse ifstatement ifelse
onlinenumber ifelse
visitstatement ifelse
ifelse getbooleanexpression   visit this
label l0   new label
mv visitjumpinsn ifeq  l0
// if-else is here handled as a special version
// of a booelan expression
compilestack pushbooleanexpression
ifelse getifblock   visit this
compilestack pop
label l1   new label
mv visitjumpinsn goto  l1
mv visitlabel l0
compilestack pushbooleanexpression
ifelse getelseblock   visit this
compilestack pop
mv visitlabel l1
public void visitternaryexpression ternaryexpression expression
onlinenumber expression
booleanexpression boolpart   expression getbooleanexpression
expression truepart   expression gettrueexpression
expression falsepart   expression getfalseexpression
if  expression instanceof elvisoperatorexpression
visitandautoboxboolean expression gettrueexpression
boolpart   new booleanexpression
new bytecodeexpression
public void visit methodvisitor mv
mv visitinsn dup
truepart   bytecodeexpression nop
final expression oldfalse   falsepart
falsepart   new bytecodeexpression
public void visit methodvisitor mv
mv visitinsn pop
visitandautoboxboolean oldfalse
boolpart visit this
label l0   new label
mv visitjumpinsn ifeq  l0
compilestack pushbooleanexpression
visitandautoboxboolean truepart
compilestack pop
label l1   new label
mv visitjumpinsn goto  l1
mv visitlabel l0
compilestack pushbooleanexpression
visitandautoboxboolean falsepart
compilestack pop
mv visitlabel l1
public void visitassertstatement assertstatement statement
onlinenumber statement
visitstatement statement
booleanexpression booleanexpression   statement getbooleanexpression
booleanexpression visit this
label l0   new label
mv visitjumpinsn ifeq  l0
// do nothing
label l1   new label
mv visitjumpinsn goto  l1
mv visitlabel l0
// push expression string onto stack
string expressiontext   booleanexpression gettext
list list   new arraylist
addvariablenames booleanexpression  list
if  list isempty
mv visitldcinsn expressiontext
else
boolean first   true
// let's create a new expression
mv visittypeinsn new
mv visitinsn dup
mv visitldcinsn expressiontext
mv visitmethodinsn invokespecial
int tempindex   compilestack definetemporaryvariable    true
for  iterator iter   list iterator    iter hasnext
string name    string  iter next
string text   name
if  first
first   false
else
text       text
mv visitvarinsn aload  tempindex
mv visitldcinsn text
mv visitmethodinsn
invokevirtual
mv visitinsn pop
mv visitvarinsn aload  tempindex
new variableexpression name  visit this
mv visitmethodinsn invokestatic
mv visitmethodinsn
invokevirtual
mv visitinsn pop
mv visitvarinsn aload  tempindex
compilestack removevar tempindex
// now the optional exception expression
statement getmessageexpression   visit this
assertfailedmethod call mv
mv visitlabel l1
private void addvariablenames expression expression  list list
if  expression instanceof booleanexpression
booleanexpression boolexp    booleanexpression  expression
addvariablenames boolexp getexpression    list
else if  expression instanceof binaryexpression
binaryexpression binexp    binaryexpression  expression
addvariablenames binexp getleftexpression    list
addvariablenames binexp getrightexpression    list
else if  expression instanceof variableexpression
variableexpression varexp    variableexpression  expression
list add varexp getname
public void visittrycatchfinally trycatchstatement statement
onlinenumber statement
visitstatement statement
catchstatement catchstatement   statement getcatchstatement 0
statement trystatement   statement gettrystatement
final statement finallystatement   statement getfinallystatement
int anyexceptionindex   compilestack definetemporaryvariable    false
if   finallystatement isempty
compilestack pushfinallyblock
new runnable
public void run
compilestack pushfinallyblockvisit this
finallystatement visit asmclassgenerator this
compilestack popfinallyblockvisit this
// start try block, label needed for exception table
final label trystart   new label
mv visitlabel trystart
trystatement visit this
// goto finally part
final label finallystart   new label
mv visitjumpinsn goto  finallystart
// marker needed for exception table
final label greend   new label
mv visitlabel greend
final label catchstartgre   new label
mv visitlabel catchstartgre
// handle catch body
mv visitmethodinsn invokestatic
mv visitinsn athrow
// add exception to table
exceptionblocks add new runnable
public void run
mv visittrycatchblock trystart  greend  catchstartgre  gre
final label tryend   new label
mv visitlabel tryend
for  iterator it   statement getcatchstatements   iterator    it hasnext
catchstatement    catchstatement  it next
classnode exceptiontype   catchstatement getexceptiontype
// start catch block, label needed for exception table
final label catchstart   new label
mv visitlabel catchstart
// create exception variable and store the exception
compilestack definevariable catchstatement getvariable    true
// handle catch body
catchstatement visit this
// goto finally start
mv visitjumpinsn goto  finallystart
// add exception to table
final string exceptiontypeinternalname   bytecodehelper getclassinternalname exceptiontype
exceptionblocks add new runnable
public void run
mv visittrycatchblock trystart  tryend  catchstart  exceptiontypeinternalname
// marker needed for the exception table
final label endofallcatches   new label
mv visitlabel endofallcatches
// remove the finally, don't let it visit itself
if   finallystatement isempty    compilestack popfinallyblock
// start finally
mv visitlabel finallystart
finallystatement visit this
// goto end of finally
label afterfinally   new label
mv visitjumpinsn goto  afterfinally
// start a block catching any exception
final label catchany   new label
mv visitlabel catchany
//store exception
mv visitvarinsn astore  anyexceptionindex
finallystatement visit this
// load the exception and rethrow it
mv visitvarinsn aload  anyexceptionindex
mv visitinsn athrow
// end of all catches and finally parts
mv visitlabel afterfinally
// add catch any block to exception table
exceptionblocks add new runnable
public void run
mv visittrycatchblock trystart  endofallcatches  catchany  null
public void visitswitch switchstatement statement
onlinenumber statement
visitstatement statement
statement getexpression   visit this
// switch does not have a continue label. use its parent's for continue
label breaklabel   compilestack pushswitch
int switchvariableindex   compilestack definetemporaryvariable    true
list casestatements   statement getcasestatements
int casecount   casestatements size
label labels   new label
for  int i   0  i < casecount  i
labels   new label
int i   0
for  iterator iter   casestatements iterator    iter hasnext    i
casestatement casestatement    casestatement  iter next
visitcasestatement casestatement  switchvariableindex  labels  labels
statement getdefaultstatement   visit this
mv visitlabel breaklabel
compilestack pop
public void visitcasestatement casestatement statement
public void visitcasestatement
casestatement statement
int switchvariableindex
label thislabel
label nextlabel
onlinenumber statement
mv visitvarinsn aload  switchvariableindex
statement getexpression   visit this
iscasemethod call mv
label l0   new label
mv visitjumpinsn ifeq  l0
mv visitlabel thislabel
statement getcode   visit this
// now if we don't finish with a break we need to jump past
// the next comparison
if  nextlabel    null
mv visitjumpinsn goto  nextlabel
mv visitlabel l0
public void visitbreakstatement breakstatement statement
onlinenumber statement
visitstatement statement
string name   statement getlabel
label breaklabel   compilestack getnamedbreaklabel name
compilestack applyfinallyblocks breaklabel  true
mv visitjumpinsn goto  breaklabel
public void visitcontinuestatement continuestatement statement
onlinenumber statement
visitstatement statement
string name   statement getlabel
label continuelabel   compilestack getcontinuelabel
if  name    null  continuelabel   compilestack getnamedcontinuelabel name
compilestack applyfinallyblocks continuelabel  false
mv visitjumpinsn goto  continuelabel
public void visitsynchronizedstatement synchronizedstatement statement
onlinenumber statement
visitstatement statement
statement getexpression   visit this
final int index   compilestack definetemporaryvariable    classhelper integer_type  true
final label synchronizedstart   new label
final label synchronizedend   new label
final label catchall   new label
mv visitvarinsn aload  index
mv visitinsn monitorenter
mv visitlabel synchronizedstart
runnable finallypart   new runnable
public void run
mv visitvarinsn aload  index
mv visitinsn monitorexit
compilestack pushfinallyblock finallypart
statement getcode   visit this
finallypart run
mv visitjumpinsn goto  synchronizedend
mv visitlabel catchall
finallypart run
mv visitinsn athrow
mv visitlabel synchronizedend
compilestack popfinallyblock
exceptionblocks add new runnable
public void run
mv visittrycatchblock synchronizedstart  catchall  catchall  null
public void visitthrowstatement throwstatement statement
onlinenumber statement
visitstatement statement
statement getexpression   visit this
// we should infer the type of the exception from the expression
mv visittypeinsn checkcast
mv visitinsn athrow
public void visitreturnstatement returnstatement statement
onlinenumber statement
visitstatement statement
classnode returntype
if  methodnode    null
returntype   methodnode getreturntype
else if  constructornode    null
returntype   constructornode getreturntype
else
throw new groovybugerror
if  returntype    classhelper void_type
if    statement    returnstatement return_null_or_void
throwexception
compilestack applyfinallyblocks
mv visitinsn return
outputreturn   true
return
expression expression   statement getexpression
evaluateexpression expression
if  returntype    classhelper object_type    expression gettype      null    expression gettype      classhelper void_type
mv visitinsn aconst_null      cheat the caller
else
// return is based on class type
// we may need to cast
doconvertandcast returntype  expression  false  true  false
if  compilestack hasfinallyblocks
// value is always saved in boxed form, so no need to have a special load routine here
int returnvalueidx   compilestack definetemporaryvariable    classhelper object_type  true
compilestack applyfinallyblocks
helper load classhelper object_type  returnvalueidx
// value is always saved in boxed form, so we need to unbox it here
helper unbox returntype
helper doreturn returntype
outputreturn   true
/**
* casts to the given type unless it can be determined that the cast is unnecessary
*/
protected void doconvertandcast classnode type  expression expression  boolean ignoreautoboxing  boolean forcecast  boolean coerce
classnode exptype   getexpressiontype expression
// temp resolution: convert all primitive casting to corresponsing object type
if   ignoreautoboxing    classhelper isprimitivetype type
type   classhelper getwrapper type
if  forcecast     type    null     exptype isderivedfrom type      exptype implementsinterface type
doconvertandcast type  coerce
/**
* @param expression
*/
protected void evaluateexpression expression expression
visitandautoboxboolean expression
if  ispoprequired expression
return     we already have the return value
// otherwise create return value if appropriate
expression assignexpr   createreturnlhsexpression expression
if  assignexpr    null
lefthandexpression   false
assignexpr visit this
public void visitexpressionstatement expressionstatement statement
onlinenumber statement      statement getexpression   getclass   getname
visitstatement statement
expression expression   statement getexpression
visitandautoboxboolean expression
if  ispoprequired expression
mv visitinsn pop
// expressions
//-------------------------------------------------------------------------
public void visitdeclarationexpression declarationexpression expression
onlinenumber expression
evaluateequal expression true
public void visitbinaryexpression binaryexpression expression
onlinenumber expression
switch  expression getoperation   gettype
case types equal       assignment
evaluateequal expression false
break
case types compare_identical
evaluatebinaryexpression compareidenticalmethod  expression
break
case types compare_equal
evaluatebinaryexpression compareequalmethod  expression
break
case types compare_not_equal
evaluatebinaryexpression comparenotequalmethod  expression
break
case types compare_to
evaluatecompareto expression
break
case types compare_greater_than
evaluatebinaryexpression comparegreaterthanmethod  expression
break
case types compare_greater_than_equal
evaluatebinaryexpression comparegreaterthanequalmethod  expression
break
case types compare_less_than
evaluatebinaryexpression comparelessthanmethod  expression
break
case types compare_less_than_equal
evaluatebinaryexpression comparelessthanequalmethod  expression
break
case types logical_and
evaluatelogicalandexpression expression
break
case types logical_or
evaluatelogicalorexpression expression
break
case types bitwise_and
evaluatebinaryexpression    expression
break
case types bitwise_and_equal
evaluatebinaryexpressionwithassignment    expression
break
case types bitwise_or
evaluatebinaryexpression    expression
break
case types bitwise_or_equal
evaluatebinaryexpressionwithassignment    expression
break
case types bitwise_xor
evaluatebinaryexpression    expression
break
case types bitwise_xor_equal
evaluatebinaryexpressionwithassignment    expression
break
case types plus
evaluatebinaryexpression    expression
break
case types plus_equal
evaluatebinaryexpressionwithassignment    expression
break
case types minus
evaluatebinaryexpression    expression
break
case types minus_equal
evaluatebinaryexpressionwithassignment    expression
break
case types multiply
evaluatebinaryexpression    expression
break
case types multiply_equal
evaluatebinaryexpressionwithassignment    expression
break
case types divide
evaluatebinaryexpression    expression
break
case types divide_equal
//spg don't use divide since biginteger implements directly
//and we want to dispatch through defaultgroovymethods to get a bigdecimal result
evaluatebinaryexpressionwithassignment    expression
break
case types intdiv
evaluatebinaryexpression    expression
break
case types intdiv_equal
evaluatebinaryexpressionwithassignment    expression
break
case types mod
evaluatebinaryexpression    expression
break
case types mod_equal
evaluatebinaryexpressionwithassignment    expression
break
case types power
evaluatebinaryexpression    expression
break
case types power_equal
evaluatebinaryexpressionwithassignment    expression
break
case types left_shift
evaluatebinaryexpression    expression
break
case types left_shift_equal
evaluatebinaryexpressionwithassignment    expression
break
case types right_shift
evaluatebinaryexpression    expression
break
case types right_shift_equal
evaluatebinaryexpressionwithassignment    expression
break
case types right_shift_unsigned
evaluatebinaryexpression    expression
break
case types right_shift_unsigned_equal
evaluatebinaryexpressionwithassignment    expression
break
case types keyword_instanceof
evaluateinstanceof expression
break
case types find_regex
evaluatebinaryexpression findregexmethod  expression
break
case types match_regex
evaluatebinaryexpression matchregexmethod  expression
break
case types left_square_bracket
if  lefthandexpression
throwexception
// this is handled right now in the evaluateequal()
// should support this here later
//evaluatebinaryexpression("putat", expression);
else
evaluatebinaryexpression    expression
break
case types keyword_in
evaluatebinaryexpression iscasemethod  expression
break
default
throwexception     expression getoperation
private void load expression exp
boolean wasleft   lefthandexpression
lefthandexpression   false
//        if (create_debug_info)
//            helper.mark("-- loading expression: " + exp.getclass().getname() +
//                    " at [" + exp.getlinenumber() + ":" + exp.getcolumnnumber() + "]");
//exp.visit(this);
visitandautoboxboolean exp
//        if (create_debug_info)
//            helper.mark(" -- end of loading --");
lefthandexpression   wasleft
public void visitpostfixexpression postfixexpression expression
switch  expression getoperation   gettype
case types plus_plus
evaluatepostfixmethod    expression getexpression
break
case types minus_minus
evaluatepostfixmethod    expression getexpression
break
private void throwexception string s
throw new runtimeparserexception s  currentastnode
public void visitprefixexpression prefixexpression expression
switch  expression getoperation   gettype
case types plus_plus
evaluateprefixmethod    expression getexpression
break
case types minus_minus
evaluateprefixmethod    expression getexpression
break
public void visitclosureexpression closureexpression expression
classnode innerclass   createclosureclass expression
addinnerclass innerclass
innerclass addinterface classhelper generated_closure_type
string innerclassinternalname   bytecodehelper getclassinternalname innerclass
passingclosureparams   true
list constructors   innerclass getdeclaredconstructors
constructornode node    constructornode  constructors get 0
parameter localvariableparams   node getparameters
mv visittypeinsn new  innerclassinternalname
mv visitinsn dup
if  isstaticmethod       classnode declaresinterface classhelper generated_closure_type
visitclassexpression new classexpression classnode
visitclassexpression new classexpression getoutermostclass
else
mv visitvarinsn aload  0
loadthis
// now let's load the various parameters we're passing
// we start at index 1 because the first variable we pass
// is the owner instance and at this point it is already
// on the stack
for  int i   2  i < localvariableparams length  i
parameter param   localvariableparams
string name   param getname
// compilestack.containsvariable(name) means to ask if the variable is already declared
// compilestack.getscope().isreferencedclassvariable(name) means to ask if the variable is a field
// if it is no field and is not yet declared, then it is either a closure shared variable or
// an already declared variable.
if   compilestack containsvariable name     compilestack getscope   isreferencedclassvariable name
visitfieldexpression new fieldexpression classnode getdeclaredfield name
else
variable v   compilestack getvariable name  classnode getsuperclass      classhelper closure_type
if  v    null
// variable is not on stack because we are
// inside a nested closure and this variable
// was not used before
// then load it from the closure field
fieldnode field   classnode getdeclaredfield name
mv visitvarinsn aload  0
mv visitfieldinsn getfield  internalclassname  name  bytecodehelper gettypedescription field gettype
// and define it
// note:
// we can simply define it here and don't have to
// be afraid about name problems because a second
// variable with that name is not allowed inside the closure
param setclosuresharedvariable false
v   compilestack definevariable param  true
param setclosuresharedvariable true
v setholder true
mv visitvarinsn aload  v getindex
passingclosureparams   false
// we may need to pass in some other constructors
//cv.visitmethodinsn(invokespecial, innerclassinternalname, "<init>", prototype + ")v");
mv visitmethodinsn
invokespecial
innerclassinternalname
bytecodehelper getmethoddescriptor classhelper void_type  localvariableparams
/**
* loads either this object or if we're inside a closure then load the top level owner
*/
protected void loadthisorowner
if  isinnerclass
visitfieldexpression new fieldexpression classnode getdeclaredfield
else
loadthis
public void visitregexexpression regexexpression expression
expression getregex   visit this
regexpattern call mv
/**
* generate byte code for constants
*
* @see <a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/classfile.doc.html#14152">class field types</a>
*/
public void visitconstantexpression constantexpression expression
final string constantname   expression getconstantname
if   methodnode    null    methodnode getname   equals        constantname    null
object value   expression getvalue
helper loadconstant value
else
mv visitfieldinsn getstatic  internalclassname constantname  bytecodehelper gettypedescription expression gettype
public void visitspreadexpression spreadexpression expression
throw new groovybugerror
public void visitspreadmapexpression spreadmapexpression expression
expression subexpression   expression getexpression
subexpression visit this
spreadmap call mv
public void visitmethodpointerexpression methodpointerexpression expression
expression subexpression   expression getexpression
subexpression visit this
loaddynamicname expression getmethodname
getmethodpointer call mv
private void loaddynamicname expression name
if  name instanceof constantexpression
constantexpression ce    constantexpression  name
object value   ce getvalue
if  value instanceof string
helper loadconstant value
return
new castexpression classhelper string_type  name  visit this
public void visitunaryminusexpression unaryminusexpression expression
expression subexpression   expression getexpression
subexpression visit this
unaryminus call mv
public void visitunaryplusexpression unaryplusexpression expression
expression subexpression   expression getexpression
subexpression visit this
unaryplus call mv
public void visitbitwisenegationexpression bitwisenegationexpression expression
expression subexpression   expression getexpression
subexpression visit this
bitwisenegate call mv
public void visitcastexpression castexpression castexpression
classnode type   castexpression gettype
visitandautoboxboolean castexpression getexpression
final classnode rht   righthandtype
righthandtype   castexpression getexpression   gettype
doconvertandcast type  castexpression getexpression    castexpression isignoringautoboxing    false  castexpression iscoerce
righthandtype   rht
public void visitnotexpression notexpression expression
expression subexpression   expression getexpression
subexpression visit this
// if we do !object, then the cast to boolean will
// do the conversion of object to boolean. so a simple
// call to unbox is enough here.
if
iscomparisonexpression subexpression
subexpression instanceof booleanexpression
helper unbox boolean class
helper negateboolean
/**
* return a primitive boolean value of the booleanexpresion.
*
* @param expression
*/
public void visitbooleanexpression booleanexpression expression
compilestack pushbooleanexpression
expression getexpression   visit this
if   iscomparisonexpression expression getexpression
// comment out for optimization when boolean values are not autoboxed for eg. function calls.
//           class typeclass = expression.getexpression().gettypeclass();
//           if (typeclass != null && typeclass != boolean.class) {
helper unbox boolean class      to return a primitive boolean
//            }
compilestack pop
private void makeinvokemethodcall methodcallexpression call  boolean usesuper  methodcallermultiadapter adapter
// receiver
// we operate on groovyobject if possible
expression objectexpression   call getobjectexpression
if   isstaticmethod       isstaticcontext      isthisexpression call getobjectexpression
objectexpression   new castexpression classnode  objectexpression
// message name
expression messagename   new castexpression classhelper string_type  call getmethod
if  usesuper
makecall new classexpression getoutermostclass   getsuperclass
objectexpression  messagename
call getarguments    adapter
call issafe    call isspreadsafe
false
else
makecall objectexpression  messagename
call getarguments    adapter
call issafe    call isspreadsafe
call isimplicitthis
private void makecall
expression receiver  expression message  expression arguments
methodcallermultiadapter adapter
boolean safe  boolean spreadsafe  boolean implicitthis
classnode cn   classnode
if  isinclosure       implicitthis
cn   getoutermostclass
makecall new classexpression cn   receiver  message  arguments
adapter  safe  spreadsafe  implicitthis
private void makecall
classexpression sender
expression receiver  expression message  expression arguments
methodcallermultiadapter adapter
boolean safe  boolean spreadsafe  boolean implicitthis
if   adapter    invokemethod    adapter    invokemethodoncurrent    adapter    invokestaticmethod     spreadsafe
string methodname   getmethodname message
if  methodname    null
makecallsite receiver  methodname  arguments  safe  implicitthis  adapter    invokemethodoncurrent  adapter    invokestaticmethod
return
// ensure variablearguments are read, not stored
boolean lhs   lefthandexpression
lefthandexpression   false
// sender
sender visit this
// receiver
boolean oldval   this implicitthis
this implicitthis   implicitthis
visitandautoboxboolean receiver
this implicitthis   oldval
// message
if  message    null  message visit this
// arguments
boolean containsspreadexpression   containsspreadexpression arguments
int numberofarguments   containsspreadexpression ?  1   argumentsize arguments
if  numberofarguments > methodcallermultiadapter max_args    containsspreadexpression
argumentlistexpression ae
if  arguments instanceof argumentlistexpression
ae    argumentlistexpression  arguments
else if  arguments instanceof tupleexpression
tupleexpression te    tupleexpression  arguments
ae   new argumentlistexpression te getexpressions
else
ae   new argumentlistexpression
ae addexpression arguments
if  containsspreadexpression
despreadlist ae getexpressions    true
else
ae visit this
else if  numberofarguments > 0
tupleexpression te    tupleexpression  arguments
for  int i   0  i < numberofarguments  i
expression argument   te getexpression i
visitandautoboxboolean argument
if  argument instanceof castexpression  loadwrapper argument
adapter call mv  numberofarguments  safe  spreadsafe
lefthandexpression   lhs
private void makegetpropertysite expression receiver  string methodname  boolean safe  boolean implicitthis
if  isnotclinit
mv visitvarinsn aload  callsitearrayvarindex
else
mv visitmethodinsn invokestatic internalclassname
final int index   allocateindex methodname
mv visitldcinsn index
mv visitinsn aaload
// site
boolean lhs   lefthandexpression
lefthandexpression   false
boolean oldval   this implicitthis
this implicitthis   implicitthis
visitandautoboxboolean receiver
this implicitthis   oldval
if   safe
mv visitmethodinsn invokeinterface
else
mv visitmethodinsn invokeinterface
lefthandexpression   lhs
private void makegroovyobjectgetpropertysite expression receiver  string methodname  boolean safe  boolean implicitthis
if  isnotclinit
mv visitvarinsn aload  callsitearrayvarindex
else
mv visitmethodinsn invokestatic internalclassname
final int index   allocateindex methodname
mv visitldcinsn index
mv visitinsn aaload
// site
boolean lhs   lefthandexpression
lefthandexpression   false
boolean oldval   this implicitthis
this implicitthis   implicitthis
visitandautoboxboolean receiver
this implicitthis   oldval
if   safe
mv visitmethodinsn invokeinterface
else
mv visitmethodinsn invokeinterface
lefthandexpression   lhs
private string getmethodname expression message
string methodname   null
if  message instanceof castexpression
castexpression msg    castexpression  message
if  msg gettype      classhelper string_type
final expression methodexpr   msg getexpression
if  methodexpr instanceof constantexpression
methodname   methodexpr gettext
if  methodname    null    message instanceof constantexpression
constantexpression constantexpression    constantexpression  message
methodname   constantexpression gettext
return methodname
private void makecallsite expression receiver  string message  expression arguments  boolean safe  boolean implicitthis  boolean callcurrent  boolean callstatic
if  isnotclinit
mv visitvarinsn aload  callsitearrayvarindex
else
mv visitmethodinsn invokestatic internalclassname
final int index   allocateindex message
mv visitldcinsn index
mv visitinsn aaload
boolean constructor   message equals constructor
// ensure variablearguments are read, not stored
boolean lhs   lefthandexpression
lefthandexpression   false
// receiver
boolean oldval   this implicitthis
this implicitthis   implicitthis
visitandautoboxboolean receiver
this implicitthis   oldval
// arguments
boolean containsspreadexpression   containsspreadexpression arguments
int numberofarguments   containsspreadexpression ?  1   argumentsize arguments
if  numberofarguments > methodcallermultiadapter max_args    containsspreadexpression
argumentlistexpression ae
if  arguments instanceof argumentlistexpression
ae    argumentlistexpression  arguments
else if  arguments instanceof tupleexpression
tupleexpression te    tupleexpression  arguments
ae   new argumentlistexpression te getexpressions
else
ae   new argumentlistexpression
ae addexpression arguments
if  containsspreadexpression
numberofarguments    1
despreadlist ae getexpressions    true
else
numberofarguments   ae getexpressions   size
for  int i   0  i < numberofarguments  i
expression argument   ae getexpression i
visitandautoboxboolean argument
if  argument instanceof castexpression  loadwrapper argument
if  numberofarguments     1
// despreaded array already on stack
else
if  numberofarguments > 4
final string createarraysignature   getcreatearraysignature numberofarguments
mv visitmethodinsn invokestatic        createarraysignature
final string desc   getdescforparamnum numberofarguments
if  callstatic
mv visitmethodinsn invokeinterface           desc
else
if  constructor
mv visitmethodinsn invokeinterface           desc
else
if  callcurrent
mv visitmethodinsn invokeinterface           desc
else
if  safe
mv visitmethodinsn invokeinterface           desc
else
mv visitmethodinsn invokeinterface           desc
lefthandexpression   lhs
private static string getdescforparamnum int numberofarguments
switch  numberofarguments
case 0
return
case 1
return
case 2
return
case 3
return
case 4
return
default
return
private static string  sig   new string
private static string getcreatearraysignature int numberofarguments
if  sig    null
stringbuilder sb   new stringbuilder
for  int i   0  i    numberofarguments    i
sb append
sb append
sig   sb tostring
return sig
private final static hashset<string> names   new hashset<string>
private final static hashset<string> basic   new hashset<string>
static
collections addall names
collections addall basic
private void makebinopcallsite binaryexpression bin  string message
final expression left   bin getleftexpression
final expression right   bin getrightexpression
if   names contains message
makebinopcallsite left  message  right
else
improveexprtype bin
classnode type1   getlhstype left
classnode type2   getlhstype right
if  classhelper isnumbertype type1     classhelper isnumbertype type2
classnode prim1   classhelper getunwrapper type1
classnode prim2   classhelper getunwrapper type2
if  message equals       prim1    classhelper int_type    prim2    classhelper int_type
makebinopcallsite left  message  right
return
classnode rettype
if  prim1    classhelper double_type    prim2    classhelper double_type
rettype   classhelper double_type
else
if  prim1    classhelper float_type    prim2    classhelper float_type
rettype   classhelper double_type
else
if  prim1    classhelper long_type    prim2    classhelper long_type
rettype   classhelper long_type
else
rettype   classhelper int_type
if  rettype    classhelper double_type     basic contains message
makebinopcallsite left  message  right
return
if  left instanceof constantexpression
mv visitldcinsn   constantexpression left  getvalue
else
visitandautoboxboolean left
helper unbox prim1
if  right instanceof constantexpression
mv visitldcinsn   constantexpression right  getvalue
else
visitandautoboxboolean right
helper unbox prim2
mv visitmethodinsn invokestatic     message      bytecodehelper gettypedescription prim1    bytecodehelper gettypedescription prim2        bytecodehelper gettypedescription rettype
helper box rettype
else
makebinopcallsite left  message  right
private void improveexprtype expression expr
if  expr instanceof binaryexpression
if  classhelper isnumbertype expr gettype
return
final binaryexpression bin    binaryexpression  expr
string message
switch  bin getoperation   gettype
case types bitwise_and
message
break
case types bitwise_or
message
break
case types bitwise_xor
message
break
case types plus
message
break
case types minus
message
break
case types multiply
message
break
case types divide
message
break
case types intdiv
message
break
case types mod
message
break
case types left_shift
message
break
case types right_shift
message
break
case types right_shift_unsigned
message
break
if   names contains message
return
improveexprtype bin getleftexpression
improveexprtype bin getrightexpression
classnode type1   getlhstype bin getleftexpression
classnode type2   getlhstype bin getrightexpression
if  classhelper isnumbertype type1     classhelper isnumbertype type2
classnode prim1   classhelper getunwrapper type1
classnode prim2   classhelper getunwrapper type2
if  message equals       prim1    classhelper int_type    prim2    classhelper int_type
return
classnode rettype
if  prim1    classhelper double_type    prim2    classhelper double_type
rettype   classhelper double_type
else
if  prim1    classhelper float_type    prim2    classhelper float_type
rettype   classhelper double_type
else
if  prim1    classhelper long_type    prim2    classhelper long_type
rettype   classhelper long_type
else
rettype   classhelper int_type
if  rettype    classhelper double_type     basic contains message
return
bin settype rettype
private void makebinopcallsite expression receiver  string message  expression arguments
preparecallsite message
// site
// ensure variablearguments are read, not stored
boolean lhs   lefthandexpression
lefthandexpression   false
boolean oldval   this implicitthis
this implicitthis   false
visitandautoboxboolean receiver
this implicitthis   oldval
visitandautoboxboolean arguments
mv visitmethodinsn invokeinterface
lefthandexpression   lhs
private void preparecallsite string message
if  isnotclinit
mv visitvarinsn aload  callsitearrayvarindex
else
mv visitmethodinsn invokestatic internalclassname
final int index   allocateindex message
mv visitldcinsn index
mv visitinsn aaload
private int allocateindex string name
callsites add name
return callsites size   1
private void despreadlist list expressions  boolean wrap
arraylist spreadindexes   new arraylist
arraylist spreadexpressions   new arraylist
arraylist normalarguments   new arraylist
for  int i   0  i < expressions size    i
object expr   expressions get i
if    expr instanceof spreadexpression
normalarguments add expr
else
spreadindexes add new constantexpression integer valueof i   spreadexpressions size
spreadexpressions add   spreadexpression  expr  getexpression
//load normal arguments as array
visittupleexpression new argumentlistexpression normalarguments   wrap
//load spread expressions as array
new tupleexpression spreadexpressions   visit this
//load insertion index
new arrayexpression classhelper int_type  spreadindexes  null   visit this
despreadlist call mv
public void visitmethodcallexpression methodcallexpression call
onlinenumber call
expression arguments   call getarguments
string methodname   call getmethodasstring
boolean issupermethodcall   usessuper call
boolean isthisexpression   isthisexpression call getobjectexpression
// are we a local variable?
if  methodname    null    isthisexpression    isfieldorvariable methodname      classnode haspossiblemethod methodname  arguments
// let's invoke the closure method
visitvariableexpression new variableexpression methodname
if  arguments instanceof tupleexpression
arguments visit this
else
new tupleexpression arguments  visit this
invokeclosuremethod call mv
else
methodcallermultiadapter adapter   invokemethod
if  isthisexpression  adapter   invokemethodoncurrent
if  issupermethodcall  adapter   invokemethodonsuper
if  isstaticinvocation call   adapter   invokestaticmethod
makeinvokemethodcall call  issupermethodcall  adapter
private boolean isstaticinvocation methodcallexpression call
if   isthisexpression call getobjectexpression     return false
if  isstaticmethod    return true
return isstaticcontext       call isimplicitthis
protected boolean emptyarguments expression arguments
return argumentsize arguments     0
protected static boolean containsspreadexpression expression arguments
list args   null
if  arguments instanceof tupleexpression
tupleexpression tupleexpression    tupleexpression  arguments
args   tupleexpression getexpressions
else if  arguments instanceof listexpression
listexpression le    listexpression  arguments
args   le getexpressions
else
return arguments instanceof spreadexpression
for  iterator iter   args iterator    iter hasnext
if  iter next   instanceof spreadexpression  return true
return false
protected static int argumentsize expression arguments
if  arguments instanceof tupleexpression
tupleexpression tupleexpression    tupleexpression  arguments
int size   tupleexpression getexpressions   size
return size
return 1
public void visitstaticmethodcallexpression staticmethodcallexpression call
onlinenumber call
makecall
new classexpression call getownertype
new constantexpression call getmethod
call getarguments
invokestaticmethod
false  false  false
private void addgeneratedclosureconstructorcall constructorcallexpression call
mv visitvarinsn aload  0
classnode callnode   classnode getsuperclass
tupleexpression arguments    tupleexpression  call getarguments
if  arguments getexpressions   size    2  throw new groovybugerror   arguments getexpressions   size
arguments getexpression 0  visit this
arguments getexpression 1  visit this
parameter p   new parameter classhelper object_type
string descriptor   helper getmethoddescriptor classhelper void_type  new parameter p p
mv visitmethodinsn invokespecial  bytecodehelper getclassinternalname callnode      descriptor
private void visitspecialconstructorcall constructorcallexpression call
if  classnode declaresinterface classhelper generated_closure_type
addgeneratedclosureconstructorcall call
return
classnode callnode   classnode
if  call issupercall    callnode   callnode getsuperclass
list constructors   sortconstructors call  callnode
call getarguments   visit this
// keep object[] on stack
mv visitinsn dup
// to select the constructor we need also the number of
// available constructors and the class we want to make
// the call on
helper pushconstant constructors size
visitclassexpression new classexpression callnode
// removes one object[] leaves the int containing the
// call flags and the construtcor number
selectconstructorandtransformarguments call mv
// object[],int -> int,object[],int
// we need to examine the flags and maybe change the
// object[] later, so this reordering will do the job
mv visitinsn dup_x1
// test if rewrap flag is set
mv visitinsn iconst_1
mv visitinsn iand
label afterif   new label
mv visitjumpinsn ifeq  afterif
// true part, so rewrap using the first argument
mv visitinsn iconst_0
mv visitinsn aaload
mv visittypeinsn checkcast
mv visitlabel afterif
// here the stack is int,object[], but we need the
// the int for our table, so swap it
mv visitinsn swap
//load "this"
if  constructornode  null
mv visitvarinsn aload  0
else
mv visittypeinsn new  bytecodehelper getclassinternalname callnode
mv visitinsn swap
//prepare switch with >>8
mv visitintinsn bipush  8
mv visitinsn ishr
label targets   new label
int indices   new int
for  int i   0  i < targets length  i
targets   new label
indices   i
// create switch targets
label defaultlabel   new label
label afterswitch   new label
mv visitlookupswitchinsn defaultlabel  indices  targets
for  int i   0  i < targets length  i
mv visitlabel targets
// to keep the stack height, we need to leave
// one object[] on the stack as last element. at the
// same time, we need the object[] on top of the stack
// to extract the parameters.
if  constructornode  null
// in this case we need one "this", so a swap will exchange
// "this" and object[], a dup_x1 will then copy the object[]
/// to the last place in the stack:
//     object[],this -swap-> this,object[]
//     this,object[] -dup_x1-> object[],this,object[]
mv visitinsn swap
mv visitinsn dup_x1
else
// in this case we need two "this" in between and the object[]
// at the bottom of the stack as well as on top for our invokespecial
// so we do dup_x1, dup2_x1, pop
//     object[],this -dup_x1-> this,object[],this
//     this,object[],this -dup2_x1-> object[],this,this,object[],this
//     object[],this,this,object[],this -pop->  object[],this,this,object[]
mv visitinsn dup_x1
mv visitinsn dup2_x1
mv visitinsn pop
constructornode cn    constructornode  constructors get i
string descriptor   helper getmethoddescriptor classhelper void_type  cn getparameters
// unwrap the object[] and make transformations if needed
// that means, to duplicate the object[], make a cast with possible
// unboxing and then swap it with the object[] for each parameter
parameter parameters   cn getparameters
for  int p   0  p < parameters length  p
mv visitinsn dup
helper pushconstant p
mv visitinsn aaload
classnode type   parameters gettype
if  classhelper isprimitivetype type
helper unbox type
else
helper docast type
helper swapwithobject type
// at the end we remove the object[]
mv visitinsn pop
// make the constructor call
mv visitmethodinsn invokespecial  bytecodehelper getclassinternalname callnode      descriptor
mv visitjumpinsn goto  afterswitch
mv visitlabel defaultlabel
// this part should never be reached!
mv visittypeinsn new
mv visitinsn dup
mv visitldcinsn
mv visitmethodinsn invokespecial
mv visitinsn athrow
mv visitlabel afterswitch
// to keep the stack hight we kept one object on the stack
// for the switch, now we remove that object
if  constructornode  null
// but in case we are not in a constructor we have an additional
// object on the stack, the result of our constructor call
// which we want to keep, so we swap the arguments to remove
// the right one
mv visitinsn swap
mv visitinsn pop
private list sortconstructors constructorcallexpression call  classnode callnode
// sort in a new list to prevent side effects
list constructors   new arraylist callnode getdeclaredconstructors
comparator comp   new comparator
public int compare object arg0  object arg1
constructornode c0    constructornode  arg0
constructornode c1    constructornode  arg1
string descriptor0   helper getmethoddescriptor classhelper void_type  c0 getparameters
string descriptor1   helper getmethoddescriptor classhelper void_type  c1 getparameters
return descriptor0 compareto descriptor1
collections sort constructors  comp
return constructors
public void visitconstructorcallexpression constructorcallexpression call
onlinenumber call
if  call isspecialcall
visitspecialconstructorcall call
return
expression arguments   call getarguments
if  arguments instanceof tupleexpression
tupleexpression tupleexpression    tupleexpression  arguments
int size   tupleexpression getexpressions   size
if  size    0
arguments   methodcallexpression no_arguments
expression receiverclass   new classexpression call gettype
makecallsite
receiverclass  constructor
arguments false  false  false
false
private static string makefieldclassname classnode type
string internalname   bytecodehelper getclassinternalname type
stringbuffer ret   new stringbuffer internalname length
for  int i   0  i < internalname length    i
char c   internalname charat i
if  c
ret append
else if  c
//append nothing -> delete ';'
else
ret append c
return ret tostring
private static string getstaticfieldname classnode type
classnode componenttype   type
string prefix
for    componenttype isarray    componenttype   componenttype getcomponenttype
prefix
if  prefix length      0  prefix       prefix
string name   prefix       makefieldclassname componenttype
return name
private void visitattributeorproperty propertyexpression expression  methodcallermultiadapter adapter
expression objectexpression   expression getobjectexpression
if  isthisorsuper objectexpression
// let's use the field expression if it's available
string name   expression getpropertyasstring
if  name    null
fieldnode field   null
if  issuperexpression objectexpression
field   classnode getsuperclass   getdeclaredfield name
else
field   classnode getdeclaredfield name
if  field    null
visitfieldexpression new fieldexpression field
return
if  issuperexpression objectexpression
string prefix
if  lefthandexpression
prefix
else
prefix
string propname   prefix   metaclasshelper capitalize name
visitmethodcallexpression new methodcallexpression objectexpression  propname  methodcallexpression no_arguments
return
final string methodname   expression getpropertyasstring
if  adapter    getproperty     expression isspreadsafe      methodname    null
makegetpropertysite objectexpression  methodname  expression issafe    expression isimplicitthis
else
// arguments already on stack if any
if  adapter    getgroovyobjectproperty     expression isspreadsafe      methodname    null
makegroovyobjectgetpropertysite objectexpression  methodname  expression issafe    expression isimplicitthis
else
makecall
objectexpression     receiver
new castexpression classhelper string_type  expression getproperty        messagename
methodcallexpression no_arguments
adapter
expression issafe    expression isspreadsafe    expression isimplicitthis
private boolean isstaticcontext
if   isinclosure    return false
if  constructornode    null  return false
return classnode isstaticclass      methodnode isstatic
public void visitpropertyexpression propertyexpression expression
expression objectexpression   expression getobjectexpression
methodcallermultiadapter adapter
if  lefthandexpression
adapter   setproperty
if  isgroovyobject objectexpression   adapter   setgroovyobjectproperty
if  isstaticcontext      isthisorsuper objectexpression   adapter   setproperty
else
adapter   getproperty
if  isgroovyobject objectexpression   adapter   getgroovyobjectproperty
if  isstaticcontext      isthisorsuper objectexpression   adapter   getproperty
visitattributeorproperty expression  adapter
public void visitattributeexpression attributeexpression expression
expression objectexpression   expression getobjectexpression
methodcallermultiadapter adapter
if  lefthandexpression
adapter   setfield
if  isgroovyobject objectexpression   adapter   setgroovyobjectfield
if  usessuper expression   adapter   setfieldonsuper
else
adapter   getfield
if  isgroovyobject objectexpression   adapter   getgroovyobjectfield
if  usessuper expression   adapter   getfieldonsuper
visitattributeorproperty expression  adapter
protected boolean isgroovyobject expression objectexpression
return isthisexpression objectexpression     objectexpression gettype   isderivedfromgroovyobject        objectexpression instanceof classexpression
public void visitfieldexpression fieldexpression expression
fieldnode field   expression getfield
if  field isstatic
if  lefthandexpression
storestaticfield expression
else
loadstaticfield expression
else
if  lefthandexpression
storethisinstancefield expression
else
loadinstancefield expression
/**
* @param fldexp
*/
public void loadstaticfield fieldexpression fldexp
fieldnode field   fldexp getfield
boolean holder   field isholder       isinclosureconstructor
classnode type   field gettype
string ownername    field getowner   equals classnode
? internalclassname
bytecodehelper getclassinternalname field getowner
if  holder
mv visitfieldinsn getstatic  ownername  fldexp getfieldname    bytecodehelper gettypedescription type
mv visitmethodinsn invokevirtual
else
mv visitfieldinsn getstatic  ownername  fldexp getfieldname    bytecodehelper gettypedescription type
if  classhelper isprimitivetype type
helper box type
else
/**
* rhs instance field. should move most of the code in the bytecodehelper
*
* @param fldexp
*/
public void loadinstancefield fieldexpression fldexp
fieldnode field   fldexp getfield
boolean holder   field isholder       isinclosureconstructor
classnode type   field gettype
string ownername    field getowner   equals classnode
? internalclassname
helper getclassinternalname field getowner
mv visitvarinsn aload  0
mv visitfieldinsn getfield  ownername  fldexp getfieldname    bytecodehelper gettypedescription type
if  holder
mv visitmethodinsn invokevirtual
else
if  classhelper isprimitivetype type
helper box type
else
public void storethisinstancefield fieldexpression expression
fieldnode field   expression getfield
boolean holder   field isholder       isinclosureconstructor
classnode type   field gettype
string ownername    field getowner   equals classnode   ?
internalclassname   bytecodehelper getclassinternalname field getowner
if  holder
mv visitvarinsn aload  0
mv visitfieldinsn getfield  ownername  expression getfieldname    bytecodehelper gettypedescription type
mv visitinsn swap
mv visitmethodinsn invokevirtual
else
if  isinclosureconstructor
helper docast type
else if   classhelper isprimitivetype type
doconvertandcast type
mv visitvarinsn aload  0
//helper.swapobjectwith(type);
mv visitinsn swap
helper unbox type
helper putfield field  ownername
public void storestaticfield fieldexpression expression
fieldnode field   expression getfield
boolean holder   field isholder       isinclosureconstructor
classnode type   field gettype
string ownername    field getowner   equals classnode
? internalclassname
helper getclassinternalname field getowner
if  holder
mv visitfieldinsn getstatic  ownername  expression getfieldname    bytecodehelper gettypedescription type
mv visitinsn swap
mv visitmethodinsn invokevirtual
else
helper docast type
mv visitfieldinsn putstatic  ownername  expression getfieldname    bytecodehelper gettypedescription type
protected void visitouterfieldexpression fieldexpression expression  classnode outerclassnode  int steps  boolean first
fieldnode field   expression getfield
boolean isstatic   field isstatic
int tempidx   compilestack definetemporaryvariable field  lefthandexpression    first
if  steps > 1     isstatic
mv visitvarinsn aload  0
mv visitfieldinsn
getfield
internalclassname
bytecodehelper gettypedescription outerclassnode
if  steps    1
int opcode    lefthandexpression  ?   isstatic  ? putstatic   putfield      isstatic  ? getstatic   getfield
string ownername   bytecodehelper getclassinternalname outerclassnode
if  lefthandexpression
mv visitvarinsn aload  tempidx
boolean holder   field isholder       isinclosureconstructor
if   holder
doconvertandcast field gettype
mv visitfieldinsn opcode  ownername  expression getfieldname    bytecodehelper gettypedescription field gettype
if   lefthandexpression
if  classhelper isprimitivetype field gettype
helper box field gettype
else
visitouterfieldexpression expression  outerclassnode getouterclass    steps   1  false
/**
* visits a bare (unqualified) variable expression.
*/
public void
visitvariableexpression variableexpression expression
string variablename   expression getname
//-----------------------------------------------------------------------
// special cases
//
// "this" for static methods is the class instance
classnode classnode   this classnode
if  isinclosure    classnode   getoutermostclass
if  variablename equals
if  isstaticmethod        implicitthis    isstaticcontext
visitclassexpression new classexpression classnode
else
loadthis
return
//
// "super" also requires special handling
if  variablename equals
if  isstaticmethod
visitclassexpression new classexpression classnode getsuperclass
else
loadthis
return                                                   <<< flow control <<<<<<<<<
variable variable   compilestack getvariable variablename  false
variablescope scope   compilestack getscope
if  variable    null
processclassvariable variablename
else
processstackvariable variable
private void loadthis
mv visitvarinsn aload  0
if   implicitthis    isinclosure
mv visitmethodinsn
invokevirtual
protected void processstackvariable variable variable
if  lefthandexpression
helper storevar variable
else
helper loadvar variable
if  asm_debug
helper mark     variable getname
protected void processclassvariable string name
if  passingclosureparams    isinscriptbody
// let's create a scriptreference to pass into the closure
mv visittypeinsn new
mv visitinsn dup
loadthisorowner
mv visitldcinsn name
mv visitmethodinsn
invokespecial
else
propertyexpression pexp   new propertyexpression variableexpression this_expression  name
pexp setimplicitthis true
visitpropertyexpression pexp
protected void processfieldaccess string name  fieldnode field  int steps
fieldexpression expression   new fieldexpression field
if  steps    0
visitfieldexpression expression
else
visitouterfieldexpression expression  classnode getouterclass    steps  true
/**
* @return true if we are in a script body, where all variables declared are no longer
*         local variables but are properties
*/
protected boolean isinscriptbody
if  classnode isscriptbody
return true
else
return classnode isscript      methodnode    null    methodnode getname   equals
/**
* @return true if this expression will have left a value on the stack
*         that must be popped
*/
protected boolean ispoprequired expression expression
if  expression instanceof methodcallexpression
return expression gettype      classhelper void_type
if  expression instanceof declarationexpression
return false
if  expression instanceof binaryexpression
binaryexpression binexp    binaryexpression  expression
switch  binexp getoperation   gettype           br todo should leave a copy of the value on the stack for all the assignemnt
//                case types.equal :   // br a copy of the right value is left on the stack (see evaluateequal()) so a pop is required for a standalone assignment
//                case types.plus_equal : // this and the following are related to evaluatebinaryexpressionwithassignment()
//                case types.minus_equal :
//                case types.multiply_equal :
//                case types.divide_equal :
//                case types.intdiv_equal :
//                case types.mod_equal :
//                    return false;
if  expression instanceof constructorcallexpression
constructorcallexpression cce    constructorcallexpression  expression
return  cce isspecialcall
return true
protected void createinterfacesyntheticstaticfields
if  referencedclasses isempty    return
addinnerclass interfaceclassloadingclass
for  iterator iter   referencedclasses iterator    iter hasnext
classref ref    classref  iter next
string staticfieldname   getstaticfieldname ref type
// generate a field node
interfaceclassloadingclass addfield staticfieldname  acc_static   acc_synthetic  classhelper class_type  null
protected void createsyntheticstaticfields
for  iterator iter   referencedclasses iterator    iter hasnext
classref ref    classref  iter next
string staticfieldname   getstaticfieldname ref type
// generate a field node
fieldnode fn   classnode getdeclaredfield staticfieldname
if  fn    null
boolean type   fn gettype      classhelper class_type
boolean modifiers   fn getmodifiers      acc_static   acc_synthetic
if   type     modifiers
string text
if   type  text       fn gettype
if   modifiers
text       fn getmodifiers          acc_static   acc_synthetic
throwexception
staticfieldname       classnode getname
text
else
cv visitfield acc_private   acc_static   acc_synthetic  staticfieldname     null  null
mv   cv visitmethod acc_private   acc_static   acc_synthetic      staticfieldname   null  null
mv visitcode
mv visitfieldinsn getstatic internalclassname staticfieldname
mv visitinsn dup
label l0   new label
mv visitjumpinsn ifnonnull l0
mv visitinsn pop
mv visitldcinsn bytecodehelper getclassloadingtypedescription ref type
mv visitmethodinsn invokestatic internalclassname
mv visitinsn dup
mv visitfieldinsn putstatic internalclassname staticfieldname
mv visitlabel l0
mv visitinsn areturn
mv visitmaxs 0 0
mv visitend
mv
cv visitmethod
acc_static   acc_synthetic


label l0   new label
mv visitlabel l0
mv visitvarinsn aload  0
mv visitmethodinsn invokestatic
label l1   new label
mv visitlabel l1
mv visitinsn areturn
label l2   new label
mv visitlabel l2
mv visitvarinsn astore  1
mv visittypeinsn new
mv visitinsn dup
mv visitvarinsn aload  1
mv visitmethodinsn invokevirtual
mv visitmethodinsn invokespecial
mv visitinsn athrow
mv visittrycatchblock l0  l2  l2         br using l2 as the 2nd param seems create the right table entry
mv visitmaxs 3  2
/**
* load class object on stack
*/
public void visitclassexpression classexpression expression
classnode type   expression gettype
if  classhelper isprimitivetype type
classnode objecttype   classhelper getwrapper type
mv visitfieldinsn getstatic  bytecodehelper getclassinternalname objecttype
else
string staticfieldname   getstaticfieldname type
referencedclasses add new classref type
string internalclassname   this internalclassname
if  classnode isinterface
internalclassname   bytecodehelper getclassinternalname interfaceclassloadingclass
mv visitmethodinsn invokestatic  internalclassname      staticfieldname
public void visitrangeexpression rangeexpression expression
expression getfrom   visit this
expression getto   visit this
helper pushconstant expression isinclusive
createrangemethod call mv
public void visitmapentryexpression mapentryexpression expression
throw new groovybugerror
public void visitmapexpression mapexpression expression
list entries   expression getmapentryexpressions
int size   entries size
helper pushconstant size   2
mv visittypeinsn anewarray
int i   0
for  iterator iter   entries iterator    iter hasnext
object object   iter next
mapentryexpression entry    mapentryexpression  object
mv visitinsn dup
helper pushconstant i
visitandautoboxboolean entry getkeyexpression
mv visitinsn aastore
mv visitinsn dup
helper pushconstant i
visitandautoboxboolean entry getvalueexpression
mv visitinsn aastore
createmapmethod call mv
public void visitargumentlistexpression argumentlistexpression ale
if  containsspreadexpression ale
despreadlist ale getexpressions    true
else
visittupleexpression ale  true
public void visittupleexpression tupleexpression expression
visittupleexpression expression  false
private void visittupleexpression tupleexpression expression  boolean usewrapper
int size   expression getexpressions   size
helper pushconstant size
mv visittypeinsn anewarray
for  int i   0  i < size  i
mv visitinsn dup
helper pushconstant i
expression argument   expression getexpression i
visitandautoboxboolean argument
if  usewrapper    argument instanceof castexpression  loadwrapper argument
mv visitinsn aastore
private void loadwrapper expression argument
classnode goalclass   argument gettype
visitclassexpression new classexpression goalclass
if  goalclass isderivedfromgroovyobject
creategroovyobjectwrappermethod call mv
else
createpojowrappermethod call mv
public void visitarrayexpression arrayexpression expression
classnode elementtype   expression getelementtype
string arraytypename   bytecodehelper getclassinternalname elementtype
list sizeexpression   expression getsizeexpression
int size   0
int dimensions   0
if  sizeexpression    null
for  iterator iter   sizeexpression iterator    iter hasnext
expression element    expression  iter next
if  element    constantexpression emtpy_expression  break
dimensions
// let's convert to an int
visitandautoboxboolean element
helper unbox int class
else
size   expression getexpressions   size
helper pushconstant size
int storeins   aastore
if  sizeexpression    null
arraytypename   bytecodehelper gettypedescription expression gettype
mv visitmultianewarrayinsn arraytypename  dimensions
else if  classhelper isprimitivetype elementtype
int primtype   0
if  elementtype    classhelper boolean_type
primtype   t_boolean
storeins   bastore
else if  elementtype    classhelper char_type
primtype   t_char
storeins   castore
else if  elementtype    classhelper float_type
primtype   t_float
storeins   fastore
else if  elementtype    classhelper double_type
primtype   t_double
storeins   dastore
else if  elementtype    classhelper byte_type
primtype   t_byte
storeins   bastore
else if  elementtype    classhelper short_type
primtype   t_short
storeins   sastore
else if  elementtype    classhelper int_type
primtype   t_int
storeins   iastore
else if  elementtype    classhelper long_type
primtype   t_long
storeins   lastore
mv visitintinsn newarray  primtype
else
mv visittypeinsn anewarray  arraytypename
for  int i   0  i < size  i
mv visitinsn dup
helper pushconstant i
expression elementexpression   expression getexpression i
if  elementexpression    null
constantexpression null visit this
else
if   elementtype equals elementexpression gettype
visitcastexpression new castexpression elementtype  elementexpression  true
else
visitandautoboxboolean elementexpression
mv visitinsn storeins
if  sizeexpression    null    classhelper isprimitivetype elementtype
int par   compilestack definetemporaryvariable    true
mv visitvarinsn aload  par
public void visitclosurelistexpression closurelistexpression expression
compilestack pushvariablescope expression getvariablescope
list expressions   expression getexpressions
final int size   expressions size
// init declarations
linkedlist declarations   new linkedlist
for  int i   0  i < size  i
object expr   expressions get i
if  expr instanceof declarationexpression
declarations add expr
declarationexpression de    declarationexpression  expr
binaryexpression be   new binaryexpression
de getleftexpression
de getoperation
de getrightexpression
expressions set i  be
de setrightexpression constantexpression null
visitdeclarationexpression de
linkedlist instructions   new linkedlist
bytecodesequence seq   new bytecodesequence instructions
blockstatement bs   new blockstatement
bs addstatement seq
parameter closureindex   new parameter classhelper int_type
closureexpression ce   new closureexpression new parameter closureindex   bs
ce setvariablescope expression getvariablescope
// to keep stack hight put a null on stack
instructions add constantexpression null
// init table
final label dflt   new label
final label tableend   new label
final label labels   new label
instructions add new bytecodeinstruction
public void visit methodvisitor mv
mv visitvarinsn iload  1
mv visittableswitchinsn 0  size   1  dflt  labels
// visit cases
for  int i   0  i < size  i
final label label   new label
object expr   expressions get i
final boolean isstatement   expr instanceof statement
labels   label
instructions add new bytecodeinstruction
public void visit methodvisitor mv
mv visitlabel label
// expressions will leave a value on stack, statements not
// so expressions need to pop the alibi null
if   isstatement  mv visitinsn pop
instructions add expr
instructions add new bytecodeinstruction
public void visit methodvisitor mv
mv visitjumpinsn goto  tableend
// default case
instructions add new bytecodeinstruction
public void visit methodvisitor mv
mv visitlabel dflt
constantexpression text   new constantexpression
constructorcallexpression cce   new constructorcallexpression classhelper make illegalargumentexception class   text
throwstatement ts   new throwstatement cce
instructions add ts
// return
instructions add new bytecodeinstruction
public void visit methodvisitor mv
mv visitlabel tableend
mv visitinsn areturn
// load main closure
visitclosureexpression ce
// we need later an array to store the curried
// closures, so we create it here and ave it
// in a temporary variable
helper pushconstant size
mv visittypeinsn anewarray
int listarrayvar   compilestack definetemporaryvariable    true
// add curried versions
for  int i   0  i < size  i
// stack: closure
// we need to create a curried closure version
// so we store the type on stack
mv visittypeinsn new
// stack: closure, type
// for a constructor call we need the type two times
// and the closure after them
mv visitinsn dup2
mv visitinsn swap
// stack: closure,type,type,closure
// so we can create the curried closure
helper pushconstant i
mv visitmethodinsn invokespecial
// stack: closure,curriedclosure
// we need to save the result
mv visitvarinsn aload  listarrayvar
mv visitinsn swap
helper pushconstant i
mv visitinsn swap
mv visitinsn aastore
// stack: closure
// we don't need the closure any longer, so remove it
mv visitinsn pop
// we load the array and create a list from it
mv visitvarinsn aload  listarrayvar
createlistmethod call mv
// remove the temporary variable to keep the
// stack clean
compilestack removevar listarrayvar
compilestack pop
public void visitbytecodesequence bytecodesequence bytecodesequence
list instructions   bytecodesequence getinstructions
for  iterator iterator   instructions iterator    iterator hasnext
object part   iterator next
if  part    emptyexpression instance
mv visitinsn aconst_null
else if  part instanceof expression
visitandautoboxboolean  expression  part
else if  part instanceof statement
statement stm    statement  part
stm visit this
mv visitinsn aconst_null
else
bytecodeinstruction runner    bytecodeinstruction  part
runner visit mv
public void visitlistexpression listexpression expression
onlinenumber expression
int size   expression getexpressions   size
boolean containsspreadexpression   containsspreadexpression expression
if   containsspreadexpression
helper pushconstant size
mv visittypeinsn anewarray
for  int i   0  i < size  i
mv visitinsn dup
helper pushconstant i
visitandautoboxboolean expression getexpression i
mv visitinsn aastore
else
despreadlist expression getexpressions    false
createlistmethod call mv
public void visitgstringexpression gstringexpression expression
mv visittypeinsn new
mv visitinsn dup
int size   expression getvalues   size
helper pushconstant size
mv visittypeinsn anewarray
for  int i   0  i < size  i
mv visitinsn dup
helper pushconstant i
visitandautoboxboolean expression getvalue i
mv visitinsn aastore
list strings   expression getstrings
size   strings size
helper pushconstant size
mv visittypeinsn anewarray
for  int i   0  i < size  i
mv visitinsn dup
helper pushconstant i
mv visitldcinsn   constantexpression  strings get i   getvalue
mv visitinsn aastore
mv visitmethodinsn invokespecial
/**
* note: ignore it. annotation generation needs the current visitor.
*/
public void visitannotations annotatednode node
private void visitannotations annotatednode targetnode  object visitor
list annotions   targetnode getannotations
if  annotions isempty    return
iterator it   annotions iterator
while  it hasnext
annotationnode an    annotationnode  it next
//skip builtin properties
if  an isbuiltin    continue
if  an hassourceretention    continue
annotationvisitor av   getannotationvisitor targetnode  an  visitor
visitannotationattributes an  av
av visitend
// todo remove dup between this and visitannotations
private void visitparameterannotations parameter parameter  int paramnumber  methodvisitor mv
list annotions   parameter getannotations
if  annotions isempty    return
iterator it   annotions iterator
while  it hasnext
annotationnode an    annotationnode  it next
//skip builtin properties
if  an isbuiltin    continue
if  an hassourceretention    continue
final string annotationdescriptor   bytecodehelper gettypedescription an getclassnode
annotationvisitor av   mv visitparameterannotation paramnumber  annotationdescriptor  an hasruntimeretention
visitannotationattributes an  av
av visitend
private annotationvisitor getannotationvisitor annotatednode targetnode  annotationnode an  object visitor
final string annotationdescriptor   bytecodehelper gettypedescription an getclassnode
if  targetnode instanceof methodnode
return   methodvisitor  visitor  visitannotation annotationdescriptor  an hasruntimeretention
else if  targetnode instanceof fieldnode
return   fieldvisitor  visitor  visitannotation annotationdescriptor  an hasruntimeretention
else if  targetnode instanceof classnode
return   classvisitor  visitor  visitannotation annotationdescriptor  an hasruntimeretention
throwexception
return null
/**
* generate the annotation attributes.
*/
private void visitannotationattributes annotationnode an  annotationvisitor av
map constantattrs   new hashmap
map enumattrs   new hashmap
map atattrs   new hashmap
map arrayattrs   new hashmap
iterator mit   an getmembers   keyset   iterator
while  mit hasnext
string name    string  mit next
expression expr   an getmember name
if  expr instanceof annotationconstantexpression
atattrs put name    annotationconstantexpression  expr  getvalue
else if  expr instanceof constantexpression
constantattrs put name    constantexpression  expr  getvalue
else if  expr instanceof classexpression
constantattrs put name
type gettype bytecodehelper gettypedescription expr gettype
else if  expr instanceof propertyexpression
enumattrs put name  expr
else if  expr instanceof listexpression
arrayattrs put name  expr
for  iterator it   constantattrs entryset   iterator    it hasnext
map entry entry    map entry  it next
av visit  string  entry getkey    entry getvalue
for  iterator it   enumattrs entryset   iterator    it hasnext
map entry entry    map entry  it next
propertyexpression propexp    propertyexpression  entry getvalue
av visitenum  string  entry getkey
bytecodehelper gettypedescription propexp getobjectexpression   gettype
string valueof   constantexpression  propexp getproperty    getvalue
for  iterator it   atattrs entryset   iterator    it hasnext
map entry entry    map entry  it next
annotationnode atnode    annotationnode  entry getvalue
annotationvisitor av2   av visitannotation  string  entry getkey
bytecodehelper gettypedescription atnode getclassnode
visitannotationattributes atnode  av2
av2 visitend
visitarrayattributes an  arrayattrs  av
private void visitarrayattributes annotationnode an  map arrayattr  annotationvisitor av
if  arrayattr isempty    return
for  iterator it   arrayattr entryset   iterator    it hasnext
map entry entry    map entry  it next
string attrname    string  entry getkey
listexpression listexpr    listexpression  entry getvalue
annotationvisitor av2   av visitarray attrname
list values   listexpr getexpressions
if   values isempty
expression expr    expression  values get 0
int arrayelementtype    1
if  expr instanceof annotationconstantexpression
arrayelementtype   1
else if  expr instanceof constantexpression
arrayelementtype   2
else if  expr instanceof classexpression
arrayelementtype   3
else if  expr instanceof propertyexpression
arrayelementtype   4
for  iterator exprit   listexpr getexpressions   iterator    exprit hasnext
switch  arrayelementtype
case 1
annotationnode atattr
annotationnode    annotationconstantexpression  exprit next    getvalue
annotationvisitor av3   av2 visitannotation null
bytecodehelper gettypedescription atattr getclassnode
visitannotationattributes atattr  av3
av3 visitend
break
case 2
av2 visit null    constantexpression  exprit next    getvalue
break
case 3
av2 visit null  type gettype
bytecodehelper gettypedescription   expression  exprit next    gettype
break
case 4
propertyexpression propexpr    propertyexpression  exprit next
av2 visitenum null
bytecodehelper gettypedescription propexpr getobjectexpression   gettype
string valueof   constantexpression  propexpr getproperty    getvalue
break
av2 visitend
// implementation methods
//-------------------------------------------------------------------------
protected boolean addinnerclass classnode innerclass
innerclass setmodule classnode getmodule
return innerclasses add innerclass
protected classnode createclosureclass closureexpression expression
classnode outerclass   getoutermostclass
string name   outerclass getname
context getnextclosureinnername outerclass  classnode  methodnode      add a more informative name
boolean staticmethodorinstaticclass   isstaticmethod      classnode isstaticclass
parameter parameters   expression getparameters
if  parameters    null
parameters   parameter empty_array
else if  parameters length    0
// let's create a default 'it' parameter
parameters   new parameter new parameter classhelper object_type     constantexpression null
parameter localvariableparams   getclosuresharedvariables expression
removeinitialvalues localvariableparams
innerclassnode answer   new innerclassnode outerclass  name  0  classhelper closure_type      closures are local inners and not public
answer setenclosingmethod this methodnode
answer setsynthetic true
if  staticmethodorinstaticclass
answer setstaticclass true
if  isinscriptbody
answer setscriptbody true
methodnode method
answer addmethod    acc_public  classhelper object_type  parameters  classnode empty_array  expression getcode
method setsourceposition expression
variablescope varscope   expression getvariablescope
if  varscope    null
throw new runtimeexception
expression       name
else
method setvariablescope varscope copy
if  parameters length > 1
parameters length    1
parameters gettype      null
parameters gettype      classhelper object_type
// let's add a typesafe call method
methodnode call   answer addmethod
acc_public,
classhelper object_type
parameters
classnode empty_array
new returnstatement
new methodcallexpression
variableexpression this_expression
new argumentlistexpression parameters
call setsourceposition expression
// let's make the constructor
blockstatement block   new blockstatement
block setsourceposition expression
variableexpression outer   new variableexpression
outer setsourceposition expression
block getvariablescope   putreferencedlocalvariable outer
variableexpression thisobject   new variableexpression
thisobject setsourceposition expression
block getvariablescope   putreferencedlocalvariable thisobject
tupleexpression conargs   new tupleexpression outer  thisobject
block addstatement
new expressionstatement(
new constructorcallexpression
classnode super
conargs
// let's assign all the parameter fields from the outer context
for  int i   0  i < localvariableparams length  i
parameter param   localvariableparams
string paramname   param getname
expression initialvalue   null
classnode type   param gettype
fieldnode paramfield   null
if  true
initialvalue   new variableexpression paramname
classnode realtype   type
type   classhelper makereference
param settype classhelper makereference
paramfield   answer addfield paramname  acc_private  type  initialvalue
paramfield setholder true
string methodname   verifier capitalize paramname
// let's add a getter & setter
expression fieldexp   new fieldexpression paramfield
answer.addmethod(
methodname
acc_public,
realtype
parameter empty_array
classnode empty_array
new returnstatement fieldexp
/*
answer.addmethod(
"set" + methodname,
acc_public,
"void",
new parameter[] { new parameter(realtype, "__value") },
new expressionstatement(
new binaryexpression(expression, token.newsymbol(types.equal, 0, 0), new variableexpression("__value"))));
*/
parameter params   new parameter
params   new parameter classhelper object_type
params   new parameter classhelper object_type
system arraycopy localvariableparams  0  params  2  localvariableparams length
astnode sn   answer addconstructor acc_public  params  classnode empty_array  block
sn setsourceposition expression
return answer
/**
* this method is called for local variables shared between scopes.
* these variables must not have init values because these would
* then in later steps be used to create multiple versions of the
* same method, in this case the constructor. a closure should not
* have more than one constructor!
*/
private void removeinitialvalues parameter params
for  int i   0  i < params length  i
if  params hasinitialexpression
params   new parameter params gettype    params getname
protected parameter getclosuresharedvariables closureexpression ce
variablescope scope   ce getvariablescope
parameter ret   new parameter
int index   0
for  iterator iter   scope getreferencedlocalvariablesiterator    iter hasnext
org codehaus groovy ast variable element    org codehaus groovy ast variable  iter next
parameter p   new parameter element gettype    element getname
ret   p
index
return ret
protected classnode getoutermostclass
if  outermostclass    null
outermostclass   classnode
while  outermostclass instanceof innerclassnode
outermostclass   outermostclass getouterclass
return outermostclass
protected void doconvertandcast classnode type
doconvertandcast type  false
protected void doconvertandcast classnode type  boolean coerce
if  type    classhelper object_type  return
if  righthandtype    null     righthandtype isderivedfrom type      righthandtype implementsinterface type
if  isvalidtypeforcast type
visitclassexpression new classexpression type
if  coerce
astypemethod call mv
else
casttotypemethod call mv
helper docast type
protected void evaluatelogicalorexpression binaryexpression expression
visitbooleanexpression new booleanexpression expression getleftexpression
label l0   new label
label l2   new label
mv visitjumpinsn ifeq  l0
mv visitlabel l2
visitconstantexpression constantexpression true
label l1   new label
mv visitjumpinsn goto  l1
mv visitlabel l0
visitbooleanexpression new booleanexpression expression getrightexpression
mv visitjumpinsn ifne  l2
visitconstantexpression constantexpression false
mv visitlabel l1
// todo: optimization: change to return primitive boolean. need to adjust the binaryexpression and iscomparisonexpression for
// consistancy.
protected void evaluatelogicalandexpression binaryexpression expression
visitbooleanexpression new booleanexpression expression getleftexpression
label l0   new label
mv visitjumpinsn ifeq  l0
visitbooleanexpression new booleanexpression expression getrightexpression
mv visitjumpinsn ifeq  l0
visitconstantexpression constantexpression true
label l1   new label
mv visitjumpinsn goto  l1
mv visitlabel l0
visitconstantexpression constantexpression false
mv visitlabel l1
protected void evaluatebinaryexpression string method  binaryexpression expression
//        makebinopcallsite(expression, method);
makebinopcallsite expression getleftexpression    method  expression getrightexpression
protected void evaluatecompareto binaryexpression expression
expression leftexpression   expression getleftexpression
leftexpression visit this
if  iscomparisonexpression leftexpression
helper boxboolean
// if the right hand side is a boolean expression, we need to autobox
expression rightexpression   expression getrightexpression
rightexpression visit this
if  iscomparisonexpression rightexpression
helper boxboolean
comparetomethod call mv
protected void evaluatebinaryexpressionwithassignment string method  binaryexpression expression
expression leftexpression   expression getleftexpression
if  leftexpression instanceof binaryexpression
binaryexpression leftbinexpr    binaryexpression  leftexpression
if  leftbinexpr getoperation   gettype      types left_square_bracket
// let's replace this assignment to a subscript operator with a
// method call
// e.g. x[5] += 10
// -> (x, [], 5), =, x[5] + 10
// -> methodcall(x, "putat", [5, methodcall(x[5], "plus", 10)])
preparecallsite
// cs_put
preparecallsite method
preparecallsite
visitandautoboxboolean leftbinexpr getleftexpression
visitandautoboxboolean leftbinexpr getrightexpression
// cs_put cs_method cs_get obj index
mv visitinsn dup2_x2
// cs_put obj index cs_method cs_get obj index
mv visitmethodinsn invokeinterface
// cs_put obj index cs_method obj[index]
visitandautoboxboolean expression getrightexpression
// cs_put obj index cs_method obj[index] right
mv visitmethodinsn invokeinterface
// cs_put obj index (obj[index] + right)
final int resultvar   compilestack definetemporaryvariable    true
mv visitvarinsn aload  resultvar
mv visitmethodinsn invokeinterface
mv visitinsn pop     drop return value
mv visitvarinsn aload  resultvar
compilestack removevar resultvar
return
evaluatebinaryexpression method  expression
// br to leave a copy of rvalue on the stack. see also ispoprequired()
mv visitinsn dup
lefthandexpression   true
evaluateexpression leftexpression
lefthandexpression   false
private void evaluatebinaryexpression methodcaller comparemethod  binaryexpression expression
expression leftexp   expression getleftexpression
expression rightexp   expression getrightexpression
load leftexp
load rightexp
comparemethod call mv
protected void evaluateequal binaryexpression expression  boolean definevariable
expression leftexpression   expression getleftexpression
if  leftexpression instanceof binaryexpression
binaryexpression leftbinexpr    binaryexpression  leftexpression
if  leftbinexpr getoperation   gettype      types left_square_bracket
// let's replace this assignment to a subscript operator with a
// method call
// e.g. x[5] = 10
// -> (x, [], 5), =, 10
// -> methodcall(x, "putat", [5, 10])
preparecallsite
visitandautoboxboolean leftbinexpr getleftexpression
visitandautoboxboolean leftbinexpr getrightexpression
visitandautoboxboolean expression getrightexpression
final int resultvar   compilestack definetemporaryvariable    true
mv visitvarinsn aload  resultvar
mv visitmethodinsn invokeinterface
mv visitinsn pop     drop return value
mv visitvarinsn aload  resultvar
compilestack removevar resultvar
return
// let's evaluate the rhs then hopefully the lhs will be a field
expression rightexpression   expression getrightexpression
if    leftexpression instanceof tupleexpression
classnode type   getlhstype leftexpression
assignmentcastandvisit type rightexpression
else
// multiple assignment here!
visitandautoboxboolean rightexpression
righthandtype   rightexpression gettype
lefthandexpression   true
if  leftexpression instanceof tupleexpression
tupleexpression tuple    tupleexpression  leftexpression
int i   0
expression lhsexpr   new bytecodeexpression
public void visit  methodvisitor mv
// copy for method call
mv visitinsn swap
mv visitinsn dup_x1
for  iterator iterator   tuple getexpressions   iterator    iterator hasnext
variableexpression var    variableexpression  iterator next
methodcallexpression call   new methodcallexpression
lhsexpr
new argumentlistexpression new constantexpression integer valueof i
classnode type   getlhstype var
assignmentcastandvisit type call
i
if  definevariable
compilestack definevariable var  true
else
visitvariableexpression var
else if  definevariable
variableexpression var    variableexpression  leftexpression
compilestack definevariable var  true
else
mv visitinsn dup       to leave a copy of the rightexpression value on the stack after the assignment
leftexpression visit this
righthandtype   null
lefthandexpression   false
private void assignmentcastandvisit classnode type  expression rightexpression
// let's not cast for primitive types as we handle these in field setting etc
if  classhelper isprimitivetype type
visitandautoboxboolean rightexpression
else if   rightexpression gettype   isderivedfrom type
visitcastexpression new castexpression type  rightexpression
else
visitandautoboxboolean rightexpression
/**
* deduces the type name required for some casting
*
* @return the type of the given (lhs) expression or null if it is java.lang.object or it cannot be deduced
*/
protected classnode getlhstype expression leftexpression
if  leftexpression instanceof variableexpression
variableexpression varexp    variableexpression  leftexpression
classnode type   varexp gettype
if  isvalidtypeforcast type
return type
string variablename   varexp getname
variable variable   compilestack getvariable variablename  false
if  variable    null
if  variable isholder
return type
if  variable isproperty    return variable gettype
type   variable gettype
if  isvalidtypeforcast type
return type
else
fieldnode field   classnode getdeclaredfield variablename
if  field    null
field   classnode getouterfield variablename
if  field    null
type   field gettype
if   field isholder      isvalidtypeforcast type
return type
else if  leftexpression instanceof fieldexpression
fieldexpression fieldexp    fieldexpression  leftexpression
classnode type   fieldexp gettype
if  isvalidtypeforcast type
return type
return leftexpression gettype
protected boolean isvalidtypeforcast classnode type
return type    classhelper dynamic_type
type    classhelper reference_type
public void visitbytecodeexpression bytecodeexpression cle
cle visit mv
protected void visitandautoboxboolean expression expression
expression visit this
if  iscomparisonexpression expression
helper boxboolean       convert boolean to boolean
private void execmethodandstoreforsubscriptoperator string method  expression expression
// execute method
makecallsite
expression
method
methodcallexpression no_arguments
false  false  false  false
// we need special code for arrays to store the result
if  expression instanceof binaryexpression
binaryexpression be    binaryexpression  expression
if  be getoperation   gettype    types left_square_bracket
mv visitinsn dup
final int resultidx   compilestack definetemporaryvariable     method  true
bytecodeexpression result   new bytecodeexpression
public void visit methodvisitor mv
mv visitvarinsn aload  resultidx
tupleexpression args   new argumentlistexpression
args addexpression be getrightexpression
args addexpression result
makecallsite
be getleftexpression
args
false  false  false  false
mv visitinsn pop
compilestack removevar resultidx
if  expression instanceof variableexpression
expression instanceof fieldexpression
expression instanceof propertyexpression
mv visitinsn dup
lefthandexpression   true
expression visit this
lefthandexpression   false
protected void evaluateprefixmethod string method  expression expression
// execute method
execmethodandstoreforsubscriptoperator method expression
// new value is already on stack, so nothing to do here
protected void evaluatepostfixmethod string method  expression expression
// load
expression visit this
// save value for later
int tempidx   compilestack definetemporaryvariable     method  true
// execute method
execmethodandstoreforsubscriptoperator method expression
// remove the result of the method call
mv visitinsn pop
//reload saved value
mv visitvarinsn aload  tempidx
compilestack removevar tempidx
protected void evaluateinstanceof binaryexpression expression
visitandautoboxboolean expression getleftexpression
expression rightexp   expression getrightexpression
classnode classtype   classhelper dynamic_type
if  rightexp instanceof classexpression
classexpression classexp    classexpression  rightexp
classtype   classexp gettype
else
throw new runtimeexception
rightexp
string classinternalname   bytecodehelper getclassinternalname classtype
mv visittypeinsn instanceof  classinternalname
/**
* @return true if the given argument expression requires the stack, in
*         which case the arguments are evaluated first, stored in the
*         variable stack and then reloaded to make a method call
*/
protected boolean argumentsusestack expression arguments
return arguments instanceof tupleexpression    arguments instanceof closureexpression
/**
* @return true if the given expression represents a non-static field
*/
protected boolean isnonstaticfield expression expression
fieldnode field   null
if  expression instanceof variableexpression
variableexpression varexp    variableexpression  expression
field   classnode getdeclaredfield varexp getname
else if  expression instanceof fieldexpression
fieldexpression fieldexp    fieldexpression  expression
field   classnode getdeclaredfield fieldexp getfieldname
else if  expression getclass      propertyexpression class
propertyexpression fieldexp    propertyexpression  expression
string possiblefield   fieldexp getpropertyasstring
if  possiblefield    null  field   classnode getdeclaredfield possiblefield
return field    null     field isstatic
private static boolean isthisexpression expression expression
if  expression instanceof variableexpression
variableexpression varexp    variableexpression  expression
return varexp getname   equals
return false
private static boolean issuperexpression expression expression
if  expression instanceof variableexpression
variableexpression varexp    variableexpression  expression
return varexp getname   equals
return false
private static boolean isthisorsuper expression expression
return isthisexpression expression     issuperexpression expression
/**
* for assignment expressions, return a safe expression for the lhs we can use
* to return the value
*/
protected expression createreturnlhsexpression expression expression
if  expression instanceof binaryexpression
binaryexpression binexpr    binaryexpression  expression
if  binexpr getoperation   isa types assignment_operator
return createreusableexpression binexpr getleftexpression
return null
protected expression createreusableexpression expression expression
expressiontransformer transformer   new expressiontransformer
public expression transform expression expression
if  expression instanceof postfixexpression
postfixexpression postfixexp    postfixexpression  expression
return postfixexp getexpression
else if  expression instanceof prefixexpression
prefixexpression prefixexp    prefixexpression  expression
return prefixexp getexpression
return expression
// could just be a postfix / prefix expression or nested inside some other expression
return transformer transform expression transformexpression transformer
protected boolean iscomparisonexpression expression expression
if  expression instanceof binaryexpression
binaryexpression binexpr    binaryexpression  expression
switch  binexpr getoperation   gettype
case types compare_equal
case types match_regex
case types compare_greater_than
case types compare_greater_than_equal
case types compare_less_than
case types compare_less_than_equal
case types compare_identical
case types compare_not_equal
case types keyword_instanceof
case types keyword_in
return true
else if  expression instanceof booleanexpression
return true
return false
protected void onlinenumber astnode statement  string message
int line   statement getlinenumber
int col   statement getcolumnnumber
this currentastnode   statement
if  line >  0
linenumber   line
columnnumber   col
if  line >  0    mv    null
label l   new label
mv visitlabel l
mv visitlinenumber line  l
if  asm_debug
helper mark message       statement getlinenumber         statement getcolumnnumber
private boolean isinnerclass
return classnode instanceof innerclassnode
/**
* @return true if the given name is a local variable or a field
*/
protected boolean isfieldorvariable string name
return compilestack containsvariable name     classnode getdeclaredfield name     null
/**
* @return if the type of the expression can be determined at compile time
*         then this method returns the type - otherwise null
*/
protected classnode getexpressiontype expression expression
if  iscomparisonexpression expression
return classhelper boolean_type
if  expression instanceof variableexpression
variableexpression varexpr    variableexpression expression
if  varexpr isthisexpression
return classnode
else if  varexpr issuperexpression
return classnode getsuperclass
variable variable   compilestack getvariable varexpr getname    false
if  variable    null     variable isholder
classnode type   variable gettype
if   variable isdynamictyped    return type
if  variable    null
org codehaus groovy ast variable var    org codehaus groovy ast variable  compilestack getscope   getreferencedclassvariable varexpr getname
if  var    null     var isdynamictyped    return var gettype
return expression gettype
protected boolean isinclosureconstructor
return constructornode    null
classnode getouterclass      null
classnode getsuperclass      classhelper closure_type
protected boolean isinclosure
return classnode getouterclass      null
classnode getsuperclass      classhelper closure_type
protected boolean isstaticmethod
return methodnode    null    methodnode isstatic
protected compileunit getcompileunit
compileunit answer   classnode getcompileunit
if  answer    null
answer   context getcompileunit
return answer
protected boolean isholdervariable expression expression
if  expression instanceof fieldexpression
fieldexpression fieldexp    fieldexpression  expression
return fieldexp getfield   isholder
if  expression instanceof variableexpression
variableexpression varexp    variableexpression  expression
variable variable   compilestack getvariable varexp getname    false
if  variable    null
return variable isholder
fieldnode field   classnode getdeclaredfield varexp getname
if  field    null
return field isholder
return false
public static boolean usessuper methodcallexpression call
expression expression   call getobjectexpression
if  expression instanceof variableexpression
variableexpression varexp    variableexpression  expression
string variable   varexp getname
return variable equals
return false
public static boolean usessuper propertyexpression pe
expression expression   pe getobjectexpression
if  expression instanceof variableexpression
variableexpression varexp    variableexpression  expression
string variable   varexp getname
return variable equals
return false
protected int getbytecodeversion
if    classnode isusinggenerics
classnode isannotated
classnode isannotationdefinition
return opcodes v1_3
final string target   getcompileunit   getconfig   gettargetbytecode
return compilerconfiguration post_jdk5 equals target  ? opcodes v1_5   opcodes v1_3
private static class classref
private final classnode type
public classref classnode type
this type   type
public boolean equals object o
if  this    o  return true
classref classref    classref  o
return type getname   equals classref type getname
public int hashcode
return type getname   hashcode
private class mymethodadapter extends methodadapter
private string boxingdesc   null
public mymethodadapter
super asmclassgenerator this mv
private void dropboxing
if  boxingdesc    null
super visitmethodinsn invokestatic  dtt     boxingdesc
boxingdesc   null
public void visitinsn int opcode
dropboxing
super visitinsn opcode        to change body of overridden methods use file   settings   file templates
public void visitintinsn int opcode  int operand
dropboxing
super visitintinsn opcode  operand        to change body of overridden methods use file   settings   file templates
public void visitvarinsn int opcode  int var
dropboxing
super visitvarinsn opcode  var        to change body of overridden methods use file   settings   file templates
public void visittypeinsn int opcode  string desc
dropboxing
super visittypeinsn opcode  desc        to change body of overridden methods use file   settings   file templates
public void visitfieldinsn int opcode  string owner  string name  string desc
dropboxing
super visitfieldinsn opcode  owner  name  desc        to change body of overridden methods use file   settings   file templates
public void visitmethodinsn int opcode  string owner  string name  string desc
if  boxing opcode owner name
dropboxing
boxingdesc   desc
else
if  unboxing opcode  owner  name
if  boxingdesc    null
boxingdesc   null
else
super visitmethodinsn opcode  owner  name  desc        to change body of overridden methods use file   settings   file templates
else
dropboxing
super visitmethodinsn opcode  owner  name  desc        to change body of overridden methods use file   settings   file templates
private boolean boxing int opcode  string owner  string name
return opcode    invokestatic    owner equals dtt     name equals
private boolean unboxing int opcode  string owner  string name
return opcode    invokestatic    owner equals dtt     name endswith
public void visitjumpinsn int opcode  label label
dropboxing
super visitjumpinsn opcode  label        to change body of overridden methods use file   settings   file templates
public void visitlabel label label
dropboxing
super visitlabel label        to change body of overridden methods use file   settings   file templates
public void visitldcinsn object cst
dropboxing
super visitldcinsn cst        to change body of overridden methods use file   settings   file templates
public void visitiincinsn int var  int increment
dropboxing
super visitiincinsn var  increment        to change body of overridden methods use file   settings   file templates
public void visittableswitchinsn int min  int max  label dflt  label labels
dropboxing
super visittableswitchinsn min  max  dflt  labels        to change body of overridden methods use file   settings   file templates
public void visitlookupswitchinsn label dflt  int keys  label labels
dropboxing
super visitlookupswitchinsn dflt  keys  labels        to change body of overridden methods use file   settings   file templates
public void visitmultianewarrayinsn string desc  int dims
dropboxing
super visitmultianewarrayinsn desc  dims        to change body of overridden methods use file   settings   file templates
public void visittrycatchblock label start  label end  label handler  string type
dropboxing
super visittrycatchblock start  end  handler  type        to change body of overridden methods use file   settings   file templates