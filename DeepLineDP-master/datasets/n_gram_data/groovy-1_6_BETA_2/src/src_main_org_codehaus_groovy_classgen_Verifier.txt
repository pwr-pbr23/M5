/*
* copyright 2003-2008 the original author or authors.
*
* licensed under the apache license, version 2.0 (the "license");
* you may not use this file except in compliance with the license.
* you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org codehaus groovy classgen
import groovy lang groovyclassloader
import groovy lang groovyobject
import groovy lang metaclass
import groovy lang groovyobjectsupport
import org codehaus groovy ast
import org codehaus groovy ast expr
import org codehaus groovy ast stmt
import org codehaus groovy syntax runtimeparserexception
import org codehaus groovy syntax token
import org codehaus groovy syntax types
import org codehaus groovy reflection classinfo
import org objectweb asm label
import org objectweb asm methodvisitor
import org objectweb asm opcodes
import java lang reflect field
import java lang reflect modifier
import java util
/**
* verifies the ast node and adds any defaulted ast code before
* bytecode generation occurs.
*
* @author <a href="mailto:james@coredevelopers.net">james strachan</a>
* @version $revision$
*/
public class verifier implements groovyclassvisitor  opcodes
public static final string __timestamp
public static final string __timestamp__
private static final parameter invoke_method_params   new parameter
new parameter classhelper string_type
new parameter classhelper object_type
private static final parameter set_property_params   new parameter
new parameter classhelper string_type
new parameter classhelper object_type
private static final parameter get_property_params   new parameter
new parameter classhelper string_type
private static final parameter set_metaclass_params   new parameter
new parameter classhelper metaclass_type
private classnode classnode
private methodnode methodnode
public classnode getclassnode
return classnode
public methodnode getmethodnode
return methodnode
private fieldnode setmetaclassfieldifnotexists classnode node  fieldnode metaclassfield
if  metaclassfield    null  return metaclassfield
final string classinternalname   bytecodehelper getclassinternalname node
metaclassfield
node addfield    acc_private   acc_transient  classhelper metaclass_type  new bytecodeexpression
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitinsn dup
mv visitmethodinsn invokevirtual  classinternalname
mv visitfieldinsn putfield  classinternalname
mv visitvarinsn aload  0
mv visitfieldinsn getfield  classinternalname
public classnode gettype
return classhelper metaclass_type
metaclassfield setsynthetic true
return metaclassfield
private fieldnode getmetaclassfield classnode node
fieldnode ret   node getdeclaredfield
if  ret  null  return ret
classnode current   node
while  current  null    current  classhelper object_type
current   current getsuperclass
ret   current getdeclaredfield
if  ret  null  continue
if  modifier isprivate ret getmodifiers     continue
return ret
return null
/**
* add code to implement groovyobject
* @param node
*/
public void visitclass final classnode node
this classnode   node
if   classnode getmodifiers     opcodes acc_interface  >0
//interfaces have no constructors, but this code expects one,
//so create a dummy and don't add it to the class node
constructornode dummy   new constructornode 0 null
addinitialization node  dummy
node visitcontents this
return
classnode classnodes   classnode getinterfaces
list interfaces   new arraylist
for  int i   0  i < classnodes length  i
classnode classnode   classnodes
interfaces add classnode getname
set interfaceset   new hashset interfaces
if  interfaceset size      interfaces size
throw new runtimeparserexception     interfaces  classnode
adddefaultparametermethods node
adddefaultparameterconstructors node
final string classinternalname   bytecodehelper getclassinternalname node
string _staticclassinfofieldname
while  node getdeclaredfield _staticclassinfofieldname     null
_staticclassinfofieldname   _staticclassinfofieldname
final string staticmetaclassfieldname   _staticclassinfofieldname
fieldnode staticmetaclassfield   node addfield staticmetaclassfieldname  acc_private acc_static  classhelper make classinfo class false   null
staticmetaclassfield setsynthetic true
node addsyntheticmethod
acc_protected
classhelper make metaclass class
parameter empty_array
classnode empty_array
new bytecodesequence new bytecodeinstruction
public void visit methodvisitor mv
mv visitfieldinsn getstatic  classinternalname  staticmetaclassfieldname
mv visitvarinsn astore  1
mv visitvarinsn aload  1
label l0   new label
mv visitjumpinsn ifnonnull  l0
mv visitvarinsn aload  0
mv visitmethodinsn invokevirtual
mv visitmethodinsn invokestatic
mv visitinsn dup
mv visitvarinsn astore  1
mv visitfieldinsn putstatic  classinternalname  staticmetaclassfieldname
mv visitlabel l0
mv visitvarinsn aload  1
mv visitmethodinsn invokevirtual
mv visitinsn areturn
boolean knownspecialcase
node isderivedfrom classhelper gstring_type
node isderivedfrom classhelper make groovyobjectsupport class
node implementsinterface classhelper metaclass_type
if   knownspecialcase
if   node isderivedfromgroovyobject    node addinterface classhelper make groovyobject class
fieldnode metaclassfield   getmetaclassfield node
if   node hasmethod    parameter empty_array
metaclassfield   setmetaclassfieldifnotexists node  metaclassfield
node addsyntheticmethod
acc_public   acc_synthetic
classhelper metaclass_type
parameter empty_array
classnode empty_array
new bytecodesequence new bytecodeinstruction
public void visit methodvisitor mv
label nulllabel   new label
mv visitvarinsn aload  0
mv visitfieldinsn getfield  classinternalname
mv visitinsn dup
mv visitjumpinsn ifnull  nulllabel
mv visitinsn areturn
mv visitlabel nulllabel
mv visitinsn pop
mv visitvarinsn aload  0
mv visitinsn dup
mv visitmethodinsn invokevirtual  classinternalname
mv visitfieldinsn putfield  classinternalname
mv visitvarinsn aload  0
mv visitfieldinsn getfield  classinternalname
mv visitinsn areturn
parameter parameters   new parameter   new parameter classhelper metaclass_type
if   node hasmethod    parameters
metaclassfield setmetaclassfieldifnotexists node metaclassfield
statement setmetaclasscode
if  modifier isfinal metaclassfield getmodifiers
constantexpression text   new constantexpression
constructorcallexpression cce   new constructorcallexpression classhelper make illegalargumentexception class   text
setmetaclasscode   new expressionstatement cce
else
list list   new arraylist
list add  new bytecodeinstruction
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitvarinsn aload  1
mv visitfieldinsn putfield  classinternalname
setmetaclasscode   new bytecodesequence list
node addsyntheticmethod
acc_public
classhelper void_type
set_metaclass_params
classnode empty_array
setmetaclasscode
if   node hasmethod   invoke_method_params
variableexpression vmethods   new variableexpression
variableexpression varguments   new variableexpression
variablescope blockscope   new variablescope
blockscope putreferencedlocalvariable vmethods
blockscope putreferencedlocalvariable varguments
node addsyntheticmethod
acc_public
classhelper object_type  invoke_method_params
classnode empty_array
new bytecodesequence new bytecodeinstruction
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitmethodinsn invokevirtual  classinternalname
mv visitvarinsn aload  0
mv visitvarinsn aload  1
mv visitvarinsn aload  2
mv visitmethodinsn invokeinterface
mv visitinsn areturn
if   node hasmethod    get_property_params
node addsyntheticmethod
acc_public
classhelper object_type
get_property_params
classnode empty_array
new bytecodesequence new bytecodeinstruction
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitmethodinsn invokevirtual  classinternalname
mv visitvarinsn aload  0
mv visitvarinsn aload  1
mv visitmethodinsn invokeinterface
mv visitinsn areturn
if   node hasmethod    set_property_params
node addsyntheticmethod
acc_public
classhelper void_type
set_property_params
classnode empty_array
new bytecodesequence new bytecodeinstruction
public void visit methodvisitor mv
mv visitvarinsn aload  0
mv visitmethodinsn invokevirtual  classinternalname
mv visitvarinsn aload  0
mv visitvarinsn aload  1
mv visitvarinsn aload  2
mv visitmethodinsn invokeinterface
mv visitinsn return
if  node getdeclaredconstructors   isempty
constructornode constructor   new constructornode acc_public  null
constructor setsynthetic true
node addconstructor constructor
if    node instanceof innerclassnode       add a static timestamp field to the class
addtimestamp node
addinitialization node
checkreturninobjectinitializer node getobjectinitializerstatements
node getobjectinitializerstatements   clear
addcovariantmethods node
node visitcontents this
protected void addtimestamp classnode node
fieldnode timetagfield   new fieldnode
verifier __timestamp
modifier public   modifier static
classhelper long_type
//"",
node
new constantexpression system currenttimemillis
// alternatively , fieldnode timetagfield = sourceunit.createfieldnode("public static final long __timestamp = " + system.currenttimemillis() + "l");
timetagfield setsynthetic true
node addfield timetagfield
timetagfield   new fieldnode
verifier __timestamp__   string valueof system currenttimemillis
modifier public   modifier static
classhelper long_type
//"",
node
new constantexpression  long  0
// alternatively , fieldnode timetagfield = sourceunit.createfieldnode("public static final long __timestamp = " + system.currenttimemillis() + "l");
timetagfield setsynthetic true
node addfield timetagfield
private void checkreturninobjectinitializer list init
codevisitorsupport cvs   new codevisitorsupport
public void visitreturnstatement returnstatement statement
throw new runtimeparserexception   statement
for  iterator iterator   init iterator    iterator hasnext
statement stm    statement  iterator next
stm visit cvs
public void visitconstructor constructornode node
codevisitorsupport checksuper   new codevisitorsupport
boolean firstmethodcall   true
string type null
public void visitmethodcallexpression methodcallexpression call
if   firstmethodcall  return
firstmethodcall   false
string name   call getmethodasstring
// the name might not be null if the method name is a gstring for example
if  name  null  return
if   name equals        name equals     return
type name
call getarguments   visit this
type null
public void visitvariableexpression variableexpression expression
if  type  null  return
string name   expression getname
if   name equals        name equals     return
throw new runtimeparserexception   name   type   expression
statement s   node getcode
//todo why can a statement can be null?
if  s    null  return
s visit checksuper
public void visitmethod methodnode node
this methodnode   node
addreturnifneeded node
statement statement
if  node getname   equals       node isstatic
parameter params   node getparameters
if  params length    1
parameter param   params
if  param gettype      null    param gettype    classhelper object_type
param settype classhelper string_type makearray
statement   node getcode
if  statement  null  statement visit new verifiercodevisitor this
private void addreturnifneeded methodnode node
statement statement   node getcode
if   node isvoidmethod
if  statement    null     it happens with @interface methods
node setcode addreturnsifneeded statement  node getvariablescope
else if   node isabstract
blockstatement newblock   new blockstatement
if  statement instanceof blockstatement
newblock addstatements filterstatements   blockstatement statement  getstatements
else
newblock addstatement filterstatement statement
newblock addstatement returnstatement return_null_or_void
node setcode newblock
private statement addreturnsifneeded statement statement  variablescope scope
if    statement instanceof returnstatement
statement instanceof bytecodesequence
statement instanceof throwstatement
return statement
if  statement instanceof emptystatement
return new returnstatement constantexpression null
if  statement instanceof expressionstatement
expressionstatement expstmt    expressionstatement  statement
return new returnstatement expstmt getexpression
if  statement instanceof synchronizedstatement
synchronizedstatement sync    synchronizedstatement  statement
sync setcode addreturnsifneeded sync getcode    scope
return sync
if  statement instanceof ifstatement
ifstatement ifs    ifstatement  statement
ifs setifblock addreturnsifneeded ifs getifblock    scope
ifs setelseblock addreturnsifneeded ifs getelseblock    scope
return ifs
//        if (statement instanceof switchstatement) {
//            switchstatement swi = (switchstatement) statement;
//            return swi;
//        }
if  statement instanceof trycatchstatement
trycatchstatement trys    trycatchstatement  statement
trys settrystatement addreturnsifneeded trys gettrystatement    scope
final int len   trys getcatchstatements   size
for  int i   0  i    len    i
final catchstatement catchstatement   trys getcatchstatement i
catchstatement setcode addreturnsifneeded catchstatement getcode    scope
return trys
if  statement instanceof blockstatement
blockstatement block    blockstatement  statement
final list list   block getstatements
if   list isempty
int idx   list size     1
statement last   addreturnsifneeded  statement  list get idx   block getvariablescope
list set idx  last
if   statementreturns last
list add new returnstatement constantexpression null
else
return new returnstatement constantexpression null
return new blockstatement filterstatements list  block getvariablescope
if  statement    null
return new returnstatement constantexpression null
else
final list list   new arraylist
list add statement
list add new returnstatement constantexpression null
return new blockstatement list new variablescope scope
private boolean statementreturns statement last
return
last instanceof returnstatement
last instanceof blockstatement
last instanceof ifstatement
last instanceof expressionstatement
last instanceof emptystatement
last instanceof trycatchstatement
last instanceof bytecodesequence
last instanceof throwstatement
last instanceof synchronizedstatement
public void visitfield fieldnode node
private boolean methodneedsreplacement methodnode m
// no method found, we need to replace
if  m  null  return true
// method is in current class, nothing to be done
if  m getdeclaringclass    this getclassnode    return false
// do not overwrite final
if   m getmodifiers   acc_final   0  return false
return true
public void visitproperty propertynode node
string name   node getname
fieldnode field   node getfield
string gettername       capitalize name
string settername       capitalize name
statement getterblock   node getgetterblock
if  getterblock    null
methodnode getter   classnode getgettermethod gettername
if   node isprivate      methodneedsreplacement getter
getterblock   creategetterblock node  field
statement setterblock   node getsetterblock
if  setterblock    null
methodnode setter   classnode getsettermethod settername
if    node isprivate
node getmodifiers   acc_final   0
methodneedsreplacement setter
setterblock   createsetterblock node  field
if  getterblock    null
methodnode getter
new methodnode gettername  node getmodifiers    node gettype    parameter empty_array  classnode empty_array  getterblock
getter setsynthetic true
addpropertymethod getter
visitmethod getter
if  classhelper boolean_type  node gettype      classhelper boolean_type  node gettype
string secondgettername       capitalize name
methodnode secondgetter
new methodnode secondgettername  node getmodifiers    node gettype    parameter empty_array  classnode empty_array  getterblock
secondgetter setsynthetic true
addpropertymethod secondgetter
visitmethod secondgetter
if  setterblock    null
parameter setterparametertypes     new parameter node gettype
methodnode setter
new methodnode settername  node getmodifiers    classhelper void_type  setterparametertypes  classnode empty_array  setterblock
setter setsynthetic true
addpropertymethod setter
visitmethod setter
protected void addpropertymethod methodnode method
classnode addmethod method
// implementation methods
//-------------------------------------------------------------------------
private interface defaultargsaction
void call argumentlistexpression arguments  parameter newparams  methodnode method
/**
* creates a new helper method for each combination of default parameter expressions
*/
protected void adddefaultparametermethods final classnode node
list methods   new arraylist node getmethods
adddefaultparameters methods  new defaultargsaction
public void call argumentlistexpression arguments  parameter newparams  methodnode method
methodcallexpression expression   new methodcallexpression variableexpression this_expression  method getname    arguments
expression setimplicitthis true
statement code   null
if  method isvoidmethod
code   new expressionstatement expression
else
code   new returnstatement expression
node addmethod method getname    method getmodifiers    method getreturntype    newparams  method getexceptions    code
protected void adddefaultparameterconstructors final classnode node
list methods   new arraylist node getdeclaredconstructors
adddefaultparameters methods  new defaultargsaction
public void call argumentlistexpression arguments  parameter newparams  methodnode method
constructornode ctor    constructornode  method
constructorcallexpression expression   new constructorcallexpression classnode this  arguments
statement code   new expressionstatement expression
node addconstructor ctor getmodifiers    newparams  ctor getexceptions    code
/**
* creates a new helper method for each combination of default parameter expressions
*/
protected void adddefaultparameters list methods  defaultargsaction action
for  iterator iter   methods iterator    iter hasnext
methodnode method    methodnode  iter next
if  method hasdefaultvalue
parameter parameters   method getparameters
int counter   0
list paramvalues   new arraylist
int size   parameters length
for  int i   size   1  i >  0  i
parameter parameter   parameters
if  parameter    null    parameter hasinitialexpression
paramvalues add integer valueof i
paramvalues add parameter getinitialexpression
counter
for  int j   1  j <  counter  j
parameter newparams    new parameter
argumentlistexpression arguments   new argumentlistexpression
int index   0
int k   1
for  int i   0  i < parameters length  i
if  k > counter   j    parameters    null    parameters hasinitialexpression
arguments addexpression parameters getinitialexpression
k
else if  parameters    null    parameters hasinitialexpression
newparams   parameters
arguments addexpression new variableexpression parameters getname
k
else
newparams   parameters
arguments addexpression new variableexpression parameters getname
action call arguments newparams method
for  int i   0  i < parameters length  i
// remove default expression
parameters setinitialexpression null
protected void addclosurecode innerclassnode node
// add a new invoke
protected void addinitialization classnode node
for  iterator iter   node getdeclaredconstructors   iterator    iter hasnext
addinitialization node   constructornode  iter next
protected void addinitialization classnode node  constructornode constructornode
statement firststatement   constructornode getfirststatement
constructorcallexpression first   getfirstifspecialconstructorcall firststatement
// in case of this(...) let the other constructor do the intit
if  first  null    first isthiscall    return
list statements   new arraylist
list staticstatements   new arraylist
for  iterator iter   node getfields   iterator    iter hasnext
addfieldinitialization statements  staticstatements   fieldnode  iter next
statements addall node getobjectinitializerstatements
if   statements isempty
statement code   constructornode getcode
blockstatement block   new blockstatement
list otherstatements   block getstatements
if  code instanceof blockstatement
block    blockstatement  code
otherstatements block getstatements
else if  code    null
otherstatements add code
if   otherstatements isempty
if  first  null
// it is super(..) since this(..) is already covered
otherstatements remove 0
statements add 0  firststatement
statements addall otherstatements
constructornode setcode new blockstatement statements  block getvariablescope
if   staticstatements isempty
node addstaticinitializerstatements staticstatements true
private constructorcallexpression getfirstifspecialconstructorcall statement code
if  code    null      code instanceof expressionstatement   return null
expression expression     expressionstatement code  getexpression
if    expression instanceof constructorcallexpression   return null
constructorcallexpression cce    constructorcallexpression  expression
if  cce isspecialcall    return cce
return null
protected void addfieldinitialization
list list
list staticlist
fieldnode fieldnode
expression expression   fieldnode getinitialexpression
if  expression    null
expressionstatement statement
new expressionstatement
new binaryexpression
new fieldexpression fieldnode
token newsymbol types equal  fieldnode getlinenumber    fieldnode getcolumnnumber
expression
if  fieldnode isstatic
staticlist add statement
fieldnode setinitialvalueexpression null      to avoid double initialization in case of several constructors
else
list add statement
/**
* capitalizes the start of the given bean property name
*/
public static string capitalize string name
return name substring 0  1  touppercase     name substring 1  name length
protected statement creategetterblock propertynode propertynode  final fieldnode field
return new bytecodesequence new bytecodeinstruction
public void visit methodvisitor mv
if  field isstatic
mv visitfieldinsn getstatic  bytecodehelper getclassinternalname classnode   field getname    bytecodehelper gettypedescription field gettype
else
mv visitvarinsn aload  0
mv visitfieldinsn getfield  bytecodehelper getclassinternalname classnode   field getname    bytecodehelper gettypedescription field gettype
final bytecodehelper helper   new bytecodehelper mv
helper doreturn field gettype
protected statement createsetterblock propertynode propertynode  final fieldnode field
return new bytecodesequence new bytecodeinstruction
public void visit methodvisitor mv
final bytecodehelper helper   new bytecodehelper mv
if  field isstatic
helper load field gettype    0
mv visitfieldinsn putstatic  bytecodehelper getclassinternalname classnode   field getname    bytecodehelper gettypedescription field gettype
else
mv visitvarinsn aload  0
helper load field gettype    1
mv visitfieldinsn putfield  bytecodehelper getclassinternalname classnode   field getname    bytecodehelper gettypedescription field gettype
/**
* filters the given statements
*/
protected list filterstatements list list
list answer   new arraylist list size
for  iterator iter   list iterator    iter hasnext
answer add filterstatement  statement  iter next
return answer
protected statement filterstatement statement statement
if  statement instanceof expressionstatement
expressionstatement expstmt    expressionstatement  statement
expression expression   expstmt getexpression
if  expression instanceof closureexpression
closureexpression closureexp    closureexpression  expression
if   closureexp isparameterspecified
return closureexp getcode
return statement
public void visitgenerictype genericstype genericstype
public static long gettimestamp  class clazz
if  clazz getclassloader   instanceof groovyclassloader innerloader
groovyclassloader innerloader innerloader    groovyclassloader innerloader  clazz getclassloader
return innerloader gettimestamp
final field fields   clazz getfields
for  int i   0  i    fields length    i
if  modifier isstatic fields getmodifiers
final string name   fields getname
if  name startswith __timestamp__
try
return long decode name substring __timestamp__ length     longvalue
catch  numberformatexception e
return long max_value
return long max_value
protected void addcovariantmethods classnode classnode
map methodstoadd   new hashmap
list declaredmethods   new arraylist classnode getmethods
map genericsspec   new hashmap
// remove staic methods from declaredmethods
for  iterator methodsiterator   declaredmethods iterator    methodsiterator hasnext
methodnode m    methodnode  methodsiterator next
if  m isstatic    methodsiterator remove
addcovariantmethods classnode  declaredmethods  methodstoadd  genericsspec
for  iterator it   methodstoadd values   iterator    it hasnext
methodnode method    methodnode  it next
classnode addmethod method
private void addcovariantmethods classnode classnode  list declaredmethods  map methodstoadd  map oldgenericsspec
classnode sn   classnode getunresolvedsuperclass false
if  sn  null
map genericsspec   creategenericsspec sn oldgenericsspec
for  iterator it   declaredmethods iterator    it hasnext
methodnode method    methodnode  it next
if  method isstatic    continue
storemissingcovariantmethods sn method methodstoadd genericsspec
addcovariantmethods sn redirect   declaredmethods methodstoadd genericsspec
classnode interfaces   classnode getinterfaces
for  int i 0  i<interfaces length  i
map genericsspec   creategenericsspec interfaces oldgenericsspec
for  iterator it   declaredmethods iterator    it hasnext
methodnode method    methodnode  it next
if  method isstatic    continue
storemissingcovariantmethods interfaces method methodstoadd genericsspec
addcovariantmethods interfaces declaredmethods methodstoadd genericsspec
private methodnode getcovariantimplementation final methodnode oldmethod  final methodnode overridingmethod  map genericsspec
// method name
if   oldmethod getname   equals overridingmethod getname     return null
// parameters
boolean normalequalparameters   equalparametersnormal overridingmethod oldmethod
boolean genericequalparameters   equalparameterswithgenerics overridingmethod oldmethod genericsspec
if   normalequalparameters     genericequalparameters  return null
// return type
classnode mr   overridingmethod getreturntype
classnode omr   oldmethod getreturntype
boolean equalreturntype   mr equals omr
if  equalreturntype    normalequalparameters  return null
// if we reach this point we have at last one parameter or return type, that
// is different in its specified form. that means we have to create a bridge method!
classnode testmr   correcttogenericsspec genericsspec omr
if   isassignable mr testmr
throw new runtimeparserexception
oldmethod gettypedescriptor
oldmethod getdeclaringclass   getname
overridingmethod
if   oldmethod getmodifiers   acc_final   0
throw new runtimeparserexception
oldmethod gettypedescriptor
oldmethod getdeclaringclass   getname
overridingmethod
if  oldmethod isstatic      overridingmethod isstatic
throw new runtimeparserexception
oldmethod gettypedescriptor
oldmethod getdeclaringclass   getname
overridingmethod
methodnode newmethod   new methodnode
oldmethod getname
overridingmethod getmodifiers     acc_synthetic   acc_bridge
oldmethod getreturntype   getplainnodereference
cleanparameters oldmethod getparameters
oldmethod getexceptions

list instructions   new arraylist 1
instructions add
new bytecodeinstruction
public void visit methodvisitor mv
bytecodehelper helper   new bytecodehelper mv
mv visitvarinsn aload 0
parameter para   oldmethod getparameters
parameter goal   overridingmethod getparameters
for  int i   0  i < para length  i
helper load para gettype    i 1
if   para gettype   equals goal gettype
helper docast goal gettype
mv visitmethodinsn
invokevirtual
bytecodehelper getclassinternalname classnode
overridingmethod getname
bytecodehelper getmethoddescriptor overridingmethod getreturntype    overridingmethod getparameters
helper doreturn oldmethod getreturntype
newmethod setcode new bytecodesequence instructions
return newmethod
private boolean isassignable classnode node  classnode testnode
if  testnode isinterface
if  node implementsinterface testnode   return true
else
if  node isderivedfrom testnode   return true
return false
private parameter cleanparameters parameter parameters
parameter params   new parameter
for  int i   0  i < params length  i
params   new parameter parameters gettype   getplainnodereference   parameters getname
return params
private void storemissingcovariantmethods classnode current  methodnode method  map methodstoadd  map genericsspec
list methods   current getmethods
for  iterator sit   methods iterator    sit hasnext
methodnode tooverride    methodnode  sit next
methodnode bridgemethod   getcovariantimplementation tooverride method genericsspec
if  bridgemethod  null  continue
methodstoadd put  bridgemethod gettypedescriptor   bridgemethod
return
private classnode correcttogenericsspec map genericsspec  genericstype type
classnode ret   null
if  type isplaceholder
string name   type getname
ret    classnode  genericsspec get name
if  ret  null  ret   type gettype
return ret
private classnode correcttogenericsspec map genericsspec  classnode type
if  type isgenericsplaceholder
string name   type getgenericstypes   getname
type    classnode  genericsspec get name
if  type  null  type   classhelper object_type
return type
private boolean equalparametersnormal methodnode m1  methodnode m2
parameter p1   m1 getparameters
parameter p2   m2 getparameters
if  p1 length  p2 length  return false
for  int i   0  i < p2 length  i
classnode type   p2 gettype
classnode parametertype   p1 gettype
if   parametertype equals type   return false
return true
private boolean equalparameterswithgenerics methodnode m1  methodnode m2  map genericsspec
parameter p1   m1 getparameters
parameter p2   m2 getparameters
if  p1 length  p2 length  return false
for  int i   0  i < p2 length  i
classnode type   p2 gettype
classnode genericstype   correcttogenericsspec genericsspec type
classnode parametertype   p1 gettype
if   parametertype equals genericstype   return false
return true
private map creategenericsspec classnode current  map oldspec
map ret   new hashmap oldspec
// ret contains the type specs, what we now need is the type spec for the
// current class. to get that we first apply the type parameters to the
// current class and then use the type names of the current class to reset
// the map. example:
//   class a<v,w,x>{}
//   class b<t extends number> extends a<t,long,string> {}
// first we have:    t->number
// we apply it to a<t,long,string> -> a<number,long,string>
// resulting in:     v->number,w->long,x->string
genericstype sgts   current getgenericstypes
if  sgts  null
classnode spec   new classnode
for  int i   0  i < spec length  i
spec correcttogenericsspec ret  sgts
genericstype newgts   current redirect   getgenericstypes
if  newgts  null  return ret
ret clear
for  int i   0  i < spec length  i
ret put newgts getname    spec
return ret