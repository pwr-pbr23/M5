/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive metastore
import java io ioexception
import java net uri
import java util arraylist
import java util iterator
import java util list
import org apache commons lang stringutils
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hive metastore api alreadyexistsexception
import org apache hadoop hive metastore api hive_metastoreconstants
import org apache hadoop hive metastore api fieldschema
import org apache hadoop hive metastore api invalidobjectexception
import org apache hadoop hive metastore api invalidoperationexception
import org apache hadoop hive metastore api metaexception
import org apache hadoop hive metastore api nosuchobjectexception
import org apache hadoop hive metastore api partition
import org apache hadoop hive metastore api table
/**
* hive specific implementation of alter
*/
public class hivealterhandler implements alterhandler
protected configuration hiveconf
private static final log log   logfactory getlog hivealterhandler class
getname
public configuration getconf
return hiveconf
@suppresswarnings
public void setconf configuration conf
hiveconf   conf
public void altertable rawstore msdb  warehouse wh  string dbname
string name  table newt  throws invalidoperationexception  metaexception
if  newt    null
throw new invalidoperationexception     newt
if   metastoreutils validatename newt gettablename
metastoreutils validatecolnames newt getsd   getcols
throw new invalidoperationexception newt gettablename
path srcpath   null
filesystem srcfs   null
path destpath   null
filesystem destfs   null
boolean success   false
string oldtblloc   null
string newtblloc   null
boolean movedata   false
boolean rename   false
table oldt   null
try
msdb opentransaction
name   name tolowercase
dbname   dbname tolowercase
// check if table with the new name already exists
if   newt gettablename   equalsignorecase name
newt getdbname   equalsignorecase dbname
if  msdb gettable newt getdbname    newt gettablename       null
throw new invalidoperationexception     newt getdbname
newt gettablename
rename   true
// get old table
oldt   msdb gettable dbname  name
if  oldt    null
throw new invalidoperationexception     newt getdbname
newt gettablename
//check that partition keys have not changed, except for virtual views
//however, allow the partition comments to change
boolean partkeyspartiallyequal   checkpartialpartkeysequal oldt getpartitionkeys
newt getpartitionkeys
if  oldt gettabletype   equals tabletype virtual_view tostring
if  oldt getpartitionkeys   size      newt getpartitionkeys   size
partkeyspartiallyequal
throw new invalidoperationexception
// if this alter is a rename, the table is not a virtual view, the user
// didn't change the default location (or new location is empty), and
// table is not an external table, that means useris asking metastore to
// move data to the new location corresponding to the new name
if  rename
oldt gettabletype   equals tabletype virtual_view tostring
oldt getsd   getlocation   compareto newt getsd   getlocation       0
stringutils isempty newt getsd   getlocation
metastoreutils isexternaltable oldt
// that means user is asking metastore to move data to new location
// corresponding to the new name
// get new location
newtblloc   wh gettablepath msdb getdatabase newt getdbname     newt gettablename    tostring
newt getsd   setlocation newtblloc
oldtblloc   oldt getsd   getlocation
movedata   true
// check that destination does not exist otherwise we will be
// overwriting data
srcpath   new path oldtblloc
srcfs   wh getfs srcpath
destpath   new path newtblloc
destfs   wh getfs destpath
// check that src and dest are on the same file system
if  srcfs    destfs
throw new invalidoperationexception     destpath
srcpath
try
srcfs exists srcpath      check that src exists and also checks
// permissions necessary
if  destfs exists destpath
throw new invalidoperationexception
newt getdbname         newt gettablename
destpath
catch  ioexception e
warehouse closefs srcfs
warehouse closefs destfs
throw new invalidoperationexception
destpath       newt getdbname
newt gettablename
// also the location field in partition
list<partition> parts   msdb getpartitions dbname  name   1
for  partition part   parts
string oldpartloc   part getsd   getlocation
path oldpartlocpath   new path oldpartloc
string oldtbllocpath   new path oldtblloc  touri   getpath
string newtbllocpath   new path newtblloc  touri   getpath
if  oldpartloc contains oldtbllocpath
path newpartlocpath   null
uri olduri   oldpartlocpath touri
string newpath   olduri getpath   replace oldtbllocpath
newtbllocpath
newpartlocpath   new path olduri getscheme
olduri getauthority
newpath
part getsd   setlocation newpartlocpath tostring
msdb alterpartition dbname  name  part getvalues    part
// now finally call alter table
msdb altertable dbname  name  newt
// commit the changes
success   msdb committransaction
catch  invalidobjectexception e
log debug e
throw new invalidoperationexception
e getmessage
catch  nosuchobjectexception e
log debug e
throw new invalidoperationexception
dbname
e getmessage
finally
if   success
msdb rollbacktransaction
if  success    movedata
// change the file name in hdfs
// check that src exists otherwise there is no need to copy the data
try
if  srcfs exists srcpath
// rename the src to destination
srcfs rename srcpath  destpath
catch  ioexception e
boolean revertmetadatatransaction   false
try
msdb opentransaction
msdb altertable dbname  newt gettablename    oldt
revertmetadatatransaction   msdb committransaction
catch  exception e1
log error    e1
if   revertmetadatatransaction
msdb rollbacktransaction
throw new invalidoperationexception
srcpath       dbname       name
if   success
throw new metaexception
public partition alterpartition final rawstore msdb  warehouse wh  final string dbname
final string name  final list<string> part_vals  final partition new_part
throws invalidoperationexception  invalidobjectexception  alreadyexistsexception
metaexception
boolean success   false
path srcpath   null
path destpath   null
filesystem srcfs   null
filesystem destfs   null
table tbl   null
partition oldpart   null
string oldpartloc   null
string newpartloc   null
// set ddl time to now if not specified
if  new_part getparameters      null
new_part getparameters   get hive_metastoreconstants ddl_time     null
integer parseint new_part getparameters   get hive_metastoreconstants ddl_time      0
new_part puttoparameters hive_metastoreconstants ddl_time  long tostring system
currenttimemillis     1000
//alter partition
if  part_vals    null    part_vals size      0
try
oldpart   msdb getpartition dbname  name  new_part getvalues
msdb alterpartition dbname  name  new_part getvalues    new_part
catch  invalidobjectexception e
throw new invalidoperationexception
catch  nosuchobjectexception e
//old partition does not exist
throw new invalidoperationexception
return oldpart
//rename partition
try
msdb opentransaction
try
oldpart   msdb getpartition dbname  name  part_vals
catch  nosuchobjectexception e
// this means there is no existing partition
throw new invalidobjectexception
partition check_part   null
try
check_part   msdb getpartition dbname  name  new_part getvalues
catch nosuchobjectexception e
// this means there is no existing partition
check_part   null
if  check_part    null
throw new alreadyexistsexception     dbname       name
new_part getvalues
tbl   msdb gettable dbname  name
if  tbl    null
throw new invalidobjectexception
// if the external partition is renamed, the file should not change
if  tbl gettabletype   equals tabletype external_table tostring
new_part getsd   setlocation oldpart getsd   getlocation
msdb alterpartition dbname  name  part_vals  new_part
else
try
destpath   new path wh gettablepath msdb getdatabase dbname   name
warehouse makepartname tbl getpartitionkeys    new_part getvalues
destpath   constructrenamedpartitionpath destpath  new_part
catch  nosuchobjectexception e
log debug e
throw new invalidoperationexception
dbname
e getmessage
if  destpath    null
newpartloc   destpath tostring
oldpartloc   oldpart getsd   getlocation
srcpath   new path oldpartloc
log info     oldpartloc
log info     newpartloc
srcfs   wh getfs srcpath
destfs   wh getfs destpath
// check that src and dest are on the same file system
if  srcfs    destfs
throw new invalidoperationexception     destpath
srcpath
try
srcfs exists srcpath      check that src exists and also checks
if  newpartloc compareto oldpartloc     0    destfs exists destpath
throw new invalidoperationexception
tbl getdbname         tbl gettablename
destpath
catch  ioexception e
warehouse closefs srcfs
warehouse closefs destfs
throw new invalidoperationexception
destpath       tbl getdbname
tbl gettablename         new_part getvalues
new_part getsd   setlocation newpartloc
msdb alterpartition dbname  name  part_vals  new_part
success   msdb committransaction
finally
if   success
msdb rollbacktransaction
if  success    newpartloc    null    newpartloc compareto oldpartloc     0
//rename the data directory
try
if  srcfs exists srcpath
//if destpath's parent path doesn't exist, we should mkdir it
path destparentpath   destpath getparent
if   wh mkdirs destparentpath
throw new ioexception     destparentpath
srcfs rename srcpath  destpath
log info
catch  ioexception e
boolean revertmetadatatransaction   false
try
msdb opentransaction
msdb alterpartition dbname  name  new_part getvalues    oldpart
revertmetadatatransaction   msdb committransaction
catch  exception e1
log error    e1
if   revertmetadatatransaction
msdb rollbacktransaction
throw new invalidoperationexception
srcpath       tbl getdbname
tbl gettablename         part_vals
return oldpart
public list<partition> alterpartitions final rawstore msdb  warehouse wh  final string dbname
final string name  final list<partition> new_parts
throws invalidoperationexception  invalidobjectexception  alreadyexistsexception
metaexception
list<partition> oldparts   new arraylist<partition>
list<list<string>> partvalslist   new arraylist<list<string>>
try
for  partition tmppart  new_parts
// set ddl time to now if not specified
if  tmppart getparameters      null
tmppart getparameters   get hive_metastoreconstants ddl_time     null
integer parseint tmppart getparameters   get hive_metastoreconstants ddl_time      0
tmppart puttoparameters hive_metastoreconstants ddl_time  long tostring system
currenttimemillis     1000
partition oldtmppart   msdb getpartition dbname  name  tmppart getvalues
oldparts add oldtmppart
partvalslist add tmppart getvalues
msdb alterpartitions dbname  name  partvalslist  new_parts
catch  invalidobjectexception e
throw new invalidoperationexception
catch  nosuchobjectexception e
//old partition does not exist
throw new invalidoperationexception
return oldparts
private boolean checkpartialpartkeysequal list<fieldschema> oldpartkeys
list<fieldschema> newpartkeys
//return true if both are null, or false if one is null and the other isn't
if  newpartkeys    null    oldpartkeys    null
return oldpartkeys    newpartkeys
if  oldpartkeys size      newpartkeys size
return false
iterator<fieldschema> oldpartkeysiter   oldpartkeys iterator
iterator<fieldschema> newpartkeysiter   newpartkeys iterator
fieldschema oldfs
fieldschema newfs
while  oldpartkeysiter hasnext
oldfs   oldpartkeysiter next
newfs   newpartkeysiter next
if   oldfs getname   equals newfs getname
oldfs gettype   equals newfs gettype
return false
return true
/**
* uses the scheme and authority of the partition's current location, and the path constructed
* using the partition's new name to construct a path for the partition's new location.
*/
private path constructrenamedpartitionpath path defaultpath  partition part
path oldpath   new path part getsd   getlocation
uri olduri   oldpath touri
return new path olduri getscheme    olduri getauthority    defaultpath touri   getpath