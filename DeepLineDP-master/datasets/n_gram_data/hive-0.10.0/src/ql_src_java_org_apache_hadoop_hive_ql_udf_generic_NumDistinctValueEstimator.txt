/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql udf generic
import java util random
import javolution util fastbitset
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop io text
public class numdistinctvalueestimator
static final log log   logfactory getlog numdistinctvalueestimator class getname
private final int bitvectorsize   32
private int numbitvectors
// refer to flajolet-martin'86 for the value of phi
private final double phi    0 77351
private int a
private int b
private  fastbitset bitvector   new fastbitset
private random avalue
private random bvalue
/* create a new distinctvalueestimator
*/
public numdistinctvalueestimator int numbitvectors
this numbitvectors   numbitvectors
bitvector   new fastbitset
for  int i 0  i< numbitvectors  i
bitvector   new fastbitset bitvectorsize
a   new int
b   new int
avalue   new random 79798
bvalue   new random 34115
for  int i   0  i < numbitvectors  i
int randval
/* a and b shouldn't be even; if a and b are even, then none of the values
* will set bit 0 thus introducing errors in the estimate. both a and b can be even
* 25% of the times and as a result 25% of the bit vectors could be inaccurate. to avoid this
* always pick odd values for a and b.
*/
do
randval   avalue nextint
while  randval % 2    0
a   randval
do
randval   bvalue nextint
while  randval % 2    0
b   randval
if  a < 0
a   a    1 <<  bitvectorsize  1
if  b < 0
b   b    1 <<  bitvectorsize  1
public numdistinctvalueestimator string s  int numbitvectors
fastbitset b   deserialize s  numbitvectors
bitvector   new fastbitset
for int i 0  i <numbitvectors  i
bitvector   new fastbitset bitvectorsize
bitvector clear
bitvector or b
/**
* resets a distinctvalueestimator object to its original state.
*/
public void reset
for  int i 0  i< numbitvectors  i
bitvector clear
public fastbitset getbitvector int index
return bitvector
public int getnumbitvectors
return numbitvectors
public int getbitvectorsize
return bitvectorsize
public void printnumdistinctvalueestimator
string t   new string
log debug
log debug
log debug numbitvectors
log debug
log debug bitvectorsize
for  int i 0  i < numbitvectors  i
t   t   bitvector tostring
log debug
log debug t
/* serializes a distinctvalueestimator object to text for transport.
*
*/
public text serialize
string s   new string
for int i 0  i < numbitvectors  i
s   s    bitvector tostring
return new text s
/* deserializes from string to fastbitset; creates a numdistinctvalueestimator object and
* returns it.
*/
private fastbitset deserialize string s  int numbitvectors
fastbitset b   new fastbitset
for  int j 0  j < numbitvectors  j
b   new fastbitset bitvectorsize
b clear
int vectorindex  0
/* parse input string to obtain the indexes that are set in the bitvector.
* when a tostring() is called on a fastbitset object to serialize it, the serialization
* adds { and } to the beginning and end of the return string.
* skip "{", "}", ",", " " in the input string.
*/
for int i 1  i < s length   1
char c   s charat i
i   i   1
// move on to the next bit vector
if  c
vectorindex   vectorindex   1
// encountered a numeric value; extract out the entire number
if  c >       c <
string t   new string
t   t   c
c   s charat i
i   i   1
while  c         c
t   t   c
c   s charat i
i   i   1
int bitindex   integer parseint t
assert bitindex >  0
assert vectorindex < numbitvectors
b set bitindex
if  c
vectorindex    vectorindex   1
return b
private int generatehash long v  int hashnum
int mod   1 <<  bitvectorsize   1    1
long temphash   a   v   b
temphash %  mod
int hash    int  temphash
/* hash function should map the long value to 0...2^l-1.
* hence hash value has to be non-negative.
*/
if  hash < 0
hash   hash   mod   1
return hash
private int generatehashforpcsa long v
int mod   1 <<  bitvectorsize   1    1
long temphash   a   v   b
temphash %  mod
int hash    int  temphash
/* hash function should map the long value to 0...2^l-1.
* hence hash value has to be non-negative.
*/
if  hash < 0
hash   hash   mod   1
return hash
public void addtoestimator long v
/* update summary bitvector :
* generate hash value of the long value and mod it by 2^bitvectorsize-1.
* in this implementation bitvectorsize is 31.
*/
for  int i   0  i<numbitvectors  i
int hash   generatehash v i
int index
// find the index of the least significant bit that is 1
for  index 0  index<bitvectorsize  index
if  hash % 2    1
break
hash   hash >> 1
// set bitvector[index] := 1
bitvector set index
public void addtoestimatorpcsa long v
int hash   generatehashforpcsa v
int rho   hash numbitvectors
int index
// find the index of the least significant bit that is 1
for  index 0  index<bitvectorsize  index
if  rho % 2    1
break
rho   rho >> 1
// set bitvector[index] := 1
bitvector set index
public void mergeestimators numdistinctvalueestimator o
// bitwise or the bitvector with the bitvector in the agg buffer
for  int i 0  i<numbitvectors  i
bitvector or o getbitvector i
public long estimatenumdistinctvaluespcsa
double numdistinctvalues   0 0
long s   0
for  int i 0  i < numbitvectors  i
int index   0
while  bitvector get index     index < bitvectorsize
index   index   1
s   s   index
numdistinctvalues     numbitvectors phi    math pow 2 0  s numbitvectors
return   long numdistinctvalues
/* we use two estimators - one due to flajolet-martin and a modification due to
* alon-matias-szegedy. fm uses the location of the least significant zero as an estimate of
* log2(phi*ndvs).
* ams uses the location of the most significant one as an estimate of the log2(ndvs).
* we average the two estimators with suitable modifications to obtain an estimate of ndvs.
*/
public long estimatenumdistinctvalues
int sumleastsigzero   0
int summostsigone   0
double avgleastsigzero
double avgmostsigone
double numdistinctvalues
for  int i 0  i< numbitvectors  i
int leastsigzero   bitvector nextclearbit 0
sumleastsigzero    leastsigzero
int mostsigone   bitvectorsize
for  int j 0  j< bitvectorsize  j
if  bitvector get j
mostsigone   j
summostsigone    mostsigone
avgleastsigzero
double  sumleastsigzero  numbitvectors   1 0      math log phi  math log 2 0
avgmostsigone    double  summostsigone  numbitvectors   1 0
numdistinctvalues   math pow 2 0   avgmostsigone   avgleastsigzero  2 0
return   long  numdistinctvalues